
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x00046c5c memsz 0x000605b4 flags rwx
    LOAD off    0x00048000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00048000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0003fd48  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00004ee4  8113ffa4  8113ffa4  00040fa4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  81144e88  81144e88  00045e88  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00019958  81146c7c  81146c7c  00047c7c  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  811605d4  811605d4  00048000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00048000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00048000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d00  00000000  00000000  00048028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000624cc  00000000  00000000  00049d28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00015abc  00000000  00000000  000ac1f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001f2a7  00000000  00000000  000c1cb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  0000836c  00000000  00000000  000e0f58  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000b121  00000000  00000000  000e92c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  000f43e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0011b2b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  0011b2f8  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  0012847d  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  00128483  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0012848f  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00128490  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00128491  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00128495  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00128499  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0012849d  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  001284a8  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  001284b2  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  001284bc  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  001284cd  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00278448  00000000  00000000  0012850c  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8113ffa4 l    d  .rodata	00000000 .rodata
81144e88 l    d  .rwdata	00000000 .rwdata
81146c7c l    d  .bss	00000000 .bss
811605d4 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm.c
00000000 l    df *ABS*	00000000 data_packet.c
00000000 l    df *ABS*	00000000 fee_buffers.c
81146c98 l     O .bss	00000004 viCh1HoldContext
81146c9c l     O .bss	00000004 viCh2HoldContext
81146ca0 l     O .bss	00000004 viCh3HoldContext
81146ca4 l     O .bss	00000004 viCh4HoldContext
81146ca8 l     O .bss	00000004 viCh5HoldContext
81146cac l     O .bss	00000004 viCh6HoldContext
81146cb0 l     O .bss	00000004 viCh7HoldContext
81146cb4 l     O .bss	00000004 viCh8HoldContext
81105148 l     F .text	00000054 vFeebWriteReg
8110519c l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
00000000 l    df *ABS*	00000000 spw_controller.c
8110574c l     F .text	00000050 uliSpwcReadReg
811056f8 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
81146ba4 l     O .rwdata	00000001 ucIoValue
8110594c l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110623c l     F .text	0000013c msgdma_write_extended_descriptor
81106378 l     F .text	00000164 msgdma_construct_extended_descriptor
811064dc l     F .text	00000318 msgdma_descriptor_async_transfer
811067f4 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
81107370 l     F .text	00000054 vRstcWriteReg
811073c4 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
81146cbc l     O .bss	00000004 viHoldContext
811086f8 l     F .text	00000058 uliSyncReadReg
8110869c l     F .text	0000005c bSyncWriteReg
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
81146ccc l     O .bss	00000004 pxNFee.3770
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
81146cd0 l     O .bss	00000004 xRAckLocal.4620
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
81146cd4 l     O .bss	00000004 bDmaBack.3983
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
81146cd8 l     O .bss	00000004 xSAckLocal.4605
00000000 l    df *ABS*	00000000 parser_comm_task.c
81146e40 l     O .bss	0000004c PreParsedLocal.4698
81146e8c l     O .bss	00000054 xTcPusL.4697
00000000 l    df *ABS*	00000000 receiver_uart_task.c
81146ee0 l     O .bss	0000004c xPreParsedReader.4686
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
81146f2c l     O .bss	00000054 xPusLocal.4707
81146f80 l     O .bss	00000054 xPusLocal.4739
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8114290f l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
811442c9 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
81144e88 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
81116ce4 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
81144496 l     O .rodata	00000010 zeroes.4389
811444a6 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
811444b6 l     O .rodata	00000010 zeroes.4404
8111b95c l     F .text	000000c4 __sbprintf
811444c6 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
811444de l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
8111d644 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8111f194 l     F .text	00000008 __fp_unlock
8111f1a8 l     F .text	000001a4 __sinit.part.1
8111f34c l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
811456d4 l     O .rwdata	00000020 lc_ctype_charset
811456b4 l     O .rwdata	00000020 lc_message_charset
811456f4 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
8114451c l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
811221bc l     F .text	0000006c sulp
81144664 l     O .rodata	00000014 fpi.2737
81144678 l     O .rodata	00000028 tinytens
81144650 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
811446b0 l     O .rodata	00000010 blanks.4332
811446a0 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
8112582c l     F .text	00000104 __sprint_r.part.0
811446d0 l     O .rodata	00000010 blanks.4348
811446c0 l     O .rodata	00000010 zeroes.4349
81126dc8 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
8112727c l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
8112b018 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
8112b15c l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
8112b190 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
8112b414 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
8112b50c l       .text	00000000 tx_next_char
8112b534 l       .text	00000000 end_tx
8112b514 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
8112c010 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
8112c28c l     F .text	00000044 alt_get_errno
8112c2d0 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
8112c4f8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
81146bec l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
8112ca98 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
81146bf8 l     O .rwdata	00000004 lockid
81146d88 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
81146bfc l     O .rwdata	00000004 lockid
81146d90 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
8112e524 l     F .text	00000050 OS_InitMisc
8112e574 l     F .text	00000074 OS_InitRdyList
8112e6f8 l     F .text	000000ec OS_InitTCBList
8112e43c l     F .text	000000e8 OS_InitEventList
8112e5e8 l     F .text	00000088 OS_InitTaskIdle
8112e670 l     F .text	00000088 OS_InitTaskStat
8112e988 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
811307a0 l     F .text	000000fc OS_FlagTaskRdy
81130550 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113208c l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
81136908 l     F .text	00000044 OSTmr_Lock
811363a8 l     F .text	00000074 OSTmr_Alloc
8113694c l     F .text	0000003c OSTmr_Unlock
8113680c l     F .text	000000fc OSTmr_Unlink
8113641c l     F .text	000000a4 OSTmr_Free
811366bc l     F .text	00000150 OSTmr_Link
81136634 l     F .text	00000088 OSTmr_InitTask
81136988 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
81136a98 l     F .text	0000003c alt_dev_reg
81145970 l     O .rwdata	0000106c jtag_uart_0
811469dc l     O .rwdata	000000d0 rs232_uart
81146aac l     O .rwdata	00000064 dma_DDR_M1
81146b10 l     O .rwdata	00000064 dma_DDR_M2
81146b74 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
8113b328 l     F .text	000002bc altera_avalon_jtag_uart_irq
8113b5e4 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
8113bde8 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
8113c180 l     F .text	000000a4 altera_avalon_uart_irq
8113c224 l     F .text	00000140 altera_avalon_uart_rxirq
8113c364 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
8113c56c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
8113c820 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
8113caa4 l     F .text	00000044 alt_get_errno
8113cae8 l     F .text	0000009c alt_msgdma_write_standard_descriptor
8113cb84 l     F .text	00000134 alt_msgdma_write_extended_descriptor
8113ccb8 l     F .text	0000018c alt_msgdma_irq
8113ce44 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
8113ced8 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
8113d034 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
8113d374 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
8113da7c l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
8113db28 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8113ecf4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
8113f338 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81146e38 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81146e3c g     O .bss	00000004 alt_instruction_exception_handler
811474fc g     O .bss	00001000 vFeeTask0_stk
81111614 g     F .text	0000004c vFailDeleteInitialization
81146e0c g     O .bss	00000004 aux_status_register
811484fc g     O .bss	00001000 vInAckHandlerTask_stk
8113eab0 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
811078fc g     F .text	0000004c vSyncInitIrq
8110db58 g     F .text	00000284 vCheckRetransmission128
81121840 g     F .text	0000007c _mprec_log10
81107a78 g     F .text	00000040 bSyncSetMbt
81105b30 g     F .text	00000108 I2C_Read
81146c4a g     O .rwdata	00000002 OSTaskNameSize
811494fc g     O .bss	00000260 xBuffer64
81121934 g     F .text	0000008c __any_on
81120308 g     F .text	0000005c _isatty_r
81144528 g     O .rodata	00000028 __mprec_tinytens
8112c130 g     F .text	0000015c alt_main
81116c08 g     F .text	000000c8 _puts_r
811049d4 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
81146d98 g     O .bss	00000004 OSTmrFreeList
811604d4 g     O .bss	00000100 alt_irq
81120478 g     F .text	00000068 _lseek_r
81113964 g     F .text	00000030 vChangeDefaultAutoResetSync
81131000 g     F .text	000000d4 OS_MemInit
81110148 g     F .text	000009d4 vLoadDefaultETHConf
8110961c g     F .text	0000014c bCheckInAck64
8114975c g     O .bss	00000150 xPus
811358e8 g     F .text	00000068 OSTimeSet
8111f54c g     F .text	000000ac __sflags
811124e8 g     F .text	00000068 vCoudlNotCreateNFee2Task
811128d4 g     F .text	0000004c vCouldNotGetMutexMebPus
8112a178 g     F .text	00000088 .hidden __eqdf2
81102aa8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
81113850 g     F .text	00000034 vLoadDefaultSyncSource
81136f98 g     F .text	000001ac Check_for_Master_Boot_Record
8115a690 g     O .bss	00000010 OSTmrWheelTbl
8113d83c g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
811498ac g     O .bss	00000010 xFeeQueueTBL3
8112d188 g     F .text	00000594 OSEventPendMulti
81146ce0 g     O .bss	00000004 xNfeeSchedule
811605d4 g       *ABS*	00000000 __alt_heap_start
8113f970 g     F .text	0000002c OSTaskCreateHook
8113ae10 g     F .text	000001c4 alt_up_sd_card_fclose
81146ce4 g     O .bss	00000004 xSemCountBuffer64
81116a4c g     F .text	00000044 printf
81146cb9 g     O .bss	00000001 SspdConfigControl
81107e94 g     F .text	00000054 bSyncCtrReset
81146c22 g     O .rwdata	00000002 OSMboxEn
81113f38 g     F .text	000000a4 aatoh
8112d780 g     F .text	00000054 OSIntEnter
81127ee8 g     F .text	000000a4 _wcrtomb_r
811048e0 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8111157c g     F .text	0000004c vFailReceiverCreate
81146cc4 g     O .bss	00000004 xQMaskDataCtrl
81104544 g     F .text	00000040 vFeebCh2HandleIrq
81117170 g     F .text	00000064 __sseek
8111f4fc g     F .text	00000010 __sinit
81106cb0 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
8111d2c4 g     F .text	00000148 __swbuf_r
8110e330 g     F .text	00000528 bResourcesInitRTOS
811053bc g     F .text	000000f4 bSpwcGetLinkError
81146c32 g     O .rwdata	00000002 OSQEn
81120394 g     F .text	00000084 _setlocale_r
81146ba8 g     O .rwdata	00000004 LedsPainelControl
81146ffc g     O .bss	00000100 cDebugBuffer
8111f354 g     F .text	00000070 __sfmoreglue
81125814 g     F .text	00000018 ungetc
8112ce44 g     F .text	000000d4 __malloc_unlock
81102d98 g     F .text	00000210 DMA_MULTIPLE_TRANSFER
8113f9f0 g     F .text	00000028 OSTaskStatHook
8110d104 g     F .text	00000088 vSendCmdQToNFeeCTRL
811138c0 g     F .text	00000030 vChangeDefaultSyncSource
81146d9c g     O .bss	00000001 OSLockNesting
81146da0 g     O .bss	00000004 OSTmrSemSignal
81112d4c g     F .text	000000d8 vNFeeStructureInit
81146ce8 g     O .bss	00000004 xSemCommInit
8110292c g     F .text	00000080 uliXorshift32
81122228 g     F .text	00001600 _strtod_r
81146cec g     O .bss	00000004 xSemCountSenderACK
81114074 g     F .text	00000448 .hidden __divsf3
81146e30 g     O .bss	00000004 current_sector_modified
81146c70 g     O .rwdata	00000002 OSDataSize
81146da4 g     O .bss	00000001 OSRunning
81105580 g     F .text	00000178 bSpwcInitCh
8112bdf8 g     F .text	00000064 alt_log_jtag_uart_isr_proc
811498bc g     O .bss	00001000 senderTask_stk
81146cf0 g     O .bss	00000004 fp
8114a8bc g     O .bss	00000030 xNfeeScheduleTBL
811094d4 g     F .text	00000148 bCheckInAck128
81120808 g     F .text	0000015c memmove
8113fa6c g     F .text	0000002c OSInitHookBegin
81108330 g     F .text	00000074 bSyncCtrCh8OutEnable
81146c68 g     O .rwdata	00000002 OSTmrSize
8111f4e4 g     F .text	00000018 _cleanup
81113b70 g     F .text	00000040 siCloseFile
81120964 g     F .text	000000b0 _Balloc
811138f0 g     F .text	00000038 vLoadDefaultAutoResetSync
811399ec g     F .text	000000cc alt_up_sd_card_is_Present
8113d77c g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
81146c84 g     O .bss	00000004 pxDmaM1Dev
81102b40 g     F .text	000000a4 DMA_DISPATCHER_STOP
81136cc0 g     F .text	00000054 Save_Modified_Sector
81104b34 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
81146da8 g     O .bss	00000004 OSIdleCtr
81146d64 g     O .bss	00000001 alt_log_write_on_flag
8110579c g     F .text	0000003c bEnableIsoDrivers
8112a200 g     F .text	000000dc .hidden __gtdf2
8113f700 g     F .text	0000002c altera_nios2_gen2_irq_init
8113f7e8 g       .text	00000000 OSStartTsk
81107bec g     F .text	00000070 bSyncSetNCycles
8112ecf8 g     F .text	000002dc OS_TCBInit
81146d67 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
81113520 g     F .text	00000078 vInitSimucamBasicHW
8114a8ec g     O .bss	00001000 vTimeoutCheckerTask_stk
81108248 g     F .text	00000074 bSyncCtrCh6OutEnable
81105eac g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81146e28 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
81146dac g     O .bss	00000002 OSTmrUsed
81146cf4 g     O .bss	00000004 xSemCountBuffer128
81103270 g     F .text	000000f8 TEMP_Read
8114b8ec g     O .bss	00001000 vDataControlTask_stk
811045c4 g     F .text	00000040 vFeebCh4HandleIrq
81146c6e g     O .rwdata	00000002 OSTmrWheelTblSize
81113214 g     F .text	0000002c cFeeSpwChannelDisable
81146c0e g     O .rwdata	00000002 OSEventSize
81146dae g     O .bss	00000001 OSPrioHighRdy
81115be8 g     F .text	00000064 _fstat_r
8113f99c g     F .text	0000002c OSTaskDelHook
81146d40 g     O .bss	00000004 errno
81108624 g     F .text	0000003c uliSyncGetCtr
8111d254 g     F .text	0000001c __svfscanf
811170e4 g     F .text	00000008 __seofread
8113f7c8 g       .text	00000000 OSStartHighRdy
81112c1c g     F .text	00000070 vEvtChangeFeeControllerMode
8110881c g     F .text	00000968 vPrintConsoleNFee
8110a560 g     F .text	000000cc bSendCmdQToNFeeInst
81134318 g     F .text	000001ec OSTaskCreateExt
8115a664 g     O .bss	00000011 alt_log_write_buf
81111938 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
81124358 g     F .text	00001244 ___svfiprintf_internal_r
8110c048 g     F .text	00000364 bPreParserV2
81130080 g     F .text	00000068 OSFlagPendGetFlagsRdy
81146c4e g     O .rwdata	00000002 OSTaskStatStkSize
8112f1cc g     F .text	00000310 OSFlagAccept
811327a8 g     F .text	000000c0 OSQFlush
81132224 g     F .text	00000148 OSQAccept
81146d78 g     O .bss	00000004 alt_argv
8114eba0 g       *ABS*	00000000 _gp
81111244 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
8112c95c g     F .text	0000013c usleep
81139fc4 g     F .text	00000384 alt_up_sd_card_fopen
811139dc g     F .text	00000030 bSDcardIsPresent
8110c3ac g     F .text	00000178 vSenderComTask
81139b2c g     F .text	000000d8 alt_up_sd_card_find_first
81111ad8 g     F .text	00000068 vFailSendNack
81146e1c g     O .bss	00000004 command_argument_register
81133e20 g     F .text	000004f8 OSTaskChangePrio
8110c6b8 g     F .text	000004fc vPusMebInTaskConfigMode
81112250 g     F .text	00000088 vCouldNotSendTMPusCommand
81146d94 g     O .bss	00000004 alt_heapsem
81106144 g     F .text	00000080 bSetBoardLeds
8112efd4 g     F .text	000001f8 OSDebugInit
81134504 g     F .text	0000034c OSTaskDel
811310d4 g     F .text	000001ac OSMutexAccept
8114c8ec g     O .bss	000004bc xSimMeb
81113404 g     F .text	00000040 vSetTimeCode
8113e324 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
81146cf8 g     O .bss	00000004 xSemCountPreParsed
81145754 g     O .rwdata	00000180 alt_fd_list
81104a84 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
811458f0 g     O .rwdata	0000001d alt_log_msg_alt_main
8115a6a0 g     O .bss	00000580 OSFlagTbl
811113ac g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
811137a8 g     F .text	0000003c vLoadDefaultRTValue
8112e204 g     F .text	000000c0 OS_EventTaskRemove
8114cda8 g     O .bss	00001000 vFeeTask5_stk
81146d66 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
81139240 g     F .text	00000134 find_first_empty_record_in_root_directory
8113ede4 g     F .text	00000098 alt_find_dev
81116734 g     F .text	00000150 memcpy
81127bb4 g     F .text	00000264 __hexnan
8114dda8 g     O .bss	00000160 xBuffer32
81146c38 g     O .rwdata	00000002 OSRdyTblSize
8115ac20 g     O .bss	000001a0 OSTmrTbl
8111f19c g     F .text	0000000c _cleanup_r
8112ad54 g     F .text	000000e4 .hidden __floatsidf
8110fd70 g     F .text	000001a8 vSendPusTM64
811079e8 g     F .text	0000004c ucSyncStatusErrorCode
81113310 g     F .text	00000034 cFeeRMAPLogDisable
8110a924 g     F .text	00000e00 vParserCommTask
8113f404 g     F .text	00000084 alt_io_redirect
811132a4 g     F .text	00000034 cFeeRMAPEchoingDisable
8112a2dc g     F .text	000000f4 .hidden __ltdf2
81112820 g     F .text	0000004c vFailSendPUStoMebTask
81104d64 g     F .text	000000d4 bFeebSetIrqControl
81112048 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
81146cfc g     O .bss	00000004 xMutexReceivedACK
81103bec g     F .text	000000b0 bSdmaInitM2Dma
8113e7ac g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
8113eaf4 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
81107f3c g     F .text	00000054 bSyncCtrErrInj
8113ea54 g     F .text	0000005c alt_msgdma_register_callback
81110b1c g     F .text	00000330 vShowEthConfig
81113598 g     F .text	00000030 bLogWriteSDCard
811116c8 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
81116cd0 g     F .text	00000014 puts
8113fb14 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
811078bc g     F .text	00000040 vSyncHandleIrq
8112cf18 g     F .text	00000128 OSEventNameGet
81104748 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
81146c1c g     O .rwdata	00000002 OSFlagMax
81120594 g     F .text	000000e0 mbrtowc
81138e38 g     F .text	000001b4 find_first_empty_cluster
811081d4 g     F .text	00000074 bSyncCtrCh5OutEnable
81146cc0 g     O .bss	00000001 vucN
81121f94 g     F .text	00000074 __fpclassifyd
81107948 g     F .text	00000054 bSyncStatusExtnIrq
8111d270 g     F .text	00000054 _vfscanf_r
81131754 g     F .text	000005a4 OSMutexPend
81121794 g     F .text	000000ac __ratio
81139928 g     F .text	000000c4 alt_up_sd_card_open_dev
811122d8 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
8112d7d4 g     F .text	00000100 OSIntExit
81107ab8 g     F .text	00000040 bSyncSetBt
81126dac g     F .text	0000001c __vfiprintf_internal
81112920 g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
81146c56 g     O .rwdata	00000002 OSTCBSize
81104704 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
81146daf g     O .bss	00000001 OSPrioCur
8113b858 g     F .text	000002c4 altera_avalon_jtag_uart_read
8113dfec g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
81116a14 g     F .text	00000038 _printf_r
81128d1c g     F .text	00000064 .hidden __udivsi3
8112b458 g     F .text	000000ac isatty
81146cb8 g     O .bss	00000001 LedsBoardControl
81146d00 g     O .bss	00000004 xSemCountReceivedACK
81146c3c g     O .rwdata	00000002 OSStkWidth
81120364 g     F .text	00000030 iswspace
81144578 g     O .rodata	000000c8 __mprec_tens
81146c30 g     O .rwdata	00000002 OSPtrSize
81112688 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
81120418 g     F .text	0000000c __locale_charset
811080ec g     F .text	00000074 bSyncCtrCh3OutEnable
81128f0c g     F .text	000000c8 .hidden __lesf2
81146c10 g     O .rwdata	00000002 OSEventTblSize
811280e8 g     F .text	0000007c .hidden __fixunsdfsi
8113f72c g       .text	00000000 OSCtxSw
81105c38 g     F .text	00000160 I2C_MultipleRead
8112bf9c g     F .text	00000074 alt_log_system_clock
81146d4c g     O .bss	00000004 __malloc_top_pad
81146db0 g     O .bss	00000004 OSTCBList
81136368 g     F .text	00000040 OSTmrSignal
81146d5c g     O .bss	00000004 alt_fd_list_lock
81123e84 g     F .text	0000001c strtoul
81146bc0 g     O .rwdata	00000004 __mb_cur_max
81120448 g     F .text	0000000c _localeconv_r
81123ea0 g     F .text	000002e0 _strtoull_r
81107300 g     F .text	00000070 vRstcHoldDeviceReset
81120d88 g     F .text	00000044 __i2b
8111fcac g     F .text	000004c4 __sfvwrite_r
81138118 g     F .text	000000c0 get_dir_divider_location
8115adc0 g     O .bss	00000c30 OSMemTbl
81146db4 g     O .bss	00000001 OSTickStepState
8112bbac g     F .text	00000060 alt_log_printf_proc
8114df08 g     O .bss	00001800 vReceiverUartTask_stk
81116edc g     F .text	0000005c _sbrk_r
81146d04 g     O .bss	00000004 xSemTimeoutChecker
81137dd8 g     F .text	000000cc filename_to_upper_case
81146d68 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
81146c34 g     O .rwdata	00000002 OSQMax
8113a348 g     F .text	00000090 alt_up_sd_card_set_attributes
81131450 g     F .text	00000304 OSMutexDel
8115b9f0 g     O .bss	00001000 OSTaskStatStk
81113a0c g     F .text	00000030 bSDcardFAT16Check
81130c1c g     F .text	000000f8 OSMemNameGet
81111098 g     F .text	00000060 vFailCreateMutexSResources
81137144 g     F .text	00000284 Read_File_Record_At_Offset
8114f708 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
81146c14 g     O .rwdata	00000002 OSFlagEn
811219c0 g     F .text	00000068 _read_r
81146c5a g     O .rwdata	00000002 OSTimeTickHookEn
8113089c g     F .text	000000ac OS_FlagUnlink
81132c70 g     F .text	00000170 OSQPost
81102490 g     F .text	0000049c bDdr2MemoryRandomReadTest
81146bdc g     O .rwdata	00000004 alt_max_fd
81111df4 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
8112e840 g     F .text	00000070 OS_MemCopy
8112e8b0 g     F .text	000000d8 OS_Sched
811389bc g     F .text	0000047c find_file_in_directory
81126f58 g     F .text	000000f8 _fclose_r
81130b24 g     F .text	000000f8 OSMemGet
81134b48 g     F .text	000001bc OSTaskNameSet
8111f164 g     F .text	00000030 fflush
81146d48 g     O .bss	00000004 __malloc_max_sbrked_mem
81146db8 g     O .bss	00000004 OSCtxSwCtr
8113fa18 g     F .text	00000054 OSTimeTickHook
8114f748 g     O .bss	00001000 vOutAckHandlerTask_stk
8112b28c g     F .text	00000188 alt_irq_register
81146c1e g     O .rwdata	00000002 OSFlagNameSize
81115204 g     F .text	00000118 .hidden __extendsfdf2
8112e2c4 g     F .text	00000108 OS_EventTaskRemoveMulti
81139ab8 g     F .text	00000074 alt_up_sd_card_is_FAT16
811059c8 g     F .text	00000088 I2C_TestAdress
81128fd4 g     F .text	000008b4 .hidden __adddf3
8115a678 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
81128dd8 g     F .text	00000078 .hidden __nesf2
8112e0ac g     F .text	00000158 OS_EventTaskWaitMulti
8112152c g     F .text	00000114 __b2d
8113dd24 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
81146c36 g     O .rwdata	00000002 OSQSize
811286e4 g     F .text	00000540 .hidden __umoddi3
8112c054 g     F .text	000000dc lseek
81133760 g     F .text	00000214 OSSemPend
8111286c g     F .text	00000068 vCouldNotGetCmdQueueMeb
811054b0 g     F .text	000000d0 bSpwcGetLinkStatus
81105014 g     F .text	00000088 bFeebGetWindowing
81146bb0 g     O .rwdata	00000004 _global_impure_ptr
81107870 g     F .text	0000004c bSSDisplayUpdate
8113847c g     F .text	00000540 get_home_directory_cluster_for_file
81121a28 g     F .text	0000056c _realloc_r
81146c20 g     O .rwdata	00000002 OSLowestPrio
811605d4 g       *ABS*	00000000 __bss_end
8113f240 g     F .text	000000f8 alt_iic_isr_register
8113fae8 g     F .text	0000002c OSTCBInitHook
81146c66 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
8112c84c g     F .text	00000110 alt_tick
81111344 g     F .text	00000068 vFailGetMutexSenderTask
81107220 g     F .text	0000006c vRstcSimucamReset
811446e0 g     O .rodata	00000100 __hexdig
8113e8a0 g     F .text	000001b4 alt_msgdma_init
81128164 g     F .text	00000580 .hidden __udivdi3
8110bd30 g     F .text	0000017c setPreAckSenderFreePos
811271d0 g     F .text	00000024 _fputwc_r
81146c08 g     O .rwdata	00000002 OSEventEn
81144550 g     O .rodata	00000028 __mprec_bigtens
81120b64 g     F .text	0000010c __s2b
81146c62 g     O .rwdata	00000002 OSTmrCfgNameSize
81150748 g     O .bss	00000010 xFeeQueueTBL4
81107b78 g     F .text	00000074 bSyncSetPolarity
8110dddc g     F .text	0000028c vCheckRetransmission64
8112ae38 g     F .text	000000b0 .hidden __floatunsidf
81146d6c g     O .bss	00000004 alt_system_clock_in_sec
8112bda4 g     F .text	00000054 alt_log_jtag_uart_startup_info
811118d0 g     F .text	00000068 vFailFoundBufferRetransmission
81121264 g     F .text	00000060 __mcmp
81146e34 g     O .bss	00000004 current_sector_index
8113c018 g     F .text	00000168 altera_avalon_uart_init
8113eb7c g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
811040cc g     F .text	00000438 bSdmaDmaM2Transfer
81113444 g     F .text	00000034 vResetTimeCode
811131e8 g     F .text	0000002c cFeeSpwChannelEnable
8111f51c g     F .text	00000018 __fp_lock_all
8113f1ec g     F .text	00000054 alt_ic_irq_enabled
81105a50 g     F .text	000000e0 I2C_Write
81146dbc g     O .bss	00000002 OSTmrFree
811306b8 g     F .text	000000e8 OS_FlagInit
8112c7a8 g     F .text	000000a4 alt_alarm_stop
81117544 g     F .text	0000001c strtol
81146d65 g     O .bss	00000001 alt_log_sys_clk_on_flag
81135b14 g     F .text	00000140 OSTmrDel
81136eb0 g     F .text	000000e8 mark_cluster
81146c44 g     O .rwdata	00000002 OSTaskIdleStkSize
81146d60 g     O .bss	00000004 alt_irq_active
81133380 g     F .text	000000b8 OSSemAccept
81115780 g     F .text	0000044c _fseeko_r
811172c0 g     F .text	00000044 strnlen
81130e30 g     F .text	000000e0 OSMemPut
81130948 g     F .text	000001dc OSMemCreate
81146dc0 g     O .bss	00000004 OSIdleCtrMax
8110ff18 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
8112b5f4 g     F .text	000005b8 alt_log_private_printf
8114572c g     O .rwdata	00000028 alt_dev_null
8113d934 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
81107b38 g     F .text	00000040 bSyncSetOst
81146c58 g     O .rwdata	00000002 OSTicksPerSec
811458d4 g     O .rwdata	00000019 alt_log_msg_bss
81139374 g     F .text	00000194 convert_filename_to_name_extension
8110c524 g     F .text	00000194 vSimMebTask
81105d98 g     F .text	00000094 i2c_start
8113f72c g       .text	00000000 OSIntCtxSw
81108160 g     F .text	00000074 bSyncCtrCh4OutEnable
8113e718 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
8112b134 g     F .text	00000028 alt_dcache_flush_all
81120c70 g     F .text	00000068 __hi0bits
811137e4 g     F .text	0000003c vChangeRTValue
81146e08 g     O .bss	00000004 is_sd_card_formated_as_FAT16
8110d9d4 g     F .text	00000184 vCheck
81112cfc g     F .text	00000050 vNFeeNotInUse
8112acd4 g     F .text	00000080 .hidden __fixdfsi
8110a0a4 g     F .text	00000234 vNFeeControlTask
81150758 g     O .bss	00001000 vInitialTask_stk
81146d08 g     O .bss	00000002 usiIdCMD
81107e40 g     F .text	00000054 bSyncCtrStart
81138fec g     F .text	00000254 find_first_empty_record_in_a_subdirectory
81123828 g     F .text	00000018 strtod
81146dc4 g     O .bss	00000004 OSTCBFreeList
81133974 g     F .text	00000174 OSSemPendAbort
811114e4 g     F .text	0000004c vFailGetMacRTC
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
81111d5c g     F .text	0000004c vFailCreateTimerRetransmisison
81111868 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
8110ede0 g     F .text	000002f0 bSendUART128v2
81113660 g     F .text	000000a4 vSimucamStructureInit
81146bd4 g     O .rwdata	00000008 alt_dev_list
811156b0 g     F .text	0000004c _fputc_r
8112cadc g     F .text	0000010c write
81116a90 g     F .text	000000a8 _putc_r
81146e2c g     O .bss	00000004 device_pointer
81146c5c g     O .rwdata	00000002 OSVersionNbr
81128e50 g     F .text	000000bc .hidden __gtsf2
8110b724 g     F .text	00000118 getPreParsedPacket
8112b1d4 g     F .text	000000b8 fstat
811134ac g     F .text	00000040 vChangeIdNFEEMaster
81115684 g     F .text	0000002c fprintf
811132d8 g     F .text	00000038 cFeeRMAPLogEnable
81102c88 g     F .text	00000110 DMA_SINGLE_TRANSFER
81104adc g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
81111ea8 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
81113c18 g     F .text	00000058 _reg_write
811134ec g     F .text	00000034 vChangeDefaultIdNFEEMaster
8112a2dc g     F .text	000000f4 .hidden __ledf2
81151758 g     O .bss	00001000 vStackMonitor_stk
811121e8 g     F .text	00000068 vCouldNotSendLog
81135d94 g     F .text	000001b8 OSTmrRemainGet
81146c04 g     O .rwdata	00000004 OSEndiannessTest
81107414 g     F .text	00000058 v_spi_start
81120fcc g     F .text	00000148 __pow5mult
81125948 g     F .text	00001464 ___vfiprintf_internal_r
81146d58 g     O .bss	00000004 __nlocale_changed
81128d80 g     F .text	00000058 .hidden __umodsi3
81107f90 g     F .text	00000074 bSyncCtrSyncOutEnable
81113a3c g     F .text	000000f8 bInitializeSDCard
81111c78 g     F .text	0000004c vFailParserCommTaskCreate
81112180 g     F .text	00000068 vCouldNotSendReset
81116f7c g     F .text	00000038 _scanf_r
81111d10 g     F .text	0000004c vFailOutAckHandlerTaskCreate
81146c16 g     O .rwdata	00000002 OSFlagGrpSize
81152758 g     O .bss	00000058 xInUseRetrans
8113dd84 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
81135f4c g     F .text	000000ec OSTmrStateGet
811605d4 g       *ABS*	00000000 end
81104644 g     F .text	00000040 vFeebCh6HandleIrq
81111a08 g     F .text	00000068 vNoContentInPreParsedBuffer
81115bcc g     F .text	0000001c fseeko
8110b83c g     F .text	00000168 bSendMessagePUStoMebTask
811123a8 g     F .text	00000070 vFailCreateNFEEQueue
81115534 g     F .text	0000000c _atoi_r
8113c864 g     F .text	00000240 altera_avalon_uart_write
8112b538 g     F .text	00000054 alt_log_txchar
81115764 g     F .text	0000001c fseek
8110ed50 g     F .text	00000090 vCCDChangeValues
8113b158 g     F .text	000001d0 altera_avalon_jtag_uart_init
8112eb40 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
81111144 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
81102020 g     F .text	00000470 bDdr2MemoryRandomWriteTest
8113be6c g     F .text	00000084 alt_avalon_timer_sc_init
81104f6c g     F .text	000000a8 bFeebSetWindowing
8113bf58 g     F .text	00000068 altera_avalon_uart_write_fd
811154c4 g     F .text	00000064 .hidden __clzsi2
8113bfc0 g     F .text	00000058 altera_avalon_uart_close_fd
811527b0 g     O .bss	00000020 xMebQTBL
8113bb1c g     F .text	000002cc altera_avalon_jtag_uart_write
811364c0 g     F .text	00000174 OSTmr_Init
811527d0 g     O .bss	00000348 xBuffer128
8111f50c g     F .text	00000004 __sfp_lock_acquire
81103368 g     F .text	00000048 sense_log_temp
81120724 g     F .text	000000e4 memchr
8112e7e4 g     F .text	0000005c OS_MemClr
81119740 g     F .text	00002200 ___vfprintf_internal_r
8113f80c g     F .text	00000164 OSTaskStkInit
81116fb4 g     F .text	00000060 _sprintf_r
81146d0a g     O .bss	00000001 SemCount32
8111f994 g     F .text	00000318 _free_r
8113f488 g     F .text	00000234 alt_printf
8110fd20 g     F .text	00000050 vTimeoutCheck
81113cc8 g     F .text	000001fc _print_codec_status
81120424 g     F .text	00000010 __locale_mb_cur_max
8112ddf4 g     F .text	000001a0 OS_EventTaskRdy
81102be4 g     F .text	000000a4 DMA_DISPATCHER_RESET
8113fd60 g     F .text	00000188 __call_exitprocs
8110a424 g     F .text	0000013c vPerformActionNFCRunning
81146dc8 g     O .bss	00000001 OSCPUUsage
811125b8 g     F .text	00000068 vCoudlNotCreateNFee4Task
81146d54 g     O .bss	00000004 __mlocale_changed
8110a2d8 g     F .text	0000014c vPerformActionNFCConfig
81107ee8 g     F .text	00000054 bSyncCtrOneShot
81146bb8 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
81108660 g     F .text	0000003c uliSyncReadStatus
81146d80 g     O .bss	00000004 _alt_tick_rate
81132868 g     F .text	00000294 OSQPend
81123948 g     F .text	000002e8 _strtoll_r
81152b18 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
81135438 g     F .text	0000010c OSTimeDly
8110cbb4 g     F .text	00000550 vPusMebInTaskRunningMode
81121114 g     F .text	00000150 __lshift
8110a62c g     F .text	000002f8 vOutAckHandlerTask
8113d7dc g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
81146d84 g     O .bss	00000004 _alt_nticks
8112c53c g     F .text	00000104 read
81136b14 g     F .text	000000f0 alt_sys_init
811148c0 g     F .text	0000012c .hidden __floatsisf
81124180 g     F .text	000001d8 __ssprint_r
811169ac g     F .text	00000068 _open_r
81113bf0 g     F .text	00000028 bTestSimucamCriticalHW
8110509c g     F .text	000000ac bFeebGetBuffersStatus
81110e4c g     F .text	000000a4 ucCrc8
8110081c g     F .text	00000cb4 bDdr2EepromDump
81146dc9 g     O .bss	00000001 OSTaskCtr
8112b504 g       .text	00000000 tx_log_str
8110fcd0 g     F .text	00000050 siPosStr
81127e18 g     F .text	000000d0 strncmp
81135544 g     F .text	00000164 OSTimeDlyHMSM
81120dcc g     F .text	00000200 __multiply
8113b6f0 g     F .text	00000070 altera_avalon_jtag_uart_close
811075e4 g     F .text	00000058 v_spi_end
81113bb0 g     F .text	00000040 cGetNextChar
8113fc74 g     F .text	000000ec strncpy
81146fd4 g     O .bss	00000028 __malloc_current_mallinfo
81146c0a g     O .rwdata	00000002 OSEventMax
81128dd8 g     F .text	00000078 .hidden __eqsf2
81121640 g     F .text	00000154 __d2b
81133ae8 g     F .text	00000118 OSSemPost
811047d0 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
81113820 g     F .text	00000030 vChangeDefaultRTValue
811046c4 g     F .text	00000040 vFeebCh8HandleIrq
81146e04 g     O .bss	00000004 initialized
8110fb80 g     F .text	00000100 vSendLog
8112d968 g     F .text	000000e4 OSSchedUnlock
8110763c g     F .text	00000164 RTCC_SPI_R_MAC
81146be8 g     O .rwdata	00000004 alt_log_boot_on_flag
8113afd4 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
81123c30 g     F .text	00000254 _strtoul_r
81152b58 g     O .bss	00000010 xFeeQueueTBL5
8113ef8c g     F .text	000000e4 alt_get_fd
81146dcc g     O .bss	00000004 OSMemFreeList
8112dac4 g     F .text	000000b8 OSStatInit
811029ac g     F .text	00000064 DMA_OPEN_DEVICE
8115ff6c g     O .bss	00000014 search_data
811051ec g     F .text	00000100 bSpwcSetLink
8112aee8 g     F .text	00000130 alt_busy_sleep
81130484 g     F .text	000000cc OSFlagQuery
81108004 g     F .text	00000074 bSyncCtrCh1OutEnable
81146c40 g     O .rwdata	00000002 OSTaskCreateExtEn
81113ec4 g     F .text	00000074 _split_codec_status
8111d5e8 g     F .text	0000005c _close_r
81111a70 g     F .text	00000068 vCouldNotSendEthConfUART
811098b4 g     F .text	000007f0 vInitialTask
8112bcac g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
8113dcc4 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
8113fbf8 g     F .text	0000007c memcmp
8112ddcc g     F .text	00000028 OS_Dummy
8113b0a4 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
811605d4 g       *ABS*	00000000 __alt_stack_base
8113b0fc g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81104814 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
81115c4c g     F .text	000000d4 _fwrite_r
8113dde4 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81104924 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
8111d48c g     F .text	0000015c __swsetup_r
8115c9f0 g     O .bss	00000180 OSQTbl
811129f0 g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
8115a648 g     O .bss	0000001c xConfEth
81129888 g     F .text	000008f0 .hidden __divdf3
81113884 g     F .text	0000003c vChangeSyncSource
8111f3c4 g     F .text	00000120 __sfp
8115ff80 g     O .bss	00000054 boot_sector_data
81112988 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
81102af4 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
811218bc g     F .text	00000078 __copybits
811452ac g     O .rwdata	00000408 __malloc_av_
8111f518 g     F .text	00000004 __sinit_lock_release
81146c7c g     O .bss	00000004 uliInitialState
81105e2c g     F .text	00000080 i2c_stop
81113fdc g     F .text	00000064 Verif_Error
81114040 g     F .text	00000034 toInt
81111290 g     F .text	0000004c vFailSendPreAckSenderSemaphore
81146dd0 g     O .bss	00000004 OSTCBHighRdy
81114ae4 g     F .text	00000720 .hidden __muldf3
81117088 g     F .text	0000005c __sread
8111f82c g     F .text	0000003c fread
81146dd4 g     O .bss	00000004 OSQFreeList
8113ee7c g     F .text	00000110 alt_find_file
8113ed38 g     F .text	000000ac alt_dev_llist_insert
8112cd1c g     F .text	00000128 __malloc_lock
81115654 g     F .text	00000030 _fprintf_r
8112c6ac g     F .text	000000fc sbrk
81113164 g     F .text	0000002c vFeeSpwRMAPLoadDefault
81111800 g     F .text	00000068 vFailGetCountSemaphorexBuffer64
81117560 g     F .text	000021e0 ___svfprintf_internal_r
811100c0 g     F .text	00000088 vTMPusTestConnection
81146d0c g     O .bss	00000004 xMebQ
8112d040 g     F .text	00000148 OSEventNameSet
8111f100 g     F .text	00000064 _fflush_r
81126e8c g     F .text	000000cc _calloc_r
81146dd8 g     O .bss	00000001 OSRdyGrp
81112b14 g     F .text	0000004c vFailSendMsgFeeCTRL
81107a34 g     F .text	00000044 ucSyncStatusCycleNumber
81136038 g     F .text	00000148 OSTmrStart
81104604 g     F .text	00000040 vFeebCh5HandleIrq
8111563c g     F .text	00000018 fopen
81102a10 g     F .text	0000004c DMA_CONFIG
81146c7c g       *ABS*	00000000 __bss_start
81116884 g     F .text	00000128 memset
8110bbf4 g     F .text	0000013c setPreParsedFreePos
8113e840 g     F .text	00000060 alt_msgdma_open
8110eb6c g     F .text	0000017c main
81111414 g     F .text	00000068 vFailGetMutexReceiverTask
81152b68 g     O .bss	00001000 vNFeeControlTask_stk
8111373c g     F .text	0000003c vChangeEPValue
81146d7c g     O .bss	00000004 alt_envp
81112b60 g     F .text	0000004c vFailFlushQueue
81146d44 g     O .bss	00000004 __malloc_max_total_mem
8113e0e4 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
81110ef0 g     F .text	0000005c ucCrc8wInit
81111da8 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
8113b03c g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102fa8 g     F .text	000002c8 POWER_Read
81105fe4 g     F .text	00000160 i2c_read
8111d40c g     F .text	00000018 __swbuf
811449e0 g     O .rodata	00000100 OSUnMapTbl
81128f0c g     F .text	000000c8 .hidden __ltsf2
8113a3d8 g     F .text	00000090 alt_up_sd_card_get_attributes
8111f5f8 g     F .text	00000234 _fread_r
811112dc g     F .text	00000068 vFailGetCountSemaphoreSenderTask
811057d8 g     F .text	0000003c bDisableIsoDrivers
81146c3a g     O .rwdata	00000002 OSSemEn
81136c04 g     F .text	000000bc Write_Sector_Data
8113a7e8 g     F .text	00000628 alt_up_sd_card_write
81153b68 g     O .bss	00000018 xFeeQ
811300e8 g     F .text	0000039c OSFlagPost
811171d4 g     F .text	00000008 __sclose
811120b0 g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
81127050 g     F .text	00000014 fclose
8112df94 g     F .text	00000118 OS_EventTaskWait
81111f78 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
81117304 g     F .text	00000240 _strtol_r
8111531c g     F .text	000001a8 .hidden __truncdfsf2
81153b80 g     O .bss	00000010 xFeeQueueTBL2
8112ec24 g     F .text	000000d4 OS_TaskStatStkChk
81134850 g     F .text	00000158 OSTaskDelReq
8111d84c g     F .text	00001690 _dtoa_r
8113e400 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
81115f20 g     F .text	00000814 _malloc_r
81128054 g     F .text	00000030 __ascii_wctomb
81131280 g     F .text	000001d0 OSMutexCreate
81111f10 g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
81109768 g     F .text	0000014c bCheckInAck32
81146be0 g     O .rwdata	00000004 alt_errno
8113df2c g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
8112da4c g     F .text	00000078 OSStart
811052ec g     F .text	000000d0 bSpwcGetLink
81106d38 g     F .text	000004e8 POWER_SPI_RW
8112559c g     F .text	000000dc __submore
8112bc0c g     F .text	000000a0 altera_avalon_jtag_uart_report_log
8112ccb4 g     F .text	00000068 __env_unlock
81112480 g     F .text	00000068 vCoudlNotCreateNFee1Task
81120170 g     F .text	000000cc _fwalk
81134d04 g     F .text	000001dc OSTaskResume
81130f10 g     F .text	000000f0 OSMemQuery
81146c4c g     O .rwdata	00000002 OSTaskStatEn
811605d4 g       *ABS*	00000000 __alt_stack_limit
81146c94 g     O .bss	00000004 ECommSpwCh
81113928 g     F .text	0000003c vChangeAutoResetSync
811206c0 g     F .text	00000064 _mbtowc_r
81109184 g     F .text	00000350 vInAckHandlerTaskV2
81146c26 g     O .rwdata	00000002 OSMemMax
81132de0 g     F .text	00000178 OSQPostFront
81116b38 g     F .text	000000d0 putc
81128c24 g     F .text	00000084 .hidden __divsi3
81146dd9 g     O .bss	00000006 OSRdyTbl
81146c00 g     O .rwdata	00000002 OSDebugEn
81145944 g     O .rwdata	0000002a alt_log_msg_cache
8111f868 g     F .text	0000012c _malloc_trim_r
81146d38 g     O .bss	00000008 xSdHandle
811144bc g     F .text	00000404 .hidden __mulsf3
81146c18 g     O .rwdata	00000002 OSFlagNodeSize
81146c80 g     O .bss	00000004 pnt_memory
81113994 g     F .text	00000048 vSyncReset
81107af8 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000514 bDdr2EepromTest
81146e10 g     O .bss	00000004 status_register
81146c60 g     O .rwdata	00000002 OSTmrCfgMax
8110848c g     F .text	00000074 bSyncIrqFlagClrError
81111b40 g     F .text	00000068 vFailSetPreAckSenderBuffer
811220e0 g     F .text	000000dc strcmp
81146e18 g     O .bss	00000004 command_register
8113236c g     F .text	000001b4 OSQCreate
811349a8 g     F .text	000001a0 OSTaskNameGet
81153b90 g     O .bss	00001000 vFeeTask4_stk
81154b90 g     O .bss	00000018 xReceivedACK
81132f58 g     F .text	00000214 OSQPostOpt
8112db7c g     F .text	00000228 OSTimeTick
81146c48 g     O .rwdata	00000002 OSTaskMax
81133438 g     F .text	000000e0 OSSemCreate
81146c6c g     O .rwdata	00000002 OSTmrWheelSize
81112340 g     F .text	00000068 vFailCreateScheduleQueue
81113c70 g     F .text	00000058 _reg_read
81131f18 g     F .text	00000174 OSMutexQuery
8112a178 g     F .text	00000088 .hidden __nedf2
81146c42 g     O .rwdata	00000002 OSTaskDelEn
81113704 g     F .text	00000038 vLoadDefaultEPValue
81154ba8 g     O .bss	00001000 vFeeTask1_stk
811082bc g     F .text	00000074 bSyncCtrCh7OutEnable
81133c00 g     F .text	00000118 OSSemQuery
81132520 g     F .text	00000288 OSQDel
81132afc g     F .text	00000174 OSQPendAbort
81146d10 g     O .bss	00000004 xMutexPreParsed
81136ad4 g     F .text	00000040 alt_irq_init
8112c640 g     F .text	0000006c alt_release_fd
81136df4 g     F .text	000000bc get_cluster_flag
81108500 g     F .text	00000074 bSyncIrqFlagClrBlank
8113eb38 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
81145910 g     O .rwdata	00000031 alt_log_msg_stackpointer
81117014 g     F .text	00000074 sprintf
811440c8 g     O .rodata	00000100 .hidden __clz_tab
811373c8 g     F .text	00000294 Write_File_Record_At_Offset
81101590 g     F .text	00000580 bDdr2MemoryWriteTest
8111147c g     F .text	00000068 vFailGetMutexTxUARTSenderTask
81146d50 g     O .bss	00000004 _PathLocale
811085cc g     F .text	00000058 bSyncIrqFlagBlank
81106bf0 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
81136180 g     F .text	000001e8 OSTmrStop
8110fc80 g     F .text	00000050 usiGetIdCMD
81123840 g     F .text	00000108 strtof
81104584 g     F .text	00000040 vFeebCh3HandleIrq
81128e50 g     F .text	000000bc .hidden __gesf2
811171dc g     F .text	0000004c strcspn
8111d424 g     F .text	00000068 _write_r
8110728c g     F .text	00000074 vRstcReleaseDeviceReset
81111cc4 g     F .text	0000004c vFailInAckHandlerTaskCreate
8112d8d4 g     F .text	00000094 OSSchedLock
81112550 g     F .text	00000068 vCoudlNotCreateNFee3Task
81120454 g     F .text	00000018 setlocale
8113de8c g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
8115cb70 g     O .bss	00000800 OSTmrTaskStk
81116f38 g     F .text	00000044 scanf
811127c0 g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
8112f4dc g     F .text	00000110 OSFlagCreate
8113765c g     F .text	00000688 Check_for_DOS_FAT
81139508 g     F .text	000002d0 create_file
811220d8 g     F .text	00000008 nanf
81146bb4 g     O .rwdata	00000004 _impure_ptr
81146e14 g     O .bss	00000004 CSD_register_w0
81146d74 g     O .bss	00000004 alt_argc
81111798 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
8111eedc g     F .text	00000224 __sflush_r
811204e0 g     F .text	000000b4 _mbrtowc_r
81120440 g     F .text	00000008 __locale_cjk_lang
811033b0 g     F .text	0000078c sense_log
81146c8c g     O .bss	00000004 ESdmaBufferSide
81146c12 g     O .rwdata	00000002 OSEventMultiEn
81115760 g     F .text	00000004 _fseek_r
81155ba8 g     O .bss	00001800 vParserCommTask_stk
81111028 g     F .text	00000070 printErrorTask
81113778 g     F .text	00000030 vChangeDefaultEPValue
8110e068 g     F .text	000002c8 vCheckRetransmission32
81135950 g     F .text	000001c4 OSTmrCreate
8110d18c g     F .text	000007dc vStackMonitor
81116d00 g     F .text	000001dc __srefill_r
81105814 g     F .text	0000003c bEnableLvdsBoard
81146d14 g     O .bss	00000004 xMutexBuffer32
8112f5ec g     F .text	00000250 OSFlagDel
81146de0 g     O .bss	00000004 OSEventFreeList
8110588c g     F .text	000000c0 bSetPreEmphasys
81100020 g       .exceptions	00000000 alt_irq_entry
81120674 g     F .text	0000004c __ascii_mbtowc
81107dc8 g     F .text	00000078 bSyncCtrExtnIrq
811214c8 g     F .text	00000064 __ulp
81113344 g     F .text	000000c0 vNFeeControlInit
8112fac0 g     F .text	000005c0 OSFlagPend
81146c5e g     O .rwdata	00000002 OSTmrEn
8111f534 g     F .text	00000018 __fp_unlock_all
811156fc g     F .text	00000064 fputc
8110f3c8 g     F .text	000002f8 bSendUART32v2
8110beac g     F .text	0000019c setPreAckReceiverFreePos
81107d88 g     F .text	00000040 bSyncErrInj
81146bcc g     O .rwdata	00000008 alt_fs_list
811573a8 g     O .bss	00001000 vSimMebTask_stk
81112758 g     F .text	00000068 vCoudlNotCreateMebTask
81137ea4 g     F .text	00000274 check_file_name_for_FAT16_compliance
811583a8 g     O .bss	00001000 vFeeTask3_stk
81135c54 g     F .text	00000140 OSTmrNameGet
811470fc g     O .bss	00000400 xSZData
8112ea04 g     F .text	0000007c OS_StrCopy
81146e20 g     O .bss	00000004 buffer_memory
811119a0 g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
811135c8 g     F .text	00000098 vLogWriteNUC
81146c28 g     O .rwdata	00000002 OSMemNameSize
81103b3c g     F .text	000000b0 bSdmaInitM1Dma
81108418 g     F .text	00000074 bSyncIrqEnableBlank
8113fa98 g     F .text	00000028 OSInitHookEnd
81112e24 g     F .text	00000340 vUpdateMemMapFEE
81111c10 g     F .text	00000068 vFailSetPreAckReceiverBuffer
81104b8c g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
81146c54 g     O .rwdata	00000002 OSTCBPrioTblMax
8112046c g     F .text	0000000c localeconv
811126f0 g     F .text	00000068 vCoudlNotCreateDataControllerTask
81146d18 g     O .bss	00000004 xTimerRetransmission
8110b9a4 g     F .text	00000250 vReceiverUartTask
81146d70 g     O .bss	00000004 alt_log_sys_clk_count
81146c50 g     O .rwdata	00000002 OSTaskStatStkChkEn
8112be5c g     F .text	00000140 alt_log_write
811593a8 g     O .bss	00001000 vFeeTask2_stk
81146d1c g     O .bss	00000004 xMutexBuffer128
81104504 g     F .text	00000040 vFeebCh1HandleIrq
81104684 g     F .text	00000040 vFeebCh7HandleIrq
8113f070 g     F .text	00000058 alt_ic_isr_register
81146c24 g     O .rwdata	00000002 OSMemEn
81146ba0 g     O .rwdata	00000004 alt_stack_limit_value
81115d20 g     F .text	0000003c fwrite
81146e24 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
81146c2e g     O .rwdata	00000002 OSMutexEn
81112a58 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
81146c7c g       *ABS*	00000000 _edata
8113bef0 g     F .text	00000068 altera_avalon_uart_read_fd
81113478 g     F .text	00000034 vLoadDefaultIdNFEEMaster
811605d4 g       *ABS*	00000000 _end
8115ffd4 g     O .bss	00000500 active_files
81146de4 g     O .bss	00000001 OSIntNesting
81111530 g     F .text	0000004c vFailInitialization
811014d0 g     F .text	000000c0 bDdr2SwitchMemory
81113240 g     F .text	0000002c cFeeRMAPDump
81146d20 g     O .bss	00000004 xSemCountBuffer32
81127064 g     F .text	0000016c __fputwc
81146cc8 g     O .bss	00000004 xQMaskFeeCtrl
81113190 g     F .text	0000002c vFeeSpwRMAPChangeConfig
8111d1e4 g     F .text	00000070 vfscanf
811397d8 g     F .text	00000150 copy_file_record_name_to_string
8113b760 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
811356a8 g     F .text	000001dc OSTimeDlyResume
81137ce4 g     F .text	000000f4 Look_for_FAT16
8112f96c g     F .text	00000154 OSFlagNameSet
81146d24 g     O .bss	00000004 xMutexBuffer64
81134ee0 g     F .text	000001c8 OSTaskStkChk
8113f158 g     F .text	00000094 alt_ic_irq_disable
81103c9c g     F .text	00000430 bSdmaDmaM1Transfer
81146c2a g     O .rwdata	00000002 OSMemSize
81111660 g     F .text	00000068 vFailSetCountSemaphorexBuffer32
811170ec g     F .text	00000084 __swrite
81146bbc g     O .rwdata	00000004 __malloc_trim_threshold
81120434 g     F .text	0000000c __locale_msgcharset
8115a3a8 g     O .bss	00000010 xFeeQueueTBL1
81146de8 g     O .bss	00000004 OSTCBCur
81111fe0 g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
81106cf4 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
8113fbb8 g     F .text	00000040 exit
81131cf8 g     F .text	00000220 OSMutexPost
81108574 g     F .text	00000058 bSyncIrqFlagError
81139c04 g     F .text	000003c0 alt_up_sd_card_find_next
81146c2c g     O .rwdata	00000002 OSMemTblSize
8112023c g     F .text	000000cc _fwalk_reent
8113e284 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
811149ec g     F .text	000000f8 .hidden __floatunsisf
811212c4 g     F .text	00000204 __mdiff
81112418 g     F .text	00000068 vCoudlNotCreateNFee0Task
81104be4 g     F .text	00000180 vFeebInitIrq
811115c8 g     F .text	0000004c vFailSenderCreate
81128ca8 g     F .text	00000074 .hidden __modsi3
81112620 g     F .text	00000068 vCoudlNotCreateNFee5Task
81107cd4 g     F .text	0000003c uliSyncGetPer
81146d28 g     O .bss	00000004 xMutexSenderACK
81111e40 g     F .text	00000068 vFailGetBlockingSemTimeoutTask
81146bac g     O .rwdata	00000004 __ctype_ptr__
81111ba8 g     F .text	00000068 vFailSetPreParsedBuffer
81136d14 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8111f510 g     F .text	00000004 __sfp_lock_release
81104e38 g     F .text	000000ac bFeebGetIrqControl
81112118 g     F .text	00000068 vCouldNotSendTurnOff
8112d71c g     F .text	00000064 OSInit
811061c4 g     F .text	00000078 bSetPainelLeds
8113d9cc g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
81146dec g     O .bss	00000004 OSTmrTime
81101b10 g     F .text	00000510 bDdr2MemoryReadTest
81135294 g     F .text	0000012c OSTaskQuery
811083a4 g     F .text	00000074 bSyncIrqEnableError
81146d2c g     O .bss	00000004 xMutexPus
811332d0 g     F .text	000000b0 OS_QInit
81122008 g     F .text	000000d0 __sccl
81115528 g     F .text	0000000c atoi
811087ac g     F .text	00000070 vFeeTask
8112ea80 g     F .text	0000005c OS_StrLen
8110497c g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
81110f4c g     F .text	000000dc vDataControllerInit
81130d14 g     F .text	0000011c OSMemNameSet
811441c8 g     O .rodata	00000101 _ctype_
81107c98 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
81111730 g     F .text	00000068 vFailSetCountSemaphorexBuffer128
81146c46 g     O .rwdata	00000002 OSTaskProfileEn
81112bac g     F .text	00000070 vEvtChangeMebMode
8113d89c g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
81146d30 g     O .bss	00000004 xTxUARTMutex
81146df0 g     O .bss	00000004 OSTime
81146bc4 g     O .rwdata	00000004 __mbtowc
8113c510 g     F .text	0000005c altera_avalon_uart_close
81146df4 g     O .bss	00000004 OSTmrSem
8115d370 g     O .bss	00001000 OSTaskIdleStk
81115540 g     F .text	000000fc _fopen_r
81146cdc g     O .bss	00000004 pdata
8113fee8 g     F .text	000000bc _exit
8113ebc0 g     F .text	00000134 alt_alarm_start
8112f83c g     F .text	00000130 OSFlagNameGet
81135884 g     F .text	00000064 OSTimeGet
81146c90 g     O .bss	00000004 ESdmaChBufferId
8113a468 g     F .text	00000380 alt_up_sd_card_read
81115d5c g     F .text	000001c4 __smakebuf_r
81146d34 g     O .bss	00000001 SemCount64
8110f0d0 g     F .text	000002f8 bSendUART64v2
81104a2c g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
81146c74 g     O .rwdata	00000008 alt_msgdma_list
81117228 g     F .text	00000098 strlen
81107530 g     F .text	000000b4 uc_spi_get_byte
81112ac0 g     F .text	00000054 vFailSendMsgAccessDMA
8113f9c8 g     F .text	00000028 OSTaskSwHook
8112c39c g     F .text	0000015c open
8115e370 g     O .bss	00000d00 OSEventTbl
811131bc g     F .text	0000002c vFeeSpwRMAPChangeDefault
8112a200 g     F .text	000000dc .hidden __gedf2
8115a3b8 g     O .bss	00000020 xSenderACK
8113f6bc g     F .text	00000044 alt_putchar
8115f070 g     O .bss	00000e58 OSTCBTbl
8112737c g     F .text	00000838 __gethex
81133d18 g     F .text	00000108 OSSemSet
8110d968 g     F .text	0000006c vTimeoutCheckerTaskv2
8111326c g     F .text	00000038 cFeeRMAPEchoingEnable
81146bc8 g     O .rwdata	00000004 __wctomb
8110e858 g     F .text	00000314 vVariablesInitialization
81125930 g     F .text	00000018 __sprint_r
81104ee4 g     F .text	00000088 bFeebGetIrqFlags
81146c88 g     O .bss	00000004 pxDmaM2Dev
811110f8 g     F .text	0000004c vFailCreateSemaphoreResources
81146be4 g     O .rwdata	00000004 alt_priority_mask
81105850 g     F .text	0000003c bDisableLvdsBoard
81133518 g     F .text	00000248 OSSemDel
81146df8 g     O .bss	00000004 OSFlagFreeList
8110746c g     F .text	000000c4 v_spi_send_byte
811077a0 g     F .text	000000d0 bSSDisplayConfig
8113f0c8 g     F .text	00000090 alt_ic_irq_enable
81146c0c g     O .rwdata	00000002 OSEventNameSize
8111b940 g     F .text	0000001c __vfprintf_internal
81146dfc g     O .bss	00000001 OSStatRdy
81108078 g     F .text	00000074 bSyncCtrCh2OutEnable
8115fec8 g     O .bss	000000a4 OSTCBPrioTbl
8113c5b0 g     F .text	00000270 altera_avalon_uart_read
81128084 g     F .text	00000064 _wctomb_r
8112cbe8 g     F .text	000000cc __env_lock
81146c52 g     O .rwdata	00000002 OSTaskSwHookEn
8110478c g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
8112a3d0 g     F .text	00000904 .hidden __subdf3
8115a3d8 g     O .bss	00000260 xPreParsed
81107d10 g     F .text	0000003c uliSyncGetOst
81146d35 g     O .bss	00000001 SemCount128
81104858 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
8110f6c0 g     F .text	00000290 vSendEthConf
81120cd8 g     F .text	000000b0 __lo0bits
8111ba20 g     F .text	000017c4 __svfscanf_r
81146bf0 g     O .rwdata	00000008 alt_alarm_list
81125678 g     F .text	0000019c _ungetc_r
81146c1a g     O .rwdata	00000002 OSFlagWidth
81102a5c g     F .text	0000004c DMA_BUSY
81127f8c g     F .text	000000c8 wcrtomb
8110ece8 g     F .text	00000068 vCCDLoadDefaultValues
8112b05c g     F .text	000000d8 close
81107d4c g     F .text	0000003c uliSyncGetGeneral
81112c8c g     F .text	00000070 vEvtChangeDataControllerMode
81146d8c g     O .bss	00000004 alt_envsem
8112b58c g     F .text	00000068 alt_log_repchar
81146e00 g     O .bss	00000004 OSIdleCtrRun
8112dda4 g     F .text	00000028 OSVersion
81146c64 g     O .rwdata	00000002 OSTmrCfgWheelSize
811353c0 g     F .text	00000078 OS_TaskStkClr
81113b34 g     F .text	0000003c siOpenFile
81108750 g     F .text	0000005c vDataControlTask
81146c3e g     O .rwdata	00000002 OSTaskCreateEn
8110f950 g     F .text	00000118 vSendTurnOff
811111f8 g     F .text	0000004c vFailSendPreParsedSemaphore
811381d8 g     F .text	000002a4 match_file_record_to_name_ext
8112e3cc g     F .text	00000070 OS_EventWaitListInit
811271f4 g     F .text	00000088 fputwc
8115a638 g     O .bss	00000010 xFeeQueueTBL0
81111190 g     F .text	00000068 vFailSendxSemCommInit
8113fac0 g     F .text	00000028 OSTaskIdleHook
8110fa68 g     F .text	00000118 vSendReset
8111f514 g     F .text	00000004 __sinit_lock_acquire
81120a3c g     F .text	00000128 __multadd
8110489c g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110799c g     F .text	0000004c ucSyncStatusState
811350a8 g     F .text	000001ec OSTaskSuspend
81120a14 g     F .text	00000028 _Bfree
81107c5c g     F .text	0000003c uliSyncGetMbt
8112eadc g     F .text	00000064 OS_TaskIdle
81146c6a g     O .rwdata	00000002 OSTmrTblSize
8113316c g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	112d7800 	call	8112d780 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045b4 	movhi	r2,33046
81100150:	10813504 	addi	r2,r2,1236
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045b4 	movhi	r2,33046
81100168:	10813504 	addi	r2,r2,1236
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	112d7d40 	call	8112d7d4 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0a717 	ldw	r2,-32100(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0a717 	ldw	r2,-32100(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204534 	movhi	r4,33044
81100260:	211afa04 	addi	r4,r4,27624
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204534 	movhi	r4,33044
81100270:	21165104 	addi	r4,r4,22852
81100274:	112b5040 	call	8112b504 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204534 	movhi	r4,33044
8110027c:	211afa04 	addi	r4,r4,27624
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204534 	movhi	r4,33044
8110028c:	21164404 	addi	r4,r4,22800
81100290:	112b5040 	call	8112b504 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04534 	movhi	gp,33044
    ori gp, gp, %lo(_gp)
811002a0:	d6bae814 	ori	gp,gp,60320
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204534 	movhi	r4,33044
811002a8:	211afa04 	addi	r4,r4,27624
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204534 	movhi	r4,33044
811002b8:	21163504 	addi	r4,r4,22740
811002bc:	112b5040 	call	8112b504 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04534 	movhi	r2,33044
    ori r2, r2, %lo(__bss_start)
811002c4:	109b1f14 	ori	r2,r2,27772

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18c17514 	ori	r3,r3,1492

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204534 	movhi	r4,33044
811002e8:	211afa04 	addi	r4,r4,27624
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204534 	movhi	r4,33044
811002f8:	21163c04 	addi	r4,r4,22768
811002fc:	112b5040 	call	8112b504 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	112c1300 	call	8112c130 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mémoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04534 	movhi	r3,33044
8110032c:	18dbff04 	addi	r3,r3,28668
81100330:	00a04534 	movhi	r2,33044
81100334:	10bfe904 	addi	r2,r2,-92
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a05417 	ldw	r2,-32432(gp)
81100354:	01604534 	movhi	r5,33044
81100358:	295bff04 	addi	r5,r5,28668
8110035c:	1009883a 	mov	r4,r2
81100360:	11156840 	call	81115684 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10c00060 	cmpeqi	r3,r2,1
8110037c:	1800031e 	bne	r3,zero,8110038c <bDdr2EepromTest+0x84>
81100380:	108000a0 	cmpeqi	r2,r2,2
81100384:	1000081e 	bne	r2,zero,811003a8 <bDdr2EepromTest+0xa0>
81100388:	00000e06 	br	811003c4 <bDdr2EepromTest+0xbc>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
8110038c:	00a00034 	movhi	r2,32768
81100390:	10827c04 	addi	r2,r2,2544
81100394:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100398:	00a00034 	movhi	r2,32768
8110039c:	10828004 	addi	r2,r2,2560
811003a0:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a4:	00001906 	br	8110040c <bDdr2EepromTest+0x104>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a8:	00a00034 	movhi	r2,32768
811003ac:	10825804 	addi	r2,r2,2400
811003b0:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b4:	00a00034 	movhi	r2,32768
811003b8:	10825c04 	addi	r2,r2,2416
811003bc:	e0bffb15 	stw	r2,-20(fp)
		break;
811003c0:	00001206 	br	8110040c <bDdr2EepromTest+0x104>
	default:
		bSuccess = FALSE;
811003c4:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c8:	00e04534 	movhi	r3,33044
811003cc:	18dbff04 	addi	r3,r3,28668
811003d0:	00a04534 	movhi	r2,33044
811003d4:	10bff204 	addi	r2,r2,-56
811003d8:	1009883a 	mov	r4,r2
811003dc:	00800bc4 	movi	r2,47
811003e0:	100d883a 	mov	r6,r2
811003e4:	200b883a 	mov	r5,r4
811003e8:	1809883a 	mov	r4,r3
811003ec:	11167340 	call	81116734 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003f0:	d0a05417 	ldw	r2,-32432(gp)
811003f4:	01604534 	movhi	r5,33044
811003f8:	295bff04 	addi	r5,r5,28668
811003fc:	1009883a 	mov	r4,r2
81100400:	11156840 	call	81115684 <fprintf>
		;
#endif
		return bSuccess;
81100404:	e0bff917 	ldw	r2,-28(fp)
81100408:	0000ff06 	br	81100808 <bDdr2EepromTest+0x500>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
8110040c:	00e04534 	movhi	r3,33044
81100410:	18dbff04 	addi	r3,r3,28668
81100414:	00a04534 	movhi	r2,33044
81100418:	10bffe04 	addi	r2,r2,-8
8110041c:	1009883a 	mov	r4,r2
81100420:	008005c4 	movi	r2,23
81100424:	100d883a 	mov	r6,r2
81100428:	200b883a 	mov	r5,r4
8110042c:	1809883a 	mov	r4,r3
81100430:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
81100434:	d0a05417 	ldw	r2,-32432(gp)
81100438:	01604534 	movhi	r5,33044
8110043c:	295bff04 	addi	r5,r5,28668
81100440:	1009883a 	mov	r4,r2
81100444:	11156840 	call	81115684 <fprintf>
#endif
	usleep(20 * 1000);
81100448:	01138804 	movi	r4,20000
8110044c:	112c95c0 	call	8112c95c <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100450:	e03ffc15 	stw	zero,-16(fp)
81100454:	00003306 	br	81100524 <bDdr2EepromTest+0x21c>
		ucControlAddr = iI;
81100458:	e0bffc17 	ldw	r2,-16(fp)
8110045c:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100460:	e0bffd03 	ldbu	r2,-12(fp)
81100464:	10c03fcc 	andi	r3,r2,255
81100468:	18c0201c 	xori	r3,r3,128
8110046c:	18ffe004 	addi	r3,r3,-128
81100470:	e13ffd43 	ldbu	r4,-11(fp)
81100474:	e0bffe04 	addi	r2,fp,-8
81100478:	d8800015 	stw	r2,0(sp)
8110047c:	200f883a 	mov	r7,r4
81100480:	180d883a 	mov	r6,r3
81100484:	e17ffb17 	ldw	r5,-20(fp)
81100488:	e13ffa17 	ldw	r4,-24(fp)
8110048c:	1105b300 	call	81105b30 <I2C_Read>
81100490:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100494:	e0bff917 	ldw	r2,-28(fp)
81100498:	10001026 	beq	r2,zero,811004dc <bDdr2EepromTest+0x1d4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
8110049c:	e0bffd43 	ldbu	r2,-11(fp)
811004a0:	e0fffe03 	ldbu	r3,-8(fp)
811004a4:	18c03fcc 	andi	r3,r3,255
811004a8:	180f883a 	mov	r7,r3
811004ac:	100d883a 	mov	r6,r2
811004b0:	01604534 	movhi	r5,33044
811004b4:	29400404 	addi	r5,r5,16
811004b8:	01204534 	movhi	r4,33044
811004bc:	211bff04 	addi	r4,r4,28668
811004c0:	11170140 	call	81117014 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c4:	d0a05417 	ldw	r2,-32432(gp)
811004c8:	01604534 	movhi	r5,33044
811004cc:	295bff04 	addi	r5,r5,28668
811004d0:	1009883a 	mov	r4,r2
811004d4:	11156840 	call	81115684 <fprintf>
811004d8:	00000f06 	br	81100518 <bDdr2EepromTest+0x210>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004dc:	00e04534 	movhi	r3,33044
811004e0:	18dbff04 	addi	r3,r3,28668
811004e4:	00a04534 	movhi	r2,33044
811004e8:	10800904 	addi	r2,r2,36
811004ec:	1009883a 	mov	r4,r2
811004f0:	008005c4 	movi	r2,23
811004f4:	100d883a 	mov	r6,r2
811004f8:	200b883a 	mov	r5,r4
811004fc:	1809883a 	mov	r4,r3
81100500:	11167340 	call	81116734 <memcpy>
			debug(fp, cDebugBuffer);
81100504:	d0a05417 	ldw	r2,-32432(gp)
81100508:	01604534 	movhi	r5,33044
8110050c:	295bff04 	addi	r5,r5,28668
81100510:	1009883a 	mov	r4,r2
81100514:	11156840 	call	81115684 <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100518:	e0bffc17 	ldw	r2,-16(fp)
8110051c:	10800044 	addi	r2,r2,1
81100520:	e0bffc15 	stw	r2,-16(fp)
81100524:	e0bffc17 	ldw	r2,-16(fp)
81100528:	10804008 	cmpgei	r2,r2,256
8110052c:	1000021e 	bne	r2,zero,81100538 <bDdr2EepromTest+0x230>
81100530:	e0bff917 	ldw	r2,-28(fp)
81100534:	103fc81e 	bne	r2,zero,81100458 <__reset+0xfb0e0458>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100538:	e0bff917 	ldw	r2,-28(fp)
8110053c:	10001026 	beq	r2,zero,81100580 <bDdr2EepromTest+0x278>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
81100540:	00e04534 	movhi	r3,33044
81100544:	18dbff04 	addi	r3,r3,28668
81100548:	00a04534 	movhi	r2,33044
8110054c:	10800f04 	addi	r2,r2,60
81100550:	1009883a 	mov	r4,r2
81100554:	00800884 	movi	r2,34
81100558:	100d883a 	mov	r6,r2
8110055c:	200b883a 	mov	r5,r4
81100560:	1809883a 	mov	r4,r3
81100564:	11167340 	call	81116734 <memcpy>
		debug(fp, cDebugBuffer);
81100568:	d0a05417 	ldw	r2,-32432(gp)
8110056c:	01604534 	movhi	r5,33044
81100570:	295bff04 	addi	r5,r5,28668
81100574:	1009883a 	mov	r4,r2
81100578:	11156840 	call	81115684 <fprintf>
8110057c:	00000f06 	br	811005bc <bDdr2EepromTest+0x2b4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
81100580:	00e04534 	movhi	r3,33044
81100584:	18dbff04 	addi	r3,r3,28668
81100588:	00a04534 	movhi	r2,33044
8110058c:	10801804 	addi	r2,r2,96
81100590:	1009883a 	mov	r4,r2
81100594:	008007c4 	movi	r2,31
81100598:	100d883a 	mov	r6,r2
8110059c:	200b883a 	mov	r5,r4
811005a0:	1809883a 	mov	r4,r3
811005a4:	11167340 	call	81116734 <memcpy>
		debug(fp, cDebugBuffer);
811005a8:	d0a05417 	ldw	r2,-32432(gp)
811005ac:	01604534 	movhi	r5,33044
811005b0:	295bff04 	addi	r5,r5,28668
811005b4:	1009883a 	mov	r4,r2
811005b8:	11156840 	call	81115684 <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005bc:	00e04534 	movhi	r3,33044
811005c0:	18dbff04 	addi	r3,r3,28668
811005c4:	00a04534 	movhi	r2,33044
811005c8:	10802004 	addi	r2,r2,128
811005cc:	1009883a 	mov	r4,r2
811005d0:	00800604 	movi	r2,24
811005d4:	100d883a 	mov	r6,r2
811005d8:	200b883a 	mov	r5,r4
811005dc:	1809883a 	mov	r4,r3
811005e0:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
811005e4:	d0a05417 	ldw	r2,-32432(gp)
811005e8:	01604534 	movhi	r5,33044
811005ec:	295bff04 	addi	r5,r5,28668
811005f0:	1009883a 	mov	r4,r2
811005f4:	11156840 	call	81115684 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f8:	00800484 	movi	r2,18
811005fc:	e0bffd85 	stb	r2,-10(fp)
81100600:	00bfe004 	movi	r2,-128
81100604:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100608:	01138804 	movi	r4,20000
8110060c:	112c95c0 	call	8112c95c <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100610:	e0bffd03 	ldbu	r2,-12(fp)
81100614:	10c03fcc 	andi	r3,r2,255
81100618:	18c0201c 	xori	r3,r3,128
8110061c:	18ffe004 	addi	r3,r3,-128
81100620:	e13ffdc3 	ldbu	r4,-9(fp)
81100624:	e0bffd83 	ldbu	r2,-10(fp)
81100628:	d8800015 	stw	r2,0(sp)
8110062c:	200f883a 	mov	r7,r4
81100630:	180d883a 	mov	r6,r3
81100634:	e17ffb17 	ldw	r5,-20(fp)
81100638:	e13ffa17 	ldw	r4,-24(fp)
8110063c:	1105a500 	call	81105a50 <I2C_Write>
81100640:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100644:	e0bff917 	ldw	r2,-28(fp)
81100648:	1000101e 	bne	r2,zero,8110068c <bDdr2EepromTest+0x384>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
8110064c:	00e04534 	movhi	r3,33044
81100650:	18dbff04 	addi	r3,r3,28668
81100654:	00a04534 	movhi	r2,33044
81100658:	10802604 	addi	r2,r2,152
8110065c:	1009883a 	mov	r4,r2
81100660:	00800604 	movi	r2,24
81100664:	100d883a 	mov	r6,r2
81100668:	200b883a 	mov	r5,r4
8110066c:	1809883a 	mov	r4,r3
81100670:	11167340 	call	81116734 <memcpy>
		debug(fp, cDebugBuffer);
81100674:	d0a05417 	ldw	r2,-32432(gp)
81100678:	01604534 	movhi	r5,33044
8110067c:	295bff04 	addi	r5,r5,28668
81100680:	1009883a 	mov	r4,r2
81100684:	11156840 	call	81115684 <fprintf>
81100688:	00003306 	br	81100758 <bDdr2EepromTest+0x450>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110068c:	e0bffd03 	ldbu	r2,-12(fp)
81100690:	10c03fcc 	andi	r3,r2,255
81100694:	18c0201c 	xori	r3,r3,128
81100698:	18ffe004 	addi	r3,r3,-128
8110069c:	e13ffdc3 	ldbu	r4,-9(fp)
811006a0:	e0bffe44 	addi	r2,fp,-7
811006a4:	d8800015 	stw	r2,0(sp)
811006a8:	200f883a 	mov	r7,r4
811006ac:	180d883a 	mov	r6,r3
811006b0:	e17ffb17 	ldw	r5,-20(fp)
811006b4:	e13ffa17 	ldw	r4,-24(fp)
811006b8:	1105b300 	call	81105b30 <I2C_Read>
811006bc:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006c0:	e0bff917 	ldw	r2,-28(fp)
811006c4:	1000101e 	bne	r2,zero,81100708 <bDdr2EepromTest+0x400>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c8:	00e04534 	movhi	r3,33044
811006cc:	18dbff04 	addi	r3,r3,28668
811006d0:	00a04534 	movhi	r2,33044
811006d4:	10802c04 	addi	r2,r2,176
811006d8:	1009883a 	mov	r4,r2
811006dc:	00800884 	movi	r2,34
811006e0:	100d883a 	mov	r6,r2
811006e4:	200b883a 	mov	r5,r4
811006e8:	1809883a 	mov	r4,r3
811006ec:	11167340 	call	81116734 <memcpy>
			debug(fp, cDebugBuffer);
811006f0:	d0a05417 	ldw	r2,-32432(gp)
811006f4:	01604534 	movhi	r5,33044
811006f8:	295bff04 	addi	r5,r5,28668
811006fc:	1009883a 	mov	r4,r2
81100700:	11156840 	call	81115684 <fprintf>
81100704:	00001406 	br	81100758 <bDdr2EepromTest+0x450>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100708:	e0bffe43 	ldbu	r2,-7(fp)
8110070c:	10c03fcc 	andi	r3,r2,255
81100710:	e0bffd83 	ldbu	r2,-10(fp)
81100714:	18801026 	beq	r3,r2,81100758 <bDdr2EepromTest+0x450>
				bSuccess = FALSE;
81100718:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110071c:	e0bffe43 	ldbu	r2,-7(fp)
81100720:	10803fcc 	andi	r2,r2,255
81100724:	e0fffd83 	ldbu	r3,-10(fp)
81100728:	180f883a 	mov	r7,r3
8110072c:	100d883a 	mov	r6,r2
81100730:	01604534 	movhi	r5,33044
81100734:	29403504 	addi	r5,r5,212
81100738:	01204534 	movhi	r4,33044
8110073c:	211bff04 	addi	r4,r4,28668
81100740:	11170140 	call	81117014 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100744:	d0a05417 	ldw	r2,-32432(gp)
81100748:	01604534 	movhi	r5,33044
8110074c:	295bff04 	addi	r5,r5,28668
81100750:	1009883a 	mov	r4,r2
81100754:	11156840 	call	81115684 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100758:	e0bff917 	ldw	r2,-28(fp)
8110075c:	10001026 	beq	r2,zero,811007a0 <bDdr2EepromTest+0x498>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
81100760:	00e04534 	movhi	r3,33044
81100764:	18dbff04 	addi	r3,r3,28668
81100768:	00a04534 	movhi	r2,33044
8110076c:	10804404 	addi	r2,r2,272
81100770:	1009883a 	mov	r4,r2
81100774:	008008c4 	movi	r2,35
81100778:	100d883a 	mov	r6,r2
8110077c:	200b883a 	mov	r5,r4
81100780:	1809883a 	mov	r4,r3
81100784:	11167340 	call	81116734 <memcpy>
		debug(fp, cDebugBuffer);
81100788:	d0a05417 	ldw	r2,-32432(gp)
8110078c:	01604534 	movhi	r5,33044
81100790:	295bff04 	addi	r5,r5,28668
81100794:	1009883a 	mov	r4,r2
81100798:	11156840 	call	81115684 <fprintf>
8110079c:	00000f06 	br	811007dc <bDdr2EepromTest+0x4d4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
811007a0:	00e04534 	movhi	r3,33044
811007a4:	18dbff04 	addi	r3,r3,28668
811007a8:	00a04534 	movhi	r2,33044
811007ac:	10804d04 	addi	r2,r2,308
811007b0:	1009883a 	mov	r4,r2
811007b4:	00800804 	movi	r2,32
811007b8:	100d883a 	mov	r6,r2
811007bc:	200b883a 	mov	r5,r4
811007c0:	1809883a 	mov	r4,r3
811007c4:	11167340 	call	81116734 <memcpy>
		debug(fp, cDebugBuffer);
811007c8:	d0a05417 	ldw	r2,-32432(gp)
811007cc:	01604534 	movhi	r5,33044
811007d0:	295bff04 	addi	r5,r5,28668
811007d4:	1009883a 	mov	r4,r2
811007d8:	11156840 	call	81115684 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007dc:	00a04534 	movhi	r2,33044
811007e0:	109bff04 	addi	r2,r2,28668
811007e4:	00c00284 	movi	r3,10
811007e8:	10c00005 	stb	r3,0(r2)
811007ec:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007f0:	d0a05417 	ldw	r2,-32432(gp)
811007f4:	01604534 	movhi	r5,33044
811007f8:	295bff04 	addi	r5,r5,28668
811007fc:	1009883a 	mov	r4,r2
81100800:	11156840 	call	81115684 <fprintf>
#endif

	return bSuccess;
81100804:	e0bff917 	ldw	r2,-28(fp)
}
81100808:	e037883a 	mov	sp,fp
8110080c:	dfc00117 	ldw	ra,4(sp)
81100810:	df000017 	ldw	fp,0(sp)
81100814:	dec00204 	addi	sp,sp,8
81100818:	f800283a 	ret

8110081c <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mémoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
8110081c:	deffb704 	addi	sp,sp,-292
81100820:	de00012e 	bgeu	sp,et,81100828 <bDdr2EepromDump+0xc>
81100824:	003b68fa 	trap	3
81100828:	dfc04815 	stw	ra,288(sp)
8110082c:	df004715 	stw	fp,284(sp)
81100830:	df004704 	addi	fp,sp,284
81100834:	2005883a 	mov	r2,r4
81100838:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
8110083c:	00e04534 	movhi	r3,33044
81100840:	18dbff04 	addi	r3,r3,28668
81100844:	00a04534 	movhi	r2,33044
81100848:	10805504 	addi	r2,r2,340
8110084c:	1009883a 	mov	r4,r2
81100850:	00800884 	movi	r2,34
81100854:	100d883a 	mov	r6,r2
81100858:	200b883a 	mov	r5,r4
8110085c:	1809883a 	mov	r4,r3
81100860:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
81100864:	d0a05417 	ldw	r2,-32432(gp)
81100868:	01604534 	movhi	r5,33044
8110086c:	295bff04 	addi	r5,r5,28668
81100870:	1009883a 	mov	r4,r2
81100874:	11156840 	call	81115684 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100878:	00bfe804 	movi	r2,-96
8110087c:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
81100880:	00800044 	movi	r2,1
81100884:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100888:	e0bfff03 	ldbu	r2,-4(fp)
8110088c:	10c00060 	cmpeqi	r3,r2,1
81100890:	1800031e 	bne	r3,zero,811008a0 <bDdr2EepromDump+0x84>
81100894:	108000a0 	cmpeqi	r2,r2,2
81100898:	1000081e 	bne	r2,zero,811008bc <bDdr2EepromDump+0xa0>
8110089c:	00000e06 	br	811008d8 <bDdr2EepromDump+0xbc>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
811008a0:	00a00034 	movhi	r2,32768
811008a4:	10827c04 	addi	r2,r2,2544
811008a8:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008ac:	00a00034 	movhi	r2,32768
811008b0:	10828004 	addi	r2,r2,2560
811008b4:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b8:	00001906 	br	81100920 <bDdr2EepromDump+0x104>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008bc:	00a00034 	movhi	r2,32768
811008c0:	10825804 	addi	r2,r2,2400
811008c4:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c8:	00a00034 	movhi	r2,32768
811008cc:	10825c04 	addi	r2,r2,2416
811008d0:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008d4:	00001206 	br	81100920 <bDdr2EepromDump+0x104>
	default:
		bSuccess = FALSE;
811008d8:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008dc:	00e04534 	movhi	r3,33044
811008e0:	18dbff04 	addi	r3,r3,28668
811008e4:	00a04534 	movhi	r2,33044
811008e8:	10805e04 	addi	r2,r2,376
811008ec:	1009883a 	mov	r4,r2
811008f0:	00800bc4 	movi	r2,47
811008f4:	100d883a 	mov	r6,r2
811008f8:	200b883a 	mov	r5,r4
811008fc:	1809883a 	mov	r4,r3
81100900:	11167340 	call	81116734 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
81100904:	d0a05417 	ldw	r2,-32432(gp)
81100908:	01604534 	movhi	r5,33044
8110090c:	295bff04 	addi	r5,r5,28668
81100910:	1009883a 	mov	r4,r2
81100914:	11156840 	call	81115684 <fprintf>
		;
#endif
		return bSuccess;
81100918:	e0bfbe17 	ldw	r2,-264(fp)
8110091c:	0002e706 	br	811014bc <bDdr2EepromDump+0xca0>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100920:	e0bfbd03 	ldbu	r2,-268(fp)
81100924:	10c03fcc 	andi	r3,r2,255
81100928:	18c0201c 	xori	r3,r3,128
8110092c:	18ffe004 	addi	r3,r3,-128
81100930:	e13fbf04 	addi	r4,fp,-260
81100934:	00804004 	movi	r2,256
81100938:	d8800015 	stw	r2,0(sp)
8110093c:	200f883a 	mov	r7,r4
81100940:	180d883a 	mov	r6,r3
81100944:	e17fbb17 	ldw	r5,-276(fp)
81100948:	e13fba17 	ldw	r4,-280(fp)
8110094c:	1105c380 	call	81105c38 <I2C_MultipleRead>
81100950:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
81100954:	e0bfbe17 	ldw	r2,-264(fp)
81100958:	1002be26 	beq	r2,zero,81101454 <bDdr2EepromDump+0xc38>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
8110095c:	e03fbc15 	stw	zero,-272(fp)
81100960:	0002b606 	br	8110143c <bDdr2EepromDump+0xc20>
			if (iI == 0) {
81100964:	e0bfbc17 	ldw	r2,-272(fp)
81100968:	1000121e 	bne	r2,zero,811009b4 <bDdr2EepromDump+0x198>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
8110096c:	e0ffbf04 	addi	r3,fp,-260
81100970:	e0bfbc17 	ldw	r2,-272(fp)
81100974:	1885883a 	add	r2,r3,r2
81100978:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110097c:	10803fcc 	andi	r2,r2,255
81100980:	100f883a 	mov	r7,r2
81100984:	e1bfbc17 	ldw	r6,-272(fp)
81100988:	01604534 	movhi	r5,33044
8110098c:	29406a04 	addi	r5,r5,424
81100990:	01204534 	movhi	r4,33044
81100994:	211bff04 	addi	r4,r4,28668
81100998:	11170140 	call	81117014 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
8110099c:	d0a05417 	ldw	r2,-32432(gp)
811009a0:	01604534 	movhi	r5,33044
811009a4:	295bff04 	addi	r5,r5,28668
811009a8:	1009883a 	mov	r4,r2
811009ac:	11156840 	call	81115684 <fprintf>
811009b0:	00029f06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 1) {
811009b4:	e0bfbc17 	ldw	r2,-272(fp)
811009b8:	10800058 	cmpnei	r2,r2,1
811009bc:	1000101e 	bne	r2,zero,81100a00 <bDdr2EepromDump+0x1e4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009c0:	00e04534 	movhi	r3,33044
811009c4:	18dbff04 	addi	r3,r3,28668
811009c8:	00a04534 	movhi	r2,33044
811009cc:	10807604 	addi	r2,r2,472
811009d0:	1009883a 	mov	r4,r2
811009d4:	00800c04 	movi	r2,48
811009d8:	100d883a 	mov	r6,r2
811009dc:	200b883a 	mov	r5,r4
811009e0:	1809883a 	mov	r4,r3
811009e4:	11167340 	call	81116734 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e8:	d0a05417 	ldw	r2,-32432(gp)
811009ec:	01604534 	movhi	r5,33044
811009f0:	295bff04 	addi	r5,r5,28668
811009f4:	1009883a 	mov	r4,r2
811009f8:	11156840 	call	81115684 <fprintf>
811009fc:	00028c06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 2) {
81100a00:	e0bfbc17 	ldw	r2,-272(fp)
81100a04:	10800098 	cmpnei	r2,r2,2
81100a08:	1000101e 	bne	r2,zero,81100a4c <bDdr2EepromDump+0x230>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a0c:	00e04534 	movhi	r3,33044
81100a10:	18dbff04 	addi	r3,r3,28668
81100a14:	00a04534 	movhi	r2,33044
81100a18:	10808204 	addi	r2,r2,520
81100a1c:	1009883a 	mov	r4,r2
81100a20:	008007c4 	movi	r2,31
81100a24:	100d883a 	mov	r6,r2
81100a28:	200b883a 	mov	r5,r4
81100a2c:	1809883a 	mov	r4,r3
81100a30:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
81100a34:	d0a05417 	ldw	r2,-32432(gp)
81100a38:	01604534 	movhi	r5,33044
81100a3c:	295bff04 	addi	r5,r5,28668
81100a40:	1009883a 	mov	r4,r2
81100a44:	11156840 	call	81115684 <fprintf>
81100a48:	00027906 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 3) {
81100a4c:	e0bfbc17 	ldw	r2,-272(fp)
81100a50:	108000d8 	cmpnei	r2,r2,3
81100a54:	1000101e 	bne	r2,zero,81100a98 <bDdr2EepromDump+0x27c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a58:	00e04534 	movhi	r3,33044
81100a5c:	18dbff04 	addi	r3,r3,28668
81100a60:	00a04534 	movhi	r2,33044
81100a64:	10808a04 	addi	r2,r2,552
81100a68:	1009883a 	mov	r4,r2
81100a6c:	008009c4 	movi	r2,39
81100a70:	100d883a 	mov	r6,r2
81100a74:	200b883a 	mov	r5,r4
81100a78:	1809883a 	mov	r4,r3
81100a7c:	11167340 	call	81116734 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a80:	d0a05417 	ldw	r2,-32432(gp)
81100a84:	01604534 	movhi	r5,33044
81100a88:	295bff04 	addi	r5,r5,28668
81100a8c:	1009883a 	mov	r4,r2
81100a90:	11156840 	call	81115684 <fprintf>
81100a94:	00026606 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 4) {
81100a98:	e0bfbc17 	ldw	r2,-272(fp)
81100a9c:	10800118 	cmpnei	r2,r2,4
81100aa0:	1000101e 	bne	r2,zero,81100ae4 <bDdr2EepromDump+0x2c8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100aa4:	00e04534 	movhi	r3,33044
81100aa8:	18dbff04 	addi	r3,r3,28668
81100aac:	00a04534 	movhi	r2,33044
81100ab0:	10809404 	addi	r2,r2,592
81100ab4:	1009883a 	mov	r4,r2
81100ab8:	00800a84 	movi	r2,42
81100abc:	100d883a 	mov	r6,r2
81100ac0:	200b883a 	mov	r5,r4
81100ac4:	1809883a 	mov	r4,r3
81100ac8:	11167340 	call	81116734 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100acc:	d0a05417 	ldw	r2,-32432(gp)
81100ad0:	01604534 	movhi	r5,33044
81100ad4:	295bff04 	addi	r5,r5,28668
81100ad8:	1009883a 	mov	r4,r2
81100adc:	11156840 	call	81115684 <fprintf>
81100ae0:	00025306 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 5) {
81100ae4:	e0bfbc17 	ldw	r2,-272(fp)
81100ae8:	10800158 	cmpnei	r2,r2,5
81100aec:	1000101e 	bne	r2,zero,81100b30 <bDdr2EepromDump+0x314>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100af0:	00e04534 	movhi	r3,33044
81100af4:	18dbff04 	addi	r3,r3,28668
81100af8:	00a04534 	movhi	r2,33044
81100afc:	10809f04 	addi	r2,r2,636
81100b00:	1009883a 	mov	r4,r2
81100b04:	00800c04 	movi	r2,48
81100b08:	100d883a 	mov	r6,r2
81100b0c:	200b883a 	mov	r5,r4
81100b10:	1809883a 	mov	r4,r3
81100b14:	11167340 	call	81116734 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b18:	d0a05417 	ldw	r2,-32432(gp)
81100b1c:	01604534 	movhi	r5,33044
81100b20:	295bff04 	addi	r5,r5,28668
81100b24:	1009883a 	mov	r4,r2
81100b28:	11156840 	call	81115684 <fprintf>
81100b2c:	00024006 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 6) {
81100b30:	e0bfbc17 	ldw	r2,-272(fp)
81100b34:	10800198 	cmpnei	r2,r2,6
81100b38:	1000101e 	bne	r2,zero,81100b7c <bDdr2EepromDump+0x360>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b3c:	00e04534 	movhi	r3,33044
81100b40:	18dbff04 	addi	r3,r3,28668
81100b44:	00a04534 	movhi	r2,33044
81100b48:	1080ab04 	addi	r2,r2,684
81100b4c:	1009883a 	mov	r4,r2
81100b50:	00800544 	movi	r2,21
81100b54:	100d883a 	mov	r6,r2
81100b58:	200b883a 	mov	r5,r4
81100b5c:	1809883a 	mov	r4,r3
81100b60:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
81100b64:	d0a05417 	ldw	r2,-32432(gp)
81100b68:	01604534 	movhi	r5,33044
81100b6c:	295bff04 	addi	r5,r5,28668
81100b70:	1009883a 	mov	r4,r2
81100b74:	11156840 	call	81115684 <fprintf>
81100b78:	00022d06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 7) {
81100b7c:	e0bfbc17 	ldw	r2,-272(fp)
81100b80:	108001d8 	cmpnei	r2,r2,7
81100b84:	1000101e 	bne	r2,zero,81100bc8 <bDdr2EepromDump+0x3ac>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b88:	00e04534 	movhi	r3,33044
81100b8c:	18dbff04 	addi	r3,r3,28668
81100b90:	00a04534 	movhi	r2,33044
81100b94:	1080b104 	addi	r2,r2,708
81100b98:	1009883a 	mov	r4,r2
81100b9c:	00800804 	movi	r2,32
81100ba0:	100d883a 	mov	r6,r2
81100ba4:	200b883a 	mov	r5,r4
81100ba8:	1809883a 	mov	r4,r3
81100bac:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
81100bb0:	d0a05417 	ldw	r2,-32432(gp)
81100bb4:	01604534 	movhi	r5,33044
81100bb8:	295bff04 	addi	r5,r5,28668
81100bbc:	1009883a 	mov	r4,r2
81100bc0:	11156840 	call	81115684 <fprintf>
81100bc4:	00021a06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 16) {
81100bc8:	e0bfbc17 	ldw	r2,-272(fp)
81100bcc:	10800418 	cmpnei	r2,r2,16
81100bd0:	1000101e 	bne	r2,zero,81100c14 <bDdr2EepromDump+0x3f8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bd4:	00e04534 	movhi	r3,33044
81100bd8:	18dbff04 	addi	r3,r3,28668
81100bdc:	00a04534 	movhi	r2,33044
81100be0:	1080b904 	addi	r2,r2,740
81100be4:	1009883a 	mov	r4,r2
81100be8:	00800d04 	movi	r2,52
81100bec:	100d883a 	mov	r6,r2
81100bf0:	200b883a 	mov	r5,r4
81100bf4:	1809883a 	mov	r4,r3
81100bf8:	11167340 	call	81116734 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bfc:	d0a05417 	ldw	r2,-32432(gp)
81100c00:	01604534 	movhi	r5,33044
81100c04:	295bff04 	addi	r5,r5,28668
81100c08:	1009883a 	mov	r4,r2
81100c0c:	11156840 	call	81115684 <fprintf>
81100c10:	00020706 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 13) {
81100c14:	e0bfbc17 	ldw	r2,-272(fp)
81100c18:	10800358 	cmpnei	r2,r2,13
81100c1c:	1000101e 	bne	r2,zero,81100c60 <bDdr2EepromDump+0x444>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c20:	00e04534 	movhi	r3,33044
81100c24:	18dbff04 	addi	r3,r3,28668
81100c28:	00a04534 	movhi	r2,33044
81100c2c:	1080c604 	addi	r2,r2,792
81100c30:	1009883a 	mov	r4,r2
81100c34:	008005c4 	movi	r2,23
81100c38:	100d883a 	mov	r6,r2
81100c3c:	200b883a 	mov	r5,r4
81100c40:	1809883a 	mov	r4,r3
81100c44:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
81100c48:	d0a05417 	ldw	r2,-32432(gp)
81100c4c:	01604534 	movhi	r5,33044
81100c50:	295bff04 	addi	r5,r5,28668
81100c54:	1009883a 	mov	r4,r2
81100c58:	11156840 	call	81115684 <fprintf>
81100c5c:	0001f406 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 14) {
81100c60:	e0bfbc17 	ldw	r2,-272(fp)
81100c64:	10800398 	cmpnei	r2,r2,14
81100c68:	1000101e 	bne	r2,zero,81100cac <bDdr2EepromDump+0x490>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c6c:	00e04534 	movhi	r3,33044
81100c70:	18dbff04 	addi	r3,r3,28668
81100c74:	00a04534 	movhi	r2,33044
81100c78:	1080cc04 	addi	r2,r2,816
81100c7c:	1009883a 	mov	r4,r2
81100c80:	008004c4 	movi	r2,19
81100c84:	100d883a 	mov	r6,r2
81100c88:	200b883a 	mov	r5,r4
81100c8c:	1809883a 	mov	r4,r3
81100c90:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
81100c94:	d0a05417 	ldw	r2,-32432(gp)
81100c98:	01604534 	movhi	r5,33044
81100c9c:	295bff04 	addi	r5,r5,28668
81100ca0:	1009883a 	mov	r4,r2
81100ca4:	11156840 	call	81115684 <fprintf>
81100ca8:	0001e106 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 17) {
81100cac:	e0bfbc17 	ldw	r2,-272(fp)
81100cb0:	10800458 	cmpnei	r2,r2,17
81100cb4:	1000101e 	bne	r2,zero,81100cf8 <bDdr2EepromDump+0x4dc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb8:	00e04534 	movhi	r3,33044
81100cbc:	18dbff04 	addi	r3,r3,28668
81100cc0:	00a04534 	movhi	r2,33044
81100cc4:	1080d104 	addi	r2,r2,836
81100cc8:	1009883a 	mov	r4,r2
81100ccc:	00800684 	movi	r2,26
81100cd0:	100d883a 	mov	r6,r2
81100cd4:	200b883a 	mov	r5,r4
81100cd8:	1809883a 	mov	r4,r3
81100cdc:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
81100ce0:	d0a05417 	ldw	r2,-32432(gp)
81100ce4:	01604534 	movhi	r5,33044
81100ce8:	295bff04 	addi	r5,r5,28668
81100cec:	1009883a 	mov	r4,r2
81100cf0:	11156840 	call	81115684 <fprintf>
81100cf4:	0001ce06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 18) {
81100cf8:	e0bfbc17 	ldw	r2,-272(fp)
81100cfc:	10800498 	cmpnei	r2,r2,18
81100d00:	1000101e 	bne	r2,zero,81100d44 <bDdr2EepromDump+0x528>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d04:	00e04534 	movhi	r3,33044
81100d08:	18dbff04 	addi	r3,r3,28668
81100d0c:	00a04534 	movhi	r2,33044
81100d10:	1080d804 	addi	r2,r2,864
81100d14:	1009883a 	mov	r4,r2
81100d18:	00800d44 	movi	r2,53
81100d1c:	100d883a 	mov	r6,r2
81100d20:	200b883a 	mov	r5,r4
81100d24:	1809883a 	mov	r4,r3
81100d28:	11167340 	call	81116734 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d2c:	d0a05417 	ldw	r2,-32432(gp)
81100d30:	01604534 	movhi	r5,33044
81100d34:	295bff04 	addi	r5,r5,28668
81100d38:	1009883a 	mov	r4,r2
81100d3c:	11156840 	call	81115684 <fprintf>
81100d40:	0001bb06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 20) {
81100d44:	e0bfbc17 	ldw	r2,-272(fp)
81100d48:	10800518 	cmpnei	r2,r2,20
81100d4c:	1000101e 	bne	r2,zero,81100d90 <bDdr2EepromDump+0x574>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d50:	00e04534 	movhi	r3,33044
81100d54:	18dbff04 	addi	r3,r3,28668
81100d58:	00a04534 	movhi	r2,33044
81100d5c:	1080e604 	addi	r2,r2,920
81100d60:	1009883a 	mov	r4,r2
81100d64:	00801204 	movi	r2,72
81100d68:	100d883a 	mov	r6,r2
81100d6c:	200b883a 	mov	r5,r4
81100d70:	1809883a 	mov	r4,r3
81100d74:	11167340 	call	81116734 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d78:	d0a05417 	ldw	r2,-32432(gp)
81100d7c:	01604534 	movhi	r5,33044
81100d80:	295bff04 	addi	r5,r5,28668
81100d84:	1009883a 	mov	r4,r2
81100d88:	11156840 	call	81115684 <fprintf>
81100d8c:	0001a806 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 22) {
81100d90:	e0bfbc17 	ldw	r2,-272(fp)
81100d94:	10800598 	cmpnei	r2,r2,22
81100d98:	1000101e 	bne	r2,zero,81100ddc <bDdr2EepromDump+0x5c0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d9c:	00e04534 	movhi	r3,33044
81100da0:	18dbff04 	addi	r3,r3,28668
81100da4:	00a04534 	movhi	r2,33044
81100da8:	1080f804 	addi	r2,r2,992
81100dac:	1009883a 	mov	r4,r2
81100db0:	00800784 	movi	r2,30
81100db4:	100d883a 	mov	r6,r2
81100db8:	200b883a 	mov	r5,r4
81100dbc:	1809883a 	mov	r4,r3
81100dc0:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
81100dc4:	d0a05417 	ldw	r2,-32432(gp)
81100dc8:	01604534 	movhi	r5,33044
81100dcc:	295bff04 	addi	r5,r5,28668
81100dd0:	1009883a 	mov	r4,r2
81100dd4:	11156840 	call	81115684 <fprintf>
81100dd8:	00019506 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 27) {
81100ddc:	e0bfbc17 	ldw	r2,-272(fp)
81100de0:	108006d8 	cmpnei	r2,r2,27
81100de4:	1000101e 	bne	r2,zero,81100e28 <bDdr2EepromDump+0x60c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de8:	00e04534 	movhi	r3,33044
81100dec:	18dbff04 	addi	r3,r3,28668
81100df0:	00a04534 	movhi	r2,33044
81100df4:	10810004 	addi	r2,r2,1024
81100df8:	1009883a 	mov	r4,r2
81100dfc:	00800a04 	movi	r2,40
81100e00:	100d883a 	mov	r6,r2
81100e04:	200b883a 	mov	r5,r4
81100e08:	1809883a 	mov	r4,r3
81100e0c:	11167340 	call	81116734 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e10:	d0a05417 	ldw	r2,-32432(gp)
81100e14:	01604534 	movhi	r5,33044
81100e18:	295bff04 	addi	r5,r5,28668
81100e1c:	1009883a 	mov	r4,r2
81100e20:	11156840 	call	81115684 <fprintf>
81100e24:	00018206 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 28) {
81100e28:	e0bfbc17 	ldw	r2,-272(fp)
81100e2c:	10800718 	cmpnei	r2,r2,28
81100e30:	1000101e 	bne	r2,zero,81100e74 <bDdr2EepromDump+0x658>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e34:	00e04534 	movhi	r3,33044
81100e38:	18dbff04 	addi	r3,r3,28668
81100e3c:	00a04534 	movhi	r2,33044
81100e40:	10810a04 	addi	r2,r2,1064
81100e44:	1009883a 	mov	r4,r2
81100e48:	00800cc4 	movi	r2,51
81100e4c:	100d883a 	mov	r6,r2
81100e50:	200b883a 	mov	r5,r4
81100e54:	1809883a 	mov	r4,r3
81100e58:	11167340 	call	81116734 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e5c:	d0a05417 	ldw	r2,-32432(gp)
81100e60:	01604534 	movhi	r5,33044
81100e64:	295bff04 	addi	r5,r5,28668
81100e68:	1009883a 	mov	r4,r2
81100e6c:	11156840 	call	81115684 <fprintf>
81100e70:	00016f06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 29) {
81100e74:	e0bfbc17 	ldw	r2,-272(fp)
81100e78:	10800758 	cmpnei	r2,r2,29
81100e7c:	1000101e 	bne	r2,zero,81100ec0 <bDdr2EepromDump+0x6a4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e80:	00e04534 	movhi	r3,33044
81100e84:	18dbff04 	addi	r3,r3,28668
81100e88:	00a04534 	movhi	r2,33044
81100e8c:	10811704 	addi	r2,r2,1116
81100e90:	1009883a 	mov	r4,r2
81100e94:	008009c4 	movi	r2,39
81100e98:	100d883a 	mov	r6,r2
81100e9c:	200b883a 	mov	r5,r4
81100ea0:	1809883a 	mov	r4,r3
81100ea4:	11167340 	call	81116734 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea8:	d0a05417 	ldw	r2,-32432(gp)
81100eac:	01604534 	movhi	r5,33044
81100eb0:	295bff04 	addi	r5,r5,28668
81100eb4:	1009883a 	mov	r4,r2
81100eb8:	11156840 	call	81115684 <fprintf>
81100ebc:	00015c06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 30) {
81100ec0:	e0bfbc17 	ldw	r2,-272(fp)
81100ec4:	10800798 	cmpnei	r2,r2,30
81100ec8:	1000101e 	bne	r2,zero,81100f0c <bDdr2EepromDump+0x6f0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ecc:	00e04534 	movhi	r3,33044
81100ed0:	18dbff04 	addi	r3,r3,28668
81100ed4:	00a04534 	movhi	r2,33044
81100ed8:	10812104 	addi	r2,r2,1156
81100edc:	1009883a 	mov	r4,r2
81100ee0:	00800b04 	movi	r2,44
81100ee4:	100d883a 	mov	r6,r2
81100ee8:	200b883a 	mov	r5,r4
81100eec:	1809883a 	mov	r4,r3
81100ef0:	11167340 	call	81116734 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100ef4:	d0a05417 	ldw	r2,-32432(gp)
81100ef8:	01604534 	movhi	r5,33044
81100efc:	295bff04 	addi	r5,r5,28668
81100f00:	1009883a 	mov	r4,r2
81100f04:	11156840 	call	81115684 <fprintf>
81100f08:	00014906 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 31) {
81100f0c:	e0bfbc17 	ldw	r2,-272(fp)
81100f10:	108007d8 	cmpnei	r2,r2,31
81100f14:	1000101e 	bne	r2,zero,81100f58 <bDdr2EepromDump+0x73c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f18:	00e04534 	movhi	r3,33044
81100f1c:	18dbff04 	addi	r3,r3,28668
81100f20:	00a04534 	movhi	r2,33044
81100f24:	10812c04 	addi	r2,r2,1200
81100f28:	1009883a 	mov	r4,r2
81100f2c:	008010c4 	movi	r2,67
81100f30:	100d883a 	mov	r6,r2
81100f34:	200b883a 	mov	r5,r4
81100f38:	1809883a 	mov	r4,r3
81100f3c:	11167340 	call	81116734 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f40:	d0a05417 	ldw	r2,-32432(gp)
81100f44:	01604534 	movhi	r5,33044
81100f48:	295bff04 	addi	r5,r5,28668
81100f4c:	1009883a 	mov	r4,r2
81100f50:	11156840 	call	81115684 <fprintf>
81100f54:	00013606 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 36) {
81100f58:	e0bfbc17 	ldw	r2,-272(fp)
81100f5c:	10800918 	cmpnei	r2,r2,36
81100f60:	1000101e 	bne	r2,zero,81100fa4 <bDdr2EepromDump+0x788>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f64:	00e04534 	movhi	r3,33044
81100f68:	18dbff04 	addi	r3,r3,28668
81100f6c:	00a04534 	movhi	r2,33044
81100f70:	10813d04 	addi	r2,r2,1268
81100f74:	1009883a 	mov	r4,r2
81100f78:	00800a84 	movi	r2,42
81100f7c:	100d883a 	mov	r6,r2
81100f80:	200b883a 	mov	r5,r4
81100f84:	1809883a 	mov	r4,r3
81100f88:	11167340 	call	81116734 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f8c:	d0a05417 	ldw	r2,-32432(gp)
81100f90:	01604534 	movhi	r5,33044
81100f94:	295bff04 	addi	r5,r5,28668
81100f98:	1009883a 	mov	r4,r2
81100f9c:	11156840 	call	81115684 <fprintf>
81100fa0:	00012306 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 37) {
81100fa4:	e0bfbc17 	ldw	r2,-272(fp)
81100fa8:	10800958 	cmpnei	r2,r2,37
81100fac:	1000101e 	bne	r2,zero,81100ff0 <bDdr2EepromDump+0x7d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fb0:	00e04534 	movhi	r3,33044
81100fb4:	18dbff04 	addi	r3,r3,28668
81100fb8:	00a04534 	movhi	r2,33044
81100fbc:	10814804 	addi	r2,r2,1312
81100fc0:	1009883a 	mov	r4,r2
81100fc4:	00800cc4 	movi	r2,51
81100fc8:	100d883a 	mov	r6,r2
81100fcc:	200b883a 	mov	r5,r4
81100fd0:	1809883a 	mov	r4,r3
81100fd4:	11167340 	call	81116734 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd8:	d0a05417 	ldw	r2,-32432(gp)
81100fdc:	01604534 	movhi	r5,33044
81100fe0:	295bff04 	addi	r5,r5,28668
81100fe4:	1009883a 	mov	r4,r2
81100fe8:	11156840 	call	81115684 <fprintf>
81100fec:	00011006 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 38) {
81100ff0:	e0bfbc17 	ldw	r2,-272(fp)
81100ff4:	10800998 	cmpnei	r2,r2,38
81100ff8:	1000101e 	bne	r2,zero,8110103c <bDdr2EepromDump+0x820>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ffc:	00e04534 	movhi	r3,33044
81101000:	18dbff04 	addi	r3,r3,28668
81101004:	00a04534 	movhi	r2,33044
81101008:	10815504 	addi	r2,r2,1364
8110100c:	1009883a 	mov	r4,r2
81101010:	00800dc4 	movi	r2,55
81101014:	100d883a 	mov	r6,r2
81101018:	200b883a 	mov	r5,r4
8110101c:	1809883a 	mov	r4,r3
81101020:	11167340 	call	81116734 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
81101024:	d0a05417 	ldw	r2,-32432(gp)
81101028:	01604534 	movhi	r5,33044
8110102c:	295bff04 	addi	r5,r5,28668
81101030:	1009883a 	mov	r4,r2
81101034:	11156840 	call	81115684 <fprintf>
81101038:	0000fd06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 41) {
8110103c:	e0bfbc17 	ldw	r2,-272(fp)
81101040:	10800a58 	cmpnei	r2,r2,41
81101044:	1000101e 	bne	r2,zero,81101088 <bDdr2EepromDump+0x86c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101048:	00e04534 	movhi	r3,33044
8110104c:	18dbff04 	addi	r3,r3,28668
81101050:	00a04534 	movhi	r2,33044
81101054:	10816304 	addi	r2,r2,1420
81101058:	1009883a 	mov	r4,r2
8110105c:	00800c84 	movi	r2,50
81101060:	100d883a 	mov	r6,r2
81101064:	200b883a 	mov	r5,r4
81101068:	1809883a 	mov	r4,r3
8110106c:	11167340 	call	81116734 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101070:	d0a05417 	ldw	r2,-32432(gp)
81101074:	01604534 	movhi	r5,33044
81101078:	295bff04 	addi	r5,r5,28668
8110107c:	1009883a 	mov	r4,r2
81101080:	11156840 	call	81115684 <fprintf>
81101084:	0000ea06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 42) {
81101088:	e0bfbc17 	ldw	r2,-272(fp)
8110108c:	10800a98 	cmpnei	r2,r2,42
81101090:	1000101e 	bne	r2,zero,811010d4 <bDdr2EepromDump+0x8b8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101094:	00e04534 	movhi	r3,33044
81101098:	18dbff04 	addi	r3,r3,28668
8110109c:	00a04534 	movhi	r2,33044
811010a0:	10817004 	addi	r2,r2,1472
811010a4:	1009883a 	mov	r4,r2
811010a8:	00800cc4 	movi	r2,51
811010ac:	100d883a 	mov	r6,r2
811010b0:	200b883a 	mov	r5,r4
811010b4:	1809883a 	mov	r4,r3
811010b8:	11167340 	call	81116734 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010bc:	d0a05417 	ldw	r2,-32432(gp)
811010c0:	01604534 	movhi	r5,33044
811010c4:	295bff04 	addi	r5,r5,28668
811010c8:	1009883a 	mov	r4,r2
811010cc:	11156840 	call	81115684 <fprintf>
811010d0:	0000d706 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 62) {
811010d4:	e0bfbc17 	ldw	r2,-272(fp)
811010d8:	10800f98 	cmpnei	r2,r2,62
811010dc:	1000101e 	bne	r2,zero,81101120 <bDdr2EepromDump+0x904>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010e0:	00e04534 	movhi	r3,33044
811010e4:	18dbff04 	addi	r3,r3,28668
811010e8:	00a04534 	movhi	r2,33044
811010ec:	10817d04 	addi	r2,r2,1524
811010f0:	1009883a 	mov	r4,r2
811010f4:	00800404 	movi	r2,16
811010f8:	100d883a 	mov	r6,r2
811010fc:	200b883a 	mov	r5,r4
81101100:	1809883a 	mov	r4,r3
81101104:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
81101108:	d0a05417 	ldw	r2,-32432(gp)
8110110c:	01604534 	movhi	r5,33044
81101110:	295bff04 	addi	r5,r5,28668
81101114:	1009883a 	mov	r4,r2
81101118:	11156840 	call	81115684 <fprintf>
8110111c:	0000c406 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 63) {
81101120:	e0bfbc17 	ldw	r2,-272(fp)
81101124:	10800fd8 	cmpnei	r2,r2,63
81101128:	10001f1e 	bne	r2,zero,811011a8 <bDdr2EepromDump+0x98c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
8110112c:	00a04534 	movhi	r2,33044
81101130:	109bff04 	addi	r2,r2,28668
81101134:	00c00a04 	movi	r3,40
81101138:	10c00005 	stb	r3,0(r2)
8110113c:	00c010c4 	movi	r3,67
81101140:	10c00045 	stb	r3,1(r2)
81101144:	00c01a04 	movi	r3,104
81101148:	10c00085 	stb	r3,2(r2)
8110114c:	00c01944 	movi	r3,101
81101150:	10c000c5 	stb	r3,3(r2)
81101154:	00c018c4 	movi	r3,99
81101158:	10c00105 	stb	r3,4(r2)
8110115c:	00c01ac4 	movi	r3,107
81101160:	10c00145 	stb	r3,5(r2)
81101164:	00c01cc4 	movi	r3,115
81101168:	10c00185 	stb	r3,6(r2)
8110116c:	00c01d44 	movi	r3,117
81101170:	10c001c5 	stb	r3,7(r2)
81101174:	00c01b44 	movi	r3,109
81101178:	10c00205 	stb	r3,8(r2)
8110117c:	00c00a44 	movi	r3,41
81101180:	10c00245 	stb	r3,9(r2)
81101184:	00c00284 	movi	r3,10
81101188:	10c00285 	stb	r3,10(r2)
8110118c:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101190:	d0a05417 	ldw	r2,-32432(gp)
81101194:	01604534 	movhi	r5,33044
81101198:	295bff04 	addi	r5,r5,28668
8110119c:	1009883a 	mov	r4,r2
811011a0:	11156840 	call	81115684 <fprintf>
811011a4:	0000a206 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 64) {
811011a8:	e0bfbc17 	ldw	r2,-272(fp)
811011ac:	10801018 	cmpnei	r2,r2,64
811011b0:	1000101e 	bne	r2,zero,811011f4 <bDdr2EepromDump+0x9d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011b4:	00e04534 	movhi	r3,33044
811011b8:	18dbff04 	addi	r3,r3,28668
811011bc:	00a04534 	movhi	r2,33044
811011c0:	10818104 	addi	r2,r2,1540
811011c4:	1009883a 	mov	r4,r2
811011c8:	00800804 	movi	r2,32
811011cc:	100d883a 	mov	r6,r2
811011d0:	200b883a 	mov	r5,r4
811011d4:	1809883a 	mov	r4,r3
811011d8:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
811011dc:	d0a05417 	ldw	r2,-32432(gp)
811011e0:	01604534 	movhi	r5,33044
811011e4:	295bff04 	addi	r5,r5,28668
811011e8:	1009883a 	mov	r4,r2
811011ec:	11156840 	call	81115684 <fprintf>
811011f0:	00008f06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 72) {
811011f4:	e0bfbc17 	ldw	r2,-272(fp)
811011f8:	10801218 	cmpnei	r2,r2,72
811011fc:	1000101e 	bne	r2,zero,81101240 <bDdr2EepromDump+0xa24>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101200:	00e04534 	movhi	r3,33044
81101204:	18dbff04 	addi	r3,r3,28668
81101208:	00a04534 	movhi	r2,33044
8110120c:	10818904 	addi	r2,r2,1572
81101210:	1009883a 	mov	r4,r2
81101214:	00800dc4 	movi	r2,55
81101218:	100d883a 	mov	r6,r2
8110121c:	200b883a 	mov	r5,r4
81101220:	1809883a 	mov	r4,r3
81101224:	11167340 	call	81116734 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101228:	d0a05417 	ldw	r2,-32432(gp)
8110122c:	01604534 	movhi	r5,33044
81101230:	295bff04 	addi	r5,r5,28668
81101234:	1009883a 	mov	r4,r2
81101238:	11156840 	call	81115684 <fprintf>
8110123c:	00007c06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 73) {
81101240:	e0bfbc17 	ldw	r2,-272(fp)
81101244:	10801258 	cmpnei	r2,r2,73
81101248:	1000101e 	bne	r2,zero,8110128c <bDdr2EepromDump+0xa70>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
8110124c:	00e04534 	movhi	r3,33044
81101250:	18dbff04 	addi	r3,r3,28668
81101254:	00a04534 	movhi	r2,33044
81101258:	10819704 	addi	r2,r2,1628
8110125c:	1009883a 	mov	r4,r2
81101260:	00800784 	movi	r2,30
81101264:	100d883a 	mov	r6,r2
81101268:	200b883a 	mov	r5,r4
8110126c:	1809883a 	mov	r4,r3
81101270:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
81101274:	d0a05417 	ldw	r2,-32432(gp)
81101278:	01604534 	movhi	r5,33044
8110127c:	295bff04 	addi	r5,r5,28668
81101280:	1009883a 	mov	r4,r2
81101284:	11156840 	call	81115684 <fprintf>
81101288:	00006906 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 91) {
8110128c:	e0bfbc17 	ldw	r2,-272(fp)
81101290:	108016d8 	cmpnei	r2,r2,91
81101294:	1000101e 	bne	r2,zero,811012d8 <bDdr2EepromDump+0xabc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101298:	00e04534 	movhi	r3,33044
8110129c:	18dbff04 	addi	r3,r3,28668
811012a0:	00a04534 	movhi	r2,33044
811012a4:	10819f04 	addi	r2,r2,1660
811012a8:	1009883a 	mov	r4,r2
811012ac:	00800804 	movi	r2,32
811012b0:	100d883a 	mov	r6,r2
811012b4:	200b883a 	mov	r5,r4
811012b8:	1809883a 	mov	r4,r3
811012bc:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
811012c0:	d0a05417 	ldw	r2,-32432(gp)
811012c4:	01604534 	movhi	r5,33044
811012c8:	295bff04 	addi	r5,r5,28668
811012cc:	1009883a 	mov	r4,r2
811012d0:	11156840 	call	81115684 <fprintf>
811012d4:	00005606 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 93) {
811012d8:	e0bfbc17 	ldw	r2,-272(fp)
811012dc:	10801758 	cmpnei	r2,r2,93
811012e0:	1000101e 	bne	r2,zero,81101324 <bDdr2EepromDump+0xb08>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012e4:	00e04534 	movhi	r3,33044
811012e8:	18dbff04 	addi	r3,r3,28668
811012ec:	00a04534 	movhi	r2,33044
811012f0:	1081a704 	addi	r2,r2,1692
811012f4:	1009883a 	mov	r4,r2
811012f8:	008009c4 	movi	r2,39
811012fc:	100d883a 	mov	r6,r2
81101300:	200b883a 	mov	r5,r4
81101304:	1809883a 	mov	r4,r3
81101308:	11167340 	call	81116734 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
8110130c:	d0a05417 	ldw	r2,-32432(gp)
81101310:	01604534 	movhi	r5,33044
81101314:	295bff04 	addi	r5,r5,28668
81101318:	1009883a 	mov	r4,r2
8110131c:	11156840 	call	81115684 <fprintf>
81101320:	00004306 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 94) {
81101324:	e0bfbc17 	ldw	r2,-272(fp)
81101328:	10801798 	cmpnei	r2,r2,94
8110132c:	1000101e 	bne	r2,zero,81101370 <bDdr2EepromDump+0xb54>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101330:	00e04534 	movhi	r3,33044
81101334:	18dbff04 	addi	r3,r3,28668
81101338:	00a04534 	movhi	r2,33044
8110133c:	1081b104 	addi	r2,r2,1732
81101340:	1009883a 	mov	r4,r2
81101344:	008006c4 	movi	r2,27
81101348:	100d883a 	mov	r6,r2
8110134c:	200b883a 	mov	r5,r4
81101350:	1809883a 	mov	r4,r3
81101354:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
81101358:	d0a05417 	ldw	r2,-32432(gp)
8110135c:	01604534 	movhi	r5,33044
81101360:	295bff04 	addi	r5,r5,28668
81101364:	1009883a 	mov	r4,r2
81101368:	11156840 	call	81115684 <fprintf>
8110136c:	00003006 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 95) {
81101370:	e0bfbc17 	ldw	r2,-272(fp)
81101374:	108017d8 	cmpnei	r2,r2,95
81101378:	1000101e 	bne	r2,zero,811013bc <bDdr2EepromDump+0xba0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110137c:	00e04534 	movhi	r3,33044
81101380:	18dbff04 	addi	r3,r3,28668
81101384:	00a04534 	movhi	r2,33044
81101388:	1081b804 	addi	r2,r2,1760
8110138c:	1009883a 	mov	r4,r2
81101390:	00800a04 	movi	r2,40
81101394:	100d883a 	mov	r6,r2
81101398:	200b883a 	mov	r5,r4
8110139c:	1809883a 	mov	r4,r3
811013a0:	11167340 	call	81116734 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
811013a4:	d0a05417 	ldw	r2,-32432(gp)
811013a8:	01604534 	movhi	r5,33044
811013ac:	295bff04 	addi	r5,r5,28668
811013b0:	1009883a 	mov	r4,r2
811013b4:	11156840 	call	81115684 <fprintf>
811013b8:	00001d06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 99) {
811013bc:	e0bfbc17 	ldw	r2,-272(fp)
811013c0:	108018d8 	cmpnei	r2,r2,99
811013c4:	1000101e 	bne	r2,zero,81101408 <bDdr2EepromDump+0xbec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c8:	00e04534 	movhi	r3,33044
811013cc:	18dbff04 	addi	r3,r3,28668
811013d0:	00a04534 	movhi	r2,33044
811013d4:	1081c204 	addi	r2,r2,1800
811013d8:	1009883a 	mov	r4,r2
811013dc:	00800984 	movi	r2,38
811013e0:	100d883a 	mov	r6,r2
811013e4:	200b883a 	mov	r5,r4
811013e8:	1809883a 	mov	r4,r3
811013ec:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
811013f0:	d0a05417 	ldw	r2,-32432(gp)
811013f4:	01604534 	movhi	r5,33044
811013f8:	295bff04 	addi	r5,r5,28668
811013fc:	1009883a 	mov	r4,r2
81101400:	11156840 	call	81115684 <fprintf>
81101404:	00000a06 	br	81101430 <bDdr2EepromDump+0xc14>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101408:	00a04534 	movhi	r2,33044
8110140c:	109bff04 	addi	r2,r2,28668
81101410:	00c00284 	movi	r3,10
81101414:	10c00005 	stb	r3,0(r2)
81101418:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
8110141c:	d0a05417 	ldw	r2,-32432(gp)
81101420:	01604534 	movhi	r5,33044
81101424:	295bff04 	addi	r5,r5,28668
81101428:	1009883a 	mov	r4,r2
8110142c:	11156840 	call	81115684 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101430:	e0bfbc17 	ldw	r2,-272(fp)
81101434:	10800044 	addi	r2,r2,1
81101438:	e0bfbc15 	stw	r2,-272(fp)
8110143c:	e0bfbc17 	ldw	r2,-272(fp)
81101440:	10804008 	cmpgei	r2,r2,256
81101444:	1000121e 	bne	r2,zero,81101490 <bDdr2EepromDump+0xc74>
81101448:	e0bfbe17 	ldw	r2,-264(fp)
8110144c:	103d451e 	bne	r2,zero,81100964 <__reset+0xfb0e0964>
81101450:	00000f06 	br	81101490 <bDdr2EepromDump+0xc74>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
81101454:	00e04534 	movhi	r3,33044
81101458:	18dbff04 	addi	r3,r3,28668
8110145c:	00a04534 	movhi	r2,33044
81101460:	1081cc04 	addi	r2,r2,1840
81101464:	1009883a 	mov	r4,r2
81101468:	008005c4 	movi	r2,23
8110146c:	100d883a 	mov	r6,r2
81101470:	200b883a 	mov	r5,r4
81101474:	1809883a 	mov	r4,r3
81101478:	11167340 	call	81116734 <memcpy>
		debug(fp, cDebugBuffer);
8110147c:	d0a05417 	ldw	r2,-32432(gp)
81101480:	01604534 	movhi	r5,33044
81101484:	295bff04 	addi	r5,r5,28668
81101488:	1009883a 	mov	r4,r2
8110148c:	11156840 	call	81115684 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101490:	00a04534 	movhi	r2,33044
81101494:	109bff04 	addi	r2,r2,28668
81101498:	00c00284 	movi	r3,10
8110149c:	10c00005 	stb	r3,0(r2)
811014a0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811014a4:	d0a05417 	ldw	r2,-32432(gp)
811014a8:	01604534 	movhi	r5,33044
811014ac:	295bff04 	addi	r5,r5,28668
811014b0:	1009883a 	mov	r4,r2
811014b4:	11156840 	call	81115684 <fprintf>
#endif

	return bSuccess;
811014b8:	e0bfbe17 	ldw	r2,-264(fp)
}
811014bc:	e037883a 	mov	sp,fp
811014c0:	dfc00117 	ldw	ra,4(sp)
811014c4:	df000017 	ldw	fp,0(sp)
811014c8:	dec00204 	addi	sp,sp,8
811014cc:	f800283a 	ret

811014d0 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014d0:	defffb04 	addi	sp,sp,-20
811014d4:	de00012e 	bgeu	sp,et,811014dc <bDdr2SwitchMemory+0xc>
811014d8:	003b68fa 	trap	3
811014dc:	dfc00415 	stw	ra,16(sp)
811014e0:	df000315 	stw	fp,12(sp)
811014e4:	df000304 	addi	fp,sp,12
811014e8:	2005883a 	mov	r2,r4
811014ec:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014f0:	00a04834 	movhi	r2,33056
811014f4:	108c2204 	addi	r2,r2,12424
811014f8:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014fc:	00800044 	movi	r2,1
81101500:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
81101504:	e0bfff03 	ldbu	r2,-4(fp)
81101508:	10c00060 	cmpeqi	r3,r2,1
8110150c:	1800031e 	bne	r3,zero,8110151c <bDdr2SwitchMemory+0x4c>
81101510:	108000a0 	cmpeqi	r2,r2,2
81101514:	1000041e 	bne	r2,zero,81101528 <bDdr2SwitchMemory+0x58>
81101518:	00000706 	br	81101538 <bDdr2SwitchMemory+0x68>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	10000015 	stw	zero,0(r2)
		break;
81101524:	00001406 	br	81101578 <bDdr2SwitchMemory+0xa8>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
81101528:	e0bffe17 	ldw	r2,-8(fp)
8110152c:	00e00034 	movhi	r3,32768
81101530:	10c00015 	stw	r3,0(r2)
		break;
81101534:	00001006 	br	81101578 <bDdr2SwitchMemory+0xa8>
	default:
		bSuccess = FALSE;
81101538:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
8110153c:	00e04534 	movhi	r3,33044
81101540:	18dbff04 	addi	r3,r3,28668
81101544:	00a04534 	movhi	r2,33044
81101548:	1081d204 	addi	r2,r2,1864
8110154c:	1009883a 	mov	r4,r2
81101550:	00800f04 	movi	r2,60
81101554:	100d883a 	mov	r6,r2
81101558:	200b883a 	mov	r5,r4
8110155c:	1809883a 	mov	r4,r3
81101560:	11167340 	call	81116734 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101564:	d0a05417 	ldw	r2,-32432(gp)
81101568:	01604534 	movhi	r5,33044
8110156c:	295bff04 	addi	r5,r5,28668
81101570:	1009883a 	mov	r4,r2
81101574:	11156840 	call	81115684 <fprintf>
		;
#endif
	}

	return bSuccess;
81101578:	e0bffd17 	ldw	r2,-12(fp)
}
8110157c:	e037883a 	mov	sp,fp
81101580:	dfc00117 	ldw	ra,4(sp)
81101584:	df000017 	ldw	fp,0(sp)
81101588:	dec00204 	addi	sp,sp,8
8110158c:	f800283a 	ret

81101590 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mémoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101590:	deffe204 	addi	sp,sp,-120
81101594:	de00012e 	bgeu	sp,et,8110159c <bDdr2MemoryWriteTest+0xc>
81101598:	003b68fa 	trap	3
8110159c:	dfc01d15 	stw	ra,116(sp)
811015a0:	df001c15 	stw	fp,112(sp)
811015a4:	dc401b15 	stw	r17,108(sp)
811015a8:	dc001a15 	stw	r16,104(sp)
811015ac:	df001c04 	addi	fp,sp,112
811015b0:	2005883a 	mov	r2,r4
811015b4:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015b8:	00e04534 	movhi	r3,33044
811015bc:	18dbff04 	addi	r3,r3,28668
811015c0:	00a04534 	movhi	r2,33044
811015c4:	1081e104 	addi	r2,r2,1924
811015c8:	1009883a 	mov	r4,r2
811015cc:	00800a04 	movi	r2,40
811015d0:	100d883a 	mov	r6,r2
811015d4:	200b883a 	mov	r5,r4
811015d8:	1809883a 	mov	r4,r3
811015dc:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
811015e0:	d0a05417 	ldw	r2,-32432(gp)
811015e4:	01604534 	movhi	r5,33044
811015e8:	295bff04 	addi	r5,r5,28668
811015ec:	1009883a 	mov	r4,r2
811015f0:	11156840 	call	81115684 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015f4:	00800044 	movi	r2,1
811015f8:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015fc:	e0bffd03 	ldbu	r2,-12(fp)
81101600:	10c00060 	cmpeqi	r3,r2,1
81101604:	1800031e 	bne	r3,zero,81101614 <bDdr2MemoryWriteTest+0x84>
81101608:	108000a0 	cmpeqi	r2,r2,2
8110160c:	1000081e 	bne	r2,zero,81101630 <bDdr2MemoryWriteTest+0xa0>
81101610:	00000e06 	br	8110164c <bDdr2MemoryWriteTest+0xbc>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101614:	e0bffd03 	ldbu	r2,-12(fp)
81101618:	1009883a 	mov	r4,r2
8110161c:	11014d00 	call	811014d0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101620:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101624:	00a00034 	movhi	r2,32768
81101628:	e0bfe615 	stw	r2,-104(fp)
		break;
8110162c:	00001906 	br	81101694 <bDdr2MemoryWriteTest+0x104>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101630:	e0bffd03 	ldbu	r2,-12(fp)
81101634:	1009883a 	mov	r4,r2
81101638:	11014d00 	call	811014d0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110163c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101640:	00a00034 	movhi	r2,32768
81101644:	e0bfe615 	stw	r2,-104(fp)
		break;
81101648:	00001206 	br	81101694 <bDdr2MemoryWriteTest+0x104>
	default:
		bSuccess = FALSE;
8110164c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101650:	00e04534 	movhi	r3,33044
81101654:	18dbff04 	addi	r3,r3,28668
81101658:	00a04534 	movhi	r2,33044
8110165c:	10bff204 	addi	r2,r2,-56
81101660:	1009883a 	mov	r4,r2
81101664:	00800bc4 	movi	r2,47
81101668:	100d883a 	mov	r6,r2
8110166c:	200b883a 	mov	r5,r4
81101670:	1809883a 	mov	r4,r3
81101674:	11167340 	call	81116734 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101678:	d0a05417 	ldw	r2,-32432(gp)
8110167c:	01604534 	movhi	r5,33044
81101680:	295bff04 	addi	r5,r5,28668
81101684:	1009883a 	mov	r4,r2
81101688:	11156840 	call	81115684 <fprintf>
		;
#endif
		return bSuccess;
8110168c:	e0bfed17 	ldw	r2,-76(fp)
81101690:	00011806 	br	81101af4 <bDdr2MemoryWriteTest+0x564>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101694:	e0bfe617 	ldw	r2,-104(fp)
81101698:	1004d53a 	srli	r2,r2,20
8110169c:	100d883a 	mov	r6,r2
811016a0:	01604534 	movhi	r5,33044
811016a4:	2941eb04 	addi	r5,r5,1964
811016a8:	01204534 	movhi	r4,33044
811016ac:	211bff04 	addi	r4,r4,28668
811016b0:	11170140 	call	81117014 <sprintf>
	debug(fp, cDebugBuffer);
811016b4:	d0a05417 	ldw	r2,-32432(gp)
811016b8:	01604534 	movhi	r5,33044
811016bc:	295bff04 	addi	r5,r5,28668
811016c0:	1009883a 	mov	r4,r2
811016c4:	11156840 	call	81115684 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016c8:	00800104 	movi	r2,4
811016cc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016d0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016d4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016d8:	e03fe715 	stw	zero,-100(fp)
811016dc:	00001506 	br	81101734 <bDdr2MemoryWriteTest+0x1a4>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016e0:	e0ffe617 	ldw	r3,-104(fp)
811016e4:	00b33374 	movhi	r2,52429
811016e8:	10b33344 	addi	r2,r2,-13107
811016ec:	1888383a 	mulxuu	r4,r3,r2
811016f0:	1885383a 	mul	r2,r3,r2
811016f4:	1021883a 	mov	r16,r2
811016f8:	2023883a 	mov	r17,r4
811016fc:	8804d0fa 	srli	r2,r17,3
81101700:	e0ffe717 	ldw	r3,-100(fp)
81101704:	18c00044 	addi	r3,r3,1
81101708:	10c7383a 	mul	r3,r2,r3
8110170c:	e0bfe717 	ldw	r2,-100(fp)
81101710:	1085883a 	add	r2,r2,r2
81101714:	1085883a 	add	r2,r2,r2
81101718:	e13fe504 	addi	r4,fp,-108
8110171c:	2085883a 	add	r2,r4,r2
81101720:	10800e04 	addi	r2,r2,56
81101724:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101728:	e0bfe717 	ldw	r2,-100(fp)
8110172c:	10800044 	addi	r2,r2,1
81101730:	e0bfe715 	stw	r2,-100(fp)
81101734:	e0bfe717 	ldw	r2,-100(fp)
81101738:	10800290 	cmplti	r2,r2,10
8110173c:	103fe81e 	bne	r2,zero,811016e0 <__reset+0xfb0e16e0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101740:	d0a07917 	ldw	r2,-32284(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101744:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101748:	00804004 	movi	r2,256
8110174c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101750:	e03fe715 	stw	zero,-100(fp)
81101754:	00001e06 	br	811017d0 <bDdr2MemoryWriteTest+0x240>
		if (iI == 0) {
81101758:	e0bfe717 	ldw	r2,-100(fp)
8110175c:	1000091e 	bne	r2,zero,81101784 <bDdr2MemoryWriteTest+0x1f4>
			xSZData[iI] = uliInitValue;
81101760:	00a04534 	movhi	r2,33044
81101764:	109c3f04 	addi	r2,r2,28924
81101768:	e0ffe717 	ldw	r3,-100(fp)
8110176c:	18c7883a 	add	r3,r3,r3
81101770:	18c7883a 	add	r3,r3,r3
81101774:	10c5883a 	add	r2,r2,r3
81101778:	e0fff017 	ldw	r3,-64(fp)
8110177c:	10c00015 	stw	r3,0(r2)
81101780:	00001006 	br	811017c4 <bDdr2MemoryWriteTest+0x234>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101784:	e0bfe717 	ldw	r2,-100(fp)
81101788:	10ffffc4 	addi	r3,r2,-1
8110178c:	00a04534 	movhi	r2,33044
81101790:	109c3f04 	addi	r2,r2,28924
81101794:	18c7883a 	add	r3,r3,r3
81101798:	18c7883a 	add	r3,r3,r3
8110179c:	10c5883a 	add	r2,r2,r3
811017a0:	10800017 	ldw	r2,0(r2)
811017a4:	11000364 	muli	r4,r2,13
811017a8:	00a04534 	movhi	r2,33044
811017ac:	109c3f04 	addi	r2,r2,28924
811017b0:	e0ffe717 	ldw	r3,-100(fp)
811017b4:	18c7883a 	add	r3,r3,r3
811017b8:	18c7883a 	add	r3,r3,r3
811017bc:	10c5883a 	add	r2,r2,r3
811017c0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017c4:	e0bfe717 	ldw	r2,-100(fp)
811017c8:	10800044 	addi	r2,r2,1
811017cc:	e0bfe715 	stw	r2,-100(fp)
811017d0:	e0ffe717 	ldw	r3,-100(fp)
811017d4:	e0bfea17 	ldw	r2,-88(fp)
811017d8:	18bfdf16 	blt	r3,r2,81101758 <__reset+0xfb0e1758>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017dc:	e0bfea17 	ldw	r2,-88(fp)
811017e0:	10ffffc4 	addi	r3,r2,-1
811017e4:	00a04534 	movhi	r2,33044
811017e8:	109c3f04 	addi	r2,r2,28924
811017ec:	18c7883a 	add	r3,r3,r3
811017f0:	18c7883a 	add	r3,r3,r3
811017f4:	10c7883a 	add	r3,r2,r3
811017f8:	00aaaaf4 	movhi	r2,43691
811017fc:	10aaaa84 	addi	r2,r2,-21846
81101800:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
81101804:	e0bfea17 	ldw	r2,-88(fp)
81101808:	10ffff84 	addi	r3,r2,-2
8110180c:	00a04534 	movhi	r2,33044
81101810:	109c3f04 	addi	r2,r2,28924
81101814:	18c7883a 	add	r3,r3,r3
81101818:	18c7883a 	add	r3,r3,r3
8110181c:	10c7883a 	add	r3,r2,r3
81101820:	00955574 	movhi	r2,21845
81101824:	10955544 	addi	r2,r2,21845
81101828:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110182c:	e0bfea17 	ldw	r2,-88(fp)
81101830:	10ffff44 	addi	r3,r2,-3
81101834:	00a04534 	movhi	r2,33044
81101838:	109c3f04 	addi	r2,r2,28924
8110183c:	18c7883a 	add	r3,r3,r3
81101840:	18c7883a 	add	r3,r3,r3
81101844:	10c5883a 	add	r2,r2,r3
81101848:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110184c:	e0bfea17 	ldw	r2,-88(fp)
81101850:	10ffff04 	addi	r3,r2,-4
81101854:	00a04534 	movhi	r2,33044
81101858:	109c3f04 	addi	r2,r2,28924
8110185c:	18c7883a 	add	r3,r3,r3
81101860:	18c7883a 	add	r3,r3,r3
81101864:	10c5883a 	add	r2,r2,r3
81101868:	00ffffc4 	movi	r3,-1
8110186c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101870:	00e04534 	movhi	r3,33044
81101874:	18dbff04 	addi	r3,r3,28668
81101878:	00a04534 	movhi	r2,33044
8110187c:	1081f104 	addi	r2,r2,1988
81101880:	1009883a 	mov	r4,r2
81101884:	00800444 	movi	r2,17
81101888:	100d883a 	mov	r6,r2
8110188c:	200b883a 	mov	r5,r4
81101890:	1809883a 	mov	r4,r3
81101894:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
81101898:	d0a05417 	ldw	r2,-32432(gp)
8110189c:	01604534 	movhi	r5,33044
811018a0:	295bff04 	addi	r5,r5,28668
811018a4:	1009883a 	mov	r4,r2
811018a8:	11156840 	call	81115684 <fprintf>
811018ac:	d0a07917 	ldw	r2,-32284(gp)
#endif
	iTimeStart = alt_nticks();
811018b0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018b4:	e0bfe517 	ldw	r2,-108(fp)
811018b8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018bc:	00810004 	movi	r2,1024
811018c0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018c4:	e0ffe817 	ldw	r3,-96(fp)
811018c8:	e0bfee17 	ldw	r2,-72(fp)
811018cc:	1885283a 	div	r2,r3,r2
811018d0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018d4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018d8:	00003a06 	br	811019c4 <bDdr2MemoryWriteTest+0x434>
		iNRemainedLen = uliByteLen - iNPos;
811018dc:	e0bfeb17 	ldw	r2,-84(fp)
811018e0:	e0ffe617 	ldw	r3,-104(fp)
811018e4:	1885c83a 	sub	r2,r3,r2
811018e8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018ec:	e0bfe817 	ldw	r2,-96(fp)
811018f0:	e0fff217 	ldw	r3,-56(fp)
811018f4:	1880060e 	bge	r3,r2,81101910 <bDdr2MemoryWriteTest+0x380>
			iNAccessLen = iNRemainedLen;
811018f8:	e0bff217 	ldw	r2,-56(fp)
811018fc:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101900:	e0ffe817 	ldw	r3,-96(fp)
81101904:	e0bfee17 	ldw	r2,-72(fp)
81101908:	1885283a 	div	r2,r3,r2
8110190c:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101910:	e0bfe817 	ldw	r2,-96(fp)
81101914:	100d883a 	mov	r6,r2
81101918:	01604534 	movhi	r5,33044
8110191c:	295c3f04 	addi	r5,r5,28924
81101920:	e13fe917 	ldw	r4,-92(fp)
81101924:	11167340 	call	81116734 <memcpy>
		pxDes += iNItemNum;
81101928:	e0bfea17 	ldw	r2,-88(fp)
8110192c:	1085883a 	add	r2,r2,r2
81101930:	1085883a 	add	r2,r2,r2
81101934:	1007883a 	mov	r3,r2
81101938:	e0bfe917 	ldw	r2,-92(fp)
8110193c:	10c5883a 	add	r2,r2,r3
81101940:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101944:	e0ffeb17 	ldw	r3,-84(fp)
81101948:	e0bfe817 	ldw	r2,-96(fp)
8110194c:	1885883a 	add	r2,r3,r2
81101950:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101954:	e0bfec17 	ldw	r2,-80(fp)
81101958:	10800288 	cmpgei	r2,r2,10
8110195c:	1000191e 	bne	r2,zero,811019c4 <bDdr2MemoryWriteTest+0x434>
81101960:	e0bfec17 	ldw	r2,-80(fp)
81101964:	1085883a 	add	r2,r2,r2
81101968:	1085883a 	add	r2,r2,r2
8110196c:	e0ffe504 	addi	r3,fp,-108
81101970:	1885883a 	add	r2,r3,r2
81101974:	10800e04 	addi	r2,r2,56
81101978:	10800017 	ldw	r2,0(r2)
8110197c:	e0ffeb17 	ldw	r3,-84(fp)
81101980:	18801036 	bltu	r3,r2,811019c4 <bDdr2MemoryWriteTest+0x434>
			iNProgressIndex++;
81101984:	e0bfec17 	ldw	r2,-80(fp)
81101988:	10800044 	addi	r2,r2,1
8110198c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101990:	e0bfec17 	ldw	r2,-80(fp)
81101994:	108002a4 	muli	r2,r2,10
81101998:	100d883a 	mov	r6,r2
8110199c:	01604534 	movhi	r5,33044
811019a0:	2941f604 	addi	r5,r5,2008
811019a4:	01204534 	movhi	r4,33044
811019a8:	211bff04 	addi	r4,r4,28668
811019ac:	11170140 	call	81117014 <sprintf>
			debug(fp, cDebugBuffer);
811019b0:	d0a05417 	ldw	r2,-32432(gp)
811019b4:	01604534 	movhi	r5,33044
811019b8:	295bff04 	addi	r5,r5,28668
811019bc:	1009883a 	mov	r4,r2
811019c0:	11156840 	call	81115684 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019c4:	e0ffeb17 	ldw	r3,-84(fp)
811019c8:	e0bfe617 	ldw	r2,-104(fp)
811019cc:	18bfc336 	bltu	r3,r2,811018dc <__reset+0xfb0e18dc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019d0:	112b1340 	call	8112b134 <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019d4:	00a04534 	movhi	r2,33044
811019d8:	109bff04 	addi	r2,r2,28668
811019dc:	00c00284 	movi	r3,10
811019e0:	10c00005 	stb	r3,0(r2)
811019e4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019e8:	d0a05417 	ldw	r2,-32432(gp)
811019ec:	01604534 	movhi	r5,33044
811019f0:	295bff04 	addi	r5,r5,28668
811019f4:	1009883a 	mov	r4,r2
811019f8:	11156840 	call	81115684 <fprintf>
811019fc:	d0e07917 	ldw	r3,-32284(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101a00:	e0bff117 	ldw	r2,-60(fp)
81101a04:	1885c83a 	sub	r2,r3,r2
81101a08:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
81101a0c:	e0bfed17 	ldw	r2,-76(fp)
81101a10:	10001e26 	beq	r2,zero,81101a8c <bDdr2MemoryWriteTest+0x4fc>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a14:	e13fef17 	ldw	r4,-68(fp)
81101a18:	11148c00 	call	811148c0 <__floatsisf>
81101a1c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a20:	d0a07817 	ldw	r2,-32288(gp)
81101a24:	1009883a 	mov	r4,r2
81101a28:	11149ec0 	call	811149ec <__floatunsisf>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	180b883a 	mov	r5,r3
81101a34:	8009883a 	mov	r4,r16
81101a38:	11140740 	call	81114074 <__divsf3>
81101a3c:	1007883a 	mov	r3,r2
81101a40:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a44:	1009883a 	mov	r4,r2
81101a48:	11152040 	call	81115204 <__extendsfdf2>
81101a4c:	1009883a 	mov	r4,r2
81101a50:	180b883a 	mov	r5,r3
81101a54:	d9400015 	stw	r5,0(sp)
81101a58:	200f883a 	mov	r7,r4
81101a5c:	e1bfe617 	ldw	r6,-104(fp)
81101a60:	01604534 	movhi	r5,33044
81101a64:	2941f804 	addi	r5,r5,2016
81101a68:	01204534 	movhi	r4,33044
81101a6c:	211bff04 	addi	r4,r4,28668
81101a70:	11170140 	call	81117014 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a74:	d0a05417 	ldw	r2,-32432(gp)
81101a78:	01604534 	movhi	r5,33044
81101a7c:	295bff04 	addi	r5,r5,28668
81101a80:	1009883a 	mov	r4,r2
81101a84:	11156840 	call	81115684 <fprintf>
81101a88:	00000f06 	br	81101ac8 <bDdr2MemoryWriteTest+0x538>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a8c:	00e04534 	movhi	r3,33044
81101a90:	18dbff04 	addi	r3,r3,28668
81101a94:	00a04534 	movhi	r2,33044
81101a98:	10820404 	addi	r2,r2,2064
81101a9c:	1009883a 	mov	r4,r2
81101aa0:	00800584 	movi	r2,22
81101aa4:	100d883a 	mov	r6,r2
81101aa8:	200b883a 	mov	r5,r4
81101aac:	1809883a 	mov	r4,r3
81101ab0:	11167340 	call	81116734 <memcpy>
		debug(fp, cDebugBuffer);
81101ab4:	d0a05417 	ldw	r2,-32432(gp)
81101ab8:	01604534 	movhi	r5,33044
81101abc:	295bff04 	addi	r5,r5,28668
81101ac0:	1009883a 	mov	r4,r2
81101ac4:	11156840 	call	81115684 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ac8:	00a04534 	movhi	r2,33044
81101acc:	109bff04 	addi	r2,r2,28668
81101ad0:	00c00284 	movi	r3,10
81101ad4:	10c00005 	stb	r3,0(r2)
81101ad8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101adc:	d0a05417 	ldw	r2,-32432(gp)
81101ae0:	01604534 	movhi	r5,33044
81101ae4:	295bff04 	addi	r5,r5,28668
81101ae8:	1009883a 	mov	r4,r2
81101aec:	11156840 	call	81115684 <fprintf>
#endif

	return bSuccess;
81101af0:	e0bfed17 	ldw	r2,-76(fp)
}
81101af4:	e6fffe04 	addi	sp,fp,-8
81101af8:	dfc00317 	ldw	ra,12(sp)
81101afc:	df000217 	ldw	fp,8(sp)
81101b00:	dc400117 	ldw	r17,4(sp)
81101b04:	dc000017 	ldw	r16,0(sp)
81101b08:	dec00404 	addi	sp,sp,16
81101b0c:	f800283a 	ret

81101b10 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mémoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b10:	deffe204 	addi	sp,sp,-120
81101b14:	de00012e 	bgeu	sp,et,81101b1c <bDdr2MemoryReadTest+0xc>
81101b18:	003b68fa 	trap	3
81101b1c:	dfc01d15 	stw	ra,116(sp)
81101b20:	df001c15 	stw	fp,112(sp)
81101b24:	dc401b15 	stw	r17,108(sp)
81101b28:	dc001a15 	stw	r16,104(sp)
81101b2c:	df001c04 	addi	fp,sp,112
81101b30:	2005883a 	mov	r2,r4
81101b34:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b38:	00e04534 	movhi	r3,33044
81101b3c:	18dbff04 	addi	r3,r3,28668
81101b40:	00a04534 	movhi	r2,33044
81101b44:	10820a04 	addi	r2,r2,2088
81101b48:	1009883a 	mov	r4,r2
81101b4c:	008009c4 	movi	r2,39
81101b50:	100d883a 	mov	r6,r2
81101b54:	200b883a 	mov	r5,r4
81101b58:	1809883a 	mov	r4,r3
81101b5c:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
81101b60:	d0a05417 	ldw	r2,-32432(gp)
81101b64:	01604534 	movhi	r5,33044
81101b68:	295bff04 	addi	r5,r5,28668
81101b6c:	1009883a 	mov	r4,r2
81101b70:	11156840 	call	81115684 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b74:	00800044 	movi	r2,1
81101b78:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b7c:	e0bffd03 	ldbu	r2,-12(fp)
81101b80:	10c00060 	cmpeqi	r3,r2,1
81101b84:	1800031e 	bne	r3,zero,81101b94 <bDdr2MemoryReadTest+0x84>
81101b88:	108000a0 	cmpeqi	r2,r2,2
81101b8c:	1000081e 	bne	r2,zero,81101bb0 <bDdr2MemoryReadTest+0xa0>
81101b90:	00000e06 	br	81101bcc <bDdr2MemoryReadTest+0xbc>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b94:	e0bffd03 	ldbu	r2,-12(fp)
81101b98:	1009883a 	mov	r4,r2
81101b9c:	11014d00 	call	811014d0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba0:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101ba4:	00a00034 	movhi	r2,32768
81101ba8:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bac:	00001906 	br	81101c14 <bDdr2MemoryReadTest+0x104>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101bb0:	e0bffd03 	ldbu	r2,-12(fp)
81101bb4:	1009883a 	mov	r4,r2
81101bb8:	11014d00 	call	811014d0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101bbc:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bc0:	00a00034 	movhi	r2,32768
81101bc4:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bc8:	00001206 	br	81101c14 <bDdr2MemoryReadTest+0x104>
	default:
		bSuccess = FALSE;
81101bcc:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bd0:	00e04534 	movhi	r3,33044
81101bd4:	18dbff04 	addi	r3,r3,28668
81101bd8:	00a04534 	movhi	r2,33044
81101bdc:	10bff204 	addi	r2,r2,-56
81101be0:	1009883a 	mov	r4,r2
81101be4:	00800bc4 	movi	r2,47
81101be8:	100d883a 	mov	r6,r2
81101bec:	200b883a 	mov	r5,r4
81101bf0:	1809883a 	mov	r4,r3
81101bf4:	11167340 	call	81116734 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101bf8:	d0a05417 	ldw	r2,-32432(gp)
81101bfc:	01604534 	movhi	r5,33044
81101c00:	295bff04 	addi	r5,r5,28668
81101c04:	1009883a 	mov	r4,r2
81101c08:	11156840 	call	81115684 <fprintf>
		;
#endif
		return bSuccess;
81101c0c:	e0bfe517 	ldw	r2,-108(fp)
81101c10:	0000fc06 	br	81102004 <bDdr2MemoryReadTest+0x4f4>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c14:	e0bfe717 	ldw	r2,-100(fp)
81101c18:	1004d53a 	srli	r2,r2,20
81101c1c:	100d883a 	mov	r6,r2
81101c20:	01604534 	movhi	r5,33044
81101c24:	29421404 	addi	r5,r5,2128
81101c28:	01204534 	movhi	r4,33044
81101c2c:	211bff04 	addi	r4,r4,28668
81101c30:	11170140 	call	81117014 <sprintf>
	debug(fp, cDebugBuffer);
81101c34:	d0a05417 	ldw	r2,-32432(gp)
81101c38:	01604534 	movhi	r5,33044
81101c3c:	295bff04 	addi	r5,r5,28668
81101c40:	1009883a 	mov	r4,r2
81101c44:	11156840 	call	81115684 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c48:	00804004 	movi	r2,256
81101c4c:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c50:	00800104 	movi	r2,4
81101c54:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c58:	e0ffec17 	ldw	r3,-80(fp)
81101c5c:	e0bfef17 	ldw	r2,-68(fp)
81101c60:	1885383a 	mul	r2,r3,r2
81101c64:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c68:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c6c:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c70:	e03fe815 	stw	zero,-96(fp)
81101c74:	00001506 	br	81101ccc <bDdr2MemoryReadTest+0x1bc>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c78:	e0ffe717 	ldw	r3,-100(fp)
81101c7c:	00b33374 	movhi	r2,52429
81101c80:	10b33344 	addi	r2,r2,-13107
81101c84:	1888383a 	mulxuu	r4,r3,r2
81101c88:	1885383a 	mul	r2,r3,r2
81101c8c:	1021883a 	mov	r16,r2
81101c90:	2023883a 	mov	r17,r4
81101c94:	8804d0fa 	srli	r2,r17,3
81101c98:	e0ffe817 	ldw	r3,-96(fp)
81101c9c:	18c00044 	addi	r3,r3,1
81101ca0:	10c7383a 	mul	r3,r2,r3
81101ca4:	e0bfe817 	ldw	r2,-96(fp)
81101ca8:	1085883a 	add	r2,r2,r2
81101cac:	1085883a 	add	r2,r2,r2
81101cb0:	e13fe504 	addi	r4,fp,-108
81101cb4:	2085883a 	add	r2,r4,r2
81101cb8:	10800e04 	addi	r2,r2,56
81101cbc:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cc0:	e0bfe817 	ldw	r2,-96(fp)
81101cc4:	10800044 	addi	r2,r2,1
81101cc8:	e0bfe815 	stw	r2,-96(fp)
81101ccc:	e0bfe817 	ldw	r2,-96(fp)
81101cd0:	10800290 	cmplti	r2,r2,10
81101cd4:	103fe81e 	bne	r2,zero,81101c78 <__reset+0xfb0e1c78>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cd8:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cdc:	00e04534 	movhi	r3,33044
81101ce0:	18dbff04 	addi	r3,r3,28668
81101ce4:	00a04534 	movhi	r2,33044
81101ce8:	10821a04 	addi	r2,r2,2152
81101cec:	1009883a 	mov	r4,r2
81101cf0:	008006c4 	movi	r2,27
81101cf4:	100d883a 	mov	r6,r2
81101cf8:	200b883a 	mov	r5,r4
81101cfc:	1809883a 	mov	r4,r3
81101d00:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
81101d04:	d0a05417 	ldw	r2,-32432(gp)
81101d08:	01604534 	movhi	r5,33044
81101d0c:	295bff04 	addi	r5,r5,28668
81101d10:	1009883a 	mov	r4,r2
81101d14:	11156840 	call	81115684 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d18:	d0a07917 	ldw	r2,-32284(gp)
#endif
	iTimeStart = alt_nticks();
81101d1c:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d20:	e0bfe617 	ldw	r2,-104(fp)
81101d24:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d28:	00810004 	movi	r2,1024
81101d2c:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d30:	e0ffe917 	ldw	r3,-92(fp)
81101d34:	e0bfef17 	ldw	r2,-68(fp)
81101d38:	1885283a 	div	r2,r3,r2
81101d3c:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d40:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d44:	00006206 	br	81101ed0 <bDdr2MemoryReadTest+0x3c0>
		iNRemainedLen = uliByteLen - iNPos;
81101d48:	e0bfed17 	ldw	r2,-76(fp)
81101d4c:	e0ffe717 	ldw	r3,-100(fp)
81101d50:	1885c83a 	sub	r2,r3,r2
81101d54:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d58:	e0bfe917 	ldw	r2,-92(fp)
81101d5c:	e0fff217 	ldw	r3,-56(fp)
81101d60:	1880060e 	bge	r3,r2,81101d7c <bDdr2MemoryReadTest+0x26c>
			iNAccessLen = iNRemainedLen;
81101d64:	e0bff217 	ldw	r2,-56(fp)
81101d68:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d6c:	e0ffe917 	ldw	r3,-92(fp)
81101d70:	e0bfef17 	ldw	r2,-68(fp)
81101d74:	1885283a 	div	r2,r3,r2
81101d78:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d7c:	00a04534 	movhi	r2,33044
81101d80:	109c3f04 	addi	r2,r2,28924
81101d84:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d88:	e03fe815 	stw	zero,-96(fp)
81101d8c:	00002b06 	br	81101e3c <bDdr2MemoryReadTest+0x32c>
			if (*pxSrc++ != *pxDes++) {
81101d90:	e0bfeb17 	ldw	r2,-84(fp)
81101d94:	10c00104 	addi	r3,r2,4
81101d98:	e0ffeb15 	stw	r3,-84(fp)
81101d9c:	10c00017 	ldw	r3,0(r2)
81101da0:	e0bfea17 	ldw	r2,-88(fp)
81101da4:	11000104 	addi	r4,r2,4
81101da8:	e13fea15 	stw	r4,-88(fp)
81101dac:	10800017 	ldw	r2,0(r2)
81101db0:	18801f26 	beq	r3,r2,81101e30 <bDdr2MemoryReadTest+0x320>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db4:	e0bfeb17 	ldw	r2,-84(fp)
81101db8:	10bfff04 	addi	r2,r2,-4
81101dbc:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dc0:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101dc4:	00a04534 	movhi	r2,33044
81101dc8:	109c3f04 	addi	r2,r2,28924
81101dcc:	e0ffe817 	ldw	r3,-96(fp)
81101dd0:	18c7883a 	add	r3,r3,r3
81101dd4:	18c7883a 	add	r3,r3,r3
81101dd8:	10c5883a 	add	r2,r2,r3
81101ddc:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101de0:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101de4:	e0ffed17 	ldw	r3,-76(fp)
81101de8:	e0bfef17 	ldw	r2,-68(fp)
81101dec:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101df0:	e0bfe817 	ldw	r2,-96(fp)
81101df4:	1885883a 	add	r2,r3,r2
81101df8:	d8800015 	stw	r2,0(sp)
81101dfc:	280f883a 	mov	r7,r5
81101e00:	200d883a 	mov	r6,r4
81101e04:	01604534 	movhi	r5,33044
81101e08:	29422104 	addi	r5,r5,2180
81101e0c:	01204534 	movhi	r4,33044
81101e10:	211bff04 	addi	r4,r4,28668
81101e14:	11170140 	call	81117014 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e18:	d0a05417 	ldw	r2,-32432(gp)
81101e1c:	01604534 	movhi	r5,33044
81101e20:	295bff04 	addi	r5,r5,28668
81101e24:	1009883a 	mov	r4,r2
81101e28:	11156840 	call	81115684 <fprintf>
#endif
				bSuccess = FALSE;
81101e2c:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e30:	e0bfe817 	ldw	r2,-96(fp)
81101e34:	10800044 	addi	r2,r2,1
81101e38:	e0bfe815 	stw	r2,-96(fp)
81101e3c:	e0ffe817 	ldw	r3,-96(fp)
81101e40:	e0bfec17 	ldw	r2,-80(fp)
81101e44:	1880020e 	bge	r3,r2,81101e50 <bDdr2MemoryReadTest+0x340>
81101e48:	e0bfe517 	ldw	r2,-108(fp)
81101e4c:	103fd01e 	bne	r2,zero,81101d90 <__reset+0xfb0e1d90>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e50:	e0ffed17 	ldw	r3,-76(fp)
81101e54:	e0bfe917 	ldw	r2,-92(fp)
81101e58:	1885883a 	add	r2,r3,r2
81101e5c:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e60:	e0bfee17 	ldw	r2,-72(fp)
81101e64:	10800288 	cmpgei	r2,r2,10
81101e68:	1000191e 	bne	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3c0>
81101e6c:	e0bfee17 	ldw	r2,-72(fp)
81101e70:	1085883a 	add	r2,r2,r2
81101e74:	1085883a 	add	r2,r2,r2
81101e78:	e0ffe504 	addi	r3,fp,-108
81101e7c:	1885883a 	add	r2,r3,r2
81101e80:	10800e04 	addi	r2,r2,56
81101e84:	10800017 	ldw	r2,0(r2)
81101e88:	e0ffed17 	ldw	r3,-76(fp)
81101e8c:	18801036 	bltu	r3,r2,81101ed0 <bDdr2MemoryReadTest+0x3c0>
			iNProgressIndex++;
81101e90:	e0bfee17 	ldw	r2,-72(fp)
81101e94:	10800044 	addi	r2,r2,1
81101e98:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e9c:	e0bfee17 	ldw	r2,-72(fp)
81101ea0:	108002a4 	muli	r2,r2,10
81101ea4:	100d883a 	mov	r6,r2
81101ea8:	01604534 	movhi	r5,33044
81101eac:	2941f604 	addi	r5,r5,2008
81101eb0:	01204534 	movhi	r4,33044
81101eb4:	211bff04 	addi	r4,r4,28668
81101eb8:	11170140 	call	81117014 <sprintf>
			debug(fp, cDebugBuffer);
81101ebc:	d0a05417 	ldw	r2,-32432(gp)
81101ec0:	01604534 	movhi	r5,33044
81101ec4:	295bff04 	addi	r5,r5,28668
81101ec8:	1009883a 	mov	r4,r2
81101ecc:	11156840 	call	81115684 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ed0:	e0bfe517 	ldw	r2,-108(fp)
81101ed4:	10000326 	beq	r2,zero,81101ee4 <bDdr2MemoryReadTest+0x3d4>
81101ed8:	e0ffed17 	ldw	r3,-76(fp)
81101edc:	e0bfe717 	ldw	r2,-100(fp)
81101ee0:	18bf9936 	bltu	r3,r2,81101d48 <__reset+0xfb0e1d48>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ee4:	00a04534 	movhi	r2,33044
81101ee8:	109bff04 	addi	r2,r2,28668
81101eec:	00c00284 	movi	r3,10
81101ef0:	10c00005 	stb	r3,0(r2)
81101ef4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ef8:	d0a05417 	ldw	r2,-32432(gp)
81101efc:	01604534 	movhi	r5,33044
81101f00:	295bff04 	addi	r5,r5,28668
81101f04:	1009883a 	mov	r4,r2
81101f08:	11156840 	call	81115684 <fprintf>
81101f0c:	d0e07917 	ldw	r3,-32284(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101f10:	e0bff117 	ldw	r2,-60(fp)
81101f14:	1885c83a 	sub	r2,r3,r2
81101f18:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f1c:	e0bfe517 	ldw	r2,-108(fp)
81101f20:	10001e26 	beq	r2,zero,81101f9c <bDdr2MemoryReadTest+0x48c>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f24:	e13ff017 	ldw	r4,-64(fp)
81101f28:	11148c00 	call	811148c0 <__floatsisf>
81101f2c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f30:	d0a07817 	ldw	r2,-32288(gp)
81101f34:	1009883a 	mov	r4,r2
81101f38:	11149ec0 	call	811149ec <__floatunsisf>
81101f3c:	1007883a 	mov	r3,r2
81101f40:	180b883a 	mov	r5,r3
81101f44:	8009883a 	mov	r4,r16
81101f48:	11140740 	call	81114074 <__divsf3>
81101f4c:	1007883a 	mov	r3,r2
81101f50:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f54:	1009883a 	mov	r4,r2
81101f58:	11152040 	call	81115204 <__extendsfdf2>
81101f5c:	1009883a 	mov	r4,r2
81101f60:	180b883a 	mov	r5,r3
81101f64:	d9400015 	stw	r5,0(sp)
81101f68:	200f883a 	mov	r7,r4
81101f6c:	e1bfe717 	ldw	r6,-100(fp)
81101f70:	01604534 	movhi	r5,33044
81101f74:	29422f04 	addi	r5,r5,2236
81101f78:	01204534 	movhi	r4,33044
81101f7c:	211bff04 	addi	r4,r4,28668
81101f80:	11170140 	call	81117014 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f84:	d0a05417 	ldw	r2,-32432(gp)
81101f88:	01604534 	movhi	r5,33044
81101f8c:	295bff04 	addi	r5,r5,28668
81101f90:	1009883a 	mov	r4,r2
81101f94:	11156840 	call	81115684 <fprintf>
81101f98:	00000f06 	br	81101fd8 <bDdr2MemoryReadTest+0x4c8>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f9c:	00e04534 	movhi	r3,33044
81101fa0:	18dbff04 	addi	r3,r3,28668
81101fa4:	00a04534 	movhi	r2,33044
81101fa8:	10823b04 	addi	r2,r2,2284
81101fac:	1009883a 	mov	r4,r2
81101fb0:	00800544 	movi	r2,21
81101fb4:	100d883a 	mov	r6,r2
81101fb8:	200b883a 	mov	r5,r4
81101fbc:	1809883a 	mov	r4,r3
81101fc0:	11167340 	call	81116734 <memcpy>
		debug(fp, cDebugBuffer);
81101fc4:	d0a05417 	ldw	r2,-32432(gp)
81101fc8:	01604534 	movhi	r5,33044
81101fcc:	295bff04 	addi	r5,r5,28668
81101fd0:	1009883a 	mov	r4,r2
81101fd4:	11156840 	call	81115684 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fd8:	00a04534 	movhi	r2,33044
81101fdc:	109bff04 	addi	r2,r2,28668
81101fe0:	00c00284 	movi	r3,10
81101fe4:	10c00005 	stb	r3,0(r2)
81101fe8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fec:	d0a05417 	ldw	r2,-32432(gp)
81101ff0:	01604534 	movhi	r5,33044
81101ff4:	295bff04 	addi	r5,r5,28668
81101ff8:	1009883a 	mov	r4,r2
81101ffc:	11156840 	call	81115684 <fprintf>
#endif

	return bSuccess;
81102000:	e0bfe517 	ldw	r2,-108(fp)
}
81102004:	e6fffe04 	addi	sp,fp,-8
81102008:	dfc00317 	ldw	ra,12(sp)
8110200c:	df000217 	ldw	fp,8(sp)
81102010:	dc400117 	ldw	r17,4(sp)
81102014:	dc000017 	ldw	r16,0(sp)
81102018:	dec00404 	addi	sp,sp,16
8110201c:	f800283a 	ret

81102020 <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a duração da função será medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102020:	deffec04 	addi	sp,sp,-80
81102024:	de00012e 	bgeu	sp,et,8110202c <bDdr2MemoryRandomWriteTest+0xc>
81102028:	003b68fa 	trap	3
8110202c:	dfc01315 	stw	ra,76(sp)
81102030:	df001215 	stw	fp,72(sp)
81102034:	dcc01115 	stw	r19,68(sp)
81102038:	dc801015 	stw	r18,64(sp)
8110203c:	dc400f15 	stw	r17,60(sp)
81102040:	dc000e15 	stw	r16,56(sp)
81102044:	df001204 	addi	fp,sp,72
81102048:	2005883a 	mov	r2,r4
8110204c:	e17ffa15 	stw	r5,-24(fp)
81102050:	e1bffb15 	stw	r6,-20(fp)
81102054:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102058:	00e04534 	movhi	r3,33044
8110205c:	18dbff04 	addi	r3,r3,28668
81102060:	00a04534 	movhi	r2,33044
81102064:	10824104 	addi	r2,r2,2308
81102068:	1009883a 	mov	r4,r2
8110206c:	00800bc4 	movi	r2,47
81102070:	100d883a 	mov	r6,r2
81102074:	200b883a 	mov	r5,r4
81102078:	1809883a 	mov	r4,r3
8110207c:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
81102080:	d0a05417 	ldw	r2,-32432(gp)
81102084:	01604534 	movhi	r5,33044
81102088:	295bff04 	addi	r5,r5,28668
8110208c:	1009883a 	mov	r4,r2
81102090:	11156840 	call	81115684 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102094:	00800044 	movi	r2,1
81102098:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	10c00060 	cmpeqi	r3,r2,1
811020a4:	1800031e 	bne	r3,zero,811020b4 <bDdr2MemoryRandomWriteTest+0x94>
811020a8:	108000a0 	cmpeqi	r2,r2,2
811020ac:	1000081e 	bne	r2,zero,811020d0 <bDdr2MemoryRandomWriteTest+0xb0>
811020b0:	00000e06 	br	811020ec <bDdr2MemoryRandomWriteTest+0xcc>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b4:	e0bff903 	ldbu	r2,-28(fp)
811020b8:	1009883a 	mov	r4,r2
811020bc:	11014d00 	call	811014d0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c0:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020c4:	00a00034 	movhi	r2,32768
811020c8:	e0bff015 	stw	r2,-64(fp)
		break;
811020cc:	00001906 	br	81102134 <bDdr2MemoryRandomWriteTest+0x114>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020d0:	e0bff903 	ldbu	r2,-28(fp)
811020d4:	1009883a 	mov	r4,r2
811020d8:	11014d00 	call	811014d0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020dc:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020e0:	00a00034 	movhi	r2,32768
811020e4:	e0bff015 	stw	r2,-64(fp)
		break;
811020e8:	00001206 	br	81102134 <bDdr2MemoryRandomWriteTest+0x114>
	default:
		bSuccess = FALSE;
811020ec:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020f0:	00e04534 	movhi	r3,33044
811020f4:	18dbff04 	addi	r3,r3,28668
811020f8:	00a04534 	movhi	r2,33044
811020fc:	10bff204 	addi	r2,r2,-56
81102100:	1009883a 	mov	r4,r2
81102104:	00800bc4 	movi	r2,47
81102108:	100d883a 	mov	r6,r2
8110210c:	200b883a 	mov	r5,r4
81102110:	1809883a 	mov	r4,r3
81102114:	11167340 	call	81116734 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102118:	d0a05417 	ldw	r2,-32432(gp)
8110211c:	01604534 	movhi	r5,33044
81102120:	295bff04 	addi	r5,r5,28668
81102124:	1009883a 	mov	r4,r2
81102128:	11156840 	call	81115684 <fprintf>
		;
#endif
		return bSuccess;
8110212c:	e0bff417 	ldw	r2,-48(fp)
81102130:	0000ce06 	br	8110246c <bDdr2MemoryRandomWriteTest+0x44c>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102134:	e0bff017 	ldw	r2,-64(fp)
81102138:	1004d53a 	srli	r2,r2,20
8110213c:	100d883a 	mov	r6,r2
81102140:	01604534 	movhi	r5,33044
81102144:	2941eb04 	addi	r5,r5,1964
81102148:	01204534 	movhi	r4,33044
8110214c:	211bff04 	addi	r4,r4,28668
81102150:	11170140 	call	81117014 <sprintf>
	debug(fp, cDebugBuffer);
81102154:	d0a05417 	ldw	r2,-32432(gp)
81102158:	01604534 	movhi	r5,33044
8110215c:	295bff04 	addi	r5,r5,28668
81102160:	1009883a 	mov	r4,r2
81102164:	11156840 	call	81115684 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102168:	d0a07917 	ldw	r2,-32284(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
8110216c:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102170:	d0a03717 	ldw	r2,-32548(gp)
81102174:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102178:	e0ffef17 	ldw	r3,-68(fp)
8110217c:	e0bff017 	ldw	r2,-64(fp)
81102180:	1885883a 	add	r2,r3,r2
81102184:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102188:	e0fff017 	ldw	r3,-64(fp)
8110218c:	00b33374 	movhi	r2,52429
81102190:	10b33344 	addi	r2,r2,-13107
81102194:	1888383a 	mulxuu	r4,r3,r2
81102198:	1885383a 	mul	r2,r3,r2
8110219c:	1025883a 	mov	r18,r2
811021a0:	2027883a 	mov	r19,r4
811021a4:	9806d13a 	srli	r3,r19,4
811021a8:	e0bfef17 	ldw	r2,-68(fp)
811021ac:	1885883a 	add	r2,r3,r2
811021b0:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
811021b4:	00800144 	movi	r2,5
811021b8:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021bc:	00e04534 	movhi	r3,33044
811021c0:	18dbff04 	addi	r3,r3,28668
811021c4:	00a04534 	movhi	r2,33044
811021c8:	10824d04 	addi	r2,r2,2356
811021cc:	1009883a 	mov	r4,r2
811021d0:	00800584 	movi	r2,22
811021d4:	100d883a 	mov	r6,r2
811021d8:	200b883a 	mov	r5,r4
811021dc:	1809883a 	mov	r4,r3
811021e0:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
811021e4:	d0a05417 	ldw	r2,-32432(gp)
811021e8:	01604534 	movhi	r5,33044
811021ec:	295bff04 	addi	r5,r5,28668
811021f0:	1009883a 	mov	r4,r2
811021f4:	11156840 	call	81115684 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021f8:	e0bffa17 	ldw	r2,-24(fp)
811021fc:	10800058 	cmpnei	r2,r2,1
81102200:	10000a1e 	bne	r2,zero,8110222c <bDdr2MemoryRandomWriteTest+0x20c>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102204:	01604534 	movhi	r5,33044
81102208:	29425304 	addi	r5,r5,2380
8110220c:	01204534 	movhi	r4,33044
81102210:	211bff04 	addi	r4,r4,28668
81102214:	11170140 	call	81117014 <sprintf>
		debug(fp, cDebugBuffer);
81102218:	d0a05417 	ldw	r2,-32432(gp)
8110221c:	01604534 	movhi	r5,33044
81102220:	295bff04 	addi	r5,r5,28668
81102224:	1009883a 	mov	r4,r2
81102228:	11156840 	call	81115684 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
8110222c:	e03ff615 	stw	zero,-40(fp)
81102230:	d0a07917 	ldw	r2,-32284(gp)

	TimeStart = alt_nticks();
81102234:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102238:	e0bfef17 	ldw	r2,-68(fp)
8110223c:	e0bff115 	stw	r2,-60(fp)
81102240:	00002c06 	br	811022f4 <bDdr2MemoryRandomWriteTest+0x2d4>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
81102244:	e0bff804 	addi	r2,fp,-32
81102248:	1009883a 	mov	r4,r2
8110224c:	110292c0 	call	8110292c <uliXorshift32>
81102250:	1007883a 	mov	r3,r2
81102254:	e0bff117 	ldw	r2,-60(fp)
81102258:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
8110225c:	e0bffa17 	ldw	r2,-24(fp)
81102260:	10800060 	cmpeqi	r2,r2,1
81102264:	1009883a 	mov	r4,r2
81102268:	e0bff117 	ldw	r2,-60(fp)
8110226c:	e0fff217 	ldw	r3,-56(fp)
81102270:	1885803a 	cmpltu	r2,r3,r2
81102274:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102278:	10803fcc 	andi	r2,r2,255
8110227c:	10001a26 	beq	r2,zero,811022e8 <bDdr2MemoryRandomWriteTest+0x2c8>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102280:	e0bff303 	ldbu	r2,-52(fp)
81102284:	100d883a 	mov	r6,r2
81102288:	01604534 	movhi	r5,33044
8110228c:	29425504 	addi	r5,r5,2388
81102290:	01204534 	movhi	r4,33044
81102294:	211bff04 	addi	r4,r4,28668
81102298:	11170140 	call	81117014 <sprintf>
			debug(fp, cDebugBuffer);
8110229c:	d0a05417 	ldw	r2,-32432(gp)
811022a0:	01604534 	movhi	r5,33044
811022a4:	295bff04 	addi	r5,r5,28668
811022a8:	1009883a 	mov	r4,r2
811022ac:	11156840 	call	81115684 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
811022b0:	e0fff017 	ldw	r3,-64(fp)
811022b4:	00b33374 	movhi	r2,52429
811022b8:	10b33344 	addi	r2,r2,-13107
811022bc:	1888383a 	mulxuu	r4,r3,r2
811022c0:	1885383a 	mul	r2,r3,r2
811022c4:	1021883a 	mov	r16,r2
811022c8:	2023883a 	mov	r17,r4
811022cc:	8804d13a 	srli	r2,r17,4
811022d0:	e0fff217 	ldw	r3,-56(fp)
811022d4:	1885883a 	add	r2,r3,r2
811022d8:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022dc:	e0bff303 	ldbu	r2,-52(fp)
811022e0:	10800144 	addi	r2,r2,5
811022e4:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022e8:	e0bff117 	ldw	r2,-60(fp)
811022ec:	10800104 	addi	r2,r2,4
811022f0:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022f4:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022f8:	e0bff517 	ldw	r2,-44(fp)
811022fc:	18bfd136 	bltu	r3,r2,81102244 <__reset+0xfb0e2244>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
81102300:	112b1340 	call	8112b134 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
81102304:	e0bffa17 	ldw	r2,-24(fp)
81102308:	10800058 	cmpnei	r2,r2,1
8110230c:	10000a1e 	bne	r2,zero,81102338 <bDdr2MemoryRandomWriteTest+0x318>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102310:	01604534 	movhi	r5,33044
81102314:	29425804 	addi	r5,r5,2400
81102318:	01204534 	movhi	r4,33044
8110231c:	211bff04 	addi	r4,r4,28668
81102320:	11170140 	call	81117014 <sprintf>
		debug(fp, cDebugBuffer);
81102324:	d0a05417 	ldw	r2,-32432(gp)
81102328:	01604534 	movhi	r5,33044
8110232c:	295bff04 	addi	r5,r5,28668
81102330:	1009883a 	mov	r4,r2
81102334:	11156840 	call	81115684 <fprintf>
#endif
	}

	if (bSuccess) {
81102338:	e0bff417 	ldw	r2,-48(fp)
8110233c:	10003126 	beq	r2,zero,81102404 <bDdr2MemoryRandomWriteTest+0x3e4>
		if (bTime == TRUE) {
81102340:	e0bffb17 	ldw	r2,-20(fp)
81102344:	10800058 	cmpnei	r2,r2,1
81102348:	1000221e 	bne	r2,zero,811023d4 <bDdr2MemoryRandomWriteTest+0x3b4>
8110234c:	d0e07917 	ldw	r3,-32284(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102350:	e0bff717 	ldw	r2,-36(fp)
81102354:	1885c83a 	sub	r2,r3,r2
81102358:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
8110235c:	e13ff617 	ldw	r4,-40(fp)
81102360:	11148c00 	call	811148c0 <__floatsisf>
81102364:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102368:	d0a07817 	ldw	r2,-32288(gp)
8110236c:	1009883a 	mov	r4,r2
81102370:	11149ec0 	call	811149ec <__floatunsisf>
81102374:	1007883a 	mov	r3,r2
81102378:	180b883a 	mov	r5,r3
8110237c:	8009883a 	mov	r4,r16
81102380:	11140740 	call	81114074 <__divsf3>
81102384:	1007883a 	mov	r3,r2
81102388:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110238c:	1009883a 	mov	r4,r2
81102390:	11152040 	call	81115204 <__extendsfdf2>
81102394:	1009883a 	mov	r4,r2
81102398:	180b883a 	mov	r5,r3
8110239c:	d9400015 	stw	r5,0(sp)
811023a0:	200f883a 	mov	r7,r4
811023a4:	e1bff017 	ldw	r6,-64(fp)
811023a8:	01604534 	movhi	r5,33044
811023ac:	29425b04 	addi	r5,r5,2412
811023b0:	01204534 	movhi	r4,33044
811023b4:	211bff04 	addi	r4,r4,28668
811023b8:	11170140 	call	81117014 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023bc:	d0a05417 	ldw	r2,-32432(gp)
811023c0:	01604534 	movhi	r5,33044
811023c4:	295bff04 	addi	r5,r5,28668
811023c8:	1009883a 	mov	r4,r2
811023cc:	11156840 	call	81115684 <fprintf>
811023d0:	00001b06 	br	81102440 <bDdr2MemoryRandomWriteTest+0x420>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023d4:	e1bff017 	ldw	r6,-64(fp)
811023d8:	01604534 	movhi	r5,33044
811023dc:	29426704 	addi	r5,r5,2460
811023e0:	01204534 	movhi	r4,33044
811023e4:	211bff04 	addi	r4,r4,28668
811023e8:	11170140 	call	81117014 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023ec:	d0a05417 	ldw	r2,-32432(gp)
811023f0:	01604534 	movhi	r5,33044
811023f4:	295bff04 	addi	r5,r5,28668
811023f8:	1009883a 	mov	r4,r2
811023fc:	11156840 	call	81115684 <fprintf>
81102400:	00000f06 	br	81102440 <bDdr2MemoryRandomWriteTest+0x420>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81102404:	00e04534 	movhi	r3,33044
81102408:	18dbff04 	addi	r3,r3,28668
8110240c:	00a04534 	movhi	r2,33044
81102410:	10820404 	addi	r2,r2,2064
81102414:	1009883a 	mov	r4,r2
81102418:	00800584 	movi	r2,22
8110241c:	100d883a 	mov	r6,r2
81102420:	200b883a 	mov	r5,r4
81102424:	1809883a 	mov	r4,r3
81102428:	11167340 	call	81116734 <memcpy>
		debug(fp, cDebugBuffer);
8110242c:	d0a05417 	ldw	r2,-32432(gp)
81102430:	01604534 	movhi	r5,33044
81102434:	295bff04 	addi	r5,r5,28668
81102438:	1009883a 	mov	r4,r2
8110243c:	11156840 	call	81115684 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102440:	00a04534 	movhi	r2,33044
81102444:	109bff04 	addi	r2,r2,28668
81102448:	00c00284 	movi	r3,10
8110244c:	10c00005 	stb	r3,0(r2)
81102450:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81102454:	d0a05417 	ldw	r2,-32432(gp)
81102458:	01604534 	movhi	r5,33044
8110245c:	295bff04 	addi	r5,r5,28668
81102460:	1009883a 	mov	r4,r2
81102464:	11156840 	call	81115684 <fprintf>
#endif

	return bSuccess;
81102468:	e0bff417 	ldw	r2,-48(fp)
}
8110246c:	e6fffc04 	addi	sp,fp,-16
81102470:	dfc00517 	ldw	ra,20(sp)
81102474:	df000417 	ldw	fp,16(sp)
81102478:	dcc00317 	ldw	r19,12(sp)
8110247c:	dc800217 	ldw	r18,8(sp)
81102480:	dc400117 	ldw	r17,4(sp)
81102484:	dc000017 	ldw	r16,0(sp)
81102488:	dec00604 	addi	sp,sp,24
8110248c:	f800283a 	ret

81102490 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a duração da função será medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102490:	deffec04 	addi	sp,sp,-80
81102494:	de00012e 	bgeu	sp,et,8110249c <bDdr2MemoryRandomReadTest+0xc>
81102498:	003b68fa 	trap	3
8110249c:	dfc01315 	stw	ra,76(sp)
811024a0:	df001215 	stw	fp,72(sp)
811024a4:	dcc01115 	stw	r19,68(sp)
811024a8:	dc801015 	stw	r18,64(sp)
811024ac:	dc400f15 	stw	r17,60(sp)
811024b0:	dc000e15 	stw	r16,56(sp)
811024b4:	df001204 	addi	fp,sp,72
811024b8:	2005883a 	mov	r2,r4
811024bc:	e17ffa15 	stw	r5,-24(fp)
811024c0:	e1bffb15 	stw	r6,-20(fp)
811024c4:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024c8:	00e04534 	movhi	r3,33044
811024cc:	18dbff04 	addi	r3,r3,28668
811024d0:	00a04534 	movhi	r2,33044
811024d4:	10827104 	addi	r2,r2,2500
811024d8:	1009883a 	mov	r4,r2
811024dc:	00800b84 	movi	r2,46
811024e0:	100d883a 	mov	r6,r2
811024e4:	200b883a 	mov	r5,r4
811024e8:	1809883a 	mov	r4,r3
811024ec:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
811024f0:	d0a05417 	ldw	r2,-32432(gp)
811024f4:	01604534 	movhi	r5,33044
811024f8:	295bff04 	addi	r5,r5,28668
811024fc:	1009883a 	mov	r4,r2
81102500:	11156840 	call	81115684 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102504:	00800044 	movi	r2,1
81102508:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
8110250c:	e0bff903 	ldbu	r2,-28(fp)
81102510:	10c00060 	cmpeqi	r3,r2,1
81102514:	1800031e 	bne	r3,zero,81102524 <bDdr2MemoryRandomReadTest+0x94>
81102518:	108000a0 	cmpeqi	r2,r2,2
8110251c:	1000081e 	bne	r2,zero,81102540 <bDdr2MemoryRandomReadTest+0xb0>
81102520:	00000e06 	br	8110255c <bDdr2MemoryRandomReadTest+0xcc>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014d00 	call	811014d0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001906 	br	811025a4 <bDdr2MemoryRandomReadTest+0x114>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102540:	e0bff903 	ldbu	r2,-28(fp)
81102544:	1009883a 	mov	r4,r2
81102548:	11014d00 	call	811014d0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110254c:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102550:	00a00034 	movhi	r2,32768
81102554:	e0bff115 	stw	r2,-60(fp)
		break;
81102558:	00001206 	br	811025a4 <bDdr2MemoryRandomReadTest+0x114>
	default:
		bSuccess = FALSE;
8110255c:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102560:	00e04534 	movhi	r3,33044
81102564:	18dbff04 	addi	r3,r3,28668
81102568:	00a04534 	movhi	r2,33044
8110256c:	10bff204 	addi	r2,r2,-56
81102570:	1009883a 	mov	r4,r2
81102574:	00800bc4 	movi	r2,47
81102578:	100d883a 	mov	r6,r2
8110257c:	200b883a 	mov	r5,r4
81102580:	1809883a 	mov	r4,r3
81102584:	11167340 	call	81116734 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102588:	d0a05417 	ldw	r2,-32432(gp)
8110258c:	01604534 	movhi	r5,33044
81102590:	295bff04 	addi	r5,r5,28668
81102594:	1009883a 	mov	r4,r2
81102598:	11156840 	call	81115684 <fprintf>
		;
#endif
		return bSuccess;
8110259c:	e0bfef17 	ldw	r2,-68(fp)
811025a0:	0000d906 	br	81102908 <bDdr2MemoryRandomReadTest+0x478>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
811025a4:	e0bff117 	ldw	r2,-60(fp)
811025a8:	1004d53a 	srli	r2,r2,20
811025ac:	100d883a 	mov	r6,r2
811025b0:	01604534 	movhi	r5,33044
811025b4:	2941eb04 	addi	r5,r5,1964
811025b8:	01204534 	movhi	r4,33044
811025bc:	211bff04 	addi	r4,r4,28668
811025c0:	11170140 	call	81117014 <sprintf>
	debug(fp, cDebugBuffer);
811025c4:	d0a05417 	ldw	r2,-32432(gp)
811025c8:	01604534 	movhi	r5,33044
811025cc:	295bff04 	addi	r5,r5,28668
811025d0:	1009883a 	mov	r4,r2
811025d4:	11156840 	call	81115684 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025d8:	d0a03717 	ldw	r2,-32548(gp)
811025dc:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025e0:	e0fff017 	ldw	r3,-64(fp)
811025e4:	e0bff117 	ldw	r2,-60(fp)
811025e8:	1885883a 	add	r2,r3,r2
811025ec:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025f0:	e0fff117 	ldw	r3,-60(fp)
811025f4:	00b33374 	movhi	r2,52429
811025f8:	10b33344 	addi	r2,r2,-13107
811025fc:	1888383a 	mulxuu	r4,r3,r2
81102600:	1885383a 	mul	r2,r3,r2
81102604:	1025883a 	mov	r18,r2
81102608:	2027883a 	mov	r19,r4
8110260c:	9806d13a 	srli	r3,r19,4
81102610:	e0bff017 	ldw	r2,-64(fp)
81102614:	1885883a 	add	r2,r3,r2
81102618:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
8110261c:	00800144 	movi	r2,5
81102620:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102624:	00e04534 	movhi	r3,33044
81102628:	18dbff04 	addi	r3,r3,28668
8110262c:	00a04534 	movhi	r2,33044
81102630:	10827d04 	addi	r2,r2,2548
81102634:	1009883a 	mov	r4,r2
81102638:	00800604 	movi	r2,24
8110263c:	100d883a 	mov	r6,r2
81102640:	200b883a 	mov	r5,r4
81102644:	1809883a 	mov	r4,r3
81102648:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
8110264c:	d0a05417 	ldw	r2,-32432(gp)
81102650:	01604534 	movhi	r5,33044
81102654:	295bff04 	addi	r5,r5,28668
81102658:	1009883a 	mov	r4,r2
8110265c:	11156840 	call	81115684 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102660:	e0bffa17 	ldw	r2,-24(fp)
81102664:	10800058 	cmpnei	r2,r2,1
81102668:	10000a1e 	bne	r2,zero,81102694 <bDdr2MemoryRandomReadTest+0x204>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
8110266c:	01604534 	movhi	r5,33044
81102670:	29425304 	addi	r5,r5,2380
81102674:	01204534 	movhi	r4,33044
81102678:	211bff04 	addi	r4,r4,28668
8110267c:	11170140 	call	81117014 <sprintf>
		debug(fp, cDebugBuffer);
81102680:	d0a05417 	ldw	r2,-32432(gp)
81102684:	01604534 	movhi	r5,33044
81102688:	295bff04 	addi	r5,r5,28668
8110268c:	1009883a 	mov	r4,r2
81102690:	11156840 	call	81115684 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102694:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102698:	d0a07917 	ldw	r2,-32284(gp)

	TimeStart = alt_nticks();
8110269c:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
811026a0:	e0bff017 	ldw	r2,-64(fp)
811026a4:	e0bff215 	stw	r2,-56(fp)
811026a8:	00003a06 	br	81102794 <bDdr2MemoryRandomReadTest+0x304>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
811026ac:	e0bff804 	addi	r2,fp,-32
811026b0:	1009883a 	mov	r4,r2
811026b4:	110292c0 	call	8110292c <uliXorshift32>
811026b8:	1007883a 	mov	r3,r2
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	10800017 	ldw	r2,0(r2)
811026c4:	18801026 	beq	r3,r2,81102708 <bDdr2MemoryRandomReadTest+0x278>
			bSuccess = FALSE;
811026c8:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026cc:	e0bffa17 	ldw	r2,-24(fp)
811026d0:	10800058 	cmpnei	r2,r2,1
811026d4:	10000c1e 	bne	r2,zero,81102708 <bDdr2MemoryRandomReadTest+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026d8:	e0bff217 	ldw	r2,-56(fp)
811026dc:	100d883a 	mov	r6,r2
811026e0:	01604534 	movhi	r5,33044
811026e4:	29428304 	addi	r5,r5,2572
811026e8:	01204534 	movhi	r4,33044
811026ec:	211bff04 	addi	r4,r4,28668
811026f0:	11170140 	call	81117014 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026f4:	d0a05417 	ldw	r2,-32432(gp)
811026f8:	01604534 	movhi	r5,33044
811026fc:	295bff04 	addi	r5,r5,28668
81102700:	1009883a 	mov	r4,r2
81102704:	11156840 	call	81115684 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
81102708:	e0bffa17 	ldw	r2,-24(fp)
8110270c:	10800058 	cmpnei	r2,r2,1
81102710:	10001d1e 	bne	r2,zero,81102788 <bDdr2MemoryRandomReadTest+0x2f8>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
81102714:	e0bff217 	ldw	r2,-56(fp)
81102718:	e0fff317 	ldw	r3,-52(fp)
8110271c:	18801a2e 	bgeu	r3,r2,81102788 <bDdr2MemoryRandomReadTest+0x2f8>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102720:	e0bff403 	ldbu	r2,-48(fp)
81102724:	100d883a 	mov	r6,r2
81102728:	01604534 	movhi	r5,33044
8110272c:	29425504 	addi	r5,r5,2388
81102730:	01204534 	movhi	r4,33044
81102734:	211bff04 	addi	r4,r4,28668
81102738:	11170140 	call	81117014 <sprintf>
			debug(fp, cDebugBuffer);
8110273c:	d0a05417 	ldw	r2,-32432(gp)
81102740:	01604534 	movhi	r5,33044
81102744:	295bff04 	addi	r5,r5,28668
81102748:	1009883a 	mov	r4,r2
8110274c:	11156840 	call	81115684 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102750:	e0fff117 	ldw	r3,-60(fp)
81102754:	00b33374 	movhi	r2,52429
81102758:	10b33344 	addi	r2,r2,-13107
8110275c:	1888383a 	mulxuu	r4,r3,r2
81102760:	1885383a 	mul	r2,r3,r2
81102764:	1021883a 	mov	r16,r2
81102768:	2023883a 	mov	r17,r4
8110276c:	8804d13a 	srli	r2,r17,4
81102770:	e0fff317 	ldw	r3,-52(fp)
81102774:	1885883a 	add	r2,r3,r2
81102778:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
8110277c:	e0bff403 	ldbu	r2,-48(fp)
81102780:	10800144 	addi	r2,r2,5
81102784:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
81102788:	e0bff217 	ldw	r2,-56(fp)
8110278c:	10800104 	addi	r2,r2,4
81102790:	e0bff215 	stw	r2,-56(fp)
81102794:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
81102798:	e0bff517 	ldw	r2,-44(fp)
8110279c:	18bfc336 	bltu	r3,r2,811026ac <__reset+0xfb0e26ac>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
811027a0:	e0bffa17 	ldw	r2,-24(fp)
811027a4:	10800058 	cmpnei	r2,r2,1
811027a8:	10000a1e 	bne	r2,zero,811027d4 <bDdr2MemoryRandomReadTest+0x344>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811027ac:	01604534 	movhi	r5,33044
811027b0:	29425804 	addi	r5,r5,2400
811027b4:	01204534 	movhi	r4,33044
811027b8:	211bff04 	addi	r4,r4,28668
811027bc:	11170140 	call	81117014 <sprintf>
		debug(fp, cDebugBuffer);
811027c0:	d0a05417 	ldw	r2,-32432(gp)
811027c4:	01604534 	movhi	r5,33044
811027c8:	295bff04 	addi	r5,r5,28668
811027cc:	1009883a 	mov	r4,r2
811027d0:	11156840 	call	81115684 <fprintf>
#endif
	}

	if (bSuccess) {
811027d4:	e0bfef17 	ldw	r2,-68(fp)
811027d8:	10003126 	beq	r2,zero,811028a0 <bDdr2MemoryRandomReadTest+0x410>
		if (bTime == TRUE) {
811027dc:	e0bffb17 	ldw	r2,-20(fp)
811027e0:	10800058 	cmpnei	r2,r2,1
811027e4:	1000221e 	bne	r2,zero,81102870 <bDdr2MemoryRandomReadTest+0x3e0>
811027e8:	d0e07917 	ldw	r3,-32284(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027ec:	e0bff717 	ldw	r2,-36(fp)
811027f0:	1885c83a 	sub	r2,r3,r2
811027f4:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027f8:	e13ff617 	ldw	r4,-40(fp)
811027fc:	11148c00 	call	811148c0 <__floatsisf>
81102800:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102804:	d0a07817 	ldw	r2,-32288(gp)
81102808:	1009883a 	mov	r4,r2
8110280c:	11149ec0 	call	811149ec <__floatunsisf>
81102810:	1007883a 	mov	r3,r2
81102814:	180b883a 	mov	r5,r3
81102818:	8009883a 	mov	r4,r16
8110281c:	11140740 	call	81114074 <__divsf3>
81102820:	1007883a 	mov	r3,r2
81102824:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102828:	1009883a 	mov	r4,r2
8110282c:	11152040 	call	81115204 <__extendsfdf2>
81102830:	1009883a 	mov	r4,r2
81102834:	180b883a 	mov	r5,r3
81102838:	d9400015 	stw	r5,0(sp)
8110283c:	200f883a 	mov	r7,r4
81102840:	e1bff117 	ldw	r6,-60(fp)
81102844:	01604534 	movhi	r5,33044
81102848:	29428b04 	addi	r5,r5,2604
8110284c:	01204534 	movhi	r4,33044
81102850:	211bff04 	addi	r4,r4,28668
81102854:	11170140 	call	81117014 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
81102858:	d0a05417 	ldw	r2,-32432(gp)
8110285c:	01604534 	movhi	r5,33044
81102860:	295bff04 	addi	r5,r5,28668
81102864:	1009883a 	mov	r4,r2
81102868:	11156840 	call	81115684 <fprintf>
8110286c:	00001b06 	br	811028dc <bDdr2MemoryRandomReadTest+0x44c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102870:	e1bff117 	ldw	r6,-60(fp)
81102874:	01604534 	movhi	r5,33044
81102878:	29429704 	addi	r5,r5,2652
8110287c:	01204534 	movhi	r4,33044
81102880:	211bff04 	addi	r4,r4,28668
81102884:	11170140 	call	81117014 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
81102888:	d0a05417 	ldw	r2,-32432(gp)
8110288c:	01604534 	movhi	r5,33044
81102890:	295bff04 	addi	r5,r5,28668
81102894:	1009883a 	mov	r4,r2
81102898:	11156840 	call	81115684 <fprintf>
8110289c:	00000f06 	br	811028dc <bDdr2MemoryRandomReadTest+0x44c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
811028a0:	00e04534 	movhi	r3,33044
811028a4:	18dbff04 	addi	r3,r3,28668
811028a8:	00a04534 	movhi	r2,33044
811028ac:	10823b04 	addi	r2,r2,2284
811028b0:	1009883a 	mov	r4,r2
811028b4:	00800544 	movi	r2,21
811028b8:	100d883a 	mov	r6,r2
811028bc:	200b883a 	mov	r5,r4
811028c0:	1809883a 	mov	r4,r3
811028c4:	11167340 	call	81116734 <memcpy>
		debug(fp, cDebugBuffer);
811028c8:	d0a05417 	ldw	r2,-32432(gp)
811028cc:	01604534 	movhi	r5,33044
811028d0:	295bff04 	addi	r5,r5,28668
811028d4:	1009883a 	mov	r4,r2
811028d8:	11156840 	call	81115684 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028dc:	00a04534 	movhi	r2,33044
811028e0:	109bff04 	addi	r2,r2,28668
811028e4:	00c00284 	movi	r3,10
811028e8:	10c00005 	stb	r3,0(r2)
811028ec:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028f0:	d0a05417 	ldw	r2,-32432(gp)
811028f4:	01604534 	movhi	r5,33044
811028f8:	295bff04 	addi	r5,r5,28668
811028fc:	1009883a 	mov	r4,r2
81102900:	11156840 	call	81115684 <fprintf>
#endif

	return bSuccess;
81102904:	e0bfef17 	ldw	r2,-68(fp)
}
81102908:	e6fffc04 	addi	sp,fp,-16
8110290c:	dfc00517 	ldw	ra,20(sp)
81102910:	df000417 	ldw	fp,16(sp)
81102914:	dcc00317 	ldw	r19,12(sp)
81102918:	dc800217 	ldw	r18,8(sp)
8110291c:	dc400117 	ldw	r17,4(sp)
81102920:	dc000017 	ldw	r16,0(sp)
81102924:	dec00604 	addi	sp,sp,24
81102928:	f800283a 	ret

8110292c <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Número aleatório resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
8110292c:	defffd04 	addi	sp,sp,-12
81102930:	de00012e 	bgeu	sp,et,81102938 <uliXorshift32+0xc>
81102934:	003b68fa 	trap	3
81102938:	df000215 	stw	fp,8(sp)
8110293c:	df000204 	addi	fp,sp,8
81102940:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102944:	e0bfff17 	ldw	r2,-4(fp)
81102948:	10800017 	ldw	r2,0(r2)
8110294c:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102950:	e0bffe17 	ldw	r2,-8(fp)
81102954:	1004937a 	slli	r2,r2,13
81102958:	e0fffe17 	ldw	r3,-8(fp)
8110295c:	1884f03a 	xor	r2,r3,r2
81102960:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102964:	e0bffe17 	ldw	r2,-8(fp)
81102968:	1004d47a 	srli	r2,r2,17
8110296c:	e0fffe17 	ldw	r3,-8(fp)
81102970:	1884f03a 	xor	r2,r3,r2
81102974:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
81102978:	e0bffe17 	ldw	r2,-8(fp)
8110297c:	1004917a 	slli	r2,r2,5
81102980:	e0fffe17 	ldw	r3,-8(fp)
81102984:	1884f03a 	xor	r2,r3,r2
81102988:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
8110298c:	e0bfff17 	ldw	r2,-4(fp)
81102990:	e0fffe17 	ldw	r3,-8(fp)
81102994:	10c00015 	stw	r3,0(r2)

	return uliX;
81102998:	e0bffe17 	ldw	r2,-8(fp)
}
8110299c:	e037883a 	mov	sp,fp
811029a0:	df000017 	ldw	fp,0(sp)
811029a4:	dec00104 	addi	sp,sp,4
811029a8:	f800283a 	ret

811029ac <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
811029ac:	defffb04 	addi	sp,sp,-20
811029b0:	de00012e 	bgeu	sp,et,811029b8 <DMA_OPEN_DEVICE+0xc>
811029b4:	003b68fa 	trap	3
811029b8:	dfc00415 	stw	ra,16(sp)
811029bc:	df000315 	stw	fp,12(sp)
811029c0:	df000304 	addi	fp,sp,12
811029c4:	e13ffe15 	stw	r4,-8(fp)
811029c8:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029cc:	00800044 	movi	r2,1
811029d0:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029d4:	e13fff17 	ldw	r4,-4(fp)
811029d8:	113e8400 	call	8113e840 <alt_msgdma_open>
811029dc:	1007883a 	mov	r3,r2
811029e0:	e0bffe17 	ldw	r2,-8(fp)
811029e4:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029e8:	e0bffe17 	ldw	r2,-8(fp)
811029ec:	10800017 	ldw	r2,0(r2)
811029f0:	1000011e 	bne	r2,zero,811029f8 <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029f4:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029f8:	e0bffd17 	ldw	r2,-12(fp)
}
811029fc:	e037883a 	mov	sp,fp
81102a00:	dfc00117 	ldw	ra,4(sp)
81102a04:	df000017 	ldw	fp,0(sp)
81102a08:	dec00204 	addi	sp,sp,8
81102a0c:	f800283a 	ret

81102a10 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configurações do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
81102a10:	defffc04 	addi	sp,sp,-16
81102a14:	de00012e 	bgeu	sp,et,81102a1c <DMA_CONFIG+0xc>
81102a18:	003b68fa 	trap	3
81102a1c:	df000315 	stw	fp,12(sp)
81102a20:	df000304 	addi	fp,sp,12
81102a24:	e13ffe15 	stw	r4,-8(fp)
81102a28:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a2c:	00800044 	movi	r2,1
81102a30:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a34:	e0bffe17 	ldw	r2,-8(fp)
81102a38:	10800317 	ldw	r2,12(r2)
81102a3c:	10800104 	addi	r2,r2,4
81102a40:	e0ffff17 	ldw	r3,-4(fp)
81102a44:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a48:	e0bffd17 	ldw	r2,-12(fp)
}
81102a4c:	e037883a 	mov	sp,fp
81102a50:	df000017 	ldw	fp,0(sp)
81102a54:	dec00104 	addi	sp,sp,4
81102a58:	f800283a 	ret

81102a5c <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a5c:	defffd04 	addi	sp,sp,-12
81102a60:	de00012e 	bgeu	sp,et,81102a68 <DMA_BUSY+0xc>
81102a64:	003b68fa 	trap	3
81102a68:	df000215 	stw	fp,8(sp)
81102a6c:	df000204 	addi	fp,sp,8
81102a70:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a74:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a78:	e0bfff17 	ldw	r2,-4(fp)
81102a7c:	10800317 	ldw	r2,12(r2)
81102a80:	10800037 	ldwio	r2,0(r2)
81102a84:	1080004c 	andi	r2,r2,1
81102a88:	10000226 	beq	r2,zero,81102a94 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a8c:	00800044 	movi	r2,1
81102a90:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a94:	e0bffe17 	ldw	r2,-8(fp)
}
81102a98:	e037883a 	mov	sp,fp
81102a9c:	df000017 	ldw	fp,0(sp)
81102aa0:	dec00104 	addi	sp,sp,4
81102aa4:	f800283a 	ret

81102aa8 <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102aa8:	defffd04 	addi	sp,sp,-12
81102aac:	de00012e 	bgeu	sp,et,81102ab4 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102ab0:	003b68fa 	trap	3
81102ab4:	df000215 	stw	fp,8(sp)
81102ab8:	df000204 	addi	fp,sp,8
81102abc:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102ac0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102ac4:	e0bfff17 	ldw	r2,-4(fp)
81102ac8:	10800317 	ldw	r2,12(r2)
81102acc:	10800037 	ldwio	r2,0(r2)
81102ad0:	1080010c 	andi	r2,r2,4
81102ad4:	10000226 	beq	r2,zero,81102ae0 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102ad8:	00800044 	movi	r2,1
81102adc:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ae0:	e0bffe17 	ldw	r2,-8(fp)
}
81102ae4:	e037883a 	mov	sp,fp
81102ae8:	df000017 	ldw	fp,0(sp)
81102aec:	dec00104 	addi	sp,sp,4
81102af0:	f800283a 	ret

81102af4 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102af4:	defffd04 	addi	sp,sp,-12
81102af8:	de00012e 	bgeu	sp,et,81102b00 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102afc:	003b68fa 	trap	3
81102b00:	df000215 	stw	fp,8(sp)
81102b04:	df000204 	addi	fp,sp,8
81102b08:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102b0c:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102b10:	e0bfff17 	ldw	r2,-4(fp)
81102b14:	10800317 	ldw	r2,12(r2)
81102b18:	10800037 	ldwio	r2,0(r2)
81102b1c:	1080008c 	andi	r2,r2,2
81102b20:	10000226 	beq	r2,zero,81102b2c <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b24:	00800044 	movi	r2,1
81102b28:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b2c:	e0bffe17 	ldw	r2,-8(fp)
}
81102b30:	e037883a 	mov	sp,fp
81102b34:	df000017 	ldw	fp,0(sp)
81102b38:	dec00104 	addi	sp,sp,4
81102b3c:	f800283a 	ret

81102b40 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a função irá verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b40:	defffa04 	addi	sp,sp,-24
81102b44:	de00012e 	bgeu	sp,et,81102b4c <DMA_DISPATCHER_STOP+0xc>
81102b48:	003b68fa 	trap	3
81102b4c:	dfc00515 	stw	ra,20(sp)
81102b50:	df000415 	stw	fp,16(sp)
81102b54:	df000404 	addi	fp,sp,16
81102b58:	e13ffd15 	stw	r4,-12(fp)
81102b5c:	e17ffe15 	stw	r5,-8(fp)
81102b60:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b64:	00800044 	movi	r2,1
81102b68:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b6c:	e0bffd17 	ldw	r2,-12(fp)
81102b70:	10800317 	ldw	r2,12(r2)
81102b74:	10800104 	addi	r2,r2,4
81102b78:	00c00044 	movi	r3,1
81102b7c:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b80:	e0bffe17 	ldw	r2,-8(fp)
81102b84:	10800058 	cmpnei	r2,r2,1
81102b88:	10000e1e 	bne	r2,zero,81102bc4 <DMA_DISPATCHER_STOP+0x84>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b8c:	00000706 	br	81102bac <DMA_DISPATCHER_STOP+0x6c>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b90:	e0bfff17 	ldw	r2,-4(fp)
81102b94:	1000031e 	bne	r2,zero,81102ba4 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b98:	01000044 	movi	r4,1
81102b9c:	112c95c0 	call	8112c95c <usleep>
81102ba0:	00000206 	br	81102bac <DMA_DISPATCHER_STOP+0x6c>
      } else {
        usleep(WaitPeriodUs);
81102ba4:	e13fff17 	ldw	r4,-4(fp)
81102ba8:	112c95c0 	call	8112c95c <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102bac:	e0bffd17 	ldw	r2,-12(fp)
81102bb0:	10800317 	ldw	r2,12(r2)
81102bb4:	10800037 	ldwio	r2,0(r2)
81102bb8:	1080080c 	andi	r2,r2,32
81102bbc:	103ff41e 	bne	r2,zero,81102b90 <__reset+0xfb0e2b90>
81102bc0:	00000206 	br	81102bcc <DMA_DISPATCHER_STOP+0x8c>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bc4:	e0bffc17 	ldw	r2,-16(fp)
81102bc8:	00000106 	br	81102bd0 <DMA_DISPATCHER_STOP+0x90>
  }
  
  return bSuccess;
81102bcc:	e0bffc17 	ldw	r2,-16(fp)
}
81102bd0:	e037883a 	mov	sp,fp
81102bd4:	dfc00117 	ldw	ra,4(sp)
81102bd8:	df000017 	ldw	fp,0(sp)
81102bdc:	dec00204 	addi	sp,sp,8
81102be0:	f800283a 	ret

81102be4 <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a função irá verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102be4:	defffa04 	addi	sp,sp,-24
81102be8:	de00012e 	bgeu	sp,et,81102bf0 <DMA_DISPATCHER_RESET+0xc>
81102bec:	003b68fa 	trap	3
81102bf0:	dfc00515 	stw	ra,20(sp)
81102bf4:	df000415 	stw	fp,16(sp)
81102bf8:	df000404 	addi	fp,sp,16
81102bfc:	e13ffd15 	stw	r4,-12(fp)
81102c00:	e17ffe15 	stw	r5,-8(fp)
81102c04:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102c08:	00800044 	movi	r2,1
81102c0c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102c10:	e0bffd17 	ldw	r2,-12(fp)
81102c14:	10800317 	ldw	r2,12(r2)
81102c18:	10800104 	addi	r2,r2,4
81102c1c:	00c00084 	movi	r3,2
81102c20:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c24:	e0bffe17 	ldw	r2,-8(fp)
81102c28:	10800058 	cmpnei	r2,r2,1
81102c2c:	10000e1e 	bne	r2,zero,81102c68 <DMA_DISPATCHER_RESET+0x84>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c30:	00000706 	br	81102c50 <DMA_DISPATCHER_RESET+0x6c>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c34:	e0bfff17 	ldw	r2,-4(fp)
81102c38:	1000031e 	bne	r2,zero,81102c48 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c3c:	01000044 	movi	r4,1
81102c40:	112c95c0 	call	8112c95c <usleep>
81102c44:	00000206 	br	81102c50 <DMA_DISPATCHER_RESET+0x6c>
      } else {
        usleep(WaitPeriodUs);
81102c48:	e13fff17 	ldw	r4,-4(fp)
81102c4c:	112c95c0 	call	8112c95c <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c50:	e0bffd17 	ldw	r2,-12(fp)
81102c54:	10800317 	ldw	r2,12(r2)
81102c58:	10800037 	ldwio	r2,0(r2)
81102c5c:	1080100c 	andi	r2,r2,64
81102c60:	103ff41e 	bne	r2,zero,81102c34 <__reset+0xfb0e2c34>
81102c64:	00000206 	br	81102c70 <DMA_DISPATCHER_RESET+0x8c>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c68:	e0bffc17 	ldw	r2,-16(fp)
81102c6c:	00000106 	br	81102c74 <DMA_DISPATCHER_RESET+0x90>
  }
  
  return bSuccess;
81102c70:	e0bffc17 	ldw	r2,-16(fp)
}
81102c74:	e037883a 	mov	sp,fp
81102c78:	dfc00117 	ldw	ra,4(sp)
81102c7c:	df000017 	ldw	fp,0(sp)
81102c80:	dec00204 	addi	sp,sp,8
81102c84:	f800283a 	ret

81102c88 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a função irá verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c88:	defff604 	addi	sp,sp,-40
81102c8c:	de00012e 	bgeu	sp,et,81102c94 <DMA_SINGLE_TRANSFER+0xc>
81102c90:	003b68fa 	trap	3
81102c94:	dfc00915 	stw	ra,36(sp)
81102c98:	df000815 	stw	fp,32(sp)
81102c9c:	dc000715 	stw	r16,28(sp)
81102ca0:	df000804 	addi	fp,sp,32
81102ca4:	e13ffb15 	stw	r4,-20(fp)
81102ca8:	e17ffc15 	stw	r5,-16(fp)
81102cac:	e1bffd15 	stw	r6,-12(fp)
81102cb0:	e1fffe15 	stw	r7,-8(fp)
81102cb4:	defff804 	addi	sp,sp,-32
81102cb8:	d8800204 	addi	r2,sp,8
81102cbc:	108003c4 	addi	r2,r2,15
81102cc0:	1004d13a 	srli	r2,r2,4
81102cc4:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cc8:	00800044 	movi	r2,1
81102ccc:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cd0:	e0fffc17 	ldw	r3,-16(fp)
81102cd4:	e13ffd17 	ldw	r4,-12(fp)
81102cd8:	e0800217 	ldw	r2,8(fp)
81102cdc:	d8800115 	stw	r2,4(sp)
81102ce0:	e0bffe17 	ldw	r2,-8(fp)
81102ce4:	d8800015 	stw	r2,0(sp)
81102ce8:	200f883a 	mov	r7,r4
81102cec:	180d883a 	mov	r6,r3
81102cf0:	800b883a 	mov	r5,r16
81102cf4:	e13ffb17 	ldw	r4,-20(fp)
81102cf8:	113d83c0 	call	8113d83c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102cfc:	10000326 	beq	r2,zero,81102d0c <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102d00:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102d04:	e0bffa17 	ldw	r2,-24(fp)
81102d08:	00001d06 	br	81102d80 <DMA_SINGLE_TRANSFER+0xf8>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102d0c:	800b883a 	mov	r5,r16
81102d10:	e13ffb17 	ldw	r4,-20(fp)
81102d14:	113eab00 	call	8113eab0 <alt_msgdma_standard_descriptor_async_transfer>
81102d18:	10000326 	beq	r2,zero,81102d28 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d1c:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d20:	e0bffa17 	ldw	r2,-24(fp)
81102d24:	00001606 	br	81102d80 <DMA_SINGLE_TRANSFER+0xf8>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d28:	e0bffa17 	ldw	r2,-24(fp)
81102d2c:	10800060 	cmpeqi	r2,r2,1
81102d30:	1007883a 	mov	r3,r2
81102d34:	e0800317 	ldw	r2,12(fp)
81102d38:	10800060 	cmpeqi	r2,r2,1
81102d3c:	1884703a 	and	r2,r3,r2
81102d40:	10803fcc 	andi	r2,r2,255
81102d44:	10000d26 	beq	r2,zero,81102d7c <DMA_SINGLE_TRANSFER+0xf4>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d48:	00000706 	br	81102d68 <DMA_SINGLE_TRANSFER+0xe0>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1000031e 	bne	r2,zero,81102d60 <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d54:	0100fa04 	movi	r4,1000
81102d58:	112c95c0 	call	8112c95c <usleep>
81102d5c:	00000206 	br	81102d68 <DMA_SINGLE_TRANSFER+0xe0>
      } else {
        usleep(WaitPeriodUs);
81102d60:	e1000417 	ldw	r4,16(fp)
81102d64:	112c95c0 	call	8112c95c <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d68:	e0bffb17 	ldw	r2,-20(fp)
81102d6c:	10800317 	ldw	r2,12(r2)
81102d70:	10800037 	ldwio	r2,0(r2)
81102d74:	1080004c 	andi	r2,r2,1
81102d78:	103ff41e 	bne	r2,zero,81102d4c <__reset+0xfb0e2d4c>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d7c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d80:	e6ffff04 	addi	sp,fp,-4
81102d84:	dfc00217 	ldw	ra,8(sp)
81102d88:	df000117 	ldw	fp,4(sp)
81102d8c:	dc000017 	ldw	r16,0(sp)
81102d90:	dec00304 	addi	sp,sp,12
81102d94:	f800283a 	ret

81102d98 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a função irá verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d98:	defff504 	addi	sp,sp,-44
81102d9c:	de00012e 	bgeu	sp,et,81102da4 <DMA_MULTIPLE_TRANSFER+0xc>
81102da0:	003b68fa 	trap	3
81102da4:	dfc00a15 	stw	ra,40(sp)
81102da8:	df000915 	stw	fp,36(sp)
81102dac:	dc000815 	stw	r16,32(sp)
81102db0:	df000904 	addi	fp,sp,36
81102db4:	e13ffb15 	stw	r4,-20(fp)
81102db8:	e17ffc15 	stw	r5,-16(fp)
81102dbc:	e1bffd15 	stw	r6,-12(fp)
81102dc0:	3805883a 	mov	r2,r7
81102dc4:	e0bffe05 	stb	r2,-8(fp)
81102dc8:	defff804 	addi	sp,sp,-32
81102dcc:	d8800204 	addi	r2,sp,8
81102dd0:	108003c4 	addi	r2,r2,15
81102dd4:	1004d13a 	srli	r2,r2,4
81102dd8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102ddc:	00800044 	movi	r2,1
81102de0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102de4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102de8:	00002506 	br	81102e80 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102dec:	e0bffa03 	ldbu	r2,-24(fp)
81102df0:	1085883a 	add	r2,r2,r2
81102df4:	1085883a 	add	r2,r2,r2
81102df8:	1007883a 	mov	r3,r2
81102dfc:	e0bffc17 	ldw	r2,-16(fp)
81102e00:	10c5883a 	add	r2,r2,r3
81102e04:	10800017 	ldw	r2,0(r2)
81102e08:	1009883a 	mov	r4,r2
81102e0c:	e0bffa03 	ldbu	r2,-24(fp)
81102e10:	1085883a 	add	r2,r2,r2
81102e14:	1085883a 	add	r2,r2,r2
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0bffd17 	ldw	r2,-12(fp)
81102e20:	10c5883a 	add	r2,r2,r3
81102e24:	10800017 	ldw	r2,0(r2)
81102e28:	1007883a 	mov	r3,r2
81102e2c:	e0800317 	ldw	r2,12(fp)
81102e30:	10804034 	orhi	r2,r2,256
81102e34:	d8800115 	stw	r2,4(sp)
81102e38:	e0800217 	ldw	r2,8(fp)
81102e3c:	d8800015 	stw	r2,0(sp)
81102e40:	180f883a 	mov	r7,r3
81102e44:	200d883a 	mov	r6,r4
81102e48:	800b883a 	mov	r5,r16
81102e4c:	e13ffb17 	ldw	r4,-20(fp)
81102e50:	113d83c0 	call	8113d83c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e54:	10000226 	beq	r2,zero,81102e60 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e58:	e03ff915 	stw	zero,-28(fp)
81102e5c:	00000506 	br	81102e74 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e60:	800b883a 	mov	r5,r16
81102e64:	e13ffb17 	ldw	r4,-20(fp)
81102e68:	113eab00 	call	8113eab0 <alt_msgdma_standard_descriptor_async_transfer>
81102e6c:	10000126 	beq	r2,zero,81102e74 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e70:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e74:	e0bffa03 	ldbu	r2,-24(fp)
81102e78:	10800044 	addi	r2,r2,1
81102e7c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e80:	e0bff917 	ldw	r2,-28(fp)
81102e84:	10800060 	cmpeqi	r2,r2,1
81102e88:	1009883a 	mov	r4,r2
81102e8c:	e0fffa03 	ldbu	r3,-24(fp)
81102e90:	e0bffe03 	ldbu	r2,-8(fp)
81102e94:	10bfffc4 	addi	r2,r2,-1
81102e98:	1884803a 	cmplt	r2,r3,r2
81102e9c:	2084703a 	and	r2,r4,r2
81102ea0:	10803fcc 	andi	r2,r2,255
81102ea4:	103fd11e 	bne	r2,zero,81102dec <__reset+0xfb0e2dec>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102ea8:	e0bff917 	ldw	r2,-28(fp)
81102eac:	10800058 	cmpnei	r2,r2,1
81102eb0:	1000211e 	bne	r2,zero,81102f38 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102eb4:	e0bffa03 	ldbu	r2,-24(fp)
81102eb8:	1085883a 	add	r2,r2,r2
81102ebc:	1085883a 	add	r2,r2,r2
81102ec0:	1007883a 	mov	r3,r2
81102ec4:	e0bffc17 	ldw	r2,-16(fp)
81102ec8:	10c5883a 	add	r2,r2,r3
81102ecc:	10800017 	ldw	r2,0(r2)
81102ed0:	1009883a 	mov	r4,r2
81102ed4:	e0bffa03 	ldbu	r2,-24(fp)
81102ed8:	1085883a 	add	r2,r2,r2
81102edc:	1085883a 	add	r2,r2,r2
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0bffd17 	ldw	r2,-12(fp)
81102ee8:	10c5883a 	add	r2,r2,r3
81102eec:	10800017 	ldw	r2,0(r2)
81102ef0:	1007883a 	mov	r3,r2
81102ef4:	e0800317 	ldw	r2,12(fp)
81102ef8:	d8800115 	stw	r2,4(sp)
81102efc:	e0800217 	ldw	r2,8(fp)
81102f00:	d8800015 	stw	r2,0(sp)
81102f04:	180f883a 	mov	r7,r3
81102f08:	200d883a 	mov	r6,r4
81102f0c:	800b883a 	mov	r5,r16
81102f10:	e13ffb17 	ldw	r4,-20(fp)
81102f14:	113d83c0 	call	8113d83c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f18:	10000226 	beq	r2,zero,81102f24 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f1c:	e03ff915 	stw	zero,-28(fp)
81102f20:	00000506 	br	81102f38 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f24:	800b883a 	mov	r5,r16
81102f28:	e13ffb17 	ldw	r4,-20(fp)
81102f2c:	113eab00 	call	8113eab0 <alt_msgdma_standard_descriptor_async_transfer>
81102f30:	10000126 	beq	r2,zero,81102f38 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f34:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f38:	e0bff917 	ldw	r2,-28(fp)
81102f3c:	10800060 	cmpeqi	r2,r2,1
81102f40:	1007883a 	mov	r3,r2
81102f44:	e0800417 	ldw	r2,16(fp)
81102f48:	10800060 	cmpeqi	r2,r2,1
81102f4c:	1884703a 	and	r2,r3,r2
81102f50:	10803fcc 	andi	r2,r2,255
81102f54:	10000d26 	beq	r2,zero,81102f8c <DMA_MULTIPLE_TRANSFER+0x1f4>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f58:	00000706 	br	81102f78 <DMA_MULTIPLE_TRANSFER+0x1e0>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f5c:	e0800517 	ldw	r2,20(fp)
81102f60:	1000031e 	bne	r2,zero,81102f70 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f64:	0100fa04 	movi	r4,1000
81102f68:	112c95c0 	call	8112c95c <usleep>
81102f6c:	00000206 	br	81102f78 <DMA_MULTIPLE_TRANSFER+0x1e0>
      } else {
    	usleep(WaitPeriodUs);
81102f70:	e1000517 	ldw	r4,20(fp)
81102f74:	112c95c0 	call	8112c95c <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f78:	e0bffb17 	ldw	r2,-20(fp)
81102f7c:	10800317 	ldw	r2,12(r2)
81102f80:	10800037 	ldwio	r2,0(r2)
81102f84:	1080004c 	andi	r2,r2,1
81102f88:	103ff41e 	bne	r2,zero,81102f5c <__reset+0xfb0e2f5c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f8c:	e0bff917 	ldw	r2,-28(fp)
}
81102f90:	e6ffff04 	addi	sp,fp,-4
81102f94:	dfc00217 	ldw	ra,8(sp)
81102f98:	df000117 	ldw	fp,4(sp)
81102f9c:	dc000017 	ldw	r16,0(sp)
81102fa0:	dec00304 	addi	sp,sp,12
81102fa4:	f800283a 	ret

81102fa8 <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102fa8:	deffef04 	addi	sp,sp,-68
81102fac:	de00012e 	bgeu	sp,et,81102fb4 <POWER_Read+0xc>
81102fb0:	003b68fa 	trap	3
81102fb4:	dfc01015 	stw	ra,64(sp)
81102fb8:	df000f15 	stw	fp,60(sp)
81102fbc:	df000f04 	addi	fp,sp,60
81102fc0:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fc4:	00800044 	movi	r2,1
81102fc8:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fcc:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fd0:	00800204 	movi	r2,8
81102fd4:	e0bffc15 	stw	r2,-16(fp)
81102fd8:	00800104 	movi	r2,4
81102fdc:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fe0:	00800044 	movi	r2,1
81102fe4:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fe8:	00800044 	movi	r2,1
81102fec:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102ff0:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102ff4:	e03ff515 	stw	zero,-44(fp)
81102ff8:	00009206 	br	81103244 <POWER_Read+0x29c>
		NextChannel = 0;
81102ffc:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81103000:	e0bff517 	ldw	r2,-44(fp)
81103004:	10c03fcc 	andi	r3,r2,255
81103008:	e13ffa03 	ldbu	r4,-24(fp)
8110300c:	e0bfff17 	ldw	r2,-4(fp)
81103010:	d8800115 	stw	r2,4(sp)
81103014:	e0bff917 	ldw	r2,-28(fp)
81103018:	d8800015 	stw	r2,0(sp)
8110301c:	e1fff817 	ldw	r7,-32(fp)
81103020:	e1bff717 	ldw	r6,-36(fp)
81103024:	200b883a 	mov	r5,r4
81103028:	1809883a 	mov	r4,r3
8110302c:	1106d380 	call	81106d38 <POWER_SPI_RW>
81103030:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103034:	e03ff415 	stw	zero,-48(fp)
81103038:	00007406 	br	8110320c <POWER_Read+0x264>
			NextChannel = i + 1;
8110303c:	e0bff417 	ldw	r2,-48(fp)
81103040:	10800044 	addi	r2,r2,1
81103044:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
81103048:	e0bff517 	ldw	r2,-44(fp)
8110304c:	10c03fcc 	andi	r3,r2,255
81103050:	e13ffa03 	ldbu	r4,-24(fp)
81103054:	e0bffe04 	addi	r2,fp,-8
81103058:	d8800115 	stw	r2,4(sp)
8110305c:	e0bff917 	ldw	r2,-28(fp)
81103060:	d8800015 	stw	r2,0(sp)
81103064:	e1fff817 	ldw	r7,-32(fp)
81103068:	e1bff717 	ldw	r6,-36(fp)
8110306c:	200b883a 	mov	r5,r4
81103070:	1809883a 	mov	r4,r3
81103074:	1106d380 	call	81106d38 <POWER_SPI_RW>
81103078:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
8110307c:	e0bff317 	ldw	r2,-52(fp)
81103080:	10005026 	beq	r2,zero,811031c4 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d7ba 	srli	r2,r2,30
8110308c:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103090:	e0bffe17 	ldw	r2,-8(fp)
81103094:	1004d07a 	srli	r2,r2,1
81103098:	108001cc 	andi	r2,r2,7
8110309c:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
811030a0:	e0bffe17 	ldw	r2,-8(fp)
811030a4:	1004d13a 	srli	r2,r2,4
811030a8:	1080004c 	andi	r2,r2,1
811030ac:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030b0:	e0bffe17 	ldw	r2,-8(fp)
811030b4:	1004d17a 	srli	r2,r2,5
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030c0:	e0bffe17 	ldw	r2,-8(fp)
811030c4:	1080004c 	andi	r2,r2,1
811030c8:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030cc:	e0bffa43 	ldbu	r2,-23(fp)
811030d0:	10000d26 	beq	r2,zero,81103108 <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030d4:	e1bff417 	ldw	r6,-48(fp)
811030d8:	01604534 	movhi	r5,33044
811030dc:	2942a104 	addi	r5,r5,2692
811030e0:	01204534 	movhi	r4,33044
811030e4:	211bff04 	addi	r4,r4,28668
811030e8:	11170140 	call	81117014 <sprintf>
					debug(fp, cDebugBuffer);
811030ec:	d0a05417 	ldw	r2,-32432(gp)
811030f0:	01604534 	movhi	r5,33044
811030f4:	295bff04 	addi	r5,r5,28668
811030f8:	1009883a 	mov	r4,r2
811030fc:	11156840 	call	81115684 <fprintf>
#endif
					bSuccess = FALSE;
81103100:	e03ff315 	stw	zero,-52(fp)
81103104:	00002206 	br	81103190 <POWER_Read+0x1e8>
				} else if (Channel != i) {
81103108:	e0fffa83 	ldbu	r3,-22(fp)
8110310c:	e0bff417 	ldw	r2,-48(fp)
81103110:	18801026 	beq	r3,r2,81103154 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103114:	e0bffa83 	ldbu	r2,-22(fp)
81103118:	d8800015 	stw	r2,0(sp)
8110311c:	e1fff417 	ldw	r7,-48(fp)
81103120:	e1bff417 	ldw	r6,-48(fp)
81103124:	01604534 	movhi	r5,33044
81103128:	2942a704 	addi	r5,r5,2716
8110312c:	01204534 	movhi	r4,33044
81103130:	211bff04 	addi	r4,r4,28668
81103134:	11170140 	call	81117014 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
81103138:	d0a05417 	ldw	r2,-32432(gp)
8110313c:	01604534 	movhi	r5,33044
81103140:	295bff04 	addi	r5,r5,28668
81103144:	1009883a 	mov	r4,r2
81103148:	11156840 	call	81115684 <fprintf>
#endif
					bSuccess = FALSE;
8110314c:	e03ff315 	stw	zero,-52(fp)
81103150:	00000f06 	br	81103190 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103154:	e0fffac3 	ldbu	r3,-21(fp)
81103158:	e0bff817 	ldw	r2,-32(fp)
8110315c:	18800c26 	beq	r3,r2,81103190 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103160:	e1bff417 	ldw	r6,-48(fp)
81103164:	01604534 	movhi	r5,33044
81103168:	2942b304 	addi	r5,r5,2764
8110316c:	01204534 	movhi	r4,33044
81103170:	211bff04 	addi	r4,r4,28668
81103174:	11170140 	call	81117014 <sprintf>
					debug(fp, cDebugBuffer);
81103178:	d0a05417 	ldw	r2,-32432(gp)
8110317c:	01604534 	movhi	r5,33044
81103180:	295bff04 	addi	r5,r5,28668
81103184:	1009883a 	mov	r4,r2
81103188:	11156840 	call	81115684 <fprintf>
#endif
					bSuccess = FALSE;
8110318c:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103190:	e0bff317 	ldw	r2,-52(fp)
81103194:	10001a26 	beq	r2,zero,81103200 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
81103198:	e0bff617 	ldw	r2,-40(fp)
8110319c:	10c00044 	addi	r3,r2,1
811031a0:	e0fff615 	stw	r3,-40(fp)
811031a4:	1085883a 	add	r2,r2,r2
811031a8:	1085883a 	add	r2,r2,r2
811031ac:	1007883a 	mov	r3,r2
811031b0:	e0bfff17 	ldw	r2,-4(fp)
811031b4:	10c5883a 	add	r2,r2,r3
811031b8:	e0fffe17 	ldw	r3,-8(fp)
811031bc:	10c00015 	stw	r3,0(r2)
811031c0:	00000f06 	br	81103200 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031c4:	00e04534 	movhi	r3,33044
811031c8:	18dbff04 	addi	r3,r3,28668
811031cc:	00a04534 	movhi	r2,33044
811031d0:	1082b904 	addi	r2,r2,2788
811031d4:	1009883a 	mov	r4,r2
811031d8:	00800444 	movi	r2,17
811031dc:	100d883a 	mov	r6,r2
811031e0:	200b883a 	mov	r5,r4
811031e4:	1809883a 	mov	r4,r3
811031e8:	11167340 	call	81116734 <memcpy>
				debug(fp, cDebugBuffer);
811031ec:	d0a05417 	ldw	r2,-32432(gp)
811031f0:	01604534 	movhi	r5,33044
811031f4:	295bff04 	addi	r5,r5,28668
811031f8:	1009883a 	mov	r4,r2
811031fc:	11156840 	call	81115684 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103200:	e0bff417 	ldw	r2,-48(fp)
81103204:	10800044 	addi	r2,r2,1
81103208:	e0bff415 	stw	r2,-48(fp)
8110320c:	e0bff517 	ldw	r2,-44(fp)
81103210:	1085883a 	add	r2,r2,r2
81103214:	1085883a 	add	r2,r2,r2
81103218:	e0fff304 	addi	r3,fp,-52
8110321c:	1885883a 	add	r2,r3,r2
81103220:	10800904 	addi	r2,r2,36
81103224:	10800017 	ldw	r2,0(r2)
81103228:	e0fff417 	ldw	r3,-48(fp)
8110322c:	1880020e 	bge	r3,r2,81103238 <POWER_Read+0x290>
81103230:	e0bff317 	ldw	r2,-52(fp)
81103234:	103f811e 	bne	r2,zero,8110303c <__reset+0xfb0e303c>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800044 	addi	r2,r2,1
81103240:	e0bff515 	stw	r2,-44(fp)
81103244:	e0bff517 	ldw	r2,-44(fp)
81103248:	10800088 	cmpgei	r2,r2,2
8110324c:	1000021e 	bne	r2,zero,81103258 <POWER_Read+0x2b0>
81103250:	e0bff317 	ldw	r2,-52(fp)
81103254:	103f691e 	bne	r2,zero,81102ffc <__reset+0xfb0e2ffc>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
81103258:	e0bff317 	ldw	r2,-52(fp)
}
8110325c:	e037883a 	mov	sp,fp
81103260:	dfc00117 	ldw	ra,4(sp)
81103264:	df000017 	ldw	fp,0(sp)
81103268:	dec00204 	addi	sp,sp,8
8110326c:	f800283a 	ret

81103270 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103270:	defff904 	addi	sp,sp,-28
81103274:	de00012e 	bgeu	sp,et,8110327c <TEMP_Read+0xc>
81103278:	003b68fa 	trap	3
8110327c:	dfc00615 	stw	ra,24(sp)
81103280:	df000515 	stw	fp,20(sp)
81103284:	df000504 	addi	fp,sp,20
81103288:	e13ffe15 	stw	r4,-8(fp)
8110328c:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103290:	00800c04 	movi	r2,48
81103294:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
81103298:	e0bffd83 	ldbu	r2,-10(fp)
8110329c:	10c03fcc 	andi	r3,r2,255
811032a0:	18c0201c 	xori	r3,r3,128
811032a4:	18ffe004 	addi	r3,r3,-128
811032a8:	e0bffdc4 	addi	r2,fp,-9
811032ac:	d8800015 	stw	r2,0(sp)
811032b0:	000f883a 	mov	r7,zero
811032b4:	180d883a 	mov	r6,r3
811032b8:	01600034 	movhi	r5,32768
811032bc:	29426004 	addi	r5,r5,2432
811032c0:	01200034 	movhi	r4,32768
811032c4:	21026404 	addi	r4,r4,2448
811032c8:	1105b300 	call	81105b30 <I2C_Read>
811032cc:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032d0:	e0bffc17 	ldw	r2,-16(fp)
811032d4:	10000226 	beq	r2,zero,811032e0 <TEMP_Read+0x70>
		BoardTemp = Data;
811032d8:	e0bffdc3 	ldbu	r2,-9(fp)
811032dc:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032e0:	e0bffc17 	ldw	r2,-16(fp)
811032e4:	10001226 	beq	r2,zero,81103330 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032e8:	e0bffd83 	ldbu	r2,-10(fp)
811032ec:	10c03fcc 	andi	r3,r2,255
811032f0:	18c0201c 	xori	r3,r3,128
811032f4:	18ffe004 	addi	r3,r3,-128
811032f8:	e0bffdc4 	addi	r2,fp,-9
811032fc:	d8800015 	stw	r2,0(sp)
81103300:	01c00044 	movi	r7,1
81103304:	180d883a 	mov	r6,r3
81103308:	01600034 	movhi	r5,32768
8110330c:	29426004 	addi	r5,r5,2432
81103310:	01200034 	movhi	r4,32768
81103314:	21026404 	addi	r4,r4,2448
81103318:	1105b300 	call	81105b30 <I2C_Read>
8110331c:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103320:	e0bffc17 	ldw	r2,-16(fp)
81103324:	10000226 	beq	r2,zero,81103330 <TEMP_Read+0xc0>
			FpgaTemp = Data;
81103328:	e0bffdc3 	ldbu	r2,-9(fp)
8110332c:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103330:	e0bffc17 	ldw	r2,-16(fp)
81103334:	10000626 	beq	r2,zero,81103350 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
81103338:	e0bffe17 	ldw	r2,-8(fp)
8110333c:	e0fffd03 	ldbu	r3,-12(fp)
81103340:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103344:	e0bfff17 	ldw	r2,-4(fp)
81103348:	e0fffd43 	ldbu	r3,-11(fp)
8110334c:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103350:	e0bffc17 	ldw	r2,-16(fp)
}
81103354:	e037883a 	mov	sp,fp
81103358:	dfc00117 	ldw	ra,4(sp)
8110335c:	df000017 	ldw	fp,0(sp)
81103360:	dec00204 	addi	sp,sp,8
81103364:	f800283a 	ret

81103368 <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
81103368:	defffb04 	addi	sp,sp,-20
8110336c:	de00012e 	bgeu	sp,et,81103374 <sense_log_temp+0xc>
81103370:	003b68fa 	trap	3
81103374:	dfc00415 	stw	ra,16(sp)
81103378:	df000315 	stw	fp,12(sp)
8110337c:	df000304 	addi	fp,sp,12
81103380:	e13ffe15 	stw	r4,-8(fp)
81103384:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
81103388:	e17fff17 	ldw	r5,-4(fp)
8110338c:	e13ffe17 	ldw	r4,-8(fp)
81103390:	11032700 	call	81103270 <TEMP_Read>
81103394:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
81103398:	e0bffd17 	ldw	r2,-12(fp)
}
8110339c:	e037883a 	mov	sp,fp
811033a0:	dfc00117 	ldw	ra,4(sp)
811033a4:	df000017 	ldw	fp,0(sp)
811033a8:	dec00204 	addi	sp,sp,8
811033ac:	f800283a 	ret

811033b0 <sense_log>:

void sense_log(void) {
811033b0:	deff0404 	addi	sp,sp,-1008
811033b4:	de00012e 	bgeu	sp,et,811033bc <sense_log+0xc>
811033b8:	003b68fa 	trap	3
811033bc:	dfc0fb15 	stw	ra,1004(sp)
811033c0:	df00fa15 	stw	fp,1000(sp)
811033c4:	dd40f915 	stw	r21,996(sp)
811033c8:	dd00f815 	stw	r20,992(sp)
811033cc:	dcc0f715 	stw	r19,988(sp)
811033d0:	dc80f615 	stw	r18,984(sp)
811033d4:	dc40f515 	stw	r17,980(sp)
811033d8:	dc00f415 	stw	r16,976(sp)
811033dc:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033e0:	00902834 	movhi	r2,16544
811033e4:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033e8:	008ed174 	movhi	r2,15173
811033ec:	10a6e984 	addi	r2,r2,-25690
811033f0:	e0bf2215 	stw	r2,-888(fp)
811033f4:	008ea0f4 	movhi	r2,14979
811033f8:	10849bc4 	addi	r2,r2,4719
811033fc:	e0bf2315 	stw	r2,-884(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2415 	stw	r2,-880(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2515 	stw	r2,-876(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2615 	stw	r2,-872(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2715 	stw	r2,-868(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2815 	stw	r2,-864(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2915 	stw	r2,-860(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2a15 	stw	r2,-856(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2b15 	stw	r2,-852(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2c15 	stw	r2,-848(fp)
8110346c:	008ed174 	movhi	r2,15173
81103470:	10a6e984 	addi	r2,r2,-25690
81103474:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2e15 	stw	r2,-840(fp)
81103484:	008fd9b4 	movhi	r2,16230
81103488:	10999984 	addi	r2,r2,26214
8110348c:	e0bf2f15 	stw	r2,-836(fp)
81103490:	00901034 	movhi	r2,16448
81103494:	e0bf3015 	stw	r2,-832(fp)
81103498:	008fd9b4 	movhi	r2,16230
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3115 	stw	r2,-828(fp)
811034a4:	008ff9b4 	movhi	r2,16358
811034a8:	10999984 	addi	r2,r2,26214
811034ac:	e0bf3215 	stw	r2,-824(fp)
811034b0:	00900834 	movhi	r2,16416
811034b4:	e0bf3315 	stw	r2,-820(fp)
811034b8:	008ff9b4 	movhi	r2,16358
811034bc:	10999984 	addi	r2,r2,26214
811034c0:	e0bf3415 	stw	r2,-816(fp)
811034c4:	00900834 	movhi	r2,16416
811034c8:	e0bf3515 	stw	r2,-812(fp)
811034cc:	008fe374 	movhi	r2,16269
811034d0:	10b33344 	addi	r2,r2,-13107
811034d4:	e0bf3615 	stw	r2,-808(fp)
811034d8:	008fecf4 	movhi	r2,16307
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3715 	stw	r2,-804(fp)
811034e4:	009014f4 	movhi	r2,16467
811034e8:	108cccc4 	addi	r2,r2,13107
811034ec:	e0bf3815 	stw	r2,-800(fp)
811034f0:	00900834 	movhi	r2,16416
811034f4:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034f8:	00a04534 	movhi	r2,33044
811034fc:	1082f004 	addi	r2,r2,3008
81103500:	e0ff3a04 	addi	r3,fp,-792
81103504:	1009883a 	mov	r4,r2
81103508:	0080c004 	movi	r2,768
8110350c:	100d883a 	mov	r6,r2
81103510:	200b883a 	mov	r5,r4
81103514:	1809883a 	mov	r4,r3
81103518:	11167340 	call	81116734 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
8110351c:	e0bf1604 	addi	r2,fp,-936
81103520:	1009883a 	mov	r4,r2
81103524:	1102fa80 	call	81102fa8 <POWER_Read>
81103528:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
8110352c:	e0bf0f17 	ldw	r2,-964(fp)
81103530:	10016026 	beq	r2,zero,81103ab4 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103534:	e03f0c15 	stw	zero,-976(fp)
81103538:	00014c06 	br	81103a6c <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
8110353c:	e0bf0c17 	ldw	r2,-976(fp)
81103540:	1085883a 	add	r2,r2,r2
81103544:	1085883a 	add	r2,r2,r2
81103548:	e0ff0c04 	addi	r3,fp,-976
8110354c:	1885883a 	add	r2,r3,r2
81103550:	10800a04 	addi	r2,r2,40
81103554:	10800017 	ldw	r2,0(r2)
81103558:	1004d77a 	srli	r2,r2,29
8110355c:	1080004c 	andi	r2,r2,1
81103560:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103564:	e0bf0c17 	ldw	r2,-976(fp)
81103568:	1085883a 	add	r2,r2,r2
8110356c:	1085883a 	add	r2,r2,r2
81103570:	e0ff0c04 	addi	r3,fp,-976
81103574:	1885883a 	add	r2,r3,r2
81103578:	10800a04 	addi	r2,r2,40
8110357c:	10800017 	ldw	r2,0(r2)
81103580:	1004d73a 	srli	r2,r2,28
81103584:	1080004c 	andi	r2,r2,1
81103588:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
8110358c:	e0bf0c17 	ldw	r2,-976(fp)
81103590:	1085883a 	add	r2,r2,r2
81103594:	1085883a 	add	r2,r2,r2
81103598:	e0ff0c04 	addi	r3,fp,-976
8110359c:	1885883a 	add	r2,r3,r2
811035a0:	10800a04 	addi	r2,r2,40
811035a4:	10800017 	ldw	r2,0(r2)
811035a8:	1006d1ba 	srli	r3,r2,6
811035ac:	00801034 	movhi	r2,64
811035b0:	10bfffc4 	addi	r2,r2,-1
811035b4:	1884703a 	and	r2,r3,r2
811035b8:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035bc:	e0bf1117 	ldw	r2,-956(fp)
811035c0:	1000091e 	bne	r2,zero,811035e8 <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035c4:	e13f1217 	ldw	r4,-952(fp)
811035c8:	11149ec0 	call	811149ec <__floatunsisf>
811035cc:	1007883a 	mov	r3,r2
811035d0:	0152a034 	movhi	r5,19072
811035d4:	1809883a 	mov	r4,r3
811035d8:	11140740 	call	81114074 <__divsf3>
811035dc:	1007883a 	mov	r3,r2
811035e0:	e0ff0d15 	stw	r3,-972(fp)
811035e4:	00000106 	br	811035ec <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035e8:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035ec:	e0bf1017 	ldw	r2,-960(fp)
811035f0:	10002626 	beq	r2,zero,8110368c <sense_log+0x2dc>
811035f4:	e0bf1117 	ldw	r2,-956(fp)
811035f8:	10002426 	beq	r2,zero,8110368c <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035fc:	014fc034 	movhi	r5,16128
81103600:	e13f0e17 	ldw	r4,-968(fp)
81103604:	11144bc0 	call	811144bc <__mulsf3>
81103608:	1007883a 	mov	r3,r2
8110360c:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103610:	e0ff3a04 	addi	r3,fp,-792
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	100491ba 	slli	r2,r2,6
8110361c:	18a1883a 	add	r16,r3,r2
81103620:	e0bf0c17 	ldw	r2,-976(fp)
81103624:	1085883a 	add	r2,r2,r2
81103628:	1085883a 	add	r2,r2,r2
8110362c:	e0ff0c04 	addi	r3,fp,-976
81103630:	1885883a 	add	r2,r3,r2
81103634:	10800a04 	addi	r2,r2,40
81103638:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
8110363c:	1023883a 	mov	r17,r2
81103640:	e13f1317 	ldw	r4,-948(fp)
81103644:	11152040 	call	81115204 <__extendsfdf2>
81103648:	1009883a 	mov	r4,r2
8110364c:	180b883a 	mov	r5,r3
81103650:	d9000015 	stw	r4,0(sp)
81103654:	d9400115 	stw	r5,4(sp)
81103658:	880f883a 	mov	r7,r17
8110365c:	800d883a 	mov	r6,r16
81103660:	01604534 	movhi	r5,33044
81103664:	2942be04 	addi	r5,r5,2808
81103668:	01204534 	movhi	r4,33044
8110366c:	211bff04 	addi	r4,r4,28668
81103670:	11170140 	call	81117014 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103674:	d0a05417 	ldw	r2,-32432(gp)
81103678:	01604534 	movhi	r5,33044
8110367c:	295bff04 	addi	r5,r5,28668
81103680:	1009883a 	mov	r4,r2
81103684:	11156840 	call	81115684 <fprintf>
81103688:	0000f506 	br	81103a60 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
8110368c:	e0bf1017 	ldw	r2,-960(fp)
81103690:	10006426 	beq	r2,zero,81103824 <sense_log+0x474>
81103694:	e0bf1117 	ldw	r2,-956(fp)
81103698:	1000621e 	bne	r2,zero,81103824 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
8110369c:	e13f0e17 	ldw	r4,-968(fp)
811036a0:	11152040 	call	81115204 <__extendsfdf2>
811036a4:	1011883a 	mov	r8,r2
811036a8:	1813883a 	mov	r9,r3
811036ac:	000d883a 	mov	r6,zero
811036b0:	01cff834 	movhi	r7,16352
811036b4:	4009883a 	mov	r4,r8
811036b8:	480b883a 	mov	r5,r9
811036bc:	1114ae40 	call	81114ae4 <__muldf3>
811036c0:	1009883a 	mov	r4,r2
811036c4:	180b883a 	mov	r5,r3
811036c8:	2021883a 	mov	r16,r4
811036cc:	2823883a 	mov	r17,r5
811036d0:	e13f0d17 	ldw	r4,-972(fp)
811036d4:	11152040 	call	81115204 <__extendsfdf2>
811036d8:	1009883a 	mov	r4,r2
811036dc:	180b883a 	mov	r5,r3
811036e0:	200d883a 	mov	r6,r4
811036e4:	280f883a 	mov	r7,r5
811036e8:	8009883a 	mov	r4,r16
811036ec:	880b883a 	mov	r5,r17
811036f0:	1114ae40 	call	81114ae4 <__muldf3>
811036f4:	1009883a 	mov	r4,r2
811036f8:	180b883a 	mov	r5,r3
811036fc:	2005883a 	mov	r2,r4
81103700:	2807883a 	mov	r3,r5
81103704:	1009883a 	mov	r4,r2
81103708:	180b883a 	mov	r5,r3
8110370c:	111531c0 	call	8111531c <__truncdfsf2>
81103710:	1007883a 	mov	r3,r2
81103714:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
81103718:	e0bf0c17 	ldw	r2,-976(fp)
8110371c:	1085883a 	add	r2,r2,r2
81103720:	1085883a 	add	r2,r2,r2
81103724:	e0ff0c04 	addi	r3,fp,-976
81103728:	1885883a 	add	r2,r3,r2
8110372c:	10801604 	addi	r2,r2,88
81103730:	10c00017 	ldw	r3,0(r2)
81103734:	180b883a 	mov	r5,r3
81103738:	e13f0d17 	ldw	r4,-972(fp)
8110373c:	11140740 	call	81114074 <__divsf3>
81103740:	1007883a 	mov	r3,r2
81103744:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
81103748:	e0bf0c17 	ldw	r2,-976(fp)
8110374c:	1085883a 	add	r2,r2,r2
81103750:	1085883a 	add	r2,r2,r2
81103754:	e0ff0c04 	addi	r3,fp,-976
81103758:	1885883a 	add	r2,r3,r2
8110375c:	10802204 	addi	r2,r2,136
81103760:	10c00017 	ldw	r3,0(r2)
81103764:	e17f1417 	ldw	r5,-944(fp)
81103768:	1809883a 	mov	r4,r3
8110376c:	11144bc0 	call	811144bc <__mulsf3>
81103770:	1007883a 	mov	r3,r2
81103774:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103778:	e0ff3a04 	addi	r3,fp,-792
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	100491ba 	slli	r2,r2,6
81103784:	18a9883a 	add	r20,r3,r2
81103788:	e0bf0c17 	ldw	r2,-976(fp)
8110378c:	1085883a 	add	r2,r2,r2
81103790:	1085883a 	add	r2,r2,r2
81103794:	e0ff0c04 	addi	r3,fp,-976
81103798:	1885883a 	add	r2,r3,r2
8110379c:	10800a04 	addi	r2,r2,40
811037a0:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811037a4:	102b883a 	mov	r21,r2
811037a8:	e13f0d17 	ldw	r4,-972(fp)
811037ac:	11152040 	call	81115204 <__extendsfdf2>
811037b0:	1021883a 	mov	r16,r2
811037b4:	1823883a 	mov	r17,r3
811037b8:	e13f1417 	ldw	r4,-944(fp)
811037bc:	11152040 	call	81115204 <__extendsfdf2>
811037c0:	1025883a 	mov	r18,r2
811037c4:	1827883a 	mov	r19,r3
811037c8:	e13f1517 	ldw	r4,-940(fp)
811037cc:	11152040 	call	81115204 <__extendsfdf2>
811037d0:	1009883a 	mov	r4,r2
811037d4:	180b883a 	mov	r5,r3
811037d8:	d9000415 	stw	r4,16(sp)
811037dc:	d9400515 	stw	r5,20(sp)
811037e0:	dc800215 	stw	r18,8(sp)
811037e4:	dcc00315 	stw	r19,12(sp)
811037e8:	dc000015 	stw	r16,0(sp)
811037ec:	dc400115 	stw	r17,4(sp)
811037f0:	a80f883a 	mov	r7,r21
811037f4:	a00d883a 	mov	r6,r20
811037f8:	01604534 	movhi	r5,33044
811037fc:	2942c704 	addi	r5,r5,2844
81103800:	01204534 	movhi	r4,33044
81103804:	211bff04 	addi	r4,r4,28668
81103808:	11170140 	call	81117014 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
8110380c:	d0a05417 	ldw	r2,-32432(gp)
81103810:	01604534 	movhi	r5,33044
81103814:	295bff04 	addi	r5,r5,28668
81103818:	1009883a 	mov	r4,r2
8110381c:	11156840 	call	81115684 <fprintf>
81103820:	00008f06 	br	81103a60 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103824:	e0bf1017 	ldw	r2,-960(fp)
81103828:	1000641e 	bne	r2,zero,811039bc <sense_log+0x60c>
8110382c:	e0bf1117 	ldw	r2,-956(fp)
81103830:	10006226 	beq	r2,zero,811039bc <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103834:	e13f0e17 	ldw	r4,-968(fp)
81103838:	11152040 	call	81115204 <__extendsfdf2>
8110383c:	1011883a 	mov	r8,r2
81103840:	1813883a 	mov	r9,r3
81103844:	000d883a 	mov	r6,zero
81103848:	01cff834 	movhi	r7,16352
8110384c:	4009883a 	mov	r4,r8
81103850:	480b883a 	mov	r5,r9
81103854:	1114ae40 	call	81114ae4 <__muldf3>
81103858:	1009883a 	mov	r4,r2
8110385c:	180b883a 	mov	r5,r3
81103860:	2021883a 	mov	r16,r4
81103864:	2823883a 	mov	r17,r5
81103868:	e13f0d17 	ldw	r4,-972(fp)
8110386c:	11152040 	call	81115204 <__extendsfdf2>
81103870:	1009883a 	mov	r4,r2
81103874:	180b883a 	mov	r5,r3
81103878:	200d883a 	mov	r6,r4
8110387c:	280f883a 	mov	r7,r5
81103880:	8009883a 	mov	r4,r16
81103884:	880b883a 	mov	r5,r17
81103888:	1114ae40 	call	81114ae4 <__muldf3>
8110388c:	1009883a 	mov	r4,r2
81103890:	180b883a 	mov	r5,r3
81103894:	2005883a 	mov	r2,r4
81103898:	2807883a 	mov	r3,r5
8110389c:	1009883a 	mov	r4,r2
811038a0:	180b883a 	mov	r5,r3
811038a4:	111531c0 	call	8111531c <__truncdfsf2>
811038a8:	1007883a 	mov	r3,r2
811038ac:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038b0:	e0bf0c17 	ldw	r2,-976(fp)
811038b4:	1085883a 	add	r2,r2,r2
811038b8:	1085883a 	add	r2,r2,r2
811038bc:	e0ff0c04 	addi	r3,fp,-976
811038c0:	1885883a 	add	r2,r3,r2
811038c4:	10801604 	addi	r2,r2,88
811038c8:	10c00017 	ldw	r3,0(r2)
811038cc:	180b883a 	mov	r5,r3
811038d0:	e13f0d17 	ldw	r4,-972(fp)
811038d4:	11140740 	call	81114074 <__divsf3>
811038d8:	1007883a 	mov	r3,r2
811038dc:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038e0:	e0bf0c17 	ldw	r2,-976(fp)
811038e4:	1085883a 	add	r2,r2,r2
811038e8:	1085883a 	add	r2,r2,r2
811038ec:	e0ff0c04 	addi	r3,fp,-976
811038f0:	1885883a 	add	r2,r3,r2
811038f4:	10802204 	addi	r2,r2,136
811038f8:	10c00017 	ldw	r3,0(r2)
811038fc:	e17f1417 	ldw	r5,-944(fp)
81103900:	1809883a 	mov	r4,r3
81103904:	11144bc0 	call	811144bc <__mulsf3>
81103908:	1007883a 	mov	r3,r2
8110390c:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103910:	e0ff3a04 	addi	r3,fp,-792
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	100491ba 	slli	r2,r2,6
8110391c:	18a9883a 	add	r20,r3,r2
81103920:	e0bf0c17 	ldw	r2,-976(fp)
81103924:	1085883a 	add	r2,r2,r2
81103928:	1085883a 	add	r2,r2,r2
8110392c:	e0ff0c04 	addi	r3,fp,-976
81103930:	1885883a 	add	r2,r3,r2
81103934:	10800a04 	addi	r2,r2,40
81103938:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110393c:	102b883a 	mov	r21,r2
81103940:	e13f0d17 	ldw	r4,-972(fp)
81103944:	11152040 	call	81115204 <__extendsfdf2>
81103948:	1021883a 	mov	r16,r2
8110394c:	1823883a 	mov	r17,r3
81103950:	e13f1417 	ldw	r4,-944(fp)
81103954:	11152040 	call	81115204 <__extendsfdf2>
81103958:	1025883a 	mov	r18,r2
8110395c:	1827883a 	mov	r19,r3
81103960:	e13f1517 	ldw	r4,-940(fp)
81103964:	11152040 	call	81115204 <__extendsfdf2>
81103968:	1009883a 	mov	r4,r2
8110396c:	180b883a 	mov	r5,r3
81103970:	d9000415 	stw	r4,16(sp)
81103974:	d9400515 	stw	r5,20(sp)
81103978:	dc800215 	stw	r18,8(sp)
8110397c:	dcc00315 	stw	r19,12(sp)
81103980:	dc000015 	stw	r16,0(sp)
81103984:	dc400115 	stw	r17,4(sp)
81103988:	a80f883a 	mov	r7,r21
8110398c:	a00d883a 	mov	r6,r20
81103990:	01604534 	movhi	r5,33044
81103994:	2942d704 	addi	r5,r5,2908
81103998:	01204534 	movhi	r4,33044
8110399c:	211bff04 	addi	r4,r4,28668
811039a0:	11170140 	call	81117014 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
811039a4:	d0a05417 	ldw	r2,-32432(gp)
811039a8:	01604534 	movhi	r5,33044
811039ac:	295bff04 	addi	r5,r5,28668
811039b0:	1009883a 	mov	r4,r2
811039b4:	11156840 	call	81115684 <fprintf>
811039b8:	00002906 	br	81103a60 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039bc:	e0bf1017 	ldw	r2,-960(fp)
811039c0:	1000271e 	bne	r2,zero,81103a60 <sense_log+0x6b0>
811039c4:	e0bf1117 	ldw	r2,-956(fp)
811039c8:	1000251e 	bne	r2,zero,81103a60 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039cc:	e0bf0e17 	ldw	r2,-968(fp)
811039d0:	10a0003c 	xorhi	r2,r2,32768
811039d4:	014fc034 	movhi	r5,16128
811039d8:	1009883a 	mov	r4,r2
811039dc:	11144bc0 	call	811144bc <__mulsf3>
811039e0:	1007883a 	mov	r3,r2
811039e4:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039e8:	e0ff3a04 	addi	r3,fp,-792
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	100491ba 	slli	r2,r2,6
811039f4:	18a1883a 	add	r16,r3,r2
811039f8:	e0bf0c17 	ldw	r2,-976(fp)
811039fc:	1085883a 	add	r2,r2,r2
81103a00:	1085883a 	add	r2,r2,r2
81103a04:	e0ff0c04 	addi	r3,fp,-976
81103a08:	1885883a 	add	r2,r3,r2
81103a0c:	10800a04 	addi	r2,r2,40
81103a10:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a14:	1023883a 	mov	r17,r2
81103a18:	e13f1317 	ldw	r4,-948(fp)
81103a1c:	11152040 	call	81115204 <__extendsfdf2>
81103a20:	1009883a 	mov	r4,r2
81103a24:	180b883a 	mov	r5,r3
81103a28:	d9000015 	stw	r4,0(sp)
81103a2c:	d9400115 	stw	r5,4(sp)
81103a30:	880f883a 	mov	r7,r17
81103a34:	800d883a 	mov	r6,r16
81103a38:	01604534 	movhi	r5,33044
81103a3c:	2942e704 	addi	r5,r5,2972
81103a40:	01204534 	movhi	r4,33044
81103a44:	211bff04 	addi	r4,r4,28668
81103a48:	11170140 	call	81117014 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a4c:	d0a05417 	ldw	r2,-32432(gp)
81103a50:	01604534 	movhi	r5,33044
81103a54:	295bff04 	addi	r5,r5,28668
81103a58:	1009883a 	mov	r4,r2
81103a5c:	11156840 	call	81115684 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800044 	addi	r2,r2,1
81103a68:	e0bf0c15 	stw	r2,-976(fp)
81103a6c:	e0bf0c17 	ldw	r2,-976(fp)
81103a70:	10800308 	cmpgei	r2,r2,12
81103a74:	1000021e 	bne	r2,zero,81103a80 <sense_log+0x6d0>
81103a78:	e0bf0f17 	ldw	r2,-964(fp)
81103a7c:	103eaf1e 	bne	r2,zero,8110353c <__reset+0xfb0e353c>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a80:	00a04534 	movhi	r2,33044
81103a84:	109bff04 	addi	r2,r2,28668
81103a88:	00c00344 	movi	r3,13
81103a8c:	10c00005 	stb	r3,0(r2)
81103a90:	00c00284 	movi	r3,10
81103a94:	10c00045 	stb	r3,1(r2)
81103a98:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a9c:	d0a05417 	ldw	r2,-32432(gp)
81103aa0:	01604534 	movhi	r5,33044
81103aa4:	295bff04 	addi	r5,r5,28668
81103aa8:	1009883a 	mov	r4,r2
81103aac:	11156840 	call	81115684 <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103ab0:	00001606 	br	81103b0c <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103ab4:	00a04534 	movhi	r2,33044
81103ab8:	109bff04 	addi	r2,r2,28668
81103abc:	00c01144 	movi	r3,69
81103ac0:	10c00005 	stb	r3,0(r2)
81103ac4:	00c01c84 	movi	r3,114
81103ac8:	10c00045 	stb	r3,1(r2)
81103acc:	00c01c84 	movi	r3,114
81103ad0:	10c00085 	stb	r3,2(r2)
81103ad4:	00c01bc4 	movi	r3,111
81103ad8:	10c000c5 	stb	r3,3(r2)
81103adc:	00c01c84 	movi	r3,114
81103ae0:	10c00105 	stb	r3,4(r2)
81103ae4:	00c00344 	movi	r3,13
81103ae8:	10c00145 	stb	r3,5(r2)
81103aec:	00c00284 	movi	r3,10
81103af0:	10c00185 	stb	r3,6(r2)
81103af4:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103af8:	d0a05417 	ldw	r2,-32432(gp)
81103afc:	01604534 	movhi	r5,33044
81103b00:	295bff04 	addi	r5,r5,28668
81103b04:	1009883a 	mov	r4,r2
81103b08:	11156840 	call	81115684 <fprintf>
#endif
	}
}
81103b0c:	0001883a 	nop
81103b10:	e6fffa04 	addi	sp,fp,-24
81103b14:	dfc00717 	ldw	ra,28(sp)
81103b18:	df000617 	ldw	fp,24(sp)
81103b1c:	dd400517 	ldw	r21,20(sp)
81103b20:	dd000417 	ldw	r20,16(sp)
81103b24:	dcc00317 	ldw	r19,12(sp)
81103b28:	dc800217 	ldw	r18,8(sp)
81103b2c:	dc400117 	ldw	r17,4(sp)
81103b30:	dc000017 	ldw	r16,0(sp)
81103b34:	dec00804 	addi	sp,sp,32
81103b38:	f800283a 	ret

81103b3c <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b3c:	defffc04 	addi	sp,sp,-16
81103b40:	de00012e 	bgeu	sp,et,81103b48 <bSdmaInitM1Dma+0xc>
81103b44:	003b68fa 	trap	3
81103b48:	dfc00315 	stw	ra,12(sp)
81103b4c:	df000215 	stw	fp,8(sp)
81103b50:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b54:	00800044 	movi	r2,1
81103b58:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b5c:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b60:	01204534 	movhi	r4,33044
81103b64:	2103b004 	addi	r4,r4,3776
81103b68:	113e8400 	call	8113e840 <alt_msgdma_open>
81103b6c:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b70:	d0a03917 	ldw	r2,-32540(gp)
81103b74:	1000021e 	bne	r2,zero,81103b80 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b78:	e03ffe15 	stw	zero,-8(fp)
81103b7c:	00001506 	br	81103bd4 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b80:	d0a03917 	ldw	r2,-32540(gp)
81103b84:	10800317 	ldw	r2,12(r2)
81103b88:	10800104 	addi	r2,r2,4
81103b8c:	00c00084 	movi	r3,2
81103b90:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b94:	00000a06 	br	81103bc0 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b98:	01000044 	movi	r4,1
81103b9c:	112c95c0 	call	8112c95c <usleep>
			usiCounter++;
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	10800044 	addi	r2,r2,1
81103ba8:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103bac:	e0bfff0b 	ldhu	r2,-4(fp)
81103bb0:	1084e230 	cmpltui	r2,r2,5000
81103bb4:	1000021e 	bne	r2,zero,81103bc0 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bb8:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bbc:	00000506 	br	81103bd4 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc0:	d0a03917 	ldw	r2,-32540(gp)
81103bc4:	10800317 	ldw	r2,12(r2)
81103bc8:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bcc:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bd0:	103ff11e 	bne	r2,zero,81103b98 <__reset+0xfb0e3b98>
				break;
			}
		}
	}

	return bStatus;
81103bd4:	e0bffe17 	ldw	r2,-8(fp)
}
81103bd8:	e037883a 	mov	sp,fp
81103bdc:	dfc00117 	ldw	ra,4(sp)
81103be0:	df000017 	ldw	fp,0(sp)
81103be4:	dec00204 	addi	sp,sp,8
81103be8:	f800283a 	ret

81103bec <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103bec:	defffc04 	addi	sp,sp,-16
81103bf0:	de00012e 	bgeu	sp,et,81103bf8 <bSdmaInitM2Dma+0xc>
81103bf4:	003b68fa 	trap	3
81103bf8:	dfc00315 	stw	ra,12(sp)
81103bfc:	df000215 	stw	fp,8(sp)
81103c00:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103c04:	00800044 	movi	r2,1
81103c08:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c0c:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c10:	01204534 	movhi	r4,33044
81103c14:	2103b504 	addi	r4,r4,3796
81103c18:	113e8400 	call	8113e840 <alt_msgdma_open>
81103c1c:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c20:	d0a03a17 	ldw	r2,-32536(gp)
81103c24:	1000021e 	bne	r2,zero,81103c30 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c28:	e03ffe15 	stw	zero,-8(fp)
81103c2c:	00001506 	br	81103c84 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c30:	d0a03a17 	ldw	r2,-32536(gp)
81103c34:	10800317 	ldw	r2,12(r2)
81103c38:	10800104 	addi	r2,r2,4
81103c3c:	00c00084 	movi	r3,2
81103c40:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c44:	00000a06 	br	81103c70 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c48:	01000044 	movi	r4,1
81103c4c:	112c95c0 	call	8112c95c <usleep>
			usiCounter++;
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	10800044 	addi	r2,r2,1
81103c58:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c5c:	e0bfff0b 	ldhu	r2,-4(fp)
81103c60:	1084e230 	cmpltui	r2,r2,5000
81103c64:	1000021e 	bne	r2,zero,81103c70 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c68:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c6c:	00000506 	br	81103c84 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c70:	d0a03a17 	ldw	r2,-32536(gp)
81103c74:	10800317 	ldw	r2,12(r2)
81103c78:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c7c:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c80:	103ff11e 	bne	r2,zero,81103c48 <__reset+0xfb0e3c48>
				break;
			}
		}
	}

	return bStatus;
81103c84:	e0bffe17 	ldw	r2,-8(fp)
}
81103c88:	e037883a 	mov	sp,fp
81103c8c:	dfc00117 	ldw	ra,4(sp)
81103c90:	df000017 	ldw	fp,0(sp)
81103c94:	dec00204 	addi	sp,sp,8
81103c98:	f800283a 	ret

81103c9c <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c9c:	deffe904 	addi	sp,sp,-92
81103ca0:	de00012e 	bgeu	sp,et,81103ca8 <bSdmaDmaM1Transfer+0xc>
81103ca4:	003b68fa 	trap	3
81103ca8:	dfc01615 	stw	ra,88(sp)
81103cac:	df001515 	stw	fp,84(sp)
81103cb0:	dc001415 	stw	r16,80(sp)
81103cb4:	df001504 	addi	fp,sp,84
81103cb8:	e13ffb15 	stw	r4,-20(fp)
81103cbc:	2809883a 	mov	r4,r5
81103cc0:	3007883a 	mov	r3,r6
81103cc4:	3805883a 	mov	r2,r7
81103cc8:	e13ffc0d 	sth	r4,-16(fp)
81103ccc:	e0fffd05 	stb	r3,-12(fp)
81103cd0:	e0bffe05 	stb	r2,-8(fp)
81103cd4:	defff004 	addi	sp,sp,-64
81103cd8:	d8800904 	addi	r2,sp,36
81103cdc:	108007c4 	addi	r2,r2,31
81103ce0:	1004d17a 	srli	r2,r2,5
81103ce4:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103ce8:	00800044 	movi	r2,1
81103cec:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81103cf0:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103cf4:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cf8:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cfc:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103d00:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103d04:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81103d08:	e0bffe03 	ldbu	r2,-8(fp)
81103d0c:	10c00268 	cmpgeui	r3,r2,9
81103d10:	1800a51e 	bne	r3,zero,81103fa8 <bSdmaDmaM1Transfer+0x30c>
81103d14:	100690ba 	slli	r3,r2,2
81103d18:	00a04434 	movhi	r2,33040
81103d1c:	108f4b04 	addi	r2,r2,15660
81103d20:	1885883a 	add	r2,r3,r2
81103d24:	10800017 	ldw	r2,0(r2)
81103d28:	1000683a 	jmp	r2
81103d2c:	81103fa8 	cmpgeui	r4,r16,16638
81103d30:	81103d50 	cmplti	r4,r16,16629
81103d34:	81103d94 	ori	r4,r16,16630
81103d38:	81103de0 	cmpeqi	r4,r16,16631
81103d3c:	81103e2c 	andhi	r4,r16,16632
81103d40:	81103e78 	rdprs	r4,r16,16633
81103d44:	81103ec4 	addi	r4,r16,16635
81103d48:	81103f10 	cmplti	r4,r16,16636
81103d4c:	81103f5c 	xori	r4,r16,16637
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d50:	e0bffd03 	ldbu	r2,-12(fp)
81103d54:	10000326 	beq	r2,zero,81103d64 <bSdmaDmaM1Transfer+0xc8>
81103d58:	10800060 	cmpeqi	r2,r2,1
81103d5c:	1000051e 	bne	r2,zero,81103d74 <bSdmaDmaM1Transfer+0xd8>
81103d60:	00000906 	br	81103d88 <bSdmaDmaM1Transfer+0xec>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d64:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d68:	00800044 	movi	r2,1
81103d6c:	e0bff715 	stw	r2,-36(fp)
			break;
81103d70:	00000706 	br	81103d90 <bSdmaDmaM1Transfer+0xf4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d74:	00800074 	movhi	r2,1
81103d78:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d7c:	00800044 	movi	r2,1
81103d80:	e0bff715 	stw	r2,-36(fp)
			break;
81103d84:	00000206 	br	81103d90 <bSdmaDmaM1Transfer+0xf4>
		default:
			bStatus = FALSE;
81103d88:	e03ff415 	stw	zero,-48(fp)
			break;
81103d8c:	0001883a 	nop
		}
		break;
81103d90:	00008706 	br	81103fb0 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d94:	e0bffd03 	ldbu	r2,-12(fp)
81103d98:	10000326 	beq	r2,zero,81103da8 <bSdmaDmaM1Transfer+0x10c>
81103d9c:	10800060 	cmpeqi	r2,r2,1
81103da0:	1000061e 	bne	r2,zero,81103dbc <bSdmaDmaM1Transfer+0x120>
81103da4:	00000b06 	br	81103dd4 <bSdmaDmaM1Transfer+0x138>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103da8:	00880004 	movi	r2,8192
81103dac:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff715 	stw	r2,-36(fp)
			break;
81103db8:	00000806 	br	81103ddc <bSdmaDmaM1Transfer+0x140>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103dbc:	00800074 	movhi	r2,1
81103dc0:	10880004 	addi	r2,r2,8192
81103dc4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103dc8:	00800044 	movi	r2,1
81103dcc:	e0bff715 	stw	r2,-36(fp)
			break;
81103dd0:	00000206 	br	81103ddc <bSdmaDmaM1Transfer+0x140>
		default:
			bStatus = FALSE;
81103dd4:	e03ff415 	stw	zero,-48(fp)
			break;
81103dd8:	0001883a 	nop
		}
		break;
81103ddc:	00007406 	br	81103fb0 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103de0:	e0bffd03 	ldbu	r2,-12(fp)
81103de4:	10000326 	beq	r2,zero,81103df4 <bSdmaDmaM1Transfer+0x158>
81103de8:	10800060 	cmpeqi	r2,r2,1
81103dec:	1000061e 	bne	r2,zero,81103e08 <bSdmaDmaM1Transfer+0x16c>
81103df0:	00000b06 	br	81103e20 <bSdmaDmaM1Transfer+0x184>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103df4:	00900004 	movi	r2,16384
81103df8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103dfc:	00800044 	movi	r2,1
81103e00:	e0bff715 	stw	r2,-36(fp)
			break;
81103e04:	00000806 	br	81103e28 <bSdmaDmaM1Transfer+0x18c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103e08:	00800074 	movhi	r2,1
81103e0c:	10900004 	addi	r2,r2,16384
81103e10:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103e14:	00800044 	movi	r2,1
81103e18:	e0bff715 	stw	r2,-36(fp)
			break;
81103e1c:	00000206 	br	81103e28 <bSdmaDmaM1Transfer+0x18c>
		default:
			bStatus = FALSE;
81103e20:	e03ff415 	stw	zero,-48(fp)
			break;
81103e24:	0001883a 	nop
		}
		break;
81103e28:	00006106 	br	81103fb0 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e2c:	e0bffd03 	ldbu	r2,-12(fp)
81103e30:	10000326 	beq	r2,zero,81103e40 <bSdmaDmaM1Transfer+0x1a4>
81103e34:	10800060 	cmpeqi	r2,r2,1
81103e38:	1000061e 	bne	r2,zero,81103e54 <bSdmaDmaM1Transfer+0x1b8>
81103e3c:	00000b06 	br	81103e6c <bSdmaDmaM1Transfer+0x1d0>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e40:	00980004 	movi	r2,24576
81103e44:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e48:	00800044 	movi	r2,1
81103e4c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e50:	00000806 	br	81103e74 <bSdmaDmaM1Transfer+0x1d8>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e54:	00800074 	movhi	r2,1
81103e58:	10980004 	addi	r2,r2,24576
81103e5c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e60:	00800044 	movi	r2,1
81103e64:	e0bff715 	stw	r2,-36(fp)
			break;
81103e68:	00000206 	br	81103e74 <bSdmaDmaM1Transfer+0x1d8>
		default:
			bStatus = FALSE;
81103e6c:	e03ff415 	stw	zero,-48(fp)
			break;
81103e70:	0001883a 	nop
		}
		break;
81103e74:	00004e06 	br	81103fb0 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e78:	e0bffd03 	ldbu	r2,-12(fp)
81103e7c:	10000326 	beq	r2,zero,81103e8c <bSdmaDmaM1Transfer+0x1f0>
81103e80:	10800060 	cmpeqi	r2,r2,1
81103e84:	1000061e 	bne	r2,zero,81103ea0 <bSdmaDmaM1Transfer+0x204>
81103e88:	00000b06 	br	81103eb8 <bSdmaDmaM1Transfer+0x21c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103e8c:	00a00014 	movui	r2,32768
81103e90:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103e94:	00800044 	movi	r2,1
81103e98:	e0bff715 	stw	r2,-36(fp)
			break;
81103e9c:	00000806 	br	81103ec0 <bSdmaDmaM1Transfer+0x224>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103ea0:	008000b4 	movhi	r2,2
81103ea4:	10a00004 	addi	r2,r2,-32768
81103ea8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103eac:	00800044 	movi	r2,1
81103eb0:	e0bff715 	stw	r2,-36(fp)
			break;
81103eb4:	00000206 	br	81103ec0 <bSdmaDmaM1Transfer+0x224>
		default:
			bStatus = FALSE;
81103eb8:	e03ff415 	stw	zero,-48(fp)
			break;
81103ebc:	0001883a 	nop
		}
		break;
81103ec0:	00003b06 	br	81103fb0 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ec4:	e0bffd03 	ldbu	r2,-12(fp)
81103ec8:	10000326 	beq	r2,zero,81103ed8 <bSdmaDmaM1Transfer+0x23c>
81103ecc:	10800060 	cmpeqi	r2,r2,1
81103ed0:	1000061e 	bne	r2,zero,81103eec <bSdmaDmaM1Transfer+0x250>
81103ed4:	00000b06 	br	81103f04 <bSdmaDmaM1Transfer+0x268>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103ed8:	00a80014 	movui	r2,40960
81103edc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103ee0:	00800044 	movi	r2,1
81103ee4:	e0bff715 	stw	r2,-36(fp)
			break;
81103ee8:	00000806 	br	81103f0c <bSdmaDmaM1Transfer+0x270>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103eec:	008000b4 	movhi	r2,2
81103ef0:	10a80004 	addi	r2,r2,-24576
81103ef4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103ef8:	00800044 	movi	r2,1
81103efc:	e0bff715 	stw	r2,-36(fp)
			break;
81103f00:	00000206 	br	81103f0c <bSdmaDmaM1Transfer+0x270>
		default:
			bStatus = FALSE;
81103f04:	e03ff415 	stw	zero,-48(fp)
			break;
81103f08:	0001883a 	nop
		}
		break;
81103f0c:	00002806 	br	81103fb0 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103f10:	e0bffd03 	ldbu	r2,-12(fp)
81103f14:	10000326 	beq	r2,zero,81103f24 <bSdmaDmaM1Transfer+0x288>
81103f18:	10800060 	cmpeqi	r2,r2,1
81103f1c:	1000061e 	bne	r2,zero,81103f38 <bSdmaDmaM1Transfer+0x29c>
81103f20:	00000b06 	br	81103f50 <bSdmaDmaM1Transfer+0x2b4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103f24:	00b00014 	movui	r2,49152
81103f28:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f2c:	00800044 	movi	r2,1
81103f30:	e0bff715 	stw	r2,-36(fp)
			break;
81103f34:	00000806 	br	81103f58 <bSdmaDmaM1Transfer+0x2bc>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f38:	008000b4 	movhi	r2,2
81103f3c:	10b00004 	addi	r2,r2,-16384
81103f40:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f44:	00800044 	movi	r2,1
81103f48:	e0bff715 	stw	r2,-36(fp)
			break;
81103f4c:	00000206 	br	81103f58 <bSdmaDmaM1Transfer+0x2bc>
		default:
			bStatus = FALSE;
81103f50:	e03ff415 	stw	zero,-48(fp)
			break;
81103f54:	0001883a 	nop
		}
		break;
81103f58:	00001506 	br	81103fb0 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f5c:	e0bffd03 	ldbu	r2,-12(fp)
81103f60:	10000326 	beq	r2,zero,81103f70 <bSdmaDmaM1Transfer+0x2d4>
81103f64:	10800060 	cmpeqi	r2,r2,1
81103f68:	1000061e 	bne	r2,zero,81103f84 <bSdmaDmaM1Transfer+0x2e8>
81103f6c:	00000b06 	br	81103f9c <bSdmaDmaM1Transfer+0x300>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103f70:	00b80014 	movui	r2,57344
81103f74:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103f78:	00800044 	movi	r2,1
81103f7c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f80:	00000806 	br	81103fa4 <bSdmaDmaM1Transfer+0x308>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103f84:	008000b4 	movhi	r2,2
81103f88:	10b80004 	addi	r2,r2,-8192
81103f8c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103f90:	00800044 	movi	r2,1
81103f94:	e0bff715 	stw	r2,-36(fp)
			break;
81103f98:	00000206 	br	81103fa4 <bSdmaDmaM1Transfer+0x308>
		default:
			bStatus = FALSE;
81103f9c:	e03ff415 	stw	zero,-48(fp)
			break;
81103fa0:	0001883a 	nop
		}
		break;
81103fa4:	00000206 	br	81103fb0 <bSdmaDmaM1Transfer+0x314>
	default:
		bStatus = FALSE;
81103fa8:	e03ff415 	stw	zero,-48(fp)
		break;
81103fac:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103fb0:	e0bffb17 	ldw	r2,-20(fp)
81103fb4:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103fb8:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
81103fbc:	e0bff417 	ldw	r2,-48(fp)
81103fc0:	10003b26 	beq	r2,zero,811040b0 <bSdmaDmaM1Transfer+0x414>
		if (pxDmaM1Dev == NULL) {
81103fc4:	d0a03917 	ldw	r2,-32540(gp)
81103fc8:	1000021e 	bne	r2,zero,81103fd4 <bSdmaDmaM1Transfer+0x338>
			bStatus = FALSE;
81103fcc:	e03ff415 	stw	zero,-48(fp)
81103fd0:	00003706 	br	811040b0 <bSdmaDmaM1Transfer+0x414>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81103fd4:	e03ff50d 	sth	zero,-44(fp)
81103fd8:	00003206 	br	811040a4 <bSdmaDmaM1Transfer+0x408>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81103fdc:	01000044 	movi	r4,1
81103fe0:	112aee80 	call	8112aee8 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103fe4:	d0a03917 	ldw	r2,-32540(gp)
81103fe8:	10800317 	ldw	r2,12(r2)
81103fec:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81103ff0:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81103ff4:	103ff91e 	bne	r2,zero,81103fdc <__reset+0xfb0e3fdc>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81103ff8:	d2203917 	ldw	r8,-32540(gp)
81103ffc:	e17ff817 	ldw	r5,-32(fp)
81104000:	e1bff617 	ldw	r6,-40(fp)
81104004:	e0bff917 	ldw	r2,-28(fp)
81104008:	e0fff717 	ldw	r3,-36(fp)
8110400c:	01000044 	movi	r4,1
81104010:	d9000815 	stw	r4,32(sp)
81104014:	01000044 	movi	r4,1
81104018:	d9000715 	stw	r4,28(sp)
8110401c:	01000044 	movi	r4,1
81104020:	d9000615 	stw	r4,24(sp)
81104024:	01000044 	movi	r4,1
81104028:	d9000515 	stw	r4,20(sp)
8110402c:	01000044 	movi	r4,1
81104030:	d9000415 	stw	r4,16(sp)
81104034:	d8c00315 	stw	r3,12(sp)
81104038:	d8800215 	stw	r2,8(sp)
8110403c:	e0bffa17 	ldw	r2,-24(fp)
81104040:	d8800115 	stw	r2,4(sp)
81104044:	00802204 	movi	r2,136
81104048:	d8800015 	stw	r2,0(sp)
8110404c:	300f883a 	mov	r7,r6
81104050:	280d883a 	mov	r6,r5
81104054:	800b883a 	mov	r5,r16
81104058:	4009883a 	mov	r4,r8
8110405c:	1106bf00 	call	81106bf0 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104060:	10000226 	beq	r2,zero,8110406c <bSdmaDmaM1Transfer+0x3d0>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104064:	e03ff415 	stw	zero,-48(fp)
					break;
81104068:	00001106 	br	811040b0 <bSdmaDmaM1Transfer+0x414>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
8110406c:	d0a03917 	ldw	r2,-32540(gp)
81104070:	800b883a 	mov	r5,r16
81104074:	1009883a 	mov	r4,r2
81104078:	1106cf40 	call	81106cf4 <iMsgdmaExtendedDescriptorSyncTransfer>
8110407c:	10000226 	beq	r2,zero,81104088 <bSdmaDmaM1Transfer+0x3ec>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104080:	e03ff415 	stw	zero,-48(fp)
						break;
81104084:	00000a06 	br	811040b0 <bSdmaDmaM1Transfer+0x414>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
81104088:	e0bff817 	ldw	r2,-32(fp)
8110408c:	10802204 	addi	r2,r2,136
81104090:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104094:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104098:	e0bff50b 	ldhu	r2,-44(fp)
8110409c:	10800044 	addi	r2,r2,1
811040a0:	e0bff50d 	sth	r2,-44(fp)
811040a4:	e0fff50b 	ldhu	r3,-44(fp)
811040a8:	e0bffc0b 	ldhu	r2,-16(fp)
811040ac:	18bfcd36 	bltu	r3,r2,81103fe4 <__reset+0xfb0e3fe4>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
811040b0:	e0bff417 	ldw	r2,-48(fp)
}
811040b4:	e6ffff04 	addi	sp,fp,-4
811040b8:	dfc00217 	ldw	ra,8(sp)
811040bc:	df000117 	ldw	fp,4(sp)
811040c0:	dc000017 	ldw	r16,0(sp)
811040c4:	dec00304 	addi	sp,sp,12
811040c8:	f800283a 	ret

811040cc <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
811040cc:	deffe904 	addi	sp,sp,-92
811040d0:	de00012e 	bgeu	sp,et,811040d8 <bSdmaDmaM2Transfer+0xc>
811040d4:	003b68fa 	trap	3
811040d8:	dfc01615 	stw	ra,88(sp)
811040dc:	df001515 	stw	fp,84(sp)
811040e0:	dc001415 	stw	r16,80(sp)
811040e4:	df001504 	addi	fp,sp,84
811040e8:	e13ffb15 	stw	r4,-20(fp)
811040ec:	2809883a 	mov	r4,r5
811040f0:	3007883a 	mov	r3,r6
811040f4:	3805883a 	mov	r2,r7
811040f8:	e13ffc0d 	sth	r4,-16(fp)
811040fc:	e0fffd05 	stb	r3,-12(fp)
81104100:	e0bffe05 	stb	r2,-8(fp)
81104104:	defff004 	addi	sp,sp,-64
81104108:	d8800904 	addi	r2,sp,36
8110410c:	108007c4 	addi	r2,r2,31
81104110:	1004d17a 	srli	r2,r2,5
81104114:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81104118:	00800044 	movi	r2,1
8110411c:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81104120:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81104124:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81104128:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
8110412c:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104130:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104134:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81104138:	e0bffe03 	ldbu	r2,-8(fp)
8110413c:	10c00268 	cmpgeui	r3,r2,9
81104140:	1800a51e 	bne	r3,zero,811043d8 <bSdmaDmaM2Transfer+0x30c>
81104144:	100690ba 	slli	r3,r2,2
81104148:	00a04434 	movhi	r2,33040
8110414c:	10905704 	addi	r2,r2,16732
81104150:	1885883a 	add	r2,r3,r2
81104154:	10800017 	ldw	r2,0(r2)
81104158:	1000683a 	jmp	r2
8110415c:	811043d8 	cmpnei	r4,r16,16655
81104160:	81104180 	call	88110418 <__reset+0x20f0418>
81104164:	811041c4 	addi	r4,r16,16647
81104168:	81104210 	cmplti	r4,r16,16648
8110416c:	8110425c 	xori	r4,r16,16649
81104170:	811042a8 	cmpgeui	r4,r16,16650
81104174:	811042f4 	orhi	r4,r16,16651
81104178:	81104340 	call	88110434 <__reset+0x20f0434>
8110417c:	8110438c 	andi	r4,r16,16654
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81104180:	e0bffd03 	ldbu	r2,-12(fp)
81104184:	10000326 	beq	r2,zero,81104194 <bSdmaDmaM2Transfer+0xc8>
81104188:	10800060 	cmpeqi	r2,r2,1
8110418c:	1000051e 	bne	r2,zero,811041a4 <bSdmaDmaM2Transfer+0xd8>
81104190:	00000906 	br	811041b8 <bSdmaDmaM2Transfer+0xec>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81104194:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81104198:	00800044 	movi	r2,1
8110419c:	e0bff715 	stw	r2,-36(fp)
			break;
811041a0:	00000706 	br	811041c0 <bSdmaDmaM2Transfer+0xf4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
811041a4:	00800074 	movhi	r2,1
811041a8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
811041ac:	00800044 	movi	r2,1
811041b0:	e0bff715 	stw	r2,-36(fp)
			break;
811041b4:	00000206 	br	811041c0 <bSdmaDmaM2Transfer+0xf4>
		default:
			bStatus = FALSE;
811041b8:	e03ff415 	stw	zero,-48(fp)
			break;
811041bc:	0001883a 	nop
		}
		break;
811041c0:	00008706 	br	811043e0 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
811041c4:	e0bffd03 	ldbu	r2,-12(fp)
811041c8:	10000326 	beq	r2,zero,811041d8 <bSdmaDmaM2Transfer+0x10c>
811041cc:	10800060 	cmpeqi	r2,r2,1
811041d0:	1000061e 	bne	r2,zero,811041ec <bSdmaDmaM2Transfer+0x120>
811041d4:	00000b06 	br	81104204 <bSdmaDmaM2Transfer+0x138>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
811041d8:	00880004 	movi	r2,8192
811041dc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
811041e0:	00800044 	movi	r2,1
811041e4:	e0bff715 	stw	r2,-36(fp)
			break;
811041e8:	00000806 	br	8110420c <bSdmaDmaM2Transfer+0x140>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
811041ec:	00800074 	movhi	r2,1
811041f0:	10880004 	addi	r2,r2,8192
811041f4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
811041f8:	00800044 	movi	r2,1
811041fc:	e0bff715 	stw	r2,-36(fp)
			break;
81104200:	00000206 	br	8110420c <bSdmaDmaM2Transfer+0x140>
		default:
			bStatus = FALSE;
81104204:	e03ff415 	stw	zero,-48(fp)
			break;
81104208:	0001883a 	nop
		}
		break;
8110420c:	00007406 	br	811043e0 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81104210:	e0bffd03 	ldbu	r2,-12(fp)
81104214:	10000326 	beq	r2,zero,81104224 <bSdmaDmaM2Transfer+0x158>
81104218:	10800060 	cmpeqi	r2,r2,1
8110421c:	1000061e 	bne	r2,zero,81104238 <bSdmaDmaM2Transfer+0x16c>
81104220:	00000b06 	br	81104250 <bSdmaDmaM2Transfer+0x184>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81104224:	00900004 	movi	r2,16384
81104228:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
8110422c:	00800044 	movi	r2,1
81104230:	e0bff715 	stw	r2,-36(fp)
			break;
81104234:	00000806 	br	81104258 <bSdmaDmaM2Transfer+0x18c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81104238:	00800074 	movhi	r2,1
8110423c:	10900004 	addi	r2,r2,16384
81104240:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104244:	00800044 	movi	r2,1
81104248:	e0bff715 	stw	r2,-36(fp)
			break;
8110424c:	00000206 	br	81104258 <bSdmaDmaM2Transfer+0x18c>
		default:
			bStatus = FALSE;
81104250:	e03ff415 	stw	zero,-48(fp)
			break;
81104254:	0001883a 	nop
		}
		break;
81104258:	00006106 	br	811043e0 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
8110425c:	e0bffd03 	ldbu	r2,-12(fp)
81104260:	10000326 	beq	r2,zero,81104270 <bSdmaDmaM2Transfer+0x1a4>
81104264:	10800060 	cmpeqi	r2,r2,1
81104268:	1000061e 	bne	r2,zero,81104284 <bSdmaDmaM2Transfer+0x1b8>
8110426c:	00000b06 	br	8110429c <bSdmaDmaM2Transfer+0x1d0>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81104270:	00980004 	movi	r2,24576
81104274:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104278:	00800044 	movi	r2,1
8110427c:	e0bff715 	stw	r2,-36(fp)
			break;
81104280:	00000806 	br	811042a4 <bSdmaDmaM2Transfer+0x1d8>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104284:	00800074 	movhi	r2,1
81104288:	10980004 	addi	r2,r2,24576
8110428c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81104290:	00800044 	movi	r2,1
81104294:	e0bff715 	stw	r2,-36(fp)
			break;
81104298:	00000206 	br	811042a4 <bSdmaDmaM2Transfer+0x1d8>
		default:
			bStatus = FALSE;
8110429c:	e03ff415 	stw	zero,-48(fp)
			break;
811042a0:	0001883a 	nop
		}
		break;
811042a4:	00004e06 	br	811043e0 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
811042a8:	e0bffd03 	ldbu	r2,-12(fp)
811042ac:	10000326 	beq	r2,zero,811042bc <bSdmaDmaM2Transfer+0x1f0>
811042b0:	10800060 	cmpeqi	r2,r2,1
811042b4:	1000061e 	bne	r2,zero,811042d0 <bSdmaDmaM2Transfer+0x204>
811042b8:	00000b06 	br	811042e8 <bSdmaDmaM2Transfer+0x21c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
811042bc:	00a00014 	movui	r2,32768
811042c0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
811042c4:	00800044 	movi	r2,1
811042c8:	e0bff715 	stw	r2,-36(fp)
			break;
811042cc:	00000806 	br	811042f0 <bSdmaDmaM2Transfer+0x224>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
811042d0:	008000b4 	movhi	r2,2
811042d4:	10a00004 	addi	r2,r2,-32768
811042d8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
811042dc:	00800044 	movi	r2,1
811042e0:	e0bff715 	stw	r2,-36(fp)
			break;
811042e4:	00000206 	br	811042f0 <bSdmaDmaM2Transfer+0x224>
		default:
			bStatus = FALSE;
811042e8:	e03ff415 	stw	zero,-48(fp)
			break;
811042ec:	0001883a 	nop
		}
		break;
811042f0:	00003b06 	br	811043e0 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811042f4:	e0bffd03 	ldbu	r2,-12(fp)
811042f8:	10000326 	beq	r2,zero,81104308 <bSdmaDmaM2Transfer+0x23c>
811042fc:	10800060 	cmpeqi	r2,r2,1
81104300:	1000061e 	bne	r2,zero,8110431c <bSdmaDmaM2Transfer+0x250>
81104304:	00000b06 	br	81104334 <bSdmaDmaM2Transfer+0x268>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81104308:	00a80014 	movui	r2,40960
8110430c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81104310:	00800044 	movi	r2,1
81104314:	e0bff715 	stw	r2,-36(fp)
			break;
81104318:	00000806 	br	8110433c <bSdmaDmaM2Transfer+0x270>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
8110431c:	008000b4 	movhi	r2,2
81104320:	10a80004 	addi	r2,r2,-24576
81104324:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81104328:	00800044 	movi	r2,1
8110432c:	e0bff715 	stw	r2,-36(fp)
			break;
81104330:	00000206 	br	8110433c <bSdmaDmaM2Transfer+0x270>
		default:
			bStatus = FALSE;
81104334:	e03ff415 	stw	zero,-48(fp)
			break;
81104338:	0001883a 	nop
		}
		break;
8110433c:	00002806 	br	811043e0 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81104340:	e0bffd03 	ldbu	r2,-12(fp)
81104344:	10000326 	beq	r2,zero,81104354 <bSdmaDmaM2Transfer+0x288>
81104348:	10800060 	cmpeqi	r2,r2,1
8110434c:	1000061e 	bne	r2,zero,81104368 <bSdmaDmaM2Transfer+0x29c>
81104350:	00000b06 	br	81104380 <bSdmaDmaM2Transfer+0x2b4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104354:	00b00014 	movui	r2,49152
81104358:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
8110435c:	00800044 	movi	r2,1
81104360:	e0bff715 	stw	r2,-36(fp)
			break;
81104364:	00000806 	br	81104388 <bSdmaDmaM2Transfer+0x2bc>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104368:	008000b4 	movhi	r2,2
8110436c:	10b00004 	addi	r2,r2,-16384
81104370:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104374:	00800044 	movi	r2,1
81104378:	e0bff715 	stw	r2,-36(fp)
			break;
8110437c:	00000206 	br	81104388 <bSdmaDmaM2Transfer+0x2bc>
		default:
			bStatus = FALSE;
81104380:	e03ff415 	stw	zero,-48(fp)
			break;
81104384:	0001883a 	nop
		}
		break;
81104388:	00001506 	br	811043e0 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110438c:	e0bffd03 	ldbu	r2,-12(fp)
81104390:	10000326 	beq	r2,zero,811043a0 <bSdmaDmaM2Transfer+0x2d4>
81104394:	10800060 	cmpeqi	r2,r2,1
81104398:	1000061e 	bne	r2,zero,811043b4 <bSdmaDmaM2Transfer+0x2e8>
8110439c:	00000b06 	br	811043cc <bSdmaDmaM2Transfer+0x300>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
811043a0:	00b80014 	movui	r2,57344
811043a4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
811043a8:	00800044 	movi	r2,1
811043ac:	e0bff715 	stw	r2,-36(fp)
			break;
811043b0:	00000806 	br	811043d4 <bSdmaDmaM2Transfer+0x308>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
811043b4:	008000b4 	movhi	r2,2
811043b8:	10b80004 	addi	r2,r2,-8192
811043bc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
811043c0:	00800044 	movi	r2,1
811043c4:	e0bff715 	stw	r2,-36(fp)
			break;
811043c8:	00000206 	br	811043d4 <bSdmaDmaM2Transfer+0x308>
		default:
			bStatus = FALSE;
811043cc:	e03ff415 	stw	zero,-48(fp)
			break;
811043d0:	0001883a 	nop
		}
		break;
811043d4:	00000206 	br	811043e0 <bSdmaDmaM2Transfer+0x314>
	default:
		bStatus = FALSE;
811043d8:	e03ff415 	stw	zero,-48(fp)
		break;
811043dc:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
811043e0:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
811043e4:	00a00034 	movhi	r2,32768
811043e8:	1885883a 	add	r2,r3,r2
811043ec:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
811043f0:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
811043f4:	e0bff417 	ldw	r2,-48(fp)
811043f8:	10003b26 	beq	r2,zero,811044e8 <bSdmaDmaM2Transfer+0x41c>
		if (pxDmaM2Dev == NULL) {
811043fc:	d0a03a17 	ldw	r2,-32536(gp)
81104400:	1000021e 	bne	r2,zero,8110440c <bSdmaDmaM2Transfer+0x340>
			bStatus = FALSE;
81104404:	e03ff415 	stw	zero,-48(fp)
81104408:	00003706 	br	811044e8 <bSdmaDmaM2Transfer+0x41c>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
8110440c:	e03ff50d 	sth	zero,-44(fp)
81104410:	00003206 	br	811044dc <bSdmaDmaM2Transfer+0x410>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81104414:	01000044 	movi	r4,1
81104418:	112aee80 	call	8112aee8 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
8110441c:	d0a03a17 	ldw	r2,-32536(gp)
81104420:	10800317 	ldw	r2,12(r2)
81104424:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104428:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
8110442c:	103ff91e 	bne	r2,zero,81104414 <__reset+0xfb0e4414>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
81104430:	d2203a17 	ldw	r8,-32536(gp)
81104434:	e17ff817 	ldw	r5,-32(fp)
81104438:	e1bff617 	ldw	r6,-40(fp)
8110443c:	e0bff917 	ldw	r2,-28(fp)
81104440:	e0fff717 	ldw	r3,-36(fp)
81104444:	01000044 	movi	r4,1
81104448:	d9000815 	stw	r4,32(sp)
8110444c:	01000044 	movi	r4,1
81104450:	d9000715 	stw	r4,28(sp)
81104454:	01000044 	movi	r4,1
81104458:	d9000615 	stw	r4,24(sp)
8110445c:	01000044 	movi	r4,1
81104460:	d9000515 	stw	r4,20(sp)
81104464:	01000044 	movi	r4,1
81104468:	d9000415 	stw	r4,16(sp)
8110446c:	d8c00315 	stw	r3,12(sp)
81104470:	d8800215 	stw	r2,8(sp)
81104474:	e0bffa17 	ldw	r2,-24(fp)
81104478:	d8800115 	stw	r2,4(sp)
8110447c:	00802204 	movi	r2,136
81104480:	d8800015 	stw	r2,0(sp)
81104484:	300f883a 	mov	r7,r6
81104488:	280d883a 	mov	r6,r5
8110448c:	800b883a 	mov	r5,r16
81104490:	4009883a 	mov	r4,r8
81104494:	1106bf00 	call	81106bf0 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104498:	10000226 	beq	r2,zero,811044a4 <bSdmaDmaM2Transfer+0x3d8>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
8110449c:	e03ff415 	stw	zero,-48(fp)
					break;
811044a0:	00001106 	br	811044e8 <bSdmaDmaM2Transfer+0x41c>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
811044a4:	d0a03a17 	ldw	r2,-32536(gp)
811044a8:	800b883a 	mov	r5,r16
811044ac:	1009883a 	mov	r4,r2
811044b0:	1106cf40 	call	81106cf4 <iMsgdmaExtendedDescriptorSyncTransfer>
811044b4:	10000226 	beq	r2,zero,811044c0 <bSdmaDmaM2Transfer+0x3f4>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
811044b8:	e03ff415 	stw	zero,-48(fp)
						break;
811044bc:	00000a06 	br	811044e8 <bSdmaDmaM2Transfer+0x41c>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
811044c0:	e0bff817 	ldw	r2,-32(fp)
811044c4:	10802204 	addi	r2,r2,136
811044c8:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
811044cc:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811044d0:	e0bff50b 	ldhu	r2,-44(fp)
811044d4:	10800044 	addi	r2,r2,1
811044d8:	e0bff50d 	sth	r2,-44(fp)
811044dc:	e0fff50b 	ldhu	r3,-44(fp)
811044e0:	e0bffc0b 	ldhu	r2,-16(fp)
811044e4:	18bfcd36 	bltu	r3,r2,8110441c <__reset+0xfb0e441c>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
811044e8:	e0bff417 	ldw	r2,-48(fp)
}
811044ec:	e6ffff04 	addi	sp,fp,-4
811044f0:	dfc00217 	ldw	ra,8(sp)
811044f4:	df000117 	ldw	fp,4(sp)
811044f8:	dc000017 	ldw	r16,0(sp)
811044fc:	dec00304 	addi	sp,sp,12
81104500:	f800283a 	ret

81104504 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81104504:	defffc04 	addi	sp,sp,-16
81104508:	de00012e 	bgeu	sp,et,81104510 <vFeebCh1HandleIrq+0xc>
8110450c:	003b68fa 	trap	3
81104510:	dfc00315 	stw	ra,12(sp)
81104514:	df000215 	stw	fp,8(sp)
81104518:	df000204 	addi	fp,sp,8
8110451c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104520:	e0bfff17 	ldw	r2,-4(fp)
81104524:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh1IrqFlagClrBufferEmpty();
81104528:	11047040 	call	81104704 <vFeebCh1IrqFlagClrBufferEmpty>
}
8110452c:	0001883a 	nop
81104530:	e037883a 	mov	sp,fp
81104534:	dfc00117 	ldw	ra,4(sp)
81104538:	df000017 	ldw	fp,0(sp)
8110453c:	dec00204 	addi	sp,sp,8
81104540:	f800283a 	ret

81104544 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
81104544:	defffc04 	addi	sp,sp,-16
81104548:	de00012e 	bgeu	sp,et,81104550 <vFeebCh2HandleIrq+0xc>
8110454c:	003b68fa 	trap	3
81104550:	dfc00315 	stw	ra,12(sp)
81104554:	df000215 	stw	fp,8(sp)
81104558:	df000204 	addi	fp,sp,8
8110455c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104560:	e0bfff17 	ldw	r2,-4(fp)
81104564:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh2IrqFlagClrBufferEmpty();
81104568:	11047480 	call	81104748 <vFeebCh2IrqFlagClrBufferEmpty>
}
8110456c:	0001883a 	nop
81104570:	e037883a 	mov	sp,fp
81104574:	dfc00117 	ldw	ra,4(sp)
81104578:	df000017 	ldw	fp,0(sp)
8110457c:	dec00204 	addi	sp,sp,8
81104580:	f800283a 	ret

81104584 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81104584:	defffc04 	addi	sp,sp,-16
81104588:	de00012e 	bgeu	sp,et,81104590 <vFeebCh3HandleIrq+0xc>
8110458c:	003b68fa 	trap	3
81104590:	dfc00315 	stw	ra,12(sp)
81104594:	df000215 	stw	fp,8(sp)
81104598:	df000204 	addi	fp,sp,8
8110459c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811045a0:	e0bfff17 	ldw	r2,-4(fp)
811045a4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh3IrqFlagClrBufferEmpty();
811045a8:	110478c0 	call	8110478c <vFeebCh3IrqFlagClrBufferEmpty>
}
811045ac:	0001883a 	nop
811045b0:	e037883a 	mov	sp,fp
811045b4:	dfc00117 	ldw	ra,4(sp)
811045b8:	df000017 	ldw	fp,0(sp)
811045bc:	dec00204 	addi	sp,sp,8
811045c0:	f800283a 	ret

811045c4 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
811045c4:	defffc04 	addi	sp,sp,-16
811045c8:	de00012e 	bgeu	sp,et,811045d0 <vFeebCh4HandleIrq+0xc>
811045cc:	003b68fa 	trap	3
811045d0:	dfc00315 	stw	ra,12(sp)
811045d4:	df000215 	stw	fp,8(sp)
811045d8:	df000204 	addi	fp,sp,8
811045dc:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811045e0:	e0bfff17 	ldw	r2,-4(fp)
811045e4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh4IrqFlagClrBufferEmpty();
811045e8:	11047d00 	call	811047d0 <vFeebCh4IrqFlagClrBufferEmpty>
}
811045ec:	0001883a 	nop
811045f0:	e037883a 	mov	sp,fp
811045f4:	dfc00117 	ldw	ra,4(sp)
811045f8:	df000017 	ldw	fp,0(sp)
811045fc:	dec00204 	addi	sp,sp,8
81104600:	f800283a 	ret

81104604 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81104604:	defffc04 	addi	sp,sp,-16
81104608:	de00012e 	bgeu	sp,et,81104610 <vFeebCh5HandleIrq+0xc>
8110460c:	003b68fa 	trap	3
81104610:	dfc00315 	stw	ra,12(sp)
81104614:	df000215 	stw	fp,8(sp)
81104618:	df000204 	addi	fp,sp,8
8110461c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104620:	e0bfff17 	ldw	r2,-4(fp)
81104624:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh5IrqFlagClrBufferEmpty();
81104628:	11048140 	call	81104814 <vFeebCh5IrqFlagClrBufferEmpty>
}
8110462c:	0001883a 	nop
81104630:	e037883a 	mov	sp,fp
81104634:	dfc00117 	ldw	ra,4(sp)
81104638:	df000017 	ldw	fp,0(sp)
8110463c:	dec00204 	addi	sp,sp,8
81104640:	f800283a 	ret

81104644 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
81104644:	defffc04 	addi	sp,sp,-16
81104648:	de00012e 	bgeu	sp,et,81104650 <vFeebCh6HandleIrq+0xc>
8110464c:	003b68fa 	trap	3
81104650:	dfc00315 	stw	ra,12(sp)
81104654:	df000215 	stw	fp,8(sp)
81104658:	df000204 	addi	fp,sp,8
8110465c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104660:	e0bfff17 	ldw	r2,-4(fp)
81104664:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vFeebCh6IrqFlagClrBufferEmpty();
81104668:	11048580 	call	81104858 <vFeebCh6IrqFlagClrBufferEmpty>
}
8110466c:	0001883a 	nop
81104670:	e037883a 	mov	sp,fp
81104674:	dfc00117 	ldw	ra,4(sp)
81104678:	df000017 	ldw	fp,0(sp)
8110467c:	dec00204 	addi	sp,sp,8
81104680:	f800283a 	ret

81104684 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
81104684:	defffc04 	addi	sp,sp,-16
81104688:	de00012e 	bgeu	sp,et,81104690 <vFeebCh7HandleIrq+0xc>
8110468c:	003b68fa 	trap	3
81104690:	dfc00315 	stw	ra,12(sp)
81104694:	df000215 	stw	fp,8(sp)
81104698:	df000204 	addi	fp,sp,8
8110469c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811046a0:	e0bfff17 	ldw	r2,-4(fp)
811046a4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh7IrqFlagClrBufferEmpty();
811046a8:	110489c0 	call	8110489c <vFeebCh7IrqFlagClrBufferEmpty>
}
811046ac:	0001883a 	nop
811046b0:	e037883a 	mov	sp,fp
811046b4:	dfc00117 	ldw	ra,4(sp)
811046b8:	df000017 	ldw	fp,0(sp)
811046bc:	dec00204 	addi	sp,sp,8
811046c0:	f800283a 	ret

811046c4 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
811046c4:	defffc04 	addi	sp,sp,-16
811046c8:	de00012e 	bgeu	sp,et,811046d0 <vFeebCh8HandleIrq+0xc>
811046cc:	003b68fa 	trap	3
811046d0:	dfc00315 	stw	ra,12(sp)
811046d4:	df000215 	stw	fp,8(sp)
811046d8:	df000204 	addi	fp,sp,8
811046dc:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811046e0:	e0bfff17 	ldw	r2,-4(fp)
811046e4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh8IrqFlagClrBufferEmpty();
811046e8:	11048e00 	call	811048e0 <vFeebCh8IrqFlagClrBufferEmpty>
}
811046ec:	0001883a 	nop
811046f0:	e037883a 	mov	sp,fp
811046f4:	dfc00117 	ldw	ra,4(sp)
811046f8:	df000017 	ldw	fp,0(sp)
811046fc:	dec00204 	addi	sp,sp,8
81104700:	f800283a 	ret

81104704 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81104704:	defffe04 	addi	sp,sp,-8
81104708:	de00012e 	bgeu	sp,et,81104710 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
8110470c:	003b68fa 	trap	3
81104710:	dfc00115 	stw	ra,4(sp)
81104714:	df000015 	stw	fp,0(sp)
81104718:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
8110471c:	01800044 	movi	r6,1
81104720:	01400144 	movi	r5,5
81104724:	01204834 	movhi	r4,33056
81104728:	210b0004 	addi	r4,r4,11264
8110472c:	11051480 	call	81105148 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104730:	0001883a 	nop
81104734:	e037883a 	mov	sp,fp
81104738:	dfc00117 	ldw	ra,4(sp)
8110473c:	df000017 	ldw	fp,0(sp)
81104740:	dec00204 	addi	sp,sp,8
81104744:	f800283a 	ret

81104748 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
81104748:	defffe04 	addi	sp,sp,-8
8110474c:	de00012e 	bgeu	sp,et,81104754 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
81104750:	003b68fa 	trap	3
81104754:	dfc00115 	stw	ra,4(sp)
81104758:	df000015 	stw	fp,0(sp)
8110475c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81104760:	01800044 	movi	r6,1
81104764:	01400144 	movi	r5,5
81104768:	01204834 	movhi	r4,33056
8110476c:	210a0004 	addi	r4,r4,10240
81104770:	11051480 	call	81105148 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104774:	0001883a 	nop
81104778:	e037883a 	mov	sp,fp
8110477c:	dfc00117 	ldw	ra,4(sp)
81104780:	df000017 	ldw	fp,0(sp)
81104784:	dec00204 	addi	sp,sp,8
81104788:	f800283a 	ret

8110478c <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
8110478c:	defffe04 	addi	sp,sp,-8
81104790:	de00012e 	bgeu	sp,et,81104798 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
81104794:	003b68fa 	trap	3
81104798:	dfc00115 	stw	ra,4(sp)
8110479c:	df000015 	stw	fp,0(sp)
811047a0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811047a4:	01800044 	movi	r6,1
811047a8:	01400144 	movi	r5,5
811047ac:	01204834 	movhi	r4,33056
811047b0:	21090004 	addi	r4,r4,9216
811047b4:	11051480 	call	81105148 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
811047b8:	0001883a 	nop
811047bc:	e037883a 	mov	sp,fp
811047c0:	dfc00117 	ldw	ra,4(sp)
811047c4:	df000017 	ldw	fp,0(sp)
811047c8:	dec00204 	addi	sp,sp,8
811047cc:	f800283a 	ret

811047d0 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
811047d0:	defffe04 	addi	sp,sp,-8
811047d4:	de00012e 	bgeu	sp,et,811047dc <vFeebCh4IrqFlagClrBufferEmpty+0xc>
811047d8:	003b68fa 	trap	3
811047dc:	dfc00115 	stw	ra,4(sp)
811047e0:	df000015 	stw	fp,0(sp)
811047e4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811047e8:	01800044 	movi	r6,1
811047ec:	01400144 	movi	r5,5
811047f0:	01204834 	movhi	r4,33056
811047f4:	21080004 	addi	r4,r4,8192
811047f8:	11051480 	call	81105148 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
811047fc:	0001883a 	nop
81104800:	e037883a 	mov	sp,fp
81104804:	dfc00117 	ldw	ra,4(sp)
81104808:	df000017 	ldw	fp,0(sp)
8110480c:	dec00204 	addi	sp,sp,8
81104810:	f800283a 	ret

81104814 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81104814:	defffe04 	addi	sp,sp,-8
81104818:	de00012e 	bgeu	sp,et,81104820 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
8110481c:	003b68fa 	trap	3
81104820:	dfc00115 	stw	ra,4(sp)
81104824:	df000015 	stw	fp,0(sp)
81104828:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110482c:	01800044 	movi	r6,1
81104830:	01400144 	movi	r5,5
81104834:	01204834 	movhi	r4,33056
81104838:	21070004 	addi	r4,r4,7168
8110483c:	11051480 	call	81105148 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104840:	0001883a 	nop
81104844:	e037883a 	mov	sp,fp
81104848:	dfc00117 	ldw	ra,4(sp)
8110484c:	df000017 	ldw	fp,0(sp)
81104850:	dec00204 	addi	sp,sp,8
81104854:	f800283a 	ret

81104858 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
81104858:	defffe04 	addi	sp,sp,-8
8110485c:	de00012e 	bgeu	sp,et,81104864 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
81104860:	003b68fa 	trap	3
81104864:	dfc00115 	stw	ra,4(sp)
81104868:	df000015 	stw	fp,0(sp)
8110486c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81104870:	01800044 	movi	r6,1
81104874:	01400144 	movi	r5,5
81104878:	01204834 	movhi	r4,33056
8110487c:	21060004 	addi	r4,r4,6144
81104880:	11051480 	call	81105148 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104884:	0001883a 	nop
81104888:	e037883a 	mov	sp,fp
8110488c:	dfc00117 	ldw	ra,4(sp)
81104890:	df000017 	ldw	fp,0(sp)
81104894:	dec00204 	addi	sp,sp,8
81104898:	f800283a 	ret

8110489c <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
8110489c:	defffe04 	addi	sp,sp,-8
811048a0:	de00012e 	bgeu	sp,et,811048a8 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
811048a4:	003b68fa 	trap	3
811048a8:	dfc00115 	stw	ra,4(sp)
811048ac:	df000015 	stw	fp,0(sp)
811048b0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811048b4:	01800044 	movi	r6,1
811048b8:	01400144 	movi	r5,5
811048bc:	01204834 	movhi	r4,33056
811048c0:	21050004 	addi	r4,r4,5120
811048c4:	11051480 	call	81105148 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
811048c8:	0001883a 	nop
811048cc:	e037883a 	mov	sp,fp
811048d0:	dfc00117 	ldw	ra,4(sp)
811048d4:	df000017 	ldw	fp,0(sp)
811048d8:	dec00204 	addi	sp,sp,8
811048dc:	f800283a 	ret

811048e0 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
811048e0:	defffe04 	addi	sp,sp,-8
811048e4:	de00012e 	bgeu	sp,et,811048ec <vFeebCh8IrqFlagClrBufferEmpty+0xc>
811048e8:	003b68fa 	trap	3
811048ec:	dfc00115 	stw	ra,4(sp)
811048f0:	df000015 	stw	fp,0(sp)
811048f4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811048f8:	01800044 	movi	r6,1
811048fc:	01400144 	movi	r5,5
81104900:	01204834 	movhi	r4,33056
81104904:	21040004 	addi	r4,r4,4096
81104908:	11051480 	call	81105148 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
8110490c:	0001883a 	nop
81104910:	e037883a 	mov	sp,fp
81104914:	dfc00117 	ldw	ra,4(sp)
81104918:	df000017 	ldw	fp,0(sp)
8110491c:	dec00204 	addi	sp,sp,8
81104920:	f800283a 	ret

81104924 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81104924:	defffd04 	addi	sp,sp,-12
81104928:	de00012e 	bgeu	sp,et,81104930 <bFeebCh1IrqFlagBufferEmpty+0xc>
8110492c:	003b68fa 	trap	3
81104930:	dfc00215 	stw	ra,8(sp)
81104934:	df000115 	stw	fp,4(sp)
81104938:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
8110493c:	01400144 	movi	r5,5
81104940:	01204834 	movhi	r4,33056
81104944:	210b0004 	addi	r4,r4,11264
81104948:	110519c0 	call	8110519c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
8110494c:	1080004c 	andi	r2,r2,1
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81104950:	10000326 	beq	r2,zero,81104960 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104954:	00800044 	movi	r2,1
81104958:	e0bfff15 	stw	r2,-4(fp)
8110495c:	00000106 	br	81104964 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104960:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104964:	e0bfff17 	ldw	r2,-4(fp)
}
81104968:	e037883a 	mov	sp,fp
8110496c:	dfc00117 	ldw	ra,4(sp)
81104970:	df000017 	ldw	fp,0(sp)
81104974:	dec00204 	addi	sp,sp,8
81104978:	f800283a 	ret

8110497c <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
8110497c:	defffd04 	addi	sp,sp,-12
81104980:	de00012e 	bgeu	sp,et,81104988 <bFeebCh2IrqFlagBufferEmpty+0xc>
81104984:	003b68fa 	trap	3
81104988:	dfc00215 	stw	ra,8(sp)
8110498c:	df000115 	stw	fp,4(sp)
81104990:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81104994:	01400144 	movi	r5,5
81104998:	01204834 	movhi	r4,33056
8110499c:	210a0004 	addi	r4,r4,10240
811049a0:	110519c0 	call	8110519c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
811049a4:	1080004c 	andi	r2,r2,1
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811049a8:	10000326 	beq	r2,zero,811049b8 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
811049ac:	00800044 	movi	r2,1
811049b0:	e0bfff15 	stw	r2,-4(fp)
811049b4:	00000106 	br	811049bc <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811049b8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811049bc:	e0bfff17 	ldw	r2,-4(fp)
}
811049c0:	e037883a 	mov	sp,fp
811049c4:	dfc00117 	ldw	ra,4(sp)
811049c8:	df000017 	ldw	fp,0(sp)
811049cc:	dec00204 	addi	sp,sp,8
811049d0:	f800283a 	ret

811049d4 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
811049d4:	defffd04 	addi	sp,sp,-12
811049d8:	de00012e 	bgeu	sp,et,811049e0 <bFeebCh3IrqFlagBufferEmpty+0xc>
811049dc:	003b68fa 	trap	3
811049e0:	dfc00215 	stw	ra,8(sp)
811049e4:	df000115 	stw	fp,4(sp)
811049e8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811049ec:	01400144 	movi	r5,5
811049f0:	01204834 	movhi	r4,33056
811049f4:	21090004 	addi	r4,r4,9216
811049f8:	110519c0 	call	8110519c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
811049fc:	1080004c 	andi	r2,r2,1
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81104a00:	10000326 	beq	r2,zero,81104a10 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104a04:	00800044 	movi	r2,1
81104a08:	e0bfff15 	stw	r2,-4(fp)
81104a0c:	00000106 	br	81104a14 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104a10:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104a14:	e0bfff17 	ldw	r2,-4(fp)
}
81104a18:	e037883a 	mov	sp,fp
81104a1c:	dfc00117 	ldw	ra,4(sp)
81104a20:	df000017 	ldw	fp,0(sp)
81104a24:	dec00204 	addi	sp,sp,8
81104a28:	f800283a 	ret

81104a2c <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81104a2c:	defffd04 	addi	sp,sp,-12
81104a30:	de00012e 	bgeu	sp,et,81104a38 <bFeebCh4IrqFlagBufferEmpty+0xc>
81104a34:	003b68fa 	trap	3
81104a38:	dfc00215 	stw	ra,8(sp)
81104a3c:	df000115 	stw	fp,4(sp)
81104a40:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81104a44:	01400144 	movi	r5,5
81104a48:	01204834 	movhi	r4,33056
81104a4c:	21080004 	addi	r4,r4,8192
81104a50:	110519c0 	call	8110519c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104a54:	1080004c 	andi	r2,r2,1
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81104a58:	10000326 	beq	r2,zero,81104a68 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104a5c:	00800044 	movi	r2,1
81104a60:	e0bfff15 	stw	r2,-4(fp)
81104a64:	00000106 	br	81104a6c <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104a68:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104a6c:	e0bfff17 	ldw	r2,-4(fp)
}
81104a70:	e037883a 	mov	sp,fp
81104a74:	dfc00117 	ldw	ra,4(sp)
81104a78:	df000017 	ldw	fp,0(sp)
81104a7c:	dec00204 	addi	sp,sp,8
81104a80:	f800283a 	ret

81104a84 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
81104a84:	defffd04 	addi	sp,sp,-12
81104a88:	de00012e 	bgeu	sp,et,81104a90 <bFeebCh5IrqFlagBufferEmpty+0xc>
81104a8c:	003b68fa 	trap	3
81104a90:	dfc00215 	stw	ra,8(sp)
81104a94:	df000115 	stw	fp,4(sp)
81104a98:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81104a9c:	01400144 	movi	r5,5
81104aa0:	01204834 	movhi	r4,33056
81104aa4:	21070004 	addi	r4,r4,7168
81104aa8:	110519c0 	call	8110519c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104aac:	1080004c 	andi	r2,r2,1
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81104ab0:	10000326 	beq	r2,zero,81104ac0 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104ab4:	00800044 	movi	r2,1
81104ab8:	e0bfff15 	stw	r2,-4(fp)
81104abc:	00000106 	br	81104ac4 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104ac0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104ac4:	e0bfff17 	ldw	r2,-4(fp)
}
81104ac8:	e037883a 	mov	sp,fp
81104acc:	dfc00117 	ldw	ra,4(sp)
81104ad0:	df000017 	ldw	fp,0(sp)
81104ad4:	dec00204 	addi	sp,sp,8
81104ad8:	f800283a 	ret

81104adc <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81104adc:	defffd04 	addi	sp,sp,-12
81104ae0:	de00012e 	bgeu	sp,et,81104ae8 <bFeebCh6IrqFlagBufferEmpty+0xc>
81104ae4:	003b68fa 	trap	3
81104ae8:	dfc00215 	stw	ra,8(sp)
81104aec:	df000115 	stw	fp,4(sp)
81104af0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81104af4:	01400144 	movi	r5,5
81104af8:	01204834 	movhi	r4,33056
81104afc:	21060004 	addi	r4,r4,6144
81104b00:	110519c0 	call	8110519c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104b04:	1080004c 	andi	r2,r2,1
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81104b08:	10000326 	beq	r2,zero,81104b18 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104b0c:	00800044 	movi	r2,1
81104b10:	e0bfff15 	stw	r2,-4(fp)
81104b14:	00000106 	br	81104b1c <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104b18:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104b1c:	e0bfff17 	ldw	r2,-4(fp)
}
81104b20:	e037883a 	mov	sp,fp
81104b24:	dfc00117 	ldw	ra,4(sp)
81104b28:	df000017 	ldw	fp,0(sp)
81104b2c:	dec00204 	addi	sp,sp,8
81104b30:	f800283a 	ret

81104b34 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81104b34:	defffd04 	addi	sp,sp,-12
81104b38:	de00012e 	bgeu	sp,et,81104b40 <bFeebCh7IrqFlagBufferEmpty+0xc>
81104b3c:	003b68fa 	trap	3
81104b40:	dfc00215 	stw	ra,8(sp)
81104b44:	df000115 	stw	fp,4(sp)
81104b48:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81104b4c:	01400144 	movi	r5,5
81104b50:	01204834 	movhi	r4,33056
81104b54:	21050004 	addi	r4,r4,5120
81104b58:	110519c0 	call	8110519c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104b5c:	1080004c 	andi	r2,r2,1
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81104b60:	10000326 	beq	r2,zero,81104b70 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104b64:	00800044 	movi	r2,1
81104b68:	e0bfff15 	stw	r2,-4(fp)
81104b6c:	00000106 	br	81104b74 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104b70:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104b74:	e0bfff17 	ldw	r2,-4(fp)
}
81104b78:	e037883a 	mov	sp,fp
81104b7c:	dfc00117 	ldw	ra,4(sp)
81104b80:	df000017 	ldw	fp,0(sp)
81104b84:	dec00204 	addi	sp,sp,8
81104b88:	f800283a 	ret

81104b8c <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81104b8c:	defffd04 	addi	sp,sp,-12
81104b90:	de00012e 	bgeu	sp,et,81104b98 <bFeebCh8IrqFlagBufferEmpty+0xc>
81104b94:	003b68fa 	trap	3
81104b98:	dfc00215 	stw	ra,8(sp)
81104b9c:	df000115 	stw	fp,4(sp)
81104ba0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81104ba4:	01400144 	movi	r5,5
81104ba8:	01204834 	movhi	r4,33056
81104bac:	21040004 	addi	r4,r4,4096
81104bb0:	110519c0 	call	8110519c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104bb4:	1080004c 	andi	r2,r2,1
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81104bb8:	10000326 	beq	r2,zero,81104bc8 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104bbc:	00800044 	movi	r2,1
81104bc0:	e0bfff15 	stw	r2,-4(fp)
81104bc4:	00000106 	br	81104bcc <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104bc8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104bcc:	e0bfff17 	ldw	r2,-4(fp)
}
81104bd0:	e037883a 	mov	sp,fp
81104bd4:	dfc00117 	ldw	ra,4(sp)
81104bd8:	df000017 	ldw	fp,0(sp)
81104bdc:	dec00204 	addi	sp,sp,8
81104be0:	f800283a 	ret

81104be4 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81104be4:	defffc04 	addi	sp,sp,-16
81104be8:	de00012e 	bgeu	sp,et,81104bf0 <vFeebInitIrq+0xc>
81104bec:	003b68fa 	trap	3
81104bf0:	dfc00315 	stw	ra,12(sp)
81104bf4:	df000215 	stw	fp,8(sp)
81104bf8:	df000204 	addi	fp,sp,8
81104bfc:	2005883a 	mov	r2,r4
81104c00:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81104c04:	e0bfff03 	ldbu	r2,-4(fp)
81104c08:	10c00268 	cmpgeui	r3,r2,9
81104c0c:	18004f1e 	bne	r3,zero,81104d4c <vFeebInitIrq+0x168>
81104c10:	100690ba 	slli	r3,r2,2
81104c14:	00a04434 	movhi	r2,33040
81104c18:	10930a04 	addi	r2,r2,19496
81104c1c:	1885883a 	add	r2,r3,r2
81104c20:	10800017 	ldw	r2,0(r2)
81104c24:	1000683a 	jmp	r2
81104c28:	81104d4c 	andi	r4,r16,16693
81104c2c:	81104c4c 	andi	r4,r16,16689
81104c30:	81104c6c 	andhi	r4,r16,16689
81104c34:	81104c8c 	andi	r4,r16,16690
81104c38:	81104cac 	andhi	r4,r16,16690
81104c3c:	81104ccc 	andi	r4,r16,16691
81104c40:	81104cec 	andhi	r4,r16,16691
81104c44:	81104d0c 	andi	r4,r16,16692
81104c48:	81104d2c 	andhi	r4,r16,16692
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81104c4c:	d0a03e04 	addi	r2,gp,-32520
81104c50:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_A_IRQ, pvHoldContext,
81104c54:	01a04434 	movhi	r6,33040
81104c58:	31914104 	addi	r6,r6,17668
81104c5c:	e17ffe17 	ldw	r5,-8(fp)
81104c60:	01000084 	movi	r4,2
81104c64:	112b28c0 	call	8112b28c <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81104c68:	00003806 	br	81104d4c <vFeebInitIrq+0x168>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81104c6c:	d0a03f04 	addi	r2,gp,-32516
81104c70:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_B_IRQ, pvHoldContext,
81104c74:	01a04434 	movhi	r6,33040
81104c78:	31915104 	addi	r6,r6,17732
81104c7c:	e17ffe17 	ldw	r5,-8(fp)
81104c80:	010000c4 	movi	r4,3
81104c84:	112b28c0 	call	8112b28c <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
81104c88:	00003006 	br	81104d4c <vFeebInitIrq+0x168>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81104c8c:	d0a04004 	addi	r2,gp,-32512
81104c90:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_C_IRQ, pvHoldContext,
81104c94:	01a04434 	movhi	r6,33040
81104c98:	31916104 	addi	r6,r6,17796
81104c9c:	e17ffe17 	ldw	r5,-8(fp)
81104ca0:	01000104 	movi	r4,4
81104ca4:	112b28c0 	call	8112b28c <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81104ca8:	00002806 	br	81104d4c <vFeebInitIrq+0x168>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81104cac:	d0a04104 	addi	r2,gp,-32508
81104cb0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_D_IRQ, pvHoldContext,
81104cb4:	01a04434 	movhi	r6,33040
81104cb8:	31917104 	addi	r6,r6,17860
81104cbc:	e17ffe17 	ldw	r5,-8(fp)
81104cc0:	01000204 	movi	r4,8
81104cc4:	112b28c0 	call	8112b28c <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
81104cc8:	00002006 	br	81104d4c <vFeebInitIrq+0x168>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81104ccc:	d0a04204 	addi	r2,gp,-32504
81104cd0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_E_IRQ, pvHoldContext,
81104cd4:	01a04434 	movhi	r6,33040
81104cd8:	31918104 	addi	r6,r6,17924
81104cdc:	e17ffe17 	ldw	r5,-8(fp)
81104ce0:	010001c4 	movi	r4,7
81104ce4:	112b28c0 	call	8112b28c <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81104ce8:	00001806 	br	81104d4c <vFeebInitIrq+0x168>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81104cec:	d0a04304 	addi	r2,gp,-32500
81104cf0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_F_IRQ, pvHoldContext,
81104cf4:	01a04434 	movhi	r6,33040
81104cf8:	31919104 	addi	r6,r6,17988
81104cfc:	e17ffe17 	ldw	r5,-8(fp)
81104d00:	01000184 	movi	r4,6
81104d04:	112b28c0 	call	8112b28c <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81104d08:	00001006 	br	81104d4c <vFeebInitIrq+0x168>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81104d0c:	d0a04404 	addi	r2,gp,-32496
81104d10:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_G_IRQ, pvHoldContext,
81104d14:	01a04434 	movhi	r6,33040
81104d18:	3191a104 	addi	r6,r6,18052
81104d1c:	e17ffe17 	ldw	r5,-8(fp)
81104d20:	01000144 	movi	r4,5
81104d24:	112b28c0 	call	8112b28c <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81104d28:	00000806 	br	81104d4c <vFeebInitIrq+0x168>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81104d2c:	d0a04504 	addi	r2,gp,-32492
81104d30:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_H_IRQ, pvHoldContext,
81104d34:	01a04434 	movhi	r6,33040
81104d38:	3191b104 	addi	r6,r6,18116
81104d3c:	e17ffe17 	ldw	r5,-8(fp)
81104d40:	01000244 	movi	r4,9
81104d44:	112b28c0 	call	8112b28c <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
81104d48:	0001883a 	nop
	}
}
81104d4c:	0001883a 	nop
81104d50:	e037883a 	mov	sp,fp
81104d54:	dfc00117 	ldw	ra,4(sp)
81104d58:	df000017 	ldw	fp,0(sp)
81104d5c:	dec00204 	addi	sp,sp,8
81104d60:	f800283a 	ret

81104d64 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
81104d64:	defffb04 	addi	sp,sp,-20
81104d68:	de00012e 	bgeu	sp,et,81104d70 <bFeebSetIrqControl+0xc>
81104d6c:	003b68fa 	trap	3
81104d70:	dfc00415 	stw	ra,16(sp)
81104d74:	df000315 	stw	fp,12(sp)
81104d78:	df000304 	addi	fp,sp,12
81104d7c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d80:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104d84:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104d88:	e0bfff17 	ldw	r2,-4(fp)
81104d8c:	10002426 	beq	r2,zero,81104e20 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104d90:	e0bfff17 	ldw	r2,-4(fp)
81104d94:	10800017 	ldw	r2,0(r2)
81104d98:	01400104 	movi	r5,4
81104d9c:	1009883a 	mov	r4,r2
81104da0:	110519c0 	call	8110519c <uliFeebReadReg>
81104da4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CTRL_REG_OFFSET);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81104da8:	e0bfff17 	ldw	r2,-4(fp)
81104dac:	10800217 	ldw	r2,8(r2)
81104db0:	10000426 	beq	r2,zero,81104dc4 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_L_BUFFER_EMPTY_EN_MSK;
81104db4:	e0bffe17 	ldw	r2,-8(fp)
81104db8:	10804014 	ori	r2,r2,256
81104dbc:	e0bffe15 	stw	r2,-8(fp)
81104dc0:	00000406 	br	81104dd4 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_L_BUFFER_EMPTY_EN_MSK);
81104dc4:	e0fffe17 	ldw	r3,-8(fp)
81104dc8:	00bfbfc4 	movi	r2,-257
81104dcc:	1884703a 	and	r2,r3,r2
81104dd0:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81104dd4:	e0bfff17 	ldw	r2,-4(fp)
81104dd8:	10800317 	ldw	r2,12(r2)
81104ddc:	10000426 	beq	r2,zero,81104df0 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_R_BUFFER_EMPTY_EN_MSK;
81104de0:	e0bffe17 	ldw	r2,-8(fp)
81104de4:	10800054 	ori	r2,r2,1
81104de8:	e0bffe15 	stw	r2,-8(fp)
81104dec:	00000406 	br	81104e00 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_R_BUFFER_EMPTY_EN_MSK);
81104df0:	e0fffe17 	ldw	r3,-8(fp)
81104df4:	00bfff84 	movi	r2,-2
81104df8:	1884703a 	and	r2,r3,r2
81104dfc:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CTRL_REG_OFFSET,
81104e00:	e0bfff17 	ldw	r2,-4(fp)
81104e04:	10800017 	ldw	r2,0(r2)
81104e08:	e1bffe17 	ldw	r6,-8(fp)
81104e0c:	01400104 	movi	r5,4
81104e10:	1009883a 	mov	r4,r2
81104e14:	11051480 	call	81105148 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81104e18:	00800044 	movi	r2,1
81104e1c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104e20:	e0bffd17 	ldw	r2,-12(fp)
}
81104e24:	e037883a 	mov	sp,fp
81104e28:	dfc00117 	ldw	ra,4(sp)
81104e2c:	df000017 	ldw	fp,0(sp)
81104e30:	dec00204 	addi	sp,sp,8
81104e34:	f800283a 	ret

81104e38 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81104e38:	defffb04 	addi	sp,sp,-20
81104e3c:	de00012e 	bgeu	sp,et,81104e44 <bFeebGetIrqControl+0xc>
81104e40:	003b68fa 	trap	3
81104e44:	dfc00415 	stw	ra,16(sp)
81104e48:	df000315 	stw	fp,12(sp)
81104e4c:	df000304 	addi	fp,sp,12
81104e50:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104e54:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104e58:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104e5c:	e0bfff17 	ldw	r2,-4(fp)
81104e60:	10001a26 	beq	r2,zero,81104ecc <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104e64:	e0bfff17 	ldw	r2,-4(fp)
81104e68:	10800017 	ldw	r2,0(r2)
81104e6c:	01400104 	movi	r5,4
81104e70:	1009883a 	mov	r4,r2
81104e74:	110519c0 	call	8110519c <uliFeebReadReg>
81104e78:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CTRL_REG_OFFSET);

		if (uliReg & COMM_IRQ_L_BUFFER_EMPTY_EN_MSK) {
81104e7c:	e0bffe17 	ldw	r2,-8(fp)
81104e80:	1080400c 	andi	r2,r2,256
81104e84:	10000426 	beq	r2,zero,81104e98 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81104e88:	e0bfff17 	ldw	r2,-4(fp)
81104e8c:	00c00044 	movi	r3,1
81104e90:	10c00215 	stw	r3,8(r2)
81104e94:	00000206 	br	81104ea0 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81104e98:	e0bfff17 	ldw	r2,-4(fp)
81104e9c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_R_BUFFER_EMPTY_EN_MSK) {
81104ea0:	e0bffe17 	ldw	r2,-8(fp)
81104ea4:	1080004c 	andi	r2,r2,1
81104ea8:	10000426 	beq	r2,zero,81104ebc <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81104eac:	e0bfff17 	ldw	r2,-4(fp)
81104eb0:	00c00044 	movi	r3,1
81104eb4:	10c00315 	stw	r3,12(r2)
81104eb8:	00000206 	br	81104ec4 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81104ebc:	e0bfff17 	ldw	r2,-4(fp)
81104ec0:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
81104ec4:	00800044 	movi	r2,1
81104ec8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ecc:	e0bffd17 	ldw	r2,-12(fp)
}
81104ed0:	e037883a 	mov	sp,fp
81104ed4:	dfc00117 	ldw	ra,4(sp)
81104ed8:	df000017 	ldw	fp,0(sp)
81104edc:	dec00204 	addi	sp,sp,8
81104ee0:	f800283a 	ret

81104ee4 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81104ee4:	defffb04 	addi	sp,sp,-20
81104ee8:	de00012e 	bgeu	sp,et,81104ef0 <bFeebGetIrqFlags+0xc>
81104eec:	003b68fa 	trap	3
81104ef0:	dfc00415 	stw	ra,16(sp)
81104ef4:	df000315 	stw	fp,12(sp)
81104ef8:	df000304 	addi	fp,sp,12
81104efc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104f00:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104f04:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104f08:	e0bfff17 	ldw	r2,-4(fp)
81104f0c:	10001126 	beq	r2,zero,81104f54 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104f10:	e0bfff17 	ldw	r2,-4(fp)
81104f14:	10800017 	ldw	r2,0(r2)
81104f18:	01400144 	movi	r5,5
81104f1c:	1009883a 	mov	r4,r2
81104f20:	110519c0 	call	8110519c <uliFeebReadReg>
81104f24:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAG_REG_OFFSET);

		if (uliReg & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104f28:	e0bffe17 	ldw	r2,-8(fp)
81104f2c:	1080004c 	andi	r2,r2,1
81104f30:	10000426 	beq	r2,zero,81104f44 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81104f34:	e0bfff17 	ldw	r2,-4(fp)
81104f38:	00c00044 	movi	r3,1
81104f3c:	10c00415 	stw	r3,16(r2)
81104f40:	00000206 	br	81104f4c <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81104f44:	e0bfff17 	ldw	r2,-4(fp)
81104f48:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
81104f4c:	00800044 	movi	r2,1
81104f50:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104f54:	e0bffd17 	ldw	r2,-12(fp)
}
81104f58:	e037883a 	mov	sp,fp
81104f5c:	dfc00117 	ldw	ra,4(sp)
81104f60:	df000017 	ldw	fp,0(sp)
81104f64:	dec00204 	addi	sp,sp,8
81104f68:	f800283a 	ret

81104f6c <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81104f6c:	defffb04 	addi	sp,sp,-20
81104f70:	de00012e 	bgeu	sp,et,81104f78 <bFeebSetWindowing+0xc>
81104f74:	003b68fa 	trap	3
81104f78:	dfc00415 	stw	ra,16(sp)
81104f7c:	df000315 	stw	fp,12(sp)
81104f80:	df000304 	addi	fp,sp,12
81104f84:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104f88:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104f8c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104f90:	e0bfff17 	ldw	r2,-4(fp)
81104f94:	10001926 	beq	r2,zero,81104ffc <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104f98:	e0bfff17 	ldw	r2,-4(fp)
81104f9c:	10800017 	ldw	r2,0(r2)
81104fa0:	000b883a 	mov	r5,zero
81104fa4:	1009883a 	mov	r4,r2
81104fa8:	110519c0 	call	8110519c <uliFeebReadReg>
81104fac:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81104fb0:	e0bfff17 	ldw	r2,-4(fp)
81104fb4:	10800117 	ldw	r2,4(r2)
81104fb8:	10000426 	beq	r2,zero,81104fcc <bFeebSetWindowing+0x60>
			uliReg |= COMM_CTRL_MASKING_EN_MSK;
81104fbc:	e0bffe17 	ldw	r2,-8(fp)
81104fc0:	10804014 	ori	r2,r2,256
81104fc4:	e0bffe15 	stw	r2,-8(fp)
81104fc8:	00000406 	br	81104fdc <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_CTRL_MASKING_EN_MSK);
81104fcc:	e0fffe17 	ldw	r3,-8(fp)
81104fd0:	00bfbfc4 	movi	r2,-257
81104fd4:	1884703a 	and	r2,r3,r2
81104fd8:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_WINDOW_CTRL_REG_OFFSET,
81104fdc:	e0bfff17 	ldw	r2,-4(fp)
81104fe0:	10800017 	ldw	r2,0(r2)
81104fe4:	e1bffe17 	ldw	r6,-8(fp)
81104fe8:	000b883a 	mov	r5,zero
81104fec:	1009883a 	mov	r4,r2
81104ff0:	11051480 	call	81105148 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81104ff4:	00800044 	movi	r2,1
81104ff8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ffc:	e0bffd17 	ldw	r2,-12(fp)
}
81105000:	e037883a 	mov	sp,fp
81105004:	dfc00117 	ldw	ra,4(sp)
81105008:	df000017 	ldw	fp,0(sp)
8110500c:	dec00204 	addi	sp,sp,8
81105010:	f800283a 	ret

81105014 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81105014:	defffb04 	addi	sp,sp,-20
81105018:	de00012e 	bgeu	sp,et,81105020 <bFeebGetWindowing+0xc>
8110501c:	003b68fa 	trap	3
81105020:	dfc00415 	stw	ra,16(sp)
81105024:	df000315 	stw	fp,12(sp)
81105028:	df000304 	addi	fp,sp,12
8110502c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105030:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105034:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105038:	e0bfff17 	ldw	r2,-4(fp)
8110503c:	10001126 	beq	r2,zero,81105084 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105040:	e0bfff17 	ldw	r2,-4(fp)
81105044:	10800017 	ldw	r2,0(r2)
81105048:	000b883a 	mov	r5,zero
8110504c:	1009883a 	mov	r4,r2
81105050:	110519c0 	call	8110519c <uliFeebReadReg>
81105054:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (uliReg & COMM_CTRL_MASKING_EN_MSK) {
81105058:	e0bffe17 	ldw	r2,-8(fp)
8110505c:	1080400c 	andi	r2,r2,256
81105060:	10000426 	beq	r2,zero,81105074 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81105064:	e0bfff17 	ldw	r2,-4(fp)
81105068:	00c00044 	movi	r3,1
8110506c:	10c00115 	stw	r3,4(r2)
81105070:	00000206 	br	8110507c <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81105074:	e0bfff17 	ldw	r2,-4(fp)
81105078:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
8110507c:	00800044 	movi	r2,1
81105080:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105084:	e0bffd17 	ldw	r2,-12(fp)
}
81105088:	e037883a 	mov	sp,fp
8110508c:	dfc00117 	ldw	ra,4(sp)
81105090:	df000017 	ldw	fp,0(sp)
81105094:	dec00204 	addi	sp,sp,8
81105098:	f800283a 	ret

8110509c <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
8110509c:	defffb04 	addi	sp,sp,-20
811050a0:	de00012e 	bgeu	sp,et,811050a8 <bFeebGetBuffersStatus+0xc>
811050a4:	003b68fa 	trap	3
811050a8:	dfc00415 	stw	ra,16(sp)
811050ac:	df000315 	stw	fp,12(sp)
811050b0:	df000304 	addi	fp,sp,12
811050b4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811050b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811050bc:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811050c0:	e0bfff17 	ldw	r2,-4(fp)
811050c4:	10001a26 	beq	r2,zero,81105130 <bFeebGetBuffersStatus+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811050c8:	e0bfff17 	ldw	r2,-4(fp)
811050cc:	10800017 	ldw	r2,0(r2)
811050d0:	01400184 	movi	r5,6
811050d4:	1009883a 	mov	r4,r2
811050d8:	110519c0 	call	8110519c <uliFeebReadReg>
811050dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_BUFFER_REG_OFFSET);

		if (uliReg & COMM_BUFF_STAT_L_BUFF_EPY_MSK) {
811050e0:	e0bffe17 	ldw	r2,-8(fp)
811050e4:	1080400c 	andi	r2,r2,256
811050e8:	10000426 	beq	r2,zero,811050fc <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
811050ec:	e0bfff17 	ldw	r2,-4(fp)
811050f0:	00c00044 	movi	r3,1
811050f4:	10c00515 	stw	r3,20(r2)
811050f8:	00000206 	br	81105104 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
811050fc:	e0bfff17 	ldw	r2,-4(fp)
81105100:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_BUFF_STAT_R_BUFF_EPY_MSK) {
81105104:	e0bffe17 	ldw	r2,-8(fp)
81105108:	1080004c 	andi	r2,r2,1
8110510c:	10000426 	beq	r2,zero,81105120 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
81105110:	e0bfff17 	ldw	r2,-4(fp)
81105114:	00c00044 	movi	r3,1
81105118:	10c00615 	stw	r3,24(r2)
8110511c:	00000206 	br	81105128 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
81105120:	e0bfff17 	ldw	r2,-4(fp)
81105124:	10000615 	stw	zero,24(r2)
		}

		bStatus = TRUE;
81105128:	00800044 	movi	r2,1
8110512c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105130:	e0bffd17 	ldw	r2,-12(fp)
}
81105134:	e037883a 	mov	sp,fp
81105138:	dfc00117 	ldw	ra,4(sp)
8110513c:	df000017 	ldw	fp,0(sp)
81105140:	dec00204 	addi	sp,sp,8
81105144:	f800283a 	ret

81105148 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81105148:	defffc04 	addi	sp,sp,-16
8110514c:	de00012e 	bgeu	sp,et,81105154 <vFeebWriteReg+0xc>
81105150:	003b68fa 	trap	3
81105154:	df000315 	stw	fp,12(sp)
81105158:	df000304 	addi	fp,sp,12
8110515c:	e13ffd15 	stw	r4,-12(fp)
81105160:	e17ffe15 	stw	r5,-8(fp)
81105164:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81105168:	e0bffe17 	ldw	r2,-8(fp)
8110516c:	1085883a 	add	r2,r2,r2
81105170:	1085883a 	add	r2,r2,r2
81105174:	1007883a 	mov	r3,r2
81105178:	e0bffd17 	ldw	r2,-12(fp)
8110517c:	10c5883a 	add	r2,r2,r3
81105180:	e0ffff17 	ldw	r3,-4(fp)
81105184:	10c00015 	stw	r3,0(r2)
}
81105188:	0001883a 	nop
8110518c:	e037883a 	mov	sp,fp
81105190:	df000017 	ldw	fp,0(sp)
81105194:	dec00104 	addi	sp,sp,4
81105198:	f800283a 	ret

8110519c <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110519c:	defffc04 	addi	sp,sp,-16
811051a0:	de00012e 	bgeu	sp,et,811051a8 <uliFeebReadReg+0xc>
811051a4:	003b68fa 	trap	3
811051a8:	df000315 	stw	fp,12(sp)
811051ac:	df000304 	addi	fp,sp,12
811051b0:	e13ffe15 	stw	r4,-8(fp)
811051b4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811051b8:	e0bfff17 	ldw	r2,-4(fp)
811051bc:	1085883a 	add	r2,r2,r2
811051c0:	1085883a 	add	r2,r2,r2
811051c4:	1007883a 	mov	r3,r2
811051c8:	e0bffe17 	ldw	r2,-8(fp)
811051cc:	10c5883a 	add	r2,r2,r3
811051d0:	10800017 	ldw	r2,0(r2)
811051d4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
811051d8:	e0bffd17 	ldw	r2,-12(fp)
}
811051dc:	e037883a 	mov	sp,fp
811051e0:	df000017 	ldw	fp,0(sp)
811051e4:	dec00104 	addi	sp,sp,4
811051e8:	f800283a 	ret

811051ec <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
811051ec:	defffb04 	addi	sp,sp,-20
811051f0:	de00012e 	bgeu	sp,et,811051f8 <bSpwcSetLink+0xc>
811051f4:	003b68fa 	trap	3
811051f8:	dfc00415 	stw	ra,16(sp)
811051fc:	df000315 	stw	fp,12(sp)
81105200:	df000304 	addi	fp,sp,12
81105204:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105208:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110520c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81105210:	e0bfff17 	ldw	r2,-4(fp)
81105214:	10002f26 	beq	r2,zero,811052d4 <bSpwcSetLink+0xe8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81105218:	e0bfff17 	ldw	r2,-4(fp)
8110521c:	10800017 	ldw	r2,0(r2)
81105220:	000b883a 	mov	r5,zero
81105224:	1009883a 	mov	r4,r2
81105228:	110574c0 	call	8110574c <uliSpwcReadReg>
8110522c:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
81105230:	e0bfff17 	ldw	r2,-4(fp)
81105234:	10800117 	ldw	r2,4(r2)
81105238:	10000426 	beq	r2,zero,8110524c <bSpwcSetLink+0x60>
			uliReg |= COMM_CTRL_LINK_AUTOSTART_MSK;
8110523c:	e0bffe17 	ldw	r2,-8(fp)
81105240:	10800114 	ori	r2,r2,4
81105244:	e0bffe15 	stw	r2,-8(fp)
81105248:	00000406 	br	8110525c <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_CTRL_LINK_AUTOSTART_MSK);
8110524c:	e0fffe17 	ldw	r3,-8(fp)
81105250:	00bffec4 	movi	r2,-5
81105254:	1884703a 	and	r2,r3,r2
81105258:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bStart) {
8110525c:	e0bfff17 	ldw	r2,-4(fp)
81105260:	10800217 	ldw	r2,8(r2)
81105264:	10000426 	beq	r2,zero,81105278 <bSpwcSetLink+0x8c>
			uliReg |= COMM_CTRL_LINK_START_MSK;
81105268:	e0bffe17 	ldw	r2,-8(fp)
8110526c:	10800094 	ori	r2,r2,2
81105270:	e0bffe15 	stw	r2,-8(fp)
81105274:	00000406 	br	81105288 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_CTRL_LINK_START_MSK);
81105278:	e0fffe17 	ldw	r3,-8(fp)
8110527c:	00bfff44 	movi	r2,-3
81105280:	1884703a 	and	r2,r3,r2
81105284:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
81105288:	e0bfff17 	ldw	r2,-4(fp)
8110528c:	10800317 	ldw	r2,12(r2)
81105290:	10000426 	beq	r2,zero,811052a4 <bSpwcSetLink+0xb8>
			uliReg |= COMM_CTRL_LINK_DISCONNECT_MSK;
81105294:	e0bffe17 	ldw	r2,-8(fp)
81105298:	10800054 	ori	r2,r2,1
8110529c:	e0bffe15 	stw	r2,-8(fp)
811052a0:	00000406 	br	811052b4 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_CTRL_LINK_DISCONNECT_MSK);
811052a4:	e0fffe17 	ldw	r3,-8(fp)
811052a8:	00bfff84 	movi	r2,-2
811052ac:	1884703a 	and	r2,r3,r2
811052b0:	e0bffe15 	stw	r2,-8(fp)
		}

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_WINDOW_CTRL_REG_OFFSET,
811052b4:	e0bfff17 	ldw	r2,-4(fp)
811052b8:	10800017 	ldw	r2,0(r2)
811052bc:	e1bffe17 	ldw	r6,-8(fp)
811052c0:	000b883a 	mov	r5,zero
811052c4:	1009883a 	mov	r4,r2
811052c8:	11056f80 	call	811056f8 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
811052cc:	00800044 	movi	r2,1
811052d0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811052d4:	e0bffd17 	ldw	r2,-12(fp)
}
811052d8:	e037883a 	mov	sp,fp
811052dc:	dfc00117 	ldw	ra,4(sp)
811052e0:	df000017 	ldw	fp,0(sp)
811052e4:	dec00204 	addi	sp,sp,8
811052e8:	f800283a 	ret

811052ec <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
811052ec:	defffb04 	addi	sp,sp,-20
811052f0:	de00012e 	bgeu	sp,et,811052f8 <bSpwcGetLink+0xc>
811052f4:	003b68fa 	trap	3
811052f8:	dfc00415 	stw	ra,16(sp)
811052fc:	df000315 	stw	fp,12(sp)
81105300:	df000304 	addi	fp,sp,12
81105304:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105308:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110530c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81105310:	e0bfff17 	ldw	r2,-4(fp)
81105314:	10002326 	beq	r2,zero,811053a4 <bSpwcGetLink+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81105318:	e0bfff17 	ldw	r2,-4(fp)
8110531c:	10800017 	ldw	r2,0(r2)
81105320:	000b883a 	mov	r5,zero
81105324:	1009883a 	mov	r4,r2
81105328:	110574c0 	call	8110574c <uliSpwcReadReg>
8110532c:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (uliReg & COMM_CTRL_LINK_AUTOSTART_MSK) {
81105330:	e0bffe17 	ldw	r2,-8(fp)
81105334:	1080010c 	andi	r2,r2,4
81105338:	10000426 	beq	r2,zero,8110534c <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8110533c:	e0bfff17 	ldw	r2,-4(fp)
81105340:	00c00044 	movi	r3,1
81105344:	10c00115 	stw	r3,4(r2)
81105348:	00000206 	br	81105354 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8110534c:	e0bfff17 	ldw	r2,-4(fp)
81105350:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_CTRL_LINK_START_MSK) {
81105354:	e0bffe17 	ldw	r2,-8(fp)
81105358:	1080008c 	andi	r2,r2,2
8110535c:	10000426 	beq	r2,zero,81105370 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bStart = TRUE;
81105360:	e0bfff17 	ldw	r2,-4(fp)
81105364:	00c00044 	movi	r3,1
81105368:	10c00215 	stw	r3,8(r2)
8110536c:	00000206 	br	81105378 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bStart = FALSE;
81105370:	e0bfff17 	ldw	r2,-4(fp)
81105374:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_CTRL_LINK_DISCONNECT_MSK) {
81105378:	e0bffe17 	ldw	r2,-8(fp)
8110537c:	1080004c 	andi	r2,r2,1
81105380:	10000426 	beq	r2,zero,81105394 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
81105384:	e0bfff17 	ldw	r2,-4(fp)
81105388:	00c00044 	movi	r3,1
8110538c:	10c00315 	stw	r3,12(r2)
81105390:	00000206 	br	8110539c <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
81105394:	e0bfff17 	ldw	r2,-4(fp)
81105398:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
8110539c:	00800044 	movi	r2,1
811053a0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811053a4:	e0bffd17 	ldw	r2,-12(fp)
}
811053a8:	e037883a 	mov	sp,fp
811053ac:	dfc00117 	ldw	ra,4(sp)
811053b0:	df000017 	ldw	fp,0(sp)
811053b4:	dec00204 	addi	sp,sp,8
811053b8:	f800283a 	ret

811053bc <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
811053bc:	defffb04 	addi	sp,sp,-20
811053c0:	de00012e 	bgeu	sp,et,811053c8 <bSpwcGetLinkError+0xc>
811053c4:	003b68fa 	trap	3
811053c8:	dfc00415 	stw	ra,16(sp)
811053cc:	df000315 	stw	fp,12(sp)
811053d0:	df000304 	addi	fp,sp,12
811053d4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811053d8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811053dc:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811053e0:	e0bfff17 	ldw	r2,-4(fp)
811053e4:	10002c26 	beq	r2,zero,81105498 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811053e8:	e0bfff17 	ldw	r2,-4(fp)
811053ec:	10800017 	ldw	r2,0(r2)
811053f0:	01400044 	movi	r5,1
811053f4:	1009883a 	mov	r4,r2
811053f8:	110574c0 	call	8110574c <uliSpwcReadReg>
811053fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_STAT_REG_OFFSET);

		if (uliReg & COMM_STAT_LINK_DISC_ERR_MSK) {
81105400:	e0bffe17 	ldw	r2,-8(fp)
81105404:	1082000c 	andi	r2,r2,2048
81105408:	10000426 	beq	r2,zero,8110541c <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110540c:	e0bfff17 	ldw	r2,-4(fp)
81105410:	00c00044 	movi	r3,1
81105414:	10c00415 	stw	r3,16(r2)
81105418:	00000206 	br	81105424 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
8110541c:	e0bfff17 	ldw	r2,-4(fp)
81105420:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_STAT_LINK_PAR_ERR_MSK) {
81105424:	e0bffe17 	ldw	r2,-8(fp)
81105428:	1081000c 	andi	r2,r2,1024
8110542c:	10000426 	beq	r2,zero,81105440 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
81105430:	e0bfff17 	ldw	r2,-4(fp)
81105434:	00c00044 	movi	r3,1
81105438:	10c00515 	stw	r3,20(r2)
8110543c:	00000206 	br	81105448 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
81105440:	e0bfff17 	ldw	r2,-4(fp)
81105444:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_STAT_LINK_ESC_ERR_MSK) {
81105448:	e0bffe17 	ldw	r2,-8(fp)
8110544c:	1080800c 	andi	r2,r2,512
81105450:	10000426 	beq	r2,zero,81105464 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
81105454:	e0bfff17 	ldw	r2,-4(fp)
81105458:	00c00044 	movi	r3,1
8110545c:	10c00615 	stw	r3,24(r2)
81105460:	00000206 	br	8110546c <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
81105464:	e0bfff17 	ldw	r2,-4(fp)
81105468:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_STAT_LINK_CRED_ERR_MSK) {
8110546c:	e0bffe17 	ldw	r2,-8(fp)
81105470:	1080400c 	andi	r2,r2,256
81105474:	10000426 	beq	r2,zero,81105488 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
81105478:	e0bfff17 	ldw	r2,-4(fp)
8110547c:	00c00044 	movi	r3,1
81105480:	10c00715 	stw	r3,28(r2)
81105484:	00000206 	br	81105490 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
81105488:	e0bfff17 	ldw	r2,-4(fp)
8110548c:	10000715 	stw	zero,28(r2)
		}

		bStatus = TRUE;
81105490:	00800044 	movi	r2,1
81105494:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105498:	e0bffd17 	ldw	r2,-12(fp)
}
8110549c:	e037883a 	mov	sp,fp
811054a0:	dfc00117 	ldw	ra,4(sp)
811054a4:	df000017 	ldw	fp,0(sp)
811054a8:	dec00204 	addi	sp,sp,8
811054ac:	f800283a 	ret

811054b0 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
811054b0:	defffb04 	addi	sp,sp,-20
811054b4:	de00012e 	bgeu	sp,et,811054bc <bSpwcGetLinkStatus+0xc>
811054b8:	003b68fa 	trap	3
811054bc:	dfc00415 	stw	ra,16(sp)
811054c0:	df000315 	stw	fp,12(sp)
811054c4:	df000304 	addi	fp,sp,12
811054c8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811054cc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811054d0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811054d4:	e0bfff17 	ldw	r2,-4(fp)
811054d8:	10002326 	beq	r2,zero,81105568 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811054dc:	e0bfff17 	ldw	r2,-4(fp)
811054e0:	10800017 	ldw	r2,0(r2)
811054e4:	01400044 	movi	r5,1
811054e8:	1009883a 	mov	r4,r2
811054ec:	110574c0 	call	8110574c <uliSpwcReadReg>
811054f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_STAT_REG_OFFSET);

		if (uliReg & COMM_STAT_LINK_STARTED_MSK) {
811054f4:	e0bffe17 	ldw	r2,-8(fp)
811054f8:	1080010c 	andi	r2,r2,4
811054fc:	10000426 	beq	r2,zero,81105510 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
81105500:	e0bfff17 	ldw	r2,-4(fp)
81105504:	00c00044 	movi	r3,1
81105508:	10c00815 	stw	r3,32(r2)
8110550c:	00000206 	br	81105518 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
81105510:	e0bfff17 	ldw	r2,-4(fp)
81105514:	10000815 	stw	zero,32(r2)
		}
		if (uliReg & COMM_STAT_LINK_CONNECTING_MSK) {
81105518:	e0bffe17 	ldw	r2,-8(fp)
8110551c:	1080008c 	andi	r2,r2,2
81105520:	10000426 	beq	r2,zero,81105534 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
81105524:	e0bfff17 	ldw	r2,-4(fp)
81105528:	00c00044 	movi	r3,1
8110552c:	10c00915 	stw	r3,36(r2)
81105530:	00000206 	br	8110553c <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
81105534:	e0bfff17 	ldw	r2,-4(fp)
81105538:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_STAT_LINK_RUNNING_MSK) {
8110553c:	e0bffe17 	ldw	r2,-8(fp)
81105540:	1080004c 	andi	r2,r2,1
81105544:	10000426 	beq	r2,zero,81105558 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
81105548:	e0bfff17 	ldw	r2,-4(fp)
8110554c:	00c00044 	movi	r3,1
81105550:	10c00a15 	stw	r3,40(r2)
81105554:	00000206 	br	81105560 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
81105558:	e0bfff17 	ldw	r2,-4(fp)
8110555c:	10000a15 	stw	zero,40(r2)
		}

		bStatus = TRUE;
81105560:	00800044 	movi	r2,1
81105564:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105568:	e0bffd17 	ldw	r2,-12(fp)
}
8110556c:	e037883a 	mov	sp,fp
81105570:	dfc00117 	ldw	ra,4(sp)
81105574:	df000017 	ldw	fp,0(sp)
81105578:	dec00204 	addi	sp,sp,8
8110557c:	f800283a 	ret

81105580 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
81105580:	defffb04 	addi	sp,sp,-20
81105584:	de00012e 	bgeu	sp,et,8110558c <bSpwcInitCh+0xc>
81105588:	003b68fa 	trap	3
8110558c:	dfc00415 	stw	ra,16(sp)
81105590:	df000315 	stw	fp,12(sp)
81105594:	df000304 	addi	fp,sp,12
81105598:	e13ffe15 	stw	r4,-8(fp)
8110559c:	2805883a 	mov	r2,r5
811055a0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
811055a4:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
811055a8:	e0bffe17 	ldw	r2,-8(fp)
811055ac:	10004c26 	beq	r2,zero,811056e0 <bSpwcInitCh+0x160>
		bStatus = TRUE;
811055b0:	00800044 	movi	r2,1
811055b4:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
811055b8:	e0bfff03 	ldbu	r2,-4(fp)
811055bc:	10c00268 	cmpgeui	r3,r2,9
811055c0:	1800371e 	bne	r3,zero,811056a0 <bSpwcInitCh+0x120>
811055c4:	100690ba 	slli	r3,r2,2
811055c8:	00a04434 	movhi	r2,33040
811055cc:	10957704 	addi	r2,r2,21980
811055d0:	1885883a 	add	r2,r3,r2
811055d4:	10800017 	ldw	r2,0(r2)
811055d8:	1000683a 	jmp	r2
811055dc:	811056a0 	cmpeqi	r4,r16,16730
811055e0:	81105600 	call	88110560 <__reset+0x20f0560>
811055e4:	81105614 	ori	r4,r16,16728
811055e8:	81105628 	cmpgeui	r4,r16,16728
811055ec:	8110563c 	xorhi	r4,r16,16728
811055f0:	81105650 	cmplti	r4,r16,16729
811055f4:	81105664 	muli	r4,r16,16729
811055f8:	81105678 	rdprs	r4,r16,16729
811055fc:	8110568c 	andi	r4,r16,16730
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81105600:	e0fffe17 	ldw	r3,-8(fp)
81105604:	00a04834 	movhi	r2,33056
81105608:	108b0004 	addi	r2,r2,11264
8110560c:	18800015 	stw	r2,0(r3)
			break;
81105610:	00002506 	br	811056a8 <bSpwcInitCh+0x128>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81105614:	e0fffe17 	ldw	r3,-8(fp)
81105618:	00a04834 	movhi	r2,33056
8110561c:	108a0004 	addi	r2,r2,10240
81105620:	18800015 	stw	r2,0(r3)
			break;
81105624:	00002006 	br	811056a8 <bSpwcInitCh+0x128>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81105628:	e0fffe17 	ldw	r3,-8(fp)
8110562c:	00a04834 	movhi	r2,33056
81105630:	10890004 	addi	r2,r2,9216
81105634:	18800015 	stw	r2,0(r3)
			break;
81105638:	00001b06 	br	811056a8 <bSpwcInitCh+0x128>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110563c:	e0fffe17 	ldw	r3,-8(fp)
81105640:	00a04834 	movhi	r2,33056
81105644:	10880004 	addi	r2,r2,8192
81105648:	18800015 	stw	r2,0(r3)
			break;
8110564c:	00001606 	br	811056a8 <bSpwcInitCh+0x128>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81105650:	e0fffe17 	ldw	r3,-8(fp)
81105654:	00a04834 	movhi	r2,33056
81105658:	10870004 	addi	r2,r2,7168
8110565c:	18800015 	stw	r2,0(r3)
			break;
81105660:	00001106 	br	811056a8 <bSpwcInitCh+0x128>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81105664:	e0fffe17 	ldw	r3,-8(fp)
81105668:	00a04834 	movhi	r2,33056
8110566c:	10860004 	addi	r2,r2,6144
81105670:	18800015 	stw	r2,0(r3)
			break;
81105674:	00000c06 	br	811056a8 <bSpwcInitCh+0x128>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81105678:	e0fffe17 	ldw	r3,-8(fp)
8110567c:	00a04834 	movhi	r2,33056
81105680:	10850004 	addi	r2,r2,5120
81105684:	18800015 	stw	r2,0(r3)
			break;
81105688:	00000706 	br	811056a8 <bSpwcInitCh+0x128>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110568c:	e0fffe17 	ldw	r3,-8(fp)
81105690:	00a04834 	movhi	r2,33056
81105694:	10840004 	addi	r2,r2,4096
81105698:	18800015 	stw	r2,0(r3)
			break;
8110569c:	00000206 	br	811056a8 <bSpwcInitCh+0x128>
		default:
			bStatus = FALSE;
811056a0:	e03ffd15 	stw	zero,-12(fp)
			break;
811056a4:	0001883a 	nop
		}

		if (bStatus) {
811056a8:	e0bffd17 	ldw	r2,-12(fp)
811056ac:	10000c26 	beq	r2,zero,811056e0 <bSpwcInitCh+0x160>
//			if (!bFeebGetWindowing(pxSpwcCh)) {
//				bStatus = FALSE;
//			}
			if (!bSpwcGetLink(pxSpwcCh)) {
811056b0:	e13ffe17 	ldw	r4,-8(fp)
811056b4:	11052ec0 	call	811052ec <bSpwcGetLink>
811056b8:	1000011e 	bne	r2,zero,811056c0 <bSpwcInitCh+0x140>
				bStatus = FALSE;
811056bc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
811056c0:	e13ffe17 	ldw	r4,-8(fp)
811056c4:	11053bc0 	call	811053bc <bSpwcGetLinkError>
811056c8:	1000011e 	bne	r2,zero,811056d0 <bSpwcInitCh+0x150>
				bStatus = FALSE;
811056cc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
811056d0:	e13ffe17 	ldw	r4,-8(fp)
811056d4:	11054b00 	call	811054b0 <bSpwcGetLinkStatus>
811056d8:	1000011e 	bne	r2,zero,811056e0 <bSpwcInitCh+0x160>
				bStatus = FALSE;
811056dc:	e03ffd15 	stw	zero,-12(fp)
//			if (!bFeebGetBuffersStatus(pxSpwcCh)) {
//				bStatus = FALSE;
//			}
		}
	}
	return bStatus;
811056e0:	e0bffd17 	ldw	r2,-12(fp)
}
811056e4:	e037883a 	mov	sp,fp
811056e8:	dfc00117 	ldw	ra,4(sp)
811056ec:	df000017 	ldw	fp,0(sp)
811056f0:	dec00204 	addi	sp,sp,8
811056f4:	f800283a 	ret

811056f8 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811056f8:	defffc04 	addi	sp,sp,-16
811056fc:	de00012e 	bgeu	sp,et,81105704 <vSpwcWriteReg+0xc>
81105700:	003b68fa 	trap	3
81105704:	df000315 	stw	fp,12(sp)
81105708:	df000304 	addi	fp,sp,12
8110570c:	e13ffd15 	stw	r4,-12(fp)
81105710:	e17ffe15 	stw	r5,-8(fp)
81105714:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81105718:	e0bffe17 	ldw	r2,-8(fp)
8110571c:	1085883a 	add	r2,r2,r2
81105720:	1085883a 	add	r2,r2,r2
81105724:	1007883a 	mov	r3,r2
81105728:	e0bffd17 	ldw	r2,-12(fp)
8110572c:	10c5883a 	add	r2,r2,r3
81105730:	e0ffff17 	ldw	r3,-4(fp)
81105734:	10c00015 	stw	r3,0(r2)
}
81105738:	0001883a 	nop
8110573c:	e037883a 	mov	sp,fp
81105740:	df000017 	ldw	fp,0(sp)
81105744:	dec00104 	addi	sp,sp,4
81105748:	f800283a 	ret

8110574c <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110574c:	defffc04 	addi	sp,sp,-16
81105750:	de00012e 	bgeu	sp,et,81105758 <uliSpwcReadReg+0xc>
81105754:	003b68fa 	trap	3
81105758:	df000315 	stw	fp,12(sp)
8110575c:	df000304 	addi	fp,sp,12
81105760:	e13ffe15 	stw	r4,-8(fp)
81105764:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105768:	e0bfff17 	ldw	r2,-4(fp)
8110576c:	1085883a 	add	r2,r2,r2
81105770:	1085883a 	add	r2,r2,r2
81105774:	1007883a 	mov	r3,r2
81105778:	e0bffe17 	ldw	r2,-8(fp)
8110577c:	10c5883a 	add	r2,r2,r3
81105780:	10800017 	ldw	r2,0(r2)
81105784:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105788:	e0bffd17 	ldw	r2,-12(fp)
}
8110578c:	e037883a 	mov	sp,fp
81105790:	df000017 	ldw	fp,0(sp)
81105794:	dec00104 	addi	sp,sp,4
81105798:	f800283a 	ret

8110579c <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110579c:	defffe04 	addi	sp,sp,-8
811057a0:	de00012e 	bgeu	sp,et,811057a8 <bEnableIsoDrivers+0xc>
811057a4:	003b68fa 	trap	3
811057a8:	dfc00115 	stw	ra,4(sp)
811057ac:	df000015 	stw	fp,0(sp)
811057b0:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
811057b4:	01400204 	movi	r5,8
811057b8:	01000044 	movi	r4,1
811057bc:	110594c0 	call	8110594c <bCtrlIoLvdsDrive>
  return  TRUE;
811057c0:	00800044 	movi	r2,1
}
811057c4:	e037883a 	mov	sp,fp
811057c8:	dfc00117 	ldw	ra,4(sp)
811057cc:	df000017 	ldw	fp,0(sp)
811057d0:	dec00204 	addi	sp,sp,8
811057d4:	f800283a 	ret

811057d8 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
811057d8:	defffe04 	addi	sp,sp,-8
811057dc:	de00012e 	bgeu	sp,et,811057e4 <bDisableIsoDrivers+0xc>
811057e0:	003b68fa 	trap	3
811057e4:	dfc00115 	stw	ra,4(sp)
811057e8:	df000015 	stw	fp,0(sp)
811057ec:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
811057f0:	01400204 	movi	r5,8
811057f4:	0009883a 	mov	r4,zero
811057f8:	110594c0 	call	8110594c <bCtrlIoLvdsDrive>
  return  TRUE;
811057fc:	00800044 	movi	r2,1
}
81105800:	e037883a 	mov	sp,fp
81105804:	dfc00117 	ldw	ra,4(sp)
81105808:	df000017 	ldw	fp,0(sp)
8110580c:	dec00204 	addi	sp,sp,8
81105810:	f800283a 	ret

81105814 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
81105814:	defffe04 	addi	sp,sp,-8
81105818:	de00012e 	bgeu	sp,et,81105820 <bEnableLvdsBoard+0xc>
8110581c:	003b68fa 	trap	3
81105820:	dfc00115 	stw	ra,4(sp)
81105824:	df000015 	stw	fp,0(sp)
81105828:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110582c:	01400104 	movi	r5,4
81105830:	01000044 	movi	r4,1
81105834:	110594c0 	call	8110594c <bCtrlIoLvdsDrive>
  return  TRUE;
81105838:	00800044 	movi	r2,1
}
8110583c:	e037883a 	mov	sp,fp
81105840:	dfc00117 	ldw	ra,4(sp)
81105844:	df000017 	ldw	fp,0(sp)
81105848:	dec00204 	addi	sp,sp,8
8110584c:	f800283a 	ret

81105850 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
81105850:	defffe04 	addi	sp,sp,-8
81105854:	de00012e 	bgeu	sp,et,8110585c <bDisableLvdsBoard+0xc>
81105858:	003b68fa 	trap	3
8110585c:	dfc00115 	stw	ra,4(sp)
81105860:	df000015 	stw	fp,0(sp)
81105864:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
81105868:	01400104 	movi	r5,4
8110586c:	0009883a 	mov	r4,zero
81105870:	110594c0 	call	8110594c <bCtrlIoLvdsDrive>
  return  TRUE;
81105874:	00800044 	movi	r2,1
}
81105878:	e037883a 	mov	sp,fp
8110587c:	dfc00117 	ldw	ra,4(sp)
81105880:	df000017 	ldw	fp,0(sp)
81105884:	dec00204 	addi	sp,sp,8
81105888:	f800283a 	ret

8110588c <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110588c:	defffd04 	addi	sp,sp,-12
81105890:	de00012e 	bgeu	sp,et,81105898 <bSetPreEmphasys+0xc>
81105894:	003b68fa 	trap	3
81105898:	dfc00215 	stw	ra,8(sp)
8110589c:	df000115 	stw	fp,4(sp)
811058a0:	df000104 	addi	fp,sp,4
811058a4:	2005883a 	mov	r2,r4
811058a8:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
811058ac:	e0bfff03 	ldbu	r2,-4(fp)
811058b0:	10c00060 	cmpeqi	r3,r2,1
811058b4:	18000d1e 	bne	r3,zero,811058ec <bSetPreEmphasys+0x60>
811058b8:	10c00088 	cmpgei	r3,r2,2
811058bc:	1800021e 	bne	r3,zero,811058c8 <bSetPreEmphasys+0x3c>
811058c0:	10000626 	beq	r2,zero,811058dc <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
811058c4:	00001b06 	br	81105934 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
811058c8:	10c000a0 	cmpeqi	r3,r2,2
811058cc:	18000e1e 	bne	r3,zero,81105908 <bSetPreEmphasys+0x7c>
811058d0:	108000e0 	cmpeqi	r2,r2,3
811058d4:	1000131e 	bne	r2,zero,81105924 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
811058d8:	00001606 	br	81105934 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
811058dc:	014000c4 	movi	r5,3
811058e0:	0009883a 	mov	r4,zero
811058e4:	110594c0 	call	8110594c <bCtrlIoLvdsDrive>
      break;
811058e8:	00001206 	br	81105934 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
811058ec:	01400084 	movi	r5,2
811058f0:	0009883a 	mov	r4,zero
811058f4:	110594c0 	call	8110594c <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
811058f8:	01400044 	movi	r5,1
811058fc:	01000044 	movi	r4,1
81105900:	110594c0 	call	8110594c <bCtrlIoLvdsDrive>
      break;
81105904:	00000b06 	br	81105934 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
81105908:	01400044 	movi	r5,1
8110590c:	0009883a 	mov	r4,zero
81105910:	110594c0 	call	8110594c <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
81105914:	01400084 	movi	r5,2
81105918:	01000044 	movi	r4,1
8110591c:	110594c0 	call	8110594c <bCtrlIoLvdsDrive>
      break;
81105920:	00000406 	br	81105934 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
81105924:	014000c4 	movi	r5,3
81105928:	01000044 	movi	r4,1
8110592c:	110594c0 	call	8110594c <bCtrlIoLvdsDrive>
      break;
81105930:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
81105934:	00800044 	movi	r2,1
}
81105938:	e037883a 	mov	sp,fp
8110593c:	dfc00117 	ldw	ra,4(sp)
81105940:	df000017 	ldw	fp,0(sp)
81105944:	dec00204 	addi	sp,sp,8
81105948:	f800283a 	ret

8110594c <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/o´s a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110594c:	defffd04 	addi	sp,sp,-12
81105950:	de00012e 	bgeu	sp,et,81105958 <bCtrlIoLvdsDrive+0xc>
81105954:	003b68fa 	trap	3
81105958:	df000215 	stw	fp,8(sp)
8110595c:	df000204 	addi	fp,sp,8
81105960:	e13ffe15 	stw	r4,-8(fp)
81105964:	2805883a 	mov	r2,r5
81105968:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110596c:	e0bffe17 	ldw	r2,-8(fp)
81105970:	1000071e 	bne	r2,zero,81105990 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
81105974:	e0bfff03 	ldbu	r2,-4(fp)
81105978:	0084303a 	nor	r2,zero,r2
8110597c:	1007883a 	mov	r3,r2
81105980:	d0a00103 	ldbu	r2,-32764(gp)
81105984:	1884703a 	and	r2,r3,r2
81105988:	d0a00105 	stb	r2,-32764(gp)
8110598c:	00000406 	br	811059a0 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
81105990:	d0e00103 	ldbu	r3,-32764(gp)
81105994:	e0bfff03 	ldbu	r2,-4(fp)
81105998:	1884b03a 	or	r2,r3,r2
8110599c:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
811059a0:	d0a00103 	ldbu	r2,-32764(gp)
811059a4:	10c03fcc 	andi	r3,r2,255
811059a8:	00a00034 	movhi	r2,32768
811059ac:	10822804 	addi	r2,r2,2208
811059b0:	10c00035 	stwio	r3,0(r2)
  return TRUE;
811059b4:	00800044 	movi	r2,1
}
811059b8:	e037883a 	mov	sp,fp
811059bc:	df000017 	ldw	fp,0(sp)
811059c0:	dec00104 	addi	sp,sp,4
811059c4:	f800283a 	ret

811059c8 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
811059c8:	defffa04 	addi	sp,sp,-24
811059cc:	de00012e 	bgeu	sp,et,811059d4 <I2C_TestAdress+0xc>
811059d0:	003b68fa 	trap	3
811059d4:	dfc00515 	stw	ra,20(sp)
811059d8:	df000415 	stw	fp,16(sp)
811059dc:	df000404 	addi	fp,sp,16
811059e0:	e13ffd15 	stw	r4,-12(fp)
811059e4:	e17ffe15 	stw	r5,-8(fp)
811059e8:	3005883a 	mov	r2,r6
811059ec:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
811059f0:	00800044 	movi	r2,1
811059f4:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
811059f8:	e17ffe17 	ldw	r5,-8(fp)
811059fc:	e13ffd17 	ldw	r4,-12(fp)
81105a00:	1105d980 	call	81105d98 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105a04:	e0bfff03 	ldbu	r2,-4(fp)
81105a08:	10803fcc 	andi	r2,r2,255
81105a0c:	100d883a 	mov	r6,r2
81105a10:	e17ffe17 	ldw	r5,-8(fp)
81105a14:	e13ffd17 	ldw	r4,-12(fp)
81105a18:	1105eac0 	call	81105eac <i2c_write>
81105a1c:	1000011e 	bne	r2,zero,81105a24 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
81105a20:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81105a24:	e17ffe17 	ldw	r5,-8(fp)
81105a28:	e13ffd17 	ldw	r4,-12(fp)
81105a2c:	1105e2c0 	call	81105e2c <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81105a30:	0106d604 	movi	r4,7000
81105a34:	112c95c0 	call	8112c95c <usleep>
    
    return bSuccess;
81105a38:	e0bffc17 	ldw	r2,-16(fp)

}
81105a3c:	e037883a 	mov	sp,fp
81105a40:	dfc00117 	ldw	ra,4(sp)
81105a44:	df000017 	ldw	fp,0(sp)
81105a48:	dec00204 	addi	sp,sp,8
81105a4c:	f800283a 	ret

81105a50 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
81105a50:	defff804 	addi	sp,sp,-32
81105a54:	de00012e 	bgeu	sp,et,81105a5c <I2C_Write+0xc>
81105a58:	003b68fa 	trap	3
81105a5c:	dfc00715 	stw	ra,28(sp)
81105a60:	df000615 	stw	fp,24(sp)
81105a64:	df000604 	addi	fp,sp,24
81105a68:	e13ffb15 	stw	r4,-20(fp)
81105a6c:	e17ffc15 	stw	r5,-16(fp)
81105a70:	3009883a 	mov	r4,r6
81105a74:	3807883a 	mov	r3,r7
81105a78:	e0800217 	ldw	r2,8(fp)
81105a7c:	e13ffd05 	stb	r4,-12(fp)
81105a80:	e0fffe05 	stb	r3,-8(fp)
81105a84:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81105a88:	00800044 	movi	r2,1
81105a8c:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81105a90:	e17ffc17 	ldw	r5,-16(fp)
81105a94:	e13ffb17 	ldw	r4,-20(fp)
81105a98:	1105d980 	call	81105d98 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105a9c:	e0bffd03 	ldbu	r2,-12(fp)
81105aa0:	10803fcc 	andi	r2,r2,255
81105aa4:	100d883a 	mov	r6,r2
81105aa8:	e17ffc17 	ldw	r5,-16(fp)
81105aac:	e13ffb17 	ldw	r4,-20(fp)
81105ab0:	1105eac0 	call	81105eac <i2c_write>
81105ab4:	1000011e 	bne	r2,zero,81105abc <I2C_Write+0x6c>
        bSuccess = FALSE;
81105ab8:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81105abc:	e0bffa17 	ldw	r2,-24(fp)
81105ac0:	10000726 	beq	r2,zero,81105ae0 <I2C_Write+0x90>
81105ac4:	e0bffe03 	ldbu	r2,-8(fp)
81105ac8:	100d883a 	mov	r6,r2
81105acc:	e17ffc17 	ldw	r5,-16(fp)
81105ad0:	e13ffb17 	ldw	r4,-20(fp)
81105ad4:	1105eac0 	call	81105eac <i2c_write>
81105ad8:	1000011e 	bne	r2,zero,81105ae0 <I2C_Write+0x90>
        bSuccess = FALSE;
81105adc:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
81105ae0:	e0bffa17 	ldw	r2,-24(fp)
81105ae4:	10000726 	beq	r2,zero,81105b04 <I2C_Write+0xb4>
81105ae8:	e0bfff03 	ldbu	r2,-4(fp)
81105aec:	100d883a 	mov	r6,r2
81105af0:	e17ffc17 	ldw	r5,-16(fp)
81105af4:	e13ffb17 	ldw	r4,-20(fp)
81105af8:	1105eac0 	call	81105eac <i2c_write>
81105afc:	1000011e 	bne	r2,zero,81105b04 <I2C_Write+0xb4>
        bSuccess = FALSE;
81105b00:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81105b04:	e17ffc17 	ldw	r5,-16(fp)
81105b08:	e13ffb17 	ldw	r4,-20(fp)
81105b0c:	1105e2c0 	call	81105e2c <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81105b10:	0106d604 	movi	r4,7000
81105b14:	112c95c0 	call	8112c95c <usleep>
    
    return bSuccess;
81105b18:	e0bffa17 	ldw	r2,-24(fp)

}
81105b1c:	e037883a 	mov	sp,fp
81105b20:	dfc00117 	ldw	ra,4(sp)
81105b24:	df000017 	ldw	fp,0(sp)
81105b28:	dec00204 	addi	sp,sp,8
81105b2c:	f800283a 	ret

81105b30 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
81105b30:	defff904 	addi	sp,sp,-28
81105b34:	de00012e 	bgeu	sp,et,81105b3c <I2C_Read+0xc>
81105b38:	003b68fa 	trap	3
81105b3c:	dfc00615 	stw	ra,24(sp)
81105b40:	df000515 	stw	fp,20(sp)
81105b44:	df000504 	addi	fp,sp,20
81105b48:	e13ffc15 	stw	r4,-16(fp)
81105b4c:	e17ffd15 	stw	r5,-12(fp)
81105b50:	3007883a 	mov	r3,r6
81105b54:	3805883a 	mov	r2,r7
81105b58:	e0fffe05 	stb	r3,-8(fp)
81105b5c:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81105b60:	00800044 	movi	r2,1
81105b64:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81105b68:	e17ffd17 	ldw	r5,-12(fp)
81105b6c:	e13ffc17 	ldw	r4,-16(fp)
81105b70:	1105d980 	call	81105d98 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105b74:	e0bffe03 	ldbu	r2,-8(fp)
81105b78:	10803fcc 	andi	r2,r2,255
81105b7c:	100d883a 	mov	r6,r2
81105b80:	e17ffd17 	ldw	r5,-12(fp)
81105b84:	e13ffc17 	ldw	r4,-16(fp)
81105b88:	1105eac0 	call	81105eac <i2c_write>
81105b8c:	1000011e 	bne	r2,zero,81105b94 <I2C_Read+0x64>
        bSuccess = FALSE;
81105b90:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81105b94:	e0bffb17 	ldw	r2,-20(fp)
81105b98:	10000726 	beq	r2,zero,81105bb8 <I2C_Read+0x88>
81105b9c:	e0bfff03 	ldbu	r2,-4(fp)
81105ba0:	100d883a 	mov	r6,r2
81105ba4:	e17ffd17 	ldw	r5,-12(fp)
81105ba8:	e13ffc17 	ldw	r4,-16(fp)
81105bac:	1105eac0 	call	81105eac <i2c_write>
81105bb0:	1000011e 	bne	r2,zero,81105bb8 <I2C_Read+0x88>
        bSuccess = FALSE;
81105bb4:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
81105bb8:	e17ffd17 	ldw	r5,-12(fp)
81105bbc:	e13ffc17 	ldw	r4,-16(fp)
81105bc0:	1105d980 	call	81105d98 <i2c_start>
    DeviceAddr |= 1; // Read
81105bc4:	e0bffe03 	ldbu	r2,-8(fp)
81105bc8:	10800054 	ori	r2,r2,1
81105bcc:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81105bd0:	e0bffb17 	ldw	r2,-20(fp)
81105bd4:	10000826 	beq	r2,zero,81105bf8 <I2C_Read+0xc8>
81105bd8:	e0bffe03 	ldbu	r2,-8(fp)
81105bdc:	10803fcc 	andi	r2,r2,255
81105be0:	100d883a 	mov	r6,r2
81105be4:	e17ffd17 	ldw	r5,-12(fp)
81105be8:	e13ffc17 	ldw	r4,-16(fp)
81105bec:	1105eac0 	call	81105eac <i2c_write>
81105bf0:	1000011e 	bne	r2,zero,81105bf8 <I2C_Read+0xc8>
        bSuccess = FALSE;
81105bf4:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81105bf8:	e0bffb17 	ldw	r2,-20(fp)
81105bfc:	10000526 	beq	r2,zero,81105c14 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
81105c00:	000f883a 	mov	r7,zero
81105c04:	e1800217 	ldw	r6,8(fp)
81105c08:	e17ffd17 	ldw	r5,-12(fp)
81105c0c:	e13ffc17 	ldw	r4,-16(fp)
81105c10:	1105fe40 	call	81105fe4 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
81105c14:	e17ffd17 	ldw	r5,-12(fp)
81105c18:	e13ffc17 	ldw	r4,-16(fp)
81105c1c:	1105e2c0 	call	81105e2c <i2c_stop>
    
    return bSuccess;
81105c20:	e0bffb17 	ldw	r2,-20(fp)
}
81105c24:	e037883a 	mov	sp,fp
81105c28:	dfc00117 	ldw	ra,4(sp)
81105c2c:	df000017 	ldw	fp,0(sp)
81105c30:	dec00204 	addi	sp,sp,8
81105c34:	f800283a 	ret

81105c38 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
81105c38:	defff604 	addi	sp,sp,-40
81105c3c:	de00012e 	bgeu	sp,et,81105c44 <I2C_MultipleRead+0xc>
81105c40:	003b68fa 	trap	3
81105c44:	dfc00915 	stw	ra,36(sp)
81105c48:	df000815 	stw	fp,32(sp)
81105c4c:	df000804 	addi	fp,sp,32
81105c50:	e13ffb15 	stw	r4,-20(fp)
81105c54:	e17ffc15 	stw	r5,-16(fp)
81105c58:	3007883a 	mov	r3,r6
81105c5c:	e1fffe15 	stw	r7,-8(fp)
81105c60:	e0800217 	ldw	r2,8(fp)
81105c64:	e0fffd05 	stb	r3,-12(fp)
81105c68:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
81105c6c:	00800044 	movi	r2,1
81105c70:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
81105c74:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81105c78:	e17ffc17 	ldw	r5,-16(fp)
81105c7c:	e13ffb17 	ldw	r4,-20(fp)
81105c80:	1105d980 	call	81105d98 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105c84:	e0bffd03 	ldbu	r2,-12(fp)
81105c88:	10803fcc 	andi	r2,r2,255
81105c8c:	100d883a 	mov	r6,r2
81105c90:	e17ffc17 	ldw	r5,-16(fp)
81105c94:	e13ffb17 	ldw	r4,-20(fp)
81105c98:	1105eac0 	call	81105eac <i2c_write>
81105c9c:	1000011e 	bne	r2,zero,81105ca4 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
81105ca0:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81105ca4:	e0bff917 	ldw	r2,-28(fp)
81105ca8:	10000726 	beq	r2,zero,81105cc8 <I2C_MultipleRead+0x90>
81105cac:	e0bffa03 	ldbu	r2,-24(fp)
81105cb0:	100d883a 	mov	r6,r2
81105cb4:	e17ffc17 	ldw	r5,-16(fp)
81105cb8:	e13ffb17 	ldw	r4,-20(fp)
81105cbc:	1105eac0 	call	81105eac <i2c_write>
81105cc0:	1000011e 	bne	r2,zero,81105cc8 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
81105cc4:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
81105cc8:	e0bff917 	ldw	r2,-28(fp)
81105ccc:	10000326 	beq	r2,zero,81105cdc <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
81105cd0:	e17ffc17 	ldw	r5,-16(fp)
81105cd4:	e13ffb17 	ldw	r4,-20(fp)
81105cd8:	1105d980 	call	81105d98 <i2c_start>
    DeviceAddr |= 1; // Read
81105cdc:	e0bffd03 	ldbu	r2,-12(fp)
81105ce0:	10800054 	ori	r2,r2,1
81105ce4:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81105ce8:	e0bff917 	ldw	r2,-28(fp)
81105cec:	10000826 	beq	r2,zero,81105d10 <I2C_MultipleRead+0xd8>
81105cf0:	e0bffd03 	ldbu	r2,-12(fp)
81105cf4:	10803fcc 	andi	r2,r2,255
81105cf8:	100d883a 	mov	r6,r2
81105cfc:	e17ffc17 	ldw	r5,-16(fp)
81105d00:	e13ffb17 	ldw	r4,-20(fp)
81105d04:	1105eac0 	call	81105eac <i2c_write>
81105d08:	1000011e 	bne	r2,zero,81105d10 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
81105d0c:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81105d10:	e0bff917 	ldw	r2,-28(fp)
81105d14:	10001726 	beq	r2,zero,81105d74 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
81105d18:	e03ff815 	stw	zero,-32(fp)
81105d1c:	00001006 	br	81105d60 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
81105d20:	e0bff817 	ldw	r2,-32(fp)
81105d24:	e0fffe17 	ldw	r3,-8(fp)
81105d28:	1889883a 	add	r4,r3,r2
81105d2c:	e0bfff0b 	ldhu	r2,-4(fp)
81105d30:	10ffffc4 	addi	r3,r2,-1
81105d34:	e0bff817 	ldw	r2,-32(fp)
81105d38:	1884c03a 	cmpne	r2,r3,r2
81105d3c:	10803fcc 	andi	r2,r2,255
81105d40:	100f883a 	mov	r7,r2
81105d44:	200d883a 	mov	r6,r4
81105d48:	e17ffc17 	ldw	r5,-16(fp)
81105d4c:	e13ffb17 	ldw	r4,-20(fp)
81105d50:	1105fe40 	call	81105fe4 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
81105d54:	e0bff817 	ldw	r2,-32(fp)
81105d58:	10800044 	addi	r2,r2,1
81105d5c:	e0bff815 	stw	r2,-32(fp)
81105d60:	e0bfff0b 	ldhu	r2,-4(fp)
81105d64:	e0fff817 	ldw	r3,-32(fp)
81105d68:	1880020e 	bge	r3,r2,81105d74 <I2C_MultipleRead+0x13c>
81105d6c:	e0bff917 	ldw	r2,-28(fp)
81105d70:	103feb1e 	bne	r2,zero,81105d20 <__reset+0xfb0e5d20>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
81105d74:	e17ffc17 	ldw	r5,-16(fp)
81105d78:	e13ffb17 	ldw	r4,-20(fp)
81105d7c:	1105e2c0 	call	81105e2c <i2c_stop>
    
    return bSuccess;    
81105d80:	e0bff917 	ldw	r2,-28(fp)
    
}
81105d84:	e037883a 	mov	sp,fp
81105d88:	dfc00117 	ldw	ra,4(sp)
81105d8c:	df000017 	ldw	fp,0(sp)
81105d90:	dec00204 	addi	sp,sp,8
81105d94:	f800283a 	ret

81105d98 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
81105d98:	defffc04 	addi	sp,sp,-16
81105d9c:	de00012e 	bgeu	sp,et,81105da4 <i2c_start+0xc>
81105da0:	003b68fa 	trap	3
81105da4:	dfc00315 	stw	ra,12(sp)
81105da8:	df000215 	stw	fp,8(sp)
81105dac:	df000204 	addi	fp,sp,8
81105db0:	e13ffe15 	stw	r4,-8(fp)
81105db4:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
81105db8:	e0bfff17 	ldw	r2,-4(fp)
81105dbc:	10800104 	addi	r2,r2,4
81105dc0:	1007883a 	mov	r3,r2
81105dc4:	00800044 	movi	r2,1
81105dc8:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
81105dcc:	e0bfff17 	ldw	r2,-4(fp)
81105dd0:	00c00044 	movi	r3,1
81105dd4:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
81105dd8:	e0bffe17 	ldw	r2,-8(fp)
81105ddc:	00c00044 	movi	r3,1
81105de0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81105de4:	01000044 	movi	r4,1
81105de8:	112c95c0 	call	8112c95c <usleep>
     
    SDA_LOW(data_base); // data low
81105dec:	e0bfff17 	ldw	r2,-4(fp)
81105df0:	0007883a 	mov	r3,zero
81105df4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
81105df8:	01000044 	movi	r4,1
81105dfc:	112c95c0 	call	8112c95c <usleep>
    SCL_LOW(clk_base); // clock low
81105e00:	e0bffe17 	ldw	r2,-8(fp)
81105e04:	0007883a 	mov	r3,zero
81105e08:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81105e0c:	01000044 	movi	r4,1
81105e10:	112c95c0 	call	8112c95c <usleep>
}
81105e14:	0001883a 	nop
81105e18:	e037883a 	mov	sp,fp
81105e1c:	dfc00117 	ldw	ra,4(sp)
81105e20:	df000017 	ldw	fp,0(sp)
81105e24:	dec00204 	addi	sp,sp,8
81105e28:	f800283a 	ret

81105e2c <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
81105e2c:	defffc04 	addi	sp,sp,-16
81105e30:	de00012e 	bgeu	sp,et,81105e38 <i2c_stop+0xc>
81105e34:	003b68fa 	trap	3
81105e38:	dfc00315 	stw	ra,12(sp)
81105e3c:	df000215 	stw	fp,8(sp)
81105e40:	df000204 	addi	fp,sp,8
81105e44:	e13ffe15 	stw	r4,-8(fp)
81105e48:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
81105e4c:	e0bfff17 	ldw	r2,-4(fp)
81105e50:	10800104 	addi	r2,r2,4
81105e54:	1007883a 	mov	r3,r2
81105e58:	00800044 	movi	r2,1
81105e5c:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
81105e60:	e0bfff17 	ldw	r2,-4(fp)
81105e64:	0007883a 	mov	r3,zero
81105e68:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
81105e6c:	e0bffe17 	ldw	r2,-8(fp)
81105e70:	00c00044 	movi	r3,1
81105e74:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
81105e78:	01000044 	movi	r4,1
81105e7c:	112c95c0 	call	8112c95c <usleep>
    SDA_HIGH(data_base); // data high
81105e80:	e0bfff17 	ldw	r2,-4(fp)
81105e84:	00c00044 	movi	r3,1
81105e88:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
81105e8c:	01000044 	movi	r4,1
81105e90:	112c95c0 	call	8112c95c <usleep>
    

    
}
81105e94:	0001883a 	nop
81105e98:	e037883a 	mov	sp,fp
81105e9c:	dfc00117 	ldw	ra,4(sp)
81105ea0:	df000017 	ldw	fp,0(sp)
81105ea4:	dec00204 	addi	sp,sp,8
81105ea8:	f800283a 	ret

81105eac <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
81105eac:	defff804 	addi	sp,sp,-32
81105eb0:	de00012e 	bgeu	sp,et,81105eb8 <i2c_write+0xc>
81105eb4:	003b68fa 	trap	3
81105eb8:	dfc00715 	stw	ra,28(sp)
81105ebc:	df000615 	stw	fp,24(sp)
81105ec0:	df000604 	addi	fp,sp,24
81105ec4:	e13ffd15 	stw	r4,-12(fp)
81105ec8:	e17ffe15 	stw	r5,-8(fp)
81105ecc:	3005883a 	mov	r2,r6
81105ed0:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
81105ed4:	00bfe004 	movi	r2,-128
81105ed8:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
81105edc:	e0bffe17 	ldw	r2,-8(fp)
81105ee0:	10800104 	addi	r2,r2,4
81105ee4:	1007883a 	mov	r3,r2
81105ee8:	00800044 	movi	r2,1
81105eec:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
81105ef0:	e03ffb15 	stw	zero,-20(fp)
81105ef4:	00001f06 	br	81105f74 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
81105ef8:	e0bffd17 	ldw	r2,-12(fp)
81105efc:	0007883a 	mov	r3,zero
81105f00:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
81105f04:	e0ffff03 	ldbu	r3,-4(fp)
81105f08:	e0bffa03 	ldbu	r2,-24(fp)
81105f0c:	1884703a 	and	r2,r3,r2
81105f10:	10803fcc 	andi	r2,r2,255
81105f14:	10000426 	beq	r2,zero,81105f28 <i2c_write+0x7c>
            SDA_HIGH(data_base);
81105f18:	e0bffe17 	ldw	r2,-8(fp)
81105f1c:	00c00044 	movi	r3,1
81105f20:	10c00035 	stwio	r3,0(r2)
81105f24:	00000306 	br	81105f34 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
81105f28:	e0bffe17 	ldw	r2,-8(fp)
81105f2c:	0007883a 	mov	r3,zero
81105f30:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
81105f34:	e0bffa03 	ldbu	r2,-24(fp)
81105f38:	1004d07a 	srli	r2,r2,1
81105f3c:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
81105f40:	e0bffd17 	ldw	r2,-12(fp)
81105f44:	00c00044 	movi	r3,1
81105f48:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81105f4c:	01000044 	movi	r4,1
81105f50:	112c95c0 	call	8112c95c <usleep>
        SCL_LOW(clk_base);
81105f54:	e0bffd17 	ldw	r2,-12(fp)
81105f58:	0007883a 	mov	r3,zero
81105f5c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81105f60:	01000044 	movi	r4,1
81105f64:	112c95c0 	call	8112c95c <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
81105f68:	e0bffb17 	ldw	r2,-20(fp)
81105f6c:	10800044 	addi	r2,r2,1
81105f70:	e0bffb15 	stw	r2,-20(fp)
81105f74:	e0bffb17 	ldw	r2,-20(fp)
81105f78:	10800210 	cmplti	r2,r2,8
81105f7c:	103fde1e 	bne	r2,zero,81105ef8 <__reset+0xfb0e5ef8>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
81105f80:	e0bffe17 	ldw	r2,-8(fp)
81105f84:	10800104 	addi	r2,r2,4
81105f88:	0007883a 	mov	r3,zero
81105f8c:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
81105f90:	e0bffd17 	ldw	r2,-12(fp)
81105f94:	00c00044 	movi	r3,1
81105f98:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
81105f9c:	01000044 	movi	r4,1
81105fa0:	112c95c0 	call	8112c95c <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
81105fa4:	e0bffe17 	ldw	r2,-8(fp)
81105fa8:	10800037 	ldwio	r2,0(r2)
81105fac:	1005003a 	cmpeq	r2,r2,zero
81105fb0:	10803fcc 	andi	r2,r2,255
81105fb4:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
81105fb8:	e0bffd17 	ldw	r2,-12(fp)
81105fbc:	0007883a 	mov	r3,zero
81105fc0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81105fc4:	01000044 	movi	r4,1
81105fc8:	112c95c0 	call	8112c95c <usleep>
    return bAck;
81105fcc:	e0bffc17 	ldw	r2,-16(fp)
}    
81105fd0:	e037883a 	mov	sp,fp
81105fd4:	dfc00117 	ldw	ra,4(sp)
81105fd8:	df000017 	ldw	fp,0(sp)
81105fdc:	dec00204 	addi	sp,sp,8
81105fe0:	f800283a 	ret

81105fe4 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
81105fe4:	defff804 	addi	sp,sp,-32
81105fe8:	de00012e 	bgeu	sp,et,81105ff0 <i2c_read+0xc>
81105fec:	003b68fa 	trap	3
81105ff0:	dfc00715 	stw	ra,28(sp)
81105ff4:	df000615 	stw	fp,24(sp)
81105ff8:	df000604 	addi	fp,sp,24
81105ffc:	e13ffc15 	stw	r4,-16(fp)
81106000:	e17ffd15 	stw	r5,-12(fp)
81106004:	e1bffe15 	stw	r6,-8(fp)
81106008:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110600c:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
81106010:	e0bffd17 	ldw	r2,-12(fp)
81106014:	10800104 	addi	r2,r2,4
81106018:	0007883a 	mov	r3,zero
8110601c:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
81106020:	e0bffc17 	ldw	r2,-16(fp)
81106024:	0007883a 	mov	r3,zero
81106028:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110602c:	01000044 	movi	r4,1
81106030:	112c95c0 	call	8112c95c <usleep>

    for(i=0;i<8;i++){
81106034:	e03ffb15 	stw	zero,-20(fp)
81106038:	00001606 	br	81106094 <i2c_read+0xb0>
        Data <<= 1;
8110603c:	e0bffa03 	ldbu	r2,-24(fp)
81106040:	1085883a 	add	r2,r2,r2
81106044:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
81106048:	e0bffc17 	ldw	r2,-16(fp)
8110604c:	00c00044 	movi	r3,1
81106050:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81106054:	01000044 	movi	r4,1
81106058:	112c95c0 	call	8112c95c <usleep>
        if (SDA_READ(data_base))  // read data   
8110605c:	e0bffd17 	ldw	r2,-12(fp)
81106060:	10800037 	ldwio	r2,0(r2)
81106064:	10000326 	beq	r2,zero,81106074 <i2c_read+0x90>
            Data |= 0x01;
81106068:	e0bffa03 	ldbu	r2,-24(fp)
8110606c:	10800054 	ori	r2,r2,1
81106070:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
81106074:	e0bffc17 	ldw	r2,-16(fp)
81106078:	0007883a 	mov	r3,zero
8110607c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81106080:	01000044 	movi	r4,1
81106084:	112c95c0 	call	8112c95c <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
81106088:	e0bffb17 	ldw	r2,-20(fp)
8110608c:	10800044 	addi	r2,r2,1
81106090:	e0bffb15 	stw	r2,-20(fp)
81106094:	e0bffb17 	ldw	r2,-20(fp)
81106098:	10800210 	cmplti	r2,r2,8
8110609c:	103fe71e 	bne	r2,zero,8110603c <__reset+0xfb0e603c>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
811060a0:	e0bffc17 	ldw	r2,-16(fp)
811060a4:	0007883a 	mov	r3,zero
811060a8:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
811060ac:	e0bffd17 	ldw	r2,-12(fp)
811060b0:	10800104 	addi	r2,r2,4
811060b4:	1007883a 	mov	r3,r2
811060b8:	00800044 	movi	r2,1
811060bc:	18800035 	stwio	r2,0(r3)
    if (bAck)
811060c0:	e0bfff17 	ldw	r2,-4(fp)
811060c4:	10000426 	beq	r2,zero,811060d8 <i2c_read+0xf4>
        SDA_LOW(data_base);
811060c8:	e0bffd17 	ldw	r2,-12(fp)
811060cc:	0007883a 	mov	r3,zero
811060d0:	10c00035 	stwio	r3,0(r2)
811060d4:	00000306 	br	811060e4 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
811060d8:	e0bffd17 	ldw	r2,-12(fp)
811060dc:	00c00044 	movi	r3,1
811060e0:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
811060e4:	e0bffc17 	ldw	r2,-16(fp)
811060e8:	00c00044 	movi	r3,1
811060ec:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
811060f0:	01000044 	movi	r4,1
811060f4:	112c95c0 	call	8112c95c <usleep>
    SCL_LOW(clk_base); // clock low
811060f8:	e0bffc17 	ldw	r2,-16(fp)
811060fc:	0007883a 	mov	r3,zero
81106100:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81106104:	01000044 	movi	r4,1
81106108:	112c95c0 	call	8112c95c <usleep>
    SDA_LOW(data_base);  // data low
8110610c:	e0bffd17 	ldw	r2,-12(fp)
81106110:	0007883a 	mov	r3,zero
81106114:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
81106118:	01000044 	movi	r4,1
8110611c:	112c95c0 	call	8112c95c <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
81106120:	e0bffe17 	ldw	r2,-8(fp)
81106124:	e0fffa03 	ldbu	r3,-24(fp)
81106128:	10c00005 	stb	r3,0(r2)
}
8110612c:	0001883a 	nop
81106130:	e037883a 	mov	sp,fp
81106134:	dfc00117 	ldw	ra,4(sp)
81106138:	df000017 	ldw	fp,0(sp)
8110613c:	dec00204 	addi	sp,sp,8
81106140:	f800283a 	ret

81106144 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
81106144:	defffd04 	addi	sp,sp,-12
81106148:	de00012e 	bgeu	sp,et,81106150 <bSetBoardLeds+0xc>
8110614c:	003b68fa 	trap	3
81106150:	df000215 	stw	fp,8(sp)
81106154:	df000204 	addi	fp,sp,8
81106158:	e13ffe15 	stw	r4,-8(fp)
8110615c:	2805883a 	mov	r2,r5
81106160:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
81106164:	e0bffe17 	ldw	r2,-8(fp)
81106168:	10800058 	cmpnei	r2,r2,1
8110616c:	1000071e 	bne	r2,zero,8110618c <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
81106170:	e0bfff03 	ldbu	r2,-4(fp)
81106174:	0084303a 	nor	r2,zero,r2
81106178:	1007883a 	mov	r3,r2
8110617c:	d0a04603 	ldbu	r2,-32488(gp)
81106180:	1884703a 	and	r2,r3,r2
81106184:	d0a04605 	stb	r2,-32488(gp)
81106188:	00000406 	br	8110619c <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110618c:	d0e04603 	ldbu	r3,-32488(gp)
81106190:	e0bfff03 	ldbu	r2,-4(fp)
81106194:	1884b03a 	or	r2,r3,r2
81106198:	d0a04605 	stb	r2,-32488(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110619c:	d0a04603 	ldbu	r2,-32488(gp)
811061a0:	10c03fcc 	andi	r3,r2,255
811061a4:	00a00034 	movhi	r2,32768
811061a8:	10827404 	addi	r2,r2,2512
811061ac:	10c00035 	stwio	r3,0(r2)

  return TRUE;
811061b0:	00800044 	movi	r2,1
}
811061b4:	e037883a 	mov	sp,fp
811061b8:	df000017 	ldw	fp,0(sp)
811061bc:	dec00104 	addi	sp,sp,4
811061c0:	f800283a 	ret

811061c4 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
811061c4:	defffd04 	addi	sp,sp,-12
811061c8:	de00012e 	bgeu	sp,et,811061d0 <bSetPainelLeds+0xc>
811061cc:	003b68fa 	trap	3
811061d0:	df000215 	stw	fp,8(sp)
811061d4:	df000204 	addi	fp,sp,8
811061d8:	e13ffe15 	stw	r4,-8(fp)
811061dc:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
811061e0:	e0bffe17 	ldw	r2,-8(fp)
811061e4:	10800058 	cmpnei	r2,r2,1
811061e8:	1000051e 	bne	r2,zero,81106200 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
811061ec:	d0e00217 	ldw	r3,-32760(gp)
811061f0:	e0bfff17 	ldw	r2,-4(fp)
811061f4:	1884b03a 	or	r2,r3,r2
811061f8:	d0a00215 	stw	r2,-32760(gp)
811061fc:	00000506 	br	81106214 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
81106200:	e0bfff17 	ldw	r2,-4(fp)
81106204:	0086303a 	nor	r3,zero,r2
81106208:	d0a00217 	ldw	r2,-32760(gp)
8110620c:	1884703a 	and	r2,r3,r2
81106210:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
81106214:	d0a00217 	ldw	r2,-32760(gp)
81106218:	1007883a 	mov	r3,r2
8110621c:	00a00034 	movhi	r2,32768
81106220:	10824004 	addi	r2,r2,2304
81106224:	10c00035 	stwio	r3,0(r2)

  return TRUE;
81106228:	00800044 	movi	r2,1
}
8110622c:	e037883a 	mov	sp,fp
81106230:	df000017 	ldw	fp,0(sp)
81106234:	dec00104 	addi	sp,sp,4
81106238:	f800283a 	ret

8110623c <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110623c:	defffc04 	addi	sp,sp,-16
81106240:	de00012e 	bgeu	sp,et,81106248 <msgdma_write_extended_descriptor+0xc>
81106244:	003b68fa 	trap	3
81106248:	df000315 	stw	fp,12(sp)
8110624c:	df000304 	addi	fp,sp,12
81106250:	e13ffd15 	stw	r4,-12(fp)
81106254:	e17ffe15 	stw	r5,-8(fp)
81106258:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110625c:	e0bffd17 	ldw	r2,-12(fp)
81106260:	10800037 	ldwio	r2,0(r2)
81106264:	1080010c 	andi	r2,r2,4
81106268:	10000226 	beq	r2,zero,81106274 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110626c:	00bff904 	movi	r2,-28
81106270:	00003d06 	br	81106368 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
81106274:	e0bfff17 	ldw	r2,-4(fp)
81106278:	10800017 	ldw	r2,0(r2)
8110627c:	1007883a 	mov	r3,r2
81106280:	e0bffe17 	ldw	r2,-8(fp)
81106284:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
81106288:	e0bffe17 	ldw	r2,-8(fp)
8110628c:	10800104 	addi	r2,r2,4
81106290:	e0ffff17 	ldw	r3,-4(fp)
81106294:	18c00117 	ldw	r3,4(r3)
81106298:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110629c:	e0bffe17 	ldw	r2,-8(fp)
811062a0:	10800204 	addi	r2,r2,8
811062a4:	e0ffff17 	ldw	r3,-4(fp)
811062a8:	18c00217 	ldw	r3,8(r3)
811062ac:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
811062b0:	e0bffe17 	ldw	r2,-8(fp)
811062b4:	10800304 	addi	r2,r2,12
811062b8:	e0ffff17 	ldw	r3,-4(fp)
811062bc:	18c0030b 	ldhu	r3,12(r3)
811062c0:	18ffffcc 	andi	r3,r3,65535
811062c4:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
811062c8:	e0bffe17 	ldw	r2,-8(fp)
811062cc:	10800384 	addi	r2,r2,14
811062d0:	e0ffff17 	ldw	r3,-4(fp)
811062d4:	18c00383 	ldbu	r3,14(r3)
811062d8:	18c03fcc 	andi	r3,r3,255
811062dc:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
811062e0:	e0bffe17 	ldw	r2,-8(fp)
811062e4:	108003c4 	addi	r2,r2,15
811062e8:	e0ffff17 	ldw	r3,-4(fp)
811062ec:	18c003c3 	ldbu	r3,15(r3)
811062f0:	18c03fcc 	andi	r3,r3,255
811062f4:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
811062f8:	e0bffe17 	ldw	r2,-8(fp)
811062fc:	10800404 	addi	r2,r2,16
81106300:	e0ffff17 	ldw	r3,-4(fp)
81106304:	18c0040b 	ldhu	r3,16(r3)
81106308:	18ffffcc 	andi	r3,r3,65535
8110630c:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
81106310:	e0bffe17 	ldw	r2,-8(fp)
81106314:	10800484 	addi	r2,r2,18
81106318:	e0ffff17 	ldw	r3,-4(fp)
8110631c:	18c0048b 	ldhu	r3,18(r3)
81106320:	18ffffcc 	andi	r3,r3,65535
81106324:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
81106328:	e0bffe17 	ldw	r2,-8(fp)
8110632c:	10800504 	addi	r2,r2,20
81106330:	e0ffff17 	ldw	r3,-4(fp)
81106334:	18c00517 	ldw	r3,20(r3)
81106338:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110633c:	e0bffe17 	ldw	r2,-8(fp)
81106340:	10800604 	addi	r2,r2,24
81106344:	e0ffff17 	ldw	r3,-4(fp)
81106348:	18c00617 	ldw	r3,24(r3)
8110634c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
81106350:	e0bffe17 	ldw	r2,-8(fp)
81106354:	10800704 	addi	r2,r2,28
81106358:	e0ffff17 	ldw	r3,-4(fp)
8110635c:	18c00717 	ldw	r3,28(r3)
81106360:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
81106364:	0005883a 	mov	r2,zero
}
81106368:	e037883a 	mov	sp,fp
8110636c:	df000017 	ldw	fp,0(sp)
81106370:	dec00104 	addi	sp,sp,4
81106374:	f800283a 	ret

81106378 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
81106378:	defff604 	addi	sp,sp,-40
8110637c:	de00012e 	bgeu	sp,et,81106384 <msgdma_construct_extended_descriptor+0xc>
81106380:	003b68fa 	trap	3
81106384:	df000915 	stw	fp,36(sp)
81106388:	df000904 	addi	fp,sp,36
8110638c:	e13ff715 	stw	r4,-36(fp)
81106390:	e17ff815 	stw	r5,-32(fp)
81106394:	e1bff915 	stw	r6,-28(fp)
81106398:	e1fffa15 	stw	r7,-24(fp)
8110639c:	e1800517 	ldw	r6,20(fp)
811063a0:	e1400617 	ldw	r5,24(fp)
811063a4:	e1000717 	ldw	r4,28(fp)
811063a8:	e0c00817 	ldw	r3,32(fp)
811063ac:	e0800917 	ldw	r2,36(fp)
811063b0:	e1bffb0d 	sth	r6,-20(fp)
811063b4:	e17ffc05 	stb	r5,-16(fp)
811063b8:	e13ffd05 	stb	r4,-12(fp)
811063bc:	e0fffe0d 	sth	r3,-8(fp)
811063c0:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
811063c4:	e0bff717 	ldw	r2,-36(fp)
811063c8:	10c01217 	ldw	r3,72(r2)
811063cc:	e0800117 	ldw	r2,4(fp)
811063d0:	18801936 	bltu	r3,r2,81106438 <msgdma_construct_extended_descriptor+0xc0>
811063d4:	e13ff717 	ldw	r4,-36(fp)
811063d8:	20801317 	ldw	r2,76(r4)
811063dc:	20c01417 	ldw	r3,80(r4)
811063e0:	e13ffe0b 	ldhu	r4,-8(fp)
811063e4:	213fffcc 	andi	r4,r4,65535
811063e8:	2015883a 	mov	r10,r4
811063ec:	0017883a 	mov	r11,zero
811063f0:	1ac01136 	bltu	r3,r11,81106438 <msgdma_construct_extended_descriptor+0xc0>
811063f4:	58c0011e 	bne	r11,r3,811063fc <msgdma_construct_extended_descriptor+0x84>
811063f8:	12800f36 	bltu	r2,r10,81106438 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
811063fc:	e13ff717 	ldw	r4,-36(fp)
81106400:	20801317 	ldw	r2,76(r4)
81106404:	20c01417 	ldw	r3,80(r4)
81106408:	e13fff0b 	ldhu	r4,-4(fp)
8110640c:	213fffcc 	andi	r4,r4,65535
81106410:	2011883a 	mov	r8,r4
81106414:	0013883a 	mov	r9,zero
81106418:	1a400736 	bltu	r3,r9,81106438 <msgdma_construct_extended_descriptor+0xc0>
8110641c:	48c0011e 	bne	r9,r3,81106424 <msgdma_construct_extended_descriptor+0xac>
81106420:	12000536 	bltu	r2,r8,81106438 <msgdma_construct_extended_descriptor+0xc0>
81106424:	e0bff717 	ldw	r2,-36(fp)
81106428:	10801703 	ldbu	r2,92(r2)
8110642c:	10803fcc 	andi	r2,r2,255
81106430:	10800060 	cmpeqi	r2,r2,1
81106434:	1000021e 	bne	r2,zero,81106440 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
81106438:	00bffa84 	movi	r2,-22
8110643c:	00002306 	br	811064cc <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
81106440:	e0bff817 	ldw	r2,-32(fp)
81106444:	e0fff917 	ldw	r3,-28(fp)
81106448:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110644c:	e0bff817 	ldw	r2,-32(fp)
81106450:	e0fffa17 	ldw	r3,-24(fp)
81106454:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
81106458:	e0bff817 	ldw	r2,-32(fp)
8110645c:	e0c00117 	ldw	r3,4(fp)
81106460:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
81106464:	e0bff817 	ldw	r2,-32(fp)
81106468:	e0fffb0b 	ldhu	r3,-20(fp)
8110646c:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
81106470:	e0bff817 	ldw	r2,-32(fp)
81106474:	e0fffc03 	ldbu	r3,-16(fp)
81106478:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110647c:	e0bff817 	ldw	r2,-32(fp)
81106480:	e0fffd03 	ldbu	r3,-12(fp)
81106484:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
81106488:	e0bff817 	ldw	r2,-32(fp)
8110648c:	e0fffe0b 	ldhu	r3,-8(fp)
81106490:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
81106494:	e0bff817 	ldw	r2,-32(fp)
81106498:	e0ffff0b 	ldhu	r3,-4(fp)
8110649c:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
811064a0:	e0bff817 	ldw	r2,-32(fp)
811064a4:	e0c00317 	ldw	r3,12(fp)
811064a8:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
811064ac:	e0bff817 	ldw	r2,-32(fp)
811064b0:	e0c00417 	ldw	r3,16(fp)
811064b4:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811064b8:	e0800217 	ldw	r2,8(fp)
811064bc:	10e00034 	orhi	r3,r2,32768
811064c0:	e0bff817 	ldw	r2,-32(fp)
811064c4:	10c00715 	stw	r3,28(r2)

	return 0;
811064c8:	0005883a 	mov	r2,zero

}
811064cc:	e037883a 	mov	sp,fp
811064d0:	df000017 	ldw	fp,0(sp)
811064d4:	dec00104 	addi	sp,sp,4
811064d8:	f800283a 	ret

811064dc <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
811064dc:	deffee04 	addi	sp,sp,-72
811064e0:	de00012e 	bgeu	sp,et,811064e8 <msgdma_descriptor_async_transfer+0xc>
811064e4:	003b68fa 	trap	3
811064e8:	dfc01115 	stw	ra,68(sp)
811064ec:	df001015 	stw	fp,64(sp)
811064f0:	df001004 	addi	fp,sp,64
811064f4:	e13ffd15 	stw	r4,-12(fp)
811064f8:	e17ffe15 	stw	r5,-8(fp)
811064fc:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
81106500:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
81106504:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
81106508:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110650c:	e0bffd17 	ldw	r2,-12(fp)
81106510:	10800317 	ldw	r2,12(r2)
81106514:	10800204 	addi	r2,r2,8
81106518:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110651c:	10bfffcc 	andi	r2,r2,65535
81106520:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81106524:	e0bffd17 	ldw	r2,-12(fp)
81106528:	10800317 	ldw	r2,12(r2)
8110652c:	10800204 	addi	r2,r2,8
81106530:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
81106534:	1004d43a 	srli	r2,r2,16
81106538:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110653c:	e0bffd17 	ldw	r2,-12(fp)
81106540:	10800917 	ldw	r2,36(r2)
81106544:	e0fff417 	ldw	r3,-48(fp)
81106548:	1880042e 	bgeu	r3,r2,8110655c <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110654c:	e0bffd17 	ldw	r2,-12(fp)
81106550:	10800917 	ldw	r2,36(r2)
81106554:	e0fff317 	ldw	r3,-52(fp)
81106558:	18800236 	bltu	r3,r2,81106564 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110655c:	00bff904 	movi	r2,-28
81106560:	00009f06 	br	811067e0 <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
81106564:	e0bffd17 	ldw	r2,-12(fp)
81106568:	10801817 	ldw	r2,96(r2)
8110656c:	e0bff615 	stw	r2,-40(fp)
81106570:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81106574:	e0bffc0b 	ldhu	r2,-16(fp)
81106578:	e0fffc84 	addi	r3,fp,-14
8110657c:	180d883a 	mov	r6,r3
81106580:	100b883a 	mov	r5,r2
81106584:	e13ff617 	ldw	r4,-40(fp)
81106588:	11337600 	call	81133760 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110658c:	00800804 	movi	r2,32
81106590:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106594:	0005303a 	rdctl	r2,status
81106598:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110659c:	e0fff717 	ldw	r3,-36(fp)
811065a0:	00bfff84 	movi	r2,-2
811065a4:	1884703a 	and	r2,r3,r2
811065a8:	1001703a 	wrctl	status,r2
  
  return context;
811065ac:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
811065b0:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811065b4:	e0bffd17 	ldw	r2,-12(fp)
811065b8:	10800317 	ldw	r2,12(r2)
811065bc:	10800104 	addi	r2,r2,4
811065c0:	e0fff117 	ldw	r3,-60(fp)
811065c4:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
811065c8:	e0bffd17 	ldw	r2,-12(fp)
811065cc:	10800317 	ldw	r2,12(r2)
811065d0:	e0fffd17 	ldw	r3,-12(fp)
811065d4:	18c00317 	ldw	r3,12(r3)
811065d8:	18c00037 	ldwio	r3,0(r3)
811065dc:	10c00035 	stwio	r3,0(r2)
811065e0:	e0bff217 	ldw	r2,-56(fp)
811065e4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811065e8:	e0bffb17 	ldw	r2,-20(fp)
811065ec:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
811065f0:	e0bffe17 	ldw	r2,-8(fp)
811065f4:	10001026 	beq	r2,zero,81106638 <msgdma_descriptor_async_transfer+0x15c>
811065f8:	e0bfff17 	ldw	r2,-4(fp)
811065fc:	10000e1e 	bne	r2,zero,81106638 <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
81106600:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
81106604:	d0a05417 	ldw	r2,-32432(gp)
81106608:	100f883a 	mov	r7,r2
8110660c:	01800784 	movi	r6,30
81106610:	01400044 	movi	r5,1
81106614:	01204534 	movhi	r4,33044
81106618:	2103ba04 	addi	r4,r4,3816
8110661c:	1115d200 	call	81115d20 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81106620:	e0bffd17 	ldw	r2,-12(fp)
81106624:	10801817 	ldw	r2,96(r2)
81106628:	1009883a 	mov	r4,r2
8110662c:	1133ae80 	call	81133ae8 <OSSemPost>

		return -ETIME;
81106630:	00bff084 	movi	r2,-62
81106634:	00006a06 	br	811067e0 <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
81106638:	e0bffe17 	ldw	r2,-8(fp)
8110663c:	1000231e 	bne	r2,zero,811066cc <msgdma_descriptor_async_transfer+0x1f0>
81106640:	e0bfff17 	ldw	r2,-4(fp)
81106644:	10002126 	beq	r2,zero,811066cc <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
81106648:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110664c:	00001506 	br	811066a4 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
81106650:	01000044 	movi	r4,1
81106654:	112aee80 	call	8112aee8 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81106658:	e0bff00b 	ldhu	r2,-64(fp)
8110665c:	1084e230 	cmpltui	r2,r2,5000
81106660:	10000d1e 	bne	r2,zero,81106698 <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
81106664:	d0a05417 	ldw	r2,-32432(gp)
81106668:	100f883a 	mov	r7,r2
8110666c:	01801544 	movi	r6,85
81106670:	01400044 	movi	r5,1
81106674:	01204534 	movhi	r4,33044
81106678:	2103c204 	addi	r4,r4,3848
8110667c:	1115d200 	call	81115d20 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
81106680:	e0bffd17 	ldw	r2,-12(fp)
81106684:	10801817 	ldw	r2,96(r2)
81106688:	1009883a 	mov	r4,r2
8110668c:	1133ae80 	call	81133ae8 <OSSemPost>

				return -ETIME;
81106690:	00bff084 	movi	r2,-62
81106694:	00005206 	br	811067e0 <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
81106698:	e0bff00b 	ldhu	r2,-64(fp)
8110669c:	10800044 	addi	r2,r2,1
811066a0:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
811066a4:	e0bffd17 	ldw	r2,-12(fp)
811066a8:	10c00317 	ldw	r3,12(r2)
811066ac:	e0bffd17 	ldw	r2,-12(fp)
811066b0:	10800417 	ldw	r2,16(r2)
811066b4:	e1bfff17 	ldw	r6,-4(fp)
811066b8:	100b883a 	mov	r5,r2
811066bc:	1809883a 	mov	r4,r3
811066c0:	110623c0 	call	8110623c <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
811066c4:	103fe21e 	bne	r2,zero,81106650 <__reset+0xfb0e6650>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
811066c8:	00000606 	br	811066e4 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
811066cc:	e0bffd17 	ldw	r2,-12(fp)
811066d0:	10801817 	ldw	r2,96(r2)
811066d4:	1009883a 	mov	r4,r2
811066d8:	1133ae80 	call	81133ae8 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
811066dc:	00bfffc4 	movi	r2,-1
811066e0:	00003f06 	br	811067e0 <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
811066e4:	e0bffd17 	ldw	r2,-12(fp)
811066e8:	10800b17 	ldw	r2,44(r2)
811066ec:	10001c26 	beq	r2,zero,81106760 <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
811066f0:	e0bffd17 	ldw	r2,-12(fp)
811066f4:	10c00d17 	ldw	r3,52(r2)
811066f8:	e0bff117 	ldw	r2,-60(fp)
811066fc:	1884b03a 	or	r2,r3,r2
81106700:	10800514 	ori	r2,r2,20
81106704:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81106708:	e0fff117 	ldw	r3,-60(fp)
8110670c:	00bff7c4 	movi	r2,-33
81106710:	1884703a 	and	r2,r3,r2
81106714:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106718:	0005303a 	rdctl	r2,status
8110671c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81106720:	e0fff917 	ldw	r3,-28(fp)
81106724:	00bfff84 	movi	r2,-2
81106728:	1884703a 	and	r2,r3,r2
8110672c:	1001703a 	wrctl	status,r2
  
  return context;
81106730:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
81106734:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81106738:	e0bffd17 	ldw	r2,-12(fp)
8110673c:	10800317 	ldw	r2,12(r2)
81106740:	10800104 	addi	r2,r2,4
81106744:	e0fff117 	ldw	r3,-60(fp)
81106748:	10c00035 	stwio	r3,0(r2)
8110674c:	e0bff217 	ldw	r2,-56(fp)
81106750:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81106754:	e0bff517 	ldw	r2,-44(fp)
81106758:	1001703a 	wrctl	status,r2
8110675c:	00001b06 	br	811067cc <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
81106760:	e0bffd17 	ldw	r2,-12(fp)
81106764:	10c00d17 	ldw	r3,52(r2)
81106768:	e0bff117 	ldw	r2,-60(fp)
8110676c:	1884b03a 	or	r2,r3,r2
81106770:	10800114 	ori	r2,r2,4
81106774:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
81106778:	e0fff117 	ldw	r3,-60(fp)
8110677c:	00bff3c4 	movi	r2,-49
81106780:	1884703a 	and	r2,r3,r2
81106784:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106788:	0005303a 	rdctl	r2,status
8110678c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81106790:	e0fffa17 	ldw	r3,-24(fp)
81106794:	00bfff84 	movi	r2,-2
81106798:	1884703a 	and	r2,r3,r2
8110679c:	1001703a 	wrctl	status,r2
  
  return context;
811067a0:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
811067a4:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811067a8:	e0bffd17 	ldw	r2,-12(fp)
811067ac:	10800317 	ldw	r2,12(r2)
811067b0:	10800104 	addi	r2,r2,4
811067b4:	e0fff117 	ldw	r3,-60(fp)
811067b8:	10c00035 	stwio	r3,0(r2)
811067bc:	e0bff217 	ldw	r2,-56(fp)
811067c0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811067c4:	e0bff817 	ldw	r2,-32(fp)
811067c8:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
811067cc:	e0bffd17 	ldw	r2,-12(fp)
811067d0:	10801817 	ldw	r2,96(r2)
811067d4:	1009883a 	mov	r4,r2
811067d8:	1133ae80 	call	81133ae8 <OSSemPost>

	return 0;
811067dc:	0005883a 	mov	r2,zero
}
811067e0:	e037883a 	mov	sp,fp
811067e4:	dfc00117 	ldw	ra,4(sp)
811067e8:	df000017 	ldw	fp,0(sp)
811067ec:	dec00204 	addi	sp,sp,8
811067f0:	f800283a 	ret

811067f4 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
811067f4:	deffee04 	addi	sp,sp,-72
811067f8:	de00012e 	bgeu	sp,et,81106800 <msgdma_descriptor_sync_transfer+0xc>
811067fc:	003b68fa 	trap	3
81106800:	dfc01115 	stw	ra,68(sp)
81106804:	df001015 	stw	fp,64(sp)
81106808:	df001004 	addi	fp,sp,64
8110680c:	e13ffd15 	stw	r4,-12(fp)
81106810:	e17ffe15 	stw	r5,-8(fp)
81106814:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
81106818:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110681c:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
81106820:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
81106824:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81106828:	e0bffd17 	ldw	r2,-12(fp)
8110682c:	10800317 	ldw	r2,12(r2)
81106830:	10800204 	addi	r2,r2,8
81106834:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
81106838:	10bfffcc 	andi	r2,r2,65535
8110683c:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81106840:	e0bffd17 	ldw	r2,-12(fp)
81106844:	10800317 	ldw	r2,12(r2)
81106848:	10800204 	addi	r2,r2,8
8110684c:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
81106850:	1004d43a 	srli	r2,r2,16
81106854:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
81106858:	00807804 	movi	r2,480
8110685c:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
81106860:	00001d06 	br	811068d8 <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
81106864:	01000044 	movi	r4,1
81106868:	112aee80 	call	8112aee8 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110686c:	e0bff10b 	ldhu	r2,-60(fp)
81106870:	1084e230 	cmpltui	r2,r2,5000
81106874:	1000091e 	bne	r2,zero,8110689c <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
81106878:	d0a05417 	ldw	r2,-32432(gp)
8110687c:	100f883a 	mov	r7,r2
81106880:	01801304 	movi	r6,76
81106884:	01400044 	movi	r5,1
81106888:	01204534 	movhi	r4,33044
8110688c:	2103d804 	addi	r4,r4,3936
81106890:	1115d200 	call	81115d20 <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
81106894:	00bff084 	movi	r2,-62
81106898:	0000d006 	br	81106bdc <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110689c:	e0bff10b 	ldhu	r2,-60(fp)
811068a0:	10800044 	addi	r2,r2,1
811068a4:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
811068a8:	e0bffd17 	ldw	r2,-12(fp)
811068ac:	10800317 	ldw	r2,12(r2)
811068b0:	10800204 	addi	r2,r2,8
811068b4:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
811068b8:	10bfffcc 	andi	r2,r2,65535
811068bc:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
811068c0:	e0bffd17 	ldw	r2,-12(fp)
811068c4:	10800317 	ldw	r2,12(r2)
811068c8:	10800204 	addi	r2,r2,8
811068cc:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
811068d0:	1004d43a 	srli	r2,r2,16
811068d4:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
811068d8:	e0bffd17 	ldw	r2,-12(fp)
811068dc:	10800917 	ldw	r2,36(r2)
811068e0:	e0fff317 	ldw	r3,-52(fp)
811068e4:	18bfdf2e 	bgeu	r3,r2,81106864 <__reset+0xfb0e6864>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
811068e8:	e0bffd17 	ldw	r2,-12(fp)
811068ec:	10800917 	ldw	r2,36(r2)
811068f0:	e0fff217 	ldw	r3,-56(fp)
811068f4:	18bfdb2e 	bgeu	r3,r2,81106864 <__reset+0xfb0e6864>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
811068f8:	e0bffd17 	ldw	r2,-12(fp)
811068fc:	10801817 	ldw	r2,96(r2)
81106900:	e0bff815 	stw	r2,-32(fp)
81106904:	e03ffc0d 	sth	zero,-16(fp)
81106908:	e0bffc0b 	ldhu	r2,-16(fp)
8110690c:	e0fffc84 	addi	r3,fp,-14
81106910:	180d883a 	mov	r6,r3
81106914:	100b883a 	mov	r5,r2
81106918:	e13ff817 	ldw	r4,-32(fp)
8110691c:	11337600 	call	81133760 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106920:	0005303a 	rdctl	r2,status
81106924:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81106928:	e0fffb17 	ldw	r3,-20(fp)
8110692c:	00bfff84 	movi	r2,-2
81106930:	1884703a 	and	r2,r3,r2
81106934:	1001703a 	wrctl	status,r2
  
  return context;
81106938:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110693c:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81106940:	e0bffd17 	ldw	r2,-12(fp)
81106944:	10800317 	ldw	r2,12(r2)
81106948:	10800104 	addi	r2,r2,4
8110694c:	00c00804 	movi	r3,32
81106950:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81106954:	e0bffd17 	ldw	r2,-12(fp)
81106958:	10800317 	ldw	r2,12(r2)
8110695c:	e0fffd17 	ldw	r3,-12(fp)
81106960:	18c00317 	ldw	r3,12(r3)
81106964:	18c00037 	ldwio	r3,0(r3)
81106968:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110696c:	e0bffe17 	ldw	r2,-8(fp)
81106970:	10001026 	beq	r2,zero,811069b4 <msgdma_descriptor_sync_transfer+0x1c0>
81106974:	e0bfff17 	ldw	r2,-4(fp)
81106978:	10000e1e 	bne	r2,zero,811069b4 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
8110697c:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
81106980:	d0a05417 	ldw	r2,-32432(gp)
81106984:	100f883a 	mov	r7,r2
81106988:	01800784 	movi	r6,30
8110698c:	01400044 	movi	r5,1
81106990:	01204534 	movhi	r4,33044
81106994:	2103ba04 	addi	r4,r4,3816
81106998:	1115d200 	call	81115d20 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110699c:	e0bffd17 	ldw	r2,-12(fp)
811069a0:	10801817 	ldw	r2,96(r2)
811069a4:	1009883a 	mov	r4,r2
811069a8:	1133ae80 	call	81133ae8 <OSSemPost>

		return -ETIME;
811069ac:	00bff084 	movi	r2,-62
811069b0:	00008a06 	br	81106bdc <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
811069b4:	e0bffe17 	ldw	r2,-8(fp)
811069b8:	1000231e 	bne	r2,zero,81106a48 <msgdma_descriptor_sync_transfer+0x254>
811069bc:	e0bfff17 	ldw	r2,-4(fp)
811069c0:	10002126 	beq	r2,zero,81106a48 <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
811069c4:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
811069c8:	00001506 	br	81106a20 <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
811069cc:	01000044 	movi	r4,1
811069d0:	112aee80 	call	8112aee8 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
811069d4:	e0bff10b 	ldhu	r2,-60(fp)
811069d8:	1084e230 	cmpltui	r2,r2,5000
811069dc:	10000d1e 	bne	r2,zero,81106a14 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
811069e0:	d0a05417 	ldw	r2,-32432(gp)
811069e4:	100f883a 	mov	r7,r2
811069e8:	01801004 	movi	r6,64
811069ec:	01400044 	movi	r5,1
811069f0:	01204534 	movhi	r4,33044
811069f4:	2103ec04 	addi	r4,r4,4016
811069f8:	1115d200 	call	81115d20 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
811069fc:	e0bffd17 	ldw	r2,-12(fp)
81106a00:	10801817 	ldw	r2,96(r2)
81106a04:	1009883a 	mov	r4,r2
81106a08:	1133ae80 	call	81133ae8 <OSSemPost>

				return -ETIME;
81106a0c:	00bff084 	movi	r2,-62
81106a10:	00007206 	br	81106bdc <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
81106a14:	e0bff10b 	ldhu	r2,-60(fp)
81106a18:	10800044 	addi	r2,r2,1
81106a1c:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
81106a20:	e0bffd17 	ldw	r2,-12(fp)
81106a24:	10c00317 	ldw	r3,12(r2)
81106a28:	e0bffd17 	ldw	r2,-12(fp)
81106a2c:	10800417 	ldw	r2,16(r2)
81106a30:	e1bfff17 	ldw	r6,-4(fp)
81106a34:	100b883a 	mov	r5,r2
81106a38:	1809883a 	mov	r4,r3
81106a3c:	110623c0 	call	8110623c <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
81106a40:	103fe21e 	bne	r2,zero,811069cc <__reset+0xfb0e69cc>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
81106a44:	00000606 	br	81106a60 <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81106a48:	e0bffd17 	ldw	r2,-12(fp)
81106a4c:	10801817 	ldw	r2,96(r2)
81106a50:	1009883a 	mov	r4,r2
81106a54:	1133ae80 	call	81133ae8 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
81106a58:	00bfffc4 	movi	r2,-1
81106a5c:	00005f06 	br	81106bdc <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81106a60:	e0bffd17 	ldw	r2,-12(fp)
81106a64:	10800317 	ldw	r2,12(r2)
81106a68:	10800104 	addi	r2,r2,4
81106a6c:	e0fffd17 	ldw	r3,-12(fp)
81106a70:	19000d17 	ldw	r4,52(r3)
81106a74:	00fff2c4 	movi	r3,-53
81106a78:	20c6703a 	and	r3,r4,r3
81106a7c:	18c00114 	ori	r3,r3,4
81106a80:	10c00035 	stwio	r3,0(r2)
81106a84:	e0bff517 	ldw	r2,-44(fp)
81106a88:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81106a8c:	e0bff717 	ldw	r2,-36(fp)
81106a90:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
81106a94:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81106a98:	e0bffd17 	ldw	r2,-12(fp)
81106a9c:	10800317 	ldw	r2,12(r2)
81106aa0:	10800037 	ldwio	r2,0(r2)
81106aa4:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
81106aa8:	00001906 	br	81106b10 <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
81106aac:	01000044 	movi	r4,1
81106ab0:	112aee80 	call	8112aee8 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81106ab4:	e0bff10b 	ldhu	r2,-60(fp)
81106ab8:	1084e230 	cmpltui	r2,r2,5000
81106abc:	10000d1e 	bne	r2,zero,81106af4 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
81106ac0:	d0a05417 	ldw	r2,-32432(gp)
81106ac4:	100f883a 	mov	r7,r2
81106ac8:	01801184 	movi	r6,70
81106acc:	01400044 	movi	r5,1
81106ad0:	01204534 	movhi	r4,33044
81106ad4:	2103fd04 	addi	r4,r4,4084
81106ad8:	1115d200 	call	81115d20 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
81106adc:	e0bffd17 	ldw	r2,-12(fp)
81106ae0:	10801817 	ldw	r2,96(r2)
81106ae4:	1009883a 	mov	r4,r2
81106ae8:	1133ae80 	call	81133ae8 <OSSemPost>

			return -ETIME;
81106aec:	00bff084 	movi	r2,-62
81106af0:	00003a06 	br	81106bdc <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
81106af4:	e0bff10b 	ldhu	r2,-60(fp)
81106af8:	10800044 	addi	r2,r2,1
81106afc:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81106b00:	e0bffd17 	ldw	r2,-12(fp)
81106b04:	10800317 	ldw	r2,12(r2)
81106b08:	10800037 	ldwio	r2,0(r2)
81106b0c:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
81106b10:	e0fff017 	ldw	r3,-64(fp)
81106b14:	e0bff617 	ldw	r2,-40(fp)
81106b18:	1884703a 	and	r2,r3,r2
81106b1c:	1000031e 	bne	r2,zero,81106b2c <msgdma_descriptor_sync_transfer+0x338>
81106b20:	e0bff017 	ldw	r2,-64(fp)
81106b24:	1080004c 	andi	r2,r2,1
81106b28:	103fe01e 	bne	r2,zero,81106aac <__reset+0xfb0e6aac>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
81106b2c:	e0fff017 	ldw	r3,-64(fp)
81106b30:	e0bff617 	ldw	r2,-40(fp)
81106b34:	1884703a 	and	r2,r3,r2
81106b38:	10000626 	beq	r2,zero,81106b54 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81106b3c:	e0bffd17 	ldw	r2,-12(fp)
81106b40:	10801817 	ldw	r2,96(r2)
81106b44:	1009883a 	mov	r4,r2
81106b48:	1133ae80 	call	81133ae8 <OSSemPost>

		return error;
81106b4c:	e0bff617 	ldw	r2,-40(fp)
81106b50:	00002206 	br	81106bdc <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
81106b54:	e0bffd17 	ldw	r2,-12(fp)
81106b58:	10800317 	ldw	r2,12(r2)
81106b5c:	10800104 	addi	r2,r2,4
81106b60:	10800037 	ldwio	r2,0(r2)
81106b64:	10800814 	ori	r2,r2,32
81106b68:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106b6c:	0005303a 	rdctl	r2,status
81106b70:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81106b74:	e0fffa17 	ldw	r3,-24(fp)
81106b78:	00bfff84 	movi	r2,-2
81106b7c:	1884703a 	and	r2,r3,r2
81106b80:	1001703a 	wrctl	status,r2
  
  return context;
81106b84:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81106b88:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81106b8c:	e0bffd17 	ldw	r2,-12(fp)
81106b90:	10800317 	ldw	r2,12(r2)
81106b94:	10800104 	addi	r2,r2,4
81106b98:	e0fff417 	ldw	r3,-48(fp)
81106b9c:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81106ba0:	e0bffd17 	ldw	r2,-12(fp)
81106ba4:	10800317 	ldw	r2,12(r2)
81106ba8:	e0fffd17 	ldw	r3,-12(fp)
81106bac:	18c00317 	ldw	r3,12(r3)
81106bb0:	18c00037 	ldwio	r3,0(r3)
81106bb4:	10c00035 	stwio	r3,0(r2)
81106bb8:	e0bff517 	ldw	r2,-44(fp)
81106bbc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81106bc0:	e0bff917 	ldw	r2,-28(fp)
81106bc4:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
81106bc8:	e0bffd17 	ldw	r2,-12(fp)
81106bcc:	10801817 	ldw	r2,96(r2)
81106bd0:	1009883a 	mov	r4,r2
81106bd4:	1133ae80 	call	81133ae8 <OSSemPost>

	return 0;
81106bd8:	0005883a 	mov	r2,zero

}
81106bdc:	e037883a 	mov	sp,fp
81106be0:	dfc00117 	ldw	ra,4(sp)
81106be4:	df000017 	ldw	fp,0(sp)
81106be8:	dec00204 	addi	sp,sp,8
81106bec:	f800283a 	ret

81106bf0 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
81106bf0:	deffec04 	addi	sp,sp,-80
81106bf4:	de00012e 	bgeu	sp,et,81106bfc <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
81106bf8:	003b68fa 	trap	3
81106bfc:	dfc01315 	stw	ra,76(sp)
81106c00:	df001215 	stw	fp,72(sp)
81106c04:	df001204 	addi	fp,sp,72
81106c08:	e13ff715 	stw	r4,-36(fp)
81106c0c:	e17ff815 	stw	r5,-32(fp)
81106c10:	e1bff915 	stw	r6,-28(fp)
81106c14:	e1fffa15 	stw	r7,-24(fp)
81106c18:	e1800617 	ldw	r6,24(fp)
81106c1c:	e1400717 	ldw	r5,28(fp)
81106c20:	e1000817 	ldw	r4,32(fp)
81106c24:	e0c00917 	ldw	r3,36(fp)
81106c28:	e0800a17 	ldw	r2,40(fp)
81106c2c:	e1bffb0d 	sth	r6,-20(fp)
81106c30:	e17ffc05 	stb	r5,-16(fp)
81106c34:	e13ffd05 	stb	r4,-12(fp)
81106c38:	e0fffe0d 	sth	r3,-8(fp)
81106c3c:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
81106c40:	e0bffb0b 	ldhu	r2,-20(fp)
81106c44:	e0fffc03 	ldbu	r3,-16(fp)
81106c48:	e13ffd03 	ldbu	r4,-12(fp)
81106c4c:	e17ffe0b 	ldhu	r5,-8(fp)
81106c50:	e1bfff0b 	ldhu	r6,-4(fp)
81106c54:	d9800815 	stw	r6,32(sp)
81106c58:	d9400715 	stw	r5,28(sp)
81106c5c:	d9000615 	stw	r4,24(sp)
81106c60:	d8c00515 	stw	r3,20(sp)
81106c64:	d8800415 	stw	r2,16(sp)
81106c68:	e0800517 	ldw	r2,20(fp)
81106c6c:	d8800315 	stw	r2,12(sp)
81106c70:	e0800417 	ldw	r2,16(fp)
81106c74:	d8800215 	stw	r2,8(sp)
81106c78:	e0800317 	ldw	r2,12(fp)
81106c7c:	d8800115 	stw	r2,4(sp)
81106c80:	e0800217 	ldw	r2,8(fp)
81106c84:	d8800015 	stw	r2,0(sp)
81106c88:	e1fffa17 	ldw	r7,-24(fp)
81106c8c:	e1bff917 	ldw	r6,-28(fp)
81106c90:	e17ff817 	ldw	r5,-32(fp)
81106c94:	e13ff717 	ldw	r4,-36(fp)
81106c98:	11063780 	call	81106378 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
81106c9c:	e037883a 	mov	sp,fp
81106ca0:	dfc00117 	ldw	ra,4(sp)
81106ca4:	df000017 	ldw	fp,0(sp)
81106ca8:	dec00204 	addi	sp,sp,8
81106cac:	f800283a 	ret

81106cb0 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
81106cb0:	defffc04 	addi	sp,sp,-16
81106cb4:	de00012e 	bgeu	sp,et,81106cbc <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
81106cb8:	003b68fa 	trap	3
81106cbc:	dfc00315 	stw	ra,12(sp)
81106cc0:	df000215 	stw	fp,8(sp)
81106cc4:	df000204 	addi	fp,sp,8
81106cc8:	e13ffe15 	stw	r4,-8(fp)
81106ccc:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
81106cd0:	e1bfff17 	ldw	r6,-4(fp)
81106cd4:	000b883a 	mov	r5,zero
81106cd8:	e13ffe17 	ldw	r4,-8(fp)
81106cdc:	11064dc0 	call	811064dc <msgdma_descriptor_async_transfer>
}
81106ce0:	e037883a 	mov	sp,fp
81106ce4:	dfc00117 	ldw	ra,4(sp)
81106ce8:	df000017 	ldw	fp,0(sp)
81106cec:	dec00204 	addi	sp,sp,8
81106cf0:	f800283a 	ret

81106cf4 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
81106cf4:	defffc04 	addi	sp,sp,-16
81106cf8:	de00012e 	bgeu	sp,et,81106d00 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
81106cfc:	003b68fa 	trap	3
81106d00:	dfc00315 	stw	ra,12(sp)
81106d04:	df000215 	stw	fp,8(sp)
81106d08:	df000204 	addi	fp,sp,8
81106d0c:	e13ffe15 	stw	r4,-8(fp)
81106d10:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
81106d14:	e1bfff17 	ldw	r6,-4(fp)
81106d18:	000b883a 	mov	r5,zero
81106d1c:	e13ffe17 	ldw	r4,-8(fp)
81106d20:	11067f40 	call	811067f4 <msgdma_descriptor_sync_transfer>
}
81106d24:	e037883a 	mov	sp,fp
81106d28:	dfc00117 	ldw	ra,4(sp)
81106d2c:	df000017 	ldw	fp,0(sp)
81106d30:	dec00204 	addi	sp,sp,8
81106d34:	f800283a 	ret

81106d38 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
81106d38:	defff204 	addi	sp,sp,-56
81106d3c:	de00012e 	bgeu	sp,et,81106d44 <POWER_SPI_RW+0xc>
81106d40:	003b68fa 	trap	3
81106d44:	dfc00d15 	stw	ra,52(sp)
81106d48:	df000c15 	stw	fp,48(sp)
81106d4c:	df000c04 	addi	fp,sp,48
81106d50:	2007883a 	mov	r3,r4
81106d54:	2805883a 	mov	r2,r5
81106d58:	e1bffe15 	stw	r6,-8(fp)
81106d5c:	e1ffff15 	stw	r7,-4(fp)
81106d60:	e0fffc05 	stb	r3,-16(fp)
81106d64:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
81106d68:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
81106d6c:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
81106d70:	008003f4 	movhi	r2,15
81106d74:	10909004 	addi	r2,r2,16960
81106d78:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
81106d7c:	00bfe004 	movi	r2,-128
81106d80:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
81106d84:	e0bffe17 	ldw	r2,-8(fp)
81106d88:	10000226 	beq	r2,zero,81106d94 <POWER_SPI_RW+0x5c>
81106d8c:	00800804 	movi	r2,32
81106d90:	00000106 	br	81106d98 <POWER_SPI_RW+0x60>
81106d94:	0005883a 	mov	r2,zero
81106d98:	e0fff403 	ldbu	r3,-48(fp)
81106d9c:	10c4b03a 	or	r2,r2,r3
81106da0:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
81106da4:	e0800217 	ldw	r2,8(fp)
81106da8:	10000226 	beq	r2,zero,81106db4 <POWER_SPI_RW+0x7c>
81106dac:	00800404 	movi	r2,16
81106db0:	00000106 	br	81106db8 <POWER_SPI_RW+0x80>
81106db4:	0005883a 	mov	r2,zero
81106db8:	e0fff403 	ldbu	r3,-48(fp)
81106dbc:	10c4b03a 	or	r2,r2,r3
81106dc0:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
81106dc4:	e0bfff17 	ldw	r2,-4(fp)
81106dc8:	10000226 	beq	r2,zero,81106dd4 <POWER_SPI_RW+0x9c>
81106dcc:	00800204 	movi	r2,8
81106dd0:	00000106 	br	81106dd8 <POWER_SPI_RW+0xa0>
81106dd4:	0005883a 	mov	r2,zero
81106dd8:	e0fff403 	ldbu	r3,-48(fp)
81106ddc:	10c4b03a 	or	r2,r2,r3
81106de0:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
81106de4:	e0bffd03 	ldbu	r2,-12(fp)
81106de8:	108001cc 	andi	r2,r2,7
81106dec:	1007883a 	mov	r3,r2
81106df0:	e0bff403 	ldbu	r2,-48(fp)
81106df4:	1884b03a 	or	r2,r3,r2
81106df8:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
81106dfc:	0007883a 	mov	r3,zero
81106e00:	00a00034 	movhi	r2,32768
81106e04:	10824404 	addi	r2,r2,2320
81106e08:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
81106e0c:	0007883a 	mov	r3,zero
81106e10:	00a00034 	movhi	r2,32768
81106e14:	10824c04 	addi	r2,r2,2352
81106e18:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
81106e1c:	e0bffc03 	ldbu	r2,-16(fp)
81106e20:	1000021e 	bne	r2,zero,81106e2c <POWER_SPI_RW+0xf4>
81106e24:	00c00084 	movi	r3,2
81106e28:	00000106 	br	81106e30 <POWER_SPI_RW+0xf8>
81106e2c:	00c00044 	movi	r3,1
81106e30:	00a00034 	movhi	r2,32768
81106e34:	10824804 	addi	r2,r2,2336
81106e38:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
81106e3c:	010003c4 	movi	r4,15
81106e40:	112c95c0 	call	8112c95c <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
81106e44:	00000306 	br	81106e54 <POWER_SPI_RW+0x11c>
		nWait++;
81106e48:	e0bff817 	ldw	r2,-32(fp)
81106e4c:	10800044 	addi	r2,r2,1
81106e50:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
81106e54:	00a00034 	movhi	r2,32768
81106e58:	10825404 	addi	r2,r2,2384
81106e5c:	10800037 	ldwio	r2,0(r2)
81106e60:	1080004c 	andi	r2,r2,1
81106e64:	10000326 	beq	r2,zero,81106e74 <POWER_SPI_RW+0x13c>
81106e68:	e0fff817 	ldw	r3,-32(fp)
81106e6c:	e0bffa17 	ldw	r2,-24(fp)
81106e70:	18bff516 	blt	r3,r2,81106e48 <__reset+0xfb0e6e48>
		nWait++;
	}

	if (SPI_SDO) {
81106e74:	00a00034 	movhi	r2,32768
81106e78:	10825404 	addi	r2,r2,2384
81106e7c:	10800037 	ldwio	r2,0(r2)
81106e80:	1080004c 	andi	r2,r2,1
81106e84:	10000626 	beq	r2,zero,81106ea0 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
81106e88:	00c000c4 	movi	r3,3
81106e8c:	00a00034 	movhi	r2,32768
81106e90:	10824804 	addi	r2,r2,2336
81106e94:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
81106e98:	0005883a 	mov	r2,zero
81106e9c:	0000db06 	br	8110720c <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
81106ea0:	e03ff715 	stw	zero,-36(fp)
81106ea4:	00002406 	br	81106f38 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
81106ea8:	e0bff403 	ldbu	r2,-48(fp)
81106eac:	10803fcc 	andi	r2,r2,255
81106eb0:	1004d1fa 	srli	r2,r2,7
81106eb4:	10c03fcc 	andi	r3,r2,255
81106eb8:	00a00034 	movhi	r2,32768
81106ebc:	10825004 	addi	r2,r2,2368
81106ec0:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
81106ec4:	e0bff403 	ldbu	r2,-48(fp)
81106ec8:	1085883a 	add	r2,r2,r2
81106ecc:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
81106ed0:	e0bff517 	ldw	r2,-44(fp)
81106ed4:	1085883a 	add	r2,r2,r2
81106ed8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
81106edc:	00a00034 	movhi	r2,32768
81106ee0:	10825404 	addi	r2,r2,2384
81106ee4:	10800037 	ldwio	r2,0(r2)
81106ee8:	1080004c 	andi	r2,r2,1
81106eec:	1007883a 	mov	r3,r2
81106ef0:	e0bff517 	ldw	r2,-44(fp)
81106ef4:	10c4b03a 	or	r2,r2,r3
81106ef8:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81106efc:	00c00044 	movi	r3,1
81106f00:	00a00034 	movhi	r2,32768
81106f04:	10824c04 	addi	r2,r2,2352
81106f08:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106f0c:	010003c4 	movi	r4,15
81106f10:	112c95c0 	call	8112c95c <usleep>
		SPI_SCK(0); //sck=0; // clock low
81106f14:	0007883a 	mov	r3,zero
81106f18:	00a00034 	movhi	r2,32768
81106f1c:	10824c04 	addi	r2,r2,2352
81106f20:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106f24:	010003c4 	movi	r4,15
81106f28:	112c95c0 	call	8112c95c <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
81106f2c:	e0bff717 	ldw	r2,-36(fp)
81106f30:	10800044 	addi	r2,r2,1
81106f34:	e0bff715 	stw	r2,-36(fp)
81106f38:	e0bff717 	ldw	r2,-36(fp)
81106f3c:	10800090 	cmplti	r2,r2,2
81106f40:	103fd91e 	bne	r2,zero,81106ea8 <__reset+0xfb0e6ea8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
81106f44:	e03ff715 	stw	zero,-36(fp)
81106f48:	00002406 	br	81106fdc <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
81106f4c:	e0bff403 	ldbu	r2,-48(fp)
81106f50:	10803fcc 	andi	r2,r2,255
81106f54:	1004d1fa 	srli	r2,r2,7
81106f58:	10c03fcc 	andi	r3,r2,255
81106f5c:	00a00034 	movhi	r2,32768
81106f60:	10825004 	addi	r2,r2,2368
81106f64:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
81106f68:	e0bff403 	ldbu	r2,-48(fp)
81106f6c:	1085883a 	add	r2,r2,r2
81106f70:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
81106f74:	e0bff517 	ldw	r2,-44(fp)
81106f78:	1085883a 	add	r2,r2,r2
81106f7c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
81106f80:	00a00034 	movhi	r2,32768
81106f84:	10825404 	addi	r2,r2,2384
81106f88:	10800037 	ldwio	r2,0(r2)
81106f8c:	1080004c 	andi	r2,r2,1
81106f90:	1007883a 	mov	r3,r2
81106f94:	e0bff517 	ldw	r2,-44(fp)
81106f98:	10c4b03a 	or	r2,r2,r3
81106f9c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81106fa0:	00c00044 	movi	r3,1
81106fa4:	00a00034 	movhi	r2,32768
81106fa8:	10824c04 	addi	r2,r2,2352
81106fac:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106fb0:	010003c4 	movi	r4,15
81106fb4:	112c95c0 	call	8112c95c <usleep>
		SPI_SCK(0); //sck=0; // clock low
81106fb8:	0007883a 	mov	r3,zero
81106fbc:	00a00034 	movhi	r2,32768
81106fc0:	10824c04 	addi	r2,r2,2352
81106fc4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106fc8:	010003c4 	movi	r4,15
81106fcc:	112c95c0 	call	8112c95c <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
81106fd0:	e0bff717 	ldw	r2,-36(fp)
81106fd4:	10800044 	addi	r2,r2,1
81106fd8:	e0bff715 	stw	r2,-36(fp)
81106fdc:	e0bff717 	ldw	r2,-36(fp)
81106fe0:	10800210 	cmplti	r2,r2,8
81106fe4:	103fd91e 	bne	r2,zero,81106f4c <__reset+0xfb0e6f4c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
81106fe8:	e03ff715 	stw	zero,-36(fp)
81106fec:	00001a06 	br	81107058 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
81106ff0:	e0bff517 	ldw	r2,-44(fp)
81106ff4:	1085883a 	add	r2,r2,r2
81106ff8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
81106ffc:	00a00034 	movhi	r2,32768
81107000:	10825404 	addi	r2,r2,2384
81107004:	10800037 	ldwio	r2,0(r2)
81107008:	1080004c 	andi	r2,r2,1
8110700c:	1007883a 	mov	r3,r2
81107010:	e0bff517 	ldw	r2,-44(fp)
81107014:	10c4b03a 	or	r2,r2,r3
81107018:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110701c:	00c00044 	movi	r3,1
81107020:	00a00034 	movhi	r2,32768
81107024:	10824c04 	addi	r2,r2,2352
81107028:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110702c:	010003c4 	movi	r4,15
81107030:	112c95c0 	call	8112c95c <usleep>
		SPI_SCK(0); //sck=0; // clock low
81107034:	0007883a 	mov	r3,zero
81107038:	00a00034 	movhi	r2,32768
8110703c:	10824c04 	addi	r2,r2,2352
81107040:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81107044:	010003c4 	movi	r4,15
81107048:	112c95c0 	call	8112c95c <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110704c:	e0bff717 	ldw	r2,-36(fp)
81107050:	10800044 	addi	r2,r2,1
81107054:	e0bff715 	stw	r2,-36(fp)
81107058:	e0bff717 	ldw	r2,-36(fp)
8110705c:	10800210 	cmplti	r2,r2,8
81107060:	103fe31e 	bne	r2,zero,81106ff0 <__reset+0xfb0e6ff0>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
81107064:	e03ff715 	stw	zero,-36(fp)
81107068:	00001a06 	br	811070d4 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110706c:	e0bff517 	ldw	r2,-44(fp)
81107070:	1085883a 	add	r2,r2,r2
81107074:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
81107078:	00a00034 	movhi	r2,32768
8110707c:	10825404 	addi	r2,r2,2384
81107080:	10800037 	ldwio	r2,0(r2)
81107084:	1080004c 	andi	r2,r2,1
81107088:	1007883a 	mov	r3,r2
8110708c:	e0bff517 	ldw	r2,-44(fp)
81107090:	10c4b03a 	or	r2,r2,r3
81107094:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81107098:	00c00044 	movi	r3,1
8110709c:	00a00034 	movhi	r2,32768
811070a0:	10824c04 	addi	r2,r2,2352
811070a4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
811070a8:	010003c4 	movi	r4,15
811070ac:	112c95c0 	call	8112c95c <usleep>
		SPI_SCK(0); //sck=0; // clock low
811070b0:	0007883a 	mov	r3,zero
811070b4:	00a00034 	movhi	r2,32768
811070b8:	10824c04 	addi	r2,r2,2352
811070bc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
811070c0:	010003c4 	movi	r4,15
811070c4:	112c95c0 	call	8112c95c <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
811070c8:	e0bff717 	ldw	r2,-36(fp)
811070cc:	10800044 	addi	r2,r2,1
811070d0:	e0bff715 	stw	r2,-36(fp)
811070d4:	e0bff717 	ldw	r2,-36(fp)
811070d8:	10800210 	cmplti	r2,r2,8
811070dc:	103fe31e 	bne	r2,zero,8110706c <__reset+0xfb0e706c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
811070e0:	e03ff715 	stw	zero,-36(fp)
811070e4:	00001a06 	br	81107150 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
811070e8:	e0bff517 	ldw	r2,-44(fp)
811070ec:	1085883a 	add	r2,r2,r2
811070f0:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
811070f4:	00a00034 	movhi	r2,32768
811070f8:	10825404 	addi	r2,r2,2384
811070fc:	10800037 	ldwio	r2,0(r2)
81107100:	1080004c 	andi	r2,r2,1
81107104:	1007883a 	mov	r3,r2
81107108:	e0bff517 	ldw	r2,-44(fp)
8110710c:	10c4b03a 	or	r2,r2,r3
81107110:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81107114:	00c00044 	movi	r3,1
81107118:	00a00034 	movhi	r2,32768
8110711c:	10824c04 	addi	r2,r2,2352
81107120:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81107124:	010003c4 	movi	r4,15
81107128:	112c95c0 	call	8112c95c <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110712c:	0007883a 	mov	r3,zero
81107130:	00a00034 	movhi	r2,32768
81107134:	10824c04 	addi	r2,r2,2352
81107138:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110713c:	010003c4 	movi	r4,15
81107140:	112c95c0 	call	8112c95c <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
81107144:	e0bff717 	ldw	r2,-36(fp)
81107148:	10800044 	addi	r2,r2,1
8110714c:	e0bff715 	stw	r2,-36(fp)
81107150:	e0bff717 	ldw	r2,-36(fp)
81107154:	10800190 	cmplti	r2,r2,6
81107158:	103fe31e 	bne	r2,zero,811070e8 <__reset+0xfb0e70e8>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110715c:	00c00044 	movi	r3,1
81107160:	00a00034 	movhi	r2,32768
81107164:	10824c04 	addi	r2,r2,2352
81107168:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110716c:	010003c4 	movi	r4,15
81107170:	112c95c0 	call	8112c95c <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
81107174:	00c000c4 	movi	r3,3
81107178:	00a00034 	movhi	r2,32768
8110717c:	10824804 	addi	r2,r2,2336
81107180:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
81107184:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
81107188:	00800044 	movi	r2,1
8110718c:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
81107190:	e03ff715 	stw	zero,-36(fp)
81107194:	00000d06 	br	811071cc <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
81107198:	e0fff517 	ldw	r3,-44(fp)
8110719c:	e0bff617 	ldw	r2,-40(fp)
811071a0:	1884703a 	and	r2,r3,r2
811071a4:	1000031e 	bne	r2,zero,811071b4 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
811071a8:	e0bff917 	ldw	r2,-28(fp)
811071ac:	10800044 	addi	r2,r2,1
811071b0:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
811071b4:	e0bff617 	ldw	r2,-40(fp)
811071b8:	1085883a 	add	r2,r2,r2
811071bc:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
811071c0:	e0bff717 	ldw	r2,-36(fp)
811071c4:	10800044 	addi	r2,r2,1
811071c8:	e0bff715 	stw	r2,-36(fp)
811071cc:	e0bff717 	ldw	r2,-36(fp)
811071d0:	10800810 	cmplti	r2,r2,32
811071d4:	103ff01e 	bne	r2,zero,81107198 <__reset+0xfb0e7198>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
811071d8:	e0bff917 	ldw	r2,-28(fp)
811071dc:	1080004c 	andi	r2,r2,1
811071e0:	1005003a 	cmpeq	r2,r2,zero
811071e4:	10803fcc 	andi	r2,r2,255
811071e8:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
811071ec:	e0bffb17 	ldw	r2,-20(fp)
811071f0:	1000021e 	bne	r2,zero,811071fc <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
811071f4:	0005883a 	mov	r2,zero
811071f8:	00000406 	br	8110720c <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
811071fc:	e0800317 	ldw	r2,12(fp)
81107200:	e0fff517 	ldw	r3,-44(fp)
81107204:	10c00015 	stw	r3,0(r2)

	return bSuccess;
81107208:	e0bffb17 	ldw	r2,-20(fp)
}
8110720c:	e037883a 	mov	sp,fp
81107210:	dfc00117 	ldw	ra,4(sp)
81107214:	df000017 	ldw	fp,0(sp)
81107218:	dec00204 	addi	sp,sp,8
8110721c:	f800283a 	ret

81107220 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
81107220:	defffc04 	addi	sp,sp,-16
81107224:	de00012e 	bgeu	sp,et,8110722c <vRstcSimucamReset+0xc>
81107228:	003b68fa 	trap	3
8110722c:	dfc00315 	stw	ra,12(sp)
81107230:	df000215 	stw	fp,8(sp)
81107234:	df000204 	addi	fp,sp,8
81107238:	2005883a 	mov	r2,r4
8110723c:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
81107240:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
81107244:	e0bfff0b 	ldhu	r2,-4(fp)
81107248:	e0fffe17 	ldw	r3,-8(fp)
8110724c:	1884b03a 	or	r2,r3,r2
81107250:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
81107254:	e0bffe17 	ldw	r2,-8(fp)
81107258:	10800074 	orhi	r2,r2,1
8110725c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
81107260:	e1bffe17 	ldw	r6,-8(fp)
81107264:	000b883a 	mov	r5,zero
81107268:	01200034 	movhi	r4,32768
8110726c:	21020004 	addi	r4,r4,2048
81107270:	11073700 	call	81107370 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
81107274:	0001883a 	nop
81107278:	e037883a 	mov	sp,fp
8110727c:	dfc00117 	ldw	ra,4(sp)
81107280:	df000017 	ldw	fp,0(sp)
81107284:	dec00204 	addi	sp,sp,8
81107288:	f800283a 	ret

8110728c <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110728c:	defffc04 	addi	sp,sp,-16
81107290:	de00012e 	bgeu	sp,et,81107298 <vRstcReleaseDeviceReset+0xc>
81107294:	003b68fa 	trap	3
81107298:	dfc00315 	stw	ra,12(sp)
8110729c:	df000215 	stw	fp,8(sp)
811072a0:	df000204 	addi	fp,sp,8
811072a4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
811072a8:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
811072ac:	01400044 	movi	r5,1
811072b0:	01200034 	movhi	r4,32768
811072b4:	21020004 	addi	r4,r4,2048
811072b8:	11073c40 	call	811073c4 <uliRstReadReg>
811072bc:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
811072c0:	e0bfff17 	ldw	r2,-4(fp)
811072c4:	0084303a 	nor	r2,zero,r2
811072c8:	e0fffe17 	ldw	r3,-8(fp)
811072cc:	1884703a 	and	r2,r3,r2
811072d0:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
811072d4:	e1bffe17 	ldw	r6,-8(fp)
811072d8:	01400044 	movi	r5,1
811072dc:	01200034 	movhi	r4,32768
811072e0:	21020004 	addi	r4,r4,2048
811072e4:	11073700 	call	81107370 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
811072e8:	0001883a 	nop
811072ec:	e037883a 	mov	sp,fp
811072f0:	dfc00117 	ldw	ra,4(sp)
811072f4:	df000017 	ldw	fp,0(sp)
811072f8:	dec00204 	addi	sp,sp,8
811072fc:	f800283a 	ret

81107300 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
81107300:	defffc04 	addi	sp,sp,-16
81107304:	de00012e 	bgeu	sp,et,8110730c <vRstcHoldDeviceReset+0xc>
81107308:	003b68fa 	trap	3
8110730c:	dfc00315 	stw	ra,12(sp)
81107310:	df000215 	stw	fp,8(sp)
81107314:	df000204 	addi	fp,sp,8
81107318:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110731c:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
81107320:	01400044 	movi	r5,1
81107324:	01200034 	movhi	r4,32768
81107328:	21020004 	addi	r4,r4,2048
8110732c:	11073c40 	call	811073c4 <uliRstReadReg>
81107330:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
81107334:	e0fffe17 	ldw	r3,-8(fp)
81107338:	e0bfff17 	ldw	r2,-4(fp)
8110733c:	1884b03a 	or	r2,r3,r2
81107340:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
81107344:	e1bffe17 	ldw	r6,-8(fp)
81107348:	01400044 	movi	r5,1
8110734c:	01200034 	movhi	r4,32768
81107350:	21020004 	addi	r4,r4,2048
81107354:	11073700 	call	81107370 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
81107358:	0001883a 	nop
8110735c:	e037883a 	mov	sp,fp
81107360:	dfc00117 	ldw	ra,4(sp)
81107364:	df000017 	ldw	fp,0(sp)
81107368:	dec00204 	addi	sp,sp,8
8110736c:	f800283a 	ret

81107370 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81107370:	defffc04 	addi	sp,sp,-16
81107374:	de00012e 	bgeu	sp,et,8110737c <vRstcWriteReg+0xc>
81107378:	003b68fa 	trap	3
8110737c:	df000315 	stw	fp,12(sp)
81107380:	df000304 	addi	fp,sp,12
81107384:	e13ffd15 	stw	r4,-12(fp)
81107388:	e17ffe15 	stw	r5,-8(fp)
8110738c:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81107390:	e0bffe17 	ldw	r2,-8(fp)
81107394:	1085883a 	add	r2,r2,r2
81107398:	1085883a 	add	r2,r2,r2
8110739c:	1007883a 	mov	r3,r2
811073a0:	e0bffd17 	ldw	r2,-12(fp)
811073a4:	10c5883a 	add	r2,r2,r3
811073a8:	e0ffff17 	ldw	r3,-4(fp)
811073ac:	10c00015 	stw	r3,0(r2)
}
811073b0:	0001883a 	nop
811073b4:	e037883a 	mov	sp,fp
811073b8:	df000017 	ldw	fp,0(sp)
811073bc:	dec00104 	addi	sp,sp,4
811073c0:	f800283a 	ret

811073c4 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811073c4:	defffc04 	addi	sp,sp,-16
811073c8:	de00012e 	bgeu	sp,et,811073d0 <uliRstReadReg+0xc>
811073cc:	003b68fa 	trap	3
811073d0:	df000315 	stw	fp,12(sp)
811073d4:	df000304 	addi	fp,sp,12
811073d8:	e13ffe15 	stw	r4,-8(fp)
811073dc:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811073e0:	e0bfff17 	ldw	r2,-4(fp)
811073e4:	1085883a 	add	r2,r2,r2
811073e8:	1085883a 	add	r2,r2,r2
811073ec:	1007883a 	mov	r3,r2
811073f0:	e0bffe17 	ldw	r2,-8(fp)
811073f4:	10c5883a 	add	r2,r2,r3
811073f8:	10800017 	ldw	r2,0(r2)
811073fc:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81107400:	e0bffd17 	ldw	r2,-12(fp)
}
81107404:	e037883a 	mov	sp,fp
81107408:	df000017 	ldw	fp,0(sp)
8110740c:	dec00104 	addi	sp,sp,4
81107410:	f800283a 	ret

81107414 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
81107414:	defffe04 	addi	sp,sp,-8
81107418:	de00012e 	bgeu	sp,et,81107420 <v_spi_start+0xc>
8110741c:	003b68fa 	trap	3
81107420:	dfc00115 	stw	ra,4(sp)
81107424:	df000015 	stw	fp,0(sp)
81107428:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110742c:	0007883a 	mov	r3,zero
81107430:	00a00034 	movhi	r2,32768
81107434:	10823004 	addi	r2,r2,2240
81107438:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110743c:	0007883a 	mov	r3,zero
81107440:	00a00034 	movhi	r2,32768
81107444:	10822c04 	addi	r2,r2,2224
81107448:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110744c:	01002584 	movi	r4,150
81107450:	112c95c0 	call	8112c95c <usleep>
}
81107454:	0001883a 	nop
81107458:	e037883a 	mov	sp,fp
8110745c:	dfc00117 	ldw	ra,4(sp)
81107460:	df000017 	ldw	fp,0(sp)
81107464:	dec00204 	addi	sp,sp,8
81107468:	f800283a 	ret

8110746c <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110746c:	defffc04 	addi	sp,sp,-16
81107470:	de00012e 	bgeu	sp,et,81107478 <v_spi_send_byte+0xc>
81107474:	003b68fa 	trap	3
81107478:	dfc00315 	stw	ra,12(sp)
8110747c:	df000215 	stw	fp,8(sp)
81107480:	df000204 	addi	fp,sp,8
81107484:	2005883a 	mov	r2,r4
81107488:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110748c:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
81107490:	00bfe004 	movi	r2,-128
81107494:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
81107498:	e03ffe05 	stb	zero,-8(fp)
8110749c:	00001b06 	br	8110750c <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
811074a0:	e0ffff03 	ldbu	r3,-4(fp)
811074a4:	e0bffe43 	ldbu	r2,-7(fp)
811074a8:	1884703a 	and	r2,r3,r2
811074ac:	10803fcc 	andi	r2,r2,255
811074b0:	1004c03a 	cmpne	r2,r2,zero
811074b4:	10c03fcc 	andi	r3,r2,255
811074b8:	00a00034 	movhi	r2,32768
811074bc:	10823404 	addi	r2,r2,2256
811074c0:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
811074c4:	e0bffe43 	ldbu	r2,-7(fp)
811074c8:	1004d07a 	srli	r2,r2,1
811074cc:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
811074d0:	00c00044 	movi	r3,1
811074d4:	00a00034 	movhi	r2,32768
811074d8:	10823004 	addi	r2,r2,2240
811074dc:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
811074e0:	01002584 	movi	r4,150
811074e4:	112c95c0 	call	8112c95c <usleep>
        SPI_SCK(0);//sck=0; // clock low
811074e8:	0007883a 	mov	r3,zero
811074ec:	00a00034 	movhi	r2,32768
811074f0:	10823004 	addi	r2,r2,2240
811074f4:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
811074f8:	01002584 	movi	r4,150
811074fc:	112c95c0 	call	8112c95c <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
81107500:	e0bffe03 	ldbu	r2,-8(fp)
81107504:	10800044 	addi	r2,r2,1
81107508:	e0bffe05 	stb	r2,-8(fp)
8110750c:	e0bffe03 	ldbu	r2,-8(fp)
81107510:	10800230 	cmpltui	r2,r2,8
81107514:	103fe21e 	bne	r2,zero,811074a0 <__reset+0xfb0e74a0>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
81107518:	0001883a 	nop
8110751c:	e037883a 	mov	sp,fp
81107520:	dfc00117 	ldw	ra,4(sp)
81107524:	df000017 	ldw	fp,0(sp)
81107528:	dec00204 	addi	sp,sp,8
8110752c:	f800283a 	ret

81107530 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
81107530:	defffd04 	addi	sp,sp,-12
81107534:	de00012e 	bgeu	sp,et,8110753c <uc_spi_get_byte+0xc>
81107538:	003b68fa 	trap	3
8110753c:	dfc00215 	stw	ra,8(sp)
81107540:	df000115 	stw	fp,4(sp)
81107544:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
81107548:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110754c:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
81107550:	e03fff05 	stb	zero,-4(fp)
81107554:	00001a06 	br	811075c0 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
81107558:	e0bfff43 	ldbu	r2,-3(fp)
8110755c:	1085883a 	add	r2,r2,r2
81107560:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
81107564:	00a00034 	movhi	r2,32768
81107568:	10823804 	addi	r2,r2,2272
8110756c:	10800037 	ldwio	r2,0(r2)
81107570:	1080004c 	andi	r2,r2,1
81107574:	1007883a 	mov	r3,r2
81107578:	e0bfff43 	ldbu	r2,-3(fp)
8110757c:	1884b03a 	or	r2,r3,r2
81107580:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
81107584:	00c00044 	movi	r3,1
81107588:	00a00034 	movhi	r2,32768
8110758c:	10823004 	addi	r2,r2,2240
81107590:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
81107594:	01002584 	movi	r4,150
81107598:	112c95c0 	call	8112c95c <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110759c:	0007883a 	mov	r3,zero
811075a0:	00a00034 	movhi	r2,32768
811075a4:	10823004 	addi	r2,r2,2240
811075a8:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
811075ac:	01002584 	movi	r4,150
811075b0:	112c95c0 	call	8112c95c <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
811075b4:	e0bfff03 	ldbu	r2,-4(fp)
811075b8:	10800044 	addi	r2,r2,1
811075bc:	e0bfff05 	stb	r2,-4(fp)
811075c0:	e0bfff03 	ldbu	r2,-4(fp)
811075c4:	10800230 	cmpltui	r2,r2,8
811075c8:	103fe31e 	bne	r2,zero,81107558 <__reset+0xfb0e7558>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
811075cc:	e0bfff43 	ldbu	r2,-3(fp)
}
811075d0:	e037883a 	mov	sp,fp
811075d4:	dfc00117 	ldw	ra,4(sp)
811075d8:	df000017 	ldw	fp,0(sp)
811075dc:	dec00204 	addi	sp,sp,8
811075e0:	f800283a 	ret

811075e4 <v_spi_end>:

void v_spi_end(void){
811075e4:	defffe04 	addi	sp,sp,-8
811075e8:	de00012e 	bgeu	sp,et,811075f0 <v_spi_end+0xc>
811075ec:	003b68fa 	trap	3
811075f0:	dfc00115 	stw	ra,4(sp)
811075f4:	df000015 	stw	fp,0(sp)
811075f8:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
811075fc:	0007883a 	mov	r3,zero
81107600:	00a00034 	movhi	r2,32768
81107604:	10823004 	addi	r2,r2,2240
81107608:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110760c:	01002584 	movi	r4,150
81107610:	112c95c0 	call	8112c95c <usleep>
    SPI_CS_N(1);
81107614:	00c00044 	movi	r3,1
81107618:	00a00034 	movhi	r2,32768
8110761c:	10822c04 	addi	r2,r2,2224
81107620:	10c00035 	stwio	r3,0(r2)
}
81107624:	0001883a 	nop
81107628:	e037883a 	mov	sp,fp
8110762c:	dfc00117 	ldw	ra,4(sp)
81107630:	df000017 	ldw	fp,0(sp)
81107634:	dec00204 	addi	sp,sp,8
81107638:	f800283a 	ret

8110763c <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110763c:	defff604 	addi	sp,sp,-40
81107640:	de00012e 	bgeu	sp,et,81107648 <RTCC_SPI_R_MAC+0xc>
81107644:	003b68fa 	trap	3
81107648:	dfc00915 	stw	ra,36(sp)
8110764c:	df000815 	stw	fp,32(sp)
81107650:	df000804 	addi	fp,sp,32
81107654:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81107658:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110765c:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
81107660:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
81107664:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
81107668:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110766c:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
81107670:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
81107674:	00800084 	movi	r2,2
81107678:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110767c:	00800cc4 	movi	r2,51
81107680:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
81107684:	11074140 	call	81107414 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
81107688:	e0bffec3 	ldbu	r2,-5(fp)
8110768c:	1009883a 	mov	r4,r2
81107690:	110746c0 	call	8110746c <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
81107694:	e0bffe83 	ldbu	r2,-6(fp)
81107698:	1009883a 	mov	r4,r2
8110769c:	110746c0 	call	8110746c <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
811076a0:	11075300 	call	81107530 <uc_spi_get_byte>
811076a4:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
811076a8:	11075300 	call	81107530 <uc_spi_get_byte>
811076ac:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
811076b0:	11075300 	call	81107530 <uc_spi_get_byte>
811076b4:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
811076b8:	11075300 	call	81107530 <uc_spi_get_byte>
811076bc:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
811076c0:	11075300 	call	81107530 <uc_spi_get_byte>
811076c4:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
811076c8:	11075300 	call	81107530 <uc_spi_get_byte>
811076cc:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
811076d0:	11075e40 	call	811075e4 <v_spi_end>

    bSuccess = TRUE;
811076d4:	00800044 	movi	r2,1
811076d8:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
811076dc:	e0bfff17 	ldw	r2,-4(fp)
811076e0:	e0fffd03 	ldbu	r3,-12(fp)
811076e4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
811076e8:	e0bfff17 	ldw	r2,-4(fp)
811076ec:	10800044 	addi	r2,r2,1
811076f0:	e0fffd43 	ldbu	r3,-11(fp)
811076f4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
811076f8:	e0bfff17 	ldw	r2,-4(fp)
811076fc:	10800084 	addi	r2,r2,2
81107700:	e0fffd83 	ldbu	r3,-10(fp)
81107704:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
81107708:	e0bfff17 	ldw	r2,-4(fp)
8110770c:	108000c4 	addi	r2,r2,3
81107710:	e0fffdc3 	ldbu	r3,-9(fp)
81107714:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
81107718:	e0bfff17 	ldw	r2,-4(fp)
8110771c:	10800104 	addi	r2,r2,4
81107720:	e0fffe03 	ldbu	r3,-8(fp)
81107724:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
81107728:	e0bfff17 	ldw	r2,-4(fp)
8110772c:	10800144 	addi	r2,r2,5
81107730:	e0fffe43 	ldbu	r3,-7(fp)
81107734:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
81107738:	e1bffd03 	ldbu	r6,-12(fp)
8110773c:	e1fffd43 	ldbu	r7,-11(fp)
81107740:	e0bffd83 	ldbu	r2,-10(fp)
81107744:	e0fffdc3 	ldbu	r3,-9(fp)
81107748:	e13ffe03 	ldbu	r4,-8(fp)
8110774c:	e17ffe43 	ldbu	r5,-7(fp)
81107750:	d9400315 	stw	r5,12(sp)
81107754:	d9000215 	stw	r4,8(sp)
81107758:	d8c00115 	stw	r3,4(sp)
8110775c:	d8800015 	stw	r2,0(sp)
81107760:	01604534 	movhi	r5,33044
81107764:	29440f04 	addi	r5,r5,4156
81107768:	01204534 	movhi	r4,33044
8110776c:	211bff04 	addi	r4,r4,28668
81107770:	11170140 	call	81117014 <sprintf>
	debug(fp, cDebugBuffer);
81107774:	d0a05417 	ldw	r2,-32432(gp)
81107778:	01604534 	movhi	r5,33044
8110777c:	295bff04 	addi	r5,r5,28668
81107780:	1009883a 	mov	r4,r2
81107784:	11156840 	call	81115684 <fprintf>
#endif

    return bSuccess;
81107788:	e0bffc17 	ldw	r2,-16(fp)
}
8110778c:	e037883a 	mov	sp,fp
81107790:	dfc00117 	ldw	ra,4(sp)
81107794:	df000017 	ldw	fp,0(sp)
81107798:	dec00204 	addi	sp,sp,8
8110779c:	f800283a 	ret

811077a0 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configuração não especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
811077a0:	defffd04 	addi	sp,sp,-12
811077a4:	de00012e 	bgeu	sp,et,811077ac <bSSDisplayConfig+0xc>
811077a8:	003b68fa 	trap	3
811077ac:	df000215 	stw	fp,8(sp)
811077b0:	df000204 	addi	fp,sp,8
811077b4:	2005883a 	mov	r2,r4
811077b8:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
811077bc:	e0bfff03 	ldbu	r2,-4(fp)
811077c0:	10c00168 	cmpgeui	r3,r2,5
811077c4:	18001c1e 	bne	r3,zero,81107838 <bSSDisplayConfig+0x98>
811077c8:	100690ba 	slli	r3,r2,2
811077cc:	00a04434 	movhi	r2,33040
811077d0:	109df804 	addi	r2,r2,30688
811077d4:	1885883a 	add	r2,r3,r2
811077d8:	10800017 	ldw	r2,0(r2)
811077dc:	1000683a 	jmp	r2
811077e0:	811077f4 	orhi	r4,r16,16863
811077e4:	81107800 	call	88110780 <__reset+0x20f0780>
811077e8:	8110780c 	andi	r4,r16,16864
811077ec:	81107820 	cmpeqi	r4,r16,16864
811077f0:	81107830 	cmpltui	r4,r16,16864
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
811077f4:	00800cc4 	movi	r2,51
811077f8:	d0a04645 	stb	r2,-32487(gp)
	    break;
811077fc:	00001006 	br	81107840 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
81107800:	00801544 	movi	r2,85
81107804:	d0a04645 	stb	r2,-32487(gp)
	    break;
81107808:	00000d06 	br	81107840 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110780c:	d0e04643 	ldbu	r3,-32487(gp)
81107810:	00bff744 	movi	r2,-35
81107814:	1884703a 	and	r2,r3,r2
81107818:	d0a04645 	stb	r2,-32487(gp)
	    break;
8110781c:	00000806 	br	81107840 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
81107820:	d0a04643 	ldbu	r2,-32487(gp)
81107824:	10800894 	ori	r2,r2,34
81107828:	d0a04645 	stb	r2,-32487(gp)
	    break;
8110782c:	00000406 	br	81107840 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
81107830:	d0204645 	stb	zero,-32487(gp)
	    break;
81107834:	00000206 	br	81107840 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
81107838:	0005883a 	mov	r2,zero
8110783c:	00000806 	br	81107860 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
81107840:	00a00034 	movhi	r2,32768
81107844:	10828404 	addi	r2,r2,2576
81107848:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110784c:	d0a04643 	ldbu	r2,-32487(gp)
81107850:	10c03fcc 	andi	r3,r2,255
81107854:	e0bffe17 	ldw	r2,-8(fp)
81107858:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110785c:	00800044 	movi	r2,1
}
81107860:	e037883a 	mov	sp,fp
81107864:	df000017 	ldw	fp,0(sp)
81107868:	dec00104 	addi	sp,sp,4
8110786c:	f800283a 	ret

81107870 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
81107870:	defffd04 	addi	sp,sp,-12
81107874:	de00012e 	bgeu	sp,et,8110787c <bSSDisplayUpdate+0xc>
81107878:	003b68fa 	trap	3
8110787c:	df000215 	stw	fp,8(sp)
81107880:	df000204 	addi	fp,sp,8
81107884:	2005883a 	mov	r2,r4
81107888:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110788c:	00a00034 	movhi	r2,32768
81107890:	10828404 	addi	r2,r2,2576
81107894:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
81107898:	e0bffe17 	ldw	r2,-8(fp)
8110789c:	10800104 	addi	r2,r2,4
811078a0:	e0ffff03 	ldbu	r3,-4(fp)
811078a4:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
811078a8:	00800044 	movi	r2,1
}
811078ac:	e037883a 	mov	sp,fp
811078b0:	df000017 	ldw	fp,0(sp)
811078b4:	dec00104 	addi	sp,sp,4
811078b8:	f800283a 	ret

811078bc <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
811078bc:	defffd04 	addi	sp,sp,-12
811078c0:	de00012e 	bgeu	sp,et,811078c8 <vSyncHandleIrq+0xc>
811078c4:	003b68fa 	trap	3
811078c8:	df000215 	stw	fp,8(sp)
811078cc:	df000204 	addi	fp,sp,8
811078d0:	e13fff15 	stw	r4,-4(fp)
	// Cast pvContext to viHoldContext's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811078d4:	e0bfff17 	ldw	r2,-4(fp)
811078d8:	e0bffe15 	stw	r2,-8(fp)
	// Use pvContext value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vucN += 1;
811078dc:	d0a04803 	ldbu	r2,-32480(gp)
811078e0:	10800044 	addi	r2,r2,1
811078e4:	d0a04805 	stb	r2,-32480(gp)
}
811078e8:	0001883a 	nop
811078ec:	e037883a 	mov	sp,fp
811078f0:	df000017 	ldw	fp,0(sp)
811078f4:	dec00104 	addi	sp,sp,4
811078f8:	f800283a 	ret

811078fc <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
811078fc:	defffd04 	addi	sp,sp,-12
81107900:	de00012e 	bgeu	sp,et,81107908 <vSyncInitIrq+0xc>
81107904:	003b68fa 	trap	3
81107908:	dfc00215 	stw	ra,8(sp)
8110790c:	df000115 	stw	fp,4(sp)
81107910:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
81107914:	d0a04704 	addi	r2,gp,-32484
81107918:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110791c:	01a04434 	movhi	r6,33040
81107920:	319e2f04 	addi	r6,r6,30908
81107924:	e17fff17 	ldw	r5,-4(fp)
81107928:	01000284 	movi	r4,10
8110792c:	112b28c0 	call	8112b28c <alt_irq_register>
}
81107930:	0001883a 	nop
81107934:	e037883a 	mov	sp,fp
81107938:	dfc00117 	ldw	ra,4(sp)
8110793c:	df000017 	ldw	fp,0(sp)
81107940:	dec00204 	addi	sp,sp,8
81107944:	f800283a 	ret

81107948 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
81107948:	defffc04 	addi	sp,sp,-16
8110794c:	de00012e 	bgeu	sp,et,81107954 <bSyncStatusExtnIrq+0xc>
81107950:	003b68fa 	trap	3
81107954:	dfc00315 	stw	ra,12(sp)
81107958:	df000215 	stw	fp,8(sp)
8110795c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
81107960:	0009883a 	mov	r4,zero
81107964:	11086f80 	call	811086f8 <uliSyncReadReg>
81107968:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110796c:	e0bfff17 	ldw	r2,-4(fp)
81107970:	1000030e 	bge	r2,zero,81107980 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
81107974:	00800044 	movi	r2,1
81107978:	e0bffe15 	stw	r2,-8(fp)
8110797c:	00000106 	br	81107984 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
81107980:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
81107984:	e0bffe17 	ldw	r2,-8(fp)
}
81107988:	e037883a 	mov	sp,fp
8110798c:	dfc00117 	ldw	ra,4(sp)
81107990:	df000017 	ldw	fp,0(sp)
81107994:	dec00204 	addi	sp,sp,8
81107998:	f800283a 	ret

8110799c <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110799c:	defffc04 	addi	sp,sp,-16
811079a0:	de00012e 	bgeu	sp,et,811079a8 <ucSyncStatusState+0xc>
811079a4:	003b68fa 	trap	3
811079a8:	dfc00315 	stw	ra,12(sp)
811079ac:	df000215 	stw	fp,8(sp)
811079b0:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
811079b4:	0009883a 	mov	r4,zero
811079b8:	11086f80 	call	811086f8 <uliSyncReadReg>
811079bc:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
811079c0:	e0bffe17 	ldw	r2,-8(fp)
811079c4:	10803fec 	andhi	r2,r2,255
811079c8:	1004d43a 	srli	r2,r2,16
811079cc:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
811079d0:	e0bfff03 	ldbu	r2,-4(fp)
}
811079d4:	e037883a 	mov	sp,fp
811079d8:	dfc00117 	ldw	ra,4(sp)
811079dc:	df000017 	ldw	fp,0(sp)
811079e0:	dec00204 	addi	sp,sp,8
811079e4:	f800283a 	ret

811079e8 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
811079e8:	defffc04 	addi	sp,sp,-16
811079ec:	de00012e 	bgeu	sp,et,811079f4 <ucSyncStatusErrorCode+0xc>
811079f0:	003b68fa 	trap	3
811079f4:	dfc00315 	stw	ra,12(sp)
811079f8:	df000215 	stw	fp,8(sp)
811079fc:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
81107a00:	0009883a 	mov	r4,zero
81107a04:	11086f80 	call	811086f8 <uliSyncReadReg>
81107a08:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
81107a0c:	e0bffe17 	ldw	r2,-8(fp)
81107a10:	10bfc00c 	andi	r2,r2,65280
81107a14:	1004d23a 	srli	r2,r2,8
81107a18:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
81107a1c:	e0bfff03 	ldbu	r2,-4(fp)
}
81107a20:	e037883a 	mov	sp,fp
81107a24:	dfc00117 	ldw	ra,4(sp)
81107a28:	df000017 	ldw	fp,0(sp)
81107a2c:	dec00204 	addi	sp,sp,8
81107a30:	f800283a 	ret

81107a34 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
81107a34:	defffc04 	addi	sp,sp,-16
81107a38:	de00012e 	bgeu	sp,et,81107a40 <ucSyncStatusCycleNumber+0xc>
81107a3c:	003b68fa 	trap	3
81107a40:	dfc00315 	stw	ra,12(sp)
81107a44:	df000215 	stw	fp,8(sp)
81107a48:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
81107a4c:	0009883a 	mov	r4,zero
81107a50:	11086f80 	call	811086f8 <uliSyncReadReg>
81107a54:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
81107a58:	e0bffe17 	ldw	r2,-8(fp)
81107a5c:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
81107a60:	e0bfff03 	ldbu	r2,-4(fp)
}
81107a64:	e037883a 	mov	sp,fp
81107a68:	dfc00117 	ldw	ra,4(sp)
81107a6c:	df000017 	ldw	fp,0(sp)
81107a70:	dec00204 	addi	sp,sp,8
81107a74:	f800283a 	ret

81107a78 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
81107a78:	defffd04 	addi	sp,sp,-12
81107a7c:	de00012e 	bgeu	sp,et,81107a84 <bSyncSetMbt+0xc>
81107a80:	003b68fa 	trap	3
81107a84:	dfc00215 	stw	ra,8(sp)
81107a88:	df000115 	stw	fp,4(sp)
81107a8c:	df000104 	addi	fp,sp,4
81107a90:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
81107a94:	e17fff17 	ldw	r5,-4(fp)
81107a98:	01000104 	movi	r4,4
81107a9c:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107aa0:	00800044 	movi	r2,1
}
81107aa4:	e037883a 	mov	sp,fp
81107aa8:	dfc00117 	ldw	ra,4(sp)
81107aac:	df000017 	ldw	fp,0(sp)
81107ab0:	dec00204 	addi	sp,sp,8
81107ab4:	f800283a 	ret

81107ab8 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
81107ab8:	defffd04 	addi	sp,sp,-12
81107abc:	de00012e 	bgeu	sp,et,81107ac4 <bSyncSetBt+0xc>
81107ac0:	003b68fa 	trap	3
81107ac4:	dfc00215 	stw	ra,8(sp)
81107ac8:	df000115 	stw	fp,4(sp)
81107acc:	df000104 	addi	fp,sp,4
81107ad0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
81107ad4:	e17fff17 	ldw	r5,-4(fp)
81107ad8:	01000144 	movi	r4,5
81107adc:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107ae0:	00800044 	movi	r2,1
}
81107ae4:	e037883a 	mov	sp,fp
81107ae8:	dfc00117 	ldw	ra,4(sp)
81107aec:	df000017 	ldw	fp,0(sp)
81107af0:	dec00204 	addi	sp,sp,8
81107af4:	f800283a 	ret

81107af8 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
81107af8:	defffd04 	addi	sp,sp,-12
81107afc:	de00012e 	bgeu	sp,et,81107b04 <bSyncSetPer+0xc>
81107b00:	003b68fa 	trap	3
81107b04:	dfc00215 	stw	ra,8(sp)
81107b08:	df000115 	stw	fp,4(sp)
81107b0c:	df000104 	addi	fp,sp,4
81107b10:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
81107b14:	e17fff17 	ldw	r5,-4(fp)
81107b18:	01000184 	movi	r4,6
81107b1c:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107b20:	00800044 	movi	r2,1
}
81107b24:	e037883a 	mov	sp,fp
81107b28:	dfc00117 	ldw	ra,4(sp)
81107b2c:	df000017 	ldw	fp,0(sp)
81107b30:	dec00204 	addi	sp,sp,8
81107b34:	f800283a 	ret

81107b38 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
81107b38:	defffd04 	addi	sp,sp,-12
81107b3c:	de00012e 	bgeu	sp,et,81107b44 <bSyncSetOst+0xc>
81107b40:	003b68fa 	trap	3
81107b44:	dfc00215 	stw	ra,8(sp)
81107b48:	df000115 	stw	fp,4(sp)
81107b4c:	df000104 	addi	fp,sp,4
81107b50:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
81107b54:	e17fff17 	ldw	r5,-4(fp)
81107b58:	010001c4 	movi	r4,7
81107b5c:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107b60:	00800044 	movi	r2,1
}
81107b64:	e037883a 	mov	sp,fp
81107b68:	dfc00117 	ldw	ra,4(sp)
81107b6c:	df000017 	ldw	fp,0(sp)
81107b70:	dec00204 	addi	sp,sp,8
81107b74:	f800283a 	ret

81107b78 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
81107b78:	defffc04 	addi	sp,sp,-16
81107b7c:	de00012e 	bgeu	sp,et,81107b84 <bSyncSetPolarity+0xc>
81107b80:	003b68fa 	trap	3
81107b84:	dfc00315 	stw	ra,12(sp)
81107b88:	df000215 	stw	fp,8(sp)
81107b8c:	df000204 	addi	fp,sp,8
81107b90:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
81107b94:	01000204 	movi	r4,8
81107b98:	11086f80 	call	811086f8 <uliSyncReadReg>
81107b9c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81107ba0:	e0bfff17 	ldw	r2,-4(fp)
81107ba4:	1000051e 	bne	r2,zero,81107bbc <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
81107ba8:	e0fffe17 	ldw	r3,-8(fp)
81107bac:	00bfbfc4 	movi	r2,-257
81107bb0:	1884703a 	and	r2,r3,r2
81107bb4:	e0bffe15 	stw	r2,-8(fp)
81107bb8:	00000306 	br	81107bc8 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
81107bbc:	e0bffe17 	ldw	r2,-8(fp)
81107bc0:	10804014 	ori	r2,r2,256
81107bc4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
81107bc8:	e17ffe17 	ldw	r5,-8(fp)
81107bcc:	01000204 	movi	r4,8
81107bd0:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107bd4:	00800044 	movi	r2,1
}
81107bd8:	e037883a 	mov	sp,fp
81107bdc:	dfc00117 	ldw	ra,4(sp)
81107be0:	df000017 	ldw	fp,0(sp)
81107be4:	dec00204 	addi	sp,sp,8
81107be8:	f800283a 	ret

81107bec <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
81107bec:	defffc04 	addi	sp,sp,-16
81107bf0:	de00012e 	bgeu	sp,et,81107bf8 <bSyncSetNCycles+0xc>
81107bf4:	003b68fa 	trap	3
81107bf8:	dfc00315 	stw	ra,12(sp)
81107bfc:	df000215 	stw	fp,8(sp)
81107c00:	df000204 	addi	fp,sp,8
81107c04:	2005883a 	mov	r2,r4
81107c08:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
81107c0c:	01000204 	movi	r4,8
81107c10:	11086f80 	call	811086f8 <uliSyncReadReg>
81107c14:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
81107c18:	e0fffe17 	ldw	r3,-8(fp)
81107c1c:	00bfc004 	movi	r2,-256
81107c20:	1884703a 	and	r2,r3,r2
81107c24:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
81107c28:	e0bfff03 	ldbu	r2,-4(fp)
81107c2c:	e0fffe17 	ldw	r3,-8(fp)
81107c30:	1884b03a 	or	r2,r3,r2
81107c34:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
81107c38:	e17ffe17 	ldw	r5,-8(fp)
81107c3c:	01000204 	movi	r4,8
81107c40:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107c44:	00800044 	movi	r2,1
}
81107c48:	e037883a 	mov	sp,fp
81107c4c:	dfc00117 	ldw	ra,4(sp)
81107c50:	df000017 	ldw	fp,0(sp)
81107c54:	dec00204 	addi	sp,sp,8
81107c58:	f800283a 	ret

81107c5c <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
81107c5c:	defffd04 	addi	sp,sp,-12
81107c60:	de00012e 	bgeu	sp,et,81107c68 <uliSyncGetMbt+0xc>
81107c64:	003b68fa 	trap	3
81107c68:	dfc00215 	stw	ra,8(sp)
81107c6c:	df000115 	stw	fp,4(sp)
81107c70:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
81107c74:	01000104 	movi	r4,4
81107c78:	11086f80 	call	811086f8 <uliSyncReadReg>
81107c7c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107c80:	e0bfff17 	ldw	r2,-4(fp)
}
81107c84:	e037883a 	mov	sp,fp
81107c88:	dfc00117 	ldw	ra,4(sp)
81107c8c:	df000017 	ldw	fp,0(sp)
81107c90:	dec00204 	addi	sp,sp,8
81107c94:	f800283a 	ret

81107c98 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
81107c98:	defffd04 	addi	sp,sp,-12
81107c9c:	de00012e 	bgeu	sp,et,81107ca4 <uliSyncGetBt+0xc>
81107ca0:	003b68fa 	trap	3
81107ca4:	dfc00215 	stw	ra,8(sp)
81107ca8:	df000115 	stw	fp,4(sp)
81107cac:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
81107cb0:	01000144 	movi	r4,5
81107cb4:	11086f80 	call	811086f8 <uliSyncReadReg>
81107cb8:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107cbc:	e0bfff17 	ldw	r2,-4(fp)
}
81107cc0:	e037883a 	mov	sp,fp
81107cc4:	dfc00117 	ldw	ra,4(sp)
81107cc8:	df000017 	ldw	fp,0(sp)
81107ccc:	dec00204 	addi	sp,sp,8
81107cd0:	f800283a 	ret

81107cd4 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
81107cd4:	defffd04 	addi	sp,sp,-12
81107cd8:	de00012e 	bgeu	sp,et,81107ce0 <uliSyncGetPer+0xc>
81107cdc:	003b68fa 	trap	3
81107ce0:	dfc00215 	stw	ra,8(sp)
81107ce4:	df000115 	stw	fp,4(sp)
81107ce8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
81107cec:	01000184 	movi	r4,6
81107cf0:	11086f80 	call	811086f8 <uliSyncReadReg>
81107cf4:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107cf8:	e0bfff17 	ldw	r2,-4(fp)
}
81107cfc:	e037883a 	mov	sp,fp
81107d00:	dfc00117 	ldw	ra,4(sp)
81107d04:	df000017 	ldw	fp,0(sp)
81107d08:	dec00204 	addi	sp,sp,8
81107d0c:	f800283a 	ret

81107d10 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
81107d10:	defffd04 	addi	sp,sp,-12
81107d14:	de00012e 	bgeu	sp,et,81107d1c <uliSyncGetOst+0xc>
81107d18:	003b68fa 	trap	3
81107d1c:	dfc00215 	stw	ra,8(sp)
81107d20:	df000115 	stw	fp,4(sp)
81107d24:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
81107d28:	010001c4 	movi	r4,7
81107d2c:	11086f80 	call	811086f8 <uliSyncReadReg>
81107d30:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107d34:	e0bfff17 	ldw	r2,-4(fp)
}
81107d38:	e037883a 	mov	sp,fp
81107d3c:	dfc00117 	ldw	ra,4(sp)
81107d40:	df000017 	ldw	fp,0(sp)
81107d44:	dec00204 	addi	sp,sp,8
81107d48:	f800283a 	ret

81107d4c <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
81107d4c:	defffd04 	addi	sp,sp,-12
81107d50:	de00012e 	bgeu	sp,et,81107d58 <uliSyncGetGeneral+0xc>
81107d54:	003b68fa 	trap	3
81107d58:	dfc00215 	stw	ra,8(sp)
81107d5c:	df000115 	stw	fp,4(sp)
81107d60:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
81107d64:	01000204 	movi	r4,8
81107d68:	11086f80 	call	811086f8 <uliSyncReadReg>
81107d6c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107d70:	e0bfff17 	ldw	r2,-4(fp)
}
81107d74:	e037883a 	mov	sp,fp
81107d78:	dfc00117 	ldw	ra,4(sp)
81107d7c:	df000017 	ldw	fp,0(sp)
81107d80:	dec00204 	addi	sp,sp,8
81107d84:	f800283a 	ret

81107d88 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
81107d88:	defffd04 	addi	sp,sp,-12
81107d8c:	de00012e 	bgeu	sp,et,81107d94 <bSyncErrInj+0xc>
81107d90:	003b68fa 	trap	3
81107d94:	dfc00215 	stw	ra,8(sp)
81107d98:	df000115 	stw	fp,4(sp)
81107d9c:	df000104 	addi	fp,sp,4
81107da0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
81107da4:	e17fff17 	ldw	r5,-4(fp)
81107da8:	01000244 	movi	r4,9
81107dac:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107db0:	00800044 	movi	r2,1
}
81107db4:	e037883a 	mov	sp,fp
81107db8:	dfc00117 	ldw	ra,4(sp)
81107dbc:	df000017 	ldw	fp,0(sp)
81107dc0:	dec00204 	addi	sp,sp,8
81107dc4:	f800283a 	ret

81107dc8 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
81107dc8:	defffc04 	addi	sp,sp,-16
81107dcc:	de00012e 	bgeu	sp,et,81107dd4 <bSyncCtrExtnIrq+0xc>
81107dd0:	003b68fa 	trap	3
81107dd4:	dfc00315 	stw	ra,12(sp)
81107dd8:	df000215 	stw	fp,8(sp)
81107ddc:	df000204 	addi	fp,sp,8
81107de0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107de4:	01000284 	movi	r4,10
81107de8:	11086f80 	call	811086f8 <uliSyncReadReg>
81107dec:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81107df0:	e0bfff17 	ldw	r2,-4(fp)
81107df4:	1000061e 	bne	r2,zero,81107e10 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
81107df8:	e0fffe17 	ldw	r3,-8(fp)
81107dfc:	00a00034 	movhi	r2,32768
81107e00:	10bfffc4 	addi	r2,r2,-1
81107e04:	1884703a 	and	r2,r3,r2
81107e08:	e0bffe15 	stw	r2,-8(fp)
81107e0c:	00000306 	br	81107e1c <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
81107e10:	e0bffe17 	ldw	r2,-8(fp)
81107e14:	10a00034 	orhi	r2,r2,32768
81107e18:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107e1c:	e17ffe17 	ldw	r5,-8(fp)
81107e20:	01000284 	movi	r4,10
81107e24:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107e28:	00800044 	movi	r2,1
}
81107e2c:	e037883a 	mov	sp,fp
81107e30:	dfc00117 	ldw	ra,4(sp)
81107e34:	df000017 	ldw	fp,0(sp)
81107e38:	dec00204 	addi	sp,sp,8
81107e3c:	f800283a 	ret

81107e40 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
81107e40:	defffd04 	addi	sp,sp,-12
81107e44:	de00012e 	bgeu	sp,et,81107e4c <bSyncCtrStart+0xc>
81107e48:	003b68fa 	trap	3
81107e4c:	dfc00215 	stw	ra,8(sp)
81107e50:	df000115 	stw	fp,4(sp)
81107e54:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107e58:	01000284 	movi	r4,10
81107e5c:	11086f80 	call	811086f8 <uliSyncReadReg>
81107e60:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
81107e64:	e0bfff17 	ldw	r2,-4(fp)
81107e68:	10800234 	orhi	r2,r2,8
81107e6c:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107e70:	e17fff17 	ldw	r5,-4(fp)
81107e74:	01000284 	movi	r4,10
81107e78:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107e7c:	00800044 	movi	r2,1
}
81107e80:	e037883a 	mov	sp,fp
81107e84:	dfc00117 	ldw	ra,4(sp)
81107e88:	df000017 	ldw	fp,0(sp)
81107e8c:	dec00204 	addi	sp,sp,8
81107e90:	f800283a 	ret

81107e94 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
81107e94:	defffd04 	addi	sp,sp,-12
81107e98:	de00012e 	bgeu	sp,et,81107ea0 <bSyncCtrReset+0xc>
81107e9c:	003b68fa 	trap	3
81107ea0:	dfc00215 	stw	ra,8(sp)
81107ea4:	df000115 	stw	fp,4(sp)
81107ea8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107eac:	01000284 	movi	r4,10
81107eb0:	11086f80 	call	811086f8 <uliSyncReadReg>
81107eb4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
81107eb8:	e0bfff17 	ldw	r2,-4(fp)
81107ebc:	10800134 	orhi	r2,r2,4
81107ec0:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107ec4:	e17fff17 	ldw	r5,-4(fp)
81107ec8:	01000284 	movi	r4,10
81107ecc:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107ed0:	00800044 	movi	r2,1
}
81107ed4:	e037883a 	mov	sp,fp
81107ed8:	dfc00117 	ldw	ra,4(sp)
81107edc:	df000017 	ldw	fp,0(sp)
81107ee0:	dec00204 	addi	sp,sp,8
81107ee4:	f800283a 	ret

81107ee8 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
81107ee8:	defffd04 	addi	sp,sp,-12
81107eec:	de00012e 	bgeu	sp,et,81107ef4 <bSyncCtrOneShot+0xc>
81107ef0:	003b68fa 	trap	3
81107ef4:	dfc00215 	stw	ra,8(sp)
81107ef8:	df000115 	stw	fp,4(sp)
81107efc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107f00:	01000284 	movi	r4,10
81107f04:	11086f80 	call	811086f8 <uliSyncReadReg>
81107f08:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
81107f0c:	e0bfff17 	ldw	r2,-4(fp)
81107f10:	108000b4 	orhi	r2,r2,2
81107f14:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107f18:	e17fff17 	ldw	r5,-4(fp)
81107f1c:	01000284 	movi	r4,10
81107f20:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107f24:	00800044 	movi	r2,1
}
81107f28:	e037883a 	mov	sp,fp
81107f2c:	dfc00117 	ldw	ra,4(sp)
81107f30:	df000017 	ldw	fp,0(sp)
81107f34:	dec00204 	addi	sp,sp,8
81107f38:	f800283a 	ret

81107f3c <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
81107f3c:	defffd04 	addi	sp,sp,-12
81107f40:	de00012e 	bgeu	sp,et,81107f48 <bSyncCtrErrInj+0xc>
81107f44:	003b68fa 	trap	3
81107f48:	dfc00215 	stw	ra,8(sp)
81107f4c:	df000115 	stw	fp,4(sp)
81107f50:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107f54:	01000284 	movi	r4,10
81107f58:	11086f80 	call	811086f8 <uliSyncReadReg>
81107f5c:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
81107f60:	e0bfff17 	ldw	r2,-4(fp)
81107f64:	10800074 	orhi	r2,r2,1
81107f68:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107f6c:	e17fff17 	ldw	r5,-4(fp)
81107f70:	01000284 	movi	r4,10
81107f74:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107f78:	00800044 	movi	r2,1
}
81107f7c:	e037883a 	mov	sp,fp
81107f80:	dfc00117 	ldw	ra,4(sp)
81107f84:	df000017 	ldw	fp,0(sp)
81107f88:	dec00204 	addi	sp,sp,8
81107f8c:	f800283a 	ret

81107f90 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
81107f90:	defffc04 	addi	sp,sp,-16
81107f94:	de00012e 	bgeu	sp,et,81107f9c <bSyncCtrSyncOutEnable+0xc>
81107f98:	003b68fa 	trap	3
81107f9c:	dfc00315 	stw	ra,12(sp)
81107fa0:	df000215 	stw	fp,8(sp)
81107fa4:	df000204 	addi	fp,sp,8
81107fa8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107fac:	01000284 	movi	r4,10
81107fb0:	11086f80 	call	811086f8 <uliSyncReadReg>
81107fb4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81107fb8:	e0bfff17 	ldw	r2,-4(fp)
81107fbc:	1000051e 	bne	r2,zero,81107fd4 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
81107fc0:	e0fffe17 	ldw	r3,-8(fp)
81107fc4:	00bfbfc4 	movi	r2,-257
81107fc8:	1884703a 	and	r2,r3,r2
81107fcc:	e0bffe15 	stw	r2,-8(fp)
81107fd0:	00000306 	br	81107fe0 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
81107fd4:	e0bffe17 	ldw	r2,-8(fp)
81107fd8:	10804014 	ori	r2,r2,256
81107fdc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107fe0:	e17ffe17 	ldw	r5,-8(fp)
81107fe4:	01000284 	movi	r4,10
81107fe8:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81107fec:	00800044 	movi	r2,1
}
81107ff0:	e037883a 	mov	sp,fp
81107ff4:	dfc00117 	ldw	ra,4(sp)
81107ff8:	df000017 	ldw	fp,0(sp)
81107ffc:	dec00204 	addi	sp,sp,8
81108000:	f800283a 	ret

81108004 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
81108004:	defffc04 	addi	sp,sp,-16
81108008:	de00012e 	bgeu	sp,et,81108010 <bSyncCtrCh1OutEnable+0xc>
8110800c:	003b68fa 	trap	3
81108010:	dfc00315 	stw	ra,12(sp)
81108014:	df000215 	stw	fp,8(sp)
81108018:	df000204 	addi	fp,sp,8
8110801c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108020:	01000284 	movi	r4,10
81108024:	11086f80 	call	811086f8 <uliSyncReadReg>
81108028:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110802c:	e0bfff17 	ldw	r2,-4(fp)
81108030:	1000051e 	bne	r2,zero,81108048 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
81108034:	e0fffe17 	ldw	r3,-8(fp)
81108038:	00bfff84 	movi	r2,-2
8110803c:	1884703a 	and	r2,r3,r2
81108040:	e0bffe15 	stw	r2,-8(fp)
81108044:	00000306 	br	81108054 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
81108048:	e0bffe17 	ldw	r2,-8(fp)
8110804c:	10800054 	ori	r2,r2,1
81108050:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108054:	e17ffe17 	ldw	r5,-8(fp)
81108058:	01000284 	movi	r4,10
8110805c:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81108060:	00800044 	movi	r2,1
}
81108064:	e037883a 	mov	sp,fp
81108068:	dfc00117 	ldw	ra,4(sp)
8110806c:	df000017 	ldw	fp,0(sp)
81108070:	dec00204 	addi	sp,sp,8
81108074:	f800283a 	ret

81108078 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
81108078:	defffc04 	addi	sp,sp,-16
8110807c:	de00012e 	bgeu	sp,et,81108084 <bSyncCtrCh2OutEnable+0xc>
81108080:	003b68fa 	trap	3
81108084:	dfc00315 	stw	ra,12(sp)
81108088:	df000215 	stw	fp,8(sp)
8110808c:	df000204 	addi	fp,sp,8
81108090:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108094:	01000284 	movi	r4,10
81108098:	11086f80 	call	811086f8 <uliSyncReadReg>
8110809c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811080a0:	e0bfff17 	ldw	r2,-4(fp)
811080a4:	1000051e 	bne	r2,zero,811080bc <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
811080a8:	e0fffe17 	ldw	r3,-8(fp)
811080ac:	00bfff44 	movi	r2,-3
811080b0:	1884703a 	and	r2,r3,r2
811080b4:	e0bffe15 	stw	r2,-8(fp)
811080b8:	00000306 	br	811080c8 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
811080bc:	e0bffe17 	ldw	r2,-8(fp)
811080c0:	10800094 	ori	r2,r2,2
811080c4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
811080c8:	e17ffe17 	ldw	r5,-8(fp)
811080cc:	01000284 	movi	r4,10
811080d0:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
811080d4:	00800044 	movi	r2,1
}
811080d8:	e037883a 	mov	sp,fp
811080dc:	dfc00117 	ldw	ra,4(sp)
811080e0:	df000017 	ldw	fp,0(sp)
811080e4:	dec00204 	addi	sp,sp,8
811080e8:	f800283a 	ret

811080ec <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
811080ec:	defffc04 	addi	sp,sp,-16
811080f0:	de00012e 	bgeu	sp,et,811080f8 <bSyncCtrCh3OutEnable+0xc>
811080f4:	003b68fa 	trap	3
811080f8:	dfc00315 	stw	ra,12(sp)
811080fc:	df000215 	stw	fp,8(sp)
81108100:	df000204 	addi	fp,sp,8
81108104:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108108:	01000284 	movi	r4,10
8110810c:	11086f80 	call	811086f8 <uliSyncReadReg>
81108110:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108114:	e0bfff17 	ldw	r2,-4(fp)
81108118:	1000051e 	bne	r2,zero,81108130 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110811c:	e0fffe17 	ldw	r3,-8(fp)
81108120:	00bffec4 	movi	r2,-5
81108124:	1884703a 	and	r2,r3,r2
81108128:	e0bffe15 	stw	r2,-8(fp)
8110812c:	00000306 	br	8110813c <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
81108130:	e0bffe17 	ldw	r2,-8(fp)
81108134:	10800114 	ori	r2,r2,4
81108138:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110813c:	e17ffe17 	ldw	r5,-8(fp)
81108140:	01000284 	movi	r4,10
81108144:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81108148:	00800044 	movi	r2,1
}
8110814c:	e037883a 	mov	sp,fp
81108150:	dfc00117 	ldw	ra,4(sp)
81108154:	df000017 	ldw	fp,0(sp)
81108158:	dec00204 	addi	sp,sp,8
8110815c:	f800283a 	ret

81108160 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
81108160:	defffc04 	addi	sp,sp,-16
81108164:	de00012e 	bgeu	sp,et,8110816c <bSyncCtrCh4OutEnable+0xc>
81108168:	003b68fa 	trap	3
8110816c:	dfc00315 	stw	ra,12(sp)
81108170:	df000215 	stw	fp,8(sp)
81108174:	df000204 	addi	fp,sp,8
81108178:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110817c:	01000284 	movi	r4,10
81108180:	11086f80 	call	811086f8 <uliSyncReadReg>
81108184:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108188:	e0bfff17 	ldw	r2,-4(fp)
8110818c:	1000051e 	bne	r2,zero,811081a4 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
81108190:	e0fffe17 	ldw	r3,-8(fp)
81108194:	00bffdc4 	movi	r2,-9
81108198:	1884703a 	and	r2,r3,r2
8110819c:	e0bffe15 	stw	r2,-8(fp)
811081a0:	00000306 	br	811081b0 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
811081a4:	e0bffe17 	ldw	r2,-8(fp)
811081a8:	10800214 	ori	r2,r2,8
811081ac:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
811081b0:	e17ffe17 	ldw	r5,-8(fp)
811081b4:	01000284 	movi	r4,10
811081b8:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
811081bc:	00800044 	movi	r2,1
}
811081c0:	e037883a 	mov	sp,fp
811081c4:	dfc00117 	ldw	ra,4(sp)
811081c8:	df000017 	ldw	fp,0(sp)
811081cc:	dec00204 	addi	sp,sp,8
811081d0:	f800283a 	ret

811081d4 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
811081d4:	defffc04 	addi	sp,sp,-16
811081d8:	de00012e 	bgeu	sp,et,811081e0 <bSyncCtrCh5OutEnable+0xc>
811081dc:	003b68fa 	trap	3
811081e0:	dfc00315 	stw	ra,12(sp)
811081e4:	df000215 	stw	fp,8(sp)
811081e8:	df000204 	addi	fp,sp,8
811081ec:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
811081f0:	01000284 	movi	r4,10
811081f4:	11086f80 	call	811086f8 <uliSyncReadReg>
811081f8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811081fc:	e0bfff17 	ldw	r2,-4(fp)
81108200:	1000051e 	bne	r2,zero,81108218 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
81108204:	e0fffe17 	ldw	r3,-8(fp)
81108208:	00bffbc4 	movi	r2,-17
8110820c:	1884703a 	and	r2,r3,r2
81108210:	e0bffe15 	stw	r2,-8(fp)
81108214:	00000306 	br	81108224 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
81108218:	e0bffe17 	ldw	r2,-8(fp)
8110821c:	10800414 	ori	r2,r2,16
81108220:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108224:	e17ffe17 	ldw	r5,-8(fp)
81108228:	01000284 	movi	r4,10
8110822c:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81108230:	00800044 	movi	r2,1
}
81108234:	e037883a 	mov	sp,fp
81108238:	dfc00117 	ldw	ra,4(sp)
8110823c:	df000017 	ldw	fp,0(sp)
81108240:	dec00204 	addi	sp,sp,8
81108244:	f800283a 	ret

81108248 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
81108248:	defffc04 	addi	sp,sp,-16
8110824c:	de00012e 	bgeu	sp,et,81108254 <bSyncCtrCh6OutEnable+0xc>
81108250:	003b68fa 	trap	3
81108254:	dfc00315 	stw	ra,12(sp)
81108258:	df000215 	stw	fp,8(sp)
8110825c:	df000204 	addi	fp,sp,8
81108260:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108264:	01000284 	movi	r4,10
81108268:	11086f80 	call	811086f8 <uliSyncReadReg>
8110826c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108270:	e0bfff17 	ldw	r2,-4(fp)
81108274:	1000051e 	bne	r2,zero,8110828c <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
81108278:	e0fffe17 	ldw	r3,-8(fp)
8110827c:	00bff7c4 	movi	r2,-33
81108280:	1884703a 	and	r2,r3,r2
81108284:	e0bffe15 	stw	r2,-8(fp)
81108288:	00000306 	br	81108298 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110828c:	e0bffe17 	ldw	r2,-8(fp)
81108290:	10800814 	ori	r2,r2,32
81108294:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108298:	e17ffe17 	ldw	r5,-8(fp)
8110829c:	01000284 	movi	r4,10
811082a0:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
811082a4:	00800044 	movi	r2,1
}
811082a8:	e037883a 	mov	sp,fp
811082ac:	dfc00117 	ldw	ra,4(sp)
811082b0:	df000017 	ldw	fp,0(sp)
811082b4:	dec00204 	addi	sp,sp,8
811082b8:	f800283a 	ret

811082bc <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
811082bc:	defffc04 	addi	sp,sp,-16
811082c0:	de00012e 	bgeu	sp,et,811082c8 <bSyncCtrCh7OutEnable+0xc>
811082c4:	003b68fa 	trap	3
811082c8:	dfc00315 	stw	ra,12(sp)
811082cc:	df000215 	stw	fp,8(sp)
811082d0:	df000204 	addi	fp,sp,8
811082d4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
811082d8:	01000284 	movi	r4,10
811082dc:	11086f80 	call	811086f8 <uliSyncReadReg>
811082e0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811082e4:	e0bfff17 	ldw	r2,-4(fp)
811082e8:	1000051e 	bne	r2,zero,81108300 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
811082ec:	e0fffe17 	ldw	r3,-8(fp)
811082f0:	00bfefc4 	movi	r2,-65
811082f4:	1884703a 	and	r2,r3,r2
811082f8:	e0bffe15 	stw	r2,-8(fp)
811082fc:	00000306 	br	8110830c <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
81108300:	e0bffe17 	ldw	r2,-8(fp)
81108304:	10801014 	ori	r2,r2,64
81108308:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110830c:	e17ffe17 	ldw	r5,-8(fp)
81108310:	01000284 	movi	r4,10
81108314:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81108318:	00800044 	movi	r2,1
}
8110831c:	e037883a 	mov	sp,fp
81108320:	dfc00117 	ldw	ra,4(sp)
81108324:	df000017 	ldw	fp,0(sp)
81108328:	dec00204 	addi	sp,sp,8
8110832c:	f800283a 	ret

81108330 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
81108330:	defffc04 	addi	sp,sp,-16
81108334:	de00012e 	bgeu	sp,et,8110833c <bSyncCtrCh8OutEnable+0xc>
81108338:	003b68fa 	trap	3
8110833c:	dfc00315 	stw	ra,12(sp)
81108340:	df000215 	stw	fp,8(sp)
81108344:	df000204 	addi	fp,sp,8
81108348:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110834c:	01000284 	movi	r4,10
81108350:	11086f80 	call	811086f8 <uliSyncReadReg>
81108354:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108358:	e0bfff17 	ldw	r2,-4(fp)
8110835c:	1000051e 	bne	r2,zero,81108374 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
81108360:	e0fffe17 	ldw	r3,-8(fp)
81108364:	00bfdfc4 	movi	r2,-129
81108368:	1884703a 	and	r2,r3,r2
8110836c:	e0bffe15 	stw	r2,-8(fp)
81108370:	00000306 	br	81108380 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
81108374:	e0bffe17 	ldw	r2,-8(fp)
81108378:	10802014 	ori	r2,r2,128
8110837c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108380:	e17ffe17 	ldw	r5,-8(fp)
81108384:	01000284 	movi	r4,10
81108388:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
8110838c:	00800044 	movi	r2,1
}
81108390:	e037883a 	mov	sp,fp
81108394:	dfc00117 	ldw	ra,4(sp)
81108398:	df000017 	ldw	fp,0(sp)
8110839c:	dec00204 	addi	sp,sp,8
811083a0:	f800283a 	ret

811083a4 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
811083a4:	defffc04 	addi	sp,sp,-16
811083a8:	de00012e 	bgeu	sp,et,811083b0 <bSyncIrqEnableError+0xc>
811083ac:	003b68fa 	trap	3
811083b0:	dfc00315 	stw	ra,12(sp)
811083b4:	df000215 	stw	fp,8(sp)
811083b8:	df000204 	addi	fp,sp,8
811083bc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
811083c0:	01000044 	movi	r4,1
811083c4:	11086f80 	call	811086f8 <uliSyncReadReg>
811083c8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811083cc:	e0bfff17 	ldw	r2,-4(fp)
811083d0:	1000051e 	bne	r2,zero,811083e8 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
811083d4:	e0fffe17 	ldw	r3,-8(fp)
811083d8:	00bfff44 	movi	r2,-3
811083dc:	1884703a 	and	r2,r3,r2
811083e0:	e0bffe15 	stw	r2,-8(fp)
811083e4:	00000306 	br	811083f4 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
811083e8:	e0bffe17 	ldw	r2,-8(fp)
811083ec:	10800094 	ori	r2,r2,2
811083f0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
811083f4:	e17ffe17 	ldw	r5,-8(fp)
811083f8:	01000044 	movi	r4,1
811083fc:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81108400:	00800044 	movi	r2,1
}
81108404:	e037883a 	mov	sp,fp
81108408:	dfc00117 	ldw	ra,4(sp)
8110840c:	df000017 	ldw	fp,0(sp)
81108410:	dec00204 	addi	sp,sp,8
81108414:	f800283a 	ret

81108418 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
81108418:	defffc04 	addi	sp,sp,-16
8110841c:	de00012e 	bgeu	sp,et,81108424 <bSyncIrqEnableBlank+0xc>
81108420:	003b68fa 	trap	3
81108424:	dfc00315 	stw	ra,12(sp)
81108428:	df000215 	stw	fp,8(sp)
8110842c:	df000204 	addi	fp,sp,8
81108430:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
81108434:	01000044 	movi	r4,1
81108438:	11086f80 	call	811086f8 <uliSyncReadReg>
8110843c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108440:	e0bfff17 	ldw	r2,-4(fp)
81108444:	1000051e 	bne	r2,zero,8110845c <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
81108448:	e0fffe17 	ldw	r3,-8(fp)
8110844c:	00bfff84 	movi	r2,-2
81108450:	1884703a 	and	r2,r3,r2
81108454:	e0bffe15 	stw	r2,-8(fp)
81108458:	00000306 	br	81108468 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110845c:	e0bffe17 	ldw	r2,-8(fp)
81108460:	10800054 	ori	r2,r2,1
81108464:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
81108468:	e17ffe17 	ldw	r5,-8(fp)
8110846c:	01000044 	movi	r4,1
81108470:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
81108474:	00800044 	movi	r2,1
}
81108478:	e037883a 	mov	sp,fp
8110847c:	dfc00117 	ldw	ra,4(sp)
81108480:	df000017 	ldw	fp,0(sp)
81108484:	dec00204 	addi	sp,sp,8
81108488:	f800283a 	ret

8110848c <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110848c:	defffc04 	addi	sp,sp,-16
81108490:	de00012e 	bgeu	sp,et,81108498 <bSyncIrqFlagClrError+0xc>
81108494:	003b68fa 	trap	3
81108498:	dfc00315 	stw	ra,12(sp)
8110849c:	df000215 	stw	fp,8(sp)
811084a0:	df000204 	addi	fp,sp,8
811084a4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
811084a8:	01000084 	movi	r4,2
811084ac:	11086f80 	call	811086f8 <uliSyncReadReg>
811084b0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811084b4:	e0bfff17 	ldw	r2,-4(fp)
811084b8:	1000051e 	bne	r2,zero,811084d0 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
811084bc:	e0fffe17 	ldw	r3,-8(fp)
811084c0:	00bfff44 	movi	r2,-3
811084c4:	1884703a 	and	r2,r3,r2
811084c8:	e0bffe15 	stw	r2,-8(fp)
811084cc:	00000306 	br	811084dc <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
811084d0:	e0bffe17 	ldw	r2,-8(fp)
811084d4:	10800094 	ori	r2,r2,2
811084d8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
811084dc:	e17ffe17 	ldw	r5,-8(fp)
811084e0:	01000084 	movi	r4,2
811084e4:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
811084e8:	00800044 	movi	r2,1
}
811084ec:	e037883a 	mov	sp,fp
811084f0:	dfc00117 	ldw	ra,4(sp)
811084f4:	df000017 	ldw	fp,0(sp)
811084f8:	dec00204 	addi	sp,sp,8
811084fc:	f800283a 	ret

81108500 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
81108500:	defffc04 	addi	sp,sp,-16
81108504:	de00012e 	bgeu	sp,et,8110850c <bSyncIrqFlagClrBlank+0xc>
81108508:	003b68fa 	trap	3
8110850c:	dfc00315 	stw	ra,12(sp)
81108510:	df000215 	stw	fp,8(sp)
81108514:	df000204 	addi	fp,sp,8
81108518:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110851c:	01000084 	movi	r4,2
81108520:	11086f80 	call	811086f8 <uliSyncReadReg>
81108524:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108528:	e0bfff17 	ldw	r2,-4(fp)
8110852c:	1000051e 	bne	r2,zero,81108544 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
81108530:	e0fffe17 	ldw	r3,-8(fp)
81108534:	00bfff84 	movi	r2,-2
81108538:	1884703a 	and	r2,r3,r2
8110853c:	e0bffe15 	stw	r2,-8(fp)
81108540:	00000306 	br	81108550 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
81108544:	e0bffe17 	ldw	r2,-8(fp)
81108548:	10800054 	ori	r2,r2,1
8110854c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
81108550:	e17ffe17 	ldw	r5,-8(fp)
81108554:	01000084 	movi	r4,2
81108558:	110869c0 	call	8110869c <bSyncWriteReg>
	return TRUE;
8110855c:	00800044 	movi	r2,1
}
81108560:	e037883a 	mov	sp,fp
81108564:	dfc00117 	ldw	ra,4(sp)
81108568:	df000017 	ldw	fp,0(sp)
8110856c:	dec00204 	addi	sp,sp,8
81108570:	f800283a 	ret

81108574 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
81108574:	defffc04 	addi	sp,sp,-16
81108578:	de00012e 	bgeu	sp,et,81108580 <bSyncIrqFlagError+0xc>
8110857c:	003b68fa 	trap	3
81108580:	dfc00315 	stw	ra,12(sp)
81108584:	df000215 	stw	fp,8(sp)
81108588:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110858c:	010000c4 	movi	r4,3
81108590:	11086f80 	call	811086f8 <uliSyncReadReg>
81108594:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
81108598:	e0bfff17 	ldw	r2,-4(fp)
8110859c:	1080008c 	andi	r2,r2,2
811085a0:	10000326 	beq	r2,zero,811085b0 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
811085a4:	00800044 	movi	r2,1
811085a8:	e0bffe15 	stw	r2,-8(fp)
811085ac:	00000106 	br	811085b4 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
811085b0:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
811085b4:	e0bffe17 	ldw	r2,-8(fp)
}
811085b8:	e037883a 	mov	sp,fp
811085bc:	dfc00117 	ldw	ra,4(sp)
811085c0:	df000017 	ldw	fp,0(sp)
811085c4:	dec00204 	addi	sp,sp,8
811085c8:	f800283a 	ret

811085cc <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
811085cc:	defffc04 	addi	sp,sp,-16
811085d0:	de00012e 	bgeu	sp,et,811085d8 <bSyncIrqFlagBlank+0xc>
811085d4:	003b68fa 	trap	3
811085d8:	dfc00315 	stw	ra,12(sp)
811085dc:	df000215 	stw	fp,8(sp)
811085e0:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
811085e4:	010000c4 	movi	r4,3
811085e8:	11086f80 	call	811086f8 <uliSyncReadReg>
811085ec:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
811085f0:	e0bfff17 	ldw	r2,-4(fp)
811085f4:	1080004c 	andi	r2,r2,1
811085f8:	10000326 	beq	r2,zero,81108608 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
811085fc:	00800044 	movi	r2,1
81108600:	e0bffe15 	stw	r2,-8(fp)
81108604:	00000106 	br	8110860c <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
81108608:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110860c:	e0bffe17 	ldw	r2,-8(fp)
}
81108610:	e037883a 	mov	sp,fp
81108614:	dfc00117 	ldw	ra,4(sp)
81108618:	df000017 	ldw	fp,0(sp)
8110861c:	dec00204 	addi	sp,sp,8
81108620:	f800283a 	ret

81108624 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
81108624:	defffd04 	addi	sp,sp,-12
81108628:	de00012e 	bgeu	sp,et,81108630 <uliSyncGetCtr+0xc>
8110862c:	003b68fa 	trap	3
81108630:	dfc00215 	stw	ra,8(sp)
81108634:	df000115 	stw	fp,4(sp)
81108638:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110863c:	01000284 	movi	r4,10
81108640:	11086f80 	call	811086f8 <uliSyncReadReg>
81108644:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81108648:	e0bfff17 	ldw	r2,-4(fp)
}
8110864c:	e037883a 	mov	sp,fp
81108650:	dfc00117 	ldw	ra,4(sp)
81108654:	df000017 	ldw	fp,0(sp)
81108658:	dec00204 	addi	sp,sp,8
8110865c:	f800283a 	ret

81108660 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
81108660:	defffd04 	addi	sp,sp,-12
81108664:	de00012e 	bgeu	sp,et,8110866c <uliSyncReadStatus+0xc>
81108668:	003b68fa 	trap	3
8110866c:	dfc00215 	stw	ra,8(sp)
81108670:	df000115 	stw	fp,4(sp)
81108674:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
81108678:	0009883a 	mov	r4,zero
8110867c:	11086f80 	call	811086f8 <uliSyncReadReg>
81108680:	e0bfff15 	stw	r2,-4(fp)
	return aux;
81108684:	e0bfff17 	ldw	r2,-4(fp)
}
81108688:	e037883a 	mov	sp,fp
8110868c:	dfc00117 	ldw	ra,4(sp)
81108690:	df000017 	ldw	fp,0(sp)
81108694:	dec00204 	addi	sp,sp,8
81108698:	f800283a 	ret

8110869c <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
static bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110869c:	defffc04 	addi	sp,sp,-16
811086a0:	de00012e 	bgeu	sp,et,811086a8 <bSyncWriteReg+0xc>
811086a4:	003b68fa 	trap	3
811086a8:	df000315 	stw	fp,12(sp)
811086ac:	df000304 	addi	fp,sp,12
811086b0:	e13ffe15 	stw	r4,-8(fp)
811086b4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
811086b8:	00a00034 	movhi	r2,32768
811086bc:	10810004 	addi	r2,r2,1024
811086c0:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
811086c4:	e0bffe17 	ldw	r2,-8(fp)
811086c8:	1085883a 	add	r2,r2,r2
811086cc:	1085883a 	add	r2,r2,r2
811086d0:	1007883a 	mov	r3,r2
811086d4:	e0bffd17 	ldw	r2,-12(fp)
811086d8:	10c5883a 	add	r2,r2,r3
811086dc:	e0ffff17 	ldw	r3,-4(fp)
811086e0:	10c00015 	stw	r3,0(r2)
	return TRUE;
811086e4:	00800044 	movi	r2,1
}
811086e8:	e037883a 	mov	sp,fp
811086ec:	df000017 	ldw	fp,0(sp)
811086f0:	dec00104 	addi	sp,sp,4
811086f4:	f800283a 	ret

811086f8 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
static alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
811086f8:	defffc04 	addi	sp,sp,-16
811086fc:	de00012e 	bgeu	sp,et,81108704 <uliSyncReadReg+0xc>
81108700:	003b68fa 	trap	3
81108704:	df000315 	stw	fp,12(sp)
81108708:	df000304 	addi	fp,sp,12
8110870c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
81108710:	00a00034 	movhi	r2,32768
81108714:	10810004 	addi	r2,r2,1024
81108718:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110871c:	e0bfff17 	ldw	r2,-4(fp)
81108720:	1085883a 	add	r2,r2,r2
81108724:	1085883a 	add	r2,r2,r2
81108728:	1007883a 	mov	r3,r2
8110872c:	e0bffd17 	ldw	r2,-12(fp)
81108730:	10c5883a 	add	r2,r2,r3
81108734:	10800017 	ldw	r2,0(r2)
81108738:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110873c:	e0bffe17 	ldw	r2,-8(fp)
}
81108740:	e037883a 	mov	sp,fp
81108744:	df000017 	ldw	fp,0(sp)
81108748:	dec00104 	addi	sp,sp,4
8110874c:	f800283a 	ret

81108750 <vDataControlTask>:


#include "data_control_task.h"


void vDataControlTask(void *task_data) {
81108750:	defffb04 	addi	sp,sp,-20
81108754:	de00012e 	bgeu	sp,et,8110875c <vDataControlTask+0xc>
81108758:	003b68fa 	trap	3
8110875c:	dfc00415 	stw	ra,16(sp)
81108760:	df000315 	stw	fp,12(sp)
81108764:	df000304 	addi	fp,sp,12
81108768:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110876c:	e03ffd15 	stw	zero,-12(fp)
	TNData_Control *pxDataC;
	INT8U error_code;


	pxDataC = (TNData_Control *) task_data;
81108770:	e0bfff17 	ldw	r2,-4(fp)
81108774:	e0bffe15 	stw	r2,-8(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
81108778:	d0a05417 	ldw	r2,-32432(gp)
8110877c:	100f883a 	mov	r7,r2
81108780:	01800804 	movi	r6,32
81108784:	01400044 	movi	r5,1
81108788:	01204534 	movhi	r4,33044
8110878c:	21041e04 	addi	r4,r4,4216
81108790:	1115d200 	call	81115d20 <fwrite>
    #endif

	for (;;) {
		OSTimeDlyHMSM(0, 0, 0, 500);; /*todo:Tirar depois do debug*/
81108794:	01c07d04 	movi	r7,500
81108798:	000d883a 	mov	r6,zero
8110879c:	000b883a 	mov	r5,zero
811087a0:	0009883a 	mov	r4,zero
811087a4:	11355440 	call	81135544 <OSTimeDlyHMSM>
	}
811087a8:	003ffa06 	br	81108794 <__reset+0xfb0e8794>

811087ac <vFeeTask>:

#include "fee_task.h"



void vFeeTask(void *task_data) {
811087ac:	defffc04 	addi	sp,sp,-16
811087b0:	de00012e 	bgeu	sp,et,811087b8 <vFeeTask+0xc>
811087b4:	003b68fa 	trap	3
811087b8:	dfc00315 	stw	ra,12(sp)
811087bc:	df000215 	stw	fp,8(sp)
811087c0:	df000204 	addi	fp,sp,8
811087c4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
811087c8:	e03ffe15 	stw	zero,-8(fp)
	static TNFee *pxNFee;
	INT8U error_code;

	pxNFee = ( TNFee * ) task_data;
811087cc:	e0bfff17 	ldw	r2,-4(fp)
811087d0:	d0a04b15 	stw	r2,-32468(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
811087d4:	d0e05417 	ldw	r3,-32432(gp)
811087d8:	d0a04b17 	ldw	r2,-32468(gp)
811087dc:	10800003 	ldbu	r2,0(r2)
811087e0:	10803fcc 	andi	r2,r2,255
811087e4:	100d883a 	mov	r6,r2
811087e8:	01604534 	movhi	r5,33044
811087ec:	29442704 	addi	r5,r5,4252
811087f0:	1809883a 	mov	r4,r3
811087f4:	11156840 	call	81115684 <fprintf>
		//debug(fp,"NFEE Task. (Task on)\n");
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
811087f8:	d0a04b17 	ldw	r2,-32468(gp)
811087fc:	1009883a 	mov	r4,r2
81108800:	110881c0 	call	8110881c <vPrintConsoleNFee>
	#endif


	for(;;){
		/* Simular N itera��es para verificar os endere�os de mem�ria */
		OSTimeDlyHMSM(0, 0, 0, 500);
81108804:	01c07d04 	movi	r7,500
81108808:	000d883a 	mov	r6,zero
8110880c:	000b883a 	mov	r5,zero
81108810:	0009883a 	mov	r4,zero
81108814:	11355440 	call	81135544 <OSTimeDlyHMSM>

	}
81108818:	003ffa06 	br	81108804 <__reset+0xfb0e8804>

8110881c <vPrintConsoleNFee>:


}

#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
8110881c:	defffa04 	addi	sp,sp,-24
81108820:	de00012e 	bgeu	sp,et,81108828 <vPrintConsoleNFee+0xc>
81108824:	003b68fa 	trap	3
81108828:	dfc00515 	stw	ra,20(sp)
8110882c:	df000415 	stw	fp,16(sp)
81108830:	df000404 	addi	fp,sp,16
81108834:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
81108838:	e0bfff17 	ldw	r2,-4(fp)
8110883c:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
81108840:	d0e05417 	ldw	r3,-32432(gp)
81108844:	e0bffe17 	ldw	r2,-8(fp)
81108848:	10800003 	ldbu	r2,0(r2)
8110884c:	10803fcc 	andi	r2,r2,255
81108850:	100d883a 	mov	r6,r2
81108854:	01604534 	movhi	r5,33044
81108858:	29442e04 	addi	r5,r5,4280
8110885c:	1809883a 	mov	r4,r3
81108860:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"\n");
81108864:	d0a05417 	ldw	r2,-32432(gp)
81108868:	100b883a 	mov	r5,r2
8110886c:	01000284 	movi	r4,10
81108870:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
81108874:	d0e05417 	ldw	r3,-32432(gp)
81108878:	e0bffe17 	ldw	r2,-8(fp)
8110887c:	10800003 	ldbu	r2,0(r2)
81108880:	10803fcc 	andi	r2,r2,255
81108884:	100d883a 	mov	r6,r2
81108888:	01604534 	movhi	r5,33044
8110888c:	29444304 	addi	r5,r5,4364
81108890:	1809883a 	mov	r4,r3
81108894:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
81108898:	d0e05417 	ldw	r3,-32432(gp)
8110889c:	e0bffe17 	ldw	r2,-8(fp)
811088a0:	1080290b 	ldhu	r2,164(r2)
811088a4:	10bfffcc 	andi	r2,r2,65535
811088a8:	100d883a 	mov	r6,r2
811088ac:	01604534 	movhi	r5,33044
811088b0:	29444904 	addi	r5,r5,4388
811088b4:	1809883a 	mov	r4,r3
811088b8:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
811088bc:	d0e05417 	ldw	r3,-32432(gp)
811088c0:	e0bffe17 	ldw	r2,-8(fp)
811088c4:	1080298b 	ldhu	r2,166(r2)
811088c8:	10bfffcc 	andi	r2,r2,65535
811088cc:	100d883a 	mov	r6,r2
811088d0:	01604534 	movhi	r5,33044
811088d4:	29444e04 	addi	r5,r5,4408
811088d8:	1809883a 	mov	r4,r3
811088dc:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
811088e0:	d0e05417 	ldw	r3,-32432(gp)
811088e4:	e0bffe17 	ldw	r2,-8(fp)
811088e8:	10802a0b 	ldhu	r2,168(r2)
811088ec:	10bfffcc 	andi	r2,r2,65535
811088f0:	100d883a 	mov	r6,r2
811088f4:	01604534 	movhi	r5,33044
811088f8:	29445404 	addi	r5,r5,4432
811088fc:	1809883a 	mov	r4,r3
81108900:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
81108904:	d0e05417 	ldw	r3,-32432(gp)
81108908:	e0bffe17 	ldw	r2,-8(fp)
8110890c:	10802a8b 	ldhu	r2,170(r2)
81108910:	10bfffcc 	andi	r2,r2,65535
81108914:	100d883a 	mov	r6,r2
81108918:	01604534 	movhi	r5,33044
8110891c:	29445804 	addi	r5,r5,4448
81108920:	1809883a 	mov	r4,r3
81108924:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
81108928:	d0e05417 	ldw	r3,-32432(gp)
8110892c:	e0bffe17 	ldw	r2,-8(fp)
81108930:	10802b0b 	ldhu	r2,172(r2)
81108934:	10bfffcc 	andi	r2,r2,65535
81108938:	100d883a 	mov	r6,r2
8110893c:	01604534 	movhi	r5,33044
81108940:	29445e04 	addi	r5,r5,4472
81108944:	1809883a 	mov	r4,r3
81108948:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"\n");
8110894c:	d0a05417 	ldw	r2,-32432(gp)
81108950:	100b883a 	mov	r5,r2
81108954:	01000284 	movi	r4,10
81108958:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
8110895c:	d0e05417 	ldw	r3,-32432(gp)
81108960:	e0bffe17 	ldw	r2,-8(fp)
81108964:	10800003 	ldbu	r2,0(r2)
81108968:	10803fcc 	andi	r2,r2,255
8110896c:	100d883a 	mov	r6,r2
81108970:	01604534 	movhi	r5,33044
81108974:	29446304 	addi	r5,r5,4492
81108978:	1809883a 	mov	r4,r3
8110897c:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
81108980:	d0e05417 	ldw	r3,-32432(gp)
81108984:	e0bffe17 	ldw	r2,-8(fp)
81108988:	10802717 	ldw	r2,156(r2)
8110898c:	100d883a 	mov	r6,r2
81108990:	01604534 	movhi	r5,33044
81108994:	29446904 	addi	r5,r5,4516
81108998:	1809883a 	mov	r4,r3
8110899c:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
811089a0:	d0e05417 	ldw	r3,-32432(gp)
811089a4:	e0bffe17 	ldw	r2,-8(fp)
811089a8:	10802117 	ldw	r2,132(r2)
811089ac:	100d883a 	mov	r6,r2
811089b0:	01604534 	movhi	r5,33044
811089b4:	29446f04 	addi	r5,r5,4540
811089b8:	1809883a 	mov	r4,r3
811089bc:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
811089c0:	d0e05417 	ldw	r3,-32432(gp)
811089c4:	e0bffe17 	ldw	r2,-8(fp)
811089c8:	10802217 	ldw	r2,136(r2)
811089cc:	100d883a 	mov	r6,r2
811089d0:	01604534 	movhi	r5,33044
811089d4:	29447604 	addi	r5,r5,4568
811089d8:	1809883a 	mov	r4,r3
811089dc:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
811089e0:	d0e05417 	ldw	r3,-32432(gp)
811089e4:	e0bffe17 	ldw	r2,-8(fp)
811089e8:	10802317 	ldw	r2,140(r2)
811089ec:	100d883a 	mov	r6,r2
811089f0:	01604534 	movhi	r5,33044
811089f4:	29447d04 	addi	r5,r5,4596
811089f8:	1809883a 	mov	r4,r3
811089fc:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
81108a00:	d0e05417 	ldw	r3,-32432(gp)
81108a04:	e0bffe17 	ldw	r2,-8(fp)
81108a08:	10802417 	ldw	r2,144(r2)
81108a0c:	100d883a 	mov	r6,r2
81108a10:	01604534 	movhi	r5,33044
81108a14:	29448404 	addi	r5,r5,4624
81108a18:	1809883a 	mov	r4,r3
81108a1c:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
81108a20:	d0e05417 	ldw	r3,-32432(gp)
81108a24:	e0bffe17 	ldw	r2,-8(fp)
81108a28:	10802517 	ldw	r2,148(r2)
81108a2c:	100d883a 	mov	r6,r2
81108a30:	01604534 	movhi	r5,33044
81108a34:	29448b04 	addi	r5,r5,4652
81108a38:	1809883a 	mov	r4,r3
81108a3c:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
81108a40:	d1205417 	ldw	r4,-32432(gp)
81108a44:	e0bffe17 	ldw	r2,-8(fp)
81108a48:	10802603 	ldbu	r2,152(r2)
81108a4c:	11403fcc 	andi	r5,r2,255
81108a50:	e0bffe17 	ldw	r2,-8(fp)
81108a54:	10802643 	ldbu	r2,153(r2)
81108a58:	11803fcc 	andi	r6,r2,255
81108a5c:	e0bffe17 	ldw	r2,-8(fp)
81108a60:	10802683 	ldbu	r2,154(r2)
81108a64:	10803fcc 	andi	r2,r2,255
81108a68:	e0fffe17 	ldw	r3,-8(fp)
81108a6c:	18c026c3 	ldbu	r3,155(r3)
81108a70:	18c03fcc 	andi	r3,r3,255
81108a74:	d8c00115 	stw	r3,4(sp)
81108a78:	d8800015 	stw	r2,0(sp)
81108a7c:	300f883a 	mov	r7,r6
81108a80:	280d883a 	mov	r6,r5
81108a84:	01604534 	movhi	r5,33044
81108a88:	29449204 	addi	r5,r5,4680
81108a8c:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
81108a90:	d0e05417 	ldw	r3,-32432(gp)
81108a94:	e0bffe17 	ldw	r2,-8(fp)
81108a98:	10802817 	ldw	r2,160(r2)
81108a9c:	100d883a 	mov	r6,r2
81108aa0:	01604534 	movhi	r5,33044
81108aa4:	29449f04 	addi	r5,r5,4732
81108aa8:	1809883a 	mov	r4,r3
81108aac:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"\n\n");
81108ab0:	d0a05417 	ldw	r2,-32432(gp)
81108ab4:	100f883a 	mov	r7,r2
81108ab8:	01800084 	movi	r6,2
81108abc:	01400044 	movi	r5,1
81108ac0:	01204534 	movhi	r4,33044
81108ac4:	2104a504 	addi	r4,r4,4756
81108ac8:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
81108acc:	d0e05417 	ldw	r3,-32432(gp)
81108ad0:	e0bffe17 	ldw	r2,-8(fp)
81108ad4:	10800003 	ldbu	r2,0(r2)
81108ad8:	10803fcc 	andi	r2,r2,255
81108adc:	100d883a 	mov	r6,r2
81108ae0:	01604534 	movhi	r5,33044
81108ae4:	2944a604 	addi	r5,r5,4760
81108ae8:	1809883a 	mov	r4,r3
81108aec:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    General Info: \n");
81108af0:	d0a05417 	ldw	r2,-32432(gp)
81108af4:	100f883a 	mov	r7,r2
81108af8:	018004c4 	movi	r6,19
81108afc:	01400044 	movi	r5,1
81108b00:	01204534 	movhi	r4,33044
81108b04:	2104ac04 	addi	r4,r4,4784
81108b08:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
81108b0c:	d0e05417 	ldw	r3,-32432(gp)
81108b10:	e0bffe17 	ldw	r2,-8(fp)
81108b14:	10800117 	ldw	r2,4(r2)
81108b18:	100d883a 	mov	r6,r2
81108b1c:	01604534 	movhi	r5,33044
81108b20:	2944b104 	addi	r5,r5,4804
81108b24:	1809883a 	mov	r4,r3
81108b28:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
81108b2c:	d0e05417 	ldw	r3,-32432(gp)
81108b30:	e0bffe17 	ldw	r2,-8(fp)
81108b34:	10800217 	ldw	r2,8(r2)
81108b38:	100d883a 	mov	r6,r2
81108b3c:	01604534 	movhi	r5,33044
81108b40:	2944b904 	addi	r5,r5,4836
81108b44:	1809883a 	mov	r4,r3
81108b48:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
81108b4c:	d0e05417 	ldw	r3,-32432(gp)
81108b50:	e0bffe17 	ldw	r2,-8(fp)
81108b54:	10800317 	ldw	r2,12(r2)
81108b58:	100d883a 	mov	r6,r2
81108b5c:	01604534 	movhi	r5,33044
81108b60:	2944c104 	addi	r5,r5,4868
81108b64:	1809883a 	mov	r4,r3
81108b68:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
81108b6c:	d0a05417 	ldw	r2,-32432(gp)
81108b70:	100f883a 	mov	r7,r2
81108b74:	01800644 	movi	r6,25
81108b78:	01400044 	movi	r5,1
81108b7c:	01204534 	movhi	r4,33044
81108b80:	2104c804 	addi	r4,r4,4896
81108b84:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
81108b88:	d0e05417 	ldw	r3,-32432(gp)
81108b8c:	e0bffe17 	ldw	r2,-8(fp)
81108b90:	10800517 	ldw	r2,20(r2)
81108b94:	100d883a 	mov	r6,r2
81108b98:	01604534 	movhi	r5,33044
81108b9c:	2944cf04 	addi	r5,r5,4924
81108ba0:	1809883a 	mov	r4,r3
81108ba4:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
81108ba8:	d0e05417 	ldw	r3,-32432(gp)
81108bac:	e0bffe17 	ldw	r2,-8(fp)
81108bb0:	10800417 	ldw	r2,16(r2)
81108bb4:	100d883a 	mov	r6,r2
81108bb8:	01604534 	movhi	r5,33044
81108bbc:	2944d704 	addi	r5,r5,4956
81108bc0:	1809883a 	mov	r4,r3
81108bc4:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
81108bc8:	d0e05417 	ldw	r3,-32432(gp)
81108bcc:	e0bffe17 	ldw	r2,-8(fp)
81108bd0:	10800603 	ldbu	r2,24(r2)
81108bd4:	10803fcc 	andi	r2,r2,255
81108bd8:	100d883a 	mov	r6,r2
81108bdc:	01604534 	movhi	r5,33044
81108be0:	2944df04 	addi	r5,r5,4988
81108be4:	1809883a 	mov	r4,r3
81108be8:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
81108bec:	d2205417 	ldw	r8,-32432(gp)
81108bf0:	e13ffe17 	ldw	r4,-8(fp)
81108bf4:	20800717 	ldw	r2,28(r4)
81108bf8:	20c00817 	ldw	r3,32(r4)
81108bfc:	100d883a 	mov	r6,r2
81108c00:	180f883a 	mov	r7,r3
81108c04:	01604534 	movhi	r5,33044
81108c08:	2944e704 	addi	r5,r5,5020
81108c0c:	4009883a 	mov	r4,r8
81108c10:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"\n");
81108c14:	d0a05417 	ldw	r2,-32432(gp)
81108c18:	100b883a 	mov	r5,r2
81108c1c:	01000284 	movi	r4,10
81108c20:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
81108c24:	d0e05417 	ldw	r3,-32432(gp)
81108c28:	e0bffe17 	ldw	r2,-8(fp)
81108c2c:	10800003 	ldbu	r2,0(r2)
81108c30:	10803fcc 	andi	r2,r2,255
81108c34:	100f883a 	mov	r7,r2
81108c38:	000d883a 	mov	r6,zero
81108c3c:	01604534 	movhi	r5,33044
81108c40:	2944ef04 	addi	r5,r5,5052
81108c44:	1809883a 	mov	r4,r3
81108c48:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Left side \n");
81108c4c:	d0a05417 	ldw	r2,-32432(gp)
81108c50:	100f883a 	mov	r7,r2
81108c54:	018004c4 	movi	r6,19
81108c58:	01400044 	movi	r5,1
81108c5c:	01204534 	movhi	r4,33044
81108c60:	2104f904 	addi	r4,r4,5092
81108c64:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
81108c68:	d0e05417 	ldw	r3,-32432(gp)
81108c6c:	e0bffe17 	ldw	r2,-8(fp)
81108c70:	10800917 	ldw	r2,36(r2)
81108c74:	100d883a 	mov	r6,r2
81108c78:	01604534 	movhi	r5,33044
81108c7c:	2944fe04 	addi	r5,r5,5112
81108c80:	1809883a 	mov	r4,r3
81108c84:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
81108c88:	d0e05417 	ldw	r3,-32432(gp)
81108c8c:	e0bffe17 	ldw	r2,-8(fp)
81108c90:	10800a17 	ldw	r2,40(r2)
81108c94:	100d883a 	mov	r6,r2
81108c98:	01604534 	movhi	r5,33044
81108c9c:	29450704 	addi	r5,r5,5148
81108ca0:	1809883a 	mov	r4,r3
81108ca4:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
81108ca8:	d0e05417 	ldw	r3,-32432(gp)
81108cac:	e0bffe17 	ldw	r2,-8(fp)
81108cb0:	10800b17 	ldw	r2,44(r2)
81108cb4:	100d883a 	mov	r6,r2
81108cb8:	01604534 	movhi	r5,33044
81108cbc:	29451204 	addi	r5,r5,5192
81108cc0:	1809883a 	mov	r4,r3
81108cc4:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Right side \n");
81108cc8:	d0a05417 	ldw	r2,-32432(gp)
81108ccc:	100f883a 	mov	r7,r2
81108cd0:	01800504 	movi	r6,20
81108cd4:	01400044 	movi	r5,1
81108cd8:	01204534 	movhi	r4,33044
81108cdc:	21051e04 	addi	r4,r4,5240
81108ce0:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
81108ce4:	d0e05417 	ldw	r3,-32432(gp)
81108ce8:	e0bffe17 	ldw	r2,-8(fp)
81108cec:	10800c17 	ldw	r2,48(r2)
81108cf0:	100d883a 	mov	r6,r2
81108cf4:	01604534 	movhi	r5,33044
81108cf8:	2944fe04 	addi	r5,r5,5112
81108cfc:	1809883a 	mov	r4,r3
81108d00:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
81108d04:	d0e05417 	ldw	r3,-32432(gp)
81108d08:	e0bffe17 	ldw	r2,-8(fp)
81108d0c:	10800d17 	ldw	r2,52(r2)
81108d10:	100d883a 	mov	r6,r2
81108d14:	01604534 	movhi	r5,33044
81108d18:	29450704 	addi	r5,r5,5148
81108d1c:	1809883a 	mov	r4,r3
81108d20:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
81108d24:	d0e05417 	ldw	r3,-32432(gp)
81108d28:	e0bffe17 	ldw	r2,-8(fp)
81108d2c:	10800e17 	ldw	r2,56(r2)
81108d30:	100d883a 	mov	r6,r2
81108d34:	01604534 	movhi	r5,33044
81108d38:	29451204 	addi	r5,r5,5192
81108d3c:	1809883a 	mov	r4,r3
81108d40:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"\n");
81108d44:	d0a05417 	ldw	r2,-32432(gp)
81108d48:	100b883a 	mov	r5,r2
81108d4c:	01000284 	movi	r4,10
81108d50:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
81108d54:	d0e05417 	ldw	r3,-32432(gp)
81108d58:	e0bffe17 	ldw	r2,-8(fp)
81108d5c:	10800003 	ldbu	r2,0(r2)
81108d60:	10803fcc 	andi	r2,r2,255
81108d64:	100f883a 	mov	r7,r2
81108d68:	01800044 	movi	r6,1
81108d6c:	01604534 	movhi	r5,33044
81108d70:	2944ef04 	addi	r5,r5,5052
81108d74:	1809883a 	mov	r4,r3
81108d78:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Left side \n");
81108d7c:	d0a05417 	ldw	r2,-32432(gp)
81108d80:	100f883a 	mov	r7,r2
81108d84:	018004c4 	movi	r6,19
81108d88:	01400044 	movi	r5,1
81108d8c:	01204534 	movhi	r4,33044
81108d90:	2104f904 	addi	r4,r4,5092
81108d94:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
81108d98:	d0e05417 	ldw	r3,-32432(gp)
81108d9c:	e0bffe17 	ldw	r2,-8(fp)
81108da0:	10800f17 	ldw	r2,60(r2)
81108da4:	100d883a 	mov	r6,r2
81108da8:	01604534 	movhi	r5,33044
81108dac:	2944fe04 	addi	r5,r5,5112
81108db0:	1809883a 	mov	r4,r3
81108db4:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
81108db8:	d0e05417 	ldw	r3,-32432(gp)
81108dbc:	e0bffe17 	ldw	r2,-8(fp)
81108dc0:	10801017 	ldw	r2,64(r2)
81108dc4:	100d883a 	mov	r6,r2
81108dc8:	01604534 	movhi	r5,33044
81108dcc:	29450704 	addi	r5,r5,5148
81108dd0:	1809883a 	mov	r4,r3
81108dd4:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
81108dd8:	d0e05417 	ldw	r3,-32432(gp)
81108ddc:	e0bffe17 	ldw	r2,-8(fp)
81108de0:	10801117 	ldw	r2,68(r2)
81108de4:	100d883a 	mov	r6,r2
81108de8:	01604534 	movhi	r5,33044
81108dec:	29451204 	addi	r5,r5,5192
81108df0:	1809883a 	mov	r4,r3
81108df4:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Right side \n");
81108df8:	d0a05417 	ldw	r2,-32432(gp)
81108dfc:	100f883a 	mov	r7,r2
81108e00:	01800504 	movi	r6,20
81108e04:	01400044 	movi	r5,1
81108e08:	01204534 	movhi	r4,33044
81108e0c:	21051e04 	addi	r4,r4,5240
81108e10:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
81108e14:	d0e05417 	ldw	r3,-32432(gp)
81108e18:	e0bffe17 	ldw	r2,-8(fp)
81108e1c:	10801217 	ldw	r2,72(r2)
81108e20:	100d883a 	mov	r6,r2
81108e24:	01604534 	movhi	r5,33044
81108e28:	2944fe04 	addi	r5,r5,5112
81108e2c:	1809883a 	mov	r4,r3
81108e30:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
81108e34:	d0e05417 	ldw	r3,-32432(gp)
81108e38:	e0bffe17 	ldw	r2,-8(fp)
81108e3c:	10801317 	ldw	r2,76(r2)
81108e40:	100d883a 	mov	r6,r2
81108e44:	01604534 	movhi	r5,33044
81108e48:	29450704 	addi	r5,r5,5148
81108e4c:	1809883a 	mov	r4,r3
81108e50:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
81108e54:	d0e05417 	ldw	r3,-32432(gp)
81108e58:	e0bffe17 	ldw	r2,-8(fp)
81108e5c:	10801417 	ldw	r2,80(r2)
81108e60:	100d883a 	mov	r6,r2
81108e64:	01604534 	movhi	r5,33044
81108e68:	29451204 	addi	r5,r5,5192
81108e6c:	1809883a 	mov	r4,r3
81108e70:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"\n");
81108e74:	d0a05417 	ldw	r2,-32432(gp)
81108e78:	100b883a 	mov	r5,r2
81108e7c:	01000284 	movi	r4,10
81108e80:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
81108e84:	d0e05417 	ldw	r3,-32432(gp)
81108e88:	e0bffe17 	ldw	r2,-8(fp)
81108e8c:	10800003 	ldbu	r2,0(r2)
81108e90:	10803fcc 	andi	r2,r2,255
81108e94:	100f883a 	mov	r7,r2
81108e98:	01800084 	movi	r6,2
81108e9c:	01604534 	movhi	r5,33044
81108ea0:	2944ef04 	addi	r5,r5,5052
81108ea4:	1809883a 	mov	r4,r3
81108ea8:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Left side \n");
81108eac:	d0a05417 	ldw	r2,-32432(gp)
81108eb0:	100f883a 	mov	r7,r2
81108eb4:	018004c4 	movi	r6,19
81108eb8:	01400044 	movi	r5,1
81108ebc:	01204534 	movhi	r4,33044
81108ec0:	2104f904 	addi	r4,r4,5092
81108ec4:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
81108ec8:	d0e05417 	ldw	r3,-32432(gp)
81108ecc:	e0bffe17 	ldw	r2,-8(fp)
81108ed0:	10801517 	ldw	r2,84(r2)
81108ed4:	100d883a 	mov	r6,r2
81108ed8:	01604534 	movhi	r5,33044
81108edc:	2944fe04 	addi	r5,r5,5112
81108ee0:	1809883a 	mov	r4,r3
81108ee4:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
81108ee8:	d0e05417 	ldw	r3,-32432(gp)
81108eec:	e0bffe17 	ldw	r2,-8(fp)
81108ef0:	10801617 	ldw	r2,88(r2)
81108ef4:	100d883a 	mov	r6,r2
81108ef8:	01604534 	movhi	r5,33044
81108efc:	29450704 	addi	r5,r5,5148
81108f00:	1809883a 	mov	r4,r3
81108f04:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
81108f08:	d0e05417 	ldw	r3,-32432(gp)
81108f0c:	e0bffe17 	ldw	r2,-8(fp)
81108f10:	10801717 	ldw	r2,92(r2)
81108f14:	100d883a 	mov	r6,r2
81108f18:	01604534 	movhi	r5,33044
81108f1c:	29451204 	addi	r5,r5,5192
81108f20:	1809883a 	mov	r4,r3
81108f24:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Right side \n");
81108f28:	d0a05417 	ldw	r2,-32432(gp)
81108f2c:	100f883a 	mov	r7,r2
81108f30:	01800504 	movi	r6,20
81108f34:	01400044 	movi	r5,1
81108f38:	01204534 	movhi	r4,33044
81108f3c:	21051e04 	addi	r4,r4,5240
81108f40:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
81108f44:	d0e05417 	ldw	r3,-32432(gp)
81108f48:	e0bffe17 	ldw	r2,-8(fp)
81108f4c:	10801817 	ldw	r2,96(r2)
81108f50:	100d883a 	mov	r6,r2
81108f54:	01604534 	movhi	r5,33044
81108f58:	2944fe04 	addi	r5,r5,5112
81108f5c:	1809883a 	mov	r4,r3
81108f60:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
81108f64:	d0e05417 	ldw	r3,-32432(gp)
81108f68:	e0bffe17 	ldw	r2,-8(fp)
81108f6c:	10801917 	ldw	r2,100(r2)
81108f70:	100d883a 	mov	r6,r2
81108f74:	01604534 	movhi	r5,33044
81108f78:	29450704 	addi	r5,r5,5148
81108f7c:	1809883a 	mov	r4,r3
81108f80:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
81108f84:	d0e05417 	ldw	r3,-32432(gp)
81108f88:	e0bffe17 	ldw	r2,-8(fp)
81108f8c:	10801a17 	ldw	r2,104(r2)
81108f90:	100d883a 	mov	r6,r2
81108f94:	01604534 	movhi	r5,33044
81108f98:	29451204 	addi	r5,r5,5192
81108f9c:	1809883a 	mov	r4,r3
81108fa0:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"\n");
81108fa4:	d0a05417 	ldw	r2,-32432(gp)
81108fa8:	100b883a 	mov	r5,r2
81108fac:	01000284 	movi	r4,10
81108fb0:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
81108fb4:	d0e05417 	ldw	r3,-32432(gp)
81108fb8:	e0bffe17 	ldw	r2,-8(fp)
81108fbc:	10800003 	ldbu	r2,0(r2)
81108fc0:	10803fcc 	andi	r2,r2,255
81108fc4:	100f883a 	mov	r7,r2
81108fc8:	018000c4 	movi	r6,3
81108fcc:	01604534 	movhi	r5,33044
81108fd0:	2944ef04 	addi	r5,r5,5052
81108fd4:	1809883a 	mov	r4,r3
81108fd8:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Left side \n");
81108fdc:	d0a05417 	ldw	r2,-32432(gp)
81108fe0:	100f883a 	mov	r7,r2
81108fe4:	018004c4 	movi	r6,19
81108fe8:	01400044 	movi	r5,1
81108fec:	01204534 	movhi	r4,33044
81108ff0:	2104f904 	addi	r4,r4,5092
81108ff4:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
81108ff8:	d0e05417 	ldw	r3,-32432(gp)
81108ffc:	e0bffe17 	ldw	r2,-8(fp)
81109000:	10801b17 	ldw	r2,108(r2)
81109004:	100d883a 	mov	r6,r2
81109008:	01604534 	movhi	r5,33044
8110900c:	2944fe04 	addi	r5,r5,5112
81109010:	1809883a 	mov	r4,r3
81109014:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
81109018:	d0e05417 	ldw	r3,-32432(gp)
8110901c:	e0bffe17 	ldw	r2,-8(fp)
81109020:	10801c17 	ldw	r2,112(r2)
81109024:	100d883a 	mov	r6,r2
81109028:	01604534 	movhi	r5,33044
8110902c:	29450704 	addi	r5,r5,5148
81109030:	1809883a 	mov	r4,r3
81109034:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
81109038:	d0e05417 	ldw	r3,-32432(gp)
8110903c:	e0bffe17 	ldw	r2,-8(fp)
81109040:	10801d17 	ldw	r2,116(r2)
81109044:	100d883a 	mov	r6,r2
81109048:	01604534 	movhi	r5,33044
8110904c:	29451204 	addi	r5,r5,5192
81109050:	1809883a 	mov	r4,r3
81109054:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"        Right side \n");
81109058:	d0a05417 	ldw	r2,-32432(gp)
8110905c:	100f883a 	mov	r7,r2
81109060:	01800504 	movi	r6,20
81109064:	01400044 	movi	r5,1
81109068:	01204534 	movhi	r4,33044
8110906c:	21051e04 	addi	r4,r4,5240
81109070:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
81109074:	d0e05417 	ldw	r3,-32432(gp)
81109078:	e0bffe17 	ldw	r2,-8(fp)
8110907c:	10801e17 	ldw	r2,120(r2)
81109080:	100d883a 	mov	r6,r2
81109084:	01604534 	movhi	r5,33044
81109088:	2944fe04 	addi	r5,r5,5112
8110908c:	1809883a 	mov	r4,r3
81109090:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
81109094:	d0e05417 	ldw	r3,-32432(gp)
81109098:	e0bffe17 	ldw	r2,-8(fp)
8110909c:	10801f17 	ldw	r2,124(r2)
811090a0:	100d883a 	mov	r6,r2
811090a4:	01604534 	movhi	r5,33044
811090a8:	29450704 	addi	r5,r5,5148
811090ac:	1809883a 	mov	r4,r3
811090b0:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
811090b4:	d0e05417 	ldw	r3,-32432(gp)
811090b8:	e0bffe17 	ldw	r2,-8(fp)
811090bc:	10802017 	ldw	r2,128(r2)
811090c0:	100d883a 	mov	r6,r2
811090c4:	01604534 	movhi	r5,33044
811090c8:	29451204 	addi	r5,r5,5192
811090cc:	1809883a 	mov	r4,r3
811090d0:	11156840 	call	81115684 <fprintf>
		fprintf(fp,"\n");
811090d4:	d0a05417 	ldw	r2,-32432(gp)
811090d8:	100b883a 	mov	r5,r2
811090dc:	01000284 	movi	r4,10
811090e0:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"==============================================================================\n");
811090e4:	d0a05417 	ldw	r2,-32432(gp)
811090e8:	100f883a 	mov	r7,r2
811090ec:	018013c4 	movi	r6,79
811090f0:	01400044 	movi	r5,1
811090f4:	01204534 	movhi	r4,33044
811090f8:	21052404 	addi	r4,r4,5264
811090fc:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"==============================================================================\n");
81109100:	d0a05417 	ldw	r2,-32432(gp)
81109104:	100f883a 	mov	r7,r2
81109108:	018013c4 	movi	r6,79
8110910c:	01400044 	movi	r5,1
81109110:	01204534 	movhi	r4,33044
81109114:	21052404 	addi	r4,r4,5264
81109118:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp,"\n");
8110911c:	d0a05417 	ldw	r2,-32432(gp)
81109120:	100b883a 	mov	r5,r2
81109124:	01000284 	movi	r4,10
81109128:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"\n");
8110912c:	d0a05417 	ldw	r2,-32432(gp)
81109130:	100b883a 	mov	r5,r2
81109134:	01000284 	movi	r4,10
81109138:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"\n");
8110913c:	d0a05417 	ldw	r2,-32432(gp)
81109140:	100b883a 	mov	r5,r2
81109144:	01000284 	movi	r4,10
81109148:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"\n");
8110914c:	d0a05417 	ldw	r2,-32432(gp)
81109150:	100b883a 	mov	r5,r2
81109154:	01000284 	movi	r4,10
81109158:	11156fc0 	call	811156fc <fputc>
		fprintf(fp,"\n");
8110915c:	d0a05417 	ldw	r2,-32432(gp)
81109160:	100b883a 	mov	r5,r2
81109164:	01000284 	movi	r4,10
81109168:	11156fc0 	call	811156fc <fputc>
	}
8110916c:	0001883a 	nop
81109170:	e037883a 	mov	sp,fp
81109174:	dfc00117 	ldw	ra,4(sp)
81109178:	df000017 	ldw	fp,0(sp)
8110917c:	dec00204 	addi	sp,sp,8
81109180:	f800283a 	ret

81109184 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
81109184:	defff604 	addi	sp,sp,-40
81109188:	de00012e 	bgeu	sp,et,81109190 <vInAckHandlerTaskV2+0xc>
8110918c:	003b68fa 	trap	3
81109190:	dfc00915 	stw	ra,36(sp)
81109194:	df000815 	stw	fp,32(sp)
81109198:	df000804 	addi	fp,sp,32
8110919c:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
811091a0:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
811091a4:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
811091a8:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
811091ac:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
811091b0:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
811091b4:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
811091b8:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
811091bc:	d0a05417 	ldw	r2,-32432(gp)
811091c0:	100f883a 	mov	r7,r2
811091c4:	018007c4 	movi	r6,31
811091c8:	01400044 	movi	r5,1
811091cc:	01204534 	movhi	r4,33044
811091d0:	21053804 	addi	r4,r4,5344
811091d4:	1115d200 	call	81115d20 <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
811091d8:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
811091dc:	e0bff917 	ldw	r2,-28(fp)
811091e0:	10c00060 	cmpeqi	r3,r2,1
811091e4:	1800071e 	bne	r3,zero,81109204 <vInAckHandlerTaskV2+0x80>
811091e8:	0080032e 	bgeu	zero,r2,811091f8 <vInAckHandlerTaskV2+0x74>
811091ec:	108000a0 	cmpeqi	r2,r2,2
811091f0:	10004a1e 	bne	r2,zero,8110931c <vInAckHandlerTaskV2+0x198>
811091f4:	0000ac06 	br	811094a8 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
811091f8:	00800044 	movi	r2,1
811091fc:	e0bff915 	stw	r2,-28(fp)
				break;
81109200:	0000b306 	br	811094d0 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
81109204:	00800044 	movi	r2,1
81109208:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
8110920c:	d0a05817 	ldw	r2,-32416(gp)
81109210:	e0fffe04 	addi	r3,fp,-8
81109214:	180d883a 	mov	r6,r3
81109218:	000b883a 	mov	r5,zero
8110921c:	1009883a 	mov	r4,r2
81109220:	11337600 	call	81133760 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81109224:	e0bffe03 	ldbu	r2,-8(fp)
81109228:	10803fcc 	andi	r2,r2,255
8110922c:	1000391e 	bne	r2,zero,81109314 <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
81109230:	d0a05717 	ldw	r2,-32420(gp)
81109234:	e0fffe04 	addi	r3,fp,-8
81109238:	180d883a 	mov	r6,r3
8110923c:	000b883a 	mov	r5,zero
81109240:	1009883a 	mov	r4,r2
81109244:	11317540 	call	81131754 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81109248:	e0bffe03 	ldbu	r2,-8(fp)
8110924c:	10803fcc 	andi	r2,r2,255
81109250:	10002b1e 	bne	r2,zero,81109300 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81109254:	e03ffa45 	stb	zero,-23(fp)
81109258:	00002206 	br	811092e4 <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
8110925c:	e0fffa43 	ldbu	r3,-23(fp)
81109260:	00a04574 	movhi	r2,33045
81109264:	1092e404 	addi	r2,r2,19344
81109268:	18c7883a 	add	r3,r3,r3
8110926c:	18c7883a 	add	r3,r3,r3
81109270:	10c5883a 	add	r2,r2,r3
81109274:	10800003 	ldbu	r2,0(r2)
81109278:	10803fcc 	andi	r2,r2,255
8110927c:	1080201c 	xori	r2,r2,128
81109280:	10bfe004 	addi	r2,r2,-128
81109284:	10001426 	beq	r2,zero,811092d8 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
81109288:	e0fffa43 	ldbu	r3,-23(fp)
8110928c:	00a04574 	movhi	r2,33045
81109290:	1092e404 	addi	r2,r2,19344
81109294:	18c7883a 	add	r3,r3,r3
81109298:	18c7883a 	add	r3,r3,r3
8110929c:	10c5883a 	add	r2,r2,r3
811092a0:	10c0000b 	ldhu	r3,0(r2)
811092a4:	d0e04c0d 	sth	r3,-32464(gp)
811092a8:	1080008b 	ldhu	r2,2(r2)
811092ac:	d0a04c8d 	sth	r2,-32462(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
811092b0:	e0fffa43 	ldbu	r3,-23(fp)
811092b4:	00a04574 	movhi	r2,33045
811092b8:	1092e404 	addi	r2,r2,19344
811092bc:	18c7883a 	add	r3,r3,r3
811092c0:	18c7883a 	add	r3,r3,r3
811092c4:	10c5883a 	add	r2,r2,r3
811092c8:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
811092cc:	00800084 	movi	r2,2
811092d0:	e0bff915 	stw	r2,-28(fp)
                                break;                                
811092d4:	00000606 	br	811092f0 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
811092d8:	e0bffa43 	ldbu	r2,-23(fp)
811092dc:	10800044 	addi	r2,r2,1
811092e0:	e0bffa45 	stb	r2,-23(fp)
811092e4:	e0bffa43 	ldbu	r2,-23(fp)
811092e8:	108001b0 	cmpltui	r2,r2,6
811092ec:	103fdb1e 	bne	r2,zero,8110925c <__reset+0xfb0e925c>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
811092f0:	d0a05717 	ldw	r2,-32420(gp)
811092f4:	1009883a 	mov	r4,r2
811092f8:	1131cf80 	call	81131cf8 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
811092fc:	00007406 	br	811094d0 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
81109300:	d0a05817 	ldw	r2,-32416(gp)
81109304:	1009883a 	mov	r4,r2
81109308:	1133ae80 	call	81133ae8 <OSSemPost>
                    	vFailGetMutexReceiverTask();
8110930c:	11114140 	call	81111414 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81109310:	00006f06 	br	811094d0 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
81109314:	11113ac0 	call	811113ac <vFailGetCountSemaphoreReceiverTask>
                }
                break;
81109318:	00006d06 	br	811094d0 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
8110931c:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81109320:	d0a05a83 	ldbu	r2,-32406(gp)
81109324:	10803fcc 	andi	r2,r2,255
81109328:	10800218 	cmpnei	r2,r2,8
8110932c:	1000021e 	bne	r2,zero,81109338 <vInAckHandlerTaskV2+0x1b4>
81109330:	00c00104 	movi	r3,4
81109334:	00000106 	br	8110933c <vInAckHandlerTaskV2+0x1b8>
81109338:	0007883a 	mov	r3,zero
8110933c:	d0a06503 	ldbu	r2,-32364(gp)
81109340:	10803fcc 	andi	r2,r2,255
81109344:	10800218 	cmpnei	r2,r2,8
81109348:	1000021e 	bne	r2,zero,81109354 <vInAckHandlerTaskV2+0x1d0>
8110934c:	00800084 	movi	r2,2
81109350:	00000106 	br	81109358 <vInAckHandlerTaskV2+0x1d4>
81109354:	0005883a 	mov	r2,zero
81109358:	1884b03a 	or	r2,r3,r2
8110935c:	1007883a 	mov	r3,r2
81109360:	d0a06543 	ldbu	r2,-32363(gp)
81109364:	10803fcc 	andi	r2,r2,255
81109368:	108001a0 	cmpeqi	r2,r2,6
8110936c:	1884b03a 	or	r2,r3,r2
81109370:	1007883a 	mov	r3,r2
81109374:	e0bffa83 	ldbu	r2,-22(fp)
81109378:	1884b03a 	or	r2,r3,r2
8110937c:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81109380:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
81109384:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
81109388:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
8110938c:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81109390:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
81109394:	e0bffa03 	ldbu	r2,-24(fp)
81109398:	10800044 	addi	r2,r2,1
8110939c:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
811093a0:	e0bffa83 	ldbu	r2,-22(fp)
811093a4:	1080004c 	andi	r2,r2,1
811093a8:	10803fcc 	andi	r2,r2,255
811093ac:	1000061e 	bne	r2,zero,811093c8 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
811093b0:	e0bffd04 	addi	r2,fp,-12
811093b4:	100b883a 	mov	r5,r2
811093b8:	d1204c04 	addi	r4,gp,-32464
811093bc:	11094d40 	call	811094d4 <bCheckInAck128>
811093c0:	e0bff815 	stw	r2,-32(fp)
811093c4:	00000206 	br	811093d0 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
811093c8:	00800044 	movi	r2,1
811093cc:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
811093d0:	e0bffa83 	ldbu	r2,-22(fp)
811093d4:	1080008c 	andi	r2,r2,2
811093d8:	10803fcc 	andi	r2,r2,255
811093dc:	1000081e 	bne	r2,zero,81109400 <vInAckHandlerTaskV2+0x27c>
811093e0:	e0bff817 	ldw	r2,-32(fp)
811093e4:	1000061e 	bne	r2,zero,81109400 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
811093e8:	e0bffc04 	addi	r2,fp,-16
811093ec:	100b883a 	mov	r5,r2
811093f0:	d1204c04 	addi	r4,gp,-32464
811093f4:	110961c0 	call	8110961c <bCheckInAck64>
811093f8:	e0bff815 	stw	r2,-32(fp)
811093fc:	00000206 	br	81109408 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
81109400:	00800044 	movi	r2,1
81109404:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
81109408:	e0bffa83 	ldbu	r2,-22(fp)
8110940c:	1080010c 	andi	r2,r2,4
81109410:	10803fcc 	andi	r2,r2,255
81109414:	1000081e 	bne	r2,zero,81109438 <vInAckHandlerTaskV2+0x2b4>
81109418:	e0bff817 	ldw	r2,-32(fp)
8110941c:	1000061e 	bne	r2,zero,81109438 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
81109420:	e0bffb04 	addi	r2,fp,-20
81109424:	100b883a 	mov	r5,r2
81109428:	d1204c04 	addi	r4,gp,-32464
8110942c:	11097680 	call	81109768 <bCheckInAck32>
81109430:	e0bff815 	stw	r2,-32(fp)
81109434:	00000206 	br	81109440 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
81109438:	00800044 	movi	r2,1
8110943c:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
81109440:	e0bffa03 	ldbu	r2,-24(fp)
81109444:	10c00044 	addi	r3,r2,1
81109448:	e0fffa05 	stb	r3,-24(fp)
8110944c:	10803fcc 	andi	r2,r2,255
81109450:	10800ca8 	cmpgeui	r2,r2,50
81109454:	10000e1e 	bne	r2,zero,81109490 <vInAckHandlerTaskV2+0x30c>
81109458:	e0bff817 	ldw	r2,-32(fp)
8110945c:	10000c1e 	bne	r2,zero,81109490 <vInAckHandlerTaskV2+0x30c>
81109460:	e0bffb17 	ldw	r2,-20(fp)
81109464:	1005003a 	cmpeq	r2,r2,zero
81109468:	1007883a 	mov	r3,r2
8110946c:	e0bffc17 	ldw	r2,-16(fp)
81109470:	1005003a 	cmpeq	r2,r2,zero
81109474:	1884b03a 	or	r2,r3,r2
81109478:	10c03fcc 	andi	r3,r2,255
8110947c:	e0bffd17 	ldw	r2,-12(fp)
81109480:	1005003a 	cmpeq	r2,r2,zero
81109484:	10803fcc 	andi	r2,r2,255
81109488:	1884b03a 	or	r2,r3,r2
8110948c:	103fc11e 	bne	r2,zero,81109394 <__reset+0xfb0e9394>
                
                if (bFound == FALSE) {
81109490:	e0bff817 	ldw	r2,-32(fp)
81109494:	1000011e 	bne	r2,zero,8110949c <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
81109498:	11118d00 	call	811118d0 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
8110949c:	00800044 	movi	r2,1
811094a0:	e0bff915 	stw	r2,-28(fp)
				break;
811094a4:	00000a06 	br	811094d0 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
811094a8:	d0a05417 	ldw	r2,-32432(gp)
811094ac:	100f883a 	mov	r7,r2
811094b0:	01801144 	movi	r6,69
811094b4:	01400044 	movi	r5,1
811094b8:	01204534 	movhi	r4,33044
811094bc:	21054004 	addi	r4,r4,5376
811094c0:	1115d200 	call	81115d20 <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
811094c4:	00800044 	movi	r2,1
811094c8:	e0bff915 	stw	r2,-28(fp)
				break;
811094cc:	0001883a 	nop
		}
	}
811094d0:	003f4206 	br	811091dc <__reset+0xfb0e91dc>

811094d4 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
811094d4:	defffa04 	addi	sp,sp,-24
811094d8:	de00012e 	bgeu	sp,et,811094e0 <bCheckInAck128+0xc>
811094dc:	003b68fa 	trap	3
811094e0:	dfc00515 	stw	ra,20(sp)
811094e4:	df000415 	stw	fp,16(sp)
811094e8:	df000404 	addi	fp,sp,16
811094ec:	e13ffe15 	stw	r4,-8(fp)
811094f0:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811094f4:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811094f8:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811094fc:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81109500:	e0bfff17 	ldw	r2,-4(fp)
81109504:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
81109508:	d0a05f17 	ldw	r2,-32388(gp)
8110950c:	e0fffd44 	addi	r3,fp,-11
81109510:	180d883a 	mov	r6,r3
81109514:	01400144 	movi	r5,5
81109518:	1009883a 	mov	r4,r2
8110951c:	11317540 	call	81131754 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81109520:	e0bffd43 	ldbu	r2,-11(fp)
81109524:	10803fcc 	andi	r2,r2,255
81109528:	10000226 	beq	r2,zero,81109534 <bCheckInAck128+0x60>
        return bFound;
8110952c:	e0bffc17 	ldw	r2,-16(fp)
81109530:	00003506 	br	81109608 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81109534:	e03ffd05 	stb	zero,-12(fp)
81109538:	00002706 	br	811095d8 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
8110953c:	e0fffd03 	ldbu	r3,-12(fp)
81109540:	00a04574 	movhi	r2,33045
81109544:	1089f404 	addi	r2,r2,10192
81109548:	18c02324 	muli	r3,r3,140
8110954c:	10c5883a 	add	r2,r2,r3
81109550:	10802104 	addi	r2,r2,132
81109554:	10c0000b 	ldhu	r3,0(r2)
81109558:	e0bffe17 	ldw	r2,-8(fp)
8110955c:	1080008b 	ldhu	r2,2(r2)
81109560:	18ffffcc 	andi	r3,r3,65535
81109564:	10bfffcc 	andi	r2,r2,65535
81109568:	1880181e 	bne	r3,r2,811095cc <bCheckInAck128+0xf8>
            bFound = TRUE;
8110956c:	00800044 	movi	r2,1
81109570:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
81109574:	e0fffd03 	ldbu	r3,-12(fp)
81109578:	00a04574 	movhi	r2,33045
8110957c:	1089d604 	addi	r2,r2,10072
81109580:	18c7883a 	add	r3,r3,r3
81109584:	18c7883a 	add	r3,r3,r3
81109588:	10c5883a 	add	r2,r2,r3
8110958c:	10000015 	stw	zero,0(r2)
            SemCount128++;
81109590:	d0a06543 	ldbu	r2,-32363(gp)
81109594:	10800044 	addi	r2,r2,1
81109598:	d0a06545 	stb	r2,-32363(gp)
            error_code = OSSemPost(xSemCountBuffer128);
8110959c:	d0a05517 	ldw	r2,-32428(gp)
811095a0:	1009883a 	mov	r4,r2
811095a4:	1133ae80 	call	81133ae8 <OSSemPost>
811095a8:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
811095ac:	e0bffd43 	ldbu	r2,-11(fp)
811095b0:	10803fcc 	andi	r2,r2,255
811095b4:	10000c26 	beq	r2,zero,811095e8 <bCheckInAck128+0x114>
                SemCount128--;
811095b8:	d0a06543 	ldbu	r2,-32363(gp)
811095bc:	10bfffc4 	addi	r2,r2,-1
811095c0:	d0a06545 	stb	r2,-32363(gp)
                vFailSetCountSemaphorexBuffer128();
811095c4:	11117300 	call	81111730 <vFailSetCountSemaphorexBuffer128>
            }
            break;
811095c8:	00000706 	br	811095e8 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
811095cc:	e0bffd03 	ldbu	r2,-12(fp)
811095d0:	10800044 	addi	r2,r2,1
811095d4:	e0bffd05 	stb	r2,-12(fp)
811095d8:	e0bffd03 	ldbu	r2,-12(fp)
811095dc:	108001b0 	cmpltui	r2,r2,6
811095e0:	103fd61e 	bne	r2,zero,8110953c <__reset+0xfb0e953c>
811095e4:	00000106 	br	811095ec <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
811095e8:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
811095ec:	d0a05f17 	ldw	r2,-32388(gp)
811095f0:	1009883a 	mov	r4,r2
811095f4:	1131cf80 	call	81131cf8 <OSMutexPost>
    (*bFinished) = TRUE;
811095f8:	e0bfff17 	ldw	r2,-4(fp)
811095fc:	00c00044 	movi	r3,1
81109600:	10c00015 	stw	r3,0(r2)

    return bFound;
81109604:	e0bffc17 	ldw	r2,-16(fp)
}
81109608:	e037883a 	mov	sp,fp
8110960c:	dfc00117 	ldw	ra,4(sp)
81109610:	df000017 	ldw	fp,0(sp)
81109614:	dec00204 	addi	sp,sp,8
81109618:	f800283a 	ret

8110961c <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
8110961c:	defffa04 	addi	sp,sp,-24
81109620:	de00012e 	bgeu	sp,et,81109628 <bCheckInAck64+0xc>
81109624:	003b68fa 	trap	3
81109628:	dfc00515 	stw	ra,20(sp)
8110962c:	df000415 	stw	fp,16(sp)
81109630:	df000404 	addi	fp,sp,16
81109634:	e13ffe15 	stw	r4,-8(fp)
81109638:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110963c:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81109640:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81109644:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81109648:	e0bfff17 	ldw	r2,-4(fp)
8110964c:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81109650:	d0a06117 	ldw	r2,-32380(gp)
81109654:	e0fffd44 	addi	r3,fp,-11
81109658:	180d883a 	mov	r6,r3
8110965c:	01400044 	movi	r5,1
81109660:	1009883a 	mov	r4,r2
81109664:	11317540 	call	81131754 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81109668:	e0bffd43 	ldbu	r2,-11(fp)
8110966c:	10803fcc 	andi	r2,r2,255
81109670:	10000226 	beq	r2,zero,8110967c <bCheckInAck64+0x60>
        return bFound;
81109674:	e0bffc17 	ldw	r2,-16(fp)
81109678:	00003606 	br	81109754 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110967c:	e03ffd05 	stb	zero,-12(fp)
81109680:	00002806 	br	81109724 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
81109684:	e0fffd03 	ldbu	r3,-12(fp)
81109688:	00a04574 	movhi	r2,33045
8110968c:	10a53f04 	addi	r2,r2,-27396
81109690:	18c01324 	muli	r3,r3,76
81109694:	10c5883a 	add	r2,r2,r3
81109698:	10801104 	addi	r2,r2,68
8110969c:	10c0000b 	ldhu	r3,0(r2)
811096a0:	e0bffe17 	ldw	r2,-8(fp)
811096a4:	1080008b 	ldhu	r2,2(r2)
811096a8:	18ffffcc 	andi	r3,r3,65535
811096ac:	10bfffcc 	andi	r2,r2,65535
811096b0:	1880191e 	bne	r3,r2,81109718 <bCheckInAck64+0xfc>
            bFound = TRUE;
811096b4:	00800044 	movi	r2,1
811096b8:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
811096bc:	e0fffd03 	ldbu	r3,-12(fp)
811096c0:	00a04574 	movhi	r2,33045
811096c4:	1089d604 	addi	r2,r2,10072
811096c8:	18c00184 	addi	r3,r3,6
811096cc:	18c7883a 	add	r3,r3,r3
811096d0:	18c7883a 	add	r3,r3,r3
811096d4:	10c5883a 	add	r2,r2,r3
811096d8:	10000015 	stw	zero,0(r2)
            SemCount64++;
811096dc:	d0a06503 	ldbu	r2,-32364(gp)
811096e0:	10800044 	addi	r2,r2,1
811096e4:	d0a06505 	stb	r2,-32364(gp)
            error_code = OSSemPost(xSemCountBuffer64);
811096e8:	d0a05117 	ldw	r2,-32444(gp)
811096ec:	1009883a 	mov	r4,r2
811096f0:	1133ae80 	call	81133ae8 <OSSemPost>
811096f4:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
811096f8:	e0bffd43 	ldbu	r2,-11(fp)
811096fc:	10803fcc 	andi	r2,r2,255
81109700:	10000c26 	beq	r2,zero,81109734 <bCheckInAck64+0x118>
                SemCount64--;
81109704:	d0a06503 	ldbu	r2,-32364(gp)
81109708:	10bfffc4 	addi	r2,r2,-1
8110970c:	d0a06505 	stb	r2,-32364(gp)
                vFailSetCountSemaphorexBuffer64();
81109710:	11116c80 	call	811116c8 <vFailSetCountSemaphorexBuffer64>
            }
            break;
81109714:	00000706 	br	81109734 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81109718:	e0bffd03 	ldbu	r2,-12(fp)
8110971c:	10800044 	addi	r2,r2,1
81109720:	e0bffd05 	stb	r2,-12(fp)
81109724:	e0bffd03 	ldbu	r2,-12(fp)
81109728:	10800230 	cmpltui	r2,r2,8
8110972c:	103fd51e 	bne	r2,zero,81109684 <__reset+0xfb0e9684>
81109730:	00000106 	br	81109738 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
81109734:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
81109738:	d0a06117 	ldw	r2,-32380(gp)
8110973c:	1009883a 	mov	r4,r2
81109740:	1131cf80 	call	81131cf8 <OSMutexPost>
    (*bFinished) = TRUE;
81109744:	e0bfff17 	ldw	r2,-4(fp)
81109748:	00c00044 	movi	r3,1
8110974c:	10c00015 	stw	r3,0(r2)

    return bFound;
81109750:	e0bffc17 	ldw	r2,-16(fp)
}
81109754:	e037883a 	mov	sp,fp
81109758:	dfc00117 	ldw	ra,4(sp)
8110975c:	df000017 	ldw	fp,0(sp)
81109760:	dec00204 	addi	sp,sp,8
81109764:	f800283a 	ret

81109768 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
81109768:	defffa04 	addi	sp,sp,-24
8110976c:	de00012e 	bgeu	sp,et,81109774 <bCheckInAck32+0xc>
81109770:	003b68fa 	trap	3
81109774:	dfc00515 	stw	ra,20(sp)
81109778:	df000415 	stw	fp,16(sp)
8110977c:	df000404 	addi	fp,sp,16
81109780:	e13ffe15 	stw	r4,-8(fp)
81109784:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81109788:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110978c:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81109790:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81109794:	e0bfff17 	ldw	r2,-4(fp)
81109798:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110979c:	d0a05d17 	ldw	r2,-32396(gp)
811097a0:	e0fffd44 	addi	r3,fp,-11
811097a4:	180d883a 	mov	r6,r3
811097a8:	01400044 	movi	r5,1
811097ac:	1009883a 	mov	r4,r2
811097b0:	11317540 	call	81131754 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811097b4:	e0bffd43 	ldbu	r2,-11(fp)
811097b8:	10803fcc 	andi	r2,r2,255
811097bc:	10000226 	beq	r2,zero,811097c8 <bCheckInAck32+0x60>
        return bFound;
811097c0:	e0bffc17 	ldw	r2,-16(fp)
811097c4:	00003606 	br	811098a0 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
811097c8:	e03ffd05 	stb	zero,-12(fp)
811097cc:	00002806 	br	81109870 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
811097d0:	e0fffd03 	ldbu	r3,-12(fp)
811097d4:	00a04574 	movhi	r2,33045
811097d8:	10b76a04 	addi	r2,r2,-8792
811097dc:	18c00b24 	muli	r3,r3,44
811097e0:	10c5883a 	add	r2,r2,r3
811097e4:	10800904 	addi	r2,r2,36
811097e8:	10c0000b 	ldhu	r3,0(r2)
811097ec:	e0bffe17 	ldw	r2,-8(fp)
811097f0:	1080008b 	ldhu	r2,2(r2)
811097f4:	18ffffcc 	andi	r3,r3,65535
811097f8:	10bfffcc 	andi	r2,r2,65535
811097fc:	1880191e 	bne	r3,r2,81109864 <bCheckInAck32+0xfc>
            bFound = TRUE;
81109800:	00800044 	movi	r2,1
81109804:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
81109808:	e0fffd03 	ldbu	r3,-12(fp)
8110980c:	00a04574 	movhi	r2,33045
81109810:	1089d604 	addi	r2,r2,10072
81109814:	18c00384 	addi	r3,r3,14
81109818:	18c7883a 	add	r3,r3,r3
8110981c:	18c7883a 	add	r3,r3,r3
81109820:	10c5883a 	add	r2,r2,r3
81109824:	10000015 	stw	zero,0(r2)
            SemCount32++;
81109828:	d0a05a83 	ldbu	r2,-32406(gp)
8110982c:	10800044 	addi	r2,r2,1
81109830:	d0a05a85 	stb	r2,-32406(gp)
            error_code = OSSemPost(xSemCountBuffer32);
81109834:	d0a06017 	ldw	r2,-32384(gp)
81109838:	1009883a 	mov	r4,r2
8110983c:	1133ae80 	call	81133ae8 <OSSemPost>
81109840:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81109844:	e0bffd43 	ldbu	r2,-11(fp)
81109848:	10803fcc 	andi	r2,r2,255
8110984c:	10000c26 	beq	r2,zero,81109880 <bCheckInAck32+0x118>
                SemCount32--;
81109850:	d0a05a83 	ldbu	r2,-32406(gp)
81109854:	10bfffc4 	addi	r2,r2,-1
81109858:	d0a05a85 	stb	r2,-32406(gp)
                vFailSetCountSemaphorexBuffer32();
8110985c:	11116600 	call	81111660 <vFailSetCountSemaphorexBuffer32>
            }
            break;
81109860:	00000706 	br	81109880 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81109864:	e0bffd03 	ldbu	r2,-12(fp)
81109868:	10800044 	addi	r2,r2,1
8110986c:	e0bffd05 	stb	r2,-12(fp)
81109870:	e0bffd03 	ldbu	r2,-12(fp)
81109874:	10800230 	cmpltui	r2,r2,8
81109878:	103fd51e 	bne	r2,zero,811097d0 <__reset+0xfb0e97d0>
8110987c:	00000106 	br	81109884 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
81109880:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
81109884:	d0a05d17 	ldw	r2,-32396(gp)
81109888:	1009883a 	mov	r4,r2
8110988c:	1131cf80 	call	81131cf8 <OSMutexPost>
    (*bFinished) = TRUE;
81109890:	e0bfff17 	ldw	r2,-4(fp)
81109894:	00c00044 	movi	r3,1
81109898:	10c00015 	stw	r3,0(r2)

    return bFound;
8110989c:	e0bffc17 	ldw	r2,-16(fp)
}
811098a0:	e037883a 	mov	sp,fp
811098a4:	dfc00117 	ldw	ra,4(sp)
811098a8:	df000017 	ldw	fp,0(sp)
811098ac:	dec00204 	addi	sp,sp,8
811098b0:	f800283a 	ret

811098b4 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
811098b4:	defff704 	addi	sp,sp,-36
811098b8:	de00012e 	bgeu	sp,et,811098c0 <vInitialTask+0xc>
811098bc:	003b68fa 	trap	3
811098c0:	dfc00815 	stw	ra,32(sp)
811098c4:	df000715 	stw	fp,28(sp)
811098c8:	df000704 	addi	fp,sp,28
811098cc:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
811098d0:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
811098d4:	d8000415 	stw	zero,16(sp)
811098d8:	d8000315 	stw	zero,12(sp)
811098dc:	00810004 	movi	r2,1024
811098e0:	d8800215 	stw	r2,8(sp)
811098e4:	00a04534 	movhi	r2,33044
811098e8:	109d3f04 	addi	r2,r2,29948
811098ec:	d8800115 	stw	r2,4(sp)
811098f0:	00800244 	movi	r2,9
811098f4:	d8800015 	stw	r2,0(sp)
811098f8:	01c00244 	movi	r7,9
811098fc:	01a04574 	movhi	r6,33045
81109900:	31a13e04 	addi	r6,r6,-31496
81109904:	01604574 	movhi	r5,33045
81109908:	29725904 	addi	r5,r5,-13980
8110990c:	01204474 	movhi	r4,33041
81109910:	2121eb04 	addi	r4,r4,-30804
81109914:	11343180 	call	81134318 <OSTaskCreateExt>
81109918:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110991c:	e0bffe03 	ldbu	r2,-8(fp)
81109920:	10803fcc 	andi	r2,r2,255
81109924:	10000526 	beq	r2,zero,8110993c <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109928:	e0bffe03 	ldbu	r2,-8(fp)
8110992c:	10803fcc 	andi	r2,r2,255
81109930:	1009883a 	mov	r4,r2
81109934:	11110280 	call	81111028 <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
81109938:	11124180 	call	81112418 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110993c:	01c17704 	movi	r7,1500
81109940:	000d883a 	mov	r6,zero
81109944:	000b883a 	mov	r5,zero
81109948:	0009883a 	mov	r4,zero
8110994c:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vFeeTask1_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81109950:	d8000415 	stw	zero,16(sp)
81109954:	d8000315 	stw	zero,12(sp)
81109958:	00810004 	movi	r2,1024
8110995c:	d8800215 	stw	r2,8(sp)
81109960:	00a04574 	movhi	r2,33045
81109964:	1092ea04 	addi	r2,r2,19368
81109968:	d8800115 	stw	r2,4(sp)
8110996c:	00800284 	movi	r2,10
81109970:	d8800015 	stw	r2,0(sp)
81109974:	01c00284 	movi	r7,10
81109978:	01a04574 	movhi	r6,33045
8110997c:	3196e904 	addi	r6,r6,23460
81109980:	01604574 	movhi	r5,33045
81109984:	29728504 	addi	r5,r5,-13804
81109988:	01204474 	movhi	r4,33041
8110998c:	2121eb04 	addi	r4,r4,-30804
81109990:	11343180 	call	81134318 <OSTaskCreateExt>
81109994:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109998:	e0bffe03 	ldbu	r2,-8(fp)
8110999c:	10803fcc 	andi	r2,r2,255
811099a0:	10000526 	beq	r2,zero,811099b8 <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
811099a4:	e0bffe03 	ldbu	r2,-8(fp)
811099a8:	10803fcc 	andi	r2,r2,255
811099ac:	1009883a 	mov	r4,r2
811099b0:	11110280 	call	81111028 <printErrorTask>
		#endif
			vCoudlNotCreateNFee1Task();
811099b4:	11124800 	call	81112480 <vCoudlNotCreateNFee1Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
811099b8:	01c17704 	movi	r7,1500
811099bc:	000d883a 	mov	r6,zero
811099c0:	000b883a 	mov	r5,zero
811099c4:	0009883a 	mov	r4,zero
811099c8:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vFeeTask2_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
811099cc:	d8000415 	stw	zero,16(sp)
811099d0:	d8000315 	stw	zero,12(sp)
811099d4:	00810004 	movi	r2,1024
811099d8:	d8800215 	stw	r2,8(sp)
811099dc:	00a045b4 	movhi	r2,33046
811099e0:	10a4ea04 	addi	r2,r2,-27736
811099e4:	d8800115 	stw	r2,4(sp)
811099e8:	008002c4 	movi	r2,11
811099ec:	d8800015 	stw	r2,0(sp)
811099f0:	01c002c4 	movi	r7,11
811099f4:	01a045b4 	movhi	r6,33046
811099f8:	31a8e904 	addi	r6,r6,-23644
811099fc:	01604574 	movhi	r5,33045
81109a00:	2972b104 	addi	r5,r5,-13628
81109a04:	01204474 	movhi	r4,33041
81109a08:	2121eb04 	addi	r4,r4,-30804
81109a0c:	11343180 	call	81134318 <OSTaskCreateExt>
81109a10:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109a14:	e0bffe03 	ldbu	r2,-8(fp)
81109a18:	10803fcc 	andi	r2,r2,255
81109a1c:	10000526 	beq	r2,zero,81109a34 <vInitialTask+0x180>
		//* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109a20:	e0bffe03 	ldbu	r2,-8(fp)
81109a24:	10803fcc 	andi	r2,r2,255
81109a28:	1009883a 	mov	r4,r2
81109a2c:	11110280 	call	81111028 <printErrorTask>
		#endif
			vCoudlNotCreateNFee2Task();
81109a30:	11124e80 	call	811124e8 <vCoudlNotCreateNFee2Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81109a34:	01c17704 	movi	r7,1500
81109a38:	000d883a 	mov	r6,zero
81109a3c:	000b883a 	mov	r5,zero
81109a40:	0009883a 	mov	r4,zero
81109a44:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vFeeTask3_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81109a48:	d8000415 	stw	zero,16(sp)
81109a4c:	d8000315 	stw	zero,12(sp)
81109a50:	00810004 	movi	r2,1024
81109a54:	d8800215 	stw	r2,8(sp)
81109a58:	00a045b4 	movhi	r2,33046
81109a5c:	10a0ea04 	addi	r2,r2,-31832
81109a60:	d8800115 	stw	r2,4(sp)
81109a64:	00800304 	movi	r2,12
81109a68:	d8800015 	stw	r2,0(sp)
81109a6c:	01c00304 	movi	r7,12
81109a70:	01a045b4 	movhi	r6,33046
81109a74:	31a4e904 	addi	r6,r6,-27740
81109a78:	01604574 	movhi	r5,33045
81109a7c:	2972dd04 	addi	r5,r5,-13452
81109a80:	01204474 	movhi	r4,33041
81109a84:	2121eb04 	addi	r4,r4,-30804
81109a88:	11343180 	call	81134318 <OSTaskCreateExt>
81109a8c:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109a90:	e0bffe03 	ldbu	r2,-8(fp)
81109a94:	10803fcc 	andi	r2,r2,255
81109a98:	10000526 	beq	r2,zero,81109ab0 <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109a9c:	e0bffe03 	ldbu	r2,-8(fp)
81109aa0:	10803fcc 	andi	r2,r2,255
81109aa4:	1009883a 	mov	r4,r2
81109aa8:	11110280 	call	81111028 <printErrorTask>
		#endif
			vCoudlNotCreateNFee3Task();
81109aac:	11125500 	call	81112550 <vCoudlNotCreateNFee3Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81109ab0:	01c17704 	movi	r7,1500
81109ab4:	000d883a 	mov	r6,zero
81109ab8:	000b883a 	mov	r5,zero
81109abc:	0009883a 	mov	r4,zero
81109ac0:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vFeeTask4_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81109ac4:	d8000415 	stw	zero,16(sp)
81109ac8:	d8000315 	stw	zero,12(sp)
81109acc:	00810004 	movi	r2,1024
81109ad0:	d8800215 	stw	r2,8(sp)
81109ad4:	00a04574 	movhi	r2,33045
81109ad8:	108ee404 	addi	r2,r2,15248
81109adc:	d8800115 	stw	r2,4(sp)
81109ae0:	00800344 	movi	r2,13
81109ae4:	d8800015 	stw	r2,0(sp)
81109ae8:	01c00344 	movi	r7,13
81109aec:	01a04574 	movhi	r6,33045
81109af0:	3192e304 	addi	r6,r6,19340
81109af4:	01604574 	movhi	r5,33045
81109af8:	29730904 	addi	r5,r5,-13276
81109afc:	01204474 	movhi	r4,33041
81109b00:	2121eb04 	addi	r4,r4,-30804
81109b04:	11343180 	call	81134318 <OSTaskCreateExt>
81109b08:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109b0c:	e0bffe03 	ldbu	r2,-8(fp)
81109b10:	10803fcc 	andi	r2,r2,255
81109b14:	10000526 	beq	r2,zero,81109b2c <vInitialTask+0x278>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109b18:	e0bffe03 	ldbu	r2,-8(fp)
81109b1c:	10803fcc 	andi	r2,r2,255
81109b20:	1009883a 	mov	r4,r2
81109b24:	11110280 	call	81111028 <printErrorTask>
		#endif
			vCoudlNotCreateNFee4Task();
81109b28:	11125b80 	call	811125b8 <vCoudlNotCreateNFee4Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81109b2c:	01c17704 	movi	r7,1500
81109b30:	000d883a 	mov	r6,zero
81109b34:	000b883a 	mov	r5,zero
81109b38:	0009883a 	mov	r4,zero
81109b3c:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vFeeTask5_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81109b40:	d8000415 	stw	zero,16(sp)
81109b44:	d8000315 	stw	zero,12(sp)
81109b48:	00810004 	movi	r2,1024
81109b4c:	d8800215 	stw	r2,8(sp)
81109b50:	00a04574 	movhi	r2,33045
81109b54:	10b36a04 	addi	r2,r2,-12888
81109b58:	d8800115 	stw	r2,4(sp)
81109b5c:	00800384 	movi	r2,14
81109b60:	d8800015 	stw	r2,0(sp)
81109b64:	01c00384 	movi	r7,14
81109b68:	01a04574 	movhi	r6,33045
81109b6c:	31b76904 	addi	r6,r6,-8796
81109b70:	01604574 	movhi	r5,33045
81109b74:	29733504 	addi	r5,r5,-13100
81109b78:	01204474 	movhi	r4,33041
81109b7c:	2121eb04 	addi	r4,r4,-30804
81109b80:	11343180 	call	81134318 <OSTaskCreateExt>
81109b84:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109b88:	e0bffe03 	ldbu	r2,-8(fp)
81109b8c:	10803fcc 	andi	r2,r2,255
81109b90:	10000526 	beq	r2,zero,81109ba8 <vInitialTask+0x2f4>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109b94:	e0bffe03 	ldbu	r2,-8(fp)
81109b98:	10803fcc 	andi	r2,r2,255
81109b9c:	1009883a 	mov	r4,r2
81109ba0:	11110280 	call	81111028 <printErrorTask>
		#endif
			vCoudlNotCreateNFee5Task();
81109ba4:	11126200 	call	81112620 <vCoudlNotCreateNFee5Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81109ba8:	01c17704 	movi	r7,1500
81109bac:	000d883a 	mov	r6,zero
81109bb0:	000b883a 	mov	r5,zero
81109bb4:	0009883a 	mov	r4,zero
81109bb8:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
81109bbc:	d8000415 	stw	zero,16(sp)
81109bc0:	d8000315 	stw	zero,12(sp)
81109bc4:	00810004 	movi	r2,1024
81109bc8:	d8800215 	stw	r2,8(sp)
81109bcc:	00a04574 	movhi	r2,33045
81109bd0:	10ae3b04 	addi	r2,r2,-18196
81109bd4:	d8800115 	stw	r2,4(sp)
81109bd8:	00800204 	movi	r2,8
81109bdc:	d8800015 	stw	r2,0(sp)
81109be0:	01c00204 	movi	r7,8
81109be4:	01a04574 	movhi	r6,33045
81109be8:	31b23a04 	addi	r6,r6,-14104
81109bec:	01604574 	movhi	r5,33045
81109bf0:	29724204 	addi	r5,r5,-14072
81109bf4:	01204474 	movhi	r4,33041
81109bf8:	2121d404 	addi	r4,r4,-30896
81109bfc:	11343180 	call	81134318 <OSTaskCreateExt>
81109c00:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109c04:	e0bffe03 	ldbu	r2,-8(fp)
81109c08:	10803fcc 	andi	r2,r2,255
81109c0c:	10000526 	beq	r2,zero,81109c24 <vInitialTask+0x370>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109c10:	e0bffe03 	ldbu	r2,-8(fp)
81109c14:	10803fcc 	andi	r2,r2,255
81109c18:	1009883a 	mov	r4,r2
81109c1c:	11110280 	call	81111028 <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
81109c20:	11126f00 	call	811126f0 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81109c24:	01c17704 	movi	r7,1500
81109c28:	000d883a 	mov	r6,zero
81109c2c:	000b883a 	mov	r5,zero
81109c30:	0009883a 	mov	r4,zero
81109c34:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
81109c38:	d8000415 	stw	zero,16(sp)
81109c3c:	d8000315 	stw	zero,12(sp)
81109c40:	00810004 	movi	r2,1024
81109c44:	d8800215 	stw	r2,8(sp)
81109c48:	00a04574 	movhi	r2,33045
81109c4c:	108ada04 	addi	r2,r2,11112
81109c50:	d8800115 	stw	r2,4(sp)
81109c54:	008001c4 	movi	r2,7
81109c58:	d8800015 	stw	r2,0(sp)
81109c5c:	01c001c4 	movi	r7,7
81109c60:	01a04574 	movhi	r6,33045
81109c64:	318ed904 	addi	r6,r6,15204
81109c68:	01604574 	movhi	r5,33045
81109c6c:	29725904 	addi	r5,r5,-13980
81109c70:	01204474 	movhi	r4,33041
81109c74:	21282904 	addi	r4,r4,-24412
81109c78:	11343180 	call	81134318 <OSTaskCreateExt>
81109c7c:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109c80:	e0bffe03 	ldbu	r2,-8(fp)
81109c84:	10803fcc 	andi	r2,r2,255
81109c88:	10000526 	beq	r2,zero,81109ca0 <vInitialTask+0x3ec>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109c8c:	e0bffe03 	ldbu	r2,-8(fp)
81109c90:	10803fcc 	andi	r2,r2,255
81109c94:	1009883a 	mov	r4,r2
81109c98:	11110280 	call	81111028 <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
81109c9c:	11126880 	call	81112688 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81109ca0:	01c17704 	movi	r7,1500
81109ca4:	000d883a 	mov	r6,zero
81109ca8:	000b883a 	mov	r5,zero
81109cac:	0009883a 	mov	r4,zero
81109cb0:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
81109cb4:	d8000415 	stw	zero,16(sp)
81109cb8:	d8000315 	stw	zero,12(sp)
81109cbc:	00810004 	movi	r2,1024
81109cc0:	d8800215 	stw	r2,8(sp)
81109cc4:	00a04574 	movhi	r2,33045
81109cc8:	109cea04 	addi	r2,r2,29608
81109ccc:	d8800115 	stw	r2,4(sp)
81109cd0:	00800184 	movi	r2,6
81109cd4:	d8800015 	stw	r2,0(sp)
81109cd8:	01c00184 	movi	r7,6
81109cdc:	01a045b4 	movhi	r6,33046
81109ce0:	31a0e904 	addi	r6,r6,-31836
81109ce4:	01604574 	movhi	r5,33045
81109ce8:	29723b04 	addi	r5,r5,-14100
81109cec:	01204474 	movhi	r4,33041
81109cf0:	21314904 	addi	r4,r4,-15068
81109cf4:	11343180 	call	81134318 <OSTaskCreateExt>
81109cf8:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109cfc:	e0bffe03 	ldbu	r2,-8(fp)
81109d00:	10803fcc 	andi	r2,r2,255
81109d04:	10000526 	beq	r2,zero,81109d1c <vInitialTask+0x468>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109d08:	e0bffe03 	ldbu	r2,-8(fp)
81109d0c:	10803fcc 	andi	r2,r2,255
81109d10:	1009883a 	mov	r4,r2
81109d14:	11110280 	call	81111028 <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
81109d18:	11127580 	call	81112758 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81109d1c:	01c17704 	movi	r7,1500
81109d20:	000d883a 	mov	r6,zero
81109d24:	000b883a 	mov	r5,zero
81109d28:	0009883a 	mov	r4,zero
81109d2c:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
81109d30:	d8000415 	stw	zero,16(sp)
81109d34:	d8000315 	stw	zero,12(sp)
81109d38:	00810004 	movi	r2,1024
81109d3c:	d8800215 	stw	r2,8(sp)
81109d40:	00a04574 	movhi	r2,33045
81109d44:	10aa3b04 	addi	r2,r2,-22292
81109d48:	d8800115 	stw	r2,4(sp)
81109d4c:	00800784 	movi	r2,30
81109d50:	d8800015 	stw	r2,0(sp)
81109d54:	01c00784 	movi	r7,30
81109d58:	01a04574 	movhi	r6,33045
81109d5c:	31ae3a04 	addi	r6,r6,-18200
81109d60:	000b883a 	mov	r5,zero
81109d64:	01204474 	movhi	r4,33041
81109d68:	21365a04 	addi	r4,r4,-9880
81109d6c:	11343180 	call	81134318 <OSTaskCreateExt>
81109d70:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109d74:	e0bffe03 	ldbu	r2,-8(fp)
81109d78:	10803fcc 	andi	r2,r2,255
81109d7c:	10000526 	beq	r2,zero,81109d94 <vInitialTask+0x4e0>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109d80:	e0bffe03 	ldbu	r2,-8(fp)
81109d84:	10803fcc 	andi	r2,r2,255
81109d88:	1009883a 	mov	r4,r2
81109d8c:	11110280 	call	81111028 <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
81109d90:	1111df40 	call	81111df4 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81109d94:	01c03204 	movi	r7,200
81109d98:	000d883a 	mov	r6,zero
81109d9c:	000b883a 	mov	r5,zero
81109da0:	0009883a 	mov	r4,zero
81109da4:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
81109da8:	d8000415 	stw	zero,16(sp)
81109dac:	d8000315 	stw	zero,12(sp)
81109db0:	00810004 	movi	r2,1024
81109db4:	d8800215 	stw	r2,8(sp)
81109db8:	00a04574 	movhi	r2,33045
81109dbc:	10bdd204 	addi	r2,r2,-2232
81109dc0:	d8800115 	stw	r2,4(sp)
81109dc4:	008006c4 	movi	r2,27
81109dc8:	d8800015 	stw	r2,0(sp)
81109dcc:	01c006c4 	movi	r7,27
81109dd0:	01a04574 	movhi	r6,33045
81109dd4:	3181d104 	addi	r6,r6,1860
81109dd8:	000b883a 	mov	r5,zero
81109ddc:	01204474 	movhi	r4,33041
81109de0:	21298b04 	addi	r4,r4,-22996
81109de4:	11343180 	call	81134318 <OSTaskCreateExt>
81109de8:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109dec:	e0bffe03 	ldbu	r2,-8(fp)
81109df0:	10803fcc 	andi	r2,r2,255
81109df4:	10000526 	beq	r2,zero,81109e0c <vInitialTask+0x558>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109df8:	e0bffe03 	ldbu	r2,-8(fp)
81109dfc:	10803fcc 	andi	r2,r2,255
81109e00:	1009883a 	mov	r4,r2
81109e04:	11110280 	call	81111028 <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
81109e08:	1111d100 	call	81111d10 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81109e0c:	01c03204 	movi	r7,200
81109e10:	000d883a 	mov	r6,zero
81109e14:	000b883a 	mov	r5,zero
81109e18:	0009883a 	mov	r4,zero
81109e1c:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
81109e20:	d8000415 	stw	zero,16(sp)
81109e24:	d8000315 	stw	zero,12(sp)
81109e28:	00810004 	movi	r2,1024
81109e2c:	d8800215 	stw	r2,8(sp)
81109e30:	00a04574 	movhi	r2,33045
81109e34:	10a13f04 	addi	r2,r2,-31492
81109e38:	d8800115 	stw	r2,4(sp)
81109e3c:	00800644 	movi	r2,25
81109e40:	d8800015 	stw	r2,0(sp)
81109e44:	01c00644 	movi	r7,25
81109e48:	01a04574 	movhi	r6,33045
81109e4c:	31a53e04 	addi	r6,r6,-27400
81109e50:	000b883a 	mov	r5,zero
81109e54:	01204474 	movhi	r4,33041
81109e58:	21246104 	addi	r4,r4,-28284
81109e5c:	11343180 	call	81134318 <OSTaskCreateExt>
81109e60:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109e64:	e0bffe03 	ldbu	r2,-8(fp)
81109e68:	10803fcc 	andi	r2,r2,255
81109e6c:	10000526 	beq	r2,zero,81109e84 <vInitialTask+0x5d0>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109e70:	e0bffe03 	ldbu	r2,-8(fp)
81109e74:	10803fcc 	andi	r2,r2,255
81109e78:	1009883a 	mov	r4,r2
81109e7c:	11110280 	call	81111028 <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
81109e80:	1111cc40 	call	81111cc4 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81109e84:	01c03204 	movi	r7,200
81109e88:	000d883a 	mov	r6,zero
81109e8c:	000b883a 	mov	r5,zero
81109e90:	0009883a 	mov	r4,zero
81109e94:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
81109e98:	d8000415 	stw	zero,16(sp)
81109e9c:	d8000315 	stw	zero,12(sp)
81109ea0:	00818004 	movi	r2,1536
81109ea4:	d8800215 	stw	r2,8(sp)
81109ea8:	00a04574 	movhi	r2,33045
81109eac:	1096ea04 	addi	r2,r2,23464
81109eb0:	d8800115 	stw	r2,4(sp)
81109eb4:	00800704 	movi	r2,28
81109eb8:	d8800015 	stw	r2,0(sp)
81109ebc:	01c00704 	movi	r7,28
81109ec0:	01a04574 	movhi	r6,33045
81109ec4:	319ce904 	addi	r6,r6,29604
81109ec8:	000b883a 	mov	r5,zero
81109ecc:	01204474 	movhi	r4,33041
81109ed0:	212a4904 	addi	r4,r4,-22236
81109ed4:	11343180 	call	81134318 <OSTaskCreateExt>
81109ed8:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109edc:	e0bffe03 	ldbu	r2,-8(fp)
81109ee0:	10803fcc 	andi	r2,r2,255
81109ee4:	10000526 	beq	r2,zero,81109efc <vInitialTask+0x648>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81109ee8:	e0bffe03 	ldbu	r2,-8(fp)
81109eec:	10803fcc 	andi	r2,r2,255
81109ef0:	1009883a 	mov	r4,r2
81109ef4:	11110280 	call	81111028 <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
81109ef8:	1111c780 	call	81111c78 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81109efc:	01c03204 	movi	r7,200
81109f00:	000d883a 	mov	r6,zero
81109f04:	000b883a 	mov	r5,zero
81109f08:	0009883a 	mov	r4,zero
81109f0c:	11355440 	call	81135544 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
81109f10:	d8000415 	stw	zero,16(sp)
81109f14:	d8000315 	stw	zero,12(sp)
81109f18:	00818004 	movi	r2,1536
81109f1c:	d8800215 	stw	r2,8(sp)
81109f20:	00a04574 	movhi	r2,33045
81109f24:	10b7c204 	addi	r2,r2,-8440
81109f28:	d8800115 	stw	r2,4(sp)
81109f2c:	00800804 	movi	r2,32
81109f30:	d8800015 	stw	r2,0(sp)
81109f34:	01c00804 	movi	r7,32
81109f38:	01a04574 	movhi	r6,33045
81109f3c:	31bdc104 	addi	r6,r6,-2300
81109f40:	000b883a 	mov	r5,zero
81109f44:	01204474 	movhi	r4,33041
81109f48:	212e6904 	addi	r4,r4,-18012
81109f4c:	11343180 	call	81134318 <OSTaskCreateExt>
81109f50:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109f54:	e0bffe03 	ldbu	r2,-8(fp)
81109f58:	10803fcc 	andi	r2,r2,255
81109f5c:	10000526 	beq	r2,zero,81109f74 <vInitialTask+0x6c0>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81109f60:	e0bffe03 	ldbu	r2,-8(fp)
81109f64:	10803fcc 	andi	r2,r2,255
81109f68:	1009883a 	mov	r4,r2
81109f6c:	11110280 	call	81111028 <printErrorTask>
		#endif
		vFailReceiverCreate();
81109f70:	111157c0 	call	8111157c <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81109f74:	01c03204 	movi	r7,200
81109f78:	000d883a 	mov	r6,zero
81109f7c:	000b883a 	mov	r5,zero
81109f80:	0009883a 	mov	r4,zero
81109f84:	11355440 	call	81135544 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
81109f88:	d8000415 	stw	zero,16(sp)
81109f8c:	d8000315 	stw	zero,12(sp)
81109f90:	00810004 	movi	r2,1024
81109f94:	d8800215 	stw	r2,8(sp)
81109f98:	00a04574 	movhi	r2,33045
81109f9c:	10a62f04 	addi	r2,r2,-26436
81109fa0:	d8800115 	stw	r2,4(sp)
81109fa4:	00800684 	movi	r2,26
81109fa8:	d8800015 	stw	r2,0(sp)
81109fac:	01c00684 	movi	r7,26
81109fb0:	01a04574 	movhi	r6,33045
81109fb4:	31aa2e04 	addi	r6,r6,-22344
81109fb8:	000b883a 	mov	r5,zero
81109fbc:	01204474 	movhi	r4,33041
81109fc0:	2130eb04 	addi	r4,r4,-15444
81109fc4:	11343180 	call	81134318 <OSTaskCreateExt>
81109fc8:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
81109fcc:	01c03204 	movi	r7,200
81109fd0:	000d883a 	mov	r6,zero
81109fd4:	000b883a 	mov	r5,zero
81109fd8:	0009883a 	mov	r4,zero
81109fdc:	11355440 	call	81135544 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
81109fe0:	e0bffe03 	ldbu	r2,-8(fp)
81109fe4:	10803fcc 	andi	r2,r2,255
81109fe8:	10000526 	beq	r2,zero,8110a000 <vInitialTask+0x74c>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81109fec:	e0bffe03 	ldbu	r2,-8(fp)
81109ff0:	10803fcc 	andi	r2,r2,255
81109ff4:	1009883a 	mov	r4,r2
81109ff8:	11110280 	call	81111028 <printErrorTask>
		#endif
		vFailSenderCreate();
81109ffc:	11115c80 	call	811115c8 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
8110a000:	d0a05e17 	ldw	r2,-32392(gp)
8110a004:	e17ffe04 	addi	r5,fp,-8
8110a008:	1009883a 	mov	r4,r2
8110a00c:	11360380 	call	81136038 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
8110a010:	e0bffe03 	ldbu	r2,-8(fp)
8110a014:	10803fcc 	andi	r2,r2,255
8110a018:	10000126 	beq	r2,zero,8110a020 <vInitialTask+0x76c>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
8110a01c:	11120b00 	call	811120b0 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
8110a020:	01c00084 	movi	r7,2
8110a024:	01800784 	movi	r6,30
8110a028:	000b883a 	mov	r5,zero
8110a02c:	0009883a 	mov	r4,zero
8110a030:	11355440 	call	81135544 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
8110a034:	01003fc4 	movi	r4,255
8110a038:	11345040 	call	81134504 <OSTaskDel>
8110a03c:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
8110a040:	e0bffe03 	ldbu	r2,-8(fp)
8110a044:	10803fcc 	andi	r2,r2,255
8110a048:	10001026 	beq	r2,zero,8110a08c <vInitialTask+0x7d8>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110a04c:	e0bffe03 	ldbu	r2,-8(fp)
8110a050:	10803fcc 	andi	r2,r2,255
8110a054:	1009883a 	mov	r4,r2
8110a058:	11110280 	call	81111028 <printErrorTask>
		#endif
		vFailDeleteInitialization();
8110a05c:	11116140 	call	81111614 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
8110a060:	014009c4 	movi	r5,39
8110a064:	01000044 	movi	r4,1
8110a068:	1133e200 	call	81133e20 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
8110a06c:	01003fc4 	movi	r4,255
8110a070:	11345040 	call	81134504 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
8110a074:	000f883a 	mov	r7,zero
8110a078:	01800284 	movi	r6,10
8110a07c:	000b883a 	mov	r5,zero
8110a080:	0009883a 	mov	r4,zero
8110a084:	11355440 	call	81135544 <OSTimeDlyHMSM>
		}
8110a088:	003ff806 	br	8110a06c <__reset+0xfb0ea06c>
	}

}
8110a08c:	0001883a 	nop
8110a090:	e037883a 	mov	sp,fp
8110a094:	dfc00117 	ldw	ra,4(sp)
8110a098:	df000017 	ldw	fp,0(sp)
8110a09c:	dec00204 	addi	sp,sp,8
8110a0a0:	f800283a 	ret

8110a0a4 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
8110a0a4:	defff804 	addi	sp,sp,-32
8110a0a8:	de00012e 	bgeu	sp,et,8110a0b0 <vNFeeControlTask+0xc>
8110a0ac:	003b68fa 	trap	3
8110a0b0:	dfc00715 	stw	ra,28(sp)
8110a0b4:	df000615 	stw	fp,24(sp)
8110a0b8:	df000604 	addi	fp,sp,24
8110a0bc:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	INT8U error_codeCtrl;
	unsigned char ucFeeInstL;
	static bool bDmaBack;

	pxFeeC = (TNFee_Control *) task_data;
8110a0c0:	e0bfff17 	ldw	r2,-4(fp)
8110a0c4:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
8110a0c8:	d0a05417 	ldw	r2,-32432(gp)
8110a0cc:	100f883a 	mov	r7,r2
8110a0d0:	01800804 	movi	r6,32
8110a0d4:	01400044 	movi	r5,1
8110a0d8:	01204534 	movhi	r4,33044
8110a0dc:	21055204 	addi	r4,r4,5448
8110a0e0:	1115d200 	call	81115d20 <fwrite>
    #endif

	bCmdSent = FALSE;
8110a0e4:	e03ffb15 	stw	zero,-20(fp)
	bDmaBack = TRUE;
8110a0e8:	00800044 	movi	r2,1
8110a0ec:	d0a04d15 	stw	r2,-32460(gp)
		/* todo: Tem os mesmos estados que o SIMUCAM : Config e Running */
		/* todo: No config ou a Meb ira configurar sozinha os FEEs e os controladores ou ir� passar a mensagem completa sem usar a QueueMask */
		/* todo: No modo Running o NFEE control s� utiliza o Queue MAsk pois � mais rapido e s� transmite no Qmask tbm */

		
		switch (pxFeeC->sMode)
8110a0f0:	e0bffa17 	ldw	r2,-24(fp)
8110a0f4:	10810f17 	ldw	r2,1084(r2)
8110a0f8:	10000326 	beq	r2,zero,8110a108 <vNFeeControlTask+0x64>
8110a0fc:	10800060 	cmpeqi	r2,r2,1
8110a100:	1000201e 	bne	r2,zero,8110a184 <vNFeeControlTask+0xe0>
8110a104:	00006806 	br	8110a2a8 <vNFeeControlTask+0x204>
		{
			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_code); /* Blocking operation */
8110a108:	d0a04a17 	ldw	r2,-32472(gp)
8110a10c:	e0fffe04 	addi	r3,fp,-8
8110a110:	180d883a 	mov	r6,r3
8110a114:	000b883a 	mov	r5,zero
8110a118:	1009883a 	mov	r4,r2
8110a11c:	11328680 	call	81132868 <OSQPend>
8110a120:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8110a124:	e0bffe03 	ldbu	r2,-8(fp)
8110a128:	10803fcc 	andi	r2,r2,255
8110a12c:	1000131e 	bne	r2,zero,8110a17c <vNFeeControlTask+0xd8>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110a130:	e0bffdc3 	ldbu	r2,-9(fp)
8110a134:	10803fcc 	andi	r2,r2,255
8110a138:	10800418 	cmpnei	r2,r2,16
8110a13c:	1000051e 	bne	r2,zero,8110a154 <vNFeeControlTask+0xb0>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
8110a140:	e0bffd17 	ldw	r2,-12(fp)
8110a144:	e17ffa17 	ldw	r5,-24(fp)
8110a148:	1009883a 	mov	r4,r2
8110a14c:	110a2d80 	call	8110a2d8 <vPerformActionNFCConfig>
8110a150:	00000706 	br	8110a170 <vNFeeControlTask+0xcc>

					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"Provavel para FEE (Remover)\n");
8110a154:	d0a05417 	ldw	r2,-32432(gp)
8110a158:	100f883a 	mov	r7,r2
8110a15c:	01800704 	movi	r6,28
8110a160:	01400044 	movi	r5,1
8110a164:	01204534 	movhi	r4,33044
8110a168:	21055b04 	addi	r4,r4,5484
8110a16c:	1115d200 	call	81115d20 <fwrite>
						#endif
					}

					bDmaBack = TRUE;
8110a170:	00800044 	movi	r2,1
8110a174:	d0a04d15 	stw	r2,-32460(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
8110a178:	00005606 	br	8110a2d4 <vNFeeControlTask+0x230>
					}

					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
8110a17c:	11129f00 	call	811129f0 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
8110a180:	00005406 	br	8110a2d4 <vNFeeControlTask+0x230>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
8110a184:	d0a04d17 	ldw	r2,-32460(gp)
8110a188:	10800058 	cmpnei	r2,r2,1
8110a18c:	1000181e 	bne	r2,zero,8110a1f0 <vNFeeControlTask+0x14c>
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 2, &error_code);
8110a190:	d0a05017 	ldw	r2,-32448(gp)
8110a194:	e0fffe04 	addi	r3,fp,-8
8110a198:	180d883a 	mov	r6,r3
8110a19c:	01400084 	movi	r5,2
8110a1a0:	1009883a 	mov	r4,r2
8110a1a4:	11328680 	call	81132868 <OSQPend>
8110a1a8:	e0bffd15 	stw	r2,-12(fp)
					if ( error_code == OS_ERR_NONE ) {
8110a1ac:	e0bffe03 	ldbu	r2,-8(fp)
8110a1b0:	10803fcc 	andi	r2,r2,255
8110a1b4:	10000e1e 	bne	r2,zero,8110a1f0 <vNFeeControlTask+0x14c>
						ucFeeInstL = uiCmdNFC.ucByte[0];
8110a1b8:	e0bffd03 	ldbu	r2,-12(fp)
8110a1bc:	e0bffc05 	stb	r2,-16(fp)

						bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
8110a1c0:	e0bffc03 	ldbu	r2,-16(fp)
8110a1c4:	e0fffc03 	ldbu	r3,-16(fp)
8110a1c8:	180f883a 	mov	r7,r3
8110a1cc:	000d883a 	mov	r6,zero
8110a1d0:	014023c4 	movi	r5,143
8110a1d4:	1009883a 	mov	r4,r2
8110a1d8:	110a5600 	call	8110a560 <bSendCmdQToNFeeInst>
8110a1dc:	e0bffb15 	stw	r2,-20(fp)
						if ( bCmdSent == TRUE )
8110a1e0:	e0bffb17 	ldw	r2,-20(fp)
8110a1e4:	10800058 	cmpnei	r2,r2,1
8110a1e8:	1000011e 	bne	r2,zero,8110a1f0 <vNFeeControlTask+0x14c>
							bDmaBack = FALSE;
8110a1ec:	d0204d15 	stw	zero,-32460(gp)
					}
				} 

				if ( bDmaBack == FALSE )
8110a1f0:	d0a04d17 	ldw	r2,-32460(gp)
8110a1f4:	1000081e 	bne	r2,zero,8110a218 <vNFeeControlTask+0x174>
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
8110a1f8:	d0a04a17 	ldw	r2,-32472(gp)
8110a1fc:	e0fffe44 	addi	r3,fp,-7
8110a200:	180d883a 	mov	r6,r3
8110a204:	000b883a 	mov	r5,zero
8110a208:	1009883a 	mov	r4,r2
8110a20c:	11328680 	call	81132868 <OSQPend>
8110a210:	e0bffd15 	stw	r2,-12(fp)
8110a214:	00000706 	br	8110a234 <vNFeeControlTask+0x190>
				else
					/* If No FEE has the DMA */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 2, &error_codeCtrl);
8110a218:	d0a04a17 	ldw	r2,-32472(gp)
8110a21c:	e0fffe44 	addi	r3,fp,-7
8110a220:	180d883a 	mov	r6,r3
8110a224:	01400084 	movi	r5,2
8110a228:	1009883a 	mov	r4,r2
8110a22c:	11328680 	call	81132868 <OSQPend>
8110a230:	e0bffd15 	stw	r2,-12(fp)

				if ( error_codeCtrl == OS_ERR_NONE ){
8110a234:	e0bffe43 	ldbu	r2,-7(fp)
8110a238:	10803fcc 	andi	r2,r2,255
8110a23c:	1000241e 	bne	r2,zero,8110a2d0 <vNFeeControlTask+0x22c>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
8110a240:	e0bffd83 	ldbu	r2,-10(fp)
8110a244:	10803fcc 	andi	r2,r2,255
8110a248:	10802058 	cmpnei	r2,r2,129
8110a24c:	1000031e 	bne	r2,zero,8110a25c <vNFeeControlTask+0x1b8>
						bDmaBack = TRUE;
8110a250:	00800044 	movi	r2,1
8110a254:	d0a04d15 	stw	r2,-32460(gp)
						}
						bDmaBack = FALSE;
					}
				}
				
				break;		
8110a258:	00001d06 	br	8110a2d0 <vNFeeControlTask+0x22c>
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
						bDmaBack = TRUE;
					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110a25c:	e0bffdc3 	ldbu	r2,-9(fp)
8110a260:	10803fcc 	andi	r2,r2,255
8110a264:	10800418 	cmpnei	r2,r2,16
8110a268:	1000051e 	bne	r2,zero,8110a280 <vNFeeControlTask+0x1dc>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
8110a26c:	e0bffd17 	ldw	r2,-12(fp)
8110a270:	e17ffa17 	ldw	r5,-24(fp)
8110a274:	1009883a 	mov	r4,r2
8110a278:	110a4240 	call	8110a424 <vPerformActionNFCRunning>
8110a27c:	00000806 	br	8110a2a0 <vNFeeControlTask+0x1fc>

						} else {
							#ifdef DEBUG_ON
								fprintf(fp,"NFEE Controller Task: Command Ignored. Not Addressed to Meb. ADDR= %ui\n", uiCmdNFC.ucByte[3]);
8110a280:	d0a05417 	ldw	r2,-32432(gp)
8110a284:	e0fffdc3 	ldbu	r3,-9(fp)
8110a288:	18c03fcc 	andi	r3,r3,255
8110a28c:	180d883a 	mov	r6,r3
8110a290:	01604534 	movhi	r5,33044
8110a294:	29456304 	addi	r5,r5,5516
8110a298:	1009883a 	mov	r4,r2
8110a29c:	11156840 	call	81115684 <fprintf>
							#endif
						}
						bDmaBack = FALSE;
8110a2a0:	d0204d15 	stw	zero,-32460(gp)
					}
				}
				
				break;		
8110a2a4:	00000a06 	br	8110a2d0 <vNFeeControlTask+0x22c>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknow state, backing to Config Mode.\n");
8110a2a8:	d0a05417 	ldw	r2,-32432(gp)
8110a2ac:	100f883a 	mov	r7,r2
8110a2b0:	01800f04 	movi	r6,60
8110a2b4:	01400044 	movi	r5,1
8110a2b8:	01204534 	movhi	r4,33044
8110a2bc:	21057504 	addi	r4,r4,5588
8110a2c0:	1115d200 	call	81115d20 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudança de esteado aqui */
				pxFeeC->sMode = sMebConfig;
8110a2c4:	e0bffa17 	ldw	r2,-24(fp)
8110a2c8:	10010f15 	stw	zero,1084(r2)
				break;
8110a2cc:	00000106 	br	8110a2d4 <vNFeeControlTask+0x230>
						}
						bDmaBack = FALSE;
					}
				}
				
				break;		
8110a2d0:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudança de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
8110a2d4:	003f8606 	br	8110a0f0 <__reset+0xfb0ea0f0>

8110a2d8 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110a2d8:	defffa04 	addi	sp,sp,-24
8110a2dc:	de00012e 	bgeu	sp,et,8110a2e4 <vPerformActionNFCConfig+0xc>
8110a2e0:	003b68fa 	trap	3
8110a2e4:	dfc00515 	stw	ra,20(sp)
8110a2e8:	df000415 	stw	fp,16(sp)
8110a2ec:	df000404 	addi	fp,sp,16
8110a2f0:	e13ffe15 	stw	r4,-8(fp)
8110a2f4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
8110a2f8:	e0bffe17 	ldw	r2,-8(fp)
8110a2fc:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110a300:	e0bffd83 	ldbu	r2,-10(fp)
8110a304:	10803fcc 	andi	r2,r2,255
8110a308:	10c00060 	cmpeqi	r3,r2,1
8110a30c:	1800031e 	bne	r3,zero,8110a31c <vPerformActionNFCConfig+0x44>
8110a310:	108000a0 	cmpeqi	r2,r2,2
8110a314:	1000091e 	bne	r2,zero,8110a33c <vPerformActionNFCConfig+0x64>
8110a318:	00003406 	br	8110a3ec <vPerformActionNFCConfig+0x114>
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
8110a31c:	d0a05417 	ldw	r2,-32432(gp)
8110a320:	100f883a 	mov	r7,r2
8110a324:	01800d44 	movi	r6,53
8110a328:	01400044 	movi	r5,1
8110a32c:	01204534 	movhi	r4,33044
8110a330:	21058504 	addi	r4,r4,5652
8110a334:	1115d200 	call	81115d20 <fwrite>
			#endif

			/* Do nothing for now */

			break;
8110a338:	00003406 	br	8110a40c <vPerformActionNFCConfig+0x134>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to RUN Mode\n");
8110a33c:	d0a05417 	ldw	r2,-32432(gp)
8110a340:	100f883a 	mov	r7,r2
8110a344:	01800ac4 	movi	r6,43
8110a348:	01400044 	movi	r5,1
8110a34c:	01204534 	movhi	r4,33044
8110a350:	21059304 	addi	r4,r4,5708
8110a354:	1115d200 	call	81115d20 <fwrite>
			#endif

			vEvtChangeFeeControllerMode(pxFeeCP->sMode, sRun);
8110a358:	e0bfff17 	ldw	r2,-4(fp)
8110a35c:	10810f17 	ldw	r2,1084(r2)
8110a360:	01400044 	movi	r5,1
8110a364:	1009883a 	mov	r4,r2
8110a368:	1112c1c0 	call	81112c1c <vEvtChangeFeeControllerMode>
			pxFeeCP->sMode = sRun;
8110a36c:	e0bfff17 	ldw	r2,-4(fp)
8110a370:	00c00044 	movi	r3,1
8110a374:	10c10f15 	stw	r3,1084(r2)
			/* ALlow NFEEs to go to any Running mode */

			/* Clear The Queue That gives access to the DMA */
			errorCodeL = OSQFlush(xNfeeSchedule);
8110a378:	d0a05017 	ldw	r2,-32448(gp)
8110a37c:	1009883a 	mov	r4,r2
8110a380:	11327a80 	call	811327a8 <OSQFlush>
8110a384:	e0bffc45 	stb	r2,-15(fp)
			if ( errorCodeL != OS_NO_ERR ) {
8110a388:	e0bffc43 	ldbu	r2,-15(fp)
8110a38c:	10000126 	beq	r2,zero,8110a394 <vPerformActionNFCConfig+0xbc>
				vFailFlushQueue();
8110a390:	1112b600 	call	81112b60 <vFailFlushQueue>
			}

			for( i = 0; i < N_OF_NFEE; i++)
8110a394:	e03ffc05 	stb	zero,-16(fp)
8110a398:	00001006 	br	8110a3dc <vPerformActionNFCConfig+0x104>
			{
				errorCodeL = OSQFlush( xFeeQ[ i ] );
8110a39c:	e0fffc03 	ldbu	r3,-16(fp)
8110a3a0:	00a04574 	movhi	r2,33045
8110a3a4:	108eda04 	addi	r2,r2,15208
8110a3a8:	18c7883a 	add	r3,r3,r3
8110a3ac:	18c7883a 	add	r3,r3,r3
8110a3b0:	10c5883a 	add	r2,r2,r3
8110a3b4:	10800017 	ldw	r2,0(r2)
8110a3b8:	1009883a 	mov	r4,r2
8110a3bc:	11327a80 	call	811327a8 <OSQFlush>
8110a3c0:	e0bffc45 	stb	r2,-15(fp)
				if ( errorCodeL != OS_NO_ERR ) {
8110a3c4:	e0bffc43 	ldbu	r2,-15(fp)
8110a3c8:	10000126 	beq	r2,zero,8110a3d0 <vPerformActionNFCConfig+0xf8>
					vFailFlushQueue();
8110a3cc:	1112b600 	call	81112b60 <vFailFlushQueue>
			errorCodeL = OSQFlush(xNfeeSchedule);
			if ( errorCodeL != OS_NO_ERR ) {
				vFailFlushQueue();
			}

			for( i = 0; i < N_OF_NFEE; i++)
8110a3d0:	e0bffc03 	ldbu	r2,-16(fp)
8110a3d4:	10800044 	addi	r2,r2,1
8110a3d8:	e0bffc05 	stb	r2,-16(fp)
8110a3dc:	e0bffc03 	ldbu	r2,-16(fp)
8110a3e0:	108001b0 	cmpltui	r2,r2,6
8110a3e4:	103fed1e 	bne	r2,zero,8110a39c <__reset+0xfb0ea39c>
					vFailFlushQueue();
				}
			}


			break;		
8110a3e8:	00000806 	br	8110a40c <vPerformActionNFCConfig+0x134>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
8110a3ec:	d0a05417 	ldw	r2,-32432(gp)
8110a3f0:	100f883a 	mov	r7,r2
8110a3f4:	01800984 	movi	r6,38
8110a3f8:	01400044 	movi	r5,1
8110a3fc:	01204534 	movhi	r4,33044
8110a400:	21059e04 	addi	r4,r4,5752
8110a404:	1115d200 	call	81115d20 <fwrite>
			#endif	
			break;
8110a408:	0001883a 	nop
	}

}
8110a40c:	0001883a 	nop
8110a410:	e037883a 	mov	sp,fp
8110a414:	dfc00117 	ldw	ra,4(sp)
8110a418:	df000017 	ldw	fp,0(sp)
8110a41c:	dec00204 	addi	sp,sp,8
8110a420:	f800283a 	ret

8110a424 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110a424:	defffa04 	addi	sp,sp,-24
8110a428:	de00012e 	bgeu	sp,et,8110a430 <vPerformActionNFCRunning+0xc>
8110a42c:	003b68fa 	trap	3
8110a430:	dfc00515 	stw	ra,20(sp)
8110a434:	df000415 	stw	fp,16(sp)
8110a438:	df000404 	addi	fp,sp,16
8110a43c:	e13ffe15 	stw	r4,-8(fp)
8110a440:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
8110a444:	e0bffe17 	ldw	r2,-8(fp)
8110a448:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110a44c:	e0bffd83 	ldbu	r2,-10(fp)
8110a450:	10803fcc 	andi	r2,r2,255
8110a454:	10c00060 	cmpeqi	r3,r2,1
8110a458:	1800031e 	bne	r3,zero,8110a468 <vPerformActionNFCRunning+0x44>
8110a45c:	108000a0 	cmpeqi	r2,r2,2
8110a460:	1000291e 	bne	r2,zero,8110a508 <vPerformActionNFCRunning+0xe4>
8110a464:	00003006 	br	8110a528 <vPerformActionNFCRunning+0x104>
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to RUN Mode\n");
8110a468:	d0a05417 	ldw	r2,-32432(gp)
8110a46c:	100f883a 	mov	r7,r2
8110a470:	01800ac4 	movi	r6,43
8110a474:	01400044 	movi	r5,1
8110a478:	01204534 	movhi	r4,33044
8110a47c:	21059304 	addi	r4,r4,5708
8110a480:	1115d200 	call	81115d20 <fwrite>
			#endif

			vEvtChangeFeeControllerMode(pxFeeCP->sMode, sMebConfig);
8110a484:	e0bfff17 	ldw	r2,-4(fp)
8110a488:	10810f17 	ldw	r2,1084(r2)
8110a48c:	000b883a 	mov	r5,zero
8110a490:	1009883a 	mov	r4,r2
8110a494:	1112c1c0 	call	81112c1c <vEvtChangeFeeControllerMode>
			pxFeeCP->sMode = sMebConfig;
8110a498:	e0bfff17 	ldw	r2,-4(fp)
8110a49c:	10010f15 	stw	zero,1084(r2)

			/* Change all NFEEs to Config mode */

			for( i = 0; i < N_OF_NFEE; i++)
8110a4a0:	e03ffc05 	stb	zero,-16(fp)
8110a4a4:	00001406 	br	8110a4f8 <vPerformActionNFCRunning+0xd4>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
8110a4a8:	e0bffc03 	ldbu	r2,-16(fp)
8110a4ac:	e0ffff17 	ldw	r3,-4(fp)
8110a4b0:	10804204 	addi	r2,r2,264
8110a4b4:	1085883a 	add	r2,r2,r2
8110a4b8:	1085883a 	add	r2,r2,r2
8110a4bc:	1885883a 	add	r2,r3,r2
8110a4c0:	10800017 	ldw	r2,0(r2)
8110a4c4:	10800017 	ldw	r2,0(r2)
8110a4c8:	10800058 	cmpnei	r2,r2,1
8110a4cc:	1000071e 	bne	r2,zero,8110a4ec <vPerformActionNFCRunning+0xc8>
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG, 0, i  );
8110a4d0:	e0bffc03 	ldbu	r2,-16(fp)
8110a4d4:	e0fffc03 	ldbu	r3,-16(fp)
8110a4d8:	180f883a 	mov	r7,r3
8110a4dc:	000d883a 	mov	r6,zero
8110a4e0:	01400044 	movi	r5,1
8110a4e4:	1009883a 	mov	r4,r2
8110a4e8:	110a5600 	call	8110a560 <bSendCmdQToNFeeInst>
			vEvtChangeFeeControllerMode(pxFeeCP->sMode, sMebConfig);
			pxFeeCP->sMode = sMebConfig;

			/* Change all NFEEs to Config mode */

			for( i = 0; i < N_OF_NFEE; i++)
8110a4ec:	e0bffc03 	ldbu	r2,-16(fp)
8110a4f0:	10800044 	addi	r2,r2,1
8110a4f4:	e0bffc05 	stb	r2,-16(fp)
8110a4f8:	e0bffc03 	ldbu	r2,-16(fp)
8110a4fc:	108001b0 	cmpltui	r2,r2,6
8110a500:	103fe91e 	bne	r2,zero,8110a4a8 <__reset+0xfb0ea4a8>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG, 0, i  );
				}
			}

			break;
8110a504:	00001006 	br	8110a548 <vPerformActionNFCRunning+0x124>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
8110a508:	d0a05417 	ldw	r2,-32432(gp)
8110a50c:	100f883a 	mov	r7,r2
8110a510:	01800d84 	movi	r6,54
8110a514:	01400044 	movi	r5,1
8110a518:	01204534 	movhi	r4,33044
8110a51c:	2105a804 	addi	r4,r4,5792
8110a520:	1115d200 	call	81115d20 <fwrite>
			#endif		
			/* Do nothing for now */

			break;		
8110a524:	00000806 	br	8110a548 <vPerformActionNFCRunning+0x124>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
8110a528:	d0a05417 	ldw	r2,-32432(gp)
8110a52c:	100f883a 	mov	r7,r2
8110a530:	01800984 	movi	r6,38
8110a534:	01400044 	movi	r5,1
8110a538:	01204534 	movhi	r4,33044
8110a53c:	21059e04 	addi	r4,r4,5752
8110a540:	1115d200 	call	81115d20 <fwrite>
			#endif	
			break;
8110a544:	0001883a 	nop
	}
}
8110a548:	0001883a 	nop
8110a54c:	e037883a 	mov	sp,fp
8110a550:	dfc00117 	ldw	ra,4(sp)
8110a554:	df000017 	ldw	fp,0(sp)
8110a558:	dec00204 	addi	sp,sp,8
8110a55c:	f800283a 	ret

8110a560 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110a560:	defff704 	addi	sp,sp,-36
8110a564:	de00012e 	bgeu	sp,et,8110a56c <bSendCmdQToNFeeInst+0xc>
8110a568:	003b68fa 	trap	3
8110a56c:	dfc00815 	stw	ra,32(sp)
8110a570:	df000715 	stw	fp,28(sp)
8110a574:	df000704 	addi	fp,sp,28
8110a578:	2011883a 	mov	r8,r4
8110a57c:	2809883a 	mov	r4,r5
8110a580:	3007883a 	mov	r3,r6
8110a584:	3805883a 	mov	r2,r7
8110a588:	e23ffc05 	stb	r8,-16(fp)
8110a58c:	e13ffd05 	stb	r4,-12(fp)
8110a590:	e0fffe05 	stb	r3,-8(fp)
8110a594:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
8110a598:	e0bffc03 	ldbu	r2,-16(fp)
8110a59c:	10800444 	addi	r2,r2,17
8110a5a0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110a5a4:	e0bffd03 	ldbu	r2,-12(fp)
8110a5a8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110a5ac:	e0bffe03 	ldbu	r2,-8(fp)
8110a5b0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110a5b4:	e0bfff03 	ldbu	r2,-4(fp)
8110a5b8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110a5bc:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
8110a5c0:	e0fffc03 	ldbu	r3,-16(fp)
8110a5c4:	00a04574 	movhi	r2,33045
8110a5c8:	108eda04 	addi	r2,r2,15208
8110a5cc:	18c7883a 	add	r3,r3,r3
8110a5d0:	18c7883a 	add	r3,r3,r3
8110a5d4:	10c5883a 	add	r2,r2,r3
8110a5d8:	10800017 	ldw	r2,0(r2)
8110a5dc:	e0fffb17 	ldw	r3,-20(fp)
8110a5e0:	180b883a 	mov	r5,r3
8110a5e4:	1009883a 	mov	r4,r2
8110a5e8:	1132c700 	call	81132c70 <OSQPost>
8110a5ec:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110a5f0:	e0bffa03 	ldbu	r2,-24(fp)
8110a5f4:	10000526 	beq	r2,zero,8110a60c <bSendCmdQToNFeeInst+0xac>
		vFailSendMsgAccessDMA( ucFeeInstP );
8110a5f8:	e0bffc03 	ldbu	r2,-16(fp)
8110a5fc:	1009883a 	mov	r4,r2
8110a600:	1112ac00 	call	81112ac0 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
8110a604:	e03ff915 	stw	zero,-28(fp)
8110a608:	00000206 	br	8110a614 <bSendCmdQToNFeeInst+0xb4>
	} else {
		bSuccesL =  TRUE;
8110a60c:	00800044 	movi	r2,1
8110a610:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
8110a614:	e0bff917 	ldw	r2,-28(fp)
}
8110a618:	e037883a 	mov	sp,fp
8110a61c:	dfc00117 	ldw	ra,4(sp)
8110a620:	df000017 	ldw	fp,0(sp)
8110a624:	dec00204 	addi	sp,sp,8
8110a628:	f800283a 	ret

8110a62c <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
8110a62c:	defff704 	addi	sp,sp,-36
8110a630:	de00012e 	bgeu	sp,et,8110a638 <vOutAckHandlerTask+0xc>
8110a634:	003b68fa 	trap	3
8110a638:	dfc00815 	stw	ra,32(sp)
8110a63c:	df000715 	stw	fp,28(sp)
8110a640:	df000704 	addi	fp,sp,28
8110a644:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
8110a648:	e03ffac5 	stb	zero,-21(fp)
8110a64c:	e03ffb05 	stb	zero,-20(fp)
8110a650:	e03ffb45 	stb	zero,-19(fp)
8110a654:	e03ffb85 	stb	zero,-18(fp)
8110a658:	e03ffbc5 	stb	zero,-17(fp)
8110a65c:	e03ffc05 	stb	zero,-16(fp)
8110a660:	e03ffc45 	stb	zero,-15(fp)
8110a664:	e03ffc85 	stb	zero,-14(fp)
8110a668:	e03ffcc5 	stb	zero,-13(fp)
8110a66c:	e03ffd05 	stb	zero,-12(fp)
8110a670:	e03ffd45 	stb	zero,-11(fp)
8110a674:	e03ffd85 	stb	zero,-10(fp)
8110a678:	e03ffdc5 	stb	zero,-9(fp)
8110a67c:	e03ffe05 	stb	zero,-8(fp)
8110a680:	e03ffe45 	stb	zero,-7(fp)
8110a684:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
8110a688:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
8110a68c:	d0a05417 	ldw	r2,-32432(gp)
8110a690:	100f883a 	mov	r7,r2
8110a694:	01800804 	movi	r6,32
8110a698:	01400044 	movi	r5,1
8110a69c:	01204534 	movhi	r4,33044
8110a6a0:	2105b604 	addi	r4,r4,5848
8110a6a4:	1115d200 	call	81115d20 <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
8110a6a8:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
8110a6ac:	e0bff917 	ldw	r2,-28(fp)
8110a6b0:	10c00060 	cmpeqi	r3,r2,1
8110a6b4:	1800071e 	bne	r3,zero,8110a6d4 <vOutAckHandlerTask+0xa8>
8110a6b8:	0080032e 	bgeu	zero,r2,8110a6c8 <vOutAckHandlerTask+0x9c>
8110a6bc:	108000a0 	cmpeqi	r2,r2,2
8110a6c0:	1000471e 	bne	r2,zero,8110a7e0 <vOutAckHandlerTask+0x1b4>
8110a6c4:	00008c06 	br	8110a8f8 <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
8110a6c8:	00800044 	movi	r2,1
8110a6cc:	e0bff915 	stw	r2,-28(fp)
				break;
8110a6d0:	00009306 	br	8110a920 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
8110a6d4:	00800044 	movi	r2,1
8110a6d8:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
8110a6dc:	d0a05317 	ldw	r2,-32436(gp)
8110a6e0:	e0fffa84 	addi	r3,fp,-22
8110a6e4:	180d883a 	mov	r6,r3
8110a6e8:	000b883a 	mov	r5,zero
8110a6ec:	1009883a 	mov	r4,r2
8110a6f0:	11337600 	call	81133760 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110a6f4:	e0bffa83 	ldbu	r2,-22(fp)
8110a6f8:	10803fcc 	andi	r2,r2,255
8110a6fc:	1000361e 	bne	r2,zero,8110a7d8 <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
8110a700:	d0a06217 	ldw	r2,-32376(gp)
8110a704:	e0fffa84 	addi	r3,fp,-22
8110a708:	180d883a 	mov	r6,r3
8110a70c:	000b883a 	mov	r5,zero
8110a710:	1009883a 	mov	r4,r2
8110a714:	11317540 	call	81131754 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110a718:	e0bffa83 	ldbu	r2,-22(fp)
8110a71c:	10803fcc 	andi	r2,r2,255
8110a720:	10002b1e 	bne	r2,zero,8110a7d0 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110a724:	e03ffa05 	stb	zero,-24(fp)
8110a728:	00002206 	br	8110a7b4 <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
8110a72c:	e0fffa03 	ldbu	r3,-24(fp)
8110a730:	00a045b4 	movhi	r2,33046
8110a734:	10a8ee04 	addi	r2,r2,-23624
8110a738:	18c7883a 	add	r3,r3,r3
8110a73c:	18c7883a 	add	r3,r3,r3
8110a740:	10c5883a 	add	r2,r2,r3
8110a744:	10800003 	ldbu	r2,0(r2)
8110a748:	10803fcc 	andi	r2,r2,255
8110a74c:	1080201c 	xori	r2,r2,128
8110a750:	10bfe004 	addi	r2,r2,-128
8110a754:	10001426 	beq	r2,zero,8110a7a8 <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8110a758:	e0fffa03 	ldbu	r3,-24(fp)
8110a75c:	00a045b4 	movhi	r2,33046
8110a760:	10a8ee04 	addi	r2,r2,-23624
8110a764:	18c7883a 	add	r3,r3,r3
8110a768:	18c7883a 	add	r3,r3,r3
8110a76c:	10c5883a 	add	r2,r2,r3
8110a770:	10c0000b 	ldhu	r3,0(r2)
8110a774:	d0e04e0d 	sth	r3,-32456(gp)
8110a778:	1080008b 	ldhu	r2,2(r2)
8110a77c:	d0a04e8d 	sth	r2,-32454(gp)
                                eSenderAckState = sSASending;
8110a780:	00800084 	movi	r2,2
8110a784:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110a788:	e0fffa03 	ldbu	r3,-24(fp)
8110a78c:	00a045b4 	movhi	r2,33046
8110a790:	10a8ee04 	addi	r2,r2,-23624
8110a794:	18c7883a 	add	r3,r3,r3
8110a798:	18c7883a 	add	r3,r3,r3
8110a79c:	10c5883a 	add	r2,r2,r3
8110a7a0:	10000005 	stb	zero,0(r2)
                                break;
8110a7a4:	00000606 	br	8110a7c0 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110a7a8:	e0bffa03 	ldbu	r2,-24(fp)
8110a7ac:	10800044 	addi	r2,r2,1
8110a7b0:	e0bffa05 	stb	r2,-24(fp)
8110a7b4:	e0bffa03 	ldbu	r2,-24(fp)
8110a7b8:	10800230 	cmpltui	r2,r2,8
8110a7bc:	103fdb1e 	bne	r2,zero,8110a72c <__reset+0xfb0ea72c>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
8110a7c0:	d0a06217 	ldw	r2,-32376(gp)
8110a7c4:	1009883a 	mov	r4,r2
8110a7c8:	1131cf80 	call	81131cf8 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110a7cc:	00005406 	br	8110a920 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
8110a7d0:	11113440 	call	81111344 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110a7d4:	00005206 	br	8110a920 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
8110a7d8:	11112dc0 	call	811112dc <vFailGetCountSemaphoreSenderTask>
                }

                break;
8110a7dc:	00005006 	br	8110a920 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
8110a7e0:	d0a04e03 	ldbu	r2,-32456(gp)
8110a7e4:	10803fcc 	andi	r2,r2,255
8110a7e8:	1080201c 	xori	r2,r2,128
8110a7ec:	10bfe004 	addi	r2,r2,-128
8110a7f0:	108008e0 	cmpeqi	r2,r2,35
8110a7f4:	1000201e 	bne	r2,zero,8110a878 <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
8110a7f8:	d0a04e43 	ldbu	r2,-32455(gp)
8110a7fc:	10c03fcc 	andi	r3,r2,255
8110a800:	18c0201c 	xori	r3,r3,128
8110a804:	18ffe004 	addi	r3,r3,-128
8110a808:	d0a04e8b 	ldhu	r2,-32454(gp)
8110a80c:	113fffcc 	andi	r4,r2,65535
8110a810:	e0bffac4 	addi	r2,fp,-21
8110a814:	200f883a 	mov	r7,r4
8110a818:	180d883a 	mov	r6,r3
8110a81c:	01604534 	movhi	r5,33044
8110a820:	2945bf04 	addi	r5,r5,5884
8110a824:	1009883a 	mov	r4,r2
8110a828:	11170140 	call	81117014 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
8110a82c:	e0bffac4 	addi	r2,fp,-21
8110a830:	1009883a 	mov	r4,r2
8110a834:	11172280 	call	81117228 <strlen>
8110a838:	1007883a 	mov	r3,r2
8110a83c:	e0bffac4 	addi	r2,fp,-21
8110a840:	180b883a 	mov	r5,r3
8110a844:	1009883a 	mov	r4,r2
8110a848:	1110ef00 	call	81110ef0 <ucCrc8wInit>
8110a84c:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
8110a850:	e13ffa43 	ldbu	r4,-23(fp)
8110a854:	e0fffac4 	addi	r3,fp,-21
8110a858:	e0bffac4 	addi	r2,fp,-21
8110a85c:	200f883a 	mov	r7,r4
8110a860:	180d883a 	mov	r6,r3
8110a864:	01604534 	movhi	r5,33044
8110a868:	2945c104 	addi	r5,r5,5892
8110a86c:	1009883a 	mov	r4,r2
8110a870:	11170140 	call	81117014 <sprintf>
8110a874:	00000c06 	br	8110a8a8 <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
8110a878:	e0bffac4 	addi	r2,fp,-21
8110a87c:	00c008c4 	movi	r3,35
8110a880:	10c00005 	stb	r3,0(r2)
8110a884:	00c01f04 	movi	r3,124
8110a888:	10c00045 	stb	r3,1(r2)
8110a88c:	00c00d44 	movi	r3,53
8110a890:	10c00085 	stb	r3,2(r2)
8110a894:	00c00d04 	movi	r3,52
8110a898:	10c000c5 	stb	r3,3(r2)
8110a89c:	00c00ec4 	movi	r3,59
8110a8a0:	10c00105 	stb	r3,4(r2)
8110a8a4:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
8110a8a8:	d0a06417 	ldw	r2,-32368(gp)
8110a8ac:	e0fffa84 	addi	r3,fp,-22
8110a8b0:	180d883a 	mov	r6,r3
8110a8b4:	01401904 	movi	r5,100
8110a8b8:	1009883a 	mov	r4,r2
8110a8bc:	11317540 	call	81131754 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
8110a8c0:	e0bffa83 	ldbu	r2,-22(fp)
8110a8c4:	10803fcc 	andi	r2,r2,255
8110a8c8:	1000071e 	bne	r2,zero,8110a8e8 <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
8110a8cc:	e0bffac4 	addi	r2,fp,-21
8110a8d0:	1009883a 	mov	r4,r2
8110a8d4:	1116cd00 	call	81116cd0 <puts>
                    OSMutexPost(xTxUARTMutex);
8110a8d8:	d0a06417 	ldw	r2,-32368(gp)
8110a8dc:	1009883a 	mov	r4,r2
8110a8e0:	1131cf80 	call	81131cf8 <OSMutexPost>
8110a8e4:	00000106 	br	8110a8ec <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
8110a8e8:	111147c0 	call	8111147c <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
8110a8ec:	00800044 	movi	r2,1
8110a8f0:	e0bff915 	stw	r2,-28(fp)
                
				break;
8110a8f4:	00000a06 	br	8110a920 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
8110a8f8:	d0a05417 	ldw	r2,-32432(gp)
8110a8fc:	100f883a 	mov	r7,r2
8110a900:	01801104 	movi	r6,68
8110a904:	01400044 	movi	r5,1
8110a908:	01204534 	movhi	r4,33044
8110a90c:	2105c404 	addi	r4,r4,5904
8110a910:	1115d200 	call	81115d20 <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
8110a914:	00800044 	movi	r2,1
8110a918:	e0bff915 	stw	r2,-28(fp)
				break;
8110a91c:	0001883a 	nop
		}
	}
8110a920:	003f6206 	br	8110a6ac <__reset+0xfb0ea6ac>

8110a924 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
8110a924:	deffd704 	addi	sp,sp,-164
8110a928:	de00012e 	bgeu	sp,et,8110a930 <vParserCommTask+0xc>
8110a92c:	003b68fa 	trap	3
8110a930:	dfc02815 	stw	ra,160(sp)
8110a934:	df002715 	stw	fp,156(sp)
8110a938:	df002704 	addi	fp,sp,156
8110a93c:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
8110a940:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
8110a944:	d0a05417 	ldw	r2,-32432(gp)
8110a948:	100f883a 	mov	r7,r2
8110a94c:	01800704 	movi	r6,28
8110a950:	01400044 	movi	r5,1
8110a954:	01204534 	movhi	r4,33044
8110a958:	2105d604 	addi	r4,r4,5976
8110a95c:	1115d200 	call	81115d20 <fwrite>
    #endif

	eParserMode = sConfiguring;
8110a960:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
8110a964:	e0bfdc17 	ldw	r2,-144(fp)
8110a968:	10800168 	cmpgeui	r2,r2,5
8110a96c:	1003691e 	bne	r2,zero,8110b714 <vParserCommTask+0xdf0>
8110a970:	e0bfdc17 	ldw	r2,-144(fp)
8110a974:	100690ba 	slli	r3,r2,2
8110a978:	00a04474 	movhi	r2,33041
8110a97c:	10aa6304 	addi	r2,r2,-22132
8110a980:	1885883a 	add	r2,r3,r2
8110a984:	10800017 	ldw	r2,0(r2)
8110a988:	1000683a 	jmp	r2
8110a98c:	8110a9a0 	cmpeqi	r4,r16,17062
8110a990:	8110a9ac 	andhi	r4,r16,17062
8110a994:	8110aa40 	call	88110aa4 <__reset+0x20f0aa4>
8110a998:	8110abc0 	call	88110abc <__reset+0x20f0abc>
8110a99c:	8110ac04 	addi	r4,r16,17072
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
8110a9a0:	00800044 	movi	r2,1
8110a9a4:	e0bfdc15 	stw	r2,-144(fp)
				break;
8110a9a8:	00035d06 	br	8110b720 <vParserCommTask+0xdfc>
			case sWaitingMessage:

				bSuccess = FALSE;
8110a9ac:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
8110a9b0:	00800044 	movi	r2,1
8110a9b4:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
8110a9b8:	d0a05617 	ldw	r2,-32424(gp)
8110a9bc:	e0ffde84 	addi	r3,fp,-134
8110a9c0:	180d883a 	mov	r6,r3
8110a9c4:	000b883a 	mov	r5,zero
8110a9c8:	1009883a 	mov	r4,r2
8110a9cc:	11337600 	call	81133760 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
8110a9d0:	e0bfde83 	ldbu	r2,-134(fp)
8110a9d4:	10803fcc 	andi	r2,r2,255
8110a9d8:	1000171e 	bne	r2,zero,8110aa38 <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
8110a9dc:	01204534 	movhi	r4,33044
8110a9e0:	211b9004 	addi	r4,r4,28224
8110a9e4:	110b7240 	call	8110b724 <getPreParsedPacket>
8110a9e8:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
8110a9ec:	e0bfdd17 	ldw	r2,-140(fp)
8110a9f0:	10800058 	cmpnei	r2,r2,1
8110a9f4:	10000e1e 	bne	r2,zero,8110aa30 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
8110a9f8:	00a04534 	movhi	r2,33044
8110a9fc:	109b9004 	addi	r2,r2,28224
8110aa00:	10800103 	ldbu	r2,4(r2)
8110aa04:	10803fcc 	andi	r2,r2,255
8110aa08:	1080201c 	xori	r2,r2,128
8110aa0c:	10bfe004 	addi	r2,r2,-128
8110aa10:	10800858 	cmpnei	r2,r2,33
8110aa14:	1000031e 	bne	r2,zero,8110aa24 <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
8110aa18:	008000c4 	movi	r2,3
8110aa1c:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110aa20:	00033f06 	br	8110b720 <vParserCommTask+0xdfc>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
8110aa24:	00800084 	movi	r2,2
8110aa28:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110aa2c:	00033c06 	br	8110b720 <vParserCommTask+0xdfc>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
8110aa30:	1111a080 	call	81111a08 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110aa34:	00033a06 	br	8110b720 <vParserCommTask+0xdfc>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
8110aa38:	11119380 	call	81111938 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
8110aa3c:	00033806 	br	8110b720 <vParserCommTask+0xdfc>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
8110aa40:	00a04534 	movhi	r2,33044
8110aa44:	109b9004 	addi	r2,r2,28224
8110aa48:	10800143 	ldbu	r2,5(r2)
8110aa4c:	10803fcc 	andi	r2,r2,255
8110aa50:	1080201c 	xori	r2,r2,128
8110aa54:	10bfe004 	addi	r2,r2,-128
8110aa58:	10c010e0 	cmpeqi	r3,r2,67
8110aa5c:	1800031e 	bne	r3,zero,8110aa6c <vParserCommTask+0x148>
8110aa60:	10801420 	cmpeqi	r2,r2,80
8110aa64:	1000051e 	bne	r2,zero,8110aa7c <vParserCommTask+0x158>
8110aa68:	00005106 	br	8110abb0 <vParserCommTask+0x28c>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
8110aa6c:	110f6c00 	call	8110f6c0 <vSendEthConf>
						eParserMode = sWaitingMessage;
8110aa70:	00800044 	movi	r2,1
8110aa74:	e0bfdc15 	stw	r2,-144(fp)
						break;
8110aa78:	00005006 	br	8110abbc <vParserCommTask+0x298>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							debug(fp,"PUS Received:\n");
8110aa7c:	d0a05417 	ldw	r2,-32432(gp)
8110aa80:	100f883a 	mov	r7,r2
8110aa84:	01800384 	movi	r6,14
8110aa88:	01400044 	movi	r5,1
8110aa8c:	01204534 	movhi	r4,33044
8110aa90:	2105de04 	addi	r4,r4,6008
8110aa94:	1115d200 	call	81115d20 <fwrite>
							memset(cPUSDebug,0,128);
8110aa98:	e0bfdec4 	addi	r2,fp,-133
8110aa9c:	01802004 	movi	r6,128
8110aaa0:	000b883a 	mov	r5,zero
8110aaa4:	1009883a 	mov	r4,r2
8110aaa8:	11168840 	call	81116884 <memset>
							sprintf(cPUSDebug, "TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
8110aaac:	00a04534 	movhi	r2,33044
8110aab0:	109b9004 	addi	r2,r2,28224
8110aab4:	1080028b 	ldhu	r2,10(r2)
8110aab8:	117fffcc 	andi	r5,r2,65535
8110aabc:	00a04534 	movhi	r2,33044
8110aac0:	109b9004 	addi	r2,r2,28224
8110aac4:	1080030b 	ldhu	r2,12(r2)
8110aac8:	11bfffcc 	andi	r6,r2,65535
8110aacc:	00a04534 	movhi	r2,33044
8110aad0:	109b9004 	addi	r2,r2,28224
8110aad4:	1080038b 	ldhu	r2,14(r2)
8110aad8:	10ffffcc 	andi	r3,r2,65535
8110aadc:	00a04534 	movhi	r2,33044
8110aae0:	109b9004 	addi	r2,r2,28224
8110aae4:	1080040b 	ldhu	r2,16(r2)
8110aae8:	113fffcc 	andi	r4,r2,65535
8110aaec:	00a04534 	movhi	r2,33044
8110aaf0:	109b9004 	addi	r2,r2,28224
8110aaf4:	1080048b 	ldhu	r2,18(r2)
8110aaf8:	10bfffcc 	andi	r2,r2,65535
8110aafc:	e23fdec4 	addi	r8,fp,-133
8110ab00:	d8800215 	stw	r2,8(sp)
8110ab04:	d9000115 	stw	r4,4(sp)
8110ab08:	d8c00015 	stw	r3,0(sp)
8110ab0c:	300f883a 	mov	r7,r6
8110ab10:	280d883a 	mov	r6,r5
8110ab14:	01604534 	movhi	r5,33044
8110ab18:	2945e204 	addi	r5,r5,6024
8110ab1c:	4009883a 	mov	r4,r8
8110ab20:	11170140 	call	81117014 <sprintf>
							debug(fp, cPUSDebug );
8110ab24:	d0a05417 	ldw	r2,-32432(gp)
8110ab28:	e0ffdec4 	addi	r3,fp,-133
8110ab2c:	180b883a 	mov	r5,r3
8110ab30:	1009883a 	mov	r4,r2
8110ab34:	11156840 	call	81115684 <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
8110ab38:	00a04534 	movhi	r2,33044
8110ab3c:	109b9004 	addi	r2,r2,28224
8110ab40:	10c0030b 	ldhu	r3,12(r2)
8110ab44:	00a04534 	movhi	r2,33044
8110ab48:	109ba304 	addi	r2,r2,28300
8110ab4c:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
8110ab50:	00a04534 	movhi	r2,33044
8110ab54:	109b9004 	addi	r2,r2,28224
8110ab58:	10c0038b 	ldhu	r3,14(r2)
8110ab5c:	00a04534 	movhi	r2,33044
8110ab60:	109ba304 	addi	r2,r2,28300
8110ab64:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
8110ab68:	00a04534 	movhi	r2,33044
8110ab6c:	109b9004 	addi	r2,r2,28224
8110ab70:	10c0040b 	ldhu	r3,16(r2)
8110ab74:	00a04534 	movhi	r2,33044
8110ab78:	109ba304 	addi	r2,r2,28300
8110ab7c:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
8110ab80:	00a04534 	movhi	r2,33044
8110ab84:	109b9004 	addi	r2,r2,28224
8110ab88:	10c0048b 	ldhu	r3,18(r2)
8110ab8c:	00a04534 	movhi	r2,33044
8110ab90:	109ba304 	addi	r2,r2,28300
8110ab94:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
8110ab98:	00a04534 	movhi	r2,33044
8110ab9c:	109ba304 	addi	r2,r2,28300
8110aba0:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
8110aba4:	00800104 	movi	r2,4
8110aba8:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
8110abac:	00000306 	br	8110abbc <vParserCommTask+0x298>
					default:
						eParserMode = sWaitingMessage;
8110abb0:	00800044 	movi	r2,1
8110abb4:	e0bfdc15 	stw	r2,-144(fp)
						break;
8110abb8:	0001883a 	nop
				}
				break;
8110abbc:	0002d806 	br	8110b720 <vParserCommTask+0xdfc>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
8110abc0:	00800044 	movi	r2,1
8110abc4:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
8110abc8:	00a04534 	movhi	r2,33044
8110abcc:	109ba304 	addi	r2,r2,28300
8110abd0:	1080030b 	ldhu	r2,12(r2)
8110abd4:	10bfffcc 	andi	r2,r2,65535
8110abd8:	10c01220 	cmpeqi	r3,r2,72
8110abdc:	1800051e 	bne	r3,zero,8110abf4 <vParserCommTask+0x2d0>
8110abe0:	108014e0 	cmpeqi	r2,r2,83
8110abe4:	1000051e 	bne	r2,zero,8110abfc <vParserCommTask+0x2d8>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
8110abe8:	00800044 	movi	r2,1
8110abec:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8110abf0:	00000306 	br	8110ac00 <vParserCommTask+0x2dc>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
8110abf4:	0001883a 	nop
8110abf8:	0002c906 	br	8110b720 <vParserCommTask+0xdfc>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
8110abfc:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
8110ac00:	0002c706 	br	8110b720 <vParserCommTask+0xdfc>
			case sPusHandling:
				eParserMode = sWaitingMessage;
8110ac04:	00800044 	movi	r2,1
8110ac08:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
8110ac0c:	00a04534 	movhi	r2,33044
8110ac10:	109ba304 	addi	r2,r2,28300
8110ac14:	1080030b 	ldhu	r2,12(r2)
8110ac18:	10bfffcc 	andi	r2,r2,65535
8110ac1c:	10c03ea0 	cmpeqi	r3,r2,250
8110ac20:	1800401e 	bne	r3,zero,8110ad24 <vParserCommTask+0x400>
8110ac24:	10c03ec8 	cmpgei	r3,r2,251
8110ac28:	1800031e 	bne	r3,zero,8110ac38 <vParserCommTask+0x314>
8110ac2c:	10800460 	cmpeqi	r2,r2,17
8110ac30:	1000061e 	bne	r2,zero,8110ac4c <vParserCommTask+0x328>
8110ac34:	0002b306 	br	8110b704 <vParserCommTask+0xde0>
8110ac38:	10c03ee0 	cmpeqi	r3,r2,251
8110ac3c:	18009a1e 	bne	r3,zero,8110aea8 <vParserCommTask+0x584>
8110ac40:	10803f20 	cmpeqi	r2,r2,252
8110ac44:	10012f1e 	bne	r2,zero,8110b104 <vParserCommTask+0x7e0>
8110ac48:	0002ae06 	br	8110b704 <vParserCommTask+0xde0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
8110ac4c:	00a04534 	movhi	r2,33044
8110ac50:	109ba304 	addi	r2,r2,28300
8110ac54:	1080038b 	ldhu	r2,14(r2)
8110ac58:	10bfffcc 	andi	r2,r2,65535
8110ac5c:	10800060 	cmpeqi	r2,r2,1
8110ac60:	10000e26 	beq	r2,zero,8110ac9c <vParserCommTask+0x378>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_TEST_CONNECTION\n");
8110ac64:	d0a05417 	ldw	r2,-32432(gp)
8110ac68:	100f883a 	mov	r7,r2
8110ac6c:	01800604 	movi	r6,24
8110ac70:	01400044 	movi	r5,1
8110ac74:	01204534 	movhi	r4,33044
8110ac78:	2105f504 	addi	r4,r4,6100
8110ac7c:	1115d200 	call	81115d20 <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
8110ac80:	00a04534 	movhi	r2,33044
8110ac84:	109ba304 	addi	r2,r2,28300
8110ac88:	1080040b 	ldhu	r2,16(r2)
8110ac8c:	10bfffcc 	andi	r2,r2,65535
8110ac90:	1009883a 	mov	r4,r2
8110ac94:	11100c00 	call	811100c0 <vTMPusTestConnection>

								break;
8110ac98:	00002106 	br	8110ad20 <vParserCommTask+0x3fc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110ac9c:	e0bfdec4 	addi	r2,fp,-133
8110aca0:	01802004 	movi	r6,128
8110aca4:	000b883a 	mov	r5,zero
8110aca8:	1009883a 	mov	r4,r2
8110acac:	11168840 	call	81116884 <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110acb0:	00a04534 	movhi	r2,33044
8110acb4:	109ba304 	addi	r2,r2,28300
8110acb8:	1080030b 	ldhu	r2,12(r2)
8110acbc:	113fffcc 	andi	r4,r2,65535
8110acc0:	00a04534 	movhi	r2,33044
8110acc4:	109ba304 	addi	r2,r2,28300
8110acc8:	1080038b 	ldhu	r2,14(r2)
8110accc:	117fffcc 	andi	r5,r2,65535
8110acd0:	00a04534 	movhi	r2,33044
8110acd4:	109ba304 	addi	r2,r2,28300
8110acd8:	1080040b 	ldhu	r2,16(r2)
8110acdc:	10bfffcc 	andi	r2,r2,65535
8110ace0:	e0ffdec4 	addi	r3,fp,-133
8110ace4:	d8800015 	stw	r2,0(sp)
8110ace8:	280f883a 	mov	r7,r5
8110acec:	200d883a 	mov	r6,r4
8110acf0:	01604534 	movhi	r5,33044
8110acf4:	2945fc04 	addi	r5,r5,6128
8110acf8:	1809883a 	mov	r4,r3
8110acfc:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110ad00:	d0a05417 	ldw	r2,-32432(gp)
8110ad04:	e0ffdec4 	addi	r3,fp,-133
8110ad08:	180b883a 	mov	r5,r3
8110ad0c:	1009883a 	mov	r4,r2
8110ad10:	11156840 	call	81115684 <fprintf>
								#endif
								eParserMode = sWaitingMessage;
8110ad14:	00800044 	movi	r2,1
8110ad18:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110ad1c:	0001883a 	nop
						}
                        break;
8110ad20:	00027b06 	br	8110b710 <vParserCommTask+0xdec>
                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
8110ad24:	00a04534 	movhi	r2,33044
8110ad28:	109ba304 	addi	r2,r2,28300
8110ad2c:	1080038b 	ldhu	r2,14(r2)
8110ad30:	10bfffcc 	andi	r2,r2,65535
8110ad34:	10c00f20 	cmpeqi	r3,r2,60
8110ad38:	18001a1e 	bne	r3,zero,8110ada4 <vParserCommTask+0x480>
8110ad3c:	10c00f48 	cmpgei	r3,r2,61
8110ad40:	1800031e 	bne	r3,zero,8110ad50 <vParserCommTask+0x42c>
8110ad44:	10800ee0 	cmpeqi	r2,r2,59
8110ad48:	1000061e 	bne	r2,zero,8110ad64 <vParserCommTask+0x440>
8110ad4c:	00003406 	br	8110ae20 <vParserCommTask+0x4fc>
8110ad50:	10c00f60 	cmpeqi	r3,r2,61
8110ad54:	18001e1e 	bne	r3,zero,8110add0 <vParserCommTask+0x4ac>
8110ad58:	10800fa0 	cmpeqi	r2,r2,62
8110ad5c:	1000271e 	bne	r2,zero,8110adfc <vParserCommTask+0x4d8>
8110ad60:	00002f06 	br	8110ae20 <vParserCommTask+0x4fc>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_RESET\n");
8110ad64:	d0a05417 	ldw	r2,-32432(gp)
8110ad68:	100f883a 	mov	r7,r2
8110ad6c:	01800384 	movi	r6,14
8110ad70:	01400044 	movi	r5,1
8110ad74:	01204534 	movhi	r4,33044
8110ad78:	21060c04 	addi	r4,r4,6192
8110ad7c:	1115d200 	call	81115d20 <fwrite>
								#endif
								vSendReset();
8110ad80:	110fa680 	call	8110fa68 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,1,0);
8110ad84:	000f883a 	mov	r7,zero
8110ad88:	01800044 	movi	r6,1
8110ad8c:	000b883a 	mov	r5,zero
8110ad90:	0009883a 	mov	r4,zero
8110ad94:	11355440 	call	81135544 <OSTimeDlyHMSM>
								vRstcSimucamReset( 50000 );
8110ad98:	0130d414 	movui	r4,50000
8110ad9c:	11072200 	call	81107220 <vRstcSimucamReset>

								break;
8110ada0:	00004006 	br	8110aea4 <vParserCommTask+0x580>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_CONFIG\n");
8110ada4:	d0a05417 	ldw	r2,-32432(gp)
8110ada8:	100f883a 	mov	r7,r2
8110adac:	018003c4 	movi	r6,15
8110adb0:	01400044 	movi	r5,1
8110adb4:	01204534 	movhi	r4,33044
8110adb8:	21061004 	addi	r4,r4,6208
8110adbc:	1115d200 	call	81115d20 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110adc0:	01204534 	movhi	r4,33044
8110adc4:	211ba304 	addi	r4,r4,28300
8110adc8:	110b83c0 	call	8110b83c <bSendMessagePUStoMebTask>

								break;
8110adcc:	00003506 	br	8110aea4 <vParserCommTask+0x580>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_RUN\n");
8110add0:	d0a05417 	ldw	r2,-32432(gp)
8110add4:	100f883a 	mov	r7,r2
8110add8:	01800304 	movi	r6,12
8110addc:	01400044 	movi	r5,1
8110ade0:	01204534 	movhi	r4,33044
8110ade4:	21061404 	addi	r4,r4,6224
8110ade8:	1115d200 	call	81115d20 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110adec:	01204534 	movhi	r4,33044
8110adf0:	211ba304 	addi	r4,r4,28300
8110adf4:	110b83c0 	call	8110b83c <bSendMessagePUStoMebTask>

								break;
8110adf8:	00002a06 	br	8110aea4 <vParserCommTask+0x580>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_TURNOFF\n");
8110adfc:	d0a05417 	ldw	r2,-32432(gp)
8110ae00:	100f883a 	mov	r7,r2
8110ae04:	01800404 	movi	r6,16
8110ae08:	01400044 	movi	r5,1
8110ae0c:	01204534 	movhi	r4,33044
8110ae10:	21061804 	addi	r4,r4,6240
8110ae14:	1115d200 	call	81115d20 <fwrite>
								#endif
								vSendTurnOff();
8110ae18:	110f9500 	call	8110f950 <vSendTurnOff>

								/* todo:Enviar emnsagens para a meb, e a meb distribui a mensagem */
								/* todo:Enviar Sinalizar Led quando puder desligar */

								break;
8110ae1c:	00002106 	br	8110aea4 <vParserCommTask+0x580>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110ae20:	e0bfdec4 	addi	r2,fp,-133
8110ae24:	01802004 	movi	r6,128
8110ae28:	000b883a 	mov	r5,zero
8110ae2c:	1009883a 	mov	r4,r2
8110ae30:	11168840 	call	81116884 <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110ae34:	00a04534 	movhi	r2,33044
8110ae38:	109ba304 	addi	r2,r2,28300
8110ae3c:	1080030b 	ldhu	r2,12(r2)
8110ae40:	113fffcc 	andi	r4,r2,65535
8110ae44:	00a04534 	movhi	r2,33044
8110ae48:	109ba304 	addi	r2,r2,28300
8110ae4c:	1080038b 	ldhu	r2,14(r2)
8110ae50:	117fffcc 	andi	r5,r2,65535
8110ae54:	00a04534 	movhi	r2,33044
8110ae58:	109ba304 	addi	r2,r2,28300
8110ae5c:	1080040b 	ldhu	r2,16(r2)
8110ae60:	10bfffcc 	andi	r2,r2,65535
8110ae64:	e0ffdec4 	addi	r3,fp,-133
8110ae68:	d8800015 	stw	r2,0(sp)
8110ae6c:	280f883a 	mov	r7,r5
8110ae70:	200d883a 	mov	r6,r4
8110ae74:	01604534 	movhi	r5,33044
8110ae78:	2945fc04 	addi	r5,r5,6128
8110ae7c:	1809883a 	mov	r4,r3
8110ae80:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110ae84:	d0a05417 	ldw	r2,-32432(gp)
8110ae88:	e0ffdec4 	addi	r3,fp,-133
8110ae8c:	180b883a 	mov	r5,r3
8110ae90:	1009883a 	mov	r4,r2
8110ae94:	11156840 	call	81115684 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8110ae98:	00800044 	movi	r2,1
8110ae9c:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110aea0:	0001883a 	nop
						}
                        break;
8110aea4:	00021a06 	br	8110b710 <vParserCommTask+0xdec>
                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8110aea8:	00a04534 	movhi	r2,33044
8110aeac:	109b9004 	addi	r2,r2,28224
8110aeb0:	1080050b 	ldhu	r2,20(r2)
8110aeb4:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
8110aeb8:	e0bfde0b 	ldhu	r2,-136(fp)
8110aebc:	108001f0 	cmpltui	r2,r2,7
8110aec0:	1000121e 	bne	r2,zero,8110af0c <vParserCommTask+0x5e8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
8110aec4:	e0bfdec4 	addi	r2,fp,-133
8110aec8:	01802004 	movi	r6,128
8110aecc:	000b883a 	mov	r5,zero
8110aed0:	1009883a 	mov	r4,r2
8110aed4:	11168840 	call	81116884 <memset>
								sprintf(cPUSDebug, "Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
8110aed8:	e0ffde0b 	ldhu	r3,-136(fp)
8110aedc:	e0bfdec4 	addi	r2,fp,-133
8110aee0:	180d883a 	mov	r6,r3
8110aee4:	01604534 	movhi	r5,33044
8110aee8:	29461d04 	addi	r5,r5,6260
8110aeec:	1009883a 	mov	r4,r2
8110aef0:	11170140 	call	81117014 <sprintf>
								debug(fp, cPUSDebug );
8110aef4:	d0a05417 	ldw	r2,-32432(gp)
8110aef8:	e0ffdec4 	addi	r3,fp,-133
8110aefc:	180b883a 	mov	r5,r3
8110af00:	1009883a 	mov	r4,r2
8110af04:	11156840 	call	81115684 <fprintf>
									break;
							}
						}


                        break;
8110af08:	00020106 	br	8110b710 <vParserCommTask+0xdec>
								sprintf(cPUSDebug, "Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
8110af0c:	00a04534 	movhi	r2,33044
8110af10:	109ba304 	addi	r2,r2,28300
8110af14:	10800483 	ldbu	r2,18(r2)
8110af18:	10c03fcc 	andi	r3,r2,255
8110af1c:	00a04534 	movhi	r2,33044
8110af20:	109ba304 	addi	r2,r2,28300
8110af24:	18c00284 	addi	r3,r3,10
8110af28:	18c7883a 	add	r3,r3,r3
8110af2c:	10c5883a 	add	r2,r2,r3
8110af30:	e0ffde0b 	ldhu	r3,-136(fp)
8110af34:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
8110af38:	00a04534 	movhi	r2,33044
8110af3c:	109ba304 	addi	r2,r2,28300
8110af40:	10800483 	ldbu	r2,18(r2)
8110af44:	10800044 	addi	r2,r2,1
8110af48:	1007883a 	mov	r3,r2
8110af4c:	00a04534 	movhi	r2,33044
8110af50:	109ba304 	addi	r2,r2,28300
8110af54:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
8110af58:	00a04534 	movhi	r2,33044
8110af5c:	109ba304 	addi	r2,r2,28300
8110af60:	1080038b 	ldhu	r2,14(r2)
8110af64:	10bfffcc 	andi	r2,r2,65535
8110af68:	10c000a0 	cmpeqi	r3,r2,2
8110af6c:	1800191e 	bne	r3,zero,8110afd4 <vParserCommTask+0x6b0>
8110af70:	10c00160 	cmpeqi	r3,r2,5
8110af74:	18002c1e 	bne	r3,zero,8110b028 <vParserCommTask+0x704>
8110af78:	10800060 	cmpeqi	r2,r2,1
8110af7c:	10003f26 	beq	r2,zero,8110b07c <vParserCommTask+0x758>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110af80:	e0bfdec4 	addi	r2,fp,-133
8110af84:	01802004 	movi	r6,128
8110af88:	000b883a 	mov	r5,zero
8110af8c:	1009883a 	mov	r4,r2
8110af90:	11168840 	call	81116884 <memset>
										sprintf(cPUSDebug, "TC_SCAM_FEE_CONFIG_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
8110af94:	e0ffde0b 	ldhu	r3,-136(fp)
8110af98:	e0bfdec4 	addi	r2,fp,-133
8110af9c:	180d883a 	mov	r6,r3
8110afa0:	01604534 	movhi	r5,33044
8110afa4:	29462904 	addi	r5,r5,6308
8110afa8:	1009883a 	mov	r4,r2
8110afac:	11170140 	call	81117014 <sprintf>
										debug(fp, cPUSDebug );
8110afb0:	d0a05417 	ldw	r2,-32432(gp)
8110afb4:	e0ffdec4 	addi	r3,fp,-133
8110afb8:	180b883a 	mov	r5,r3
8110afbc:	1009883a 	mov	r4,r2
8110afc0:	11156840 	call	81115684 <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
8110afc4:	01204534 	movhi	r4,33044
8110afc8:	211ba304 	addi	r4,r4,28300
8110afcc:	110b83c0 	call	8110b83c <bSendMessagePUStoMebTask>

									break;
8110afd0:	00004b06 	br	8110b100 <vParserCommTask+0x7dc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110afd4:	e0bfdec4 	addi	r2,fp,-133
8110afd8:	01802004 	movi	r6,128
8110afdc:	000b883a 	mov	r5,zero
8110afe0:	1009883a 	mov	r4,r2
8110afe4:	11168840 	call	81116884 <memset>
										sprintf(cPUSDebug, "TC_SCAM_FEE_STANDBY_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
8110afe8:	e0ffde0b 	ldhu	r3,-136(fp)
8110afec:	e0bfdec4 	addi	r2,fp,-133
8110aff0:	180d883a 	mov	r6,r3
8110aff4:	01604534 	movhi	r5,33044
8110aff8:	29463504 	addi	r5,r5,6356
8110affc:	1009883a 	mov	r4,r2
8110b000:	11170140 	call	81117014 <sprintf>
										debug(fp, cPUSDebug );
8110b004:	d0a05417 	ldw	r2,-32432(gp)
8110b008:	e0ffdec4 	addi	r3,fp,-133
8110b00c:	180b883a 	mov	r5,r3
8110b010:	1009883a 	mov	r4,r2
8110b014:	11156840 	call	81115684 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
8110b018:	01204534 	movhi	r4,33044
8110b01c:	211ba304 	addi	r4,r4,28300
8110b020:	110b83c0 	call	8110b83c <bSendMessagePUStoMebTask>

									break;
8110b024:	00003606 	br	8110b100 <vParserCommTask+0x7dc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110b028:	e0bfdec4 	addi	r2,fp,-133
8110b02c:	01802004 	movi	r6,128
8110b030:	000b883a 	mov	r5,zero
8110b034:	1009883a 	mov	r4,r2
8110b038:	11168840 	call	81116884 <memset>
										sprintf(cPUSDebug, "TC_SCAM_FEE_CALIBRATION_TEST_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
8110b03c:	e0ffde0b 	ldhu	r3,-136(fp)
8110b040:	e0bfdec4 	addi	r2,fp,-133
8110b044:	180d883a 	mov	r6,r3
8110b048:	01604534 	movhi	r5,33044
8110b04c:	29464104 	addi	r5,r5,6404
8110b050:	1009883a 	mov	r4,r2
8110b054:	11170140 	call	81117014 <sprintf>
										debug(fp, cPUSDebug );
8110b058:	d0a05417 	ldw	r2,-32432(gp)
8110b05c:	e0ffdec4 	addi	r3,fp,-133
8110b060:	180b883a 	mov	r5,r3
8110b064:	1009883a 	mov	r4,r2
8110b068:	11156840 	call	81115684 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
8110b06c:	01204534 	movhi	r4,33044
8110b070:	211ba304 	addi	r4,r4,28300
8110b074:	110b83c0 	call	8110b83c <bSendMessagePUStoMebTask>

									break;
8110b078:	00002106 	br	8110b100 <vParserCommTask+0x7dc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110b07c:	e0bfdec4 	addi	r2,fp,-133
8110b080:	01802004 	movi	r6,128
8110b084:	000b883a 	mov	r5,zero
8110b088:	1009883a 	mov	r4,r2
8110b08c:	11168840 	call	81116884 <memset>
										sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110b090:	00a04534 	movhi	r2,33044
8110b094:	109ba304 	addi	r2,r2,28300
8110b098:	1080030b 	ldhu	r2,12(r2)
8110b09c:	113fffcc 	andi	r4,r2,65535
8110b0a0:	00a04534 	movhi	r2,33044
8110b0a4:	109ba304 	addi	r2,r2,28300
8110b0a8:	1080038b 	ldhu	r2,14(r2)
8110b0ac:	117fffcc 	andi	r5,r2,65535
8110b0b0:	00a04534 	movhi	r2,33044
8110b0b4:	109ba304 	addi	r2,r2,28300
8110b0b8:	1080040b 	ldhu	r2,16(r2)
8110b0bc:	10bfffcc 	andi	r2,r2,65535
8110b0c0:	e0ffdec4 	addi	r3,fp,-133
8110b0c4:	d8800015 	stw	r2,0(sp)
8110b0c8:	280f883a 	mov	r7,r5
8110b0cc:	200d883a 	mov	r6,r4
8110b0d0:	01604534 	movhi	r5,33044
8110b0d4:	2945fc04 	addi	r5,r5,6128
8110b0d8:	1809883a 	mov	r4,r3
8110b0dc:	11170140 	call	81117014 <sprintf>
										debug(fp, cPUSDebug );
8110b0e0:	d0a05417 	ldw	r2,-32432(gp)
8110b0e4:	e0ffdec4 	addi	r3,fp,-133
8110b0e8:	180b883a 	mov	r5,r3
8110b0ec:	1009883a 	mov	r4,r2
8110b0f0:	11156840 	call	81115684 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
8110b0f4:	00800044 	movi	r2,1
8110b0f8:	e0bfdc15 	stw	r2,-144(fp)
									break;
8110b0fc:	0001883a 	nop
							}
						}


                        break;
8110b100:	00018306 	br	8110b710 <vParserCommTask+0xdec>
					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8110b104:	00a04534 	movhi	r2,33044
8110b108:	109b9004 	addi	r2,r2,28224
8110b10c:	1080050b 	ldhu	r2,20(r2)
8110b110:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
8110b114:	00a04534 	movhi	r2,33044
8110b118:	109ba304 	addi	r2,r2,28300
8110b11c:	10800483 	ldbu	r2,18(r2)
8110b120:	10c03fcc 	andi	r3,r2,255
8110b124:	00a04534 	movhi	r2,33044
8110b128:	109ba304 	addi	r2,r2,28300
8110b12c:	18c00284 	addi	r3,r3,10
8110b130:	18c7883a 	add	r3,r3,r3
8110b134:	10c5883a 	add	r2,r2,r3
8110b138:	e0ffde0b 	ldhu	r3,-136(fp)
8110b13c:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
8110b140:	00a04534 	movhi	r2,33044
8110b144:	109ba304 	addi	r2,r2,28300
8110b148:	10800483 	ldbu	r2,18(r2)
8110b14c:	10800044 	addi	r2,r2,1
8110b150:	1007883a 	mov	r3,r2
8110b154:	00a04534 	movhi	r2,33044
8110b158:	109ba304 	addi	r2,r2,28300
8110b15c:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
8110b160:	00a04534 	movhi	r2,33044
8110b164:	109ba304 	addi	r2,r2,28300
8110b168:	1080038b 	ldhu	r2,14(r2)
8110b16c:	10bfffcc 	andi	r2,r2,65535
8110b170:	10c000e0 	cmpeqi	r3,r2,3
8110b174:	18000a1e 	bne	r3,zero,8110b1a0 <vParserCommTask+0x87c>
8110b178:	10c00108 	cmpgei	r3,r2,4
8110b17c:	1800031e 	bne	r3,zero,8110b18c <vParserCommTask+0x868>
8110b180:	108000a0 	cmpeqi	r2,r2,2
8110b184:	1000451e 	bne	r2,zero,8110b29c <vParserCommTask+0x978>
8110b188:	00013c06 	br	8110b67c <vParserCommTask+0xd58>
8110b18c:	10c00120 	cmpeqi	r3,r2,4
8110b190:	1800181e 	bne	r3,zero,8110b1f4 <vParserCommTask+0x8d0>
8110b194:	10800160 	cmpeqi	r2,r2,5
8110b198:	10002b1e 	bne	r2,zero,8110b248 <vParserCommTask+0x924>
8110b19c:	00013706 	br	8110b67c <vParserCommTask+0xd58>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110b1a0:	e0bfdec4 	addi	r2,fp,-133
8110b1a4:	01802004 	movi	r6,128
8110b1a8:	000b883a 	mov	r5,zero
8110b1ac:	1009883a 	mov	r4,r2
8110b1b0:	11168840 	call	81116884 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_ENABLE-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110b1b4:	e0ffde0b 	ldhu	r3,-136(fp)
8110b1b8:	e0bfdec4 	addi	r2,fp,-133
8110b1bc:	180d883a 	mov	r6,r3
8110b1c0:	01604534 	movhi	r5,33044
8110b1c4:	29465004 	addi	r5,r5,6464
8110b1c8:	1009883a 	mov	r4,r2
8110b1cc:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b1d0:	d0a05417 	ldw	r2,-32432(gp)
8110b1d4:	e0ffdec4 	addi	r3,fp,-133
8110b1d8:	180b883a 	mov	r5,r3
8110b1dc:	1009883a 	mov	r4,r2
8110b1e0:	11156840 	call	81115684 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110b1e4:	01204534 	movhi	r4,33044
8110b1e8:	211ba304 	addi	r4,r4,28300
8110b1ec:	110b83c0 	call	8110b83c <bSendMessagePUStoMebTask>

								break;
8110b1f0:	00014306 	br	8110b700 <vParserCommTask+0xddc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110b1f4:	e0bfdec4 	addi	r2,fp,-133
8110b1f8:	01802004 	movi	r6,128
8110b1fc:	000b883a 	mov	r5,zero
8110b200:	1009883a 	mov	r4,r2
8110b204:	11168840 	call	81116884 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_DISABLE-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110b208:	e0ffde0b 	ldhu	r3,-136(fp)
8110b20c:	e0bfdec4 	addi	r2,fp,-133
8110b210:	180d883a 	mov	r6,r3
8110b214:	01604534 	movhi	r5,33044
8110b218:	29465d04 	addi	r5,r5,6516
8110b21c:	1009883a 	mov	r4,r2
8110b220:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b224:	d0a05417 	ldw	r2,-32432(gp)
8110b228:	e0ffdec4 	addi	r3,fp,-133
8110b22c:	180b883a 	mov	r5,r3
8110b230:	1009883a 	mov	r4,r2
8110b234:	11156840 	call	81115684 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110b238:	01204534 	movhi	r4,33044
8110b23c:	211ba304 	addi	r4,r4,28300
8110b240:	110b83c0 	call	8110b83c <bSendMessagePUStoMebTask>

								break;
8110b244:	00012e06 	br	8110b700 <vParserCommTask+0xddc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110b248:	e0bfdec4 	addi	r2,fp,-133
8110b24c:	01802004 	movi	r6,128
8110b250:	000b883a 	mov	r5,zero
8110b254:	1009883a 	mov	r4,r2
8110b258:	11168840 	call	81116884 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_RESET-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110b25c:	e0ffde0b 	ldhu	r3,-136(fp)
8110b260:	e0bfdec4 	addi	r2,fp,-133
8110b264:	180d883a 	mov	r6,r3
8110b268:	01604534 	movhi	r5,33044
8110b26c:	29466a04 	addi	r5,r5,6568
8110b270:	1009883a 	mov	r4,r2
8110b274:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b278:	d0a05417 	ldw	r2,-32432(gp)
8110b27c:	e0ffdec4 	addi	r3,fp,-133
8110b280:	180b883a 	mov	r5,r3
8110b284:	1009883a 	mov	r4,r2
8110b288:	11156840 	call	81115684 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110b28c:	01204534 	movhi	r4,33044
8110b290:	211ba304 	addi	r4,r4,28300
8110b294:	110b83c0 	call	8110b83c <bSendMessagePUStoMebTask>

								break;
8110b298:	00011906 	br	8110b700 <vParserCommTask+0xddc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
8110b29c:	00a04534 	movhi	r2,33044
8110b2a0:	109ba304 	addi	r2,r2,28300
8110b2a4:	10800483 	ldbu	r2,18(r2)
8110b2a8:	10c03fcc 	andi	r3,r2,255
8110b2ac:	00a04534 	movhi	r2,33044
8110b2b0:	109b9004 	addi	r2,r2,28224
8110b2b4:	1100058b 	ldhu	r4,22(r2)
8110b2b8:	00a04534 	movhi	r2,33044
8110b2bc:	109ba304 	addi	r2,r2,28300
8110b2c0:	18c00284 	addi	r3,r3,10
8110b2c4:	18c7883a 	add	r3,r3,r3
8110b2c8:	10c5883a 	add	r2,r2,r3
8110b2cc:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110b2d0:	00a04534 	movhi	r2,33044
8110b2d4:	109ba304 	addi	r2,r2,28300
8110b2d8:	10800483 	ldbu	r2,18(r2)
8110b2dc:	10800044 	addi	r2,r2,1
8110b2e0:	1007883a 	mov	r3,r2
8110b2e4:	00a04534 	movhi	r2,33044
8110b2e8:	109ba304 	addi	r2,r2,28300
8110b2ec:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
8110b2f0:	00a04534 	movhi	r2,33044
8110b2f4:	109ba304 	addi	r2,r2,28300
8110b2f8:	10800483 	ldbu	r2,18(r2)
8110b2fc:	10c03fcc 	andi	r3,r2,255
8110b300:	00a04534 	movhi	r2,33044
8110b304:	109b9004 	addi	r2,r2,28224
8110b308:	1100060b 	ldhu	r4,24(r2)
8110b30c:	00a04534 	movhi	r2,33044
8110b310:	109ba304 	addi	r2,r2,28300
8110b314:	18c00284 	addi	r3,r3,10
8110b318:	18c7883a 	add	r3,r3,r3
8110b31c:	10c5883a 	add	r2,r2,r3
8110b320:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110b324:	00a04534 	movhi	r2,33044
8110b328:	109ba304 	addi	r2,r2,28300
8110b32c:	10800483 	ldbu	r2,18(r2)
8110b330:	10800044 	addi	r2,r2,1
8110b334:	1007883a 	mov	r3,r2
8110b338:	00a04534 	movhi	r2,33044
8110b33c:	109ba304 	addi	r2,r2,28300
8110b340:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
8110b344:	00a04534 	movhi	r2,33044
8110b348:	109ba304 	addi	r2,r2,28300
8110b34c:	10800483 	ldbu	r2,18(r2)
8110b350:	10c03fcc 	andi	r3,r2,255
8110b354:	00a04534 	movhi	r2,33044
8110b358:	109b9004 	addi	r2,r2,28224
8110b35c:	1100068b 	ldhu	r4,26(r2)
8110b360:	00a04534 	movhi	r2,33044
8110b364:	109ba304 	addi	r2,r2,28300
8110b368:	18c00284 	addi	r3,r3,10
8110b36c:	18c7883a 	add	r3,r3,r3
8110b370:	10c5883a 	add	r2,r2,r3
8110b374:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110b378:	00a04534 	movhi	r2,33044
8110b37c:	109ba304 	addi	r2,r2,28300
8110b380:	10800483 	ldbu	r2,18(r2)
8110b384:	10800044 	addi	r2,r2,1
8110b388:	1007883a 	mov	r3,r2
8110b38c:	00a04534 	movhi	r2,33044
8110b390:	109ba304 	addi	r2,r2,28300
8110b394:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
8110b398:	00a04534 	movhi	r2,33044
8110b39c:	109ba304 	addi	r2,r2,28300
8110b3a0:	10800483 	ldbu	r2,18(r2)
8110b3a4:	10c03fcc 	andi	r3,r2,255
8110b3a8:	00a04534 	movhi	r2,33044
8110b3ac:	109b9004 	addi	r2,r2,28224
8110b3b0:	1100070b 	ldhu	r4,28(r2)
8110b3b4:	00a04534 	movhi	r2,33044
8110b3b8:	109ba304 	addi	r2,r2,28300
8110b3bc:	18c00284 	addi	r3,r3,10
8110b3c0:	18c7883a 	add	r3,r3,r3
8110b3c4:	10c5883a 	add	r2,r2,r3
8110b3c8:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110b3cc:	00a04534 	movhi	r2,33044
8110b3d0:	109ba304 	addi	r2,r2,28300
8110b3d4:	10800483 	ldbu	r2,18(r2)
8110b3d8:	10800044 	addi	r2,r2,1
8110b3dc:	1007883a 	mov	r3,r2
8110b3e0:	00a04534 	movhi	r2,33044
8110b3e4:	109ba304 	addi	r2,r2,28300
8110b3e8:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
8110b3ec:	00a04534 	movhi	r2,33044
8110b3f0:	109ba304 	addi	r2,r2,28300
8110b3f4:	10800483 	ldbu	r2,18(r2)
8110b3f8:	10c03fcc 	andi	r3,r2,255
8110b3fc:	00a04534 	movhi	r2,33044
8110b400:	109b9004 	addi	r2,r2,28224
8110b404:	1100078b 	ldhu	r4,30(r2)
8110b408:	00a04534 	movhi	r2,33044
8110b40c:	109ba304 	addi	r2,r2,28300
8110b410:	18c00284 	addi	r3,r3,10
8110b414:	18c7883a 	add	r3,r3,r3
8110b418:	10c5883a 	add	r2,r2,r3
8110b41c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110b420:	00a04534 	movhi	r2,33044
8110b424:	109ba304 	addi	r2,r2,28300
8110b428:	10800483 	ldbu	r2,18(r2)
8110b42c:	10800044 	addi	r2,r2,1
8110b430:	1007883a 	mov	r3,r2
8110b434:	00a04534 	movhi	r2,33044
8110b438:	109ba304 	addi	r2,r2,28300
8110b43c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
8110b440:	00a04534 	movhi	r2,33044
8110b444:	109ba304 	addi	r2,r2,28300
8110b448:	10800483 	ldbu	r2,18(r2)
8110b44c:	10c03fcc 	andi	r3,r2,255
8110b450:	00a04534 	movhi	r2,33044
8110b454:	109b9004 	addi	r2,r2,28224
8110b458:	1100080b 	ldhu	r4,32(r2)
8110b45c:	00a04534 	movhi	r2,33044
8110b460:	109ba304 	addi	r2,r2,28300
8110b464:	18c00284 	addi	r3,r3,10
8110b468:	18c7883a 	add	r3,r3,r3
8110b46c:	10c5883a 	add	r2,r2,r3
8110b470:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110b474:	00a04534 	movhi	r2,33044
8110b478:	109ba304 	addi	r2,r2,28300
8110b47c:	10800483 	ldbu	r2,18(r2)
8110b480:	10800044 	addi	r2,r2,1
8110b484:	1007883a 	mov	r3,r2
8110b488:	00a04534 	movhi	r2,33044
8110b48c:	109ba304 	addi	r2,r2,28300
8110b490:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110b494:	e0bfdec4 	addi	r2,fp,-133
8110b498:	01802004 	movi	r6,128
8110b49c:	000b883a 	mov	r5,zero
8110b4a0:	1009883a 	mov	r4,r2
8110b4a4:	11168840 	call	81116884 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_RMAP_CONFIG_UPDATE->\n");
8110b4a8:	e0ffdec4 	addi	r3,fp,-133
8110b4ac:	00a04534 	movhi	r2,33044
8110b4b0:	10867604 	addi	r2,r2,6616
8110b4b4:	1009883a 	mov	r4,r2
8110b4b8:	00800884 	movi	r2,34
8110b4bc:	100d883a 	mov	r6,r2
8110b4c0:	200b883a 	mov	r5,r4
8110b4c4:	1809883a 	mov	r4,r3
8110b4c8:	11167340 	call	81116734 <memcpy>
									debug(fp, cPUSDebug );
8110b4cc:	d0a05417 	ldw	r2,-32432(gp)
8110b4d0:	e0ffdec4 	addi	r3,fp,-133
8110b4d4:	180b883a 	mov	r5,r3
8110b4d8:	1009883a 	mov	r4,r2
8110b4dc:	11156840 	call	81115684 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110b4e0:	e0ffde0b 	ldhu	r3,-136(fp)
8110b4e4:	e0bfdec4 	addi	r2,fp,-133
8110b4e8:	180d883a 	mov	r6,r3
8110b4ec:	01604534 	movhi	r5,33044
8110b4f0:	29467f04 	addi	r5,r5,6652
8110b4f4:	1009883a 	mov	r4,r2
8110b4f8:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b4fc:	d0a05417 	ldw	r2,-32432(gp)
8110b500:	e0ffdec4 	addi	r3,fp,-133
8110b504:	180b883a 	mov	r5,r3
8110b508:	1009883a 	mov	r4,r2
8110b50c:	11156840 	call	81115684 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
8110b510:	00a04534 	movhi	r2,33044
8110b514:	109b9004 	addi	r2,r2,28224
8110b518:	1080058b 	ldhu	r2,22(r2)
8110b51c:	10ffffcc 	andi	r3,r2,65535
8110b520:	e0bfdec4 	addi	r2,fp,-133
8110b524:	180d883a 	mov	r6,r3
8110b528:	01604534 	movhi	r5,33044
8110b52c:	29468604 	addi	r5,r5,6680
8110b530:	1009883a 	mov	r4,r2
8110b534:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b538:	d0a05417 	ldw	r2,-32432(gp)
8110b53c:	e0ffdec4 	addi	r3,fp,-133
8110b540:	180b883a 	mov	r5,r3
8110b544:	1009883a 	mov	r4,r2
8110b548:	11156840 	call	81115684 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
8110b54c:	00a04534 	movhi	r2,33044
8110b550:	109b9004 	addi	r2,r2,28224
8110b554:	1080060b 	ldhu	r2,24(r2)
8110b558:	10ffffcc 	andi	r3,r2,65535
8110b55c:	e0bfdec4 	addi	r2,fp,-133
8110b560:	180d883a 	mov	r6,r3
8110b564:	01604534 	movhi	r5,33044
8110b568:	29468a04 	addi	r5,r5,6696
8110b56c:	1009883a 	mov	r4,r2
8110b570:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b574:	d0a05417 	ldw	r2,-32432(gp)
8110b578:	e0ffdec4 	addi	r3,fp,-133
8110b57c:	180b883a 	mov	r5,r3
8110b580:	1009883a 	mov	r4,r2
8110b584:	11156840 	call	81115684 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
8110b588:	00a04534 	movhi	r2,33044
8110b58c:	109b9004 	addi	r2,r2,28224
8110b590:	1080068b 	ldhu	r2,26(r2)
8110b594:	10ffffcc 	andi	r3,r2,65535
8110b598:	e0bfdec4 	addi	r2,fp,-133
8110b59c:	180d883a 	mov	r6,r3
8110b5a0:	01604534 	movhi	r5,33044
8110b5a4:	29468f04 	addi	r5,r5,6716
8110b5a8:	1009883a 	mov	r4,r2
8110b5ac:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b5b0:	d0a05417 	ldw	r2,-32432(gp)
8110b5b4:	e0ffdec4 	addi	r3,fp,-133
8110b5b8:	180b883a 	mov	r5,r3
8110b5bc:	1009883a 	mov	r4,r2
8110b5c0:	11156840 	call	81115684 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
8110b5c4:	00a04534 	movhi	r2,33044
8110b5c8:	109b9004 	addi	r2,r2,28224
8110b5cc:	1080070b 	ldhu	r2,28(r2)
8110b5d0:	10ffffcc 	andi	r3,r2,65535
8110b5d4:	e0bfdec4 	addi	r2,fp,-133
8110b5d8:	180d883a 	mov	r6,r3
8110b5dc:	01604534 	movhi	r5,33044
8110b5e0:	29469604 	addi	r5,r5,6744
8110b5e4:	1009883a 	mov	r4,r2
8110b5e8:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b5ec:	d0a05417 	ldw	r2,-32432(gp)
8110b5f0:	e0ffdec4 	addi	r3,fp,-133
8110b5f4:	180b883a 	mov	r5,r3
8110b5f8:	1009883a 	mov	r4,r2
8110b5fc:	11156840 	call	81115684 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
8110b600:	00a04534 	movhi	r2,33044
8110b604:	109b9004 	addi	r2,r2,28224
8110b608:	1080078b 	ldhu	r2,30(r2)
8110b60c:	10ffffcc 	andi	r3,r2,65535
8110b610:	e0bfdec4 	addi	r2,fp,-133
8110b614:	180d883a 	mov	r6,r3
8110b618:	01604534 	movhi	r5,33044
8110b61c:	29469d04 	addi	r5,r5,6772
8110b620:	1009883a 	mov	r4,r2
8110b624:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b628:	d0a05417 	ldw	r2,-32432(gp)
8110b62c:	e0ffdec4 	addi	r3,fp,-133
8110b630:	180b883a 	mov	r5,r3
8110b634:	1009883a 	mov	r4,r2
8110b638:	11156840 	call	81115684 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
8110b63c:	00a04534 	movhi	r2,33044
8110b640:	109b9004 	addi	r2,r2,28224
8110b644:	1080080b 	ldhu	r2,32(r2)
8110b648:	10ffffcc 	andi	r3,r2,65535
8110b64c:	e0bfdec4 	addi	r2,fp,-133
8110b650:	180d883a 	mov	r6,r3
8110b654:	01604534 	movhi	r5,33044
8110b658:	2946a304 	addi	r5,r5,6796
8110b65c:	1009883a 	mov	r4,r2
8110b660:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b664:	d0a05417 	ldw	r2,-32432(gp)
8110b668:	e0ffdec4 	addi	r3,fp,-133
8110b66c:	180b883a 	mov	r5,r3
8110b670:	1009883a 	mov	r4,r2
8110b674:	11156840 	call	81115684 <fprintf>
								#endif

								break;
8110b678:	00002106 	br	8110b700 <vParserCommTask+0xddc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110b67c:	e0bfdec4 	addi	r2,fp,-133
8110b680:	01802004 	movi	r6,128
8110b684:	000b883a 	mov	r5,zero
8110b688:	1009883a 	mov	r4,r2
8110b68c:	11168840 	call	81116884 <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110b690:	00a04534 	movhi	r2,33044
8110b694:	109ba304 	addi	r2,r2,28300
8110b698:	1080030b 	ldhu	r2,12(r2)
8110b69c:	113fffcc 	andi	r4,r2,65535
8110b6a0:	00a04534 	movhi	r2,33044
8110b6a4:	109ba304 	addi	r2,r2,28300
8110b6a8:	1080038b 	ldhu	r2,14(r2)
8110b6ac:	117fffcc 	andi	r5,r2,65535
8110b6b0:	00a04534 	movhi	r2,33044
8110b6b4:	109ba304 	addi	r2,r2,28300
8110b6b8:	1080040b 	ldhu	r2,16(r2)
8110b6bc:	10bfffcc 	andi	r2,r2,65535
8110b6c0:	e0ffdec4 	addi	r3,fp,-133
8110b6c4:	d8800015 	stw	r2,0(sp)
8110b6c8:	280f883a 	mov	r7,r5
8110b6cc:	200d883a 	mov	r6,r4
8110b6d0:	01604534 	movhi	r5,33044
8110b6d4:	2945fc04 	addi	r5,r5,6128
8110b6d8:	1809883a 	mov	r4,r3
8110b6dc:	11170140 	call	81117014 <sprintf>
									debug(fp, cPUSDebug );
8110b6e0:	d0a05417 	ldw	r2,-32432(gp)
8110b6e4:	e0ffdec4 	addi	r3,fp,-133
8110b6e8:	180b883a 	mov	r5,r3
8110b6ec:	1009883a 	mov	r4,r2
8110b6f0:	11156840 	call	81115684 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8110b6f4:	00800044 	movi	r2,1
8110b6f8:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110b6fc:	0001883a 	nop
						}
                        break;
8110b700:	00000306 	br	8110b710 <vParserCommTask+0xdec>
                    default:
						eParserMode = sWaitingMessage;
8110b704:	00800044 	movi	r2,1
8110b708:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8110b70c:	0001883a 	nop
                }
				break;				
8110b710:	00000306 	br	8110b720 <vParserCommTask+0xdfc>
			default:
				eParserMode = sWaitingMessage;
8110b714:	00800044 	movi	r2,1
8110b718:	e0bfdc15 	stw	r2,-144(fp)
				break;
8110b71c:	0001883a 	nop
		}
	}
8110b720:	003c9006 	br	8110a964 <__reset+0xfb0ea964>

8110b724 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
8110b724:	defffb04 	addi	sp,sp,-20
8110b728:	de00012e 	bgeu	sp,et,8110b730 <getPreParsedPacket+0xc>
8110b72c:	003b68fa 	trap	3
8110b730:	dfc00415 	stw	ra,16(sp)
8110b734:	df000315 	stw	fp,12(sp)
8110b738:	df000304 	addi	fp,sp,12
8110b73c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110b740:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
8110b744:	d0a05c17 	ldw	r2,-32400(gp)
8110b748:	e0fffe44 	addi	r3,fp,-7
8110b74c:	180d883a 	mov	r6,r3
8110b750:	000b883a 	mov	r5,zero
8110b754:	1009883a 	mov	r4,r2
8110b758:	11317540 	call	81131754 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
8110b75c:	e0bffe43 	ldbu	r2,-7(fp)
8110b760:	10803fcc 	andi	r2,r2,255
8110b764:	10002e1e 	bne	r2,zero,8110b820 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8110b768:	e03ffe05 	stb	zero,-8(fp)
8110b76c:	00002506 	br	8110b804 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
8110b770:	e0fffe03 	ldbu	r3,-8(fp)
8110b774:	00a045b4 	movhi	r2,33046
8110b778:	10a8f604 	addi	r2,r2,-23592
8110b77c:	18c01324 	muli	r3,r3,76
8110b780:	10c5883a 	add	r2,r2,r3
8110b784:	10800104 	addi	r2,r2,4
8110b788:	10800003 	ldbu	r2,0(r2)
8110b78c:	10803fcc 	andi	r2,r2,255
8110b790:	1080201c 	xori	r2,r2,128
8110b794:	10bfe004 	addi	r2,r2,-128
8110b798:	10001726 	beq	r2,zero,8110b7f8 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
8110b79c:	e0fffe03 	ldbu	r3,-8(fp)
8110b7a0:	e13fff17 	ldw	r4,-4(fp)
8110b7a4:	00a045b4 	movhi	r2,33046
8110b7a8:	10a8f604 	addi	r2,r2,-23592
8110b7ac:	18c01324 	muli	r3,r3,76
8110b7b0:	10c5883a 	add	r2,r2,r3
8110b7b4:	2007883a 	mov	r3,r4
8110b7b8:	1009883a 	mov	r4,r2
8110b7bc:	00801304 	movi	r2,76
8110b7c0:	100d883a 	mov	r6,r2
8110b7c4:	200b883a 	mov	r5,r4
8110b7c8:	1809883a 	mov	r4,r3
8110b7cc:	11167340 	call	81116734 <memcpy>
                bSuccess = TRUE;
8110b7d0:	00800044 	movi	r2,1
8110b7d4:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
8110b7d8:	e0fffe03 	ldbu	r3,-8(fp)
8110b7dc:	00a045b4 	movhi	r2,33046
8110b7e0:	10a8f604 	addi	r2,r2,-23592
8110b7e4:	18c01324 	muli	r3,r3,76
8110b7e8:	10c5883a 	add	r2,r2,r3
8110b7ec:	10800104 	addi	r2,r2,4
8110b7f0:	10000005 	stb	zero,0(r2)
                break;
8110b7f4:	00000606 	br	8110b810 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8110b7f8:	e0bffe03 	ldbu	r2,-8(fp)
8110b7fc:	10800044 	addi	r2,r2,1
8110b800:	e0bffe05 	stb	r2,-8(fp)
8110b804:	e0bffe03 	ldbu	r2,-8(fp)
8110b808:	10800230 	cmpltui	r2,r2,8
8110b80c:	103fd81e 	bne	r2,zero,8110b770 <__reset+0xfb0eb770>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
8110b810:	d0a05c17 	ldw	r2,-32400(gp)
8110b814:	1009883a 	mov	r4,r2
8110b818:	1131cf80 	call	81131cf8 <OSMutexPost>
8110b81c:	00000106 	br	8110b824 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
8110b820:	11119a00 	call	811119a0 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
8110b824:	e0bffd17 	ldw	r2,-12(fp)
}
8110b828:	e037883a 	mov	sp,fp
8110b82c:	dfc00117 	ldw	ra,4(sp)
8110b830:	df000017 	ldw	fp,0(sp)
8110b834:	dec00204 	addi	sp,sp,8
8110b838:	f800283a 	ret

8110b83c <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
8110b83c:	defffa04 	addi	sp,sp,-24
8110b840:	de00012e 	bgeu	sp,et,8110b848 <bSendMessagePUStoMebTask+0xc>
8110b844:	003b68fa 	trap	3
8110b848:	dfc00515 	stw	ra,20(sp)
8110b84c:	df000415 	stw	fp,16(sp)
8110b850:	df000404 	addi	fp,sp,16
8110b854:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110b858:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
8110b85c:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
8110b860:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
8110b864:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
8110b868:	d0a06317 	ldw	r2,-32372(gp)
8110b86c:	e0fffd44 	addi	r3,fp,-11
8110b870:	180d883a 	mov	r6,r3
8110b874:	01400284 	movi	r5,10
8110b878:	1009883a 	mov	r4,r2
8110b87c:	11317540 	call	81131754 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110b880:	e0bffd43 	ldbu	r2,-11(fp)
8110b884:	10803fcc 	andi	r2,r2,255
8110b888:	1000401e 	bne	r2,zero,8110b98c <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
8110b88c:	e03ffd05 	stb	zero,-12(fp)
8110b890:	00003806 	br	8110b974 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
8110b894:	e0fffd03 	ldbu	r3,-12(fp)
8110b898:	00a04574 	movhi	r2,33045
8110b89c:	10a5d704 	addi	r2,r2,-26788
8110b8a0:	18c01524 	muli	r3,r3,84
8110b8a4:	10c5883a 	add	r2,r2,r3
8110b8a8:	10800104 	addi	r2,r2,4
8110b8ac:	10800017 	ldw	r2,0(r2)
8110b8b0:	10002d1e 	bne	r2,zero,8110b968 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
8110b8b4:	e0fffd03 	ldbu	r3,-12(fp)
8110b8b8:	00a04574 	movhi	r2,33045
8110b8bc:	10a5d704 	addi	r2,r2,-26788
8110b8c0:	18c01524 	muli	r3,r3,84
8110b8c4:	10c7883a 	add	r3,r2,r3
8110b8c8:	e0bfff17 	ldw	r2,-4(fp)
8110b8cc:	1009883a 	mov	r4,r2
8110b8d0:	00801504 	movi	r2,84
8110b8d4:	100d883a 	mov	r6,r2
8110b8d8:	200b883a 	mov	r5,r4
8110b8dc:	1809883a 	mov	r4,r3
8110b8e0:	11167340 	call	81116734 <memcpy>
            	xPus[i].bInUse = TRUE;
8110b8e4:	e0fffd03 	ldbu	r3,-12(fp)
8110b8e8:	00a04574 	movhi	r2,33045
8110b8ec:	10a5d704 	addi	r2,r2,-26788
8110b8f0:	18c01524 	muli	r3,r3,84
8110b8f4:	10c5883a 	add	r2,r2,r3
8110b8f8:	10800104 	addi	r2,r2,4
8110b8fc:	00c00044 	movi	r3,1
8110b900:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
8110b904:	00800044 	movi	r2,1
8110b908:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
8110b90c:	00800044 	movi	r2,1
8110b910:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
8110b914:	d0a05b17 	ldw	r2,-32404(gp)
8110b918:	e0fffe17 	ldw	r3,-8(fp)
8110b91c:	180b883a 	mov	r5,r3
8110b920:	1009883a 	mov	r4,r2
8110b924:	1132c700 	call	81132c70 <OSQPost>
8110b928:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
8110b92c:	e0bffd43 	ldbu	r2,-11(fp)
8110b930:	10803fcc 	andi	r2,r2,255
8110b934:	10000926 	beq	r2,zero,8110b95c <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
8110b938:	11128200 	call	81112820 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
8110b93c:	e0fffd03 	ldbu	r3,-12(fp)
8110b940:	00a04574 	movhi	r2,33045
8110b944:	10a5d704 	addi	r2,r2,-26788
8110b948:	18c01524 	muli	r3,r3,84
8110b94c:	10c5883a 	add	r2,r2,r3
8110b950:	10800104 	addi	r2,r2,4
8110b954:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
8110b958:	00000906 	br	8110b980 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
8110b95c:	00800044 	movi	r2,1
8110b960:	e0bffc15 	stw	r2,-16(fp)
                break;
8110b964:	00000606 	br	8110b980 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
8110b968:	e0bffd03 	ldbu	r2,-12(fp)
8110b96c:	10800044 	addi	r2,r2,1
8110b970:	e0bffd05 	stb	r2,-12(fp)
8110b974:	e0bffd03 	ldbu	r2,-12(fp)
8110b978:	10800130 	cmpltui	r2,r2,4
8110b97c:	103fc51e 	bne	r2,zero,8110b894 <__reset+0xfb0eb894>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
8110b980:	d0a06317 	ldw	r2,-32372(gp)
8110b984:	1009883a 	mov	r4,r2
8110b988:	1131cf80 	call	81131cf8 <OSMutexPost>
    }

    return bSuccess;
8110b98c:	e0bffc17 	ldw	r2,-16(fp)
}
8110b990:	e037883a 	mov	sp,fp
8110b994:	dfc00117 	ldw	ra,4(sp)
8110b998:	df000017 	ldw	fp,0(sp)
8110b99c:	dec00204 	addi	sp,sp,8
8110b9a0:	f800283a 	ret

8110b9a4 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
8110b9a4:	deffab04 	addi	sp,sp,-340
8110b9a8:	de00012e 	bgeu	sp,et,8110b9b0 <vReceiverUartTask+0xc>
8110b9ac:	003b68fa 	trap	3
8110b9b0:	dfc05415 	stw	ra,336(sp)
8110b9b4:	df005315 	stw	fp,332(sp)
8110b9b8:	df005304 	addi	fp,sp,332
8110b9bc:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110b9c0:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
8110b9c4:	d0a05417 	ldw	r2,-32432(gp)
8110b9c8:	100f883a 	mov	r7,r2
8110b9cc:	01800784 	movi	r6,30
8110b9d0:	01400044 	movi	r5,1
8110b9d4:	01204534 	movhi	r4,33044
8110b9d8:	2106a904 	addi	r4,r4,6820
8110b9dc:	1115d200 	call	81115d20 <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
8110b9e0:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
8110b9e4:	e0bfad17 	ldw	r2,-332(fp)
8110b9e8:	10c00060 	cmpeqi	r3,r2,1
8110b9ec:	1800091e 	bne	r3,zero,8110ba14 <vReceiverUartTask+0x70>
8110b9f0:	0080052e 	bgeu	zero,r2,8110ba08 <vReceiverUartTask+0x64>
8110b9f4:	10c000a0 	cmpeqi	r3,r2,2
8110b9f8:	18005d1e 	bne	r3,zero,8110bb70 <vReceiverUartTask+0x1cc>
8110b9fc:	108000e0 	cmpeqi	r2,r2,3
8110ba00:	10006e1e 	bne	r2,zero,8110bbbc <vReceiverUartTask+0x218>
8110ba04:	00007706 	br	8110bbe4 <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
8110ba08:	00800044 	movi	r2,1
8110ba0c:	e0bfad15 	stw	r2,-332(fp)
                break;
8110ba10:	00007706 	br	8110bbf0 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
8110ba14:	e0bfaf04 	addi	r2,fp,-324
8110ba18:	01802004 	movi	r6,128
8110ba1c:	000b883a 	mov	r5,zero
8110ba20:	1009883a 	mov	r4,r2
8110ba24:	11168840 	call	81116884 <memset>
                scanf("%s", cReceive);
8110ba28:	e0bfcf04 	addi	r2,fp,-196
8110ba2c:	100b883a 	mov	r5,r2
8110ba30:	01204534 	movhi	r4,33044
8110ba34:	2106b104 	addi	r4,r4,6852
8110ba38:	1116f380 	call	81116f38 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
8110ba3c:	e0ffcf04 	addi	r3,fp,-196
8110ba40:	e0bfaf04 	addi	r2,fp,-324
8110ba44:	01801fc4 	movi	r6,127
8110ba48:	180b883a 	mov	r5,r3
8110ba4c:	1009883a 	mov	r4,r2
8110ba50:	11167340 	call	81116734 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
8110ba54:	e0bfaf04 	addi	r2,fp,-324
8110ba58:	01604534 	movhi	r5,33044
8110ba5c:	295bb804 	addi	r5,r5,28384
8110ba60:	1009883a 	mov	r4,r2
8110ba64:	110c0480 	call	8110c048 <bPreParserV2>
8110ba68:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
8110ba6c:	e0bfae17 	ldw	r2,-328(fp)
8110ba70:	10800058 	cmpnei	r2,r2,1
8110ba74:	1000281e 	bne	r2,zero,8110bb18 <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
8110ba78:	00a04534 	movhi	r2,33044
8110ba7c:	109bb804 	addi	r2,r2,28384
8110ba80:	10800103 	ldbu	r2,4(r2)
8110ba84:	10803fcc 	andi	r2,r2,255
8110ba88:	1080201c 	xori	r2,r2,128
8110ba8c:	10bfe004 	addi	r2,r2,-128
8110ba90:	10800fe0 	cmpeqi	r2,r2,63
8110ba94:	1000081e 	bne	r2,zero,8110bab8 <vReceiverUartTask+0x114>
8110ba98:	00a04534 	movhi	r2,33044
8110ba9c:	109bb804 	addi	r2,r2,28384
8110baa0:	10800103 	ldbu	r2,4(r2)
8110baa4:	10803fcc 	andi	r2,r2,255
8110baa8:	1080201c 	xori	r2,r2,128
8110baac:	10bfe004 	addi	r2,r2,-128
8110bab0:	10800858 	cmpnei	r2,r2,33
8110bab4:	1000031e 	bne	r2,zero,8110bac4 <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
8110bab8:	00800084 	movi	r2,2
8110babc:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110bac0:	00004b06 	br	8110bbf0 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
8110bac4:	00a04534 	movhi	r2,33044
8110bac8:	109bb804 	addi	r2,r2,28384
8110bacc:	10800103 	ldbu	r2,4(r2)
8110bad0:	10803fcc 	andi	r2,r2,255
8110bad4:	1080201c 	xori	r2,r2,128
8110bad8:	10bfe004 	addi	r2,r2,-128
8110badc:	108008d8 	cmpnei	r2,r2,35
8110bae0:	10000a1e 	bne	r2,zero,8110bb0c <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
8110bae4:	00800044 	movi	r2,1
8110bae8:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
8110baec:	d0a05417 	ldw	r2,-32432(gp)
8110baf0:	100f883a 	mov	r7,r2
8110baf4:	018006c4 	movi	r6,27
8110baf8:	01400044 	movi	r5,1
8110bafc:	01204534 	movhi	r4,33044
8110bb00:	2106b204 	addi	r4,r4,6856
8110bb04:	1115d200 	call	81115d20 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110bb08:	00003906 	br	8110bbf0 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
8110bb0c:	008000c4 	movi	r2,3
8110bb10:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110bb14:	00003606 	br	8110bbf0 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
8110bb18:	00a04534 	movhi	r2,33044
8110bb1c:	109bb804 	addi	r2,r2,28384
8110bb20:	00c008c4 	movi	r3,35
8110bb24:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
8110bb28:	00a04534 	movhi	r2,33044
8110bb2c:	109bb804 	addi	r2,r2,28384
8110bb30:	00c00b84 	movi	r3,46
8110bb34:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
8110bb38:	00a04534 	movhi	r2,33044
8110bb3c:	109bb804 	addi	r2,r2,28384
8110bb40:	00c00044 	movi	r3,1
8110bb44:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
8110bb48:	01204534 	movhi	r4,33044
8110bb4c:	211bb804 	addi	r4,r4,28384
8110bb50:	110bd300 	call	8110bd30 <setPreAckSenderFreePos>
8110bb54:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
8110bb58:	e0bfae17 	ldw	r2,-328(fp)
8110bb5c:	1000011e 	bne	r2,zero,8110bb64 <vReceiverUartTask+0x1c0>
                        vFailSendNack();
8110bb60:	1111ad80 	call	81111ad8 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
8110bb64:	00800044 	movi	r2,1
8110bb68:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
8110bb6c:	00002006 	br	8110bbf0 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
8110bb70:	01204534 	movhi	r4,33044
8110bb74:	211bb804 	addi	r4,r4,28384
8110bb78:	110bd300 	call	8110bd30 <setPreAckSenderFreePos>
8110bb7c:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
8110bb80:	e0bfae17 	ldw	r2,-328(fp)
8110bb84:	10800058 	cmpnei	r2,r2,1
8110bb88:	1000081e 	bne	r2,zero,8110bbac <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
8110bb8c:	01204534 	movhi	r4,33044
8110bb90:	211bb804 	addi	r4,r4,28384
8110bb94:	110bbf40 	call	8110bbf4 <setPreParsedFreePos>
8110bb98:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
8110bb9c:	e0bfae17 	ldw	r2,-328(fp)
8110bba0:	1000031e 	bne	r2,zero,8110bbb0 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
8110bba4:	1111ba80 	call	81111ba8 <vFailSetPreParsedBuffer>
8110bba8:	00000106 	br	8110bbb0 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
8110bbac:	1111b400 	call	81111b40 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
8110bbb0:	00800044 	movi	r2,1
8110bbb4:	e0bfad15 	stw	r2,-332(fp)
                break;
8110bbb8:	00000d06 	br	8110bbf0 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
8110bbbc:	01204534 	movhi	r4,33044
8110bbc0:	211bb804 	addi	r4,r4,28384
8110bbc4:	110beac0 	call	8110beac <setPreAckReceiverFreePos>
8110bbc8:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
8110bbcc:	e0bfae17 	ldw	r2,-328(fp)
8110bbd0:	1000011e 	bne	r2,zero,8110bbd8 <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
8110bbd4:	1111c100 	call	81111c10 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
8110bbd8:	00800044 	movi	r2,1
8110bbdc:	e0bfad15 	stw	r2,-332(fp)
                break;
8110bbe0:	00000306 	br	8110bbf0 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
8110bbe4:	00800044 	movi	r2,1
8110bbe8:	e0bfad15 	stw	r2,-332(fp)
                break;
8110bbec:	0001883a 	nop
        }

    }
8110bbf0:	003f7c06 	br	8110b9e4 <__reset+0xfb0eb9e4>

8110bbf4 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
8110bbf4:	defffb04 	addi	sp,sp,-20
8110bbf8:	de00012e 	bgeu	sp,et,8110bc00 <setPreParsedFreePos+0xc>
8110bbfc:	003b68fa 	trap	3
8110bc00:	dfc00415 	stw	ra,16(sp)
8110bc04:	df000315 	stw	fp,12(sp)
8110bc08:	df000304 	addi	fp,sp,12
8110bc0c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110bc10:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8110bc14:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
8110bc18:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
8110bc1c:	d0a05c17 	ldw	r2,-32400(gp)
8110bc20:	e0fffe44 	addi	r3,fp,-7
8110bc24:	180d883a 	mov	r6,r3
8110bc28:	01400284 	movi	r5,10
8110bc2c:	1009883a 	mov	r4,r2
8110bc30:	11317540 	call	81131754 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110bc34:	e0bffe43 	ldbu	r2,-7(fp)
8110bc38:	10803fcc 	andi	r2,r2,255
8110bc3c:	1000361e 	bne	r2,zero,8110bd18 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
8110bc40:	e03ffe05 	stb	zero,-8(fp)
8110bc44:	00002e06 	br	8110bd00 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
8110bc48:	e0fffe03 	ldbu	r3,-8(fp)
8110bc4c:	00a045b4 	movhi	r2,33046
8110bc50:	10a8f604 	addi	r2,r2,-23592
8110bc54:	18c01324 	muli	r3,r3,76
8110bc58:	10c5883a 	add	r2,r2,r3
8110bc5c:	10800104 	addi	r2,r2,4
8110bc60:	10800003 	ldbu	r2,0(r2)
8110bc64:	10803fcc 	andi	r2,r2,255
8110bc68:	1080201c 	xori	r2,r2,128
8110bc6c:	10bfe004 	addi	r2,r2,-128
8110bc70:	1000201e 	bne	r2,zero,8110bcf4 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
8110bc74:	e0fffe03 	ldbu	r3,-8(fp)
8110bc78:	00a045b4 	movhi	r2,33046
8110bc7c:	10a8f604 	addi	r2,r2,-23592
8110bc80:	18c01324 	muli	r3,r3,76
8110bc84:	10c7883a 	add	r3,r2,r3
8110bc88:	e0bfff17 	ldw	r2,-4(fp)
8110bc8c:	1009883a 	mov	r4,r2
8110bc90:	00801304 	movi	r2,76
8110bc94:	100d883a 	mov	r6,r2
8110bc98:	200b883a 	mov	r5,r4
8110bc9c:	1809883a 	mov	r4,r3
8110bca0:	11167340 	call	81116734 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
8110bca4:	d0a05617 	ldw	r2,-32424(gp)
8110bca8:	1009883a 	mov	r4,r2
8110bcac:	1133ae80 	call	81133ae8 <OSSemPost>
8110bcb0:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
8110bcb4:	e0bffe43 	ldbu	r2,-7(fp)
8110bcb8:	10803fcc 	andi	r2,r2,255
8110bcbc:	1000031e 	bne	r2,zero,8110bccc <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
8110bcc0:	00800044 	movi	r2,1
8110bcc4:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
8110bcc8:	00001006 	br	8110bd0c <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
8110bccc:	11111f80 	call	811111f8 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
8110bcd0:	e0fffe03 	ldbu	r3,-8(fp)
8110bcd4:	00a045b4 	movhi	r2,33046
8110bcd8:	10a8f604 	addi	r2,r2,-23592
8110bcdc:	18c01324 	muli	r3,r3,76
8110bce0:	10c5883a 	add	r2,r2,r3
8110bce4:	10800104 	addi	r2,r2,4
8110bce8:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
8110bcec:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
8110bcf0:	00000606 	br	8110bd0c <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
8110bcf4:	e0bffe03 	ldbu	r2,-8(fp)
8110bcf8:	10800044 	addi	r2,r2,1
8110bcfc:	e0bffe05 	stb	r2,-8(fp)
8110bd00:	e0bffe03 	ldbu	r2,-8(fp)
8110bd04:	10800230 	cmpltui	r2,r2,8
8110bd08:	103fcf1e 	bne	r2,zero,8110bc48 <__reset+0xfb0ebc48>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
8110bd0c:	d0a05c17 	ldw	r2,-32400(gp)
8110bd10:	1009883a 	mov	r4,r2
8110bd14:	1131cf80 	call	81131cf8 <OSMutexPost>
    }
    return bSuccess;
8110bd18:	e0bffd17 	ldw	r2,-12(fp)
}
8110bd1c:	e037883a 	mov	sp,fp
8110bd20:	dfc00117 	ldw	ra,4(sp)
8110bd24:	df000017 	ldw	fp,0(sp)
8110bd28:	dec00204 	addi	sp,sp,8
8110bd2c:	f800283a 	ret

8110bd30 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
8110bd30:	defffb04 	addi	sp,sp,-20
8110bd34:	de00012e 	bgeu	sp,et,8110bd3c <setPreAckSenderFreePos+0xc>
8110bd38:	003b68fa 	trap	3
8110bd3c:	dfc00415 	stw	ra,16(sp)
8110bd40:	df000315 	stw	fp,12(sp)
8110bd44:	df000304 	addi	fp,sp,12
8110bd48:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110bd4c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8110bd50:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
8110bd54:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
8110bd58:	d0a06217 	ldw	r2,-32376(gp)
8110bd5c:	e0fffe44 	addi	r3,fp,-7
8110bd60:	180d883a 	mov	r6,r3
8110bd64:	01400284 	movi	r5,10
8110bd68:	1009883a 	mov	r4,r2
8110bd6c:	11317540 	call	81131754 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110bd70:	e0bffe43 	ldbu	r2,-7(fp)
8110bd74:	10803fcc 	andi	r2,r2,255
8110bd78:	1000461e 	bne	r2,zero,8110be94 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
8110bd7c:	e03ffe05 	stb	zero,-8(fp)
8110bd80:	00003e06 	br	8110be7c <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
8110bd84:	e0fffe03 	ldbu	r3,-8(fp)
8110bd88:	00a045b4 	movhi	r2,33046
8110bd8c:	10a8ee04 	addi	r2,r2,-23624
8110bd90:	18c7883a 	add	r3,r3,r3
8110bd94:	18c7883a 	add	r3,r3,r3
8110bd98:	10c5883a 	add	r2,r2,r3
8110bd9c:	10800003 	ldbu	r2,0(r2)
8110bda0:	10803fcc 	andi	r2,r2,255
8110bda4:	1080201c 	xori	r2,r2,128
8110bda8:	10bfe004 	addi	r2,r2,-128
8110bdac:	1000301e 	bne	r2,zero,8110be70 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
8110bdb0:	e0fffe03 	ldbu	r3,-8(fp)
8110bdb4:	e0bfff17 	ldw	r2,-4(fp)
8110bdb8:	11000103 	ldbu	r4,4(r2)
8110bdbc:	00a045b4 	movhi	r2,33046
8110bdc0:	10a8ee04 	addi	r2,r2,-23624
8110bdc4:	18c7883a 	add	r3,r3,r3
8110bdc8:	18c7883a 	add	r3,r3,r3
8110bdcc:	10c5883a 	add	r2,r2,r3
8110bdd0:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
8110bdd4:	e0fffe03 	ldbu	r3,-8(fp)
8110bdd8:	e0bfff17 	ldw	r2,-4(fp)
8110bddc:	11000143 	ldbu	r4,5(r2)
8110bde0:	00a045b4 	movhi	r2,33046
8110bde4:	10a8ee04 	addi	r2,r2,-23624
8110bde8:	18c7883a 	add	r3,r3,r3
8110bdec:	18c7883a 	add	r3,r3,r3
8110bdf0:	10c5883a 	add	r2,r2,r3
8110bdf4:	10800044 	addi	r2,r2,1
8110bdf8:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
8110bdfc:	e0fffe03 	ldbu	r3,-8(fp)
8110be00:	e0bfff17 	ldw	r2,-4(fp)
8110be04:	1100020b 	ldhu	r4,8(r2)
8110be08:	00a045b4 	movhi	r2,33046
8110be0c:	10a8ee04 	addi	r2,r2,-23624
8110be10:	18c7883a 	add	r3,r3,r3
8110be14:	18c7883a 	add	r3,r3,r3
8110be18:	10c5883a 	add	r2,r2,r3
8110be1c:	10800084 	addi	r2,r2,2
8110be20:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
8110be24:	d0a05317 	ldw	r2,-32436(gp)
8110be28:	1009883a 	mov	r4,r2
8110be2c:	1133ae80 	call	81133ae8 <OSSemPost>
8110be30:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
8110be34:	e0bffe43 	ldbu	r2,-7(fp)
8110be38:	10803fcc 	andi	r2,r2,255
8110be3c:	10000926 	beq	r2,zero,8110be64 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
8110be40:	11112900 	call	81111290 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
8110be44:	e0fffe03 	ldbu	r3,-8(fp)
8110be48:	00a045b4 	movhi	r2,33046
8110be4c:	10a8ee04 	addi	r2,r2,-23624
8110be50:	18c7883a 	add	r3,r3,r3
8110be54:	18c7883a 	add	r3,r3,r3
8110be58:	10c5883a 	add	r2,r2,r3
8110be5c:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
8110be60:	00000906 	br	8110be88 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
8110be64:	00800044 	movi	r2,1
8110be68:	e0bffd15 	stw	r2,-12(fp)
                break;
8110be6c:	00000606 	br	8110be88 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
8110be70:	e0bffe03 	ldbu	r2,-8(fp)
8110be74:	10800044 	addi	r2,r2,1
8110be78:	e0bffe05 	stb	r2,-8(fp)
8110be7c:	e0bffe03 	ldbu	r2,-8(fp)
8110be80:	10800230 	cmpltui	r2,r2,8
8110be84:	103fbf1e 	bne	r2,zero,8110bd84 <__reset+0xfb0ebd84>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
8110be88:	d0a06217 	ldw	r2,-32376(gp)
8110be8c:	1009883a 	mov	r4,r2
8110be90:	1131cf80 	call	81131cf8 <OSMutexPost>
    }

    return bSuccess;
8110be94:	e0bffd17 	ldw	r2,-12(fp)
}
8110be98:	e037883a 	mov	sp,fp
8110be9c:	dfc00117 	ldw	ra,4(sp)
8110bea0:	df000017 	ldw	fp,0(sp)
8110bea4:	dec00204 	addi	sp,sp,8
8110bea8:	f800283a 	ret

8110beac <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
8110beac:	defffb04 	addi	sp,sp,-20
8110beb0:	de00012e 	bgeu	sp,et,8110beb8 <setPreAckReceiverFreePos+0xc>
8110beb4:	003b68fa 	trap	3
8110beb8:	dfc00415 	stw	ra,16(sp)
8110bebc:	df000315 	stw	fp,12(sp)
8110bec0:	df000304 	addi	fp,sp,12
8110bec4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110bec8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8110becc:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
8110bed0:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
8110bed4:	d0a05717 	ldw	r2,-32420(gp)
8110bed8:	e0fffe44 	addi	r3,fp,-7
8110bedc:	180d883a 	mov	r6,r3
8110bee0:	01400504 	movi	r5,20
8110bee4:	1009883a 	mov	r4,r2
8110bee8:	11317540 	call	81131754 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110beec:	e0bffe43 	ldbu	r2,-7(fp)
8110bef0:	10803fcc 	andi	r2,r2,255
8110bef4:	1000471e 	bne	r2,zero,8110c014 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8110bef8:	e03ffe05 	stb	zero,-8(fp)
8110befc:	00003e06 	br	8110bff8 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
8110bf00:	e0fffe03 	ldbu	r3,-8(fp)
8110bf04:	00a04574 	movhi	r2,33045
8110bf08:	1092e404 	addi	r2,r2,19344
8110bf0c:	18c7883a 	add	r3,r3,r3
8110bf10:	18c7883a 	add	r3,r3,r3
8110bf14:	10c5883a 	add	r2,r2,r3
8110bf18:	10800003 	ldbu	r2,0(r2)
8110bf1c:	10803fcc 	andi	r2,r2,255
8110bf20:	1080201c 	xori	r2,r2,128
8110bf24:	10bfe004 	addi	r2,r2,-128
8110bf28:	1000301e 	bne	r2,zero,8110bfec <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
8110bf2c:	e0fffe03 	ldbu	r3,-8(fp)
8110bf30:	e0bfff17 	ldw	r2,-4(fp)
8110bf34:	11000103 	ldbu	r4,4(r2)
8110bf38:	00a04574 	movhi	r2,33045
8110bf3c:	1092e404 	addi	r2,r2,19344
8110bf40:	18c7883a 	add	r3,r3,r3
8110bf44:	18c7883a 	add	r3,r3,r3
8110bf48:	10c5883a 	add	r2,r2,r3
8110bf4c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
8110bf50:	e0fffe03 	ldbu	r3,-8(fp)
8110bf54:	e0bfff17 	ldw	r2,-4(fp)
8110bf58:	11000143 	ldbu	r4,5(r2)
8110bf5c:	00a04574 	movhi	r2,33045
8110bf60:	1092e404 	addi	r2,r2,19344
8110bf64:	18c7883a 	add	r3,r3,r3
8110bf68:	18c7883a 	add	r3,r3,r3
8110bf6c:	10c5883a 	add	r2,r2,r3
8110bf70:	10800044 	addi	r2,r2,1
8110bf74:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
8110bf78:	e0fffe03 	ldbu	r3,-8(fp)
8110bf7c:	e0bfff17 	ldw	r2,-4(fp)
8110bf80:	1100020b 	ldhu	r4,8(r2)
8110bf84:	00a04574 	movhi	r2,33045
8110bf88:	1092e404 	addi	r2,r2,19344
8110bf8c:	18c7883a 	add	r3,r3,r3
8110bf90:	18c7883a 	add	r3,r3,r3
8110bf94:	10c5883a 	add	r2,r2,r3
8110bf98:	10800084 	addi	r2,r2,2
8110bf9c:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
8110bfa0:	d0a05817 	ldw	r2,-32416(gp)
8110bfa4:	1009883a 	mov	r4,r2
8110bfa8:	1133ae80 	call	81133ae8 <OSSemPost>
8110bfac:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
8110bfb0:	e0bffe43 	ldbu	r2,-7(fp)
8110bfb4:	10803fcc 	andi	r2,r2,255
8110bfb8:	1000031e 	bne	r2,zero,8110bfc8 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
8110bfbc:	00800044 	movi	r2,1
8110bfc0:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
8110bfc4:	00000f06 	br	8110c004 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
8110bfc8:	11112440 	call	81111244 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
8110bfcc:	e0fffe03 	ldbu	r3,-8(fp)
8110bfd0:	00a04574 	movhi	r2,33045
8110bfd4:	1092e404 	addi	r2,r2,19344
8110bfd8:	18c7883a 	add	r3,r3,r3
8110bfdc:	18c7883a 	add	r3,r3,r3
8110bfe0:	10c5883a 	add	r2,r2,r3
8110bfe4:	10000005 	stb	zero,0(r2)
                }
                break;
8110bfe8:	00000606 	br	8110c004 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8110bfec:	e0bffe03 	ldbu	r2,-8(fp)
8110bff0:	10800044 	addi	r2,r2,1
8110bff4:	e0bffe05 	stb	r2,-8(fp)
8110bff8:	e0bffe03 	ldbu	r2,-8(fp)
8110bffc:	108001b0 	cmpltui	r2,r2,6
8110c000:	103fbf1e 	bne	r2,zero,8110bf00 <__reset+0xfb0ebf00>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
8110c004:	d0a05717 	ldw	r2,-32420(gp)
8110c008:	1009883a 	mov	r4,r2
8110c00c:	1131cf80 	call	81131cf8 <OSMutexPost>
8110c010:	00000706 	br	8110c030 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
8110c014:	d0a05417 	ldw	r2,-32432(gp)
8110c018:	100f883a 	mov	r7,r2
8110c01c:	01801404 	movi	r6,80
8110c020:	01400044 	movi	r5,1
8110c024:	01204534 	movhi	r4,33044
8110c028:	2106b904 	addi	r4,r4,6884
8110c02c:	1115d200 	call	81115d20 <fwrite>
        #endif
    }

    return bSuccess;
8110c030:	e0bffd17 	ldw	r2,-12(fp)
}
8110c034:	e037883a 	mov	sp,fp
8110c038:	dfc00117 	ldw	ra,4(sp)
8110c03c:	df000017 	ldw	fp,0(sp)
8110c040:	dec00204 	addi	sp,sp,8
8110c044:	f800283a 	ret

8110c048 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
8110c048:	defff404 	addi	sp,sp,-48
8110c04c:	de00012e 	bgeu	sp,et,8110c054 <bPreParserV2+0xc>
8110c050:	003b68fa 	trap	3
8110c054:	dfc00b15 	stw	ra,44(sp)
8110c058:	df000a15 	stw	fp,40(sp)
8110c05c:	dc000915 	stw	r16,36(sp)
8110c060:	df000a04 	addi	fp,sp,40
8110c064:	e13ffd15 	stw	r4,-12(fp)
8110c068:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
8110c06c:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
8110c070:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
8110c074:	01402004 	movi	r5,128
8110c078:	e13ffd17 	ldw	r4,-12(fp)
8110c07c:	11172c00 	call	811172c0 <strnlen>
8110c080:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
8110c084:	01400ec4 	movi	r5,59
8110c088:	e13ffd17 	ldw	r4,-12(fp)
8110c08c:	110fcd00 	call	8110fcd0 <siPosStr>
8110c090:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
8110c094:	e0fff98f 	ldh	r3,-26(fp)
8110c098:	e0bff90f 	ldh	r2,-28(fp)
8110c09c:	10bfffc4 	addi	r2,r2,-1
8110c0a0:	18800226 	beq	r3,r2,8110c0ac <bPreParserV2+0x64>
        return bSuccess;
8110c0a4:	e0bff617 	ldw	r2,-40(fp)
8110c0a8:	0000ba06 	br	8110c394 <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
8110c0ac:	01401f04 	movi	r5,124
8110c0b0:	e13ffd17 	ldw	r4,-12(fp)
8110c0b4:	110fcd00 	call	8110fcd0 <siPosStr>
8110c0b8:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
8110c0bc:	e0bffa0f 	ldh	r2,-24(fp)
8110c0c0:	e0fff98f 	ldh	r3,-26(fp)
8110c0c4:	1880020e 	bge	r3,r2,8110c0d0 <bPreParserV2+0x88>
        return bSuccess;
8110c0c8:	e0bff617 	ldw	r2,-40(fp)
8110c0cc:	0000b106 	br	8110c394 <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
8110c0d0:	01604534 	movhi	r5,33044
8110c0d4:	2946ce04 	addi	r5,r5,6968
8110c0d8:	e13ffd17 	ldw	r4,-12(fp)
8110c0dc:	11171dc0 	call	811171dc <strcspn>
8110c0e0:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
8110c0e4:	e0bffa8f 	ldh	r2,-22(fp)
8110c0e8:	e0fffa0f 	ldh	r3,-24(fp)
8110c0ec:	1880020e 	bge	r3,r2,8110c0f8 <bPreParserV2+0xb0>
        return bSuccess;
8110c0f0:	e0bff617 	ldw	r2,-40(fp)
8110c0f4:	0000a706 	br	8110c394 <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
8110c0f8:	e0bffa8f 	ldh	r2,-22(fp)
8110c0fc:	e0fffd17 	ldw	r3,-12(fp)
8110c100:	1885883a 	add	r2,r3,r2
8110c104:	10c00003 	ldbu	r3,0(r2)
8110c108:	e0bffe17 	ldw	r2,-8(fp)
8110c10c:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
8110c110:	e0bffe17 	ldw	r2,-8(fp)
8110c114:	10800103 	ldbu	r2,4(r2)
8110c118:	10803fcc 	andi	r2,r2,255
8110c11c:	1080201c 	xori	r2,r2,128
8110c120:	10bfe004 	addi	r2,r2,-128
8110c124:	108008d8 	cmpnei	r2,r2,35
8110c128:	1000041e 	bne	r2,zero,8110c13c <bPreParserV2+0xf4>
        bSuccess = TRUE;
8110c12c:	00800044 	movi	r2,1
8110c130:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
8110c134:	e0bff617 	ldw	r2,-40(fp)
8110c138:	00009606 	br	8110c394 <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
8110c13c:	e0bffa8f 	ldh	r2,-22(fp)
8110c140:	e0fffd17 	ldw	r3,-12(fp)
8110c144:	1889883a 	add	r4,r3,r2
8110c148:	e0fffa0f 	ldh	r3,-24(fp)
8110c14c:	e0bffa8f 	ldh	r2,-22(fp)
8110c150:	1885c83a 	sub	r2,r3,r2
8110c154:	100b883a 	mov	r5,r2
8110c158:	1110ef00 	call	81110ef0 <ucCrc8wInit>
8110c15c:	1007883a 	mov	r3,r2
8110c160:	e0bffe17 	ldw	r2,-8(fp)
8110c164:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
8110c168:	e0bffa8f 	ldh	r2,-22(fp)
8110c16c:	10800044 	addi	r2,r2,1
8110c170:	e0fffd17 	ldw	r3,-12(fp)
8110c174:	1885883a 	add	r2,r3,r2
8110c178:	10c00003 	ldbu	r3,0(r2)
8110c17c:	e0bffe17 	ldw	r2,-8(fp)
8110c180:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
8110c184:	e0bffe17 	ldw	r2,-8(fp)
8110c188:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
8110c18c:	e0bffe17 	ldw	r2,-8(fp)
8110c190:	10800204 	addi	r2,r2,8
8110c194:	01801004 	movi	r6,64
8110c198:	000b883a 	mov	r5,zero
8110c19c:	1009883a 	mov	r4,r2
8110c1a0:	11168840 	call	81116884 <memset>

    i = siIni + 3; /* "?C:i..." */
8110c1a4:	e0bffa8b 	ldhu	r2,-22(fp)
8110c1a8:	108000c4 	addi	r2,r2,3
8110c1ac:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
8110c1b0:	e0bffb44 	addi	r2,fp,-19
8110c1b4:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
8110c1b8:	e0bffb44 	addi	r2,fp,-19
8110c1bc:	01800184 	movi	r6,6
8110c1c0:	000b883a 	mov	r5,zero
8110c1c4:	1009883a 	mov	r4,r2
8110c1c8:	11168840 	call	81116884 <memset>
        do {
            c = buffer[i];
8110c1cc:	e0bff703 	ldbu	r2,-36(fp)
8110c1d0:	e0fffd17 	ldw	r3,-12(fp)
8110c1d4:	1885883a 	add	r2,r3,r2
8110c1d8:	10800003 	ldbu	r2,0(r2)
8110c1dc:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
8110c1e0:	d0e00317 	ldw	r3,-32756(gp)
8110c1e4:	e0bffb07 	ldb	r2,-20(fp)
8110c1e8:	10800044 	addi	r2,r2,1
8110c1ec:	1885883a 	add	r2,r3,r2
8110c1f0:	10800003 	ldbu	r2,0(r2)
8110c1f4:	10803fcc 	andi	r2,r2,255
8110c1f8:	1080010c 	andi	r2,r2,4
8110c1fc:	10000626 	beq	r2,zero,8110c218 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
8110c200:	e0bff817 	ldw	r2,-32(fp)
8110c204:	e0fffb03 	ldbu	r3,-20(fp)
8110c208:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
8110c20c:	e0bff817 	ldw	r2,-32(fp)
8110c210:	10800044 	addi	r2,r2,1
8110c214:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
8110c218:	e0bff703 	ldbu	r2,-36(fp)
8110c21c:	10800044 	addi	r2,r2,1
8110c220:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
8110c224:	e0bff90f 	ldh	r2,-28(fp)
8110c228:	e0fff703 	ldbu	r3,-36(fp)
8110c22c:	1880090e 	bge	r3,r2,8110c254 <bPreParserV2+0x20c>
8110c230:	e0bffb07 	ldb	r2,-20(fp)
8110c234:	10800ea0 	cmpeqi	r2,r2,58
8110c238:	1000061e 	bne	r2,zero,8110c254 <bPreParserV2+0x20c>
8110c23c:	e0bffb07 	ldb	r2,-20(fp)
8110c240:	10800ee0 	cmpeqi	r2,r2,59
8110c244:	1000031e 	bne	r2,zero,8110c254 <bPreParserV2+0x20c>
8110c248:	e0bffb07 	ldb	r2,-20(fp)
8110c24c:	10801f18 	cmpnei	r2,r2,124
8110c250:	103fde1e 	bne	r2,zero,8110c1cc <__reset+0xfb0ec1cc>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110c254:	e0bff817 	ldw	r2,-32(fp)
8110c258:	00c00284 	movi	r3,10
8110c25c:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
8110c260:	e0bffb07 	ldb	r2,-20(fp)
8110c264:	10800ea0 	cmpeqi	r2,r2,58
8110c268:	1000031e 	bne	r2,zero,8110c278 <bPreParserV2+0x230>
8110c26c:	e0bffb07 	ldb	r2,-20(fp)
8110c270:	10801f18 	cmpnei	r2,r2,124
8110c274:	10001a1e 	bne	r2,zero,8110c2e0 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
8110c278:	e0bffe17 	ldw	r2,-8(fp)
8110c27c:	10800183 	ldbu	r2,6(r2)
8110c280:	10803fcc 	andi	r2,r2,255
8110c284:	10800828 	cmpgeui	r2,r2,32
8110c288:	1000041e 	bne	r2,zero,8110c29c <bPreParserV2+0x254>
8110c28c:	e0bffe17 	ldw	r2,-8(fp)
8110c290:	10800183 	ldbu	r2,6(r2)
8110c294:	14003fcc 	andi	r16,r2,255
8110c298:	00000106 	br	8110c2a0 <bPreParserV2+0x258>
8110c29c:	04000804 	movi	r16,32
8110c2a0:	e0bffb44 	addi	r2,fp,-19
8110c2a4:	1009883a 	mov	r4,r2
8110c2a8:	11155280 	call	81115528 <atoi>
8110c2ac:	1009883a 	mov	r4,r2
8110c2b0:	e0fffe17 	ldw	r3,-8(fp)
8110c2b4:	80800104 	addi	r2,r16,4
8110c2b8:	1085883a 	add	r2,r2,r2
8110c2bc:	1885883a 	add	r2,r3,r2
8110c2c0:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
8110c2c4:	e0bffe17 	ldw	r2,-8(fp)
8110c2c8:	10800183 	ldbu	r2,6(r2)
8110c2cc:	10800044 	addi	r2,r2,1
8110c2d0:	1007883a 	mov	r3,r2
8110c2d4:	e0bffe17 	ldw	r2,-8(fp)
8110c2d8:	10c00185 	stb	r3,6(r2)
8110c2dc:	00000906 	br	8110c304 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
8110c2e0:	e0bffb07 	ldb	r2,-20(fp)
8110c2e4:	10800ed8 	cmpnei	r2,r2,59
8110c2e8:	1000061e 	bne	r2,zero,8110c304 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
8110c2ec:	e0bffb44 	addi	r2,fp,-19
8110c2f0:	1009883a 	mov	r4,r2
8110c2f4:	11155280 	call	81115528 <atoi>
8110c2f8:	1007883a 	mov	r3,r2
8110c2fc:	e0bffe17 	ldw	r2,-8(fp)
8110c300:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
8110c304:	e0bffb07 	ldb	r2,-20(fp)
8110c308:	10800ee0 	cmpeqi	r2,r2,59
8110c30c:	1000031e 	bne	r2,zero,8110c31c <bPreParserV2+0x2d4>
8110c310:	e0bff90f 	ldh	r2,-28(fp)
8110c314:	e0fff703 	ldbu	r3,-36(fp)
8110c318:	18bfa516 	blt	r3,r2,8110c1b0 <__reset+0xfb0ec1b0>


    if ( c == FINAL_CHAR )
8110c31c:	e0bffb07 	ldb	r2,-20(fp)
8110c320:	10800ed8 	cmpnei	r2,r2,59
8110c324:	1000191e 	bne	r2,zero,8110c38c <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
8110c328:	e0bffe17 	ldw	r2,-8(fp)
8110c32c:	10c01243 	ldbu	r3,73(r2)
8110c330:	e0bffe17 	ldw	r2,-8(fp)
8110c334:	10801203 	ldbu	r2,72(r2)
8110c338:	18c03fcc 	andi	r3,r3,255
8110c33c:	10803fcc 	andi	r2,r2,255
8110c340:	1880031e 	bne	r3,r2,8110c350 <bPreParserV2+0x308>
            bSuccess = TRUE;
8110c344:	00800044 	movi	r2,1
8110c348:	e0bff615 	stw	r2,-40(fp)
8110c34c:	00001006 	br	8110c390 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
8110c350:	d0e05417 	ldw	r3,-32432(gp)
8110c354:	e0bffe17 	ldw	r2,-8(fp)
8110c358:	10801203 	ldbu	r2,72(r2)
8110c35c:	11003fcc 	andi	r4,r2,255
8110c360:	e0bffe17 	ldw	r2,-8(fp)
8110c364:	10801243 	ldbu	r2,73(r2)
8110c368:	10803fcc 	andi	r2,r2,255
8110c36c:	100f883a 	mov	r7,r2
8110c370:	200d883a 	mov	r6,r4
8110c374:	01604534 	movhi	r5,33044
8110c378:	2946d004 	addi	r5,r5,6976
8110c37c:	1809883a 	mov	r4,r3
8110c380:	11156840 	call	81115684 <fprintf>
            #endif
            bSuccess = FALSE;
8110c384:	e03ff615 	stw	zero,-40(fp)
8110c388:	00000106 	br	8110c390 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
8110c38c:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
8110c390:	e0bff617 	ldw	r2,-40(fp)
}
8110c394:	e6ffff04 	addi	sp,fp,-4
8110c398:	dfc00217 	ldw	ra,8(sp)
8110c39c:	df000117 	ldw	fp,4(sp)
8110c3a0:	dc000017 	ldw	r16,0(sp)
8110c3a4:	dec00304 	addi	sp,sp,12
8110c3a8:	f800283a 	ret

8110c3ac <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
8110c3ac:	defffb04 	addi	sp,sp,-20
8110c3b0:	de00012e 	bgeu	sp,et,8110c3b8 <vSenderComTask+0xc>
8110c3b4:	003b68fa 	trap	3
8110c3b8:	dfc00415 	stw	ra,16(sp)
8110c3bc:	df000315 	stw	fp,12(sp)
8110c3c0:	df000304 	addi	fp,sp,12
8110c3c4:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
8110c3c8:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
8110c3cc:	d0a05417 	ldw	r2,-32432(gp)
8110c3d0:	100f883a 	mov	r7,r2
8110c3d4:	01800704 	movi	r6,28
8110c3d8:	01400044 	movi	r5,1
8110c3dc:	01204534 	movhi	r4,33044
8110c3e0:	2106dc04 	addi	r4,r4,7024
8110c3e4:	1115d200 	call	81115d20 <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
8110c3e8:	e0bffd17 	ldw	r2,-12(fp)
8110c3ec:	10c00060 	cmpeqi	r3,r2,1
8110c3f0:	1800091e 	bne	r3,zero,8110c418 <vSenderComTask+0x6c>
8110c3f4:	0080052e 	bgeu	zero,r2,8110c40c <vSenderComTask+0x60>
8110c3f8:	10c000a0 	cmpeqi	r3,r2,2
8110c3fc:	1800471e 	bne	r3,zero,8110c51c <vSenderComTask+0x170>
8110c400:	10800160 	cmpeqi	r2,r2,5
8110c404:	10002c1e 	bne	r2,zero,8110c4b8 <vSenderComTask+0x10c>
8110c408:	00003a06 	br	8110c4f4 <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
8110c40c:	00800044 	movi	r2,1
8110c410:	e0bffd15 	stw	r2,-12(fp)
                break;
8110c414:	00004206 	br	8110c520 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
8110c418:	d0a05417 	ldw	r2,-32432(gp)
8110c41c:	100f883a 	mov	r7,r2
8110c420:	01800784 	movi	r6,30
8110c424:	01400044 	movi	r5,1
8110c428:	01204534 	movhi	r4,33044
8110c42c:	2106e404 	addi	r4,r4,7056
8110c430:	1115d200 	call	81115d20 <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
8110c434:	01400044 	movi	r5,1
8110c438:	01204534 	movhi	r4,33044
8110c43c:	2106ec04 	addi	r4,r4,7088
8110c440:	110f3c80 	call	8110f3c8 <bSendUART32v2>
8110c444:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
8110c448:	e0bffe17 	ldw	r2,-8(fp)
8110c44c:	10800058 	cmpnei	r2,r2,1
8110c450:	10000a1e 	bne	r2,zero,8110c47c <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
8110c454:	00800144 	movi	r2,5
8110c458:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
8110c45c:	d0a05417 	ldw	r2,-32432(gp)
8110c460:	100f883a 	mov	r7,r2
8110c464:	01800d44 	movi	r6,53
8110c468:	01400044 	movi	r5,1
8110c46c:	01204534 	movhi	r4,33044
8110c470:	2106ef04 	addi	r4,r4,7100
8110c474:	1115d200 	call	81115d20 <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
8110c478:	00002906 	br	8110c520 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
8110c47c:	d0a05417 	ldw	r2,-32432(gp)
8110c480:	100f883a 	mov	r7,r2
8110c484:	01800784 	movi	r6,30
8110c488:	01400044 	movi	r5,1
8110c48c:	01204534 	movhi	r4,33044
8110c490:	2106fd04 	addi	r4,r4,7156
8110c494:	1115d200 	call	81115d20 <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
8110c498:	00800044 	movi	r2,1
8110c49c:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
8110c4a0:	000f883a 	mov	r7,zero
8110c4a4:	01800144 	movi	r6,5
8110c4a8:	000b883a 	mov	r5,zero
8110c4ac:	0009883a 	mov	r4,zero
8110c4b0:	11355440 	call	81135544 <OSTimeDlyHMSM>
                }
                break;
8110c4b4:	00001a06 	br	8110c520 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
8110c4b8:	00800144 	movi	r2,5
8110c4bc:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"sDummySender\n");
8110c4c0:	d0a05417 	ldw	r2,-32432(gp)
8110c4c4:	100f883a 	mov	r7,r2
8110c4c8:	01800344 	movi	r6,13
8110c4cc:	01400044 	movi	r5,1
8110c4d0:	01204534 	movhi	r4,33044
8110c4d4:	21070504 	addi	r4,r4,7188
8110c4d8:	1115d200 	call	81115d20 <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 10, 0); /*Sleeps for 3 second*/
8110c4dc:	000f883a 	mov	r7,zero
8110c4e0:	01800284 	movi	r6,10
8110c4e4:	000b883a 	mov	r5,zero
8110c4e8:	0009883a 	mov	r4,zero
8110c4ec:	11355440 	call	81135544 <OSTimeDlyHMSM>

                break;
8110c4f0:	00000b06 	br	8110c520 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
8110c4f4:	d0a05417 	ldw	r2,-32432(gp)
8110c4f8:	100f883a 	mov	r7,r2
8110c4fc:	018003c4 	movi	r6,15
8110c500:	01400044 	movi	r5,1
8110c504:	01204534 	movhi	r4,33044
8110c508:	21070904 	addi	r4,r4,7204
8110c50c:	1115d200 	call	81115d20 <fwrite>
                #endif
                eSenderMode = sDummySender;
8110c510:	00800144 	movi	r2,5
8110c514:	e0bffd15 	stw	r2,-12(fp)
                break;
8110c518:	00000106 	br	8110c520 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
8110c51c:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
8110c520:	003fb106 	br	8110c3e8 <__reset+0xfb0ec3e8>

8110c524 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
8110c524:	defffa04 	addi	sp,sp,-24
8110c528:	de00012e 	bgeu	sp,et,8110c530 <vSimMebTask+0xc>
8110c52c:	003b68fa 	trap	3
8110c530:	dfc00515 	stw	ra,20(sp)
8110c534:	df000415 	stw	fp,16(sp)
8110c538:	df000404 	addi	fp,sp,16
8110c53c:	e13fff15 	stw	r4,-4(fp)
	TSimucam_MEB *pxMebC;
	tQMask uiCmdMeb;
	INT8U error_code;

	pxMebC = (TSimucam_MEB *) task_data;
8110c540:	e0bfff17 	ldw	r2,-4(fp)
8110c544:	e0bffc15 	stw	r2,-16(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
8110c548:	d0a05417 	ldw	r2,-32432(gp)
8110c54c:	100f883a 	mov	r7,r2
8110c550:	018008c4 	movi	r6,35
8110c554:	01400044 	movi	r5,1
8110c558:	01204534 	movhi	r4,33044
8110c55c:	21070d04 	addi	r4,r4,7220
8110c560:	1115d200 	call	81115d20 <fwrite>
    #endif

	for (;;) {
		switch ( pxMebC->eMode )
8110c564:	e0bffc17 	ldw	r2,-16(fp)
8110c568:	10800117 	ldw	r2,4(r2)
8110c56c:	10000326 	beq	r2,zero,8110c57c <vSimMebTask+0x58>
8110c570:	10800060 	cmpeqi	r2,r2,1
8110c574:	1000231e 	bne	r2,zero,8110c604 <vSimMebTask+0xe0>
8110c578:	00004406 	br	8110c68c <vSimMebTask+0x168>
		{
			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
8110c57c:	d0a05b17 	ldw	r2,-32404(gp)
8110c580:	e0fffe04 	addi	r3,fp,-8
8110c584:	180d883a 	mov	r6,r3
8110c588:	000b883a 	mov	r5,zero
8110c58c:	1009883a 	mov	r4,r2
8110c590:	11328680 	call	81132868 <OSQPend>
8110c594:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8110c598:	e0bffe03 	ldbu	r2,-8(fp)
8110c59c:	10803fcc 	andi	r2,r2,255
8110c5a0:	1000151e 	bne	r2,zero,8110c5f8 <vSimMebTask+0xd4>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
8110c5a4:	e0bffdc3 	ldbu	r2,-9(fp)
8110c5a8:	10803fcc 	andi	r2,r2,255
8110c5ac:	10800058 	cmpnei	r2,r2,1
8110c5b0:	1000081e 	bne	r2,zero,8110c5d4 <vSimMebTask+0xb0>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
8110c5b4:	e0bffd83 	ldbu	r2,-10(fp)
8110c5b8:	10803fcc 	andi	r2,r2,255
8110c5bc:	10800060 	cmpeqi	r2,r2,1
8110c5c0:	1000011e 	bne	r2,zero,8110c5c8 <vSimMebTask+0xa4>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskConfigMode( pxMebC );
								break;
							default:
								break;
8110c5c4:	00000e06 	br	8110c600 <vSimMebTask+0xdc>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskConfigMode( pxMebC );
8110c5c8:	e13ffc17 	ldw	r4,-16(fp)
8110c5cc:	110c6b80 	call	8110c6b8 <vPusMebInTaskConfigMode>
								break;
8110c5d0:	00000b06 	br	8110c600 <vSimMebTask+0xdc>
							default:
								break;
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored. Not Addressed to Meb. ADDR= %ui\n", uiCmdMeb.ucByte[3]);
8110c5d4:	d0a05417 	ldw	r2,-32432(gp)
8110c5d8:	e0fffdc3 	ldbu	r3,-9(fp)
8110c5dc:	18c03fcc 	andi	r3,r3,255
8110c5e0:	180d883a 	mov	r6,r3
8110c5e4:	01604534 	movhi	r5,33044
8110c5e8:	29471604 	addi	r5,r5,7256
8110c5ec:	1009883a 	mov	r4,r2
8110c5f0:	11156840 	call	81115684 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
8110c5f4:	00002f06 	br	8110c6b4 <vSimMebTask+0x190>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
8110c5f8:	111286c0 	call	8111286c <vCouldNotGetCmdQueueMeb>
				}

				break;
8110c5fc:	00002d06 	br	8110c6b4 <vSimMebTask+0x190>
8110c600:	00002c06 	br	8110c6b4 <vSimMebTask+0x190>
			case sRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
8110c604:	d0a05b17 	ldw	r2,-32404(gp)
8110c608:	e0fffe04 	addi	r3,fp,-8
8110c60c:	180d883a 	mov	r6,r3
8110c610:	000b883a 	mov	r5,zero
8110c614:	1009883a 	mov	r4,r2
8110c618:	11328680 	call	81132868 <OSQPend>
8110c61c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8110c620:	e0bffe03 	ldbu	r2,-8(fp)
8110c624:	10803fcc 	andi	r2,r2,255
8110c628:	1000151e 	bne	r2,zero,8110c680 <vSimMebTask+0x15c>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
8110c62c:	e0bffdc3 	ldbu	r2,-9(fp)
8110c630:	10803fcc 	andi	r2,r2,255
8110c634:	10800058 	cmpnei	r2,r2,1
8110c638:	1000081e 	bne	r2,zero,8110c65c <vSimMebTask+0x138>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
8110c63c:	e0bffd83 	ldbu	r2,-10(fp)
8110c640:	10803fcc 	andi	r2,r2,255
8110c644:	10800060 	cmpeqi	r2,r2,1
8110c648:	1000011e 	bne	r2,zero,8110c650 <vSimMebTask+0x12c>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskRunningMode( pxMebC );
								break;
							default:
								break;
8110c64c:	00000e06 	br	8110c688 <vSimMebTask+0x164>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskRunningMode( pxMebC );
8110c650:	e13ffc17 	ldw	r4,-16(fp)
8110c654:	110cbb40 	call	8110cbb4 <vPusMebInTaskRunningMode>
								break;
8110c658:	00000b06 	br	8110c688 <vSimMebTask+0x164>
							default:
								break;
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored. Not Addressed to Meb. ADDR= %ui\n", uiCmdMeb.ucByte[3]);
8110c65c:	d0a05417 	ldw	r2,-32432(gp)
8110c660:	e0fffdc3 	ldbu	r3,-9(fp)
8110c664:	18c03fcc 	andi	r3,r3,255
8110c668:	180d883a 	mov	r6,r3
8110c66c:	01604534 	movhi	r5,33044
8110c670:	29471604 	addi	r5,r5,7256
8110c674:	1009883a 	mov	r4,r2
8110c678:	11156840 	call	81115684 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			

				break;
8110c67c:	00000d06 	br	8110c6b4 <vSimMebTask+0x190>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
8110c680:	111286c0 	call	8111286c <vCouldNotGetCmdQueueMeb>
				}			

				break;
8110c684:	00000b06 	br	8110c6b4 <vSimMebTask+0x190>
8110c688:	00000a06 	br	8110c6b4 <vSimMebTask+0x190>
			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode.\n");
8110c68c:	d0a05417 	ldw	r2,-32432(gp)
8110c690:	100f883a 	mov	r7,r2
8110c694:	01800c04 	movi	r6,48
8110c698:	01400044 	movi	r5,1
8110c69c:	01204534 	movhi	r4,33044
8110c6a0:	21072504 	addi	r4,r4,7316
8110c6a4:	1115d200 	call	81115d20 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudança de esteado aqui */
				pxMebC->eMode = sMebConfig;
8110c6a8:	e0bffc17 	ldw	r2,-16(fp)
8110c6ac:	10000115 	stw	zero,4(r2)
				break;
8110c6b0:	0001883a 	nop
		}
	}
8110c6b4:	003fab06 	br	8110c564 <__reset+0xfb0ec564>

8110c6b8 <vPusMebInTaskConfigMode>:
}

/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal ) {
8110c6b8:	defff904 	addi	sp,sp,-28
8110c6bc:	de00012e 	bgeu	sp,et,8110c6c4 <vPusMebInTaskConfigMode+0xc>
8110c6c0:	003b68fa 	trap	3
8110c6c4:	dfc00615 	stw	ra,24(sp)
8110c6c8:	df000515 	stw	fp,20(sp)
8110c6cc:	df000504 	addi	fp,sp,20
8110c6d0:	e13fff15 	stw	r4,-4(fp)
	unsigned char i;
	unsigned short int usiFeeInstL;
	static tTMPus xPusLocal;
	bool bSuccess = FALSE;
8110c6d4:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;

	bSuccess = FALSE;
8110c6d8:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 1, &error_code);
8110c6dc:	d0a06317 	ldw	r2,-32372(gp)
8110c6e0:	e0fffe84 	addi	r3,fp,-6
8110c6e4:	180d883a 	mov	r6,r3
8110c6e8:	01400044 	movi	r5,1
8110c6ec:	1009883a 	mov	r4,r2
8110c6f0:	11317540 	call	81131754 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
8110c6f4:	e0bffe83 	ldbu	r2,-6(fp)
8110c6f8:	10803fcc 	andi	r2,r2,255
8110c6fc:	10002c1e 	bne	r2,zero,8110c7b0 <vPusMebInTaskConfigMode+0xf8>

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
8110c700:	e03ffc05 	stb	zero,-16(fp)
8110c704:	00002306 	br	8110c794 <vPusMebInTaskConfigMode+0xdc>
	    {
            if ( xPus[i].bInUse == TRUE ) {
8110c708:	e0fffc03 	ldbu	r3,-16(fp)
8110c70c:	00a04574 	movhi	r2,33045
8110c710:	10a5d704 	addi	r2,r2,-26788
8110c714:	18c01524 	muli	r3,r3,84
8110c718:	10c5883a 	add	r2,r2,r3
8110c71c:	10800104 	addi	r2,r2,4
8110c720:	10800017 	ldw	r2,0(r2)
8110c724:	10800058 	cmpnei	r2,r2,1
8110c728:	1000171e 	bne	r2,zero,8110c788 <vPusMebInTaskConfigMode+0xd0>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[i];
8110c72c:	e13ffc03 	ldbu	r4,-16(fp)
8110c730:	00e04534 	movhi	r3,33044
8110c734:	18dbcb04 	addi	r3,r3,28460
8110c738:	00a04574 	movhi	r2,33045
8110c73c:	10a5d704 	addi	r2,r2,-26788
8110c740:	21001524 	muli	r4,r4,84
8110c744:	1105883a 	add	r2,r2,r4
8110c748:	1009883a 	mov	r4,r2
8110c74c:	00801504 	movi	r2,84
8110c750:	100d883a 	mov	r6,r2
8110c754:	200b883a 	mov	r5,r4
8110c758:	1809883a 	mov	r4,r3
8110c75c:	11167340 	call	81116734 <memcpy>
            	xPus[i].bInUse = FALSE;
8110c760:	e0fffc03 	ldbu	r3,-16(fp)
8110c764:	00a04574 	movhi	r2,33045
8110c768:	10a5d704 	addi	r2,r2,-26788
8110c76c:	18c01524 	muli	r3,r3,84
8110c770:	10c5883a 	add	r2,r2,r3
8110c774:	10800104 	addi	r2,r2,4
8110c778:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
8110c77c:	00800044 	movi	r2,1
8110c780:	e0bffd15 	stw	r2,-12(fp)
                break;
8110c784:	00000606 	br	8110c7a0 <vPusMebInTaskConfigMode+0xe8>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 1, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
8110c788:	e0bffc03 	ldbu	r2,-16(fp)
8110c78c:	10800044 	addi	r2,r2,1
8110c790:	e0bffc05 	stb	r2,-16(fp)
8110c794:	e0bffc03 	ldbu	r2,-16(fp)
8110c798:	10800130 	cmpltui	r2,r2,4
8110c79c:	103fda1e 	bne	r2,zero,8110c708 <__reset+0xfb0ec708>
            	xPus[i].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
8110c7a0:	d0a06317 	ldw	r2,-32372(gp)
8110c7a4:	1009883a 	mov	r4,r2
8110c7a8:	1131cf80 	call	81131cf8 <OSMutexPost>
8110c7ac:	00000106 	br	8110c7b4 <vPusMebInTaskConfigMode+0xfc>
	} else {
		vCouldNotGetMutexMebPus();
8110c7b0:	11128d40 	call	811128d4 <vCouldNotGetMutexMebPus>
	}

	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {
8110c7b4:	e0bffd17 	ldw	r2,-12(fp)
8110c7b8:	10800058 	cmpnei	r2,r2,1
8110c7bc:	1000f71e 	bne	r2,zero,8110cb9c <vPusMebInTaskConfigMode+0x4e4>

		switch (xPusLocal.usiType) {
8110c7c0:	00a04534 	movhi	r2,33044
8110c7c4:	109bcb04 	addi	r2,r2,28460
8110c7c8:	1080030b 	ldhu	r2,12(r2)
8110c7cc:	10bfffcc 	andi	r2,r2,65535
8110c7d0:	10c03ee0 	cmpeqi	r3,r2,251
8110c7d4:	1800491e 	bne	r3,zero,8110c8fc <vPusMebInTaskConfigMode+0x244>
8110c7d8:	10c03f20 	cmpeqi	r3,r2,252
8110c7dc:	1800891e 	bne	r3,zero,8110ca04 <vPusMebInTaskConfigMode+0x34c>
8110c7e0:	10803ea0 	cmpeqi	r2,r2,250
8110c7e4:	1000011e 	bne	r2,zero,8110c7ec <vPusMebInTaskConfigMode+0x134>

						break;
				}
				break;
			default:
				break;
8110c7e8:	0000ec06 	br	8110cb9c <vPusMebInTaskConfigMode+0x4e4>
	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {

		switch (xPusLocal.usiType) {
			case 250: /* srv-Type = 250 */
				switch ( xPusLocal.usiSubType )
8110c7ec:	00a04534 	movhi	r2,33044
8110c7f0:	109bcb04 	addi	r2,r2,28460
8110c7f4:	1080038b 	ldhu	r2,14(r2)
8110c7f8:	10bfffcc 	andi	r2,r2,65535
8110c7fc:	10c00f60 	cmpeqi	r3,r2,61
8110c800:	18000c1e 	bne	r3,zero,8110c834 <vPusMebInTaskConfigMode+0x17c>
8110c804:	10c00fa0 	cmpeqi	r3,r2,62
8110c808:	18001e1e 	bne	r3,zero,8110c884 <vPusMebInTaskConfigMode+0x1cc>
8110c80c:	10800f20 	cmpeqi	r2,r2,60
8110c810:	10002426 	beq	r2,zero,8110c8a4 <vPusMebInTaskConfigMode+0x1ec>
				{
					case 60: /* TC_SCAM_CONFIG */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: MEB already in the Config Mode\n");
8110c814:	d0a05417 	ldw	r2,-32432(gp)
8110c818:	100f883a 	mov	r7,r2
8110c81c:	01800a44 	movi	r6,41
8110c820:	01400044 	movi	r5,1
8110c824:	01204534 	movhi	r4,33044
8110c828:	21073204 	addi	r4,r4,7368
8110c82c:	1115d200 	call	81115d20 <fwrite>
						#endif
						break;
8110c830:	00003106 	br	8110c8f8 <vPusMebInTaskConfigMode+0x240>


					case 61: /* TC_SCAM_RUN */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: Changing to RUN Mode\n");
8110c834:	d0a05417 	ldw	r2,-32432(gp)
8110c838:	100f883a 	mov	r7,r2
8110c83c:	018007c4 	movi	r6,31
8110c840:	01400044 	movi	r5,1
8110c844:	01204534 	movhi	r4,33044
8110c848:	21073d04 	addi	r4,r4,7412
8110c84c:	1115d200 	call	81115d20 <fwrite>
						#endif

							vEvtChangeMebMode(pxMebCLocal->eMode, sRun);
8110c850:	e0bfff17 	ldw	r2,-4(fp)
8110c854:	10800117 	ldw	r2,4(r2)
8110c858:	01400044 	movi	r5,1
8110c85c:	1009883a 	mov	r4,r2
8110c860:	1112bac0 	call	81112bac <vEvtChangeMebMode>
							pxMebCLocal->eMode = sRun;
8110c864:	e0bfff17 	ldw	r2,-4(fp)
8110c868:	00c00044 	movi	r3,1
8110c86c:	10c00115 	stw	r3,4(r2)

							vSendCmdQToNFeeCTRL( M_NFC_RUN, 0, 0 );
8110c870:	000d883a 	mov	r6,zero
8110c874:	000b883a 	mov	r5,zero
8110c878:	01000084 	movi	r4,2
8110c87c:	110d1040 	call	8110d104 <vSendCmdQToNFeeCTRL>
						break;
8110c880:	00001d06 	br	8110c8f8 <vPusMebInTaskConfigMode+0x240>
					case 62: /* TC_SCAM_TURNOFF */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: Turnning OFF \n");
8110c884:	d0a05417 	ldw	r2,-32432(gp)
8110c888:	100f883a 	mov	r7,r2
8110c88c:	01800604 	movi	r6,24
8110c890:	01400044 	movi	r5,1
8110c894:	01204534 	movhi	r4,33044
8110c898:	21074504 	addi	r4,r4,7444
8110c89c:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* todo:Enviar emnsagens para a meb, e a meb distribui a mensagem */
						/* todo:Enviar Sinalizar Led quando puder desligar */

						break;
8110c8a0:	00001506 	br	8110c8f8 <vPusMebInTaskConfigMode+0x240>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110c8a4:	d0e05417 	ldw	r3,-32432(gp)
8110c8a8:	00a04534 	movhi	r2,33044
8110c8ac:	109bcb04 	addi	r2,r2,28460
8110c8b0:	1080030b 	ldhu	r2,12(r2)
8110c8b4:	113fffcc 	andi	r4,r2,65535
8110c8b8:	00a04534 	movhi	r2,33044
8110c8bc:	109bcb04 	addi	r2,r2,28460
8110c8c0:	1080038b 	ldhu	r2,14(r2)
8110c8c4:	117fffcc 	andi	r5,r2,65535
8110c8c8:	00a04534 	movhi	r2,33044
8110c8cc:	109bcb04 	addi	r2,r2,28460
8110c8d0:	1080040b 	ldhu	r2,16(r2)
8110c8d4:	10bfffcc 	andi	r2,r2,65535
8110c8d8:	d8800015 	stw	r2,0(sp)
8110c8dc:	280f883a 	mov	r7,r5
8110c8e0:	200d883a 	mov	r6,r4
8110c8e4:	01604534 	movhi	r5,33044
8110c8e8:	29474c04 	addi	r5,r5,7472
8110c8ec:	1809883a 	mov	r4,r3
8110c8f0:	11156840 	call	81115684 <fprintf>
						#endif
						break;
8110c8f4:	0001883a 	nop
				}
				break;
8110c8f8:	0000a806 	br	8110cb9c <vPusMebInTaskConfigMode+0x4e4>
			case 251: /* srv-Type = 251 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
8110c8fc:	00a04534 	movhi	r2,33044
8110c900:	109bcb04 	addi	r2,r2,28460
8110c904:	1080050b 	ldhu	r2,20(r2)
8110c908:	e0bffe0d 	sth	r2,-8(fp)

				switch ( xPusLocal.usiSubType )
8110c90c:	00a04534 	movhi	r2,33044
8110c910:	109bcb04 	addi	r2,r2,28460
8110c914:	1080038b 	ldhu	r2,14(r2)
8110c918:	10bfffcc 	andi	r2,r2,65535
8110c91c:	10c000a0 	cmpeqi	r3,r2,2
8110c920:	1800131e 	bne	r3,zero,8110c970 <vPusMebInTaskConfigMode+0x2b8>
8110c924:	10c00160 	cmpeqi	r3,r2,5
8110c928:	1800111e 	bne	r3,zero,8110c970 <vPusMebInTaskConfigMode+0x2b8>
8110c92c:	10800060 	cmpeqi	r2,r2,1
8110c930:	10001e26 	beq	r2,zero,8110c9ac <vPusMebInTaskConfigMode+0x2f4>
				{
					case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110c934:	d0a05417 	ldw	r2,-32432(gp)
8110c938:	e0fffe0b 	ldhu	r3,-8(fp)
8110c93c:	180d883a 	mov	r6,r3
8110c940:	01604534 	movhi	r5,33044
8110c944:	29476004 	addi	r5,r5,7552
8110c948:	1009883a 	mov	r4,r2
8110c94c:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> FEE_CONFIG_ENTER \n");
8110c950:	d0a05417 	ldw	r2,-32432(gp)
8110c954:	100f883a 	mov	r7,r2
8110c958:	01800684 	movi	r6,26
8110c95c:	01400044 	movi	r5,1
8110c960:	01204534 	movhi	r4,33044
8110c964:	21076704 	addi	r4,r4,7580
8110c968:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* Build a function to send this command to the FEE instance */


						break;
8110c96c:	00002406 	br	8110ca00 <vPusMebInTaskConfigMode+0x348>
					case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
					case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110c970:	d0a05417 	ldw	r2,-32432(gp)
8110c974:	e0fffe0b 	ldhu	r3,-8(fp)
8110c978:	180d883a 	mov	r6,r3
8110c97c:	01604534 	movhi	r5,33044
8110c980:	29476004 	addi	r5,r5,7552
8110c984:	1009883a 	mov	r4,r2
8110c988:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"WARNING: Can't change NFEE mode while MEB is in Config Mode. \n\n");
8110c98c:	d0a05417 	ldw	r2,-32432(gp)
8110c990:	100f883a 	mov	r7,r2
8110c994:	01800fc4 	movi	r6,63
8110c998:	01400044 	movi	r5,1
8110c99c:	01204534 	movhi	r4,33044
8110c9a0:	21076e04 	addi	r4,r4,7608
8110c9a4:	1115d200 	call	81115d20 <fwrite>
						#endif

							/* Do nothing */

						break;
8110c9a8:	00001506 	br	8110ca00 <vPusMebInTaskConfigMode+0x348>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110c9ac:	d0e05417 	ldw	r3,-32432(gp)
8110c9b0:	00a04534 	movhi	r2,33044
8110c9b4:	109bcb04 	addi	r2,r2,28460
8110c9b8:	1080030b 	ldhu	r2,12(r2)
8110c9bc:	113fffcc 	andi	r4,r2,65535
8110c9c0:	00a04534 	movhi	r2,33044
8110c9c4:	109bcb04 	addi	r2,r2,28460
8110c9c8:	1080038b 	ldhu	r2,14(r2)
8110c9cc:	117fffcc 	andi	r5,r2,65535
8110c9d0:	00a04534 	movhi	r2,33044
8110c9d4:	109bcb04 	addi	r2,r2,28460
8110c9d8:	1080040b 	ldhu	r2,16(r2)
8110c9dc:	10bfffcc 	andi	r2,r2,65535
8110c9e0:	d8800015 	stw	r2,0(sp)
8110c9e4:	280f883a 	mov	r7,r5
8110c9e8:	200d883a 	mov	r6,r4
8110c9ec:	01604534 	movhi	r5,33044
8110c9f0:	29474c04 	addi	r5,r5,7472
8110c9f4:	1809883a 	mov	r4,r3
8110c9f8:	11156840 	call	81115684 <fprintf>
						#endif
						break;
8110c9fc:	0001883a 	nop
				}
				break;
8110ca00:	00006606 	br	8110cb9c <vPusMebInTaskConfigMode+0x4e4>
			case 252: /* srv-Type = 252 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
8110ca04:	00a04534 	movhi	r2,33044
8110ca08:	109bcb04 	addi	r2,r2,28460
8110ca0c:	1080050b 	ldhu	r2,20(r2)
8110ca10:	e0bffe0d 	sth	r2,-8(fp)


				switch ( xPusLocal.usiSubType )
8110ca14:	00a04534 	movhi	r2,33044
8110ca18:	109bcb04 	addi	r2,r2,28460
8110ca1c:	1080038b 	ldhu	r2,14(r2)
8110ca20:	10bfffcc 	andi	r2,r2,65535
8110ca24:	10c000e0 	cmpeqi	r3,r2,3
8110ca28:	18000a1e 	bne	r3,zero,8110ca54 <vPusMebInTaskConfigMode+0x39c>
8110ca2c:	10c00108 	cmpgei	r3,r2,4
8110ca30:	1800031e 	bne	r3,zero,8110ca40 <vPusMebInTaskConfigMode+0x388>
8110ca34:	108000a0 	cmpeqi	r2,r2,2
8110ca38:	1000331e 	bne	r2,zero,8110cb08 <vPusMebInTaskConfigMode+0x450>
8110ca3c:	00004106 	br	8110cb44 <vPusMebInTaskConfigMode+0x48c>
8110ca40:	10c00120 	cmpeqi	r3,r2,4
8110ca44:	1800121e 	bne	r3,zero,8110ca90 <vPusMebInTaskConfigMode+0x3d8>
8110ca48:	10800160 	cmpeqi	r2,r2,5
8110ca4c:	10001f1e 	bne	r2,zero,8110cacc <vPusMebInTaskConfigMode+0x414>
8110ca50:	00003c06 	br	8110cb44 <vPusMebInTaskConfigMode+0x48c>
				{
					case 3: /* TC_SCAM_SPW_LINK_ENABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110ca54:	d0a05417 	ldw	r2,-32432(gp)
8110ca58:	e0fffe0b 	ldhu	r3,-8(fp)
8110ca5c:	180d883a 	mov	r6,r3
8110ca60:	01604534 	movhi	r5,33044
8110ca64:	29476004 	addi	r5,r5,7552
8110ca68:	1009883a 	mov	r4,r2
8110ca6c:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_ENABLE \n");
8110ca70:	d0a05417 	ldw	r2,-32432(gp)
8110ca74:	100f883a 	mov	r7,r2
8110ca78:	01800844 	movi	r6,33
8110ca7c:	01400044 	movi	r5,1
8110ca80:	01204534 	movhi	r4,33044
8110ca84:	21077e04 	addi	r4,r4,7672
8110ca88:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* todo: Usar as fun��es de configura��o disponibilizadas pelo Fran�a  */
						/* todo: Como a Meb esta em config ela pode operar todas as configura��es tranquilamente  */

						break;
8110ca8c:	00004206 	br	8110cb98 <vPusMebInTaskConfigMode+0x4e0>
					case 4: /* TC_SCAM_SPW_LINK_DISABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110ca90:	d0a05417 	ldw	r2,-32432(gp)
8110ca94:	e0fffe0b 	ldhu	r3,-8(fp)
8110ca98:	180d883a 	mov	r6,r3
8110ca9c:	01604534 	movhi	r5,33044
8110caa0:	29476004 	addi	r5,r5,7552
8110caa4:	1009883a 	mov	r4,r2
8110caa8:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_DISABLE \n");
8110caac:	d0a05417 	ldw	r2,-32432(gp)
8110cab0:	100f883a 	mov	r7,r2
8110cab4:	01800884 	movi	r6,34
8110cab8:	01400044 	movi	r5,1
8110cabc:	01204534 	movhi	r4,33044
8110cac0:	21078704 	addi	r4,r4,7708
8110cac4:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* todo: Usar as fun��es de configura��o disponibilizadas pelo Fran�a  */
						/* todo: Como a Meb esta em config ela pode operar todas as configura��es tranquilamente  */

						break;
8110cac8:	00003306 	br	8110cb98 <vPusMebInTaskConfigMode+0x4e0>
					case 5: /* TC_SCAM_SPW_LINK_RESET */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110cacc:	d0a05417 	ldw	r2,-32432(gp)
8110cad0:	e0fffe0b 	ldhu	r3,-8(fp)
8110cad4:	180d883a 	mov	r6,r3
8110cad8:	01604534 	movhi	r5,33044
8110cadc:	29476004 	addi	r5,r5,7552
8110cae0:	1009883a 	mov	r4,r2
8110cae4:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_RESET \n");
8110cae8:	d0a05417 	ldw	r2,-32432(gp)
8110caec:	100f883a 	mov	r7,r2
8110caf0:	01800804 	movi	r6,32
8110caf4:	01400044 	movi	r5,1
8110caf8:	01204534 	movhi	r4,33044
8110cafc:	21079004 	addi	r4,r4,7744
8110cb00:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* todo: Usar as fun��es de configura��o disponibilizadas pelo Fran�a  */
						/* todo: Como a Meb esta em config ela pode operar todas as configura��es tranquilamente  */

						break;
8110cb04:	00002406 	br	8110cb98 <vPusMebInTaskConfigMode+0x4e0>
					case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110cb08:	d0a05417 	ldw	r2,-32432(gp)
8110cb0c:	e0fffe0b 	ldhu	r3,-8(fp)
8110cb10:	180d883a 	mov	r6,r3
8110cb14:	01604534 	movhi	r5,33044
8110cb18:	29476004 	addi	r5,r5,7552
8110cb1c:	1009883a 	mov	r4,r2
8110cb20:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_RMAP_CONFIG_UPDATE \n");
8110cb24:	d0a05417 	ldw	r2,-32432(gp)
8110cb28:	100f883a 	mov	r7,r2
8110cb2c:	01800a04 	movi	r6,40
8110cb30:	01400044 	movi	r5,1
8110cb34:	01204534 	movhi	r4,33044
8110cb38:	21079904 	addi	r4,r4,7780
8110cb3c:	1115d200 	call	81115d20 <fwrite>
							debug(fp, cPUSDebug );
							sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
							debug(fp, cPUSDebug );
						#endif
*/
						break;
8110cb40:	00001506 	br	8110cb98 <vPusMebInTaskConfigMode+0x4e0>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110cb44:	d0e05417 	ldw	r3,-32432(gp)
8110cb48:	00a04534 	movhi	r2,33044
8110cb4c:	109bcb04 	addi	r2,r2,28460
8110cb50:	1080030b 	ldhu	r2,12(r2)
8110cb54:	113fffcc 	andi	r4,r2,65535
8110cb58:	00a04534 	movhi	r2,33044
8110cb5c:	109bcb04 	addi	r2,r2,28460
8110cb60:	1080038b 	ldhu	r2,14(r2)
8110cb64:	117fffcc 	andi	r5,r2,65535
8110cb68:	00a04534 	movhi	r2,33044
8110cb6c:	109bcb04 	addi	r2,r2,28460
8110cb70:	1080040b 	ldhu	r2,16(r2)
8110cb74:	10bfffcc 	andi	r2,r2,65535
8110cb78:	d8800015 	stw	r2,0(sp)
8110cb7c:	280f883a 	mov	r7,r5
8110cb80:	200d883a 	mov	r6,r4
8110cb84:	01604534 	movhi	r5,33044
8110cb88:	29474c04 	addi	r5,r5,7472
8110cb8c:	1809883a 	mov	r4,r3
8110cb90:	11156840 	call	81115684 <fprintf>
						#endif

						break;
8110cb94:	0001883a 	nop
				}
				break;
8110cb98:	0001883a 	nop
				break;
		}

	}

}
8110cb9c:	0001883a 	nop
8110cba0:	e037883a 	mov	sp,fp
8110cba4:	dfc00117 	ldw	ra,4(sp)
8110cba8:	df000017 	ldw	fp,0(sp)
8110cbac:	dec00204 	addi	sp,sp,8
8110cbb0:	f800283a 	ret

8110cbb4 <vPusMebInTaskRunningMode>:


/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal ) {
8110cbb4:	defff904 	addi	sp,sp,-28
8110cbb8:	de00012e 	bgeu	sp,et,8110cbc0 <vPusMebInTaskRunningMode+0xc>
8110cbbc:	003b68fa 	trap	3
8110cbc0:	dfc00615 	stw	ra,24(sp)
8110cbc4:	df000515 	stw	fp,20(sp)
8110cbc8:	df000504 	addi	fp,sp,20
8110cbcc:	e13fff15 	stw	r4,-4(fp)
	unsigned char i;
	unsigned short int usiFeeInstL;
	static tTMPus xPusLocal;
	bool bSuccess = FALSE;
8110cbd0:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;

	bSuccess = FALSE;
8110cbd4:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 1, &error_code);
8110cbd8:	d0a06317 	ldw	r2,-32372(gp)
8110cbdc:	e0fffe84 	addi	r3,fp,-6
8110cbe0:	180d883a 	mov	r6,r3
8110cbe4:	01400044 	movi	r5,1
8110cbe8:	1009883a 	mov	r4,r2
8110cbec:	11317540 	call	81131754 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
8110cbf0:	e0bffe83 	ldbu	r2,-6(fp)
8110cbf4:	10803fcc 	andi	r2,r2,255
8110cbf8:	10002c1e 	bne	r2,zero,8110ccac <vPusMebInTaskRunningMode+0xf8>

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
8110cbfc:	e03ffc05 	stb	zero,-16(fp)
8110cc00:	00002306 	br	8110cc90 <vPusMebInTaskRunningMode+0xdc>
	    {
            if ( xPus[i].bInUse == TRUE ) {
8110cc04:	e0fffc03 	ldbu	r3,-16(fp)
8110cc08:	00a04574 	movhi	r2,33045
8110cc0c:	10a5d704 	addi	r2,r2,-26788
8110cc10:	18c01524 	muli	r3,r3,84
8110cc14:	10c5883a 	add	r2,r2,r3
8110cc18:	10800104 	addi	r2,r2,4
8110cc1c:	10800017 	ldw	r2,0(r2)
8110cc20:	10800058 	cmpnei	r2,r2,1
8110cc24:	1000171e 	bne	r2,zero,8110cc84 <vPusMebInTaskRunningMode+0xd0>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[i];
8110cc28:	e13ffc03 	ldbu	r4,-16(fp)
8110cc2c:	00e04534 	movhi	r3,33044
8110cc30:	18dbe004 	addi	r3,r3,28544
8110cc34:	00a04574 	movhi	r2,33045
8110cc38:	10a5d704 	addi	r2,r2,-26788
8110cc3c:	21001524 	muli	r4,r4,84
8110cc40:	1105883a 	add	r2,r2,r4
8110cc44:	1009883a 	mov	r4,r2
8110cc48:	00801504 	movi	r2,84
8110cc4c:	100d883a 	mov	r6,r2
8110cc50:	200b883a 	mov	r5,r4
8110cc54:	1809883a 	mov	r4,r3
8110cc58:	11167340 	call	81116734 <memcpy>
            	xPus[i].bInUse = FALSE;
8110cc5c:	e0fffc03 	ldbu	r3,-16(fp)
8110cc60:	00a04574 	movhi	r2,33045
8110cc64:	10a5d704 	addi	r2,r2,-26788
8110cc68:	18c01524 	muli	r3,r3,84
8110cc6c:	10c5883a 	add	r2,r2,r3
8110cc70:	10800104 	addi	r2,r2,4
8110cc74:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
8110cc78:	00800044 	movi	r2,1
8110cc7c:	e0bffd15 	stw	r2,-12(fp)
                break;
8110cc80:	00000606 	br	8110cc9c <vPusMebInTaskRunningMode+0xe8>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 1, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
8110cc84:	e0bffc03 	ldbu	r2,-16(fp)
8110cc88:	10800044 	addi	r2,r2,1
8110cc8c:	e0bffc05 	stb	r2,-16(fp)
8110cc90:	e0bffc03 	ldbu	r2,-16(fp)
8110cc94:	10800130 	cmpltui	r2,r2,4
8110cc98:	103fda1e 	bne	r2,zero,8110cc04 <__reset+0xfb0ecc04>
            	xPus[i].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
8110cc9c:	d0a06317 	ldw	r2,-32372(gp)
8110cca0:	1009883a 	mov	r4,r2
8110cca4:	1131cf80 	call	81131cf8 <OSMutexPost>
8110cca8:	00000106 	br	8110ccb0 <vPusMebInTaskRunningMode+0xfc>
	} else {
		vCouldNotGetMutexMebPus();
8110ccac:	11128d40 	call	811128d4 <vCouldNotGetMutexMebPus>
	}

	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {
8110ccb0:	e0bffd17 	ldw	r2,-12(fp)
8110ccb4:	10800058 	cmpnei	r2,r2,1
8110ccb8:	10010c1e 	bne	r2,zero,8110d0ec <vPusMebInTaskRunningMode+0x538>

		switch (xPusLocal.usiType) {
8110ccbc:	00a04534 	movhi	r2,33044
8110ccc0:	109be004 	addi	r2,r2,28544
8110ccc4:	1080030b 	ldhu	r2,12(r2)
8110ccc8:	10bfffcc 	andi	r2,r2,65535
8110cccc:	10c03ee0 	cmpeqi	r3,r2,251
8110ccd0:	1800481e 	bne	r3,zero,8110cdf4 <vPusMebInTaskRunningMode+0x240>
8110ccd4:	10c03f20 	cmpeqi	r3,r2,252
8110ccd8:	1800971e 	bne	r3,zero,8110cf38 <vPusMebInTaskRunningMode+0x384>
8110ccdc:	10803ea0 	cmpeqi	r2,r2,250
8110cce0:	1000011e 	bne	r2,zero,8110cce8 <vPusMebInTaskRunningMode+0x134>

						break;
				}
				break;
			default:
				break;
8110cce4:	00010106 	br	8110d0ec <vPusMebInTaskRunningMode+0x538>
	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {

		switch (xPusLocal.usiType) {
			case 250: /* srv-Type = 250 */
				switch ( xPusLocal.usiSubType )
8110cce8:	00a04534 	movhi	r2,33044
8110ccec:	109be004 	addi	r2,r2,28544
8110ccf0:	1080038b 	ldhu	r2,14(r2)
8110ccf4:	10bfffcc 	andi	r2,r2,65535
8110ccf8:	10c00f60 	cmpeqi	r3,r2,61
8110ccfc:	1800171e 	bne	r3,zero,8110cd5c <vPusMebInTaskRunningMode+0x1a8>
8110cd00:	10c00fa0 	cmpeqi	r3,r2,62
8110cd04:	18001d1e 	bne	r3,zero,8110cd7c <vPusMebInTaskRunningMode+0x1c8>
8110cd08:	10800f20 	cmpeqi	r2,r2,60
8110cd0c:	10002326 	beq	r2,zero,8110cd9c <vPusMebInTaskRunningMode+0x1e8>
				{
					case 60: /* TC_SCAM_CONFIG */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: Changing to Config Mode\n");
8110cd10:	d0a05417 	ldw	r2,-32432(gp)
8110cd14:	100f883a 	mov	r7,r2
8110cd18:	01800884 	movi	r6,34
8110cd1c:	01400044 	movi	r5,1
8110cd20:	01204534 	movhi	r4,33044
8110cd24:	2107a404 	addi	r4,r4,7824
8110cd28:	1115d200 	call	81115d20 <fwrite>
						#endif

						vEvtChangeMebMode(pxMebCLocal->eMode, sMebConfig);
8110cd2c:	e0bfff17 	ldw	r2,-4(fp)
8110cd30:	10800117 	ldw	r2,4(r2)
8110cd34:	000b883a 	mov	r5,zero
8110cd38:	1009883a 	mov	r4,r2
8110cd3c:	1112bac0 	call	81112bac <vEvtChangeMebMode>
						pxMebCLocal->eMode = sMebConfig;
8110cd40:	e0bfff17 	ldw	r2,-4(fp)
8110cd44:	10000115 	stw	zero,4(r2)

	/*todo: URGENTE: Passar todos os FEE para modo de configura��o  */
	/*todo: URGENTE: Data Controller e NFEE COntroller tamb�m  */

						vSendCmdQToNFeeCTRL( M_NFC_CONFIG, 0, 0 );
8110cd48:	000d883a 	mov	r6,zero
8110cd4c:	000b883a 	mov	r5,zero
8110cd50:	01000044 	movi	r4,1
8110cd54:	110d1040 	call	8110d104 <vSendCmdQToNFeeCTRL>


						break;
8110cd58:	00002506 	br	8110cdf0 <vPusMebInTaskRunningMode+0x23c>

					case 61: /* TC_SCAM_RUN */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: MEB already in the RUN Mode\n");
8110cd5c:	d0a05417 	ldw	r2,-32432(gp)
8110cd60:	100f883a 	mov	r7,r2
8110cd64:	01800984 	movi	r6,38
8110cd68:	01400044 	movi	r5,1
8110cd6c:	01204534 	movhi	r4,33044
8110cd70:	2107ad04 	addi	r4,r4,7860
8110cd74:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* Do nothing */

						break;
8110cd78:	00001d06 	br	8110cdf0 <vPusMebInTaskRunningMode+0x23c>


					case 62: /* TC_SCAM_TURNOFF */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: Turnning OFF \n");
8110cd7c:	d0a05417 	ldw	r2,-32432(gp)
8110cd80:	100f883a 	mov	r7,r2
8110cd84:	01800604 	movi	r6,24
8110cd88:	01400044 	movi	r5,1
8110cd8c:	01204534 	movhi	r4,33044
8110cd90:	21074504 	addi	r4,r4,7444
8110cd94:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* todo:Enviar emnsagens para a meb, e a meb distribui a mensagem */
						/* todo:Enviar Sinalizar Led quando puder desligar */

						break;
8110cd98:	00001506 	br	8110cdf0 <vPusMebInTaskRunningMode+0x23c>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110cd9c:	d0e05417 	ldw	r3,-32432(gp)
8110cda0:	00a04534 	movhi	r2,33044
8110cda4:	109be004 	addi	r2,r2,28544
8110cda8:	1080030b 	ldhu	r2,12(r2)
8110cdac:	113fffcc 	andi	r4,r2,65535
8110cdb0:	00a04534 	movhi	r2,33044
8110cdb4:	109be004 	addi	r2,r2,28544
8110cdb8:	1080038b 	ldhu	r2,14(r2)
8110cdbc:	117fffcc 	andi	r5,r2,65535
8110cdc0:	00a04534 	movhi	r2,33044
8110cdc4:	109be004 	addi	r2,r2,28544
8110cdc8:	1080040b 	ldhu	r2,16(r2)
8110cdcc:	10bfffcc 	andi	r2,r2,65535
8110cdd0:	d8800015 	stw	r2,0(sp)
8110cdd4:	280f883a 	mov	r7,r5
8110cdd8:	200d883a 	mov	r6,r4
8110cddc:	01604534 	movhi	r5,33044
8110cde0:	29474c04 	addi	r5,r5,7472
8110cde4:	1809883a 	mov	r4,r3
8110cde8:	11156840 	call	81115684 <fprintf>
						#endif
						break;
8110cdec:	0001883a 	nop
				}
				break;
8110cdf0:	0000be06 	br	8110d0ec <vPusMebInTaskRunningMode+0x538>
			case 251: /* srv-Type = 251 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
8110cdf4:	00a04534 	movhi	r2,33044
8110cdf8:	109be004 	addi	r2,r2,28544
8110cdfc:	1080050b 	ldhu	r2,20(r2)
8110ce00:	e0bffe0d 	sth	r2,-8(fp)

				switch ( xPusLocal.usiSubType )
8110ce04:	00a04534 	movhi	r2,33044
8110ce08:	109be004 	addi	r2,r2,28544
8110ce0c:	1080038b 	ldhu	r2,14(r2)
8110ce10:	10bfffcc 	andi	r2,r2,65535
8110ce14:	10c000a0 	cmpeqi	r3,r2,2
8110ce18:	1800131e 	bne	r3,zero,8110ce68 <vPusMebInTaskRunningMode+0x2b4>
8110ce1c:	10c00160 	cmpeqi	r3,r2,5
8110ce20:	1800201e 	bne	r3,zero,8110cea4 <vPusMebInTaskRunningMode+0x2f0>
8110ce24:	10800060 	cmpeqi	r2,r2,1
8110ce28:	10002d26 	beq	r2,zero,8110cee0 <vPusMebInTaskRunningMode+0x32c>
				{
					case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110ce2c:	d0a05417 	ldw	r2,-32432(gp)
8110ce30:	e0fffe0b 	ldhu	r3,-8(fp)
8110ce34:	180d883a 	mov	r6,r3
8110ce38:	01604534 	movhi	r5,33044
8110ce3c:	29476004 	addi	r5,r5,7552
8110ce40:	1009883a 	mov	r4,r2
8110ce44:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> FEE_CONFIG_ENTER \n");
8110ce48:	d0a05417 	ldw	r2,-32432(gp)
8110ce4c:	100f883a 	mov	r7,r2
8110ce50:	01800684 	movi	r6,26
8110ce54:	01400044 	movi	r5,1
8110ce58:	01204534 	movhi	r4,33044
8110ce5c:	21076704 	addi	r4,r4,7580
8110ce60:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* Build a function to send this command to the FEE instance */
						 /* Using QMASK send to NfeeControl that will forward */

						break;
8110ce64:	00003306 	br	8110cf34 <vPusMebInTaskRunningMode+0x380>
					case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110ce68:	d0a05417 	ldw	r2,-32432(gp)
8110ce6c:	e0fffe0b 	ldhu	r3,-8(fp)
8110ce70:	180d883a 	mov	r6,r3
8110ce74:	01604534 	movhi	r5,33044
8110ce78:	29476004 	addi	r5,r5,7552
8110ce7c:	1009883a 	mov	r4,r2
8110ce80:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> FEE_STANDBY_ENTER \n");
8110ce84:	d0a05417 	ldw	r2,-32432(gp)
8110ce88:	100f883a 	mov	r7,r2
8110ce8c:	018006c4 	movi	r6,27
8110ce90:	01400044 	movi	r5,1
8110ce94:	01204534 	movhi	r4,33044
8110ce98:	2107b704 	addi	r4,r4,7900
8110ce9c:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* Using QMASK send to NfeeControl that will foward */

						break;
8110cea0:	00002406 	br	8110cf34 <vPusMebInTaskRunningMode+0x380>
					case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110cea4:	d0a05417 	ldw	r2,-32432(gp)
8110cea8:	e0fffe0b 	ldhu	r3,-8(fp)
8110ceac:	180d883a 	mov	r6,r3
8110ceb0:	01604534 	movhi	r5,33044
8110ceb4:	29476004 	addi	r5,r5,7552
8110ceb8:	1009883a 	mov	r4,r2
8110cebc:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> TC_SCAM_FEE_CALIBRATION_TEST_ENTER \n");
8110cec0:	d0a05417 	ldw	r2,-32432(gp)
8110cec4:	100f883a 	mov	r7,r2
8110cec8:	01800b04 	movi	r6,44
8110cecc:	01400044 	movi	r5,1
8110ced0:	01204534 	movhi	r4,33044
8110ced4:	2107be04 	addi	r4,r4,7928
8110ced8:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* Using QMASK send to NfeeControl that will foward */

						break;
8110cedc:	00001506 	br	8110cf34 <vPusMebInTaskRunningMode+0x380>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110cee0:	d0e05417 	ldw	r3,-32432(gp)
8110cee4:	00a04534 	movhi	r2,33044
8110cee8:	109be004 	addi	r2,r2,28544
8110ceec:	1080030b 	ldhu	r2,12(r2)
8110cef0:	113fffcc 	andi	r4,r2,65535
8110cef4:	00a04534 	movhi	r2,33044
8110cef8:	109be004 	addi	r2,r2,28544
8110cefc:	1080038b 	ldhu	r2,14(r2)
8110cf00:	117fffcc 	andi	r5,r2,65535
8110cf04:	00a04534 	movhi	r2,33044
8110cf08:	109be004 	addi	r2,r2,28544
8110cf0c:	1080040b 	ldhu	r2,16(r2)
8110cf10:	10bfffcc 	andi	r2,r2,65535
8110cf14:	d8800015 	stw	r2,0(sp)
8110cf18:	280f883a 	mov	r7,r5
8110cf1c:	200d883a 	mov	r6,r4
8110cf20:	01604534 	movhi	r5,33044
8110cf24:	29474c04 	addi	r5,r5,7472
8110cf28:	1809883a 	mov	r4,r3
8110cf2c:	11156840 	call	81115684 <fprintf>
						#endif
						break;
8110cf30:	0001883a 	nop
				}
				break;
8110cf34:	00006d06 	br	8110d0ec <vPusMebInTaskRunningMode+0x538>
			case 252: /* srv-Type = 252 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
8110cf38:	00a04534 	movhi	r2,33044
8110cf3c:	109be004 	addi	r2,r2,28544
8110cf40:	1080050b 	ldhu	r2,20(r2)
8110cf44:	e0bffe0d 	sth	r2,-8(fp)


				switch ( xPusLocal.usiSubType )
8110cf48:	00a04534 	movhi	r2,33044
8110cf4c:	109be004 	addi	r2,r2,28544
8110cf50:	1080038b 	ldhu	r2,14(r2)
8110cf54:	10bfffcc 	andi	r2,r2,65535
8110cf58:	10c000e0 	cmpeqi	r3,r2,3
8110cf5c:	18000a1e 	bne	r3,zero,8110cf88 <vPusMebInTaskRunningMode+0x3d4>
8110cf60:	10c00108 	cmpgei	r3,r2,4
8110cf64:	1800031e 	bne	r3,zero,8110cf74 <vPusMebInTaskRunningMode+0x3c0>
8110cf68:	108000a0 	cmpeqi	r2,r2,2
8110cf6c:	1000331e 	bne	r2,zero,8110d03c <vPusMebInTaskRunningMode+0x488>
8110cf70:	00004806 	br	8110d094 <vPusMebInTaskRunningMode+0x4e0>
8110cf74:	10c00120 	cmpeqi	r3,r2,4
8110cf78:	1800121e 	bne	r3,zero,8110cfc4 <vPusMebInTaskRunningMode+0x410>
8110cf7c:	10800160 	cmpeqi	r2,r2,5
8110cf80:	10001f1e 	bne	r2,zero,8110d000 <vPusMebInTaskRunningMode+0x44c>
8110cf84:	00004306 	br	8110d094 <vPusMebInTaskRunningMode+0x4e0>
				{
					case 3: /* TC_SCAM_SPW_LINK_ENABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110cf88:	d0a05417 	ldw	r2,-32432(gp)
8110cf8c:	e0fffe0b 	ldhu	r3,-8(fp)
8110cf90:	180d883a 	mov	r6,r3
8110cf94:	01604534 	movhi	r5,33044
8110cf98:	29476004 	addi	r5,r5,7552
8110cf9c:	1009883a 	mov	r4,r2
8110cfa0:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_ENABLE \n");
8110cfa4:	d0a05417 	ldw	r2,-32432(gp)
8110cfa8:	100f883a 	mov	r7,r2
8110cfac:	01800844 	movi	r6,33
8110cfb0:	01400044 	movi	r5,1
8110cfb4:	01204534 	movhi	r4,33044
8110cfb8:	21077e04 	addi	r4,r4,7672
8110cfbc:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* todo: Usar as fun��es de configura��o disponibilizadas pelo Fran�a  */
						/* todo: Como a Meb esta em config ela pode operar todas as configura��es tranquilamente  */

						break;
8110cfc0:	00004906 	br	8110d0e8 <vPusMebInTaskRunningMode+0x534>
					case 4: /* TC_SCAM_SPW_LINK_DISABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110cfc4:	d0a05417 	ldw	r2,-32432(gp)
8110cfc8:	e0fffe0b 	ldhu	r3,-8(fp)
8110cfcc:	180d883a 	mov	r6,r3
8110cfd0:	01604534 	movhi	r5,33044
8110cfd4:	29476004 	addi	r5,r5,7552
8110cfd8:	1009883a 	mov	r4,r2
8110cfdc:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_DISABLE \n");
8110cfe0:	d0a05417 	ldw	r2,-32432(gp)
8110cfe4:	100f883a 	mov	r7,r2
8110cfe8:	01800884 	movi	r6,34
8110cfec:	01400044 	movi	r5,1
8110cff0:	01204534 	movhi	r4,33044
8110cff4:	21078704 	addi	r4,r4,7708
8110cff8:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* todo: Usar as fun��es de configura��o disponibilizadas pelo Fran�a  */
						/* todo: Como a Meb esta em config ela pode operar todas as configura��es tranquilamente  */

						break;
8110cffc:	00003a06 	br	8110d0e8 <vPusMebInTaskRunningMode+0x534>
					case 5: /* TC_SCAM_SPW_LINK_RESET */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d000:	d0a05417 	ldw	r2,-32432(gp)
8110d004:	e0fffe0b 	ldhu	r3,-8(fp)
8110d008:	180d883a 	mov	r6,r3
8110d00c:	01604534 	movhi	r5,33044
8110d010:	29476004 	addi	r5,r5,7552
8110d014:	1009883a 	mov	r4,r2
8110d018:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_RESET \n");
8110d01c:	d0a05417 	ldw	r2,-32432(gp)
8110d020:	100f883a 	mov	r7,r2
8110d024:	01800804 	movi	r6,32
8110d028:	01400044 	movi	r5,1
8110d02c:	01204534 	movhi	r4,33044
8110d030:	21079004 	addi	r4,r4,7744
8110d034:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* todo: Usar as fun��es de configura��o disponibilizadas pelo Fran�a  */
						/* todo: Como a Meb esta em config ela pode operar todas as configura��es tranquilamente  */

						break;
8110d038:	00002b06 	br	8110d0e8 <vPusMebInTaskRunningMode+0x534>
					case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d03c:	d0a05417 	ldw	r2,-32432(gp)
8110d040:	e0fffe0b 	ldhu	r3,-8(fp)
8110d044:	180d883a 	mov	r6,r3
8110d048:	01604534 	movhi	r5,33044
8110d04c:	29476004 	addi	r5,r5,7552
8110d050:	1009883a 	mov	r4,r2
8110d054:	11156840 	call	81115684 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_RMAP_CONFIG_UPDATE \n");
8110d058:	d0a05417 	ldw	r2,-32432(gp)
8110d05c:	100f883a 	mov	r7,r2
8110d060:	01800a04 	movi	r6,40
8110d064:	01400044 	movi	r5,1
8110d068:	01204534 	movhi	r4,33044
8110d06c:	21079904 	addi	r4,r4,7780
8110d070:	1115d200 	call	81115d20 <fwrite>
							fprintf(fp,"WARNING: Operation Forbiden in Meb Running Mode. \n\n");
8110d074:	d0a05417 	ldw	r2,-32432(gp)
8110d078:	100f883a 	mov	r7,r2
8110d07c:	01800cc4 	movi	r6,51
8110d080:	01400044 	movi	r5,1
8110d084:	01204534 	movhi	r4,33044
8110d088:	2107ca04 	addi	r4,r4,7976
8110d08c:	1115d200 	call	81115d20 <fwrite>
						#endif

						/* Do nothing */
						/* Return a PUS error? */

						break;
8110d090:	00001506 	br	8110d0e8 <vPusMebInTaskRunningMode+0x534>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110d094:	d0e05417 	ldw	r3,-32432(gp)
8110d098:	00a04534 	movhi	r2,33044
8110d09c:	109be004 	addi	r2,r2,28544
8110d0a0:	1080030b 	ldhu	r2,12(r2)
8110d0a4:	113fffcc 	andi	r4,r2,65535
8110d0a8:	00a04534 	movhi	r2,33044
8110d0ac:	109be004 	addi	r2,r2,28544
8110d0b0:	1080038b 	ldhu	r2,14(r2)
8110d0b4:	117fffcc 	andi	r5,r2,65535
8110d0b8:	00a04534 	movhi	r2,33044
8110d0bc:	109be004 	addi	r2,r2,28544
8110d0c0:	1080040b 	ldhu	r2,16(r2)
8110d0c4:	10bfffcc 	andi	r2,r2,65535
8110d0c8:	d8800015 	stw	r2,0(sp)
8110d0cc:	280f883a 	mov	r7,r5
8110d0d0:	200d883a 	mov	r6,r4
8110d0d4:	01604534 	movhi	r5,33044
8110d0d8:	29474c04 	addi	r5,r5,7472
8110d0dc:	1809883a 	mov	r4,r3
8110d0e0:	11156840 	call	81115684 <fprintf>
						#endif

						break;
8110d0e4:	0001883a 	nop
				}
				break;
8110d0e8:	0001883a 	nop
			default:
				break;
		}
	}
}
8110d0ec:	0001883a 	nop
8110d0f0:	e037883a 	mov	sp,fp
8110d0f4:	dfc00117 	ldw	ra,4(sp)
8110d0f8:	df000017 	ldw	fp,0(sp)
8110d0fc:	dec00204 	addi	sp,sp,8
8110d100:	f800283a 	ret

8110d104 <vSendCmdQToNFeeCTRL>:

void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110d104:	defff904 	addi	sp,sp,-28
8110d108:	de00012e 	bgeu	sp,et,8110d110 <vSendCmdQToNFeeCTRL+0xc>
8110d10c:	003b68fa 	trap	3
8110d110:	dfc00615 	stw	ra,24(sp)
8110d114:	df000515 	stw	fp,20(sp)
8110d118:	df000504 	addi	fp,sp,20
8110d11c:	2807883a 	mov	r3,r5
8110d120:	3005883a 	mov	r2,r6
8110d124:	e13ffd05 	stb	r4,-12(fp)
8110d128:	e0fffe05 	stb	r3,-8(fp)
8110d12c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110d130:	00800404 	movi	r2,16
8110d134:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110d138:	e0bffd03 	ldbu	r2,-12(fp)
8110d13c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110d140:	e0bffe03 	ldbu	r2,-8(fp)
8110d144:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110d148:	e0bfff03 	ldbu	r2,-4(fp)
8110d14c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8110d150:	d0a04a17 	ldw	r2,-32472(gp)
8110d154:	e0fffc17 	ldw	r3,-16(fp)
8110d158:	180b883a 	mov	r5,r3
8110d15c:	1009883a 	mov	r4,r2
8110d160:	1132c700 	call	81132c70 <OSQPost>
8110d164:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110d168:	e0bffb03 	ldbu	r2,-20(fp)
8110d16c:	10000126 	beq	r2,zero,8110d174 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
8110d170:	1112b140 	call	81112b14 <vFailSendMsgFeeCTRL>
	}

}
8110d174:	0001883a 	nop
8110d178:	e037883a 	mov	sp,fp
8110d17c:	dfc00117 	ldw	ra,4(sp)
8110d180:	df000017 	ldw	fp,0(sp)
8110d184:	dec00204 	addi	sp,sp,8
8110d188:	f800283a 	ret

8110d18c <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
8110d18c:	defff804 	addi	sp,sp,-32
8110d190:	de00012e 	bgeu	sp,et,8110d198 <vStackMonitor+0xc>
8110d194:	003b68fa 	trap	3
8110d198:	dfc00715 	stw	ra,28(sp)
8110d19c:	df000615 	stw	fp,24(sp)
8110d1a0:	df000604 	addi	fp,sp,24
8110d1a4:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
8110d1a8:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
8110d1ac:	d0a05417 	ldw	r2,-32432(gp)
8110d1b0:	100f883a 	mov	r7,r2
8110d1b4:	018006c4 	movi	r6,27
8110d1b8:	01400044 	movi	r5,1
8110d1bc:	01204534 	movhi	r4,33044
8110d1c0:	2107d704 	addi	r4,r4,8028
8110d1c4:	1115d200 	call	81115d20 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
8110d1c8:	d0a05417 	ldw	r2,-32432(gp)
8110d1cc:	100f883a 	mov	r7,r2
8110d1d0:	01800b04 	movi	r6,44
8110d1d4:	01400044 	movi	r5,1
8110d1d8:	01204534 	movhi	r4,33044
8110d1dc:	2107de04 	addi	r4,r4,8056
8110d1e0:	1115d200 	call	81115d20 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
8110d1e4:	d0a05417 	ldw	r2,-32432(gp)
8110d1e8:	100f883a 	mov	r7,r2
8110d1ec:	01800f84 	movi	r6,62
8110d1f0:	01400044 	movi	r5,1
8110d1f4:	01204534 	movhi	r4,33044
8110d1f8:	2107ea04 	addi	r4,r4,8104
8110d1fc:	1115d200 	call	81115d20 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
8110d200:	e0bffd04 	addi	r2,fp,-12
8110d204:	100b883a 	mov	r5,r2
8110d208:	01000804 	movi	r4,32
8110d20c:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d210:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
8110d214:	e0bffc03 	ldbu	r2,-16(fp)
8110d218:	10000f1e 	bne	r2,zero,8110d258 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d21c:	d1205417 	ldw	r4,-32432(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
8110d220:	e0fffd17 	ldw	r3,-12(fp)
8110d224:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d228:	188b883a 	add	r5,r3,r2
8110d22c:	e0bffd17 	ldw	r2,-12(fp)
8110d230:	e0fffe17 	ldw	r3,-8(fp)
8110d234:	d8c00115 	stw	r3,4(sp)
8110d238:	d8800015 	stw	r2,0(sp)
8110d23c:	280f883a 	mov	r7,r5
8110d240:	01a04534 	movhi	r6,33044
8110d244:	3187fa04 	addi	r6,r6,8168
8110d248:	01604534 	movhi	r5,33044
8110d24c:	2947fe04 	addi	r5,r5,8184
8110d250:	11156840 	call	81115684 <fprintf>
8110d254:	00000706 	br	8110d274 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
8110d258:	d0a05417 	ldw	r2,-32432(gp)
8110d25c:	100f883a 	mov	r7,r2
8110d260:	01800904 	movi	r6,36
8110d264:	01400044 	movi	r5,1
8110d268:	01204534 	movhi	r4,33044
8110d26c:	21080d04 	addi	r4,r4,8244
8110d270:	1115d200 	call	81115d20 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
8110d274:	e0bffd04 	addi	r2,fp,-12
8110d278:	100b883a 	mov	r5,r2
8110d27c:	01000784 	movi	r4,30
8110d280:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d284:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d288:	e0bffc03 	ldbu	r2,-16(fp)
8110d28c:	10000f1e 	bne	r2,zero,8110d2cc <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d290:	d1205417 	ldw	r4,-32432(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
8110d294:	e0fffd17 	ldw	r3,-12(fp)
8110d298:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d29c:	188b883a 	add	r5,r3,r2
8110d2a0:	e0bffd17 	ldw	r2,-12(fp)
8110d2a4:	e0fffe17 	ldw	r3,-8(fp)
8110d2a8:	d8c00115 	stw	r3,4(sp)
8110d2ac:	d8800015 	stw	r2,0(sp)
8110d2b0:	280f883a 	mov	r7,r5
8110d2b4:	01a04534 	movhi	r6,33044
8110d2b8:	31881704 	addi	r6,r6,8284
8110d2bc:	01604534 	movhi	r5,33044
8110d2c0:	2947fe04 	addi	r5,r5,8184
8110d2c4:	11156840 	call	81115684 <fprintf>
8110d2c8:	00000706 	br	8110d2e8 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
8110d2cc:	d0a05417 	ldw	r2,-32432(gp)
8110d2d0:	100f883a 	mov	r7,r2
8110d2d4:	01800984 	movi	r6,38
8110d2d8:	01400044 	movi	r5,1
8110d2dc:	01204534 	movhi	r4,33044
8110d2e0:	21081b04 	addi	r4,r4,8300
8110d2e4:	1115d200 	call	81115d20 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
8110d2e8:	e0bffd04 	addi	r2,fp,-12
8110d2ec:	100b883a 	mov	r5,r2
8110d2f0:	01000704 	movi	r4,28
8110d2f4:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d2f8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d2fc:	e0bffc03 	ldbu	r2,-16(fp)
8110d300:	10000f1e 	bne	r2,zero,8110d340 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d304:	d1205417 	ldw	r4,-32432(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
8110d308:	e0fffd17 	ldw	r3,-12(fp)
8110d30c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d310:	188b883a 	add	r5,r3,r2
8110d314:	e0bffd17 	ldw	r2,-12(fp)
8110d318:	e0fffe17 	ldw	r3,-8(fp)
8110d31c:	d8c00115 	stw	r3,4(sp)
8110d320:	d8800015 	stw	r2,0(sp)
8110d324:	280f883a 	mov	r7,r5
8110d328:	01a04534 	movhi	r6,33044
8110d32c:	31882504 	addi	r6,r6,8340
8110d330:	01604534 	movhi	r5,33044
8110d334:	2947fe04 	addi	r5,r5,8184
8110d338:	11156840 	call	81115684 <fprintf>
8110d33c:	00000706 	br	8110d35c <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
8110d340:	d0a05417 	ldw	r2,-32432(gp)
8110d344:	100f883a 	mov	r7,r2
8110d348:	01800884 	movi	r6,34
8110d34c:	01400044 	movi	r5,1
8110d350:	01204534 	movhi	r4,33044
8110d354:	21082804 	addi	r4,r4,8352
8110d358:	1115d200 	call	81115d20 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
8110d35c:	e0bffd04 	addi	r2,fp,-12
8110d360:	100b883a 	mov	r5,r2
8110d364:	010006c4 	movi	r4,27
8110d368:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d36c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d370:	e0bffc03 	ldbu	r2,-16(fp)
8110d374:	10000f1e 	bne	r2,zero,8110d3b4 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d378:	d1205417 	ldw	r4,-32432(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
8110d37c:	e0fffd17 	ldw	r3,-12(fp)
8110d380:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d384:	188b883a 	add	r5,r3,r2
8110d388:	e0bffd17 	ldw	r2,-12(fp)
8110d38c:	e0fffe17 	ldw	r3,-8(fp)
8110d390:	d8c00115 	stw	r3,4(sp)
8110d394:	d8800015 	stw	r2,0(sp)
8110d398:	280f883a 	mov	r7,r5
8110d39c:	01a04534 	movhi	r6,33044
8110d3a0:	31883104 	addi	r6,r6,8388
8110d3a4:	01604534 	movhi	r5,33044
8110d3a8:	2947fe04 	addi	r5,r5,8184
8110d3ac:	11156840 	call	81115684 <fprintf>
8110d3b0:	00000706 	br	8110d3d0 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
8110d3b4:	d0a05417 	ldw	r2,-32432(gp)
8110d3b8:	100f883a 	mov	r7,r2
8110d3bc:	018008c4 	movi	r6,35
8110d3c0:	01400044 	movi	r5,1
8110d3c4:	01204534 	movhi	r4,33044
8110d3c8:	21083504 	addi	r4,r4,8404
8110d3cc:	1115d200 	call	81115d20 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
8110d3d0:	e0bffd04 	addi	r2,fp,-12
8110d3d4:	100b883a 	mov	r5,r2
8110d3d8:	01000684 	movi	r4,26
8110d3dc:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d3e0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d3e4:	e0bffc03 	ldbu	r2,-16(fp)
8110d3e8:	10000f1e 	bne	r2,zero,8110d428 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d3ec:	d1205417 	ldw	r4,-32432(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
8110d3f0:	e0fffd17 	ldw	r3,-12(fp)
8110d3f4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d3f8:	188b883a 	add	r5,r3,r2
8110d3fc:	e0bffd17 	ldw	r2,-12(fp)
8110d400:	e0fffe17 	ldw	r3,-8(fp)
8110d404:	d8c00115 	stw	r3,4(sp)
8110d408:	d8800015 	stw	r2,0(sp)
8110d40c:	280f883a 	mov	r7,r5
8110d410:	01a04534 	movhi	r6,33044
8110d414:	31883e04 	addi	r6,r6,8440
8110d418:	01604534 	movhi	r5,33044
8110d41c:	2947fe04 	addi	r5,r5,8184
8110d420:	11156840 	call	81115684 <fprintf>
8110d424:	00000706 	br	8110d444 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
8110d428:	d0a05417 	ldw	r2,-32432(gp)
8110d42c:	100f883a 	mov	r7,r2
8110d430:	01800884 	movi	r6,34
8110d434:	01400044 	movi	r5,1
8110d438:	01204534 	movhi	r4,33044
8110d43c:	21084104 	addi	r4,r4,8452
8110d440:	1115d200 	call	81115d20 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
8110d444:	e0bffd04 	addi	r2,fp,-12
8110d448:	100b883a 	mov	r5,r2
8110d44c:	01000644 	movi	r4,25
8110d450:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d454:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d458:	e0bffc03 	ldbu	r2,-16(fp)
8110d45c:	10000f1e 	bne	r2,zero,8110d49c <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d460:	d1205417 	ldw	r4,-32432(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
8110d464:	e0fffd17 	ldw	r3,-12(fp)
8110d468:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d46c:	188b883a 	add	r5,r3,r2
8110d470:	e0bffd17 	ldw	r2,-12(fp)
8110d474:	e0fffe17 	ldw	r3,-8(fp)
8110d478:	d8c00115 	stw	r3,4(sp)
8110d47c:	d8800015 	stw	r2,0(sp)
8110d480:	280f883a 	mov	r7,r5
8110d484:	01a04534 	movhi	r6,33044
8110d488:	31884a04 	addi	r6,r6,8488
8110d48c:	01604534 	movhi	r5,33044
8110d490:	2947fe04 	addi	r5,r5,8184
8110d494:	11156840 	call	81115684 <fprintf>
8110d498:	00000706 	br	8110d4b8 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
8110d49c:	d0a05417 	ldw	r2,-32432(gp)
8110d4a0:	100f883a 	mov	r7,r2
8110d4a4:	01800884 	movi	r6,34
8110d4a8:	01400044 	movi	r5,1
8110d4ac:	01204534 	movhi	r4,33044
8110d4b0:	21084d04 	addi	r4,r4,8500
8110d4b4:	1115d200 	call	81115d20 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
8110d4b8:	e0bffd04 	addi	r2,fp,-12
8110d4bc:	100b883a 	mov	r5,r2
8110d4c0:	01000044 	movi	r4,1
8110d4c4:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d4c8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d4cc:	e0bffc03 	ldbu	r2,-16(fp)
8110d4d0:	10000f1e 	bne	r2,zero,8110d510 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d4d4:	d1205417 	ldw	r4,-32432(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
8110d4d8:	e0fffd17 	ldw	r3,-12(fp)
8110d4dc:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d4e0:	188b883a 	add	r5,r3,r2
8110d4e4:	e0bffd17 	ldw	r2,-12(fp)
8110d4e8:	e0fffe17 	ldw	r3,-8(fp)
8110d4ec:	d8c00115 	stw	r3,4(sp)
8110d4f0:	d8800015 	stw	r2,0(sp)
8110d4f4:	280f883a 	mov	r7,r5
8110d4f8:	01a04534 	movhi	r6,33044
8110d4fc:	31885604 	addi	r6,r6,8536
8110d500:	01604534 	movhi	r5,33044
8110d504:	2947fe04 	addi	r5,r5,8184
8110d508:	11156840 	call	81115684 <fprintf>
8110d50c:	00000706 	br	8110d52c <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
8110d510:	d0a05417 	ldw	r2,-32432(gp)
8110d514:	100f883a 	mov	r7,r2
8110d518:	01800804 	movi	r6,32
8110d51c:	01400044 	movi	r5,1
8110d520:	01204534 	movhi	r4,33044
8110d524:	21085904 	addi	r4,r4,8548
8110d528:	1115d200 	call	81115d20 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
8110d52c:	e0bffd04 	addi	r2,fp,-12
8110d530:	100b883a 	mov	r5,r2
8110d534:	01000244 	movi	r4,9
8110d538:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d53c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d540:	e0bffc03 	ldbu	r2,-16(fp)
8110d544:	10000f1e 	bne	r2,zero,8110d584 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d548:	d1205417 	ldw	r4,-32432(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
8110d54c:	e0fffd17 	ldw	r3,-12(fp)
8110d550:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d554:	188b883a 	add	r5,r3,r2
8110d558:	e0bffd17 	ldw	r2,-12(fp)
8110d55c:	e0fffe17 	ldw	r3,-8(fp)
8110d560:	d8c00115 	stw	r3,4(sp)
8110d564:	d8800015 	stw	r2,0(sp)
8110d568:	280f883a 	mov	r7,r5
8110d56c:	01a04534 	movhi	r6,33044
8110d570:	31886204 	addi	r6,r6,8584
8110d574:	01604534 	movhi	r5,33044
8110d578:	2947fe04 	addi	r5,r5,8184
8110d57c:	11156840 	call	81115684 <fprintf>
8110d580:	00000706 	br	8110d5a0 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
8110d584:	d0a05417 	ldw	r2,-32432(gp)
8110d588:	100f883a 	mov	r7,r2
8110d58c:	018008c4 	movi	r6,35
8110d590:	01400044 	movi	r5,1
8110d594:	01204534 	movhi	r4,33044
8110d598:	21086504 	addi	r4,r4,8596
8110d59c:	1115d200 	call	81115d20 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
8110d5a0:	e0bffd04 	addi	r2,fp,-12
8110d5a4:	100b883a 	mov	r5,r2
8110d5a8:	01000284 	movi	r4,10
8110d5ac:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d5b0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d5b4:	e0bffc03 	ldbu	r2,-16(fp)
8110d5b8:	10000f1e 	bne	r2,zero,8110d5f8 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d5bc:	d1205417 	ldw	r4,-32432(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
8110d5c0:	e0fffd17 	ldw	r3,-12(fp)
8110d5c4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d5c8:	188b883a 	add	r5,r3,r2
8110d5cc:	e0bffd17 	ldw	r2,-12(fp)
8110d5d0:	e0fffe17 	ldw	r3,-8(fp)
8110d5d4:	d8c00115 	stw	r3,4(sp)
8110d5d8:	d8800015 	stw	r2,0(sp)
8110d5dc:	280f883a 	mov	r7,r5
8110d5e0:	01a04534 	movhi	r6,33044
8110d5e4:	31886e04 	addi	r6,r6,8632
8110d5e8:	01604534 	movhi	r5,33044
8110d5ec:	2947fe04 	addi	r5,r5,8184
8110d5f0:	11156840 	call	81115684 <fprintf>
8110d5f4:	00000706 	br	8110d614 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
8110d5f8:	d0a05417 	ldw	r2,-32432(gp)
8110d5fc:	100f883a 	mov	r7,r2
8110d600:	018008c4 	movi	r6,35
8110d604:	01400044 	movi	r5,1
8110d608:	01204534 	movhi	r4,33044
8110d60c:	21087104 	addi	r4,r4,8644
8110d610:	1115d200 	call	81115d20 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
8110d614:	e0bffd04 	addi	r2,fp,-12
8110d618:	100b883a 	mov	r5,r2
8110d61c:	010002c4 	movi	r4,11
8110d620:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d624:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d628:	e0bffc03 	ldbu	r2,-16(fp)
8110d62c:	10000f1e 	bne	r2,zero,8110d66c <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d630:	d1205417 	ldw	r4,-32432(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
8110d634:	e0fffd17 	ldw	r3,-12(fp)
8110d638:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d63c:	188b883a 	add	r5,r3,r2
8110d640:	e0bffd17 	ldw	r2,-12(fp)
8110d644:	e0fffe17 	ldw	r3,-8(fp)
8110d648:	d8c00115 	stw	r3,4(sp)
8110d64c:	d8800015 	stw	r2,0(sp)
8110d650:	280f883a 	mov	r7,r5
8110d654:	01a04534 	movhi	r6,33044
8110d658:	31887a04 	addi	r6,r6,8680
8110d65c:	01604534 	movhi	r5,33044
8110d660:	2947fe04 	addi	r5,r5,8184
8110d664:	11156840 	call	81115684 <fprintf>
8110d668:	00000706 	br	8110d688 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
8110d66c:	d0a05417 	ldw	r2,-32432(gp)
8110d670:	100f883a 	mov	r7,r2
8110d674:	018008c4 	movi	r6,35
8110d678:	01400044 	movi	r5,1
8110d67c:	01204534 	movhi	r4,33044
8110d680:	21087d04 	addi	r4,r4,8692
8110d684:	1115d200 	call	81115d20 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
8110d688:	e0bffd04 	addi	r2,fp,-12
8110d68c:	100b883a 	mov	r5,r2
8110d690:	01000304 	movi	r4,12
8110d694:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d698:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d69c:	e0bffc03 	ldbu	r2,-16(fp)
8110d6a0:	10000f1e 	bne	r2,zero,8110d6e0 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d6a4:	d1205417 	ldw	r4,-32432(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
8110d6a8:	e0fffd17 	ldw	r3,-12(fp)
8110d6ac:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d6b0:	188b883a 	add	r5,r3,r2
8110d6b4:	e0bffd17 	ldw	r2,-12(fp)
8110d6b8:	e0fffe17 	ldw	r3,-8(fp)
8110d6bc:	d8c00115 	stw	r3,4(sp)
8110d6c0:	d8800015 	stw	r2,0(sp)
8110d6c4:	280f883a 	mov	r7,r5
8110d6c8:	01a04534 	movhi	r6,33044
8110d6cc:	31888604 	addi	r6,r6,8728
8110d6d0:	01604534 	movhi	r5,33044
8110d6d4:	2947fe04 	addi	r5,r5,8184
8110d6d8:	11156840 	call	81115684 <fprintf>
8110d6dc:	00000706 	br	8110d6fc <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
8110d6e0:	d0a05417 	ldw	r2,-32432(gp)
8110d6e4:	100f883a 	mov	r7,r2
8110d6e8:	018008c4 	movi	r6,35
8110d6ec:	01400044 	movi	r5,1
8110d6f0:	01204534 	movhi	r4,33044
8110d6f4:	21088904 	addi	r4,r4,8740
8110d6f8:	1115d200 	call	81115d20 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
8110d6fc:	e0bffd04 	addi	r2,fp,-12
8110d700:	100b883a 	mov	r5,r2
8110d704:	01000344 	movi	r4,13
8110d708:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d70c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d710:	e0bffc03 	ldbu	r2,-16(fp)
8110d714:	10000f1e 	bne	r2,zero,8110d754 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d718:	d1205417 	ldw	r4,-32432(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
8110d71c:	e0fffd17 	ldw	r3,-12(fp)
8110d720:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d724:	188b883a 	add	r5,r3,r2
8110d728:	e0bffd17 	ldw	r2,-12(fp)
8110d72c:	e0fffe17 	ldw	r3,-8(fp)
8110d730:	d8c00115 	stw	r3,4(sp)
8110d734:	d8800015 	stw	r2,0(sp)
8110d738:	280f883a 	mov	r7,r5
8110d73c:	01a04534 	movhi	r6,33044
8110d740:	31889204 	addi	r6,r6,8776
8110d744:	01604534 	movhi	r5,33044
8110d748:	2947fe04 	addi	r5,r5,8184
8110d74c:	11156840 	call	81115684 <fprintf>
8110d750:	00000706 	br	8110d770 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
8110d754:	d0a05417 	ldw	r2,-32432(gp)
8110d758:	100f883a 	mov	r7,r2
8110d75c:	018008c4 	movi	r6,35
8110d760:	01400044 	movi	r5,1
8110d764:	01204534 	movhi	r4,33044
8110d768:	21089504 	addi	r4,r4,8788
8110d76c:	1115d200 	call	81115d20 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
8110d770:	e0bffd04 	addi	r2,fp,-12
8110d774:	100b883a 	mov	r5,r2
8110d778:	01000384 	movi	r4,14
8110d77c:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d780:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d784:	e0bffc03 	ldbu	r2,-16(fp)
8110d788:	10000f1e 	bne	r2,zero,8110d7c8 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d78c:	d1205417 	ldw	r4,-32432(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
8110d790:	e0fffd17 	ldw	r3,-12(fp)
8110d794:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d798:	188b883a 	add	r5,r3,r2
8110d79c:	e0bffd17 	ldw	r2,-12(fp)
8110d7a0:	e0fffe17 	ldw	r3,-8(fp)
8110d7a4:	d8c00115 	stw	r3,4(sp)
8110d7a8:	d8800015 	stw	r2,0(sp)
8110d7ac:	280f883a 	mov	r7,r5
8110d7b0:	01a04534 	movhi	r6,33044
8110d7b4:	31889e04 	addi	r6,r6,8824
8110d7b8:	01604534 	movhi	r5,33044
8110d7bc:	2947fe04 	addi	r5,r5,8184
8110d7c0:	11156840 	call	81115684 <fprintf>
8110d7c4:	00000706 	br	8110d7e4 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
8110d7c8:	d0a05417 	ldw	r2,-32432(gp)
8110d7cc:	100f883a 	mov	r7,r2
8110d7d0:	018008c4 	movi	r6,35
8110d7d4:	01400044 	movi	r5,1
8110d7d8:	01204534 	movhi	r4,33044
8110d7dc:	2108a104 	addi	r4,r4,8836
8110d7e0:	1115d200 	call	81115d20 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
8110d7e4:	e0bffd04 	addi	r2,fp,-12
8110d7e8:	100b883a 	mov	r5,r2
8110d7ec:	01000204 	movi	r4,8
8110d7f0:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d7f4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d7f8:	e0bffc03 	ldbu	r2,-16(fp)
8110d7fc:	10000f1e 	bne	r2,zero,8110d83c <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d800:	d1205417 	ldw	r4,-32432(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
8110d804:	e0fffd17 	ldw	r3,-12(fp)
8110d808:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d80c:	188b883a 	add	r5,r3,r2
8110d810:	e0bffd17 	ldw	r2,-12(fp)
8110d814:	e0fffe17 	ldw	r3,-8(fp)
8110d818:	d8c00115 	stw	r3,4(sp)
8110d81c:	d8800015 	stw	r2,0(sp)
8110d820:	280f883a 	mov	r7,r5
8110d824:	01a04534 	movhi	r6,33044
8110d828:	3188aa04 	addi	r6,r6,8872
8110d82c:	01604534 	movhi	r5,33044
8110d830:	2947fe04 	addi	r5,r5,8184
8110d834:	11156840 	call	81115684 <fprintf>
8110d838:	00000706 	br	8110d858 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
8110d83c:	d0a05417 	ldw	r2,-32432(gp)
8110d840:	100f883a 	mov	r7,r2
8110d844:	01800884 	movi	r6,34
8110d848:	01400044 	movi	r5,1
8110d84c:	01204534 	movhi	r4,33044
8110d850:	2108ad04 	addi	r4,r4,8884
8110d854:	1115d200 	call	81115d20 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
8110d858:	e0bffd04 	addi	r2,fp,-12
8110d85c:	100b883a 	mov	r5,r2
8110d860:	010001c4 	movi	r4,7
8110d864:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d868:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d86c:	e0bffc03 	ldbu	r2,-16(fp)
8110d870:	10000f1e 	bne	r2,zero,8110d8b0 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d874:	d1205417 	ldw	r4,-32432(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
8110d878:	e0fffd17 	ldw	r3,-12(fp)
8110d87c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d880:	188b883a 	add	r5,r3,r2
8110d884:	e0bffd17 	ldw	r2,-12(fp)
8110d888:	e0fffe17 	ldw	r3,-8(fp)
8110d88c:	d8c00115 	stw	r3,4(sp)
8110d890:	d8800015 	stw	r2,0(sp)
8110d894:	280f883a 	mov	r7,r5
8110d898:	01a04534 	movhi	r6,33044
8110d89c:	3188b604 	addi	r6,r6,8920
8110d8a0:	01604534 	movhi	r5,33044
8110d8a4:	2947fe04 	addi	r5,r5,8184
8110d8a8:	11156840 	call	81115684 <fprintf>
8110d8ac:	00000706 	br	8110d8cc <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
8110d8b0:	d0a05417 	ldw	r2,-32432(gp)
8110d8b4:	100f883a 	mov	r7,r2
8110d8b8:	01800844 	movi	r6,33
8110d8bc:	01400044 	movi	r5,1
8110d8c0:	01204534 	movhi	r4,33044
8110d8c4:	2108b904 	addi	r4,r4,8932
8110d8c8:	1115d200 	call	81115d20 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
8110d8cc:	e0bffd04 	addi	r2,fp,-12
8110d8d0:	100b883a 	mov	r5,r2
8110d8d4:	01000184 	movi	r4,6
8110d8d8:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8110d8dc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110d8e0:	e0bffc03 	ldbu	r2,-16(fp)
8110d8e4:	10000f1e 	bne	r2,zero,8110d924 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d8e8:	d1205417 	ldw	r4,-32432(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
8110d8ec:	e0fffd17 	ldw	r3,-12(fp)
8110d8f0:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110d8f4:	188b883a 	add	r5,r3,r2
8110d8f8:	e0bffd17 	ldw	r2,-12(fp)
8110d8fc:	e0fffe17 	ldw	r3,-8(fp)
8110d900:	d8c00115 	stw	r3,4(sp)
8110d904:	d8800015 	stw	r2,0(sp)
8110d908:	280f883a 	mov	r7,r5
8110d90c:	01a04534 	movhi	r6,33044
8110d910:	3188c204 	addi	r6,r6,8968
8110d914:	01604534 	movhi	r5,33044
8110d918:	2947fe04 	addi	r5,r5,8184
8110d91c:	11156840 	call	81115684 <fprintf>
8110d920:	00000706 	br	8110d940 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
8110d924:	d0a05417 	ldw	r2,-32432(gp)
8110d928:	100f883a 	mov	r7,r2
8110d92c:	018007c4 	movi	r6,31
8110d930:	01400044 	movi	r5,1
8110d934:	01204534 	movhi	r4,33044
8110d938:	2108c504 	addi	r4,r4,8980
8110d93c:	1115d200 	call	81115d20 <fwrite>
    	}		


    	fprintf(fp, "\n" );
8110d940:	d0a05417 	ldw	r2,-32432(gp)
8110d944:	100b883a 	mov	r5,r2
8110d948:	01000284 	movi	r4,10
8110d94c:	11156fc0 	call	811156fc <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
8110d950:	000f883a 	mov	r7,zero
8110d954:	01800284 	movi	r6,10
8110d958:	000b883a 	mov	r5,zero
8110d95c:	0009883a 	mov	r4,zero
8110d960:	11355440 	call	81135544 <OSTimeDlyHMSM>
    }
8110d964:	003e1806 	br	8110d1c8 <__reset+0xfb0ed1c8>

8110d968 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
8110d968:	defffc04 	addi	sp,sp,-16
8110d96c:	de00012e 	bgeu	sp,et,8110d974 <vTimeoutCheckerTaskv2+0xc>
8110d970:	003b68fa 	trap	3
8110d974:	dfc00315 	stw	ra,12(sp)
8110d978:	df000215 	stw	fp,8(sp)
8110d97c:	df000204 	addi	fp,sp,8
8110d980:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
8110d984:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
8110d988:	d0a05417 	ldw	r2,-32432(gp)
8110d98c:	100f883a 	mov	r7,r2
8110d990:	01800844 	movi	r6,33
8110d994:	01400044 	movi	r5,1
8110d998:	01204534 	movhi	r4,33044
8110d99c:	2108cd04 	addi	r4,r4,9012
8110d9a0:	1115d200 	call	81115d20 <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
8110d9a4:	d0a05917 	ldw	r2,-32412(gp)
8110d9a8:	e1bffe04 	addi	r6,fp,-8
8110d9ac:	000b883a 	mov	r5,zero
8110d9b0:	1009883a 	mov	r4,r2
8110d9b4:	11337600 	call	81133760 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
8110d9b8:	e0bffe03 	ldbu	r2,-8(fp)
8110d9bc:	10803fcc 	andi	r2,r2,255
8110d9c0:	1000021e 	bne	r2,zero,8110d9cc <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
8110d9c4:	110d9d40 	call	8110d9d4 <vCheck>
8110d9c8:	003ff606 	br	8110d9a4 <__reset+0xfb0ed9a4>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
8110d9cc:	1111e400 	call	81111e40 <vFailGetBlockingSemTimeoutTask>
        }
    }
8110d9d0:	003ff406 	br	8110d9a4 <__reset+0xfb0ed9a4>

8110d9d4 <vCheck>:
}


void vCheck( void ) {
8110d9d4:	defffd04 	addi	sp,sp,-12
8110d9d8:	de00012e 	bgeu	sp,et,8110d9e0 <vCheck+0xc>
8110d9dc:	003b68fa 	trap	3
8110d9e0:	dfc00215 	stw	ra,8(sp)
8110d9e4:	df000115 	stw	fp,4(sp)
8110d9e8:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
8110d9ec:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
8110d9f0:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
8110d9f4:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8110d9f8:	d0a05a83 	ldbu	r2,-32406(gp)
8110d9fc:	10803fcc 	andi	r2,r2,255
8110da00:	10800218 	cmpnei	r2,r2,8
8110da04:	1000021e 	bne	r2,zero,8110da10 <vCheck+0x3c>
8110da08:	00c00104 	movi	r3,4
8110da0c:	00000106 	br	8110da14 <vCheck+0x40>
8110da10:	0007883a 	mov	r3,zero
8110da14:	d0a06503 	ldbu	r2,-32364(gp)
8110da18:	10803fcc 	andi	r2,r2,255
8110da1c:	10800218 	cmpnei	r2,r2,8
8110da20:	1000021e 	bne	r2,zero,8110da2c <vCheck+0x58>
8110da24:	00800084 	movi	r2,2
8110da28:	00000106 	br	8110da30 <vCheck+0x5c>
8110da2c:	0005883a 	mov	r2,zero
8110da30:	1884b03a 	or	r2,r3,r2
8110da34:	1007883a 	mov	r3,r2
8110da38:	d0a06543 	ldbu	r2,-32363(gp)
8110da3c:	10803fcc 	andi	r2,r2,255
8110da40:	108001a0 	cmpeqi	r2,r2,6
8110da44:	1884b03a 	or	r2,r3,r2
8110da48:	1007883a 	mov	r3,r2
8110da4c:	e0bfff03 	ldbu	r2,-4(fp)
8110da50:	1884b03a 	or	r2,r3,r2
8110da54:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
8110da58:	e0bfff03 	ldbu	r2,-4(fp)
8110da5c:	108001d8 	cmpnei	r2,r2,7
8110da60:	10003726 	beq	r2,zero,8110db40 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
8110da64:	d0a06417 	ldw	r2,-32368(gp)
8110da68:	e0ffff44 	addi	r3,fp,-3
8110da6c:	180d883a 	mov	r6,r3
8110da70:	000b883a 	mov	r5,zero
8110da74:	1009883a 	mov	r4,r2
8110da78:	11317540 	call	81131754 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
8110da7c:	e0bfff43 	ldbu	r2,-3(fp)
8110da80:	10803fcc 	andi	r2,r2,255
8110da84:	10000826 	beq	r2,zero,8110daa8 <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
8110da88:	d0a05417 	ldw	r2,-32432(gp)
8110da8c:	100f883a 	mov	r7,r2
8110da90:	01800f04 	movi	r6,60
8110da94:	01400044 	movi	r5,1
8110da98:	01204534 	movhi	r4,33044
8110da9c:	2108d604 	addi	r4,r4,9048
8110daa0:	1115d200 	call	81115d20 <fwrite>
		#endif
        return;
8110daa4:	00002706 	br	8110db44 <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8110daa8:	e0bfff03 	ldbu	r2,-4(fp)
8110daac:	1080004c 	andi	r2,r2,1
8110dab0:	10803fcc 	andi	r2,r2,255
8110dab4:	1000021e 	bne	r2,zero,8110dac0 <vCheck+0xec>
        vCheckRetransmission128();
8110dab8:	110db580 	call	8110db58 <vCheckRetransmission128>
8110dabc:	00000506 	br	8110dad4 <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
8110dac0:	01800604 	movi	r6,24
8110dac4:	000b883a 	mov	r5,zero
8110dac8:	01204574 	movhi	r4,33045
8110dacc:	2109d604 	addi	r4,r4,10072
8110dad0:	11168840 	call	81116884 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
8110dad4:	e0bfff03 	ldbu	r2,-4(fp)
8110dad8:	1080008c 	andi	r2,r2,2
8110dadc:	10803fcc 	andi	r2,r2,255
8110dae0:	1000021e 	bne	r2,zero,8110daec <vCheck+0x118>
        vCheckRetransmission64();
8110dae4:	110dddc0 	call	8110dddc <vCheckRetransmission64>
8110dae8:	00000506 	br	8110db00 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
8110daec:	01800804 	movi	r6,32
8110daf0:	000b883a 	mov	r5,zero
8110daf4:	01204574 	movhi	r4,33045
8110daf8:	2109dc04 	addi	r4,r4,10096
8110dafc:	11168840 	call	81116884 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
8110db00:	e0bfff03 	ldbu	r2,-4(fp)
8110db04:	1080010c 	andi	r2,r2,4
8110db08:	10803fcc 	andi	r2,r2,255
8110db0c:	1000021e 	bne	r2,zero,8110db18 <vCheck+0x144>
        vCheckRetransmission32();
8110db10:	110e0680 	call	8110e068 <vCheckRetransmission32>
8110db14:	00000506 	br	8110db2c <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
8110db18:	01800804 	movi	r6,32
8110db1c:	000b883a 	mov	r5,zero
8110db20:	01204574 	movhi	r4,33045
8110db24:	2109e404 	addi	r4,r4,10128
8110db28:	11168840 	call	81116884 <memset>


    OSMutexPost(xTxUARTMutex);
8110db2c:	d0a06417 	ldw	r2,-32368(gp)
8110db30:	1009883a 	mov	r4,r2
8110db34:	1131cf80 	call	81131cf8 <OSMutexPost>

    return;
8110db38:	0001883a 	nop
8110db3c:	00000106 	br	8110db44 <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
8110db40:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
8110db44:	e037883a 	mov	sp,fp
8110db48:	dfc00117 	ldw	ra,4(sp)
8110db4c:	df000017 	ldw	fp,0(sp)
8110db50:	dec00204 	addi	sp,sp,8
8110db54:	f800283a 	ret

8110db58 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
8110db58:	defffd04 	addi	sp,sp,-12
8110db5c:	de00012e 	bgeu	sp,et,8110db64 <vCheckRetransmission128+0xc>
8110db60:	003b68fa 	trap	3
8110db64:	dfc00215 	stw	ra,8(sp)
8110db68:	df000115 	stw	fp,4(sp)
8110db6c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8110db70:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
8110db74:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8110db78:	d0a05f17 	ldw	r2,-32388(gp)
8110db7c:	e0ffff44 	addi	r3,fp,-3
8110db80:	180b883a 	mov	r5,r3
8110db84:	1009883a 	mov	r4,r2
8110db88:	11310d40 	call	811310d4 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8110db8c:	e0bfff43 	ldbu	r2,-3(fp)
8110db90:	10803fcc 	andi	r2,r2,255
8110db94:	10008b1e 	bne	r2,zero,8110ddc4 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
8110db98:	e03fff05 	stb	zero,-4(fp)
8110db9c:	00008106 	br	8110dda4 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
8110dba0:	e0ffff03 	ldbu	r3,-4(fp)
8110dba4:	00a04574 	movhi	r2,33045
8110dba8:	1089d604 	addi	r2,r2,10072
8110dbac:	18c7883a 	add	r3,r3,r3
8110dbb0:	18c7883a 	add	r3,r3,r3
8110dbb4:	10c5883a 	add	r2,r2,r3
8110dbb8:	10800017 	ldw	r2,0(r2)
8110dbbc:	10800058 	cmpnei	r2,r2,1
8110dbc0:	1000751e 	bne	r2,zero,8110dd98 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
8110dbc4:	e0ffff03 	ldbu	r3,-4(fp)
8110dbc8:	00a04574 	movhi	r2,33045
8110dbcc:	1089f404 	addi	r2,r2,10192
8110dbd0:	18c02324 	muli	r3,r3,140
8110dbd4:	10c5883a 	add	r2,r2,r3
8110dbd8:	10802004 	addi	r2,r2,128
8110dbdc:	10800017 	ldw	r2,0(r2)
8110dbe0:	10800058 	cmpnei	r2,r2,1
8110dbe4:	1000211e 	bne	r2,zero,8110dc6c <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
8110dbe8:	e0ffff03 	ldbu	r3,-4(fp)
8110dbec:	00a04574 	movhi	r2,33045
8110dbf0:	1089f404 	addi	r2,r2,10192
8110dbf4:	19002324 	muli	r4,r3,140
8110dbf8:	1105883a 	add	r2,r2,r4
8110dbfc:	10802184 	addi	r2,r2,134
8110dc00:	1080000b 	ldhu	r2,0(r2)
8110dc04:	10800044 	addi	r2,r2,1
8110dc08:	100b883a 	mov	r5,r2
8110dc0c:	00a04574 	movhi	r2,33045
8110dc10:	1089f404 	addi	r2,r2,10192
8110dc14:	19002324 	muli	r4,r3,140
8110dc18:	1105883a 	add	r2,r2,r4
8110dc1c:	10802184 	addi	r2,r2,134
8110dc20:	1140000d 	sth	r5,0(r2)
8110dc24:	00a04574 	movhi	r2,33045
8110dc28:	1089f404 	addi	r2,r2,10192
8110dc2c:	18c02324 	muli	r3,r3,140
8110dc30:	10c5883a 	add	r2,r2,r3
8110dc34:	10802184 	addi	r2,r2,134
8110dc38:	1080000b 	ldhu	r2,0(r2)
8110dc3c:	10bfffcc 	andi	r2,r2,65535
8110dc40:	10a0001c 	xori	r2,r2,32768
8110dc44:	10a00004 	addi	r2,r2,-32768
8110dc48:	10800090 	cmplti	r2,r2,2
8110dc4c:	1000071e 	bne	r2,zero,8110dc6c <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
8110dc50:	e0ffff03 	ldbu	r3,-4(fp)
8110dc54:	00a04574 	movhi	r2,33045
8110dc58:	1089f404 	addi	r2,r2,10192
8110dc5c:	18c02324 	muli	r3,r3,140
8110dc60:	10c5883a 	add	r2,r2,r3
8110dc64:	10802004 	addi	r2,r2,128
8110dc68:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
8110dc6c:	e0ffff03 	ldbu	r3,-4(fp)
8110dc70:	00a04574 	movhi	r2,33045
8110dc74:	1089f404 	addi	r2,r2,10192
8110dc78:	18c02324 	muli	r3,r3,140
8110dc7c:	10c5883a 	add	r2,r2,r3
8110dc80:	10802004 	addi	r2,r2,128
8110dc84:	10800017 	ldw	r2,0(r2)
8110dc88:	1000431e 	bne	r2,zero,8110dd98 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
8110dc8c:	e0bfff03 	ldbu	r2,-4(fp)
8110dc90:	10c02324 	muli	r3,r2,140
8110dc94:	00a04574 	movhi	r2,33045
8110dc98:	1089f404 	addi	r2,r2,10192
8110dc9c:	1885883a 	add	r2,r3,r2
8110dca0:	1009883a 	mov	r4,r2
8110dca4:	1116cd00 	call	81116cd0 <puts>
                xBuffer128[ucIL].bSent = TRUE;
8110dca8:	e0ffff03 	ldbu	r3,-4(fp)
8110dcac:	00a04574 	movhi	r2,33045
8110dcb0:	1089f404 	addi	r2,r2,10192
8110dcb4:	18c02324 	muli	r3,r3,140
8110dcb8:	10c5883a 	add	r2,r2,r3
8110dcbc:	10802004 	addi	r2,r2,128
8110dcc0:	00c00044 	movi	r3,1
8110dcc4:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
8110dcc8:	e0ffff03 	ldbu	r3,-4(fp)
8110dccc:	00a04574 	movhi	r2,33045
8110dcd0:	1089f404 	addi	r2,r2,10192
8110dcd4:	18c02324 	muli	r3,r3,140
8110dcd8:	10c5883a 	add	r2,r2,r3
8110dcdc:	10802184 	addi	r2,r2,134
8110dce0:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8110dce4:	e0ffff03 	ldbu	r3,-4(fp)
8110dce8:	00a04574 	movhi	r2,33045
8110dcec:	1089f404 	addi	r2,r2,10192
8110dcf0:	19002324 	muli	r4,r3,140
8110dcf4:	1105883a 	add	r2,r2,r4
8110dcf8:	10802204 	addi	r2,r2,136
8110dcfc:	10800003 	ldbu	r2,0(r2)
8110dd00:	10800044 	addi	r2,r2,1
8110dd04:	100b883a 	mov	r5,r2
8110dd08:	00a04574 	movhi	r2,33045
8110dd0c:	1089f404 	addi	r2,r2,10192
8110dd10:	19002324 	muli	r4,r3,140
8110dd14:	1105883a 	add	r2,r2,r4
8110dd18:	10802204 	addi	r2,r2,136
8110dd1c:	11400005 	stb	r5,0(r2)
8110dd20:	00a04574 	movhi	r2,33045
8110dd24:	1089f404 	addi	r2,r2,10192
8110dd28:	18c02324 	muli	r3,r3,140
8110dd2c:	10c5883a 	add	r2,r2,r3
8110dd30:	10802204 	addi	r2,r2,136
8110dd34:	10800003 	ldbu	r2,0(r2)
8110dd38:	10803fcc 	andi	r2,r2,255
8110dd3c:	108000b0 	cmpltui	r2,r2,2
8110dd40:	1000151e 	bne	r2,zero,8110dd98 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
8110dd44:	e0ffff03 	ldbu	r3,-4(fp)
8110dd48:	00a04574 	movhi	r2,33045
8110dd4c:	1089d604 	addi	r2,r2,10072
8110dd50:	18c7883a 	add	r3,r3,r3
8110dd54:	18c7883a 	add	r3,r3,r3
8110dd58:	10c5883a 	add	r2,r2,r3
8110dd5c:	10000015 	stw	zero,0(r2)
                    SemCount128++;
8110dd60:	d0a06543 	ldbu	r2,-32363(gp)
8110dd64:	10800044 	addi	r2,r2,1
8110dd68:	d0a06545 	stb	r2,-32363(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
8110dd6c:	d0a05517 	ldw	r2,-32428(gp)
8110dd70:	1009883a 	mov	r4,r2
8110dd74:	1133ae80 	call	81133ae8 <OSSemPost>
8110dd78:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8110dd7c:	e0bfff43 	ldbu	r2,-3(fp)
8110dd80:	10803fcc 	andi	r2,r2,255
8110dd84:	10000426 	beq	r2,zero,8110dd98 <vCheckRetransmission128+0x240>
                        SemCount128--;
8110dd88:	d0a06543 	ldbu	r2,-32363(gp)
8110dd8c:	10bfffc4 	addi	r2,r2,-1
8110dd90:	d0a06545 	stb	r2,-32363(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8110dd94:	11117300 	call	81111730 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
8110dd98:	e0bfff03 	ldbu	r2,-4(fp)
8110dd9c:	10800044 	addi	r2,r2,1
8110dda0:	e0bfff05 	stb	r2,-4(fp)
8110dda4:	e0bfff03 	ldbu	r2,-4(fp)
8110dda8:	108001b0 	cmpltui	r2,r2,6
8110ddac:	103f7c1e 	bne	r2,zero,8110dba0 <__reset+0xfb0edba0>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
8110ddb0:	d0a05f17 	ldw	r2,-32388(gp)
8110ddb4:	1009883a 	mov	r4,r2
8110ddb8:	1131cf80 	call	81131cf8 <OSMutexPost>

    return;
8110ddbc:	0001883a 	nop
8110ddc0:	00000106 	br	8110ddc8 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8110ddc4:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
8110ddc8:	e037883a 	mov	sp,fp
8110ddcc:	dfc00117 	ldw	ra,4(sp)
8110ddd0:	df000017 	ldw	fp,0(sp)
8110ddd4:	dec00204 	addi	sp,sp,8
8110ddd8:	f800283a 	ret

8110dddc <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
8110dddc:	defffd04 	addi	sp,sp,-12
8110dde0:	de00012e 	bgeu	sp,et,8110dde8 <vCheckRetransmission64+0xc>
8110dde4:	003b68fa 	trap	3
8110dde8:	dfc00215 	stw	ra,8(sp)
8110ddec:	df000115 	stw	fp,4(sp)
8110ddf0:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8110ddf4:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
8110ddf8:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8110ddfc:	d0a06117 	ldw	r2,-32380(gp)
8110de00:	e0ffff44 	addi	r3,fp,-3
8110de04:	180b883a 	mov	r5,r3
8110de08:	1009883a 	mov	r4,r2
8110de0c:	11310d40 	call	811310d4 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8110de10:	e0bfff43 	ldbu	r2,-3(fp)
8110de14:	10803fcc 	andi	r2,r2,255
8110de18:	10008d1e 	bne	r2,zero,8110e050 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
8110de1c:	e03fff05 	stb	zero,-4(fp)
8110de20:	00008306 	br	8110e030 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
8110de24:	e0ffff03 	ldbu	r3,-4(fp)
8110de28:	00a04574 	movhi	r2,33045
8110de2c:	1089d604 	addi	r2,r2,10072
8110de30:	18c00184 	addi	r3,r3,6
8110de34:	18c7883a 	add	r3,r3,r3
8110de38:	18c7883a 	add	r3,r3,r3
8110de3c:	10c5883a 	add	r2,r2,r3
8110de40:	10800017 	ldw	r2,0(r2)
8110de44:	10800058 	cmpnei	r2,r2,1
8110de48:	1000761e 	bne	r2,zero,8110e024 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
8110de4c:	e0ffff03 	ldbu	r3,-4(fp)
8110de50:	00a04574 	movhi	r2,33045
8110de54:	10a53f04 	addi	r2,r2,-27396
8110de58:	18c01324 	muli	r3,r3,76
8110de5c:	10c5883a 	add	r2,r2,r3
8110de60:	10801004 	addi	r2,r2,64
8110de64:	10800017 	ldw	r2,0(r2)
8110de68:	10800058 	cmpnei	r2,r2,1
8110de6c:	1000211e 	bne	r2,zero,8110def4 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
8110de70:	e0ffff03 	ldbu	r3,-4(fp)
8110de74:	00a04574 	movhi	r2,33045
8110de78:	10a53f04 	addi	r2,r2,-27396
8110de7c:	19001324 	muli	r4,r3,76
8110de80:	1105883a 	add	r2,r2,r4
8110de84:	10801184 	addi	r2,r2,70
8110de88:	1080000b 	ldhu	r2,0(r2)
8110de8c:	10800044 	addi	r2,r2,1
8110de90:	100b883a 	mov	r5,r2
8110de94:	00a04574 	movhi	r2,33045
8110de98:	10a53f04 	addi	r2,r2,-27396
8110de9c:	19001324 	muli	r4,r3,76
8110dea0:	1105883a 	add	r2,r2,r4
8110dea4:	10801184 	addi	r2,r2,70
8110dea8:	1140000d 	sth	r5,0(r2)
8110deac:	00a04574 	movhi	r2,33045
8110deb0:	10a53f04 	addi	r2,r2,-27396
8110deb4:	18c01324 	muli	r3,r3,76
8110deb8:	10c5883a 	add	r2,r2,r3
8110debc:	10801184 	addi	r2,r2,70
8110dec0:	1080000b 	ldhu	r2,0(r2)
8110dec4:	10bfffcc 	andi	r2,r2,65535
8110dec8:	10a0001c 	xori	r2,r2,32768
8110decc:	10a00004 	addi	r2,r2,-32768
8110ded0:	10800090 	cmplti	r2,r2,2
8110ded4:	1000071e 	bne	r2,zero,8110def4 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
8110ded8:	e0ffff03 	ldbu	r3,-4(fp)
8110dedc:	00a04574 	movhi	r2,33045
8110dee0:	10a53f04 	addi	r2,r2,-27396
8110dee4:	18c01324 	muli	r3,r3,76
8110dee8:	10c5883a 	add	r2,r2,r3
8110deec:	10801004 	addi	r2,r2,64
8110def0:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
8110def4:	e0ffff03 	ldbu	r3,-4(fp)
8110def8:	00a04574 	movhi	r2,33045
8110defc:	10a53f04 	addi	r2,r2,-27396
8110df00:	18c01324 	muli	r3,r3,76
8110df04:	10c5883a 	add	r2,r2,r3
8110df08:	10801004 	addi	r2,r2,64
8110df0c:	10800017 	ldw	r2,0(r2)
8110df10:	1000441e 	bne	r2,zero,8110e024 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
8110df14:	e0bfff03 	ldbu	r2,-4(fp)
8110df18:	10c01324 	muli	r3,r2,76
8110df1c:	00a04574 	movhi	r2,33045
8110df20:	10a53f04 	addi	r2,r2,-27396
8110df24:	1885883a 	add	r2,r3,r2
8110df28:	1009883a 	mov	r4,r2
8110df2c:	1116cd00 	call	81116cd0 <puts>
                xBuffer64[ucIL].bSent = TRUE;
8110df30:	e0ffff03 	ldbu	r3,-4(fp)
8110df34:	00a04574 	movhi	r2,33045
8110df38:	10a53f04 	addi	r2,r2,-27396
8110df3c:	18c01324 	muli	r3,r3,76
8110df40:	10c5883a 	add	r2,r2,r3
8110df44:	10801004 	addi	r2,r2,64
8110df48:	00c00044 	movi	r3,1
8110df4c:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
8110df50:	e0ffff03 	ldbu	r3,-4(fp)
8110df54:	00a04574 	movhi	r2,33045
8110df58:	10a53f04 	addi	r2,r2,-27396
8110df5c:	18c01324 	muli	r3,r3,76
8110df60:	10c5883a 	add	r2,r2,r3
8110df64:	10801184 	addi	r2,r2,70
8110df68:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8110df6c:	e0ffff03 	ldbu	r3,-4(fp)
8110df70:	00a04574 	movhi	r2,33045
8110df74:	10a53f04 	addi	r2,r2,-27396
8110df78:	19001324 	muli	r4,r3,76
8110df7c:	1105883a 	add	r2,r2,r4
8110df80:	10801204 	addi	r2,r2,72
8110df84:	10800003 	ldbu	r2,0(r2)
8110df88:	10800044 	addi	r2,r2,1
8110df8c:	100b883a 	mov	r5,r2
8110df90:	00a04574 	movhi	r2,33045
8110df94:	10a53f04 	addi	r2,r2,-27396
8110df98:	19001324 	muli	r4,r3,76
8110df9c:	1105883a 	add	r2,r2,r4
8110dfa0:	10801204 	addi	r2,r2,72
8110dfa4:	11400005 	stb	r5,0(r2)
8110dfa8:	00a04574 	movhi	r2,33045
8110dfac:	10a53f04 	addi	r2,r2,-27396
8110dfb0:	18c01324 	muli	r3,r3,76
8110dfb4:	10c5883a 	add	r2,r2,r3
8110dfb8:	10801204 	addi	r2,r2,72
8110dfbc:	10800003 	ldbu	r2,0(r2)
8110dfc0:	10803fcc 	andi	r2,r2,255
8110dfc4:	108000b0 	cmpltui	r2,r2,2
8110dfc8:	1000161e 	bne	r2,zero,8110e024 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
8110dfcc:	e0ffff03 	ldbu	r3,-4(fp)
8110dfd0:	00a04574 	movhi	r2,33045
8110dfd4:	1089d604 	addi	r2,r2,10072
8110dfd8:	18c00184 	addi	r3,r3,6
8110dfdc:	18c7883a 	add	r3,r3,r3
8110dfe0:	18c7883a 	add	r3,r3,r3
8110dfe4:	10c5883a 	add	r2,r2,r3
8110dfe8:	10000015 	stw	zero,0(r2)
                    SemCount64++;
8110dfec:	d0a06503 	ldbu	r2,-32364(gp)
8110dff0:	10800044 	addi	r2,r2,1
8110dff4:	d0a06505 	stb	r2,-32364(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
8110dff8:	d0a05117 	ldw	r2,-32444(gp)
8110dffc:	1009883a 	mov	r4,r2
8110e000:	1133ae80 	call	81133ae8 <OSSemPost>
8110e004:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8110e008:	e0bfff43 	ldbu	r2,-3(fp)
8110e00c:	10803fcc 	andi	r2,r2,255
8110e010:	10000426 	beq	r2,zero,8110e024 <vCheckRetransmission64+0x248>
                        SemCount64--;
8110e014:	d0a06503 	ldbu	r2,-32364(gp)
8110e018:	10bfffc4 	addi	r2,r2,-1
8110e01c:	d0a06505 	stb	r2,-32364(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8110e020:	11116c80 	call	811116c8 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
8110e024:	e0bfff03 	ldbu	r2,-4(fp)
8110e028:	10800044 	addi	r2,r2,1
8110e02c:	e0bfff05 	stb	r2,-4(fp)
8110e030:	e0bfff03 	ldbu	r2,-4(fp)
8110e034:	10800230 	cmpltui	r2,r2,8
8110e038:	103f7a1e 	bne	r2,zero,8110de24 <__reset+0xfb0ede24>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
8110e03c:	d0a06117 	ldw	r2,-32380(gp)
8110e040:	1009883a 	mov	r4,r2
8110e044:	1131cf80 	call	81131cf8 <OSMutexPost>

    return;
8110e048:	0001883a 	nop
8110e04c:	00000106 	br	8110e054 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8110e050:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
8110e054:	e037883a 	mov	sp,fp
8110e058:	dfc00117 	ldw	ra,4(sp)
8110e05c:	df000017 	ldw	fp,0(sp)
8110e060:	dec00204 	addi	sp,sp,8
8110e064:	f800283a 	ret

8110e068 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
8110e068:	defffd04 	addi	sp,sp,-12
8110e06c:	de00012e 	bgeu	sp,et,8110e074 <vCheckRetransmission32+0xc>
8110e070:	003b68fa 	trap	3
8110e074:	dfc00215 	stw	ra,8(sp)
8110e078:	df000115 	stw	fp,4(sp)
8110e07c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8110e080:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
8110e084:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
8110e088:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8110e08c:	d0a05d17 	ldw	r2,-32396(gp)
8110e090:	e0ffff84 	addi	r3,fp,-2
8110e094:	180b883a 	mov	r5,r3
8110e098:	1009883a 	mov	r4,r2
8110e09c:	11310d40 	call	811310d4 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8110e0a0:	e0bfff83 	ldbu	r2,-2(fp)
8110e0a4:	10803fcc 	andi	r2,r2,255
8110e0a8:	10009b1e 	bne	r2,zero,8110e318 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
8110e0ac:	e03fff05 	stb	zero,-4(fp)
8110e0b0:	00009106 	br	8110e2f8 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
8110e0b4:	e0ffff03 	ldbu	r3,-4(fp)
8110e0b8:	00a04574 	movhi	r2,33045
8110e0bc:	1089d604 	addi	r2,r2,10072
8110e0c0:	18c00384 	addi	r3,r3,14
8110e0c4:	18c7883a 	add	r3,r3,r3
8110e0c8:	18c7883a 	add	r3,r3,r3
8110e0cc:	10c5883a 	add	r2,r2,r3
8110e0d0:	10800017 	ldw	r2,0(r2)
8110e0d4:	10800058 	cmpnei	r2,r2,1
8110e0d8:	1000841e 	bne	r2,zero,8110e2ec <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
8110e0dc:	e0ffff03 	ldbu	r3,-4(fp)
8110e0e0:	00a04574 	movhi	r2,33045
8110e0e4:	10b76a04 	addi	r2,r2,-8792
8110e0e8:	18c00b24 	muli	r3,r3,44
8110e0ec:	10c5883a 	add	r2,r2,r3
8110e0f0:	10800804 	addi	r2,r2,32
8110e0f4:	10800017 	ldw	r2,0(r2)
8110e0f8:	10800058 	cmpnei	r2,r2,1
8110e0fc:	1000211e 	bne	r2,zero,8110e184 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
8110e100:	e0ffff03 	ldbu	r3,-4(fp)
8110e104:	00a04574 	movhi	r2,33045
8110e108:	10b76a04 	addi	r2,r2,-8792
8110e10c:	19000b24 	muli	r4,r3,44
8110e110:	1105883a 	add	r2,r2,r4
8110e114:	10800984 	addi	r2,r2,38
8110e118:	1080000b 	ldhu	r2,0(r2)
8110e11c:	10800044 	addi	r2,r2,1
8110e120:	100b883a 	mov	r5,r2
8110e124:	00a04574 	movhi	r2,33045
8110e128:	10b76a04 	addi	r2,r2,-8792
8110e12c:	19000b24 	muli	r4,r3,44
8110e130:	1105883a 	add	r2,r2,r4
8110e134:	10800984 	addi	r2,r2,38
8110e138:	1140000d 	sth	r5,0(r2)
8110e13c:	00a04574 	movhi	r2,33045
8110e140:	10b76a04 	addi	r2,r2,-8792
8110e144:	18c00b24 	muli	r3,r3,44
8110e148:	10c5883a 	add	r2,r2,r3
8110e14c:	10800984 	addi	r2,r2,38
8110e150:	1080000b 	ldhu	r2,0(r2)
8110e154:	10bfffcc 	andi	r2,r2,65535
8110e158:	10a0001c 	xori	r2,r2,32768
8110e15c:	10a00004 	addi	r2,r2,-32768
8110e160:	10800090 	cmplti	r2,r2,2
8110e164:	1000071e 	bne	r2,zero,8110e184 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
8110e168:	e0ffff03 	ldbu	r3,-4(fp)
8110e16c:	00a04574 	movhi	r2,33045
8110e170:	10b76a04 	addi	r2,r2,-8792
8110e174:	18c00b24 	muli	r3,r3,44
8110e178:	10c5883a 	add	r2,r2,r3
8110e17c:	10800804 	addi	r2,r2,32
8110e180:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
8110e184:	e0ffff03 	ldbu	r3,-4(fp)
8110e188:	00a04574 	movhi	r2,33045
8110e18c:	10b76a04 	addi	r2,r2,-8792
8110e190:	18c00b24 	muli	r3,r3,44
8110e194:	10c5883a 	add	r2,r2,r3
8110e198:	10800804 	addi	r2,r2,32
8110e19c:	10800017 	ldw	r2,0(r2)
8110e1a0:	1000521e 	bne	r2,zero,8110e2ec <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
8110e1a4:	e0bfff03 	ldbu	r2,-4(fp)
8110e1a8:	10c00b24 	muli	r3,r2,44
8110e1ac:	00a04574 	movhi	r2,33045
8110e1b0:	10b76a04 	addi	r2,r2,-8792
8110e1b4:	1885883a 	add	r2,r3,r2
8110e1b8:	1009883a 	mov	r4,r2
8110e1bc:	1116cd00 	call	81116cd0 <puts>
                xBuffer32[ucIL].bSent = TRUE;
8110e1c0:	e0ffff03 	ldbu	r3,-4(fp)
8110e1c4:	00a04574 	movhi	r2,33045
8110e1c8:	10b76a04 	addi	r2,r2,-8792
8110e1cc:	18c00b24 	muli	r3,r3,44
8110e1d0:	10c5883a 	add	r2,r2,r3
8110e1d4:	10800804 	addi	r2,r2,32
8110e1d8:	00c00044 	movi	r3,1
8110e1dc:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
8110e1e0:	e0ffff03 	ldbu	r3,-4(fp)
8110e1e4:	00a04574 	movhi	r2,33045
8110e1e8:	10b76a04 	addi	r2,r2,-8792
8110e1ec:	18c00b24 	muli	r3,r3,44
8110e1f0:	10c5883a 	add	r2,r2,r3
8110e1f4:	10800984 	addi	r2,r2,38
8110e1f8:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
8110e1fc:	e0ffff03 	ldbu	r3,-4(fp)
8110e200:	00a04574 	movhi	r2,33045
8110e204:	10b76a04 	addi	r2,r2,-8792
8110e208:	18c00b24 	muli	r3,r3,44
8110e20c:	10c5883a 	add	r2,r2,r3
8110e210:	10800904 	addi	r2,r2,36
8110e214:	1080000b 	ldhu	r2,0(r2)
8110e218:	10bfffcc 	andi	r2,r2,65535
8110e21c:	10800058 	cmpnei	r2,r2,1
8110e220:	1000021e 	bne	r2,zero,8110e22c <vCheckRetransmission32+0x1c4>
8110e224:	00bffe84 	movi	r2,-6
8110e228:	00000106 	br	8110e230 <vCheckRetransmission32+0x1c8>
8110e22c:	00800044 	movi	r2,1
8110e230:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
8110e234:	e0ffff03 	ldbu	r3,-4(fp)
8110e238:	00a04574 	movhi	r2,33045
8110e23c:	10b76a04 	addi	r2,r2,-8792
8110e240:	19000b24 	muli	r4,r3,44
8110e244:	1105883a 	add	r2,r2,r4
8110e248:	10800a04 	addi	r2,r2,40
8110e24c:	10800003 	ldbu	r2,0(r2)
8110e250:	10800044 	addi	r2,r2,1
8110e254:	100b883a 	mov	r5,r2
8110e258:	00a04574 	movhi	r2,33045
8110e25c:	10b76a04 	addi	r2,r2,-8792
8110e260:	19000b24 	muli	r4,r3,44
8110e264:	1105883a 	add	r2,r2,r4
8110e268:	10800a04 	addi	r2,r2,40
8110e26c:	11400005 	stb	r5,0(r2)
8110e270:	00a04574 	movhi	r2,33045
8110e274:	10b76a04 	addi	r2,r2,-8792
8110e278:	18c00b24 	muli	r3,r3,44
8110e27c:	10c5883a 	add	r2,r2,r3
8110e280:	10800a04 	addi	r2,r2,40
8110e284:	10800003 	ldbu	r2,0(r2)
8110e288:	10803fcc 	andi	r2,r2,255
8110e28c:	e0ffff43 	ldbu	r3,-3(fp)
8110e290:	1880162e 	bgeu	r3,r2,8110e2ec <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
8110e294:	e0ffff03 	ldbu	r3,-4(fp)
8110e298:	00a04574 	movhi	r2,33045
8110e29c:	1089d604 	addi	r2,r2,10072
8110e2a0:	18c00384 	addi	r3,r3,14
8110e2a4:	18c7883a 	add	r3,r3,r3
8110e2a8:	18c7883a 	add	r3,r3,r3
8110e2ac:	10c5883a 	add	r2,r2,r3
8110e2b0:	10000015 	stw	zero,0(r2)
                    SemCount32++;
8110e2b4:	d0a05a83 	ldbu	r2,-32406(gp)
8110e2b8:	10800044 	addi	r2,r2,1
8110e2bc:	d0a05a85 	stb	r2,-32406(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
8110e2c0:	d0a06017 	ldw	r2,-32384(gp)
8110e2c4:	1009883a 	mov	r4,r2
8110e2c8:	1133ae80 	call	81133ae8 <OSSemPost>
8110e2cc:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8110e2d0:	e0bfff83 	ldbu	r2,-2(fp)
8110e2d4:	10803fcc 	andi	r2,r2,255
8110e2d8:	10000426 	beq	r2,zero,8110e2ec <vCheckRetransmission32+0x284>
                        SemCount32--;
8110e2dc:	d0a05a83 	ldbu	r2,-32406(gp)
8110e2e0:	10bfffc4 	addi	r2,r2,-1
8110e2e4:	d0a05a85 	stb	r2,-32406(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8110e2e8:	11116600 	call	81111660 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
8110e2ec:	e0bfff03 	ldbu	r2,-4(fp)
8110e2f0:	10800044 	addi	r2,r2,1
8110e2f4:	e0bfff05 	stb	r2,-4(fp)
8110e2f8:	e0bfff03 	ldbu	r2,-4(fp)
8110e2fc:	10800230 	cmpltui	r2,r2,8
8110e300:	103f6c1e 	bne	r2,zero,8110e0b4 <__reset+0xfb0ee0b4>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
8110e304:	d0a05d17 	ldw	r2,-32396(gp)
8110e308:	1009883a 	mov	r4,r2
8110e30c:	1131cf80 	call	81131cf8 <OSMutexPost>

    return;
8110e310:	0001883a 	nop
8110e314:	00000106 	br	8110e31c <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8110e318:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
8110e31c:	e037883a 	mov	sp,fp
8110e320:	dfc00117 	ldw	ra,4(sp)
8110e324:	df000017 	ldw	fp,0(sp)
8110e328:	dec00204 	addi	sp,sp,8
8110e32c:	f800283a 	ret

8110e330 <bResourcesInitRTOS>:
 * Control of all Simucam application
 */
TSimucam_MEB xSimMeb; /* Struct */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
8110e330:	defff904 	addi	sp,sp,-28
8110e334:	de00012e 	bgeu	sp,et,8110e33c <bResourcesInitRTOS+0xc>
8110e338:	003b68fa 	trap	3
8110e33c:	dfc00615 	stw	ra,24(sp)
8110e340:	df000515 	stw	fp,20(sp)
8110e344:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
8110e348:	00800044 	movi	r2,1
8110e34c:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
8110e350:	0009883a 	mov	r4,zero
8110e354:	11334380 	call	81133438 <OSSemCreate>
8110e358:	d0a05215 	stw	r2,-32440(gp)
	if (!xSemCommInit) {
8110e35c:	d0a05217 	ldw	r2,-32440(gp)
8110e360:	1000021e 	bne	r2,zero,8110e36c <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
8110e364:	11110f80 	call	811110f8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110e368:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
8110e36c:	e0bfff04 	addi	r2,fp,-4
8110e370:	100b883a 	mov	r5,r2
8110e374:	01000444 	movi	r4,17
8110e378:	11312800 	call	81131280 <OSMutexCreate>
8110e37c:	d0a06415 	stw	r2,-32368(gp)
	if ( err != OS_ERR_NONE ) {
8110e380:	e0bfff03 	ldbu	r2,-4(fp)
8110e384:	10803fcc 	andi	r2,r2,255
8110e388:	10000526 	beq	r2,zero,8110e3a0 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
8110e38c:	e0bfff03 	ldbu	r2,-4(fp)
8110e390:	10803fcc 	andi	r2,r2,255
8110e394:	1009883a 	mov	r4,r2
8110e398:	11110980 	call	81111098 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110e39c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
8110e3a0:	e0bfff04 	addi	r2,fp,-4
8110e3a4:	100b883a 	mov	r5,r2
8110e3a8:	01000504 	movi	r4,20
8110e3ac:	11312800 	call	81131280 <OSMutexCreate>
8110e3b0:	d0a05f15 	stw	r2,-32388(gp)
	if ( err != OS_ERR_NONE ) {
8110e3b4:	e0bfff03 	ldbu	r2,-4(fp)
8110e3b8:	10803fcc 	andi	r2,r2,255
8110e3bc:	10000526 	beq	r2,zero,8110e3d4 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
8110e3c0:	e0bfff03 	ldbu	r2,-4(fp)
8110e3c4:	10803fcc 	andi	r2,r2,255
8110e3c8:	1009883a 	mov	r4,r2
8110e3cc:	11110980 	call	81111098 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110e3d0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
8110e3d4:	e0bfff04 	addi	r2,fp,-4
8110e3d8:	100b883a 	mov	r5,r2
8110e3dc:	01000544 	movi	r4,21
8110e3e0:	11312800 	call	81131280 <OSMutexCreate>
8110e3e4:	d0a06115 	stw	r2,-32380(gp)
	if ( err != OS_ERR_NONE ) {
8110e3e8:	e0bfff03 	ldbu	r2,-4(fp)
8110e3ec:	10803fcc 	andi	r2,r2,255
8110e3f0:	10000526 	beq	r2,zero,8110e408 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
8110e3f4:	e0bfff03 	ldbu	r2,-4(fp)
8110e3f8:	10803fcc 	andi	r2,r2,255
8110e3fc:	1009883a 	mov	r4,r2
8110e400:	11110980 	call	81111098 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110e404:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
8110e408:	e0bfff04 	addi	r2,fp,-4
8110e40c:	100b883a 	mov	r5,r2
8110e410:	01000584 	movi	r4,22
8110e414:	11312800 	call	81131280 <OSMutexCreate>
8110e418:	d0a05d15 	stw	r2,-32396(gp)
	if ( err != OS_ERR_NONE ) {
8110e41c:	e0bfff03 	ldbu	r2,-4(fp)
8110e420:	10803fcc 	andi	r2,r2,255
8110e424:	10000526 	beq	r2,zero,8110e43c <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
8110e428:	e0bfff03 	ldbu	r2,-4(fp)
8110e42c:	10803fcc 	andi	r2,r2,255
8110e430:	1009883a 	mov	r4,r2
8110e434:	11110980 	call	81111098 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110e438:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
8110e43c:	00800184 	movi	r2,6
8110e440:	d0a06545 	stb	r2,-32363(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
8110e444:	01000184 	movi	r4,6
8110e448:	11334380 	call	81133438 <OSSemCreate>
8110e44c:	d0a05515 	stw	r2,-32428(gp)
	if (!xSemCountBuffer128) {
8110e450:	d0a05517 	ldw	r2,-32428(gp)
8110e454:	1000031e 	bne	r2,zero,8110e464 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
8110e458:	d0206545 	stb	zero,-32363(gp)
		vFailCreateSemaphoreResources();
8110e45c:	11110f80 	call	811110f8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110e460:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
8110e464:	00800204 	movi	r2,8
8110e468:	d0a06505 	stb	r2,-32364(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
8110e46c:	01000204 	movi	r4,8
8110e470:	11334380 	call	81133438 <OSSemCreate>
8110e474:	d0a05115 	stw	r2,-32444(gp)
	if (!xSemCountBuffer64) {
8110e478:	d0a05117 	ldw	r2,-32444(gp)
8110e47c:	1000031e 	bne	r2,zero,8110e48c <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
8110e480:	d0206505 	stb	zero,-32364(gp)
		vFailCreateSemaphoreResources();
8110e484:	11110f80 	call	811110f8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110e488:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
8110e48c:	00800204 	movi	r2,8
8110e490:	d0a05a85 	stb	r2,-32406(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
8110e494:	01000204 	movi	r4,8
8110e498:	11334380 	call	81133438 <OSSemCreate>
8110e49c:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCountBuffer32) {
8110e4a0:	d0a06017 	ldw	r2,-32384(gp)
8110e4a4:	1000031e 	bne	r2,zero,8110e4b4 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
8110e4a8:	d0205a85 	stb	zero,-32406(gp)
		vFailCreateSemaphoreResources();
8110e4ac:	11110f80 	call	811110f8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110e4b0:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
8110e4b4:	e0bfff04 	addi	r2,fp,-4
8110e4b8:	100b883a 	mov	r5,r2
8110e4bc:	010004c4 	movi	r4,19
8110e4c0:	11312800 	call	81131280 <OSMutexCreate>
8110e4c4:	d0a05715 	stw	r2,-32420(gp)
	if ( err != OS_ERR_NONE ) {
8110e4c8:	e0bfff03 	ldbu	r2,-4(fp)
8110e4cc:	10803fcc 	andi	r2,r2,255
8110e4d0:	10000526 	beq	r2,zero,8110e4e8 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
8110e4d4:	e0bfff03 	ldbu	r2,-4(fp)
8110e4d8:	10803fcc 	andi	r2,r2,255
8110e4dc:	1009883a 	mov	r4,r2
8110e4e0:	11110980 	call	81111098 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110e4e4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
8110e4e8:	e0bfff04 	addi	r2,fp,-4
8110e4ec:	100b883a 	mov	r5,r2
8110e4f0:	010005c4 	movi	r4,23
8110e4f4:	11312800 	call	81131280 <OSMutexCreate>
8110e4f8:	d0a05c15 	stw	r2,-32400(gp)
	if ( err != OS_ERR_NONE ) {
8110e4fc:	e0bfff03 	ldbu	r2,-4(fp)
8110e500:	10803fcc 	andi	r2,r2,255
8110e504:	10000526 	beq	r2,zero,8110e51c <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
8110e508:	e0bfff03 	ldbu	r2,-4(fp)
8110e50c:	10803fcc 	andi	r2,r2,255
8110e510:	1009883a 	mov	r4,r2
8110e514:	11110980 	call	81111098 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110e518:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
8110e51c:	0009883a 	mov	r4,zero
8110e520:	11334380 	call	81133438 <OSSemCreate>
8110e524:	d0a05815 	stw	r2,-32416(gp)
	if (!xSemCountReceivedACK) {
8110e528:	d0a05817 	ldw	r2,-32416(gp)
8110e52c:	1000021e 	bne	r2,zero,8110e538 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
8110e530:	11110f80 	call	811110f8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110e534:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
8110e538:	0009883a 	mov	r4,zero
8110e53c:	11334380 	call	81133438 <OSSemCreate>
8110e540:	d0a05615 	stw	r2,-32424(gp)
	if (!xSemCountPreParsed) {
8110e544:	d0a05617 	ldw	r2,-32424(gp)
8110e548:	1000021e 	bne	r2,zero,8110e554 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
8110e54c:	11110f80 	call	811110f8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110e550:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
8110e554:	0009883a 	mov	r4,zero
8110e558:	11334380 	call	81133438 <OSSemCreate>
8110e55c:	d0a05315 	stw	r2,-32436(gp)
	if (!xSemCountSenderACK) {
8110e560:	d0a05317 	ldw	r2,-32436(gp)
8110e564:	1000021e 	bne	r2,zero,8110e570 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
8110e568:	11110f80 	call	811110f8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110e56c:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
8110e570:	e0bfff04 	addi	r2,fp,-4
8110e574:	100b883a 	mov	r5,r2
8110e578:	01000484 	movi	r4,18
8110e57c:	11312800 	call	81131280 <OSMutexCreate>
8110e580:	d0a06215 	stw	r2,-32376(gp)
	if ( err != OS_ERR_NONE ) {
8110e584:	e0bfff03 	ldbu	r2,-4(fp)
8110e588:	10803fcc 	andi	r2,r2,255
8110e58c:	10000526 	beq	r2,zero,8110e5a4 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
8110e590:	e0bfff03 	ldbu	r2,-4(fp)
8110e594:	10803fcc 	andi	r2,r2,255
8110e598:	1009883a 	mov	r4,r2
8110e59c:	11110980 	call	81111098 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110e5a0:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
8110e5a4:	0009883a 	mov	r4,zero
8110e5a8:	11334380 	call	81133438 <OSSemCreate>
8110e5ac:	d0a05915 	stw	r2,-32412(gp)
	if (!xSemTimeoutChecker) {
8110e5b0:	d0a05917 	ldw	r2,-32412(gp)
8110e5b4:	1000021e 	bne	r2,zero,8110e5c0 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
8110e5b8:	11110f80 	call	811110f8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110e5bc:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
8110e5c0:	e0bfff04 	addi	r2,fp,-4
8110e5c4:	d8800215 	stw	r2,8(sp)
8110e5c8:	00a04534 	movhi	r2,33044
8110e5cc:	1088e604 	addi	r2,r2,9112
8110e5d0:	d8800115 	stw	r2,4(sp)
8110e5d4:	d8000015 	stw	zero,0(sp)
8110e5d8:	01e04474 	movhi	r7,33041
8110e5dc:	39ff4804 	addi	r7,r7,-736
8110e5e0:	01800084 	movi	r6,2
8110e5e4:	01400104 	movi	r5,4
8110e5e8:	01000284 	movi	r4,10
8110e5ec:	11359500 	call	81135950 <OSTmrCreate>
8110e5f0:	d0a05e15 	stw	r2,-32392(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
8110e5f4:	e0bfff03 	ldbu	r2,-4(fp)
8110e5f8:	10803fcc 	andi	r2,r2,255
8110e5fc:	10000226 	beq	r2,zero,8110e608 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
8110e600:	1111d5c0 	call	81111d5c <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
8110e604:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
8110e608:	01400304 	movi	r5,12
8110e60c:	01204574 	movhi	r4,33045
8110e610:	212a2f04 	addi	r4,r4,-22340
8110e614:	113236c0 	call	8113236c <OSQCreate>
8110e618:	d0a05015 	stw	r2,-32448(gp)
	if ( xNfeeSchedule == NULL ) {
8110e61c:	d0a05017 	ldw	r2,-32448(gp)
8110e620:	1000021e 	bne	r2,zero,8110e62c <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
8110e624:	11123400 	call	81112340 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
8110e628:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
8110e62c:	01400104 	movi	r5,4
8110e630:	012045b4 	movhi	r4,33046
8110e634:	21298e04 	addi	r4,r4,-22984
8110e638:	113236c0 	call	8113236c <OSQCreate>
8110e63c:	1007883a 	mov	r3,r2
8110e640:	00a04574 	movhi	r2,33045
8110e644:	108eda04 	addi	r2,r2,15208
8110e648:	10c00015 	stw	r3,0(r2)
	if ( xFeeQ[0] == NULL ) {
8110e64c:	00a04574 	movhi	r2,33045
8110e650:	108eda04 	addi	r2,r2,15208
8110e654:	10800017 	ldw	r2,0(r2)
8110e658:	1000031e 	bne	r2,zero,8110e668 <bResourcesInitRTOS+0x338>
		vFailCreateNFEEQueue( 0 );
8110e65c:	0009883a 	mov	r4,zero
8110e660:	11123a80 	call	811123a8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110e664:	e03ffe15 	stw	zero,-8(fp)
	}
	xFeeQ[1] = OSQCreate(&xFeeQueueTBL1[0], N_MSG_FEE);
8110e668:	01400104 	movi	r5,4
8110e66c:	012045b4 	movhi	r4,33046
8110e670:	2128ea04 	addi	r4,r4,-23640
8110e674:	113236c0 	call	8113236c <OSQCreate>
8110e678:	1007883a 	mov	r3,r2
8110e67c:	00a04574 	movhi	r2,33045
8110e680:	108eda04 	addi	r2,r2,15208
8110e684:	10c00115 	stw	r3,4(r2)
	if ( xFeeQ[1] == NULL ) {
8110e688:	00a04574 	movhi	r2,33045
8110e68c:	108eda04 	addi	r2,r2,15208
8110e690:	10800117 	ldw	r2,4(r2)
8110e694:	1000031e 	bne	r2,zero,8110e6a4 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 1 );
8110e698:	01000044 	movi	r4,1
8110e69c:	11123a80 	call	811123a8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110e6a0:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[2] = OSQCreate(&xFeeQueueTBL2[0], N_MSG_FEE);
8110e6a4:	01400104 	movi	r5,4
8110e6a8:	01204574 	movhi	r4,33045
8110e6ac:	210ee004 	addi	r4,r4,15232
8110e6b0:	113236c0 	call	8113236c <OSQCreate>
8110e6b4:	1007883a 	mov	r3,r2
8110e6b8:	00a04574 	movhi	r2,33045
8110e6bc:	108eda04 	addi	r2,r2,15208
8110e6c0:	10c00215 	stw	r3,8(r2)
	if ( xFeeQ[2] == NULL ) {
8110e6c4:	00a04574 	movhi	r2,33045
8110e6c8:	108eda04 	addi	r2,r2,15208
8110e6cc:	10800217 	ldw	r2,8(r2)
8110e6d0:	1000031e 	bne	r2,zero,8110e6e0 <bResourcesInitRTOS+0x3b0>
		vFailCreateNFEEQueue( 2 );
8110e6d4:	01000084 	movi	r4,2
8110e6d8:	11123a80 	call	811123a8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110e6dc:	e03ffe15 	stw	zero,-8(fp)
	}
	
	xFeeQ[3] = OSQCreate(&xFeeQueueTBL3[0], N_MSG_FEE);
8110e6e0:	01400104 	movi	r5,4
8110e6e4:	01204574 	movhi	r4,33045
8110e6e8:	21262b04 	addi	r4,r4,-26452
8110e6ec:	113236c0 	call	8113236c <OSQCreate>
8110e6f0:	1007883a 	mov	r3,r2
8110e6f4:	00a04574 	movhi	r2,33045
8110e6f8:	108eda04 	addi	r2,r2,15208
8110e6fc:	10c00315 	stw	r3,12(r2)
	if ( xFeeQ[0] == NULL ) {
8110e700:	00a04574 	movhi	r2,33045
8110e704:	108eda04 	addi	r2,r2,15208
8110e708:	10800017 	ldw	r2,0(r2)
8110e70c:	1000031e 	bne	r2,zero,8110e71c <bResourcesInitRTOS+0x3ec>
		vFailCreateNFEEQueue( 3 );
8110e710:	010000c4 	movi	r4,3
8110e714:	11123a80 	call	811123a8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110e718:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[4] = OSQCreate(&xFeeQueueTBL4[0], N_MSG_FEE);
8110e71c:	01400104 	movi	r5,4
8110e720:	01204574 	movhi	r4,33045
8110e724:	2101d204 	addi	r4,r4,1864
8110e728:	113236c0 	call	8113236c <OSQCreate>
8110e72c:	1007883a 	mov	r3,r2
8110e730:	00a04574 	movhi	r2,33045
8110e734:	108eda04 	addi	r2,r2,15208
8110e738:	10c00415 	stw	r3,16(r2)
	if ( xFeeQ[4] == NULL ) {
8110e73c:	00a04574 	movhi	r2,33045
8110e740:	108eda04 	addi	r2,r2,15208
8110e744:	10800417 	ldw	r2,16(r2)
8110e748:	1000031e 	bne	r2,zero,8110e758 <bResourcesInitRTOS+0x428>
		vFailCreateNFEEQueue( 4 );
8110e74c:	01000104 	movi	r4,4
8110e750:	11123a80 	call	811123a8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110e754:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[5] = OSQCreate(&xFeeQueueTBL5[0], N_MSG_FEE);
8110e758:	01400104 	movi	r5,4
8110e75c:	01204574 	movhi	r4,33045
8110e760:	210ad604 	addi	r4,r4,11096
8110e764:	113236c0 	call	8113236c <OSQCreate>
8110e768:	1007883a 	mov	r3,r2
8110e76c:	00a04574 	movhi	r2,33045
8110e770:	108eda04 	addi	r2,r2,15208
8110e774:	10c00515 	stw	r3,20(r2)
	if ( xFeeQ[5] == NULL ) {
8110e778:	00a04574 	movhi	r2,33045
8110e77c:	108eda04 	addi	r2,r2,15208
8110e780:	10800517 	ldw	r2,20(r2)
8110e784:	1000031e 	bne	r2,zero,8110e794 <bResourcesInitRTOS+0x464>
		vFailCreateNFEEQueue( 5 );
8110e788:	01000144 	movi	r4,5
8110e78c:	11123a80 	call	811123a8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110e790:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
8110e794:	01400204 	movi	r5,8
8110e798:	01204574 	movhi	r4,33045
8110e79c:	2109ec04 	addi	r4,r4,10160
8110e7a0:	113236c0 	call	8113236c <OSQCreate>
8110e7a4:	d0a05b15 	stw	r2,-32404(gp)
	if ( xFeeQ[5] == NULL ) {
8110e7a8:	00a04574 	movhi	r2,33045
8110e7ac:	108eda04 	addi	r2,r2,15208
8110e7b0:	10800517 	ldw	r2,20(r2)
8110e7b4:	1000031e 	bne	r2,zero,8110e7c4 <bResourcesInitRTOS+0x494>
		vFailCreateNFEEQueue( 5 );
8110e7b8:	01000144 	movi	r4,5
8110e7bc:	11123a80 	call	811123a8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110e7c0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
8110e7c4:	e0bfff04 	addi	r2,fp,-4
8110e7c8:	100b883a 	mov	r5,r2
8110e7cc:	01000144 	movi	r4,5
8110e7d0:	11312800 	call	81131280 <OSMutexCreate>
8110e7d4:	d0a06315 	stw	r2,-32372(gp)
	if ( err != OS_ERR_NONE ) {
8110e7d8:	e0bfff03 	ldbu	r2,-4(fp)
8110e7dc:	10803fcc 	andi	r2,r2,255
8110e7e0:	10000526 	beq	r2,zero,8110e7f8 <bResourcesInitRTOS+0x4c8>
		vFailCreateMutexSPUSQueueMeb(err);
8110e7e4:	e0bfff03 	ldbu	r2,-4(fp)
8110e7e8:	10803fcc 	andi	r2,r2,255
8110e7ec:	1009883a 	mov	r4,r2
8110e7f0:	11127c00 	call	811127c0 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
8110e7f4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
8110e7f8:	01400404 	movi	r5,16
8110e7fc:	01204574 	movhi	r4,33045
8110e800:	210ac604 	addi	r4,r4,11032
8110e804:	113236c0 	call	8113236c <OSQCreate>
8110e808:	d0a04a15 	stw	r2,-32472(gp)
	if ( xQMaskFeeCtrl == NULL ) {
8110e80c:	d0a04a17 	ldw	r2,-32472(gp)
8110e810:	1000021e 	bne	r2,zero,8110e81c <bResourcesInitRTOS+0x4ec>
		vCouldNotCreateQueueMaskNfeeCtrl( );
8110e814:	11129200 	call	81112920 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
8110e818:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
8110e81c:	01400404 	movi	r5,16
8110e820:	01204574 	movhi	r4,33045
8110e824:	213dc204 	addi	r4,r4,-2296
8110e828:	113236c0 	call	8113236c <OSQCreate>
8110e82c:	d0a04a15 	stw	r2,-32472(gp)
	if ( xQMaskFeeCtrl == NULL ) {
8110e830:	d0a04a17 	ldw	r2,-32472(gp)
8110e834:	1000021e 	bne	r2,zero,8110e840 <bResourcesInitRTOS+0x510>
		vCouldNotCreateQueueMaskDataCtrl( );
8110e838:	11129880 	call	81112988 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
8110e83c:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
8110e840:	e0bffe17 	ldw	r2,-8(fp)
}
8110e844:	e037883a 	mov	sp,fp
8110e848:	dfc00117 	ldw	ra,4(sp)
8110e84c:	df000017 	ldw	fp,0(sp)
8110e850:	dec00204 	addi	sp,sp,8
8110e854:	f800283a 	ret

8110e858 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
8110e858:	defffd04 	addi	sp,sp,-12
8110e85c:	de00012e 	bgeu	sp,et,8110e864 <vVariablesInitialization+0xc>
8110e860:	003b68fa 	trap	3
8110e864:	dfc00215 	stw	ra,8(sp)
8110e868:	df000115 	stw	fp,4(sp)
8110e86c:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
8110e870:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
8110e874:	00800084 	movi	r2,2
8110e878:	d0a05a0d 	sth	r2,-32408(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
8110e87c:	01800604 	movi	r6,24
8110e880:	000b883a 	mov	r5,zero
8110e884:	01204574 	movhi	r4,33045
8110e888:	2109d604 	addi	r4,r4,10072
8110e88c:	11168840 	call	81116884 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
8110e890:	01800804 	movi	r6,32
8110e894:	000b883a 	mov	r5,zero
8110e898:	01204574 	movhi	r4,33045
8110e89c:	2109dc04 	addi	r4,r4,10096
8110e8a0:	11168840 	call	81116884 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
8110e8a4:	01800804 	movi	r6,32
8110e8a8:	000b883a 	mov	r5,zero
8110e8ac:	01204574 	movhi	r4,33045
8110e8b0:	2109e404 	addi	r4,r4,10128
8110e8b4:	11168840 	call	81116884 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110e8b8:	e03fff05 	stb	zero,-4(fp)
8110e8bc:	00002806 	br	8110e960 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
8110e8c0:	e0bfff03 	ldbu	r2,-4(fp)
8110e8c4:	10c02324 	muli	r3,r2,140
8110e8c8:	00a04574 	movhi	r2,33045
8110e8cc:	1089f404 	addi	r2,r2,10192
8110e8d0:	1885883a 	add	r2,r3,r2
8110e8d4:	01802004 	movi	r6,128
8110e8d8:	000b883a 	mov	r5,zero
8110e8dc:	1009883a 	mov	r4,r2
8110e8e0:	11168840 	call	81116884 <memset>
		xBuffer128[ucIL].bSent = FALSE;
8110e8e4:	e0ffff03 	ldbu	r3,-4(fp)
8110e8e8:	00a04574 	movhi	r2,33045
8110e8ec:	1089f404 	addi	r2,r2,10192
8110e8f0:	18c02324 	muli	r3,r3,140
8110e8f4:	10c5883a 	add	r2,r2,r3
8110e8f8:	10802004 	addi	r2,r2,128
8110e8fc:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
8110e900:	e0ffff03 	ldbu	r3,-4(fp)
8110e904:	00a04574 	movhi	r2,33045
8110e908:	1089f404 	addi	r2,r2,10192
8110e90c:	18c02324 	muli	r3,r3,140
8110e910:	10c5883a 	add	r2,r2,r3
8110e914:	10802104 	addi	r2,r2,132
8110e918:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
8110e91c:	e0ffff03 	ldbu	r3,-4(fp)
8110e920:	00a04574 	movhi	r2,33045
8110e924:	1089f404 	addi	r2,r2,10192
8110e928:	18c02324 	muli	r3,r3,140
8110e92c:	10c5883a 	add	r2,r2,r3
8110e930:	10802184 	addi	r2,r2,134
8110e934:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
8110e938:	e0ffff03 	ldbu	r3,-4(fp)
8110e93c:	00a04574 	movhi	r2,33045
8110e940:	1089f404 	addi	r2,r2,10192
8110e944:	18c02324 	muli	r3,r3,140
8110e948:	10c5883a 	add	r2,r2,r3
8110e94c:	10802204 	addi	r2,r2,136
8110e950:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110e954:	e0bfff03 	ldbu	r2,-4(fp)
8110e958:	10800044 	addi	r2,r2,1
8110e95c:	e0bfff05 	stb	r2,-4(fp)
8110e960:	e0bfff03 	ldbu	r2,-4(fp)
8110e964:	108001b0 	cmpltui	r2,r2,6
8110e968:	103fd51e 	bne	r2,zero,8110e8c0 <__reset+0xfb0ee8c0>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
8110e96c:	e03fff05 	stb	zero,-4(fp)
8110e970:	00002806 	br	8110ea14 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
8110e974:	e0bfff03 	ldbu	r2,-4(fp)
8110e978:	10c01324 	muli	r3,r2,76
8110e97c:	00a04574 	movhi	r2,33045
8110e980:	10a53f04 	addi	r2,r2,-27396
8110e984:	1885883a 	add	r2,r3,r2
8110e988:	01801004 	movi	r6,64
8110e98c:	000b883a 	mov	r5,zero
8110e990:	1009883a 	mov	r4,r2
8110e994:	11168840 	call	81116884 <memset>
		xBuffer64[ucIL].bSent = FALSE;
8110e998:	e0ffff03 	ldbu	r3,-4(fp)
8110e99c:	00a04574 	movhi	r2,33045
8110e9a0:	10a53f04 	addi	r2,r2,-27396
8110e9a4:	18c01324 	muli	r3,r3,76
8110e9a8:	10c5883a 	add	r2,r2,r3
8110e9ac:	10801004 	addi	r2,r2,64
8110e9b0:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
8110e9b4:	e0ffff03 	ldbu	r3,-4(fp)
8110e9b8:	00a04574 	movhi	r2,33045
8110e9bc:	10a53f04 	addi	r2,r2,-27396
8110e9c0:	18c01324 	muli	r3,r3,76
8110e9c4:	10c5883a 	add	r2,r2,r3
8110e9c8:	10801104 	addi	r2,r2,68
8110e9cc:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
8110e9d0:	e0ffff03 	ldbu	r3,-4(fp)
8110e9d4:	00a04574 	movhi	r2,33045
8110e9d8:	10a53f04 	addi	r2,r2,-27396
8110e9dc:	18c01324 	muli	r3,r3,76
8110e9e0:	10c5883a 	add	r2,r2,r3
8110e9e4:	10801184 	addi	r2,r2,70
8110e9e8:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
8110e9ec:	e0ffff03 	ldbu	r3,-4(fp)
8110e9f0:	00a04574 	movhi	r2,33045
8110e9f4:	10a53f04 	addi	r2,r2,-27396
8110e9f8:	18c01324 	muli	r3,r3,76
8110e9fc:	10c5883a 	add	r2,r2,r3
8110ea00:	10801204 	addi	r2,r2,72
8110ea04:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
8110ea08:	e0bfff03 	ldbu	r2,-4(fp)
8110ea0c:	10800044 	addi	r2,r2,1
8110ea10:	e0bfff05 	stb	r2,-4(fp)
8110ea14:	e0bfff03 	ldbu	r2,-4(fp)
8110ea18:	10800230 	cmpltui	r2,r2,8
8110ea1c:	103fd51e 	bne	r2,zero,8110e974 <__reset+0xfb0ee974>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
8110ea20:	e03fff05 	stb	zero,-4(fp)
8110ea24:	00002806 	br	8110eac8 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
8110ea28:	e0bfff03 	ldbu	r2,-4(fp)
8110ea2c:	10c00b24 	muli	r3,r2,44
8110ea30:	00a04574 	movhi	r2,33045
8110ea34:	10b76a04 	addi	r2,r2,-8792
8110ea38:	1885883a 	add	r2,r3,r2
8110ea3c:	01800804 	movi	r6,32
8110ea40:	000b883a 	mov	r5,zero
8110ea44:	1009883a 	mov	r4,r2
8110ea48:	11168840 	call	81116884 <memset>
		xBuffer32[ucIL].bSent = FALSE;
8110ea4c:	e0ffff03 	ldbu	r3,-4(fp)
8110ea50:	00a04574 	movhi	r2,33045
8110ea54:	10b76a04 	addi	r2,r2,-8792
8110ea58:	18c00b24 	muli	r3,r3,44
8110ea5c:	10c5883a 	add	r2,r2,r3
8110ea60:	10800804 	addi	r2,r2,32
8110ea64:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
8110ea68:	e0ffff03 	ldbu	r3,-4(fp)
8110ea6c:	00a04574 	movhi	r2,33045
8110ea70:	10b76a04 	addi	r2,r2,-8792
8110ea74:	18c00b24 	muli	r3,r3,44
8110ea78:	10c5883a 	add	r2,r2,r3
8110ea7c:	10800904 	addi	r2,r2,36
8110ea80:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
8110ea84:	e0ffff03 	ldbu	r3,-4(fp)
8110ea88:	00a04574 	movhi	r2,33045
8110ea8c:	10b76a04 	addi	r2,r2,-8792
8110ea90:	18c00b24 	muli	r3,r3,44
8110ea94:	10c5883a 	add	r2,r2,r3
8110ea98:	10800984 	addi	r2,r2,38
8110ea9c:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
8110eaa0:	e0ffff03 	ldbu	r3,-4(fp)
8110eaa4:	00a04574 	movhi	r2,33045
8110eaa8:	10b76a04 	addi	r2,r2,-8792
8110eaac:	18c00b24 	muli	r3,r3,44
8110eab0:	10c5883a 	add	r2,r2,r3
8110eab4:	10800a04 	addi	r2,r2,40
8110eab8:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
8110eabc:	e0bfff03 	ldbu	r2,-4(fp)
8110eac0:	10800044 	addi	r2,r2,1
8110eac4:	e0bfff05 	stb	r2,-4(fp)
8110eac8:	e0bfff03 	ldbu	r2,-4(fp)
8110eacc:	10800230 	cmpltui	r2,r2,8
8110ead0:	103fd51e 	bne	r2,zero,8110ea28 <__reset+0xfb0eea28>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
8110ead4:	e03fff05 	stb	zero,-4(fp)
8110ead8:	00001b06 	br	8110eb48 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
8110eadc:	e0ffff03 	ldbu	r3,-4(fp)
8110eae0:	00a04574 	movhi	r2,33045
8110eae4:	10a5d704 	addi	r2,r2,-26788
8110eae8:	18c01524 	muli	r3,r3,84
8110eaec:	10c5883a 	add	r2,r2,r3
8110eaf0:	10800104 	addi	r2,r2,4
8110eaf4:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
8110eaf8:	e0ffff03 	ldbu	r3,-4(fp)
8110eafc:	00a04574 	movhi	r2,33045
8110eb00:	10a5d704 	addi	r2,r2,-26788
8110eb04:	18c01524 	muli	r3,r3,84
8110eb08:	10c5883a 	add	r2,r2,r3
8110eb0c:	10800484 	addi	r2,r2,18
8110eb10:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
8110eb14:	e0bfff03 	ldbu	r2,-4(fp)
8110eb18:	10801524 	muli	r2,r2,84
8110eb1c:	10c00504 	addi	r3,r2,20
8110eb20:	00a04574 	movhi	r2,33045
8110eb24:	10a5d704 	addi	r2,r2,-26788
8110eb28:	1885883a 	add	r2,r3,r2
8110eb2c:	01801004 	movi	r6,64
8110eb30:	000b883a 	mov	r5,zero
8110eb34:	1009883a 	mov	r4,r2
8110eb38:	11168840 	call	81116884 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
8110eb3c:	e0bfff03 	ldbu	r2,-4(fp)
8110eb40:	10800044 	addi	r2,r2,1
8110eb44:	e0bfff05 	stb	r2,-4(fp)
8110eb48:	e0bfff03 	ldbu	r2,-4(fp)
8110eb4c:	10800130 	cmpltui	r2,r2,4
8110eb50:	103fe21e 	bne	r2,zero,8110eadc <__reset+0xfb0eeadc>
*/




}
8110eb54:	0001883a 	nop
8110eb58:	e037883a 	mov	sp,fp
8110eb5c:	dfc00117 	ldw	ra,4(sp)
8110eb60:	df000017 	ldw	fp,0(sp)
8110eb64:	dec00204 	addi	sp,sp,8
8110eb68:	f800283a 	ret

8110eb6c <main>:



/* Entry point */
int main(void)
{
8110eb6c:	defff704 	addi	sp,sp,-36
8110eb70:	de00012e 	bgeu	sp,et,8110eb78 <main+0xc>
8110eb74:	003b68fa 	trap	3
8110eb78:	dfc00815 	stw	ra,32(sp)
8110eb7c:	df000715 	stw	fp,28(sp)
8110eb80:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
8110eb84:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
8110eb88:	112d71c0 	call	8112d71c <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
8110eb8c:	01604534 	movhi	r5,33044
8110eb90:	2948ea04 	addi	r5,r5,9128
8110eb94:	01204534 	movhi	r4,33044
8110eb98:	2108eb04 	addi	r4,r4,9132
8110eb9c:	111563c0 	call	8111563c <fopen>
8110eba0:	d0a05415 	stw	r2,-32432(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
8110eba4:	d0a05417 	ldw	r2,-32432(gp)
8110eba8:	100f883a 	mov	r7,r2
8110ebac:	01800484 	movi	r6,18
8110ebb0:	01400044 	movi	r5,1
8110ebb4:	01204534 	movhi	r4,33044
8110ebb8:	2108f004 	addi	r4,r4,9152
8110ebbc:	1115d200 	call	81115d20 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
8110ebc0:	11135200 	call	81113520 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
8110ebc4:	1113bf00 	call	81113bf0 <bTestSimucamCriticalHW>
8110ebc8:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110ebcc:	e0bffe17 	ldw	r2,-8(fp)
8110ebd0:	1000031e 	bne	r2,zero,8110ebe0 <main+0x74>
		vFailTestCriticasParts();
8110ebd4:	11111440 	call	81111144 <vFailTestCriticasParts>
		return -1;
8110ebd8:	00bfffc4 	movi	r2,-1
8110ebdc:	00003d06 	br	8110ecd4 <main+0x168>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
8110ebe0:	1113a3c0 	call	81113a3c <bInitializeSDCard>
8110ebe4:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110ebe8:	e0bffe17 	ldw	r2,-8(fp)
8110ebec:	1000031e 	bne	r2,zero,8110ebfc <main+0x90>
		vFailTestCriticasParts();
8110ebf0:	11111440 	call	81111144 <vFailTestCriticasParts>
		return -1;
8110ebf4:	00bfffc4 	movi	r2,-1
8110ebf8:	00003606 	br	8110ecd4 <main+0x168>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
8110ebfc:	11101480 	call	81110148 <vLoadDefaultETHConf>
8110ec00:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110ec04:	e0bffe17 	ldw	r2,-8(fp)
8110ec08:	1000091e 	bne	r2,zero,8110ec30 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. (exit) \n");
8110ec0c:	d0a05417 	ldw	r2,-32432(gp)
8110ec10:	100f883a 	mov	r7,r2
8110ec14:	01801644 	movi	r6,89
8110ec18:	01400044 	movi	r5,1
8110ec1c:	01204534 	movhi	r4,33044
8110ec20:	2108f504 	addi	r4,r4,9172
8110ec24:	1115d200 	call	81115d20 <fwrite>
		#endif
		return -1;
8110ec28:	00bfffc4 	movi	r2,-1
8110ec2c:	00002906 	br	8110ecd4 <main+0x168>
	}

	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
8110ec30:	1110b1c0 	call	81110b1c <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
8110ec34:	110e3300 	call	8110e330 <bResourcesInitRTOS>
8110ec38:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110ec3c:	e0bffe17 	ldw	r2,-8(fp)
8110ec40:	1000091e 	bne	r2,zero,8110ec68 <main+0xfc>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
8110ec44:	d0a05417 	ldw	r2,-32432(gp)
8110ec48:	100f883a 	mov	r7,r2
8110ec4c:	01800ac4 	movi	r6,43
8110ec50:	01400044 	movi	r5,1
8110ec54:	01204534 	movhi	r4,33044
8110ec58:	21090c04 	addi	r4,r4,9264
8110ec5c:	1115d200 	call	81115d20 <fwrite>
		return -1;
8110ec60:	00bfffc4 	movi	r2,-1
8110ec64:	00001b06 	br	8110ecd4 <main+0x168>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
8110ec68:	01204574 	movhi	r4,33045
8110ec6c:	21323b04 	addi	r4,r4,-14100
8110ec70:	11136600 	call	81113660 <vSimucamStructureInit>

	vVariablesInitialization();
8110ec74:	110e8580 	call	8110e858 <vVariablesInitialization>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
8110ec78:	d8000415 	stw	zero,16(sp)
8110ec7c:	d8000315 	stw	zero,12(sp)
8110ec80:	00810004 	movi	r2,1024
8110ec84:	d8800215 	stw	r2,8(sp)
8110ec88:	00a04574 	movhi	r2,33045
8110ec8c:	1081d604 	addi	r2,r2,1880
8110ec90:	d8800115 	stw	r2,4(sp)
8110ec94:	00800044 	movi	r2,1
8110ec98:	d8800015 	stw	r2,0(sp)
8110ec9c:	01c00044 	movi	r7,1
8110eca0:	01a04574 	movhi	r6,33045
8110eca4:	3185d504 	addi	r6,r6,5972
8110eca8:	000b883a 	mov	r5,zero
8110ecac:	01204474 	movhi	r4,33041
8110ecb0:	21262d04 	addi	r4,r4,-26444
8110ecb4:	11343180 	call	81134318 <OSTaskCreateExt>
8110ecb8:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
8110ecbc:	e0bfff03 	ldbu	r2,-4(fp)
8110ecc0:	1000021e 	bne	r2,zero,8110eccc <main+0x160>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
8110ecc4:	112da4c0 	call	8112da4c <OSStart>
8110ecc8:	00000106 	br	8110ecd0 <main+0x164>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
8110eccc:	11115300 	call	81111530 <vFailInitialization>
	}
  
	return 0;
8110ecd0:	0005883a 	mov	r2,zero
}
8110ecd4:	e037883a 	mov	sp,fp
8110ecd8:	dfc00117 	ldw	ra,4(sp)
8110ecdc:	df000017 	ldw	fp,0(sp)
8110ece0:	dec00204 	addi	sp,sp,8
8110ece4:	f800283a 	ret

8110ece8 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
8110ece8:	defffe04 	addi	sp,sp,-8
8110ecec:	de00012e 	bgeu	sp,et,8110ecf4 <vCCDLoadDefaultValues+0xc>
8110ecf0:	003b68fa 	trap	3
8110ecf4:	df000115 	stw	fp,4(sp)
8110ecf8:	df000104 	addi	fp,sp,4
8110ecfc:	e13fff15 	stw	r4,-4(fp)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadCcdDefsSDCard();

	ccdDef->usiHeight = 4510;
8110ed00:	e0bfff17 	ldw	r2,-4(fp)
8110ed04:	00c46784 	movi	r3,4510
8110ed08:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = 30;
8110ed0c:	e0bfff17 	ldw	r2,-4(fp)
8110ed10:	00c00784 	movi	r3,30
8110ed14:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = 2255;
8110ed18:	e0bfff17 	ldw	r2,-4(fp)
8110ed1c:	00c233c4 	movi	r3,2255
8110ed20:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = 15;
8110ed24:	e0bfff17 	ldw	r2,-4(fp)
8110ed28:	00c003c4 	movi	r3,15
8110ed2c:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = 25;
8110ed30:	e0bfff17 	ldw	r2,-4(fp)
8110ed34:	00c00644 	movi	r3,25
8110ed38:	10c0000d 	sth	r3,0(r2)
}
8110ed3c:	0001883a 	nop
8110ed40:	e037883a 	mov	sp,fp
8110ed44:	df000017 	ldw	fp,0(sp)
8110ed48:	dec00104 	addi	sp,sp,4
8110ed4c:	f800283a 	ret

8110ed50 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
8110ed50:	defff904 	addi	sp,sp,-28
8110ed54:	de00012e 	bgeu	sp,et,8110ed5c <vCCDChangeValues+0xc>
8110ed58:	003b68fa 	trap	3
8110ed5c:	df000615 	stw	fp,24(sp)
8110ed60:	df000604 	addi	fp,sp,24
8110ed64:	e13ffa15 	stw	r4,-24(fp)
8110ed68:	2811883a 	mov	r8,r5
8110ed6c:	300b883a 	mov	r5,r6
8110ed70:	3809883a 	mov	r4,r7
8110ed74:	e0c00117 	ldw	r3,4(fp)
8110ed78:	e0800217 	ldw	r2,8(fp)
8110ed7c:	e23ffb0d 	sth	r8,-20(fp)
8110ed80:	e17ffc0d 	sth	r5,-16(fp)
8110ed84:	e13ffd0d 	sth	r4,-12(fp)
8110ed88:	e0fffe0d 	sth	r3,-8(fp)
8110ed8c:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
8110ed90:	e0bffa17 	ldw	r2,-24(fp)
8110ed94:	e0fffb0b 	ldhu	r3,-20(fp)
8110ed98:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
8110ed9c:	e0bffa17 	ldw	r2,-24(fp)
8110eda0:	e0fffc0b 	ldhu	r3,-16(fp)
8110eda4:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
8110eda8:	e0bffa17 	ldw	r2,-24(fp)
8110edac:	e0fffd0b 	ldhu	r3,-12(fp)
8110edb0:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
8110edb4:	e0bffa17 	ldw	r2,-24(fp)
8110edb8:	e0fffe0b 	ldhu	r3,-8(fp)
8110edbc:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
8110edc0:	e0bffa17 	ldw	r2,-24(fp)
8110edc4:	e0ffff0b 	ldhu	r3,-4(fp)
8110edc8:	10c0000d 	sth	r3,0(r2)
}
8110edcc:	0001883a 	nop
8110edd0:	e037883a 	mov	sp,fp
8110edd4:	df000017 	ldw	fp,0(sp)
8110edd8:	dec00104 	addi	sp,sp,4
8110eddc:	f800283a 	ret

8110ede0 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
8110ede0:	defff904 	addi	sp,sp,-28
8110ede4:	de00012e 	bgeu	sp,et,8110edec <bSendUART128v2+0xc>
8110ede8:	003b68fa 	trap	3
8110edec:	dfc00615 	stw	ra,24(sp)
8110edf0:	df000515 	stw	fp,20(sp)
8110edf4:	df000504 	addi	fp,sp,20
8110edf8:	e13ffe15 	stw	r4,-8(fp)
8110edfc:	2805883a 	mov	r2,r5
8110ee00:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
8110ee04:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8110ee08:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8110ee0c:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8110ee10:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8110ee14:	d0a05517 	ldw	r2,-32428(gp)
8110ee18:	e0fffd04 	addi	r3,fp,-12
8110ee1c:	180d883a 	mov	r6,r3
8110ee20:	01400504 	movi	r5,20
8110ee24:	1009883a 	mov	r4,r2
8110ee28:	11337600 	call	81133760 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8110ee2c:	e0bffd03 	ldbu	r2,-12(fp)
8110ee30:	10803fcc 	andi	r2,r2,255
8110ee34:	10000326 	beq	r2,zero,8110ee44 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8110ee38:	11117980 	call	81111798 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
8110ee3c:	e0bffc17 	ldw	r2,-16(fp)
8110ee40:	00009e06 	br	8110f0bc <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8110ee44:	d0a05f17 	ldw	r2,-32388(gp)
8110ee48:	e0fffd04 	addi	r3,fp,-12
8110ee4c:	180d883a 	mov	r6,r3
8110ee50:	01400104 	movi	r5,4
8110ee54:	1009883a 	mov	r4,r2
8110ee58:	11317540 	call	81131754 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110ee5c:	e0bffd03 	ldbu	r2,-12(fp)
8110ee60:	10803fcc 	andi	r2,r2,255
8110ee64:	10001126 	beq	r2,zero,8110eeac <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
8110ee68:	d0a05417 	ldw	r2,-32432(gp)
8110ee6c:	100f883a 	mov	r7,r2
8110ee70:	01801484 	movi	r6,82
8110ee74:	01400044 	movi	r5,1
8110ee78:	01204534 	movhi	r4,33044
8110ee7c:	21091704 	addi	r4,r4,9308
8110ee80:	1115d200 	call	81115d20 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
8110ee84:	d0a05517 	ldw	r2,-32428(gp)
8110ee88:	1009883a 	mov	r4,r2
8110ee8c:	1133ae80 	call	81133ae8 <OSSemPost>
8110ee90:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8110ee94:	e0bffd03 	ldbu	r2,-12(fp)
8110ee98:	10803fcc 	andi	r2,r2,255
8110ee9c:	10000126 	beq	r2,zero,8110eea4 <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8110eea0:	11117300 	call	81111730 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
8110eea4:	e0bffc17 	ldw	r2,-16(fp)
8110eea8:	00008406 	br	8110f0bc <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110eeac:	e03ffb05 	stb	zero,-20(fp)
8110eeb0:	00004306 	br	8110efc0 <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
8110eeb4:	e0fffb03 	ldbu	r3,-20(fp)
8110eeb8:	00a04574 	movhi	r2,33045
8110eebc:	1089d604 	addi	r2,r2,10072
8110eec0:	18c7883a 	add	r3,r3,r3
8110eec4:	18c7883a 	add	r3,r3,r3
8110eec8:	10c5883a 	add	r2,r2,r3
8110eecc:	10800017 	ldw	r2,0(r2)
8110eed0:	1000381e 	bne	r2,zero,8110efb4 <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
8110eed4:	e0bffb03 	ldbu	r2,-20(fp)
8110eed8:	10c02324 	muli	r3,r2,140
8110eedc:	00a04574 	movhi	r2,33045
8110eee0:	1089f404 	addi	r2,r2,10192
8110eee4:	1885883a 	add	r2,r3,r2
8110eee8:	01802004 	movi	r6,128
8110eeec:	000b883a 	mov	r5,zero
8110eef0:	1009883a 	mov	r4,r2
8110eef4:	11168840 	call	81116884 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
8110eef8:	e0bffb03 	ldbu	r2,-20(fp)
8110eefc:	10c02324 	muli	r3,r2,140
8110ef00:	00a04574 	movhi	r2,33045
8110ef04:	1089f404 	addi	r2,r2,10192
8110ef08:	1885883a 	add	r2,r3,r2
8110ef0c:	01801fc4 	movi	r6,127
8110ef10:	e17ffe17 	ldw	r5,-8(fp)
8110ef14:	1009883a 	mov	r4,r2
8110ef18:	11167340 	call	81116734 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
8110ef1c:	e13ffb03 	ldbu	r4,-20(fp)
8110ef20:	e0ffff0b 	ldhu	r3,-4(fp)
8110ef24:	00a04574 	movhi	r2,33045
8110ef28:	1089f404 	addi	r2,r2,10192
8110ef2c:	21002324 	muli	r4,r4,140
8110ef30:	1105883a 	add	r2,r2,r4
8110ef34:	10802104 	addi	r2,r2,132
8110ef38:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
8110ef3c:	e0fffb03 	ldbu	r3,-20(fp)
8110ef40:	00a04574 	movhi	r2,33045
8110ef44:	1089f404 	addi	r2,r2,10192
8110ef48:	18c02324 	muli	r3,r3,140
8110ef4c:	10c5883a 	add	r2,r2,r3
8110ef50:	10802204 	addi	r2,r2,136
8110ef54:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
8110ef58:	e0fffb03 	ldbu	r3,-20(fp)
8110ef5c:	00a04574 	movhi	r2,33045
8110ef60:	1089f404 	addi	r2,r2,10192
8110ef64:	18c02324 	muli	r3,r3,140
8110ef68:	10c5883a 	add	r2,r2,r3
8110ef6c:	10802184 	addi	r2,r2,134
8110ef70:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
8110ef74:	e0fffb03 	ldbu	r3,-20(fp)
8110ef78:	00a04574 	movhi	r2,33045
8110ef7c:	1089f404 	addi	r2,r2,10192
8110ef80:	18c02324 	muli	r3,r3,140
8110ef84:	10c5883a 	add	r2,r2,r3
8110ef88:	10802004 	addi	r2,r2,128
8110ef8c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
8110ef90:	e0fffb03 	ldbu	r3,-20(fp)
8110ef94:	00a04574 	movhi	r2,33045
8110ef98:	1089d604 	addi	r2,r2,10072
8110ef9c:	18c7883a 	add	r3,r3,r3
8110efa0:	18c7883a 	add	r3,r3,r3
8110efa4:	10c5883a 	add	r2,r2,r3
8110efa8:	00c00044 	movi	r3,1
8110efac:	10c00015 	stw	r3,0(r2)
			break;
8110efb0:	00000606 	br	8110efcc <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110efb4:	e0bffb03 	ldbu	r2,-20(fp)
8110efb8:	10800044 	addi	r2,r2,1
8110efbc:	e0bffb05 	stb	r2,-20(fp)
8110efc0:	e0bffb03 	ldbu	r2,-20(fp)
8110efc4:	108001b0 	cmpltui	r2,r2,6
8110efc8:	103fba1e 	bne	r2,zero,8110eeb4 <__reset+0xfb0eeeb4>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
8110efcc:	e0bffb03 	ldbu	r2,-20(fp)
8110efd0:	108001b0 	cmpltui	r2,r2,6
8110efd4:	1000091e 	bne	r2,zero,8110effc <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
8110efd8:	d0a05517 	ldw	r2,-32428(gp)
8110efdc:	1009883a 	mov	r4,r2
8110efe0:	1133ae80 	call	81133ae8 <OSSemPost>
8110efe4:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
8110efe8:	d0a05f17 	ldw	r2,-32388(gp)
8110efec:	1009883a 	mov	r4,r2
8110eff0:	1131cf80 	call	81131cf8 <OSMutexPost>
		return bSuccessL;
8110eff4:	e0bffc17 	ldw	r2,-16(fp)
8110eff8:	00003006 	br	8110f0bc <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
8110effc:	00800044 	movi	r2,1
8110f000:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
8110f004:	d0a06543 	ldbu	r2,-32363(gp)
8110f008:	10bfffc4 	addi	r2,r2,-1
8110f00c:	d0a06545 	stb	r2,-32363(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8110f010:	d0a06417 	ldw	r2,-32368(gp)
8110f014:	e0fffd04 	addi	r3,fp,-12
8110f018:	180d883a 	mov	r6,r3
8110f01c:	01400084 	movi	r5,2
8110f020:	1009883a 	mov	r4,r2
8110f024:	11317540 	call	81131754 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110f028:	e0bffd03 	ldbu	r2,-12(fp)
8110f02c:	10803fcc 	andi	r2,r2,255
8110f030:	10000c26 	beq	r2,zero,8110f064 <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
8110f034:	d0a05417 	ldw	r2,-32432(gp)
8110f038:	100f883a 	mov	r7,r2
8110f03c:	01801c04 	movi	r6,112
8110f040:	01400044 	movi	r5,1
8110f044:	01204534 	movhi	r4,33044
8110f048:	21092c04 	addi	r4,r4,9392
8110f04c:	1115d200 	call	81115d20 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8110f050:	d0a05f17 	ldw	r2,-32388(gp)
8110f054:	1009883a 	mov	r4,r2
8110f058:	1131cf80 	call	81131cf8 <OSMutexPost>
		return bSuccessL;
8110f05c:	e0bffc17 	ldw	r2,-16(fp)
8110f060:	00001606 	br	8110f0bc <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
8110f064:	e0bffb03 	ldbu	r2,-20(fp)
8110f068:	10c02324 	muli	r3,r2,140
8110f06c:	00a04574 	movhi	r2,33045
8110f070:	1089f404 	addi	r2,r2,10192
8110f074:	1885883a 	add	r2,r3,r2
8110f078:	1009883a 	mov	r4,r2
8110f07c:	1116cd00 	call	81116cd0 <puts>
	xBuffer128[ucIL].bSent = TRUE;
8110f080:	e0fffb03 	ldbu	r3,-20(fp)
8110f084:	00a04574 	movhi	r2,33045
8110f088:	1089f404 	addi	r2,r2,10192
8110f08c:	18c02324 	muli	r3,r3,140
8110f090:	10c5883a 	add	r2,r2,r3
8110f094:	10802004 	addi	r2,r2,128
8110f098:	00c00044 	movi	r3,1
8110f09c:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
8110f0a0:	d0a06417 	ldw	r2,-32368(gp)
8110f0a4:	1009883a 	mov	r4,r2
8110f0a8:	1131cf80 	call	81131cf8 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
8110f0ac:	d0a05f17 	ldw	r2,-32388(gp)
8110f0b0:	1009883a 	mov	r4,r2
8110f0b4:	1131cf80 	call	81131cf8 <OSMutexPost>

	return bSuccessL;
8110f0b8:	e0bffc17 	ldw	r2,-16(fp)
}
8110f0bc:	e037883a 	mov	sp,fp
8110f0c0:	dfc00117 	ldw	ra,4(sp)
8110f0c4:	df000017 	ldw	fp,0(sp)
8110f0c8:	dec00204 	addi	sp,sp,8
8110f0cc:	f800283a 	ret

8110f0d0 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
8110f0d0:	defff904 	addi	sp,sp,-28
8110f0d4:	de00012e 	bgeu	sp,et,8110f0dc <bSendUART64v2+0xc>
8110f0d8:	003b68fa 	trap	3
8110f0dc:	dfc00615 	stw	ra,24(sp)
8110f0e0:	df000515 	stw	fp,20(sp)
8110f0e4:	df000504 	addi	fp,sp,20
8110f0e8:	e13ffe15 	stw	r4,-8(fp)
8110f0ec:	2805883a 	mov	r2,r5
8110f0f0:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
8110f0f4:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8110f0f8:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8110f0fc:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8110f100:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8110f104:	d0a05117 	ldw	r2,-32444(gp)
8110f108:	e0fffd04 	addi	r3,fp,-12
8110f10c:	180d883a 	mov	r6,r3
8110f110:	01400504 	movi	r5,20
8110f114:	1009883a 	mov	r4,r2
8110f118:	11337600 	call	81133760 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8110f11c:	e0bffd03 	ldbu	r2,-12(fp)
8110f120:	10803fcc 	andi	r2,r2,255
8110f124:	10000326 	beq	r2,zero,8110f134 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8110f128:	11118000 	call	81111800 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
8110f12c:	e0bffc17 	ldw	r2,-16(fp)
8110f130:	0000a006 	br	8110f3b4 <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8110f134:	d0a06117 	ldw	r2,-32380(gp)
8110f138:	e0fffd04 	addi	r3,fp,-12
8110f13c:	180d883a 	mov	r6,r3
8110f140:	01400104 	movi	r5,4
8110f144:	1009883a 	mov	r4,r2
8110f148:	11317540 	call	81131754 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110f14c:	e0bffd03 	ldbu	r2,-12(fp)
8110f150:	10803fcc 	andi	r2,r2,255
8110f154:	10001126 	beq	r2,zero,8110f19c <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
8110f158:	d0a05417 	ldw	r2,-32432(gp)
8110f15c:	100f883a 	mov	r7,r2
8110f160:	018013c4 	movi	r6,79
8110f164:	01400044 	movi	r5,1
8110f168:	01204534 	movhi	r4,33044
8110f16c:	21094904 	addi	r4,r4,9508
8110f170:	1115d200 	call	81115d20 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
8110f174:	d0a05117 	ldw	r2,-32444(gp)
8110f178:	1009883a 	mov	r4,r2
8110f17c:	1133ae80 	call	81133ae8 <OSSemPost>
8110f180:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8110f184:	e0bffd03 	ldbu	r2,-12(fp)
8110f188:	10803fcc 	andi	r2,r2,255
8110f18c:	10000126 	beq	r2,zero,8110f194 <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8110f190:	11116c80 	call	811116c8 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
8110f194:	e0bffc17 	ldw	r2,-16(fp)
8110f198:	00008606 	br	8110f3b4 <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
8110f19c:	e03ffb05 	stb	zero,-20(fp)
8110f1a0:	00004506 	br	8110f2b8 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
8110f1a4:	e0fffb03 	ldbu	r3,-20(fp)
8110f1a8:	00a04574 	movhi	r2,33045
8110f1ac:	1089d604 	addi	r2,r2,10072
8110f1b0:	18c00184 	addi	r3,r3,6
8110f1b4:	18c7883a 	add	r3,r3,r3
8110f1b8:	18c7883a 	add	r3,r3,r3
8110f1bc:	10c5883a 	add	r2,r2,r3
8110f1c0:	10800017 	ldw	r2,0(r2)
8110f1c4:	1000391e 	bne	r2,zero,8110f2ac <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
8110f1c8:	e0bffb03 	ldbu	r2,-20(fp)
8110f1cc:	10c01324 	muli	r3,r2,76
8110f1d0:	00a04574 	movhi	r2,33045
8110f1d4:	10a53f04 	addi	r2,r2,-27396
8110f1d8:	1885883a 	add	r2,r3,r2
8110f1dc:	01801004 	movi	r6,64
8110f1e0:	000b883a 	mov	r5,zero
8110f1e4:	1009883a 	mov	r4,r2
8110f1e8:	11168840 	call	81116884 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
8110f1ec:	e0bffb03 	ldbu	r2,-20(fp)
8110f1f0:	10c01324 	muli	r3,r2,76
8110f1f4:	00a04574 	movhi	r2,33045
8110f1f8:	10a53f04 	addi	r2,r2,-27396
8110f1fc:	1885883a 	add	r2,r3,r2
8110f200:	01800fc4 	movi	r6,63
8110f204:	e17ffe17 	ldw	r5,-8(fp)
8110f208:	1009883a 	mov	r4,r2
8110f20c:	11167340 	call	81116734 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
8110f210:	e13ffb03 	ldbu	r4,-20(fp)
8110f214:	e0ffff0b 	ldhu	r3,-4(fp)
8110f218:	00a04574 	movhi	r2,33045
8110f21c:	10a53f04 	addi	r2,r2,-27396
8110f220:	21001324 	muli	r4,r4,76
8110f224:	1105883a 	add	r2,r2,r4
8110f228:	10801104 	addi	r2,r2,68
8110f22c:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
8110f230:	e0fffb03 	ldbu	r3,-20(fp)
8110f234:	00a04574 	movhi	r2,33045
8110f238:	10a53f04 	addi	r2,r2,-27396
8110f23c:	18c01324 	muli	r3,r3,76
8110f240:	10c5883a 	add	r2,r2,r3
8110f244:	10801204 	addi	r2,r2,72
8110f248:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
8110f24c:	e0fffb03 	ldbu	r3,-20(fp)
8110f250:	00a04574 	movhi	r2,33045
8110f254:	10a53f04 	addi	r2,r2,-27396
8110f258:	18c01324 	muli	r3,r3,76
8110f25c:	10c5883a 	add	r2,r2,r3
8110f260:	10801184 	addi	r2,r2,70
8110f264:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
8110f268:	e0fffb03 	ldbu	r3,-20(fp)
8110f26c:	00a04574 	movhi	r2,33045
8110f270:	10a53f04 	addi	r2,r2,-27396
8110f274:	18c01324 	muli	r3,r3,76
8110f278:	10c5883a 	add	r2,r2,r3
8110f27c:	10801004 	addi	r2,r2,64
8110f280:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
8110f284:	e0fffb03 	ldbu	r3,-20(fp)
8110f288:	00a04574 	movhi	r2,33045
8110f28c:	1089d604 	addi	r2,r2,10072
8110f290:	18c00184 	addi	r3,r3,6
8110f294:	18c7883a 	add	r3,r3,r3
8110f298:	18c7883a 	add	r3,r3,r3
8110f29c:	10c5883a 	add	r2,r2,r3
8110f2a0:	00c00044 	movi	r3,1
8110f2a4:	10c00015 	stw	r3,0(r2)
			break;
8110f2a8:	00000606 	br	8110f2c4 <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
8110f2ac:	e0bffb03 	ldbu	r2,-20(fp)
8110f2b0:	10800044 	addi	r2,r2,1
8110f2b4:	e0bffb05 	stb	r2,-20(fp)
8110f2b8:	e0bffb03 	ldbu	r2,-20(fp)
8110f2bc:	10800230 	cmpltui	r2,r2,8
8110f2c0:	103fb81e 	bne	r2,zero,8110f1a4 <__reset+0xfb0ef1a4>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
8110f2c4:	e0bffb03 	ldbu	r2,-20(fp)
8110f2c8:	10800230 	cmpltui	r2,r2,8
8110f2cc:	1000091e 	bne	r2,zero,8110f2f4 <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
8110f2d0:	d0a05117 	ldw	r2,-32444(gp)
8110f2d4:	1009883a 	mov	r4,r2
8110f2d8:	1133ae80 	call	81133ae8 <OSSemPost>
8110f2dc:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
8110f2e0:	d0a06117 	ldw	r2,-32380(gp)
8110f2e4:	1009883a 	mov	r4,r2
8110f2e8:	1131cf80 	call	81131cf8 <OSMutexPost>
		return bSuccessL;
8110f2ec:	e0bffc17 	ldw	r2,-16(fp)
8110f2f0:	00003006 	br	8110f3b4 <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
8110f2f4:	00800044 	movi	r2,1
8110f2f8:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
8110f2fc:	d0a06503 	ldbu	r2,-32364(gp)
8110f300:	10bfffc4 	addi	r2,r2,-1
8110f304:	d0a06505 	stb	r2,-32364(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8110f308:	d0a06417 	ldw	r2,-32368(gp)
8110f30c:	e0fffd04 	addi	r3,fp,-12
8110f310:	180d883a 	mov	r6,r3
8110f314:	01400084 	movi	r5,2
8110f318:	1009883a 	mov	r4,r2
8110f31c:	11317540 	call	81131754 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110f320:	e0bffd03 	ldbu	r2,-12(fp)
8110f324:	10803fcc 	andi	r2,r2,255
8110f328:	10000c26 	beq	r2,zero,8110f35c <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
8110f32c:	d0a05417 	ldw	r2,-32432(gp)
8110f330:	100f883a 	mov	r7,r2
8110f334:	01801bc4 	movi	r6,111
8110f338:	01400044 	movi	r5,1
8110f33c:	01204534 	movhi	r4,33044
8110f340:	21095d04 	addi	r4,r4,9588
8110f344:	1115d200 	call	81115d20 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
8110f348:	d0a06117 	ldw	r2,-32380(gp)
8110f34c:	1009883a 	mov	r4,r2
8110f350:	1131cf80 	call	81131cf8 <OSMutexPost>
		return bSuccessL;
8110f354:	e0bffc17 	ldw	r2,-16(fp)
8110f358:	00001606 	br	8110f3b4 <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
8110f35c:	e0bffb03 	ldbu	r2,-20(fp)
8110f360:	10c01324 	muli	r3,r2,76
8110f364:	00a04574 	movhi	r2,33045
8110f368:	10a53f04 	addi	r2,r2,-27396
8110f36c:	1885883a 	add	r2,r3,r2
8110f370:	1009883a 	mov	r4,r2
8110f374:	1116cd00 	call	81116cd0 <puts>
	xBuffer64[ucIL].bSent = TRUE;
8110f378:	e0fffb03 	ldbu	r3,-20(fp)
8110f37c:	00a04574 	movhi	r2,33045
8110f380:	10a53f04 	addi	r2,r2,-27396
8110f384:	18c01324 	muli	r3,r3,76
8110f388:	10c5883a 	add	r2,r2,r3
8110f38c:	10801004 	addi	r2,r2,64
8110f390:	00c00044 	movi	r3,1
8110f394:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
8110f398:	d0a06417 	ldw	r2,-32368(gp)
8110f39c:	1009883a 	mov	r4,r2
8110f3a0:	1131cf80 	call	81131cf8 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
8110f3a4:	d0a06117 	ldw	r2,-32380(gp)
8110f3a8:	1009883a 	mov	r4,r2
8110f3ac:	1131cf80 	call	81131cf8 <OSMutexPost>

	return bSuccessL;
8110f3b0:	e0bffc17 	ldw	r2,-16(fp)
}
8110f3b4:	e037883a 	mov	sp,fp
8110f3b8:	dfc00117 	ldw	ra,4(sp)
8110f3bc:	df000017 	ldw	fp,0(sp)
8110f3c0:	dec00204 	addi	sp,sp,8
8110f3c4:	f800283a 	ret

8110f3c8 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
8110f3c8:	defff904 	addi	sp,sp,-28
8110f3cc:	de00012e 	bgeu	sp,et,8110f3d4 <bSendUART32v2+0xc>
8110f3d0:	003b68fa 	trap	3
8110f3d4:	dfc00615 	stw	ra,24(sp)
8110f3d8:	df000515 	stw	fp,20(sp)
8110f3dc:	df000504 	addi	fp,sp,20
8110f3e0:	e13ffe15 	stw	r4,-8(fp)
8110f3e4:	2805883a 	mov	r2,r5
8110f3e8:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
8110f3ec:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8110f3f0:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8110f3f4:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8110f3f8:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8110f3fc:	d0a06017 	ldw	r2,-32384(gp)
8110f400:	e0fffd04 	addi	r3,fp,-12
8110f404:	180d883a 	mov	r6,r3
8110f408:	01400504 	movi	r5,20
8110f40c:	1009883a 	mov	r4,r2
8110f410:	11337600 	call	81133760 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8110f414:	e0bffd03 	ldbu	r2,-12(fp)
8110f418:	10803fcc 	andi	r2,r2,255
8110f41c:	10000326 	beq	r2,zero,8110f42c <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8110f420:	11118680 	call	81111868 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
8110f424:	e0bffc17 	ldw	r2,-16(fp)
8110f428:	0000a006 	br	8110f6ac <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8110f42c:	d0a05d17 	ldw	r2,-32396(gp)
8110f430:	e0fffd04 	addi	r3,fp,-12
8110f434:	180d883a 	mov	r6,r3
8110f438:	01400104 	movi	r5,4
8110f43c:	1009883a 	mov	r4,r2
8110f440:	11317540 	call	81131754 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110f444:	e0bffd03 	ldbu	r2,-12(fp)
8110f448:	10803fcc 	andi	r2,r2,255
8110f44c:	10001126 	beq	r2,zero,8110f494 <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
8110f450:	d0a05417 	ldw	r2,-32432(gp)
8110f454:	100f883a 	mov	r7,r2
8110f458:	018013c4 	movi	r6,79
8110f45c:	01400044 	movi	r5,1
8110f460:	01204534 	movhi	r4,33044
8110f464:	21097904 	addi	r4,r4,9700
8110f468:	1115d200 	call	81115d20 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
8110f46c:	d0a06017 	ldw	r2,-32384(gp)
8110f470:	1009883a 	mov	r4,r2
8110f474:	1133ae80 	call	81133ae8 <OSSemPost>
8110f478:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8110f47c:	e0bffd03 	ldbu	r2,-12(fp)
8110f480:	10803fcc 	andi	r2,r2,255
8110f484:	10000126 	beq	r2,zero,8110f48c <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8110f488:	11116600 	call	81111660 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
8110f48c:	e0bffc17 	ldw	r2,-16(fp)
8110f490:	00008606 	br	8110f6ac <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
8110f494:	e03ffb05 	stb	zero,-20(fp)
8110f498:	00004506 	br	8110f5b0 <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
8110f49c:	e0fffb03 	ldbu	r3,-20(fp)
8110f4a0:	00a04574 	movhi	r2,33045
8110f4a4:	1089d604 	addi	r2,r2,10072
8110f4a8:	18c00384 	addi	r3,r3,14
8110f4ac:	18c7883a 	add	r3,r3,r3
8110f4b0:	18c7883a 	add	r3,r3,r3
8110f4b4:	10c5883a 	add	r2,r2,r3
8110f4b8:	10800017 	ldw	r2,0(r2)
8110f4bc:	1000391e 	bne	r2,zero,8110f5a4 <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
8110f4c0:	e0bffb03 	ldbu	r2,-20(fp)
8110f4c4:	10c00b24 	muli	r3,r2,44
8110f4c8:	00a04574 	movhi	r2,33045
8110f4cc:	10b76a04 	addi	r2,r2,-8792
8110f4d0:	1885883a 	add	r2,r3,r2
8110f4d4:	01800804 	movi	r6,32
8110f4d8:	000b883a 	mov	r5,zero
8110f4dc:	1009883a 	mov	r4,r2
8110f4e0:	11168840 	call	81116884 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
8110f4e4:	e0bffb03 	ldbu	r2,-20(fp)
8110f4e8:	10c00b24 	muli	r3,r2,44
8110f4ec:	00a04574 	movhi	r2,33045
8110f4f0:	10b76a04 	addi	r2,r2,-8792
8110f4f4:	1885883a 	add	r2,r3,r2
8110f4f8:	018007c4 	movi	r6,31
8110f4fc:	e17ffe17 	ldw	r5,-8(fp)
8110f500:	1009883a 	mov	r4,r2
8110f504:	11167340 	call	81116734 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
8110f508:	e13ffb03 	ldbu	r4,-20(fp)
8110f50c:	e0ffff0b 	ldhu	r3,-4(fp)
8110f510:	00a04574 	movhi	r2,33045
8110f514:	10b76a04 	addi	r2,r2,-8792
8110f518:	21000b24 	muli	r4,r4,44
8110f51c:	1105883a 	add	r2,r2,r4
8110f520:	10800904 	addi	r2,r2,36
8110f524:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
8110f528:	e0fffb03 	ldbu	r3,-20(fp)
8110f52c:	00a04574 	movhi	r2,33045
8110f530:	10b76a04 	addi	r2,r2,-8792
8110f534:	18c00b24 	muli	r3,r3,44
8110f538:	10c5883a 	add	r2,r2,r3
8110f53c:	10800a04 	addi	r2,r2,40
8110f540:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
8110f544:	e0fffb03 	ldbu	r3,-20(fp)
8110f548:	00a04574 	movhi	r2,33045
8110f54c:	10b76a04 	addi	r2,r2,-8792
8110f550:	18c00b24 	muli	r3,r3,44
8110f554:	10c5883a 	add	r2,r2,r3
8110f558:	10800984 	addi	r2,r2,38
8110f55c:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
8110f560:	e0fffb03 	ldbu	r3,-20(fp)
8110f564:	00a04574 	movhi	r2,33045
8110f568:	10b76a04 	addi	r2,r2,-8792
8110f56c:	18c00b24 	muli	r3,r3,44
8110f570:	10c5883a 	add	r2,r2,r3
8110f574:	10800804 	addi	r2,r2,32
8110f578:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
8110f57c:	e0fffb03 	ldbu	r3,-20(fp)
8110f580:	00a04574 	movhi	r2,33045
8110f584:	1089d604 	addi	r2,r2,10072
8110f588:	18c00384 	addi	r3,r3,14
8110f58c:	18c7883a 	add	r3,r3,r3
8110f590:	18c7883a 	add	r3,r3,r3
8110f594:	10c5883a 	add	r2,r2,r3
8110f598:	00c00044 	movi	r3,1
8110f59c:	10c00015 	stw	r3,0(r2)
			break;
8110f5a0:	00000606 	br	8110f5bc <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
8110f5a4:	e0bffb03 	ldbu	r2,-20(fp)
8110f5a8:	10800044 	addi	r2,r2,1
8110f5ac:	e0bffb05 	stb	r2,-20(fp)
8110f5b0:	e0bffb03 	ldbu	r2,-20(fp)
8110f5b4:	10800230 	cmpltui	r2,r2,8
8110f5b8:	103fb81e 	bne	r2,zero,8110f49c <__reset+0xfb0ef49c>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
8110f5bc:	e0bffb03 	ldbu	r2,-20(fp)
8110f5c0:	10800230 	cmpltui	r2,r2,8
8110f5c4:	1000091e 	bne	r2,zero,8110f5ec <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
8110f5c8:	d0a06017 	ldw	r2,-32384(gp)
8110f5cc:	1009883a 	mov	r4,r2
8110f5d0:	1133ae80 	call	81133ae8 <OSSemPost>
8110f5d4:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
8110f5d8:	d0a05d17 	ldw	r2,-32396(gp)
8110f5dc:	1009883a 	mov	r4,r2
8110f5e0:	1131cf80 	call	81131cf8 <OSMutexPost>
		return bSuccessL;
8110f5e4:	e0bffc17 	ldw	r2,-16(fp)
8110f5e8:	00003006 	br	8110f6ac <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
8110f5ec:	00800044 	movi	r2,1
8110f5f0:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
8110f5f4:	d0a05a83 	ldbu	r2,-32406(gp)
8110f5f8:	10bfffc4 	addi	r2,r2,-1
8110f5fc:	d0a05a85 	stb	r2,-32406(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8110f600:	d0a06417 	ldw	r2,-32368(gp)
8110f604:	e0fffd04 	addi	r3,fp,-12
8110f608:	180d883a 	mov	r6,r3
8110f60c:	01400084 	movi	r5,2
8110f610:	1009883a 	mov	r4,r2
8110f614:	11317540 	call	81131754 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110f618:	e0bffd03 	ldbu	r2,-12(fp)
8110f61c:	10803fcc 	andi	r2,r2,255
8110f620:	10000c26 	beq	r2,zero,8110f654 <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
8110f624:	d0a05417 	ldw	r2,-32432(gp)
8110f628:	100f883a 	mov	r7,r2
8110f62c:	01801bc4 	movi	r6,111
8110f630:	01400044 	movi	r5,1
8110f634:	01204534 	movhi	r4,33044
8110f638:	21098d04 	addi	r4,r4,9780
8110f63c:	1115d200 	call	81115d20 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
8110f640:	d0a05d17 	ldw	r2,-32396(gp)
8110f644:	1009883a 	mov	r4,r2
8110f648:	1131cf80 	call	81131cf8 <OSMutexPost>
		return bSuccessL;
8110f64c:	e0bffc17 	ldw	r2,-16(fp)
8110f650:	00001606 	br	8110f6ac <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
8110f654:	e0bffb03 	ldbu	r2,-20(fp)
8110f658:	10c00b24 	muli	r3,r2,44
8110f65c:	00a04574 	movhi	r2,33045
8110f660:	10b76a04 	addi	r2,r2,-8792
8110f664:	1885883a 	add	r2,r3,r2
8110f668:	1009883a 	mov	r4,r2
8110f66c:	1116cd00 	call	81116cd0 <puts>
	xBuffer32[ucIL].bSent = TRUE;
8110f670:	e0fffb03 	ldbu	r3,-20(fp)
8110f674:	00a04574 	movhi	r2,33045
8110f678:	10b76a04 	addi	r2,r2,-8792
8110f67c:	18c00b24 	muli	r3,r3,44
8110f680:	10c5883a 	add	r2,r2,r3
8110f684:	10800804 	addi	r2,r2,32
8110f688:	00c00044 	movi	r3,1
8110f68c:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
8110f690:	d0a06417 	ldw	r2,-32368(gp)
8110f694:	1009883a 	mov	r4,r2
8110f698:	1131cf80 	call	81131cf8 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
8110f69c:	d0a05d17 	ldw	r2,-32396(gp)
8110f6a0:	1009883a 	mov	r4,r2
8110f6a4:	1131cf80 	call	81131cf8 <OSMutexPost>

	return bSuccessL;
8110f6a8:	e0bffc17 	ldw	r2,-16(fp)
}
8110f6ac:	e037883a 	mov	sp,fp
8110f6b0:	dfc00117 	ldw	ra,4(sp)
8110f6b4:	df000017 	ldw	fp,0(sp)
8110f6b8:	dec00204 	addi	sp,sp,8
8110f6bc:	f800283a 	ret

8110f6c0 <vSendEthConf>:


void vSendEthConf ( void ) {
8110f6c0:	deffc304 	addi	sp,sp,-244
8110f6c4:	de00012e 	bgeu	sp,et,8110f6cc <vSendEthConf+0xc>
8110f6c8:	003b68fa 	trap	3
8110f6cc:	dfc03c15 	stw	ra,240(sp)
8110f6d0:	df003b15 	stw	fp,236(sp)
8110f6d4:	dd403a15 	stw	r21,232(sp)
8110f6d8:	dd003915 	stw	r20,228(sp)
8110f6dc:	dcc03815 	stw	r19,224(sp)
8110f6e0:	dc803715 	stw	r18,220(sp)
8110f6e4:	dc403615 	stw	r17,216(sp)
8110f6e8:	dc003515 	stw	r16,212(sp)
8110f6ec:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
8110f6f0:	e03fd98d 	sth	zero,-154(fp)
8110f6f4:	e03fda0d 	sth	zero,-152(fp)
8110f6f8:	e0bfda84 	addi	r2,fp,-150
8110f6fc:	00c01f04 	movi	r3,124
8110f700:	180d883a 	mov	r6,r3
8110f704:	000b883a 	mov	r5,zero
8110f708:	1009883a 	mov	r4,r2
8110f70c:	11168840 	call	81116884 <memset>
    unsigned char crc = 0;
8110f710:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8110f714:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110f718:	110fc800 	call	8110fc80 <usiGetIdCMD>
8110f71c:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f720:	e57fd90b 	ldhu	r21,-156(fp)
8110f724:	00a045b4 	movhi	r2,33046
8110f728:	10a99204 	addi	r2,r2,-22968
8110f72c:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8110f730:	00a045b4 	movhi	r2,33046
8110f734:	10a99204 	addi	r2,r2,-22968
8110f738:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f73c:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8110f740:	00a045b4 	movhi	r2,33046
8110f744:	10a99204 	addi	r2,r2,-22968
8110f748:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f74c:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8110f750:	00a045b4 	movhi	r2,33046
8110f754:	10a99204 	addi	r2,r2,-22968
8110f758:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f75c:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8110f760:	00a045b4 	movhi	r2,33046
8110f764:	10a99204 	addi	r2,r2,-22968
8110f768:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f76c:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8110f770:	00a045b4 	movhi	r2,33046
8110f774:	10a99204 	addi	r2,r2,-22968
8110f778:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f77c:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8110f780:	00a045b4 	movhi	r2,33046
8110f784:	10a99204 	addi	r2,r2,-22968
8110f788:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f78c:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8110f790:	00a045b4 	movhi	r2,33046
8110f794:	10a99204 	addi	r2,r2,-22968
8110f798:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f79c:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8110f7a0:	00a045b4 	movhi	r2,33046
8110f7a4:	10a99204 	addi	r2,r2,-22968
8110f7a8:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f7ac:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8110f7b0:	00a045b4 	movhi	r2,33046
8110f7b4:	10a99204 	addi	r2,r2,-22968
8110f7b8:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f7bc:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8110f7c0:	00a045b4 	movhi	r2,33046
8110f7c4:	10a99204 	addi	r2,r2,-22968
8110f7c8:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f7cc:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8110f7d0:	00a045b4 	movhi	r2,33046
8110f7d4:	10a99204 	addi	r2,r2,-22968
8110f7d8:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f7dc:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8110f7e0:	00a045b4 	movhi	r2,33046
8110f7e4:	10a99204 	addi	r2,r2,-22968
8110f7e8:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f7ec:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8110f7f0:	00a045b4 	movhi	r2,33046
8110f7f4:	10a99204 	addi	r2,r2,-22968
8110f7f8:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f7fc:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8110f800:	00a045b4 	movhi	r2,33046
8110f804:	10a99204 	addi	r2,r2,-22968
8110f808:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f80c:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8110f810:	00a045b4 	movhi	r2,33046
8110f814:	10a99204 	addi	r2,r2,-22968
8110f818:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f81c:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8110f820:	00a045b4 	movhi	r2,33046
8110f824:	10a99204 	addi	r2,r2,-22968
8110f828:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f82c:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
8110f830:	00a045b4 	movhi	r2,33046
8110f834:	10a99204 	addi	r2,r2,-22968
8110f838:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110f83c:	10bfffcc 	andi	r2,r2,65535
8110f840:	e53fd984 	addi	r20,fp,-154
8110f844:	d8801115 	stw	r2,68(sp)
8110f848:	dcc01015 	stw	r19,64(sp)
8110f84c:	dc800f15 	stw	r18,60(sp)
8110f850:	dc400e15 	stw	r17,56(sp)
8110f854:	dc000d15 	stw	r16,52(sp)
8110f858:	dbc00c15 	stw	r15,48(sp)
8110f85c:	db800b15 	stw	r14,44(sp)
8110f860:	db400a15 	stw	r13,40(sp)
8110f864:	db000915 	stw	r12,36(sp)
8110f868:	dac00815 	stw	r11,32(sp)
8110f86c:	da800715 	stw	r10,28(sp)
8110f870:	da400615 	stw	r9,24(sp)
8110f874:	da000515 	stw	r8,20(sp)
8110f878:	d9c00415 	stw	r7,16(sp)
8110f87c:	d9800315 	stw	r6,12(sp)
8110f880:	d9400215 	stw	r5,8(sp)
8110f884:	d9000115 	stw	r4,4(sp)
8110f888:	d8c00015 	stw	r3,0(sp)
8110f88c:	a80f883a 	mov	r7,r21
8110f890:	018010c4 	movi	r6,67
8110f894:	01604534 	movhi	r5,33044
8110f898:	2949a904 	addi	r5,r5,9892
8110f89c:	a009883a 	mov	r4,r20
8110f8a0:	11170140 	call	81117014 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
8110f8a4:	e0bfd984 	addi	r2,fp,-154
8110f8a8:	1009883a 	mov	r4,r2
8110f8ac:	11172280 	call	81117228 <strlen>
8110f8b0:	1007883a 	mov	r3,r2
8110f8b4:	e0bfd984 	addi	r2,fp,-154
8110f8b8:	180b883a 	mov	r5,r3
8110f8bc:	1009883a 	mov	r4,r2
8110f8c0:	1110ef00 	call	81110ef0 <ucCrc8wInit>
8110f8c4:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
8110f8c8:	e13fd703 	ldbu	r4,-164(fp)
8110f8cc:	e0ffd984 	addi	r3,fp,-154
8110f8d0:	e0bfd984 	addi	r2,fp,-154
8110f8d4:	200f883a 	mov	r7,r4
8110f8d8:	180d883a 	mov	r6,r3
8110f8dc:	01604534 	movhi	r5,33044
8110f8e0:	2949c104 	addi	r5,r5,9988
8110f8e4:	1009883a 	mov	r4,r2
8110f8e8:	11170140 	call	81117014 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
8110f8ec:	e0bfd90b 	ldhu	r2,-156(fp)
8110f8f0:	10ffffcc 	andi	r3,r2,65535
8110f8f4:	18e0001c 	xori	r3,r3,32768
8110f8f8:	18e00004 	addi	r3,r3,-32768
8110f8fc:	e0bfd984 	addi	r2,fp,-154
8110f900:	180b883a 	mov	r5,r3
8110f904:	1009883a 	mov	r4,r2
8110f908:	110ede00 	call	8110ede0 <bSendUART128v2>
8110f90c:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
8110f910:	e0bfd817 	ldw	r2,-160(fp)
8110f914:	10800060 	cmpeqi	r2,r2,1
8110f918:	1000011e 	bne	r2,zero,8110f920 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
8110f91c:	1111a700 	call	81111a70 <vCouldNotSendEthConfUART>
	}
}
8110f920:	0001883a 	nop
8110f924:	e6fffa04 	addi	sp,fp,-24
8110f928:	dfc00717 	ldw	ra,28(sp)
8110f92c:	df000617 	ldw	fp,24(sp)
8110f930:	dd400517 	ldw	r21,20(sp)
8110f934:	dd000417 	ldw	r20,16(sp)
8110f938:	dcc00317 	ldw	r19,12(sp)
8110f93c:	dc800217 	ldw	r18,8(sp)
8110f940:	dc400117 	ldw	r17,4(sp)
8110f944:	dc000017 	ldw	r16,0(sp)
8110f948:	dec00804 	addi	sp,sp,32
8110f94c:	f800283a 	ret

8110f950 <vSendTurnOff>:


void vSendTurnOff ( void ) {
8110f950:	defff304 	addi	sp,sp,-52
8110f954:	de00012e 	bgeu	sp,et,8110f95c <vSendTurnOff+0xc>
8110f958:	003b68fa 	trap	3
8110f95c:	dfc00c15 	stw	ra,48(sp)
8110f960:	df000b15 	stw	fp,44(sp)
8110f964:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8110f968:	e03ff78d 	sth	zero,-34(fp)
8110f96c:	e03ff80d 	sth	zero,-32(fp)
8110f970:	e03ff88d 	sth	zero,-30(fp)
8110f974:	e03ff90d 	sth	zero,-28(fp)
8110f978:	e03ff98d 	sth	zero,-26(fp)
8110f97c:	e03ffa0d 	sth	zero,-24(fp)
8110f980:	e03ffa8d 	sth	zero,-22(fp)
8110f984:	e03ffb0d 	sth	zero,-20(fp)
8110f988:	e03ffb8d 	sth	zero,-18(fp)
8110f98c:	e03ffc0d 	sth	zero,-16(fp)
8110f990:	e03ffc8d 	sth	zero,-14(fp)
8110f994:	e03ffd0d 	sth	zero,-12(fp)
8110f998:	e03ffd8d 	sth	zero,-10(fp)
8110f99c:	e03ffe0d 	sth	zero,-8(fp)
8110f9a0:	e03ffe8d 	sth	zero,-6(fp)
8110f9a4:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8110f9a8:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8110f9ac:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110f9b0:	110fc800 	call	8110fc80 <usiGetIdCMD>
8110f9b4:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
8110f9b8:	e0fff70b 	ldhu	r3,-36(fp)
8110f9bc:	e0bff784 	addi	r2,fp,-34
8110f9c0:	180d883a 	mov	r6,r3
8110f9c4:	01604534 	movhi	r5,33044
8110f9c8:	2949c404 	addi	r5,r5,10000
8110f9cc:	1009883a 	mov	r4,r2
8110f9d0:	11170140 	call	81117014 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8110f9d4:	e0bff784 	addi	r2,fp,-34
8110f9d8:	1009883a 	mov	r4,r2
8110f9dc:	11172280 	call	81117228 <strlen>
8110f9e0:	1007883a 	mov	r3,r2
8110f9e4:	e0bff784 	addi	r2,fp,-34
8110f9e8:	180b883a 	mov	r5,r3
8110f9ec:	1009883a 	mov	r4,r2
8110f9f0:	1110ef00 	call	81110ef0 <ucCrc8wInit>
8110f9f4:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8110f9f8:	e13ff503 	ldbu	r4,-44(fp)
8110f9fc:	e0fff784 	addi	r3,fp,-34
8110fa00:	e0bff784 	addi	r2,fp,-34
8110fa04:	200f883a 	mov	r7,r4
8110fa08:	180d883a 	mov	r6,r3
8110fa0c:	01604534 	movhi	r5,33044
8110fa10:	2949c104 	addi	r5,r5,9988
8110fa14:	1009883a 	mov	r4,r2
8110fa18:	11170140 	call	81117014 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8110fa1c:	e0bff70b 	ldhu	r2,-36(fp)
8110fa20:	10ffffcc 	andi	r3,r2,65535
8110fa24:	18e0001c 	xori	r3,r3,32768
8110fa28:	18e00004 	addi	r3,r3,-32768
8110fa2c:	e0bff784 	addi	r2,fp,-34
8110fa30:	180b883a 	mov	r5,r3
8110fa34:	1009883a 	mov	r4,r2
8110fa38:	110f3c80 	call	8110f3c8 <bSendUART32v2>
8110fa3c:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8110fa40:	e0bff617 	ldw	r2,-40(fp)
8110fa44:	10800060 	cmpeqi	r2,r2,1
8110fa48:	1000011e 	bne	r2,zero,8110fa50 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8110fa4c:	11121180 	call	81112118 <vCouldNotSendTurnOff>
	}
}
8110fa50:	0001883a 	nop
8110fa54:	e037883a 	mov	sp,fp
8110fa58:	dfc00117 	ldw	ra,4(sp)
8110fa5c:	df000017 	ldw	fp,0(sp)
8110fa60:	dec00204 	addi	sp,sp,8
8110fa64:	f800283a 	ret

8110fa68 <vSendReset>:

void vSendReset ( void ) {
8110fa68:	defff304 	addi	sp,sp,-52
8110fa6c:	de00012e 	bgeu	sp,et,8110fa74 <vSendReset+0xc>
8110fa70:	003b68fa 	trap	3
8110fa74:	dfc00c15 	stw	ra,48(sp)
8110fa78:	df000b15 	stw	fp,44(sp)
8110fa7c:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8110fa80:	e03ff78d 	sth	zero,-34(fp)
8110fa84:	e03ff80d 	sth	zero,-32(fp)
8110fa88:	e03ff88d 	sth	zero,-30(fp)
8110fa8c:	e03ff90d 	sth	zero,-28(fp)
8110fa90:	e03ff98d 	sth	zero,-26(fp)
8110fa94:	e03ffa0d 	sth	zero,-24(fp)
8110fa98:	e03ffa8d 	sth	zero,-22(fp)
8110fa9c:	e03ffb0d 	sth	zero,-20(fp)
8110faa0:	e03ffb8d 	sth	zero,-18(fp)
8110faa4:	e03ffc0d 	sth	zero,-16(fp)
8110faa8:	e03ffc8d 	sth	zero,-14(fp)
8110faac:	e03ffd0d 	sth	zero,-12(fp)
8110fab0:	e03ffd8d 	sth	zero,-10(fp)
8110fab4:	e03ffe0d 	sth	zero,-8(fp)
8110fab8:	e03ffe8d 	sth	zero,-6(fp)
8110fabc:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8110fac0:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8110fac4:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110fac8:	110fc800 	call	8110fc80 <usiGetIdCMD>
8110facc:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
8110fad0:	e0fff70b 	ldhu	r3,-36(fp)
8110fad4:	e0bff784 	addi	r2,fp,-34
8110fad8:	180d883a 	mov	r6,r3
8110fadc:	01604534 	movhi	r5,33044
8110fae0:	2949c604 	addi	r5,r5,10008
8110fae4:	1009883a 	mov	r4,r2
8110fae8:	11170140 	call	81117014 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8110faec:	e0bff784 	addi	r2,fp,-34
8110faf0:	1009883a 	mov	r4,r2
8110faf4:	11172280 	call	81117228 <strlen>
8110faf8:	1007883a 	mov	r3,r2
8110fafc:	e0bff784 	addi	r2,fp,-34
8110fb00:	180b883a 	mov	r5,r3
8110fb04:	1009883a 	mov	r4,r2
8110fb08:	1110ef00 	call	81110ef0 <ucCrc8wInit>
8110fb0c:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8110fb10:	e13ff503 	ldbu	r4,-44(fp)
8110fb14:	e0fff784 	addi	r3,fp,-34
8110fb18:	e0bff784 	addi	r2,fp,-34
8110fb1c:	200f883a 	mov	r7,r4
8110fb20:	180d883a 	mov	r6,r3
8110fb24:	01604534 	movhi	r5,33044
8110fb28:	2949c104 	addi	r5,r5,9988
8110fb2c:	1009883a 	mov	r4,r2
8110fb30:	11170140 	call	81117014 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8110fb34:	e0bff70b 	ldhu	r2,-36(fp)
8110fb38:	10ffffcc 	andi	r3,r2,65535
8110fb3c:	18e0001c 	xori	r3,r3,32768
8110fb40:	18e00004 	addi	r3,r3,-32768
8110fb44:	e0bff784 	addi	r2,fp,-34
8110fb48:	180b883a 	mov	r5,r3
8110fb4c:	1009883a 	mov	r4,r2
8110fb50:	110f3c80 	call	8110f3c8 <bSendUART32v2>
8110fb54:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8110fb58:	e0bff617 	ldw	r2,-40(fp)
8110fb5c:	10800060 	cmpeqi	r2,r2,1
8110fb60:	1000011e 	bne	r2,zero,8110fb68 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8110fb64:	11121180 	call	81112118 <vCouldNotSendTurnOff>
	}
}
8110fb68:	0001883a 	nop
8110fb6c:	e037883a 	mov	sp,fp
8110fb70:	dfc00117 	ldw	ra,4(sp)
8110fb74:	df000017 	ldw	fp,0(sp)
8110fb78:	dec00204 	addi	sp,sp,8
8110fb7c:	f800283a 	ret

8110fb80 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
8110fb80:	deffda04 	addi	sp,sp,-152
8110fb84:	de00012e 	bgeu	sp,et,8110fb8c <vSendLog+0xc>
8110fb88:	003b68fa 	trap	3
8110fb8c:	dfc02515 	stw	ra,148(sp)
8110fb90:	df002415 	stw	fp,144(sp)
8110fb94:	df002404 	addi	fp,sp,144
8110fb98:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
8110fb9c:	e03fde8d 	sth	zero,-134(fp)
8110fba0:	e03fdf0d 	sth	zero,-132(fp)
8110fba4:	e0bfdf84 	addi	r2,fp,-130
8110fba8:	00c01f04 	movi	r3,124
8110fbac:	180d883a 	mov	r6,r3
8110fbb0:	000b883a 	mov	r5,zero
8110fbb4:	1009883a 	mov	r4,r2
8110fbb8:	11168840 	call	81116884 <memset>
    unsigned char crc = 0;
8110fbbc:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8110fbc0:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110fbc4:	110fc800 	call	8110fc80 <usiGetIdCMD>
8110fbc8:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
8110fbcc:	e0ffde0b 	ldhu	r3,-136(fp)
8110fbd0:	e0bfde84 	addi	r2,fp,-134
8110fbd4:	e1ffff17 	ldw	r7,-4(fp)
8110fbd8:	180d883a 	mov	r6,r3
8110fbdc:	01604534 	movhi	r5,33044
8110fbe0:	2949c804 	addi	r5,r5,10016
8110fbe4:	1009883a 	mov	r4,r2
8110fbe8:	11170140 	call	81117014 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
8110fbec:	e0bfde84 	addi	r2,fp,-134
8110fbf0:	1009883a 	mov	r4,r2
8110fbf4:	11172280 	call	81117228 <strlen>
8110fbf8:	1007883a 	mov	r3,r2
8110fbfc:	e0bfde84 	addi	r2,fp,-134
8110fc00:	180b883a 	mov	r5,r3
8110fc04:	1009883a 	mov	r4,r2
8110fc08:	1110ef00 	call	81110ef0 <ucCrc8wInit>
8110fc0c:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
8110fc10:	e13fdc03 	ldbu	r4,-144(fp)
8110fc14:	e0ffde84 	addi	r3,fp,-134
8110fc18:	e0bfde84 	addi	r2,fp,-134
8110fc1c:	200f883a 	mov	r7,r4
8110fc20:	180d883a 	mov	r6,r3
8110fc24:	01604534 	movhi	r5,33044
8110fc28:	2949c104 	addi	r5,r5,9988
8110fc2c:	1009883a 	mov	r4,r2
8110fc30:	11170140 	call	81117014 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8110fc34:	e0bfde0b 	ldhu	r2,-136(fp)
8110fc38:	10ffffcc 	andi	r3,r2,65535
8110fc3c:	18e0001c 	xori	r3,r3,32768
8110fc40:	18e00004 	addi	r3,r3,-32768
8110fc44:	e0bfde84 	addi	r2,fp,-134
8110fc48:	180b883a 	mov	r5,r3
8110fc4c:	1009883a 	mov	r4,r2
8110fc50:	110ede00 	call	8110ede0 <bSendUART128v2>
8110fc54:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
8110fc58:	e0bfdd17 	ldw	r2,-140(fp)
8110fc5c:	10800060 	cmpeqi	r2,r2,1
8110fc60:	1000011e 	bne	r2,zero,8110fc68 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8110fc64:	11121e80 	call	811121e8 <vCouldNotSendLog>
	}
}
8110fc68:	0001883a 	nop
8110fc6c:	e037883a 	mov	sp,fp
8110fc70:	dfc00117 	ldw	ra,4(sp)
8110fc74:	df000017 	ldw	fp,0(sp)
8110fc78:	dec00204 	addi	sp,sp,8
8110fc7c:	f800283a 	ret

8110fc80 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
8110fc80:	deffff04 	addi	sp,sp,-4
8110fc84:	de00012e 	bgeu	sp,et,8110fc8c <usiGetIdCMD+0xc>
8110fc88:	003b68fa 	trap	3
8110fc8c:	df000015 	stw	fp,0(sp)
8110fc90:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
8110fc94:	d0a05a0b 	ldhu	r2,-32408(gp)
8110fc98:	10ffffcc 	andi	r3,r2,65535
8110fc9c:	00bfffd4 	movui	r2,65535
8110fca0:	1880031e 	bne	r3,r2,8110fcb0 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
8110fca4:	00800084 	movi	r2,2
8110fca8:	d0a05a0d 	sth	r2,-32408(gp)
8110fcac:	00000306 	br	8110fcbc <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
8110fcb0:	d0a05a0b 	ldhu	r2,-32408(gp)
8110fcb4:	10800044 	addi	r2,r2,1
8110fcb8:	d0a05a0d 	sth	r2,-32408(gp)

    return usiIdCMD;
8110fcbc:	d0a05a0b 	ldhu	r2,-32408(gp)
}
8110fcc0:	e037883a 	mov	sp,fp
8110fcc4:	df000017 	ldw	fp,0(sp)
8110fcc8:	dec00104 	addi	sp,sp,4
8110fccc:	f800283a 	ret

8110fcd0 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
8110fcd0:	defffb04 	addi	sp,sp,-20
8110fcd4:	de00012e 	bgeu	sp,et,8110fcdc <siPosStr+0xc>
8110fcd8:	003b68fa 	trap	3
8110fcdc:	dfc00415 	stw	ra,16(sp)
8110fce0:	df000315 	stw	fp,12(sp)
8110fce4:	df000304 	addi	fp,sp,12
8110fce8:	e13ffe15 	stw	r4,-8(fp)
8110fcec:	2805883a 	mov	r2,r5
8110fcf0:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
8110fcf4:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
8110fcf8:	e0bfff03 	ldbu	r2,-4(fp)
8110fcfc:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
8110fd00:	e17ffd04 	addi	r5,fp,-12
8110fd04:	e13ffe17 	ldw	r4,-8(fp)
8110fd08:	11171dc0 	call	811171dc <strcspn>
}
8110fd0c:	e037883a 	mov	sp,fp
8110fd10:	dfc00117 	ldw	ra,4(sp)
8110fd14:	df000017 	ldw	fp,0(sp)
8110fd18:	dec00204 	addi	sp,sp,8
8110fd1c:	f800283a 	ret

8110fd20 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
8110fd20:	defffc04 	addi	sp,sp,-16
8110fd24:	de00012e 	bgeu	sp,et,8110fd2c <vTimeoutCheck+0xc>
8110fd28:	003b68fa 	trap	3
8110fd2c:	dfc00315 	stw	ra,12(sp)
8110fd30:	df000215 	stw	fp,8(sp)
8110fd34:	df000204 	addi	fp,sp,8
8110fd38:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
8110fd3c:	d0a05917 	ldw	r2,-32412(gp)
8110fd40:	1009883a 	mov	r4,r2
8110fd44:	1133ae80 	call	81133ae8 <OSSemPost>
8110fd48:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
8110fd4c:	e0bffe03 	ldbu	r2,-8(fp)
8110fd50:	10000126 	beq	r2,zero,8110fd58 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
8110fd54:	1111ea80 	call	81111ea8 <vFailPostBlockingSemTimeoutTask>
	}
}
8110fd58:	0001883a 	nop
8110fd5c:	e037883a 	mov	sp,fp
8110fd60:	dfc00117 	ldw	ra,4(sp)
8110fd64:	df000017 	ldw	fp,0(sp)
8110fd68:	dec00204 	addi	sp,sp,8
8110fd6c:	f800283a 	ret

8110fd70 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
8110fd70:	deffe304 	addi	sp,sp,-116
8110fd74:	de00012e 	bgeu	sp,et,8110fd7c <vSendPusTM64+0xc>
8110fd78:	003b68fa 	trap	3
8110fd7c:	dfc01815 	stw	ra,96(sp)
8110fd80:	df001715 	stw	fp,92(sp)
8110fd84:	df001704 	addi	fp,sp,92
8110fd88:	e1000215 	stw	r4,8(fp)
8110fd8c:	e1400315 	stw	r5,12(fp)
8110fd90:	e1800415 	stw	r6,16(fp)
8110fd94:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
8110fd98:	e03fef8d 	sth	zero,-66(fp)
8110fd9c:	e03ff00d 	sth	zero,-64(fp)
8110fda0:	e0bff084 	addi	r2,fp,-62
8110fda4:	00c00f04 	movi	r3,60
8110fda8:	180d883a 	mov	r6,r3
8110fdac:	000b883a 	mov	r5,zero
8110fdb0:	1009883a 	mov	r4,r2
8110fdb4:	11168840 	call	81116884 <memset>
    unsigned char crc = 0;
8110fdb8:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
8110fdbc:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8110fdc0:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110fdc4:	110fc800 	call	8110fc80 <usiGetIdCMD>
8110fdc8:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8110fdcc:	e1bfef0b 	ldhu	r6,-68(fp)
8110fdd0:	e080040b 	ldhu	r2,16(fp)
8110fdd4:	11ffffcc 	andi	r7,r2,65535
8110fdd8:	e080048b 	ldhu	r2,18(fp)
8110fddc:	10bfffcc 	andi	r2,r2,65535
8110fde0:	e0c0050b 	ldhu	r3,20(fp)
8110fde4:	18ffffcc 	andi	r3,r3,65535
8110fde8:	e100058b 	ldhu	r4,22(fp)
8110fdec:	213fffcc 	andi	r4,r4,65535
8110fdf0:	e140060b 	ldhu	r5,24(fp)
8110fdf4:	297fffcc 	andi	r5,r5,65535
8110fdf8:	e23fef84 	addi	r8,fp,-66
8110fdfc:	d9400315 	stw	r5,12(sp)
8110fe00:	d9000215 	stw	r4,8(sp)
8110fe04:	d8c00115 	stw	r3,4(sp)
8110fe08:	d8800015 	stw	r2,0(sp)
8110fe0c:	01604534 	movhi	r5,33044
8110fe10:	2949cb04 	addi	r5,r5,10028
8110fe14:	4009883a 	mov	r4,r8
8110fe18:	11170140 	call	81117014 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8110fe1c:	e03fed05 	stb	zero,-76(fp)
8110fe20:	00001206 	br	8110fe6c <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8110fe24:	e0bfed03 	ldbu	r2,-76(fp)
8110fe28:	10800284 	addi	r2,r2,10
8110fe2c:	1085883a 	add	r2,r2,r2
8110fe30:	e0c00204 	addi	r3,fp,8
8110fe34:	1885883a 	add	r2,r3,r2
8110fe38:	1080000b 	ldhu	r2,0(r2)
8110fe3c:	113fffcc 	andi	r4,r2,65535
8110fe40:	e0ffef84 	addi	r3,fp,-66
8110fe44:	e0bfef84 	addi	r2,fp,-66
8110fe48:	200f883a 	mov	r7,r4
8110fe4c:	180d883a 	mov	r6,r3
8110fe50:	01604534 	movhi	r5,33044
8110fe54:	2949d204 	addi	r5,r5,10056
8110fe58:	1009883a 	mov	r4,r2
8110fe5c:	11170140 	call	81117014 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8110fe60:	e0bfed03 	ldbu	r2,-76(fp)
8110fe64:	10800044 	addi	r2,r2,1
8110fe68:	e0bfed05 	stb	r2,-76(fp)
8110fe6c:	e0800683 	ldbu	r2,26(fp)
8110fe70:	10803fcc 	andi	r2,r2,255
8110fe74:	e0ffed03 	ldbu	r3,-76(fp)
8110fe78:	18bfea36 	bltu	r3,r2,8110fe24 <__reset+0xfb0efe24>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8110fe7c:	e0bfef84 	addi	r2,fp,-66
8110fe80:	1009883a 	mov	r4,r2
8110fe84:	11172280 	call	81117228 <strlen>
8110fe88:	1007883a 	mov	r3,r2
8110fe8c:	e0bfef84 	addi	r2,fp,-66
8110fe90:	180b883a 	mov	r5,r3
8110fe94:	1009883a 	mov	r4,r2
8110fe98:	1110ef00 	call	81110ef0 <ucCrc8wInit>
8110fe9c:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8110fea0:	e13fed43 	ldbu	r4,-75(fp)
8110fea4:	e0ffef84 	addi	r3,fp,-66
8110fea8:	e0bfef84 	addi	r2,fp,-66
8110feac:	200f883a 	mov	r7,r4
8110feb0:	180d883a 	mov	r6,r3
8110feb4:	01604534 	movhi	r5,33044
8110feb8:	2949c104 	addi	r5,r5,9988
8110febc:	1009883a 	mov	r4,r2
8110fec0:	11170140 	call	81117014 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
8110fec4:	e0bfef0b 	ldhu	r2,-68(fp)
8110fec8:	10ffffcc 	andi	r3,r2,65535
8110fecc:	18e0001c 	xori	r3,r3,32768
8110fed0:	18e00004 	addi	r3,r3,-32768
8110fed4:	e0bfef84 	addi	r2,fp,-66
8110fed8:	180b883a 	mov	r5,r3
8110fedc:	1009883a 	mov	r4,r2
8110fee0:	110f0d00 	call	8110f0d0 <bSendUART64v2>
8110fee4:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
8110fee8:	e0bfee17 	ldw	r2,-72(fp)
8110feec:	10800060 	cmpeqi	r2,r2,1
8110fef0:	1000031e 	bne	r2,zero,8110ff00 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8110fef4:	e0bfef84 	addi	r2,fp,-66
8110fef8:	1009883a 	mov	r4,r2
8110fefc:	11122500 	call	81112250 <vCouldNotSendTMPusCommand>
	}
}
8110ff00:	0001883a 	nop
8110ff04:	e037883a 	mov	sp,fp
8110ff08:	dfc00117 	ldw	ra,4(sp)
8110ff0c:	df000017 	ldw	fp,0(sp)
8110ff10:	dec00604 	addi	sp,sp,24
8110ff14:	f800283a 	ret

8110ff18 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
8110ff18:	deffd304 	addi	sp,sp,-180
8110ff1c:	de00012e 	bgeu	sp,et,8110ff24 <vSendPusTM128+0xc>
8110ff20:	003b68fa 	trap	3
8110ff24:	dfc02815 	stw	ra,160(sp)
8110ff28:	df002715 	stw	fp,156(sp)
8110ff2c:	df002704 	addi	fp,sp,156
8110ff30:	e1000215 	stw	r4,8(fp)
8110ff34:	e1400315 	stw	r5,12(fp)
8110ff38:	e1800415 	stw	r6,16(fp)
8110ff3c:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
8110ff40:	e03fdf8d 	sth	zero,-130(fp)
8110ff44:	e03fe00d 	sth	zero,-128(fp)
8110ff48:	e0bfe084 	addi	r2,fp,-126
8110ff4c:	00c01f04 	movi	r3,124
8110ff50:	180d883a 	mov	r6,r3
8110ff54:	000b883a 	mov	r5,zero
8110ff58:	1009883a 	mov	r4,r2
8110ff5c:	11168840 	call	81116884 <memset>
    unsigned char crc = 0;
8110ff60:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
8110ff64:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
8110ff68:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110ff6c:	110fc800 	call	8110fc80 <usiGetIdCMD>
8110ff70:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8110ff74:	e1bfdf0b 	ldhu	r6,-132(fp)
8110ff78:	e080040b 	ldhu	r2,16(fp)
8110ff7c:	11ffffcc 	andi	r7,r2,65535
8110ff80:	e080048b 	ldhu	r2,18(fp)
8110ff84:	10bfffcc 	andi	r2,r2,65535
8110ff88:	e0c0050b 	ldhu	r3,20(fp)
8110ff8c:	18ffffcc 	andi	r3,r3,65535
8110ff90:	e100058b 	ldhu	r4,22(fp)
8110ff94:	213fffcc 	andi	r4,r4,65535
8110ff98:	e140060b 	ldhu	r5,24(fp)
8110ff9c:	297fffcc 	andi	r5,r5,65535
8110ffa0:	e23fdf84 	addi	r8,fp,-130
8110ffa4:	d9400315 	stw	r5,12(sp)
8110ffa8:	d9000215 	stw	r4,8(sp)
8110ffac:	d8c00115 	stw	r3,4(sp)
8110ffb0:	d8800015 	stw	r2,0(sp)
8110ffb4:	01604534 	movhi	r5,33044
8110ffb8:	2949cb04 	addi	r5,r5,10028
8110ffbc:	4009883a 	mov	r4,r8
8110ffc0:	11170140 	call	81117014 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8110ffc4:	e03fdd05 	stb	zero,-140(fp)
8110ffc8:	00001206 	br	81110014 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8110ffcc:	e0bfdd03 	ldbu	r2,-140(fp)
8110ffd0:	10800284 	addi	r2,r2,10
8110ffd4:	1085883a 	add	r2,r2,r2
8110ffd8:	e0c00204 	addi	r3,fp,8
8110ffdc:	1885883a 	add	r2,r3,r2
8110ffe0:	1080000b 	ldhu	r2,0(r2)
8110ffe4:	113fffcc 	andi	r4,r2,65535
8110ffe8:	e0ffdf84 	addi	r3,fp,-130
8110ffec:	e0bfdf84 	addi	r2,fp,-130
8110fff0:	200f883a 	mov	r7,r4
8110fff4:	180d883a 	mov	r6,r3
8110fff8:	01604534 	movhi	r5,33044
8110fffc:	2949d204 	addi	r5,r5,10056
81110000:	1009883a 	mov	r4,r2
81110004:	11170140 	call	81117014 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81110008:	e0bfdd03 	ldbu	r2,-140(fp)
8111000c:	10800044 	addi	r2,r2,1
81110010:	e0bfdd05 	stb	r2,-140(fp)
81110014:	e0800683 	ldbu	r2,26(fp)
81110018:	10803fcc 	andi	r2,r2,255
8111001c:	e0ffdd03 	ldbu	r3,-140(fp)
81110020:	18bfea36 	bltu	r3,r2,8110ffcc <__reset+0xfb0effcc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81110024:	e0bfdf84 	addi	r2,fp,-130
81110028:	1009883a 	mov	r4,r2
8111002c:	11172280 	call	81117228 <strlen>
81110030:	1007883a 	mov	r3,r2
81110034:	e0bfdf84 	addi	r2,fp,-130
81110038:	180b883a 	mov	r5,r3
8111003c:	1009883a 	mov	r4,r2
81110040:	1110ef00 	call	81110ef0 <ucCrc8wInit>
81110044:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81110048:	e13fdd43 	ldbu	r4,-139(fp)
8111004c:	e0ffdf84 	addi	r3,fp,-130
81110050:	e0bfdf84 	addi	r2,fp,-130
81110054:	200f883a 	mov	r7,r4
81110058:	180d883a 	mov	r6,r3
8111005c:	01604534 	movhi	r5,33044
81110060:	2949c104 	addi	r5,r5,9988
81110064:	1009883a 	mov	r4,r2
81110068:	11170140 	call	81117014 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
8111006c:	e0bfdf0b 	ldhu	r2,-132(fp)
81110070:	10ffffcc 	andi	r3,r2,65535
81110074:	18e0001c 	xori	r3,r3,32768
81110078:	18e00004 	addi	r3,r3,-32768
8111007c:	e0bfdf84 	addi	r2,fp,-130
81110080:	180b883a 	mov	r5,r3
81110084:	1009883a 	mov	r4,r2
81110088:	110ede00 	call	8110ede0 <bSendUART128v2>
8111008c:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
81110090:	e0bfde17 	ldw	r2,-136(fp)
81110094:	10800060 	cmpeqi	r2,r2,1
81110098:	1000031e 	bne	r2,zero,811100a8 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111009c:	e0bfdf84 	addi	r2,fp,-130
811100a0:	1009883a 	mov	r4,r2
811100a4:	11122500 	call	81112250 <vCouldNotSendTMPusCommand>
	}
}
811100a8:	0001883a 	nop
811100ac:	e037883a 	mov	sp,fp
811100b0:	dfc00117 	ldw	ra,4(sp)
811100b4:	df000017 	ldw	fp,0(sp)
811100b8:	dec00604 	addi	sp,sp,24
811100bc:	f800283a 	ret

811100c0 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
811100c0:	deffd704 	addi	sp,sp,-164
811100c4:	de00012e 	bgeu	sp,et,811100cc <vTMPusTestConnection+0xc>
811100c8:	003b68fa 	trap	3
811100cc:	dfc02815 	stw	ra,160(sp)
811100d0:	df002715 	stw	fp,156(sp)
811100d4:	df002704 	addi	fp,sp,156
811100d8:	2005883a 	mov	r2,r4
811100dc:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
811100e0:	e0bfff0b 	ldhu	r2,-4(fp)
811100e4:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
811100e8:	00801c04 	movi	r2,112
811100ec:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
811100f0:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
811100f4:	00800444 	movi	r2,17
811100f8:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
811100fc:	00800084 	movi	r2,2
81110100:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
81110104:	d809883a 	mov	r4,sp
81110108:	e0bfee04 	addi	r2,fp,-72
8111010c:	00c01104 	movi	r3,68
81110110:	180d883a 	mov	r6,r3
81110114:	100b883a 	mov	r5,r2
81110118:	11167340 	call	81116734 <memcpy>
8111011c:	e13fea17 	ldw	r4,-88(fp)
81110120:	e17feb17 	ldw	r5,-84(fp)
81110124:	e1bfec17 	ldw	r6,-80(fp)
81110128:	e1ffed17 	ldw	r7,-76(fp)
8111012c:	110fd700 	call	8110fd70 <vSendPusTM64>
}
81110130:	0001883a 	nop
81110134:	e037883a 	mov	sp,fp
81110138:	dfc00117 	ldw	ra,4(sp)
8111013c:	df000017 	ldw	fp,0(sp)
81110140:	dec00204 	addi	sp,sp,8
81110144:	f800283a 	ret

81110148 <vLoadDefaultETHConf>:

/*Configuration related to the eth connection*/
TConfEth xConfEth;


bool vLoadDefaultETHConf( void ){
81110148:	defff504 	addi	sp,sp,-44
8111014c:	de00012e 	bgeu	sp,et,81110154 <vLoadDefaultETHConf+0xc>
81110150:	003b68fa 	trap	3
81110154:	dfc00a15 	stw	ra,40(sp)
81110158:	df000915 	stw	fp,36(sp)
8111015c:	dc000815 	stw	r16,32(sp)
81110160:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81110164:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81110168:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8111016c:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81110170:	d0a06617 	ldw	r2,-32360(gp)
81110174:	10800058 	cmpnei	r2,r2,1
81110178:	1002041e 	bne	r2,zero,8111098c <vLoadDefaultETHConf+0x844>
8111017c:	11139dc0 	call	811139dc <bSDcardIsPresent>
81110180:	10020226 	beq	r2,zero,8111098c <vLoadDefaultETHConf+0x844>
81110184:	1113a0c0 	call	81113a0c <bSDcardFAT16Check>
81110188:	10020026 	beq	r2,zero,8111098c <vLoadDefaultETHConf+0x844>

		siFile = siOpenFile( ETH_FILE_NAME );
8111018c:	01204534 	movhi	r4,33044
81110190:	2109d404 	addi	r4,r4,10064
81110194:	1113b340 	call	81113b34 <siOpenFile>
81110198:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8111019c:	e0bffc0f 	ldh	r2,-16(fp)
811101a0:	1001f216 	blt	r2,zero,8111096c <vLoadDefaultETHConf+0x824>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
811101a4:	e0bffd04 	addi	r2,fp,-12
811101a8:	01800204 	movi	r6,8
811101ac:	01400284 	movi	r5,10
811101b0:	1009883a 	mov	r4,r2
811101b4:	11168840 	call	81116884 <memset>
			p_inteiro = inteiro;
811101b8:	e0bffd04 	addi	r2,fp,-12
811101bc:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
811101c0:	e0bffc0f 	ldh	r2,-16(fp)
811101c4:	1009883a 	mov	r4,r2
811101c8:	1113bb00 	call	81113bb0 <cGetNextChar>
811101cc:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
811101d0:	e0bff947 	ldb	r2,-27(fp)
811101d4:	10800084 	addi	r2,r2,2
811101d8:	10c015a8 	cmpgeui	r3,r2,86
811101dc:	1801d71e 	bne	r3,zero,8111093c <vLoadDefaultETHConf+0x7f4>
811101e0:	100690ba 	slli	r3,r2,2
811101e4:	00a04474 	movhi	r2,33041
811101e8:	10807e04 	addi	r2,r2,504
811101ec:	1885883a 	add	r2,r3,r2
811101f0:	10800017 	ldw	r2,0(r2)
811101f4:	1000683a 	jmp	r2
811101f8:	81110390 	cmplti	r4,r16,17422
811101fc:	81110384 	addi	r4,r16,17422
81110200:	8111093c 	xorhi	r4,r16,17444
81110204:	8111093c 	xorhi	r4,r16,17444
81110208:	8111093c 	xorhi	r4,r16,17444
8111020c:	8111093c 	xorhi	r4,r16,17444
81110210:	8111093c 	xorhi	r4,r16,17444
81110214:	8111093c 	xorhi	r4,r16,17444
81110218:	8111093c 	xorhi	r4,r16,17444
8111021c:	8111093c 	xorhi	r4,r16,17444
81110220:	8111093c 	xorhi	r4,r16,17444
81110224:	8111093c 	xorhi	r4,r16,17444
81110228:	8111095c 	xori	r4,r16,17445
8111022c:	8111093c 	xorhi	r4,r16,17444
81110230:	8111093c 	xorhi	r4,r16,17444
81110234:	8111095c 	xori	r4,r16,17445
81110238:	8111093c 	xorhi	r4,r16,17444
8111023c:	8111093c 	xorhi	r4,r16,17444
81110240:	8111093c 	xorhi	r4,r16,17444
81110244:	8111093c 	xorhi	r4,r16,17444
81110248:	8111093c 	xorhi	r4,r16,17444
8111024c:	8111093c 	xorhi	r4,r16,17444
81110250:	8111093c 	xorhi	r4,r16,17444
81110254:	8111093c 	xorhi	r4,r16,17444
81110258:	8111093c 	xorhi	r4,r16,17444
8111025c:	8111093c 	xorhi	r4,r16,17444
81110260:	8111093c 	xorhi	r4,r16,17444
81110264:	8111093c 	xorhi	r4,r16,17444
81110268:	8111093c 	xorhi	r4,r16,17444
8111026c:	8111093c 	xorhi	r4,r16,17444
81110270:	8111093c 	xorhi	r4,r16,17444
81110274:	8111093c 	xorhi	r4,r16,17444
81110278:	8111093c 	xorhi	r4,r16,17444
8111027c:	8111093c 	xorhi	r4,r16,17444
81110280:	8111095c 	xori	r4,r16,17445
81110284:	8111093c 	xorhi	r4,r16,17444
81110288:	8111093c 	xorhi	r4,r16,17444
8111028c:	8111093c 	xorhi	r4,r16,17444
81110290:	8111093c 	xorhi	r4,r16,17444
81110294:	8111093c 	xorhi	r4,r16,17444
81110298:	8111093c 	xorhi	r4,r16,17444
8111029c:	81110350 	cmplti	r4,r16,17421
811102a0:	8111093c 	xorhi	r4,r16,17444
811102a4:	8111093c 	xorhi	r4,r16,17444
811102a8:	8111093c 	xorhi	r4,r16,17444
811102ac:	8111093c 	xorhi	r4,r16,17444
811102b0:	8111093c 	xorhi	r4,r16,17444
811102b4:	8111093c 	xorhi	r4,r16,17444
811102b8:	8111093c 	xorhi	r4,r16,17444
811102bc:	8111093c 	xorhi	r4,r16,17444
811102c0:	8111093c 	xorhi	r4,r16,17444
811102c4:	8111093c 	xorhi	r4,r16,17444
811102c8:	8111093c 	xorhi	r4,r16,17444
811102cc:	8111093c 	xorhi	r4,r16,17444
811102d0:	8111093c 	xorhi	r4,r16,17444
811102d4:	8111093c 	xorhi	r4,r16,17444
811102d8:	8111093c 	xorhi	r4,r16,17444
811102dc:	8111093c 	xorhi	r4,r16,17444
811102e0:	8111093c 	xorhi	r4,r16,17444
811102e4:	8111093c 	xorhi	r4,r16,17444
811102e8:	8111093c 	xorhi	r4,r16,17444
811102ec:	8111093c 	xorhi	r4,r16,17444
811102f0:	811108f4 	orhi	r4,r16,17443
811102f4:	8111093c 	xorhi	r4,r16,17444
811102f8:	8111093c 	xorhi	r4,r16,17444
811102fc:	8111093c 	xorhi	r4,r16,17444
81110300:	8111093c 	xorhi	r4,r16,17444
81110304:	8111093c 	xorhi	r4,r16,17444
81110308:	8111093c 	xorhi	r4,r16,17444
8111030c:	8111093c 	xorhi	r4,r16,17444
81110310:	811106f4 	orhi	r4,r16,17435
81110314:	8111093c 	xorhi	r4,r16,17444
81110318:	8111093c 	xorhi	r4,r16,17444
8111031c:	81110554 	ori	r4,r16,17429
81110320:	8111084c 	andi	r4,r16,17441
81110324:	81110488 	cmpgei	r4,r16,17426
81110328:	8111093c 	xorhi	r4,r16,17444
8111032c:	8111093c 	xorhi	r4,r16,17444
81110330:	8111093c 	xorhi	r4,r16,17444
81110334:	811103b8 	rdprs	r4,r16,17422
81110338:	8111093c 	xorhi	r4,r16,17444
8111033c:	8111093c 	xorhi	r4,r16,17444
81110340:	811107c4 	addi	r4,r16,17439
81110344:	8111093c 	xorhi	r4,r16,17444
81110348:	8111093c 	xorhi	r4,r16,17444
8111034c:	81110624 	muli	r4,r16,17432
					case 39:// single quote '
						c = cGetNextChar(siFile);
81110350:	e0bffc0f 	ldh	r2,-16(fp)
81110354:	1009883a 	mov	r4,r2
81110358:	1113bb00 	call	81113bb0 <cGetNextChar>
8111035c:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81110360:	00000406 	br	81110374 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
81110364:	e0bffc0f 	ldh	r2,-16(fp)
81110368:	1009883a 	mov	r4,r2
8111036c:	1113bb00 	call	81113bb0 <cGetNextChar>
81110370:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
81110374:	e0bff947 	ldb	r2,-27(fp)
81110378:	108009d8 	cmpnei	r2,r2,39
8111037c:	103ff91e 	bne	r2,zero,81110364 <__reset+0xfb0f0364>
							c = cGetNextChar(siFile);
						}
						break;
81110380:	00017706 	br	81110960 <vLoadDefaultETHConf+0x818>
					case -1: 	//EOF
						bEOF = TRUE;
81110384:	00800044 	movi	r2,1
81110388:	e0bff815 	stw	r2,-32(fp)
						break;
8111038c:	00017406 	br	81110960 <vLoadDefaultETHConf+0x818>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81110390:	d0a05417 	ldw	r2,-32432(gp)
81110394:	100f883a 	mov	r7,r2
81110398:	018006c4 	movi	r6,27
8111039c:	01400044 	movi	r5,1
811103a0:	01204534 	movhi	r4,33044
811103a4:	2109d604 	addi	r4,r4,10072
811103a8:	1115d200 	call	81115d20 <fwrite>
						#endif
						bEOF = TRUE;
811103ac:	00800044 	movi	r2,1
811103b0:	e0bff815 	stw	r2,-32(fp)
						break;
811103b4:	00016a06 	br	81110960 <vLoadDefaultETHConf+0x818>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
811103b8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811103bc:	e0bffc0f 	ldh	r2,-16(fp)
811103c0:	1009883a 	mov	r4,r2
811103c4:	1113bb00 	call	81113bb0 <cGetNextChar>
811103c8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811103cc:	d0e00317 	ldw	r3,-32756(gp)
811103d0:	e0bff947 	ldb	r2,-27(fp)
811103d4:	10800044 	addi	r2,r2,1
811103d8:	1885883a 	add	r2,r3,r2
811103dc:	10800003 	ldbu	r2,0(r2)
811103e0:	10803fcc 	andi	r2,r2,255
811103e4:	1080010c 	andi	r2,r2,4
811103e8:	10000626 	beq	r2,zero,81110404 <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
811103ec:	e0bffa17 	ldw	r2,-24(fp)
811103f0:	e0fff943 	ldbu	r3,-27(fp)
811103f4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811103f8:	e0bffa17 	ldw	r2,-24(fp)
811103fc:	10800044 	addi	r2,r2,1
81110400:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
81110404:	e0bff947 	ldb	r2,-27(fp)
81110408:	10800ea0 	cmpeqi	r2,r2,58
8111040c:	1000031e 	bne	r2,zero,8111041c <vLoadDefaultETHConf+0x2d4>
81110410:	e0bff947 	ldb	r2,-27(fp)
81110414:	10800ed8 	cmpnei	r2,r2,59
81110418:	103fe81e 	bne	r2,zero,811103bc <__reset+0xfb0f03bc>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111041c:	e0bffa17 	ldw	r2,-24(fp)
81110420:	00c00284 	movi	r3,10
81110424:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
81110428:	e0bff903 	ldbu	r2,-28(fp)
8111042c:	10800168 	cmpgeui	r2,r2,5
81110430:	1000021e 	bne	r2,zero,8111043c <vLoadDefaultETHConf+0x2f4>
81110434:	e43ff903 	ldbu	r16,-28(fp)
81110438:	00000106 	br	81110440 <vLoadDefaultETHConf+0x2f8>
8111043c:	04000144 	movi	r16,5
81110440:	e0bffd04 	addi	r2,fp,-12
81110444:	1009883a 	mov	r4,r2
81110448:	11155280 	call	81115528 <atoi>
8111044c:	1007883a 	mov	r3,r2
81110450:	00a045b4 	movhi	r2,33046
81110454:	10a99204 	addi	r2,r2,-22968
81110458:	1405883a 	add	r2,r2,r16
8111045c:	10800404 	addi	r2,r2,16
81110460:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81110464:	e0bffd04 	addi	r2,fp,-12
81110468:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111046c:	e0bff903 	ldbu	r2,-28(fp)
81110470:	10800044 	addi	r2,r2,1
81110474:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81110478:	e0bff947 	ldb	r2,-27(fp)
8111047c:	10800ed8 	cmpnei	r2,r2,59
81110480:	103fce1e 	bne	r2,zero,811103bc <__reset+0xfb0f03bc>

						break;
81110484:	00013606 	br	81110960 <vLoadDefaultETHConf+0x818>
					case 'I':

						ucParser = 0;
81110488:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111048c:	e0bffc0f 	ldh	r2,-16(fp)
81110490:	1009883a 	mov	r4,r2
81110494:	1113bb00 	call	81113bb0 <cGetNextChar>
81110498:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111049c:	d0e00317 	ldw	r3,-32756(gp)
811104a0:	e0bff947 	ldb	r2,-27(fp)
811104a4:	10800044 	addi	r2,r2,1
811104a8:	1885883a 	add	r2,r3,r2
811104ac:	10800003 	ldbu	r2,0(r2)
811104b0:	10803fcc 	andi	r2,r2,255
811104b4:	1080010c 	andi	r2,r2,4
811104b8:	10000626 	beq	r2,zero,811104d4 <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
811104bc:	e0bffa17 	ldw	r2,-24(fp)
811104c0:	e0fff943 	ldbu	r3,-27(fp)
811104c4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811104c8:	e0bffa17 	ldw	r2,-24(fp)
811104cc:	10800044 	addi	r2,r2,1
811104d0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811104d4:	e0bff947 	ldb	r2,-27(fp)
811104d8:	10800ba0 	cmpeqi	r2,r2,46
811104dc:	1000031e 	bne	r2,zero,811104ec <vLoadDefaultETHConf+0x3a4>
811104e0:	e0bff947 	ldb	r2,-27(fp)
811104e4:	10800ed8 	cmpnei	r2,r2,59
811104e8:	103fe81e 	bne	r2,zero,8111048c <__reset+0xfb0f048c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811104ec:	e0bffa17 	ldw	r2,-24(fp)
811104f0:	00c00284 	movi	r3,10
811104f4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
811104f8:	e0bff903 	ldbu	r2,-28(fp)
811104fc:	108000e8 	cmpgeui	r2,r2,3
81110500:	1000021e 	bne	r2,zero,8111050c <vLoadDefaultETHConf+0x3c4>
81110504:	e43ff903 	ldbu	r16,-28(fp)
81110508:	00000106 	br	81110510 <vLoadDefaultETHConf+0x3c8>
8111050c:	040000c4 	movi	r16,3
81110510:	e0bffd04 	addi	r2,fp,-12
81110514:	1009883a 	mov	r4,r2
81110518:	11155280 	call	81115528 <atoi>
8111051c:	1007883a 	mov	r3,r2
81110520:	00a045b4 	movhi	r2,33046
81110524:	10a99204 	addi	r2,r2,-22968
81110528:	1405883a 	add	r2,r2,r16
8111052c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81110530:	e0bffd04 	addi	r2,fp,-12
81110534:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81110538:	e0bff903 	ldbu	r2,-28(fp)
8111053c:	10800044 	addi	r2,r2,1
81110540:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81110544:	e0bff947 	ldb	r2,-27(fp)
81110548:	10800ed8 	cmpnei	r2,r2,59
8111054c:	103fcf1e 	bne	r2,zero,8111048c <__reset+0xfb0f048c>

						break;
81110550:	00010306 	br	81110960 <vLoadDefaultETHConf+0x818>
					case 'G':

						ucParser = 0;
81110554:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81110558:	e0bffc0f 	ldh	r2,-16(fp)
8111055c:	1009883a 	mov	r4,r2
81110560:	1113bb00 	call	81113bb0 <cGetNextChar>
81110564:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81110568:	d0e00317 	ldw	r3,-32756(gp)
8111056c:	e0bff947 	ldb	r2,-27(fp)
81110570:	10800044 	addi	r2,r2,1
81110574:	1885883a 	add	r2,r3,r2
81110578:	10800003 	ldbu	r2,0(r2)
8111057c:	10803fcc 	andi	r2,r2,255
81110580:	1080010c 	andi	r2,r2,4
81110584:	10000626 	beq	r2,zero,811105a0 <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
81110588:	e0bffa17 	ldw	r2,-24(fp)
8111058c:	e0fff943 	ldbu	r3,-27(fp)
81110590:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81110594:	e0bffa17 	ldw	r2,-24(fp)
81110598:	10800044 	addi	r2,r2,1
8111059c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811105a0:	e0bff947 	ldb	r2,-27(fp)
811105a4:	10800ba0 	cmpeqi	r2,r2,46
811105a8:	1000031e 	bne	r2,zero,811105b8 <vLoadDefaultETHConf+0x470>
811105ac:	e0bff947 	ldb	r2,-27(fp)
811105b0:	10800ed8 	cmpnei	r2,r2,59
811105b4:	103fe81e 	bne	r2,zero,81110558 <__reset+0xfb0f0558>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811105b8:	e0bffa17 	ldw	r2,-24(fp)
811105bc:	00c00284 	movi	r3,10
811105c0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
811105c4:	e0bff903 	ldbu	r2,-28(fp)
811105c8:	108000e8 	cmpgeui	r2,r2,3
811105cc:	1000021e 	bne	r2,zero,811105d8 <vLoadDefaultETHConf+0x490>
811105d0:	e43ff903 	ldbu	r16,-28(fp)
811105d4:	00000106 	br	811105dc <vLoadDefaultETHConf+0x494>
811105d8:	040000c4 	movi	r16,3
811105dc:	e0bffd04 	addi	r2,fp,-12
811105e0:	1009883a 	mov	r4,r2
811105e4:	11155280 	call	81115528 <atoi>
811105e8:	1007883a 	mov	r3,r2
811105ec:	00a045b4 	movhi	r2,33046
811105f0:	10a99204 	addi	r2,r2,-22968
811105f4:	1405883a 	add	r2,r2,r16
811105f8:	10800104 	addi	r2,r2,4
811105fc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81110600:	e0bffd04 	addi	r2,fp,-12
81110604:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81110608:	e0bff903 	ldbu	r2,-28(fp)
8111060c:	10800044 	addi	r2,r2,1
81110610:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81110614:	e0bff947 	ldb	r2,-27(fp)
81110618:	10800ed8 	cmpnei	r2,r2,59
8111061c:	103fce1e 	bne	r2,zero,81110558 <__reset+0xfb0f0558>

						break;
81110620:	0000cf06 	br	81110960 <vLoadDefaultETHConf+0x818>
					case 'S':

						ucParser = 0;
81110624:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81110628:	e0bffc0f 	ldh	r2,-16(fp)
8111062c:	1009883a 	mov	r4,r2
81110630:	1113bb00 	call	81113bb0 <cGetNextChar>
81110634:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81110638:	d0e00317 	ldw	r3,-32756(gp)
8111063c:	e0bff947 	ldb	r2,-27(fp)
81110640:	10800044 	addi	r2,r2,1
81110644:	1885883a 	add	r2,r3,r2
81110648:	10800003 	ldbu	r2,0(r2)
8111064c:	10803fcc 	andi	r2,r2,255
81110650:	1080010c 	andi	r2,r2,4
81110654:	10000626 	beq	r2,zero,81110670 <vLoadDefaultETHConf+0x528>
									(*p_inteiro) = c;
81110658:	e0bffa17 	ldw	r2,-24(fp)
8111065c:	e0fff943 	ldbu	r3,-27(fp)
81110660:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81110664:	e0bffa17 	ldw	r2,-24(fp)
81110668:	10800044 	addi	r2,r2,1
8111066c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81110670:	e0bff947 	ldb	r2,-27(fp)
81110674:	10800ba0 	cmpeqi	r2,r2,46
81110678:	1000031e 	bne	r2,zero,81110688 <vLoadDefaultETHConf+0x540>
8111067c:	e0bff947 	ldb	r2,-27(fp)
81110680:	10800ed8 	cmpnei	r2,r2,59
81110684:	103fe81e 	bne	r2,zero,81110628 <__reset+0xfb0f0628>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81110688:	e0bffa17 	ldw	r2,-24(fp)
8111068c:	00c00284 	movi	r3,10
81110690:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81110694:	e0bff903 	ldbu	r2,-28(fp)
81110698:	108000e8 	cmpgeui	r2,r2,3
8111069c:	1000021e 	bne	r2,zero,811106a8 <vLoadDefaultETHConf+0x560>
811106a0:	e43ff903 	ldbu	r16,-28(fp)
811106a4:	00000106 	br	811106ac <vLoadDefaultETHConf+0x564>
811106a8:	040000c4 	movi	r16,3
811106ac:	e0bffd04 	addi	r2,fp,-12
811106b0:	1009883a 	mov	r4,r2
811106b4:	11155280 	call	81115528 <atoi>
811106b8:	1007883a 	mov	r3,r2
811106bc:	00a045b4 	movhi	r2,33046
811106c0:	10a99204 	addi	r2,r2,-22968
811106c4:	1405883a 	add	r2,r2,r16
811106c8:	10800204 	addi	r2,r2,8
811106cc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811106d0:	e0bffd04 	addi	r2,fp,-12
811106d4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811106d8:	e0bff903 	ldbu	r2,-28(fp)
811106dc:	10800044 	addi	r2,r2,1
811106e0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811106e4:	e0bff947 	ldb	r2,-27(fp)
811106e8:	10800ed8 	cmpnei	r2,r2,59
811106ec:	103fce1e 	bne	r2,zero,81110628 <__reset+0xfb0f0628>

						break;
811106f0:	00009b06 	br	81110960 <vLoadDefaultETHConf+0x818>
					case 'D':

						ucParser = 0;
811106f4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811106f8:	e0bffc0f 	ldh	r2,-16(fp)
811106fc:	1009883a 	mov	r4,r2
81110700:	1113bb00 	call	81113bb0 <cGetNextChar>
81110704:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81110708:	d0e00317 	ldw	r3,-32756(gp)
8111070c:	e0bff947 	ldb	r2,-27(fp)
81110710:	10800044 	addi	r2,r2,1
81110714:	1885883a 	add	r2,r3,r2
81110718:	10800003 	ldbu	r2,0(r2)
8111071c:	10803fcc 	andi	r2,r2,255
81110720:	1080010c 	andi	r2,r2,4
81110724:	10000626 	beq	r2,zero,81110740 <vLoadDefaultETHConf+0x5f8>
									(*p_inteiro) = c;
81110728:	e0bffa17 	ldw	r2,-24(fp)
8111072c:	e0fff943 	ldbu	r3,-27(fp)
81110730:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81110734:	e0bffa17 	ldw	r2,-24(fp)
81110738:	10800044 	addi	r2,r2,1
8111073c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81110740:	e0bff947 	ldb	r2,-27(fp)
81110744:	10800ba0 	cmpeqi	r2,r2,46
81110748:	1000031e 	bne	r2,zero,81110758 <vLoadDefaultETHConf+0x610>
8111074c:	e0bff947 	ldb	r2,-27(fp)
81110750:	10800ed8 	cmpnei	r2,r2,59
81110754:	103fe81e 	bne	r2,zero,811106f8 <__reset+0xfb0f06f8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81110758:	e0bffa17 	ldw	r2,-24(fp)
8111075c:	00c00284 	movi	r3,10
81110760:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
81110764:	e0bff903 	ldbu	r2,-28(fp)
81110768:	108000e8 	cmpgeui	r2,r2,3
8111076c:	1000021e 	bne	r2,zero,81110778 <vLoadDefaultETHConf+0x630>
81110770:	e43ff903 	ldbu	r16,-28(fp)
81110774:	00000106 	br	8111077c <vLoadDefaultETHConf+0x634>
81110778:	040000c4 	movi	r16,3
8111077c:	e0bffd04 	addi	r2,fp,-12
81110780:	1009883a 	mov	r4,r2
81110784:	11155280 	call	81115528 <atoi>
81110788:	1007883a 	mov	r3,r2
8111078c:	00a045b4 	movhi	r2,33046
81110790:	10a99204 	addi	r2,r2,-22968
81110794:	1405883a 	add	r2,r2,r16
81110798:	10800304 	addi	r2,r2,12
8111079c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811107a0:	e0bffd04 	addi	r2,fp,-12
811107a4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811107a8:	e0bff903 	ldbu	r2,-28(fp)
811107ac:	10800044 	addi	r2,r2,1
811107b0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811107b4:	e0bff947 	ldb	r2,-27(fp)
811107b8:	10800ed8 	cmpnei	r2,r2,59
811107bc:	103fce1e 	bne	r2,zero,811106f8 <__reset+0xfb0f06f8>

						break;						
811107c0:	00006706 	br	81110960 <vLoadDefaultETHConf+0x818>
					case 'P':

						do {
							c = cGetNextChar(siFile);
811107c4:	e0bffc0f 	ldh	r2,-16(fp)
811107c8:	1009883a 	mov	r4,r2
811107cc:	1113bb00 	call	81113bb0 <cGetNextChar>
811107d0:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
811107d4:	d0e00317 	ldw	r3,-32756(gp)
811107d8:	e0bff947 	ldb	r2,-27(fp)
811107dc:	10800044 	addi	r2,r2,1
811107e0:	1885883a 	add	r2,r3,r2
811107e4:	10800003 	ldbu	r2,0(r2)
811107e8:	10803fcc 	andi	r2,r2,255
811107ec:	1080010c 	andi	r2,r2,4
811107f0:	10000626 	beq	r2,zero,8111080c <vLoadDefaultETHConf+0x6c4>
								(*p_inteiro) = c;
811107f4:	e0bffa17 	ldw	r2,-24(fp)
811107f8:	e0fff943 	ldbu	r3,-27(fp)
811107fc:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81110800:	e0bffa17 	ldw	r2,-24(fp)
81110804:	10800044 	addi	r2,r2,1
81110808:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111080c:	e0bff947 	ldb	r2,-27(fp)
81110810:	10800ed8 	cmpnei	r2,r2,59
81110814:	103feb1e 	bne	r2,zero,811107c4 <__reset+0xfb0f07c4>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81110818:	e0bffa17 	ldw	r2,-24(fp)
8111081c:	00c00284 	movi	r3,10
81110820:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
81110824:	e0bffd04 	addi	r2,fp,-12
81110828:	1009883a 	mov	r4,r2
8111082c:	11155280 	call	81115528 <atoi>
81110830:	1007883a 	mov	r3,r2
81110834:	00a045b4 	movhi	r2,33046
81110838:	10a99204 	addi	r2,r2,-22968
8111083c:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81110840:	e0bffd04 	addi	r2,fp,-12
81110844:	e0bffa15 	stw	r2,-24(fp)

						break;
81110848:	00004506 	br	81110960 <vLoadDefaultETHConf+0x818>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8111084c:	e0bffc0f 	ldh	r2,-16(fp)
81110850:	1009883a 	mov	r4,r2
81110854:	1113bb00 	call	81113bb0 <cGetNextChar>
81110858:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111085c:	d0e00317 	ldw	r3,-32756(gp)
81110860:	e0bff947 	ldb	r2,-27(fp)
81110864:	10800044 	addi	r2,r2,1
81110868:	1885883a 	add	r2,r3,r2
8111086c:	10800003 	ldbu	r2,0(r2)
81110870:	10803fcc 	andi	r2,r2,255
81110874:	1080010c 	andi	r2,r2,4
81110878:	10000626 	beq	r2,zero,81110894 <vLoadDefaultETHConf+0x74c>
								(*p_inteiro) = c;
8111087c:	e0bffa17 	ldw	r2,-24(fp)
81110880:	e0fff943 	ldbu	r3,-27(fp)
81110884:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81110888:	e0bffa17 	ldw	r2,-24(fp)
8111088c:	10800044 	addi	r2,r2,1
81110890:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81110894:	e0bff947 	ldb	r2,-27(fp)
81110898:	10800ed8 	cmpnei	r2,r2,59
8111089c:	103feb1e 	bne	r2,zero,8111084c <__reset+0xfb0f084c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811108a0:	e0bffa17 	ldw	r2,-24(fp)
811108a4:	00c00284 	movi	r3,10
811108a8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
811108ac:	e0bffd04 	addi	r2,fp,-12
811108b0:	1009883a 	mov	r4,r2
811108b4:	11155280 	call	81115528 <atoi>
811108b8:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
811108bc:	e0bffc8f 	ldh	r2,-14(fp)
811108c0:	10800058 	cmpnei	r2,r2,1
811108c4:	1000051e 	bne	r2,zero,811108dc <vLoadDefaultETHConf+0x794>
							xConfEth.bDHCP = TRUE;
811108c8:	00a045b4 	movhi	r2,33046
811108cc:	10a99204 	addi	r2,r2,-22968
811108d0:	00c00044 	movi	r3,1
811108d4:	10c00615 	stw	r3,24(r2)
811108d8:	00000306 	br	811108e8 <vLoadDefaultETHConf+0x7a0>
						else
							xConfEth.bDHCP = FALSE;
811108dc:	00a045b4 	movhi	r2,33046
811108e0:	10a99204 	addi	r2,r2,-22968
811108e4:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811108e8:	e0bffd04 	addi	r2,fp,-12
811108ec:	e0bffa15 	stw	r2,-24(fp)

						break;
811108f0:	00001b06 	br	81110960 <vLoadDefaultETHConf+0x818>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
811108f4:	e0bffc0f 	ldh	r2,-16(fp)
811108f8:	1009883a 	mov	r4,r2
811108fc:	1113b700 	call	81113b70 <siCloseFile>
81110900:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
81110904:	e0bffb17 	ldw	r2,-20(fp)
81110908:	1000071e 	bne	r2,zero,81110928 <vLoadDefaultETHConf+0x7e0>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
8111090c:	d0a05417 	ldw	r2,-32432(gp)
81110910:	100f883a 	mov	r7,r2
81110914:	01800784 	movi	r6,30
81110918:	01400044 	movi	r5,1
8111091c:	01204534 	movhi	r4,33044
81110920:	2109dd04 	addi	r4,r4,10100
81110924:	1115d200 	call	81115d20 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81110928:	00800044 	movi	r2,1
8111092c:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
81110930:	00800044 	movi	r2,1
81110934:	e0bff715 	stw	r2,-36(fp)
						break;
81110938:	00000906 	br	81110960 <vLoadDefaultETHConf+0x818>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111093c:	d0a05417 	ldw	r2,-32432(gp)
81110940:	100f883a 	mov	r7,r2
81110944:	01800844 	movi	r6,33
81110948:	01400044 	movi	r5,1
8111094c:	01204534 	movhi	r4,33044
81110950:	2109e504 	addi	r4,r4,10132
81110954:	1115d200 	call	81115d20 <fwrite>
						#endif
						break;
81110958:	00000106 	br	81110960 <vLoadDefaultETHConf+0x818>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111095c:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
81110960:	e0bff817 	ldw	r2,-32(fp)
81110964:	103e1626 	beq	r2,zero,811101c0 <__reset+0xfb0f01c0>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81110968:	00000f06 	br	811109a8 <vLoadDefaultETHConf+0x860>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111096c:	d0a05417 	ldw	r2,-32432(gp)
81110970:	100f883a 	mov	r7,r2
81110974:	01800604 	movi	r6,24
81110978:	01400044 	movi	r5,1
8111097c:	01204534 	movhi	r4,33044
81110980:	2109ee04 	addi	r4,r4,10168
81110984:	1115d200 	call	81115d20 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81110988:	00000706 	br	811109a8 <vLoadDefaultETHConf+0x860>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111098c:	d0a05417 	ldw	r2,-32432(gp)
81110990:	100f883a 	mov	r7,r2
81110994:	018004c4 	movi	r6,19
81110998:	01400044 	movi	r5,1
8111099c:	01204534 	movhi	r4,33044
811109a0:	2109f504 	addi	r4,r4,10196
811109a4:	1115d200 	call	81115d20 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
811109a8:	e0bff717 	ldw	r2,-36(fp)
811109ac:	1000541e 	bne	r2,zero,81110b00 <vLoadDefaultETHConf+0x9b8>
		/*Enviar mensagem que e gravar log que n�o encontrou o arquivo e come�ara a utilizar o padrao*/
		printf("Aten��o: Arquivo de conex�o n�o foi encontrado. Carregando conf padrao\n");
811109b0:	01204534 	movhi	r4,33044
811109b4:	2109fa04 	addi	r4,r4,10216
811109b8:	1116cd00 	call	81116cd0 <puts>
		printf("N�o encontrou:'%s'.\n", ETH_FILE_NAME);
811109bc:	01604534 	movhi	r5,33044
811109c0:	2949d404 	addi	r5,r5,10064
811109c4:	01204534 	movhi	r4,33044
811109c8:	210a0e04 	addi	r4,r4,10296
811109cc:	1116a4c0 	call	81116a4c <printf>


		xConfEth.siPortPUS = 17000;
811109d0:	00a045b4 	movhi	r2,33046
811109d4:	10a99204 	addi	r2,r2,-22968
811109d8:	00d09a04 	movi	r3,17000
811109dc:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
811109e0:	00a045b4 	movhi	r2,33046
811109e4:	10a99204 	addi	r2,r2,-22968
811109e8:	00fff004 	movi	r3,-64
811109ec:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
811109f0:	00a045b4 	movhi	r2,33046
811109f4:	10a99204 	addi	r2,r2,-22968
811109f8:	00ffea04 	movi	r3,-88
811109fc:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
81110a00:	00a045b4 	movhi	r2,33046
81110a04:	10a99204 	addi	r2,r2,-22968
81110a08:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81110a0c:	00a045b4 	movhi	r2,33046
81110a10:	10a99204 	addi	r2,r2,-22968
81110a14:	00c00144 	movi	r3,5
81110a18:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81110a1c:	00a045b4 	movhi	r2,33046
81110a20:	10a99204 	addi	r2,r2,-22968
81110a24:	00fff004 	movi	r3,-64
81110a28:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81110a2c:	00a045b4 	movhi	r2,33046
81110a30:	10a99204 	addi	r2,r2,-22968
81110a34:	00ffea04 	movi	r3,-88
81110a38:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
81110a3c:	00a045b4 	movhi	r2,33046
81110a40:	10a99204 	addi	r2,r2,-22968
81110a44:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
81110a48:	00a045b4 	movhi	r2,33046
81110a4c:	10a99204 	addi	r2,r2,-22968
81110a50:	00c00044 	movi	r3,1
81110a54:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
81110a58:	00a045b4 	movhi	r2,33046
81110a5c:	10a99204 	addi	r2,r2,-22968
81110a60:	00ffffc4 	movi	r3,-1
81110a64:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
81110a68:	00a045b4 	movhi	r2,33046
81110a6c:	10a99204 	addi	r2,r2,-22968
81110a70:	00ffffc4 	movi	r3,-1
81110a74:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
81110a78:	00a045b4 	movhi	r2,33046
81110a7c:	10a99204 	addi	r2,r2,-22968
81110a80:	00ffffc4 	movi	r3,-1
81110a84:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
81110a88:	00a045b4 	movhi	r2,33046
81110a8c:	10a99204 	addi	r2,r2,-22968
81110a90:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
81110a94:	00a045b4 	movhi	r2,33046
81110a98:	10a99204 	addi	r2,r2,-22968
81110a9c:	00ffff04 	movi	r3,-4
81110aa0:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
81110aa4:	00a045b4 	movhi	r2,33046
81110aa8:	10a99204 	addi	r2,r2,-22968
81110aac:	00fffdc4 	movi	r3,-9
81110ab0:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
81110ab4:	00a045b4 	movhi	r2,33046
81110ab8:	10a99204 	addi	r2,r2,-22968
81110abc:	00c018c4 	movi	r3,99
81110ac0:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
81110ac4:	00a045b4 	movhi	r2,33046
81110ac8:	10a99204 	addi	r2,r2,-22968
81110acc:	00c01344 	movi	r3,77
81110ad0:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
81110ad4:	00a045b4 	movhi	r2,33046
81110ad8:	10a99204 	addi	r2,r2,-22968
81110adc:	00c007c4 	movi	r3,31
81110ae0:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
81110ae4:	00a045b4 	movhi	r2,33046
81110ae8:	10a99204 	addi	r2,r2,-22968
81110aec:	00c01084 	movi	r3,66
81110af0:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
81110af4:	00a045b4 	movhi	r2,33046
81110af8:	10a99204 	addi	r2,r2,-22968
81110afc:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
81110b00:	e0bff717 	ldw	r2,-36(fp)
}
81110b04:	e6ffff04 	addi	sp,fp,-4
81110b08:	dfc00217 	ldw	ra,8(sp)
81110b0c:	df000117 	ldw	fp,4(sp)
81110b10:	dc000017 	ldw	r16,0(sp)
81110b14:	dec00304 	addi	sp,sp,12
81110b18:	f800283a 	ret

81110b1c <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
81110b1c:	defff004 	addi	sp,sp,-64
81110b20:	de00012e 	bgeu	sp,et,81110b28 <vShowEthConfig+0xc>
81110b24:	003b68fa 	trap	3
81110b28:	dfc00f15 	stw	ra,60(sp)
81110b2c:	df000e15 	stw	fp,56(sp)
81110b30:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
81110b34:	d0a05417 	ldw	r2,-32432(gp)
81110b38:	100f883a 	mov	r7,r2
81110b3c:	018007c4 	movi	r6,31
81110b40:	01400044 	movi	r5,1
81110b44:	01204534 	movhi	r4,33044
81110b48:	210a1404 	addi	r4,r4,10320
81110b4c:	1115d200 	call	81115d20 <fwrite>

		memset(buffer,0,40);
81110b50:	01800a04 	movi	r6,40
81110b54:	000b883a 	mov	r5,zero
81110b58:	e13ff604 	addi	r4,fp,-40
81110b5c:	11168840 	call	81116884 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
81110b60:	00a045b4 	movhi	r2,33046
81110b64:	10a99204 	addi	r2,r2,-22968
81110b68:	10800403 	ldbu	r2,16(r2)
81110b6c:	11803fcc 	andi	r6,r2,255
81110b70:	00a045b4 	movhi	r2,33046
81110b74:	10a99204 	addi	r2,r2,-22968
81110b78:	10800443 	ldbu	r2,17(r2)
81110b7c:	11c03fcc 	andi	r7,r2,255
81110b80:	00a045b4 	movhi	r2,33046
81110b84:	10a99204 	addi	r2,r2,-22968
81110b88:	10800483 	ldbu	r2,18(r2)
81110b8c:	10c03fcc 	andi	r3,r2,255
81110b90:	00a045b4 	movhi	r2,33046
81110b94:	10a99204 	addi	r2,r2,-22968
81110b98:	108004c3 	ldbu	r2,19(r2)
81110b9c:	11003fcc 	andi	r4,r2,255
81110ba0:	00a045b4 	movhi	r2,33046
81110ba4:	10a99204 	addi	r2,r2,-22968
81110ba8:	10800503 	ldbu	r2,20(r2)
81110bac:	11403fcc 	andi	r5,r2,255
81110bb0:	00a045b4 	movhi	r2,33046
81110bb4:	10a99204 	addi	r2,r2,-22968
81110bb8:	10800543 	ldbu	r2,21(r2)
81110bbc:	10803fcc 	andi	r2,r2,255
81110bc0:	d8800315 	stw	r2,12(sp)
81110bc4:	d9400215 	stw	r5,8(sp)
81110bc8:	d9000115 	stw	r4,4(sp)
81110bcc:	d8c00015 	stw	r3,0(sp)
81110bd0:	01604534 	movhi	r5,33044
81110bd4:	294a1c04 	addi	r5,r5,10352
81110bd8:	e13ff604 	addi	r4,fp,-40
81110bdc:	11170140 	call	81117014 <sprintf>
		debug(fp, buffer );
81110be0:	d0a05417 	ldw	r2,-32432(gp)
81110be4:	e17ff604 	addi	r5,fp,-40
81110be8:	1009883a 	mov	r4,r2
81110bec:	11156840 	call	81115684 <fprintf>

		memset(buffer,0,40);
81110bf0:	01800a04 	movi	r6,40
81110bf4:	000b883a 	mov	r5,zero
81110bf8:	e13ff604 	addi	r4,fp,-40
81110bfc:	11168840 	call	81116884 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
81110c00:	00a045b4 	movhi	r2,33046
81110c04:	10a99204 	addi	r2,r2,-22968
81110c08:	10800003 	ldbu	r2,0(r2)
81110c0c:	11003fcc 	andi	r4,r2,255
81110c10:	00a045b4 	movhi	r2,33046
81110c14:	10a99204 	addi	r2,r2,-22968
81110c18:	10800043 	ldbu	r2,1(r2)
81110c1c:	11403fcc 	andi	r5,r2,255
81110c20:	00a045b4 	movhi	r2,33046
81110c24:	10a99204 	addi	r2,r2,-22968
81110c28:	10800083 	ldbu	r2,2(r2)
81110c2c:	10c03fcc 	andi	r3,r2,255
81110c30:	00a045b4 	movhi	r2,33046
81110c34:	10a99204 	addi	r2,r2,-22968
81110c38:	108000c3 	ldbu	r2,3(r2)
81110c3c:	10803fcc 	andi	r2,r2,255
81110c40:	d8800115 	stw	r2,4(sp)
81110c44:	d8c00015 	stw	r3,0(sp)
81110c48:	280f883a 	mov	r7,r5
81110c4c:	200d883a 	mov	r6,r4
81110c50:	01604534 	movhi	r5,33044
81110c54:	294a2504 	addi	r5,r5,10388
81110c58:	e13ff604 	addi	r4,fp,-40
81110c5c:	11170140 	call	81117014 <sprintf>
		debug(fp, buffer );
81110c60:	d0a05417 	ldw	r2,-32432(gp)
81110c64:	e17ff604 	addi	r5,fp,-40
81110c68:	1009883a 	mov	r4,r2
81110c6c:	11156840 	call	81115684 <fprintf>

		memset(buffer,0,40);
81110c70:	01800a04 	movi	r6,40
81110c74:	000b883a 	mov	r5,zero
81110c78:	e13ff604 	addi	r4,fp,-40
81110c7c:	11168840 	call	81116884 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
81110c80:	00a045b4 	movhi	r2,33046
81110c84:	10a99204 	addi	r2,r2,-22968
81110c88:	10800103 	ldbu	r2,4(r2)
81110c8c:	11003fcc 	andi	r4,r2,255
81110c90:	00a045b4 	movhi	r2,33046
81110c94:	10a99204 	addi	r2,r2,-22968
81110c98:	10800143 	ldbu	r2,5(r2)
81110c9c:	11403fcc 	andi	r5,r2,255
81110ca0:	00a045b4 	movhi	r2,33046
81110ca4:	10a99204 	addi	r2,r2,-22968
81110ca8:	10800183 	ldbu	r2,6(r2)
81110cac:	10c03fcc 	andi	r3,r2,255
81110cb0:	00a045b4 	movhi	r2,33046
81110cb4:	10a99204 	addi	r2,r2,-22968
81110cb8:	108001c3 	ldbu	r2,7(r2)
81110cbc:	10803fcc 	andi	r2,r2,255
81110cc0:	d8800115 	stw	r2,4(sp)
81110cc4:	d8c00015 	stw	r3,0(sp)
81110cc8:	280f883a 	mov	r7,r5
81110ccc:	200d883a 	mov	r6,r4
81110cd0:	01604534 	movhi	r5,33044
81110cd4:	294a2b04 	addi	r5,r5,10412
81110cd8:	e13ff604 	addi	r4,fp,-40
81110cdc:	11170140 	call	81117014 <sprintf>
		debug(fp, buffer );
81110ce0:	d0a05417 	ldw	r2,-32432(gp)
81110ce4:	e17ff604 	addi	r5,fp,-40
81110ce8:	1009883a 	mov	r4,r2
81110cec:	11156840 	call	81115684 <fprintf>

		memset(buffer,0,40);
81110cf0:	01800a04 	movi	r6,40
81110cf4:	000b883a 	mov	r5,zero
81110cf8:	e13ff604 	addi	r4,fp,-40
81110cfc:	11168840 	call	81116884 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
81110d00:	00a045b4 	movhi	r2,33046
81110d04:	10a99204 	addi	r2,r2,-22968
81110d08:	10800203 	ldbu	r2,8(r2)
81110d0c:	11003fcc 	andi	r4,r2,255
81110d10:	00a045b4 	movhi	r2,33046
81110d14:	10a99204 	addi	r2,r2,-22968
81110d18:	10800243 	ldbu	r2,9(r2)
81110d1c:	11403fcc 	andi	r5,r2,255
81110d20:	00a045b4 	movhi	r2,33046
81110d24:	10a99204 	addi	r2,r2,-22968
81110d28:	10800283 	ldbu	r2,10(r2)
81110d2c:	10c03fcc 	andi	r3,r2,255
81110d30:	00a045b4 	movhi	r2,33046
81110d34:	10a99204 	addi	r2,r2,-22968
81110d38:	108002c3 	ldbu	r2,11(r2)
81110d3c:	10803fcc 	andi	r2,r2,255
81110d40:	d8800115 	stw	r2,4(sp)
81110d44:	d8c00015 	stw	r3,0(sp)
81110d48:	280f883a 	mov	r7,r5
81110d4c:	200d883a 	mov	r6,r4
81110d50:	01604534 	movhi	r5,33044
81110d54:	294a3204 	addi	r5,r5,10440
81110d58:	e13ff604 	addi	r4,fp,-40
81110d5c:	11170140 	call	81117014 <sprintf>
		debug(fp, buffer );
81110d60:	d0a05417 	ldw	r2,-32432(gp)
81110d64:	e17ff604 	addi	r5,fp,-40
81110d68:	1009883a 	mov	r4,r2
81110d6c:	11156840 	call	81115684 <fprintf>

		memset(buffer,0,40);
81110d70:	01800a04 	movi	r6,40
81110d74:	000b883a 	mov	r5,zero
81110d78:	e13ff604 	addi	r4,fp,-40
81110d7c:	11168840 	call	81116884 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
81110d80:	00a045b4 	movhi	r2,33046
81110d84:	10a99204 	addi	r2,r2,-22968
81110d88:	10800303 	ldbu	r2,12(r2)
81110d8c:	11003fcc 	andi	r4,r2,255
81110d90:	00a045b4 	movhi	r2,33046
81110d94:	10a99204 	addi	r2,r2,-22968
81110d98:	10800343 	ldbu	r2,13(r2)
81110d9c:	11403fcc 	andi	r5,r2,255
81110da0:	00a045b4 	movhi	r2,33046
81110da4:	10a99204 	addi	r2,r2,-22968
81110da8:	10800383 	ldbu	r2,14(r2)
81110dac:	10c03fcc 	andi	r3,r2,255
81110db0:	00a045b4 	movhi	r2,33046
81110db4:	10a99204 	addi	r2,r2,-22968
81110db8:	108003c3 	ldbu	r2,15(r2)
81110dbc:	10803fcc 	andi	r2,r2,255
81110dc0:	d8800115 	stw	r2,4(sp)
81110dc4:	d8c00015 	stw	r3,0(sp)
81110dc8:	280f883a 	mov	r7,r5
81110dcc:	200d883a 	mov	r6,r4
81110dd0:	01604534 	movhi	r5,33044
81110dd4:	294a3904 	addi	r5,r5,10468
81110dd8:	e13ff604 	addi	r4,fp,-40
81110ddc:	11170140 	call	81117014 <sprintf>
		debug(fp, buffer );
81110de0:	d0a05417 	ldw	r2,-32432(gp)
81110de4:	e17ff604 	addi	r5,fp,-40
81110de8:	1009883a 	mov	r4,r2
81110dec:	11156840 	call	81115684 <fprintf>

		memset(buffer,0,40);
81110df0:	01800a04 	movi	r6,40
81110df4:	000b883a 	mov	r5,zero
81110df8:	e13ff604 	addi	r4,fp,-40
81110dfc:	11168840 	call	81116884 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
81110e00:	00a045b4 	movhi	r2,33046
81110e04:	10a99204 	addi	r2,r2,-22968
81110e08:	1080058b 	ldhu	r2,22(r2)
81110e0c:	10bfffcc 	andi	r2,r2,65535
81110e10:	100d883a 	mov	r6,r2
81110e14:	01604534 	movhi	r5,33044
81110e18:	294a4004 	addi	r5,r5,10496
81110e1c:	e13ff604 	addi	r4,fp,-40
81110e20:	11170140 	call	81117014 <sprintf>
		debug(fp, buffer );
81110e24:	d0a05417 	ldw	r2,-32432(gp)
81110e28:	e17ff604 	addi	r5,fp,-40
81110e2c:	1009883a 	mov	r4,r2
81110e30:	11156840 	call	81115684 <fprintf>

	}
81110e34:	0001883a 	nop
81110e38:	e037883a 	mov	sp,fp
81110e3c:	dfc00117 	ldw	ra,4(sp)
81110e40:	df000017 	ldw	fp,0(sp)
81110e44:	dec00204 	addi	sp,sp,8
81110e48:	f800283a 	ret

81110e4c <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
81110e4c:	defffb04 	addi	sp,sp,-20
81110e50:	de00012e 	bgeu	sp,et,81110e58 <ucCrc8+0xc>
81110e54:	003b68fa 	trap	3
81110e58:	df000415 	stw	fp,16(sp)
81110e5c:	df000404 	addi	fp,sp,16
81110e60:	e13ffd15 	stw	r4,-12(fp)
81110e64:	e17ffe15 	stw	r5,-8(fp)
81110e68:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
81110e6c:	e0bffe17 	ldw	r2,-8(fp)
81110e70:	1000021e 	bne	r2,zero,81110e7c <ucCrc8+0x30>
        return 0;
81110e74:	0005883a 	mov	r2,zero
81110e78:	00001906 	br	81110ee0 <ucCrc8+0x94>
    crc &= 0xff;
81110e7c:	e0bffd17 	ldw	r2,-12(fp)
81110e80:	10803fcc 	andi	r2,r2,255
81110e84:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
81110e88:	e0fffe17 	ldw	r3,-8(fp)
81110e8c:	e0bfff17 	ldw	r2,-4(fp)
81110e90:	1885883a 	add	r2,r3,r2
81110e94:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
81110e98:	00000d06 	br	81110ed0 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
81110e9c:	e0bffe17 	ldw	r2,-8(fp)
81110ea0:	10c00044 	addi	r3,r2,1
81110ea4:	e0fffe15 	stw	r3,-8(fp)
81110ea8:	10800003 	ldbu	r2,0(r2)
81110eac:	10c03fcc 	andi	r3,r2,255
81110eb0:	e0bffd17 	ldw	r2,-12(fp)
81110eb4:	1886f03a 	xor	r3,r3,r2
81110eb8:	00a04534 	movhi	r2,33044
81110ebc:	108a43c4 	addi	r2,r2,10511
81110ec0:	10c5883a 	add	r2,r2,r3
81110ec4:	10800003 	ldbu	r2,0(r2)
81110ec8:	10803fcc 	andi	r2,r2,255
81110ecc:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
81110ed0:	e0fffe17 	ldw	r3,-8(fp)
81110ed4:	e0bffc17 	ldw	r2,-16(fp)
81110ed8:	18bff036 	bltu	r3,r2,81110e9c <__reset+0xfb0f0e9c>
        crc = crc8_table[crc ^ *data++];
    return crc;
81110edc:	e0bffd17 	ldw	r2,-12(fp)
}
81110ee0:	e037883a 	mov	sp,fp
81110ee4:	df000017 	ldw	fp,0(sp)
81110ee8:	dec00104 	addi	sp,sp,4
81110eec:	f800283a 	ret

81110ef0 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
81110ef0:	defffb04 	addi	sp,sp,-20
81110ef4:	de00012e 	bgeu	sp,et,81110efc <ucCrc8wInit+0xc>
81110ef8:	003b68fa 	trap	3
81110efc:	dfc00415 	stw	ra,16(sp)
81110f00:	df000315 	stw	fp,12(sp)
81110f04:	df000304 	addi	fp,sp,12
81110f08:	e13ffe15 	stw	r4,-8(fp)
81110f0c:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
81110f10:	000d883a 	mov	r6,zero
81110f14:	000b883a 	mov	r5,zero
81110f18:	0009883a 	mov	r4,zero
81110f1c:	1110e4c0 	call	81110e4c <ucCrc8>
81110f20:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
81110f24:	e0bffd03 	ldbu	r2,-12(fp)
81110f28:	e1bfff17 	ldw	r6,-4(fp)
81110f2c:	e17ffe17 	ldw	r5,-8(fp)
81110f30:	1009883a 	mov	r4,r2
81110f34:	1110e4c0 	call	81110e4c <ucCrc8>
}
81110f38:	e037883a 	mov	sp,fp
81110f3c:	dfc00117 	ldw	ra,4(sp)
81110f40:	df000017 	ldw	fp,0(sp)
81110f44:	dec00204 	addi	sp,sp,8
81110f48:	f800283a 	ret

81110f4c <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
81110f4c:	defffc04 	addi	sp,sp,-16
81110f50:	de00012e 	bgeu	sp,et,81110f58 <vDataControllerInit+0xc>
81110f54:	003b68fa 	trap	3
81110f58:	df000315 	stw	fp,12(sp)
81110f5c:	df000304 	addi	fp,sp,12
81110f60:	e13ffe15 	stw	r4,-8(fp)
81110f64:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81110f68:	e03ffd05 	stb	zero,-12(fp)
81110f6c:	00001c06 	br	81110fe0 <vDataControllerInit+0x94>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
81110f70:	e0bffd03 	ldbu	r2,-12(fp)
81110f74:	e0fffd03 	ldbu	r3,-12(fp)
81110f78:	18c02c24 	muli	r3,r3,176
81110f7c:	e13fff17 	ldw	r4,-4(fp)
81110f80:	20c7883a 	add	r3,r4,r3
81110f84:	e13ffe17 	ldw	r4,-8(fp)
81110f88:	10800244 	addi	r2,r2,9
81110f8c:	1085883a 	add	r2,r2,r2
81110f90:	1085883a 	add	r2,r2,r2
81110f94:	2085883a 	add	r2,r4,r2
81110f98:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
81110f9c:	e17ffd03 	ldbu	r5,-12(fp)
81110fa0:	e0bffd03 	ldbu	r2,-12(fp)
81110fa4:	e0ffff17 	ldw	r3,-4(fp)
81110fa8:	10804204 	addi	r2,r2,264
81110fac:	1085883a 	add	r2,r2,r2
81110fb0:	1085883a 	add	r2,r2,r2
81110fb4:	1885883a 	add	r2,r3,r2
81110fb8:	10c00017 	ldw	r3,0(r2)
81110fbc:	e13ffe17 	ldw	r4,-8(fp)
81110fc0:	288003c4 	addi	r2,r5,15
81110fc4:	1085883a 	add	r2,r2,r2
81110fc8:	1085883a 	add	r2,r2,r2
81110fcc:	2085883a 	add	r2,r4,r2
81110fd0:	10c00015 	stw	r3,0(r2)


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81110fd4:	e0bffd03 	ldbu	r2,-12(fp)
81110fd8:	10800044 	addi	r2,r2,1
81110fdc:	e0bffd05 	stb	r2,-12(fp)
81110fe0:	e0bffd03 	ldbu	r2,-12(fp)
81110fe4:	108001b0 	cmpltui	r2,r2,6
81110fe8:	103fe11e 	bne	r2,zero,81110f70 <__reset+0xfb0f0f70>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
81110fec:	e0bfff17 	ldw	r2,-4(fp)
81110ff0:	10c10e04 	addi	r3,r2,1080
81110ff4:	e0bffe17 	ldw	r2,-8(fp)
81110ff8:	10c01515 	stw	r3,84(r2)
	xDataControlL->bUpdateComplete = FALSE;
81110ffc:	e0bffe17 	ldw	r2,-8(fp)
81111000:	10001615 	stw	zero,88(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
81111004:	e0bffe17 	ldw	r2,-8(fp)
81111008:	10c01604 	addi	r3,r2,88
8111100c:	e0bfff17 	ldw	r2,-4(fp)
81111010:	10c11015 	stw	r3,1088(r2)
}
81111014:	0001883a 	nop
81111018:	e037883a 	mov	sp,fp
8111101c:	df000017 	ldw	fp,0(sp)
81111020:	dec00104 	addi	sp,sp,4
81111024:	f800283a 	ret

81111028 <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
81111028:	defff904 	addi	sp,sp,-28
8111102c:	de00012e 	bgeu	sp,et,81111034 <printErrorTask+0xc>
81111030:	003b68fa 	trap	3
81111034:	dfc00615 	stw	ra,24(sp)
81111038:	df000515 	stw	fp,20(sp)
8111103c:	df000504 	addi	fp,sp,20
81111040:	2005883a 	mov	r2,r4
81111044:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
81111048:	e03ffb15 	stw	zero,-20(fp)
8111104c:	e03ffc15 	stw	zero,-16(fp)
81111050:	e03ffd15 	stw	zero,-12(fp)
81111054:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
81111058:	e0bfff03 	ldbu	r2,-4(fp)
8111105c:	100d883a 	mov	r6,r2
81111060:	01604534 	movhi	r5,33044
81111064:	294a8404 	addi	r5,r5,10768
81111068:	e13ffb04 	addi	r4,fp,-20
8111106c:	11170140 	call	81117014 <sprintf>
		debug(fp, buffer);
81111070:	d0a05417 	ldw	r2,-32432(gp)
81111074:	e17ffb04 	addi	r5,fp,-20
81111078:	1009883a 	mov	r4,r2
8111107c:	11156840 	call	81115684 <fprintf>
	}
81111080:	0001883a 	nop
81111084:	e037883a 	mov	sp,fp
81111088:	dfc00117 	ldw	ra,4(sp)
8111108c:	df000017 	ldw	fp,0(sp)
81111090:	dec00204 	addi	sp,sp,8
81111094:	f800283a 	ret

81111098 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
81111098:	defffd04 	addi	sp,sp,-12
8111109c:	de00012e 	bgeu	sp,et,811110a4 <vFailCreateMutexSResources+0xc>
811110a0:	003b68fa 	trap	3
811110a4:	dfc00215 	stw	ra,8(sp)
811110a8:	df000115 	stw	fp,4(sp)
811110ac:	df000104 	addi	fp,sp,4
811110b0:	2005883a 	mov	r2,r4
811110b4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
811110b8:	d0a05417 	ldw	r2,-32432(gp)
811110bc:	100f883a 	mov	r7,r2
811110c0:	018008c4 	movi	r6,35
811110c4:	01400044 	movi	r5,1
811110c8:	01204534 	movhi	r4,33044
811110cc:	210a8704 	addi	r4,r4,10780
811110d0:	1115d200 	call	81115d20 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
811110d4:	e0bfff03 	ldbu	r2,-4(fp)
811110d8:	1009883a 	mov	r4,r2
811110dc:	11110280 	call	81111028 <printErrorTask>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811110e0:	0001883a 	nop
811110e4:	e037883a 	mov	sp,fp
811110e8:	dfc00117 	ldw	ra,4(sp)
811110ec:	df000017 	ldw	fp,0(sp)
811110f0:	dec00204 	addi	sp,sp,8
811110f4:	f800283a 	ret

811110f8 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
811110f8:	defffe04 	addi	sp,sp,-8
811110fc:	de00012e 	bgeu	sp,et,81111104 <vFailCreateSemaphoreResources+0xc>
81111100:	003b68fa 	trap	3
81111104:	dfc00115 	stw	ra,4(sp)
81111108:	df000015 	stw	fp,0(sp)
8111110c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
81111110:	d0a05417 	ldw	r2,-32432(gp)
81111114:	100f883a 	mov	r7,r2
81111118:	01800984 	movi	r6,38
8111111c:	01400044 	movi	r5,1
81111120:	01204534 	movhi	r4,33044
81111124:	210a9004 	addi	r4,r4,10816
81111128:	1115d200 	call	81115d20 <fwrite>

	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8111112c:	0001883a 	nop
81111130:	e037883a 	mov	sp,fp
81111134:	dfc00117 	ldw	ra,4(sp)
81111138:	df000017 	ldw	fp,0(sp)
8111113c:	dec00204 	addi	sp,sp,8
81111140:	f800283a 	ret

81111144 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
81111144:	defffe04 	addi	sp,sp,-8
81111148:	de00012e 	bgeu	sp,et,81111150 <vFailTestCriticasParts+0xc>
8111114c:	003b68fa 	trap	3
81111150:	dfc00115 	stw	ra,4(sp)
81111154:	df000015 	stw	fp,0(sp)
81111158:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8111115c:	d0a05417 	ldw	r2,-32432(gp)
81111160:	100f883a 	mov	r7,r2
81111164:	018007c4 	movi	r6,31
81111168:	01400044 	movi	r5,1
8111116c:	01204534 	movhi	r4,33044
81111170:	210a9a04 	addi	r4,r4,10856
81111174:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111178:	0001883a 	nop
8111117c:	e037883a 	mov	sp,fp
81111180:	dfc00117 	ldw	ra,4(sp)
81111184:	df000017 	ldw	fp,0(sp)
81111188:	dec00204 	addi	sp,sp,8
8111118c:	f800283a 	ret

81111190 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
81111190:	defffe04 	addi	sp,sp,-8
81111194:	de00012e 	bgeu	sp,et,8111119c <vFailSendxSemCommInit+0xc>
81111198:	003b68fa 	trap	3
8111119c:	dfc00115 	stw	ra,4(sp)
811111a0:	df000015 	stw	fp,0(sp)
811111a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
811111a8:	d0a05417 	ldw	r2,-32432(gp)
811111ac:	100f883a 	mov	r7,r2
811111b0:	01800744 	movi	r6,29
811111b4:	01400044 	movi	r5,1
811111b8:	01204534 	movhi	r4,33044
811111bc:	210aa204 	addi	r4,r4,10888
811111c0:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
811111c4:	d0a05417 	ldw	r2,-32432(gp)
811111c8:	100f883a 	mov	r7,r2
811111cc:	01800a44 	movi	r6,41
811111d0:	01400044 	movi	r5,1
811111d4:	01204534 	movhi	r4,33044
811111d8:	210aaa04 	addi	r4,r4,10920
811111dc:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811111e0:	0001883a 	nop
811111e4:	e037883a 	mov	sp,fp
811111e8:	dfc00117 	ldw	ra,4(sp)
811111ec:	df000017 	ldw	fp,0(sp)
811111f0:	dec00204 	addi	sp,sp,8
811111f4:	f800283a 	ret

811111f8 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
811111f8:	defffe04 	addi	sp,sp,-8
811111fc:	de00012e 	bgeu	sp,et,81111204 <vFailSendPreParsedSemaphore+0xc>
81111200:	003b68fa 	trap	3
81111204:	dfc00115 	stw	ra,4(sp)
81111208:	df000015 	stw	fp,0(sp)
8111120c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
81111210:	d0a05417 	ldw	r2,-32432(gp)
81111214:	100f883a 	mov	r7,r2
81111218:	01800904 	movi	r6,36
8111121c:	01400044 	movi	r5,1
81111220:	01204534 	movhi	r4,33044
81111224:	210ab504 	addi	r4,r4,10964
81111228:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8111122c:	0001883a 	nop
81111230:	e037883a 	mov	sp,fp
81111234:	dfc00117 	ldw	ra,4(sp)
81111238:	df000017 	ldw	fp,0(sp)
8111123c:	dec00204 	addi	sp,sp,8
81111240:	f800283a 	ret

81111244 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
81111244:	defffe04 	addi	sp,sp,-8
81111248:	de00012e 	bgeu	sp,et,81111250 <vFailSendPreAckReceiverSemaphore+0xc>
8111124c:	003b68fa 	trap	3
81111250:	dfc00115 	stw	ra,4(sp)
81111254:	df000015 	stw	fp,0(sp)
81111258:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8111125c:	d0a05417 	ldw	r2,-32432(gp)
81111260:	100f883a 	mov	r7,r2
81111264:	01800a44 	movi	r6,41
81111268:	01400044 	movi	r5,1
8111126c:	01204534 	movhi	r4,33044
81111270:	210abf04 	addi	r4,r4,11004
81111274:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111278:	0001883a 	nop
8111127c:	e037883a 	mov	sp,fp
81111280:	dfc00117 	ldw	ra,4(sp)
81111284:	df000017 	ldw	fp,0(sp)
81111288:	dec00204 	addi	sp,sp,8
8111128c:	f800283a 	ret

81111290 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
81111290:	defffe04 	addi	sp,sp,-8
81111294:	de00012e 	bgeu	sp,et,8111129c <vFailSendPreAckSenderSemaphore+0xc>
81111298:	003b68fa 	trap	3
8111129c:	dfc00115 	stw	ra,4(sp)
811112a0:	df000015 	stw	fp,0(sp)
811112a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
811112a8:	d0a05417 	ldw	r2,-32432(gp)
811112ac:	100f883a 	mov	r7,r2
811112b0:	018009c4 	movi	r6,39
811112b4:	01400044 	movi	r5,1
811112b8:	01204534 	movhi	r4,33044
811112bc:	210aca04 	addi	r4,r4,11048
811112c0:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811112c4:	0001883a 	nop
811112c8:	e037883a 	mov	sp,fp
811112cc:	dfc00117 	ldw	ra,4(sp)
811112d0:	df000017 	ldw	fp,0(sp)
811112d4:	dec00204 	addi	sp,sp,8
811112d8:	f800283a 	ret

811112dc <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
811112dc:	defffe04 	addi	sp,sp,-8
811112e0:	de00012e 	bgeu	sp,et,811112e8 <vFailGetCountSemaphoreSenderTask+0xc>
811112e4:	003b68fa 	trap	3
811112e8:	dfc00115 	stw	ra,4(sp)
811112ec:	df000015 	stw	fp,0(sp)
811112f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
811112f4:	d0a05417 	ldw	r2,-32432(gp)
811112f8:	100f883a 	mov	r7,r2
811112fc:	01800a44 	movi	r6,41
81111300:	01400044 	movi	r5,1
81111304:	01204534 	movhi	r4,33044
81111308:	210ad404 	addi	r4,r4,11088
8111130c:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
81111310:	d0a05417 	ldw	r2,-32432(gp)
81111314:	100f883a 	mov	r7,r2
81111318:	01801104 	movi	r6,68
8111131c:	01400044 	movi	r5,1
81111320:	01204534 	movhi	r4,33044
81111324:	210adf04 	addi	r4,r4,11132
81111328:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8111132c:	0001883a 	nop
81111330:	e037883a 	mov	sp,fp
81111334:	dfc00117 	ldw	ra,4(sp)
81111338:	df000017 	ldw	fp,0(sp)
8111133c:	dec00204 	addi	sp,sp,8
81111340:	f800283a 	ret

81111344 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
81111344:	defffe04 	addi	sp,sp,-8
81111348:	de00012e 	bgeu	sp,et,81111350 <vFailGetMutexSenderTask+0xc>
8111134c:	003b68fa 	trap	3
81111350:	dfc00115 	stw	ra,4(sp)
81111354:	df000015 	stw	fp,0(sp)
81111358:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8111135c:	d0a05417 	ldw	r2,-32432(gp)
81111360:	100f883a 	mov	r7,r2
81111364:	01800804 	movi	r6,32
81111368:	01400044 	movi	r5,1
8111136c:	01204534 	movhi	r4,33044
81111370:	210af104 	addi	r4,r4,11204
81111374:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
81111378:	d0a05417 	ldw	r2,-32432(gp)
8111137c:	100f883a 	mov	r7,r2
81111380:	01801084 	movi	r6,66
81111384:	01400044 	movi	r5,1
81111388:	01204534 	movhi	r4,33044
8111138c:	210afa04 	addi	r4,r4,11240
81111390:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111394:	0001883a 	nop
81111398:	e037883a 	mov	sp,fp
8111139c:	dfc00117 	ldw	ra,4(sp)
811113a0:	df000017 	ldw	fp,0(sp)
811113a4:	dec00204 	addi	sp,sp,8
811113a8:	f800283a 	ret

811113ac <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
811113ac:	defffe04 	addi	sp,sp,-8
811113b0:	de00012e 	bgeu	sp,et,811113b8 <vFailGetCountSemaphoreReceiverTask+0xc>
811113b4:	003b68fa 	trap	3
811113b8:	dfc00115 	stw	ra,4(sp)
811113bc:	df000015 	stw	fp,0(sp)
811113c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
811113c4:	d0a05417 	ldw	r2,-32432(gp)
811113c8:	100f883a 	mov	r7,r2
811113cc:	01800ac4 	movi	r6,43
811113d0:	01400044 	movi	r5,1
811113d4:	01204534 	movhi	r4,33044
811113d8:	210b0b04 	addi	r4,r4,11308
811113dc:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
811113e0:	d0a05417 	ldw	r2,-32432(gp)
811113e4:	100f883a 	mov	r7,r2
811113e8:	01801184 	movi	r6,70
811113ec:	01400044 	movi	r5,1
811113f0:	01204534 	movhi	r4,33044
811113f4:	210b1604 	addi	r4,r4,11352
811113f8:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811113fc:	0001883a 	nop
81111400:	e037883a 	mov	sp,fp
81111404:	dfc00117 	ldw	ra,4(sp)
81111408:	df000017 	ldw	fp,0(sp)
8111140c:	dec00204 	addi	sp,sp,8
81111410:	f800283a 	ret

81111414 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
81111414:	defffe04 	addi	sp,sp,-8
81111418:	de00012e 	bgeu	sp,et,81111420 <vFailGetMutexReceiverTask+0xc>
8111141c:	003b68fa 	trap	3
81111420:	dfc00115 	stw	ra,4(sp)
81111424:	df000015 	stw	fp,0(sp)
81111428:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8111142c:	d0a05417 	ldw	r2,-32432(gp)
81111430:	100f883a 	mov	r7,r2
81111434:	01800884 	movi	r6,34
81111438:	01400044 	movi	r5,1
8111143c:	01204534 	movhi	r4,33044
81111440:	210b2804 	addi	r4,r4,11424
81111444:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
81111448:	d0a05417 	ldw	r2,-32432(gp)
8111144c:	100f883a 	mov	r7,r2
81111450:	01801104 	movi	r6,68
81111454:	01400044 	movi	r5,1
81111458:	01204534 	movhi	r4,33044
8111145c:	210b3104 	addi	r4,r4,11460
81111460:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111464:	0001883a 	nop
81111468:	e037883a 	mov	sp,fp
8111146c:	dfc00117 	ldw	ra,4(sp)
81111470:	df000017 	ldw	fp,0(sp)
81111474:	dec00204 	addi	sp,sp,8
81111478:	f800283a 	ret

8111147c <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8111147c:	defffe04 	addi	sp,sp,-8
81111480:	de00012e 	bgeu	sp,et,81111488 <vFailGetMutexTxUARTSenderTask+0xc>
81111484:	003b68fa 	trap	3
81111488:	dfc00115 	stw	ra,4(sp)
8111148c:	df000015 	stw	fp,0(sp)
81111490:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
81111494:	d0a05417 	ldw	r2,-32432(gp)
81111498:	100f883a 	mov	r7,r2
8111149c:	01800984 	movi	r6,38
811114a0:	01400044 	movi	r5,1
811114a4:	01204534 	movhi	r4,33044
811114a8:	210b4304 	addi	r4,r4,11532
811114ac:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
811114b0:	d0a05417 	ldw	r2,-32432(gp)
811114b4:	100f883a 	mov	r7,r2
811114b8:	01801044 	movi	r6,65
811114bc:	01400044 	movi	r5,1
811114c0:	01204534 	movhi	r4,33044
811114c4:	210b4d04 	addi	r4,r4,11572
811114c8:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811114cc:	0001883a 	nop
811114d0:	e037883a 	mov	sp,fp
811114d4:	dfc00117 	ldw	ra,4(sp)
811114d8:	df000017 	ldw	fp,0(sp)
811114dc:	dec00204 	addi	sp,sp,8
811114e0:	f800283a 	ret

811114e4 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
811114e4:	defffe04 	addi	sp,sp,-8
811114e8:	de00012e 	bgeu	sp,et,811114f0 <vFailGetMacRTC+0xc>
811114ec:	003b68fa 	trap	3
811114f0:	dfc00115 	stw	ra,4(sp)
811114f4:	df000015 	stw	fp,0(sp)
811114f8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
811114fc:	d0a05417 	ldw	r2,-32432(gp)
81111500:	100f883a 	mov	r7,r2
81111504:	018003c4 	movi	r6,15
81111508:	01400044 	movi	r5,1
8111150c:	01204534 	movhi	r4,33044
81111510:	210b5e04 	addi	r4,r4,11640
81111514:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111518:	0001883a 	nop
8111151c:	e037883a 	mov	sp,fp
81111520:	dfc00117 	ldw	ra,4(sp)
81111524:	df000017 	ldw	fp,0(sp)
81111528:	dec00204 	addi	sp,sp,8
8111152c:	f800283a 	ret

81111530 <vFailInitialization>:


void vFailInitialization( void )
{
81111530:	defffe04 	addi	sp,sp,-8
81111534:	de00012e 	bgeu	sp,et,8111153c <vFailInitialization+0xc>
81111538:	003b68fa 	trap	3
8111153c:	dfc00115 	stw	ra,4(sp)
81111540:	df000015 	stw	fp,0(sp)
81111544:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
81111548:	d0a05417 	ldw	r2,-32432(gp)
8111154c:	100f883a 	mov	r7,r2
81111550:	01800504 	movi	r6,20
81111554:	01400044 	movi	r5,1
81111558:	01204534 	movhi	r4,33044
8111155c:	210b6204 	addi	r4,r4,11656
81111560:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111564:	0001883a 	nop
81111568:	e037883a 	mov	sp,fp
8111156c:	dfc00117 	ldw	ra,4(sp)
81111570:	df000017 	ldw	fp,0(sp)
81111574:	dec00204 	addi	sp,sp,8
81111578:	f800283a 	ret

8111157c <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8111157c:	defffe04 	addi	sp,sp,-8
81111580:	de00012e 	bgeu	sp,et,81111588 <vFailReceiverCreate+0xc>
81111584:	003b68fa 	trap	3
81111588:	dfc00115 	stw	ra,4(sp)
8111158c:	df000015 	stw	fp,0(sp)
81111590:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
81111594:	d0a05417 	ldw	r2,-32432(gp)
81111598:	100f883a 	mov	r7,r2
8111159c:	01800484 	movi	r6,18
811115a0:	01400044 	movi	r5,1
811115a4:	01204534 	movhi	r4,33044
811115a8:	210b6804 	addi	r4,r4,11680
811115ac:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811115b0:	0001883a 	nop
811115b4:	e037883a 	mov	sp,fp
811115b8:	dfc00117 	ldw	ra,4(sp)
811115bc:	df000017 	ldw	fp,0(sp)
811115c0:	dec00204 	addi	sp,sp,8
811115c4:	f800283a 	ret

811115c8 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
811115c8:	defffe04 	addi	sp,sp,-8
811115cc:	de00012e 	bgeu	sp,et,811115d4 <vFailSenderCreate+0xc>
811115d0:	003b68fa 	trap	3
811115d4:	dfc00115 	stw	ra,4(sp)
811115d8:	df000015 	stw	fp,0(sp)
811115dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
811115e0:	d0a05417 	ldw	r2,-32432(gp)
811115e4:	100f883a 	mov	r7,r2
811115e8:	01800484 	movi	r6,18
811115ec:	01400044 	movi	r5,1
811115f0:	01204534 	movhi	r4,33044
811115f4:	210b6d04 	addi	r4,r4,11700
811115f8:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811115fc:	0001883a 	nop
81111600:	e037883a 	mov	sp,fp
81111604:	dfc00117 	ldw	ra,4(sp)
81111608:	df000017 	ldw	fp,0(sp)
8111160c:	dec00204 	addi	sp,sp,8
81111610:	f800283a 	ret

81111614 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
81111614:	defffe04 	addi	sp,sp,-8
81111618:	de00012e 	bgeu	sp,et,81111620 <vFailDeleteInitialization+0xc>
8111161c:	003b68fa 	trap	3
81111620:	dfc00115 	stw	ra,4(sp)
81111624:	df000015 	stw	fp,0(sp)
81111628:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
8111162c:	d0a05417 	ldw	r2,-32432(gp)
81111630:	100f883a 	mov	r7,r2
81111634:	01800684 	movi	r6,26
81111638:	01400044 	movi	r5,1
8111163c:	01204534 	movhi	r4,33044
81111640:	210b7204 	addi	r4,r4,11720
81111644:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111648:	0001883a 	nop
8111164c:	e037883a 	mov	sp,fp
81111650:	dfc00117 	ldw	ra,4(sp)
81111654:	df000017 	ldw	fp,0(sp)
81111658:	dec00204 	addi	sp,sp,8
8111165c:	f800283a 	ret

81111660 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
81111660:	defffe04 	addi	sp,sp,-8
81111664:	de00012e 	bgeu	sp,et,8111166c <vFailSetCountSemaphorexBuffer32+0xc>
81111668:	003b68fa 	trap	3
8111166c:	dfc00115 	stw	ra,4(sp)
81111670:	df000015 	stw	fp,0(sp)
81111674:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
81111678:	d0a05417 	ldw	r2,-32432(gp)
8111167c:	100f883a 	mov	r7,r2
81111680:	01800a04 	movi	r6,40
81111684:	01400044 	movi	r5,1
81111688:	01204534 	movhi	r4,33044
8111168c:	210b7904 	addi	r4,r4,11748
81111690:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81111694:	d0a05417 	ldw	r2,-32432(gp)
81111698:	100f883a 	mov	r7,r2
8111169c:	018008c4 	movi	r6,35
811116a0:	01400044 	movi	r5,1
811116a4:	01204534 	movhi	r4,33044
811116a8:	210b8404 	addi	r4,r4,11792
811116ac:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811116b0:	0001883a 	nop
811116b4:	e037883a 	mov	sp,fp
811116b8:	dfc00117 	ldw	ra,4(sp)
811116bc:	df000017 	ldw	fp,0(sp)
811116c0:	dec00204 	addi	sp,sp,8
811116c4:	f800283a 	ret

811116c8 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
811116c8:	defffe04 	addi	sp,sp,-8
811116cc:	de00012e 	bgeu	sp,et,811116d4 <vFailSetCountSemaphorexBuffer64+0xc>
811116d0:	003b68fa 	trap	3
811116d4:	dfc00115 	stw	ra,4(sp)
811116d8:	df000015 	stw	fp,0(sp)
811116dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
811116e0:	d0a05417 	ldw	r2,-32432(gp)
811116e4:	100f883a 	mov	r7,r2
811116e8:	01800a04 	movi	r6,40
811116ec:	01400044 	movi	r5,1
811116f0:	01204534 	movhi	r4,33044
811116f4:	210b8d04 	addi	r4,r4,11828
811116f8:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
811116fc:	d0a05417 	ldw	r2,-32432(gp)
81111700:	100f883a 	mov	r7,r2
81111704:	018008c4 	movi	r6,35
81111708:	01400044 	movi	r5,1
8111170c:	01204534 	movhi	r4,33044
81111710:	210b8404 	addi	r4,r4,11792
81111714:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111718:	0001883a 	nop
8111171c:	e037883a 	mov	sp,fp
81111720:	dfc00117 	ldw	ra,4(sp)
81111724:	df000017 	ldw	fp,0(sp)
81111728:	dec00204 	addi	sp,sp,8
8111172c:	f800283a 	ret

81111730 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
81111730:	defffe04 	addi	sp,sp,-8
81111734:	de00012e 	bgeu	sp,et,8111173c <vFailSetCountSemaphorexBuffer128+0xc>
81111738:	003b68fa 	trap	3
8111173c:	dfc00115 	stw	ra,4(sp)
81111740:	df000015 	stw	fp,0(sp)
81111744:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
81111748:	d0a05417 	ldw	r2,-32432(gp)
8111174c:	100f883a 	mov	r7,r2
81111750:	01800a44 	movi	r6,41
81111754:	01400044 	movi	r5,1
81111758:	01204534 	movhi	r4,33044
8111175c:	210b9804 	addi	r4,r4,11872
81111760:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81111764:	d0a05417 	ldw	r2,-32432(gp)
81111768:	100f883a 	mov	r7,r2
8111176c:	018008c4 	movi	r6,35
81111770:	01400044 	movi	r5,1
81111774:	01204534 	movhi	r4,33044
81111778:	210b8404 	addi	r4,r4,11792
8111177c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111780:	0001883a 	nop
81111784:	e037883a 	mov	sp,fp
81111788:	dfc00117 	ldw	ra,4(sp)
8111178c:	df000017 	ldw	fp,0(sp)
81111790:	dec00204 	addi	sp,sp,8
81111794:	f800283a 	ret

81111798 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
81111798:	defffe04 	addi	sp,sp,-8
8111179c:	de00012e 	bgeu	sp,et,811117a4 <vFailGetCountSemaphorexBuffer128+0xc>
811117a0:	003b68fa 	trap	3
811117a4:	dfc00115 	stw	ra,4(sp)
811117a8:	df000015 	stw	fp,0(sp)
811117ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
811117b0:	d0a05417 	ldw	r2,-32432(gp)
811117b4:	100f883a 	mov	r7,r2
811117b8:	01800a44 	movi	r6,41
811117bc:	01400044 	movi	r5,1
811117c0:	01204534 	movhi	r4,33044
811117c4:	210ba304 	addi	r4,r4,11916
811117c8:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
811117cc:	d0a05417 	ldw	r2,-32432(gp)
811117d0:	100f883a 	mov	r7,r2
811117d4:	01800884 	movi	r6,34
811117d8:	01400044 	movi	r5,1
811117dc:	01204534 	movhi	r4,33044
811117e0:	210bae04 	addi	r4,r4,11960
811117e4:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811117e8:	0001883a 	nop
811117ec:	e037883a 	mov	sp,fp
811117f0:	dfc00117 	ldw	ra,4(sp)
811117f4:	df000017 	ldw	fp,0(sp)
811117f8:	dec00204 	addi	sp,sp,8
811117fc:	f800283a 	ret

81111800 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
81111800:	defffe04 	addi	sp,sp,-8
81111804:	de00012e 	bgeu	sp,et,8111180c <vFailGetCountSemaphorexBuffer64+0xc>
81111808:	003b68fa 	trap	3
8111180c:	dfc00115 	stw	ra,4(sp)
81111810:	df000015 	stw	fp,0(sp)
81111814:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
81111818:	d0a05417 	ldw	r2,-32432(gp)
8111181c:	100f883a 	mov	r7,r2
81111820:	01800a04 	movi	r6,40
81111824:	01400044 	movi	r5,1
81111828:	01204534 	movhi	r4,33044
8111182c:	210bb704 	addi	r4,r4,11996
81111830:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81111834:	d0a05417 	ldw	r2,-32432(gp)
81111838:	100f883a 	mov	r7,r2
8111183c:	01800884 	movi	r6,34
81111840:	01400044 	movi	r5,1
81111844:	01204534 	movhi	r4,33044
81111848:	210bae04 	addi	r4,r4,11960
8111184c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111850:	0001883a 	nop
81111854:	e037883a 	mov	sp,fp
81111858:	dfc00117 	ldw	ra,4(sp)
8111185c:	df000017 	ldw	fp,0(sp)
81111860:	dec00204 	addi	sp,sp,8
81111864:	f800283a 	ret

81111868 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
81111868:	defffe04 	addi	sp,sp,-8
8111186c:	de00012e 	bgeu	sp,et,81111874 <vFailGetCountSemaphorexBuffer32+0xc>
81111870:	003b68fa 	trap	3
81111874:	dfc00115 	stw	ra,4(sp)
81111878:	df000015 	stw	fp,0(sp)
8111187c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
81111880:	d0a05417 	ldw	r2,-32432(gp)
81111884:	100f883a 	mov	r7,r2
81111888:	01800a04 	movi	r6,40
8111188c:	01400044 	movi	r5,1
81111890:	01204534 	movhi	r4,33044
81111894:	210bc204 	addi	r4,r4,12040
81111898:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111189c:	d0a05417 	ldw	r2,-32432(gp)
811118a0:	100f883a 	mov	r7,r2
811118a4:	01800884 	movi	r6,34
811118a8:	01400044 	movi	r5,1
811118ac:	01204534 	movhi	r4,33044
811118b0:	210bae04 	addi	r4,r4,11960
811118b4:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811118b8:	0001883a 	nop
811118bc:	e037883a 	mov	sp,fp
811118c0:	dfc00117 	ldw	ra,4(sp)
811118c4:	df000017 	ldw	fp,0(sp)
811118c8:	dec00204 	addi	sp,sp,8
811118cc:	f800283a 	ret

811118d0 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
811118d0:	defffe04 	addi	sp,sp,-8
811118d4:	de00012e 	bgeu	sp,et,811118dc <vFailFoundBufferRetransmission+0xc>
811118d8:	003b68fa 	trap	3
811118dc:	dfc00115 	stw	ra,4(sp)
811118e0:	df000015 	stw	fp,0(sp)
811118e4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
811118e8:	d0a05417 	ldw	r2,-32432(gp)
811118ec:	100f883a 	mov	r7,r2
811118f0:	01800a84 	movi	r6,42
811118f4:	01400044 	movi	r5,1
811118f8:	01204534 	movhi	r4,33044
811118fc:	210bcd04 	addi	r4,r4,12084
81111900:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
81111904:	d0a05417 	ldw	r2,-32432(gp)
81111908:	100f883a 	mov	r7,r2
8111190c:	01801204 	movi	r6,72
81111910:	01400044 	movi	r5,1
81111914:	01204534 	movhi	r4,33044
81111918:	210bd804 	addi	r4,r4,12128
8111191c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111920:	0001883a 	nop
81111924:	e037883a 	mov	sp,fp
81111928:	dfc00117 	ldw	ra,4(sp)
8111192c:	df000017 	ldw	fp,0(sp)
81111930:	dec00204 	addi	sp,sp,8
81111934:	f800283a 	ret

81111938 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
81111938:	defffe04 	addi	sp,sp,-8
8111193c:	de00012e 	bgeu	sp,et,81111944 <vFailGetCountSemaphorePreParsedBuffer+0xc>
81111940:	003b68fa 	trap	3
81111944:	dfc00115 	stw	ra,4(sp)
81111948:	df000015 	stw	fp,0(sp)
8111194c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
81111950:	d0a05417 	ldw	r2,-32432(gp)
81111954:	100f883a 	mov	r7,r2
81111958:	01800b84 	movi	r6,46
8111195c:	01400044 	movi	r5,1
81111960:	01204534 	movhi	r4,33044
81111964:	210beb04 	addi	r4,r4,12204
81111968:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111196c:	d0a05417 	ldw	r2,-32432(gp)
81111970:	100f883a 	mov	r7,r2
81111974:	018010c4 	movi	r6,67
81111978:	01400044 	movi	r5,1
8111197c:	01204534 	movhi	r4,33044
81111980:	210bf704 	addi	r4,r4,12252
81111984:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111988:	0001883a 	nop
8111198c:	e037883a 	mov	sp,fp
81111990:	dfc00117 	ldw	ra,4(sp)
81111994:	df000017 	ldw	fp,0(sp)
81111998:	dec00204 	addi	sp,sp,8
8111199c:	f800283a 	ret

811119a0 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
811119a0:	defffe04 	addi	sp,sp,-8
811119a4:	de00012e 	bgeu	sp,et,811119ac <vFailGetxMutexPreParsedParserRxTask+0xc>
811119a8:	003b68fa 	trap	3
811119ac:	dfc00115 	stw	ra,4(sp)
811119b0:	df000015 	stw	fp,0(sp)
811119b4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
811119b8:	d0a05417 	ldw	r2,-32432(gp)
811119bc:	100f883a 	mov	r7,r2
811119c0:	01800b04 	movi	r6,44
811119c4:	01400044 	movi	r5,1
811119c8:	01204534 	movhi	r4,33044
811119cc:	210c0804 	addi	r4,r4,12320
811119d0:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
811119d4:	d0a05417 	ldw	r2,-32432(gp)
811119d8:	100f883a 	mov	r7,r2
811119dc:	01800fc4 	movi	r6,63
811119e0:	01400044 	movi	r5,1
811119e4:	01204534 	movhi	r4,33044
811119e8:	210c1404 	addi	r4,r4,12368
811119ec:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811119f0:	0001883a 	nop
811119f4:	e037883a 	mov	sp,fp
811119f8:	dfc00117 	ldw	ra,4(sp)
811119fc:	df000017 	ldw	fp,0(sp)
81111a00:	dec00204 	addi	sp,sp,8
81111a04:	f800283a 	ret

81111a08 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
81111a08:	defffe04 	addi	sp,sp,-8
81111a0c:	de00012e 	bgeu	sp,et,81111a14 <vNoContentInPreParsedBuffer+0xc>
81111a10:	003b68fa 	trap	3
81111a14:	dfc00115 	stw	ra,4(sp)
81111a18:	df000015 	stw	fp,0(sp)
81111a1c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
81111a20:	d0a05417 	ldw	r2,-32432(gp)
81111a24:	100f883a 	mov	r7,r2
81111a28:	01800904 	movi	r6,36
81111a2c:	01400044 	movi	r5,1
81111a30:	01204534 	movhi	r4,33044
81111a34:	210c2404 	addi	r4,r4,12432
81111a38:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
81111a3c:	d0a05417 	ldw	r2,-32432(gp)
81111a40:	100f883a 	mov	r7,r2
81111a44:	01801684 	movi	r6,90
81111a48:	01400044 	movi	r5,1
81111a4c:	01204534 	movhi	r4,33044
81111a50:	210c2e04 	addi	r4,r4,12472
81111a54:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111a58:	0001883a 	nop
81111a5c:	e037883a 	mov	sp,fp
81111a60:	dfc00117 	ldw	ra,4(sp)
81111a64:	df000017 	ldw	fp,0(sp)
81111a68:	dec00204 	addi	sp,sp,8
81111a6c:	f800283a 	ret

81111a70 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
81111a70:	defffe04 	addi	sp,sp,-8
81111a74:	de00012e 	bgeu	sp,et,81111a7c <vCouldNotSendEthConfUART+0xc>
81111a78:	003b68fa 	trap	3
81111a7c:	dfc00115 	stw	ra,4(sp)
81111a80:	df000015 	stw	fp,0(sp)
81111a84:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
81111a88:	d0a05417 	ldw	r2,-32432(gp)
81111a8c:	100f883a 	mov	r7,r2
81111a90:	01800844 	movi	r6,33
81111a94:	01400044 	movi	r5,1
81111a98:	01204534 	movhi	r4,33044
81111a9c:	210c4504 	addi	r4,r4,12564
81111aa0:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
81111aa4:	d0a05417 	ldw	r2,-32432(gp)
81111aa8:	100f883a 	mov	r7,r2
81111aac:	01801784 	movi	r6,94
81111ab0:	01400044 	movi	r5,1
81111ab4:	01204534 	movhi	r4,33044
81111ab8:	210c4e04 	addi	r4,r4,12600
81111abc:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111ac0:	0001883a 	nop
81111ac4:	e037883a 	mov	sp,fp
81111ac8:	dfc00117 	ldw	ra,4(sp)
81111acc:	df000017 	ldw	fp,0(sp)
81111ad0:	dec00204 	addi	sp,sp,8
81111ad4:	f800283a 	ret

81111ad8 <vFailSendNack>:

void vFailSendNack( void )
{
81111ad8:	defffe04 	addi	sp,sp,-8
81111adc:	de00012e 	bgeu	sp,et,81111ae4 <vFailSendNack+0xc>
81111ae0:	003b68fa 	trap	3
81111ae4:	dfc00115 	stw	ra,4(sp)
81111ae8:	df000015 	stw	fp,0(sp)
81111aec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
81111af0:	d0a05417 	ldw	r2,-32432(gp)
81111af4:	100f883a 	mov	r7,r2
81111af8:	01800584 	movi	r6,22
81111afc:	01400044 	movi	r5,1
81111b00:	01204534 	movhi	r4,33044
81111b04:	210c6604 	addi	r4,r4,12696
81111b08:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
81111b0c:	d0a05417 	ldw	r2,-32432(gp)
81111b10:	100f883a 	mov	r7,r2
81111b14:	01800a84 	movi	r6,42
81111b18:	01400044 	movi	r5,1
81111b1c:	01204534 	movhi	r4,33044
81111b20:	210c6c04 	addi	r4,r4,12720
81111b24:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111b28:	0001883a 	nop
81111b2c:	e037883a 	mov	sp,fp
81111b30:	dfc00117 	ldw	ra,4(sp)
81111b34:	df000017 	ldw	fp,0(sp)
81111b38:	dec00204 	addi	sp,sp,8
81111b3c:	f800283a 	ret

81111b40 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
81111b40:	defffe04 	addi	sp,sp,-8
81111b44:	de00012e 	bgeu	sp,et,81111b4c <vFailSetPreAckSenderBuffer+0xc>
81111b48:	003b68fa 	trap	3
81111b4c:	dfc00115 	stw	ra,4(sp)
81111b50:	df000015 	stw	fp,0(sp)
81111b54:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
81111b58:	d0a05417 	ldw	r2,-32432(gp)
81111b5c:	100f883a 	mov	r7,r2
81111b60:	018008c4 	movi	r6,35
81111b64:	01400044 	movi	r5,1
81111b68:	01204534 	movhi	r4,33044
81111b6c:	210c7704 	addi	r4,r4,12764
81111b70:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
81111b74:	d0a05417 	ldw	r2,-32432(gp)
81111b78:	100f883a 	mov	r7,r2
81111b7c:	01801584 	movi	r6,86
81111b80:	01400044 	movi	r5,1
81111b84:	01204534 	movhi	r4,33044
81111b88:	210c8004 	addi	r4,r4,12800
81111b8c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111b90:	0001883a 	nop
81111b94:	e037883a 	mov	sp,fp
81111b98:	dfc00117 	ldw	ra,4(sp)
81111b9c:	df000017 	ldw	fp,0(sp)
81111ba0:	dec00204 	addi	sp,sp,8
81111ba4:	f800283a 	ret

81111ba8 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
81111ba8:	defffe04 	addi	sp,sp,-8
81111bac:	de00012e 	bgeu	sp,et,81111bb4 <vFailSetPreParsedBuffer+0xc>
81111bb0:	003b68fa 	trap	3
81111bb4:	dfc00115 	stw	ra,4(sp)
81111bb8:	df000015 	stw	fp,0(sp)
81111bbc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
81111bc0:	d0a05417 	ldw	r2,-32432(gp)
81111bc4:	100f883a 	mov	r7,r2
81111bc8:	01800804 	movi	r6,32
81111bcc:	01400044 	movi	r5,1
81111bd0:	01204534 	movhi	r4,33044
81111bd4:	210c9604 	addi	r4,r4,12888
81111bd8:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
81111bdc:	d0a05417 	ldw	r2,-32432(gp)
81111be0:	100f883a 	mov	r7,r2
81111be4:	018013c4 	movi	r6,79
81111be8:	01400044 	movi	r5,1
81111bec:	01204534 	movhi	r4,33044
81111bf0:	210c9f04 	addi	r4,r4,12924
81111bf4:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111bf8:	0001883a 	nop
81111bfc:	e037883a 	mov	sp,fp
81111c00:	dfc00117 	ldw	ra,4(sp)
81111c04:	df000017 	ldw	fp,0(sp)
81111c08:	dec00204 	addi	sp,sp,8
81111c0c:	f800283a 	ret

81111c10 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
81111c10:	defffe04 	addi	sp,sp,-8
81111c14:	de00012e 	bgeu	sp,et,81111c1c <vFailSetPreAckReceiverBuffer+0xc>
81111c18:	003b68fa 	trap	3
81111c1c:	dfc00115 	stw	ra,4(sp)
81111c20:	df000015 	stw	fp,0(sp)
81111c24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
81111c28:	d0a05417 	ldw	r2,-32432(gp)
81111c2c:	100f883a 	mov	r7,r2
81111c30:	01800944 	movi	r6,37
81111c34:	01400044 	movi	r5,1
81111c38:	01204534 	movhi	r4,33044
81111c3c:	210cb304 	addi	r4,r4,13004
81111c40:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
81111c44:	d0a05417 	ldw	r2,-32432(gp)
81111c48:	100f883a 	mov	r7,r2
81111c4c:	018015c4 	movi	r6,87
81111c50:	01400044 	movi	r5,1
81111c54:	01204534 	movhi	r4,33044
81111c58:	210cbd04 	addi	r4,r4,13044
81111c5c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111c60:	0001883a 	nop
81111c64:	e037883a 	mov	sp,fp
81111c68:	dfc00117 	ldw	ra,4(sp)
81111c6c:	df000017 	ldw	fp,0(sp)
81111c70:	dec00204 	addi	sp,sp,8
81111c74:	f800283a 	ret

81111c78 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
81111c78:	defffe04 	addi	sp,sp,-8
81111c7c:	de00012e 	bgeu	sp,et,81111c84 <vFailParserCommTaskCreate+0xc>
81111c80:	003b68fa 	trap	3
81111c84:	dfc00115 	stw	ra,4(sp)
81111c88:	df000015 	stw	fp,0(sp)
81111c8c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
81111c90:	d0a05417 	ldw	r2,-32432(gp)
81111c94:	100f883a 	mov	r7,r2
81111c98:	01800684 	movi	r6,26
81111c9c:	01400044 	movi	r5,1
81111ca0:	01204534 	movhi	r4,33044
81111ca4:	210cd304 	addi	r4,r4,13132
81111ca8:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
81111cac:	0001883a 	nop
81111cb0:	e037883a 	mov	sp,fp
81111cb4:	dfc00117 	ldw	ra,4(sp)
81111cb8:	df000017 	ldw	fp,0(sp)
81111cbc:	dec00204 	addi	sp,sp,8
81111cc0:	f800283a 	ret

81111cc4 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
81111cc4:	defffe04 	addi	sp,sp,-8
81111cc8:	de00012e 	bgeu	sp,et,81111cd0 <vFailInAckHandlerTaskCreate+0xc>
81111ccc:	003b68fa 	trap	3
81111cd0:	dfc00115 	stw	ra,4(sp)
81111cd4:	df000015 	stw	fp,0(sp)
81111cd8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81111cdc:	d0a05417 	ldw	r2,-32432(gp)
81111ce0:	100f883a 	mov	r7,r2
81111ce4:	01800704 	movi	r6,28
81111ce8:	01400044 	movi	r5,1
81111cec:	01204534 	movhi	r4,33044
81111cf0:	210cda04 	addi	r4,r4,13160
81111cf4:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
81111cf8:	0001883a 	nop
81111cfc:	e037883a 	mov	sp,fp
81111d00:	dfc00117 	ldw	ra,4(sp)
81111d04:	df000017 	ldw	fp,0(sp)
81111d08:	dec00204 	addi	sp,sp,8
81111d0c:	f800283a 	ret

81111d10 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
81111d10:	defffe04 	addi	sp,sp,-8
81111d14:	de00012e 	bgeu	sp,et,81111d1c <vFailOutAckHandlerTaskCreate+0xc>
81111d18:	003b68fa 	trap	3
81111d1c:	dfc00115 	stw	ra,4(sp)
81111d20:	df000015 	stw	fp,0(sp)
81111d24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81111d28:	d0a05417 	ldw	r2,-32432(gp)
81111d2c:	100f883a 	mov	r7,r2
81111d30:	01800704 	movi	r6,28
81111d34:	01400044 	movi	r5,1
81111d38:	01204534 	movhi	r4,33044
81111d3c:	210cda04 	addi	r4,r4,13160
81111d40:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
81111d44:	0001883a 	nop
81111d48:	e037883a 	mov	sp,fp
81111d4c:	dfc00117 	ldw	ra,4(sp)
81111d50:	df000017 	ldw	fp,0(sp)
81111d54:	dec00204 	addi	sp,sp,8
81111d58:	f800283a 	ret

81111d5c <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
81111d5c:	defffe04 	addi	sp,sp,-8
81111d60:	de00012e 	bgeu	sp,et,81111d68 <vFailCreateTimerRetransmisison+0xc>
81111d64:	003b68fa 	trap	3
81111d68:	dfc00115 	stw	ra,4(sp)
81111d6c:	df000015 	stw	fp,0(sp)
81111d70:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
81111d74:	d0a05417 	ldw	r2,-32432(gp)
81111d78:	100f883a 	mov	r7,r2
81111d7c:	018007c4 	movi	r6,31
81111d80:	01400044 	movi	r5,1
81111d84:	01204534 	movhi	r4,33044
81111d88:	210ce204 	addi	r4,r4,13192
81111d8c:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
81111d90:	0001883a 	nop
81111d94:	e037883a 	mov	sp,fp
81111d98:	dfc00117 	ldw	ra,4(sp)
81111d9c:	df000017 	ldw	fp,0(sp)
81111da0:	dec00204 	addi	sp,sp,8
81111da4:	f800283a 	ret

81111da8 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
81111da8:	defffe04 	addi	sp,sp,-8
81111dac:	de00012e 	bgeu	sp,et,81111db4 <vCouldNotCheckBufferTimeOutFunction+0xc>
81111db0:	003b68fa 	trap	3
81111db4:	dfc00115 	stw	ra,4(sp)
81111db8:	df000015 	stw	fp,0(sp)
81111dbc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
81111dc0:	d0a05417 	ldw	r2,-32432(gp)
81111dc4:	100f883a 	mov	r7,r2
81111dc8:	01800904 	movi	r6,36
81111dcc:	01400044 	movi	r5,1
81111dd0:	01204534 	movhi	r4,33044
81111dd4:	210cea04 	addi	r4,r4,13224
81111dd8:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
81111ddc:	0001883a 	nop
81111de0:	e037883a 	mov	sp,fp
81111de4:	dfc00117 	ldw	ra,4(sp)
81111de8:	df000017 	ldw	fp,0(sp)
81111dec:	dec00204 	addi	sp,sp,8
81111df0:	f800283a 	ret

81111df4 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
81111df4:	defffe04 	addi	sp,sp,-8
81111df8:	de00012e 	bgeu	sp,et,81111e00 <vFailTimeoutCheckerTaskCreate+0xc>
81111dfc:	003b68fa 	trap	3
81111e00:	dfc00115 	stw	ra,4(sp)
81111e04:	df000015 	stw	fp,0(sp)
81111e08:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
81111e0c:	d0a05417 	ldw	r2,-32432(gp)
81111e10:	100f883a 	mov	r7,r2
81111e14:	01800a04 	movi	r6,40
81111e18:	01400044 	movi	r5,1
81111e1c:	01204534 	movhi	r4,33044
81111e20:	210cf404 	addi	r4,r4,13264
81111e24:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
81111e28:	0001883a 	nop
81111e2c:	e037883a 	mov	sp,fp
81111e30:	dfc00117 	ldw	ra,4(sp)
81111e34:	df000017 	ldw	fp,0(sp)
81111e38:	dec00204 	addi	sp,sp,8
81111e3c:	f800283a 	ret

81111e40 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
81111e40:	defffe04 	addi	sp,sp,-8
81111e44:	de00012e 	bgeu	sp,et,81111e4c <vFailGetBlockingSemTimeoutTask+0xc>
81111e48:	003b68fa 	trap	3
81111e4c:	dfc00115 	stw	ra,4(sp)
81111e50:	df000015 	stw	fp,0(sp)
81111e54:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
81111e58:	d0a05417 	ldw	r2,-32432(gp)
81111e5c:	100f883a 	mov	r7,r2
81111e60:	018009c4 	movi	r6,39
81111e64:	01400044 	movi	r5,1
81111e68:	01204534 	movhi	r4,33044
81111e6c:	210cff04 	addi	r4,r4,13308
81111e70:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
81111e74:	d0a05417 	ldw	r2,-32432(gp)
81111e78:	100f883a 	mov	r7,r2
81111e7c:	01800cc4 	movi	r6,51
81111e80:	01400044 	movi	r5,1
81111e84:	01204534 	movhi	r4,33044
81111e88:	210d0904 	addi	r4,r4,13348
81111e8c:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111e90:	0001883a 	nop
81111e94:	e037883a 	mov	sp,fp
81111e98:	dfc00117 	ldw	ra,4(sp)
81111e9c:	df000017 	ldw	fp,0(sp)
81111ea0:	dec00204 	addi	sp,sp,8
81111ea4:	f800283a 	ret

81111ea8 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
81111ea8:	defffe04 	addi	sp,sp,-8
81111eac:	de00012e 	bgeu	sp,et,81111eb4 <vFailPostBlockingSemTimeoutTask+0xc>
81111eb0:	003b68fa 	trap	3
81111eb4:	dfc00115 	stw	ra,4(sp)
81111eb8:	df000015 	stw	fp,0(sp)
81111ebc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
81111ec0:	d0a05417 	ldw	r2,-32432(gp)
81111ec4:	100f883a 	mov	r7,r2
81111ec8:	01800a04 	movi	r6,40
81111ecc:	01400044 	movi	r5,1
81111ed0:	01204534 	movhi	r4,33044
81111ed4:	210d1604 	addi	r4,r4,13400
81111ed8:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
81111edc:	d0a05417 	ldw	r2,-32432(gp)
81111ee0:	100f883a 	mov	r7,r2
81111ee4:	01800c84 	movi	r6,50
81111ee8:	01400044 	movi	r5,1
81111eec:	01204534 	movhi	r4,33044
81111ef0:	210d2104 	addi	r4,r4,13444
81111ef4:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111ef8:	0001883a 	nop
81111efc:	e037883a 	mov	sp,fp
81111f00:	dfc00117 	ldw	ra,4(sp)
81111f04:	df000017 	ldw	fp,0(sp)
81111f08:	dec00204 	addi	sp,sp,8
81111f0c:	f800283a 	ret

81111f10 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
81111f10:	defffe04 	addi	sp,sp,-8
81111f14:	de00012e 	bgeu	sp,et,81111f1c <vFailCouldNotRetransmitTimeoutTask+0xc>
81111f18:	003b68fa 	trap	3
81111f1c:	dfc00115 	stw	ra,4(sp)
81111f20:	df000015 	stw	fp,0(sp)
81111f24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
81111f28:	d0a05417 	ldw	r2,-32432(gp)
81111f2c:	100f883a 	mov	r7,r2
81111f30:	01800ac4 	movi	r6,43
81111f34:	01400044 	movi	r5,1
81111f38:	01204534 	movhi	r4,33044
81111f3c:	210d2e04 	addi	r4,r4,13496
81111f40:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
81111f44:	d0a05417 	ldw	r2,-32432(gp)
81111f48:	100f883a 	mov	r7,r2
81111f4c:	01801644 	movi	r6,89
81111f50:	01400044 	movi	r5,1
81111f54:	01204534 	movhi	r4,33044
81111f58:	210d3904 	addi	r4,r4,13540
81111f5c:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111f60:	0001883a 	nop
81111f64:	e037883a 	mov	sp,fp
81111f68:	dfc00117 	ldw	ra,4(sp)
81111f6c:	df000017 	ldw	fp,0(sp)
81111f70:	dec00204 	addi	sp,sp,8
81111f74:	f800283a 	ret

81111f78 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
81111f78:	defffe04 	addi	sp,sp,-8
81111f7c:	de00012e 	bgeu	sp,et,81111f84 <vCouldNotRetransmitB32TimeoutTask+0xc>
81111f80:	003b68fa 	trap	3
81111f84:	dfc00115 	stw	ra,4(sp)
81111f88:	df000015 	stw	fp,0(sp)
81111f8c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
81111f90:	d0a05417 	ldw	r2,-32432(gp)
81111f94:	100f883a 	mov	r7,r2
81111f98:	01800a84 	movi	r6,42
81111f9c:	01400044 	movi	r5,1
81111fa0:	01204534 	movhi	r4,33044
81111fa4:	210d5004 	addi	r4,r4,13632
81111fa8:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
81111fac:	d0a05417 	ldw	r2,-32432(gp)
81111fb0:	100f883a 	mov	r7,r2
81111fb4:	01801444 	movi	r6,81
81111fb8:	01400044 	movi	r5,1
81111fbc:	01204534 	movhi	r4,33044
81111fc0:	210d5b04 	addi	r4,r4,13676
81111fc4:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81111fc8:	0001883a 	nop
81111fcc:	e037883a 	mov	sp,fp
81111fd0:	dfc00117 	ldw	ra,4(sp)
81111fd4:	df000017 	ldw	fp,0(sp)
81111fd8:	dec00204 	addi	sp,sp,8
81111fdc:	f800283a 	ret

81111fe0 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
81111fe0:	defffe04 	addi	sp,sp,-8
81111fe4:	de00012e 	bgeu	sp,et,81111fec <vCouldNotRetransmitB64TimeoutTask+0xc>
81111fe8:	003b68fa 	trap	3
81111fec:	dfc00115 	stw	ra,4(sp)
81111ff0:	df000015 	stw	fp,0(sp)
81111ff4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
81111ff8:	d0a05417 	ldw	r2,-32432(gp)
81111ffc:	100f883a 	mov	r7,r2
81112000:	01800a84 	movi	r6,42
81112004:	01400044 	movi	r5,1
81112008:	01204534 	movhi	r4,33044
8111200c:	210d7004 	addi	r4,r4,13760
81112010:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
81112014:	d0a05417 	ldw	r2,-32432(gp)
81112018:	100f883a 	mov	r7,r2
8111201c:	01801444 	movi	r6,81
81112020:	01400044 	movi	r5,1
81112024:	01204534 	movhi	r4,33044
81112028:	210d7b04 	addi	r4,r4,13804
8111202c:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112030:	0001883a 	nop
81112034:	e037883a 	mov	sp,fp
81112038:	dfc00117 	ldw	ra,4(sp)
8111203c:	df000017 	ldw	fp,0(sp)
81112040:	dec00204 	addi	sp,sp,8
81112044:	f800283a 	ret

81112048 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
81112048:	defffe04 	addi	sp,sp,-8
8111204c:	de00012e 	bgeu	sp,et,81112054 <vCouldNotRetransmitB128TimeoutTask+0xc>
81112050:	003b68fa 	trap	3
81112054:	dfc00115 	stw	ra,4(sp)
81112058:	df000015 	stw	fp,0(sp)
8111205c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
81112060:	d0a05417 	ldw	r2,-32432(gp)
81112064:	100f883a 	mov	r7,r2
81112068:	01800ac4 	movi	r6,43
8111206c:	01400044 	movi	r5,1
81112070:	01204534 	movhi	r4,33044
81112074:	210d9004 	addi	r4,r4,13888
81112078:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111207c:	d0a05417 	ldw	r2,-32432(gp)
81112080:	100f883a 	mov	r7,r2
81112084:	01801484 	movi	r6,82
81112088:	01400044 	movi	r5,1
8111208c:	01204534 	movhi	r4,33044
81112090:	210d9b04 	addi	r4,r4,13932
81112094:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112098:	0001883a 	nop
8111209c:	e037883a 	mov	sp,fp
811120a0:	dfc00117 	ldw	ra,4(sp)
811120a4:	df000017 	ldw	fp,0(sp)
811120a8:	dec00204 	addi	sp,sp,8
811120ac:	f800283a 	ret

811120b0 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
811120b0:	defffe04 	addi	sp,sp,-8
811120b4:	de00012e 	bgeu	sp,et,811120bc <vFailStartTimerRetransmission+0xc>
811120b8:	003b68fa 	trap	3
811120bc:	dfc00115 	stw	ra,4(sp)
811120c0:	df000015 	stw	fp,0(sp)
811120c4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
811120c8:	d0a05417 	ldw	r2,-32432(gp)
811120cc:	100f883a 	mov	r7,r2
811120d0:	01800984 	movi	r6,38
811120d4:	01400044 	movi	r5,1
811120d8:	01204534 	movhi	r4,33044
811120dc:	210db004 	addi	r4,r4,14016
811120e0:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
811120e4:	d0a05417 	ldw	r2,-32432(gp)
811120e8:	100f883a 	mov	r7,r2
811120ec:	01800d44 	movi	r6,53
811120f0:	01400044 	movi	r5,1
811120f4:	01204534 	movhi	r4,33044
811120f8:	210dba04 	addi	r4,r4,14056
811120fc:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112100:	0001883a 	nop
81112104:	e037883a 	mov	sp,fp
81112108:	dfc00117 	ldw	ra,4(sp)
8111210c:	df000017 	ldw	fp,0(sp)
81112110:	dec00204 	addi	sp,sp,8
81112114:	f800283a 	ret

81112118 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
81112118:	defffe04 	addi	sp,sp,-8
8111211c:	de00012e 	bgeu	sp,et,81112124 <vCouldNotSendTurnOff+0xc>
81112120:	003b68fa 	trap	3
81112124:	dfc00115 	stw	ra,4(sp)
81112128:	df000015 	stw	fp,0(sp)
8111212c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
81112130:	d0a05417 	ldw	r2,-32432(gp)
81112134:	100f883a 	mov	r7,r2
81112138:	01800744 	movi	r6,29
8111213c:	01400044 	movi	r5,1
81112140:	01204534 	movhi	r4,33044
81112144:	210dc804 	addi	r4,r4,14112
81112148:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
8111214c:	d0a05417 	ldw	r2,-32432(gp)
81112150:	100f883a 	mov	r7,r2
81112154:	01800984 	movi	r6,38
81112158:	01400044 	movi	r5,1
8111215c:	01204534 	movhi	r4,33044
81112160:	210dd004 	addi	r4,r4,14144
81112164:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112168:	0001883a 	nop
8111216c:	e037883a 	mov	sp,fp
81112170:	dfc00117 	ldw	ra,4(sp)
81112174:	df000017 	ldw	fp,0(sp)
81112178:	dec00204 	addi	sp,sp,8
8111217c:	f800283a 	ret

81112180 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
81112180:	defffe04 	addi	sp,sp,-8
81112184:	de00012e 	bgeu	sp,et,8111218c <vCouldNotSendReset+0xc>
81112188:	003b68fa 	trap	3
8111218c:	dfc00115 	stw	ra,4(sp)
81112190:	df000015 	stw	fp,0(sp)
81112194:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
81112198:	d0a05417 	ldw	r2,-32432(gp)
8111219c:	100f883a 	mov	r7,r2
811121a0:	018006c4 	movi	r6,27
811121a4:	01400044 	movi	r5,1
811121a8:	01204534 	movhi	r4,33044
811121ac:	210dda04 	addi	r4,r4,14184
811121b0:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
811121b4:	d0a05417 	ldw	r2,-32432(gp)
811121b8:	100f883a 	mov	r7,r2
811121bc:	018008c4 	movi	r6,35
811121c0:	01400044 	movi	r5,1
811121c4:	01204534 	movhi	r4,33044
811121c8:	210de104 	addi	r4,r4,14212
811121cc:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811121d0:	0001883a 	nop
811121d4:	e037883a 	mov	sp,fp
811121d8:	dfc00117 	ldw	ra,4(sp)
811121dc:	df000017 	ldw	fp,0(sp)
811121e0:	dec00204 	addi	sp,sp,8
811121e4:	f800283a 	ret

811121e8 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
811121e8:	defffe04 	addi	sp,sp,-8
811121ec:	de00012e 	bgeu	sp,et,811121f4 <vCouldNotSendLog+0xc>
811121f0:	003b68fa 	trap	3
811121f4:	dfc00115 	stw	ra,4(sp)
811121f8:	df000015 	stw	fp,0(sp)
811121fc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
81112200:	d0a05417 	ldw	r2,-32432(gp)
81112204:	100f883a 	mov	r7,r2
81112208:	01800644 	movi	r6,25
8111220c:	01400044 	movi	r5,1
81112210:	01204534 	movhi	r4,33044
81112214:	210dea04 	addi	r4,r4,14248
81112218:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
8111221c:	d0a05417 	ldw	r2,-32432(gp)
81112220:	100f883a 	mov	r7,r2
81112224:	018008c4 	movi	r6,35
81112228:	01400044 	movi	r5,1
8111222c:	01204534 	movhi	r4,33044
81112230:	210df104 	addi	r4,r4,14276
81112234:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112238:	0001883a 	nop
8111223c:	e037883a 	mov	sp,fp
81112240:	dfc00117 	ldw	ra,4(sp)
81112244:	df000017 	ldw	fp,0(sp)
81112248:	dec00204 	addi	sp,sp,8
8111224c:	f800283a 	ret

81112250 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
81112250:	defffd04 	addi	sp,sp,-12
81112254:	de00012e 	bgeu	sp,et,8111225c <vCouldNotSendTMPusCommand+0xc>
81112258:	003b68fa 	trap	3
8111225c:	dfc00215 	stw	ra,8(sp)
81112260:	df000115 	stw	fp,4(sp)
81112264:	df000104 	addi	fp,sp,4
81112268:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111226c:	d0a05417 	ldw	r2,-32432(gp)
81112270:	100f883a 	mov	r7,r2
81112274:	01800884 	movi	r6,34
81112278:	01400044 	movi	r5,1
8111227c:	01204534 	movhi	r4,33044
81112280:	210dfa04 	addi	r4,r4,14312
81112284:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
81112288:	d0a05417 	ldw	r2,-32432(gp)
8111228c:	100f883a 	mov	r7,r2
81112290:	01800ac4 	movi	r6,43
81112294:	01400044 	movi	r5,1
81112298:	01204534 	movhi	r4,33044
8111229c:	210e0304 	addi	r4,r4,14348
811122a0:	1115d200 	call	81115d20 <fwrite>
		debug(fp,"cData");
811122a4:	d0a05417 	ldw	r2,-32432(gp)
811122a8:	100f883a 	mov	r7,r2
811122ac:	01800144 	movi	r6,5
811122b0:	01400044 	movi	r5,1
811122b4:	01204534 	movhi	r4,33044
811122b8:	210e0e04 	addi	r4,r4,14392
811122bc:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811122c0:	0001883a 	nop
811122c4:	e037883a 	mov	sp,fp
811122c8:	dfc00117 	ldw	ra,4(sp)
811122cc:	df000017 	ldw	fp,0(sp)
811122d0:	dec00204 	addi	sp,sp,8
811122d4:	f800283a 	ret

811122d8 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
811122d8:	defffe04 	addi	sp,sp,-8
811122dc:	de00012e 	bgeu	sp,et,811122e4 <vWarnCouldNotgetMutexRetrans128+0xc>
811122e0:	003b68fa 	trap	3
811122e4:	dfc00115 	stw	ra,4(sp)
811122e8:	df000015 	stw	fp,0(sp)
811122ec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
811122f0:	d0a05417 	ldw	r2,-32432(gp)
811122f4:	100f883a 	mov	r7,r2
811122f8:	01800a04 	movi	r6,40
811122fc:	01400044 	movi	r5,1
81112300:	01204534 	movhi	r4,33044
81112304:	210e1004 	addi	r4,r4,14400
81112308:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8111230c:	d0a05417 	ldw	r2,-32432(gp)
81112310:	100f883a 	mov	r7,r2
81112314:	018014c4 	movi	r6,83
81112318:	01400044 	movi	r5,1
8111231c:	01204534 	movhi	r4,33044
81112320:	210e1b04 	addi	r4,r4,14444
81112324:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112328:	0001883a 	nop
8111232c:	e037883a 	mov	sp,fp
81112330:	dfc00117 	ldw	ra,4(sp)
81112334:	df000017 	ldw	fp,0(sp)
81112338:	dec00204 	addi	sp,sp,8
8111233c:	f800283a 	ret

81112340 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
81112340:	defffe04 	addi	sp,sp,-8
81112344:	de00012e 	bgeu	sp,et,8111234c <vFailCreateScheduleQueue+0xc>
81112348:	003b68fa 	trap	3
8111234c:	dfc00115 	stw	ra,4(sp)
81112350:	df000015 	stw	fp,0(sp)
81112354:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
81112358:	d0a05417 	ldw	r2,-32432(gp)
8111235c:	100f883a 	mov	r7,r2
81112360:	01800844 	movi	r6,33
81112364:	01400044 	movi	r5,1
81112368:	01204534 	movhi	r4,33044
8111236c:	210e3004 	addi	r4,r4,14528
81112370:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
81112374:	d0a05417 	ldw	r2,-32432(gp)
81112378:	100f883a 	mov	r7,r2
8111237c:	01801204 	movi	r6,72
81112380:	01400044 	movi	r5,1
81112384:	01204534 	movhi	r4,33044
81112388:	210e3904 	addi	r4,r4,14564
8111238c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112390:	0001883a 	nop
81112394:	e037883a 	mov	sp,fp
81112398:	dfc00117 	ldw	ra,4(sp)
8111239c:	df000017 	ldw	fp,0(sp)
811123a0:	dec00204 	addi	sp,sp,8
811123a4:	f800283a 	ret

811123a8 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
811123a8:	defffd04 	addi	sp,sp,-12
811123ac:	de00012e 	bgeu	sp,et,811123b4 <vFailCreateNFEEQueue+0xc>
811123b0:	003b68fa 	trap	3
811123b4:	dfc00215 	stw	ra,8(sp)
811123b8:	df000115 	stw	fp,4(sp)
811123bc:	df000104 	addi	fp,sp,4
811123c0:	2005883a 	mov	r2,r4
811123c4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
811123c8:	d0a05417 	ldw	r2,-32432(gp)
811123cc:	100f883a 	mov	r7,r2
811123d0:	01800744 	movi	r6,29
811123d4:	01400044 	movi	r5,1
811123d8:	01204534 	movhi	r4,33044
811123dc:	210e4c04 	addi	r4,r4,14640
811123e0:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
811123e4:	d0a05417 	ldw	r2,-32432(gp)
811123e8:	e0ffff03 	ldbu	r3,-4(fp)
811123ec:	180d883a 	mov	r6,r3
811123f0:	01604534 	movhi	r5,33044
811123f4:	294e5404 	addi	r5,r5,14672
811123f8:	1009883a 	mov	r4,r2
811123fc:	1116a4c0 	call	81116a4c <printf>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112400:	0001883a 	nop
81112404:	e037883a 	mov	sp,fp
81112408:	dfc00117 	ldw	ra,4(sp)
8111240c:	df000017 	ldw	fp,0(sp)
81112410:	dec00204 	addi	sp,sp,8
81112414:	f800283a 	ret

81112418 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
81112418:	defffe04 	addi	sp,sp,-8
8111241c:	de00012e 	bgeu	sp,et,81112424 <vCoudlNotCreateNFee0Task+0xc>
81112420:	003b68fa 	trap	3
81112424:	dfc00115 	stw	ra,4(sp)
81112428:	df000015 	stw	fp,0(sp)
8111242c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
81112430:	d0a05417 	ldw	r2,-32432(gp)
81112434:	100f883a 	mov	r7,r2
81112438:	01800844 	movi	r6,33
8111243c:	01400044 	movi	r5,1
81112440:	01204534 	movhi	r4,33044
81112444:	210e6204 	addi	r4,r4,14728
81112448:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
8111244c:	d0a05417 	ldw	r2,-32432(gp)
81112450:	100f883a 	mov	r7,r2
81112454:	01800784 	movi	r6,30
81112458:	01400044 	movi	r5,1
8111245c:	01204534 	movhi	r4,33044
81112460:	210e6b04 	addi	r4,r4,14764
81112464:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112468:	0001883a 	nop
8111246c:	e037883a 	mov	sp,fp
81112470:	dfc00117 	ldw	ra,4(sp)
81112474:	df000017 	ldw	fp,0(sp)
81112478:	dec00204 	addi	sp,sp,8
8111247c:	f800283a 	ret

81112480 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
81112480:	defffe04 	addi	sp,sp,-8
81112484:	de00012e 	bgeu	sp,et,8111248c <vCoudlNotCreateNFee1Task+0xc>
81112488:	003b68fa 	trap	3
8111248c:	dfc00115 	stw	ra,4(sp)
81112490:	df000015 	stw	fp,0(sp)
81112494:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
81112498:	d0a05417 	ldw	r2,-32432(gp)
8111249c:	100f883a 	mov	r7,r2
811124a0:	01800844 	movi	r6,33
811124a4:	01400044 	movi	r5,1
811124a8:	01204534 	movhi	r4,33044
811124ac:	210e7304 	addi	r4,r4,14796
811124b0:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
811124b4:	d0a05417 	ldw	r2,-32432(gp)
811124b8:	100f883a 	mov	r7,r2
811124bc:	01800784 	movi	r6,30
811124c0:	01400044 	movi	r5,1
811124c4:	01204534 	movhi	r4,33044
811124c8:	210e7c04 	addi	r4,r4,14832
811124cc:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811124d0:	0001883a 	nop
811124d4:	e037883a 	mov	sp,fp
811124d8:	dfc00117 	ldw	ra,4(sp)
811124dc:	df000017 	ldw	fp,0(sp)
811124e0:	dec00204 	addi	sp,sp,8
811124e4:	f800283a 	ret

811124e8 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
811124e8:	defffe04 	addi	sp,sp,-8
811124ec:	de00012e 	bgeu	sp,et,811124f4 <vCoudlNotCreateNFee2Task+0xc>
811124f0:	003b68fa 	trap	3
811124f4:	dfc00115 	stw	ra,4(sp)
811124f8:	df000015 	stw	fp,0(sp)
811124fc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
81112500:	d0a05417 	ldw	r2,-32432(gp)
81112504:	100f883a 	mov	r7,r2
81112508:	01800844 	movi	r6,33
8111250c:	01400044 	movi	r5,1
81112510:	01204534 	movhi	r4,33044
81112514:	210e8404 	addi	r4,r4,14864
81112518:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
8111251c:	d0a05417 	ldw	r2,-32432(gp)
81112520:	100f883a 	mov	r7,r2
81112524:	01800784 	movi	r6,30
81112528:	01400044 	movi	r5,1
8111252c:	01204534 	movhi	r4,33044
81112530:	210e8d04 	addi	r4,r4,14900
81112534:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112538:	0001883a 	nop
8111253c:	e037883a 	mov	sp,fp
81112540:	dfc00117 	ldw	ra,4(sp)
81112544:	df000017 	ldw	fp,0(sp)
81112548:	dec00204 	addi	sp,sp,8
8111254c:	f800283a 	ret

81112550 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
81112550:	defffe04 	addi	sp,sp,-8
81112554:	de00012e 	bgeu	sp,et,8111255c <vCoudlNotCreateNFee3Task+0xc>
81112558:	003b68fa 	trap	3
8111255c:	dfc00115 	stw	ra,4(sp)
81112560:	df000015 	stw	fp,0(sp)
81112564:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
81112568:	d0a05417 	ldw	r2,-32432(gp)
8111256c:	100f883a 	mov	r7,r2
81112570:	01800844 	movi	r6,33
81112574:	01400044 	movi	r5,1
81112578:	01204534 	movhi	r4,33044
8111257c:	210e9504 	addi	r4,r4,14932
81112580:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
81112584:	d0a05417 	ldw	r2,-32432(gp)
81112588:	100f883a 	mov	r7,r2
8111258c:	01800784 	movi	r6,30
81112590:	01400044 	movi	r5,1
81112594:	01204534 	movhi	r4,33044
81112598:	210e9e04 	addi	r4,r4,14968
8111259c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811125a0:	0001883a 	nop
811125a4:	e037883a 	mov	sp,fp
811125a8:	dfc00117 	ldw	ra,4(sp)
811125ac:	df000017 	ldw	fp,0(sp)
811125b0:	dec00204 	addi	sp,sp,8
811125b4:	f800283a 	ret

811125b8 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
811125b8:	defffe04 	addi	sp,sp,-8
811125bc:	de00012e 	bgeu	sp,et,811125c4 <vCoudlNotCreateNFee4Task+0xc>
811125c0:	003b68fa 	trap	3
811125c4:	dfc00115 	stw	ra,4(sp)
811125c8:	df000015 	stw	fp,0(sp)
811125cc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
811125d0:	d0a05417 	ldw	r2,-32432(gp)
811125d4:	100f883a 	mov	r7,r2
811125d8:	01800844 	movi	r6,33
811125dc:	01400044 	movi	r5,1
811125e0:	01204534 	movhi	r4,33044
811125e4:	210ea604 	addi	r4,r4,15000
811125e8:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
811125ec:	d0a05417 	ldw	r2,-32432(gp)
811125f0:	100f883a 	mov	r7,r2
811125f4:	01800784 	movi	r6,30
811125f8:	01400044 	movi	r5,1
811125fc:	01204534 	movhi	r4,33044
81112600:	210eaf04 	addi	r4,r4,15036
81112604:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112608:	0001883a 	nop
8111260c:	e037883a 	mov	sp,fp
81112610:	dfc00117 	ldw	ra,4(sp)
81112614:	df000017 	ldw	fp,0(sp)
81112618:	dec00204 	addi	sp,sp,8
8111261c:	f800283a 	ret

81112620 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
81112620:	defffe04 	addi	sp,sp,-8
81112624:	de00012e 	bgeu	sp,et,8111262c <vCoudlNotCreateNFee5Task+0xc>
81112628:	003b68fa 	trap	3
8111262c:	dfc00115 	stw	ra,4(sp)
81112630:	df000015 	stw	fp,0(sp)
81112634:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
81112638:	d0a05417 	ldw	r2,-32432(gp)
8111263c:	100f883a 	mov	r7,r2
81112640:	01800844 	movi	r6,33
81112644:	01400044 	movi	r5,1
81112648:	01204534 	movhi	r4,33044
8111264c:	210eb704 	addi	r4,r4,15068
81112650:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
81112654:	d0a05417 	ldw	r2,-32432(gp)
81112658:	100f883a 	mov	r7,r2
8111265c:	01800784 	movi	r6,30
81112660:	01400044 	movi	r5,1
81112664:	01204534 	movhi	r4,33044
81112668:	210ec004 	addi	r4,r4,15104
8111266c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112670:	0001883a 	nop
81112674:	e037883a 	mov	sp,fp
81112678:	dfc00117 	ldw	ra,4(sp)
8111267c:	df000017 	ldw	fp,0(sp)
81112680:	dec00204 	addi	sp,sp,8
81112684:	f800283a 	ret

81112688 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
81112688:	defffe04 	addi	sp,sp,-8
8111268c:	de00012e 	bgeu	sp,et,81112694 <vCoudlNotCreateNFeeControllerTask+0xc>
81112690:	003b68fa 	trap	3
81112694:	dfc00115 	stw	ra,4(sp)
81112698:	df000015 	stw	fp,0(sp)
8111269c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
811126a0:	d0a05417 	ldw	r2,-32432(gp)
811126a4:	100f883a 	mov	r7,r2
811126a8:	01800a84 	movi	r6,42
811126ac:	01400044 	movi	r5,1
811126b0:	01204534 	movhi	r4,33044
811126b4:	210ec804 	addi	r4,r4,15136
811126b8:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
811126bc:	d0a05417 	ldw	r2,-32432(gp)
811126c0:	100f883a 	mov	r7,r2
811126c4:	018009c4 	movi	r6,39
811126c8:	01400044 	movi	r5,1
811126cc:	01204534 	movhi	r4,33044
811126d0:	210ed304 	addi	r4,r4,15180
811126d4:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811126d8:	0001883a 	nop
811126dc:	e037883a 	mov	sp,fp
811126e0:	dfc00117 	ldw	ra,4(sp)
811126e4:	df000017 	ldw	fp,0(sp)
811126e8:	dec00204 	addi	sp,sp,8
811126ec:	f800283a 	ret

811126f0 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
811126f0:	defffe04 	addi	sp,sp,-8
811126f4:	de00012e 	bgeu	sp,et,811126fc <vCoudlNotCreateDataControllerTask+0xc>
811126f8:	003b68fa 	trap	3
811126fc:	dfc00115 	stw	ra,4(sp)
81112700:	df000015 	stw	fp,0(sp)
81112704:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
81112708:	d0a05417 	ldw	r2,-32432(gp)
8111270c:	100f883a 	mov	r7,r2
81112710:	01800a84 	movi	r6,42
81112714:	01400044 	movi	r5,1
81112718:	01204534 	movhi	r4,33044
8111271c:	210edd04 	addi	r4,r4,15220
81112720:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
81112724:	d0a05417 	ldw	r2,-32432(gp)
81112728:	100f883a 	mov	r7,r2
8111272c:	018009c4 	movi	r6,39
81112730:	01400044 	movi	r5,1
81112734:	01204534 	movhi	r4,33044
81112738:	210ee804 	addi	r4,r4,15264
8111273c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112740:	0001883a 	nop
81112744:	e037883a 	mov	sp,fp
81112748:	dfc00117 	ldw	ra,4(sp)
8111274c:	df000017 	ldw	fp,0(sp)
81112750:	dec00204 	addi	sp,sp,8
81112754:	f800283a 	ret

81112758 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
81112758:	defffe04 	addi	sp,sp,-8
8111275c:	de00012e 	bgeu	sp,et,81112764 <vCoudlNotCreateMebTask+0xc>
81112760:	003b68fa 	trap	3
81112764:	dfc00115 	stw	ra,4(sp)
81112768:	df000015 	stw	fp,0(sp)
8111276c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
81112770:	d0a05417 	ldw	r2,-32432(gp)
81112774:	100f883a 	mov	r7,r2
81112778:	018007c4 	movi	r6,31
8111277c:	01400044 	movi	r5,1
81112780:	01204534 	movhi	r4,33044
81112784:	210ef204 	addi	r4,r4,15304
81112788:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
8111278c:	d0a05417 	ldw	r2,-32432(gp)
81112790:	100f883a 	mov	r7,r2
81112794:	018006c4 	movi	r6,27
81112798:	01400044 	movi	r5,1
8111279c:	01204534 	movhi	r4,33044
811127a0:	210efa04 	addi	r4,r4,15336
811127a4:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811127a8:	0001883a 	nop
811127ac:	e037883a 	mov	sp,fp
811127b0:	dfc00117 	ldw	ra,4(sp)
811127b4:	df000017 	ldw	fp,0(sp)
811127b8:	dec00204 	addi	sp,sp,8
811127bc:	f800283a 	ret

811127c0 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
811127c0:	defffd04 	addi	sp,sp,-12
811127c4:	de00012e 	bgeu	sp,et,811127cc <vFailCreateMutexSPUSQueueMeb+0xc>
811127c8:	003b68fa 	trap	3
811127cc:	dfc00215 	stw	ra,8(sp)
811127d0:	df000115 	stw	fp,4(sp)
811127d4:	df000104 	addi	fp,sp,4
811127d8:	2005883a 	mov	r2,r4
811127dc:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
811127e0:	d0a05417 	ldw	r2,-32432(gp)
811127e4:	100f883a 	mov	r7,r2
811127e8:	01800944 	movi	r6,37
811127ec:	01400044 	movi	r5,1
811127f0:	01204534 	movhi	r4,33044
811127f4:	210f0104 	addi	r4,r4,15364
811127f8:	1115d200 	call	81115d20 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
811127fc:	e0bfff03 	ldbu	r2,-4(fp)
81112800:	1009883a 	mov	r4,r2
81112804:	11110280 	call	81111028 <printErrorTask>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112808:	0001883a 	nop
8111280c:	e037883a 	mov	sp,fp
81112810:	dfc00117 	ldw	ra,4(sp)
81112814:	df000017 	ldw	fp,0(sp)
81112818:	dec00204 	addi	sp,sp,8
8111281c:	f800283a 	ret

81112820 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
81112820:	defffe04 	addi	sp,sp,-8
81112824:	de00012e 	bgeu	sp,et,8111282c <vFailSendPUStoMebTask+0xc>
81112828:	003b68fa 	trap	3
8111282c:	dfc00115 	stw	ra,4(sp)
81112830:	df000015 	stw	fp,0(sp)
81112834:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
81112838:	d0a05417 	ldw	r2,-32432(gp)
8111283c:	100f883a 	mov	r7,r2
81112840:	01800784 	movi	r6,30
81112844:	01400044 	movi	r5,1
81112848:	01204534 	movhi	r4,33044
8111284c:	210f0b04 	addi	r4,r4,15404
81112850:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112854:	0001883a 	nop
81112858:	e037883a 	mov	sp,fp
8111285c:	dfc00117 	ldw	ra,4(sp)
81112860:	df000017 	ldw	fp,0(sp)
81112864:	dec00204 	addi	sp,sp,8
81112868:	f800283a 	ret

8111286c <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8111286c:	defffe04 	addi	sp,sp,-8
81112870:	de00012e 	bgeu	sp,et,81112878 <vCouldNotGetCmdQueueMeb+0xc>
81112874:	003b68fa 	trap	3
81112878:	dfc00115 	stw	ra,4(sp)
8111287c:	df000015 	stw	fp,0(sp)
81112880:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetCmdQueueMeb. (exit)\n");
81112884:	d0a05417 	ldw	r2,-32432(gp)
81112888:	100f883a 	mov	r7,r2
8111288c:	01800804 	movi	r6,32
81112890:	01400044 	movi	r5,1
81112894:	01204534 	movhi	r4,33044
81112898:	210f1304 	addi	r4,r4,15436
8111289c:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
811128a0:	d0a05417 	ldw	r2,-32432(gp)
811128a4:	100f883a 	mov	r7,r2
811128a8:	01800cc4 	movi	r6,51
811128ac:	01400044 	movi	r5,1
811128b0:	01204534 	movhi	r4,33044
811128b4:	210f1c04 	addi	r4,r4,15472
811128b8:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811128bc:	0001883a 	nop
811128c0:	e037883a 	mov	sp,fp
811128c4:	dfc00117 	ldw	ra,4(sp)
811128c8:	df000017 	ldw	fp,0(sp)
811128cc:	dec00204 	addi	sp,sp,8
811128d0:	f800283a 	ret

811128d4 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
811128d4:	defffe04 	addi	sp,sp,-8
811128d8:	de00012e 	bgeu	sp,et,811128e0 <vCouldNotGetMutexMebPus+0xc>
811128dc:	003b68fa 	trap	3
811128e0:	dfc00115 	stw	ra,4(sp)
811128e4:	df000015 	stw	fp,0(sp)
811128e8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
811128ec:	d0a05417 	ldw	r2,-32432(gp)
811128f0:	100f883a 	mov	r7,r2
811128f4:	01800804 	movi	r6,32
811128f8:	01400044 	movi	r5,1
811128fc:	01204534 	movhi	r4,33044
81112900:	210f2904 	addi	r4,r4,15524
81112904:	1115d200 	call	81115d20 <fwrite>
	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112908:	0001883a 	nop
8111290c:	e037883a 	mov	sp,fp
81112910:	dfc00117 	ldw	ra,4(sp)
81112914:	df000017 	ldw	fp,0(sp)
81112918:	dec00204 	addi	sp,sp,8
8111291c:	f800283a 	ret

81112920 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
81112920:	defffe04 	addi	sp,sp,-8
81112924:	de00012e 	bgeu	sp,et,8111292c <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
81112928:	003b68fa 	trap	3
8111292c:	dfc00115 	stw	ra,4(sp)
81112930:	df000015 	stw	fp,0(sp)
81112934:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
81112938:	d0a05417 	ldw	r2,-32432(gp)
8111293c:	100f883a 	mov	r7,r2
81112940:	01800a44 	movi	r6,41
81112944:	01400044 	movi	r5,1
81112948:	01204534 	movhi	r4,33044
8111294c:	210f3204 	addi	r4,r4,15560
81112950:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
81112954:	d0a05417 	ldw	r2,-32432(gp)
81112958:	100f883a 	mov	r7,r2
8111295c:	01800c84 	movi	r6,50
81112960:	01400044 	movi	r5,1
81112964:	01204534 	movhi	r4,33044
81112968:	210f3d04 	addi	r4,r4,15604
8111296c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112970:	0001883a 	nop
81112974:	e037883a 	mov	sp,fp
81112978:	dfc00117 	ldw	ra,4(sp)
8111297c:	df000017 	ldw	fp,0(sp)
81112980:	dec00204 	addi	sp,sp,8
81112984:	f800283a 	ret

81112988 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
81112988:	defffe04 	addi	sp,sp,-8
8111298c:	de00012e 	bgeu	sp,et,81112994 <vCouldNotCreateQueueMaskDataCtrl+0xc>
81112990:	003b68fa 	trap	3
81112994:	dfc00115 	stw	ra,4(sp)
81112998:	df000015 	stw	fp,0(sp)
8111299c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
811129a0:	d0a05417 	ldw	r2,-32432(gp)
811129a4:	100f883a 	mov	r7,r2
811129a8:	01800a44 	movi	r6,41
811129ac:	01400044 	movi	r5,1
811129b0:	01204534 	movhi	r4,33044
811129b4:	210f4a04 	addi	r4,r4,15656
811129b8:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
811129bc:	d0a05417 	ldw	r2,-32432(gp)
811129c0:	100f883a 	mov	r7,r2
811129c4:	01800c84 	movi	r6,50
811129c8:	01400044 	movi	r5,1
811129cc:	01204534 	movhi	r4,33044
811129d0:	210f5504 	addi	r4,r4,15700
811129d4:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
811129d8:	0001883a 	nop
811129dc:	e037883a 	mov	sp,fp
811129e0:	dfc00117 	ldw	ra,4(sp)
811129e4:	df000017 	ldw	fp,0(sp)
811129e8:	dec00204 	addi	sp,sp,8
811129ec:	f800283a 	ret

811129f0 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
811129f0:	defffe04 	addi	sp,sp,-8
811129f4:	de00012e 	bgeu	sp,et,811129fc <vCouldNotGetQueueMaskNfeeCtrl+0xc>
811129f8:	003b68fa 	trap	3
811129fc:	dfc00115 	stw	ra,4(sp)
81112a00:	df000015 	stw	fp,0(sp)
81112a04:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
81112a08:	d0a05417 	ldw	r2,-32432(gp)
81112a0c:	100f883a 	mov	r7,r2
81112a10:	01800984 	movi	r6,38
81112a14:	01400044 	movi	r5,1
81112a18:	01204534 	movhi	r4,33044
81112a1c:	210f6204 	addi	r4,r4,15752
81112a20:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
81112a24:	d0a05417 	ldw	r2,-32432(gp)
81112a28:	100f883a 	mov	r7,r2
81112a2c:	01800bc4 	movi	r6,47
81112a30:	01400044 	movi	r5,1
81112a34:	01204534 	movhi	r4,33044
81112a38:	210f6c04 	addi	r4,r4,15792
81112a3c:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112a40:	0001883a 	nop
81112a44:	e037883a 	mov	sp,fp
81112a48:	dfc00117 	ldw	ra,4(sp)
81112a4c:	df000017 	ldw	fp,0(sp)
81112a50:	dec00204 	addi	sp,sp,8
81112a54:	f800283a 	ret

81112a58 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
81112a58:	defffe04 	addi	sp,sp,-8
81112a5c:	de00012e 	bgeu	sp,et,81112a64 <vCouldNotGetQueueMaskDataCtrl+0xc>
81112a60:	003b68fa 	trap	3
81112a64:	dfc00115 	stw	ra,4(sp)
81112a68:	df000015 	stw	fp,0(sp)
81112a6c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
81112a70:	d0a05417 	ldw	r2,-32432(gp)
81112a74:	100f883a 	mov	r7,r2
81112a78:	01800984 	movi	r6,38
81112a7c:	01400044 	movi	r5,1
81112a80:	01204534 	movhi	r4,33044
81112a84:	210f7804 	addi	r4,r4,15840
81112a88:	1115d200 	call	81115d20 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
81112a8c:	d0a05417 	ldw	r2,-32432(gp)
81112a90:	100f883a 	mov	r7,r2
81112a94:	01800bc4 	movi	r6,47
81112a98:	01400044 	movi	r5,1
81112a9c:	01204534 	movhi	r4,33044
81112aa0:	210f8204 	addi	r4,r4,15880
81112aa4:	1115d200 	call	81115d20 <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112aa8:	0001883a 	nop
81112aac:	e037883a 	mov	sp,fp
81112ab0:	dfc00117 	ldw	ra,4(sp)
81112ab4:	df000017 	ldw	fp,0(sp)
81112ab8:	dec00204 	addi	sp,sp,8
81112abc:	f800283a 	ret

81112ac0 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
81112ac0:	defffd04 	addi	sp,sp,-12
81112ac4:	de00012e 	bgeu	sp,et,81112acc <vFailSendMsgAccessDMA+0xc>
81112ac8:	003b68fa 	trap	3
81112acc:	dfc00215 	stw	ra,8(sp)
81112ad0:	df000115 	stw	fp,4(sp)
81112ad4:	df000104 	addi	fp,sp,4
81112ad8:	2005883a 	mov	r2,r4
81112adc:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
81112ae0:	d0a05417 	ldw	r2,-32432(gp)
81112ae4:	e0ffff03 	ldbu	r3,-4(fp)
81112ae8:	180d883a 	mov	r6,r3
81112aec:	01604534 	movhi	r5,33044
81112af0:	294f8e04 	addi	r5,r5,15928
81112af4:	1009883a 	mov	r4,r2
81112af8:	11156840 	call	81115684 <fprintf>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112afc:	0001883a 	nop
81112b00:	e037883a 	mov	sp,fp
81112b04:	dfc00117 	ldw	ra,4(sp)
81112b08:	df000017 	ldw	fp,0(sp)
81112b0c:	dec00204 	addi	sp,sp,8
81112b10:	f800283a 	ret

81112b14 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
81112b14:	defffe04 	addi	sp,sp,-8
81112b18:	de00012e 	bgeu	sp,et,81112b20 <vFailSendMsgFeeCTRL+0xc>
81112b1c:	003b68fa 	trap	3
81112b20:	dfc00115 	stw	ra,4(sp)
81112b24:	df000015 	stw	fp,0(sp)
81112b28:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
81112b2c:	d0a05417 	ldw	r2,-32432(gp)
81112b30:	100f883a 	mov	r7,r2
81112b34:	018005c4 	movi	r6,23
81112b38:	01400044 	movi	r5,1
81112b3c:	01204534 	movhi	r4,33044
81112b40:	210f9604 	addi	r4,r4,15960
81112b44:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
81112b48:	0001883a 	nop
81112b4c:	e037883a 	mov	sp,fp
81112b50:	dfc00117 	ldw	ra,4(sp)
81112b54:	df000017 	ldw	fp,0(sp)
81112b58:	dec00204 	addi	sp,sp,8
81112b5c:	f800283a 	ret

81112b60 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
81112b60:	defffe04 	addi	sp,sp,-8
81112b64:	de00012e 	bgeu	sp,et,81112b6c <vFailFlushQueue+0xc>
81112b68:	003b68fa 	trap	3
81112b6c:	dfc00115 	stw	ra,4(sp)
81112b70:	df000015 	stw	fp,0(sp)
81112b74:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
81112b78:	d0a05417 	ldw	r2,-32432(gp)
81112b7c:	100f883a 	mov	r7,r2
81112b80:	01800744 	movi	r6,29
81112b84:	01400044 	movi	r5,1
81112b88:	01204534 	movhi	r4,33044
81112b8c:	210f9c04 	addi	r4,r4,15984
81112b90:	1115d200 	call	81115d20 <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
81112b94:	0001883a 	nop
81112b98:	e037883a 	mov	sp,fp
81112b9c:	dfc00117 	ldw	ra,4(sp)
81112ba0:	df000017 	ldw	fp,0(sp)
81112ba4:	dec00204 	addi	sp,sp,8
81112ba8:	f800283a 	ret

81112bac <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( tSimucamStates eOldState, tSimucamStates eNewState ) {
81112bac:	defffc04 	addi	sp,sp,-16
81112bb0:	de00012e 	bgeu	sp,et,81112bb8 <vEvtChangeMebMode+0xc>
81112bb4:	003b68fa 	trap	3
81112bb8:	dfc00315 	stw	ra,12(sp)
81112bbc:	df000215 	stw	fp,8(sp)
81112bc0:	df000204 	addi	fp,sp,8
81112bc4:	e13ffe15 	stw	r4,-8(fp)
81112bc8:	e17fff15 	stw	r5,-4(fp)

	#ifdef DEBUG_ON
		fprintf(fp, "\nvEvtChangeMebMode ( sMebConfig = 0, sRun = 1 ) \n");
81112bcc:	d0a05417 	ldw	r2,-32432(gp)
81112bd0:	100f883a 	mov	r7,r2
81112bd4:	01800c44 	movi	r6,49
81112bd8:	01400044 	movi	r5,1
81112bdc:	01204534 	movhi	r4,33044
81112be0:	210fa404 	addi	r4,r4,16016
81112be4:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp, "Meb State Change: %hu -> %hu \n\n", eOldState, eNewState );
81112be8:	d0a05417 	ldw	r2,-32432(gp)
81112bec:	e1ffff17 	ldw	r7,-4(fp)
81112bf0:	e1bffe17 	ldw	r6,-8(fp)
81112bf4:	01604534 	movhi	r5,33044
81112bf8:	294fb104 	addi	r5,r5,16068
81112bfc:	1009883a 	mov	r4,r2
81112c00:	11156840 	call	81115684 <fprintf>
	#endif

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81112c04:	0001883a 	nop
81112c08:	e037883a 	mov	sp,fp
81112c0c:	dfc00117 	ldw	ra,4(sp)
81112c10:	df000017 	ldw	fp,0(sp)
81112c14:	dec00204 	addi	sp,sp,8
81112c18:	f800283a 	ret

81112c1c <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( tSimucamStates eOldState, tSimucamStates eNewState ) {
81112c1c:	defffc04 	addi	sp,sp,-16
81112c20:	de00012e 	bgeu	sp,et,81112c28 <vEvtChangeFeeControllerMode+0xc>
81112c24:	003b68fa 	trap	3
81112c28:	dfc00315 	stw	ra,12(sp)
81112c2c:	df000215 	stw	fp,8(sp)
81112c30:	df000204 	addi	fp,sp,8
81112c34:	e13ffe15 	stw	r4,-8(fp)
81112c38:	e17fff15 	stw	r5,-4(fp)

	#ifdef DEBUG_ON
		fprintf(fp, "\vEvtChangeFeeControllerMode ( sMebConfig = 0, sRun = 1 ) \n");
81112c3c:	d0a05417 	ldw	r2,-32432(gp)
81112c40:	100f883a 	mov	r7,r2
81112c44:	01800e84 	movi	r6,58
81112c48:	01400044 	movi	r5,1
81112c4c:	01204534 	movhi	r4,33044
81112c50:	210fb904 	addi	r4,r4,16100
81112c54:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp, "NFEE Controller State Change: %hu -> %hu \n\n", eOldState, eNewState );
81112c58:	d0a05417 	ldw	r2,-32432(gp)
81112c5c:	e1ffff17 	ldw	r7,-4(fp)
81112c60:	e1bffe17 	ldw	r6,-8(fp)
81112c64:	01604534 	movhi	r5,33044
81112c68:	294fc804 	addi	r5,r5,16160
81112c6c:	1009883a 	mov	r4,r2
81112c70:	11156840 	call	81115684 <fprintf>
	#endif

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81112c74:	0001883a 	nop
81112c78:	e037883a 	mov	sp,fp
81112c7c:	dfc00117 	ldw	ra,4(sp)
81112c80:	df000017 	ldw	fp,0(sp)
81112c84:	dec00204 	addi	sp,sp,8
81112c88:	f800283a 	ret

81112c8c <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( tSimucamStates eOldState, tSimucamStates eNewState ) {
81112c8c:	defffc04 	addi	sp,sp,-16
81112c90:	de00012e 	bgeu	sp,et,81112c98 <vEvtChangeDataControllerMode+0xc>
81112c94:	003b68fa 	trap	3
81112c98:	dfc00315 	stw	ra,12(sp)
81112c9c:	df000215 	stw	fp,8(sp)
81112ca0:	df000204 	addi	fp,sp,8
81112ca4:	e13ffe15 	stw	r4,-8(fp)
81112ca8:	e17fff15 	stw	r5,-4(fp)

	#ifdef DEBUG_ON
		fprintf(fp, "\vEvtChangeDataControllerMode ( sMebConfig = 0, sRun = 1 ) \n");
81112cac:	d0a05417 	ldw	r2,-32432(gp)
81112cb0:	100f883a 	mov	r7,r2
81112cb4:	01800ec4 	movi	r6,59
81112cb8:	01400044 	movi	r5,1
81112cbc:	01204534 	movhi	r4,33044
81112cc0:	210fd304 	addi	r4,r4,16204
81112cc4:	1115d200 	call	81115d20 <fwrite>
		fprintf(fp, "Data Controller State Change: %hu -> %hu \n\n", eOldState, eNewState );
81112cc8:	d0a05417 	ldw	r2,-32432(gp)
81112ccc:	e1ffff17 	ldw	r7,-4(fp)
81112cd0:	e1bffe17 	ldw	r6,-8(fp)
81112cd4:	01604534 	movhi	r5,33044
81112cd8:	294fe204 	addi	r5,r5,16264
81112cdc:	1009883a 	mov	r4,r2
81112ce0:	11156840 	call	81115684 <fprintf>
	#endif

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
81112ce4:	0001883a 	nop
81112ce8:	e037883a 	mov	sp,fp
81112cec:	dfc00117 	ldw	ra,4(sp)
81112cf0:	df000017 	ldw	fp,0(sp)
81112cf4:	dec00204 	addi	sp,sp,8
81112cf8:	f800283a 	ret

81112cfc <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81112cfc:	defffd04 	addi	sp,sp,-12
81112d00:	de00012e 	bgeu	sp,et,81112d08 <vNFeeNotInUse+0xc>
81112d04:	003b68fa 	trap	3
81112d08:	df000215 	stw	fp,8(sp)
81112d0c:	df000204 	addi	fp,sp,8
81112d10:	e13ffe15 	stw	r4,-8(fp)
81112d14:	2805883a 	mov	r2,r5
81112d18:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
81112d1c:	e0bffe17 	ldw	r2,-8(fp)
81112d20:	e0ffff03 	ldbu	r3,-4(fp)
81112d24:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
81112d28:	e0bffe17 	ldw	r2,-8(fp)
81112d2c:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81112d30:	e0bffe17 	ldw	r2,-8(fp)
81112d34:	10002215 	stw	zero,136(r2)
}
81112d38:	0001883a 	nop
81112d3c:	e037883a 	mov	sp,fp
81112d40:	df000017 	ldw	fp,0(sp)
81112d44:	dec00104 	addi	sp,sp,4
81112d48:	f800283a 	ret

81112d4c <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81112d4c:	defffb04 	addi	sp,sp,-20
81112d50:	de00012e 	bgeu	sp,et,81112d58 <vNFeeStructureInit+0xc>
81112d54:	003b68fa 	trap	3
81112d58:	dfc00415 	stw	ra,16(sp)
81112d5c:	df000315 	stw	fp,12(sp)
81112d60:	df000304 	addi	fp,sp,12
81112d64:	e13ffe15 	stw	r4,-8(fp)
81112d68:	2805883a 	mov	r2,r5
81112d6c:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
81112d70:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
81112d74:	e0bffe17 	ldw	r2,-8(fp)
81112d78:	e0ffff03 	ldbu	r3,-4(fp)
81112d7c:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
81112d80:	e0bffe17 	ldw	r2,-8(fp)
81112d84:	10802904 	addi	r2,r2,164
81112d88:	1009883a 	mov	r4,r2
81112d8c:	110ece80 	call	8110ece8 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
81112d90:	e13ffe17 	ldw	r4,-8(fp)
81112d94:	1112e240 	call	81112e24 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
81112d98:	e0bffe17 	ldw	r2,-8(fp)
81112d9c:	00c00044 	movi	r3,1
81112da0:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81112da4:	e0bffe17 	ldw	r2,-8(fp)
81112da8:	10002215 	stw	zero,136(r2)
    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeConfig;    
81112dac:	e0bffe17 	ldw	r2,-8(fp)
81112db0:	10002715 	stw	zero,156(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
81112db4:	e03ffd05 	stb	zero,-12(fp)
81112db8:	00000906 	br	81112de0 <vNFeeStructureInit+0x94>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
81112dbc:	e0bffd03 	ldbu	r2,-12(fp)
81112dc0:	e0fffe17 	ldw	r3,-8(fp)
81112dc4:	1885883a 	add	r2,r3,r2
81112dc8:	10802604 	addi	r2,r2,152
81112dcc:	e0fffd03 	ldbu	r3,-12(fp)
81112dd0:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
81112dd4:	e0bffd03 	ldbu	r2,-12(fp)
81112dd8:	10800044 	addi	r2,r2,1
81112ddc:	e0bffd05 	stb	r2,-12(fp)
81112de0:	e0bffd03 	ldbu	r2,-12(fp)
81112de4:	10800130 	cmpltui	r2,r2,4
81112de8:	103ff41e 	bne	r2,zero,81112dbc <__reset+0xfb0f2dbc>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
81112dec:	e0bffe17 	ldw	r2,-8(fp)
81112df0:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
81112df4:	e0bffe17 	ldw	r2,-8(fp)
81112df8:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bLogging = FALSE;
81112dfc:	e0bffe17 	ldw	r2,-8(fp)
81112e00:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
81112e04:	e0bffe17 	ldw	r2,-8(fp)
81112e08:	10002515 	stw	zero,148(r2)

}
81112e0c:	0001883a 	nop
81112e10:	e037883a 	mov	sp,fp
81112e14:	dfc00117 	ldw	ra,4(sp)
81112e18:	df000017 	ldw	fp,0(sp)
81112e1c:	dec00204 	addi	sp,sp,8
81112e20:	f800283a 	ret

81112e24 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
81112e24:	defff404 	addi	sp,sp,-48
81112e28:	de00012e 	bgeu	sp,et,81112e30 <vUpdateMemMapFEE+0xc>
81112e2c:	003b68fa 	trap	3
81112e30:	df000b15 	stw	fp,44(sp)
81112e34:	df000b04 	addi	fp,sp,44
81112e38:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
81112e3c:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
81112e40:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
81112e44:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
81112e48:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
81112e4c:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
81112e50:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
81112e54:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
81112e58:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
81112e5c:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
81112e60:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
81112e64:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
81112e68:	e17fff17 	ldw	r5,-4(fp)
81112e6c:	01035a34 	movhi	r4,3432
81112e70:	21348c04 	addi	r4,r4,-11728
81112e74:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
81112e78:	e13fff17 	ldw	r4,-4(fp)
81112e7c:	21000003 	ldbu	r4,0(r4)
81112e80:	21403fcc 	andi	r5,r4,255
81112e84:	01035a34 	movhi	r4,3432
81112e88:	21348c04 	addi	r4,r4,-11728
81112e8c:	2909383a 	mul	r4,r5,r4
81112e90:	200b883a 	mov	r5,r4
81112e94:	e13fff17 	ldw	r4,-4(fp)
81112e98:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
81112e9c:	e13fff17 	ldw	r4,-4(fp)
81112ea0:	21400117 	ldw	r5,4(r4)
81112ea4:	01033234 	movhi	r4,3272
81112ea8:	21348c04 	addi	r4,r4,-11728
81112eac:	290b883a 	add	r5,r5,r4
81112eb0:	e13fff17 	ldw	r4,-4(fp)
81112eb4:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81112eb8:	e13fff17 	ldw	r4,-4(fp)
81112ebc:	21002b0b 	ldhu	r4,172(r4)
81112ec0:	217fffcc 	andi	r5,r4,65535
81112ec4:	e13fff17 	ldw	r4,-4(fp)
81112ec8:	21002a0b 	ldhu	r4,168(r4)
81112ecc:	213fffcc 	andi	r4,r4,65535
81112ed0:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
81112ed4:	e13fff17 	ldw	r4,-4(fp)
81112ed8:	21002a8b 	ldhu	r4,170(r4)
81112edc:	21bfffcc 	andi	r6,r4,65535
81112ee0:	e13fff17 	ldw	r4,-4(fp)
81112ee4:	2100298b 	ldhu	r4,166(r4)
81112ee8:	213fffcc 	andi	r4,r4,65535
81112eec:	310d883a 	add	r6,r6,r4
81112ef0:	e13fff17 	ldw	r4,-4(fp)
81112ef4:	2100290b 	ldhu	r4,164(r4)
81112ef8:	213fffcc 	andi	r4,r4,65535
81112efc:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81112f00:	2909383a 	mul	r4,r5,r4
81112f04:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
81112f08:	e13ffa17 	ldw	r4,-24(fp)
81112f0c:	2109883a 	add	r4,r4,r4
81112f10:	200b883a 	mov	r5,r4
81112f14:	e13fff17 	ldw	r4,-4(fp)
81112f18:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
81112f1c:	e13fff17 	ldw	r4,-4(fp)
81112f20:	21000517 	ldw	r4,20(r4)
81112f24:	2008d0fa 	srli	r4,r4,3
81112f28:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
81112f2c:	e13fff17 	ldw	r4,-4(fp)
81112f30:	21000517 	ldw	r4,20(r4)
81112f34:	210001cc 	andi	r4,r4,7
81112f38:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
81112f3c:	e13ffb17 	ldw	r4,-20(fp)
81112f40:	20001226 	beq	r4,zero,81112f8c <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
81112f44:	e13ff517 	ldw	r4,-44(fp)
81112f48:	21000044 	addi	r4,r4,1
81112f4c:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
81112f50:	e13fff17 	ldw	r4,-4(fp)
81112f54:	21400517 	ldw	r5,20(r4)
81112f58:	e13ffb17 	ldw	r4,-20(fp)
81112f5c:	2909c83a 	sub	r4,r5,r4
81112f60:	21400204 	addi	r5,r4,8
81112f64:	e13fff17 	ldw	r4,-4(fp)
81112f68:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
81112f6c:	e13ffb17 	ldw	r4,-20(fp)
81112f70:	200b883a 	mov	r5,r4
81112f74:	01000204 	movi	r4,8
81112f78:	2149c83a 	sub	r4,r4,r5
81112f7c:	200b883a 	mov	r5,r4
81112f80:	e13fff17 	ldw	r4,-4(fp)
81112f84:	21400605 	stb	r5,24(r4)
81112f88:	00000206 	br	81112f94 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
81112f8c:	e13fff17 	ldw	r4,-4(fp)
81112f90:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
81112f94:	e13ff517 	ldw	r4,-44(fp)
81112f98:	2008d13a 	srli	r4,r4,4
81112f9c:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
81112fa0:	e13ff517 	ldw	r4,-44(fp)
81112fa4:	210003cc 	andi	r4,r4,15
81112fa8:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
81112fac:	e13ffc17 	ldw	r4,-16(fp)
81112fb0:	20000b26 	beq	r4,zero,81112fe0 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
81112fb4:	e13ff717 	ldw	r4,-36(fp)
81112fb8:	21000044 	addi	r4,r4,1
81112fbc:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
81112fc0:	e17ff517 	ldw	r5,-44(fp)
81112fc4:	e13ffc17 	ldw	r4,-16(fp)
81112fc8:	290bc83a 	sub	r5,r5,r4
81112fcc:	e13ff717 	ldw	r4,-36(fp)
81112fd0:	2909883a 	add	r4,r5,r4
81112fd4:	21000404 	addi	r4,r4,16
81112fd8:	e13ff615 	stw	r4,-40(fp)
81112fdc:	00000406 	br	81112ff0 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
81112fe0:	e17ff517 	ldw	r5,-44(fp)
81112fe4:	e13ff717 	ldw	r4,-36(fp)
81112fe8:	2909883a 	add	r4,r5,r4
81112fec:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
81112ff0:	e13ff617 	ldw	r4,-40(fp)
81112ff4:	200a90fa 	slli	r5,r4,3
81112ff8:	e13fff17 	ldw	r4,-4(fp)
81112ffc:	21400515 	stw	r5,20(r4)

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
81113000:	e13ffb17 	ldw	r4,-20(fp)
81113004:	20000926 	beq	r4,zero,8111302c <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
81113008:	e13ffc17 	ldw	r4,-16(fp)
8111300c:	2109883a 	add	r4,r4,r4
81113010:	2109883a 	add	r4,r4,r4
81113014:	200b883a 	mov	r5,r4
81113018:	e13ffb17 	ldw	r4,-20(fp)
8111301c:	2008d07a 	srli	r4,r4,1
81113020:	2909883a 	add	r4,r5,r4
81113024:	e13ff805 	stb	r4,-32(fp)
81113028:	00000406 	br	8111303c <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111302c:	e13ffc17 	ldw	r4,-16(fp)
81113030:	2109883a 	add	r4,r4,r4
81113034:	2109883a 	add	r4,r4,r4
81113038:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111303c:	e13ff803 	ldbu	r4,-32(fp)
81113040:	01401004 	movi	r5,64
81113044:	2909c83a 	sub	r4,r5,r4
81113048:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
8111304c:	e13ffd03 	ldbu	r4,-12(fp)
81113050:	217ff804 	addi	r5,r4,-32
81113054:	28000416 	blt	r5,zero,81113068 <vUpdateMemMapFEE+0x244>
81113058:	013fffc4 	movi	r4,-1
8111305c:	2144d83a 	srl	r2,r4,r5
81113060:	0007883a 	mov	r3,zero
81113064:	00000a06 	br	81113090 <vUpdateMemMapFEE+0x26c>
81113068:	017fffc4 	movi	r5,-1
8111306c:	280c907a 	slli	r6,r5,1
81113070:	014007c4 	movi	r5,31
81113074:	290bc83a 	sub	r5,r5,r4
81113078:	314a983a 	sll	r5,r6,r5
8111307c:	01bfffc4 	movi	r6,-1
81113080:	3104d83a 	srl	r2,r6,r4
81113084:	2884b03a 	or	r2,r5,r2
81113088:	017fffc4 	movi	r5,-1
8111308c:	2906d83a 	srl	r3,r5,r4
81113090:	e13fff17 	ldw	r4,-4(fp)
81113094:	20800715 	stw	r2,28(r4)
81113098:	20c00815 	stw	r3,32(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111309c:	e0bfff17 	ldw	r2,-4(fp)
811130a0:	e0fff717 	ldw	r3,-36(fp)
811130a4:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
811130a8:	e0bfff17 	ldw	r2,-4(fp)
811130ac:	10c00117 	ldw	r3,4(r2)
811130b0:	008004b4 	movhi	r2,18
811130b4:	10a40004 	addi	r2,r2,-28672
811130b8:	1885883a 	add	r2,r3,r2
811130bc:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
811130c0:	e0bfff17 	ldw	r2,-4(fp)
811130c4:	10c00517 	ldw	r3,20(r2)
811130c8:	008000b4 	movhi	r2,2
811130cc:	10a40004 	addi	r2,r2,-28672
811130d0:	1885883a 	add	r2,r3,r2
811130d4:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
811130d8:	e03ff845 	stb	zero,-31(fp)
811130dc:	00001906 	br	81113144 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
811130e0:	e0bff843 	ldbu	r2,-31(fp)
811130e4:	e0ffff17 	ldw	r3,-4(fp)
811130e8:	10800624 	muli	r2,r2,24
811130ec:	1885883a 	add	r2,r3,r2
811130f0:	10800904 	addi	r2,r2,36
811130f4:	e0fff917 	ldw	r3,-28(fp)
811130f8:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
811130fc:	e0fff917 	ldw	r3,-28(fp)
81113100:	e0bffe17 	ldw	r2,-8(fp)
81113104:	1885883a 	add	r2,r3,r2
81113108:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111310c:	e0bff843 	ldbu	r2,-31(fp)
81113110:	e0ffff17 	ldw	r3,-4(fp)
81113114:	10800624 	muli	r2,r2,24
81113118:	1885883a 	add	r2,r3,r2
8111311c:	10800c04 	addi	r2,r2,48
81113120:	e0fff917 	ldw	r3,-28(fp)
81113124:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81113128:	e0fff917 	ldw	r3,-28(fp)
8111312c:	e0bffe17 	ldw	r2,-8(fp)
81113130:	1885883a 	add	r2,r3,r2
81113134:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81113138:	e0bff843 	ldbu	r2,-31(fp)
8111313c:	10800044 	addi	r2,r2,1
81113140:	e0bff845 	stb	r2,-31(fp)
81113144:	e0bff843 	ldbu	r2,-31(fp)
81113148:	10800130 	cmpltui	r2,r2,4
8111314c:	103fe41e 	bne	r2,zero,811130e0 <__reset+0xfb0f30e0>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
81113150:	0001883a 	nop
81113154:	e037883a 	mov	sp,fp
81113158:	df000017 	ldw	fp,0(sp)
8111315c:	dec00104 	addi	sp,sp,4
81113160:	f800283a 	ret

81113164 <vFeeSpwRMAPLoadDefault>:

/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
81113164:	defffe04 	addi	sp,sp,-8
81113168:	de00012e 	bgeu	sp,et,81113170 <vFeeSpwRMAPLoadDefault+0xc>
8111316c:	003b68fa 	trap	3
81113170:	df000115 	stw	fp,4(sp)
81113174:	df000104 	addi	fp,sp,4
81113178:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configurações
}
8111317c:	0001883a 	nop
81113180:	e037883a 	mov	sp,fp
81113184:	df000017 	ldw	fp,0(sp)
81113188:	dec00104 	addi	sp,sp,4
8111318c:	f800283a 	ret

81113190 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
81113190:	defffe04 	addi	sp,sp,-8
81113194:	de00012e 	bgeu	sp,et,8111319c <vFeeSpwRMAPChangeConfig+0xc>
81113198:	003b68fa 	trap	3
8111319c:	df000115 	stw	fp,4(sp)
811131a0:	df000104 	addi	fp,sp,4
811131a4:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configurações
}
811131a8:	0001883a 	nop
811131ac:	e037883a 	mov	sp,fp
811131b0:	df000017 	ldw	fp,0(sp)
811131b4:	dec00104 	addi	sp,sp,4
811131b8:	f800283a 	ret

811131bc <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
811131bc:	defffe04 	addi	sp,sp,-8
811131c0:	de00012e 	bgeu	sp,et,811131c8 <vFeeSpwRMAPChangeDefault+0xc>
811131c4:	003b68fa 	trap	3
811131c8:	df000115 	stw	fp,4(sp)
811131cc:	df000104 	addi	fp,sp,4
811131d0:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configurações, enviar o numero do FEE tbm
}
811131d4:	0001883a 	nop
811131d8:	e037883a 	mov	sp,fp
811131dc:	df000017 	ldw	fp,0(sp)
811131e0:	dec00104 	addi	sp,sp,4
811131e4:	f800283a 	ret

811131e8 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
811131e8:	defffe04 	addi	sp,sp,-8
811131ec:	de00012e 	bgeu	sp,et,811131f4 <cFeeSpwChannelEnable+0xc>
811131f0:	003b68fa 	trap	3
811131f4:	df000115 	stw	fp,4(sp)
811131f8:	df000104 	addi	fp,sp,4
811131fc:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o França
}
81113200:	0001883a 	nop
81113204:	e037883a 	mov	sp,fp
81113208:	df000017 	ldw	fp,0(sp)
8111320c:	dec00104 	addi	sp,sp,4
81113210:	f800283a 	ret

81113214 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
81113214:	defffe04 	addi	sp,sp,-8
81113218:	de00012e 	bgeu	sp,et,81113220 <cFeeSpwChannelDisable+0xc>
8111321c:	003b68fa 	trap	3
81113220:	df000115 	stw	fp,4(sp)
81113224:	df000104 	addi	fp,sp,4
81113228:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o França
}
8111322c:	0001883a 	nop
81113230:	e037883a 	mov	sp,fp
81113234:	df000017 	ldw	fp,0(sp)
81113238:	dec00104 	addi	sp,sp,4
8111323c:	f800283a 	ret

81113240 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
81113240:	defffe04 	addi	sp,sp,-8
81113244:	de00012e 	bgeu	sp,et,8111324c <cFeeRMAPDump+0xc>
81113248:	003b68fa 	trap	3
8111324c:	df000115 	stw	fp,4(sp)
81113250:	df000104 	addi	fp,sp,4
81113254:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
81113258:	0001883a 	nop
8111325c:	e037883a 	mov	sp,fp
81113260:	df000017 	ldw	fp,0(sp)
81113264:	dec00104 	addi	sp,sp,4
81113268:	f800283a 	ret

8111326c <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8111326c:	defffe04 	addi	sp,sp,-8
81113270:	de00012e 	bgeu	sp,et,81113278 <cFeeRMAPEchoingEnable+0xc>
81113274:	003b68fa 	trap	3
81113278:	df000115 	stw	fp,4(sp)
8111327c:	df000104 	addi	fp,sp,4
81113280:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
81113284:	e0bfff17 	ldw	r2,-4(fp)
81113288:	00c00044 	movi	r3,1
8111328c:	10c02415 	stw	r3,144(r2)
}
81113290:	0001883a 	nop
81113294:	e037883a 	mov	sp,fp
81113298:	df000017 	ldw	fp,0(sp)
8111329c:	dec00104 	addi	sp,sp,4
811132a0:	f800283a 	ret

811132a4 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
811132a4:	defffe04 	addi	sp,sp,-8
811132a8:	de00012e 	bgeu	sp,et,811132b0 <cFeeRMAPEchoingDisable+0xc>
811132ac:	003b68fa 	trap	3
811132b0:	df000115 	stw	fp,4(sp)
811132b4:	df000104 	addi	fp,sp,4
811132b8:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
811132bc:	e0bfff17 	ldw	r2,-4(fp)
811132c0:	10002415 	stw	zero,144(r2)
}
811132c4:	0001883a 	nop
811132c8:	e037883a 	mov	sp,fp
811132cc:	df000017 	ldw	fp,0(sp)
811132d0:	dec00104 	addi	sp,sp,4
811132d4:	f800283a 	ret

811132d8 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
811132d8:	defffe04 	addi	sp,sp,-8
811132dc:	de00012e 	bgeu	sp,et,811132e4 <cFeeRMAPLogEnable+0xc>
811132e0:	003b68fa 	trap	3
811132e4:	df000115 	stw	fp,4(sp)
811132e8:	df000104 	addi	fp,sp,4
811132ec:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
811132f0:	e0bfff17 	ldw	r2,-4(fp)
811132f4:	00c00044 	movi	r3,1
811132f8:	10c02315 	stw	r3,140(r2)
}
811132fc:	0001883a 	nop
81113300:	e037883a 	mov	sp,fp
81113304:	df000017 	ldw	fp,0(sp)
81113308:	dec00104 	addi	sp,sp,4
8111330c:	f800283a 	ret

81113310 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
81113310:	defffe04 	addi	sp,sp,-8
81113314:	de00012e 	bgeu	sp,et,8111331c <cFeeRMAPLogDisable+0xc>
81113318:	003b68fa 	trap	3
8111331c:	df000115 	stw	fp,4(sp)
81113320:	df000104 	addi	fp,sp,4
81113324:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
81113328:	e0bfff17 	ldw	r2,-4(fp)
8111332c:	10002315 	stw	zero,140(r2)
}
81113330:	0001883a 	nop
81113334:	e037883a 	mov	sp,fp
81113338:	df000017 	ldw	fp,0(sp)
8111333c:	dec00104 	addi	sp,sp,4
81113340:	f800283a 	ret

81113344 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
81113344:	defffc04 	addi	sp,sp,-16
81113348:	de00012e 	bgeu	sp,et,81113350 <vNFeeControlInit+0xc>
8111334c:	003b68fa 	trap	3
81113350:	dfc00315 	stw	ra,12(sp)
81113354:	df000215 	stw	fp,8(sp)
81113358:	df000204 	addi	fp,sp,8
8111335c:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
81113360:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
81113364:	e13fff17 	ldw	r4,-4(fp)
81113368:	11134440 	call	81113444 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111336c:	e13fff17 	ldw	r4,-4(fp)
81113370:	11134780 	call	81113478 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebConfig;
81113374:	e0bfff17 	ldw	r2,-4(fp)
81113378:	10010f15 	stw	zero,1084(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111337c:	e03ffe05 	stb	zero,-8(fp)
81113380:	00001706 	br	811133e0 <vNFeeControlInit+0x9c>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
81113384:	e0bffe03 	ldbu	r2,-8(fp)
81113388:	10802c24 	muli	r2,r2,176
8111338c:	e0ffff17 	ldw	r3,-4(fp)
81113390:	1885883a 	add	r2,r3,r2
81113394:	e0fffe03 	ldbu	r3,-8(fp)
81113398:	180b883a 	mov	r5,r3
8111339c:	1009883a 	mov	r4,r2
811133a0:	1112d4c0 	call	81112d4c <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
811133a4:	e0bffe03 	ldbu	r2,-8(fp)
811133a8:	e0fffe03 	ldbu	r3,-8(fp)
811133ac:	18c02c24 	muli	r3,r3,176
811133b0:	18c02104 	addi	r3,r3,132
811133b4:	e13fff17 	ldw	r4,-4(fp)
811133b8:	20c7883a 	add	r3,r4,r3
811133bc:	e13fff17 	ldw	r4,-4(fp)
811133c0:	10804204 	addi	r2,r2,264
811133c4:	1085883a 	add	r2,r2,r2
811133c8:	1085883a 	add	r2,r2,r2
811133cc:	2085883a 	add	r2,r4,r2
811133d0:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebConfig;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
811133d4:	e0bffe03 	ldbu	r2,-8(fp)
811133d8:	10800044 	addi	r2,r2,1
811133dc:	e0bffe05 	stb	r2,-8(fp)
811133e0:	e0bffe03 	ldbu	r2,-8(fp)
811133e4:	108001b0 	cmpltui	r2,r2,6
811133e8:	103fe61e 	bne	r2,zero,81113384 <__reset+0xfb0f3384>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
    }

}
811133ec:	0001883a 	nop
811133f0:	e037883a 	mov	sp,fp
811133f4:	dfc00117 	ldw	ra,4(sp)
811133f8:	df000017 	ldw	fp,0(sp)
811133fc:	dec00204 	addi	sp,sp,8
81113400:	f800283a 	ret

81113404 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
81113404:	defffd04 	addi	sp,sp,-12
81113408:	de00012e 	bgeu	sp,et,81113410 <vSetTimeCode+0xc>
8111340c:	003b68fa 	trap	3
81113410:	df000215 	stw	fp,8(sp)
81113414:	df000204 	addi	fp,sp,8
81113418:	e13ffe15 	stw	r4,-8(fp)
8111341c:	2805883a 	mov	r2,r5
81113420:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
81113424:	e0bffe17 	ldw	r2,-8(fp)
81113428:	e0ffff03 	ldbu	r3,-4(fp)
8111342c:	10c10e05 	stb	r3,1080(r2)
}
81113430:	0001883a 	nop
81113434:	e037883a 	mov	sp,fp
81113438:	df000017 	ldw	fp,0(sp)
8111343c:	dec00104 	addi	sp,sp,4
81113440:	f800283a 	ret

81113444 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
81113444:	defffe04 	addi	sp,sp,-8
81113448:	de00012e 	bgeu	sp,et,81113450 <vResetTimeCode+0xc>
8111344c:	003b68fa 	trap	3
81113450:	df000115 	stw	fp,4(sp)
81113454:	df000104 	addi	fp,sp,4
81113458:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111345c:	e0bfff17 	ldw	r2,-4(fp)
81113460:	10010e05 	stb	zero,1080(r2)
}
81113464:	0001883a 	nop
81113468:	e037883a 	mov	sp,fp
8111346c:	df000017 	ldw	fp,0(sp)
81113470:	dec00104 	addi	sp,sp,4
81113474:	f800283a 	ret

81113478 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
81113478:	defffe04 	addi	sp,sp,-8
8111347c:	de00012e 	bgeu	sp,et,81113484 <vLoadDefaultIdNFEEMaster+0xc>
81113480:	003b68fa 	trap	3
81113484:	df000115 	stw	fp,4(sp)
81113488:	df000104 	addi	fp,sp,4
8111348c:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
81113490:	e0bfff17 	ldw	r2,-4(fp)
81113494:	10010e45 	stb	zero,1081(r2)
}
81113498:	0001883a 	nop
8111349c:	e037883a 	mov	sp,fp
811134a0:	df000017 	ldw	fp,0(sp)
811134a4:	dec00104 	addi	sp,sp,4
811134a8:	f800283a 	ret

811134ac <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
811134ac:	defffd04 	addi	sp,sp,-12
811134b0:	de00012e 	bgeu	sp,et,811134b8 <vChangeIdNFEEMaster+0xc>
811134b4:	003b68fa 	trap	3
811134b8:	df000215 	stw	fp,8(sp)
811134bc:	df000204 	addi	fp,sp,8
811134c0:	e13ffe15 	stw	r4,-8(fp)
811134c4:	2805883a 	mov	r2,r5
811134c8:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
811134cc:	e0bffe17 	ldw	r2,-8(fp)
811134d0:	e0ffff03 	ldbu	r3,-4(fp)
811134d4:	10c10e45 	stb	r3,1081(r2)
}
811134d8:	0001883a 	nop
811134dc:	e037883a 	mov	sp,fp
811134e0:	df000017 	ldw	fp,0(sp)
811134e4:	dec00104 	addi	sp,sp,4
811134e8:	f800283a 	ret

811134ec <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
811134ec:	defffd04 	addi	sp,sp,-12
811134f0:	de00012e 	bgeu	sp,et,811134f8 <vChangeDefaultIdNFEEMaster+0xc>
811134f4:	003b68fa 	trap	3
811134f8:	df000215 	stw	fp,8(sp)
811134fc:	df000204 	addi	fp,sp,8
81113500:	e13ffe15 	stw	r4,-8(fp)
81113504:	2805883a 	mov	r2,r5
81113508:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111350c:	0001883a 	nop
81113510:	e037883a 	mov	sp,fp
81113514:	df000017 	ldw	fp,0(sp)
81113518:	dec00104 	addi	sp,sp,4
8111351c:	f800283a 	ret

81113520 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
81113520:	defffe04 	addi	sp,sp,-8
81113524:	de00012e 	bgeu	sp,et,8111352c <vInitSimucamBasicHW+0xc>
81113528:	003b68fa 	trap	3
8111352c:	dfc00115 	stw	ra,4(sp)
81113530:	df000015 	stw	fp,0(sp)
81113534:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
81113538:	01403fc4 	movi	r5,255
8111353c:	0009883a 	mov	r4,zero
81113540:	11061440 	call	81106144 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
81113544:	01400834 	movhi	r5,32
81113548:	297fffc4 	addi	r5,r5,-1
8111354c:	0009883a 	mov	r4,zero
81113550:	11061c40 	call	811061c4 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
81113554:	01400074 	movhi	r5,1
81113558:	01000044 	movi	r4,1
8111355c:	11061c40 	call	811061c4 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
81113560:	0009883a 	mov	r4,zero
81113564:	11077a00 	call	811077a0 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
81113568:	0009883a 	mov	r4,zero
8111356c:	11078700 	call	81107870 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81113570:	01008004 	movi	r4,512
81113574:	11073000 	call	81107300 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81113578:	01008004 	movi	r4,512
8111357c:	110728c0 	call	8110728c <vRstcReleaseDeviceReset>

}
81113580:	0001883a 	nop
81113584:	e037883a 	mov	sp,fp
81113588:	dfc00117 	ldw	ra,4(sp)
8111358c:	df000017 	ldw	fp,0(sp)
81113590:	dec00204 	addi	sp,sp,8
81113594:	f800283a 	ret

81113598 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
81113598:	defffd04 	addi	sp,sp,-12
8111359c:	de00012e 	bgeu	sp,et,811135a4 <bLogWriteSDCard+0xc>
811135a0:	003b68fa 	trap	3
811135a4:	df000215 	stw	fp,8(sp)
811135a8:	df000204 	addi	fp,sp,8
811135ac:	e13ffe15 	stw	r4,-8(fp)
811135b0:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
811135b4:	00800044 	movi	r2,1
}
811135b8:	e037883a 	mov	sp,fp
811135bc:	df000017 	ldw	fp,0(sp)
811135c0:	dec00104 	addi	sp,sp,4
811135c4:	f800283a 	ret

811135c8 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
811135c8:	deffe004 	addi	sp,sp,-128
811135cc:	de00012e 	bgeu	sp,et,811135d4 <vLogWriteNUC+0xc>
811135d0:	003b68fa 	trap	3
811135d4:	dfc01f15 	stw	ra,124(sp)
811135d8:	df001e15 	stw	fp,120(sp)
811135dc:	df001e04 	addi	fp,sp,120
811135e0:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
811135e4:	e03fe215 	stw	zero,-120(fp)
811135e8:	e0bfe304 	addi	r2,fp,-116
811135ec:	00c01b84 	movi	r3,110
811135f0:	180d883a 	mov	r6,r3
811135f4:	000b883a 	mov	r5,zero
811135f8:	1009883a 	mov	r4,r2
811135fc:	11168840 	call	81116884 <memset>
	memset(cTemp,0,114);
81113600:	01801c84 	movi	r6,114
81113604:	000b883a 	mov	r5,zero
81113608:	e13fe204 	addi	r4,fp,-120
8111360c:	11168840 	call	81116884 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
81113610:	e13fff17 	ldw	r4,-4(fp)
81113614:	11172280 	call	81117228 <strlen>
81113618:	10801c68 	cmpgeui	r2,r2,113
8111361c:	1000031e 	bne	r2,zero,8111362c <vLogWriteNUC+0x64>
81113620:	e13fff17 	ldw	r4,-4(fp)
81113624:	11172280 	call	81117228 <strlen>
81113628:	00000106 	br	81113630 <vLogWriteNUC+0x68>
8111362c:	00801c44 	movi	r2,113
81113630:	100d883a 	mov	r6,r2
81113634:	e17fff17 	ldw	r5,-4(fp)
81113638:	e13fe204 	addi	r4,fp,-120
8111363c:	11167340 	call	81116734 <memcpy>
	vSendLog ( cDataIn );
81113640:	e13fff17 	ldw	r4,-4(fp)
81113644:	110fb800 	call	8110fb80 <vSendLog>
}
81113648:	0001883a 	nop
8111364c:	e037883a 	mov	sp,fp
81113650:	dfc00117 	ldw	ra,4(sp)
81113654:	df000017 	ldw	fp,0(sp)
81113658:	dec00204 	addi	sp,sp,8
8111365c:	f800283a 	ret

81113660 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
81113660:	defffd04 	addi	sp,sp,-12
81113664:	de00012e 	bgeu	sp,et,8111366c <vSimucamStructureInit+0xc>
81113668:	003b68fa 	trap	3
8111366c:	dfc00215 	stw	ra,8(sp)
81113670:	df000115 	stw	fp,4(sp)
81113674:	df000104 	addi	fp,sp,4
81113678:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111367c:	e0bfff17 	ldw	r2,-4(fp)
81113680:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebConfig;
81113684:	e0bfff17 	ldw	r2,-4(fp)
81113688:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111368c:	e13fff17 	ldw	r4,-4(fp)
81113690:	11137040 	call	81113704 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
81113694:	e13fff17 	ldw	r4,-4(fp)
81113698:	11137a80 	call	811137a8 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111369c:	e13fff17 	ldw	r4,-4(fp)
811136a0:	11138500 	call	81113850 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
811136a4:	e13fff17 	ldw	r4,-4(fp)
811136a8:	11138f00 	call	811138f0 <vLoadDefaultAutoResetSync>


    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
811136ac:	e0bfff17 	ldw	r2,-4(fp)
811136b0:	10800017 	ldw	r2,0(r2)
811136b4:	10000b1e 	bne	r2,zero,811136e4 <vSimucamStructureInit+0x84>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
811136b8:	e0bfff17 	ldw	r2,-4(fp)
811136bc:	10801e04 	addi	r2,r2,120
811136c0:	1009883a 	mov	r4,r2
811136c4:	11133440 	call	81113344 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
811136c8:	e0bfff17 	ldw	r2,-4(fp)
811136cc:	10c00704 	addi	r3,r2,28
811136d0:	e0bfff17 	ldw	r2,-4(fp)
811136d4:	10801e04 	addi	r2,r2,120
811136d8:	100b883a 	mov	r5,r2
811136dc:	1809883a 	mov	r4,r3
811136e0:	1110f4c0 	call	81110f4c <vDataControllerInit>
        /* todo: Not in use yet */
    }


    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
811136e4:	e0bfff17 	ldw	r2,-4(fp)
811136e8:	10000205 	stb	zero,8(r2)

    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
811136ec:	0001883a 	nop
811136f0:	e037883a 	mov	sp,fp
811136f4:	dfc00117 	ldw	ra,4(sp)
811136f8:	df000017 	ldw	fp,0(sp)
811136fc:	dec00204 	addi	sp,sp,8
81113700:	f800283a 	ret

81113704 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
81113704:	defffe04 	addi	sp,sp,-8
81113708:	de00012e 	bgeu	sp,et,81113710 <vLoadDefaultEPValue+0xc>
8111370c:	003b68fa 	trap	3
81113710:	df000115 	stw	fp,4(sp)
81113714:	df000104 	addi	fp,sp,4
81113718:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111371c:	e0bfff17 	ldw	r2,-4(fp)
81113720:	00d07234 	movhi	r3,16840
81113724:	10c00315 	stw	r3,12(r2)
}
81113728:	0001883a 	nop
8111372c:	e037883a 	mov	sp,fp
81113730:	df000017 	ldw	fp,0(sp)
81113734:	dec00104 	addi	sp,sp,4
81113738:	f800283a 	ret

8111373c <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111373c:	defffd04 	addi	sp,sp,-12
81113740:	de00012e 	bgeu	sp,et,81113748 <vChangeEPValue+0xc>
81113744:	003b68fa 	trap	3
81113748:	df000215 	stw	fp,8(sp)
8111374c:	df000204 	addi	fp,sp,8
81113750:	e13ffe15 	stw	r4,-8(fp)
81113754:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
81113758:	e0bffe17 	ldw	r2,-8(fp)
8111375c:	e0ffff17 	ldw	r3,-4(fp)
81113760:	10c00315 	stw	r3,12(r2)
}
81113764:	0001883a 	nop
81113768:	e037883a 	mov	sp,fp
8111376c:	df000017 	ldw	fp,0(sp)
81113770:	dec00104 	addi	sp,sp,4
81113774:	f800283a 	ret

81113778 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81113778:	defffd04 	addi	sp,sp,-12
8111377c:	de00012e 	bgeu	sp,et,81113784 <vChangeDefaultEPValue+0xc>
81113780:	003b68fa 	trap	3
81113784:	df000215 	stw	fp,8(sp)
81113788:	df000204 	addi	fp,sp,8
8111378c:	e13ffe15 	stw	r4,-8(fp)
81113790:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
81113794:	0001883a 	nop
81113798:	e037883a 	mov	sp,fp
8111379c:	df000017 	ldw	fp,0(sp)
811137a0:	dec00104 	addi	sp,sp,4
811137a4:	f800283a 	ret

811137a8 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
811137a8:	defffe04 	addi	sp,sp,-8
811137ac:	de00012e 	bgeu	sp,et,811137b4 <vLoadDefaultRTValue+0xc>
811137b0:	003b68fa 	trap	3
811137b4:	df000115 	stw	fp,4(sp)
811137b8:	df000104 	addi	fp,sp,4
811137bc:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
811137c0:	e0ffff17 	ldw	r3,-4(fp)
811137c4:	00901eb4 	movhi	r2,16506
811137c8:	10a66684 	addi	r2,r2,-26214
811137cc:	18800415 	stw	r2,16(r3)
}
811137d0:	0001883a 	nop
811137d4:	e037883a 	mov	sp,fp
811137d8:	df000017 	ldw	fp,0(sp)
811137dc:	dec00104 	addi	sp,sp,4
811137e0:	f800283a 	ret

811137e4 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
811137e4:	defffd04 	addi	sp,sp,-12
811137e8:	de00012e 	bgeu	sp,et,811137f0 <vChangeRTValue+0xc>
811137ec:	003b68fa 	trap	3
811137f0:	df000215 	stw	fp,8(sp)
811137f4:	df000204 	addi	fp,sp,8
811137f8:	e13ffe15 	stw	r4,-8(fp)
811137fc:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
81113800:	e0bffe17 	ldw	r2,-8(fp)
81113804:	e0ffff17 	ldw	r3,-4(fp)
81113808:	10c00415 	stw	r3,16(r2)
}
8111380c:	0001883a 	nop
81113810:	e037883a 	mov	sp,fp
81113814:	df000017 	ldw	fp,0(sp)
81113818:	dec00104 	addi	sp,sp,4
8111381c:	f800283a 	ret

81113820 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81113820:	defffd04 	addi	sp,sp,-12
81113824:	de00012e 	bgeu	sp,et,8111382c <vChangeDefaultRTValue+0xc>
81113828:	003b68fa 	trap	3
8111382c:	df000215 	stw	fp,8(sp)
81113830:	df000204 	addi	fp,sp,8
81113834:	e13ffe15 	stw	r4,-8(fp)
81113838:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111383c:	0001883a 	nop
81113840:	e037883a 	mov	sp,fp
81113844:	df000017 	ldw	fp,0(sp)
81113848:	dec00104 	addi	sp,sp,4
8111384c:	f800283a 	ret

81113850 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
81113850:	defffe04 	addi	sp,sp,-8
81113854:	de00012e 	bgeu	sp,et,8111385c <vLoadDefaultSyncSource+0xc>
81113858:	003b68fa 	trap	3
8111385c:	df000115 	stw	fp,4(sp)
81113860:	df000104 	addi	fp,sp,4
81113864:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
81113868:	e0bfff17 	ldw	r2,-4(fp)
8111386c:	10000515 	stw	zero,20(r2)
}
81113870:	0001883a 	nop
81113874:	e037883a 	mov	sp,fp
81113878:	df000017 	ldw	fp,0(sp)
8111387c:	dec00104 	addi	sp,sp,4
81113880:	f800283a 	ret

81113884 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
81113884:	defffd04 	addi	sp,sp,-12
81113888:	de00012e 	bgeu	sp,et,81113890 <vChangeSyncSource+0xc>
8111388c:	003b68fa 	trap	3
81113890:	df000215 	stw	fp,8(sp)
81113894:	df000204 	addi	fp,sp,8
81113898:	e13ffe15 	stw	r4,-8(fp)
8111389c:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
811138a0:	e0bffe17 	ldw	r2,-8(fp)
811138a4:	e0ffff17 	ldw	r3,-4(fp)
811138a8:	10c00515 	stw	r3,20(r2)
}
811138ac:	0001883a 	nop
811138b0:	e037883a 	mov	sp,fp
811138b4:	df000017 	ldw	fp,0(sp)
811138b8:	dec00104 	addi	sp,sp,4
811138bc:	f800283a 	ret

811138c0 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
811138c0:	defffd04 	addi	sp,sp,-12
811138c4:	de00012e 	bgeu	sp,et,811138cc <vChangeDefaultSyncSource+0xc>
811138c8:	003b68fa 	trap	3
811138cc:	df000215 	stw	fp,8(sp)
811138d0:	df000204 	addi	fp,sp,8
811138d4:	e13ffe15 	stw	r4,-8(fp)
811138d8:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
811138dc:	0001883a 	nop
811138e0:	e037883a 	mov	sp,fp
811138e4:	df000017 	ldw	fp,0(sp)
811138e8:	dec00104 	addi	sp,sp,4
811138ec:	f800283a 	ret

811138f0 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
811138f0:	defffe04 	addi	sp,sp,-8
811138f4:	de00012e 	bgeu	sp,et,811138fc <vLoadDefaultAutoResetSync+0xc>
811138f8:	003b68fa 	trap	3
811138fc:	df000115 	stw	fp,4(sp)
81113900:	df000104 	addi	fp,sp,4
81113904:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoRestSyncMode = TRUE;
81113908:	e0bfff17 	ldw	r2,-4(fp)
8111390c:	00c00044 	movi	r3,1
81113910:	10c00615 	stw	r3,24(r2)
}
81113914:	0001883a 	nop
81113918:	e037883a 	mov	sp,fp
8111391c:	df000017 	ldw	fp,0(sp)
81113920:	dec00104 	addi	sp,sp,4
81113924:	f800283a 	ret

81113928 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81113928:	defffd04 	addi	sp,sp,-12
8111392c:	de00012e 	bgeu	sp,et,81113934 <vChangeAutoResetSync+0xc>
81113930:	003b68fa 	trap	3
81113934:	df000215 	stw	fp,8(sp)
81113938:	df000204 	addi	fp,sp,8
8111393c:	e13ffe15 	stw	r4,-8(fp)
81113940:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoRestSyncMode = bAutoReset;
81113944:	e0bffe17 	ldw	r2,-8(fp)
81113948:	e0ffff17 	ldw	r3,-4(fp)
8111394c:	10c00615 	stw	r3,24(r2)
}
81113950:	0001883a 	nop
81113954:	e037883a 	mov	sp,fp
81113958:	df000017 	ldw	fp,0(sp)
8111395c:	dec00104 	addi	sp,sp,4
81113960:	f800283a 	ret

81113964 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81113964:	defffd04 	addi	sp,sp,-12
81113968:	de00012e 	bgeu	sp,et,81113970 <vChangeDefaultAutoResetSync+0xc>
8111396c:	003b68fa 	trap	3
81113970:	df000215 	stw	fp,8(sp)
81113974:	df000204 	addi	fp,sp,8
81113978:	e13ffe15 	stw	r4,-8(fp)
8111397c:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
81113980:	0001883a 	nop
81113984:	e037883a 	mov	sp,fp
81113988:	df000017 	ldw	fp,0(sp)
8111398c:	dec00104 	addi	sp,sp,4
81113990:	f800283a 	ret

81113994 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
81113994:	defffc04 	addi	sp,sp,-16
81113998:	de00012e 	bgeu	sp,et,811139a0 <vSyncReset+0xc>
8111399c:	003b68fa 	trap	3
811139a0:	dfc00315 	stw	ra,12(sp)
811139a4:	df000215 	stw	fp,8(sp)
811139a8:	df000204 	addi	fp,sp,8
811139ac:	e13ffe15 	stw	r4,-8(fp)
811139b0:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
811139b4:	e0bffe17 	ldw	r2,-8(fp)
811139b8:	10801e04 	addi	r2,r2,120
811139bc:	1009883a 	mov	r4,r2
811139c0:	11134440 	call	81113444 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
811139c4:	0001883a 	nop
811139c8:	e037883a 	mov	sp,fp
811139cc:	dfc00117 	ldw	ra,4(sp)
811139d0:	df000017 	ldw	fp,0(sp)
811139d4:	dec00204 	addi	sp,sp,8
811139d8:	f800283a 	ret

811139dc <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
811139dc:	defffe04 	addi	sp,sp,-8
811139e0:	de00012e 	bgeu	sp,et,811139e8 <bSDcardIsPresent+0xc>
811139e4:	003b68fa 	trap	3
811139e8:	dfc00115 	stw	ra,4(sp)
811139ec:	df000015 	stw	fp,0(sp)
811139f0:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
811139f4:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
}
811139f8:	e037883a 	mov	sp,fp
811139fc:	dfc00117 	ldw	ra,4(sp)
81113a00:	df000017 	ldw	fp,0(sp)
81113a04:	dec00204 	addi	sp,sp,8
81113a08:	f800283a 	ret

81113a0c <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
81113a0c:	defffe04 	addi	sp,sp,-8
81113a10:	de00012e 	bgeu	sp,et,81113a18 <bSDcardFAT16Check+0xc>
81113a14:	003b68fa 	trap	3
81113a18:	dfc00115 	stw	ra,4(sp)
81113a1c:	df000015 	stw	fp,0(sp)
81113a20:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
81113a24:	1139ab80 	call	81139ab8 <alt_up_sd_card_is_FAT16>
}
81113a28:	e037883a 	mov	sp,fp
81113a2c:	dfc00117 	ldw	ra,4(sp)
81113a30:	df000017 	ldw	fp,0(sp)
81113a34:	dec00204 	addi	sp,sp,8
81113a38:	f800283a 	ret

81113a3c <bInitializeSDCard>:

bool bInitializeSDCard( void ){
81113a3c:	defffd04 	addi	sp,sp,-12
81113a40:	de00012e 	bgeu	sp,et,81113a48 <bInitializeSDCard+0xc>
81113a44:	003b68fa 	trap	3
81113a48:	dfc00215 	stw	ra,8(sp)
81113a4c:	df000115 	stw	fp,4(sp)
81113a50:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
81113a54:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
81113a58:	d0206715 	stw	zero,-32356(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
81113a5c:	01204534 	movhi	r4,33044
81113a60:	210fed04 	addi	r4,r4,16308
81113a64:	11399280 	call	81139928 <alt_up_sd_card_open_dev>
81113a68:	d0a06715 	stw	r2,-32356(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
81113a6c:	d0a06717 	ldw	r2,-32356(gp)
81113a70:	10002226 	beq	r2,zero,81113afc <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
81113a74:	11139dc0 	call	811139dc <bSDcardIsPresent>
81113a78:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
81113a7c:	e0bfff17 	ldw	r2,-4(fp)
81113a80:	10001626 	beq	r2,zero,81113adc <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
81113a84:	1113a0c0 	call	81113a0c <bSDcardFAT16Check>
81113a88:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
81113a8c:	e0bfff17 	ldw	r2,-4(fp)
81113a90:	10000a26 	beq	r2,zero,81113abc <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
81113a94:	00800044 	movi	r2,1
81113a98:	d0a06615 	stw	r2,-32360(gp)
				debug(fp, "SD is up.\r\n");
81113a9c:	d0a05417 	ldw	r2,-32432(gp)
81113aa0:	100f883a 	mov	r7,r2
81113aa4:	018002c4 	movi	r6,11
81113aa8:	01400044 	movi	r5,1
81113aac:	01204534 	movhi	r4,33044
81113ab0:	210ff804 	addi	r4,r4,16352
81113ab4:	1115d200 	call	81115d20 <fwrite>
81113ab8:	00001806 	br	81113b1c <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
81113abc:	d0a05417 	ldw	r2,-32432(gp)
81113ac0:	100f883a 	mov	r7,r2
81113ac4:	01800984 	movi	r6,38
81113ac8:	01400044 	movi	r5,1
81113acc:	01204534 	movhi	r4,33044
81113ad0:	210ffb04 	addi	r4,r4,16364
81113ad4:	1115d200 	call	81115d20 <fwrite>
81113ad8:	00001006 	br	81113b1c <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
81113adc:	d0a05417 	ldw	r2,-32432(gp)
81113ae0:	100f883a 	mov	r7,r2
81113ae4:	01800744 	movi	r6,29
81113ae8:	01400044 	movi	r5,1
81113aec:	01204534 	movhi	r4,33044
81113af0:	21100504 	addi	r4,r4,16404
81113af4:	1115d200 	call	81115d20 <fwrite>
81113af8:	00000806 	br	81113b1c <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
81113afc:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
81113b00:	d0a05417 	ldw	r2,-32432(gp)
81113b04:	100f883a 	mov	r7,r2
81113b08:	018008c4 	movi	r6,35
81113b0c:	01400044 	movi	r5,1
81113b10:	01204534 	movhi	r4,33044
81113b14:	21100d04 	addi	r4,r4,16436
81113b18:	1115d200 	call	81115d20 <fwrite>
	}

	return bSucess;
81113b1c:	e0bfff17 	ldw	r2,-4(fp)
}
81113b20:	e037883a 	mov	sp,fp
81113b24:	dfc00117 	ldw	ra,4(sp)
81113b28:	df000017 	ldw	fp,0(sp)
81113b2c:	dec00204 	addi	sp,sp,8
81113b30:	f800283a 	ret

81113b34 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
81113b34:	defffd04 	addi	sp,sp,-12
81113b38:	de00012e 	bgeu	sp,et,81113b40 <siOpenFile+0xc>
81113b3c:	003b68fa 	trap	3
81113b40:	dfc00215 	stw	ra,8(sp)
81113b44:	df000115 	stw	fp,4(sp)
81113b48:	df000104 	addi	fp,sp,4
81113b4c:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
81113b50:	000b883a 	mov	r5,zero
81113b54:	e13fff17 	ldw	r4,-4(fp)
81113b58:	1139fc40 	call	81139fc4 <alt_up_sd_card_fopen>
}
81113b5c:	e037883a 	mov	sp,fp
81113b60:	dfc00117 	ldw	ra,4(sp)
81113b64:	df000017 	ldw	fp,0(sp)
81113b68:	dec00204 	addi	sp,sp,8
81113b6c:	f800283a 	ret

81113b70 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
81113b70:	defffd04 	addi	sp,sp,-12
81113b74:	de00012e 	bgeu	sp,et,81113b7c <siCloseFile+0xc>
81113b78:	003b68fa 	trap	3
81113b7c:	dfc00215 	stw	ra,8(sp)
81113b80:	df000115 	stw	fp,4(sp)
81113b84:	df000104 	addi	fp,sp,4
81113b88:	2005883a 	mov	r2,r4
81113b8c:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
81113b90:	e0bfff0f 	ldh	r2,-4(fp)
81113b94:	1009883a 	mov	r4,r2
81113b98:	113ae100 	call	8113ae10 <alt_up_sd_card_fclose>
}
81113b9c:	e037883a 	mov	sp,fp
81113ba0:	dfc00117 	ldw	ra,4(sp)
81113ba4:	df000017 	ldw	fp,0(sp)
81113ba8:	dec00204 	addi	sp,sp,8
81113bac:	f800283a 	ret

81113bb0 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
81113bb0:	defffd04 	addi	sp,sp,-12
81113bb4:	de00012e 	bgeu	sp,et,81113bbc <cGetNextChar+0xc>
81113bb8:	003b68fa 	trap	3
81113bbc:	dfc00215 	stw	ra,8(sp)
81113bc0:	df000115 	stw	fp,4(sp)
81113bc4:	df000104 	addi	fp,sp,4
81113bc8:	2005883a 	mov	r2,r4
81113bcc:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
81113bd0:	e0bfff0f 	ldh	r2,-4(fp)
81113bd4:	1009883a 	mov	r4,r2
81113bd8:	113a4680 	call	8113a468 <alt_up_sd_card_read>
}
81113bdc:	e037883a 	mov	sp,fp
81113be0:	dfc00117 	ldw	ra,4(sp)
81113be4:	df000017 	ldw	fp,0(sp)
81113be8:	dec00204 	addi	sp,sp,8
81113bec:	f800283a 	ret

81113bf0 <bTestSimucamCriticalHW>:


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void )
{
81113bf0:	deffff04 	addi	sp,sp,-4
81113bf4:	de00012e 	bgeu	sp,et,81113bfc <bTestSimucamCriticalHW+0xc>
81113bf8:	003b68fa 	trap	3
81113bfc:	df000015 	stw	fp,0(sp)
81113c00:	d839883a 	mov	fp,sp
	/*
	 * Verificar com Fran�a quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	return TRUE;
81113c04:	00800044 	movi	r2,1
}
81113c08:	e037883a 	mov	sp,fp
81113c0c:	df000017 	ldw	fp,0(sp)
81113c10:	dec00104 	addi	sp,sp,4
81113c14:	f800283a 	ret

81113c18 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
81113c18:	defffc04 	addi	sp,sp,-16
81113c1c:	de00012e 	bgeu	sp,et,81113c24 <_reg_write+0xc>
81113c20:	003b68fa 	trap	3
81113c24:	df000315 	stw	fp,12(sp)
81113c28:	df000304 	addi	fp,sp,12
81113c2c:	e13ffd15 	stw	r4,-12(fp)
81113c30:	e17ffe15 	stw	r5,-8(fp)
81113c34:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
81113c38:	e0bffe17 	ldw	r2,-8(fp)
81113c3c:	1085883a 	add	r2,r2,r2
81113c40:	1085883a 	add	r2,r2,r2
81113c44:	1007883a 	mov	r3,r2
81113c48:	e0bffd17 	ldw	r2,-12(fp)
81113c4c:	1885883a 	add	r2,r3,r2
81113c50:	1007883a 	mov	r3,r2
81113c54:	e0bfff17 	ldw	r2,-4(fp)
81113c58:	18800035 	stwio	r2,0(r3)
	return 1;
81113c5c:	00800044 	movi	r2,1

}
81113c60:	e037883a 	mov	sp,fp
81113c64:	df000017 	ldw	fp,0(sp)
81113c68:	dec00104 	addi	sp,sp,4
81113c6c:	f800283a 	ret

81113c70 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
81113c70:	defffc04 	addi	sp,sp,-16
81113c74:	de00012e 	bgeu	sp,et,81113c7c <_reg_read+0xc>
81113c78:	003b68fa 	trap	3
81113c7c:	df000315 	stw	fp,12(sp)
81113c80:	df000304 	addi	fp,sp,12
81113c84:	e13ffd15 	stw	r4,-12(fp)
81113c88:	e17ffe15 	stw	r5,-8(fp)
81113c8c:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
81113c90:	e0bffe17 	ldw	r2,-8(fp)
81113c94:	1085883a 	add	r2,r2,r2
81113c98:	1085883a 	add	r2,r2,r2
81113c9c:	1007883a 	mov	r3,r2
81113ca0:	e0bffd17 	ldw	r2,-12(fp)
81113ca4:	1885883a 	add	r2,r3,r2
81113ca8:	10c00037 	ldwio	r3,0(r2)
81113cac:	e0bfff17 	ldw	r2,-4(fp)
81113cb0:	10c00015 	stw	r3,0(r2)
	return 1;
81113cb4:	00800044 	movi	r2,1

}
81113cb8:	e037883a 	mov	sp,fp
81113cbc:	df000017 	ldw	fp,0(sp)
81113cc0:	dec00104 	addi	sp,sp,4
81113cc4:	f800283a 	ret

81113cc8 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
81113cc8:	defffa04 	addi	sp,sp,-24
81113ccc:	de00012e 	bgeu	sp,et,81113cd4 <_print_codec_status+0xc>
81113cd0:	003b68fa 	trap	3
81113cd4:	dfc00515 	stw	ra,20(sp)
81113cd8:	df000415 	stw	fp,16(sp)
81113cdc:	df000404 	addi	fp,sp,16
81113ce0:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
81113ce4:	e0bfff17 	ldw	r2,-4(fp)
81113ce8:	1005d1ba 	srai	r2,r2,6
81113cec:	1080004c 	andi	r2,r2,1
81113cf0:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
81113cf4:	e0bfff17 	ldw	r2,-4(fp)
81113cf8:	1005d17a 	srai	r2,r2,5
81113cfc:	1080004c 	andi	r2,r2,1
81113d00:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
81113d04:	e0bfff17 	ldw	r2,-4(fp)
81113d08:	1005d13a 	srai	r2,r2,4
81113d0c:	1080004c 	andi	r2,r2,1
81113d10:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
81113d14:	00e04534 	movhi	r3,33044
81113d18:	18dbff04 	addi	r3,r3,28668
81113d1c:	00a04534 	movhi	r2,33044
81113d20:	10901604 	addi	r2,r2,16472
81113d24:	1009883a 	mov	r4,r2
81113d28:	008005c4 	movi	r2,23
81113d2c:	100d883a 	mov	r6,r2
81113d30:	200b883a 	mov	r5,r4
81113d34:	1809883a 	mov	r4,r3
81113d38:	11167340 	call	81116734 <memcpy>
	debug(fp, cDebugBuffer);
81113d3c:	d0a05417 	ldw	r2,-32432(gp)
81113d40:	01604534 	movhi	r5,33044
81113d44:	295bff04 	addi	r5,r5,28668
81113d48:	1009883a 	mov	r4,r2
81113d4c:	11156840 	call	81115684 <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
81113d50:	e0bffc17 	ldw	r2,-16(fp)
81113d54:	10800058 	cmpnei	r2,r2,1
81113d58:	1000031e 	bne	r2,zero,81113d68 <_print_codec_status+0xa0>
81113d5c:	00a04534 	movhi	r2,33044
81113d60:	10901c04 	addi	r2,r2,16496
81113d64:	00000206 	br	81113d70 <_print_codec_status+0xa8>
81113d68:	00a04534 	movhi	r2,33044
81113d6c:	10901d04 	addi	r2,r2,16500
81113d70:	100d883a 	mov	r6,r2
81113d74:	01604534 	movhi	r5,33044
81113d78:	29501e04 	addi	r5,r5,16504
81113d7c:	01204534 	movhi	r4,33044
81113d80:	211bff04 	addi	r4,r4,28668
81113d84:	11170140 	call	81117014 <sprintf>
	debug(fp, cDebugBuffer);
81113d88:	d0a05417 	ldw	r2,-32432(gp)
81113d8c:	01604534 	movhi	r5,33044
81113d90:	295bff04 	addi	r5,r5,28668
81113d94:	1009883a 	mov	r4,r2
81113d98:	11156840 	call	81115684 <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
81113d9c:	e0bffd17 	ldw	r2,-12(fp)
81113da0:	10800058 	cmpnei	r2,r2,1
81113da4:	1000031e 	bne	r2,zero,81113db4 <_print_codec_status+0xec>
81113da8:	00a04534 	movhi	r2,33044
81113dac:	10901c04 	addi	r2,r2,16496
81113db0:	00000206 	br	81113dbc <_print_codec_status+0xf4>
81113db4:	00a04534 	movhi	r2,33044
81113db8:	10901d04 	addi	r2,r2,16500
81113dbc:	100d883a 	mov	r6,r2
81113dc0:	01604534 	movhi	r5,33044
81113dc4:	29502404 	addi	r5,r5,16528
81113dc8:	01204534 	movhi	r4,33044
81113dcc:	211bff04 	addi	r4,r4,28668
81113dd0:	11170140 	call	81117014 <sprintf>
	debug(fp, cDebugBuffer);
81113dd4:	d0a05417 	ldw	r2,-32432(gp)
81113dd8:	01604534 	movhi	r5,33044
81113ddc:	295bff04 	addi	r5,r5,28668
81113de0:	1009883a 	mov	r4,r2
81113de4:	11156840 	call	81115684 <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
81113de8:	e0bffe17 	ldw	r2,-8(fp)
81113dec:	10800058 	cmpnei	r2,r2,1
81113df0:	1000031e 	bne	r2,zero,81113e00 <_print_codec_status+0x138>
81113df4:	00a04534 	movhi	r2,33044
81113df8:	10901c04 	addi	r2,r2,16496
81113dfc:	00000206 	br	81113e08 <_print_codec_status+0x140>
81113e00:	00a04534 	movhi	r2,33044
81113e04:	10901d04 	addi	r2,r2,16500
81113e08:	100d883a 	mov	r6,r2
81113e0c:	01604534 	movhi	r5,33044
81113e10:	29502a04 	addi	r5,r5,16552
81113e14:	01204534 	movhi	r4,33044
81113e18:	211bff04 	addi	r4,r4,28668
81113e1c:	11170140 	call	81117014 <sprintf>
	debug(fp, cDebugBuffer);
81113e20:	d0a05417 	ldw	r2,-32432(gp)
81113e24:	01604534 	movhi	r5,33044
81113e28:	295bff04 	addi	r5,r5,28668
81113e2c:	1009883a 	mov	r4,r2
81113e30:	11156840 	call	81115684 <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
81113e34:	00a04534 	movhi	r2,33044
81113e38:	109bff04 	addi	r2,r2,28668
81113e3c:	00c00b44 	movi	r3,45
81113e40:	10c00005 	stb	r3,0(r2)
81113e44:	00c00b44 	movi	r3,45
81113e48:	10c00045 	stb	r3,1(r2)
81113e4c:	00c00b44 	movi	r3,45
81113e50:	10c00085 	stb	r3,2(r2)
81113e54:	00c00b44 	movi	r3,45
81113e58:	10c000c5 	stb	r3,3(r2)
81113e5c:	00c00b44 	movi	r3,45
81113e60:	10c00105 	stb	r3,4(r2)
81113e64:	00c00b44 	movi	r3,45
81113e68:	10c00145 	stb	r3,5(r2)
81113e6c:	00c00b44 	movi	r3,45
81113e70:	10c00185 	stb	r3,6(r2)
81113e74:	00c00b44 	movi	r3,45
81113e78:	10c001c5 	stb	r3,7(r2)
81113e7c:	00c00804 	movi	r3,32
81113e80:	10c00205 	stb	r3,8(r2)
81113e84:	00c00804 	movi	r3,32
81113e88:	10c00245 	stb	r3,9(r2)
81113e8c:	00c00284 	movi	r3,10
81113e90:	10c00285 	stb	r3,10(r2)
81113e94:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
81113e98:	d0a05417 	ldw	r2,-32432(gp)
81113e9c:	01604534 	movhi	r5,33044
81113ea0:	295bff04 	addi	r5,r5,28668
81113ea4:	1009883a 	mov	r4,r2
81113ea8:	11156840 	call	81115684 <fprintf>
#endif
}
81113eac:	0001883a 	nop
81113eb0:	e037883a 	mov	sp,fp
81113eb4:	dfc00117 	ldw	ra,4(sp)
81113eb8:	df000017 	ldw	fp,0(sp)
81113ebc:	dec00204 	addi	sp,sp,8
81113ec0:	f800283a 	ret

81113ec4 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
81113ec4:	defffb04 	addi	sp,sp,-20
81113ec8:	de00012e 	bgeu	sp,et,81113ed0 <_split_codec_status+0xc>
81113ecc:	003b68fa 	trap	3
81113ed0:	df000415 	stw	fp,16(sp)
81113ed4:	df000404 	addi	fp,sp,16
81113ed8:	e13ffc15 	stw	r4,-16(fp)
81113edc:	e17ffd15 	stw	r5,-12(fp)
81113ee0:	e1bffe15 	stw	r6,-8(fp)
81113ee4:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
81113ee8:	e0bffc17 	ldw	r2,-16(fp)
81113eec:	1005d1ba 	srai	r2,r2,6
81113ef0:	10c0004c 	andi	r3,r2,1
81113ef4:	e0bffd17 	ldw	r2,-12(fp)
81113ef8:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
81113efc:	e0bffc17 	ldw	r2,-16(fp)
81113f00:	1005d17a 	srai	r2,r2,5
81113f04:	10c0004c 	andi	r3,r2,1
81113f08:	e0bffe17 	ldw	r2,-8(fp)
81113f0c:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
81113f10:	e0bffc17 	ldw	r2,-16(fp)
81113f14:	1005d13a 	srai	r2,r2,4
81113f18:	10c0004c 	andi	r3,r2,1
81113f1c:	e0bfff17 	ldw	r2,-4(fp)
81113f20:	10c00015 	stw	r3,0(r2)
}
81113f24:	0001883a 	nop
81113f28:	e037883a 	mov	sp,fp
81113f2c:	df000017 	ldw	fp,0(sp)
81113f30:	dec00104 	addi	sp,sp,4
81113f34:	f800283a 	ret

81113f38 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
81113f38:	defffc04 	addi	sp,sp,-16
81113f3c:	de00012e 	bgeu	sp,et,81113f44 <aatoh+0xc>
81113f40:	003b68fa 	trap	3
81113f44:	df000315 	stw	fp,12(sp)
81113f48:	df000304 	addi	fp,sp,12
81113f4c:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
81113f50:	e0bfff17 	ldw	r2,-4(fp)
81113f54:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81113f58:	e0bffd17 	ldw	r2,-12(fp)
81113f5c:	10c00003 	ldbu	r3,0(r2)
81113f60:	e0bffd17 	ldw	r2,-12(fp)
81113f64:	10800003 	ldbu	r2,0(r2)
81113f68:	10803fcc 	andi	r2,r2,255
81113f6c:	10800eb0 	cmpltui	r2,r2,58
81113f70:	1000021e 	bne	r2,zero,81113f7c <aatoh+0x44>
81113f74:	00800dc4 	movi	r2,55
81113f78:	00000106 	br	81113f80 <aatoh+0x48>
81113f7c:	00800c04 	movi	r2,48
81113f80:	1885c83a 	sub	r2,r3,r2
81113f84:	1004913a 	slli	r2,r2,4
81113f88:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
81113f8c:	e0bffd17 	ldw	r2,-12(fp)
81113f90:	10800044 	addi	r2,r2,1
81113f94:	10c00003 	ldbu	r3,0(r2)
81113f98:	e0bffd17 	ldw	r2,-12(fp)
81113f9c:	10800044 	addi	r2,r2,1
81113fa0:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81113fa4:	10803fcc 	andi	r2,r2,255
81113fa8:	10800eb0 	cmpltui	r2,r2,58
81113fac:	1000021e 	bne	r2,zero,81113fb8 <aatoh+0x80>
81113fb0:	00800dc4 	movi	r2,55
81113fb4:	00000106 	br	81113fbc <aatoh+0x84>
81113fb8:	00800c04 	movi	r2,48
81113fbc:	1885c83a 	sub	r2,r3,r2
81113fc0:	2085883a 	add	r2,r4,r2
81113fc4:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
81113fc8:	e0bffe03 	ldbu	r2,-8(fp)
}
81113fcc:	e037883a 	mov	sp,fp
81113fd0:	df000017 	ldw	fp,0(sp)
81113fd4:	dec00104 	addi	sp,sp,4
81113fd8:	f800283a 	ret

81113fdc <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
81113fdc:	defffd04 	addi	sp,sp,-12
81113fe0:	de00012e 	bgeu	sp,et,81113fe8 <Verif_Error+0xc>
81113fe4:	003b68fa 	trap	3
81113fe8:	dfc00215 	stw	ra,8(sp)
81113fec:	df000115 	stw	fp,4(sp)
81113ff0:	df000104 	addi	fp,sp,4
81113ff4:	2005883a 	mov	r2,r4
81113ff8:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
81113ffc:	e0bfff03 	ldbu	r2,-4(fp)
81114000:	1000091e 	bne	r2,zero,81114028 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
81114004:	d0a05417 	ldw	r2,-32432(gp)
81114008:	100f883a 	mov	r7,r2
8111400c:	018001c4 	movi	r6,7
81114010:	01400044 	movi	r5,1
81114014:	01204534 	movhi	r4,33044
81114018:	21103004 	addi	r4,r4,16576
8111401c:	1115d200 	call	81115d20 <fwrite>
#endif
		return 0;
81114020:	0005883a 	mov	r2,zero
81114024:	00000106 	br	8111402c <Verif_Error+0x50>
	} else
		return 1;
81114028:	00800044 	movi	r2,1
}
8111402c:	e037883a 	mov	sp,fp
81114030:	dfc00117 	ldw	ra,4(sp)
81114034:	df000017 	ldw	fp,0(sp)
81114038:	dec00204 	addi	sp,sp,8
8111403c:	f800283a 	ret

81114040 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
81114040:	defffe04 	addi	sp,sp,-8
81114044:	de00012e 	bgeu	sp,et,8111404c <toInt+0xc>
81114048:	003b68fa 	trap	3
8111404c:	df000115 	stw	fp,4(sp)
81114050:	df000104 	addi	fp,sp,4
81114054:	2005883a 	mov	r2,r4
81114058:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8111405c:	e0bfff03 	ldbu	r2,-4(fp)
81114060:	10bff404 	addi	r2,r2,-48
}
81114064:	e037883a 	mov	sp,fp
81114068:	df000017 	ldw	fp,0(sp)
8111406c:	dec00104 	addi	sp,sp,4
81114070:	f800283a 	ret

81114074 <__divsf3>:
81114074:	defff504 	addi	sp,sp,-44
81114078:	200cd5fa 	srli	r6,r4,23
8111407c:	de00012e 	bgeu	sp,et,81114084 <__divsf3+0x10>
81114080:	003b68fa 	trap	3
81114084:	dcc00415 	stw	r19,16(sp)
81114088:	2026d7fa 	srli	r19,r4,31
8111408c:	00c02034 	movhi	r3,128
81114090:	dd800715 	stw	r22,28(sp)
81114094:	dd000515 	stw	r20,20(sp)
81114098:	dc800315 	stw	r18,12(sp)
8111409c:	18ffffc4 	addi	r3,r3,-1
811140a0:	dfc00a15 	stw	ra,40(sp)
811140a4:	df000915 	stw	fp,36(sp)
811140a8:	ddc00815 	stw	r23,32(sp)
811140ac:	dd400615 	stw	r21,24(sp)
811140b0:	dc400215 	stw	r17,8(sp)
811140b4:	dc000115 	stw	r16,4(sp)
811140b8:	35003fcc 	andi	r20,r6,255
811140bc:	1924703a 	and	r18,r3,r4
811140c0:	9d803fcc 	andi	r22,r19,255
811140c4:	a0005226 	beq	r20,zero,81114210 <__divsf3+0x19c>
811140c8:	00803fc4 	movi	r2,255
811140cc:	a0802e26 	beq	r20,r2,81114188 <__divsf3+0x114>
811140d0:	91002034 	orhi	r4,r18,128
811140d4:	202490fa 	slli	r18,r4,3
811140d8:	a53fe044 	addi	r20,r20,-127
811140dc:	0021883a 	mov	r16,zero
811140e0:	002f883a 	mov	r23,zero
811140e4:	280cd5fa 	srli	r6,r5,23
811140e8:	282ad7fa 	srli	r21,r5,31
811140ec:	00c02034 	movhi	r3,128
811140f0:	18ffffc4 	addi	r3,r3,-1
811140f4:	31803fcc 	andi	r6,r6,255
811140f8:	1962703a 	and	r17,r3,r5
811140fc:	af003fcc 	andi	fp,r21,255
81114100:	30004a26 	beq	r6,zero,8111422c <__divsf3+0x1b8>
81114104:	00803fc4 	movi	r2,255
81114108:	30804526 	beq	r6,r2,81114220 <__divsf3+0x1ac>
8111410c:	89402034 	orhi	r5,r17,128
81114110:	282290fa 	slli	r17,r5,3
81114114:	31bfe044 	addi	r6,r6,-127
81114118:	000b883a 	mov	r5,zero
8111411c:	2c20b03a 	or	r16,r5,r16
81114120:	802090ba 	slli	r16,r16,2
81114124:	00a04474 	movhi	r2,33041
81114128:	10905204 	addi	r2,r2,16712
8111412c:	80a1883a 	add	r16,r16,r2
81114130:	81000017 	ldw	r4,0(r16)
81114134:	9d46f03a 	xor	r3,r19,r21
81114138:	180f883a 	mov	r7,r3
8111413c:	18803fcc 	andi	r2,r3,255
81114140:	a18dc83a 	sub	r6,r20,r6
81114144:	2000683a 	jmp	r4
81114148:	8111432c 	andhi	r4,r16,17676
8111414c:	811141b0 	cmpltui	r4,r16,17670
81114150:	81114320 	cmpeqi	r4,r16,17676
81114154:	8111419c 	xori	r4,r16,17670
81114158:	81114320 	cmpeqi	r4,r16,17676
8111415c:	811142f8 	rdprs	r4,r16,17675
81114160:	81114320 	cmpeqi	r4,r16,17676
81114164:	8111419c 	xori	r4,r16,17670
81114168:	811141b0 	cmpltui	r4,r16,17670
8111416c:	811141b0 	cmpltui	r4,r16,17670
81114170:	811142f8 	rdprs	r4,r16,17675
81114174:	8111419c 	xori	r4,r16,17670
81114178:	8111440c 	andi	r4,r16,17680
8111417c:	8111440c 	andi	r4,r16,17680
81114180:	8111440c 	andi	r4,r16,17680
81114184:	811143c0 	call	8811143c <__reset+0x20f143c>
81114188:	9000581e 	bne	r18,zero,811142ec <__divsf3+0x278>
8111418c:	04000204 	movi	r16,8
81114190:	05c00084 	movi	r23,2
81114194:	003fd306 	br	811140e4 <__reset+0xfb0f40e4>
81114198:	0023883a 	mov	r17,zero
8111419c:	e02d883a 	mov	r22,fp
811141a0:	282f883a 	mov	r23,r5
811141a4:	00800084 	movi	r2,2
811141a8:	b8808f1e 	bne	r23,r2,811143e8 <__divsf3+0x374>
811141ac:	b005883a 	mov	r2,r22
811141b0:	11c0004c 	andi	r7,r2,1
811141b4:	013fffc4 	movi	r4,-1
811141b8:	000d883a 	mov	r6,zero
811141bc:	21003fcc 	andi	r4,r4,255
811141c0:	200895fa 	slli	r4,r4,23
811141c4:	38803fcc 	andi	r2,r7,255
811141c8:	00c02034 	movhi	r3,128
811141cc:	100497fa 	slli	r2,r2,31
811141d0:	18ffffc4 	addi	r3,r3,-1
811141d4:	30c6703a 	and	r3,r6,r3
811141d8:	1906b03a 	or	r3,r3,r4
811141dc:	1884b03a 	or	r2,r3,r2
811141e0:	dfc00a17 	ldw	ra,40(sp)
811141e4:	df000917 	ldw	fp,36(sp)
811141e8:	ddc00817 	ldw	r23,32(sp)
811141ec:	dd800717 	ldw	r22,28(sp)
811141f0:	dd400617 	ldw	r21,24(sp)
811141f4:	dd000517 	ldw	r20,20(sp)
811141f8:	dcc00417 	ldw	r19,16(sp)
811141fc:	dc800317 	ldw	r18,12(sp)
81114200:	dc400217 	ldw	r17,8(sp)
81114204:	dc000117 	ldw	r16,4(sp)
81114208:	dec00b04 	addi	sp,sp,44
8111420c:	f800283a 	ret
81114210:	90002b1e 	bne	r18,zero,811142c0 <__divsf3+0x24c>
81114214:	04000104 	movi	r16,4
81114218:	05c00044 	movi	r23,1
8111421c:	003fb106 	br	811140e4 <__reset+0xfb0f40e4>
81114220:	8800251e 	bne	r17,zero,811142b8 <__divsf3+0x244>
81114224:	01400084 	movi	r5,2
81114228:	00000206 	br	81114234 <__divsf3+0x1c0>
8111422c:	88001a1e 	bne	r17,zero,81114298 <__divsf3+0x224>
81114230:	01400044 	movi	r5,1
81114234:	8160b03a 	or	r16,r16,r5
81114238:	802090ba 	slli	r16,r16,2
8111423c:	00e04474 	movhi	r3,33041
81114240:	18d09604 	addi	r3,r3,16984
81114244:	80e1883a 	add	r16,r16,r3
81114248:	80c00017 	ldw	r3,0(r16)
8111424c:	9d44f03a 	xor	r2,r19,r21
81114250:	a18dc83a 	sub	r6,r20,r6
81114254:	1800683a 	jmp	r3
81114258:	811141b0 	cmpltui	r4,r16,17670
8111425c:	811141b0 	cmpltui	r4,r16,17670
81114260:	811143fc 	xorhi	r4,r16,17679
81114264:	81114198 	cmpnei	r4,r16,17670
81114268:	811143fc 	xorhi	r4,r16,17679
8111426c:	811142f8 	rdprs	r4,r16,17675
81114270:	811143fc 	xorhi	r4,r16,17679
81114274:	81114198 	cmpnei	r4,r16,17670
81114278:	811141b0 	cmpltui	r4,r16,17670
8111427c:	811141b0 	cmpltui	r4,r16,17670
81114280:	811142f8 	rdprs	r4,r16,17675
81114284:	81114198 	cmpnei	r4,r16,17670
81114288:	8111440c 	andi	r4,r16,17680
8111428c:	8111440c 	andi	r4,r16,17680
81114290:	8111440c 	andi	r4,r16,17680
81114294:	81114424 	muli	r4,r16,17680
81114298:	8809883a 	mov	r4,r17
8111429c:	11154c40 	call	811154c4 <__clzsi2>
811142a0:	10fffec4 	addi	r3,r2,-5
811142a4:	10801d84 	addi	r2,r2,118
811142a8:	88e2983a 	sll	r17,r17,r3
811142ac:	008dc83a 	sub	r6,zero,r2
811142b0:	000b883a 	mov	r5,zero
811142b4:	003f9906 	br	8111411c <__reset+0xfb0f411c>
811142b8:	014000c4 	movi	r5,3
811142bc:	003f9706 	br	8111411c <__reset+0xfb0f411c>
811142c0:	9009883a 	mov	r4,r18
811142c4:	d9400015 	stw	r5,0(sp)
811142c8:	11154c40 	call	811154c4 <__clzsi2>
811142cc:	10fffec4 	addi	r3,r2,-5
811142d0:	11801d84 	addi	r6,r2,118
811142d4:	90e4983a 	sll	r18,r18,r3
811142d8:	01a9c83a 	sub	r20,zero,r6
811142dc:	0021883a 	mov	r16,zero
811142e0:	002f883a 	mov	r23,zero
811142e4:	d9400017 	ldw	r5,0(sp)
811142e8:	003f7e06 	br	811140e4 <__reset+0xfb0f40e4>
811142ec:	04000304 	movi	r16,12
811142f0:	05c000c4 	movi	r23,3
811142f4:	003f7b06 	br	811140e4 <__reset+0xfb0f40e4>
811142f8:	01802034 	movhi	r6,128
811142fc:	000f883a 	mov	r7,zero
81114300:	31bfffc4 	addi	r6,r6,-1
81114304:	013fffc4 	movi	r4,-1
81114308:	003fac06 	br	811141bc <__reset+0xfb0f41bc>
8111430c:	01400044 	movi	r5,1
81114310:	2909c83a 	sub	r4,r5,r4
81114314:	00c006c4 	movi	r3,27
81114318:	19004b0e 	bge	r3,r4,81114448 <__divsf3+0x3d4>
8111431c:	114e703a 	and	r7,r2,r5
81114320:	0009883a 	mov	r4,zero
81114324:	000d883a 	mov	r6,zero
81114328:	003fa406 	br	811141bc <__reset+0xfb0f41bc>
8111432c:	9006917a 	slli	r3,r18,5
81114330:	8822917a 	slli	r17,r17,5
81114334:	1c40372e 	bgeu	r3,r17,81114414 <__divsf3+0x3a0>
81114338:	31bfffc4 	addi	r6,r6,-1
8111433c:	010006c4 	movi	r4,27
81114340:	000b883a 	mov	r5,zero
81114344:	180f883a 	mov	r7,r3
81114348:	294b883a 	add	r5,r5,r5
8111434c:	18c7883a 	add	r3,r3,r3
81114350:	38000116 	blt	r7,zero,81114358 <__divsf3+0x2e4>
81114354:	1c400236 	bltu	r3,r17,81114360 <__divsf3+0x2ec>
81114358:	1c47c83a 	sub	r3,r3,r17
8111435c:	29400054 	ori	r5,r5,1
81114360:	213fffc4 	addi	r4,r4,-1
81114364:	203ff71e 	bne	r4,zero,81114344 <__reset+0xfb0f4344>
81114368:	1806c03a 	cmpne	r3,r3,zero
8111436c:	1962b03a 	or	r17,r3,r5
81114370:	31001fc4 	addi	r4,r6,127
81114374:	013fe50e 	bge	zero,r4,8111430c <__reset+0xfb0f430c>
81114378:	88c001cc 	andi	r3,r17,7
8111437c:	18000426 	beq	r3,zero,81114390 <__divsf3+0x31c>
81114380:	88c003cc 	andi	r3,r17,15
81114384:	01400104 	movi	r5,4
81114388:	19400126 	beq	r3,r5,81114390 <__divsf3+0x31c>
8111438c:	8963883a 	add	r17,r17,r5
81114390:	88c2002c 	andhi	r3,r17,2048
81114394:	18000426 	beq	r3,zero,811143a8 <__divsf3+0x334>
81114398:	00fe0034 	movhi	r3,63488
8111439c:	18ffffc4 	addi	r3,r3,-1
811143a0:	31002004 	addi	r4,r6,128
811143a4:	88e2703a 	and	r17,r17,r3
811143a8:	00c03f84 	movi	r3,254
811143ac:	193f8016 	blt	r3,r4,811141b0 <__reset+0xfb0f41b0>
811143b0:	880c91ba 	slli	r6,r17,6
811143b4:	11c0004c 	andi	r7,r2,1
811143b8:	300cd27a 	srli	r6,r6,9
811143bc:	003f7f06 	br	811141bc <__reset+0xfb0f41bc>
811143c0:	9080102c 	andhi	r2,r18,64
811143c4:	10000226 	beq	r2,zero,811143d0 <__divsf3+0x35c>
811143c8:	8880102c 	andhi	r2,r17,64
811143cc:	10001826 	beq	r2,zero,81114430 <__divsf3+0x3bc>
811143d0:	00802034 	movhi	r2,128
811143d4:	91801034 	orhi	r6,r18,64
811143d8:	10bfffc4 	addi	r2,r2,-1
811143dc:	980f883a 	mov	r7,r19
811143e0:	308c703a 	and	r6,r6,r2
811143e4:	003fc706 	br	81114304 <__reset+0xfb0f4304>
811143e8:	008000c4 	movi	r2,3
811143ec:	b8802d26 	beq	r23,r2,811144a4 <__divsf3+0x430>
811143f0:	00c00044 	movi	r3,1
811143f4:	b005883a 	mov	r2,r22
811143f8:	b8ffdd1e 	bne	r23,r3,81114370 <__reset+0xfb0f4370>
811143fc:	11c0004c 	andi	r7,r2,1
81114400:	0009883a 	mov	r4,zero
81114404:	000d883a 	mov	r6,zero
81114408:	003f6c06 	br	811141bc <__reset+0xfb0f41bc>
8111440c:	9023883a 	mov	r17,r18
81114410:	003f6406 	br	811141a4 <__reset+0xfb0f41a4>
81114414:	1c47c83a 	sub	r3,r3,r17
81114418:	01000684 	movi	r4,26
8111441c:	01400044 	movi	r5,1
81114420:	003fc806 	br	81114344 <__reset+0xfb0f4344>
81114424:	9080102c 	andhi	r2,r18,64
81114428:	103fe926 	beq	r2,zero,811143d0 <__reset+0xfb0f43d0>
8111442c:	0023883a 	mov	r17,zero
81114430:	00802034 	movhi	r2,128
81114434:	89801034 	orhi	r6,r17,64
81114438:	10bfffc4 	addi	r2,r2,-1
8111443c:	a80f883a 	mov	r7,r21
81114440:	308c703a 	and	r6,r6,r2
81114444:	003faf06 	br	81114304 <__reset+0xfb0f4304>
81114448:	01c00804 	movi	r7,32
8111444c:	390fc83a 	sub	r7,r7,r4
81114450:	89ce983a 	sll	r7,r17,r7
81114454:	890ad83a 	srl	r5,r17,r4
81114458:	380ec03a 	cmpne	r7,r7,zero
8111445c:	29cab03a 	or	r5,r5,r7
81114460:	28c001cc 	andi	r3,r5,7
81114464:	18000426 	beq	r3,zero,81114478 <__divsf3+0x404>
81114468:	28c003cc 	andi	r3,r5,15
8111446c:	01000104 	movi	r4,4
81114470:	19000126 	beq	r3,r4,81114478 <__divsf3+0x404>
81114474:	290b883a 	add	r5,r5,r4
81114478:	28c1002c 	andhi	r3,r5,1024
8111447c:	18000426 	beq	r3,zero,81114490 <__divsf3+0x41c>
81114480:	11c0004c 	andi	r7,r2,1
81114484:	01000044 	movi	r4,1
81114488:	000d883a 	mov	r6,zero
8111448c:	003f4b06 	br	811141bc <__reset+0xfb0f41bc>
81114490:	280a91ba 	slli	r5,r5,6
81114494:	11c0004c 	andi	r7,r2,1
81114498:	0009883a 	mov	r4,zero
8111449c:	280cd27a 	srli	r6,r5,9
811144a0:	003f4606 	br	811141bc <__reset+0xfb0f41bc>
811144a4:	00802034 	movhi	r2,128
811144a8:	89801034 	orhi	r6,r17,64
811144ac:	10bfffc4 	addi	r2,r2,-1
811144b0:	b00f883a 	mov	r7,r22
811144b4:	308c703a 	and	r6,r6,r2
811144b8:	003f9206 	br	81114304 <__reset+0xfb0f4304>

811144bc <__mulsf3>:
811144bc:	defff504 	addi	sp,sp,-44
811144c0:	de00012e 	bgeu	sp,et,811144c8 <__mulsf3+0xc>
811144c4:	003b68fa 	trap	3
811144c8:	dc000115 	stw	r16,4(sp)
811144cc:	2020d5fa 	srli	r16,r4,23
811144d0:	dd400615 	stw	r21,24(sp)
811144d4:	202ad7fa 	srli	r21,r4,31
811144d8:	dc800315 	stw	r18,12(sp)
811144dc:	04802034 	movhi	r18,128
811144e0:	df000915 	stw	fp,36(sp)
811144e4:	dd000515 	stw	r20,20(sp)
811144e8:	94bfffc4 	addi	r18,r18,-1
811144ec:	dfc00a15 	stw	ra,40(sp)
811144f0:	ddc00815 	stw	r23,32(sp)
811144f4:	dd800715 	stw	r22,28(sp)
811144f8:	dcc00415 	stw	r19,16(sp)
811144fc:	dc400215 	stw	r17,8(sp)
81114500:	84003fcc 	andi	r16,r16,255
81114504:	9124703a 	and	r18,r18,r4
81114508:	a829883a 	mov	r20,r21
8111450c:	af003fcc 	andi	fp,r21,255
81114510:	80005426 	beq	r16,zero,81114664 <__mulsf3+0x1a8>
81114514:	00803fc4 	movi	r2,255
81114518:	80802f26 	beq	r16,r2,811145d8 <__mulsf3+0x11c>
8111451c:	91002034 	orhi	r4,r18,128
81114520:	202490fa 	slli	r18,r4,3
81114524:	843fe044 	addi	r16,r16,-127
81114528:	0023883a 	mov	r17,zero
8111452c:	002f883a 	mov	r23,zero
81114530:	2804d5fa 	srli	r2,r5,23
81114534:	282cd7fa 	srli	r22,r5,31
81114538:	01002034 	movhi	r4,128
8111453c:	213fffc4 	addi	r4,r4,-1
81114540:	10803fcc 	andi	r2,r2,255
81114544:	2166703a 	and	r19,r4,r5
81114548:	b1803fcc 	andi	r6,r22,255
8111454c:	10004c26 	beq	r2,zero,81114680 <__mulsf3+0x1c4>
81114550:	00c03fc4 	movi	r3,255
81114554:	10c04726 	beq	r2,r3,81114674 <__mulsf3+0x1b8>
81114558:	99002034 	orhi	r4,r19,128
8111455c:	202690fa 	slli	r19,r4,3
81114560:	10bfe044 	addi	r2,r2,-127
81114564:	0007883a 	mov	r3,zero
81114568:	80a1883a 	add	r16,r16,r2
8111456c:	010003c4 	movi	r4,15
81114570:	1c44b03a 	or	r2,r3,r17
81114574:	b56af03a 	xor	r21,r22,r21
81114578:	81c00044 	addi	r7,r16,1
8111457c:	20806b36 	bltu	r4,r2,8111472c <__mulsf3+0x270>
81114580:	100490ba 	slli	r2,r2,2
81114584:	01204474 	movhi	r4,33041
81114588:	21116604 	addi	r4,r4,17816
8111458c:	1105883a 	add	r2,r2,r4
81114590:	10800017 	ldw	r2,0(r2)
81114594:	1000683a 	jmp	r2
81114598:	8111472c 	andhi	r4,r16,17692
8111459c:	811145ec 	andhi	r4,r16,17687
811145a0:	811145ec 	andhi	r4,r16,17687
811145a4:	811145e8 	cmpgeui	r4,r16,17687
811145a8:	81114710 	cmplti	r4,r16,17692
811145ac:	81114710 	cmplti	r4,r16,17692
811145b0:	811146fc 	xorhi	r4,r16,17691
811145b4:	811145e8 	cmpgeui	r4,r16,17687
811145b8:	81114710 	cmplti	r4,r16,17692
811145bc:	811146fc 	xorhi	r4,r16,17691
811145c0:	81114710 	cmplti	r4,r16,17692
811145c4:	811145e8 	cmpgeui	r4,r16,17687
811145c8:	8111471c 	xori	r4,r16,17692
811145cc:	8111471c 	xori	r4,r16,17692
811145d0:	8111471c 	xori	r4,r16,17692
811145d4:	811147f8 	rdprs	r4,r16,17695
811145d8:	90003b1e 	bne	r18,zero,811146c8 <__mulsf3+0x20c>
811145dc:	04400204 	movi	r17,8
811145e0:	05c00084 	movi	r23,2
811145e4:	003fd206 	br	81114530 <__reset+0xfb0f4530>
811145e8:	302b883a 	mov	r21,r6
811145ec:	00800084 	movi	r2,2
811145f0:	18802626 	beq	r3,r2,8111468c <__mulsf3+0x1d0>
811145f4:	008000c4 	movi	r2,3
811145f8:	1880ab26 	beq	r3,r2,811148a8 <__mulsf3+0x3ec>
811145fc:	00800044 	movi	r2,1
81114600:	1880a21e 	bne	r3,r2,8111488c <__mulsf3+0x3d0>
81114604:	a829883a 	mov	r20,r21
81114608:	0007883a 	mov	r3,zero
8111460c:	0009883a 	mov	r4,zero
81114610:	18803fcc 	andi	r2,r3,255
81114614:	100695fa 	slli	r3,r2,23
81114618:	a0803fcc 	andi	r2,r20,255
8111461c:	100a97fa 	slli	r5,r2,31
81114620:	00802034 	movhi	r2,128
81114624:	10bfffc4 	addi	r2,r2,-1
81114628:	2084703a 	and	r2,r4,r2
8111462c:	10c4b03a 	or	r2,r2,r3
81114630:	1144b03a 	or	r2,r2,r5
81114634:	dfc00a17 	ldw	ra,40(sp)
81114638:	df000917 	ldw	fp,36(sp)
8111463c:	ddc00817 	ldw	r23,32(sp)
81114640:	dd800717 	ldw	r22,28(sp)
81114644:	dd400617 	ldw	r21,24(sp)
81114648:	dd000517 	ldw	r20,20(sp)
8111464c:	dcc00417 	ldw	r19,16(sp)
81114650:	dc800317 	ldw	r18,12(sp)
81114654:	dc400217 	ldw	r17,8(sp)
81114658:	dc000117 	ldw	r16,4(sp)
8111465c:	dec00b04 	addi	sp,sp,44
81114660:	f800283a 	ret
81114664:	90000d1e 	bne	r18,zero,8111469c <__mulsf3+0x1e0>
81114668:	04400104 	movi	r17,4
8111466c:	05c00044 	movi	r23,1
81114670:	003faf06 	br	81114530 <__reset+0xfb0f4530>
81114674:	9806c03a 	cmpne	r3,r19,zero
81114678:	18c00084 	addi	r3,r3,2
8111467c:	003fba06 	br	81114568 <__reset+0xfb0f4568>
81114680:	9800141e 	bne	r19,zero,811146d4 <__mulsf3+0x218>
81114684:	00c00044 	movi	r3,1
81114688:	003fb706 	br	81114568 <__reset+0xfb0f4568>
8111468c:	a829883a 	mov	r20,r21
81114690:	00ffffc4 	movi	r3,-1
81114694:	0009883a 	mov	r4,zero
81114698:	003fdd06 	br	81114610 <__reset+0xfb0f4610>
8111469c:	9009883a 	mov	r4,r18
811146a0:	d9400015 	stw	r5,0(sp)
811146a4:	11154c40 	call	811154c4 <__clzsi2>
811146a8:	10fffec4 	addi	r3,r2,-5
811146ac:	10801d84 	addi	r2,r2,118
811146b0:	90e4983a 	sll	r18,r18,r3
811146b4:	00a1c83a 	sub	r16,zero,r2
811146b8:	0023883a 	mov	r17,zero
811146bc:	002f883a 	mov	r23,zero
811146c0:	d9400017 	ldw	r5,0(sp)
811146c4:	003f9a06 	br	81114530 <__reset+0xfb0f4530>
811146c8:	04400304 	movi	r17,12
811146cc:	05c000c4 	movi	r23,3
811146d0:	003f9706 	br	81114530 <__reset+0xfb0f4530>
811146d4:	9809883a 	mov	r4,r19
811146d8:	d9800015 	stw	r6,0(sp)
811146dc:	11154c40 	call	811154c4 <__clzsi2>
811146e0:	10fffec4 	addi	r3,r2,-5
811146e4:	10801d84 	addi	r2,r2,118
811146e8:	98e6983a 	sll	r19,r19,r3
811146ec:	0085c83a 	sub	r2,zero,r2
811146f0:	0007883a 	mov	r3,zero
811146f4:	d9800017 	ldw	r6,0(sp)
811146f8:	003f9b06 	br	81114568 <__reset+0xfb0f4568>
811146fc:	01002034 	movhi	r4,128
81114700:	0029883a 	mov	r20,zero
81114704:	213fffc4 	addi	r4,r4,-1
81114708:	00ffffc4 	movi	r3,-1
8111470c:	003fc006 	br	81114610 <__reset+0xfb0f4610>
81114710:	9027883a 	mov	r19,r18
81114714:	b807883a 	mov	r3,r23
81114718:	003fb406 	br	811145ec <__reset+0xfb0f45ec>
8111471c:	9027883a 	mov	r19,r18
81114720:	e02b883a 	mov	r21,fp
81114724:	b807883a 	mov	r3,r23
81114728:	003fb006 	br	811145ec <__reset+0xfb0f45ec>
8111472c:	9004d43a 	srli	r2,r18,16
81114730:	9810d43a 	srli	r8,r19,16
81114734:	94bfffcc 	andi	r18,r18,65535
81114738:	993fffcc 	andi	r4,r19,65535
8111473c:	910d383a 	mul	r6,r18,r4
81114740:	20a7383a 	mul	r19,r4,r2
81114744:	9225383a 	mul	r18,r18,r8
81114748:	3006d43a 	srli	r3,r6,16
8111474c:	1211383a 	mul	r8,r2,r8
81114750:	94e5883a 	add	r18,r18,r19
81114754:	1c87883a 	add	r3,r3,r18
81114758:	1cc0022e 	bgeu	r3,r19,81114764 <__mulsf3+0x2a8>
8111475c:	00800074 	movhi	r2,1
81114760:	4091883a 	add	r8,r8,r2
81114764:	1804943a 	slli	r2,r3,16
81114768:	31bfffcc 	andi	r6,r6,65535
8111476c:	1806d43a 	srli	r3,r3,16
81114770:	1185883a 	add	r2,r2,r6
81114774:	102691ba 	slli	r19,r2,6
81114778:	1a07883a 	add	r3,r3,r8
8111477c:	1004d6ba 	srli	r2,r2,26
81114780:	180891ba 	slli	r4,r3,6
81114784:	9826c03a 	cmpne	r19,r19,zero
81114788:	9884b03a 	or	r2,r19,r2
8111478c:	1126b03a 	or	r19,r2,r4
81114790:	9882002c 	andhi	r2,r19,2048
81114794:	10000426 	beq	r2,zero,811147a8 <__mulsf3+0x2ec>
81114798:	9804d07a 	srli	r2,r19,1
8111479c:	9900004c 	andi	r4,r19,1
811147a0:	3821883a 	mov	r16,r7
811147a4:	1126b03a 	or	r19,r2,r4
811147a8:	80c01fc4 	addi	r3,r16,127
811147ac:	00c0210e 	bge	zero,r3,81114834 <__mulsf3+0x378>
811147b0:	988001cc 	andi	r2,r19,7
811147b4:	10000426 	beq	r2,zero,811147c8 <__mulsf3+0x30c>
811147b8:	988003cc 	andi	r2,r19,15
811147bc:	01000104 	movi	r4,4
811147c0:	11000126 	beq	r2,r4,811147c8 <__mulsf3+0x30c>
811147c4:	9927883a 	add	r19,r19,r4
811147c8:	9882002c 	andhi	r2,r19,2048
811147cc:	10000426 	beq	r2,zero,811147e0 <__mulsf3+0x324>
811147d0:	00be0034 	movhi	r2,63488
811147d4:	10bfffc4 	addi	r2,r2,-1
811147d8:	80c02004 	addi	r3,r16,128
811147dc:	98a6703a 	and	r19,r19,r2
811147e0:	00803f84 	movi	r2,254
811147e4:	10ffa916 	blt	r2,r3,8111468c <__reset+0xfb0f468c>
811147e8:	980891ba 	slli	r4,r19,6
811147ec:	a829883a 	mov	r20,r21
811147f0:	2008d27a 	srli	r4,r4,9
811147f4:	003f8606 	br	81114610 <__reset+0xfb0f4610>
811147f8:	9080102c 	andhi	r2,r18,64
811147fc:	10000826 	beq	r2,zero,81114820 <__mulsf3+0x364>
81114800:	9880102c 	andhi	r2,r19,64
81114804:	1000061e 	bne	r2,zero,81114820 <__mulsf3+0x364>
81114808:	00802034 	movhi	r2,128
8111480c:	99001034 	orhi	r4,r19,64
81114810:	10bfffc4 	addi	r2,r2,-1
81114814:	b029883a 	mov	r20,r22
81114818:	2088703a 	and	r4,r4,r2
8111481c:	003fba06 	br	81114708 <__reset+0xfb0f4708>
81114820:	00802034 	movhi	r2,128
81114824:	91001034 	orhi	r4,r18,64
81114828:	10bfffc4 	addi	r2,r2,-1
8111482c:	2088703a 	and	r4,r4,r2
81114830:	003fb506 	br	81114708 <__reset+0xfb0f4708>
81114834:	00800044 	movi	r2,1
81114838:	10c7c83a 	sub	r3,r2,r3
8111483c:	008006c4 	movi	r2,27
81114840:	10ff7016 	blt	r2,r3,81114604 <__reset+0xfb0f4604>
81114844:	00800804 	movi	r2,32
81114848:	10c5c83a 	sub	r2,r2,r3
8111484c:	9884983a 	sll	r2,r19,r2
81114850:	98c6d83a 	srl	r3,r19,r3
81114854:	1004c03a 	cmpne	r2,r2,zero
81114858:	1884b03a 	or	r2,r3,r2
8111485c:	10c001cc 	andi	r3,r2,7
81114860:	18000426 	beq	r3,zero,81114874 <__mulsf3+0x3b8>
81114864:	10c003cc 	andi	r3,r2,15
81114868:	01000104 	movi	r4,4
8111486c:	19000126 	beq	r3,r4,81114874 <__mulsf3+0x3b8>
81114870:	1105883a 	add	r2,r2,r4
81114874:	10c1002c 	andhi	r3,r2,1024
81114878:	18000626 	beq	r3,zero,81114894 <__mulsf3+0x3d8>
8111487c:	a829883a 	mov	r20,r21
81114880:	00c00044 	movi	r3,1
81114884:	0009883a 	mov	r4,zero
81114888:	003f6106 	br	81114610 <__reset+0xfb0f4610>
8111488c:	3821883a 	mov	r16,r7
81114890:	003fc506 	br	811147a8 <__reset+0xfb0f47a8>
81114894:	100491ba 	slli	r2,r2,6
81114898:	a829883a 	mov	r20,r21
8111489c:	0007883a 	mov	r3,zero
811148a0:	1008d27a 	srli	r4,r2,9
811148a4:	003f5a06 	br	81114610 <__reset+0xfb0f4610>
811148a8:	00802034 	movhi	r2,128
811148ac:	99001034 	orhi	r4,r19,64
811148b0:	10bfffc4 	addi	r2,r2,-1
811148b4:	a829883a 	mov	r20,r21
811148b8:	2088703a 	and	r4,r4,r2
811148bc:	003f9206 	br	81114708 <__reset+0xfb0f4708>

811148c0 <__floatsisf>:
811148c0:	defffd04 	addi	sp,sp,-12
811148c4:	de00012e 	bgeu	sp,et,811148cc <__floatsisf+0xc>
811148c8:	003b68fa 	trap	3
811148cc:	dfc00215 	stw	ra,8(sp)
811148d0:	dc400115 	stw	r17,4(sp)
811148d4:	dc000015 	stw	r16,0(sp)
811148d8:	20003526 	beq	r4,zero,811149b0 <__floatsisf+0xf0>
811148dc:	2021883a 	mov	r16,r4
811148e0:	2022d7fa 	srli	r17,r4,31
811148e4:	20003616 	blt	r4,zero,811149c0 <__floatsisf+0x100>
811148e8:	8009883a 	mov	r4,r16
811148ec:	11154c40 	call	811154c4 <__clzsi2>
811148f0:	00c02784 	movi	r3,158
811148f4:	1887c83a 	sub	r3,r3,r2
811148f8:	01002584 	movi	r4,150
811148fc:	20c01416 	blt	r4,r3,81114950 <__floatsisf+0x90>
81114900:	20c9c83a 	sub	r4,r4,r3
81114904:	8120983a 	sll	r16,r16,r4
81114908:	00802034 	movhi	r2,128
8111490c:	10bfffc4 	addi	r2,r2,-1
81114910:	8809883a 	mov	r4,r17
81114914:	80a0703a 	and	r16,r16,r2
81114918:	18803fcc 	andi	r2,r3,255
8111491c:	100695fa 	slli	r3,r2,23
81114920:	20803fcc 	andi	r2,r4,255
81114924:	100897fa 	slli	r4,r2,31
81114928:	00802034 	movhi	r2,128
8111492c:	10bfffc4 	addi	r2,r2,-1
81114930:	8084703a 	and	r2,r16,r2
81114934:	10c4b03a 	or	r2,r2,r3
81114938:	1104b03a 	or	r2,r2,r4
8111493c:	dfc00217 	ldw	ra,8(sp)
81114940:	dc400117 	ldw	r17,4(sp)
81114944:	dc000017 	ldw	r16,0(sp)
81114948:	dec00304 	addi	sp,sp,12
8111494c:	f800283a 	ret
81114950:	01002644 	movi	r4,153
81114954:	20c01c16 	blt	r4,r3,811149c8 <__floatsisf+0x108>
81114958:	20c9c83a 	sub	r4,r4,r3
8111495c:	8120983a 	sll	r16,r16,r4
81114960:	013f0034 	movhi	r4,64512
81114964:	213fffc4 	addi	r4,r4,-1
81114968:	814001cc 	andi	r5,r16,7
8111496c:	8108703a 	and	r4,r16,r4
81114970:	28000426 	beq	r5,zero,81114984 <__floatsisf+0xc4>
81114974:	840003cc 	andi	r16,r16,15
81114978:	01400104 	movi	r5,4
8111497c:	81400126 	beq	r16,r5,81114984 <__floatsisf+0xc4>
81114980:	2149883a 	add	r4,r4,r5
81114984:	2141002c 	andhi	r5,r4,1024
81114988:	28000526 	beq	r5,zero,811149a0 <__floatsisf+0xe0>
8111498c:	00c027c4 	movi	r3,159
81114990:	1887c83a 	sub	r3,r3,r2
81114994:	00bf0034 	movhi	r2,64512
81114998:	10bfffc4 	addi	r2,r2,-1
8111499c:	2088703a 	and	r4,r4,r2
811149a0:	202091ba 	slli	r16,r4,6
811149a4:	8809883a 	mov	r4,r17
811149a8:	8020d27a 	srli	r16,r16,9
811149ac:	003fda06 	br	81114918 <__reset+0xfb0f4918>
811149b0:	0009883a 	mov	r4,zero
811149b4:	0007883a 	mov	r3,zero
811149b8:	0021883a 	mov	r16,zero
811149bc:	003fd606 	br	81114918 <__reset+0xfb0f4918>
811149c0:	0121c83a 	sub	r16,zero,r4
811149c4:	003fc806 	br	811148e8 <__reset+0xfb0f48e8>
811149c8:	01002e44 	movi	r4,185
811149cc:	20c9c83a 	sub	r4,r4,r3
811149d0:	01400144 	movi	r5,5
811149d4:	8108983a 	sll	r4,r16,r4
811149d8:	288bc83a 	sub	r5,r5,r2
811149dc:	8160d83a 	srl	r16,r16,r5
811149e0:	2008c03a 	cmpne	r4,r4,zero
811149e4:	8120b03a 	or	r16,r16,r4
811149e8:	003fdd06 	br	81114960 <__reset+0xfb0f4960>

811149ec <__floatunsisf>:
811149ec:	defffe04 	addi	sp,sp,-8
811149f0:	de00012e 	bgeu	sp,et,811149f8 <__floatunsisf+0xc>
811149f4:	003b68fa 	trap	3
811149f8:	dfc00115 	stw	ra,4(sp)
811149fc:	dc000015 	stw	r16,0(sp)
81114a00:	20002c26 	beq	r4,zero,81114ab4 <__floatunsisf+0xc8>
81114a04:	2021883a 	mov	r16,r4
81114a08:	11154c40 	call	811154c4 <__clzsi2>
81114a0c:	00c02784 	movi	r3,158
81114a10:	1887c83a 	sub	r3,r3,r2
81114a14:	01002584 	movi	r4,150
81114a18:	20c00f16 	blt	r4,r3,81114a58 <__floatunsisf+0x6c>
81114a1c:	20c9c83a 	sub	r4,r4,r3
81114a20:	8108983a 	sll	r4,r16,r4
81114a24:	00802034 	movhi	r2,128
81114a28:	10bfffc4 	addi	r2,r2,-1
81114a2c:	2088703a 	and	r4,r4,r2
81114a30:	18803fcc 	andi	r2,r3,255
81114a34:	100695fa 	slli	r3,r2,23
81114a38:	00802034 	movhi	r2,128
81114a3c:	10bfffc4 	addi	r2,r2,-1
81114a40:	2084703a 	and	r2,r4,r2
81114a44:	10c4b03a 	or	r2,r2,r3
81114a48:	dfc00117 	ldw	ra,4(sp)
81114a4c:	dc000017 	ldw	r16,0(sp)
81114a50:	dec00204 	addi	sp,sp,8
81114a54:	f800283a 	ret
81114a58:	01002644 	movi	r4,153
81114a5c:	20c01816 	blt	r4,r3,81114ac0 <__floatunsisf+0xd4>
81114a60:	20c9c83a 	sub	r4,r4,r3
81114a64:	8108983a 	sll	r4,r16,r4
81114a68:	017f0034 	movhi	r5,64512
81114a6c:	297fffc4 	addi	r5,r5,-1
81114a70:	218001cc 	andi	r6,r4,7
81114a74:	214a703a 	and	r5,r4,r5
81114a78:	30000426 	beq	r6,zero,81114a8c <__floatunsisf+0xa0>
81114a7c:	210003cc 	andi	r4,r4,15
81114a80:	01800104 	movi	r6,4
81114a84:	21800126 	beq	r4,r6,81114a8c <__floatunsisf+0xa0>
81114a88:	298b883a 	add	r5,r5,r6
81114a8c:	2901002c 	andhi	r4,r5,1024
81114a90:	20000526 	beq	r4,zero,81114aa8 <__floatunsisf+0xbc>
81114a94:	00c027c4 	movi	r3,159
81114a98:	1887c83a 	sub	r3,r3,r2
81114a9c:	00bf0034 	movhi	r2,64512
81114aa0:	10bfffc4 	addi	r2,r2,-1
81114aa4:	288a703a 	and	r5,r5,r2
81114aa8:	280891ba 	slli	r4,r5,6
81114aac:	2008d27a 	srli	r4,r4,9
81114ab0:	003fdf06 	br	81114a30 <__reset+0xfb0f4a30>
81114ab4:	0007883a 	mov	r3,zero
81114ab8:	0009883a 	mov	r4,zero
81114abc:	003fdc06 	br	81114a30 <__reset+0xfb0f4a30>
81114ac0:	01402e44 	movi	r5,185
81114ac4:	28cbc83a 	sub	r5,r5,r3
81114ac8:	01000144 	movi	r4,5
81114acc:	2089c83a 	sub	r4,r4,r2
81114ad0:	814a983a 	sll	r5,r16,r5
81114ad4:	8108d83a 	srl	r4,r16,r4
81114ad8:	2820c03a 	cmpne	r16,r5,zero
81114adc:	2408b03a 	or	r4,r4,r16
81114ae0:	003fe106 	br	81114a68 <__reset+0xfb0f4a68>

81114ae4 <__muldf3>:
81114ae4:	defff304 	addi	sp,sp,-52
81114ae8:	2804d53a 	srli	r2,r5,20
81114aec:	de00012e 	bgeu	sp,et,81114af4 <__muldf3+0x10>
81114af0:	003b68fa 	trap	3
81114af4:	dd800915 	stw	r22,36(sp)
81114af8:	282cd7fa 	srli	r22,r5,31
81114afc:	dc000315 	stw	r16,12(sp)
81114b00:	04000434 	movhi	r16,16
81114b04:	dd400815 	stw	r21,32(sp)
81114b08:	dc800515 	stw	r18,20(sp)
81114b0c:	843fffc4 	addi	r16,r16,-1
81114b10:	dfc00c15 	stw	ra,48(sp)
81114b14:	df000b15 	stw	fp,44(sp)
81114b18:	ddc00a15 	stw	r23,40(sp)
81114b1c:	dd000715 	stw	r20,28(sp)
81114b20:	dcc00615 	stw	r19,24(sp)
81114b24:	dc400415 	stw	r17,16(sp)
81114b28:	1481ffcc 	andi	r18,r2,2047
81114b2c:	2c20703a 	and	r16,r5,r16
81114b30:	b02b883a 	mov	r21,r22
81114b34:	b2403fcc 	andi	r9,r22,255
81114b38:	90006026 	beq	r18,zero,81114cbc <__muldf3+0x1d8>
81114b3c:	0081ffc4 	movi	r2,2047
81114b40:	2029883a 	mov	r20,r4
81114b44:	90803626 	beq	r18,r2,81114c20 <__muldf3+0x13c>
81114b48:	80800434 	orhi	r2,r16,16
81114b4c:	100490fa 	slli	r2,r2,3
81114b50:	2020d77a 	srli	r16,r4,29
81114b54:	202890fa 	slli	r20,r4,3
81114b58:	94bf0044 	addi	r18,r18,-1023
81114b5c:	80a0b03a 	or	r16,r16,r2
81114b60:	0027883a 	mov	r19,zero
81114b64:	0039883a 	mov	fp,zero
81114b68:	3804d53a 	srli	r2,r7,20
81114b6c:	382ed7fa 	srli	r23,r7,31
81114b70:	04400434 	movhi	r17,16
81114b74:	8c7fffc4 	addi	r17,r17,-1
81114b78:	1081ffcc 	andi	r2,r2,2047
81114b7c:	3011883a 	mov	r8,r6
81114b80:	3c62703a 	and	r17,r7,r17
81114b84:	ba803fcc 	andi	r10,r23,255
81114b88:	10006d26 	beq	r2,zero,81114d40 <__muldf3+0x25c>
81114b8c:	00c1ffc4 	movi	r3,2047
81114b90:	10c06526 	beq	r2,r3,81114d28 <__muldf3+0x244>
81114b94:	88c00434 	orhi	r3,r17,16
81114b98:	180690fa 	slli	r3,r3,3
81114b9c:	3022d77a 	srli	r17,r6,29
81114ba0:	301090fa 	slli	r8,r6,3
81114ba4:	10bf0044 	addi	r2,r2,-1023
81114ba8:	88e2b03a 	or	r17,r17,r3
81114bac:	000b883a 	mov	r5,zero
81114bb0:	9085883a 	add	r2,r18,r2
81114bb4:	2cc8b03a 	or	r4,r5,r19
81114bb8:	00c003c4 	movi	r3,15
81114bbc:	bdacf03a 	xor	r22,r23,r22
81114bc0:	12c00044 	addi	r11,r2,1
81114bc4:	19009936 	bltu	r3,r4,81114e2c <__muldf3+0x348>
81114bc8:	200890ba 	slli	r4,r4,2
81114bcc:	00e04474 	movhi	r3,33041
81114bd0:	18d2f804 	addi	r3,r3,19424
81114bd4:	20c9883a 	add	r4,r4,r3
81114bd8:	20c00017 	ldw	r3,0(r4)
81114bdc:	1800683a 	jmp	r3
81114be0:	81114e2c 	andhi	r4,r16,17720
81114be4:	81114c40 	call	881114c4 <__reset+0x20f14c4>
81114be8:	81114c40 	call	881114c4 <__reset+0x20f14c4>
81114bec:	81114c3c 	xorhi	r4,r16,17712
81114bf0:	81114e08 	cmpgei	r4,r16,17720
81114bf4:	81114e08 	cmpgei	r4,r16,17720
81114bf8:	81114df0 	cmpltui	r4,r16,17719
81114bfc:	81114c3c 	xorhi	r4,r16,17712
81114c00:	81114e08 	cmpgei	r4,r16,17720
81114c04:	81114df0 	cmpltui	r4,r16,17719
81114c08:	81114e08 	cmpgei	r4,r16,17720
81114c0c:	81114c3c 	xorhi	r4,r16,17712
81114c10:	81114e18 	cmpnei	r4,r16,17720
81114c14:	81114e18 	cmpnei	r4,r16,17720
81114c18:	81114e18 	cmpnei	r4,r16,17720
81114c1c:	81115034 	orhi	r4,r16,17728
81114c20:	2404b03a 	or	r2,r4,r16
81114c24:	10006f1e 	bne	r2,zero,81114de4 <__muldf3+0x300>
81114c28:	04c00204 	movi	r19,8
81114c2c:	0021883a 	mov	r16,zero
81114c30:	0029883a 	mov	r20,zero
81114c34:	07000084 	movi	fp,2
81114c38:	003fcb06 	br	81114b68 <__reset+0xfb0f4b68>
81114c3c:	502d883a 	mov	r22,r10
81114c40:	00800084 	movi	r2,2
81114c44:	28805726 	beq	r5,r2,81114da4 <__muldf3+0x2c0>
81114c48:	008000c4 	movi	r2,3
81114c4c:	28816626 	beq	r5,r2,811151e8 <__muldf3+0x704>
81114c50:	00800044 	movi	r2,1
81114c54:	2881411e 	bne	r5,r2,8111515c <__muldf3+0x678>
81114c58:	b02b883a 	mov	r21,r22
81114c5c:	0005883a 	mov	r2,zero
81114c60:	000b883a 	mov	r5,zero
81114c64:	0029883a 	mov	r20,zero
81114c68:	1004953a 	slli	r2,r2,20
81114c6c:	a8c03fcc 	andi	r3,r21,255
81114c70:	04400434 	movhi	r17,16
81114c74:	8c7fffc4 	addi	r17,r17,-1
81114c78:	180697fa 	slli	r3,r3,31
81114c7c:	2c4a703a 	and	r5,r5,r17
81114c80:	288ab03a 	or	r5,r5,r2
81114c84:	28c6b03a 	or	r3,r5,r3
81114c88:	a005883a 	mov	r2,r20
81114c8c:	dfc00c17 	ldw	ra,48(sp)
81114c90:	df000b17 	ldw	fp,44(sp)
81114c94:	ddc00a17 	ldw	r23,40(sp)
81114c98:	dd800917 	ldw	r22,36(sp)
81114c9c:	dd400817 	ldw	r21,32(sp)
81114ca0:	dd000717 	ldw	r20,28(sp)
81114ca4:	dcc00617 	ldw	r19,24(sp)
81114ca8:	dc800517 	ldw	r18,20(sp)
81114cac:	dc400417 	ldw	r17,16(sp)
81114cb0:	dc000317 	ldw	r16,12(sp)
81114cb4:	dec00d04 	addi	sp,sp,52
81114cb8:	f800283a 	ret
81114cbc:	2404b03a 	or	r2,r4,r16
81114cc0:	2027883a 	mov	r19,r4
81114cc4:	10004226 	beq	r2,zero,81114dd0 <__muldf3+0x2ec>
81114cc8:	8000fc26 	beq	r16,zero,811150bc <__muldf3+0x5d8>
81114ccc:	8009883a 	mov	r4,r16
81114cd0:	d9800215 	stw	r6,8(sp)
81114cd4:	d9c00015 	stw	r7,0(sp)
81114cd8:	da400115 	stw	r9,4(sp)
81114cdc:	11154c40 	call	811154c4 <__clzsi2>
81114ce0:	d9800217 	ldw	r6,8(sp)
81114ce4:	d9c00017 	ldw	r7,0(sp)
81114ce8:	da400117 	ldw	r9,4(sp)
81114cec:	113ffd44 	addi	r4,r2,-11
81114cf0:	00c00704 	movi	r3,28
81114cf4:	1900ed16 	blt	r3,r4,811150ac <__muldf3+0x5c8>
81114cf8:	00c00744 	movi	r3,29
81114cfc:	147ffe04 	addi	r17,r2,-8
81114d00:	1907c83a 	sub	r3,r3,r4
81114d04:	8460983a 	sll	r16,r16,r17
81114d08:	98c6d83a 	srl	r3,r19,r3
81114d0c:	9c68983a 	sll	r20,r19,r17
81114d10:	1c20b03a 	or	r16,r3,r16
81114d14:	1080fcc4 	addi	r2,r2,1011
81114d18:	00a5c83a 	sub	r18,zero,r2
81114d1c:	0027883a 	mov	r19,zero
81114d20:	0039883a 	mov	fp,zero
81114d24:	003f9006 	br	81114b68 <__reset+0xfb0f4b68>
81114d28:	3446b03a 	or	r3,r6,r17
81114d2c:	1800261e 	bne	r3,zero,81114dc8 <__muldf3+0x2e4>
81114d30:	0023883a 	mov	r17,zero
81114d34:	0011883a 	mov	r8,zero
81114d38:	01400084 	movi	r5,2
81114d3c:	003f9c06 	br	81114bb0 <__reset+0xfb0f4bb0>
81114d40:	3446b03a 	or	r3,r6,r17
81114d44:	18001c26 	beq	r3,zero,81114db8 <__muldf3+0x2d4>
81114d48:	8800ce26 	beq	r17,zero,81115084 <__muldf3+0x5a0>
81114d4c:	8809883a 	mov	r4,r17
81114d50:	d9800215 	stw	r6,8(sp)
81114d54:	da400115 	stw	r9,4(sp)
81114d58:	da800015 	stw	r10,0(sp)
81114d5c:	11154c40 	call	811154c4 <__clzsi2>
81114d60:	d9800217 	ldw	r6,8(sp)
81114d64:	da400117 	ldw	r9,4(sp)
81114d68:	da800017 	ldw	r10,0(sp)
81114d6c:	113ffd44 	addi	r4,r2,-11
81114d70:	00c00704 	movi	r3,28
81114d74:	1900bf16 	blt	r3,r4,81115074 <__muldf3+0x590>
81114d78:	00c00744 	movi	r3,29
81114d7c:	123ffe04 	addi	r8,r2,-8
81114d80:	1907c83a 	sub	r3,r3,r4
81114d84:	8a22983a 	sll	r17,r17,r8
81114d88:	30c6d83a 	srl	r3,r6,r3
81114d8c:	3210983a 	sll	r8,r6,r8
81114d90:	1c62b03a 	or	r17,r3,r17
81114d94:	1080fcc4 	addi	r2,r2,1011
81114d98:	0085c83a 	sub	r2,zero,r2
81114d9c:	000b883a 	mov	r5,zero
81114da0:	003f8306 	br	81114bb0 <__reset+0xfb0f4bb0>
81114da4:	b02b883a 	mov	r21,r22
81114da8:	0081ffc4 	movi	r2,2047
81114dac:	000b883a 	mov	r5,zero
81114db0:	0029883a 	mov	r20,zero
81114db4:	003fac06 	br	81114c68 <__reset+0xfb0f4c68>
81114db8:	0023883a 	mov	r17,zero
81114dbc:	0011883a 	mov	r8,zero
81114dc0:	01400044 	movi	r5,1
81114dc4:	003f7a06 	br	81114bb0 <__reset+0xfb0f4bb0>
81114dc8:	014000c4 	movi	r5,3
81114dcc:	003f7806 	br	81114bb0 <__reset+0xfb0f4bb0>
81114dd0:	04c00104 	movi	r19,4
81114dd4:	0021883a 	mov	r16,zero
81114dd8:	0029883a 	mov	r20,zero
81114ddc:	07000044 	movi	fp,1
81114de0:	003f6106 	br	81114b68 <__reset+0xfb0f4b68>
81114de4:	04c00304 	movi	r19,12
81114de8:	070000c4 	movi	fp,3
81114dec:	003f5e06 	br	81114b68 <__reset+0xfb0f4b68>
81114df0:	01400434 	movhi	r5,16
81114df4:	002b883a 	mov	r21,zero
81114df8:	297fffc4 	addi	r5,r5,-1
81114dfc:	053fffc4 	movi	r20,-1
81114e00:	0081ffc4 	movi	r2,2047
81114e04:	003f9806 	br	81114c68 <__reset+0xfb0f4c68>
81114e08:	8023883a 	mov	r17,r16
81114e0c:	a011883a 	mov	r8,r20
81114e10:	e00b883a 	mov	r5,fp
81114e14:	003f8a06 	br	81114c40 <__reset+0xfb0f4c40>
81114e18:	8023883a 	mov	r17,r16
81114e1c:	a011883a 	mov	r8,r20
81114e20:	482d883a 	mov	r22,r9
81114e24:	e00b883a 	mov	r5,fp
81114e28:	003f8506 	br	81114c40 <__reset+0xfb0f4c40>
81114e2c:	a00ad43a 	srli	r5,r20,16
81114e30:	401ad43a 	srli	r13,r8,16
81114e34:	a53fffcc 	andi	r20,r20,65535
81114e38:	423fffcc 	andi	r8,r8,65535
81114e3c:	4519383a 	mul	r12,r8,r20
81114e40:	4147383a 	mul	r3,r8,r5
81114e44:	6d09383a 	mul	r4,r13,r20
81114e48:	600cd43a 	srli	r6,r12,16
81114e4c:	2b5d383a 	mul	r14,r5,r13
81114e50:	20c9883a 	add	r4,r4,r3
81114e54:	310d883a 	add	r6,r6,r4
81114e58:	30c0022e 	bgeu	r6,r3,81114e64 <__muldf3+0x380>
81114e5c:	00c00074 	movhi	r3,1
81114e60:	70dd883a 	add	r14,r14,r3
81114e64:	8826d43a 	srli	r19,r17,16
81114e68:	8bffffcc 	andi	r15,r17,65535
81114e6c:	7d23383a 	mul	r17,r15,r20
81114e70:	7949383a 	mul	r4,r15,r5
81114e74:	9d29383a 	mul	r20,r19,r20
81114e78:	8814d43a 	srli	r10,r17,16
81114e7c:	3012943a 	slli	r9,r6,16
81114e80:	a129883a 	add	r20,r20,r4
81114e84:	633fffcc 	andi	r12,r12,65535
81114e88:	5515883a 	add	r10,r10,r20
81114e8c:	3006d43a 	srli	r3,r6,16
81114e90:	4b13883a 	add	r9,r9,r12
81114e94:	2ccb383a 	mul	r5,r5,r19
81114e98:	5100022e 	bgeu	r10,r4,81114ea4 <__muldf3+0x3c0>
81114e9c:	01000074 	movhi	r4,1
81114ea0:	290b883a 	add	r5,r5,r4
81114ea4:	802ad43a 	srli	r21,r16,16
81114ea8:	843fffcc 	andi	r16,r16,65535
81114eac:	440d383a 	mul	r6,r8,r16
81114eb0:	4565383a 	mul	r18,r8,r21
81114eb4:	8349383a 	mul	r4,r16,r13
81114eb8:	500e943a 	slli	r7,r10,16
81114ebc:	3010d43a 	srli	r8,r6,16
81114ec0:	5028d43a 	srli	r20,r10,16
81114ec4:	2489883a 	add	r4,r4,r18
81114ec8:	8abfffcc 	andi	r10,r17,65535
81114ecc:	3a95883a 	add	r10,r7,r10
81114ed0:	4119883a 	add	r12,r8,r4
81114ed4:	a169883a 	add	r20,r20,r5
81114ed8:	1a87883a 	add	r3,r3,r10
81114edc:	6d5b383a 	mul	r13,r13,r21
81114ee0:	6480022e 	bgeu	r12,r18,81114eec <__muldf3+0x408>
81114ee4:	01000074 	movhi	r4,1
81114ee8:	691b883a 	add	r13,r13,r4
81114eec:	7c25383a 	mul	r18,r15,r16
81114ef0:	7d4b383a 	mul	r5,r15,r21
81114ef4:	84cf383a 	mul	r7,r16,r19
81114ef8:	901ed43a 	srli	r15,r18,16
81114efc:	6008d43a 	srli	r4,r12,16
81114f00:	6010943a 	slli	r8,r12,16
81114f04:	394f883a 	add	r7,r7,r5
81114f08:	333fffcc 	andi	r12,r6,65535
81114f0c:	79df883a 	add	r15,r15,r7
81114f10:	235b883a 	add	r13,r4,r13
81114f14:	9d63383a 	mul	r17,r19,r21
81114f18:	4309883a 	add	r4,r8,r12
81114f1c:	7940022e 	bgeu	r15,r5,81114f28 <__muldf3+0x444>
81114f20:	01400074 	movhi	r5,1
81114f24:	8963883a 	add	r17,r17,r5
81114f28:	780a943a 	slli	r5,r15,16
81114f2c:	91bfffcc 	andi	r6,r18,65535
81114f30:	70c7883a 	add	r3,r14,r3
81114f34:	298d883a 	add	r6,r5,r6
81114f38:	1a8f803a 	cmpltu	r7,r3,r10
81114f3c:	350b883a 	add	r5,r6,r20
81114f40:	20c7883a 	add	r3,r4,r3
81114f44:	3955883a 	add	r10,r7,r5
81114f48:	1909803a 	cmpltu	r4,r3,r4
81114f4c:	6a91883a 	add	r8,r13,r10
81114f50:	780cd43a 	srli	r6,r15,16
81114f54:	2219883a 	add	r12,r4,r8
81114f58:	2d0b803a 	cmpltu	r5,r5,r20
81114f5c:	51cf803a 	cmpltu	r7,r10,r7
81114f60:	29ceb03a 	or	r7,r5,r7
81114f64:	4351803a 	cmpltu	r8,r8,r13
81114f68:	610b803a 	cmpltu	r5,r12,r4
81114f6c:	4148b03a 	or	r4,r8,r5
81114f70:	398f883a 	add	r7,r7,r6
81114f74:	3909883a 	add	r4,r7,r4
81114f78:	1810927a 	slli	r8,r3,9
81114f7c:	2449883a 	add	r4,r4,r17
81114f80:	2008927a 	slli	r4,r4,9
81114f84:	6022d5fa 	srli	r17,r12,23
81114f88:	1806d5fa 	srli	r3,r3,23
81114f8c:	4252b03a 	or	r9,r8,r9
81114f90:	600a927a 	slli	r5,r12,9
81114f94:	4810c03a 	cmpne	r8,r9,zero
81114f98:	2462b03a 	or	r17,r4,r17
81114f9c:	40c6b03a 	or	r3,r8,r3
81114fa0:	8900402c 	andhi	r4,r17,256
81114fa4:	1950b03a 	or	r8,r3,r5
81114fa8:	20000726 	beq	r4,zero,81114fc8 <__muldf3+0x4e4>
81114fac:	4006d07a 	srli	r3,r8,1
81114fb0:	880497fa 	slli	r2,r17,31
81114fb4:	4200004c 	andi	r8,r8,1
81114fb8:	8822d07a 	srli	r17,r17,1
81114fbc:	1a10b03a 	or	r8,r3,r8
81114fc0:	1210b03a 	or	r8,r2,r8
81114fc4:	5805883a 	mov	r2,r11
81114fc8:	1140ffc4 	addi	r5,r2,1023
81114fcc:	0140440e 	bge	zero,r5,811150e0 <__muldf3+0x5fc>
81114fd0:	40c001cc 	andi	r3,r8,7
81114fd4:	18000726 	beq	r3,zero,81114ff4 <__muldf3+0x510>
81114fd8:	40c003cc 	andi	r3,r8,15
81114fdc:	01000104 	movi	r4,4
81114fe0:	19000426 	beq	r3,r4,81114ff4 <__muldf3+0x510>
81114fe4:	4107883a 	add	r3,r8,r4
81114fe8:	1a11803a 	cmpltu	r8,r3,r8
81114fec:	8a23883a 	add	r17,r17,r8
81114ff0:	1811883a 	mov	r8,r3
81114ff4:	88c0402c 	andhi	r3,r17,256
81114ff8:	18000426 	beq	r3,zero,8111500c <__muldf3+0x528>
81114ffc:	11410004 	addi	r5,r2,1024
81115000:	00bfc034 	movhi	r2,65280
81115004:	10bfffc4 	addi	r2,r2,-1
81115008:	88a2703a 	and	r17,r17,r2
8111500c:	0081ff84 	movi	r2,2046
81115010:	117f6416 	blt	r2,r5,81114da4 <__reset+0xfb0f4da4>
81115014:	8828977a 	slli	r20,r17,29
81115018:	4010d0fa 	srli	r8,r8,3
8111501c:	8822927a 	slli	r17,r17,9
81115020:	2881ffcc 	andi	r2,r5,2047
81115024:	a228b03a 	or	r20,r20,r8
81115028:	880ad33a 	srli	r5,r17,12
8111502c:	b02b883a 	mov	r21,r22
81115030:	003f0d06 	br	81114c68 <__reset+0xfb0f4c68>
81115034:	8080022c 	andhi	r2,r16,8
81115038:	10000926 	beq	r2,zero,81115060 <__muldf3+0x57c>
8111503c:	8880022c 	andhi	r2,r17,8
81115040:	1000071e 	bne	r2,zero,81115060 <__muldf3+0x57c>
81115044:	00800434 	movhi	r2,16
81115048:	89400234 	orhi	r5,r17,8
8111504c:	10bfffc4 	addi	r2,r2,-1
81115050:	b82b883a 	mov	r21,r23
81115054:	288a703a 	and	r5,r5,r2
81115058:	4029883a 	mov	r20,r8
8111505c:	003f6806 	br	81114e00 <__reset+0xfb0f4e00>
81115060:	00800434 	movhi	r2,16
81115064:	81400234 	orhi	r5,r16,8
81115068:	10bfffc4 	addi	r2,r2,-1
8111506c:	288a703a 	and	r5,r5,r2
81115070:	003f6306 	br	81114e00 <__reset+0xfb0f4e00>
81115074:	147ff604 	addi	r17,r2,-40
81115078:	3462983a 	sll	r17,r6,r17
8111507c:	0011883a 	mov	r8,zero
81115080:	003f4406 	br	81114d94 <__reset+0xfb0f4d94>
81115084:	3009883a 	mov	r4,r6
81115088:	d9800215 	stw	r6,8(sp)
8111508c:	da400115 	stw	r9,4(sp)
81115090:	da800015 	stw	r10,0(sp)
81115094:	11154c40 	call	811154c4 <__clzsi2>
81115098:	10800804 	addi	r2,r2,32
8111509c:	da800017 	ldw	r10,0(sp)
811150a0:	da400117 	ldw	r9,4(sp)
811150a4:	d9800217 	ldw	r6,8(sp)
811150a8:	003f3006 	br	81114d6c <__reset+0xfb0f4d6c>
811150ac:	143ff604 	addi	r16,r2,-40
811150b0:	9c20983a 	sll	r16,r19,r16
811150b4:	0029883a 	mov	r20,zero
811150b8:	003f1606 	br	81114d14 <__reset+0xfb0f4d14>
811150bc:	d9800215 	stw	r6,8(sp)
811150c0:	d9c00015 	stw	r7,0(sp)
811150c4:	da400115 	stw	r9,4(sp)
811150c8:	11154c40 	call	811154c4 <__clzsi2>
811150cc:	10800804 	addi	r2,r2,32
811150d0:	da400117 	ldw	r9,4(sp)
811150d4:	d9c00017 	ldw	r7,0(sp)
811150d8:	d9800217 	ldw	r6,8(sp)
811150dc:	003f0306 	br	81114cec <__reset+0xfb0f4cec>
811150e0:	00c00044 	movi	r3,1
811150e4:	1947c83a 	sub	r3,r3,r5
811150e8:	00800e04 	movi	r2,56
811150ec:	10feda16 	blt	r2,r3,81114c58 <__reset+0xfb0f4c58>
811150f0:	008007c4 	movi	r2,31
811150f4:	10c01b16 	blt	r2,r3,81115164 <__muldf3+0x680>
811150f8:	00800804 	movi	r2,32
811150fc:	10c5c83a 	sub	r2,r2,r3
81115100:	888a983a 	sll	r5,r17,r2
81115104:	40c8d83a 	srl	r4,r8,r3
81115108:	4084983a 	sll	r2,r8,r2
8111510c:	88e2d83a 	srl	r17,r17,r3
81115110:	2906b03a 	or	r3,r5,r4
81115114:	1004c03a 	cmpne	r2,r2,zero
81115118:	1886b03a 	or	r3,r3,r2
8111511c:	188001cc 	andi	r2,r3,7
81115120:	10000726 	beq	r2,zero,81115140 <__muldf3+0x65c>
81115124:	188003cc 	andi	r2,r3,15
81115128:	01000104 	movi	r4,4
8111512c:	11000426 	beq	r2,r4,81115140 <__muldf3+0x65c>
81115130:	1805883a 	mov	r2,r3
81115134:	10c00104 	addi	r3,r2,4
81115138:	1885803a 	cmpltu	r2,r3,r2
8111513c:	88a3883a 	add	r17,r17,r2
81115140:	8880202c 	andhi	r2,r17,128
81115144:	10001c26 	beq	r2,zero,811151b8 <__muldf3+0x6d4>
81115148:	b02b883a 	mov	r21,r22
8111514c:	00800044 	movi	r2,1
81115150:	000b883a 	mov	r5,zero
81115154:	0029883a 	mov	r20,zero
81115158:	003ec306 	br	81114c68 <__reset+0xfb0f4c68>
8111515c:	5805883a 	mov	r2,r11
81115160:	003f9906 	br	81114fc8 <__reset+0xfb0f4fc8>
81115164:	00bff844 	movi	r2,-31
81115168:	1145c83a 	sub	r2,r2,r5
8111516c:	8888d83a 	srl	r4,r17,r2
81115170:	00800804 	movi	r2,32
81115174:	18801a26 	beq	r3,r2,811151e0 <__muldf3+0x6fc>
81115178:	00801004 	movi	r2,64
8111517c:	10c5c83a 	sub	r2,r2,r3
81115180:	8884983a 	sll	r2,r17,r2
81115184:	1204b03a 	or	r2,r2,r8
81115188:	1004c03a 	cmpne	r2,r2,zero
8111518c:	2084b03a 	or	r2,r4,r2
81115190:	144001cc 	andi	r17,r2,7
81115194:	88000d1e 	bne	r17,zero,811151cc <__muldf3+0x6e8>
81115198:	000b883a 	mov	r5,zero
8111519c:	1028d0fa 	srli	r20,r2,3
811151a0:	b02b883a 	mov	r21,r22
811151a4:	0005883a 	mov	r2,zero
811151a8:	a468b03a 	or	r20,r20,r17
811151ac:	003eae06 	br	81114c68 <__reset+0xfb0f4c68>
811151b0:	1007883a 	mov	r3,r2
811151b4:	0023883a 	mov	r17,zero
811151b8:	880a927a 	slli	r5,r17,9
811151bc:	1805883a 	mov	r2,r3
811151c0:	8822977a 	slli	r17,r17,29
811151c4:	280ad33a 	srli	r5,r5,12
811151c8:	003ff406 	br	8111519c <__reset+0xfb0f519c>
811151cc:	10c003cc 	andi	r3,r2,15
811151d0:	01000104 	movi	r4,4
811151d4:	193ff626 	beq	r3,r4,811151b0 <__reset+0xfb0f51b0>
811151d8:	0023883a 	mov	r17,zero
811151dc:	003fd506 	br	81115134 <__reset+0xfb0f5134>
811151e0:	0005883a 	mov	r2,zero
811151e4:	003fe706 	br	81115184 <__reset+0xfb0f5184>
811151e8:	00800434 	movhi	r2,16
811151ec:	89400234 	orhi	r5,r17,8
811151f0:	10bfffc4 	addi	r2,r2,-1
811151f4:	b02b883a 	mov	r21,r22
811151f8:	288a703a 	and	r5,r5,r2
811151fc:	4029883a 	mov	r20,r8
81115200:	003eff06 	br	81114e00 <__reset+0xfb0f4e00>

81115204 <__extendsfdf2>:
81115204:	200ad5fa 	srli	r5,r4,23
81115208:	defffd04 	addi	sp,sp,-12
8111520c:	de00012e 	bgeu	sp,et,81115214 <__extendsfdf2+0x10>
81115210:	003b68fa 	trap	3
81115214:	29403fcc 	andi	r5,r5,255
81115218:	dc400115 	stw	r17,4(sp)
8111521c:	29800044 	addi	r6,r5,1
81115220:	04402034 	movhi	r17,128
81115224:	dc000015 	stw	r16,0(sp)
81115228:	8c7fffc4 	addi	r17,r17,-1
8111522c:	dfc00215 	stw	ra,8(sp)
81115230:	31803fcc 	andi	r6,r6,255
81115234:	00800044 	movi	r2,1
81115238:	8922703a 	and	r17,r17,r4
8111523c:	2020d7fa 	srli	r16,r4,31
81115240:	1180110e 	bge	r2,r6,81115288 <__extendsfdf2+0x84>
81115244:	880cd0fa 	srli	r6,r17,3
81115248:	8822977a 	slli	r17,r17,29
8111524c:	2940e004 	addi	r5,r5,896
81115250:	2941ffcc 	andi	r5,r5,2047
81115254:	2804953a 	slli	r2,r5,20
81115258:	01400434 	movhi	r5,16
8111525c:	800697fa 	slli	r3,r16,31
81115260:	297fffc4 	addi	r5,r5,-1
81115264:	314a703a 	and	r5,r6,r5
81115268:	288ab03a 	or	r5,r5,r2
8111526c:	28c6b03a 	or	r3,r5,r3
81115270:	8805883a 	mov	r2,r17
81115274:	dfc00217 	ldw	ra,8(sp)
81115278:	dc400117 	ldw	r17,4(sp)
8111527c:	dc000017 	ldw	r16,0(sp)
81115280:	dec00304 	addi	sp,sp,12
81115284:	f800283a 	ret
81115288:	2800111e 	bne	r5,zero,811152d0 <__extendsfdf2+0xcc>
8111528c:	88001c26 	beq	r17,zero,81115300 <__extendsfdf2+0xfc>
81115290:	8809883a 	mov	r4,r17
81115294:	11154c40 	call	811154c4 <__clzsi2>
81115298:	00c00284 	movi	r3,10
8111529c:	18801b16 	blt	r3,r2,8111530c <__extendsfdf2+0x108>
811152a0:	018002c4 	movi	r6,11
811152a4:	308dc83a 	sub	r6,r6,r2
811152a8:	11000544 	addi	r4,r2,21
811152ac:	8986d83a 	srl	r3,r17,r6
811152b0:	8922983a 	sll	r17,r17,r4
811152b4:	0180e244 	movi	r6,905
811152b8:	01400434 	movhi	r5,16
811152bc:	3085c83a 	sub	r2,r6,r2
811152c0:	297fffc4 	addi	r5,r5,-1
811152c4:	194c703a 	and	r6,r3,r5
811152c8:	1141ffcc 	andi	r5,r2,2047
811152cc:	003fe006 	br	81115250 <__reset+0xfb0f5250>
811152d0:	88000826 	beq	r17,zero,811152f4 <__extendsfdf2+0xf0>
811152d4:	880cd0fa 	srli	r6,r17,3
811152d8:	00800434 	movhi	r2,16
811152dc:	10bfffc4 	addi	r2,r2,-1
811152e0:	31800234 	orhi	r6,r6,8
811152e4:	8822977a 	slli	r17,r17,29
811152e8:	308c703a 	and	r6,r6,r2
811152ec:	0141ffc4 	movi	r5,2047
811152f0:	003fd706 	br	81115250 <__reset+0xfb0f5250>
811152f4:	0141ffc4 	movi	r5,2047
811152f8:	000d883a 	mov	r6,zero
811152fc:	003fd406 	br	81115250 <__reset+0xfb0f5250>
81115300:	000b883a 	mov	r5,zero
81115304:	000d883a 	mov	r6,zero
81115308:	003fd106 	br	81115250 <__reset+0xfb0f5250>
8111530c:	11bffd44 	addi	r6,r2,-11
81115310:	8986983a 	sll	r3,r17,r6
81115314:	0023883a 	mov	r17,zero
81115318:	003fe606 	br	811152b4 <__reset+0xfb0f52b4>

8111531c <__truncdfsf2>:
8111531c:	2810d53a 	srli	r8,r5,20
81115320:	01c00434 	movhi	r7,16
81115324:	39ffffc4 	addi	r7,r7,-1
81115328:	29ce703a 	and	r7,r5,r7
8111532c:	4201ffcc 	andi	r8,r8,2047
81115330:	380e90fa 	slli	r7,r7,3
81115334:	200cd77a 	srli	r6,r4,29
81115338:	42400044 	addi	r9,r8,1
8111533c:	4a41ffcc 	andi	r9,r9,2047
81115340:	00c00044 	movi	r3,1
81115344:	280ad7fa 	srli	r5,r5,31
81115348:	31ceb03a 	or	r7,r6,r7
8111534c:	200490fa 	slli	r2,r4,3
81115350:	1a40230e 	bge	r3,r9,811153e0 <__truncdfsf2+0xc4>
81115354:	40ff2004 	addi	r3,r8,-896
81115358:	01803f84 	movi	r6,254
8111535c:	30c01516 	blt	r6,r3,811153b4 <__truncdfsf2+0x98>
81115360:	00c0380e 	bge	zero,r3,81115444 <__truncdfsf2+0x128>
81115364:	200c91ba 	slli	r6,r4,6
81115368:	380e90fa 	slli	r7,r7,3
8111536c:	1004d77a 	srli	r2,r2,29
81115370:	300cc03a 	cmpne	r6,r6,zero
81115374:	31ccb03a 	or	r6,r6,r7
81115378:	308cb03a 	or	r6,r6,r2
8111537c:	308001cc 	andi	r2,r6,7
81115380:	10000426 	beq	r2,zero,81115394 <__truncdfsf2+0x78>
81115384:	308003cc 	andi	r2,r6,15
81115388:	01000104 	movi	r4,4
8111538c:	11000126 	beq	r2,r4,81115394 <__truncdfsf2+0x78>
81115390:	31800104 	addi	r6,r6,4
81115394:	3081002c 	andhi	r2,r6,1024
81115398:	10001626 	beq	r2,zero,811153f4 <__truncdfsf2+0xd8>
8111539c:	18c00044 	addi	r3,r3,1
811153a0:	00803fc4 	movi	r2,255
811153a4:	18800326 	beq	r3,r2,811153b4 <__truncdfsf2+0x98>
811153a8:	300c91ba 	slli	r6,r6,6
811153ac:	300cd27a 	srli	r6,r6,9
811153b0:	00000206 	br	811153bc <__truncdfsf2+0xa0>
811153b4:	00ffffc4 	movi	r3,-1
811153b8:	000d883a 	mov	r6,zero
811153bc:	18c03fcc 	andi	r3,r3,255
811153c0:	180895fa 	slli	r4,r3,23
811153c4:	00c02034 	movhi	r3,128
811153c8:	280a97fa 	slli	r5,r5,31
811153cc:	18ffffc4 	addi	r3,r3,-1
811153d0:	30c6703a 	and	r3,r6,r3
811153d4:	1906b03a 	or	r3,r3,r4
811153d8:	1944b03a 	or	r2,r3,r5
811153dc:	f800283a 	ret
811153e0:	40000b1e 	bne	r8,zero,81115410 <__truncdfsf2+0xf4>
811153e4:	388cb03a 	or	r6,r7,r2
811153e8:	0007883a 	mov	r3,zero
811153ec:	30000426 	beq	r6,zero,81115400 <__truncdfsf2+0xe4>
811153f0:	01800144 	movi	r6,5
811153f4:	00803fc4 	movi	r2,255
811153f8:	300cd0fa 	srli	r6,r6,3
811153fc:	18800a26 	beq	r3,r2,81115428 <__truncdfsf2+0x10c>
81115400:	00802034 	movhi	r2,128
81115404:	10bfffc4 	addi	r2,r2,-1
81115408:	308c703a 	and	r6,r6,r2
8111540c:	003feb06 	br	811153bc <__reset+0xfb0f53bc>
81115410:	3888b03a 	or	r4,r7,r2
81115414:	203fe726 	beq	r4,zero,811153b4 <__reset+0xfb0f53b4>
81115418:	380c90fa 	slli	r6,r7,3
8111541c:	00c03fc4 	movi	r3,255
81115420:	31808034 	orhi	r6,r6,512
81115424:	003fd506 	br	8111537c <__reset+0xfb0f537c>
81115428:	303fe226 	beq	r6,zero,811153b4 <__reset+0xfb0f53b4>
8111542c:	00802034 	movhi	r2,128
81115430:	31801034 	orhi	r6,r6,64
81115434:	10bfffc4 	addi	r2,r2,-1
81115438:	00ffffc4 	movi	r3,-1
8111543c:	308c703a 	and	r6,r6,r2
81115440:	003fde06 	br	811153bc <__reset+0xfb0f53bc>
81115444:	013ffa44 	movi	r4,-23
81115448:	19000e16 	blt	r3,r4,81115484 <__truncdfsf2+0x168>
8111544c:	01000784 	movi	r4,30
81115450:	20c9c83a 	sub	r4,r4,r3
81115454:	018007c4 	movi	r6,31
81115458:	39c02034 	orhi	r7,r7,128
8111545c:	31000b16 	blt	r6,r4,8111548c <__truncdfsf2+0x170>
81115460:	423f2084 	addi	r8,r8,-894
81115464:	120c983a 	sll	r6,r2,r8
81115468:	3a0e983a 	sll	r7,r7,r8
8111546c:	1104d83a 	srl	r2,r2,r4
81115470:	300cc03a 	cmpne	r6,r6,zero
81115474:	31ceb03a 	or	r7,r6,r7
81115478:	388cb03a 	or	r6,r7,r2
8111547c:	0007883a 	mov	r3,zero
81115480:	003fbe06 	br	8111537c <__reset+0xfb0f537c>
81115484:	0007883a 	mov	r3,zero
81115488:	003fd906 	br	811153f0 <__reset+0xfb0f53f0>
8111548c:	01bfff84 	movi	r6,-2
81115490:	30cdc83a 	sub	r6,r6,r3
81115494:	00c00804 	movi	r3,32
81115498:	398cd83a 	srl	r6,r7,r6
8111549c:	20c00726 	beq	r4,r3,811154bc <__truncdfsf2+0x1a0>
811154a0:	423f2884 	addi	r8,r8,-862
811154a4:	3a0e983a 	sll	r7,r7,r8
811154a8:	3884b03a 	or	r2,r7,r2
811154ac:	1004c03a 	cmpne	r2,r2,zero
811154b0:	118cb03a 	or	r6,r2,r6
811154b4:	0007883a 	mov	r3,zero
811154b8:	003fb006 	br	8111537c <__reset+0xfb0f537c>
811154bc:	000f883a 	mov	r7,zero
811154c0:	003ff906 	br	811154a8 <__reset+0xfb0f54a8>

811154c4 <__clzsi2>:
811154c4:	00bfffd4 	movui	r2,65535
811154c8:	11000536 	bltu	r2,r4,811154e0 <__clzsi2+0x1c>
811154cc:	00803fc4 	movi	r2,255
811154d0:	11000f36 	bltu	r2,r4,81115510 <__clzsi2+0x4c>
811154d4:	00800804 	movi	r2,32
811154d8:	0007883a 	mov	r3,zero
811154dc:	00000506 	br	811154f4 <__clzsi2+0x30>
811154e0:	00804034 	movhi	r2,256
811154e4:	10bfffc4 	addi	r2,r2,-1
811154e8:	11000c2e 	bgeu	r2,r4,8111551c <__clzsi2+0x58>
811154ec:	00800204 	movi	r2,8
811154f0:	00c00604 	movi	r3,24
811154f4:	20c8d83a 	srl	r4,r4,r3
811154f8:	00e04534 	movhi	r3,33044
811154fc:	18d03204 	addi	r3,r3,16584
81115500:	1909883a 	add	r4,r3,r4
81115504:	20c00003 	ldbu	r3,0(r4)
81115508:	10c5c83a 	sub	r2,r2,r3
8111550c:	f800283a 	ret
81115510:	00800604 	movi	r2,24
81115514:	00c00204 	movi	r3,8
81115518:	003ff606 	br	811154f4 <__reset+0xfb0f54f4>
8111551c:	00800404 	movi	r2,16
81115520:	1007883a 	mov	r3,r2
81115524:	003ff306 	br	811154f4 <__reset+0xfb0f54f4>

81115528 <atoi>:
81115528:	01800284 	movi	r6,10
8111552c:	000b883a 	mov	r5,zero
81115530:	11175441 	jmpi	81117544 <strtol>

81115534 <_atoi_r>:
81115534:	01c00284 	movi	r7,10
81115538:	000d883a 	mov	r6,zero
8111553c:	11173041 	jmpi	81117304 <_strtol_r>

81115540 <_fopen_r>:
81115540:	defffa04 	addi	sp,sp,-24
81115544:	3005883a 	mov	r2,r6
81115548:	de00012e 	bgeu	sp,et,81115550 <_fopen_r+0x10>
8111554c:	003b68fa 	trap	3
81115550:	d80d883a 	mov	r6,sp
81115554:	dcc00415 	stw	r19,16(sp)
81115558:	2827883a 	mov	r19,r5
8111555c:	100b883a 	mov	r5,r2
81115560:	dc800315 	stw	r18,12(sp)
81115564:	dfc00515 	stw	ra,20(sp)
81115568:	dc400215 	stw	r17,8(sp)
8111556c:	dc000115 	stw	r16,4(sp)
81115570:	2025883a 	mov	r18,r4
81115574:	111f54c0 	call	8111f54c <__sflags>
81115578:	10002726 	beq	r2,zero,81115618 <_fopen_r+0xd8>
8111557c:	9009883a 	mov	r4,r18
81115580:	1023883a 	mov	r17,r2
81115584:	111f3c40 	call	8111f3c4 <__sfp>
81115588:	1021883a 	mov	r16,r2
8111558c:	10002226 	beq	r2,zero,81115618 <_fopen_r+0xd8>
81115590:	d9800017 	ldw	r6,0(sp)
81115594:	01c06d84 	movi	r7,438
81115598:	980b883a 	mov	r5,r19
8111559c:	9009883a 	mov	r4,r18
811155a0:	11169ac0 	call	811169ac <_open_r>
811155a4:	10001916 	blt	r2,zero,8111560c <_fopen_r+0xcc>
811155a8:	8080038d 	sth	r2,14(r16)
811155ac:	00a04474 	movhi	r2,33041
811155b0:	109c2204 	addi	r2,r2,28808
811155b4:	80800815 	stw	r2,32(r16)
811155b8:	00a04474 	movhi	r2,33041
811155bc:	109c3b04 	addi	r2,r2,28908
811155c0:	80800915 	stw	r2,36(r16)
811155c4:	00a04474 	movhi	r2,33041
811155c8:	109c5c04 	addi	r2,r2,29040
811155cc:	80800a15 	stw	r2,40(r16)
811155d0:	00a04474 	movhi	r2,33041
811155d4:	109c7504 	addi	r2,r2,29140
811155d8:	8440030d 	sth	r17,12(r16)
811155dc:	84000715 	stw	r16,28(r16)
811155e0:	80800b15 	stw	r2,44(r16)
811155e4:	8c40400c 	andi	r17,r17,256
811155e8:	88000d1e 	bne	r17,zero,81115620 <_fopen_r+0xe0>
811155ec:	8005883a 	mov	r2,r16
811155f0:	dfc00517 	ldw	ra,20(sp)
811155f4:	dcc00417 	ldw	r19,16(sp)
811155f8:	dc800317 	ldw	r18,12(sp)
811155fc:	dc400217 	ldw	r17,8(sp)
81115600:	dc000117 	ldw	r16,4(sp)
81115604:	dec00604 	addi	sp,sp,24
81115608:	f800283a 	ret
8111560c:	111f50c0 	call	8111f50c <__sfp_lock_acquire>
81115610:	8000030d 	sth	zero,12(r16)
81115614:	111f5100 	call	8111f510 <__sfp_lock_release>
81115618:	0005883a 	mov	r2,zero
8111561c:	003ff406 	br	811155f0 <__reset+0xfb0f55f0>
81115620:	01c00084 	movi	r7,2
81115624:	000d883a 	mov	r6,zero
81115628:	800b883a 	mov	r5,r16
8111562c:	9009883a 	mov	r4,r18
81115630:	11157600 	call	81115760 <_fseek_r>
81115634:	8005883a 	mov	r2,r16
81115638:	003fed06 	br	811155f0 <__reset+0xfb0f55f0>

8111563c <fopen>:
8111563c:	00a04534 	movhi	r2,33044
81115640:	109aed04 	addi	r2,r2,27572
81115644:	280d883a 	mov	r6,r5
81115648:	200b883a 	mov	r5,r4
8111564c:	11000017 	ldw	r4,0(r2)
81115650:	11155401 	jmpi	81115540 <_fopen_r>

81115654 <_fprintf_r>:
81115654:	defffe04 	addi	sp,sp,-8
81115658:	2809883a 	mov	r4,r5
8111565c:	300b883a 	mov	r5,r6
81115660:	de00012e 	bgeu	sp,et,81115668 <_fprintf_r+0x14>
81115664:	003b68fa 	trap	3
81115668:	dfc00015 	stw	ra,0(sp)
8111566c:	d9c00115 	stw	r7,4(sp)
81115670:	d9800104 	addi	r6,sp,4
81115674:	111b9400 	call	8111b940 <__vfprintf_internal>
81115678:	dfc00017 	ldw	ra,0(sp)
8111567c:	dec00204 	addi	sp,sp,8
81115680:	f800283a 	ret

81115684 <fprintf>:
81115684:	defffd04 	addi	sp,sp,-12
81115688:	de00012e 	bgeu	sp,et,81115690 <fprintf+0xc>
8111568c:	003b68fa 	trap	3
81115690:	dfc00015 	stw	ra,0(sp)
81115694:	d9800115 	stw	r6,4(sp)
81115698:	d9c00215 	stw	r7,8(sp)
8111569c:	d9800104 	addi	r6,sp,4
811156a0:	111b9400 	call	8111b940 <__vfprintf_internal>
811156a4:	dfc00017 	ldw	ra,0(sp)
811156a8:	dec00304 	addi	sp,sp,12
811156ac:	f800283a 	ret

811156b0 <_fputc_r>:
811156b0:	defffc04 	addi	sp,sp,-16
811156b4:	de00012e 	bgeu	sp,et,811156bc <_fputc_r+0xc>
811156b8:	003b68fa 	trap	3
811156bc:	dc000215 	stw	r16,8(sp)
811156c0:	dfc00315 	stw	ra,12(sp)
811156c4:	2021883a 	mov	r16,r4
811156c8:	20000726 	beq	r4,zero,811156e8 <_fputc_r+0x38>
811156cc:	20800e17 	ldw	r2,56(r4)
811156d0:	1000051e 	bne	r2,zero,811156e8 <_fputc_r+0x38>
811156d4:	d9400015 	stw	r5,0(sp)
811156d8:	d9800115 	stw	r6,4(sp)
811156dc:	111f4fc0 	call	8111f4fc <__sinit>
811156e0:	d9800117 	ldw	r6,4(sp)
811156e4:	d9400017 	ldw	r5,0(sp)
811156e8:	8009883a 	mov	r4,r16
811156ec:	dfc00317 	ldw	ra,12(sp)
811156f0:	dc000217 	ldw	r16,8(sp)
811156f4:	dec00404 	addi	sp,sp,16
811156f8:	1116a901 	jmpi	81116a90 <_putc_r>

811156fc <fputc>:
811156fc:	00a04534 	movhi	r2,33044
81115700:	defffc04 	addi	sp,sp,-16
81115704:	109aed04 	addi	r2,r2,27572
81115708:	de00012e 	bgeu	sp,et,81115710 <fputc+0x14>
8111570c:	003b68fa 	trap	3
81115710:	dc000115 	stw	r16,4(sp)
81115714:	14000017 	ldw	r16,0(r2)
81115718:	dc400215 	stw	r17,8(sp)
8111571c:	dfc00315 	stw	ra,12(sp)
81115720:	2023883a 	mov	r17,r4
81115724:	80000626 	beq	r16,zero,81115740 <fputc+0x44>
81115728:	80800e17 	ldw	r2,56(r16)
8111572c:	1000041e 	bne	r2,zero,81115740 <fputc+0x44>
81115730:	8009883a 	mov	r4,r16
81115734:	d9400015 	stw	r5,0(sp)
81115738:	111f4fc0 	call	8111f4fc <__sinit>
8111573c:	d9400017 	ldw	r5,0(sp)
81115740:	280d883a 	mov	r6,r5
81115744:	8009883a 	mov	r4,r16
81115748:	880b883a 	mov	r5,r17
8111574c:	dfc00317 	ldw	ra,12(sp)
81115750:	dc400217 	ldw	r17,8(sp)
81115754:	dc000117 	ldw	r16,4(sp)
81115758:	dec00404 	addi	sp,sp,16
8111575c:	1116a901 	jmpi	81116a90 <_putc_r>

81115760 <_fseek_r>:
81115760:	11157801 	jmpi	81115780 <_fseeko_r>

81115764 <fseek>:
81115764:	00a04534 	movhi	r2,33044
81115768:	109aed04 	addi	r2,r2,27572
8111576c:	300f883a 	mov	r7,r6
81115770:	280d883a 	mov	r6,r5
81115774:	200b883a 	mov	r5,r4
81115778:	11000017 	ldw	r4,0(r2)
8111577c:	11157801 	jmpi	81115780 <_fseeko_r>

81115780 <_fseeko_r>:
81115780:	deffe804 	addi	sp,sp,-96
81115784:	de00012e 	bgeu	sp,et,8111578c <_fseeko_r+0xc>
81115788:	003b68fa 	trap	3
8111578c:	dd401415 	stw	r21,80(sp)
81115790:	dc801115 	stw	r18,68(sp)
81115794:	dc401015 	stw	r17,64(sp)
81115798:	dc000f15 	stw	r16,60(sp)
8111579c:	dfc01715 	stw	ra,92(sp)
811157a0:	ddc01615 	stw	r23,88(sp)
811157a4:	dd801515 	stw	r22,84(sp)
811157a8:	dd001315 	stw	r20,76(sp)
811157ac:	dcc01215 	stw	r19,72(sp)
811157b0:	2023883a 	mov	r17,r4
811157b4:	2821883a 	mov	r16,r5
811157b8:	302b883a 	mov	r21,r6
811157bc:	3825883a 	mov	r18,r7
811157c0:	20000226 	beq	r4,zero,811157cc <_fseeko_r+0x4c>
811157c4:	20800e17 	ldw	r2,56(r4)
811157c8:	10005a26 	beq	r2,zero,81115934 <_fseeko_r+0x1b4>
811157cc:	8080030b 	ldhu	r2,12(r16)
811157d0:	00c04204 	movi	r3,264
811157d4:	1080420c 	andi	r2,r2,264
811157d8:	10c05b26 	beq	r2,r3,81115948 <_fseeko_r+0x1c8>
811157dc:	85000a17 	ldw	r20,40(r16)
811157e0:	a000f626 	beq	r20,zero,81115bbc <_fseeko_r+0x43c>
811157e4:	00800044 	movi	r2,1
811157e8:	90803e26 	beq	r18,r2,811158e4 <_fseeko_r+0x164>
811157ec:	00800084 	movi	r2,2
811157f0:	90801026 	beq	r18,r2,81115834 <_fseeko_r+0xb4>
811157f4:	90000f26 	beq	r18,zero,81115834 <_fseeko_r+0xb4>
811157f8:	00800584 	movi	r2,22
811157fc:	88800015 	stw	r2,0(r17)
81115800:	04ffffc4 	movi	r19,-1
81115804:	9805883a 	mov	r2,r19
81115808:	dfc01717 	ldw	ra,92(sp)
8111580c:	ddc01617 	ldw	r23,88(sp)
81115810:	dd801517 	ldw	r22,84(sp)
81115814:	dd401417 	ldw	r21,80(sp)
81115818:	dd001317 	ldw	r20,76(sp)
8111581c:	dcc01217 	ldw	r19,72(sp)
81115820:	dc801117 	ldw	r18,68(sp)
81115824:	dc401017 	ldw	r17,64(sp)
81115828:	dc000f17 	ldw	r16,60(sp)
8111582c:	dec01804 	addi	sp,sp,96
81115830:	f800283a 	ret
81115834:	80800417 	ldw	r2,16(r16)
81115838:	002f883a 	mov	r23,zero
8111583c:	0027883a 	mov	r19,zero
81115840:	1000cb26 	beq	r2,zero,81115b70 <_fseeko_r+0x3f0>
81115844:	8080030b 	ldhu	r2,12(r16)
81115848:	10c2068c 	andi	r3,r2,2074
8111584c:	1800071e 	bne	r3,zero,8111586c <_fseeko_r+0xec>
81115850:	10c1000c 	andi	r3,r2,1024
81115854:	1800451e 	bne	r3,zero,8111596c <_fseeko_r+0x1ec>
81115858:	00e04474 	movhi	r3,33041
8111585c:	18dc5c04 	addi	r3,r3,29040
81115860:	a0c0b726 	beq	r20,r3,81115b40 <_fseeko_r+0x3c0>
81115864:	10820014 	ori	r2,r2,2048
81115868:	8080030d 	sth	r2,12(r16)
8111586c:	800b883a 	mov	r5,r16
81115870:	8809883a 	mov	r4,r17
81115874:	111f1000 	call	8111f100 <_fflush_r>
81115878:	1027883a 	mov	r19,r2
8111587c:	103fe01e 	bne	r2,zero,81115800 <__reset+0xfb0f5800>
81115880:	81400717 	ldw	r5,28(r16)
81115884:	900f883a 	mov	r7,r18
81115888:	a80d883a 	mov	r6,r21
8111588c:	8809883a 	mov	r4,r17
81115890:	a03ee83a 	callr	r20
81115894:	00ffffc4 	movi	r3,-1
81115898:	10ffd926 	beq	r2,r3,81115800 <__reset+0xfb0f5800>
8111589c:	81400c17 	ldw	r5,48(r16)
811158a0:	28000526 	beq	r5,zero,811158b8 <_fseeko_r+0x138>
811158a4:	80801004 	addi	r2,r16,64
811158a8:	28800226 	beq	r5,r2,811158b4 <_fseeko_r+0x134>
811158ac:	8809883a 	mov	r4,r17
811158b0:	111f9940 	call	8111f994 <_free_r>
811158b4:	80000c15 	stw	zero,48(r16)
811158b8:	8080030b 	ldhu	r2,12(r16)
811158bc:	80c00417 	ldw	r3,16(r16)
811158c0:	80000115 	stw	zero,4(r16)
811158c4:	10bdf7cc 	andi	r2,r2,63455
811158c8:	80c00015 	stw	r3,0(r16)
811158cc:	8080030d 	sth	r2,12(r16)
811158d0:	01800204 	movi	r6,8
811158d4:	000b883a 	mov	r5,zero
811158d8:	81001704 	addi	r4,r16,92
811158dc:	11168840 	call	81116884 <memset>
811158e0:	003fc806 	br	81115804 <__reset+0xfb0f5804>
811158e4:	800b883a 	mov	r5,r16
811158e8:	8809883a 	mov	r4,r17
811158ec:	111f1000 	call	8111f100 <_fflush_r>
811158f0:	8080030b 	ldhu	r2,12(r16)
811158f4:	10c4000c 	andi	r3,r2,4096
811158f8:	18008726 	beq	r3,zero,81115b18 <_fseeko_r+0x398>
811158fc:	84c01417 	ldw	r19,80(r16)
81115900:	10c0010c 	andi	r3,r2,4
81115904:	1800431e 	bne	r3,zero,81115a14 <_fseeko_r+0x294>
81115908:	1080020c 	andi	r2,r2,8
8111590c:	10008026 	beq	r2,zero,81115b10 <_fseeko_r+0x390>
81115910:	80c00017 	ldw	r3,0(r16)
81115914:	80800417 	ldw	r2,16(r16)
81115918:	18000226 	beq	r3,zero,81115924 <_fseeko_r+0x1a4>
8111591c:	1887c83a 	sub	r3,r3,r2
81115920:	98e7883a 	add	r19,r19,r3
81115924:	aceb883a 	add	r21,r21,r19
81115928:	05c00044 	movi	r23,1
8111592c:	0025883a 	mov	r18,zero
81115930:	003fc306 	br	81115840 <__reset+0xfb0f5840>
81115934:	111f4fc0 	call	8111f4fc <__sinit>
81115938:	8080030b 	ldhu	r2,12(r16)
8111593c:	00c04204 	movi	r3,264
81115940:	1080420c 	andi	r2,r2,264
81115944:	10ffa51e 	bne	r2,r3,811157dc <__reset+0xfb0f57dc>
81115948:	800b883a 	mov	r5,r16
8111594c:	8809883a 	mov	r4,r17
81115950:	111f1000 	call	8111f100 <_fflush_r>
81115954:	003fa106 	br	811157dc <__reset+0xfb0f57dc>
81115958:	8080030b 	ldhu	r2,12(r16)
8111595c:	00c10004 	movi	r3,1024
81115960:	80c01315 	stw	r3,76(r16)
81115964:	10c4b03a 	or	r2,r2,r3
81115968:	8080030d 	sth	r2,12(r16)
8111596c:	9000311e 	bne	r18,zero,81115a34 <_fseeko_r+0x2b4>
81115970:	a82d883a 	mov	r22,r21
81115974:	b800371e 	bne	r23,zero,81115a54 <_fseeko_r+0x2d4>
81115978:	8080030b 	ldhu	r2,12(r16)
8111597c:	1084000c 	andi	r2,r2,4096
81115980:	10007f26 	beq	r2,zero,81115b80 <_fseeko_r+0x400>
81115984:	80801417 	ldw	r2,80(r16)
81115988:	81800117 	ldw	r6,4(r16)
8111598c:	81400c17 	ldw	r5,48(r16)
81115990:	11a7c83a 	sub	r19,r2,r6
81115994:	28008226 	beq	r5,zero,81115ba0 <_fseeko_r+0x420>
81115998:	81c00f17 	ldw	r7,60(r16)
8111599c:	99e7c83a 	sub	r19,r19,r7
811159a0:	81000e17 	ldw	r4,56(r16)
811159a4:	80800417 	ldw	r2,16(r16)
811159a8:	99a7883a 	add	r19,r19,r6
811159ac:	2087c83a 	sub	r3,r4,r2
811159b0:	98e7c83a 	sub	r19,r19,r3
811159b4:	38c7883a 	add	r3,r7,r3
811159b8:	b4c02b16 	blt	r22,r19,81115a68 <_fseeko_r+0x2e8>
811159bc:	98c9883a 	add	r4,r19,r3
811159c0:	b100292e 	bgeu	r22,r4,81115a68 <_fseeko_r+0x2e8>
811159c4:	b4e7c83a 	sub	r19,r22,r19
811159c8:	14c5883a 	add	r2,r2,r19
811159cc:	1ce7c83a 	sub	r19,r3,r19
811159d0:	80800015 	stw	r2,0(r16)
811159d4:	84c00115 	stw	r19,4(r16)
811159d8:	28000526 	beq	r5,zero,811159f0 <_fseeko_r+0x270>
811159dc:	80801004 	addi	r2,r16,64
811159e0:	28800226 	beq	r5,r2,811159ec <_fseeko_r+0x26c>
811159e4:	8809883a 	mov	r4,r17
811159e8:	111f9940 	call	8111f994 <_free_r>
811159ec:	80000c15 	stw	zero,48(r16)
811159f0:	8080030b 	ldhu	r2,12(r16)
811159f4:	01800204 	movi	r6,8
811159f8:	000b883a 	mov	r5,zero
811159fc:	10bff7cc 	andi	r2,r2,65503
81115a00:	8080030d 	sth	r2,12(r16)
81115a04:	81001704 	addi	r4,r16,92
81115a08:	11168840 	call	81116884 <memset>
81115a0c:	0027883a 	mov	r19,zero
81115a10:	003f7c06 	br	81115804 <__reset+0xfb0f5804>
81115a14:	80c00117 	ldw	r3,4(r16)
81115a18:	80800c17 	ldw	r2,48(r16)
81115a1c:	98e7c83a 	sub	r19,r19,r3
81115a20:	10003b26 	beq	r2,zero,81115b10 <_fseeko_r+0x390>
81115a24:	80c00f17 	ldw	r3,60(r16)
81115a28:	80800417 	ldw	r2,16(r16)
81115a2c:	98e7c83a 	sub	r19,r19,r3
81115a30:	003fbc06 	br	81115924 <__reset+0xfb0f5924>
81115a34:	8140038f 	ldh	r5,14(r16)
81115a38:	d80d883a 	mov	r6,sp
81115a3c:	8809883a 	mov	r4,r17
81115a40:	1115be80 	call	81115be8 <_fstat_r>
81115a44:	103f891e 	bne	r2,zero,8111586c <__reset+0xfb0f586c>
81115a48:	dd800417 	ldw	r22,16(sp)
81115a4c:	adad883a 	add	r22,r21,r22
81115a50:	b83fc926 	beq	r23,zero,81115978 <__reset+0xfb0f5978>
81115a54:	81400c17 	ldw	r5,48(r16)
81115a58:	81800117 	ldw	r6,4(r16)
81115a5c:	28005026 	beq	r5,zero,81115ba0 <_fseeko_r+0x420>
81115a60:	81c00f17 	ldw	r7,60(r16)
81115a64:	003fce06 	br	811159a0 <__reset+0xfb0f59a0>
81115a68:	84c01317 	ldw	r19,76(r16)
81115a6c:	81400717 	ldw	r5,28(r16)
81115a70:	000f883a 	mov	r7,zero
81115a74:	04e7c83a 	sub	r19,zero,r19
81115a78:	9da6703a 	and	r19,r19,r22
81115a7c:	980d883a 	mov	r6,r19
81115a80:	8809883a 	mov	r4,r17
81115a84:	a03ee83a 	callr	r20
81115a88:	00ffffc4 	movi	r3,-1
81115a8c:	10ff7726 	beq	r2,r3,8111586c <__reset+0xfb0f586c>
81115a90:	80800417 	ldw	r2,16(r16)
81115a94:	81400c17 	ldw	r5,48(r16)
81115a98:	80000115 	stw	zero,4(r16)
81115a9c:	80800015 	stw	r2,0(r16)
81115aa0:	28000526 	beq	r5,zero,81115ab8 <_fseeko_r+0x338>
81115aa4:	80801004 	addi	r2,r16,64
81115aa8:	28800226 	beq	r5,r2,81115ab4 <_fseeko_r+0x334>
81115aac:	8809883a 	mov	r4,r17
81115ab0:	111f9940 	call	8111f994 <_free_r>
81115ab4:	80000c15 	stw	zero,48(r16)
81115ab8:	8080030b 	ldhu	r2,12(r16)
81115abc:	b4e7c83a 	sub	r19,r22,r19
81115ac0:	10bff7cc 	andi	r2,r2,65503
81115ac4:	8080030d 	sth	r2,12(r16)
81115ac8:	98000b26 	beq	r19,zero,81115af8 <_fseeko_r+0x378>
81115acc:	800b883a 	mov	r5,r16
81115ad0:	8809883a 	mov	r4,r17
81115ad4:	1116d000 	call	81116d00 <__srefill_r>
81115ad8:	103f641e 	bne	r2,zero,8111586c <__reset+0xfb0f586c>
81115adc:	80800117 	ldw	r2,4(r16)
81115ae0:	14ff6236 	bltu	r2,r19,8111586c <__reset+0xfb0f586c>
81115ae4:	80c00017 	ldw	r3,0(r16)
81115ae8:	14c5c83a 	sub	r2,r2,r19
81115aec:	80800115 	stw	r2,4(r16)
81115af0:	1ce7883a 	add	r19,r3,r19
81115af4:	84c00015 	stw	r19,0(r16)
81115af8:	01800204 	movi	r6,8
81115afc:	000b883a 	mov	r5,zero
81115b00:	81001704 	addi	r4,r16,92
81115b04:	11168840 	call	81116884 <memset>
81115b08:	0027883a 	mov	r19,zero
81115b0c:	003f3d06 	br	81115804 <__reset+0xfb0f5804>
81115b10:	80800417 	ldw	r2,16(r16)
81115b14:	003f8306 	br	81115924 <__reset+0xfb0f5924>
81115b18:	81400717 	ldw	r5,28(r16)
81115b1c:	900f883a 	mov	r7,r18
81115b20:	000d883a 	mov	r6,zero
81115b24:	8809883a 	mov	r4,r17
81115b28:	a03ee83a 	callr	r20
81115b2c:	1027883a 	mov	r19,r2
81115b30:	00bfffc4 	movi	r2,-1
81115b34:	98bf3226 	beq	r19,r2,81115800 <__reset+0xfb0f5800>
81115b38:	8080030b 	ldhu	r2,12(r16)
81115b3c:	003f7006 	br	81115900 <__reset+0xfb0f5900>
81115b40:	8140038f 	ldh	r5,14(r16)
81115b44:	283f4716 	blt	r5,zero,81115864 <__reset+0xfb0f5864>
81115b48:	d80d883a 	mov	r6,sp
81115b4c:	8809883a 	mov	r4,r17
81115b50:	1115be80 	call	81115be8 <_fstat_r>
81115b54:	1000041e 	bne	r2,zero,81115b68 <_fseeko_r+0x3e8>
81115b58:	d8800117 	ldw	r2,4(sp)
81115b5c:	00e00014 	movui	r3,32768
81115b60:	10bc000c 	andi	r2,r2,61440
81115b64:	10ff7c26 	beq	r2,r3,81115958 <__reset+0xfb0f5958>
81115b68:	8080030b 	ldhu	r2,12(r16)
81115b6c:	003f3d06 	br	81115864 <__reset+0xfb0f5864>
81115b70:	800b883a 	mov	r5,r16
81115b74:	8809883a 	mov	r4,r17
81115b78:	1115d5c0 	call	81115d5c <__smakebuf_r>
81115b7c:	003f3106 	br	81115844 <__reset+0xfb0f5844>
81115b80:	81400717 	ldw	r5,28(r16)
81115b84:	01c00044 	movi	r7,1
81115b88:	000d883a 	mov	r6,zero
81115b8c:	8809883a 	mov	r4,r17
81115b90:	a03ee83a 	callr	r20
81115b94:	00ffffc4 	movi	r3,-1
81115b98:	10ff7b1e 	bne	r2,r3,81115988 <__reset+0xfb0f5988>
81115b9c:	003f3306 	br	8111586c <__reset+0xfb0f586c>
81115ba0:	80c00017 	ldw	r3,0(r16)
81115ba4:	80800417 	ldw	r2,16(r16)
81115ba8:	000b883a 	mov	r5,zero
81115bac:	1887c83a 	sub	r3,r3,r2
81115bb0:	98e7c83a 	sub	r19,r19,r3
81115bb4:	30c7883a 	add	r3,r6,r3
81115bb8:	003f7f06 	br	811159b8 <__reset+0xfb0f59b8>
81115bbc:	00800744 	movi	r2,29
81115bc0:	88800015 	stw	r2,0(r17)
81115bc4:	04ffffc4 	movi	r19,-1
81115bc8:	003f0e06 	br	81115804 <__reset+0xfb0f5804>

81115bcc <fseeko>:
81115bcc:	00a04534 	movhi	r2,33044
81115bd0:	109aed04 	addi	r2,r2,27572
81115bd4:	300f883a 	mov	r7,r6
81115bd8:	280d883a 	mov	r6,r5
81115bdc:	200b883a 	mov	r5,r4
81115be0:	11000017 	ldw	r4,0(r2)
81115be4:	11157801 	jmpi	81115780 <_fseeko_r>

81115be8 <_fstat_r>:
81115be8:	defffd04 	addi	sp,sp,-12
81115bec:	de00012e 	bgeu	sp,et,81115bf4 <_fstat_r+0xc>
81115bf0:	003b68fa 	trap	3
81115bf4:	2805883a 	mov	r2,r5
81115bf8:	dc000015 	stw	r16,0(sp)
81115bfc:	04204534 	movhi	r16,33044
81115c00:	dc400115 	stw	r17,4(sp)
81115c04:	841b5004 	addi	r16,r16,27968
81115c08:	2023883a 	mov	r17,r4
81115c0c:	300b883a 	mov	r5,r6
81115c10:	1009883a 	mov	r4,r2
81115c14:	dfc00215 	stw	ra,8(sp)
81115c18:	80000015 	stw	zero,0(r16)
81115c1c:	112b1d40 	call	8112b1d4 <fstat>
81115c20:	00ffffc4 	movi	r3,-1
81115c24:	10c00526 	beq	r2,r3,81115c3c <_fstat_r+0x54>
81115c28:	dfc00217 	ldw	ra,8(sp)
81115c2c:	dc400117 	ldw	r17,4(sp)
81115c30:	dc000017 	ldw	r16,0(sp)
81115c34:	dec00304 	addi	sp,sp,12
81115c38:	f800283a 	ret
81115c3c:	80c00017 	ldw	r3,0(r16)
81115c40:	183ff926 	beq	r3,zero,81115c28 <__reset+0xfb0f5c28>
81115c44:	88c00015 	stw	r3,0(r17)
81115c48:	003ff706 	br	81115c28 <__reset+0xfb0f5c28>

81115c4c <_fwrite_r>:
81115c4c:	defff504 	addi	sp,sp,-44
81115c50:	de00012e 	bgeu	sp,et,81115c58 <_fwrite_r+0xc>
81115c54:	003b68fa 	trap	3
81115c58:	dc800815 	stw	r18,32(sp)
81115c5c:	39a5383a 	mul	r18,r7,r6
81115c60:	d8800304 	addi	r2,sp,12
81115c64:	d8800015 	stw	r2,0(sp)
81115c68:	00800044 	movi	r2,1
81115c6c:	dcc00915 	stw	r19,36(sp)
81115c70:	dc400715 	stw	r17,28(sp)
81115c74:	dc000615 	stw	r16,24(sp)
81115c78:	d9400315 	stw	r5,12(sp)
81115c7c:	dfc00a15 	stw	ra,40(sp)
81115c80:	dc800415 	stw	r18,16(sp)
81115c84:	dc800215 	stw	r18,8(sp)
81115c88:	d8800115 	stw	r2,4(sp)
81115c8c:	3027883a 	mov	r19,r6
81115c90:	3821883a 	mov	r16,r7
81115c94:	2023883a 	mov	r17,r4
81115c98:	d9400b17 	ldw	r5,44(sp)
81115c9c:	20000226 	beq	r4,zero,81115ca8 <_fwrite_r+0x5c>
81115ca0:	20800e17 	ldw	r2,56(r4)
81115ca4:	10001a26 	beq	r2,zero,81115d10 <_fwrite_r+0xc4>
81115ca8:	2880030b 	ldhu	r2,12(r5)
81115cac:	10c8000c 	andi	r3,r2,8192
81115cb0:	1800061e 	bne	r3,zero,81115ccc <_fwrite_r+0x80>
81115cb4:	29001917 	ldw	r4,100(r5)
81115cb8:	00f7ffc4 	movi	r3,-8193
81115cbc:	10880014 	ori	r2,r2,8192
81115cc0:	20c6703a 	and	r3,r4,r3
81115cc4:	2880030d 	sth	r2,12(r5)
81115cc8:	28c01915 	stw	r3,100(r5)
81115ccc:	d80d883a 	mov	r6,sp
81115cd0:	8809883a 	mov	r4,r17
81115cd4:	111fcac0 	call	8111fcac <__sfvwrite_r>
81115cd8:	10000b26 	beq	r2,zero,81115d08 <_fwrite_r+0xbc>
81115cdc:	d9000217 	ldw	r4,8(sp)
81115ce0:	980b883a 	mov	r5,r19
81115ce4:	9109c83a 	sub	r4,r18,r4
81115ce8:	1128d1c0 	call	81128d1c <__udivsi3>
81115cec:	dfc00a17 	ldw	ra,40(sp)
81115cf0:	dcc00917 	ldw	r19,36(sp)
81115cf4:	dc800817 	ldw	r18,32(sp)
81115cf8:	dc400717 	ldw	r17,28(sp)
81115cfc:	dc000617 	ldw	r16,24(sp)
81115d00:	dec00b04 	addi	sp,sp,44
81115d04:	f800283a 	ret
81115d08:	8005883a 	mov	r2,r16
81115d0c:	003ff706 	br	81115cec <__reset+0xfb0f5cec>
81115d10:	d9400515 	stw	r5,20(sp)
81115d14:	111f4fc0 	call	8111f4fc <__sinit>
81115d18:	d9400517 	ldw	r5,20(sp)
81115d1c:	003fe206 	br	81115ca8 <__reset+0xfb0f5ca8>

81115d20 <fwrite>:
81115d20:	defffe04 	addi	sp,sp,-8
81115d24:	00a04534 	movhi	r2,33044
81115d28:	de00012e 	bgeu	sp,et,81115d30 <fwrite+0x10>
81115d2c:	003b68fa 	trap	3
81115d30:	109aed04 	addi	r2,r2,27572
81115d34:	d9c00015 	stw	r7,0(sp)
81115d38:	300f883a 	mov	r7,r6
81115d3c:	280d883a 	mov	r6,r5
81115d40:	200b883a 	mov	r5,r4
81115d44:	11000017 	ldw	r4,0(r2)
81115d48:	dfc00115 	stw	ra,4(sp)
81115d4c:	1115c4c0 	call	81115c4c <_fwrite_r>
81115d50:	dfc00117 	ldw	ra,4(sp)
81115d54:	dec00204 	addi	sp,sp,8
81115d58:	f800283a 	ret

81115d5c <__smakebuf_r>:
81115d5c:	2880030b 	ldhu	r2,12(r5)
81115d60:	10c0008c 	andi	r3,r2,2
81115d64:	1800431e 	bne	r3,zero,81115e74 <__smakebuf_r+0x118>
81115d68:	deffec04 	addi	sp,sp,-80
81115d6c:	de00012e 	bgeu	sp,et,81115d74 <__smakebuf_r+0x18>
81115d70:	003b68fa 	trap	3
81115d74:	dc000f15 	stw	r16,60(sp)
81115d78:	2821883a 	mov	r16,r5
81115d7c:	2940038f 	ldh	r5,14(r5)
81115d80:	dc401015 	stw	r17,64(sp)
81115d84:	dfc01315 	stw	ra,76(sp)
81115d88:	dcc01215 	stw	r19,72(sp)
81115d8c:	dc801115 	stw	r18,68(sp)
81115d90:	2023883a 	mov	r17,r4
81115d94:	28001c16 	blt	r5,zero,81115e08 <__smakebuf_r+0xac>
81115d98:	d80d883a 	mov	r6,sp
81115d9c:	1115be80 	call	81115be8 <_fstat_r>
81115da0:	10001816 	blt	r2,zero,81115e04 <__smakebuf_r+0xa8>
81115da4:	d8800117 	ldw	r2,4(sp)
81115da8:	00e00014 	movui	r3,32768
81115dac:	10bc000c 	andi	r2,r2,61440
81115db0:	14c80020 	cmpeqi	r19,r2,8192
81115db4:	10c03726 	beq	r2,r3,81115e94 <__smakebuf_r+0x138>
81115db8:	80c0030b 	ldhu	r3,12(r16)
81115dbc:	18c20014 	ori	r3,r3,2048
81115dc0:	80c0030d 	sth	r3,12(r16)
81115dc4:	00c80004 	movi	r3,8192
81115dc8:	10c0521e 	bne	r2,r3,81115f14 <__smakebuf_r+0x1b8>
81115dcc:	8140038f 	ldh	r5,14(r16)
81115dd0:	8809883a 	mov	r4,r17
81115dd4:	11203080 	call	81120308 <_isatty_r>
81115dd8:	10004c26 	beq	r2,zero,81115f0c <__smakebuf_r+0x1b0>
81115ddc:	8080030b 	ldhu	r2,12(r16)
81115de0:	80c010c4 	addi	r3,r16,67
81115de4:	80c00015 	stw	r3,0(r16)
81115de8:	10800054 	ori	r2,r2,1
81115dec:	8080030d 	sth	r2,12(r16)
81115df0:	00800044 	movi	r2,1
81115df4:	80c00415 	stw	r3,16(r16)
81115df8:	80800515 	stw	r2,20(r16)
81115dfc:	04810004 	movi	r18,1024
81115e00:	00000706 	br	81115e20 <__smakebuf_r+0xc4>
81115e04:	8080030b 	ldhu	r2,12(r16)
81115e08:	10c0200c 	andi	r3,r2,128
81115e0c:	18001f1e 	bne	r3,zero,81115e8c <__smakebuf_r+0x130>
81115e10:	04810004 	movi	r18,1024
81115e14:	10820014 	ori	r2,r2,2048
81115e18:	8080030d 	sth	r2,12(r16)
81115e1c:	0027883a 	mov	r19,zero
81115e20:	900b883a 	mov	r5,r18
81115e24:	8809883a 	mov	r4,r17
81115e28:	1115f200 	call	81115f20 <_malloc_r>
81115e2c:	10002c26 	beq	r2,zero,81115ee0 <__smakebuf_r+0x184>
81115e30:	80c0030b 	ldhu	r3,12(r16)
81115e34:	012044b4 	movhi	r4,33042
81115e38:	213c6704 	addi	r4,r4,-3684
81115e3c:	89000f15 	stw	r4,60(r17)
81115e40:	18c02014 	ori	r3,r3,128
81115e44:	80c0030d 	sth	r3,12(r16)
81115e48:	80800015 	stw	r2,0(r16)
81115e4c:	80800415 	stw	r2,16(r16)
81115e50:	84800515 	stw	r18,20(r16)
81115e54:	98001a1e 	bne	r19,zero,81115ec0 <__smakebuf_r+0x164>
81115e58:	dfc01317 	ldw	ra,76(sp)
81115e5c:	dcc01217 	ldw	r19,72(sp)
81115e60:	dc801117 	ldw	r18,68(sp)
81115e64:	dc401017 	ldw	r17,64(sp)
81115e68:	dc000f17 	ldw	r16,60(sp)
81115e6c:	dec01404 	addi	sp,sp,80
81115e70:	f800283a 	ret
81115e74:	288010c4 	addi	r2,r5,67
81115e78:	28800015 	stw	r2,0(r5)
81115e7c:	28800415 	stw	r2,16(r5)
81115e80:	00800044 	movi	r2,1
81115e84:	28800515 	stw	r2,20(r5)
81115e88:	f800283a 	ret
81115e8c:	04801004 	movi	r18,64
81115e90:	003fe006 	br	81115e14 <__reset+0xfb0f5e14>
81115e94:	81000a17 	ldw	r4,40(r16)
81115e98:	00e04474 	movhi	r3,33041
81115e9c:	18dc5c04 	addi	r3,r3,29040
81115ea0:	20ffc51e 	bne	r4,r3,81115db8 <__reset+0xfb0f5db8>
81115ea4:	8080030b 	ldhu	r2,12(r16)
81115ea8:	04810004 	movi	r18,1024
81115eac:	84801315 	stw	r18,76(r16)
81115eb0:	1484b03a 	or	r2,r2,r18
81115eb4:	8080030d 	sth	r2,12(r16)
81115eb8:	0027883a 	mov	r19,zero
81115ebc:	003fd806 	br	81115e20 <__reset+0xfb0f5e20>
81115ec0:	8140038f 	ldh	r5,14(r16)
81115ec4:	8809883a 	mov	r4,r17
81115ec8:	11203080 	call	81120308 <_isatty_r>
81115ecc:	103fe226 	beq	r2,zero,81115e58 <__reset+0xfb0f5e58>
81115ed0:	8080030b 	ldhu	r2,12(r16)
81115ed4:	10800054 	ori	r2,r2,1
81115ed8:	8080030d 	sth	r2,12(r16)
81115edc:	003fde06 	br	81115e58 <__reset+0xfb0f5e58>
81115ee0:	8080030b 	ldhu	r2,12(r16)
81115ee4:	10c0800c 	andi	r3,r2,512
81115ee8:	183fdb1e 	bne	r3,zero,81115e58 <__reset+0xfb0f5e58>
81115eec:	10800094 	ori	r2,r2,2
81115ef0:	80c010c4 	addi	r3,r16,67
81115ef4:	8080030d 	sth	r2,12(r16)
81115ef8:	00800044 	movi	r2,1
81115efc:	80c00015 	stw	r3,0(r16)
81115f00:	80c00415 	stw	r3,16(r16)
81115f04:	80800515 	stw	r2,20(r16)
81115f08:	003fd306 	br	81115e58 <__reset+0xfb0f5e58>
81115f0c:	04810004 	movi	r18,1024
81115f10:	003fc306 	br	81115e20 <__reset+0xfb0f5e20>
81115f14:	0027883a 	mov	r19,zero
81115f18:	04810004 	movi	r18,1024
81115f1c:	003fc006 	br	81115e20 <__reset+0xfb0f5e20>

81115f20 <_malloc_r>:
81115f20:	defff504 	addi	sp,sp,-44
81115f24:	de00012e 	bgeu	sp,et,81115f2c <_malloc_r+0xc>
81115f28:	003b68fa 	trap	3
81115f2c:	288002c4 	addi	r2,r5,11
81115f30:	dc800315 	stw	r18,12(sp)
81115f34:	dfc00a15 	stw	ra,40(sp)
81115f38:	df000915 	stw	fp,36(sp)
81115f3c:	ddc00815 	stw	r23,32(sp)
81115f40:	dd800715 	stw	r22,28(sp)
81115f44:	dd400615 	stw	r21,24(sp)
81115f48:	dd000515 	stw	r20,20(sp)
81115f4c:	dcc00415 	stw	r19,16(sp)
81115f50:	dc400215 	stw	r17,8(sp)
81115f54:	dc000115 	stw	r16,4(sp)
81115f58:	00c00584 	movi	r3,22
81115f5c:	2025883a 	mov	r18,r4
81115f60:	18807f2e 	bgeu	r3,r2,81116160 <_malloc_r+0x240>
81115f64:	047ffe04 	movi	r17,-8
81115f68:	1462703a 	and	r17,r2,r17
81115f6c:	8800a316 	blt	r17,zero,811161fc <_malloc_r+0x2dc>
81115f70:	8940a236 	bltu	r17,r5,811161fc <_malloc_r+0x2dc>
81115f74:	112cd1c0 	call	8112cd1c <__malloc_lock>
81115f78:	00807dc4 	movi	r2,503
81115f7c:	1441e92e 	bgeu	r2,r17,81116724 <_malloc_r+0x804>
81115f80:	8804d27a 	srli	r2,r17,9
81115f84:	1000a126 	beq	r2,zero,8111620c <_malloc_r+0x2ec>
81115f88:	00c00104 	movi	r3,4
81115f8c:	18811e36 	bltu	r3,r2,81116408 <_malloc_r+0x4e8>
81115f90:	8804d1ba 	srli	r2,r17,6
81115f94:	12000e44 	addi	r8,r2,57
81115f98:	11c00e04 	addi	r7,r2,56
81115f9c:	4209883a 	add	r4,r8,r8
81115fa0:	04e04534 	movhi	r19,33044
81115fa4:	2109883a 	add	r4,r4,r4
81115fa8:	9cd4ab04 	addi	r19,r19,21164
81115fac:	2109883a 	add	r4,r4,r4
81115fb0:	9909883a 	add	r4,r19,r4
81115fb4:	24000117 	ldw	r16,4(r4)
81115fb8:	213ffe04 	addi	r4,r4,-8
81115fbc:	24009726 	beq	r4,r16,8111621c <_malloc_r+0x2fc>
81115fc0:	80800117 	ldw	r2,4(r16)
81115fc4:	01bfff04 	movi	r6,-4
81115fc8:	014003c4 	movi	r5,15
81115fcc:	1184703a 	and	r2,r2,r6
81115fd0:	1447c83a 	sub	r3,r2,r17
81115fd4:	28c00716 	blt	r5,r3,81115ff4 <_malloc_r+0xd4>
81115fd8:	1800920e 	bge	r3,zero,81116224 <_malloc_r+0x304>
81115fdc:	84000317 	ldw	r16,12(r16)
81115fe0:	24008e26 	beq	r4,r16,8111621c <_malloc_r+0x2fc>
81115fe4:	80800117 	ldw	r2,4(r16)
81115fe8:	1184703a 	and	r2,r2,r6
81115fec:	1447c83a 	sub	r3,r2,r17
81115ff0:	28fff90e 	bge	r5,r3,81115fd8 <__reset+0xfb0f5fd8>
81115ff4:	3809883a 	mov	r4,r7
81115ff8:	01a04534 	movhi	r6,33044
81115ffc:	9c000417 	ldw	r16,16(r19)
81116000:	3194ab04 	addi	r6,r6,21164
81116004:	32000204 	addi	r8,r6,8
81116008:	82013426 	beq	r16,r8,811164dc <_malloc_r+0x5bc>
8111600c:	80c00117 	ldw	r3,4(r16)
81116010:	00bfff04 	movi	r2,-4
81116014:	188e703a 	and	r7,r3,r2
81116018:	3c45c83a 	sub	r2,r7,r17
8111601c:	00c003c4 	movi	r3,15
81116020:	18811f16 	blt	r3,r2,811164a0 <_malloc_r+0x580>
81116024:	32000515 	stw	r8,20(r6)
81116028:	32000415 	stw	r8,16(r6)
8111602c:	10007f0e 	bge	r2,zero,8111622c <_malloc_r+0x30c>
81116030:	00807fc4 	movi	r2,511
81116034:	11c0fd36 	bltu	r2,r7,8111642c <_malloc_r+0x50c>
81116038:	3806d0fa 	srli	r3,r7,3
8111603c:	01c00044 	movi	r7,1
81116040:	30800117 	ldw	r2,4(r6)
81116044:	19400044 	addi	r5,r3,1
81116048:	294b883a 	add	r5,r5,r5
8111604c:	1807d0ba 	srai	r3,r3,2
81116050:	294b883a 	add	r5,r5,r5
81116054:	294b883a 	add	r5,r5,r5
81116058:	298b883a 	add	r5,r5,r6
8111605c:	38c6983a 	sll	r3,r7,r3
81116060:	29c00017 	ldw	r7,0(r5)
81116064:	2a7ffe04 	addi	r9,r5,-8
81116068:	1886b03a 	or	r3,r3,r2
8111606c:	82400315 	stw	r9,12(r16)
81116070:	81c00215 	stw	r7,8(r16)
81116074:	30c00115 	stw	r3,4(r6)
81116078:	2c000015 	stw	r16,0(r5)
8111607c:	3c000315 	stw	r16,12(r7)
81116080:	2005d0ba 	srai	r2,r4,2
81116084:	01400044 	movi	r5,1
81116088:	288a983a 	sll	r5,r5,r2
8111608c:	19406f36 	bltu	r3,r5,8111624c <_malloc_r+0x32c>
81116090:	28c4703a 	and	r2,r5,r3
81116094:	10000a1e 	bne	r2,zero,811160c0 <_malloc_r+0x1a0>
81116098:	00bfff04 	movi	r2,-4
8111609c:	294b883a 	add	r5,r5,r5
811160a0:	2088703a 	and	r4,r4,r2
811160a4:	28c4703a 	and	r2,r5,r3
811160a8:	21000104 	addi	r4,r4,4
811160ac:	1000041e 	bne	r2,zero,811160c0 <_malloc_r+0x1a0>
811160b0:	294b883a 	add	r5,r5,r5
811160b4:	28c4703a 	and	r2,r5,r3
811160b8:	21000104 	addi	r4,r4,4
811160bc:	103ffc26 	beq	r2,zero,811160b0 <__reset+0xfb0f60b0>
811160c0:	02bfff04 	movi	r10,-4
811160c4:	024003c4 	movi	r9,15
811160c8:	21800044 	addi	r6,r4,1
811160cc:	318d883a 	add	r6,r6,r6
811160d0:	318d883a 	add	r6,r6,r6
811160d4:	318d883a 	add	r6,r6,r6
811160d8:	998d883a 	add	r6,r19,r6
811160dc:	333ffe04 	addi	r12,r6,-8
811160e0:	2017883a 	mov	r11,r4
811160e4:	31800104 	addi	r6,r6,4
811160e8:	34000017 	ldw	r16,0(r6)
811160ec:	31fffd04 	addi	r7,r6,-12
811160f0:	81c0041e 	bne	r16,r7,81116104 <_malloc_r+0x1e4>
811160f4:	0000fb06 	br	811164e4 <_malloc_r+0x5c4>
811160f8:	1801030e 	bge	r3,zero,81116508 <_malloc_r+0x5e8>
811160fc:	84000317 	ldw	r16,12(r16)
81116100:	81c0f826 	beq	r16,r7,811164e4 <_malloc_r+0x5c4>
81116104:	80800117 	ldw	r2,4(r16)
81116108:	1284703a 	and	r2,r2,r10
8111610c:	1447c83a 	sub	r3,r2,r17
81116110:	48fff90e 	bge	r9,r3,811160f8 <__reset+0xfb0f60f8>
81116114:	80800317 	ldw	r2,12(r16)
81116118:	81000217 	ldw	r4,8(r16)
8111611c:	89400054 	ori	r5,r17,1
81116120:	81400115 	stw	r5,4(r16)
81116124:	20800315 	stw	r2,12(r4)
81116128:	11000215 	stw	r4,8(r2)
8111612c:	8463883a 	add	r17,r16,r17
81116130:	9c400515 	stw	r17,20(r19)
81116134:	9c400415 	stw	r17,16(r19)
81116138:	18800054 	ori	r2,r3,1
8111613c:	88800115 	stw	r2,4(r17)
81116140:	8a000315 	stw	r8,12(r17)
81116144:	8a000215 	stw	r8,8(r17)
81116148:	88e3883a 	add	r17,r17,r3
8111614c:	88c00015 	stw	r3,0(r17)
81116150:	9009883a 	mov	r4,r18
81116154:	112ce440 	call	8112ce44 <__malloc_unlock>
81116158:	80800204 	addi	r2,r16,8
8111615c:	00001b06 	br	811161cc <_malloc_r+0x2ac>
81116160:	04400404 	movi	r17,16
81116164:	89402536 	bltu	r17,r5,811161fc <_malloc_r+0x2dc>
81116168:	112cd1c0 	call	8112cd1c <__malloc_lock>
8111616c:	00800184 	movi	r2,6
81116170:	01000084 	movi	r4,2
81116174:	04e04534 	movhi	r19,33044
81116178:	1085883a 	add	r2,r2,r2
8111617c:	9cd4ab04 	addi	r19,r19,21164
81116180:	1085883a 	add	r2,r2,r2
81116184:	9885883a 	add	r2,r19,r2
81116188:	14000117 	ldw	r16,4(r2)
8111618c:	10fffe04 	addi	r3,r2,-8
81116190:	80c0d926 	beq	r16,r3,811164f8 <_malloc_r+0x5d8>
81116194:	80c00117 	ldw	r3,4(r16)
81116198:	81000317 	ldw	r4,12(r16)
8111619c:	00bfff04 	movi	r2,-4
811161a0:	1884703a 	and	r2,r3,r2
811161a4:	81400217 	ldw	r5,8(r16)
811161a8:	8085883a 	add	r2,r16,r2
811161ac:	10c00117 	ldw	r3,4(r2)
811161b0:	29000315 	stw	r4,12(r5)
811161b4:	21400215 	stw	r5,8(r4)
811161b8:	18c00054 	ori	r3,r3,1
811161bc:	10c00115 	stw	r3,4(r2)
811161c0:	9009883a 	mov	r4,r18
811161c4:	112ce440 	call	8112ce44 <__malloc_unlock>
811161c8:	80800204 	addi	r2,r16,8
811161cc:	dfc00a17 	ldw	ra,40(sp)
811161d0:	df000917 	ldw	fp,36(sp)
811161d4:	ddc00817 	ldw	r23,32(sp)
811161d8:	dd800717 	ldw	r22,28(sp)
811161dc:	dd400617 	ldw	r21,24(sp)
811161e0:	dd000517 	ldw	r20,20(sp)
811161e4:	dcc00417 	ldw	r19,16(sp)
811161e8:	dc800317 	ldw	r18,12(sp)
811161ec:	dc400217 	ldw	r17,8(sp)
811161f0:	dc000117 	ldw	r16,4(sp)
811161f4:	dec00b04 	addi	sp,sp,44
811161f8:	f800283a 	ret
811161fc:	00800304 	movi	r2,12
81116200:	90800015 	stw	r2,0(r18)
81116204:	0005883a 	mov	r2,zero
81116208:	003ff006 	br	811161cc <__reset+0xfb0f61cc>
8111620c:	01002004 	movi	r4,128
81116210:	02001004 	movi	r8,64
81116214:	01c00fc4 	movi	r7,63
81116218:	003f6106 	br	81115fa0 <__reset+0xfb0f5fa0>
8111621c:	4009883a 	mov	r4,r8
81116220:	003f7506 	br	81115ff8 <__reset+0xfb0f5ff8>
81116224:	81000317 	ldw	r4,12(r16)
81116228:	003fde06 	br	811161a4 <__reset+0xfb0f61a4>
8111622c:	81c5883a 	add	r2,r16,r7
81116230:	11400117 	ldw	r5,4(r2)
81116234:	9009883a 	mov	r4,r18
81116238:	29400054 	ori	r5,r5,1
8111623c:	11400115 	stw	r5,4(r2)
81116240:	112ce440 	call	8112ce44 <__malloc_unlock>
81116244:	80800204 	addi	r2,r16,8
81116248:	003fe006 	br	811161cc <__reset+0xfb0f61cc>
8111624c:	9c000217 	ldw	r16,8(r19)
81116250:	00bfff04 	movi	r2,-4
81116254:	85800117 	ldw	r22,4(r16)
81116258:	b0ac703a 	and	r22,r22,r2
8111625c:	b4400336 	bltu	r22,r17,8111626c <_malloc_r+0x34c>
81116260:	b445c83a 	sub	r2,r22,r17
81116264:	00c003c4 	movi	r3,15
81116268:	18805d16 	blt	r3,r2,811163e0 <_malloc_r+0x4c0>
8111626c:	05e04534 	movhi	r23,33044
81116270:	00a04534 	movhi	r2,33044
81116274:	109b5304 	addi	r2,r2,27980
81116278:	bddaee04 	addi	r23,r23,27576
8111627c:	15400017 	ldw	r21,0(r2)
81116280:	b8c00017 	ldw	r3,0(r23)
81116284:	00bfffc4 	movi	r2,-1
81116288:	858d883a 	add	r6,r16,r22
8111628c:	8d6b883a 	add	r21,r17,r21
81116290:	1880ea26 	beq	r3,r2,8111663c <_malloc_r+0x71c>
81116294:	ad4403c4 	addi	r21,r21,4111
81116298:	00bc0004 	movi	r2,-4096
8111629c:	a8aa703a 	and	r21,r21,r2
811162a0:	a80b883a 	mov	r5,r21
811162a4:	9009883a 	mov	r4,r18
811162a8:	d9800015 	stw	r6,0(sp)
811162ac:	1116edc0 	call	81116edc <_sbrk_r>
811162b0:	1029883a 	mov	r20,r2
811162b4:	00bfffc4 	movi	r2,-1
811162b8:	d9800017 	ldw	r6,0(sp)
811162bc:	a080e826 	beq	r20,r2,81116660 <_malloc_r+0x740>
811162c0:	a180a636 	bltu	r20,r6,8111655c <_malloc_r+0x63c>
811162c4:	07204534 	movhi	fp,33044
811162c8:	e71bf504 	addi	fp,fp,28628
811162cc:	e0800017 	ldw	r2,0(fp)
811162d0:	a887883a 	add	r3,r21,r2
811162d4:	e0c00015 	stw	r3,0(fp)
811162d8:	3500e626 	beq	r6,r20,81116674 <_malloc_r+0x754>
811162dc:	b9000017 	ldw	r4,0(r23)
811162e0:	00bfffc4 	movi	r2,-1
811162e4:	2080ee26 	beq	r4,r2,811166a0 <_malloc_r+0x780>
811162e8:	a185c83a 	sub	r2,r20,r6
811162ec:	10c5883a 	add	r2,r2,r3
811162f0:	e0800015 	stw	r2,0(fp)
811162f4:	a0c001cc 	andi	r3,r20,7
811162f8:	1800bc26 	beq	r3,zero,811165ec <_malloc_r+0x6cc>
811162fc:	a0e9c83a 	sub	r20,r20,r3
81116300:	00840204 	movi	r2,4104
81116304:	a5000204 	addi	r20,r20,8
81116308:	10c7c83a 	sub	r3,r2,r3
8111630c:	a545883a 	add	r2,r20,r21
81116310:	1083ffcc 	andi	r2,r2,4095
81116314:	18abc83a 	sub	r21,r3,r2
81116318:	a80b883a 	mov	r5,r21
8111631c:	9009883a 	mov	r4,r18
81116320:	1116edc0 	call	81116edc <_sbrk_r>
81116324:	00ffffc4 	movi	r3,-1
81116328:	10c0e126 	beq	r2,r3,811166b0 <_malloc_r+0x790>
8111632c:	1505c83a 	sub	r2,r2,r20
81116330:	1545883a 	add	r2,r2,r21
81116334:	10800054 	ori	r2,r2,1
81116338:	e0c00017 	ldw	r3,0(fp)
8111633c:	9d000215 	stw	r20,8(r19)
81116340:	a0800115 	stw	r2,4(r20)
81116344:	a8c7883a 	add	r3,r21,r3
81116348:	e0c00015 	stw	r3,0(fp)
8111634c:	84c00e26 	beq	r16,r19,81116388 <_malloc_r+0x468>
81116350:	018003c4 	movi	r6,15
81116354:	3580a72e 	bgeu	r6,r22,811165f4 <_malloc_r+0x6d4>
81116358:	81400117 	ldw	r5,4(r16)
8111635c:	013ffe04 	movi	r4,-8
81116360:	b0bffd04 	addi	r2,r22,-12
81116364:	1104703a 	and	r2,r2,r4
81116368:	2900004c 	andi	r4,r5,1
8111636c:	2088b03a 	or	r4,r4,r2
81116370:	81000115 	stw	r4,4(r16)
81116374:	01400144 	movi	r5,5
81116378:	8089883a 	add	r4,r16,r2
8111637c:	21400115 	stw	r5,4(r4)
81116380:	21400215 	stw	r5,8(r4)
81116384:	3080cd36 	bltu	r6,r2,811166bc <_malloc_r+0x79c>
81116388:	00a04534 	movhi	r2,33044
8111638c:	109b5204 	addi	r2,r2,27976
81116390:	11000017 	ldw	r4,0(r2)
81116394:	20c0012e 	bgeu	r4,r3,8111639c <_malloc_r+0x47c>
81116398:	10c00015 	stw	r3,0(r2)
8111639c:	00a04534 	movhi	r2,33044
811163a0:	109b5104 	addi	r2,r2,27972
811163a4:	11000017 	ldw	r4,0(r2)
811163a8:	9c000217 	ldw	r16,8(r19)
811163ac:	20c0012e 	bgeu	r4,r3,811163b4 <_malloc_r+0x494>
811163b0:	10c00015 	stw	r3,0(r2)
811163b4:	80c00117 	ldw	r3,4(r16)
811163b8:	00bfff04 	movi	r2,-4
811163bc:	1886703a 	and	r3,r3,r2
811163c0:	1c45c83a 	sub	r2,r3,r17
811163c4:	1c400236 	bltu	r3,r17,811163d0 <_malloc_r+0x4b0>
811163c8:	00c003c4 	movi	r3,15
811163cc:	18800416 	blt	r3,r2,811163e0 <_malloc_r+0x4c0>
811163d0:	9009883a 	mov	r4,r18
811163d4:	112ce440 	call	8112ce44 <__malloc_unlock>
811163d8:	0005883a 	mov	r2,zero
811163dc:	003f7b06 	br	811161cc <__reset+0xfb0f61cc>
811163e0:	88c00054 	ori	r3,r17,1
811163e4:	80c00115 	stw	r3,4(r16)
811163e8:	8463883a 	add	r17,r16,r17
811163ec:	10800054 	ori	r2,r2,1
811163f0:	9c400215 	stw	r17,8(r19)
811163f4:	88800115 	stw	r2,4(r17)
811163f8:	9009883a 	mov	r4,r18
811163fc:	112ce440 	call	8112ce44 <__malloc_unlock>
81116400:	80800204 	addi	r2,r16,8
81116404:	003f7106 	br	811161cc <__reset+0xfb0f61cc>
81116408:	00c00504 	movi	r3,20
8111640c:	18804a2e 	bgeu	r3,r2,81116538 <_malloc_r+0x618>
81116410:	00c01504 	movi	r3,84
81116414:	18806e36 	bltu	r3,r2,811165d0 <_malloc_r+0x6b0>
81116418:	8804d33a 	srli	r2,r17,12
8111641c:	12001bc4 	addi	r8,r2,111
81116420:	11c01b84 	addi	r7,r2,110
81116424:	4209883a 	add	r4,r8,r8
81116428:	003edd06 	br	81115fa0 <__reset+0xfb0f5fa0>
8111642c:	3804d27a 	srli	r2,r7,9
81116430:	00c00104 	movi	r3,4
81116434:	1880442e 	bgeu	r3,r2,81116548 <_malloc_r+0x628>
81116438:	00c00504 	movi	r3,20
8111643c:	18808136 	bltu	r3,r2,81116644 <_malloc_r+0x724>
81116440:	11401704 	addi	r5,r2,92
81116444:	10c016c4 	addi	r3,r2,91
81116448:	294b883a 	add	r5,r5,r5
8111644c:	294b883a 	add	r5,r5,r5
81116450:	294b883a 	add	r5,r5,r5
81116454:	994b883a 	add	r5,r19,r5
81116458:	28800017 	ldw	r2,0(r5)
8111645c:	01a04534 	movhi	r6,33044
81116460:	297ffe04 	addi	r5,r5,-8
81116464:	3194ab04 	addi	r6,r6,21164
81116468:	28806526 	beq	r5,r2,81116600 <_malloc_r+0x6e0>
8111646c:	01bfff04 	movi	r6,-4
81116470:	10c00117 	ldw	r3,4(r2)
81116474:	1986703a 	and	r3,r3,r6
81116478:	38c0022e 	bgeu	r7,r3,81116484 <_malloc_r+0x564>
8111647c:	10800217 	ldw	r2,8(r2)
81116480:	28bffb1e 	bne	r5,r2,81116470 <__reset+0xfb0f6470>
81116484:	11400317 	ldw	r5,12(r2)
81116488:	98c00117 	ldw	r3,4(r19)
8111648c:	81400315 	stw	r5,12(r16)
81116490:	80800215 	stw	r2,8(r16)
81116494:	2c000215 	stw	r16,8(r5)
81116498:	14000315 	stw	r16,12(r2)
8111649c:	003ef806 	br	81116080 <__reset+0xfb0f6080>
811164a0:	88c00054 	ori	r3,r17,1
811164a4:	80c00115 	stw	r3,4(r16)
811164a8:	8463883a 	add	r17,r16,r17
811164ac:	34400515 	stw	r17,20(r6)
811164b0:	34400415 	stw	r17,16(r6)
811164b4:	10c00054 	ori	r3,r2,1
811164b8:	8a000315 	stw	r8,12(r17)
811164bc:	8a000215 	stw	r8,8(r17)
811164c0:	88c00115 	stw	r3,4(r17)
811164c4:	88a3883a 	add	r17,r17,r2
811164c8:	88800015 	stw	r2,0(r17)
811164cc:	9009883a 	mov	r4,r18
811164d0:	112ce440 	call	8112ce44 <__malloc_unlock>
811164d4:	80800204 	addi	r2,r16,8
811164d8:	003f3c06 	br	811161cc <__reset+0xfb0f61cc>
811164dc:	30c00117 	ldw	r3,4(r6)
811164e0:	003ee706 	br	81116080 <__reset+0xfb0f6080>
811164e4:	5ac00044 	addi	r11,r11,1
811164e8:	588000cc 	andi	r2,r11,3
811164ec:	31800204 	addi	r6,r6,8
811164f0:	103efd1e 	bne	r2,zero,811160e8 <__reset+0xfb0f60e8>
811164f4:	00002406 	br	81116588 <_malloc_r+0x668>
811164f8:	14000317 	ldw	r16,12(r2)
811164fc:	143f251e 	bne	r2,r16,81116194 <__reset+0xfb0f6194>
81116500:	21000084 	addi	r4,r4,2
81116504:	003ebc06 	br	81115ff8 <__reset+0xfb0f5ff8>
81116508:	8085883a 	add	r2,r16,r2
8111650c:	10c00117 	ldw	r3,4(r2)
81116510:	81000317 	ldw	r4,12(r16)
81116514:	81400217 	ldw	r5,8(r16)
81116518:	18c00054 	ori	r3,r3,1
8111651c:	10c00115 	stw	r3,4(r2)
81116520:	29000315 	stw	r4,12(r5)
81116524:	21400215 	stw	r5,8(r4)
81116528:	9009883a 	mov	r4,r18
8111652c:	112ce440 	call	8112ce44 <__malloc_unlock>
81116530:	80800204 	addi	r2,r16,8
81116534:	003f2506 	br	811161cc <__reset+0xfb0f61cc>
81116538:	12001704 	addi	r8,r2,92
8111653c:	11c016c4 	addi	r7,r2,91
81116540:	4209883a 	add	r4,r8,r8
81116544:	003e9606 	br	81115fa0 <__reset+0xfb0f5fa0>
81116548:	3804d1ba 	srli	r2,r7,6
8111654c:	11400e44 	addi	r5,r2,57
81116550:	10c00e04 	addi	r3,r2,56
81116554:	294b883a 	add	r5,r5,r5
81116558:	003fbc06 	br	8111644c <__reset+0xfb0f644c>
8111655c:	84ff5926 	beq	r16,r19,811162c4 <__reset+0xfb0f62c4>
81116560:	00a04534 	movhi	r2,33044
81116564:	1094ab04 	addi	r2,r2,21164
81116568:	14000217 	ldw	r16,8(r2)
8111656c:	00bfff04 	movi	r2,-4
81116570:	80c00117 	ldw	r3,4(r16)
81116574:	1886703a 	and	r3,r3,r2
81116578:	003f9106 	br	811163c0 <__reset+0xfb0f63c0>
8111657c:	60800217 	ldw	r2,8(r12)
81116580:	213fffc4 	addi	r4,r4,-1
81116584:	1300651e 	bne	r2,r12,8111671c <_malloc_r+0x7fc>
81116588:	208000cc 	andi	r2,r4,3
8111658c:	633ffe04 	addi	r12,r12,-8
81116590:	103ffa1e 	bne	r2,zero,8111657c <__reset+0xfb0f657c>
81116594:	98800117 	ldw	r2,4(r19)
81116598:	0146303a 	nor	r3,zero,r5
8111659c:	1884703a 	and	r2,r3,r2
811165a0:	98800115 	stw	r2,4(r19)
811165a4:	294b883a 	add	r5,r5,r5
811165a8:	117f2836 	bltu	r2,r5,8111624c <__reset+0xfb0f624c>
811165ac:	283f2726 	beq	r5,zero,8111624c <__reset+0xfb0f624c>
811165b0:	2886703a 	and	r3,r5,r2
811165b4:	5809883a 	mov	r4,r11
811165b8:	183ec31e 	bne	r3,zero,811160c8 <__reset+0xfb0f60c8>
811165bc:	294b883a 	add	r5,r5,r5
811165c0:	2886703a 	and	r3,r5,r2
811165c4:	21000104 	addi	r4,r4,4
811165c8:	183ffc26 	beq	r3,zero,811165bc <__reset+0xfb0f65bc>
811165cc:	003ebe06 	br	811160c8 <__reset+0xfb0f60c8>
811165d0:	00c05504 	movi	r3,340
811165d4:	18801236 	bltu	r3,r2,81116620 <_malloc_r+0x700>
811165d8:	8804d3fa 	srli	r2,r17,15
811165dc:	12001e04 	addi	r8,r2,120
811165e0:	11c01dc4 	addi	r7,r2,119
811165e4:	4209883a 	add	r4,r8,r8
811165e8:	003e6d06 	br	81115fa0 <__reset+0xfb0f5fa0>
811165ec:	00c40004 	movi	r3,4096
811165f0:	003f4606 	br	8111630c <__reset+0xfb0f630c>
811165f4:	00800044 	movi	r2,1
811165f8:	a0800115 	stw	r2,4(r20)
811165fc:	003f7406 	br	811163d0 <__reset+0xfb0f63d0>
81116600:	1805d0ba 	srai	r2,r3,2
81116604:	01c00044 	movi	r7,1
81116608:	30c00117 	ldw	r3,4(r6)
8111660c:	388e983a 	sll	r7,r7,r2
81116610:	2805883a 	mov	r2,r5
81116614:	38c6b03a 	or	r3,r7,r3
81116618:	30c00115 	stw	r3,4(r6)
8111661c:	003f9b06 	br	8111648c <__reset+0xfb0f648c>
81116620:	00c15504 	movi	r3,1364
81116624:	18801a36 	bltu	r3,r2,81116690 <_malloc_r+0x770>
81116628:	8804d4ba 	srli	r2,r17,18
8111662c:	12001f44 	addi	r8,r2,125
81116630:	11c01f04 	addi	r7,r2,124
81116634:	4209883a 	add	r4,r8,r8
81116638:	003e5906 	br	81115fa0 <__reset+0xfb0f5fa0>
8111663c:	ad400404 	addi	r21,r21,16
81116640:	003f1706 	br	811162a0 <__reset+0xfb0f62a0>
81116644:	00c01504 	movi	r3,84
81116648:	18802336 	bltu	r3,r2,811166d8 <_malloc_r+0x7b8>
8111664c:	3804d33a 	srli	r2,r7,12
81116650:	11401bc4 	addi	r5,r2,111
81116654:	10c01b84 	addi	r3,r2,110
81116658:	294b883a 	add	r5,r5,r5
8111665c:	003f7b06 	br	8111644c <__reset+0xfb0f644c>
81116660:	9c000217 	ldw	r16,8(r19)
81116664:	00bfff04 	movi	r2,-4
81116668:	80c00117 	ldw	r3,4(r16)
8111666c:	1886703a 	and	r3,r3,r2
81116670:	003f5306 	br	811163c0 <__reset+0xfb0f63c0>
81116674:	3083ffcc 	andi	r2,r6,4095
81116678:	103f181e 	bne	r2,zero,811162dc <__reset+0xfb0f62dc>
8111667c:	99000217 	ldw	r4,8(r19)
81116680:	b545883a 	add	r2,r22,r21
81116684:	10800054 	ori	r2,r2,1
81116688:	20800115 	stw	r2,4(r4)
8111668c:	003f3e06 	br	81116388 <__reset+0xfb0f6388>
81116690:	01003f84 	movi	r4,254
81116694:	02001fc4 	movi	r8,127
81116698:	01c01f84 	movi	r7,126
8111669c:	003e4006 	br	81115fa0 <__reset+0xfb0f5fa0>
811166a0:	00a04534 	movhi	r2,33044
811166a4:	109aee04 	addi	r2,r2,27576
811166a8:	15000015 	stw	r20,0(r2)
811166ac:	003f1106 	br	811162f4 <__reset+0xfb0f62f4>
811166b0:	00800044 	movi	r2,1
811166b4:	002b883a 	mov	r21,zero
811166b8:	003f1f06 	br	81116338 <__reset+0xfb0f6338>
811166bc:	81400204 	addi	r5,r16,8
811166c0:	9009883a 	mov	r4,r18
811166c4:	111f9940 	call	8111f994 <_free_r>
811166c8:	00a04534 	movhi	r2,33044
811166cc:	109bf504 	addi	r2,r2,28628
811166d0:	10c00017 	ldw	r3,0(r2)
811166d4:	003f2c06 	br	81116388 <__reset+0xfb0f6388>
811166d8:	00c05504 	movi	r3,340
811166dc:	18800536 	bltu	r3,r2,811166f4 <_malloc_r+0x7d4>
811166e0:	3804d3fa 	srli	r2,r7,15
811166e4:	11401e04 	addi	r5,r2,120
811166e8:	10c01dc4 	addi	r3,r2,119
811166ec:	294b883a 	add	r5,r5,r5
811166f0:	003f5606 	br	8111644c <__reset+0xfb0f644c>
811166f4:	00c15504 	movi	r3,1364
811166f8:	18800536 	bltu	r3,r2,81116710 <_malloc_r+0x7f0>
811166fc:	3804d4ba 	srli	r2,r7,18
81116700:	11401f44 	addi	r5,r2,125
81116704:	10c01f04 	addi	r3,r2,124
81116708:	294b883a 	add	r5,r5,r5
8111670c:	003f4f06 	br	8111644c <__reset+0xfb0f644c>
81116710:	01403f84 	movi	r5,254
81116714:	00c01f84 	movi	r3,126
81116718:	003f4c06 	br	8111644c <__reset+0xfb0f644c>
8111671c:	98800117 	ldw	r2,4(r19)
81116720:	003fa006 	br	811165a4 <__reset+0xfb0f65a4>
81116724:	8808d0fa 	srli	r4,r17,3
81116728:	20800044 	addi	r2,r4,1
8111672c:	1085883a 	add	r2,r2,r2
81116730:	003e9006 	br	81116174 <__reset+0xfb0f6174>

81116734 <memcpy>:
81116734:	defffd04 	addi	sp,sp,-12
81116738:	de00012e 	bgeu	sp,et,81116740 <memcpy+0xc>
8111673c:	003b68fa 	trap	3
81116740:	00c003c4 	movi	r3,15
81116744:	dfc00215 	stw	ra,8(sp)
81116748:	dc400115 	stw	r17,4(sp)
8111674c:	dc000015 	stw	r16,0(sp)
81116750:	2005883a 	mov	r2,r4
81116754:	1980452e 	bgeu	r3,r6,8111686c <memcpy+0x138>
81116758:	2906b03a 	or	r3,r5,r4
8111675c:	18c000cc 	andi	r3,r3,3
81116760:	1800441e 	bne	r3,zero,81116874 <memcpy+0x140>
81116764:	347ffc04 	addi	r17,r6,-16
81116768:	8822d13a 	srli	r17,r17,4
8111676c:	28c00104 	addi	r3,r5,4
81116770:	23400104 	addi	r13,r4,4
81116774:	8820913a 	slli	r16,r17,4
81116778:	2b000204 	addi	r12,r5,8
8111677c:	22c00204 	addi	r11,r4,8
81116780:	84000504 	addi	r16,r16,20
81116784:	2a800304 	addi	r10,r5,12
81116788:	22400304 	addi	r9,r4,12
8111678c:	2c21883a 	add	r16,r5,r16
81116790:	2811883a 	mov	r8,r5
81116794:	200f883a 	mov	r7,r4
81116798:	41000017 	ldw	r4,0(r8)
8111679c:	1fc00017 	ldw	ra,0(r3)
811167a0:	63c00017 	ldw	r15,0(r12)
811167a4:	39000015 	stw	r4,0(r7)
811167a8:	53800017 	ldw	r14,0(r10)
811167ac:	6fc00015 	stw	ra,0(r13)
811167b0:	5bc00015 	stw	r15,0(r11)
811167b4:	4b800015 	stw	r14,0(r9)
811167b8:	18c00404 	addi	r3,r3,16
811167bc:	39c00404 	addi	r7,r7,16
811167c0:	42000404 	addi	r8,r8,16
811167c4:	6b400404 	addi	r13,r13,16
811167c8:	63000404 	addi	r12,r12,16
811167cc:	5ac00404 	addi	r11,r11,16
811167d0:	52800404 	addi	r10,r10,16
811167d4:	4a400404 	addi	r9,r9,16
811167d8:	1c3fef1e 	bne	r3,r16,81116798 <__reset+0xfb0f6798>
811167dc:	89c00044 	addi	r7,r17,1
811167e0:	380e913a 	slli	r7,r7,4
811167e4:	310003cc 	andi	r4,r6,15
811167e8:	02c000c4 	movi	r11,3
811167ec:	11c7883a 	add	r3,r2,r7
811167f0:	29cb883a 	add	r5,r5,r7
811167f4:	5900212e 	bgeu	r11,r4,8111687c <memcpy+0x148>
811167f8:	1813883a 	mov	r9,r3
811167fc:	2811883a 	mov	r8,r5
81116800:	200f883a 	mov	r7,r4
81116804:	42800017 	ldw	r10,0(r8)
81116808:	4a400104 	addi	r9,r9,4
8111680c:	39ffff04 	addi	r7,r7,-4
81116810:	4abfff15 	stw	r10,-4(r9)
81116814:	42000104 	addi	r8,r8,4
81116818:	59fffa36 	bltu	r11,r7,81116804 <__reset+0xfb0f6804>
8111681c:	213fff04 	addi	r4,r4,-4
81116820:	2008d0ba 	srli	r4,r4,2
81116824:	318000cc 	andi	r6,r6,3
81116828:	21000044 	addi	r4,r4,1
8111682c:	2109883a 	add	r4,r4,r4
81116830:	2109883a 	add	r4,r4,r4
81116834:	1907883a 	add	r3,r3,r4
81116838:	290b883a 	add	r5,r5,r4
8111683c:	30000626 	beq	r6,zero,81116858 <memcpy+0x124>
81116840:	198d883a 	add	r6,r3,r6
81116844:	29c00003 	ldbu	r7,0(r5)
81116848:	18c00044 	addi	r3,r3,1
8111684c:	29400044 	addi	r5,r5,1
81116850:	19ffffc5 	stb	r7,-1(r3)
81116854:	19bffb1e 	bne	r3,r6,81116844 <__reset+0xfb0f6844>
81116858:	dfc00217 	ldw	ra,8(sp)
8111685c:	dc400117 	ldw	r17,4(sp)
81116860:	dc000017 	ldw	r16,0(sp)
81116864:	dec00304 	addi	sp,sp,12
81116868:	f800283a 	ret
8111686c:	2007883a 	mov	r3,r4
81116870:	003ff206 	br	8111683c <__reset+0xfb0f683c>
81116874:	2007883a 	mov	r3,r4
81116878:	003ff106 	br	81116840 <__reset+0xfb0f6840>
8111687c:	200d883a 	mov	r6,r4
81116880:	003fee06 	br	8111683c <__reset+0xfb0f683c>

81116884 <memset>:
81116884:	20c000cc 	andi	r3,r4,3
81116888:	2005883a 	mov	r2,r4
8111688c:	18004426 	beq	r3,zero,811169a0 <memset+0x11c>
81116890:	31ffffc4 	addi	r7,r6,-1
81116894:	30004026 	beq	r6,zero,81116998 <memset+0x114>
81116898:	2813883a 	mov	r9,r5
8111689c:	200d883a 	mov	r6,r4
811168a0:	2007883a 	mov	r3,r4
811168a4:	00000406 	br	811168b8 <memset+0x34>
811168a8:	3a3fffc4 	addi	r8,r7,-1
811168ac:	31800044 	addi	r6,r6,1
811168b0:	38003926 	beq	r7,zero,81116998 <memset+0x114>
811168b4:	400f883a 	mov	r7,r8
811168b8:	18c00044 	addi	r3,r3,1
811168bc:	32400005 	stb	r9,0(r6)
811168c0:	1a0000cc 	andi	r8,r3,3
811168c4:	403ff81e 	bne	r8,zero,811168a8 <__reset+0xfb0f68a8>
811168c8:	010000c4 	movi	r4,3
811168cc:	21c02d2e 	bgeu	r4,r7,81116984 <memset+0x100>
811168d0:	29003fcc 	andi	r4,r5,255
811168d4:	200c923a 	slli	r6,r4,8
811168d8:	3108b03a 	or	r4,r6,r4
811168dc:	200c943a 	slli	r6,r4,16
811168e0:	218cb03a 	or	r6,r4,r6
811168e4:	010003c4 	movi	r4,15
811168e8:	21c0182e 	bgeu	r4,r7,8111694c <memset+0xc8>
811168ec:	3b3ffc04 	addi	r12,r7,-16
811168f0:	6018d13a 	srli	r12,r12,4
811168f4:	1a000104 	addi	r8,r3,4
811168f8:	1ac00204 	addi	r11,r3,8
811168fc:	6008913a 	slli	r4,r12,4
81116900:	1a800304 	addi	r10,r3,12
81116904:	1813883a 	mov	r9,r3
81116908:	21000504 	addi	r4,r4,20
8111690c:	1909883a 	add	r4,r3,r4
81116910:	49800015 	stw	r6,0(r9)
81116914:	41800015 	stw	r6,0(r8)
81116918:	59800015 	stw	r6,0(r11)
8111691c:	51800015 	stw	r6,0(r10)
81116920:	42000404 	addi	r8,r8,16
81116924:	4a400404 	addi	r9,r9,16
81116928:	5ac00404 	addi	r11,r11,16
8111692c:	52800404 	addi	r10,r10,16
81116930:	413ff71e 	bne	r8,r4,81116910 <__reset+0xfb0f6910>
81116934:	63000044 	addi	r12,r12,1
81116938:	6018913a 	slli	r12,r12,4
8111693c:	39c003cc 	andi	r7,r7,15
81116940:	010000c4 	movi	r4,3
81116944:	1b07883a 	add	r3,r3,r12
81116948:	21c00e2e 	bgeu	r4,r7,81116984 <memset+0x100>
8111694c:	1813883a 	mov	r9,r3
81116950:	3811883a 	mov	r8,r7
81116954:	010000c4 	movi	r4,3
81116958:	49800015 	stw	r6,0(r9)
8111695c:	423fff04 	addi	r8,r8,-4
81116960:	4a400104 	addi	r9,r9,4
81116964:	223ffc36 	bltu	r4,r8,81116958 <__reset+0xfb0f6958>
81116968:	393fff04 	addi	r4,r7,-4
8111696c:	2008d0ba 	srli	r4,r4,2
81116970:	39c000cc 	andi	r7,r7,3
81116974:	21000044 	addi	r4,r4,1
81116978:	2109883a 	add	r4,r4,r4
8111697c:	2109883a 	add	r4,r4,r4
81116980:	1907883a 	add	r3,r3,r4
81116984:	38000526 	beq	r7,zero,8111699c <memset+0x118>
81116988:	19cf883a 	add	r7,r3,r7
8111698c:	19400005 	stb	r5,0(r3)
81116990:	18c00044 	addi	r3,r3,1
81116994:	38fffd1e 	bne	r7,r3,8111698c <__reset+0xfb0f698c>
81116998:	f800283a 	ret
8111699c:	f800283a 	ret
811169a0:	2007883a 	mov	r3,r4
811169a4:	300f883a 	mov	r7,r6
811169a8:	003fc706 	br	811168c8 <__reset+0xfb0f68c8>

811169ac <_open_r>:
811169ac:	defffd04 	addi	sp,sp,-12
811169b0:	de00012e 	bgeu	sp,et,811169b8 <_open_r+0xc>
811169b4:	003b68fa 	trap	3
811169b8:	2805883a 	mov	r2,r5
811169bc:	dc000015 	stw	r16,0(sp)
811169c0:	04204534 	movhi	r16,33044
811169c4:	dc400115 	stw	r17,4(sp)
811169c8:	300b883a 	mov	r5,r6
811169cc:	841b5004 	addi	r16,r16,27968
811169d0:	2023883a 	mov	r17,r4
811169d4:	380d883a 	mov	r6,r7
811169d8:	1009883a 	mov	r4,r2
811169dc:	dfc00215 	stw	ra,8(sp)
811169e0:	80000015 	stw	zero,0(r16)
811169e4:	112c39c0 	call	8112c39c <open>
811169e8:	00ffffc4 	movi	r3,-1
811169ec:	10c00526 	beq	r2,r3,81116a04 <_open_r+0x58>
811169f0:	dfc00217 	ldw	ra,8(sp)
811169f4:	dc400117 	ldw	r17,4(sp)
811169f8:	dc000017 	ldw	r16,0(sp)
811169fc:	dec00304 	addi	sp,sp,12
81116a00:	f800283a 	ret
81116a04:	80c00017 	ldw	r3,0(r16)
81116a08:	183ff926 	beq	r3,zero,811169f0 <__reset+0xfb0f69f0>
81116a0c:	88c00015 	stw	r3,0(r17)
81116a10:	003ff706 	br	811169f0 <__reset+0xfb0f69f0>

81116a14 <_printf_r>:
81116a14:	defffd04 	addi	sp,sp,-12
81116a18:	2805883a 	mov	r2,r5
81116a1c:	de00012e 	bgeu	sp,et,81116a24 <_printf_r+0x10>
81116a20:	003b68fa 	trap	3
81116a24:	dfc00015 	stw	ra,0(sp)
81116a28:	d9800115 	stw	r6,4(sp)
81116a2c:	d9c00215 	stw	r7,8(sp)
81116a30:	21400217 	ldw	r5,8(r4)
81116a34:	d9c00104 	addi	r7,sp,4
81116a38:	100d883a 	mov	r6,r2
81116a3c:	11197400 	call	81119740 <___vfprintf_internal_r>
81116a40:	dfc00017 	ldw	ra,0(sp)
81116a44:	dec00304 	addi	sp,sp,12
81116a48:	f800283a 	ret

81116a4c <printf>:
81116a4c:	defffc04 	addi	sp,sp,-16
81116a50:	de00012e 	bgeu	sp,et,81116a58 <printf+0xc>
81116a54:	003b68fa 	trap	3
81116a58:	dfc00015 	stw	ra,0(sp)
81116a5c:	d9400115 	stw	r5,4(sp)
81116a60:	d9800215 	stw	r6,8(sp)
81116a64:	d9c00315 	stw	r7,12(sp)
81116a68:	00a04534 	movhi	r2,33044
81116a6c:	109aed04 	addi	r2,r2,27572
81116a70:	10800017 	ldw	r2,0(r2)
81116a74:	200b883a 	mov	r5,r4
81116a78:	d9800104 	addi	r6,sp,4
81116a7c:	11000217 	ldw	r4,8(r2)
81116a80:	111b9400 	call	8111b940 <__vfprintf_internal>
81116a84:	dfc00017 	ldw	ra,0(sp)
81116a88:	dec00404 	addi	sp,sp,16
81116a8c:	f800283a 	ret

81116a90 <_putc_r>:
81116a90:	defffc04 	addi	sp,sp,-16
81116a94:	de00012e 	bgeu	sp,et,81116a9c <_putc_r+0xc>
81116a98:	003b68fa 	trap	3
81116a9c:	dc000215 	stw	r16,8(sp)
81116aa0:	dfc00315 	stw	ra,12(sp)
81116aa4:	2021883a 	mov	r16,r4
81116aa8:	20000226 	beq	r4,zero,81116ab4 <_putc_r+0x24>
81116aac:	20800e17 	ldw	r2,56(r4)
81116ab0:	10001b26 	beq	r2,zero,81116b20 <_putc_r+0x90>
81116ab4:	30800217 	ldw	r2,8(r6)
81116ab8:	10bfffc4 	addi	r2,r2,-1
81116abc:	30800215 	stw	r2,8(r6)
81116ac0:	10000a16 	blt	r2,zero,81116aec <_putc_r+0x5c>
81116ac4:	30800017 	ldw	r2,0(r6)
81116ac8:	11400005 	stb	r5,0(r2)
81116acc:	30800017 	ldw	r2,0(r6)
81116ad0:	10c00044 	addi	r3,r2,1
81116ad4:	30c00015 	stw	r3,0(r6)
81116ad8:	10800003 	ldbu	r2,0(r2)
81116adc:	dfc00317 	ldw	ra,12(sp)
81116ae0:	dc000217 	ldw	r16,8(sp)
81116ae4:	dec00404 	addi	sp,sp,16
81116ae8:	f800283a 	ret
81116aec:	30c00617 	ldw	r3,24(r6)
81116af0:	10c00616 	blt	r2,r3,81116b0c <_putc_r+0x7c>
81116af4:	30800017 	ldw	r2,0(r6)
81116af8:	00c00284 	movi	r3,10
81116afc:	11400005 	stb	r5,0(r2)
81116b00:	30800017 	ldw	r2,0(r6)
81116b04:	11400003 	ldbu	r5,0(r2)
81116b08:	28fff11e 	bne	r5,r3,81116ad0 <__reset+0xfb0f6ad0>
81116b0c:	8009883a 	mov	r4,r16
81116b10:	dfc00317 	ldw	ra,12(sp)
81116b14:	dc000217 	ldw	r16,8(sp)
81116b18:	dec00404 	addi	sp,sp,16
81116b1c:	111d2c41 	jmpi	8111d2c4 <__swbuf_r>
81116b20:	d9400015 	stw	r5,0(sp)
81116b24:	d9800115 	stw	r6,4(sp)
81116b28:	111f4fc0 	call	8111f4fc <__sinit>
81116b2c:	d9800117 	ldw	r6,4(sp)
81116b30:	d9400017 	ldw	r5,0(sp)
81116b34:	003fdf06 	br	81116ab4 <__reset+0xfb0f6ab4>

81116b38 <putc>:
81116b38:	00a04534 	movhi	r2,33044
81116b3c:	defffc04 	addi	sp,sp,-16
81116b40:	109aed04 	addi	r2,r2,27572
81116b44:	de00012e 	bgeu	sp,et,81116b4c <putc+0x14>
81116b48:	003b68fa 	trap	3
81116b4c:	dc000115 	stw	r16,4(sp)
81116b50:	14000017 	ldw	r16,0(r2)
81116b54:	dc400215 	stw	r17,8(sp)
81116b58:	dfc00315 	stw	ra,12(sp)
81116b5c:	2023883a 	mov	r17,r4
81116b60:	80000226 	beq	r16,zero,81116b6c <putc+0x34>
81116b64:	80800e17 	ldw	r2,56(r16)
81116b68:	10001a26 	beq	r2,zero,81116bd4 <putc+0x9c>
81116b6c:	28800217 	ldw	r2,8(r5)
81116b70:	10bfffc4 	addi	r2,r2,-1
81116b74:	28800215 	stw	r2,8(r5)
81116b78:	10000b16 	blt	r2,zero,81116ba8 <putc+0x70>
81116b7c:	28800017 	ldw	r2,0(r5)
81116b80:	14400005 	stb	r17,0(r2)
81116b84:	28800017 	ldw	r2,0(r5)
81116b88:	10c00044 	addi	r3,r2,1
81116b8c:	28c00015 	stw	r3,0(r5)
81116b90:	10800003 	ldbu	r2,0(r2)
81116b94:	dfc00317 	ldw	ra,12(sp)
81116b98:	dc400217 	ldw	r17,8(sp)
81116b9c:	dc000117 	ldw	r16,4(sp)
81116ba0:	dec00404 	addi	sp,sp,16
81116ba4:	f800283a 	ret
81116ba8:	28c00617 	ldw	r3,24(r5)
81116bac:	10c00e16 	blt	r2,r3,81116be8 <putc+0xb0>
81116bb0:	28800017 	ldw	r2,0(r5)
81116bb4:	01000284 	movi	r4,10
81116bb8:	14400005 	stb	r17,0(r2)
81116bbc:	28800017 	ldw	r2,0(r5)
81116bc0:	10c00003 	ldbu	r3,0(r2)
81116bc4:	193ff01e 	bne	r3,r4,81116b88 <__reset+0xfb0f6b88>
81116bc8:	280d883a 	mov	r6,r5
81116bcc:	180b883a 	mov	r5,r3
81116bd0:	00000706 	br	81116bf0 <putc+0xb8>
81116bd4:	8009883a 	mov	r4,r16
81116bd8:	d9400015 	stw	r5,0(sp)
81116bdc:	111f4fc0 	call	8111f4fc <__sinit>
81116be0:	d9400017 	ldw	r5,0(sp)
81116be4:	003fe106 	br	81116b6c <__reset+0xfb0f6b6c>
81116be8:	280d883a 	mov	r6,r5
81116bec:	880b883a 	mov	r5,r17
81116bf0:	8009883a 	mov	r4,r16
81116bf4:	dfc00317 	ldw	ra,12(sp)
81116bf8:	dc400217 	ldw	r17,8(sp)
81116bfc:	dc000117 	ldw	r16,4(sp)
81116c00:	dec00404 	addi	sp,sp,16
81116c04:	111d2c41 	jmpi	8111d2c4 <__swbuf_r>

81116c08 <_puts_r>:
81116c08:	defff604 	addi	sp,sp,-40
81116c0c:	de00012e 	bgeu	sp,et,81116c14 <_puts_r+0xc>
81116c10:	003b68fa 	trap	3
81116c14:	dc000715 	stw	r16,28(sp)
81116c18:	2021883a 	mov	r16,r4
81116c1c:	2809883a 	mov	r4,r5
81116c20:	dc400815 	stw	r17,32(sp)
81116c24:	dfc00915 	stw	ra,36(sp)
81116c28:	2823883a 	mov	r17,r5
81116c2c:	11172280 	call	81117228 <strlen>
81116c30:	10c00044 	addi	r3,r2,1
81116c34:	d8800115 	stw	r2,4(sp)
81116c38:	00a04534 	movhi	r2,33044
81116c3c:	10911404 	addi	r2,r2,17488
81116c40:	d8800215 	stw	r2,8(sp)
81116c44:	00800044 	movi	r2,1
81116c48:	d8800315 	stw	r2,12(sp)
81116c4c:	00800084 	movi	r2,2
81116c50:	dc400015 	stw	r17,0(sp)
81116c54:	d8c00615 	stw	r3,24(sp)
81116c58:	dec00415 	stw	sp,16(sp)
81116c5c:	d8800515 	stw	r2,20(sp)
81116c60:	80000226 	beq	r16,zero,81116c6c <_puts_r+0x64>
81116c64:	80800e17 	ldw	r2,56(r16)
81116c68:	10001426 	beq	r2,zero,81116cbc <_puts_r+0xb4>
81116c6c:	81400217 	ldw	r5,8(r16)
81116c70:	2880030b 	ldhu	r2,12(r5)
81116c74:	10c8000c 	andi	r3,r2,8192
81116c78:	1800061e 	bne	r3,zero,81116c94 <_puts_r+0x8c>
81116c7c:	29001917 	ldw	r4,100(r5)
81116c80:	00f7ffc4 	movi	r3,-8193
81116c84:	10880014 	ori	r2,r2,8192
81116c88:	20c6703a 	and	r3,r4,r3
81116c8c:	2880030d 	sth	r2,12(r5)
81116c90:	28c01915 	stw	r3,100(r5)
81116c94:	d9800404 	addi	r6,sp,16
81116c98:	8009883a 	mov	r4,r16
81116c9c:	111fcac0 	call	8111fcac <__sfvwrite_r>
81116ca0:	1000091e 	bne	r2,zero,81116cc8 <_puts_r+0xc0>
81116ca4:	00800284 	movi	r2,10
81116ca8:	dfc00917 	ldw	ra,36(sp)
81116cac:	dc400817 	ldw	r17,32(sp)
81116cb0:	dc000717 	ldw	r16,28(sp)
81116cb4:	dec00a04 	addi	sp,sp,40
81116cb8:	f800283a 	ret
81116cbc:	8009883a 	mov	r4,r16
81116cc0:	111f4fc0 	call	8111f4fc <__sinit>
81116cc4:	003fe906 	br	81116c6c <__reset+0xfb0f6c6c>
81116cc8:	00bfffc4 	movi	r2,-1
81116ccc:	003ff606 	br	81116ca8 <__reset+0xfb0f6ca8>

81116cd0 <puts>:
81116cd0:	00a04534 	movhi	r2,33044
81116cd4:	109aed04 	addi	r2,r2,27572
81116cd8:	200b883a 	mov	r5,r4
81116cdc:	11000017 	ldw	r4,0(r2)
81116ce0:	1116c081 	jmpi	81116c08 <_puts_r>

81116ce4 <lflush>:
81116ce4:	2080030b 	ldhu	r2,12(r4)
81116ce8:	00c00244 	movi	r3,9
81116cec:	1080024c 	andi	r2,r2,9
81116cf0:	10c00226 	beq	r2,r3,81116cfc <lflush+0x18>
81116cf4:	0005883a 	mov	r2,zero
81116cf8:	f800283a 	ret
81116cfc:	111f1641 	jmpi	8111f164 <fflush>

81116d00 <__srefill_r>:
81116d00:	defffc04 	addi	sp,sp,-16
81116d04:	de00012e 	bgeu	sp,et,81116d0c <__srefill_r+0xc>
81116d08:	003b68fa 	trap	3
81116d0c:	dc400115 	stw	r17,4(sp)
81116d10:	dc000015 	stw	r16,0(sp)
81116d14:	dfc00315 	stw	ra,12(sp)
81116d18:	dc800215 	stw	r18,8(sp)
81116d1c:	2023883a 	mov	r17,r4
81116d20:	2821883a 	mov	r16,r5
81116d24:	20000226 	beq	r4,zero,81116d30 <__srefill_r+0x30>
81116d28:	20800e17 	ldw	r2,56(r4)
81116d2c:	10003c26 	beq	r2,zero,81116e20 <__srefill_r+0x120>
81116d30:	80c0030b 	ldhu	r3,12(r16)
81116d34:	1908000c 	andi	r4,r3,8192
81116d38:	1805883a 	mov	r2,r3
81116d3c:	2000071e 	bne	r4,zero,81116d5c <__srefill_r+0x5c>
81116d40:	81001917 	ldw	r4,100(r16)
81116d44:	18880014 	ori	r2,r3,8192
81116d48:	00f7ffc4 	movi	r3,-8193
81116d4c:	20c8703a 	and	r4,r4,r3
81116d50:	8080030d 	sth	r2,12(r16)
81116d54:	1007883a 	mov	r3,r2
81116d58:	81001915 	stw	r4,100(r16)
81116d5c:	80000115 	stw	zero,4(r16)
81116d60:	1100080c 	andi	r4,r2,32
81116d64:	2000571e 	bne	r4,zero,81116ec4 <__srefill_r+0x1c4>
81116d68:	1100010c 	andi	r4,r2,4
81116d6c:	20001f26 	beq	r4,zero,81116dec <__srefill_r+0xec>
81116d70:	81400c17 	ldw	r5,48(r16)
81116d74:	28000826 	beq	r5,zero,81116d98 <__srefill_r+0x98>
81116d78:	80801004 	addi	r2,r16,64
81116d7c:	28800226 	beq	r5,r2,81116d88 <__srefill_r+0x88>
81116d80:	8809883a 	mov	r4,r17
81116d84:	111f9940 	call	8111f994 <_free_r>
81116d88:	80800f17 	ldw	r2,60(r16)
81116d8c:	80000c15 	stw	zero,48(r16)
81116d90:	80800115 	stw	r2,4(r16)
81116d94:	1000391e 	bne	r2,zero,81116e7c <__srefill_r+0x17c>
81116d98:	80800417 	ldw	r2,16(r16)
81116d9c:	10004b26 	beq	r2,zero,81116ecc <__srefill_r+0x1cc>
81116da0:	8480030b 	ldhu	r18,12(r16)
81116da4:	908000cc 	andi	r2,r18,3
81116da8:	10001f1e 	bne	r2,zero,81116e28 <__srefill_r+0x128>
81116dac:	81800417 	ldw	r6,16(r16)
81116db0:	80800817 	ldw	r2,32(r16)
81116db4:	81c00517 	ldw	r7,20(r16)
81116db8:	81400717 	ldw	r5,28(r16)
81116dbc:	81800015 	stw	r6,0(r16)
81116dc0:	8809883a 	mov	r4,r17
81116dc4:	103ee83a 	callr	r2
81116dc8:	80800115 	stw	r2,4(r16)
81116dcc:	00800e0e 	bge	zero,r2,81116e08 <__srefill_r+0x108>
81116dd0:	0005883a 	mov	r2,zero
81116dd4:	dfc00317 	ldw	ra,12(sp)
81116dd8:	dc800217 	ldw	r18,8(sp)
81116ddc:	dc400117 	ldw	r17,4(sp)
81116de0:	dc000017 	ldw	r16,0(sp)
81116de4:	dec00404 	addi	sp,sp,16
81116de8:	f800283a 	ret
81116dec:	1100040c 	andi	r4,r2,16
81116df0:	20003026 	beq	r4,zero,81116eb4 <__srefill_r+0x1b4>
81116df4:	1080020c 	andi	r2,r2,8
81116df8:	1000241e 	bne	r2,zero,81116e8c <__srefill_r+0x18c>
81116dfc:	18c00114 	ori	r3,r3,4
81116e00:	80c0030d 	sth	r3,12(r16)
81116e04:	003fe406 	br	81116d98 <__reset+0xfb0f6d98>
81116e08:	80c0030b 	ldhu	r3,12(r16)
81116e0c:	1000161e 	bne	r2,zero,81116e68 <__srefill_r+0x168>
81116e10:	18c00814 	ori	r3,r3,32
81116e14:	00bfffc4 	movi	r2,-1
81116e18:	80c0030d 	sth	r3,12(r16)
81116e1c:	003fed06 	br	81116dd4 <__reset+0xfb0f6dd4>
81116e20:	111f4fc0 	call	8111f4fc <__sinit>
81116e24:	003fc206 	br	81116d30 <__reset+0xfb0f6d30>
81116e28:	00a04534 	movhi	r2,33044
81116e2c:	109aec04 	addi	r2,r2,27568
81116e30:	11000017 	ldw	r4,0(r2)
81116e34:	01604474 	movhi	r5,33041
81116e38:	00800044 	movi	r2,1
81116e3c:	295b3904 	addi	r5,r5,27876
81116e40:	8080030d 	sth	r2,12(r16)
81116e44:	11201700 	call	81120170 <_fwalk>
81116e48:	00800244 	movi	r2,9
81116e4c:	8480030d 	sth	r18,12(r16)
81116e50:	9480024c 	andi	r18,r18,9
81116e54:	90bfd51e 	bne	r18,r2,81116dac <__reset+0xfb0f6dac>
81116e58:	800b883a 	mov	r5,r16
81116e5c:	8809883a 	mov	r4,r17
81116e60:	111eedc0 	call	8111eedc <__sflush_r>
81116e64:	003fd106 	br	81116dac <__reset+0xfb0f6dac>
81116e68:	18c01014 	ori	r3,r3,64
81116e6c:	80000115 	stw	zero,4(r16)
81116e70:	00bfffc4 	movi	r2,-1
81116e74:	80c0030d 	sth	r3,12(r16)
81116e78:	003fd606 	br	81116dd4 <__reset+0xfb0f6dd4>
81116e7c:	80c00e17 	ldw	r3,56(r16)
81116e80:	0005883a 	mov	r2,zero
81116e84:	80c00015 	stw	r3,0(r16)
81116e88:	003fd206 	br	81116dd4 <__reset+0xfb0f6dd4>
81116e8c:	800b883a 	mov	r5,r16
81116e90:	8809883a 	mov	r4,r17
81116e94:	111f1000 	call	8111f100 <_fflush_r>
81116e98:	10000a1e 	bne	r2,zero,81116ec4 <__srefill_r+0x1c4>
81116e9c:	8080030b 	ldhu	r2,12(r16)
81116ea0:	00fffdc4 	movi	r3,-9
81116ea4:	80000215 	stw	zero,8(r16)
81116ea8:	1886703a 	and	r3,r3,r2
81116eac:	80000615 	stw	zero,24(r16)
81116eb0:	003fd206 	br	81116dfc <__reset+0xfb0f6dfc>
81116eb4:	00800244 	movi	r2,9
81116eb8:	88800015 	stw	r2,0(r17)
81116ebc:	18c01014 	ori	r3,r3,64
81116ec0:	80c0030d 	sth	r3,12(r16)
81116ec4:	00bfffc4 	movi	r2,-1
81116ec8:	003fc206 	br	81116dd4 <__reset+0xfb0f6dd4>
81116ecc:	800b883a 	mov	r5,r16
81116ed0:	8809883a 	mov	r4,r17
81116ed4:	1115d5c0 	call	81115d5c <__smakebuf_r>
81116ed8:	003fb106 	br	81116da0 <__reset+0xfb0f6da0>

81116edc <_sbrk_r>:
81116edc:	defffd04 	addi	sp,sp,-12
81116ee0:	de00012e 	bgeu	sp,et,81116ee8 <_sbrk_r+0xc>
81116ee4:	003b68fa 	trap	3
81116ee8:	dc000015 	stw	r16,0(sp)
81116eec:	04204534 	movhi	r16,33044
81116ef0:	dc400115 	stw	r17,4(sp)
81116ef4:	841b5004 	addi	r16,r16,27968
81116ef8:	2023883a 	mov	r17,r4
81116efc:	2809883a 	mov	r4,r5
81116f00:	dfc00215 	stw	ra,8(sp)
81116f04:	80000015 	stw	zero,0(r16)
81116f08:	112c6ac0 	call	8112c6ac <sbrk>
81116f0c:	00ffffc4 	movi	r3,-1
81116f10:	10c00526 	beq	r2,r3,81116f28 <_sbrk_r+0x4c>
81116f14:	dfc00217 	ldw	ra,8(sp)
81116f18:	dc400117 	ldw	r17,4(sp)
81116f1c:	dc000017 	ldw	r16,0(sp)
81116f20:	dec00304 	addi	sp,sp,12
81116f24:	f800283a 	ret
81116f28:	80c00017 	ldw	r3,0(r16)
81116f2c:	183ff926 	beq	r3,zero,81116f14 <__reset+0xfb0f6f14>
81116f30:	88c00015 	stw	r3,0(r17)
81116f34:	003ff706 	br	81116f14 <__reset+0xfb0f6f14>

81116f38 <scanf>:
81116f38:	defffc04 	addi	sp,sp,-16
81116f3c:	de00012e 	bgeu	sp,et,81116f44 <scanf+0xc>
81116f40:	003b68fa 	trap	3
81116f44:	dfc00015 	stw	ra,0(sp)
81116f48:	d9400115 	stw	r5,4(sp)
81116f4c:	d9800215 	stw	r6,8(sp)
81116f50:	d9c00315 	stw	r7,12(sp)
81116f54:	00a04534 	movhi	r2,33044
81116f58:	109aed04 	addi	r2,r2,27572
81116f5c:	200d883a 	mov	r6,r4
81116f60:	11000017 	ldw	r4,0(r2)
81116f64:	d9c00104 	addi	r7,sp,4
81116f68:	21400117 	ldw	r5,4(r4)
81116f6c:	111d2700 	call	8111d270 <_vfscanf_r>
81116f70:	dfc00017 	ldw	ra,0(sp)
81116f74:	dec00404 	addi	sp,sp,16
81116f78:	f800283a 	ret

81116f7c <_scanf_r>:
81116f7c:	defffd04 	addi	sp,sp,-12
81116f80:	2805883a 	mov	r2,r5
81116f84:	de00012e 	bgeu	sp,et,81116f8c <_scanf_r+0x10>
81116f88:	003b68fa 	trap	3
81116f8c:	dfc00015 	stw	ra,0(sp)
81116f90:	d9800115 	stw	r6,4(sp)
81116f94:	d9c00215 	stw	r7,8(sp)
81116f98:	21400117 	ldw	r5,4(r4)
81116f9c:	d9c00104 	addi	r7,sp,4
81116fa0:	100d883a 	mov	r6,r2
81116fa4:	111d2700 	call	8111d270 <_vfscanf_r>
81116fa8:	dfc00017 	ldw	ra,0(sp)
81116fac:	dec00304 	addi	sp,sp,12
81116fb0:	f800283a 	ret

81116fb4 <_sprintf_r>:
81116fb4:	deffe404 	addi	sp,sp,-112
81116fb8:	2807883a 	mov	r3,r5
81116fbc:	de00012e 	bgeu	sp,et,81116fc4 <_sprintf_r+0x10>
81116fc0:	003b68fa 	trap	3
81116fc4:	dfc01a15 	stw	ra,104(sp)
81116fc8:	d9c01b15 	stw	r7,108(sp)
81116fcc:	00a00034 	movhi	r2,32768
81116fd0:	10bfffc4 	addi	r2,r2,-1
81116fd4:	02008204 	movi	r8,520
81116fd8:	d8800215 	stw	r2,8(sp)
81116fdc:	d8800515 	stw	r2,20(sp)
81116fe0:	d9c01b04 	addi	r7,sp,108
81116fe4:	d80b883a 	mov	r5,sp
81116fe8:	00bfffc4 	movi	r2,-1
81116fec:	d8c00015 	stw	r3,0(sp)
81116ff0:	d8c00415 	stw	r3,16(sp)
81116ff4:	da00030d 	sth	r8,12(sp)
81116ff8:	d880038d 	sth	r2,14(sp)
81116ffc:	11175600 	call	81117560 <___svfprintf_internal_r>
81117000:	d8c00017 	ldw	r3,0(sp)
81117004:	18000005 	stb	zero,0(r3)
81117008:	dfc01a17 	ldw	ra,104(sp)
8111700c:	dec01c04 	addi	sp,sp,112
81117010:	f800283a 	ret

81117014 <sprintf>:
81117014:	deffe304 	addi	sp,sp,-116
81117018:	2007883a 	mov	r3,r4
8111701c:	de00012e 	bgeu	sp,et,81117024 <sprintf+0x10>
81117020:	003b68fa 	trap	3
81117024:	dfc01a15 	stw	ra,104(sp)
81117028:	d9801b15 	stw	r6,108(sp)
8111702c:	d9c01c15 	stw	r7,112(sp)
81117030:	01204534 	movhi	r4,33044
81117034:	211aed04 	addi	r4,r4,27572
81117038:	21000017 	ldw	r4,0(r4)
8111703c:	00a00034 	movhi	r2,32768
81117040:	10bfffc4 	addi	r2,r2,-1
81117044:	280d883a 	mov	r6,r5
81117048:	02008204 	movi	r8,520
8111704c:	d8800215 	stw	r2,8(sp)
81117050:	d8800515 	stw	r2,20(sp)
81117054:	d9c01b04 	addi	r7,sp,108
81117058:	d80b883a 	mov	r5,sp
8111705c:	00bfffc4 	movi	r2,-1
81117060:	d8c00015 	stw	r3,0(sp)
81117064:	d8c00415 	stw	r3,16(sp)
81117068:	da00030d 	sth	r8,12(sp)
8111706c:	d880038d 	sth	r2,14(sp)
81117070:	11175600 	call	81117560 <___svfprintf_internal_r>
81117074:	d8c00017 	ldw	r3,0(sp)
81117078:	18000005 	stb	zero,0(r3)
8111707c:	dfc01a17 	ldw	ra,104(sp)
81117080:	dec01d04 	addi	sp,sp,116
81117084:	f800283a 	ret

81117088 <__sread>:
81117088:	defffe04 	addi	sp,sp,-8
8111708c:	de00012e 	bgeu	sp,et,81117094 <__sread+0xc>
81117090:	003b68fa 	trap	3
81117094:	dc000015 	stw	r16,0(sp)
81117098:	2821883a 	mov	r16,r5
8111709c:	2940038f 	ldh	r5,14(r5)
811170a0:	dfc00115 	stw	ra,4(sp)
811170a4:	11219c00 	call	811219c0 <_read_r>
811170a8:	10000716 	blt	r2,zero,811170c8 <__sread+0x40>
811170ac:	80c01417 	ldw	r3,80(r16)
811170b0:	1887883a 	add	r3,r3,r2
811170b4:	80c01415 	stw	r3,80(r16)
811170b8:	dfc00117 	ldw	ra,4(sp)
811170bc:	dc000017 	ldw	r16,0(sp)
811170c0:	dec00204 	addi	sp,sp,8
811170c4:	f800283a 	ret
811170c8:	80c0030b 	ldhu	r3,12(r16)
811170cc:	18fbffcc 	andi	r3,r3,61439
811170d0:	80c0030d 	sth	r3,12(r16)
811170d4:	dfc00117 	ldw	ra,4(sp)
811170d8:	dc000017 	ldw	r16,0(sp)
811170dc:	dec00204 	addi	sp,sp,8
811170e0:	f800283a 	ret

811170e4 <__seofread>:
811170e4:	0005883a 	mov	r2,zero
811170e8:	f800283a 	ret

811170ec <__swrite>:
811170ec:	defffb04 	addi	sp,sp,-20
811170f0:	de00012e 	bgeu	sp,et,811170f8 <__swrite+0xc>
811170f4:	003b68fa 	trap	3
811170f8:	2880030b 	ldhu	r2,12(r5)
811170fc:	dcc00315 	stw	r19,12(sp)
81117100:	dc800215 	stw	r18,8(sp)
81117104:	dc400115 	stw	r17,4(sp)
81117108:	dc000015 	stw	r16,0(sp)
8111710c:	dfc00415 	stw	ra,16(sp)
81117110:	10c0400c 	andi	r3,r2,256
81117114:	2821883a 	mov	r16,r5
81117118:	2023883a 	mov	r17,r4
8111711c:	3025883a 	mov	r18,r6
81117120:	3827883a 	mov	r19,r7
81117124:	18000526 	beq	r3,zero,8111713c <__swrite+0x50>
81117128:	2940038f 	ldh	r5,14(r5)
8111712c:	01c00084 	movi	r7,2
81117130:	000d883a 	mov	r6,zero
81117134:	11204780 	call	81120478 <_lseek_r>
81117138:	8080030b 	ldhu	r2,12(r16)
8111713c:	8140038f 	ldh	r5,14(r16)
81117140:	10bbffcc 	andi	r2,r2,61439
81117144:	980f883a 	mov	r7,r19
81117148:	900d883a 	mov	r6,r18
8111714c:	8809883a 	mov	r4,r17
81117150:	8080030d 	sth	r2,12(r16)
81117154:	dfc00417 	ldw	ra,16(sp)
81117158:	dcc00317 	ldw	r19,12(sp)
8111715c:	dc800217 	ldw	r18,8(sp)
81117160:	dc400117 	ldw	r17,4(sp)
81117164:	dc000017 	ldw	r16,0(sp)
81117168:	dec00504 	addi	sp,sp,20
8111716c:	111d4241 	jmpi	8111d424 <_write_r>

81117170 <__sseek>:
81117170:	defffe04 	addi	sp,sp,-8
81117174:	de00012e 	bgeu	sp,et,8111717c <__sseek+0xc>
81117178:	003b68fa 	trap	3
8111717c:	dc000015 	stw	r16,0(sp)
81117180:	2821883a 	mov	r16,r5
81117184:	2940038f 	ldh	r5,14(r5)
81117188:	dfc00115 	stw	ra,4(sp)
8111718c:	11204780 	call	81120478 <_lseek_r>
81117190:	00ffffc4 	movi	r3,-1
81117194:	10c00826 	beq	r2,r3,811171b8 <__sseek+0x48>
81117198:	80c0030b 	ldhu	r3,12(r16)
8111719c:	80801415 	stw	r2,80(r16)
811171a0:	18c40014 	ori	r3,r3,4096
811171a4:	80c0030d 	sth	r3,12(r16)
811171a8:	dfc00117 	ldw	ra,4(sp)
811171ac:	dc000017 	ldw	r16,0(sp)
811171b0:	dec00204 	addi	sp,sp,8
811171b4:	f800283a 	ret
811171b8:	80c0030b 	ldhu	r3,12(r16)
811171bc:	18fbffcc 	andi	r3,r3,61439
811171c0:	80c0030d 	sth	r3,12(r16)
811171c4:	dfc00117 	ldw	ra,4(sp)
811171c8:	dc000017 	ldw	r16,0(sp)
811171cc:	dec00204 	addi	sp,sp,8
811171d0:	f800283a 	ret

811171d4 <__sclose>:
811171d4:	2940038f 	ldh	r5,14(r5)
811171d8:	111d5e81 	jmpi	8111d5e8 <_close_r>

811171dc <strcspn>:
811171dc:	21c00007 	ldb	r7,0(r4)
811171e0:	38000f26 	beq	r7,zero,81117220 <strcspn+0x44>
811171e4:	2a000007 	ldb	r8,0(r5)
811171e8:	2005883a 	mov	r2,r4
811171ec:	40000726 	beq	r8,zero,8111720c <strcspn+0x30>
811171f0:	3a000926 	beq	r7,r8,81117218 <strcspn+0x3c>
811171f4:	2807883a 	mov	r3,r5
811171f8:	00000106 	br	81117200 <strcspn+0x24>
811171fc:	31c00626 	beq	r6,r7,81117218 <strcspn+0x3c>
81117200:	18c00044 	addi	r3,r3,1
81117204:	19800007 	ldb	r6,0(r3)
81117208:	303ffc1e 	bne	r6,zero,811171fc <__reset+0xfb0f71fc>
8111720c:	10800044 	addi	r2,r2,1
81117210:	11c00007 	ldb	r7,0(r2)
81117214:	383ff51e 	bne	r7,zero,811171ec <__reset+0xfb0f71ec>
81117218:	1105c83a 	sub	r2,r2,r4
8111721c:	f800283a 	ret
81117220:	0005883a 	mov	r2,zero
81117224:	f800283a 	ret

81117228 <strlen>:
81117228:	208000cc 	andi	r2,r4,3
8111722c:	10002026 	beq	r2,zero,811172b0 <strlen+0x88>
81117230:	20800007 	ldb	r2,0(r4)
81117234:	10002026 	beq	r2,zero,811172b8 <strlen+0x90>
81117238:	2005883a 	mov	r2,r4
8111723c:	00000206 	br	81117248 <strlen+0x20>
81117240:	10c00007 	ldb	r3,0(r2)
81117244:	18001826 	beq	r3,zero,811172a8 <strlen+0x80>
81117248:	10800044 	addi	r2,r2,1
8111724c:	10c000cc 	andi	r3,r2,3
81117250:	183ffb1e 	bne	r3,zero,81117240 <__reset+0xfb0f7240>
81117254:	10c00017 	ldw	r3,0(r2)
81117258:	01ffbff4 	movhi	r7,65279
8111725c:	39ffbfc4 	addi	r7,r7,-257
81117260:	00ca303a 	nor	r5,zero,r3
81117264:	01a02074 	movhi	r6,32897
81117268:	19c7883a 	add	r3,r3,r7
8111726c:	31a02004 	addi	r6,r6,-32640
81117270:	1946703a 	and	r3,r3,r5
81117274:	1986703a 	and	r3,r3,r6
81117278:	1800091e 	bne	r3,zero,811172a0 <strlen+0x78>
8111727c:	10800104 	addi	r2,r2,4
81117280:	10c00017 	ldw	r3,0(r2)
81117284:	19cb883a 	add	r5,r3,r7
81117288:	00c6303a 	nor	r3,zero,r3
8111728c:	28c6703a 	and	r3,r5,r3
81117290:	1986703a 	and	r3,r3,r6
81117294:	183ff926 	beq	r3,zero,8111727c <__reset+0xfb0f727c>
81117298:	00000106 	br	811172a0 <strlen+0x78>
8111729c:	10800044 	addi	r2,r2,1
811172a0:	10c00007 	ldb	r3,0(r2)
811172a4:	183ffd1e 	bne	r3,zero,8111729c <__reset+0xfb0f729c>
811172a8:	1105c83a 	sub	r2,r2,r4
811172ac:	f800283a 	ret
811172b0:	2005883a 	mov	r2,r4
811172b4:	003fe706 	br	81117254 <__reset+0xfb0f7254>
811172b8:	0005883a 	mov	r2,zero
811172bc:	f800283a 	ret

811172c0 <strnlen>:
811172c0:	28000e26 	beq	r5,zero,811172fc <strnlen+0x3c>
811172c4:	20800007 	ldb	r2,0(r4)
811172c8:	10000c26 	beq	r2,zero,811172fc <strnlen+0x3c>
811172cc:	20c00044 	addi	r3,r4,1
811172d0:	214b883a 	add	r5,r4,r5
811172d4:	28c00526 	beq	r5,r3,811172ec <strnlen+0x2c>
811172d8:	19800007 	ldb	r6,0(r3)
811172dc:	19c00044 	addi	r7,r3,1
811172e0:	30000426 	beq	r6,zero,811172f4 <strnlen+0x34>
811172e4:	3807883a 	mov	r3,r7
811172e8:	28fffb1e 	bne	r5,r3,811172d8 <__reset+0xfb0f72d8>
811172ec:	2905c83a 	sub	r2,r5,r4
811172f0:	f800283a 	ret
811172f4:	1905c83a 	sub	r2,r3,r4
811172f8:	f800283a 	ret
811172fc:	0005883a 	mov	r2,zero
81117300:	f800283a 	ret

81117304 <_strtol_r>:
81117304:	00a04534 	movhi	r2,33044
81117308:	defff404 	addi	sp,sp,-48
8111730c:	109aeb04 	addi	r2,r2,27564
81117310:	de00012e 	bgeu	sp,et,81117318 <_strtol_r+0x14>
81117314:	003b68fa 	trap	3
81117318:	dd400715 	stw	r21,28(sp)
8111731c:	15400017 	ldw	r21,0(r2)
81117320:	dd800815 	stw	r22,32(sp)
81117324:	dd000615 	stw	r20,24(sp)
81117328:	dcc00515 	stw	r19,20(sp)
8111732c:	d9000015 	stw	r4,0(sp)
81117330:	dfc00b15 	stw	ra,44(sp)
81117334:	df000a15 	stw	fp,40(sp)
81117338:	ddc00915 	stw	r23,36(sp)
8111733c:	dc800415 	stw	r18,16(sp)
81117340:	dc400315 	stw	r17,12(sp)
81117344:	dc000215 	stw	r16,8(sp)
81117348:	2829883a 	mov	r20,r5
8111734c:	3027883a 	mov	r19,r6
81117350:	382d883a 	mov	r22,r7
81117354:	2809883a 	mov	r4,r5
81117358:	24000003 	ldbu	r16,0(r4)
8111735c:	24400044 	addi	r17,r4,1
81117360:	2007883a 	mov	r3,r4
81117364:	ac05883a 	add	r2,r21,r16
81117368:	10800043 	ldbu	r2,1(r2)
8111736c:	8809883a 	mov	r4,r17
81117370:	1080020c 	andi	r2,r2,8
81117374:	103ff81e 	bne	r2,zero,81117358 <__reset+0xfb0f7358>
81117378:	00800b44 	movi	r2,45
8111737c:	80805826 	beq	r16,r2,811174e0 <_strtol_r+0x1dc>
81117380:	00800ac4 	movi	r2,43
81117384:	80805a26 	beq	r16,r2,811174f0 <_strtol_r+0x1ec>
81117388:	0039883a 	mov	fp,zero
8111738c:	b0004426 	beq	r22,zero,811174a0 <_strtol_r+0x19c>
81117390:	00800404 	movi	r2,16
81117394:	b0806026 	beq	r22,r2,81117518 <_strtol_r+0x214>
81117398:	b02f883a 	mov	r23,r22
8111739c:	00a00034 	movhi	r2,32768
811173a0:	e025003a 	cmpeq	r18,fp,zero
811173a4:	14a5c83a 	sub	r18,r2,r18
811173a8:	b80b883a 	mov	r5,r23
811173ac:	9009883a 	mov	r4,r18
811173b0:	1128d800 	call	81128d80 <__umodsi3>
811173b4:	b80b883a 	mov	r5,r23
811173b8:	9009883a 	mov	r4,r18
811173bc:	d8800115 	stw	r2,4(sp)
811173c0:	1128d1c0 	call	81128d1c <__udivsi3>
811173c4:	ac07883a 	add	r3,r21,r16
811173c8:	18c00043 	ldbu	r3,1(r3)
811173cc:	880b883a 	mov	r5,r17
811173d0:	000d883a 	mov	r6,zero
811173d4:	1a00010c 	andi	r8,r3,4
811173d8:	0009883a 	mov	r4,zero
811173dc:	02800044 	movi	r10,1
811173e0:	027fffc4 	movi	r9,-1
811173e4:	d9c00117 	ldw	r7,4(sp)
811173e8:	40000e26 	beq	r8,zero,81117424 <_strtol_r+0x120>
811173ec:	843ff404 	addi	r16,r16,-48
811173f0:	8580120e 	bge	r16,r22,8111743c <_strtol_r+0x138>
811173f4:	32400526 	beq	r6,r9,8111740c <_strtol_r+0x108>
811173f8:	11002536 	bltu	r2,r4,81117490 <_strtol_r+0x18c>
811173fc:	20802326 	beq	r4,r2,8111748c <_strtol_r+0x188>
81117400:	25c9383a 	mul	r4,r4,r23
81117404:	01800044 	movi	r6,1
81117408:	8109883a 	add	r4,r16,r4
8111740c:	2c000003 	ldbu	r16,0(r5)
81117410:	29400044 	addi	r5,r5,1
81117414:	ac07883a 	add	r3,r21,r16
81117418:	18c00043 	ldbu	r3,1(r3)
8111741c:	1a00010c 	andi	r8,r3,4
81117420:	403ff21e 	bne	r8,zero,811173ec <__reset+0xfb0f73ec>
81117424:	18c000cc 	andi	r3,r3,3
81117428:	18000426 	beq	r3,zero,8111743c <_strtol_r+0x138>
8111742c:	1a801a26 	beq	r3,r10,81117498 <_strtol_r+0x194>
81117430:	00c015c4 	movi	r3,87
81117434:	80e1c83a 	sub	r16,r16,r3
81117438:	85bfee16 	blt	r16,r22,811173f4 <__reset+0xfb0f73f4>
8111743c:	00bfffc4 	movi	r2,-1
81117440:	30801e26 	beq	r6,r2,811174bc <_strtol_r+0x1b8>
81117444:	e0001b1e 	bne	fp,zero,811174b4 <_strtol_r+0x1b0>
81117448:	2005883a 	mov	r2,r4
8111744c:	98000326 	beq	r19,zero,8111745c <_strtol_r+0x158>
81117450:	3000211e 	bne	r6,zero,811174d8 <_strtol_r+0x1d4>
81117454:	a00b883a 	mov	r5,r20
81117458:	99400015 	stw	r5,0(r19)
8111745c:	dfc00b17 	ldw	ra,44(sp)
81117460:	df000a17 	ldw	fp,40(sp)
81117464:	ddc00917 	ldw	r23,36(sp)
81117468:	dd800817 	ldw	r22,32(sp)
8111746c:	dd400717 	ldw	r21,28(sp)
81117470:	dd000617 	ldw	r20,24(sp)
81117474:	dcc00517 	ldw	r19,20(sp)
81117478:	dc800417 	ldw	r18,16(sp)
8111747c:	dc400317 	ldw	r17,12(sp)
81117480:	dc000217 	ldw	r16,8(sp)
81117484:	dec00c04 	addi	sp,sp,48
81117488:	f800283a 	ret
8111748c:	3c3fdc0e 	bge	r7,r16,81117400 <__reset+0xfb0f7400>
81117490:	01bfffc4 	movi	r6,-1
81117494:	003fdd06 	br	8111740c <__reset+0xfb0f740c>
81117498:	00c00dc4 	movi	r3,55
8111749c:	003fe506 	br	81117434 <__reset+0xfb0f7434>
811174a0:	00800c04 	movi	r2,48
811174a4:	80801626 	beq	r16,r2,81117500 <_strtol_r+0x1fc>
811174a8:	05800284 	movi	r22,10
811174ac:	b02f883a 	mov	r23,r22
811174b0:	003fba06 	br	8111739c <__reset+0xfb0f739c>
811174b4:	0109c83a 	sub	r4,zero,r4
811174b8:	003fe306 	br	81117448 <__reset+0xfb0f7448>
811174bc:	d9000017 	ldw	r4,0(sp)
811174c0:	00c00884 	movi	r3,34
811174c4:	e005003a 	cmpeq	r2,fp,zero
811174c8:	20c00015 	stw	r3,0(r4)
811174cc:	00e00034 	movhi	r3,32768
811174d0:	1885c83a 	sub	r2,r3,r2
811174d4:	983fe126 	beq	r19,zero,8111745c <__reset+0xfb0f745c>
811174d8:	297fffc4 	addi	r5,r5,-1
811174dc:	003fde06 	br	81117458 <__reset+0xfb0f7458>
811174e0:	1c400084 	addi	r17,r3,2
811174e4:	1c000043 	ldbu	r16,1(r3)
811174e8:	07000044 	movi	fp,1
811174ec:	003fa706 	br	8111738c <__reset+0xfb0f738c>
811174f0:	1c400084 	addi	r17,r3,2
811174f4:	1c000043 	ldbu	r16,1(r3)
811174f8:	0039883a 	mov	fp,zero
811174fc:	003fa306 	br	8111738c <__reset+0xfb0f738c>
81117500:	88800003 	ldbu	r2,0(r17)
81117504:	00c01604 	movi	r3,88
81117508:	108037cc 	andi	r2,r2,223
8111750c:	10c00826 	beq	r2,r3,81117530 <_strtol_r+0x22c>
81117510:	05800204 	movi	r22,8
81117514:	003fa006 	br	81117398 <__reset+0xfb0f7398>
81117518:	00800c04 	movi	r2,48
8111751c:	80bf9e1e 	bne	r16,r2,81117398 <__reset+0xfb0f7398>
81117520:	88800003 	ldbu	r2,0(r17)
81117524:	00c01604 	movi	r3,88
81117528:	108037cc 	andi	r2,r2,223
8111752c:	10ff9a1e 	bne	r2,r3,81117398 <__reset+0xfb0f7398>
81117530:	05c00404 	movi	r23,16
81117534:	8c000043 	ldbu	r16,1(r17)
81117538:	b82d883a 	mov	r22,r23
8111753c:	8c400084 	addi	r17,r17,2
81117540:	003f9606 	br	8111739c <__reset+0xfb0f739c>

81117544 <strtol>:
81117544:	00a04534 	movhi	r2,33044
81117548:	109aed04 	addi	r2,r2,27572
8111754c:	300f883a 	mov	r7,r6
81117550:	280d883a 	mov	r6,r5
81117554:	200b883a 	mov	r5,r4
81117558:	11000017 	ldw	r4,0(r2)
8111755c:	11173041 	jmpi	81117304 <_strtol_r>

81117560 <___svfprintf_internal_r>:
81117560:	deffb704 	addi	sp,sp,-292
81117564:	de00012e 	bgeu	sp,et,8111756c <___svfprintf_internal_r+0xc>
81117568:	003b68fa 	trap	3
8111756c:	dfc04815 	stw	ra,288(sp)
81117570:	ddc04615 	stw	r23,280(sp)
81117574:	d9402c15 	stw	r5,176(sp)
81117578:	d9003915 	stw	r4,228(sp)
8111757c:	302f883a 	mov	r23,r6
81117580:	d9c02d15 	stw	r7,180(sp)
81117584:	df004715 	stw	fp,284(sp)
81117588:	dd804515 	stw	r22,276(sp)
8111758c:	dd404415 	stw	r21,272(sp)
81117590:	dd004315 	stw	r20,268(sp)
81117594:	dcc04215 	stw	r19,264(sp)
81117598:	dc804115 	stw	r18,260(sp)
8111759c:	dc404015 	stw	r17,256(sp)
811175a0:	dc003f15 	stw	r16,252(sp)
811175a4:	11204480 	call	81120448 <_localeconv_r>
811175a8:	10800017 	ldw	r2,0(r2)
811175ac:	1009883a 	mov	r4,r2
811175b0:	d8803415 	stw	r2,208(sp)
811175b4:	11172280 	call	81117228 <strlen>
811175b8:	d8c02c17 	ldw	r3,176(sp)
811175bc:	d8803815 	stw	r2,224(sp)
811175c0:	1880030b 	ldhu	r2,12(r3)
811175c4:	1080200c 	andi	r2,r2,128
811175c8:	10000226 	beq	r2,zero,811175d4 <___svfprintf_internal_r+0x74>
811175cc:	18800417 	ldw	r2,16(r3)
811175d0:	10067f26 	beq	r2,zero,81118fd0 <___svfprintf_internal_r+0x1a70>
811175d4:	dcc03917 	ldw	r19,228(sp)
811175d8:	d8c00404 	addi	r3,sp,16
811175dc:	05604534 	movhi	r21,33044
811175e0:	d9001e04 	addi	r4,sp,120
811175e4:	ad512584 	addi	r21,r21,17558
811175e8:	d8c01e15 	stw	r3,120(sp)
811175ec:	d8002015 	stw	zero,128(sp)
811175f0:	d8001f15 	stw	zero,124(sp)
811175f4:	d8003315 	stw	zero,204(sp)
811175f8:	d8003615 	stw	zero,216(sp)
811175fc:	d8003715 	stw	zero,220(sp)
81117600:	1811883a 	mov	r8,r3
81117604:	d8003a15 	stw	zero,232(sp)
81117608:	d8003b15 	stw	zero,236(sp)
8111760c:	d8002f15 	stw	zero,188(sp)
81117610:	d9002815 	stw	r4,160(sp)
81117614:	b8800007 	ldb	r2,0(r23)
81117618:	10026726 	beq	r2,zero,81117fb8 <___svfprintf_internal_r+0xa58>
8111761c:	00c00944 	movi	r3,37
81117620:	b821883a 	mov	r16,r23
81117624:	10c0021e 	bne	r2,r3,81117630 <___svfprintf_internal_r+0xd0>
81117628:	00001406 	br	8111767c <___svfprintf_internal_r+0x11c>
8111762c:	10c00326 	beq	r2,r3,8111763c <___svfprintf_internal_r+0xdc>
81117630:	84000044 	addi	r16,r16,1
81117634:	80800007 	ldb	r2,0(r16)
81117638:	103ffc1e 	bne	r2,zero,8111762c <__reset+0xfb0f762c>
8111763c:	85e3c83a 	sub	r17,r16,r23
81117640:	88000e26 	beq	r17,zero,8111767c <___svfprintf_internal_r+0x11c>
81117644:	d8c02017 	ldw	r3,128(sp)
81117648:	d8801f17 	ldw	r2,124(sp)
8111764c:	45c00015 	stw	r23,0(r8)
81117650:	1c47883a 	add	r3,r3,r17
81117654:	10800044 	addi	r2,r2,1
81117658:	d8c02015 	stw	r3,128(sp)
8111765c:	44400115 	stw	r17,4(r8)
81117660:	d8801f15 	stw	r2,124(sp)
81117664:	00c001c4 	movi	r3,7
81117668:	18809716 	blt	r3,r2,811178c8 <___svfprintf_internal_r+0x368>
8111766c:	42000204 	addi	r8,r8,8
81117670:	d9402f17 	ldw	r5,188(sp)
81117674:	2c4b883a 	add	r5,r5,r17
81117678:	d9402f15 	stw	r5,188(sp)
8111767c:	80800007 	ldb	r2,0(r16)
81117680:	10009826 	beq	r2,zero,811178e4 <___svfprintf_internal_r+0x384>
81117684:	84400047 	ldb	r17,1(r16)
81117688:	00bfffc4 	movi	r2,-1
8111768c:	85c00044 	addi	r23,r16,1
81117690:	d8002785 	stb	zero,158(sp)
81117694:	0007883a 	mov	r3,zero
81117698:	000f883a 	mov	r7,zero
8111769c:	d8802915 	stw	r2,164(sp)
811176a0:	d8003115 	stw	zero,196(sp)
811176a4:	0025883a 	mov	r18,zero
811176a8:	01401604 	movi	r5,88
811176ac:	01800244 	movi	r6,9
811176b0:	02800a84 	movi	r10,42
811176b4:	02401b04 	movi	r9,108
811176b8:	bdc00044 	addi	r23,r23,1
811176bc:	88bff804 	addi	r2,r17,-32
811176c0:	2882f036 	bltu	r5,r2,81118284 <___svfprintf_internal_r+0xd24>
811176c4:	100490ba 	slli	r2,r2,2
811176c8:	01204474 	movhi	r4,33041
811176cc:	211db704 	addi	r4,r4,30428
811176d0:	1105883a 	add	r2,r2,r4
811176d4:	10800017 	ldw	r2,0(r2)
811176d8:	1000683a 	jmp	r2
811176dc:	811181ec 	andhi	r4,r16,17927
811176e0:	81118284 	addi	r4,r16,17930
811176e4:	81118284 	addi	r4,r16,17930
811176e8:	811181e0 	cmpeqi	r4,r16,17927
811176ec:	81118284 	addi	r4,r16,17930
811176f0:	81118284 	addi	r4,r16,17930
811176f4:	81118284 	addi	r4,r16,17930
811176f8:	81118284 	addi	r4,r16,17930
811176fc:	81118284 	addi	r4,r16,17930
81117700:	81118284 	addi	r4,r16,17930
81117704:	81117940 	call	88111794 <__reset+0x20f1794>
81117708:	8111811c 	xori	r4,r16,17924
8111770c:	81118284 	addi	r4,r16,17930
81117710:	81117850 	cmplti	r4,r16,17889
81117714:	81117968 	cmpgeui	r4,r16,17893
81117718:	81118284 	addi	r4,r16,17930
8111771c:	811179dc 	xori	r4,r16,17895
81117720:	811179a8 	cmpgeui	r4,r16,17894
81117724:	811179a8 	cmpgeui	r4,r16,17894
81117728:	811179a8 	cmpgeui	r4,r16,17894
8111772c:	811179a8 	cmpgeui	r4,r16,17894
81117730:	811179a8 	cmpgeui	r4,r16,17894
81117734:	811179a8 	cmpgeui	r4,r16,17894
81117738:	811179a8 	cmpgeui	r4,r16,17894
8111773c:	811179a8 	cmpgeui	r4,r16,17894
81117740:	811179a8 	cmpgeui	r4,r16,17894
81117744:	81118284 	addi	r4,r16,17930
81117748:	81118284 	addi	r4,r16,17930
8111774c:	81118284 	addi	r4,r16,17930
81117750:	81118284 	addi	r4,r16,17930
81117754:	81118284 	addi	r4,r16,17930
81117758:	81118284 	addi	r4,r16,17930
8111775c:	81118284 	addi	r4,r16,17930
81117760:	81118284 	addi	r4,r16,17930
81117764:	81118284 	addi	r4,r16,17930
81117768:	81118284 	addi	r4,r16,17930
8111776c:	81117a94 	ori	r4,r16,17898
81117770:	811179e8 	cmpgeui	r4,r16,17895
81117774:	81118284 	addi	r4,r16,17930
81117778:	811179e8 	cmpgeui	r4,r16,17895
8111777c:	81118284 	addi	r4,r16,17930
81117780:	81118284 	addi	r4,r16,17930
81117784:	81118284 	addi	r4,r16,17930
81117788:	81118284 	addi	r4,r16,17930
8111778c:	81117a88 	cmpgei	r4,r16,17898
81117790:	81118284 	addi	r4,r16,17930
81117794:	81118284 	addi	r4,r16,17930
81117798:	81117b50 	cmplti	r4,r16,17901
8111779c:	81118284 	addi	r4,r16,17930
811177a0:	81118284 	addi	r4,r16,17930
811177a4:	81118284 	addi	r4,r16,17930
811177a8:	81118284 	addi	r4,r16,17930
811177ac:	81118284 	addi	r4,r16,17930
811177b0:	81117fc0 	call	881117fc <__reset+0x20f17fc>
811177b4:	81118284 	addi	r4,r16,17930
811177b8:	81118284 	addi	r4,r16,17930
811177bc:	81118020 	cmpeqi	r4,r16,17920
811177c0:	81118284 	addi	r4,r16,17930
811177c4:	81118284 	addi	r4,r16,17930
811177c8:	81118284 	addi	r4,r16,17930
811177cc:	81118284 	addi	r4,r16,17930
811177d0:	81118284 	addi	r4,r16,17930
811177d4:	81118284 	addi	r4,r16,17930
811177d8:	81118284 	addi	r4,r16,17930
811177dc:	81118284 	addi	r4,r16,17930
811177e0:	81118284 	addi	r4,r16,17930
811177e4:	81118284 	addi	r4,r16,17930
811177e8:	811180d0 	cmplti	r4,r16,17923
811177ec:	8111820c 	andi	r4,r16,17928
811177f0:	811179e8 	cmpgeui	r4,r16,17895
811177f4:	811179e8 	cmpgeui	r4,r16,17895
811177f8:	811179e8 	cmpgeui	r4,r16,17895
811177fc:	81118260 	cmpeqi	r4,r16,17929
81117800:	8111820c 	andi	r4,r16,17928
81117804:	81118284 	addi	r4,r16,17930
81117808:	81118284 	addi	r4,r16,17930
8111780c:	8111821c 	xori	r4,r16,17928
81117810:	81118284 	addi	r4,r16,17930
81117814:	8111822c 	andhi	r4,r16,17928
81117818:	8111810c 	andi	r4,r16,17924
8111781c:	8111785c 	xori	r4,r16,17889
81117820:	8111812c 	andhi	r4,r16,17924
81117824:	81118284 	addi	r4,r16,17930
81117828:	81118138 	rdprs	r4,r16,17924
8111782c:	81118284 	addi	r4,r16,17930
81117830:	81118194 	ori	r4,r16,17926
81117834:	81118284 	addi	r4,r16,17930
81117838:	81118284 	addi	r4,r16,17930
8111783c:	811181a4 	muli	r4,r16,17926
81117840:	d9003117 	ldw	r4,196(sp)
81117844:	d8802d15 	stw	r2,180(sp)
81117848:	0109c83a 	sub	r4,zero,r4
8111784c:	d9003115 	stw	r4,196(sp)
81117850:	94800114 	ori	r18,r18,4
81117854:	bc400007 	ldb	r17,0(r23)
81117858:	003f9706 	br	811176b8 <__reset+0xfb0f76b8>
8111785c:	00800c04 	movi	r2,48
81117860:	d9002d17 	ldw	r4,180(sp)
81117864:	d9402917 	ldw	r5,164(sp)
81117868:	d8802705 	stb	r2,156(sp)
8111786c:	00801e04 	movi	r2,120
81117870:	d8802745 	stb	r2,157(sp)
81117874:	d8002785 	stb	zero,158(sp)
81117878:	20c00104 	addi	r3,r4,4
8111787c:	25000017 	ldw	r20,0(r4)
81117880:	002d883a 	mov	r22,zero
81117884:	90800094 	ori	r2,r18,2
81117888:	28028616 	blt	r5,zero,811182a4 <___svfprintf_internal_r+0xd44>
8111788c:	00bfdfc4 	movi	r2,-129
81117890:	90a4703a 	and	r18,r18,r2
81117894:	d8c02d15 	stw	r3,180(sp)
81117898:	94800094 	ori	r18,r18,2
8111789c:	a002731e 	bne	r20,zero,8111826c <___svfprintf_internal_r+0xd0c>
811178a0:	00a04534 	movhi	r2,33044
811178a4:	10911e04 	addi	r2,r2,17528
811178a8:	d8803a15 	stw	r2,232(sp)
811178ac:	04401e04 	movi	r17,120
811178b0:	d8c02917 	ldw	r3,164(sp)
811178b4:	0039883a 	mov	fp,zero
811178b8:	1801d526 	beq	r3,zero,81118010 <___svfprintf_internal_r+0xab0>
811178bc:	0029883a 	mov	r20,zero
811178c0:	002d883a 	mov	r22,zero
811178c4:	0001f106 	br	8111808c <___svfprintf_internal_r+0xb2c>
811178c8:	d9402c17 	ldw	r5,176(sp)
811178cc:	d9801e04 	addi	r6,sp,120
811178d0:	9809883a 	mov	r4,r19
811178d4:	11241800 	call	81124180 <__ssprint_r>
811178d8:	1000081e 	bne	r2,zero,811178fc <___svfprintf_internal_r+0x39c>
811178dc:	da000404 	addi	r8,sp,16
811178e0:	003f6306 	br	81117670 <__reset+0xfb0f7670>
811178e4:	d8802017 	ldw	r2,128(sp)
811178e8:	10000426 	beq	r2,zero,811178fc <___svfprintf_internal_r+0x39c>
811178ec:	d9402c17 	ldw	r5,176(sp)
811178f0:	d9003917 	ldw	r4,228(sp)
811178f4:	d9801e04 	addi	r6,sp,120
811178f8:	11241800 	call	81124180 <__ssprint_r>
811178fc:	d8802c17 	ldw	r2,176(sp)
81117900:	10c0030b 	ldhu	r3,12(r2)
81117904:	d8802f17 	ldw	r2,188(sp)
81117908:	18c0100c 	andi	r3,r3,64
8111790c:	1805f51e 	bne	r3,zero,811190e4 <___svfprintf_internal_r+0x1b84>
81117910:	dfc04817 	ldw	ra,288(sp)
81117914:	df004717 	ldw	fp,284(sp)
81117918:	ddc04617 	ldw	r23,280(sp)
8111791c:	dd804517 	ldw	r22,276(sp)
81117920:	dd404417 	ldw	r21,272(sp)
81117924:	dd004317 	ldw	r20,268(sp)
81117928:	dcc04217 	ldw	r19,264(sp)
8111792c:	dc804117 	ldw	r18,260(sp)
81117930:	dc404017 	ldw	r17,256(sp)
81117934:	dc003f17 	ldw	r16,252(sp)
81117938:	dec04904 	addi	sp,sp,292
8111793c:	f800283a 	ret
81117940:	d8802d17 	ldw	r2,180(sp)
81117944:	d9002d17 	ldw	r4,180(sp)
81117948:	10800017 	ldw	r2,0(r2)
8111794c:	d8803115 	stw	r2,196(sp)
81117950:	20800104 	addi	r2,r4,4
81117954:	d9003117 	ldw	r4,196(sp)
81117958:	203fb916 	blt	r4,zero,81117840 <__reset+0xfb0f7840>
8111795c:	d8802d15 	stw	r2,180(sp)
81117960:	bc400007 	ldb	r17,0(r23)
81117964:	003f5406 	br	811176b8 <__reset+0xfb0f76b8>
81117968:	bc400007 	ldb	r17,0(r23)
8111796c:	bac00044 	addi	r11,r23,1
81117970:	8a873926 	beq	r17,r10,81119658 <___svfprintf_internal_r+0x20f8>
81117974:	88bff404 	addi	r2,r17,-48
81117978:	0009883a 	mov	r4,zero
8111797c:	30868836 	bltu	r6,r2,811193a0 <___svfprintf_internal_r+0x1e40>
81117980:	5c400007 	ldb	r17,0(r11)
81117984:	210002a4 	muli	r4,r4,10
81117988:	5dc00044 	addi	r23,r11,1
8111798c:	b817883a 	mov	r11,r23
81117990:	2089883a 	add	r4,r4,r2
81117994:	88bff404 	addi	r2,r17,-48
81117998:	30bff92e 	bgeu	r6,r2,81117980 <__reset+0xfb0f7980>
8111799c:	2005d716 	blt	r4,zero,811190fc <___svfprintf_internal_r+0x1b9c>
811179a0:	d9002915 	stw	r4,164(sp)
811179a4:	003f4506 	br	811176bc <__reset+0xfb0f76bc>
811179a8:	b809883a 	mov	r4,r23
811179ac:	d8003115 	stw	zero,196(sp)
811179b0:	88bff404 	addi	r2,r17,-48
811179b4:	0017883a 	mov	r11,zero
811179b8:	24400007 	ldb	r17,0(r4)
811179bc:	5ac002a4 	muli	r11,r11,10
811179c0:	bdc00044 	addi	r23,r23,1
811179c4:	b809883a 	mov	r4,r23
811179c8:	12d7883a 	add	r11,r2,r11
811179cc:	88bff404 	addi	r2,r17,-48
811179d0:	30bff92e 	bgeu	r6,r2,811179b8 <__reset+0xfb0f79b8>
811179d4:	dac03115 	stw	r11,196(sp)
811179d8:	003f3806 	br	811176bc <__reset+0xfb0f76bc>
811179dc:	94802014 	ori	r18,r18,128
811179e0:	bc400007 	ldb	r17,0(r23)
811179e4:	003f3406 	br	811176b8 <__reset+0xfb0f76b8>
811179e8:	18c03fcc 	andi	r3,r3,255
811179ec:	1807471e 	bne	r3,zero,8111970c <___svfprintf_internal_r+0x21ac>
811179f0:	9080020c 	andi	r2,r18,8
811179f4:	10047d26 	beq	r2,zero,81118bec <___svfprintf_internal_r+0x168c>
811179f8:	d8c02d17 	ldw	r3,180(sp)
811179fc:	d9002d17 	ldw	r4,180(sp)
81117a00:	d9402d17 	ldw	r5,180(sp)
81117a04:	18c00017 	ldw	r3,0(r3)
81117a08:	21000117 	ldw	r4,4(r4)
81117a0c:	29400204 	addi	r5,r5,8
81117a10:	d8c03615 	stw	r3,216(sp)
81117a14:	d9003715 	stw	r4,220(sp)
81117a18:	d9402d15 	stw	r5,180(sp)
81117a1c:	d9003617 	ldw	r4,216(sp)
81117a20:	d9403717 	ldw	r5,220(sp)
81117a24:	da003e15 	stw	r8,248(sp)
81117a28:	04000044 	movi	r16,1
81117a2c:	1121f940 	call	81121f94 <__fpclassifyd>
81117a30:	da003e17 	ldw	r8,248(sp)
81117a34:	14044b1e 	bne	r2,r16,81118b64 <___svfprintf_internal_r+0x1604>
81117a38:	d9003617 	ldw	r4,216(sp)
81117a3c:	d9403717 	ldw	r5,220(sp)
81117a40:	000d883a 	mov	r6,zero
81117a44:	000f883a 	mov	r7,zero
81117a48:	112a2dc0 	call	8112a2dc <__ledf2>
81117a4c:	da003e17 	ldw	r8,248(sp)
81117a50:	1005f316 	blt	r2,zero,81119220 <___svfprintf_internal_r+0x1cc0>
81117a54:	df002783 	ldbu	fp,158(sp)
81117a58:	008011c4 	movi	r2,71
81117a5c:	1445590e 	bge	r2,r17,81118fc4 <___svfprintf_internal_r+0x1a64>
81117a60:	04204534 	movhi	r16,33044
81117a64:	84111604 	addi	r16,r16,17496
81117a68:	00c000c4 	movi	r3,3
81117a6c:	00bfdfc4 	movi	r2,-129
81117a70:	d8c02a15 	stw	r3,168(sp)
81117a74:	90a4703a 	and	r18,r18,r2
81117a78:	d8c02e15 	stw	r3,184(sp)
81117a7c:	d8002915 	stw	zero,164(sp)
81117a80:	d8003215 	stw	zero,200(sp)
81117a84:	00006606 	br	81117c20 <___svfprintf_internal_r+0x6c0>
81117a88:	94800214 	ori	r18,r18,8
81117a8c:	bc400007 	ldb	r17,0(r23)
81117a90:	003f0906 	br	811176b8 <__reset+0xfb0f76b8>
81117a94:	18c03fcc 	andi	r3,r3,255
81117a98:	1807181e 	bne	r3,zero,811196fc <___svfprintf_internal_r+0x219c>
81117a9c:	94800414 	ori	r18,r18,16
81117aa0:	9080080c 	andi	r2,r18,32
81117aa4:	10039626 	beq	r2,zero,81118900 <___svfprintf_internal_r+0x13a0>
81117aa8:	d9402d17 	ldw	r5,180(sp)
81117aac:	28800117 	ldw	r2,4(r5)
81117ab0:	2d000017 	ldw	r20,0(r5)
81117ab4:	29400204 	addi	r5,r5,8
81117ab8:	d9402d15 	stw	r5,180(sp)
81117abc:	102d883a 	mov	r22,r2
81117ac0:	10039816 	blt	r2,zero,81118924 <___svfprintf_internal_r+0x13c4>
81117ac4:	d9402917 	ldw	r5,164(sp)
81117ac8:	df002783 	ldbu	fp,158(sp)
81117acc:	2803ab16 	blt	r5,zero,8111897c <___svfprintf_internal_r+0x141c>
81117ad0:	00ffdfc4 	movi	r3,-129
81117ad4:	a584b03a 	or	r2,r20,r22
81117ad8:	90e4703a 	and	r18,r18,r3
81117adc:	10014a26 	beq	r2,zero,81118008 <___svfprintf_internal_r+0xaa8>
81117ae0:	b0034b26 	beq	r22,zero,81118810 <___svfprintf_internal_r+0x12b0>
81117ae4:	dc402a15 	stw	r17,168(sp)
81117ae8:	dc001e04 	addi	r16,sp,120
81117aec:	b023883a 	mov	r17,r22
81117af0:	402d883a 	mov	r22,r8
81117af4:	a009883a 	mov	r4,r20
81117af8:	880b883a 	mov	r5,r17
81117afc:	01800284 	movi	r6,10
81117b00:	000f883a 	mov	r7,zero
81117b04:	11286e40 	call	811286e4 <__umoddi3>
81117b08:	10800c04 	addi	r2,r2,48
81117b0c:	843fffc4 	addi	r16,r16,-1
81117b10:	a009883a 	mov	r4,r20
81117b14:	880b883a 	mov	r5,r17
81117b18:	80800005 	stb	r2,0(r16)
81117b1c:	01800284 	movi	r6,10
81117b20:	000f883a 	mov	r7,zero
81117b24:	11281640 	call	81128164 <__udivdi3>
81117b28:	1029883a 	mov	r20,r2
81117b2c:	10c4b03a 	or	r2,r2,r3
81117b30:	1823883a 	mov	r17,r3
81117b34:	103fef1e 	bne	r2,zero,81117af4 <__reset+0xfb0f7af4>
81117b38:	d8c02817 	ldw	r3,160(sp)
81117b3c:	dc402a17 	ldw	r17,168(sp)
81117b40:	b011883a 	mov	r8,r22
81117b44:	1c07c83a 	sub	r3,r3,r16
81117b48:	d8c02e15 	stw	r3,184(sp)
81117b4c:	00002e06 	br	81117c08 <___svfprintf_internal_r+0x6a8>
81117b50:	18c03fcc 	andi	r3,r3,255
81117b54:	1806e71e 	bne	r3,zero,811196f4 <___svfprintf_internal_r+0x2194>
81117b58:	94800414 	ori	r18,r18,16
81117b5c:	9080080c 	andi	r2,r18,32
81117b60:	1002d426 	beq	r2,zero,811186b4 <___svfprintf_internal_r+0x1154>
81117b64:	d9402d17 	ldw	r5,180(sp)
81117b68:	d8c02917 	ldw	r3,164(sp)
81117b6c:	d8002785 	stb	zero,158(sp)
81117b70:	28800204 	addi	r2,r5,8
81117b74:	2d000017 	ldw	r20,0(r5)
81117b78:	2d800117 	ldw	r22,4(r5)
81117b7c:	18041516 	blt	r3,zero,81118bd4 <___svfprintf_internal_r+0x1674>
81117b80:	013fdfc4 	movi	r4,-129
81117b84:	a586b03a 	or	r3,r20,r22
81117b88:	d8802d15 	stw	r2,180(sp)
81117b8c:	9124703a 	and	r18,r18,r4
81117b90:	1802d51e 	bne	r3,zero,811186e8 <___svfprintf_internal_r+0x1188>
81117b94:	d9402917 	ldw	r5,164(sp)
81117b98:	0039883a 	mov	fp,zero
81117b9c:	2806be26 	beq	r5,zero,81119698 <___svfprintf_internal_r+0x2138>
81117ba0:	0029883a 	mov	r20,zero
81117ba4:	002d883a 	mov	r22,zero
81117ba8:	dc001e04 	addi	r16,sp,120
81117bac:	a006d0fa 	srli	r3,r20,3
81117bb0:	b008977a 	slli	r4,r22,29
81117bb4:	b02cd0fa 	srli	r22,r22,3
81117bb8:	a50001cc 	andi	r20,r20,7
81117bbc:	a0800c04 	addi	r2,r20,48
81117bc0:	843fffc4 	addi	r16,r16,-1
81117bc4:	20e8b03a 	or	r20,r4,r3
81117bc8:	80800005 	stb	r2,0(r16)
81117bcc:	a586b03a 	or	r3,r20,r22
81117bd0:	183ff61e 	bne	r3,zero,81117bac <__reset+0xfb0f7bac>
81117bd4:	90c0004c 	andi	r3,r18,1
81117bd8:	18013926 	beq	r3,zero,811180c0 <___svfprintf_internal_r+0xb60>
81117bdc:	10803fcc 	andi	r2,r2,255
81117be0:	1080201c 	xori	r2,r2,128
81117be4:	10bfe004 	addi	r2,r2,-128
81117be8:	00c00c04 	movi	r3,48
81117bec:	10c13426 	beq	r2,r3,811180c0 <___svfprintf_internal_r+0xb60>
81117bf0:	80ffffc5 	stb	r3,-1(r16)
81117bf4:	d8c02817 	ldw	r3,160(sp)
81117bf8:	80bfffc4 	addi	r2,r16,-1
81117bfc:	1021883a 	mov	r16,r2
81117c00:	1887c83a 	sub	r3,r3,r2
81117c04:	d8c02e15 	stw	r3,184(sp)
81117c08:	d8802e17 	ldw	r2,184(sp)
81117c0c:	d9002917 	ldw	r4,164(sp)
81117c10:	1100010e 	bge	r2,r4,81117c18 <___svfprintf_internal_r+0x6b8>
81117c14:	2005883a 	mov	r2,r4
81117c18:	d8802a15 	stw	r2,168(sp)
81117c1c:	d8003215 	stw	zero,200(sp)
81117c20:	e7003fcc 	andi	fp,fp,255
81117c24:	e700201c 	xori	fp,fp,128
81117c28:	e73fe004 	addi	fp,fp,-128
81117c2c:	e0000326 	beq	fp,zero,81117c3c <___svfprintf_internal_r+0x6dc>
81117c30:	d8c02a17 	ldw	r3,168(sp)
81117c34:	18c00044 	addi	r3,r3,1
81117c38:	d8c02a15 	stw	r3,168(sp)
81117c3c:	90c0008c 	andi	r3,r18,2
81117c40:	d8c02b15 	stw	r3,172(sp)
81117c44:	18000326 	beq	r3,zero,81117c54 <___svfprintf_internal_r+0x6f4>
81117c48:	d8c02a17 	ldw	r3,168(sp)
81117c4c:	18c00084 	addi	r3,r3,2
81117c50:	d8c02a15 	stw	r3,168(sp)
81117c54:	90c0210c 	andi	r3,r18,132
81117c58:	d8c03015 	stw	r3,192(sp)
81117c5c:	1801a11e 	bne	r3,zero,811182e4 <___svfprintf_internal_r+0xd84>
81117c60:	d9003117 	ldw	r4,196(sp)
81117c64:	d8c02a17 	ldw	r3,168(sp)
81117c68:	20e9c83a 	sub	r20,r4,r3
81117c6c:	05019d0e 	bge	zero,r20,811182e4 <___svfprintf_internal_r+0xd84>
81117c70:	02400404 	movi	r9,16
81117c74:	d8c02017 	ldw	r3,128(sp)
81117c78:	d8801f17 	ldw	r2,124(sp)
81117c7c:	4d051b0e 	bge	r9,r20,811190ec <___svfprintf_internal_r+0x1b8c>
81117c80:	01604534 	movhi	r5,33044
81117c84:	29512984 	addi	r5,r5,17574
81117c88:	dc403c15 	stw	r17,240(sp)
81117c8c:	d9403515 	stw	r5,212(sp)
81117c90:	a023883a 	mov	r17,r20
81117c94:	482d883a 	mov	r22,r9
81117c98:	9029883a 	mov	r20,r18
81117c9c:	070001c4 	movi	fp,7
81117ca0:	8025883a 	mov	r18,r16
81117ca4:	dc002c17 	ldw	r16,176(sp)
81117ca8:	00000306 	br	81117cb8 <___svfprintf_internal_r+0x758>
81117cac:	8c7ffc04 	addi	r17,r17,-16
81117cb0:	42000204 	addi	r8,r8,8
81117cb4:	b440130e 	bge	r22,r17,81117d04 <___svfprintf_internal_r+0x7a4>
81117cb8:	01204534 	movhi	r4,33044
81117cbc:	18c00404 	addi	r3,r3,16
81117cc0:	10800044 	addi	r2,r2,1
81117cc4:	21112984 	addi	r4,r4,17574
81117cc8:	41000015 	stw	r4,0(r8)
81117ccc:	45800115 	stw	r22,4(r8)
81117cd0:	d8c02015 	stw	r3,128(sp)
81117cd4:	d8801f15 	stw	r2,124(sp)
81117cd8:	e0bff40e 	bge	fp,r2,81117cac <__reset+0xfb0f7cac>
81117cdc:	d9801e04 	addi	r6,sp,120
81117ce0:	800b883a 	mov	r5,r16
81117ce4:	9809883a 	mov	r4,r19
81117ce8:	11241800 	call	81124180 <__ssprint_r>
81117cec:	103f031e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81117cf0:	8c7ffc04 	addi	r17,r17,-16
81117cf4:	d8c02017 	ldw	r3,128(sp)
81117cf8:	d8801f17 	ldw	r2,124(sp)
81117cfc:	da000404 	addi	r8,sp,16
81117d00:	b47fed16 	blt	r22,r17,81117cb8 <__reset+0xfb0f7cb8>
81117d04:	9021883a 	mov	r16,r18
81117d08:	a025883a 	mov	r18,r20
81117d0c:	8829883a 	mov	r20,r17
81117d10:	dc403c17 	ldw	r17,240(sp)
81117d14:	d9403517 	ldw	r5,212(sp)
81117d18:	a0c7883a 	add	r3,r20,r3
81117d1c:	10800044 	addi	r2,r2,1
81117d20:	41400015 	stw	r5,0(r8)
81117d24:	45000115 	stw	r20,4(r8)
81117d28:	d8c02015 	stw	r3,128(sp)
81117d2c:	d8801f15 	stw	r2,124(sp)
81117d30:	010001c4 	movi	r4,7
81117d34:	20829f16 	blt	r4,r2,811187b4 <___svfprintf_internal_r+0x1254>
81117d38:	df002787 	ldb	fp,158(sp)
81117d3c:	42000204 	addi	r8,r8,8
81117d40:	e0000c26 	beq	fp,zero,81117d74 <___svfprintf_internal_r+0x814>
81117d44:	d8801f17 	ldw	r2,124(sp)
81117d48:	d9002784 	addi	r4,sp,158
81117d4c:	18c00044 	addi	r3,r3,1
81117d50:	10800044 	addi	r2,r2,1
81117d54:	41000015 	stw	r4,0(r8)
81117d58:	01000044 	movi	r4,1
81117d5c:	41000115 	stw	r4,4(r8)
81117d60:	d8c02015 	stw	r3,128(sp)
81117d64:	d8801f15 	stw	r2,124(sp)
81117d68:	010001c4 	movi	r4,7
81117d6c:	20823816 	blt	r4,r2,81118650 <___svfprintf_internal_r+0x10f0>
81117d70:	42000204 	addi	r8,r8,8
81117d74:	d8802b17 	ldw	r2,172(sp)
81117d78:	10000c26 	beq	r2,zero,81117dac <___svfprintf_internal_r+0x84c>
81117d7c:	d8801f17 	ldw	r2,124(sp)
81117d80:	d9002704 	addi	r4,sp,156
81117d84:	18c00084 	addi	r3,r3,2
81117d88:	10800044 	addi	r2,r2,1
81117d8c:	41000015 	stw	r4,0(r8)
81117d90:	01000084 	movi	r4,2
81117d94:	41000115 	stw	r4,4(r8)
81117d98:	d8c02015 	stw	r3,128(sp)
81117d9c:	d8801f15 	stw	r2,124(sp)
81117da0:	010001c4 	movi	r4,7
81117da4:	20823216 	blt	r4,r2,81118670 <___svfprintf_internal_r+0x1110>
81117da8:	42000204 	addi	r8,r8,8
81117dac:	d9003017 	ldw	r4,192(sp)
81117db0:	00802004 	movi	r2,128
81117db4:	20819726 	beq	r4,r2,81118414 <___svfprintf_internal_r+0xeb4>
81117db8:	d9402917 	ldw	r5,164(sp)
81117dbc:	d8802e17 	ldw	r2,184(sp)
81117dc0:	28adc83a 	sub	r22,r5,r2
81117dc4:	05802f0e 	bge	zero,r22,81117e84 <___svfprintf_internal_r+0x924>
81117dc8:	07000404 	movi	fp,16
81117dcc:	d8801f17 	ldw	r2,124(sp)
81117dd0:	e583c00e 	bge	fp,r22,81118cd4 <___svfprintf_internal_r+0x1774>
81117dd4:	01604534 	movhi	r5,33044
81117dd8:	29512584 	addi	r5,r5,17558
81117ddc:	dc402915 	stw	r17,164(sp)
81117de0:	d9402b15 	stw	r5,172(sp)
81117de4:	b023883a 	mov	r17,r22
81117de8:	050001c4 	movi	r20,7
81117dec:	902d883a 	mov	r22,r18
81117df0:	8025883a 	mov	r18,r16
81117df4:	dc002c17 	ldw	r16,176(sp)
81117df8:	00000306 	br	81117e08 <___svfprintf_internal_r+0x8a8>
81117dfc:	8c7ffc04 	addi	r17,r17,-16
81117e00:	42000204 	addi	r8,r8,8
81117e04:	e440110e 	bge	fp,r17,81117e4c <___svfprintf_internal_r+0x8ec>
81117e08:	18c00404 	addi	r3,r3,16
81117e0c:	10800044 	addi	r2,r2,1
81117e10:	45400015 	stw	r21,0(r8)
81117e14:	47000115 	stw	fp,4(r8)
81117e18:	d8c02015 	stw	r3,128(sp)
81117e1c:	d8801f15 	stw	r2,124(sp)
81117e20:	a0bff60e 	bge	r20,r2,81117dfc <__reset+0xfb0f7dfc>
81117e24:	d9801e04 	addi	r6,sp,120
81117e28:	800b883a 	mov	r5,r16
81117e2c:	9809883a 	mov	r4,r19
81117e30:	11241800 	call	81124180 <__ssprint_r>
81117e34:	103eb11e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81117e38:	8c7ffc04 	addi	r17,r17,-16
81117e3c:	d8c02017 	ldw	r3,128(sp)
81117e40:	d8801f17 	ldw	r2,124(sp)
81117e44:	da000404 	addi	r8,sp,16
81117e48:	e47fef16 	blt	fp,r17,81117e08 <__reset+0xfb0f7e08>
81117e4c:	9021883a 	mov	r16,r18
81117e50:	b025883a 	mov	r18,r22
81117e54:	882d883a 	mov	r22,r17
81117e58:	dc402917 	ldw	r17,164(sp)
81117e5c:	d9002b17 	ldw	r4,172(sp)
81117e60:	1d87883a 	add	r3,r3,r22
81117e64:	10800044 	addi	r2,r2,1
81117e68:	41000015 	stw	r4,0(r8)
81117e6c:	45800115 	stw	r22,4(r8)
81117e70:	d8c02015 	stw	r3,128(sp)
81117e74:	d8801f15 	stw	r2,124(sp)
81117e78:	010001c4 	movi	r4,7
81117e7c:	2081ec16 	blt	r4,r2,81118630 <___svfprintf_internal_r+0x10d0>
81117e80:	42000204 	addi	r8,r8,8
81117e84:	9080400c 	andi	r2,r18,256
81117e88:	1001181e 	bne	r2,zero,811182ec <___svfprintf_internal_r+0xd8c>
81117e8c:	d9402e17 	ldw	r5,184(sp)
81117e90:	d8801f17 	ldw	r2,124(sp)
81117e94:	44000015 	stw	r16,0(r8)
81117e98:	1947883a 	add	r3,r3,r5
81117e9c:	10800044 	addi	r2,r2,1
81117ea0:	41400115 	stw	r5,4(r8)
81117ea4:	d8c02015 	stw	r3,128(sp)
81117ea8:	d8801f15 	stw	r2,124(sp)
81117eac:	010001c4 	movi	r4,7
81117eb0:	2081d116 	blt	r4,r2,811185f8 <___svfprintf_internal_r+0x1098>
81117eb4:	42000204 	addi	r8,r8,8
81117eb8:	9480010c 	andi	r18,r18,4
81117ebc:	90003226 	beq	r18,zero,81117f88 <___svfprintf_internal_r+0xa28>
81117ec0:	d9403117 	ldw	r5,196(sp)
81117ec4:	d8802a17 	ldw	r2,168(sp)
81117ec8:	28a1c83a 	sub	r16,r5,r2
81117ecc:	04002e0e 	bge	zero,r16,81117f88 <___svfprintf_internal_r+0xa28>
81117ed0:	04400404 	movi	r17,16
81117ed4:	d8801f17 	ldw	r2,124(sp)
81117ed8:	8c04b90e 	bge	r17,r16,811191c0 <___svfprintf_internal_r+0x1c60>
81117edc:	01604534 	movhi	r5,33044
81117ee0:	29512984 	addi	r5,r5,17574
81117ee4:	d9403515 	stw	r5,212(sp)
81117ee8:	048001c4 	movi	r18,7
81117eec:	dd002c17 	ldw	r20,176(sp)
81117ef0:	00000306 	br	81117f00 <___svfprintf_internal_r+0x9a0>
81117ef4:	843ffc04 	addi	r16,r16,-16
81117ef8:	42000204 	addi	r8,r8,8
81117efc:	8c00130e 	bge	r17,r16,81117f4c <___svfprintf_internal_r+0x9ec>
81117f00:	01204534 	movhi	r4,33044
81117f04:	18c00404 	addi	r3,r3,16
81117f08:	10800044 	addi	r2,r2,1
81117f0c:	21112984 	addi	r4,r4,17574
81117f10:	41000015 	stw	r4,0(r8)
81117f14:	44400115 	stw	r17,4(r8)
81117f18:	d8c02015 	stw	r3,128(sp)
81117f1c:	d8801f15 	stw	r2,124(sp)
81117f20:	90bff40e 	bge	r18,r2,81117ef4 <__reset+0xfb0f7ef4>
81117f24:	d9801e04 	addi	r6,sp,120
81117f28:	a00b883a 	mov	r5,r20
81117f2c:	9809883a 	mov	r4,r19
81117f30:	11241800 	call	81124180 <__ssprint_r>
81117f34:	103e711e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81117f38:	843ffc04 	addi	r16,r16,-16
81117f3c:	d8c02017 	ldw	r3,128(sp)
81117f40:	d8801f17 	ldw	r2,124(sp)
81117f44:	da000404 	addi	r8,sp,16
81117f48:	8c3fed16 	blt	r17,r16,81117f00 <__reset+0xfb0f7f00>
81117f4c:	d9403517 	ldw	r5,212(sp)
81117f50:	1c07883a 	add	r3,r3,r16
81117f54:	10800044 	addi	r2,r2,1
81117f58:	41400015 	stw	r5,0(r8)
81117f5c:	44000115 	stw	r16,4(r8)
81117f60:	d8c02015 	stw	r3,128(sp)
81117f64:	d8801f15 	stw	r2,124(sp)
81117f68:	010001c4 	movi	r4,7
81117f6c:	2080060e 	bge	r4,r2,81117f88 <___svfprintf_internal_r+0xa28>
81117f70:	d9402c17 	ldw	r5,176(sp)
81117f74:	d9801e04 	addi	r6,sp,120
81117f78:	9809883a 	mov	r4,r19
81117f7c:	11241800 	call	81124180 <__ssprint_r>
81117f80:	103e5e1e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81117f84:	d8c02017 	ldw	r3,128(sp)
81117f88:	d8803117 	ldw	r2,196(sp)
81117f8c:	d9002a17 	ldw	r4,168(sp)
81117f90:	1100010e 	bge	r2,r4,81117f98 <___svfprintf_internal_r+0xa38>
81117f94:	2005883a 	mov	r2,r4
81117f98:	d9402f17 	ldw	r5,188(sp)
81117f9c:	288b883a 	add	r5,r5,r2
81117fa0:	d9402f15 	stw	r5,188(sp)
81117fa4:	18019c1e 	bne	r3,zero,81118618 <___svfprintf_internal_r+0x10b8>
81117fa8:	b8800007 	ldb	r2,0(r23)
81117fac:	d8001f15 	stw	zero,124(sp)
81117fb0:	da000404 	addi	r8,sp,16
81117fb4:	103d991e 	bne	r2,zero,8111761c <__reset+0xfb0f761c>
81117fb8:	b821883a 	mov	r16,r23
81117fbc:	003daf06 	br	8111767c <__reset+0xfb0f767c>
81117fc0:	18c03fcc 	andi	r3,r3,255
81117fc4:	1805c71e 	bne	r3,zero,811196e4 <___svfprintf_internal_r+0x2184>
81117fc8:	94800414 	ori	r18,r18,16
81117fcc:	9080080c 	andi	r2,r18,32
81117fd0:	10020126 	beq	r2,zero,811187d8 <___svfprintf_internal_r+0x1278>
81117fd4:	d8802d17 	ldw	r2,180(sp)
81117fd8:	d9002917 	ldw	r4,164(sp)
81117fdc:	d8002785 	stb	zero,158(sp)
81117fe0:	10c00204 	addi	r3,r2,8
81117fe4:	15000017 	ldw	r20,0(r2)
81117fe8:	15800117 	ldw	r22,4(r2)
81117fec:	20038e16 	blt	r4,zero,81118e28 <___svfprintf_internal_r+0x18c8>
81117ff0:	013fdfc4 	movi	r4,-129
81117ff4:	a584b03a 	or	r2,r20,r22
81117ff8:	d8c02d15 	stw	r3,180(sp)
81117ffc:	9124703a 	and	r18,r18,r4
81118000:	0039883a 	mov	fp,zero
81118004:	103eb61e 	bne	r2,zero,81117ae0 <__reset+0xfb0f7ae0>
81118008:	d8802917 	ldw	r2,164(sp)
8111800c:	1002c81e 	bne	r2,zero,81118b30 <___svfprintf_internal_r+0x15d0>
81118010:	d8002915 	stw	zero,164(sp)
81118014:	d8002e15 	stw	zero,184(sp)
81118018:	dc001e04 	addi	r16,sp,120
8111801c:	003efa06 	br	81117c08 <__reset+0xfb0f7c08>
81118020:	18c03fcc 	andi	r3,r3,255
81118024:	1805ad1e 	bne	r3,zero,811196dc <___svfprintf_internal_r+0x217c>
81118028:	01604534 	movhi	r5,33044
8111802c:	29511904 	addi	r5,r5,17508
81118030:	d9403a15 	stw	r5,232(sp)
81118034:	9080080c 	andi	r2,r18,32
81118038:	10006126 	beq	r2,zero,811181c0 <___svfprintf_internal_r+0xc60>
8111803c:	d8802d17 	ldw	r2,180(sp)
81118040:	15000017 	ldw	r20,0(r2)
81118044:	15800117 	ldw	r22,4(r2)
81118048:	10800204 	addi	r2,r2,8
8111804c:	d8802d15 	stw	r2,180(sp)
81118050:	9080004c 	andi	r2,r18,1
81118054:	10018e26 	beq	r2,zero,81118690 <___svfprintf_internal_r+0x1130>
81118058:	a584b03a 	or	r2,r20,r22
8111805c:	10030926 	beq	r2,zero,81118c84 <___svfprintf_internal_r+0x1724>
81118060:	d8c02917 	ldw	r3,164(sp)
81118064:	00800c04 	movi	r2,48
81118068:	d8802705 	stb	r2,156(sp)
8111806c:	dc402745 	stb	r17,157(sp)
81118070:	d8002785 	stb	zero,158(sp)
81118074:	90800094 	ori	r2,r18,2
81118078:	18048716 	blt	r3,zero,81119298 <___svfprintf_internal_r+0x1d38>
8111807c:	00bfdfc4 	movi	r2,-129
81118080:	90a4703a 	and	r18,r18,r2
81118084:	94800094 	ori	r18,r18,2
81118088:	0039883a 	mov	fp,zero
8111808c:	d9003a17 	ldw	r4,232(sp)
81118090:	dc001e04 	addi	r16,sp,120
81118094:	a08003cc 	andi	r2,r20,15
81118098:	b006973a 	slli	r3,r22,28
8111809c:	2085883a 	add	r2,r4,r2
811180a0:	a028d13a 	srli	r20,r20,4
811180a4:	10800003 	ldbu	r2,0(r2)
811180a8:	b02cd13a 	srli	r22,r22,4
811180ac:	843fffc4 	addi	r16,r16,-1
811180b0:	1d28b03a 	or	r20,r3,r20
811180b4:	80800005 	stb	r2,0(r16)
811180b8:	a584b03a 	or	r2,r20,r22
811180bc:	103ff51e 	bne	r2,zero,81118094 <__reset+0xfb0f8094>
811180c0:	d8c02817 	ldw	r3,160(sp)
811180c4:	1c07c83a 	sub	r3,r3,r16
811180c8:	d8c02e15 	stw	r3,184(sp)
811180cc:	003ece06 	br	81117c08 <__reset+0xfb0f7c08>
811180d0:	d8c02d17 	ldw	r3,180(sp)
811180d4:	d9002d17 	ldw	r4,180(sp)
811180d8:	d8002785 	stb	zero,158(sp)
811180dc:	18800017 	ldw	r2,0(r3)
811180e0:	21000104 	addi	r4,r4,4
811180e4:	00c00044 	movi	r3,1
811180e8:	d8c02a15 	stw	r3,168(sp)
811180ec:	d8801405 	stb	r2,80(sp)
811180f0:	d9002d15 	stw	r4,180(sp)
811180f4:	d8c02e15 	stw	r3,184(sp)
811180f8:	d8002915 	stw	zero,164(sp)
811180fc:	d8003215 	stw	zero,200(sp)
81118100:	dc001404 	addi	r16,sp,80
81118104:	0039883a 	mov	fp,zero
81118108:	003ecc06 	br	81117c3c <__reset+0xfb0f7c3c>
8111810c:	18c03fcc 	andi	r3,r3,255
81118110:	183e9226 	beq	r3,zero,81117b5c <__reset+0xfb0f7b5c>
81118114:	d9c02785 	stb	r7,158(sp)
81118118:	003e9006 	br	81117b5c <__reset+0xfb0f7b5c>
8111811c:	00c00044 	movi	r3,1
81118120:	01c00ac4 	movi	r7,43
81118124:	bc400007 	ldb	r17,0(r23)
81118128:	003d6306 	br	811176b8 <__reset+0xfb0f76b8>
8111812c:	94800814 	ori	r18,r18,32
81118130:	bc400007 	ldb	r17,0(r23)
81118134:	003d6006 	br	811176b8 <__reset+0xfb0f76b8>
81118138:	d8c02d17 	ldw	r3,180(sp)
8111813c:	d8002785 	stb	zero,158(sp)
81118140:	1c000017 	ldw	r16,0(r3)
81118144:	1d000104 	addi	r20,r3,4
81118148:	80040f26 	beq	r16,zero,81119188 <___svfprintf_internal_r+0x1c28>
8111814c:	d9002917 	ldw	r4,164(sp)
81118150:	2003dc16 	blt	r4,zero,811190c4 <___svfprintf_internal_r+0x1b64>
81118154:	200d883a 	mov	r6,r4
81118158:	000b883a 	mov	r5,zero
8111815c:	8009883a 	mov	r4,r16
81118160:	da003e15 	stw	r8,248(sp)
81118164:	11207240 	call	81120724 <memchr>
81118168:	da003e17 	ldw	r8,248(sp)
8111816c:	10045826 	beq	r2,zero,811192d0 <___svfprintf_internal_r+0x1d70>
81118170:	1405c83a 	sub	r2,r2,r16
81118174:	d8802e15 	stw	r2,184(sp)
81118178:	1003d816 	blt	r2,zero,811190dc <___svfprintf_internal_r+0x1b7c>
8111817c:	df002783 	ldbu	fp,158(sp)
81118180:	d8802a15 	stw	r2,168(sp)
81118184:	dd002d15 	stw	r20,180(sp)
81118188:	d8002915 	stw	zero,164(sp)
8111818c:	d8003215 	stw	zero,200(sp)
81118190:	003ea306 	br	81117c20 <__reset+0xfb0f7c20>
81118194:	18c03fcc 	andi	r3,r3,255
81118198:	183f8c26 	beq	r3,zero,81117fcc <__reset+0xfb0f7fcc>
8111819c:	d9c02785 	stb	r7,158(sp)
811181a0:	003f8a06 	br	81117fcc <__reset+0xfb0f7fcc>
811181a4:	18c03fcc 	andi	r3,r3,255
811181a8:	1805631e 	bne	r3,zero,81119738 <___svfprintf_internal_r+0x21d8>
811181ac:	01604534 	movhi	r5,33044
811181b0:	29511e04 	addi	r5,r5,17528
811181b4:	d9403a15 	stw	r5,232(sp)
811181b8:	9080080c 	andi	r2,r18,32
811181bc:	103f9f1e 	bne	r2,zero,8111803c <__reset+0xfb0f803c>
811181c0:	9080040c 	andi	r2,r18,16
811181c4:	10029c26 	beq	r2,zero,81118c38 <___svfprintf_internal_r+0x16d8>
811181c8:	d8c02d17 	ldw	r3,180(sp)
811181cc:	002d883a 	mov	r22,zero
811181d0:	1d000017 	ldw	r20,0(r3)
811181d4:	18c00104 	addi	r3,r3,4
811181d8:	d8c02d15 	stw	r3,180(sp)
811181dc:	003f9c06 	br	81118050 <__reset+0xfb0f8050>
811181e0:	94800054 	ori	r18,r18,1
811181e4:	bc400007 	ldb	r17,0(r23)
811181e8:	003d3306 	br	811176b8 <__reset+0xfb0f76b8>
811181ec:	38803fcc 	andi	r2,r7,255
811181f0:	1080201c 	xori	r2,r2,128
811181f4:	10bfe004 	addi	r2,r2,-128
811181f8:	1002971e 	bne	r2,zero,81118c58 <___svfprintf_internal_r+0x16f8>
811181fc:	00c00044 	movi	r3,1
81118200:	01c00804 	movi	r7,32
81118204:	bc400007 	ldb	r17,0(r23)
81118208:	003d2b06 	br	811176b8 <__reset+0xfb0f76b8>
8111820c:	18c03fcc 	andi	r3,r3,255
81118210:	183e2326 	beq	r3,zero,81117aa0 <__reset+0xfb0f7aa0>
81118214:	d9c02785 	stb	r7,158(sp)
81118218:	003e2106 	br	81117aa0 <__reset+0xfb0f7aa0>
8111821c:	bc400007 	ldb	r17,0(r23)
81118220:	8a430426 	beq	r17,r9,81118e34 <___svfprintf_internal_r+0x18d4>
81118224:	94800414 	ori	r18,r18,16
81118228:	003d2306 	br	811176b8 <__reset+0xfb0f76b8>
8111822c:	18c03fcc 	andi	r3,r3,255
81118230:	18053f1e 	bne	r3,zero,81119730 <___svfprintf_internal_r+0x21d0>
81118234:	9080080c 	andi	r2,r18,32
81118238:	10028926 	beq	r2,zero,81118c60 <___svfprintf_internal_r+0x1700>
8111823c:	d9402d17 	ldw	r5,180(sp)
81118240:	d9002f17 	ldw	r4,188(sp)
81118244:	28800017 	ldw	r2,0(r5)
81118248:	2007d7fa 	srai	r3,r4,31
8111824c:	29400104 	addi	r5,r5,4
81118250:	d9402d15 	stw	r5,180(sp)
81118254:	11000015 	stw	r4,0(r2)
81118258:	10c00115 	stw	r3,4(r2)
8111825c:	003ced06 	br	81117614 <__reset+0xfb0f7614>
81118260:	94801014 	ori	r18,r18,64
81118264:	bc400007 	ldb	r17,0(r23)
81118268:	003d1306 	br	811176b8 <__reset+0xfb0f76b8>
8111826c:	01204534 	movhi	r4,33044
81118270:	21111e04 	addi	r4,r4,17528
81118274:	0039883a 	mov	fp,zero
81118278:	d9003a15 	stw	r4,232(sp)
8111827c:	04401e04 	movi	r17,120
81118280:	003f8206 	br	8111808c <__reset+0xfb0f808c>
81118284:	18c03fcc 	andi	r3,r3,255
81118288:	1805221e 	bne	r3,zero,81119714 <___svfprintf_internal_r+0x21b4>
8111828c:	883d9526 	beq	r17,zero,811178e4 <__reset+0xfb0f78e4>
81118290:	00c00044 	movi	r3,1
81118294:	d8c02a15 	stw	r3,168(sp)
81118298:	dc401405 	stb	r17,80(sp)
8111829c:	d8002785 	stb	zero,158(sp)
811182a0:	003f9406 	br	811180f4 <__reset+0xfb0f80f4>
811182a4:	01204534 	movhi	r4,33044
811182a8:	21111e04 	addi	r4,r4,17528
811182ac:	d9003a15 	stw	r4,232(sp)
811182b0:	d8c02d15 	stw	r3,180(sp)
811182b4:	1025883a 	mov	r18,r2
811182b8:	04401e04 	movi	r17,120
811182bc:	a584b03a 	or	r2,r20,r22
811182c0:	1000fa1e 	bne	r2,zero,811186ac <___svfprintf_internal_r+0x114c>
811182c4:	0039883a 	mov	fp,zero
811182c8:	00800084 	movi	r2,2
811182cc:	10803fcc 	andi	r2,r2,255
811182d0:	00c00044 	movi	r3,1
811182d4:	10c21626 	beq	r2,r3,81118b30 <___svfprintf_internal_r+0x15d0>
811182d8:	00c00084 	movi	r3,2
811182dc:	10fe301e 	bne	r2,r3,81117ba0 <__reset+0xfb0f7ba0>
811182e0:	003d7606 	br	811178bc <__reset+0xfb0f78bc>
811182e4:	d8c02017 	ldw	r3,128(sp)
811182e8:	003e9506 	br	81117d40 <__reset+0xfb0f7d40>
811182ec:	00801944 	movi	r2,101
811182f0:	14407c0e 	bge	r2,r17,811184e4 <___svfprintf_internal_r+0xf84>
811182f4:	d9003617 	ldw	r4,216(sp)
811182f8:	d9403717 	ldw	r5,220(sp)
811182fc:	000d883a 	mov	r6,zero
81118300:	000f883a 	mov	r7,zero
81118304:	d8c03d15 	stw	r3,244(sp)
81118308:	da003e15 	stw	r8,248(sp)
8111830c:	112a1780 	call	8112a178 <__eqdf2>
81118310:	d8c03d17 	ldw	r3,244(sp)
81118314:	da003e17 	ldw	r8,248(sp)
81118318:	1000f51e 	bne	r2,zero,811186f0 <___svfprintf_internal_r+0x1190>
8111831c:	d8801f17 	ldw	r2,124(sp)
81118320:	01204534 	movhi	r4,33044
81118324:	21112504 	addi	r4,r4,17556
81118328:	18c00044 	addi	r3,r3,1
8111832c:	10800044 	addi	r2,r2,1
81118330:	41000015 	stw	r4,0(r8)
81118334:	01000044 	movi	r4,1
81118338:	41000115 	stw	r4,4(r8)
8111833c:	d8c02015 	stw	r3,128(sp)
81118340:	d8801f15 	stw	r2,124(sp)
81118344:	010001c4 	movi	r4,7
81118348:	20826616 	blt	r4,r2,81118ce4 <___svfprintf_internal_r+0x1784>
8111834c:	42000204 	addi	r8,r8,8
81118350:	d8802617 	ldw	r2,152(sp)
81118354:	d9403317 	ldw	r5,204(sp)
81118358:	11400216 	blt	r2,r5,81118364 <___svfprintf_internal_r+0xe04>
8111835c:	9080004c 	andi	r2,r18,1
81118360:	103ed526 	beq	r2,zero,81117eb8 <__reset+0xfb0f7eb8>
81118364:	d8803817 	ldw	r2,224(sp)
81118368:	d9003417 	ldw	r4,208(sp)
8111836c:	d9403817 	ldw	r5,224(sp)
81118370:	1887883a 	add	r3,r3,r2
81118374:	d8801f17 	ldw	r2,124(sp)
81118378:	41000015 	stw	r4,0(r8)
8111837c:	41400115 	stw	r5,4(r8)
81118380:	10800044 	addi	r2,r2,1
81118384:	d8c02015 	stw	r3,128(sp)
81118388:	d8801f15 	stw	r2,124(sp)
8111838c:	010001c4 	movi	r4,7
81118390:	2082af16 	blt	r4,r2,81118e50 <___svfprintf_internal_r+0x18f0>
81118394:	42000204 	addi	r8,r8,8
81118398:	d8803317 	ldw	r2,204(sp)
8111839c:	143fffc4 	addi	r16,r2,-1
811183a0:	043ec50e 	bge	zero,r16,81117eb8 <__reset+0xfb0f7eb8>
811183a4:	04400404 	movi	r17,16
811183a8:	d8801f17 	ldw	r2,124(sp)
811183ac:	8c00860e 	bge	r17,r16,811185c8 <___svfprintf_internal_r+0x1068>
811183b0:	01604534 	movhi	r5,33044
811183b4:	29512584 	addi	r5,r5,17558
811183b8:	d9402b15 	stw	r5,172(sp)
811183bc:	058001c4 	movi	r22,7
811183c0:	dd002c17 	ldw	r20,176(sp)
811183c4:	00000306 	br	811183d4 <___svfprintf_internal_r+0xe74>
811183c8:	42000204 	addi	r8,r8,8
811183cc:	843ffc04 	addi	r16,r16,-16
811183d0:	8c00800e 	bge	r17,r16,811185d4 <___svfprintf_internal_r+0x1074>
811183d4:	18c00404 	addi	r3,r3,16
811183d8:	10800044 	addi	r2,r2,1
811183dc:	45400015 	stw	r21,0(r8)
811183e0:	44400115 	stw	r17,4(r8)
811183e4:	d8c02015 	stw	r3,128(sp)
811183e8:	d8801f15 	stw	r2,124(sp)
811183ec:	b0bff60e 	bge	r22,r2,811183c8 <__reset+0xfb0f83c8>
811183f0:	d9801e04 	addi	r6,sp,120
811183f4:	a00b883a 	mov	r5,r20
811183f8:	9809883a 	mov	r4,r19
811183fc:	11241800 	call	81124180 <__ssprint_r>
81118400:	103d3e1e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118404:	d8c02017 	ldw	r3,128(sp)
81118408:	d8801f17 	ldw	r2,124(sp)
8111840c:	da000404 	addi	r8,sp,16
81118410:	003fee06 	br	811183cc <__reset+0xfb0f83cc>
81118414:	d9403117 	ldw	r5,196(sp)
81118418:	d8802a17 	ldw	r2,168(sp)
8111841c:	28adc83a 	sub	r22,r5,r2
81118420:	05be650e 	bge	zero,r22,81117db8 <__reset+0xfb0f7db8>
81118424:	07000404 	movi	fp,16
81118428:	d8801f17 	ldw	r2,124(sp)
8111842c:	e583a20e 	bge	fp,r22,811192b8 <___svfprintf_internal_r+0x1d58>
81118430:	01604534 	movhi	r5,33044
81118434:	29512584 	addi	r5,r5,17558
81118438:	dc403015 	stw	r17,192(sp)
8111843c:	d9402b15 	stw	r5,172(sp)
81118440:	b023883a 	mov	r17,r22
81118444:	050001c4 	movi	r20,7
81118448:	902d883a 	mov	r22,r18
8111844c:	8025883a 	mov	r18,r16
81118450:	dc002c17 	ldw	r16,176(sp)
81118454:	00000306 	br	81118464 <___svfprintf_internal_r+0xf04>
81118458:	8c7ffc04 	addi	r17,r17,-16
8111845c:	42000204 	addi	r8,r8,8
81118460:	e440110e 	bge	fp,r17,811184a8 <___svfprintf_internal_r+0xf48>
81118464:	18c00404 	addi	r3,r3,16
81118468:	10800044 	addi	r2,r2,1
8111846c:	45400015 	stw	r21,0(r8)
81118470:	47000115 	stw	fp,4(r8)
81118474:	d8c02015 	stw	r3,128(sp)
81118478:	d8801f15 	stw	r2,124(sp)
8111847c:	a0bff60e 	bge	r20,r2,81118458 <__reset+0xfb0f8458>
81118480:	d9801e04 	addi	r6,sp,120
81118484:	800b883a 	mov	r5,r16
81118488:	9809883a 	mov	r4,r19
8111848c:	11241800 	call	81124180 <__ssprint_r>
81118490:	103d1a1e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118494:	8c7ffc04 	addi	r17,r17,-16
81118498:	d8c02017 	ldw	r3,128(sp)
8111849c:	d8801f17 	ldw	r2,124(sp)
811184a0:	da000404 	addi	r8,sp,16
811184a4:	e47fef16 	blt	fp,r17,81118464 <__reset+0xfb0f8464>
811184a8:	9021883a 	mov	r16,r18
811184ac:	b025883a 	mov	r18,r22
811184b0:	882d883a 	mov	r22,r17
811184b4:	dc403017 	ldw	r17,192(sp)
811184b8:	d9002b17 	ldw	r4,172(sp)
811184bc:	1d87883a 	add	r3,r3,r22
811184c0:	10800044 	addi	r2,r2,1
811184c4:	41000015 	stw	r4,0(r8)
811184c8:	45800115 	stw	r22,4(r8)
811184cc:	d8c02015 	stw	r3,128(sp)
811184d0:	d8801f15 	stw	r2,124(sp)
811184d4:	010001c4 	movi	r4,7
811184d8:	20819a16 	blt	r4,r2,81118b44 <___svfprintf_internal_r+0x15e4>
811184dc:	42000204 	addi	r8,r8,8
811184e0:	003e3506 	br	81117db8 <__reset+0xfb0f7db8>
811184e4:	d9403317 	ldw	r5,204(sp)
811184e8:	00800044 	movi	r2,1
811184ec:	18c00044 	addi	r3,r3,1
811184f0:	1141710e 	bge	r2,r5,81118ab8 <___svfprintf_internal_r+0x1558>
811184f4:	dc401f17 	ldw	r17,124(sp)
811184f8:	00800044 	movi	r2,1
811184fc:	40800115 	stw	r2,4(r8)
81118500:	8c400044 	addi	r17,r17,1
81118504:	44000015 	stw	r16,0(r8)
81118508:	d8c02015 	stw	r3,128(sp)
8111850c:	dc401f15 	stw	r17,124(sp)
81118510:	008001c4 	movi	r2,7
81118514:	14417416 	blt	r2,r17,81118ae8 <___svfprintf_internal_r+0x1588>
81118518:	42000204 	addi	r8,r8,8
8111851c:	d8803817 	ldw	r2,224(sp)
81118520:	d9003417 	ldw	r4,208(sp)
81118524:	8c400044 	addi	r17,r17,1
81118528:	10c7883a 	add	r3,r2,r3
8111852c:	40800115 	stw	r2,4(r8)
81118530:	41000015 	stw	r4,0(r8)
81118534:	d8c02015 	stw	r3,128(sp)
81118538:	dc401f15 	stw	r17,124(sp)
8111853c:	008001c4 	movi	r2,7
81118540:	14417216 	blt	r2,r17,81118b0c <___svfprintf_internal_r+0x15ac>
81118544:	45800204 	addi	r22,r8,8
81118548:	d9003617 	ldw	r4,216(sp)
8111854c:	d9403717 	ldw	r5,220(sp)
81118550:	000d883a 	mov	r6,zero
81118554:	000f883a 	mov	r7,zero
81118558:	d8c03d15 	stw	r3,244(sp)
8111855c:	112a1780 	call	8112a178 <__eqdf2>
81118560:	d8c03d17 	ldw	r3,244(sp)
81118564:	1000b326 	beq	r2,zero,81118834 <___svfprintf_internal_r+0x12d4>
81118568:	d9403317 	ldw	r5,204(sp)
8111856c:	84000044 	addi	r16,r16,1
81118570:	8c400044 	addi	r17,r17,1
81118574:	28bfffc4 	addi	r2,r5,-1
81118578:	1887883a 	add	r3,r3,r2
8111857c:	b0800115 	stw	r2,4(r22)
81118580:	b4000015 	stw	r16,0(r22)
81118584:	d8c02015 	stw	r3,128(sp)
81118588:	dc401f15 	stw	r17,124(sp)
8111858c:	008001c4 	movi	r2,7
81118590:	1440d216 	blt	r2,r17,811188dc <___svfprintf_internal_r+0x137c>
81118594:	b5800204 	addi	r22,r22,8
81118598:	d9003b17 	ldw	r4,236(sp)
8111859c:	df0022c4 	addi	fp,sp,139
811185a0:	8c400044 	addi	r17,r17,1
811185a4:	20c7883a 	add	r3,r4,r3
811185a8:	b7000015 	stw	fp,0(r22)
811185ac:	b1000115 	stw	r4,4(r22)
811185b0:	d8c02015 	stw	r3,128(sp)
811185b4:	dc401f15 	stw	r17,124(sp)
811185b8:	008001c4 	movi	r2,7
811185bc:	14400e16 	blt	r2,r17,811185f8 <___svfprintf_internal_r+0x1098>
811185c0:	b2000204 	addi	r8,r22,8
811185c4:	003e3c06 	br	81117eb8 <__reset+0xfb0f7eb8>
811185c8:	01204534 	movhi	r4,33044
811185cc:	21112584 	addi	r4,r4,17558
811185d0:	d9002b15 	stw	r4,172(sp)
811185d4:	d9002b17 	ldw	r4,172(sp)
811185d8:	1c07883a 	add	r3,r3,r16
811185dc:	44000115 	stw	r16,4(r8)
811185e0:	41000015 	stw	r4,0(r8)
811185e4:	10800044 	addi	r2,r2,1
811185e8:	d8c02015 	stw	r3,128(sp)
811185ec:	d8801f15 	stw	r2,124(sp)
811185f0:	010001c4 	movi	r4,7
811185f4:	20be2f0e 	bge	r4,r2,81117eb4 <__reset+0xfb0f7eb4>
811185f8:	d9402c17 	ldw	r5,176(sp)
811185fc:	d9801e04 	addi	r6,sp,120
81118600:	9809883a 	mov	r4,r19
81118604:	11241800 	call	81124180 <__ssprint_r>
81118608:	103cbc1e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
8111860c:	d8c02017 	ldw	r3,128(sp)
81118610:	da000404 	addi	r8,sp,16
81118614:	003e2806 	br	81117eb8 <__reset+0xfb0f7eb8>
81118618:	d9402c17 	ldw	r5,176(sp)
8111861c:	d9801e04 	addi	r6,sp,120
81118620:	9809883a 	mov	r4,r19
81118624:	11241800 	call	81124180 <__ssprint_r>
81118628:	103e5f26 	beq	r2,zero,81117fa8 <__reset+0xfb0f7fa8>
8111862c:	003cb306 	br	811178fc <__reset+0xfb0f78fc>
81118630:	d9402c17 	ldw	r5,176(sp)
81118634:	d9801e04 	addi	r6,sp,120
81118638:	9809883a 	mov	r4,r19
8111863c:	11241800 	call	81124180 <__ssprint_r>
81118640:	103cae1e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118644:	d8c02017 	ldw	r3,128(sp)
81118648:	da000404 	addi	r8,sp,16
8111864c:	003e0d06 	br	81117e84 <__reset+0xfb0f7e84>
81118650:	d9402c17 	ldw	r5,176(sp)
81118654:	d9801e04 	addi	r6,sp,120
81118658:	9809883a 	mov	r4,r19
8111865c:	11241800 	call	81124180 <__ssprint_r>
81118660:	103ca61e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118664:	d8c02017 	ldw	r3,128(sp)
81118668:	da000404 	addi	r8,sp,16
8111866c:	003dc106 	br	81117d74 <__reset+0xfb0f7d74>
81118670:	d9402c17 	ldw	r5,176(sp)
81118674:	d9801e04 	addi	r6,sp,120
81118678:	9809883a 	mov	r4,r19
8111867c:	11241800 	call	81124180 <__ssprint_r>
81118680:	103c9e1e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118684:	d8c02017 	ldw	r3,128(sp)
81118688:	da000404 	addi	r8,sp,16
8111868c:	003dc706 	br	81117dac <__reset+0xfb0f7dac>
81118690:	d8802917 	ldw	r2,164(sp)
81118694:	d8002785 	stb	zero,158(sp)
81118698:	103f0816 	blt	r2,zero,811182bc <__reset+0xfb0f82bc>
8111869c:	00ffdfc4 	movi	r3,-129
811186a0:	a584b03a 	or	r2,r20,r22
811186a4:	90e4703a 	and	r18,r18,r3
811186a8:	103c8126 	beq	r2,zero,811178b0 <__reset+0xfb0f78b0>
811186ac:	0039883a 	mov	fp,zero
811186b0:	003e7606 	br	8111808c <__reset+0xfb0f808c>
811186b4:	9080040c 	andi	r2,r18,16
811186b8:	10013d26 	beq	r2,zero,81118bb0 <___svfprintf_internal_r+0x1650>
811186bc:	d9002d17 	ldw	r4,180(sp)
811186c0:	d9402917 	ldw	r5,164(sp)
811186c4:	d8002785 	stb	zero,158(sp)
811186c8:	20800104 	addi	r2,r4,4
811186cc:	25000017 	ldw	r20,0(r4)
811186d0:	002d883a 	mov	r22,zero
811186d4:	28013f16 	blt	r5,zero,81118bd4 <___svfprintf_internal_r+0x1674>
811186d8:	00ffdfc4 	movi	r3,-129
811186dc:	d8802d15 	stw	r2,180(sp)
811186e0:	90e4703a 	and	r18,r18,r3
811186e4:	a03d2b26 	beq	r20,zero,81117b94 <__reset+0xfb0f7b94>
811186e8:	0039883a 	mov	fp,zero
811186ec:	003d2e06 	br	81117ba8 <__reset+0xfb0f7ba8>
811186f0:	dc402617 	ldw	r17,152(sp)
811186f4:	0441830e 	bge	zero,r17,81118d04 <___svfprintf_internal_r+0x17a4>
811186f8:	dc403217 	ldw	r17,200(sp)
811186fc:	d8803317 	ldw	r2,204(sp)
81118700:	1440010e 	bge	r2,r17,81118708 <___svfprintf_internal_r+0x11a8>
81118704:	1023883a 	mov	r17,r2
81118708:	04400a0e 	bge	zero,r17,81118734 <___svfprintf_internal_r+0x11d4>
8111870c:	d8801f17 	ldw	r2,124(sp)
81118710:	1c47883a 	add	r3,r3,r17
81118714:	44000015 	stw	r16,0(r8)
81118718:	10800044 	addi	r2,r2,1
8111871c:	44400115 	stw	r17,4(r8)
81118720:	d8c02015 	stw	r3,128(sp)
81118724:	d8801f15 	stw	r2,124(sp)
81118728:	010001c4 	movi	r4,7
8111872c:	20827516 	blt	r4,r2,81119104 <___svfprintf_internal_r+0x1ba4>
81118730:	42000204 	addi	r8,r8,8
81118734:	88027b16 	blt	r17,zero,81119124 <___svfprintf_internal_r+0x1bc4>
81118738:	d9003217 	ldw	r4,200(sp)
8111873c:	2463c83a 	sub	r17,r4,r17
81118740:	0440990e 	bge	zero,r17,811189a8 <___svfprintf_internal_r+0x1448>
81118744:	05800404 	movi	r22,16
81118748:	d8801f17 	ldw	r2,124(sp)
8111874c:	b441530e 	bge	r22,r17,81118c9c <___svfprintf_internal_r+0x173c>
81118750:	01204534 	movhi	r4,33044
81118754:	21112584 	addi	r4,r4,17558
81118758:	d9002b15 	stw	r4,172(sp)
8111875c:	070001c4 	movi	fp,7
81118760:	dd002c17 	ldw	r20,176(sp)
81118764:	00000306 	br	81118774 <___svfprintf_internal_r+0x1214>
81118768:	42000204 	addi	r8,r8,8
8111876c:	8c7ffc04 	addi	r17,r17,-16
81118770:	b4414d0e 	bge	r22,r17,81118ca8 <___svfprintf_internal_r+0x1748>
81118774:	18c00404 	addi	r3,r3,16
81118778:	10800044 	addi	r2,r2,1
8111877c:	45400015 	stw	r21,0(r8)
81118780:	45800115 	stw	r22,4(r8)
81118784:	d8c02015 	stw	r3,128(sp)
81118788:	d8801f15 	stw	r2,124(sp)
8111878c:	e0bff60e 	bge	fp,r2,81118768 <__reset+0xfb0f8768>
81118790:	d9801e04 	addi	r6,sp,120
81118794:	a00b883a 	mov	r5,r20
81118798:	9809883a 	mov	r4,r19
8111879c:	11241800 	call	81124180 <__ssprint_r>
811187a0:	103c561e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
811187a4:	d8c02017 	ldw	r3,128(sp)
811187a8:	d8801f17 	ldw	r2,124(sp)
811187ac:	da000404 	addi	r8,sp,16
811187b0:	003fee06 	br	8111876c <__reset+0xfb0f876c>
811187b4:	d9402c17 	ldw	r5,176(sp)
811187b8:	d9801e04 	addi	r6,sp,120
811187bc:	9809883a 	mov	r4,r19
811187c0:	11241800 	call	81124180 <__ssprint_r>
811187c4:	103c4d1e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
811187c8:	d8c02017 	ldw	r3,128(sp)
811187cc:	df002787 	ldb	fp,158(sp)
811187d0:	da000404 	addi	r8,sp,16
811187d4:	003d5a06 	br	81117d40 <__reset+0xfb0f7d40>
811187d8:	9080040c 	andi	r2,r18,16
811187dc:	10005c26 	beq	r2,zero,81118950 <___svfprintf_internal_r+0x13f0>
811187e0:	d9402d17 	ldw	r5,180(sp)
811187e4:	d8c02917 	ldw	r3,164(sp)
811187e8:	d8002785 	stb	zero,158(sp)
811187ec:	28800104 	addi	r2,r5,4
811187f0:	2d000017 	ldw	r20,0(r5)
811187f4:	002d883a 	mov	r22,zero
811187f8:	18005e16 	blt	r3,zero,81118974 <___svfprintf_internal_r+0x1414>
811187fc:	00ffdfc4 	movi	r3,-129
81118800:	d8802d15 	stw	r2,180(sp)
81118804:	90e4703a 	and	r18,r18,r3
81118808:	0039883a 	mov	fp,zero
8111880c:	a03dfe26 	beq	r20,zero,81118008 <__reset+0xfb0f8008>
81118810:	00800244 	movi	r2,9
81118814:	153cb336 	bltu	r2,r20,81117ae4 <__reset+0xfb0f7ae4>
81118818:	a5000c04 	addi	r20,r20,48
8111881c:	dc001dc4 	addi	r16,sp,119
81118820:	dd001dc5 	stb	r20,119(sp)
81118824:	d8c02817 	ldw	r3,160(sp)
81118828:	1c07c83a 	sub	r3,r3,r16
8111882c:	d8c02e15 	stw	r3,184(sp)
81118830:	003cf506 	br	81117c08 <__reset+0xfb0f7c08>
81118834:	d8803317 	ldw	r2,204(sp)
81118838:	143fffc4 	addi	r16,r2,-1
8111883c:	043f560e 	bge	zero,r16,81118598 <__reset+0xfb0f8598>
81118840:	07000404 	movi	fp,16
81118844:	e403530e 	bge	fp,r16,81119594 <___svfprintf_internal_r+0x2034>
81118848:	01604534 	movhi	r5,33044
8111884c:	29512584 	addi	r5,r5,17558
81118850:	d9402b15 	stw	r5,172(sp)
81118854:	01c001c4 	movi	r7,7
81118858:	dd002c17 	ldw	r20,176(sp)
8111885c:	00000306 	br	8111886c <___svfprintf_internal_r+0x130c>
81118860:	843ffc04 	addi	r16,r16,-16
81118864:	b5800204 	addi	r22,r22,8
81118868:	e400130e 	bge	fp,r16,811188b8 <___svfprintf_internal_r+0x1358>
8111886c:	18c00404 	addi	r3,r3,16
81118870:	8c400044 	addi	r17,r17,1
81118874:	b5400015 	stw	r21,0(r22)
81118878:	b7000115 	stw	fp,4(r22)
8111887c:	d8c02015 	stw	r3,128(sp)
81118880:	dc401f15 	stw	r17,124(sp)
81118884:	3c7ff60e 	bge	r7,r17,81118860 <__reset+0xfb0f8860>
81118888:	d9801e04 	addi	r6,sp,120
8111888c:	a00b883a 	mov	r5,r20
81118890:	9809883a 	mov	r4,r19
81118894:	d9c03d15 	stw	r7,244(sp)
81118898:	11241800 	call	81124180 <__ssprint_r>
8111889c:	d9c03d17 	ldw	r7,244(sp)
811188a0:	103c161e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
811188a4:	843ffc04 	addi	r16,r16,-16
811188a8:	d8c02017 	ldw	r3,128(sp)
811188ac:	dc401f17 	ldw	r17,124(sp)
811188b0:	dd800404 	addi	r22,sp,16
811188b4:	e43fed16 	blt	fp,r16,8111886c <__reset+0xfb0f886c>
811188b8:	d8802b17 	ldw	r2,172(sp)
811188bc:	1c07883a 	add	r3,r3,r16
811188c0:	8c400044 	addi	r17,r17,1
811188c4:	b0800015 	stw	r2,0(r22)
811188c8:	b4000115 	stw	r16,4(r22)
811188cc:	d8c02015 	stw	r3,128(sp)
811188d0:	dc401f15 	stw	r17,124(sp)
811188d4:	008001c4 	movi	r2,7
811188d8:	147f2e0e 	bge	r2,r17,81118594 <__reset+0xfb0f8594>
811188dc:	d9402c17 	ldw	r5,176(sp)
811188e0:	d9801e04 	addi	r6,sp,120
811188e4:	9809883a 	mov	r4,r19
811188e8:	11241800 	call	81124180 <__ssprint_r>
811188ec:	103c031e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
811188f0:	d8c02017 	ldw	r3,128(sp)
811188f4:	dc401f17 	ldw	r17,124(sp)
811188f8:	dd800404 	addi	r22,sp,16
811188fc:	003f2606 	br	81118598 <__reset+0xfb0f8598>
81118900:	9080040c 	andi	r2,r18,16
81118904:	1000c326 	beq	r2,zero,81118c14 <___svfprintf_internal_r+0x16b4>
81118908:	d8802d17 	ldw	r2,180(sp)
8111890c:	15000017 	ldw	r20,0(r2)
81118910:	10800104 	addi	r2,r2,4
81118914:	d8802d15 	stw	r2,180(sp)
81118918:	a02dd7fa 	srai	r22,r20,31
8111891c:	b005883a 	mov	r2,r22
81118920:	103c680e 	bge	r2,zero,81117ac4 <__reset+0xfb0f7ac4>
81118924:	0529c83a 	sub	r20,zero,r20
81118928:	a004c03a 	cmpne	r2,r20,zero
8111892c:	05adc83a 	sub	r22,zero,r22
81118930:	b0adc83a 	sub	r22,r22,r2
81118934:	d8802917 	ldw	r2,164(sp)
81118938:	07000b44 	movi	fp,45
8111893c:	df002785 	stb	fp,158(sp)
81118940:	10022e16 	blt	r2,zero,811191fc <___svfprintf_internal_r+0x1c9c>
81118944:	00bfdfc4 	movi	r2,-129
81118948:	90a4703a 	and	r18,r18,r2
8111894c:	003c6406 	br	81117ae0 <__reset+0xfb0f7ae0>
81118950:	9080100c 	andi	r2,r18,64
81118954:	d8002785 	stb	zero,158(sp)
81118958:	10012526 	beq	r2,zero,81118df0 <___svfprintf_internal_r+0x1890>
8111895c:	d9002d17 	ldw	r4,180(sp)
81118960:	d9402917 	ldw	r5,164(sp)
81118964:	002d883a 	mov	r22,zero
81118968:	20800104 	addi	r2,r4,4
8111896c:	2500000b 	ldhu	r20,0(r4)
81118970:	283fa20e 	bge	r5,zero,811187fc <__reset+0xfb0f87fc>
81118974:	d8802d15 	stw	r2,180(sp)
81118978:	0039883a 	mov	fp,zero
8111897c:	a584b03a 	or	r2,r20,r22
81118980:	103c571e 	bne	r2,zero,81117ae0 <__reset+0xfb0f7ae0>
81118984:	00800044 	movi	r2,1
81118988:	003e5006 	br	811182cc <__reset+0xfb0f82cc>
8111898c:	d9402c17 	ldw	r5,176(sp)
81118990:	d9801e04 	addi	r6,sp,120
81118994:	9809883a 	mov	r4,r19
81118998:	11241800 	call	81124180 <__ssprint_r>
8111899c:	103bd71e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
811189a0:	d8c02017 	ldw	r3,128(sp)
811189a4:	da000404 	addi	r8,sp,16
811189a8:	d9003217 	ldw	r4,200(sp)
811189ac:	d8802617 	ldw	r2,152(sp)
811189b0:	d9403317 	ldw	r5,204(sp)
811189b4:	8123883a 	add	r17,r16,r4
811189b8:	11400216 	blt	r2,r5,811189c4 <___svfprintf_internal_r+0x1464>
811189bc:	9100004c 	andi	r4,r18,1
811189c0:	20000d26 	beq	r4,zero,811189f8 <___svfprintf_internal_r+0x1498>
811189c4:	d9003817 	ldw	r4,224(sp)
811189c8:	d9403417 	ldw	r5,208(sp)
811189cc:	1907883a 	add	r3,r3,r4
811189d0:	d9001f17 	ldw	r4,124(sp)
811189d4:	41400015 	stw	r5,0(r8)
811189d8:	d9403817 	ldw	r5,224(sp)
811189dc:	21000044 	addi	r4,r4,1
811189e0:	d8c02015 	stw	r3,128(sp)
811189e4:	41400115 	stw	r5,4(r8)
811189e8:	d9001f15 	stw	r4,124(sp)
811189ec:	014001c4 	movi	r5,7
811189f0:	2901dc16 	blt	r5,r4,81119164 <___svfprintf_internal_r+0x1c04>
811189f4:	42000204 	addi	r8,r8,8
811189f8:	d9003317 	ldw	r4,204(sp)
811189fc:	8121883a 	add	r16,r16,r4
81118a00:	2085c83a 	sub	r2,r4,r2
81118a04:	8461c83a 	sub	r16,r16,r17
81118a08:	1400010e 	bge	r2,r16,81118a10 <___svfprintf_internal_r+0x14b0>
81118a0c:	1021883a 	mov	r16,r2
81118a10:	04000a0e 	bge	zero,r16,81118a3c <___svfprintf_internal_r+0x14dc>
81118a14:	d9001f17 	ldw	r4,124(sp)
81118a18:	1c07883a 	add	r3,r3,r16
81118a1c:	44400015 	stw	r17,0(r8)
81118a20:	21000044 	addi	r4,r4,1
81118a24:	44000115 	stw	r16,4(r8)
81118a28:	d8c02015 	stw	r3,128(sp)
81118a2c:	d9001f15 	stw	r4,124(sp)
81118a30:	014001c4 	movi	r5,7
81118a34:	2901e616 	blt	r5,r4,811191d0 <___svfprintf_internal_r+0x1c70>
81118a38:	42000204 	addi	r8,r8,8
81118a3c:	8001f616 	blt	r16,zero,81119218 <___svfprintf_internal_r+0x1cb8>
81118a40:	1421c83a 	sub	r16,r2,r16
81118a44:	043d1c0e 	bge	zero,r16,81117eb8 <__reset+0xfb0f7eb8>
81118a48:	04400404 	movi	r17,16
81118a4c:	d8801f17 	ldw	r2,124(sp)
81118a50:	8c3edd0e 	bge	r17,r16,811185c8 <__reset+0xfb0f85c8>
81118a54:	01604534 	movhi	r5,33044
81118a58:	29512584 	addi	r5,r5,17558
81118a5c:	d9402b15 	stw	r5,172(sp)
81118a60:	058001c4 	movi	r22,7
81118a64:	dd002c17 	ldw	r20,176(sp)
81118a68:	00000306 	br	81118a78 <___svfprintf_internal_r+0x1518>
81118a6c:	42000204 	addi	r8,r8,8
81118a70:	843ffc04 	addi	r16,r16,-16
81118a74:	8c3ed70e 	bge	r17,r16,811185d4 <__reset+0xfb0f85d4>
81118a78:	18c00404 	addi	r3,r3,16
81118a7c:	10800044 	addi	r2,r2,1
81118a80:	45400015 	stw	r21,0(r8)
81118a84:	44400115 	stw	r17,4(r8)
81118a88:	d8c02015 	stw	r3,128(sp)
81118a8c:	d8801f15 	stw	r2,124(sp)
81118a90:	b0bff60e 	bge	r22,r2,81118a6c <__reset+0xfb0f8a6c>
81118a94:	d9801e04 	addi	r6,sp,120
81118a98:	a00b883a 	mov	r5,r20
81118a9c:	9809883a 	mov	r4,r19
81118aa0:	11241800 	call	81124180 <__ssprint_r>
81118aa4:	103b951e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118aa8:	d8c02017 	ldw	r3,128(sp)
81118aac:	d8801f17 	ldw	r2,124(sp)
81118ab0:	da000404 	addi	r8,sp,16
81118ab4:	003fee06 	br	81118a70 <__reset+0xfb0f8a70>
81118ab8:	9088703a 	and	r4,r18,r2
81118abc:	203e8d1e 	bne	r4,zero,811184f4 <__reset+0xfb0f84f4>
81118ac0:	dc401f17 	ldw	r17,124(sp)
81118ac4:	40800115 	stw	r2,4(r8)
81118ac8:	44000015 	stw	r16,0(r8)
81118acc:	8c400044 	addi	r17,r17,1
81118ad0:	d8c02015 	stw	r3,128(sp)
81118ad4:	dc401f15 	stw	r17,124(sp)
81118ad8:	008001c4 	movi	r2,7
81118adc:	147f7f16 	blt	r2,r17,811188dc <__reset+0xfb0f88dc>
81118ae0:	45800204 	addi	r22,r8,8
81118ae4:	003eac06 	br	81118598 <__reset+0xfb0f8598>
81118ae8:	d9402c17 	ldw	r5,176(sp)
81118aec:	d9801e04 	addi	r6,sp,120
81118af0:	9809883a 	mov	r4,r19
81118af4:	11241800 	call	81124180 <__ssprint_r>
81118af8:	103b801e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118afc:	d8c02017 	ldw	r3,128(sp)
81118b00:	dc401f17 	ldw	r17,124(sp)
81118b04:	da000404 	addi	r8,sp,16
81118b08:	003e8406 	br	8111851c <__reset+0xfb0f851c>
81118b0c:	d9402c17 	ldw	r5,176(sp)
81118b10:	d9801e04 	addi	r6,sp,120
81118b14:	9809883a 	mov	r4,r19
81118b18:	11241800 	call	81124180 <__ssprint_r>
81118b1c:	103b771e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118b20:	d8c02017 	ldw	r3,128(sp)
81118b24:	dc401f17 	ldw	r17,124(sp)
81118b28:	dd800404 	addi	r22,sp,16
81118b2c:	003e8606 	br	81118548 <__reset+0xfb0f8548>
81118b30:	0029883a 	mov	r20,zero
81118b34:	a5000c04 	addi	r20,r20,48
81118b38:	dc001dc4 	addi	r16,sp,119
81118b3c:	dd001dc5 	stb	r20,119(sp)
81118b40:	003f3806 	br	81118824 <__reset+0xfb0f8824>
81118b44:	d9402c17 	ldw	r5,176(sp)
81118b48:	d9801e04 	addi	r6,sp,120
81118b4c:	9809883a 	mov	r4,r19
81118b50:	11241800 	call	81124180 <__ssprint_r>
81118b54:	103b691e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118b58:	d8c02017 	ldw	r3,128(sp)
81118b5c:	da000404 	addi	r8,sp,16
81118b60:	003c9506 	br	81117db8 <__reset+0xfb0f7db8>
81118b64:	d9003617 	ldw	r4,216(sp)
81118b68:	d9403717 	ldw	r5,220(sp)
81118b6c:	da003e15 	stw	r8,248(sp)
81118b70:	1121f940 	call	81121f94 <__fpclassifyd>
81118b74:	da003e17 	ldw	r8,248(sp)
81118b78:	1000bd1e 	bne	r2,zero,81118e70 <___svfprintf_internal_r+0x1910>
81118b7c:	008011c4 	movi	r2,71
81118b80:	14411e0e 	bge	r2,r17,81118ffc <___svfprintf_internal_r+0x1a9c>
81118b84:	04204534 	movhi	r16,33044
81118b88:	84111804 	addi	r16,r16,17504
81118b8c:	00c000c4 	movi	r3,3
81118b90:	00bfdfc4 	movi	r2,-129
81118b94:	d8c02a15 	stw	r3,168(sp)
81118b98:	90a4703a 	and	r18,r18,r2
81118b9c:	df002783 	ldbu	fp,158(sp)
81118ba0:	d8c02e15 	stw	r3,184(sp)
81118ba4:	d8002915 	stw	zero,164(sp)
81118ba8:	d8003215 	stw	zero,200(sp)
81118bac:	003c1c06 	br	81117c20 <__reset+0xfb0f7c20>
81118bb0:	9080100c 	andi	r2,r18,64
81118bb4:	d8002785 	stb	zero,158(sp)
81118bb8:	10009426 	beq	r2,zero,81118e0c <___svfprintf_internal_r+0x18ac>
81118bbc:	d8c02d17 	ldw	r3,180(sp)
81118bc0:	d9002917 	ldw	r4,164(sp)
81118bc4:	002d883a 	mov	r22,zero
81118bc8:	18800104 	addi	r2,r3,4
81118bcc:	1d00000b 	ldhu	r20,0(r3)
81118bd0:	203ec10e 	bge	r4,zero,811186d8 <__reset+0xfb0f86d8>
81118bd4:	a586b03a 	or	r3,r20,r22
81118bd8:	d8802d15 	stw	r2,180(sp)
81118bdc:	183ec21e 	bne	r3,zero,811186e8 <__reset+0xfb0f86e8>
81118be0:	0039883a 	mov	fp,zero
81118be4:	0005883a 	mov	r2,zero
81118be8:	003db806 	br	811182cc <__reset+0xfb0f82cc>
81118bec:	d8802d17 	ldw	r2,180(sp)
81118bf0:	d8c02d17 	ldw	r3,180(sp)
81118bf4:	d9002d17 	ldw	r4,180(sp)
81118bf8:	10800017 	ldw	r2,0(r2)
81118bfc:	18c00117 	ldw	r3,4(r3)
81118c00:	21000204 	addi	r4,r4,8
81118c04:	d8803615 	stw	r2,216(sp)
81118c08:	d8c03715 	stw	r3,220(sp)
81118c0c:	d9002d15 	stw	r4,180(sp)
81118c10:	003b8206 	br	81117a1c <__reset+0xfb0f7a1c>
81118c14:	9080100c 	andi	r2,r18,64
81118c18:	10010726 	beq	r2,zero,81119038 <___svfprintf_internal_r+0x1ad8>
81118c1c:	d8c02d17 	ldw	r3,180(sp)
81118c20:	1d00000f 	ldh	r20,0(r3)
81118c24:	18c00104 	addi	r3,r3,4
81118c28:	d8c02d15 	stw	r3,180(sp)
81118c2c:	a02dd7fa 	srai	r22,r20,31
81118c30:	b005883a 	mov	r2,r22
81118c34:	003ba206 	br	81117ac0 <__reset+0xfb0f7ac0>
81118c38:	9080100c 	andi	r2,r18,64
81118c3c:	10010526 	beq	r2,zero,81119054 <___svfprintf_internal_r+0x1af4>
81118c40:	d9002d17 	ldw	r4,180(sp)
81118c44:	002d883a 	mov	r22,zero
81118c48:	2500000b 	ldhu	r20,0(r4)
81118c4c:	21000104 	addi	r4,r4,4
81118c50:	d9002d15 	stw	r4,180(sp)
81118c54:	003cfe06 	br	81118050 <__reset+0xfb0f8050>
81118c58:	bc400007 	ldb	r17,0(r23)
81118c5c:	003a9606 	br	811176b8 <__reset+0xfb0f76b8>
81118c60:	9080040c 	andi	r2,r18,16
81118c64:	10010126 	beq	r2,zero,8111906c <___svfprintf_internal_r+0x1b0c>
81118c68:	d9402d17 	ldw	r5,180(sp)
81118c6c:	d8c02f17 	ldw	r3,188(sp)
81118c70:	28800017 	ldw	r2,0(r5)
81118c74:	29400104 	addi	r5,r5,4
81118c78:	d9402d15 	stw	r5,180(sp)
81118c7c:	10c00015 	stw	r3,0(r2)
81118c80:	003a6406 	br	81117614 <__reset+0xfb0f7614>
81118c84:	d9002917 	ldw	r4,164(sp)
81118c88:	d8002785 	stb	zero,158(sp)
81118c8c:	203d8d16 	blt	r4,zero,811182c4 <__reset+0xfb0f82c4>
81118c90:	00bfdfc4 	movi	r2,-129
81118c94:	90a4703a 	and	r18,r18,r2
81118c98:	003b0506 	br	811178b0 <__reset+0xfb0f78b0>
81118c9c:	01604534 	movhi	r5,33044
81118ca0:	29512584 	addi	r5,r5,17558
81118ca4:	d9402b15 	stw	r5,172(sp)
81118ca8:	d9402b17 	ldw	r5,172(sp)
81118cac:	1c47883a 	add	r3,r3,r17
81118cb0:	10800044 	addi	r2,r2,1
81118cb4:	41400015 	stw	r5,0(r8)
81118cb8:	44400115 	stw	r17,4(r8)
81118cbc:	d8c02015 	stw	r3,128(sp)
81118cc0:	d8801f15 	stw	r2,124(sp)
81118cc4:	010001c4 	movi	r4,7
81118cc8:	20bf3016 	blt	r4,r2,8111898c <__reset+0xfb0f898c>
81118ccc:	42000204 	addi	r8,r8,8
81118cd0:	003f3506 	br	811189a8 <__reset+0xfb0f89a8>
81118cd4:	01204534 	movhi	r4,33044
81118cd8:	21112584 	addi	r4,r4,17558
81118cdc:	d9002b15 	stw	r4,172(sp)
81118ce0:	003c5e06 	br	81117e5c <__reset+0xfb0f7e5c>
81118ce4:	d9402c17 	ldw	r5,176(sp)
81118ce8:	d9801e04 	addi	r6,sp,120
81118cec:	9809883a 	mov	r4,r19
81118cf0:	11241800 	call	81124180 <__ssprint_r>
81118cf4:	103b011e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118cf8:	d8c02017 	ldw	r3,128(sp)
81118cfc:	da000404 	addi	r8,sp,16
81118d00:	003d9306 	br	81118350 <__reset+0xfb0f8350>
81118d04:	d8801f17 	ldw	r2,124(sp)
81118d08:	01604534 	movhi	r5,33044
81118d0c:	01000044 	movi	r4,1
81118d10:	18c00044 	addi	r3,r3,1
81118d14:	10800044 	addi	r2,r2,1
81118d18:	29512504 	addi	r5,r5,17556
81118d1c:	41000115 	stw	r4,4(r8)
81118d20:	41400015 	stw	r5,0(r8)
81118d24:	d8c02015 	stw	r3,128(sp)
81118d28:	d8801f15 	stw	r2,124(sp)
81118d2c:	010001c4 	movi	r4,7
81118d30:	2080b516 	blt	r4,r2,81119008 <___svfprintf_internal_r+0x1aa8>
81118d34:	42000204 	addi	r8,r8,8
81118d38:	8800041e 	bne	r17,zero,81118d4c <___svfprintf_internal_r+0x17ec>
81118d3c:	d8803317 	ldw	r2,204(sp)
81118d40:	1000021e 	bne	r2,zero,81118d4c <___svfprintf_internal_r+0x17ec>
81118d44:	9080004c 	andi	r2,r18,1
81118d48:	103c5b26 	beq	r2,zero,81117eb8 <__reset+0xfb0f7eb8>
81118d4c:	d9003817 	ldw	r4,224(sp)
81118d50:	d8801f17 	ldw	r2,124(sp)
81118d54:	d9403417 	ldw	r5,208(sp)
81118d58:	20c7883a 	add	r3,r4,r3
81118d5c:	10800044 	addi	r2,r2,1
81118d60:	41000115 	stw	r4,4(r8)
81118d64:	41400015 	stw	r5,0(r8)
81118d68:	d8c02015 	stw	r3,128(sp)
81118d6c:	d8801f15 	stw	r2,124(sp)
81118d70:	010001c4 	movi	r4,7
81118d74:	20818016 	blt	r4,r2,81119378 <___svfprintf_internal_r+0x1e18>
81118d78:	42000204 	addi	r8,r8,8
81118d7c:	0463c83a 	sub	r17,zero,r17
81118d80:	0440cb0e 	bge	zero,r17,811190b0 <___svfprintf_internal_r+0x1b50>
81118d84:	05800404 	movi	r22,16
81118d88:	b440e80e 	bge	r22,r17,8111912c <___svfprintf_internal_r+0x1bcc>
81118d8c:	01604534 	movhi	r5,33044
81118d90:	29512584 	addi	r5,r5,17558
81118d94:	d9402b15 	stw	r5,172(sp)
81118d98:	070001c4 	movi	fp,7
81118d9c:	dd002c17 	ldw	r20,176(sp)
81118da0:	00000306 	br	81118db0 <___svfprintf_internal_r+0x1850>
81118da4:	42000204 	addi	r8,r8,8
81118da8:	8c7ffc04 	addi	r17,r17,-16
81118dac:	b440e20e 	bge	r22,r17,81119138 <___svfprintf_internal_r+0x1bd8>
81118db0:	18c00404 	addi	r3,r3,16
81118db4:	10800044 	addi	r2,r2,1
81118db8:	45400015 	stw	r21,0(r8)
81118dbc:	45800115 	stw	r22,4(r8)
81118dc0:	d8c02015 	stw	r3,128(sp)
81118dc4:	d8801f15 	stw	r2,124(sp)
81118dc8:	e0bff60e 	bge	fp,r2,81118da4 <__reset+0xfb0f8da4>
81118dcc:	d9801e04 	addi	r6,sp,120
81118dd0:	a00b883a 	mov	r5,r20
81118dd4:	9809883a 	mov	r4,r19
81118dd8:	11241800 	call	81124180 <__ssprint_r>
81118ddc:	103ac71e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118de0:	d8c02017 	ldw	r3,128(sp)
81118de4:	d8801f17 	ldw	r2,124(sp)
81118de8:	da000404 	addi	r8,sp,16
81118dec:	003fee06 	br	81118da8 <__reset+0xfb0f8da8>
81118df0:	d8c02d17 	ldw	r3,180(sp)
81118df4:	d9002917 	ldw	r4,164(sp)
81118df8:	002d883a 	mov	r22,zero
81118dfc:	18800104 	addi	r2,r3,4
81118e00:	1d000017 	ldw	r20,0(r3)
81118e04:	203e7d0e 	bge	r4,zero,811187fc <__reset+0xfb0f87fc>
81118e08:	003eda06 	br	81118974 <__reset+0xfb0f8974>
81118e0c:	d9402d17 	ldw	r5,180(sp)
81118e10:	d8c02917 	ldw	r3,164(sp)
81118e14:	002d883a 	mov	r22,zero
81118e18:	28800104 	addi	r2,r5,4
81118e1c:	2d000017 	ldw	r20,0(r5)
81118e20:	183e2d0e 	bge	r3,zero,811186d8 <__reset+0xfb0f86d8>
81118e24:	003f6b06 	br	81118bd4 <__reset+0xfb0f8bd4>
81118e28:	d8c02d15 	stw	r3,180(sp)
81118e2c:	0039883a 	mov	fp,zero
81118e30:	003ed206 	br	8111897c <__reset+0xfb0f897c>
81118e34:	bc400043 	ldbu	r17,1(r23)
81118e38:	94800814 	ori	r18,r18,32
81118e3c:	bdc00044 	addi	r23,r23,1
81118e40:	8c403fcc 	andi	r17,r17,255
81118e44:	8c40201c 	xori	r17,r17,128
81118e48:	8c7fe004 	addi	r17,r17,-128
81118e4c:	003a1a06 	br	811176b8 <__reset+0xfb0f76b8>
81118e50:	d9402c17 	ldw	r5,176(sp)
81118e54:	d9801e04 	addi	r6,sp,120
81118e58:	9809883a 	mov	r4,r19
81118e5c:	11241800 	call	81124180 <__ssprint_r>
81118e60:	103aa61e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81118e64:	d8c02017 	ldw	r3,128(sp)
81118e68:	da000404 	addi	r8,sp,16
81118e6c:	003d4a06 	br	81118398 <__reset+0xfb0f8398>
81118e70:	d9002917 	ldw	r4,164(sp)
81118e74:	05bff7c4 	movi	r22,-33
81118e78:	00bfffc4 	movi	r2,-1
81118e7c:	8dac703a 	and	r22,r17,r22
81118e80:	20806a26 	beq	r4,r2,8111902c <___svfprintf_internal_r+0x1acc>
81118e84:	008011c4 	movi	r2,71
81118e88:	b0813726 	beq	r22,r2,81119368 <___svfprintf_internal_r+0x1e08>
81118e8c:	d9003717 	ldw	r4,220(sp)
81118e90:	90c04014 	ori	r3,r18,256
81118e94:	d8c02b15 	stw	r3,172(sp)
81118e98:	20015d16 	blt	r4,zero,81119410 <___svfprintf_internal_r+0x1eb0>
81118e9c:	dd003717 	ldw	r20,220(sp)
81118ea0:	d8002a05 	stb	zero,168(sp)
81118ea4:	00801984 	movi	r2,102
81118ea8:	88814026 	beq	r17,r2,811193ac <___svfprintf_internal_r+0x1e4c>
81118eac:	00801184 	movi	r2,70
81118eb0:	88817126 	beq	r17,r2,81119478 <___svfprintf_internal_r+0x1f18>
81118eb4:	00801144 	movi	r2,69
81118eb8:	b0816226 	beq	r22,r2,81119444 <___svfprintf_internal_r+0x1ee4>
81118ebc:	d8c02917 	ldw	r3,164(sp)
81118ec0:	d8802104 	addi	r2,sp,132
81118ec4:	d8800315 	stw	r2,12(sp)
81118ec8:	d9403617 	ldw	r5,216(sp)
81118ecc:	d8802504 	addi	r2,sp,148
81118ed0:	d8800215 	stw	r2,8(sp)
81118ed4:	d8802604 	addi	r2,sp,152
81118ed8:	d8c00015 	stw	r3,0(sp)
81118edc:	d8800115 	stw	r2,4(sp)
81118ee0:	01c00084 	movi	r7,2
81118ee4:	a00d883a 	mov	r6,r20
81118ee8:	9809883a 	mov	r4,r19
81118eec:	d8c03d15 	stw	r3,244(sp)
81118ef0:	da003e15 	stw	r8,248(sp)
81118ef4:	111d84c0 	call	8111d84c <_dtoa_r>
81118ef8:	1021883a 	mov	r16,r2
81118efc:	008019c4 	movi	r2,103
81118f00:	d8c03d17 	ldw	r3,244(sp)
81118f04:	da003e17 	ldw	r8,248(sp)
81118f08:	8880e726 	beq	r17,r2,811192a8 <___svfprintf_internal_r+0x1d48>
81118f0c:	008011c4 	movi	r2,71
81118f10:	8880d426 	beq	r17,r2,81119264 <___svfprintf_internal_r+0x1d04>
81118f14:	80f9883a 	add	fp,r16,r3
81118f18:	d9003617 	ldw	r4,216(sp)
81118f1c:	000d883a 	mov	r6,zero
81118f20:	000f883a 	mov	r7,zero
81118f24:	a00b883a 	mov	r5,r20
81118f28:	da003e15 	stw	r8,248(sp)
81118f2c:	112a1780 	call	8112a178 <__eqdf2>
81118f30:	da003e17 	ldw	r8,248(sp)
81118f34:	1000e426 	beq	r2,zero,811192c8 <___svfprintf_internal_r+0x1d68>
81118f38:	d8802117 	ldw	r2,132(sp)
81118f3c:	1700062e 	bgeu	r2,fp,81118f58 <___svfprintf_internal_r+0x19f8>
81118f40:	01000c04 	movi	r4,48
81118f44:	10c00044 	addi	r3,r2,1
81118f48:	d8c02115 	stw	r3,132(sp)
81118f4c:	11000005 	stb	r4,0(r2)
81118f50:	d8802117 	ldw	r2,132(sp)
81118f54:	173ffb36 	bltu	r2,fp,81118f44 <__reset+0xfb0f8f44>
81118f58:	1405c83a 	sub	r2,r2,r16
81118f5c:	d8803315 	stw	r2,204(sp)
81118f60:	008011c4 	movi	r2,71
81118f64:	b080c526 	beq	r22,r2,8111927c <___svfprintf_internal_r+0x1d1c>
81118f68:	00801944 	movi	r2,101
81118f6c:	1441d90e 	bge	r2,r17,811196d4 <___svfprintf_internal_r+0x2174>
81118f70:	d8c02617 	ldw	r3,152(sp)
81118f74:	00801984 	movi	r2,102
81118f78:	d8c03215 	stw	r3,200(sp)
81118f7c:	88813426 	beq	r17,r2,81119450 <___svfprintf_internal_r+0x1ef0>
81118f80:	d8c03217 	ldw	r3,200(sp)
81118f84:	d9003317 	ldw	r4,204(sp)
81118f88:	19012516 	blt	r3,r4,81119420 <___svfprintf_internal_r+0x1ec0>
81118f8c:	9480004c 	andi	r18,r18,1
81118f90:	9001841e 	bne	r18,zero,811195a4 <___svfprintf_internal_r+0x2044>
81118f94:	1805883a 	mov	r2,r3
81118f98:	1801cc16 	blt	r3,zero,811196cc <___svfprintf_internal_r+0x216c>
81118f9c:	d8c03217 	ldw	r3,200(sp)
81118fa0:	044019c4 	movi	r17,103
81118fa4:	d8c02e15 	stw	r3,184(sp)
81118fa8:	df002a07 	ldb	fp,168(sp)
81118fac:	e000a61e 	bne	fp,zero,81119248 <___svfprintf_internal_r+0x1ce8>
81118fb0:	df002783 	ldbu	fp,158(sp)
81118fb4:	d8802a15 	stw	r2,168(sp)
81118fb8:	dc802b17 	ldw	r18,172(sp)
81118fbc:	d8002915 	stw	zero,164(sp)
81118fc0:	003b1706 	br	81117c20 <__reset+0xfb0f7c20>
81118fc4:	04204534 	movhi	r16,33044
81118fc8:	84111504 	addi	r16,r16,17492
81118fcc:	003aa606 	br	81117a68 <__reset+0xfb0f7a68>
81118fd0:	d9003917 	ldw	r4,228(sp)
81118fd4:	04001004 	movi	r16,64
81118fd8:	800b883a 	mov	r5,r16
81118fdc:	1115f200 	call	81115f20 <_malloc_r>
81118fe0:	d9002c17 	ldw	r4,176(sp)
81118fe4:	20800015 	stw	r2,0(r4)
81118fe8:	20800415 	stw	r2,16(r4)
81118fec:	1001cb26 	beq	r2,zero,8111971c <___svfprintf_internal_r+0x21bc>
81118ff0:	d8802c17 	ldw	r2,176(sp)
81118ff4:	14000515 	stw	r16,20(r2)
81118ff8:	00397606 	br	811175d4 <__reset+0xfb0f75d4>
81118ffc:	04204534 	movhi	r16,33044
81119000:	84111704 	addi	r16,r16,17500
81119004:	003ee106 	br	81118b8c <__reset+0xfb0f8b8c>
81119008:	d9402c17 	ldw	r5,176(sp)
8111900c:	d9801e04 	addi	r6,sp,120
81119010:	9809883a 	mov	r4,r19
81119014:	11241800 	call	81124180 <__ssprint_r>
81119018:	103a381e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
8111901c:	dc402617 	ldw	r17,152(sp)
81119020:	d8c02017 	ldw	r3,128(sp)
81119024:	da000404 	addi	r8,sp,16
81119028:	003f4306 	br	81118d38 <__reset+0xfb0f8d38>
8111902c:	01400184 	movi	r5,6
81119030:	d9402915 	stw	r5,164(sp)
81119034:	003f9506 	br	81118e8c <__reset+0xfb0f8e8c>
81119038:	d9002d17 	ldw	r4,180(sp)
8111903c:	25000017 	ldw	r20,0(r4)
81119040:	21000104 	addi	r4,r4,4
81119044:	d9002d15 	stw	r4,180(sp)
81119048:	a02dd7fa 	srai	r22,r20,31
8111904c:	b005883a 	mov	r2,r22
81119050:	003a9b06 	br	81117ac0 <__reset+0xfb0f7ac0>
81119054:	d9402d17 	ldw	r5,180(sp)
81119058:	002d883a 	mov	r22,zero
8111905c:	2d000017 	ldw	r20,0(r5)
81119060:	29400104 	addi	r5,r5,4
81119064:	d9402d15 	stw	r5,180(sp)
81119068:	003bf906 	br	81118050 <__reset+0xfb0f8050>
8111906c:	9480100c 	andi	r18,r18,64
81119070:	90006e26 	beq	r18,zero,8111922c <___svfprintf_internal_r+0x1ccc>
81119074:	d9002d17 	ldw	r4,180(sp)
81119078:	d9402f17 	ldw	r5,188(sp)
8111907c:	20800017 	ldw	r2,0(r4)
81119080:	21000104 	addi	r4,r4,4
81119084:	d9002d15 	stw	r4,180(sp)
81119088:	1140000d 	sth	r5,0(r2)
8111908c:	00396106 	br	81117614 <__reset+0xfb0f7614>
81119090:	d9402c17 	ldw	r5,176(sp)
81119094:	d9801e04 	addi	r6,sp,120
81119098:	9809883a 	mov	r4,r19
8111909c:	11241800 	call	81124180 <__ssprint_r>
811190a0:	103a161e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
811190a4:	d8c02017 	ldw	r3,128(sp)
811190a8:	d8801f17 	ldw	r2,124(sp)
811190ac:	da000404 	addi	r8,sp,16
811190b0:	d9403317 	ldw	r5,204(sp)
811190b4:	10800044 	addi	r2,r2,1
811190b8:	44000015 	stw	r16,0(r8)
811190bc:	28c7883a 	add	r3,r5,r3
811190c0:	003b7706 	br	81117ea0 <__reset+0xfb0f7ea0>
811190c4:	8009883a 	mov	r4,r16
811190c8:	da003e15 	stw	r8,248(sp)
811190cc:	11172280 	call	81117228 <strlen>
811190d0:	d8802e15 	stw	r2,184(sp)
811190d4:	da003e17 	ldw	r8,248(sp)
811190d8:	103c280e 	bge	r2,zero,8111817c <__reset+0xfb0f817c>
811190dc:	0005883a 	mov	r2,zero
811190e0:	003c2606 	br	8111817c <__reset+0xfb0f817c>
811190e4:	00bfffc4 	movi	r2,-1
811190e8:	003a0906 	br	81117910 <__reset+0xfb0f7910>
811190ec:	01204534 	movhi	r4,33044
811190f0:	21112984 	addi	r4,r4,17574
811190f4:	d9003515 	stw	r4,212(sp)
811190f8:	003b0606 	br	81117d14 <__reset+0xfb0f7d14>
811190fc:	013fffc4 	movi	r4,-1
81119100:	003a2706 	br	811179a0 <__reset+0xfb0f79a0>
81119104:	d9402c17 	ldw	r5,176(sp)
81119108:	d9801e04 	addi	r6,sp,120
8111910c:	9809883a 	mov	r4,r19
81119110:	11241800 	call	81124180 <__ssprint_r>
81119114:	1039f91e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81119118:	d8c02017 	ldw	r3,128(sp)
8111911c:	da000404 	addi	r8,sp,16
81119120:	003d8406 	br	81118734 <__reset+0xfb0f8734>
81119124:	0023883a 	mov	r17,zero
81119128:	003d8306 	br	81118738 <__reset+0xfb0f8738>
8111912c:	01204534 	movhi	r4,33044
81119130:	21112584 	addi	r4,r4,17558
81119134:	d9002b15 	stw	r4,172(sp)
81119138:	d9002b17 	ldw	r4,172(sp)
8111913c:	1c47883a 	add	r3,r3,r17
81119140:	10800044 	addi	r2,r2,1
81119144:	41000015 	stw	r4,0(r8)
81119148:	44400115 	stw	r17,4(r8)
8111914c:	d8c02015 	stw	r3,128(sp)
81119150:	d8801f15 	stw	r2,124(sp)
81119154:	010001c4 	movi	r4,7
81119158:	20bfcd16 	blt	r4,r2,81119090 <__reset+0xfb0f9090>
8111915c:	42000204 	addi	r8,r8,8
81119160:	003fd306 	br	811190b0 <__reset+0xfb0f90b0>
81119164:	d9402c17 	ldw	r5,176(sp)
81119168:	d9801e04 	addi	r6,sp,120
8111916c:	9809883a 	mov	r4,r19
81119170:	11241800 	call	81124180 <__ssprint_r>
81119174:	1039e11e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
81119178:	d8802617 	ldw	r2,152(sp)
8111917c:	d8c02017 	ldw	r3,128(sp)
81119180:	da000404 	addi	r8,sp,16
81119184:	003e1c06 	br	811189f8 <__reset+0xfb0f89f8>
81119188:	d8802917 	ldw	r2,164(sp)
8111918c:	00c00184 	movi	r3,6
81119190:	1880012e 	bgeu	r3,r2,81119198 <___svfprintf_internal_r+0x1c38>
81119194:	1805883a 	mov	r2,r3
81119198:	d8802e15 	stw	r2,184(sp)
8111919c:	1000f316 	blt	r2,zero,8111956c <___svfprintf_internal_r+0x200c>
811191a0:	04204534 	movhi	r16,33044
811191a4:	d8802a15 	stw	r2,168(sp)
811191a8:	dd002d15 	stw	r20,180(sp)
811191ac:	d8002915 	stw	zero,164(sp)
811191b0:	d8003215 	stw	zero,200(sp)
811191b4:	84112304 	addi	r16,r16,17548
811191b8:	0039883a 	mov	fp,zero
811191bc:	003a9f06 	br	81117c3c <__reset+0xfb0f7c3c>
811191c0:	01204534 	movhi	r4,33044
811191c4:	21112984 	addi	r4,r4,17574
811191c8:	d9003515 	stw	r4,212(sp)
811191cc:	003b5f06 	br	81117f4c <__reset+0xfb0f7f4c>
811191d0:	d9402c17 	ldw	r5,176(sp)
811191d4:	d9801e04 	addi	r6,sp,120
811191d8:	9809883a 	mov	r4,r19
811191dc:	11241800 	call	81124180 <__ssprint_r>
811191e0:	1039c61e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
811191e4:	d8802617 	ldw	r2,152(sp)
811191e8:	d9403317 	ldw	r5,204(sp)
811191ec:	d8c02017 	ldw	r3,128(sp)
811191f0:	da000404 	addi	r8,sp,16
811191f4:	2885c83a 	sub	r2,r5,r2
811191f8:	003e1006 	br	81118a3c <__reset+0xfb0f8a3c>
811191fc:	00800044 	movi	r2,1
81119200:	10803fcc 	andi	r2,r2,255
81119204:	00c00044 	movi	r3,1
81119208:	10fa3526 	beq	r2,r3,81117ae0 <__reset+0xfb0f7ae0>
8111920c:	00c00084 	movi	r3,2
81119210:	10fb9e26 	beq	r2,r3,8111808c <__reset+0xfb0f808c>
81119214:	003a6406 	br	81117ba8 <__reset+0xfb0f7ba8>
81119218:	0021883a 	mov	r16,zero
8111921c:	003e0806 	br	81118a40 <__reset+0xfb0f8a40>
81119220:	07000b44 	movi	fp,45
81119224:	df002785 	stb	fp,158(sp)
81119228:	003a0b06 	br	81117a58 <__reset+0xfb0f7a58>
8111922c:	d8c02d17 	ldw	r3,180(sp)
81119230:	d9002f17 	ldw	r4,188(sp)
81119234:	18800017 	ldw	r2,0(r3)
81119238:	18c00104 	addi	r3,r3,4
8111923c:	d8c02d15 	stw	r3,180(sp)
81119240:	11000015 	stw	r4,0(r2)
81119244:	0038f306 	br	81117614 <__reset+0xfb0f7614>
81119248:	00c00b44 	movi	r3,45
8111924c:	d8c02785 	stb	r3,158(sp)
81119250:	d8802a15 	stw	r2,168(sp)
81119254:	dc802b17 	ldw	r18,172(sp)
81119258:	d8002915 	stw	zero,164(sp)
8111925c:	07000b44 	movi	fp,45
81119260:	003a7306 	br	81117c30 <__reset+0xfb0f7c30>
81119264:	9080004c 	andi	r2,r18,1
81119268:	1000941e 	bne	r2,zero,811194bc <___svfprintf_internal_r+0x1f5c>
8111926c:	d8802117 	ldw	r2,132(sp)
81119270:	1405c83a 	sub	r2,r2,r16
81119274:	d8803315 	stw	r2,204(sp)
81119278:	b441161e 	bne	r22,r17,811196d4 <___svfprintf_internal_r+0x2174>
8111927c:	dd802617 	ldw	r22,152(sp)
81119280:	00bfff44 	movi	r2,-3
81119284:	b0801a16 	blt	r22,r2,811192f0 <___svfprintf_internal_r+0x1d90>
81119288:	d9402917 	ldw	r5,164(sp)
8111928c:	2d801816 	blt	r5,r22,811192f0 <___svfprintf_internal_r+0x1d90>
81119290:	dd803215 	stw	r22,200(sp)
81119294:	003f3a06 	br	81118f80 <__reset+0xfb0f8f80>
81119298:	1025883a 	mov	r18,r2
8111929c:	0039883a 	mov	fp,zero
811192a0:	00800084 	movi	r2,2
811192a4:	003fd606 	br	81119200 <__reset+0xfb0f9200>
811192a8:	9080004c 	andi	r2,r18,1
811192ac:	103f191e 	bne	r2,zero,81118f14 <__reset+0xfb0f8f14>
811192b0:	d8802117 	ldw	r2,132(sp)
811192b4:	003f2806 	br	81118f58 <__reset+0xfb0f8f58>
811192b8:	01204534 	movhi	r4,33044
811192bc:	21112584 	addi	r4,r4,17558
811192c0:	d9002b15 	stw	r4,172(sp)
811192c4:	003c7c06 	br	811184b8 <__reset+0xfb0f84b8>
811192c8:	e005883a 	mov	r2,fp
811192cc:	003f2206 	br	81118f58 <__reset+0xfb0f8f58>
811192d0:	d9402917 	ldw	r5,164(sp)
811192d4:	df002783 	ldbu	fp,158(sp)
811192d8:	dd002d15 	stw	r20,180(sp)
811192dc:	d9402a15 	stw	r5,168(sp)
811192e0:	d9402e15 	stw	r5,184(sp)
811192e4:	d8002915 	stw	zero,164(sp)
811192e8:	d8003215 	stw	zero,200(sp)
811192ec:	003a4c06 	br	81117c20 <__reset+0xfb0f7c20>
811192f0:	8c7fff84 	addi	r17,r17,-2
811192f4:	b5bfffc4 	addi	r22,r22,-1
811192f8:	dd802615 	stw	r22,152(sp)
811192fc:	dc4022c5 	stb	r17,139(sp)
81119300:	b000c316 	blt	r22,zero,81119610 <___svfprintf_internal_r+0x20b0>
81119304:	00800ac4 	movi	r2,43
81119308:	d8802305 	stb	r2,140(sp)
8111930c:	00800244 	movi	r2,9
81119310:	15806e16 	blt	r2,r22,811194cc <___svfprintf_internal_r+0x1f6c>
81119314:	00800c04 	movi	r2,48
81119318:	b5800c04 	addi	r22,r22,48
8111931c:	d8802345 	stb	r2,141(sp)
81119320:	dd802385 	stb	r22,142(sp)
81119324:	d88023c4 	addi	r2,sp,143
81119328:	df0022c4 	addi	fp,sp,139
8111932c:	d8c03317 	ldw	r3,204(sp)
81119330:	1739c83a 	sub	fp,r2,fp
81119334:	d9003317 	ldw	r4,204(sp)
81119338:	e0c7883a 	add	r3,fp,r3
8111933c:	df003b15 	stw	fp,236(sp)
81119340:	d8c02e15 	stw	r3,184(sp)
81119344:	00800044 	movi	r2,1
81119348:	1100b70e 	bge	r2,r4,81119628 <___svfprintf_internal_r+0x20c8>
8111934c:	d8c02e17 	ldw	r3,184(sp)
81119350:	18c00044 	addi	r3,r3,1
81119354:	d8c02e15 	stw	r3,184(sp)
81119358:	1805883a 	mov	r2,r3
8111935c:	1800b016 	blt	r3,zero,81119620 <___svfprintf_internal_r+0x20c0>
81119360:	d8003215 	stw	zero,200(sp)
81119364:	003f1006 	br	81118fa8 <__reset+0xfb0f8fa8>
81119368:	d8802917 	ldw	r2,164(sp)
8111936c:	103ec71e 	bne	r2,zero,81118e8c <__reset+0xfb0f8e8c>
81119370:	dc002915 	stw	r16,164(sp)
81119374:	003ec506 	br	81118e8c <__reset+0xfb0f8e8c>
81119378:	d9402c17 	ldw	r5,176(sp)
8111937c:	d9801e04 	addi	r6,sp,120
81119380:	9809883a 	mov	r4,r19
81119384:	11241800 	call	81124180 <__ssprint_r>
81119388:	10395c1e 	bne	r2,zero,811178fc <__reset+0xfb0f78fc>
8111938c:	dc402617 	ldw	r17,152(sp)
81119390:	d8c02017 	ldw	r3,128(sp)
81119394:	d8801f17 	ldw	r2,124(sp)
81119398:	da000404 	addi	r8,sp,16
8111939c:	003e7706 	br	81118d7c <__reset+0xfb0f8d7c>
811193a0:	582f883a 	mov	r23,r11
811193a4:	d8002915 	stw	zero,164(sp)
811193a8:	0038c406 	br	811176bc <__reset+0xfb0f76bc>
811193ac:	d8c02917 	ldw	r3,164(sp)
811193b0:	d8802104 	addi	r2,sp,132
811193b4:	d8800315 	stw	r2,12(sp)
811193b8:	d9403617 	ldw	r5,216(sp)
811193bc:	d8802504 	addi	r2,sp,148
811193c0:	d8800215 	stw	r2,8(sp)
811193c4:	d8802604 	addi	r2,sp,152
811193c8:	d8c00015 	stw	r3,0(sp)
811193cc:	9809883a 	mov	r4,r19
811193d0:	d8800115 	stw	r2,4(sp)
811193d4:	01c000c4 	movi	r7,3
811193d8:	a00d883a 	mov	r6,r20
811193dc:	da003e15 	stw	r8,248(sp)
811193e0:	111d84c0 	call	8111d84c <_dtoa_r>
811193e4:	d9002917 	ldw	r4,164(sp)
811193e8:	da003e17 	ldw	r8,248(sp)
811193ec:	1021883a 	mov	r16,r2
811193f0:	1139883a 	add	fp,r2,r4
811193f4:	2007883a 	mov	r3,r4
811193f8:	81000007 	ldb	r4,0(r16)
811193fc:	00800c04 	movi	r2,48
81119400:	20806f26 	beq	r4,r2,811195c0 <___svfprintf_internal_r+0x2060>
81119404:	d8c02617 	ldw	r3,152(sp)
81119408:	e0f9883a 	add	fp,fp,r3
8111940c:	003ec206 	br	81118f18 <__reset+0xfb0f8f18>
81119410:	00c00b44 	movi	r3,45
81119414:	2520003c 	xorhi	r20,r4,32768
81119418:	d8c02a05 	stb	r3,168(sp)
8111941c:	003ea106 	br	81118ea4 <__reset+0xfb0f8ea4>
81119420:	d8c03217 	ldw	r3,200(sp)
81119424:	00c0890e 	bge	zero,r3,8111964c <___svfprintf_internal_r+0x20ec>
81119428:	00800044 	movi	r2,1
8111942c:	d9003317 	ldw	r4,204(sp)
81119430:	1105883a 	add	r2,r2,r4
81119434:	d8802e15 	stw	r2,184(sp)
81119438:	10005f16 	blt	r2,zero,811195b8 <___svfprintf_internal_r+0x2058>
8111943c:	044019c4 	movi	r17,103
81119440:	003ed906 	br	81118fa8 <__reset+0xfb0f8fa8>
81119444:	d9002917 	ldw	r4,164(sp)
81119448:	20c00044 	addi	r3,r4,1
8111944c:	003e9c06 	br	81118ec0 <__reset+0xfb0f8ec0>
81119450:	d9002917 	ldw	r4,164(sp)
81119454:	00c0680e 	bge	zero,r3,811195f8 <___svfprintf_internal_r+0x2098>
81119458:	2000461e 	bne	r4,zero,81119574 <___svfprintf_internal_r+0x2014>
8111945c:	9480004c 	andi	r18,r18,1
81119460:	9000441e 	bne	r18,zero,81119574 <___svfprintf_internal_r+0x2014>
81119464:	1805883a 	mov	r2,r3
81119468:	1800a016 	blt	r3,zero,811196ec <___svfprintf_internal_r+0x218c>
8111946c:	d8c03217 	ldw	r3,200(sp)
81119470:	d8c02e15 	stw	r3,184(sp)
81119474:	003ecc06 	br	81118fa8 <__reset+0xfb0f8fa8>
81119478:	d9402917 	ldw	r5,164(sp)
8111947c:	d8802104 	addi	r2,sp,132
81119480:	d8800315 	stw	r2,12(sp)
81119484:	d9400015 	stw	r5,0(sp)
81119488:	d8802504 	addi	r2,sp,148
8111948c:	d9403617 	ldw	r5,216(sp)
81119490:	d8800215 	stw	r2,8(sp)
81119494:	d8802604 	addi	r2,sp,152
81119498:	d8800115 	stw	r2,4(sp)
8111949c:	01c000c4 	movi	r7,3
811194a0:	a00d883a 	mov	r6,r20
811194a4:	9809883a 	mov	r4,r19
811194a8:	da003e15 	stw	r8,248(sp)
811194ac:	111d84c0 	call	8111d84c <_dtoa_r>
811194b0:	d8c02917 	ldw	r3,164(sp)
811194b4:	da003e17 	ldw	r8,248(sp)
811194b8:	1021883a 	mov	r16,r2
811194bc:	00801184 	movi	r2,70
811194c0:	80f9883a 	add	fp,r16,r3
811194c4:	88bfcc26 	beq	r17,r2,811193f8 <__reset+0xfb0f93f8>
811194c8:	003e9306 	br	81118f18 <__reset+0xfb0f8f18>
811194cc:	df0022c4 	addi	fp,sp,139
811194d0:	dc002915 	stw	r16,164(sp)
811194d4:	9829883a 	mov	r20,r19
811194d8:	e021883a 	mov	r16,fp
811194dc:	4027883a 	mov	r19,r8
811194e0:	b009883a 	mov	r4,r22
811194e4:	01400284 	movi	r5,10
811194e8:	1128ca80 	call	81128ca8 <__modsi3>
811194ec:	10800c04 	addi	r2,r2,48
811194f0:	843fffc4 	addi	r16,r16,-1
811194f4:	b009883a 	mov	r4,r22
811194f8:	01400284 	movi	r5,10
811194fc:	80800005 	stb	r2,0(r16)
81119500:	1128c240 	call	81128c24 <__divsi3>
81119504:	102d883a 	mov	r22,r2
81119508:	00800244 	movi	r2,9
8111950c:	15bff416 	blt	r2,r22,811194e0 <__reset+0xfb0f94e0>
81119510:	9811883a 	mov	r8,r19
81119514:	b0800c04 	addi	r2,r22,48
81119518:	a027883a 	mov	r19,r20
8111951c:	8029883a 	mov	r20,r16
81119520:	a17fffc4 	addi	r5,r20,-1
81119524:	a0bfffc5 	stb	r2,-1(r20)
81119528:	dc002917 	ldw	r16,164(sp)
8111952c:	2f00752e 	bgeu	r5,fp,81119704 <___svfprintf_internal_r+0x21a4>
81119530:	d9c02384 	addi	r7,sp,142
81119534:	3d0fc83a 	sub	r7,r7,r20
81119538:	d9002344 	addi	r4,sp,141
8111953c:	e1cf883a 	add	r7,fp,r7
81119540:	00000106 	br	81119548 <___svfprintf_internal_r+0x1fe8>
81119544:	28800003 	ldbu	r2,0(r5)
81119548:	20800005 	stb	r2,0(r4)
8111954c:	21000044 	addi	r4,r4,1
81119550:	29400044 	addi	r5,r5,1
81119554:	21fffb1e 	bne	r4,r7,81119544 <__reset+0xfb0f9544>
81119558:	d8802304 	addi	r2,sp,140
8111955c:	1505c83a 	sub	r2,r2,r20
81119560:	d8c02344 	addi	r3,sp,141
81119564:	1885883a 	add	r2,r3,r2
81119568:	003f7006 	br	8111932c <__reset+0xfb0f932c>
8111956c:	0005883a 	mov	r2,zero
81119570:	003f0b06 	br	811191a0 <__reset+0xfb0f91a0>
81119574:	d9002917 	ldw	r4,164(sp)
81119578:	d8c03217 	ldw	r3,200(sp)
8111957c:	20800044 	addi	r2,r4,1
81119580:	1885883a 	add	r2,r3,r2
81119584:	d8802e15 	stw	r2,184(sp)
81119588:	103e870e 	bge	r2,zero,81118fa8 <__reset+0xfb0f8fa8>
8111958c:	0005883a 	mov	r2,zero
81119590:	003e8506 	br	81118fa8 <__reset+0xfb0f8fa8>
81119594:	01204534 	movhi	r4,33044
81119598:	21112584 	addi	r4,r4,17558
8111959c:	d9002b15 	stw	r4,172(sp)
811195a0:	003cc506 	br	811188b8 <__reset+0xfb0f88b8>
811195a4:	d8c03217 	ldw	r3,200(sp)
811195a8:	18c00044 	addi	r3,r3,1
811195ac:	d8c02e15 	stw	r3,184(sp)
811195b0:	1805883a 	mov	r2,r3
811195b4:	183fa10e 	bge	r3,zero,8111943c <__reset+0xfb0f943c>
811195b8:	0005883a 	mov	r2,zero
811195bc:	003f9f06 	br	8111943c <__reset+0xfb0f943c>
811195c0:	d9003617 	ldw	r4,216(sp)
811195c4:	000d883a 	mov	r6,zero
811195c8:	000f883a 	mov	r7,zero
811195cc:	a00b883a 	mov	r5,r20
811195d0:	d8c03d15 	stw	r3,244(sp)
811195d4:	da003e15 	stw	r8,248(sp)
811195d8:	112a1780 	call	8112a178 <__eqdf2>
811195dc:	d8c03d17 	ldw	r3,244(sp)
811195e0:	da003e17 	ldw	r8,248(sp)
811195e4:	103f8726 	beq	r2,zero,81119404 <__reset+0xfb0f9404>
811195e8:	00800044 	movi	r2,1
811195ec:	10c7c83a 	sub	r3,r2,r3
811195f0:	d8c02615 	stw	r3,152(sp)
811195f4:	003f8406 	br	81119408 <__reset+0xfb0f9408>
811195f8:	20000e1e 	bne	r4,zero,81119634 <___svfprintf_internal_r+0x20d4>
811195fc:	9480004c 	andi	r18,r18,1
81119600:	90000c1e 	bne	r18,zero,81119634 <___svfprintf_internal_r+0x20d4>
81119604:	00800044 	movi	r2,1
81119608:	d8802e15 	stw	r2,184(sp)
8111960c:	003e6606 	br	81118fa8 <__reset+0xfb0f8fa8>
81119610:	00800b44 	movi	r2,45
81119614:	05adc83a 	sub	r22,zero,r22
81119618:	d8802305 	stb	r2,140(sp)
8111961c:	003f3b06 	br	8111930c <__reset+0xfb0f930c>
81119620:	0005883a 	mov	r2,zero
81119624:	003f4e06 	br	81119360 <__reset+0xfb0f9360>
81119628:	90a4703a 	and	r18,r18,r2
8111962c:	903f4a26 	beq	r18,zero,81119358 <__reset+0xfb0f9358>
81119630:	003f4606 	br	8111934c <__reset+0xfb0f934c>
81119634:	d8c02917 	ldw	r3,164(sp)
81119638:	18c00084 	addi	r3,r3,2
8111963c:	d8c02e15 	stw	r3,184(sp)
81119640:	1805883a 	mov	r2,r3
81119644:	183e580e 	bge	r3,zero,81118fa8 <__reset+0xfb0f8fa8>
81119648:	003fd006 	br	8111958c <__reset+0xfb0f958c>
8111964c:	00800084 	movi	r2,2
81119650:	10c5c83a 	sub	r2,r2,r3
81119654:	003f7506 	br	8111942c <__reset+0xfb0f942c>
81119658:	d8802d17 	ldw	r2,180(sp)
8111965c:	d9002d17 	ldw	r4,180(sp)
81119660:	bc400043 	ldbu	r17,1(r23)
81119664:	10800017 	ldw	r2,0(r2)
81119668:	582f883a 	mov	r23,r11
8111966c:	d8802915 	stw	r2,164(sp)
81119670:	20800104 	addi	r2,r4,4
81119674:	d9002917 	ldw	r4,164(sp)
81119678:	d8802d15 	stw	r2,180(sp)
8111967c:	203df00e 	bge	r4,zero,81118e40 <__reset+0xfb0f8e40>
81119680:	8c403fcc 	andi	r17,r17,255
81119684:	00bfffc4 	movi	r2,-1
81119688:	8c40201c 	xori	r17,r17,128
8111968c:	d8802915 	stw	r2,164(sp)
81119690:	8c7fe004 	addi	r17,r17,-128
81119694:	00380806 	br	811176b8 <__reset+0xfb0f76b8>
81119698:	9080004c 	andi	r2,r18,1
8111969c:	0039883a 	mov	fp,zero
811196a0:	10000726 	beq	r2,zero,811196c0 <___svfprintf_internal_r+0x2160>
811196a4:	d8c02817 	ldw	r3,160(sp)
811196a8:	dc001dc4 	addi	r16,sp,119
811196ac:	00800c04 	movi	r2,48
811196b0:	1c07c83a 	sub	r3,r3,r16
811196b4:	d8801dc5 	stb	r2,119(sp)
811196b8:	d8c02e15 	stw	r3,184(sp)
811196bc:	00395206 	br	81117c08 <__reset+0xfb0f7c08>
811196c0:	d8002e15 	stw	zero,184(sp)
811196c4:	dc001e04 	addi	r16,sp,120
811196c8:	00394f06 	br	81117c08 <__reset+0xfb0f7c08>
811196cc:	0005883a 	mov	r2,zero
811196d0:	003e3206 	br	81118f9c <__reset+0xfb0f8f9c>
811196d4:	dd802617 	ldw	r22,152(sp)
811196d8:	003f0606 	br	811192f4 <__reset+0xfb0f92f4>
811196dc:	d9c02785 	stb	r7,158(sp)
811196e0:	003a5106 	br	81118028 <__reset+0xfb0f8028>
811196e4:	d9c02785 	stb	r7,158(sp)
811196e8:	003a3706 	br	81117fc8 <__reset+0xfb0f7fc8>
811196ec:	0005883a 	mov	r2,zero
811196f0:	003f5e06 	br	8111946c <__reset+0xfb0f946c>
811196f4:	d9c02785 	stb	r7,158(sp)
811196f8:	00391706 	br	81117b58 <__reset+0xfb0f7b58>
811196fc:	d9c02785 	stb	r7,158(sp)
81119700:	0038e606 	br	81117a9c <__reset+0xfb0f7a9c>
81119704:	d8802344 	addi	r2,sp,141
81119708:	003f0806 	br	8111932c <__reset+0xfb0f932c>
8111970c:	d9c02785 	stb	r7,158(sp)
81119710:	0038b706 	br	811179f0 <__reset+0xfb0f79f0>
81119714:	d9c02785 	stb	r7,158(sp)
81119718:	003adc06 	br	8111828c <__reset+0xfb0f828c>
8111971c:	d9403917 	ldw	r5,228(sp)
81119720:	00800304 	movi	r2,12
81119724:	28800015 	stw	r2,0(r5)
81119728:	00bfffc4 	movi	r2,-1
8111972c:	00387806 	br	81117910 <__reset+0xfb0f7910>
81119730:	d9c02785 	stb	r7,158(sp)
81119734:	003abf06 	br	81118234 <__reset+0xfb0f8234>
81119738:	d9c02785 	stb	r7,158(sp)
8111973c:	003a9b06 	br	811181ac <__reset+0xfb0f81ac>

81119740 <___vfprintf_internal_r>:
81119740:	deffb804 	addi	sp,sp,-288
81119744:	de00012e 	bgeu	sp,et,8111974c <___vfprintf_internal_r+0xc>
81119748:	003b68fa 	trap	3
8111974c:	dfc04715 	stw	ra,284(sp)
81119750:	ddc04515 	stw	r23,276(sp)
81119754:	dd404315 	stw	r21,268(sp)
81119758:	d9002c15 	stw	r4,176(sp)
8111975c:	282f883a 	mov	r23,r5
81119760:	302b883a 	mov	r21,r6
81119764:	d9c02d15 	stw	r7,180(sp)
81119768:	df004615 	stw	fp,280(sp)
8111976c:	dd804415 	stw	r22,272(sp)
81119770:	dd004215 	stw	r20,264(sp)
81119774:	dcc04115 	stw	r19,260(sp)
81119778:	dc804015 	stw	r18,256(sp)
8111977c:	dc403f15 	stw	r17,252(sp)
81119780:	dc003e15 	stw	r16,248(sp)
81119784:	11204480 	call	81120448 <_localeconv_r>
81119788:	10800017 	ldw	r2,0(r2)
8111978c:	1009883a 	mov	r4,r2
81119790:	d8803415 	stw	r2,208(sp)
81119794:	11172280 	call	81117228 <strlen>
81119798:	d8803715 	stw	r2,220(sp)
8111979c:	d8802c17 	ldw	r2,176(sp)
811197a0:	10000226 	beq	r2,zero,811197ac <___vfprintf_internal_r+0x6c>
811197a4:	10800e17 	ldw	r2,56(r2)
811197a8:	1000f926 	beq	r2,zero,81119b90 <___vfprintf_internal_r+0x450>
811197ac:	b880030b 	ldhu	r2,12(r23)
811197b0:	10c8000c 	andi	r3,r2,8192
811197b4:	1800061e 	bne	r3,zero,811197d0 <___vfprintf_internal_r+0x90>
811197b8:	b9001917 	ldw	r4,100(r23)
811197bc:	00f7ffc4 	movi	r3,-8193
811197c0:	10880014 	ori	r2,r2,8192
811197c4:	20c6703a 	and	r3,r4,r3
811197c8:	b880030d 	sth	r2,12(r23)
811197cc:	b8c01915 	stw	r3,100(r23)
811197d0:	10c0020c 	andi	r3,r2,8
811197d4:	1800c126 	beq	r3,zero,81119adc <___vfprintf_internal_r+0x39c>
811197d8:	b8c00417 	ldw	r3,16(r23)
811197dc:	1800bf26 	beq	r3,zero,81119adc <___vfprintf_internal_r+0x39c>
811197e0:	1080068c 	andi	r2,r2,26
811197e4:	00c00284 	movi	r3,10
811197e8:	10c0c426 	beq	r2,r3,81119afc <___vfprintf_internal_r+0x3bc>
811197ec:	d8c00404 	addi	r3,sp,16
811197f0:	05204534 	movhi	r20,33044
811197f4:	d9001e04 	addi	r4,sp,120
811197f8:	a5112d84 	addi	r20,r20,17590
811197fc:	d8c01e15 	stw	r3,120(sp)
81119800:	d8002015 	stw	zero,128(sp)
81119804:	d8001f15 	stw	zero,124(sp)
81119808:	d8003315 	stw	zero,204(sp)
8111980c:	d8003615 	stw	zero,216(sp)
81119810:	d8003815 	stw	zero,224(sp)
81119814:	1811883a 	mov	r8,r3
81119818:	d8003915 	stw	zero,228(sp)
8111981c:	d8003a15 	stw	zero,232(sp)
81119820:	d8002f15 	stw	zero,188(sp)
81119824:	d9002815 	stw	r4,160(sp)
81119828:	a8800007 	ldb	r2,0(r21)
8111982c:	10027b26 	beq	r2,zero,8111a21c <___vfprintf_internal_r+0xadc>
81119830:	00c00944 	movi	r3,37
81119834:	a821883a 	mov	r16,r21
81119838:	10c0021e 	bne	r2,r3,81119844 <___vfprintf_internal_r+0x104>
8111983c:	00001406 	br	81119890 <___vfprintf_internal_r+0x150>
81119840:	10c00326 	beq	r2,r3,81119850 <___vfprintf_internal_r+0x110>
81119844:	84000044 	addi	r16,r16,1
81119848:	80800007 	ldb	r2,0(r16)
8111984c:	103ffc1e 	bne	r2,zero,81119840 <__reset+0xfb0f9840>
81119850:	8563c83a 	sub	r17,r16,r21
81119854:	88000e26 	beq	r17,zero,81119890 <___vfprintf_internal_r+0x150>
81119858:	d8c02017 	ldw	r3,128(sp)
8111985c:	d8801f17 	ldw	r2,124(sp)
81119860:	45400015 	stw	r21,0(r8)
81119864:	1c47883a 	add	r3,r3,r17
81119868:	10800044 	addi	r2,r2,1
8111986c:	d8c02015 	stw	r3,128(sp)
81119870:	44400115 	stw	r17,4(r8)
81119874:	d8801f15 	stw	r2,124(sp)
81119878:	00c001c4 	movi	r3,7
8111987c:	1880a716 	blt	r3,r2,81119b1c <___vfprintf_internal_r+0x3dc>
81119880:	42000204 	addi	r8,r8,8
81119884:	d9402f17 	ldw	r5,188(sp)
81119888:	2c4b883a 	add	r5,r5,r17
8111988c:	d9402f15 	stw	r5,188(sp)
81119890:	80800007 	ldb	r2,0(r16)
81119894:	1000a826 	beq	r2,zero,81119b38 <___vfprintf_internal_r+0x3f8>
81119898:	84400047 	ldb	r17,1(r16)
8111989c:	00bfffc4 	movi	r2,-1
811198a0:	85400044 	addi	r21,r16,1
811198a4:	d8002785 	stb	zero,158(sp)
811198a8:	0007883a 	mov	r3,zero
811198ac:	000f883a 	mov	r7,zero
811198b0:	d8802915 	stw	r2,164(sp)
811198b4:	d8003115 	stw	zero,196(sp)
811198b8:	0025883a 	mov	r18,zero
811198bc:	01401604 	movi	r5,88
811198c0:	01800244 	movi	r6,9
811198c4:	02800a84 	movi	r10,42
811198c8:	02401b04 	movi	r9,108
811198cc:	ad400044 	addi	r21,r21,1
811198d0:	88bff804 	addi	r2,r17,-32
811198d4:	28830436 	bltu	r5,r2,8111a4e8 <___vfprintf_internal_r+0xda8>
811198d8:	100490ba 	slli	r2,r2,2
811198dc:	012044b4 	movhi	r4,33042
811198e0:	21263c04 	addi	r4,r4,-26384
811198e4:	1105883a 	add	r2,r2,r4
811198e8:	10800017 	ldw	r2,0(r2)
811198ec:	1000683a 	jmp	r2
811198f0:	8111a408 	cmpgei	r4,r16,18064
811198f4:	8111a4e8 	cmpgeui	r4,r16,18067
811198f8:	8111a4e8 	cmpgeui	r4,r16,18067
811198fc:	8111a428 	cmpgeui	r4,r16,18064
81119900:	8111a4e8 	cmpgeui	r4,r16,18067
81119904:	8111a4e8 	cmpgeui	r4,r16,18067
81119908:	8111a4e8 	cmpgeui	r4,r16,18067
8111990c:	8111a4e8 	cmpgeui	r4,r16,18067
81119910:	8111a4e8 	cmpgeui	r4,r16,18067
81119914:	8111a4e8 	cmpgeui	r4,r16,18067
81119918:	81119b9c 	xori	r4,r16,18030
8111991c:	8111a344 	addi	r4,r16,18061
81119920:	8111a4e8 	cmpgeui	r4,r16,18067
81119924:	81119a64 	muli	r4,r16,18025
81119928:	81119bc4 	addi	r4,r16,18031
8111992c:	8111a4e8 	cmpgeui	r4,r16,18067
81119930:	81119c04 	addi	r4,r16,18032
81119934:	81119c10 	cmplti	r4,r16,18032
81119938:	81119c10 	cmplti	r4,r16,18032
8111993c:	81119c10 	cmplti	r4,r16,18032
81119940:	81119c10 	cmplti	r4,r16,18032
81119944:	81119c10 	cmplti	r4,r16,18032
81119948:	81119c10 	cmplti	r4,r16,18032
8111994c:	81119c10 	cmplti	r4,r16,18032
81119950:	81119c10 	cmplti	r4,r16,18032
81119954:	81119c10 	cmplti	r4,r16,18032
81119958:	8111a4e8 	cmpgeui	r4,r16,18067
8111995c:	8111a4e8 	cmpgeui	r4,r16,18067
81119960:	8111a4e8 	cmpgeui	r4,r16,18067
81119964:	8111a4e8 	cmpgeui	r4,r16,18067
81119968:	8111a4e8 	cmpgeui	r4,r16,18067
8111996c:	8111a4e8 	cmpgeui	r4,r16,18067
81119970:	8111a4e8 	cmpgeui	r4,r16,18067
81119974:	8111a4e8 	cmpgeui	r4,r16,18067
81119978:	8111a4e8 	cmpgeui	r4,r16,18067
8111997c:	8111a4e8 	cmpgeui	r4,r16,18067
81119980:	81119c44 	addi	r4,r16,18033
81119984:	81119d00 	call	881119d0 <__reset+0x20f19d0>
81119988:	8111a4e8 	cmpgeui	r4,r16,18067
8111998c:	81119d00 	call	881119d0 <__reset+0x20f19d0>
81119990:	8111a4e8 	cmpgeui	r4,r16,18067
81119994:	8111a4e8 	cmpgeui	r4,r16,18067
81119998:	8111a4e8 	cmpgeui	r4,r16,18067
8111999c:	8111a4e8 	cmpgeui	r4,r16,18067
811199a0:	81119da0 	cmpeqi	r4,r16,18038
811199a4:	8111a4e8 	cmpgeui	r4,r16,18067
811199a8:	8111a4e8 	cmpgeui	r4,r16,18067
811199ac:	81119dac 	andhi	r4,r16,18038
811199b0:	8111a4e8 	cmpgeui	r4,r16,18067
811199b4:	8111a4e8 	cmpgeui	r4,r16,18067
811199b8:	8111a4e8 	cmpgeui	r4,r16,18067
811199bc:	8111a4e8 	cmpgeui	r4,r16,18067
811199c0:	8111a4e8 	cmpgeui	r4,r16,18067
811199c4:	8111a224 	muli	r4,r16,18056
811199c8:	8111a4e8 	cmpgeui	r4,r16,18067
811199cc:	8111a4e8 	cmpgeui	r4,r16,18067
811199d0:	8111a284 	addi	r4,r16,18058
811199d4:	8111a4e8 	cmpgeui	r4,r16,18067
811199d8:	8111a4e8 	cmpgeui	r4,r16,18067
811199dc:	8111a4e8 	cmpgeui	r4,r16,18067
811199e0:	8111a4e8 	cmpgeui	r4,r16,18067
811199e4:	8111a4e8 	cmpgeui	r4,r16,18067
811199e8:	8111a4e8 	cmpgeui	r4,r16,18067
811199ec:	8111a4e8 	cmpgeui	r4,r16,18067
811199f0:	8111a4e8 	cmpgeui	r4,r16,18067
811199f4:	8111a4e8 	cmpgeui	r4,r16,18067
811199f8:	8111a4e8 	cmpgeui	r4,r16,18067
811199fc:	8111a494 	ori	r4,r16,18066
81119a00:	8111a434 	orhi	r4,r16,18064
81119a04:	81119d00 	call	881119d0 <__reset+0x20f19d0>
81119a08:	81119d00 	call	881119d0 <__reset+0x20f19d0>
81119a0c:	81119d00 	call	881119d0 <__reset+0x20f19d0>
81119a10:	8111a444 	addi	r4,r16,18065
81119a14:	8111a434 	orhi	r4,r16,18064
81119a18:	8111a4e8 	cmpgeui	r4,r16,18067
81119a1c:	8111a4e8 	cmpgeui	r4,r16,18067
81119a20:	8111a450 	cmplti	r4,r16,18065
81119a24:	8111a4e8 	cmpgeui	r4,r16,18067
81119a28:	8111a460 	cmpeqi	r4,r16,18065
81119a2c:	8111a334 	orhi	r4,r16,18060
81119a30:	81119a70 	cmpltui	r4,r16,18025
81119a34:	8111a354 	ori	r4,r16,18061
81119a38:	8111a4e8 	cmpgeui	r4,r16,18067
81119a3c:	8111a360 	cmpeqi	r4,r16,18061
81119a40:	8111a4e8 	cmpgeui	r4,r16,18067
81119a44:	8111a3bc 	xorhi	r4,r16,18062
81119a48:	8111a4e8 	cmpgeui	r4,r16,18067
81119a4c:	8111a4e8 	cmpgeui	r4,r16,18067
81119a50:	8111a3cc 	andi	r4,r16,18063
81119a54:	d9003117 	ldw	r4,196(sp)
81119a58:	d8802d15 	stw	r2,180(sp)
81119a5c:	0109c83a 	sub	r4,zero,r4
81119a60:	d9003115 	stw	r4,196(sp)
81119a64:	94800114 	ori	r18,r18,4
81119a68:	ac400007 	ldb	r17,0(r21)
81119a6c:	003f9706 	br	811198cc <__reset+0xfb0f98cc>
81119a70:	00800c04 	movi	r2,48
81119a74:	d9002d17 	ldw	r4,180(sp)
81119a78:	d9402917 	ldw	r5,164(sp)
81119a7c:	d8802705 	stb	r2,156(sp)
81119a80:	00801e04 	movi	r2,120
81119a84:	d8802745 	stb	r2,157(sp)
81119a88:	d8002785 	stb	zero,158(sp)
81119a8c:	20c00104 	addi	r3,r4,4
81119a90:	24c00017 	ldw	r19,0(r4)
81119a94:	002d883a 	mov	r22,zero
81119a98:	90800094 	ori	r2,r18,2
81119a9c:	28029a16 	blt	r5,zero,8111a508 <___vfprintf_internal_r+0xdc8>
81119aa0:	00bfdfc4 	movi	r2,-129
81119aa4:	90a4703a 	and	r18,r18,r2
81119aa8:	d8c02d15 	stw	r3,180(sp)
81119aac:	94800094 	ori	r18,r18,2
81119ab0:	9802871e 	bne	r19,zero,8111a4d0 <___vfprintf_internal_r+0xd90>
81119ab4:	00a04534 	movhi	r2,33044
81119ab8:	10911e04 	addi	r2,r2,17528
81119abc:	d8803915 	stw	r2,228(sp)
81119ac0:	04401e04 	movi	r17,120
81119ac4:	d8802917 	ldw	r2,164(sp)
81119ac8:	0039883a 	mov	fp,zero
81119acc:	1001e926 	beq	r2,zero,8111a274 <___vfprintf_internal_r+0xb34>
81119ad0:	0027883a 	mov	r19,zero
81119ad4:	002d883a 	mov	r22,zero
81119ad8:	00020506 	br	8111a2f0 <___vfprintf_internal_r+0xbb0>
81119adc:	d9002c17 	ldw	r4,176(sp)
81119ae0:	b80b883a 	mov	r5,r23
81119ae4:	111d48c0 	call	8111d48c <__swsetup_r>
81119ae8:	1005ac1e 	bne	r2,zero,8111b19c <___vfprintf_internal_r+0x1a5c>
81119aec:	b880030b 	ldhu	r2,12(r23)
81119af0:	00c00284 	movi	r3,10
81119af4:	1080068c 	andi	r2,r2,26
81119af8:	10ff3c1e 	bne	r2,r3,811197ec <__reset+0xfb0f97ec>
81119afc:	b880038f 	ldh	r2,14(r23)
81119b00:	103f3a16 	blt	r2,zero,811197ec <__reset+0xfb0f97ec>
81119b04:	d9c02d17 	ldw	r7,180(sp)
81119b08:	d9002c17 	ldw	r4,176(sp)
81119b0c:	a80d883a 	mov	r6,r21
81119b10:	b80b883a 	mov	r5,r23
81119b14:	111b95c0 	call	8111b95c <__sbprintf>
81119b18:	00001106 	br	81119b60 <___vfprintf_internal_r+0x420>
81119b1c:	d9002c17 	ldw	r4,176(sp)
81119b20:	d9801e04 	addi	r6,sp,120
81119b24:	b80b883a 	mov	r5,r23
81119b28:	11259300 	call	81125930 <__sprint_r>
81119b2c:	1000081e 	bne	r2,zero,81119b50 <___vfprintf_internal_r+0x410>
81119b30:	da000404 	addi	r8,sp,16
81119b34:	003f5306 	br	81119884 <__reset+0xfb0f9884>
81119b38:	d8802017 	ldw	r2,128(sp)
81119b3c:	10000426 	beq	r2,zero,81119b50 <___vfprintf_internal_r+0x410>
81119b40:	d9002c17 	ldw	r4,176(sp)
81119b44:	d9801e04 	addi	r6,sp,120
81119b48:	b80b883a 	mov	r5,r23
81119b4c:	11259300 	call	81125930 <__sprint_r>
81119b50:	b880030b 	ldhu	r2,12(r23)
81119b54:	1080100c 	andi	r2,r2,64
81119b58:	1005901e 	bne	r2,zero,8111b19c <___vfprintf_internal_r+0x1a5c>
81119b5c:	d8802f17 	ldw	r2,188(sp)
81119b60:	dfc04717 	ldw	ra,284(sp)
81119b64:	df004617 	ldw	fp,280(sp)
81119b68:	ddc04517 	ldw	r23,276(sp)
81119b6c:	dd804417 	ldw	r22,272(sp)
81119b70:	dd404317 	ldw	r21,268(sp)
81119b74:	dd004217 	ldw	r20,264(sp)
81119b78:	dcc04117 	ldw	r19,260(sp)
81119b7c:	dc804017 	ldw	r18,256(sp)
81119b80:	dc403f17 	ldw	r17,252(sp)
81119b84:	dc003e17 	ldw	r16,248(sp)
81119b88:	dec04804 	addi	sp,sp,288
81119b8c:	f800283a 	ret
81119b90:	d9002c17 	ldw	r4,176(sp)
81119b94:	111f4fc0 	call	8111f4fc <__sinit>
81119b98:	003f0406 	br	811197ac <__reset+0xfb0f97ac>
81119b9c:	d8802d17 	ldw	r2,180(sp)
81119ba0:	d9002d17 	ldw	r4,180(sp)
81119ba4:	10800017 	ldw	r2,0(r2)
81119ba8:	d8803115 	stw	r2,196(sp)
81119bac:	20800104 	addi	r2,r4,4
81119bb0:	d9003117 	ldw	r4,196(sp)
81119bb4:	203fa716 	blt	r4,zero,81119a54 <__reset+0xfb0f9a54>
81119bb8:	d8802d15 	stw	r2,180(sp)
81119bbc:	ac400007 	ldb	r17,0(r21)
81119bc0:	003f4206 	br	811198cc <__reset+0xfb0f98cc>
81119bc4:	ac400007 	ldb	r17,0(r21)
81119bc8:	aac00044 	addi	r11,r21,1
81119bcc:	8a872826 	beq	r17,r10,8111b870 <___vfprintf_internal_r+0x2130>
81119bd0:	88bff404 	addi	r2,r17,-48
81119bd4:	0009883a 	mov	r4,zero
81119bd8:	30867d36 	bltu	r6,r2,8111b5d0 <___vfprintf_internal_r+0x1e90>
81119bdc:	5c400007 	ldb	r17,0(r11)
81119be0:	210002a4 	muli	r4,r4,10
81119be4:	5d400044 	addi	r21,r11,1
81119be8:	a817883a 	mov	r11,r21
81119bec:	2089883a 	add	r4,r4,r2
81119bf0:	88bff404 	addi	r2,r17,-48
81119bf4:	30bff92e 	bgeu	r6,r2,81119bdc <__reset+0xfb0f9bdc>
81119bf8:	2005c916 	blt	r4,zero,8111b320 <___vfprintf_internal_r+0x1be0>
81119bfc:	d9002915 	stw	r4,164(sp)
81119c00:	003f3306 	br	811198d0 <__reset+0xfb0f98d0>
81119c04:	94802014 	ori	r18,r18,128
81119c08:	ac400007 	ldb	r17,0(r21)
81119c0c:	003f2f06 	br	811198cc <__reset+0xfb0f98cc>
81119c10:	a809883a 	mov	r4,r21
81119c14:	d8003115 	stw	zero,196(sp)
81119c18:	88bff404 	addi	r2,r17,-48
81119c1c:	0017883a 	mov	r11,zero
81119c20:	24400007 	ldb	r17,0(r4)
81119c24:	5ac002a4 	muli	r11,r11,10
81119c28:	ad400044 	addi	r21,r21,1
81119c2c:	a809883a 	mov	r4,r21
81119c30:	12d7883a 	add	r11,r2,r11
81119c34:	88bff404 	addi	r2,r17,-48
81119c38:	30bff92e 	bgeu	r6,r2,81119c20 <__reset+0xfb0f9c20>
81119c3c:	dac03115 	stw	r11,196(sp)
81119c40:	003f2306 	br	811198d0 <__reset+0xfb0f98d0>
81119c44:	18c03fcc 	andi	r3,r3,255
81119c48:	18072b1e 	bne	r3,zero,8111b8f8 <___vfprintf_internal_r+0x21b8>
81119c4c:	94800414 	ori	r18,r18,16
81119c50:	9080080c 	andi	r2,r18,32
81119c54:	10037b26 	beq	r2,zero,8111aa44 <___vfprintf_internal_r+0x1304>
81119c58:	d9402d17 	ldw	r5,180(sp)
81119c5c:	28800117 	ldw	r2,4(r5)
81119c60:	2cc00017 	ldw	r19,0(r5)
81119c64:	29400204 	addi	r5,r5,8
81119c68:	d9402d15 	stw	r5,180(sp)
81119c6c:	102d883a 	mov	r22,r2
81119c70:	10044b16 	blt	r2,zero,8111ada0 <___vfprintf_internal_r+0x1660>
81119c74:	d9402917 	ldw	r5,164(sp)
81119c78:	df002783 	ldbu	fp,158(sp)
81119c7c:	2803bc16 	blt	r5,zero,8111ab70 <___vfprintf_internal_r+0x1430>
81119c80:	00ffdfc4 	movi	r3,-129
81119c84:	9d84b03a 	or	r2,r19,r22
81119c88:	90e4703a 	and	r18,r18,r3
81119c8c:	10017726 	beq	r2,zero,8111a26c <___vfprintf_internal_r+0xb2c>
81119c90:	b0038326 	beq	r22,zero,8111aaa0 <___vfprintf_internal_r+0x1360>
81119c94:	dc402a15 	stw	r17,168(sp)
81119c98:	dc001e04 	addi	r16,sp,120
81119c9c:	b023883a 	mov	r17,r22
81119ca0:	402d883a 	mov	r22,r8
81119ca4:	9809883a 	mov	r4,r19
81119ca8:	880b883a 	mov	r5,r17
81119cac:	01800284 	movi	r6,10
81119cb0:	000f883a 	mov	r7,zero
81119cb4:	11286e40 	call	811286e4 <__umoddi3>
81119cb8:	10800c04 	addi	r2,r2,48
81119cbc:	843fffc4 	addi	r16,r16,-1
81119cc0:	9809883a 	mov	r4,r19
81119cc4:	880b883a 	mov	r5,r17
81119cc8:	80800005 	stb	r2,0(r16)
81119ccc:	01800284 	movi	r6,10
81119cd0:	000f883a 	mov	r7,zero
81119cd4:	11281640 	call	81128164 <__udivdi3>
81119cd8:	1027883a 	mov	r19,r2
81119cdc:	10c4b03a 	or	r2,r2,r3
81119ce0:	1823883a 	mov	r17,r3
81119ce4:	103fef1e 	bne	r2,zero,81119ca4 <__reset+0xfb0f9ca4>
81119ce8:	d8c02817 	ldw	r3,160(sp)
81119cec:	dc402a17 	ldw	r17,168(sp)
81119cf0:	b011883a 	mov	r8,r22
81119cf4:	1c07c83a 	sub	r3,r3,r16
81119cf8:	d8c02e15 	stw	r3,184(sp)
81119cfc:	00005906 	br	81119e64 <___vfprintf_internal_r+0x724>
81119d00:	18c03fcc 	andi	r3,r3,255
81119d04:	1806fa1e 	bne	r3,zero,8111b8f0 <___vfprintf_internal_r+0x21b0>
81119d08:	9080020c 	andi	r2,r18,8
81119d0c:	10048a26 	beq	r2,zero,8111af38 <___vfprintf_internal_r+0x17f8>
81119d10:	d8c02d17 	ldw	r3,180(sp)
81119d14:	d9002d17 	ldw	r4,180(sp)
81119d18:	d9402d17 	ldw	r5,180(sp)
81119d1c:	18c00017 	ldw	r3,0(r3)
81119d20:	21000117 	ldw	r4,4(r4)
81119d24:	29400204 	addi	r5,r5,8
81119d28:	d8c03615 	stw	r3,216(sp)
81119d2c:	d9003815 	stw	r4,224(sp)
81119d30:	d9402d15 	stw	r5,180(sp)
81119d34:	d9003617 	ldw	r4,216(sp)
81119d38:	d9403817 	ldw	r5,224(sp)
81119d3c:	da003d15 	stw	r8,244(sp)
81119d40:	04000044 	movi	r16,1
81119d44:	1121f940 	call	81121f94 <__fpclassifyd>
81119d48:	da003d17 	ldw	r8,244(sp)
81119d4c:	14041f1e 	bne	r2,r16,8111adcc <___vfprintf_internal_r+0x168c>
81119d50:	d9003617 	ldw	r4,216(sp)
81119d54:	d9403817 	ldw	r5,224(sp)
81119d58:	000d883a 	mov	r6,zero
81119d5c:	000f883a 	mov	r7,zero
81119d60:	112a2dc0 	call	8112a2dc <__ledf2>
81119d64:	da003d17 	ldw	r8,244(sp)
81119d68:	1005be16 	blt	r2,zero,8111b464 <___vfprintf_internal_r+0x1d24>
81119d6c:	df002783 	ldbu	fp,158(sp)
81119d70:	008011c4 	movi	r2,71
81119d74:	1445330e 	bge	r2,r17,8111b244 <___vfprintf_internal_r+0x1b04>
81119d78:	04204534 	movhi	r16,33044
81119d7c:	84111604 	addi	r16,r16,17496
81119d80:	00c000c4 	movi	r3,3
81119d84:	00bfdfc4 	movi	r2,-129
81119d88:	d8c02a15 	stw	r3,168(sp)
81119d8c:	90a4703a 	and	r18,r18,r2
81119d90:	d8c02e15 	stw	r3,184(sp)
81119d94:	d8002915 	stw	zero,164(sp)
81119d98:	d8003215 	stw	zero,200(sp)
81119d9c:	00003706 	br	81119e7c <___vfprintf_internal_r+0x73c>
81119da0:	94800214 	ori	r18,r18,8
81119da4:	ac400007 	ldb	r17,0(r21)
81119da8:	003ec806 	br	811198cc <__reset+0xfb0f98cc>
81119dac:	18c03fcc 	andi	r3,r3,255
81119db0:	1806db1e 	bne	r3,zero,8111b920 <___vfprintf_internal_r+0x21e0>
81119db4:	94800414 	ori	r18,r18,16
81119db8:	9080080c 	andi	r2,r18,32
81119dbc:	1002d826 	beq	r2,zero,8111a920 <___vfprintf_internal_r+0x11e0>
81119dc0:	d9402d17 	ldw	r5,180(sp)
81119dc4:	d8c02917 	ldw	r3,164(sp)
81119dc8:	d8002785 	stb	zero,158(sp)
81119dcc:	28800204 	addi	r2,r5,8
81119dd0:	2cc00017 	ldw	r19,0(r5)
81119dd4:	2d800117 	ldw	r22,4(r5)
81119dd8:	18048f16 	blt	r3,zero,8111b018 <___vfprintf_internal_r+0x18d8>
81119ddc:	013fdfc4 	movi	r4,-129
81119de0:	9d86b03a 	or	r3,r19,r22
81119de4:	d8802d15 	stw	r2,180(sp)
81119de8:	9124703a 	and	r18,r18,r4
81119dec:	1802d91e 	bne	r3,zero,8111a954 <___vfprintf_internal_r+0x1214>
81119df0:	d8c02917 	ldw	r3,164(sp)
81119df4:	0039883a 	mov	fp,zero
81119df8:	1805c326 	beq	r3,zero,8111b508 <___vfprintf_internal_r+0x1dc8>
81119dfc:	0027883a 	mov	r19,zero
81119e00:	002d883a 	mov	r22,zero
81119e04:	dc001e04 	addi	r16,sp,120
81119e08:	9806d0fa 	srli	r3,r19,3
81119e0c:	b008977a 	slli	r4,r22,29
81119e10:	b02cd0fa 	srli	r22,r22,3
81119e14:	9cc001cc 	andi	r19,r19,7
81119e18:	98800c04 	addi	r2,r19,48
81119e1c:	843fffc4 	addi	r16,r16,-1
81119e20:	20e6b03a 	or	r19,r4,r3
81119e24:	80800005 	stb	r2,0(r16)
81119e28:	9d86b03a 	or	r3,r19,r22
81119e2c:	183ff61e 	bne	r3,zero,81119e08 <__reset+0xfb0f9e08>
81119e30:	90c0004c 	andi	r3,r18,1
81119e34:	18013b26 	beq	r3,zero,8111a324 <___vfprintf_internal_r+0xbe4>
81119e38:	10803fcc 	andi	r2,r2,255
81119e3c:	1080201c 	xori	r2,r2,128
81119e40:	10bfe004 	addi	r2,r2,-128
81119e44:	00c00c04 	movi	r3,48
81119e48:	10c13626 	beq	r2,r3,8111a324 <___vfprintf_internal_r+0xbe4>
81119e4c:	80ffffc5 	stb	r3,-1(r16)
81119e50:	d8c02817 	ldw	r3,160(sp)
81119e54:	80bfffc4 	addi	r2,r16,-1
81119e58:	1021883a 	mov	r16,r2
81119e5c:	1887c83a 	sub	r3,r3,r2
81119e60:	d8c02e15 	stw	r3,184(sp)
81119e64:	d8802e17 	ldw	r2,184(sp)
81119e68:	d9002917 	ldw	r4,164(sp)
81119e6c:	1100010e 	bge	r2,r4,81119e74 <___vfprintf_internal_r+0x734>
81119e70:	2005883a 	mov	r2,r4
81119e74:	d8802a15 	stw	r2,168(sp)
81119e78:	d8003215 	stw	zero,200(sp)
81119e7c:	e7003fcc 	andi	fp,fp,255
81119e80:	e700201c 	xori	fp,fp,128
81119e84:	e73fe004 	addi	fp,fp,-128
81119e88:	e0000326 	beq	fp,zero,81119e98 <___vfprintf_internal_r+0x758>
81119e8c:	d8c02a17 	ldw	r3,168(sp)
81119e90:	18c00044 	addi	r3,r3,1
81119e94:	d8c02a15 	stw	r3,168(sp)
81119e98:	90c0008c 	andi	r3,r18,2
81119e9c:	d8c02b15 	stw	r3,172(sp)
81119ea0:	18000326 	beq	r3,zero,81119eb0 <___vfprintf_internal_r+0x770>
81119ea4:	d8c02a17 	ldw	r3,168(sp)
81119ea8:	18c00084 	addi	r3,r3,2
81119eac:	d8c02a15 	stw	r3,168(sp)
81119eb0:	90c0210c 	andi	r3,r18,132
81119eb4:	d8c03015 	stw	r3,192(sp)
81119eb8:	1801a31e 	bne	r3,zero,8111a548 <___vfprintf_internal_r+0xe08>
81119ebc:	d9003117 	ldw	r4,196(sp)
81119ec0:	d8c02a17 	ldw	r3,168(sp)
81119ec4:	20e7c83a 	sub	r19,r4,r3
81119ec8:	04c19f0e 	bge	zero,r19,8111a548 <___vfprintf_internal_r+0xe08>
81119ecc:	02400404 	movi	r9,16
81119ed0:	d8c02017 	ldw	r3,128(sp)
81119ed4:	d8801f17 	ldw	r2,124(sp)
81119ed8:	4cc50d0e 	bge	r9,r19,8111b310 <___vfprintf_internal_r+0x1bd0>
81119edc:	01604534 	movhi	r5,33044
81119ee0:	29513184 	addi	r5,r5,17606
81119ee4:	dc403b15 	stw	r17,236(sp)
81119ee8:	d9403515 	stw	r5,212(sp)
81119eec:	9823883a 	mov	r17,r19
81119ef0:	482d883a 	mov	r22,r9
81119ef4:	9027883a 	mov	r19,r18
81119ef8:	070001c4 	movi	fp,7
81119efc:	8025883a 	mov	r18,r16
81119f00:	dc002c17 	ldw	r16,176(sp)
81119f04:	00000306 	br	81119f14 <___vfprintf_internal_r+0x7d4>
81119f08:	8c7ffc04 	addi	r17,r17,-16
81119f0c:	42000204 	addi	r8,r8,8
81119f10:	b440130e 	bge	r22,r17,81119f60 <___vfprintf_internal_r+0x820>
81119f14:	01204534 	movhi	r4,33044
81119f18:	18c00404 	addi	r3,r3,16
81119f1c:	10800044 	addi	r2,r2,1
81119f20:	21113184 	addi	r4,r4,17606
81119f24:	41000015 	stw	r4,0(r8)
81119f28:	45800115 	stw	r22,4(r8)
81119f2c:	d8c02015 	stw	r3,128(sp)
81119f30:	d8801f15 	stw	r2,124(sp)
81119f34:	e0bff40e 	bge	fp,r2,81119f08 <__reset+0xfb0f9f08>
81119f38:	d9801e04 	addi	r6,sp,120
81119f3c:	b80b883a 	mov	r5,r23
81119f40:	8009883a 	mov	r4,r16
81119f44:	11259300 	call	81125930 <__sprint_r>
81119f48:	103f011e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
81119f4c:	8c7ffc04 	addi	r17,r17,-16
81119f50:	d8c02017 	ldw	r3,128(sp)
81119f54:	d8801f17 	ldw	r2,124(sp)
81119f58:	da000404 	addi	r8,sp,16
81119f5c:	b47fed16 	blt	r22,r17,81119f14 <__reset+0xfb0f9f14>
81119f60:	9021883a 	mov	r16,r18
81119f64:	9825883a 	mov	r18,r19
81119f68:	8827883a 	mov	r19,r17
81119f6c:	dc403b17 	ldw	r17,236(sp)
81119f70:	d9403517 	ldw	r5,212(sp)
81119f74:	98c7883a 	add	r3,r19,r3
81119f78:	10800044 	addi	r2,r2,1
81119f7c:	41400015 	stw	r5,0(r8)
81119f80:	44c00115 	stw	r19,4(r8)
81119f84:	d8c02015 	stw	r3,128(sp)
81119f88:	d8801f15 	stw	r2,124(sp)
81119f8c:	010001c4 	movi	r4,7
81119f90:	2082a316 	blt	r4,r2,8111aa20 <___vfprintf_internal_r+0x12e0>
81119f94:	df002787 	ldb	fp,158(sp)
81119f98:	42000204 	addi	r8,r8,8
81119f9c:	e0000c26 	beq	fp,zero,81119fd0 <___vfprintf_internal_r+0x890>
81119fa0:	d8801f17 	ldw	r2,124(sp)
81119fa4:	d9002784 	addi	r4,sp,158
81119fa8:	18c00044 	addi	r3,r3,1
81119fac:	10800044 	addi	r2,r2,1
81119fb0:	41000015 	stw	r4,0(r8)
81119fb4:	01000044 	movi	r4,1
81119fb8:	41000115 	stw	r4,4(r8)
81119fbc:	d8c02015 	stw	r3,128(sp)
81119fc0:	d8801f15 	stw	r2,124(sp)
81119fc4:	010001c4 	movi	r4,7
81119fc8:	20823c16 	blt	r4,r2,8111a8bc <___vfprintf_internal_r+0x117c>
81119fcc:	42000204 	addi	r8,r8,8
81119fd0:	d8802b17 	ldw	r2,172(sp)
81119fd4:	10000c26 	beq	r2,zero,8111a008 <___vfprintf_internal_r+0x8c8>
81119fd8:	d8801f17 	ldw	r2,124(sp)
81119fdc:	d9002704 	addi	r4,sp,156
81119fe0:	18c00084 	addi	r3,r3,2
81119fe4:	10800044 	addi	r2,r2,1
81119fe8:	41000015 	stw	r4,0(r8)
81119fec:	01000084 	movi	r4,2
81119ff0:	41000115 	stw	r4,4(r8)
81119ff4:	d8c02015 	stw	r3,128(sp)
81119ff8:	d8801f15 	stw	r2,124(sp)
81119ffc:	010001c4 	movi	r4,7
8111a000:	20823616 	blt	r4,r2,8111a8dc <___vfprintf_internal_r+0x119c>
8111a004:	42000204 	addi	r8,r8,8
8111a008:	d9003017 	ldw	r4,192(sp)
8111a00c:	00802004 	movi	r2,128
8111a010:	20819926 	beq	r4,r2,8111a678 <___vfprintf_internal_r+0xf38>
8111a014:	d9402917 	ldw	r5,164(sp)
8111a018:	d8802e17 	ldw	r2,184(sp)
8111a01c:	28adc83a 	sub	r22,r5,r2
8111a020:	0580310e 	bge	zero,r22,8111a0e8 <___vfprintf_internal_r+0x9a8>
8111a024:	07000404 	movi	fp,16
8111a028:	d8801f17 	ldw	r2,124(sp)
8111a02c:	e584140e 	bge	fp,r22,8111b080 <___vfprintf_internal_r+0x1940>
8111a030:	01604534 	movhi	r5,33044
8111a034:	29512d84 	addi	r5,r5,17590
8111a038:	dc402915 	stw	r17,164(sp)
8111a03c:	d9402b15 	stw	r5,172(sp)
8111a040:	b023883a 	mov	r17,r22
8111a044:	04c001c4 	movi	r19,7
8111a048:	a82d883a 	mov	r22,r21
8111a04c:	902b883a 	mov	r21,r18
8111a050:	8025883a 	mov	r18,r16
8111a054:	dc002c17 	ldw	r16,176(sp)
8111a058:	00000306 	br	8111a068 <___vfprintf_internal_r+0x928>
8111a05c:	8c7ffc04 	addi	r17,r17,-16
8111a060:	42000204 	addi	r8,r8,8
8111a064:	e440110e 	bge	fp,r17,8111a0ac <___vfprintf_internal_r+0x96c>
8111a068:	18c00404 	addi	r3,r3,16
8111a06c:	10800044 	addi	r2,r2,1
8111a070:	45000015 	stw	r20,0(r8)
8111a074:	47000115 	stw	fp,4(r8)
8111a078:	d8c02015 	stw	r3,128(sp)
8111a07c:	d8801f15 	stw	r2,124(sp)
8111a080:	98bff60e 	bge	r19,r2,8111a05c <__reset+0xfb0fa05c>
8111a084:	d9801e04 	addi	r6,sp,120
8111a088:	b80b883a 	mov	r5,r23
8111a08c:	8009883a 	mov	r4,r16
8111a090:	11259300 	call	81125930 <__sprint_r>
8111a094:	103eae1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111a098:	8c7ffc04 	addi	r17,r17,-16
8111a09c:	d8c02017 	ldw	r3,128(sp)
8111a0a0:	d8801f17 	ldw	r2,124(sp)
8111a0a4:	da000404 	addi	r8,sp,16
8111a0a8:	e47fef16 	blt	fp,r17,8111a068 <__reset+0xfb0fa068>
8111a0ac:	9021883a 	mov	r16,r18
8111a0b0:	a825883a 	mov	r18,r21
8111a0b4:	b02b883a 	mov	r21,r22
8111a0b8:	882d883a 	mov	r22,r17
8111a0bc:	dc402917 	ldw	r17,164(sp)
8111a0c0:	d9002b17 	ldw	r4,172(sp)
8111a0c4:	1d87883a 	add	r3,r3,r22
8111a0c8:	10800044 	addi	r2,r2,1
8111a0cc:	41000015 	stw	r4,0(r8)
8111a0d0:	45800115 	stw	r22,4(r8)
8111a0d4:	d8c02015 	stw	r3,128(sp)
8111a0d8:	d8801f15 	stw	r2,124(sp)
8111a0dc:	010001c4 	movi	r4,7
8111a0e0:	2081ee16 	blt	r4,r2,8111a89c <___vfprintf_internal_r+0x115c>
8111a0e4:	42000204 	addi	r8,r8,8
8111a0e8:	9080400c 	andi	r2,r18,256
8111a0ec:	1001181e 	bne	r2,zero,8111a550 <___vfprintf_internal_r+0xe10>
8111a0f0:	d9402e17 	ldw	r5,184(sp)
8111a0f4:	d8801f17 	ldw	r2,124(sp)
8111a0f8:	44000015 	stw	r16,0(r8)
8111a0fc:	1947883a 	add	r3,r3,r5
8111a100:	10800044 	addi	r2,r2,1
8111a104:	41400115 	stw	r5,4(r8)
8111a108:	d8c02015 	stw	r3,128(sp)
8111a10c:	d8801f15 	stw	r2,124(sp)
8111a110:	010001c4 	movi	r4,7
8111a114:	2081d316 	blt	r4,r2,8111a864 <___vfprintf_internal_r+0x1124>
8111a118:	42000204 	addi	r8,r8,8
8111a11c:	9480010c 	andi	r18,r18,4
8111a120:	90003226 	beq	r18,zero,8111a1ec <___vfprintf_internal_r+0xaac>
8111a124:	d9403117 	ldw	r5,196(sp)
8111a128:	d8802a17 	ldw	r2,168(sp)
8111a12c:	28a1c83a 	sub	r16,r5,r2
8111a130:	04002e0e 	bge	zero,r16,8111a1ec <___vfprintf_internal_r+0xaac>
8111a134:	04400404 	movi	r17,16
8111a138:	d8801f17 	ldw	r2,124(sp)
8111a13c:	8c04a20e 	bge	r17,r16,8111b3c8 <___vfprintf_internal_r+0x1c88>
8111a140:	01604534 	movhi	r5,33044
8111a144:	29513184 	addi	r5,r5,17606
8111a148:	d9403515 	stw	r5,212(sp)
8111a14c:	048001c4 	movi	r18,7
8111a150:	dcc02c17 	ldw	r19,176(sp)
8111a154:	00000306 	br	8111a164 <___vfprintf_internal_r+0xa24>
8111a158:	843ffc04 	addi	r16,r16,-16
8111a15c:	42000204 	addi	r8,r8,8
8111a160:	8c00130e 	bge	r17,r16,8111a1b0 <___vfprintf_internal_r+0xa70>
8111a164:	01204534 	movhi	r4,33044
8111a168:	18c00404 	addi	r3,r3,16
8111a16c:	10800044 	addi	r2,r2,1
8111a170:	21113184 	addi	r4,r4,17606
8111a174:	41000015 	stw	r4,0(r8)
8111a178:	44400115 	stw	r17,4(r8)
8111a17c:	d8c02015 	stw	r3,128(sp)
8111a180:	d8801f15 	stw	r2,124(sp)
8111a184:	90bff40e 	bge	r18,r2,8111a158 <__reset+0xfb0fa158>
8111a188:	d9801e04 	addi	r6,sp,120
8111a18c:	b80b883a 	mov	r5,r23
8111a190:	9809883a 	mov	r4,r19
8111a194:	11259300 	call	81125930 <__sprint_r>
8111a198:	103e6d1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111a19c:	843ffc04 	addi	r16,r16,-16
8111a1a0:	d8c02017 	ldw	r3,128(sp)
8111a1a4:	d8801f17 	ldw	r2,124(sp)
8111a1a8:	da000404 	addi	r8,sp,16
8111a1ac:	8c3fed16 	blt	r17,r16,8111a164 <__reset+0xfb0fa164>
8111a1b0:	d9403517 	ldw	r5,212(sp)
8111a1b4:	1c07883a 	add	r3,r3,r16
8111a1b8:	10800044 	addi	r2,r2,1
8111a1bc:	41400015 	stw	r5,0(r8)
8111a1c0:	44000115 	stw	r16,4(r8)
8111a1c4:	d8c02015 	stw	r3,128(sp)
8111a1c8:	d8801f15 	stw	r2,124(sp)
8111a1cc:	010001c4 	movi	r4,7
8111a1d0:	2080060e 	bge	r4,r2,8111a1ec <___vfprintf_internal_r+0xaac>
8111a1d4:	d9002c17 	ldw	r4,176(sp)
8111a1d8:	d9801e04 	addi	r6,sp,120
8111a1dc:	b80b883a 	mov	r5,r23
8111a1e0:	11259300 	call	81125930 <__sprint_r>
8111a1e4:	103e5a1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111a1e8:	d8c02017 	ldw	r3,128(sp)
8111a1ec:	d8803117 	ldw	r2,196(sp)
8111a1f0:	d9002a17 	ldw	r4,168(sp)
8111a1f4:	1100010e 	bge	r2,r4,8111a1fc <___vfprintf_internal_r+0xabc>
8111a1f8:	2005883a 	mov	r2,r4
8111a1fc:	d9402f17 	ldw	r5,188(sp)
8111a200:	288b883a 	add	r5,r5,r2
8111a204:	d9402f15 	stw	r5,188(sp)
8111a208:	18019e1e 	bne	r3,zero,8111a884 <___vfprintf_internal_r+0x1144>
8111a20c:	a8800007 	ldb	r2,0(r21)
8111a210:	d8001f15 	stw	zero,124(sp)
8111a214:	da000404 	addi	r8,sp,16
8111a218:	103d851e 	bne	r2,zero,81119830 <__reset+0xfb0f9830>
8111a21c:	a821883a 	mov	r16,r21
8111a220:	003d9b06 	br	81119890 <__reset+0xfb0f9890>
8111a224:	18c03fcc 	andi	r3,r3,255
8111a228:	1805c11e 	bne	r3,zero,8111b930 <___vfprintf_internal_r+0x21f0>
8111a22c:	94800414 	ori	r18,r18,16
8111a230:	9080080c 	andi	r2,r18,32
8111a234:	10020c26 	beq	r2,zero,8111aa68 <___vfprintf_internal_r+0x1328>
8111a238:	d8802d17 	ldw	r2,180(sp)
8111a23c:	d9002917 	ldw	r4,164(sp)
8111a240:	d8002785 	stb	zero,158(sp)
8111a244:	10c00204 	addi	r3,r2,8
8111a248:	14c00017 	ldw	r19,0(r2)
8111a24c:	15800117 	ldw	r22,4(r2)
8111a250:	20040f16 	blt	r4,zero,8111b290 <___vfprintf_internal_r+0x1b50>
8111a254:	013fdfc4 	movi	r4,-129
8111a258:	9d84b03a 	or	r2,r19,r22
8111a25c:	d8c02d15 	stw	r3,180(sp)
8111a260:	9124703a 	and	r18,r18,r4
8111a264:	0039883a 	mov	fp,zero
8111a268:	103e891e 	bne	r2,zero,81119c90 <__reset+0xfb0f9c90>
8111a26c:	d9002917 	ldw	r4,164(sp)
8111a270:	2002c11e 	bne	r4,zero,8111ad78 <___vfprintf_internal_r+0x1638>
8111a274:	d8002915 	stw	zero,164(sp)
8111a278:	d8002e15 	stw	zero,184(sp)
8111a27c:	dc001e04 	addi	r16,sp,120
8111a280:	003ef806 	br	81119e64 <__reset+0xfb0f9e64>
8111a284:	18c03fcc 	andi	r3,r3,255
8111a288:	18059d1e 	bne	r3,zero,8111b900 <___vfprintf_internal_r+0x21c0>
8111a28c:	01604534 	movhi	r5,33044
8111a290:	29511904 	addi	r5,r5,17508
8111a294:	d9403915 	stw	r5,228(sp)
8111a298:	9080080c 	andi	r2,r18,32
8111a29c:	10005226 	beq	r2,zero,8111a3e8 <___vfprintf_internal_r+0xca8>
8111a2a0:	d8802d17 	ldw	r2,180(sp)
8111a2a4:	14c00017 	ldw	r19,0(r2)
8111a2a8:	15800117 	ldw	r22,4(r2)
8111a2ac:	10800204 	addi	r2,r2,8
8111a2b0:	d8802d15 	stw	r2,180(sp)
8111a2b4:	9080004c 	andi	r2,r18,1
8111a2b8:	10019026 	beq	r2,zero,8111a8fc <___vfprintf_internal_r+0x11bc>
8111a2bc:	9d84b03a 	or	r2,r19,r22
8111a2c0:	10036926 	beq	r2,zero,8111b068 <___vfprintf_internal_r+0x1928>
8111a2c4:	d8c02917 	ldw	r3,164(sp)
8111a2c8:	00800c04 	movi	r2,48
8111a2cc:	d8802705 	stb	r2,156(sp)
8111a2d0:	dc402745 	stb	r17,157(sp)
8111a2d4:	d8002785 	stb	zero,158(sp)
8111a2d8:	90800094 	ori	r2,r18,2
8111a2dc:	18045d16 	blt	r3,zero,8111b454 <___vfprintf_internal_r+0x1d14>
8111a2e0:	00bfdfc4 	movi	r2,-129
8111a2e4:	90a4703a 	and	r18,r18,r2
8111a2e8:	94800094 	ori	r18,r18,2
8111a2ec:	0039883a 	mov	fp,zero
8111a2f0:	d9003917 	ldw	r4,228(sp)
8111a2f4:	dc001e04 	addi	r16,sp,120
8111a2f8:	988003cc 	andi	r2,r19,15
8111a2fc:	b006973a 	slli	r3,r22,28
8111a300:	2085883a 	add	r2,r4,r2
8111a304:	9826d13a 	srli	r19,r19,4
8111a308:	10800003 	ldbu	r2,0(r2)
8111a30c:	b02cd13a 	srli	r22,r22,4
8111a310:	843fffc4 	addi	r16,r16,-1
8111a314:	1ce6b03a 	or	r19,r3,r19
8111a318:	80800005 	stb	r2,0(r16)
8111a31c:	9d84b03a 	or	r2,r19,r22
8111a320:	103ff51e 	bne	r2,zero,8111a2f8 <__reset+0xfb0fa2f8>
8111a324:	d8c02817 	ldw	r3,160(sp)
8111a328:	1c07c83a 	sub	r3,r3,r16
8111a32c:	d8c02e15 	stw	r3,184(sp)
8111a330:	003ecc06 	br	81119e64 <__reset+0xfb0f9e64>
8111a334:	18c03fcc 	andi	r3,r3,255
8111a338:	183e9f26 	beq	r3,zero,81119db8 <__reset+0xfb0f9db8>
8111a33c:	d9c02785 	stb	r7,158(sp)
8111a340:	003e9d06 	br	81119db8 <__reset+0xfb0f9db8>
8111a344:	00c00044 	movi	r3,1
8111a348:	01c00ac4 	movi	r7,43
8111a34c:	ac400007 	ldb	r17,0(r21)
8111a350:	003d5e06 	br	811198cc <__reset+0xfb0f98cc>
8111a354:	94800814 	ori	r18,r18,32
8111a358:	ac400007 	ldb	r17,0(r21)
8111a35c:	003d5b06 	br	811198cc <__reset+0xfb0f98cc>
8111a360:	d8c02d17 	ldw	r3,180(sp)
8111a364:	d8002785 	stb	zero,158(sp)
8111a368:	1c000017 	ldw	r16,0(r3)
8111a36c:	1cc00104 	addi	r19,r3,4
8111a370:	80041926 	beq	r16,zero,8111b3d8 <___vfprintf_internal_r+0x1c98>
8111a374:	d9002917 	ldw	r4,164(sp)
8111a378:	2003d016 	blt	r4,zero,8111b2bc <___vfprintf_internal_r+0x1b7c>
8111a37c:	200d883a 	mov	r6,r4
8111a380:	000b883a 	mov	r5,zero
8111a384:	8009883a 	mov	r4,r16
8111a388:	da003d15 	stw	r8,244(sp)
8111a38c:	11207240 	call	81120724 <memchr>
8111a390:	da003d17 	ldw	r8,244(sp)
8111a394:	10045426 	beq	r2,zero,8111b4e8 <___vfprintf_internal_r+0x1da8>
8111a398:	1405c83a 	sub	r2,r2,r16
8111a39c:	d8802e15 	stw	r2,184(sp)
8111a3a0:	1003cc16 	blt	r2,zero,8111b2d4 <___vfprintf_internal_r+0x1b94>
8111a3a4:	df002783 	ldbu	fp,158(sp)
8111a3a8:	d8802a15 	stw	r2,168(sp)
8111a3ac:	dcc02d15 	stw	r19,180(sp)
8111a3b0:	d8002915 	stw	zero,164(sp)
8111a3b4:	d8003215 	stw	zero,200(sp)
8111a3b8:	003eb006 	br	81119e7c <__reset+0xfb0f9e7c>
8111a3bc:	18c03fcc 	andi	r3,r3,255
8111a3c0:	183f9b26 	beq	r3,zero,8111a230 <__reset+0xfb0fa230>
8111a3c4:	d9c02785 	stb	r7,158(sp)
8111a3c8:	003f9906 	br	8111a230 <__reset+0xfb0fa230>
8111a3cc:	18c03fcc 	andi	r3,r3,255
8111a3d0:	1805551e 	bne	r3,zero,8111b928 <___vfprintf_internal_r+0x21e8>
8111a3d4:	01604534 	movhi	r5,33044
8111a3d8:	29511e04 	addi	r5,r5,17528
8111a3dc:	d9403915 	stw	r5,228(sp)
8111a3e0:	9080080c 	andi	r2,r18,32
8111a3e4:	103fae1e 	bne	r2,zero,8111a2a0 <__reset+0xfb0fa2a0>
8111a3e8:	9080040c 	andi	r2,r18,16
8111a3ec:	1002de26 	beq	r2,zero,8111af68 <___vfprintf_internal_r+0x1828>
8111a3f0:	d8c02d17 	ldw	r3,180(sp)
8111a3f4:	002d883a 	mov	r22,zero
8111a3f8:	1cc00017 	ldw	r19,0(r3)
8111a3fc:	18c00104 	addi	r3,r3,4
8111a400:	d8c02d15 	stw	r3,180(sp)
8111a404:	003fab06 	br	8111a2b4 <__reset+0xfb0fa2b4>
8111a408:	38803fcc 	andi	r2,r7,255
8111a40c:	1080201c 	xori	r2,r2,128
8111a410:	10bfe004 	addi	r2,r2,-128
8111a414:	1002d21e 	bne	r2,zero,8111af60 <___vfprintf_internal_r+0x1820>
8111a418:	00c00044 	movi	r3,1
8111a41c:	01c00804 	movi	r7,32
8111a420:	ac400007 	ldb	r17,0(r21)
8111a424:	003d2906 	br	811198cc <__reset+0xfb0f98cc>
8111a428:	94800054 	ori	r18,r18,1
8111a42c:	ac400007 	ldb	r17,0(r21)
8111a430:	003d2606 	br	811198cc <__reset+0xfb0f98cc>
8111a434:	18c03fcc 	andi	r3,r3,255
8111a438:	183e0526 	beq	r3,zero,81119c50 <__reset+0xfb0f9c50>
8111a43c:	d9c02785 	stb	r7,158(sp)
8111a440:	003e0306 	br	81119c50 <__reset+0xfb0f9c50>
8111a444:	94801014 	ori	r18,r18,64
8111a448:	ac400007 	ldb	r17,0(r21)
8111a44c:	003d1f06 	br	811198cc <__reset+0xfb0f98cc>
8111a450:	ac400007 	ldb	r17,0(r21)
8111a454:	8a438726 	beq	r17,r9,8111b274 <___vfprintf_internal_r+0x1b34>
8111a458:	94800414 	ori	r18,r18,16
8111a45c:	003d1b06 	br	811198cc <__reset+0xfb0f98cc>
8111a460:	18c03fcc 	andi	r3,r3,255
8111a464:	1805341e 	bne	r3,zero,8111b938 <___vfprintf_internal_r+0x21f8>
8111a468:	9080080c 	andi	r2,r18,32
8111a46c:	1002cd26 	beq	r2,zero,8111afa4 <___vfprintf_internal_r+0x1864>
8111a470:	d9402d17 	ldw	r5,180(sp)
8111a474:	d9002f17 	ldw	r4,188(sp)
8111a478:	28800017 	ldw	r2,0(r5)
8111a47c:	2007d7fa 	srai	r3,r4,31
8111a480:	29400104 	addi	r5,r5,4
8111a484:	d9402d15 	stw	r5,180(sp)
8111a488:	11000015 	stw	r4,0(r2)
8111a48c:	10c00115 	stw	r3,4(r2)
8111a490:	003ce506 	br	81119828 <__reset+0xfb0f9828>
8111a494:	d8c02d17 	ldw	r3,180(sp)
8111a498:	d9002d17 	ldw	r4,180(sp)
8111a49c:	d8002785 	stb	zero,158(sp)
8111a4a0:	18800017 	ldw	r2,0(r3)
8111a4a4:	21000104 	addi	r4,r4,4
8111a4a8:	00c00044 	movi	r3,1
8111a4ac:	d8c02a15 	stw	r3,168(sp)
8111a4b0:	d8801405 	stb	r2,80(sp)
8111a4b4:	d9002d15 	stw	r4,180(sp)
8111a4b8:	d8c02e15 	stw	r3,184(sp)
8111a4bc:	d8002915 	stw	zero,164(sp)
8111a4c0:	d8003215 	stw	zero,200(sp)
8111a4c4:	dc001404 	addi	r16,sp,80
8111a4c8:	0039883a 	mov	fp,zero
8111a4cc:	003e7206 	br	81119e98 <__reset+0xfb0f9e98>
8111a4d0:	01204534 	movhi	r4,33044
8111a4d4:	21111e04 	addi	r4,r4,17528
8111a4d8:	0039883a 	mov	fp,zero
8111a4dc:	d9003915 	stw	r4,228(sp)
8111a4e0:	04401e04 	movi	r17,120
8111a4e4:	003f8206 	br	8111a2f0 <__reset+0xfb0fa2f0>
8111a4e8:	18c03fcc 	andi	r3,r3,255
8111a4ec:	1805061e 	bne	r3,zero,8111b908 <___vfprintf_internal_r+0x21c8>
8111a4f0:	883d9126 	beq	r17,zero,81119b38 <__reset+0xfb0f9b38>
8111a4f4:	00c00044 	movi	r3,1
8111a4f8:	d8c02a15 	stw	r3,168(sp)
8111a4fc:	dc401405 	stb	r17,80(sp)
8111a500:	d8002785 	stb	zero,158(sp)
8111a504:	003fec06 	br	8111a4b8 <__reset+0xfb0fa4b8>
8111a508:	01604534 	movhi	r5,33044
8111a50c:	29511e04 	addi	r5,r5,17528
8111a510:	d9403915 	stw	r5,228(sp)
8111a514:	d8c02d15 	stw	r3,180(sp)
8111a518:	1025883a 	mov	r18,r2
8111a51c:	04401e04 	movi	r17,120
8111a520:	9d84b03a 	or	r2,r19,r22
8111a524:	1000fc1e 	bne	r2,zero,8111a918 <___vfprintf_internal_r+0x11d8>
8111a528:	0039883a 	mov	fp,zero
8111a52c:	00800084 	movi	r2,2
8111a530:	10803fcc 	andi	r2,r2,255
8111a534:	00c00044 	movi	r3,1
8111a538:	10c20f26 	beq	r2,r3,8111ad78 <___vfprintf_internal_r+0x1638>
8111a53c:	00c00084 	movi	r3,2
8111a540:	10fd6326 	beq	r2,r3,81119ad0 <__reset+0xfb0f9ad0>
8111a544:	003e2d06 	br	81119dfc <__reset+0xfb0f9dfc>
8111a548:	d8c02017 	ldw	r3,128(sp)
8111a54c:	003e9306 	br	81119f9c <__reset+0xfb0f9f9c>
8111a550:	00801944 	movi	r2,101
8111a554:	14407e0e 	bge	r2,r17,8111a750 <___vfprintf_internal_r+0x1010>
8111a558:	d9003617 	ldw	r4,216(sp)
8111a55c:	d9403817 	ldw	r5,224(sp)
8111a560:	000d883a 	mov	r6,zero
8111a564:	000f883a 	mov	r7,zero
8111a568:	d8c03c15 	stw	r3,240(sp)
8111a56c:	da003d15 	stw	r8,244(sp)
8111a570:	112a1780 	call	8112a178 <__eqdf2>
8111a574:	d8c03c17 	ldw	r3,240(sp)
8111a578:	da003d17 	ldw	r8,244(sp)
8111a57c:	1000f71e 	bne	r2,zero,8111a95c <___vfprintf_internal_r+0x121c>
8111a580:	d8801f17 	ldw	r2,124(sp)
8111a584:	01204534 	movhi	r4,33044
8111a588:	21112504 	addi	r4,r4,17556
8111a58c:	18c00044 	addi	r3,r3,1
8111a590:	10800044 	addi	r2,r2,1
8111a594:	41000015 	stw	r4,0(r8)
8111a598:	01000044 	movi	r4,1
8111a59c:	41000115 	stw	r4,4(r8)
8111a5a0:	d8c02015 	stw	r3,128(sp)
8111a5a4:	d8801f15 	stw	r2,124(sp)
8111a5a8:	010001c4 	movi	r4,7
8111a5ac:	2082b816 	blt	r4,r2,8111b090 <___vfprintf_internal_r+0x1950>
8111a5b0:	42000204 	addi	r8,r8,8
8111a5b4:	d8802617 	ldw	r2,152(sp)
8111a5b8:	d9403317 	ldw	r5,204(sp)
8111a5bc:	11400216 	blt	r2,r5,8111a5c8 <___vfprintf_internal_r+0xe88>
8111a5c0:	9080004c 	andi	r2,r18,1
8111a5c4:	103ed526 	beq	r2,zero,8111a11c <__reset+0xfb0fa11c>
8111a5c8:	d8803717 	ldw	r2,220(sp)
8111a5cc:	d9003417 	ldw	r4,208(sp)
8111a5d0:	d9403717 	ldw	r5,220(sp)
8111a5d4:	1887883a 	add	r3,r3,r2
8111a5d8:	d8801f17 	ldw	r2,124(sp)
8111a5dc:	41000015 	stw	r4,0(r8)
8111a5e0:	41400115 	stw	r5,4(r8)
8111a5e4:	10800044 	addi	r2,r2,1
8111a5e8:	d8c02015 	stw	r3,128(sp)
8111a5ec:	d8801f15 	stw	r2,124(sp)
8111a5f0:	010001c4 	movi	r4,7
8111a5f4:	20832916 	blt	r4,r2,8111b29c <___vfprintf_internal_r+0x1b5c>
8111a5f8:	42000204 	addi	r8,r8,8
8111a5fc:	d8803317 	ldw	r2,204(sp)
8111a600:	143fffc4 	addi	r16,r2,-1
8111a604:	043ec50e 	bge	zero,r16,8111a11c <__reset+0xfb0fa11c>
8111a608:	04400404 	movi	r17,16
8111a60c:	d8801f17 	ldw	r2,124(sp)
8111a610:	8c00880e 	bge	r17,r16,8111a834 <___vfprintf_internal_r+0x10f4>
8111a614:	01604534 	movhi	r5,33044
8111a618:	29512d84 	addi	r5,r5,17590
8111a61c:	d9402b15 	stw	r5,172(sp)
8111a620:	058001c4 	movi	r22,7
8111a624:	dcc02c17 	ldw	r19,176(sp)
8111a628:	00000306 	br	8111a638 <___vfprintf_internal_r+0xef8>
8111a62c:	42000204 	addi	r8,r8,8
8111a630:	843ffc04 	addi	r16,r16,-16
8111a634:	8c00820e 	bge	r17,r16,8111a840 <___vfprintf_internal_r+0x1100>
8111a638:	18c00404 	addi	r3,r3,16
8111a63c:	10800044 	addi	r2,r2,1
8111a640:	45000015 	stw	r20,0(r8)
8111a644:	44400115 	stw	r17,4(r8)
8111a648:	d8c02015 	stw	r3,128(sp)
8111a64c:	d8801f15 	stw	r2,124(sp)
8111a650:	b0bff60e 	bge	r22,r2,8111a62c <__reset+0xfb0fa62c>
8111a654:	d9801e04 	addi	r6,sp,120
8111a658:	b80b883a 	mov	r5,r23
8111a65c:	9809883a 	mov	r4,r19
8111a660:	11259300 	call	81125930 <__sprint_r>
8111a664:	103d3a1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111a668:	d8c02017 	ldw	r3,128(sp)
8111a66c:	d8801f17 	ldw	r2,124(sp)
8111a670:	da000404 	addi	r8,sp,16
8111a674:	003fee06 	br	8111a630 <__reset+0xfb0fa630>
8111a678:	d9403117 	ldw	r5,196(sp)
8111a67c:	d8802a17 	ldw	r2,168(sp)
8111a680:	28adc83a 	sub	r22,r5,r2
8111a684:	05be630e 	bge	zero,r22,8111a014 <__reset+0xfb0fa014>
8111a688:	07000404 	movi	fp,16
8111a68c:	d8801f17 	ldw	r2,124(sp)
8111a690:	e5838f0e 	bge	fp,r22,8111b4d0 <___vfprintf_internal_r+0x1d90>
8111a694:	01604534 	movhi	r5,33044
8111a698:	29512d84 	addi	r5,r5,17590
8111a69c:	dc403015 	stw	r17,192(sp)
8111a6a0:	d9402b15 	stw	r5,172(sp)
8111a6a4:	b023883a 	mov	r17,r22
8111a6a8:	04c001c4 	movi	r19,7
8111a6ac:	a82d883a 	mov	r22,r21
8111a6b0:	902b883a 	mov	r21,r18
8111a6b4:	8025883a 	mov	r18,r16
8111a6b8:	dc002c17 	ldw	r16,176(sp)
8111a6bc:	00000306 	br	8111a6cc <___vfprintf_internal_r+0xf8c>
8111a6c0:	8c7ffc04 	addi	r17,r17,-16
8111a6c4:	42000204 	addi	r8,r8,8
8111a6c8:	e440110e 	bge	fp,r17,8111a710 <___vfprintf_internal_r+0xfd0>
8111a6cc:	18c00404 	addi	r3,r3,16
8111a6d0:	10800044 	addi	r2,r2,1
8111a6d4:	45000015 	stw	r20,0(r8)
8111a6d8:	47000115 	stw	fp,4(r8)
8111a6dc:	d8c02015 	stw	r3,128(sp)
8111a6e0:	d8801f15 	stw	r2,124(sp)
8111a6e4:	98bff60e 	bge	r19,r2,8111a6c0 <__reset+0xfb0fa6c0>
8111a6e8:	d9801e04 	addi	r6,sp,120
8111a6ec:	b80b883a 	mov	r5,r23
8111a6f0:	8009883a 	mov	r4,r16
8111a6f4:	11259300 	call	81125930 <__sprint_r>
8111a6f8:	103d151e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111a6fc:	8c7ffc04 	addi	r17,r17,-16
8111a700:	d8c02017 	ldw	r3,128(sp)
8111a704:	d8801f17 	ldw	r2,124(sp)
8111a708:	da000404 	addi	r8,sp,16
8111a70c:	e47fef16 	blt	fp,r17,8111a6cc <__reset+0xfb0fa6cc>
8111a710:	9021883a 	mov	r16,r18
8111a714:	a825883a 	mov	r18,r21
8111a718:	b02b883a 	mov	r21,r22
8111a71c:	882d883a 	mov	r22,r17
8111a720:	dc403017 	ldw	r17,192(sp)
8111a724:	d9002b17 	ldw	r4,172(sp)
8111a728:	1d87883a 	add	r3,r3,r22
8111a72c:	10800044 	addi	r2,r2,1
8111a730:	41000015 	stw	r4,0(r8)
8111a734:	45800115 	stw	r22,4(r8)
8111a738:	d8c02015 	stw	r3,128(sp)
8111a73c:	d8801f15 	stw	r2,124(sp)
8111a740:	010001c4 	movi	r4,7
8111a744:	20818e16 	blt	r4,r2,8111ad80 <___vfprintf_internal_r+0x1640>
8111a748:	42000204 	addi	r8,r8,8
8111a74c:	003e3106 	br	8111a014 <__reset+0xfb0fa014>
8111a750:	d9403317 	ldw	r5,204(sp)
8111a754:	00800044 	movi	r2,1
8111a758:	18c00044 	addi	r3,r3,1
8111a75c:	1141530e 	bge	r2,r5,8111acac <___vfprintf_internal_r+0x156c>
8111a760:	dc401f17 	ldw	r17,124(sp)
8111a764:	00800044 	movi	r2,1
8111a768:	40800115 	stw	r2,4(r8)
8111a76c:	8c400044 	addi	r17,r17,1
8111a770:	44000015 	stw	r16,0(r8)
8111a774:	d8c02015 	stw	r3,128(sp)
8111a778:	dc401f15 	stw	r17,124(sp)
8111a77c:	008001c4 	movi	r2,7
8111a780:	14416b16 	blt	r2,r17,8111ad30 <___vfprintf_internal_r+0x15f0>
8111a784:	42000204 	addi	r8,r8,8
8111a788:	d8803717 	ldw	r2,220(sp)
8111a78c:	d9003417 	ldw	r4,208(sp)
8111a790:	8c400044 	addi	r17,r17,1
8111a794:	10c7883a 	add	r3,r2,r3
8111a798:	40800115 	stw	r2,4(r8)
8111a79c:	41000015 	stw	r4,0(r8)
8111a7a0:	d8c02015 	stw	r3,128(sp)
8111a7a4:	dc401f15 	stw	r17,124(sp)
8111a7a8:	008001c4 	movi	r2,7
8111a7ac:	14416916 	blt	r2,r17,8111ad54 <___vfprintf_internal_r+0x1614>
8111a7b0:	45800204 	addi	r22,r8,8
8111a7b4:	d9003617 	ldw	r4,216(sp)
8111a7b8:	d9403817 	ldw	r5,224(sp)
8111a7bc:	000d883a 	mov	r6,zero
8111a7c0:	000f883a 	mov	r7,zero
8111a7c4:	d8c03c15 	stw	r3,240(sp)
8111a7c8:	112a1780 	call	8112a178 <__eqdf2>
8111a7cc:	d8c03c17 	ldw	r3,240(sp)
8111a7d0:	1000bc26 	beq	r2,zero,8111aac4 <___vfprintf_internal_r+0x1384>
8111a7d4:	d9403317 	ldw	r5,204(sp)
8111a7d8:	84000044 	addi	r16,r16,1
8111a7dc:	8c400044 	addi	r17,r17,1
8111a7e0:	28bfffc4 	addi	r2,r5,-1
8111a7e4:	1887883a 	add	r3,r3,r2
8111a7e8:	b0800115 	stw	r2,4(r22)
8111a7ec:	b4000015 	stw	r16,0(r22)
8111a7f0:	d8c02015 	stw	r3,128(sp)
8111a7f4:	dc401f15 	stw	r17,124(sp)
8111a7f8:	008001c4 	movi	r2,7
8111a7fc:	14414316 	blt	r2,r17,8111ad0c <___vfprintf_internal_r+0x15cc>
8111a800:	b5800204 	addi	r22,r22,8
8111a804:	d9003a17 	ldw	r4,232(sp)
8111a808:	df0022c4 	addi	fp,sp,139
8111a80c:	8c400044 	addi	r17,r17,1
8111a810:	20c7883a 	add	r3,r4,r3
8111a814:	b7000015 	stw	fp,0(r22)
8111a818:	b1000115 	stw	r4,4(r22)
8111a81c:	d8c02015 	stw	r3,128(sp)
8111a820:	dc401f15 	stw	r17,124(sp)
8111a824:	008001c4 	movi	r2,7
8111a828:	14400e16 	blt	r2,r17,8111a864 <___vfprintf_internal_r+0x1124>
8111a82c:	b2000204 	addi	r8,r22,8
8111a830:	003e3a06 	br	8111a11c <__reset+0xfb0fa11c>
8111a834:	01204534 	movhi	r4,33044
8111a838:	21112d84 	addi	r4,r4,17590
8111a83c:	d9002b15 	stw	r4,172(sp)
8111a840:	d9002b17 	ldw	r4,172(sp)
8111a844:	1c07883a 	add	r3,r3,r16
8111a848:	44000115 	stw	r16,4(r8)
8111a84c:	41000015 	stw	r4,0(r8)
8111a850:	10800044 	addi	r2,r2,1
8111a854:	d8c02015 	stw	r3,128(sp)
8111a858:	d8801f15 	stw	r2,124(sp)
8111a85c:	010001c4 	movi	r4,7
8111a860:	20be2d0e 	bge	r4,r2,8111a118 <__reset+0xfb0fa118>
8111a864:	d9002c17 	ldw	r4,176(sp)
8111a868:	d9801e04 	addi	r6,sp,120
8111a86c:	b80b883a 	mov	r5,r23
8111a870:	11259300 	call	81125930 <__sprint_r>
8111a874:	103cb61e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111a878:	d8c02017 	ldw	r3,128(sp)
8111a87c:	da000404 	addi	r8,sp,16
8111a880:	003e2606 	br	8111a11c <__reset+0xfb0fa11c>
8111a884:	d9002c17 	ldw	r4,176(sp)
8111a888:	d9801e04 	addi	r6,sp,120
8111a88c:	b80b883a 	mov	r5,r23
8111a890:	11259300 	call	81125930 <__sprint_r>
8111a894:	103e5d26 	beq	r2,zero,8111a20c <__reset+0xfb0fa20c>
8111a898:	003cad06 	br	81119b50 <__reset+0xfb0f9b50>
8111a89c:	d9002c17 	ldw	r4,176(sp)
8111a8a0:	d9801e04 	addi	r6,sp,120
8111a8a4:	b80b883a 	mov	r5,r23
8111a8a8:	11259300 	call	81125930 <__sprint_r>
8111a8ac:	103ca81e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111a8b0:	d8c02017 	ldw	r3,128(sp)
8111a8b4:	da000404 	addi	r8,sp,16
8111a8b8:	003e0b06 	br	8111a0e8 <__reset+0xfb0fa0e8>
8111a8bc:	d9002c17 	ldw	r4,176(sp)
8111a8c0:	d9801e04 	addi	r6,sp,120
8111a8c4:	b80b883a 	mov	r5,r23
8111a8c8:	11259300 	call	81125930 <__sprint_r>
8111a8cc:	103ca01e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111a8d0:	d8c02017 	ldw	r3,128(sp)
8111a8d4:	da000404 	addi	r8,sp,16
8111a8d8:	003dbd06 	br	81119fd0 <__reset+0xfb0f9fd0>
8111a8dc:	d9002c17 	ldw	r4,176(sp)
8111a8e0:	d9801e04 	addi	r6,sp,120
8111a8e4:	b80b883a 	mov	r5,r23
8111a8e8:	11259300 	call	81125930 <__sprint_r>
8111a8ec:	103c981e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111a8f0:	d8c02017 	ldw	r3,128(sp)
8111a8f4:	da000404 	addi	r8,sp,16
8111a8f8:	003dc306 	br	8111a008 <__reset+0xfb0fa008>
8111a8fc:	d8802917 	ldw	r2,164(sp)
8111a900:	d8002785 	stb	zero,158(sp)
8111a904:	103f0616 	blt	r2,zero,8111a520 <__reset+0xfb0fa520>
8111a908:	00ffdfc4 	movi	r3,-129
8111a90c:	9d84b03a 	or	r2,r19,r22
8111a910:	90e4703a 	and	r18,r18,r3
8111a914:	103c6b26 	beq	r2,zero,81119ac4 <__reset+0xfb0f9ac4>
8111a918:	0039883a 	mov	fp,zero
8111a91c:	003e7406 	br	8111a2f0 <__reset+0xfb0fa2f0>
8111a920:	9080040c 	andi	r2,r18,16
8111a924:	1001b326 	beq	r2,zero,8111aff4 <___vfprintf_internal_r+0x18b4>
8111a928:	d9002d17 	ldw	r4,180(sp)
8111a92c:	d9402917 	ldw	r5,164(sp)
8111a930:	d8002785 	stb	zero,158(sp)
8111a934:	20800104 	addi	r2,r4,4
8111a938:	24c00017 	ldw	r19,0(r4)
8111a93c:	002d883a 	mov	r22,zero
8111a940:	2801b516 	blt	r5,zero,8111b018 <___vfprintf_internal_r+0x18d8>
8111a944:	00ffdfc4 	movi	r3,-129
8111a948:	d8802d15 	stw	r2,180(sp)
8111a94c:	90e4703a 	and	r18,r18,r3
8111a950:	983d2726 	beq	r19,zero,81119df0 <__reset+0xfb0f9df0>
8111a954:	0039883a 	mov	fp,zero
8111a958:	003d2a06 	br	81119e04 <__reset+0xfb0f9e04>
8111a95c:	dc402617 	ldw	r17,152(sp)
8111a960:	0441d30e 	bge	zero,r17,8111b0b0 <___vfprintf_internal_r+0x1970>
8111a964:	dc403217 	ldw	r17,200(sp)
8111a968:	d8803317 	ldw	r2,204(sp)
8111a96c:	1440010e 	bge	r2,r17,8111a974 <___vfprintf_internal_r+0x1234>
8111a970:	1023883a 	mov	r17,r2
8111a974:	04400a0e 	bge	zero,r17,8111a9a0 <___vfprintf_internal_r+0x1260>
8111a978:	d8801f17 	ldw	r2,124(sp)
8111a97c:	1c47883a 	add	r3,r3,r17
8111a980:	44000015 	stw	r16,0(r8)
8111a984:	10800044 	addi	r2,r2,1
8111a988:	44400115 	stw	r17,4(r8)
8111a98c:	d8c02015 	stw	r3,128(sp)
8111a990:	d8801f15 	stw	r2,124(sp)
8111a994:	010001c4 	movi	r4,7
8111a998:	20826516 	blt	r4,r2,8111b330 <___vfprintf_internal_r+0x1bf0>
8111a99c:	42000204 	addi	r8,r8,8
8111a9a0:	88026116 	blt	r17,zero,8111b328 <___vfprintf_internal_r+0x1be8>
8111a9a4:	d9003217 	ldw	r4,200(sp)
8111a9a8:	2463c83a 	sub	r17,r4,r17
8111a9ac:	04407b0e 	bge	zero,r17,8111ab9c <___vfprintf_internal_r+0x145c>
8111a9b0:	05800404 	movi	r22,16
8111a9b4:	d8801f17 	ldw	r2,124(sp)
8111a9b8:	b4419d0e 	bge	r22,r17,8111b030 <___vfprintf_internal_r+0x18f0>
8111a9bc:	01204534 	movhi	r4,33044
8111a9c0:	21112d84 	addi	r4,r4,17590
8111a9c4:	d9002b15 	stw	r4,172(sp)
8111a9c8:	070001c4 	movi	fp,7
8111a9cc:	dcc02c17 	ldw	r19,176(sp)
8111a9d0:	00000306 	br	8111a9e0 <___vfprintf_internal_r+0x12a0>
8111a9d4:	42000204 	addi	r8,r8,8
8111a9d8:	8c7ffc04 	addi	r17,r17,-16
8111a9dc:	b441970e 	bge	r22,r17,8111b03c <___vfprintf_internal_r+0x18fc>
8111a9e0:	18c00404 	addi	r3,r3,16
8111a9e4:	10800044 	addi	r2,r2,1
8111a9e8:	45000015 	stw	r20,0(r8)
8111a9ec:	45800115 	stw	r22,4(r8)
8111a9f0:	d8c02015 	stw	r3,128(sp)
8111a9f4:	d8801f15 	stw	r2,124(sp)
8111a9f8:	e0bff60e 	bge	fp,r2,8111a9d4 <__reset+0xfb0fa9d4>
8111a9fc:	d9801e04 	addi	r6,sp,120
8111aa00:	b80b883a 	mov	r5,r23
8111aa04:	9809883a 	mov	r4,r19
8111aa08:	11259300 	call	81125930 <__sprint_r>
8111aa0c:	103c501e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111aa10:	d8c02017 	ldw	r3,128(sp)
8111aa14:	d8801f17 	ldw	r2,124(sp)
8111aa18:	da000404 	addi	r8,sp,16
8111aa1c:	003fee06 	br	8111a9d8 <__reset+0xfb0fa9d8>
8111aa20:	d9002c17 	ldw	r4,176(sp)
8111aa24:	d9801e04 	addi	r6,sp,120
8111aa28:	b80b883a 	mov	r5,r23
8111aa2c:	11259300 	call	81125930 <__sprint_r>
8111aa30:	103c471e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111aa34:	d8c02017 	ldw	r3,128(sp)
8111aa38:	df002787 	ldb	fp,158(sp)
8111aa3c:	da000404 	addi	r8,sp,16
8111aa40:	003d5606 	br	81119f9c <__reset+0xfb0f9f9c>
8111aa44:	9080040c 	andi	r2,r18,16
8111aa48:	10016126 	beq	r2,zero,8111afd0 <___vfprintf_internal_r+0x1890>
8111aa4c:	d8802d17 	ldw	r2,180(sp)
8111aa50:	14c00017 	ldw	r19,0(r2)
8111aa54:	10800104 	addi	r2,r2,4
8111aa58:	d8802d15 	stw	r2,180(sp)
8111aa5c:	982dd7fa 	srai	r22,r19,31
8111aa60:	b005883a 	mov	r2,r22
8111aa64:	003c8206 	br	81119c70 <__reset+0xfb0f9c70>
8111aa68:	9080040c 	andi	r2,r18,16
8111aa6c:	10003526 	beq	r2,zero,8111ab44 <___vfprintf_internal_r+0x1404>
8111aa70:	d9402d17 	ldw	r5,180(sp)
8111aa74:	d8c02917 	ldw	r3,164(sp)
8111aa78:	d8002785 	stb	zero,158(sp)
8111aa7c:	28800104 	addi	r2,r5,4
8111aa80:	2cc00017 	ldw	r19,0(r5)
8111aa84:	002d883a 	mov	r22,zero
8111aa88:	18003716 	blt	r3,zero,8111ab68 <___vfprintf_internal_r+0x1428>
8111aa8c:	00ffdfc4 	movi	r3,-129
8111aa90:	d8802d15 	stw	r2,180(sp)
8111aa94:	90e4703a 	and	r18,r18,r3
8111aa98:	0039883a 	mov	fp,zero
8111aa9c:	983df326 	beq	r19,zero,8111a26c <__reset+0xfb0fa26c>
8111aaa0:	00800244 	movi	r2,9
8111aaa4:	14fc7b36 	bltu	r2,r19,81119c94 <__reset+0xfb0f9c94>
8111aaa8:	d8c02817 	ldw	r3,160(sp)
8111aaac:	dc001dc4 	addi	r16,sp,119
8111aab0:	9cc00c04 	addi	r19,r19,48
8111aab4:	1c07c83a 	sub	r3,r3,r16
8111aab8:	dcc01dc5 	stb	r19,119(sp)
8111aabc:	d8c02e15 	stw	r3,184(sp)
8111aac0:	003ce806 	br	81119e64 <__reset+0xfb0f9e64>
8111aac4:	d8803317 	ldw	r2,204(sp)
8111aac8:	143fffc4 	addi	r16,r2,-1
8111aacc:	043f4d0e 	bge	zero,r16,8111a804 <__reset+0xfb0fa804>
8111aad0:	07000404 	movi	fp,16
8111aad4:	e400810e 	bge	fp,r16,8111acdc <___vfprintf_internal_r+0x159c>
8111aad8:	01604534 	movhi	r5,33044
8111aadc:	29512d84 	addi	r5,r5,17590
8111aae0:	d9402b15 	stw	r5,172(sp)
8111aae4:	01c001c4 	movi	r7,7
8111aae8:	dcc02c17 	ldw	r19,176(sp)
8111aaec:	00000306 	br	8111aafc <___vfprintf_internal_r+0x13bc>
8111aaf0:	b5800204 	addi	r22,r22,8
8111aaf4:	843ffc04 	addi	r16,r16,-16
8111aaf8:	e4007b0e 	bge	fp,r16,8111ace8 <___vfprintf_internal_r+0x15a8>
8111aafc:	18c00404 	addi	r3,r3,16
8111ab00:	8c400044 	addi	r17,r17,1
8111ab04:	b5000015 	stw	r20,0(r22)
8111ab08:	b7000115 	stw	fp,4(r22)
8111ab0c:	d8c02015 	stw	r3,128(sp)
8111ab10:	dc401f15 	stw	r17,124(sp)
8111ab14:	3c7ff60e 	bge	r7,r17,8111aaf0 <__reset+0xfb0faaf0>
8111ab18:	d9801e04 	addi	r6,sp,120
8111ab1c:	b80b883a 	mov	r5,r23
8111ab20:	9809883a 	mov	r4,r19
8111ab24:	d9c03c15 	stw	r7,240(sp)
8111ab28:	11259300 	call	81125930 <__sprint_r>
8111ab2c:	d9c03c17 	ldw	r7,240(sp)
8111ab30:	103c071e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111ab34:	d8c02017 	ldw	r3,128(sp)
8111ab38:	dc401f17 	ldw	r17,124(sp)
8111ab3c:	dd800404 	addi	r22,sp,16
8111ab40:	003fec06 	br	8111aaf4 <__reset+0xfb0faaf4>
8111ab44:	9080100c 	andi	r2,r18,64
8111ab48:	d8002785 	stb	zero,158(sp)
8111ab4c:	10010e26 	beq	r2,zero,8111af88 <___vfprintf_internal_r+0x1848>
8111ab50:	d9002d17 	ldw	r4,180(sp)
8111ab54:	d9402917 	ldw	r5,164(sp)
8111ab58:	002d883a 	mov	r22,zero
8111ab5c:	20800104 	addi	r2,r4,4
8111ab60:	24c0000b 	ldhu	r19,0(r4)
8111ab64:	283fc90e 	bge	r5,zero,8111aa8c <__reset+0xfb0faa8c>
8111ab68:	d8802d15 	stw	r2,180(sp)
8111ab6c:	0039883a 	mov	fp,zero
8111ab70:	9d84b03a 	or	r2,r19,r22
8111ab74:	103c461e 	bne	r2,zero,81119c90 <__reset+0xfb0f9c90>
8111ab78:	00800044 	movi	r2,1
8111ab7c:	003e6c06 	br	8111a530 <__reset+0xfb0fa530>
8111ab80:	d9002c17 	ldw	r4,176(sp)
8111ab84:	d9801e04 	addi	r6,sp,120
8111ab88:	b80b883a 	mov	r5,r23
8111ab8c:	11259300 	call	81125930 <__sprint_r>
8111ab90:	103bef1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111ab94:	d8c02017 	ldw	r3,128(sp)
8111ab98:	da000404 	addi	r8,sp,16
8111ab9c:	d9003217 	ldw	r4,200(sp)
8111aba0:	d8802617 	ldw	r2,152(sp)
8111aba4:	d9403317 	ldw	r5,204(sp)
8111aba8:	8123883a 	add	r17,r16,r4
8111abac:	11400216 	blt	r2,r5,8111abb8 <___vfprintf_internal_r+0x1478>
8111abb0:	9100004c 	andi	r4,r18,1
8111abb4:	20000d26 	beq	r4,zero,8111abec <___vfprintf_internal_r+0x14ac>
8111abb8:	d9003717 	ldw	r4,220(sp)
8111abbc:	d9403417 	ldw	r5,208(sp)
8111abc0:	1907883a 	add	r3,r3,r4
8111abc4:	d9001f17 	ldw	r4,124(sp)
8111abc8:	41400015 	stw	r5,0(r8)
8111abcc:	d9403717 	ldw	r5,220(sp)
8111abd0:	21000044 	addi	r4,r4,1
8111abd4:	d8c02015 	stw	r3,128(sp)
8111abd8:	41400115 	stw	r5,4(r8)
8111abdc:	d9001f15 	stw	r4,124(sp)
8111abe0:	014001c4 	movi	r5,7
8111abe4:	2901e816 	blt	r5,r4,8111b388 <___vfprintf_internal_r+0x1c48>
8111abe8:	42000204 	addi	r8,r8,8
8111abec:	d9003317 	ldw	r4,204(sp)
8111abf0:	8121883a 	add	r16,r16,r4
8111abf4:	2085c83a 	sub	r2,r4,r2
8111abf8:	8461c83a 	sub	r16,r16,r17
8111abfc:	1400010e 	bge	r2,r16,8111ac04 <___vfprintf_internal_r+0x14c4>
8111ac00:	1021883a 	mov	r16,r2
8111ac04:	04000a0e 	bge	zero,r16,8111ac30 <___vfprintf_internal_r+0x14f0>
8111ac08:	d9001f17 	ldw	r4,124(sp)
8111ac0c:	1c07883a 	add	r3,r3,r16
8111ac10:	44400015 	stw	r17,0(r8)
8111ac14:	21000044 	addi	r4,r4,1
8111ac18:	44000115 	stw	r16,4(r8)
8111ac1c:	d8c02015 	stw	r3,128(sp)
8111ac20:	d9001f15 	stw	r4,124(sp)
8111ac24:	014001c4 	movi	r5,7
8111ac28:	2901fb16 	blt	r5,r4,8111b418 <___vfprintf_internal_r+0x1cd8>
8111ac2c:	42000204 	addi	r8,r8,8
8111ac30:	8001f716 	blt	r16,zero,8111b410 <___vfprintf_internal_r+0x1cd0>
8111ac34:	1421c83a 	sub	r16,r2,r16
8111ac38:	043d380e 	bge	zero,r16,8111a11c <__reset+0xfb0fa11c>
8111ac3c:	04400404 	movi	r17,16
8111ac40:	d8801f17 	ldw	r2,124(sp)
8111ac44:	8c3efb0e 	bge	r17,r16,8111a834 <__reset+0xfb0fa834>
8111ac48:	01604534 	movhi	r5,33044
8111ac4c:	29512d84 	addi	r5,r5,17590
8111ac50:	d9402b15 	stw	r5,172(sp)
8111ac54:	058001c4 	movi	r22,7
8111ac58:	dcc02c17 	ldw	r19,176(sp)
8111ac5c:	00000306 	br	8111ac6c <___vfprintf_internal_r+0x152c>
8111ac60:	42000204 	addi	r8,r8,8
8111ac64:	843ffc04 	addi	r16,r16,-16
8111ac68:	8c3ef50e 	bge	r17,r16,8111a840 <__reset+0xfb0fa840>
8111ac6c:	18c00404 	addi	r3,r3,16
8111ac70:	10800044 	addi	r2,r2,1
8111ac74:	45000015 	stw	r20,0(r8)
8111ac78:	44400115 	stw	r17,4(r8)
8111ac7c:	d8c02015 	stw	r3,128(sp)
8111ac80:	d8801f15 	stw	r2,124(sp)
8111ac84:	b0bff60e 	bge	r22,r2,8111ac60 <__reset+0xfb0fac60>
8111ac88:	d9801e04 	addi	r6,sp,120
8111ac8c:	b80b883a 	mov	r5,r23
8111ac90:	9809883a 	mov	r4,r19
8111ac94:	11259300 	call	81125930 <__sprint_r>
8111ac98:	103bad1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111ac9c:	d8c02017 	ldw	r3,128(sp)
8111aca0:	d8801f17 	ldw	r2,124(sp)
8111aca4:	da000404 	addi	r8,sp,16
8111aca8:	003fee06 	br	8111ac64 <__reset+0xfb0fac64>
8111acac:	9088703a 	and	r4,r18,r2
8111acb0:	203eab1e 	bne	r4,zero,8111a760 <__reset+0xfb0fa760>
8111acb4:	dc401f17 	ldw	r17,124(sp)
8111acb8:	40800115 	stw	r2,4(r8)
8111acbc:	44000015 	stw	r16,0(r8)
8111acc0:	8c400044 	addi	r17,r17,1
8111acc4:	d8c02015 	stw	r3,128(sp)
8111acc8:	dc401f15 	stw	r17,124(sp)
8111accc:	008001c4 	movi	r2,7
8111acd0:	14400e16 	blt	r2,r17,8111ad0c <___vfprintf_internal_r+0x15cc>
8111acd4:	45800204 	addi	r22,r8,8
8111acd8:	003eca06 	br	8111a804 <__reset+0xfb0fa804>
8111acdc:	01204534 	movhi	r4,33044
8111ace0:	21112d84 	addi	r4,r4,17590
8111ace4:	d9002b15 	stw	r4,172(sp)
8111ace8:	d8802b17 	ldw	r2,172(sp)
8111acec:	1c07883a 	add	r3,r3,r16
8111acf0:	8c400044 	addi	r17,r17,1
8111acf4:	b0800015 	stw	r2,0(r22)
8111acf8:	b4000115 	stw	r16,4(r22)
8111acfc:	d8c02015 	stw	r3,128(sp)
8111ad00:	dc401f15 	stw	r17,124(sp)
8111ad04:	008001c4 	movi	r2,7
8111ad08:	147ebd0e 	bge	r2,r17,8111a800 <__reset+0xfb0fa800>
8111ad0c:	d9002c17 	ldw	r4,176(sp)
8111ad10:	d9801e04 	addi	r6,sp,120
8111ad14:	b80b883a 	mov	r5,r23
8111ad18:	11259300 	call	81125930 <__sprint_r>
8111ad1c:	103b8c1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111ad20:	d8c02017 	ldw	r3,128(sp)
8111ad24:	dc401f17 	ldw	r17,124(sp)
8111ad28:	dd800404 	addi	r22,sp,16
8111ad2c:	003eb506 	br	8111a804 <__reset+0xfb0fa804>
8111ad30:	d9002c17 	ldw	r4,176(sp)
8111ad34:	d9801e04 	addi	r6,sp,120
8111ad38:	b80b883a 	mov	r5,r23
8111ad3c:	11259300 	call	81125930 <__sprint_r>
8111ad40:	103b831e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111ad44:	d8c02017 	ldw	r3,128(sp)
8111ad48:	dc401f17 	ldw	r17,124(sp)
8111ad4c:	da000404 	addi	r8,sp,16
8111ad50:	003e8d06 	br	8111a788 <__reset+0xfb0fa788>
8111ad54:	d9002c17 	ldw	r4,176(sp)
8111ad58:	d9801e04 	addi	r6,sp,120
8111ad5c:	b80b883a 	mov	r5,r23
8111ad60:	11259300 	call	81125930 <__sprint_r>
8111ad64:	103b7a1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111ad68:	d8c02017 	ldw	r3,128(sp)
8111ad6c:	dc401f17 	ldw	r17,124(sp)
8111ad70:	dd800404 	addi	r22,sp,16
8111ad74:	003e8f06 	br	8111a7b4 <__reset+0xfb0fa7b4>
8111ad78:	0027883a 	mov	r19,zero
8111ad7c:	003f4a06 	br	8111aaa8 <__reset+0xfb0faaa8>
8111ad80:	d9002c17 	ldw	r4,176(sp)
8111ad84:	d9801e04 	addi	r6,sp,120
8111ad88:	b80b883a 	mov	r5,r23
8111ad8c:	11259300 	call	81125930 <__sprint_r>
8111ad90:	103b6f1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111ad94:	d8c02017 	ldw	r3,128(sp)
8111ad98:	da000404 	addi	r8,sp,16
8111ad9c:	003c9d06 	br	8111a014 <__reset+0xfb0fa014>
8111ada0:	04e7c83a 	sub	r19,zero,r19
8111ada4:	9804c03a 	cmpne	r2,r19,zero
8111ada8:	05adc83a 	sub	r22,zero,r22
8111adac:	b0adc83a 	sub	r22,r22,r2
8111adb0:	d8802917 	ldw	r2,164(sp)
8111adb4:	07000b44 	movi	fp,45
8111adb8:	df002785 	stb	fp,158(sp)
8111adbc:	10017b16 	blt	r2,zero,8111b3ac <___vfprintf_internal_r+0x1c6c>
8111adc0:	00bfdfc4 	movi	r2,-129
8111adc4:	90a4703a 	and	r18,r18,r2
8111adc8:	003bb106 	br	81119c90 <__reset+0xfb0f9c90>
8111adcc:	d9003617 	ldw	r4,216(sp)
8111add0:	d9403817 	ldw	r5,224(sp)
8111add4:	da003d15 	stw	r8,244(sp)
8111add8:	1121f940 	call	81121f94 <__fpclassifyd>
8111addc:	da003d17 	ldw	r8,244(sp)
8111ade0:	1000f026 	beq	r2,zero,8111b1a4 <___vfprintf_internal_r+0x1a64>
8111ade4:	d9002917 	ldw	r4,164(sp)
8111ade8:	05bff7c4 	movi	r22,-33
8111adec:	00bfffc4 	movi	r2,-1
8111adf0:	8dac703a 	and	r22,r17,r22
8111adf4:	20820026 	beq	r4,r2,8111b5f8 <___vfprintf_internal_r+0x1eb8>
8111adf8:	008011c4 	movi	r2,71
8111adfc:	b081f726 	beq	r22,r2,8111b5dc <___vfprintf_internal_r+0x1e9c>
8111ae00:	d9003817 	ldw	r4,224(sp)
8111ae04:	90c04014 	ori	r3,r18,256
8111ae08:	d8c02b15 	stw	r3,172(sp)
8111ae0c:	20021516 	blt	r4,zero,8111b664 <___vfprintf_internal_r+0x1f24>
8111ae10:	dcc03817 	ldw	r19,224(sp)
8111ae14:	d8002a05 	stb	zero,168(sp)
8111ae18:	00801984 	movi	r2,102
8111ae1c:	8881f926 	beq	r17,r2,8111b604 <___vfprintf_internal_r+0x1ec4>
8111ae20:	00801184 	movi	r2,70
8111ae24:	88821c26 	beq	r17,r2,8111b698 <___vfprintf_internal_r+0x1f58>
8111ae28:	00801144 	movi	r2,69
8111ae2c:	b081ef26 	beq	r22,r2,8111b5ec <___vfprintf_internal_r+0x1eac>
8111ae30:	d8c02917 	ldw	r3,164(sp)
8111ae34:	d8802104 	addi	r2,sp,132
8111ae38:	d8800315 	stw	r2,12(sp)
8111ae3c:	d9403617 	ldw	r5,216(sp)
8111ae40:	d8802504 	addi	r2,sp,148
8111ae44:	d9002c17 	ldw	r4,176(sp)
8111ae48:	d8800215 	stw	r2,8(sp)
8111ae4c:	d8802604 	addi	r2,sp,152
8111ae50:	d8c00015 	stw	r3,0(sp)
8111ae54:	d8800115 	stw	r2,4(sp)
8111ae58:	01c00084 	movi	r7,2
8111ae5c:	980d883a 	mov	r6,r19
8111ae60:	d8c03c15 	stw	r3,240(sp)
8111ae64:	da003d15 	stw	r8,244(sp)
8111ae68:	111d84c0 	call	8111d84c <_dtoa_r>
8111ae6c:	1021883a 	mov	r16,r2
8111ae70:	008019c4 	movi	r2,103
8111ae74:	d8c03c17 	ldw	r3,240(sp)
8111ae78:	da003d17 	ldw	r8,244(sp)
8111ae7c:	88817126 	beq	r17,r2,8111b444 <___vfprintf_internal_r+0x1d04>
8111ae80:	008011c4 	movi	r2,71
8111ae84:	88829226 	beq	r17,r2,8111b8d0 <___vfprintf_internal_r+0x2190>
8111ae88:	80f9883a 	add	fp,r16,r3
8111ae8c:	d9003617 	ldw	r4,216(sp)
8111ae90:	000d883a 	mov	r6,zero
8111ae94:	000f883a 	mov	r7,zero
8111ae98:	980b883a 	mov	r5,r19
8111ae9c:	da003d15 	stw	r8,244(sp)
8111aea0:	112a1780 	call	8112a178 <__eqdf2>
8111aea4:	da003d17 	ldw	r8,244(sp)
8111aea8:	10018d26 	beq	r2,zero,8111b4e0 <___vfprintf_internal_r+0x1da0>
8111aeac:	d8802117 	ldw	r2,132(sp)
8111aeb0:	1700062e 	bgeu	r2,fp,8111aecc <___vfprintf_internal_r+0x178c>
8111aeb4:	01000c04 	movi	r4,48
8111aeb8:	10c00044 	addi	r3,r2,1
8111aebc:	d8c02115 	stw	r3,132(sp)
8111aec0:	11000005 	stb	r4,0(r2)
8111aec4:	d8802117 	ldw	r2,132(sp)
8111aec8:	173ffb36 	bltu	r2,fp,8111aeb8 <__reset+0xfb0faeb8>
8111aecc:	1405c83a 	sub	r2,r2,r16
8111aed0:	d8803315 	stw	r2,204(sp)
8111aed4:	008011c4 	movi	r2,71
8111aed8:	b0817626 	beq	r22,r2,8111b4b4 <___vfprintf_internal_r+0x1d74>
8111aedc:	00801944 	movi	r2,101
8111aee0:	1442810e 	bge	r2,r17,8111b8e8 <___vfprintf_internal_r+0x21a8>
8111aee4:	d8c02617 	ldw	r3,152(sp)
8111aee8:	00801984 	movi	r2,102
8111aeec:	d8c03215 	stw	r3,200(sp)
8111aef0:	8881fe26 	beq	r17,r2,8111b6ec <___vfprintf_internal_r+0x1fac>
8111aef4:	d8c03217 	ldw	r3,200(sp)
8111aef8:	d9003317 	ldw	r4,204(sp)
8111aefc:	1901dd16 	blt	r3,r4,8111b674 <___vfprintf_internal_r+0x1f34>
8111af00:	9480004c 	andi	r18,r18,1
8111af04:	90022b1e 	bne	r18,zero,8111b7b4 <___vfprintf_internal_r+0x2074>
8111af08:	1805883a 	mov	r2,r3
8111af0c:	18028016 	blt	r3,zero,8111b910 <___vfprintf_internal_r+0x21d0>
8111af10:	d8c03217 	ldw	r3,200(sp)
8111af14:	044019c4 	movi	r17,103
8111af18:	d8c02e15 	stw	r3,184(sp)
8111af1c:	df002a07 	ldb	fp,168(sp)
8111af20:	e001531e 	bne	fp,zero,8111b470 <___vfprintf_internal_r+0x1d30>
8111af24:	df002783 	ldbu	fp,158(sp)
8111af28:	d8802a15 	stw	r2,168(sp)
8111af2c:	dc802b17 	ldw	r18,172(sp)
8111af30:	d8002915 	stw	zero,164(sp)
8111af34:	003bd106 	br	81119e7c <__reset+0xfb0f9e7c>
8111af38:	d8802d17 	ldw	r2,180(sp)
8111af3c:	d8c02d17 	ldw	r3,180(sp)
8111af40:	d9002d17 	ldw	r4,180(sp)
8111af44:	10800017 	ldw	r2,0(r2)
8111af48:	18c00117 	ldw	r3,4(r3)
8111af4c:	21000204 	addi	r4,r4,8
8111af50:	d8803615 	stw	r2,216(sp)
8111af54:	d8c03815 	stw	r3,224(sp)
8111af58:	d9002d15 	stw	r4,180(sp)
8111af5c:	003b7506 	br	81119d34 <__reset+0xfb0f9d34>
8111af60:	ac400007 	ldb	r17,0(r21)
8111af64:	003a5906 	br	811198cc <__reset+0xfb0f98cc>
8111af68:	9080100c 	andi	r2,r18,64
8111af6c:	1000a826 	beq	r2,zero,8111b210 <___vfprintf_internal_r+0x1ad0>
8111af70:	d9002d17 	ldw	r4,180(sp)
8111af74:	002d883a 	mov	r22,zero
8111af78:	24c0000b 	ldhu	r19,0(r4)
8111af7c:	21000104 	addi	r4,r4,4
8111af80:	d9002d15 	stw	r4,180(sp)
8111af84:	003ccb06 	br	8111a2b4 <__reset+0xfb0fa2b4>
8111af88:	d8c02d17 	ldw	r3,180(sp)
8111af8c:	d9002917 	ldw	r4,164(sp)
8111af90:	002d883a 	mov	r22,zero
8111af94:	18800104 	addi	r2,r3,4
8111af98:	1cc00017 	ldw	r19,0(r3)
8111af9c:	203ebb0e 	bge	r4,zero,8111aa8c <__reset+0xfb0faa8c>
8111afa0:	003ef106 	br	8111ab68 <__reset+0xfb0fab68>
8111afa4:	9080040c 	andi	r2,r18,16
8111afa8:	1000921e 	bne	r2,zero,8111b1f4 <___vfprintf_internal_r+0x1ab4>
8111afac:	9480100c 	andi	r18,r18,64
8111afb0:	90013926 	beq	r18,zero,8111b498 <___vfprintf_internal_r+0x1d58>
8111afb4:	d9002d17 	ldw	r4,180(sp)
8111afb8:	d9402f17 	ldw	r5,188(sp)
8111afbc:	20800017 	ldw	r2,0(r4)
8111afc0:	21000104 	addi	r4,r4,4
8111afc4:	d9002d15 	stw	r4,180(sp)
8111afc8:	1140000d 	sth	r5,0(r2)
8111afcc:	003a1606 	br	81119828 <__reset+0xfb0f9828>
8111afd0:	9080100c 	andi	r2,r18,64
8111afd4:	10008026 	beq	r2,zero,8111b1d8 <___vfprintf_internal_r+0x1a98>
8111afd8:	d8c02d17 	ldw	r3,180(sp)
8111afdc:	1cc0000f 	ldh	r19,0(r3)
8111afe0:	18c00104 	addi	r3,r3,4
8111afe4:	d8c02d15 	stw	r3,180(sp)
8111afe8:	982dd7fa 	srai	r22,r19,31
8111afec:	b005883a 	mov	r2,r22
8111aff0:	003b1f06 	br	81119c70 <__reset+0xfb0f9c70>
8111aff4:	9080100c 	andi	r2,r18,64
8111aff8:	d8002785 	stb	zero,158(sp)
8111affc:	10008a1e 	bne	r2,zero,8111b228 <___vfprintf_internal_r+0x1ae8>
8111b000:	d9402d17 	ldw	r5,180(sp)
8111b004:	d8c02917 	ldw	r3,164(sp)
8111b008:	002d883a 	mov	r22,zero
8111b00c:	28800104 	addi	r2,r5,4
8111b010:	2cc00017 	ldw	r19,0(r5)
8111b014:	183e4b0e 	bge	r3,zero,8111a944 <__reset+0xfb0fa944>
8111b018:	9d86b03a 	or	r3,r19,r22
8111b01c:	d8802d15 	stw	r2,180(sp)
8111b020:	183e4c1e 	bne	r3,zero,8111a954 <__reset+0xfb0fa954>
8111b024:	0039883a 	mov	fp,zero
8111b028:	0005883a 	mov	r2,zero
8111b02c:	003d4006 	br	8111a530 <__reset+0xfb0fa530>
8111b030:	01604534 	movhi	r5,33044
8111b034:	29512d84 	addi	r5,r5,17590
8111b038:	d9402b15 	stw	r5,172(sp)
8111b03c:	d9402b17 	ldw	r5,172(sp)
8111b040:	1c47883a 	add	r3,r3,r17
8111b044:	10800044 	addi	r2,r2,1
8111b048:	41400015 	stw	r5,0(r8)
8111b04c:	44400115 	stw	r17,4(r8)
8111b050:	d8c02015 	stw	r3,128(sp)
8111b054:	d8801f15 	stw	r2,124(sp)
8111b058:	010001c4 	movi	r4,7
8111b05c:	20bec816 	blt	r4,r2,8111ab80 <__reset+0xfb0fab80>
8111b060:	42000204 	addi	r8,r8,8
8111b064:	003ecd06 	br	8111ab9c <__reset+0xfb0fab9c>
8111b068:	d9002917 	ldw	r4,164(sp)
8111b06c:	d8002785 	stb	zero,158(sp)
8111b070:	203d2d16 	blt	r4,zero,8111a528 <__reset+0xfb0fa528>
8111b074:	00bfdfc4 	movi	r2,-129
8111b078:	90a4703a 	and	r18,r18,r2
8111b07c:	003a9106 	br	81119ac4 <__reset+0xfb0f9ac4>
8111b080:	01204534 	movhi	r4,33044
8111b084:	21112d84 	addi	r4,r4,17590
8111b088:	d9002b15 	stw	r4,172(sp)
8111b08c:	003c0c06 	br	8111a0c0 <__reset+0xfb0fa0c0>
8111b090:	d9002c17 	ldw	r4,176(sp)
8111b094:	d9801e04 	addi	r6,sp,120
8111b098:	b80b883a 	mov	r5,r23
8111b09c:	11259300 	call	81125930 <__sprint_r>
8111b0a0:	103aab1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111b0a4:	d8c02017 	ldw	r3,128(sp)
8111b0a8:	da000404 	addi	r8,sp,16
8111b0ac:	003d4106 	br	8111a5b4 <__reset+0xfb0fa5b4>
8111b0b0:	d8801f17 	ldw	r2,124(sp)
8111b0b4:	01604534 	movhi	r5,33044
8111b0b8:	01000044 	movi	r4,1
8111b0bc:	18c00044 	addi	r3,r3,1
8111b0c0:	10800044 	addi	r2,r2,1
8111b0c4:	29512504 	addi	r5,r5,17556
8111b0c8:	41000115 	stw	r4,4(r8)
8111b0cc:	41400015 	stw	r5,0(r8)
8111b0d0:	d8c02015 	stw	r3,128(sp)
8111b0d4:	d8801f15 	stw	r2,124(sp)
8111b0d8:	010001c4 	movi	r4,7
8111b0dc:	20805c16 	blt	r4,r2,8111b250 <___vfprintf_internal_r+0x1b10>
8111b0e0:	42000204 	addi	r8,r8,8
8111b0e4:	8800041e 	bne	r17,zero,8111b0f8 <___vfprintf_internal_r+0x19b8>
8111b0e8:	d8803317 	ldw	r2,204(sp)
8111b0ec:	1000021e 	bne	r2,zero,8111b0f8 <___vfprintf_internal_r+0x19b8>
8111b0f0:	9080004c 	andi	r2,r18,1
8111b0f4:	103c0926 	beq	r2,zero,8111a11c <__reset+0xfb0fa11c>
8111b0f8:	d9003717 	ldw	r4,220(sp)
8111b0fc:	d8801f17 	ldw	r2,124(sp)
8111b100:	d9403417 	ldw	r5,208(sp)
8111b104:	20c7883a 	add	r3,r4,r3
8111b108:	10800044 	addi	r2,r2,1
8111b10c:	41000115 	stw	r4,4(r8)
8111b110:	41400015 	stw	r5,0(r8)
8111b114:	d8c02015 	stw	r3,128(sp)
8111b118:	d8801f15 	stw	r2,124(sp)
8111b11c:	010001c4 	movi	r4,7
8111b120:	20812116 	blt	r4,r2,8111b5a8 <___vfprintf_internal_r+0x1e68>
8111b124:	42000204 	addi	r8,r8,8
8111b128:	0463c83a 	sub	r17,zero,r17
8111b12c:	0440730e 	bge	zero,r17,8111b2fc <___vfprintf_internal_r+0x1bbc>
8111b130:	05800404 	movi	r22,16
8111b134:	b440860e 	bge	r22,r17,8111b350 <___vfprintf_internal_r+0x1c10>
8111b138:	01604534 	movhi	r5,33044
8111b13c:	29512d84 	addi	r5,r5,17590
8111b140:	d9402b15 	stw	r5,172(sp)
8111b144:	070001c4 	movi	fp,7
8111b148:	dcc02c17 	ldw	r19,176(sp)
8111b14c:	00000306 	br	8111b15c <___vfprintf_internal_r+0x1a1c>
8111b150:	42000204 	addi	r8,r8,8
8111b154:	8c7ffc04 	addi	r17,r17,-16
8111b158:	b440800e 	bge	r22,r17,8111b35c <___vfprintf_internal_r+0x1c1c>
8111b15c:	18c00404 	addi	r3,r3,16
8111b160:	10800044 	addi	r2,r2,1
8111b164:	45000015 	stw	r20,0(r8)
8111b168:	45800115 	stw	r22,4(r8)
8111b16c:	d8c02015 	stw	r3,128(sp)
8111b170:	d8801f15 	stw	r2,124(sp)
8111b174:	e0bff60e 	bge	fp,r2,8111b150 <__reset+0xfb0fb150>
8111b178:	d9801e04 	addi	r6,sp,120
8111b17c:	b80b883a 	mov	r5,r23
8111b180:	9809883a 	mov	r4,r19
8111b184:	11259300 	call	81125930 <__sprint_r>
8111b188:	103a711e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111b18c:	d8c02017 	ldw	r3,128(sp)
8111b190:	d8801f17 	ldw	r2,124(sp)
8111b194:	da000404 	addi	r8,sp,16
8111b198:	003fee06 	br	8111b154 <__reset+0xfb0fb154>
8111b19c:	00bfffc4 	movi	r2,-1
8111b1a0:	003a6f06 	br	81119b60 <__reset+0xfb0f9b60>
8111b1a4:	008011c4 	movi	r2,71
8111b1a8:	1440b816 	blt	r2,r17,8111b48c <___vfprintf_internal_r+0x1d4c>
8111b1ac:	04204534 	movhi	r16,33044
8111b1b0:	84111704 	addi	r16,r16,17500
8111b1b4:	00c000c4 	movi	r3,3
8111b1b8:	00bfdfc4 	movi	r2,-129
8111b1bc:	d8c02a15 	stw	r3,168(sp)
8111b1c0:	90a4703a 	and	r18,r18,r2
8111b1c4:	df002783 	ldbu	fp,158(sp)
8111b1c8:	d8c02e15 	stw	r3,184(sp)
8111b1cc:	d8002915 	stw	zero,164(sp)
8111b1d0:	d8003215 	stw	zero,200(sp)
8111b1d4:	003b2906 	br	81119e7c <__reset+0xfb0f9e7c>
8111b1d8:	d9002d17 	ldw	r4,180(sp)
8111b1dc:	24c00017 	ldw	r19,0(r4)
8111b1e0:	21000104 	addi	r4,r4,4
8111b1e4:	d9002d15 	stw	r4,180(sp)
8111b1e8:	982dd7fa 	srai	r22,r19,31
8111b1ec:	b005883a 	mov	r2,r22
8111b1f0:	003a9f06 	br	81119c70 <__reset+0xfb0f9c70>
8111b1f4:	d9402d17 	ldw	r5,180(sp)
8111b1f8:	d8c02f17 	ldw	r3,188(sp)
8111b1fc:	28800017 	ldw	r2,0(r5)
8111b200:	29400104 	addi	r5,r5,4
8111b204:	d9402d15 	stw	r5,180(sp)
8111b208:	10c00015 	stw	r3,0(r2)
8111b20c:	00398606 	br	81119828 <__reset+0xfb0f9828>
8111b210:	d9402d17 	ldw	r5,180(sp)
8111b214:	002d883a 	mov	r22,zero
8111b218:	2cc00017 	ldw	r19,0(r5)
8111b21c:	29400104 	addi	r5,r5,4
8111b220:	d9402d15 	stw	r5,180(sp)
8111b224:	003c2306 	br	8111a2b4 <__reset+0xfb0fa2b4>
8111b228:	d8c02d17 	ldw	r3,180(sp)
8111b22c:	d9002917 	ldw	r4,164(sp)
8111b230:	002d883a 	mov	r22,zero
8111b234:	18800104 	addi	r2,r3,4
8111b238:	1cc0000b 	ldhu	r19,0(r3)
8111b23c:	203dc10e 	bge	r4,zero,8111a944 <__reset+0xfb0fa944>
8111b240:	003f7506 	br	8111b018 <__reset+0xfb0fb018>
8111b244:	04204534 	movhi	r16,33044
8111b248:	84111504 	addi	r16,r16,17492
8111b24c:	003acc06 	br	81119d80 <__reset+0xfb0f9d80>
8111b250:	d9002c17 	ldw	r4,176(sp)
8111b254:	d9801e04 	addi	r6,sp,120
8111b258:	b80b883a 	mov	r5,r23
8111b25c:	11259300 	call	81125930 <__sprint_r>
8111b260:	103a3b1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111b264:	dc402617 	ldw	r17,152(sp)
8111b268:	d8c02017 	ldw	r3,128(sp)
8111b26c:	da000404 	addi	r8,sp,16
8111b270:	003f9c06 	br	8111b0e4 <__reset+0xfb0fb0e4>
8111b274:	ac400043 	ldbu	r17,1(r21)
8111b278:	94800814 	ori	r18,r18,32
8111b27c:	ad400044 	addi	r21,r21,1
8111b280:	8c403fcc 	andi	r17,r17,255
8111b284:	8c40201c 	xori	r17,r17,128
8111b288:	8c7fe004 	addi	r17,r17,-128
8111b28c:	00398f06 	br	811198cc <__reset+0xfb0f98cc>
8111b290:	d8c02d15 	stw	r3,180(sp)
8111b294:	0039883a 	mov	fp,zero
8111b298:	003e3506 	br	8111ab70 <__reset+0xfb0fab70>
8111b29c:	d9002c17 	ldw	r4,176(sp)
8111b2a0:	d9801e04 	addi	r6,sp,120
8111b2a4:	b80b883a 	mov	r5,r23
8111b2a8:	11259300 	call	81125930 <__sprint_r>
8111b2ac:	103a281e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111b2b0:	d8c02017 	ldw	r3,128(sp)
8111b2b4:	da000404 	addi	r8,sp,16
8111b2b8:	003cd006 	br	8111a5fc <__reset+0xfb0fa5fc>
8111b2bc:	8009883a 	mov	r4,r16
8111b2c0:	da003d15 	stw	r8,244(sp)
8111b2c4:	11172280 	call	81117228 <strlen>
8111b2c8:	d8802e15 	stw	r2,184(sp)
8111b2cc:	da003d17 	ldw	r8,244(sp)
8111b2d0:	103c340e 	bge	r2,zero,8111a3a4 <__reset+0xfb0fa3a4>
8111b2d4:	0005883a 	mov	r2,zero
8111b2d8:	003c3206 	br	8111a3a4 <__reset+0xfb0fa3a4>
8111b2dc:	d9002c17 	ldw	r4,176(sp)
8111b2e0:	d9801e04 	addi	r6,sp,120
8111b2e4:	b80b883a 	mov	r5,r23
8111b2e8:	11259300 	call	81125930 <__sprint_r>
8111b2ec:	103a181e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111b2f0:	d8c02017 	ldw	r3,128(sp)
8111b2f4:	d8801f17 	ldw	r2,124(sp)
8111b2f8:	da000404 	addi	r8,sp,16
8111b2fc:	d9403317 	ldw	r5,204(sp)
8111b300:	10800044 	addi	r2,r2,1
8111b304:	44000015 	stw	r16,0(r8)
8111b308:	28c7883a 	add	r3,r5,r3
8111b30c:	003b7d06 	br	8111a104 <__reset+0xfb0fa104>
8111b310:	01204534 	movhi	r4,33044
8111b314:	21113184 	addi	r4,r4,17606
8111b318:	d9003515 	stw	r4,212(sp)
8111b31c:	003b1406 	br	81119f70 <__reset+0xfb0f9f70>
8111b320:	013fffc4 	movi	r4,-1
8111b324:	003a3506 	br	81119bfc <__reset+0xfb0f9bfc>
8111b328:	0023883a 	mov	r17,zero
8111b32c:	003d9d06 	br	8111a9a4 <__reset+0xfb0fa9a4>
8111b330:	d9002c17 	ldw	r4,176(sp)
8111b334:	d9801e04 	addi	r6,sp,120
8111b338:	b80b883a 	mov	r5,r23
8111b33c:	11259300 	call	81125930 <__sprint_r>
8111b340:	103a031e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111b344:	d8c02017 	ldw	r3,128(sp)
8111b348:	da000404 	addi	r8,sp,16
8111b34c:	003d9406 	br	8111a9a0 <__reset+0xfb0fa9a0>
8111b350:	01204534 	movhi	r4,33044
8111b354:	21112d84 	addi	r4,r4,17590
8111b358:	d9002b15 	stw	r4,172(sp)
8111b35c:	d9002b17 	ldw	r4,172(sp)
8111b360:	1c47883a 	add	r3,r3,r17
8111b364:	10800044 	addi	r2,r2,1
8111b368:	41000015 	stw	r4,0(r8)
8111b36c:	44400115 	stw	r17,4(r8)
8111b370:	d8c02015 	stw	r3,128(sp)
8111b374:	d8801f15 	stw	r2,124(sp)
8111b378:	010001c4 	movi	r4,7
8111b37c:	20bfd716 	blt	r4,r2,8111b2dc <__reset+0xfb0fb2dc>
8111b380:	42000204 	addi	r8,r8,8
8111b384:	003fdd06 	br	8111b2fc <__reset+0xfb0fb2fc>
8111b388:	d9002c17 	ldw	r4,176(sp)
8111b38c:	d9801e04 	addi	r6,sp,120
8111b390:	b80b883a 	mov	r5,r23
8111b394:	11259300 	call	81125930 <__sprint_r>
8111b398:	1039ed1e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111b39c:	d8802617 	ldw	r2,152(sp)
8111b3a0:	d8c02017 	ldw	r3,128(sp)
8111b3a4:	da000404 	addi	r8,sp,16
8111b3a8:	003e1006 	br	8111abec <__reset+0xfb0fabec>
8111b3ac:	00800044 	movi	r2,1
8111b3b0:	10803fcc 	andi	r2,r2,255
8111b3b4:	00c00044 	movi	r3,1
8111b3b8:	10fa3526 	beq	r2,r3,81119c90 <__reset+0xfb0f9c90>
8111b3bc:	00c00084 	movi	r3,2
8111b3c0:	10fbcb26 	beq	r2,r3,8111a2f0 <__reset+0xfb0fa2f0>
8111b3c4:	003a8f06 	br	81119e04 <__reset+0xfb0f9e04>
8111b3c8:	01204534 	movhi	r4,33044
8111b3cc:	21113184 	addi	r4,r4,17606
8111b3d0:	d9003515 	stw	r4,212(sp)
8111b3d4:	003b7606 	br	8111a1b0 <__reset+0xfb0fa1b0>
8111b3d8:	d8802917 	ldw	r2,164(sp)
8111b3dc:	00c00184 	movi	r3,6
8111b3e0:	1880012e 	bgeu	r3,r2,8111b3e8 <___vfprintf_internal_r+0x1ca8>
8111b3e4:	1805883a 	mov	r2,r3
8111b3e8:	d8802e15 	stw	r2,184(sp)
8111b3ec:	1000ef16 	blt	r2,zero,8111b7ac <___vfprintf_internal_r+0x206c>
8111b3f0:	04204534 	movhi	r16,33044
8111b3f4:	d8802a15 	stw	r2,168(sp)
8111b3f8:	dcc02d15 	stw	r19,180(sp)
8111b3fc:	d8002915 	stw	zero,164(sp)
8111b400:	d8003215 	stw	zero,200(sp)
8111b404:	84112304 	addi	r16,r16,17548
8111b408:	0039883a 	mov	fp,zero
8111b40c:	003aa206 	br	81119e98 <__reset+0xfb0f9e98>
8111b410:	0021883a 	mov	r16,zero
8111b414:	003e0706 	br	8111ac34 <__reset+0xfb0fac34>
8111b418:	d9002c17 	ldw	r4,176(sp)
8111b41c:	d9801e04 	addi	r6,sp,120
8111b420:	b80b883a 	mov	r5,r23
8111b424:	11259300 	call	81125930 <__sprint_r>
8111b428:	1039c91e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111b42c:	d8802617 	ldw	r2,152(sp)
8111b430:	d9403317 	ldw	r5,204(sp)
8111b434:	d8c02017 	ldw	r3,128(sp)
8111b438:	da000404 	addi	r8,sp,16
8111b43c:	2885c83a 	sub	r2,r5,r2
8111b440:	003dfb06 	br	8111ac30 <__reset+0xfb0fac30>
8111b444:	9080004c 	andi	r2,r18,1
8111b448:	103e8f1e 	bne	r2,zero,8111ae88 <__reset+0xfb0fae88>
8111b44c:	d8802117 	ldw	r2,132(sp)
8111b450:	003e9e06 	br	8111aecc <__reset+0xfb0faecc>
8111b454:	1025883a 	mov	r18,r2
8111b458:	0039883a 	mov	fp,zero
8111b45c:	00800084 	movi	r2,2
8111b460:	003fd306 	br	8111b3b0 <__reset+0xfb0fb3b0>
8111b464:	07000b44 	movi	fp,45
8111b468:	df002785 	stb	fp,158(sp)
8111b46c:	003a4006 	br	81119d70 <__reset+0xfb0f9d70>
8111b470:	00c00b44 	movi	r3,45
8111b474:	d8c02785 	stb	r3,158(sp)
8111b478:	d8802a15 	stw	r2,168(sp)
8111b47c:	dc802b17 	ldw	r18,172(sp)
8111b480:	d8002915 	stw	zero,164(sp)
8111b484:	07000b44 	movi	fp,45
8111b488:	003a8006 	br	81119e8c <__reset+0xfb0f9e8c>
8111b48c:	04204534 	movhi	r16,33044
8111b490:	84111804 	addi	r16,r16,17504
8111b494:	003f4706 	br	8111b1b4 <__reset+0xfb0fb1b4>
8111b498:	d8c02d17 	ldw	r3,180(sp)
8111b49c:	d9002f17 	ldw	r4,188(sp)
8111b4a0:	18800017 	ldw	r2,0(r3)
8111b4a4:	18c00104 	addi	r3,r3,4
8111b4a8:	d8c02d15 	stw	r3,180(sp)
8111b4ac:	11000015 	stw	r4,0(r2)
8111b4b0:	0038dd06 	br	81119828 <__reset+0xfb0f9828>
8111b4b4:	dd802617 	ldw	r22,152(sp)
8111b4b8:	00bfff44 	movi	r2,-3
8111b4bc:	b0801c16 	blt	r22,r2,8111b530 <___vfprintf_internal_r+0x1df0>
8111b4c0:	d9402917 	ldw	r5,164(sp)
8111b4c4:	2d801a16 	blt	r5,r22,8111b530 <___vfprintf_internal_r+0x1df0>
8111b4c8:	dd803215 	stw	r22,200(sp)
8111b4cc:	003e8906 	br	8111aef4 <__reset+0xfb0faef4>
8111b4d0:	01204534 	movhi	r4,33044
8111b4d4:	21112d84 	addi	r4,r4,17590
8111b4d8:	d9002b15 	stw	r4,172(sp)
8111b4dc:	003c9106 	br	8111a724 <__reset+0xfb0fa724>
8111b4e0:	e005883a 	mov	r2,fp
8111b4e4:	003e7906 	br	8111aecc <__reset+0xfb0faecc>
8111b4e8:	d9402917 	ldw	r5,164(sp)
8111b4ec:	df002783 	ldbu	fp,158(sp)
8111b4f0:	dcc02d15 	stw	r19,180(sp)
8111b4f4:	d9402a15 	stw	r5,168(sp)
8111b4f8:	d9402e15 	stw	r5,184(sp)
8111b4fc:	d8002915 	stw	zero,164(sp)
8111b500:	d8003215 	stw	zero,200(sp)
8111b504:	003a5d06 	br	81119e7c <__reset+0xfb0f9e7c>
8111b508:	9080004c 	andi	r2,r18,1
8111b50c:	0039883a 	mov	fp,zero
8111b510:	10000426 	beq	r2,zero,8111b524 <___vfprintf_internal_r+0x1de4>
8111b514:	00800c04 	movi	r2,48
8111b518:	dc001dc4 	addi	r16,sp,119
8111b51c:	d8801dc5 	stb	r2,119(sp)
8111b520:	003b8006 	br	8111a324 <__reset+0xfb0fa324>
8111b524:	d8002e15 	stw	zero,184(sp)
8111b528:	dc001e04 	addi	r16,sp,120
8111b52c:	003a4d06 	br	81119e64 <__reset+0xfb0f9e64>
8111b530:	8c7fff84 	addi	r17,r17,-2
8111b534:	b5bfffc4 	addi	r22,r22,-1
8111b538:	dd802615 	stw	r22,152(sp)
8111b53c:	dc4022c5 	stb	r17,139(sp)
8111b540:	b000bf16 	blt	r22,zero,8111b840 <___vfprintf_internal_r+0x2100>
8111b544:	00800ac4 	movi	r2,43
8111b548:	d8802305 	stb	r2,140(sp)
8111b54c:	00800244 	movi	r2,9
8111b550:	15807016 	blt	r2,r22,8111b714 <___vfprintf_internal_r+0x1fd4>
8111b554:	00800c04 	movi	r2,48
8111b558:	b5800c04 	addi	r22,r22,48
8111b55c:	d8802345 	stb	r2,141(sp)
8111b560:	dd802385 	stb	r22,142(sp)
8111b564:	d88023c4 	addi	r2,sp,143
8111b568:	df0022c4 	addi	fp,sp,139
8111b56c:	d8c03317 	ldw	r3,204(sp)
8111b570:	1739c83a 	sub	fp,r2,fp
8111b574:	d9003317 	ldw	r4,204(sp)
8111b578:	e0c7883a 	add	r3,fp,r3
8111b57c:	df003a15 	stw	fp,232(sp)
8111b580:	d8c02e15 	stw	r3,184(sp)
8111b584:	00800044 	movi	r2,1
8111b588:	1100b30e 	bge	r2,r4,8111b858 <___vfprintf_internal_r+0x2118>
8111b58c:	d8c02e17 	ldw	r3,184(sp)
8111b590:	18c00044 	addi	r3,r3,1
8111b594:	d8c02e15 	stw	r3,184(sp)
8111b598:	1805883a 	mov	r2,r3
8111b59c:	1800ac16 	blt	r3,zero,8111b850 <___vfprintf_internal_r+0x2110>
8111b5a0:	d8003215 	stw	zero,200(sp)
8111b5a4:	003e5d06 	br	8111af1c <__reset+0xfb0faf1c>
8111b5a8:	d9002c17 	ldw	r4,176(sp)
8111b5ac:	d9801e04 	addi	r6,sp,120
8111b5b0:	b80b883a 	mov	r5,r23
8111b5b4:	11259300 	call	81125930 <__sprint_r>
8111b5b8:	1039651e 	bne	r2,zero,81119b50 <__reset+0xfb0f9b50>
8111b5bc:	dc402617 	ldw	r17,152(sp)
8111b5c0:	d8c02017 	ldw	r3,128(sp)
8111b5c4:	d8801f17 	ldw	r2,124(sp)
8111b5c8:	da000404 	addi	r8,sp,16
8111b5cc:	003ed606 	br	8111b128 <__reset+0xfb0fb128>
8111b5d0:	582b883a 	mov	r21,r11
8111b5d4:	d8002915 	stw	zero,164(sp)
8111b5d8:	0038bd06 	br	811198d0 <__reset+0xfb0f98d0>
8111b5dc:	d8802917 	ldw	r2,164(sp)
8111b5e0:	103e071e 	bne	r2,zero,8111ae00 <__reset+0xfb0fae00>
8111b5e4:	dc002915 	stw	r16,164(sp)
8111b5e8:	003e0506 	br	8111ae00 <__reset+0xfb0fae00>
8111b5ec:	d9002917 	ldw	r4,164(sp)
8111b5f0:	20c00044 	addi	r3,r4,1
8111b5f4:	003e0f06 	br	8111ae34 <__reset+0xfb0fae34>
8111b5f8:	01400184 	movi	r5,6
8111b5fc:	d9402915 	stw	r5,164(sp)
8111b600:	003dff06 	br	8111ae00 <__reset+0xfb0fae00>
8111b604:	d8802104 	addi	r2,sp,132
8111b608:	d8800315 	stw	r2,12(sp)
8111b60c:	d8802504 	addi	r2,sp,148
8111b610:	d8800215 	stw	r2,8(sp)
8111b614:	d8802604 	addi	r2,sp,152
8111b618:	d8800115 	stw	r2,4(sp)
8111b61c:	d8802917 	ldw	r2,164(sp)
8111b620:	d9403617 	ldw	r5,216(sp)
8111b624:	d9002c17 	ldw	r4,176(sp)
8111b628:	d8800015 	stw	r2,0(sp)
8111b62c:	01c000c4 	movi	r7,3
8111b630:	980d883a 	mov	r6,r19
8111b634:	da003d15 	stw	r8,244(sp)
8111b638:	111d84c0 	call	8111d84c <_dtoa_r>
8111b63c:	d8c02917 	ldw	r3,164(sp)
8111b640:	da003d17 	ldw	r8,244(sp)
8111b644:	1021883a 	mov	r16,r2
8111b648:	10f9883a 	add	fp,r2,r3
8111b64c:	81000007 	ldb	r4,0(r16)
8111b650:	00800c04 	movi	r2,48
8111b654:	20805e26 	beq	r4,r2,8111b7d0 <___vfprintf_internal_r+0x2090>
8111b658:	d8c02617 	ldw	r3,152(sp)
8111b65c:	e0f9883a 	add	fp,fp,r3
8111b660:	003e0a06 	br	8111ae8c <__reset+0xfb0fae8c>
8111b664:	00c00b44 	movi	r3,45
8111b668:	24e0003c 	xorhi	r19,r4,32768
8111b66c:	d8c02a05 	stb	r3,168(sp)
8111b670:	003de906 	br	8111ae18 <__reset+0xfb0fae18>
8111b674:	d8c03217 	ldw	r3,200(sp)
8111b678:	00c07a0e 	bge	zero,r3,8111b864 <___vfprintf_internal_r+0x2124>
8111b67c:	00800044 	movi	r2,1
8111b680:	d9003317 	ldw	r4,204(sp)
8111b684:	1105883a 	add	r2,r2,r4
8111b688:	d8802e15 	stw	r2,184(sp)
8111b68c:	10004e16 	blt	r2,zero,8111b7c8 <___vfprintf_internal_r+0x2088>
8111b690:	044019c4 	movi	r17,103
8111b694:	003e2106 	br	8111af1c <__reset+0xfb0faf1c>
8111b698:	d9002917 	ldw	r4,164(sp)
8111b69c:	d8802104 	addi	r2,sp,132
8111b6a0:	d8800315 	stw	r2,12(sp)
8111b6a4:	d9000015 	stw	r4,0(sp)
8111b6a8:	d8802504 	addi	r2,sp,148
8111b6ac:	d9403617 	ldw	r5,216(sp)
8111b6b0:	d9002c17 	ldw	r4,176(sp)
8111b6b4:	d8800215 	stw	r2,8(sp)
8111b6b8:	d8802604 	addi	r2,sp,152
8111b6bc:	d8800115 	stw	r2,4(sp)
8111b6c0:	01c000c4 	movi	r7,3
8111b6c4:	980d883a 	mov	r6,r19
8111b6c8:	da003d15 	stw	r8,244(sp)
8111b6cc:	111d84c0 	call	8111d84c <_dtoa_r>
8111b6d0:	d8c02917 	ldw	r3,164(sp)
8111b6d4:	da003d17 	ldw	r8,244(sp)
8111b6d8:	1021883a 	mov	r16,r2
8111b6dc:	00801184 	movi	r2,70
8111b6e0:	80f9883a 	add	fp,r16,r3
8111b6e4:	88bfd926 	beq	r17,r2,8111b64c <__reset+0xfb0fb64c>
8111b6e8:	003de806 	br	8111ae8c <__reset+0xfb0fae8c>
8111b6ec:	d9002917 	ldw	r4,164(sp)
8111b6f0:	00c04d0e 	bge	zero,r3,8111b828 <___vfprintf_internal_r+0x20e8>
8111b6f4:	2000441e 	bne	r4,zero,8111b808 <___vfprintf_internal_r+0x20c8>
8111b6f8:	9480004c 	andi	r18,r18,1
8111b6fc:	9000421e 	bne	r18,zero,8111b808 <___vfprintf_internal_r+0x20c8>
8111b700:	1805883a 	mov	r2,r3
8111b704:	18007016 	blt	r3,zero,8111b8c8 <___vfprintf_internal_r+0x2188>
8111b708:	d8c03217 	ldw	r3,200(sp)
8111b70c:	d8c02e15 	stw	r3,184(sp)
8111b710:	003e0206 	br	8111af1c <__reset+0xfb0faf1c>
8111b714:	df0022c4 	addi	fp,sp,139
8111b718:	dc002915 	stw	r16,164(sp)
8111b71c:	4027883a 	mov	r19,r8
8111b720:	e021883a 	mov	r16,fp
8111b724:	b009883a 	mov	r4,r22
8111b728:	01400284 	movi	r5,10
8111b72c:	1128ca80 	call	81128ca8 <__modsi3>
8111b730:	10800c04 	addi	r2,r2,48
8111b734:	843fffc4 	addi	r16,r16,-1
8111b738:	b009883a 	mov	r4,r22
8111b73c:	01400284 	movi	r5,10
8111b740:	80800005 	stb	r2,0(r16)
8111b744:	1128c240 	call	81128c24 <__divsi3>
8111b748:	102d883a 	mov	r22,r2
8111b74c:	00800244 	movi	r2,9
8111b750:	15bff416 	blt	r2,r22,8111b724 <__reset+0xfb0fb724>
8111b754:	9811883a 	mov	r8,r19
8111b758:	b0800c04 	addi	r2,r22,48
8111b75c:	8027883a 	mov	r19,r16
8111b760:	997fffc4 	addi	r5,r19,-1
8111b764:	98bfffc5 	stb	r2,-1(r19)
8111b768:	dc002917 	ldw	r16,164(sp)
8111b76c:	2f006a2e 	bgeu	r5,fp,8111b918 <___vfprintf_internal_r+0x21d8>
8111b770:	d9c02384 	addi	r7,sp,142
8111b774:	3ccfc83a 	sub	r7,r7,r19
8111b778:	d9002344 	addi	r4,sp,141
8111b77c:	e1cf883a 	add	r7,fp,r7
8111b780:	00000106 	br	8111b788 <___vfprintf_internal_r+0x2048>
8111b784:	28800003 	ldbu	r2,0(r5)
8111b788:	20800005 	stb	r2,0(r4)
8111b78c:	21000044 	addi	r4,r4,1
8111b790:	29400044 	addi	r5,r5,1
8111b794:	393ffb1e 	bne	r7,r4,8111b784 <__reset+0xfb0fb784>
8111b798:	d8802304 	addi	r2,sp,140
8111b79c:	14c5c83a 	sub	r2,r2,r19
8111b7a0:	d8c02344 	addi	r3,sp,141
8111b7a4:	1885883a 	add	r2,r3,r2
8111b7a8:	003f7006 	br	8111b56c <__reset+0xfb0fb56c>
8111b7ac:	0005883a 	mov	r2,zero
8111b7b0:	003f0f06 	br	8111b3f0 <__reset+0xfb0fb3f0>
8111b7b4:	d8c03217 	ldw	r3,200(sp)
8111b7b8:	18c00044 	addi	r3,r3,1
8111b7bc:	d8c02e15 	stw	r3,184(sp)
8111b7c0:	1805883a 	mov	r2,r3
8111b7c4:	183fb20e 	bge	r3,zero,8111b690 <__reset+0xfb0fb690>
8111b7c8:	0005883a 	mov	r2,zero
8111b7cc:	003fb006 	br	8111b690 <__reset+0xfb0fb690>
8111b7d0:	d9003617 	ldw	r4,216(sp)
8111b7d4:	000d883a 	mov	r6,zero
8111b7d8:	000f883a 	mov	r7,zero
8111b7dc:	980b883a 	mov	r5,r19
8111b7e0:	d8c03c15 	stw	r3,240(sp)
8111b7e4:	da003d15 	stw	r8,244(sp)
8111b7e8:	112a1780 	call	8112a178 <__eqdf2>
8111b7ec:	d8c03c17 	ldw	r3,240(sp)
8111b7f0:	da003d17 	ldw	r8,244(sp)
8111b7f4:	103f9826 	beq	r2,zero,8111b658 <__reset+0xfb0fb658>
8111b7f8:	00800044 	movi	r2,1
8111b7fc:	10c7c83a 	sub	r3,r2,r3
8111b800:	d8c02615 	stw	r3,152(sp)
8111b804:	003f9506 	br	8111b65c <__reset+0xfb0fb65c>
8111b808:	d9002917 	ldw	r4,164(sp)
8111b80c:	d8c03217 	ldw	r3,200(sp)
8111b810:	20800044 	addi	r2,r4,1
8111b814:	1885883a 	add	r2,r3,r2
8111b818:	d8802e15 	stw	r2,184(sp)
8111b81c:	103dbf0e 	bge	r2,zero,8111af1c <__reset+0xfb0faf1c>
8111b820:	0005883a 	mov	r2,zero
8111b824:	003dbd06 	br	8111af1c <__reset+0xfb0faf1c>
8111b828:	2000211e 	bne	r4,zero,8111b8b0 <___vfprintf_internal_r+0x2170>
8111b82c:	9480004c 	andi	r18,r18,1
8111b830:	90001f1e 	bne	r18,zero,8111b8b0 <___vfprintf_internal_r+0x2170>
8111b834:	00800044 	movi	r2,1
8111b838:	d8802e15 	stw	r2,184(sp)
8111b83c:	003db706 	br	8111af1c <__reset+0xfb0faf1c>
8111b840:	00800b44 	movi	r2,45
8111b844:	05adc83a 	sub	r22,zero,r22
8111b848:	d8802305 	stb	r2,140(sp)
8111b84c:	003f3f06 	br	8111b54c <__reset+0xfb0fb54c>
8111b850:	0005883a 	mov	r2,zero
8111b854:	003f5206 	br	8111b5a0 <__reset+0xfb0fb5a0>
8111b858:	90a4703a 	and	r18,r18,r2
8111b85c:	903f4e26 	beq	r18,zero,8111b598 <__reset+0xfb0fb598>
8111b860:	003f4a06 	br	8111b58c <__reset+0xfb0fb58c>
8111b864:	00800084 	movi	r2,2
8111b868:	10c5c83a 	sub	r2,r2,r3
8111b86c:	003f8406 	br	8111b680 <__reset+0xfb0fb680>
8111b870:	d8802d17 	ldw	r2,180(sp)
8111b874:	d9002d17 	ldw	r4,180(sp)
8111b878:	ac400043 	ldbu	r17,1(r21)
8111b87c:	10800017 	ldw	r2,0(r2)
8111b880:	582b883a 	mov	r21,r11
8111b884:	d8802915 	stw	r2,164(sp)
8111b888:	20800104 	addi	r2,r4,4
8111b88c:	d9002917 	ldw	r4,164(sp)
8111b890:	d8802d15 	stw	r2,180(sp)
8111b894:	203e7a0e 	bge	r4,zero,8111b280 <__reset+0xfb0fb280>
8111b898:	8c403fcc 	andi	r17,r17,255
8111b89c:	00bfffc4 	movi	r2,-1
8111b8a0:	8c40201c 	xori	r17,r17,128
8111b8a4:	d8802915 	stw	r2,164(sp)
8111b8a8:	8c7fe004 	addi	r17,r17,-128
8111b8ac:	00380706 	br	811198cc <__reset+0xfb0f98cc>
8111b8b0:	d8c02917 	ldw	r3,164(sp)
8111b8b4:	18c00084 	addi	r3,r3,2
8111b8b8:	d8c02e15 	stw	r3,184(sp)
8111b8bc:	1805883a 	mov	r2,r3
8111b8c0:	183d960e 	bge	r3,zero,8111af1c <__reset+0xfb0faf1c>
8111b8c4:	003fd606 	br	8111b820 <__reset+0xfb0fb820>
8111b8c8:	0005883a 	mov	r2,zero
8111b8cc:	003f8e06 	br	8111b708 <__reset+0xfb0fb708>
8111b8d0:	9080004c 	andi	r2,r18,1
8111b8d4:	103f811e 	bne	r2,zero,8111b6dc <__reset+0xfb0fb6dc>
8111b8d8:	d8802117 	ldw	r2,132(sp)
8111b8dc:	1405c83a 	sub	r2,r2,r16
8111b8e0:	d8803315 	stw	r2,204(sp)
8111b8e4:	b47ef326 	beq	r22,r17,8111b4b4 <__reset+0xfb0fb4b4>
8111b8e8:	dd802617 	ldw	r22,152(sp)
8111b8ec:	003f1106 	br	8111b534 <__reset+0xfb0fb534>
8111b8f0:	d9c02785 	stb	r7,158(sp)
8111b8f4:	00390406 	br	81119d08 <__reset+0xfb0f9d08>
8111b8f8:	d9c02785 	stb	r7,158(sp)
8111b8fc:	0038d306 	br	81119c4c <__reset+0xfb0f9c4c>
8111b900:	d9c02785 	stb	r7,158(sp)
8111b904:	003a6106 	br	8111a28c <__reset+0xfb0fa28c>
8111b908:	d9c02785 	stb	r7,158(sp)
8111b90c:	003af806 	br	8111a4f0 <__reset+0xfb0fa4f0>
8111b910:	0005883a 	mov	r2,zero
8111b914:	003d7e06 	br	8111af10 <__reset+0xfb0faf10>
8111b918:	d8802344 	addi	r2,sp,141
8111b91c:	003f1306 	br	8111b56c <__reset+0xfb0fb56c>
8111b920:	d9c02785 	stb	r7,158(sp)
8111b924:	00392306 	br	81119db4 <__reset+0xfb0f9db4>
8111b928:	d9c02785 	stb	r7,158(sp)
8111b92c:	003aa906 	br	8111a3d4 <__reset+0xfb0fa3d4>
8111b930:	d9c02785 	stb	r7,158(sp)
8111b934:	003a3d06 	br	8111a22c <__reset+0xfb0fa22c>
8111b938:	d9c02785 	stb	r7,158(sp)
8111b93c:	003aca06 	br	8111a468 <__reset+0xfb0fa468>

8111b940 <__vfprintf_internal>:
8111b940:	00a04534 	movhi	r2,33044
8111b944:	109aed04 	addi	r2,r2,27572
8111b948:	300f883a 	mov	r7,r6
8111b94c:	280d883a 	mov	r6,r5
8111b950:	200b883a 	mov	r5,r4
8111b954:	11000017 	ldw	r4,0(r2)
8111b958:	11197401 	jmpi	81119740 <___vfprintf_internal_r>

8111b95c <__sbprintf>:
8111b95c:	defee204 	addi	sp,sp,-1144
8111b960:	de00012e 	bgeu	sp,et,8111b968 <__sbprintf+0xc>
8111b964:	003b68fa 	trap	3
8111b968:	2880030b 	ldhu	r2,12(r5)
8111b96c:	2ac01917 	ldw	r11,100(r5)
8111b970:	2a80038b 	ldhu	r10,14(r5)
8111b974:	2a400717 	ldw	r9,28(r5)
8111b978:	2a000917 	ldw	r8,36(r5)
8111b97c:	00c10004 	movi	r3,1024
8111b980:	dc011a15 	stw	r16,1128(sp)
8111b984:	10bfff4c 	andi	r2,r2,65533
8111b988:	2821883a 	mov	r16,r5
8111b98c:	d8cb883a 	add	r5,sp,r3
8111b990:	dc811c15 	stw	r18,1136(sp)
8111b994:	dc411b15 	stw	r17,1132(sp)
8111b998:	dfc11d15 	stw	ra,1140(sp)
8111b99c:	2025883a 	mov	r18,r4
8111b9a0:	d881030d 	sth	r2,1036(sp)
8111b9a4:	dac11915 	stw	r11,1124(sp)
8111b9a8:	da81038d 	sth	r10,1038(sp)
8111b9ac:	da410715 	stw	r9,1052(sp)
8111b9b0:	da010915 	stw	r8,1060(sp)
8111b9b4:	dec10015 	stw	sp,1024(sp)
8111b9b8:	dec10415 	stw	sp,1040(sp)
8111b9bc:	d8c10215 	stw	r3,1032(sp)
8111b9c0:	d8c10515 	stw	r3,1044(sp)
8111b9c4:	d8010615 	stw	zero,1048(sp)
8111b9c8:	11197400 	call	81119740 <___vfprintf_internal_r>
8111b9cc:	1023883a 	mov	r17,r2
8111b9d0:	10000416 	blt	r2,zero,8111b9e4 <__sbprintf+0x88>
8111b9d4:	d9410004 	addi	r5,sp,1024
8111b9d8:	9009883a 	mov	r4,r18
8111b9dc:	111f1000 	call	8111f100 <_fflush_r>
8111b9e0:	10000d1e 	bne	r2,zero,8111ba18 <__sbprintf+0xbc>
8111b9e4:	d881030b 	ldhu	r2,1036(sp)
8111b9e8:	1080100c 	andi	r2,r2,64
8111b9ec:	10000326 	beq	r2,zero,8111b9fc <__sbprintf+0xa0>
8111b9f0:	8080030b 	ldhu	r2,12(r16)
8111b9f4:	10801014 	ori	r2,r2,64
8111b9f8:	8080030d 	sth	r2,12(r16)
8111b9fc:	8805883a 	mov	r2,r17
8111ba00:	dfc11d17 	ldw	ra,1140(sp)
8111ba04:	dc811c17 	ldw	r18,1136(sp)
8111ba08:	dc411b17 	ldw	r17,1132(sp)
8111ba0c:	dc011a17 	ldw	r16,1128(sp)
8111ba10:	dec11e04 	addi	sp,sp,1144
8111ba14:	f800283a 	ret
8111ba18:	047fffc4 	movi	r17,-1
8111ba1c:	003ff106 	br	8111b9e4 <__reset+0xfb0fb9e4>

8111ba20 <__svfscanf_r>:
8111ba20:	deff4b04 	addi	sp,sp,-724
8111ba24:	de00012e 	bgeu	sp,et,8111ba2c <__svfscanf_r+0xc>
8111ba28:	003b68fa 	trap	3
8111ba2c:	2880030b 	ldhu	r2,12(r5)
8111ba30:	df00b315 	stw	fp,716(sp)
8111ba34:	dd80b115 	stw	r22,708(sp)
8111ba38:	dfc0b415 	stw	ra,720(sp)
8111ba3c:	ddc0b215 	stw	r23,712(sp)
8111ba40:	dd40b015 	stw	r21,704(sp)
8111ba44:	dd00af15 	stw	r20,700(sp)
8111ba48:	dcc0ae15 	stw	r19,696(sp)
8111ba4c:	dc80ad15 	stw	r18,692(sp)
8111ba50:	dc40ac15 	stw	r17,688(sp)
8111ba54:	dc00ab15 	stw	r16,684(sp)
8111ba58:	10c8000c 	andi	r3,r2,8192
8111ba5c:	d9c09c15 	stw	r7,624(sp)
8111ba60:	2839883a 	mov	fp,r5
8111ba64:	202d883a 	mov	r22,r4
8111ba68:	1800061e 	bne	r3,zero,8111ba84 <__svfscanf_r+0x64>
8111ba6c:	29001917 	ldw	r4,100(r5)
8111ba70:	00f7ffc4 	movi	r3,-8193
8111ba74:	10880014 	ori	r2,r2,8192
8111ba78:	20c6703a 	and	r3,r4,r3
8111ba7c:	2880030d 	sth	r2,12(r5)
8111ba80:	28c01915 	stw	r3,100(r5)
8111ba84:	30800003 	ldbu	r2,0(r6)
8111ba88:	0021883a 	mov	r16,zero
8111ba8c:	05e04534 	movhi	r23,33044
8111ba90:	d800a115 	stw	zero,644(sp)
8111ba94:	d8009e15 	stw	zero,632(sp)
8111ba98:	d800a015 	stw	zero,640(sp)
8111ba9c:	d8809b15 	stw	r2,620(sp)
8111baa0:	bddaeb04 	addi	r23,r23,27564
8111baa4:	8025883a 	mov	r18,r16
8111baa8:	35000044 	addi	r20,r6,1
8111baac:	10001e26 	beq	r2,zero,8111bb28 <__svfscanf_r+0x108>
8111bab0:	b9c00017 	ldw	r7,0(r23)
8111bab4:	3887883a 	add	r3,r7,r2
8111bab8:	18c00043 	ldbu	r3,1(r3)
8111babc:	18c0020c 	andi	r3,r3,8
8111bac0:	18001b26 	beq	r3,zero,8111bb30 <__svfscanf_r+0x110>
8111bac4:	e0800117 	ldw	r2,4(fp)
8111bac8:	00800e0e 	bge	zero,r2,8111bb04 <__svfscanf_r+0xe4>
8111bacc:	e0c00017 	ldw	r3,0(fp)
8111bad0:	b9000017 	ldw	r4,0(r23)
8111bad4:	18800003 	ldbu	r2,0(r3)
8111bad8:	2085883a 	add	r2,r4,r2
8111badc:	10800043 	ldbu	r2,1(r2)
8111bae0:	1080020c 	andi	r2,r2,8
8111bae4:	10000b26 	beq	r2,zero,8111bb14 <__svfscanf_r+0xf4>
8111bae8:	e0800117 	ldw	r2,4(fp)
8111baec:	18c00044 	addi	r3,r3,1
8111baf0:	e0c00015 	stw	r3,0(fp)
8111baf4:	10bfffc4 	addi	r2,r2,-1
8111baf8:	e0800115 	stw	r2,4(fp)
8111bafc:	94800044 	addi	r18,r18,1
8111bb00:	00bff216 	blt	zero,r2,8111bacc <__reset+0xfb0fbacc>
8111bb04:	e00b883a 	mov	r5,fp
8111bb08:	b009883a 	mov	r4,r22
8111bb0c:	1116d000 	call	81116d00 <__srefill_r>
8111bb10:	103fee26 	beq	r2,zero,8111bacc <__reset+0xfb0fbacc>
8111bb14:	a00d883a 	mov	r6,r20
8111bb18:	30800003 	ldbu	r2,0(r6)
8111bb1c:	35000044 	addi	r20,r6,1
8111bb20:	d8809b15 	stw	r2,620(sp)
8111bb24:	103fe21e 	bne	r2,zero,8111bab0 <__reset+0xfb0fbab0>
8111bb28:	d880a017 	ldw	r2,640(sp)
8111bb2c:	00009906 	br	8111bd94 <__svfscanf_r+0x374>
8111bb30:	00c00944 	movi	r3,37
8111bb34:	10c0881e 	bne	r2,r3,8111bd58 <__svfscanf_r+0x338>
8111bb38:	30c00043 	ldbu	r3,1(r6)
8111bb3c:	0023883a 	mov	r17,zero
8111bb40:	0027883a 	mov	r19,zero
8111bb44:	01001e04 	movi	r4,120
8111bb48:	01401b04 	movi	r5,108
8111bb4c:	a1800044 	addi	r6,r20,1
8111bb50:	20c0a236 	bltu	r4,r3,8111bddc <__svfscanf_r+0x3bc>
8111bb54:	180490ba 	slli	r2,r3,2
8111bb58:	022044b4 	movhi	r8,33042
8111bb5c:	422edb04 	addi	r8,r8,-17556
8111bb60:	1205883a 	add	r2,r2,r8
8111bb64:	10800017 	ldw	r2,0(r2)
8111bb68:	1000683a 	jmp	r2
8111bb6c:	8111bd90 	cmplti	r4,r16,18166
8111bb70:	8111bddc 	xori	r4,r16,18167
8111bb74:	8111bddc 	xori	r4,r16,18167
8111bb78:	8111bddc 	xori	r4,r16,18167
8111bb7c:	8111bddc 	xori	r4,r16,18167
8111bb80:	8111bddc 	xori	r4,r16,18167
8111bb84:	8111bddc 	xori	r4,r16,18167
8111bb88:	8111bddc 	xori	r4,r16,18167
8111bb8c:	8111bddc 	xori	r4,r16,18167
8111bb90:	8111bddc 	xori	r4,r16,18167
8111bb94:	8111bddc 	xori	r4,r16,18167
8111bb98:	8111bddc 	xori	r4,r16,18167
8111bb9c:	8111bddc 	xori	r4,r16,18167
8111bba0:	8111bddc 	xori	r4,r16,18167
8111bba4:	8111bddc 	xori	r4,r16,18167
8111bba8:	8111bddc 	xori	r4,r16,18167
8111bbac:	8111bddc 	xori	r4,r16,18167
8111bbb0:	8111bddc 	xori	r4,r16,18167
8111bbb4:	8111bddc 	xori	r4,r16,18167
8111bbb8:	8111bddc 	xori	r4,r16,18167
8111bbbc:	8111bddc 	xori	r4,r16,18167
8111bbc0:	8111bddc 	xori	r4,r16,18167
8111bbc4:	8111bddc 	xori	r4,r16,18167
8111bbc8:	8111bddc 	xori	r4,r16,18167
8111bbcc:	8111bddc 	xori	r4,r16,18167
8111bbd0:	8111bddc 	xori	r4,r16,18167
8111bbd4:	8111bddc 	xori	r4,r16,18167
8111bbd8:	8111bddc 	xori	r4,r16,18167
8111bbdc:	8111bddc 	xori	r4,r16,18167
8111bbe0:	8111bddc 	xori	r4,r16,18167
8111bbe4:	8111bddc 	xori	r4,r16,18167
8111bbe8:	8111bddc 	xori	r4,r16,18167
8111bbec:	8111bddc 	xori	r4,r16,18167
8111bbf0:	8111bddc 	xori	r4,r16,18167
8111bbf4:	8111bddc 	xori	r4,r16,18167
8111bbf8:	8111bddc 	xori	r4,r16,18167
8111bbfc:	8111bddc 	xori	r4,r16,18167
8111bc00:	8111bd50 	cmplti	r4,r16,18165
8111bc04:	8111bddc 	xori	r4,r16,18167
8111bc08:	8111bddc 	xori	r4,r16,18167
8111bc0c:	8111bddc 	xori	r4,r16,18167
8111bc10:	8111bddc 	xori	r4,r16,18167
8111bc14:	8111bdc4 	addi	r4,r16,18167
8111bc18:	8111bddc 	xori	r4,r16,18167
8111bc1c:	8111bddc 	xori	r4,r16,18167
8111bc20:	8111bddc 	xori	r4,r16,18167
8111bc24:	8111bddc 	xori	r4,r16,18167
8111bc28:	8111bddc 	xori	r4,r16,18167
8111bc2c:	8111bef8 	rdprs	r4,r16,18171
8111bc30:	8111bef8 	rdprs	r4,r16,18171
8111bc34:	8111bef8 	rdprs	r4,r16,18171
8111bc38:	8111bef8 	rdprs	r4,r16,18171
8111bc3c:	8111bef8 	rdprs	r4,r16,18171
8111bc40:	8111bef8 	rdprs	r4,r16,18171
8111bc44:	8111bef8 	rdprs	r4,r16,18171
8111bc48:	8111bef8 	rdprs	r4,r16,18171
8111bc4c:	8111bef8 	rdprs	r4,r16,18171
8111bc50:	8111bef8 	rdprs	r4,r16,18171
8111bc54:	8111bddc 	xori	r4,r16,18167
8111bc58:	8111bddc 	xori	r4,r16,18167
8111bc5c:	8111bddc 	xori	r4,r16,18167
8111bc60:	8111bddc 	xori	r4,r16,18167
8111bc64:	8111bddc 	xori	r4,r16,18167
8111bc68:	8111bddc 	xori	r4,r16,18167
8111bc6c:	8111bddc 	xori	r4,r16,18167
8111bc70:	8111bddc 	xori	r4,r16,18167
8111bc74:	8111bddc 	xori	r4,r16,18167
8111bc78:	8111bddc 	xori	r4,r16,18167
8111bc7c:	8111becc 	andi	r4,r16,18171
8111bc80:	8111bf7c 	xorhi	r4,r16,18173
8111bc84:	8111bddc 	xori	r4,r16,18167
8111bc88:	8111bf7c 	xorhi	r4,r16,18173
8111bc8c:	8111bddc 	xori	r4,r16,18167
8111bc90:	8111bddc 	xori	r4,r16,18167
8111bc94:	8111bddc 	xori	r4,r16,18167
8111bc98:	8111bddc 	xori	r4,r16,18167
8111bc9c:	8111bf68 	cmpgeui	r4,r16,18173
8111bca0:	8111bddc 	xori	r4,r16,18167
8111bca4:	8111bddc 	xori	r4,r16,18167
8111bca8:	8111bf3c 	xorhi	r4,r16,18172
8111bcac:	8111bddc 	xori	r4,r16,18167
8111bcb0:	8111bddc 	xori	r4,r16,18167
8111bcb4:	8111bddc 	xori	r4,r16,18167
8111bcb8:	8111bddc 	xori	r4,r16,18167
8111bcbc:	8111bddc 	xori	r4,r16,18167
8111bcc0:	8111bddc 	xori	r4,r16,18167
8111bcc4:	8111bddc 	xori	r4,r16,18167
8111bcc8:	8111bddc 	xori	r4,r16,18167
8111bccc:	8111bf14 	ori	r4,r16,18172
8111bcd0:	8111bddc 	xori	r4,r16,18167
8111bcd4:	8111bddc 	xori	r4,r16,18167
8111bcd8:	8111c0b0 	cmpltui	r4,r16,18178
8111bcdc:	8111bddc 	xori	r4,r16,18167
8111bce0:	8111bddc 	xori	r4,r16,18167
8111bce4:	8111bddc 	xori	r4,r16,18167
8111bce8:	8111bddc 	xori	r4,r16,18167
8111bcec:	8111bddc 	xori	r4,r16,18167
8111bcf0:	8111bddc 	xori	r4,r16,18167
8111bcf4:	8111bddc 	xori	r4,r16,18167
8111bcf8:	8111c034 	orhi	r4,r16,18176
8111bcfc:	8111c00c 	andi	r4,r16,18176
8111bd00:	8111bf7c 	xorhi	r4,r16,18173
8111bd04:	8111bf7c 	xorhi	r4,r16,18173
8111bd08:	8111bf7c 	xorhi	r4,r16,18173
8111bd0c:	8111bff8 	rdprs	r4,r16,18175
8111bd10:	8111c13c 	xorhi	r4,r16,18180
8111bd14:	8111bddc 	xori	r4,r16,18167
8111bd18:	8111bddc 	xori	r4,r16,18167
8111bd1c:	8111bfe4 	muli	r4,r16,18175
8111bd20:	8111bddc 	xori	r4,r16,18167
8111bd24:	8111bfb4 	orhi	r4,r16,18174
8111bd28:	8111bf90 	cmplti	r4,r16,18174
8111bd2c:	8111bea0 	cmpeqi	r4,r16,18170
8111bd30:	8111bddc 	xori	r4,r16,18167
8111bd34:	8111bddc 	xori	r4,r16,18167
8111bd38:	8111be8c 	andi	r4,r16,18170
8111bd3c:	8111bddc 	xori	r4,r16,18167
8111bd40:	8111be14 	ori	r4,r16,18168
8111bd44:	8111bddc 	xori	r4,r16,18167
8111bd48:	8111bddc 	xori	r4,r16,18167
8111bd4c:	8111bf14 	ori	r4,r16,18172
8111bd50:	d9809d15 	stw	r6,628(sp)
8111bd54:	3029883a 	mov	r20,r6
8111bd58:	e0800117 	ldw	r2,4(fp)
8111bd5c:	0081aa0e 	bge	zero,r2,8111c408 <__svfscanf_r+0x9e8>
8111bd60:	e0800017 	ldw	r2,0(fp)
8111bd64:	a0ffffc3 	ldbu	r3,-1(r20)
8111bd68:	11000003 	ldbu	r4,0(r2)
8111bd6c:	20ff6e1e 	bne	r4,r3,8111bb28 <__reset+0xfb0fbb28>
8111bd70:	e0c00117 	ldw	r3,4(fp)
8111bd74:	10800044 	addi	r2,r2,1
8111bd78:	e0800015 	stw	r2,0(fp)
8111bd7c:	18bfffc4 	addi	r2,r3,-1
8111bd80:	e0800115 	stw	r2,4(fp)
8111bd84:	94800044 	addi	r18,r18,1
8111bd88:	a00d883a 	mov	r6,r20
8111bd8c:	003f6206 	br	8111bb18 <__reset+0xfb0fbb18>
8111bd90:	00bfffc4 	movi	r2,-1
8111bd94:	dfc0b417 	ldw	ra,720(sp)
8111bd98:	df00b317 	ldw	fp,716(sp)
8111bd9c:	ddc0b217 	ldw	r23,712(sp)
8111bda0:	dd80b117 	ldw	r22,708(sp)
8111bda4:	dd40b017 	ldw	r21,704(sp)
8111bda8:	dd00af17 	ldw	r20,700(sp)
8111bdac:	dcc0ae17 	ldw	r19,696(sp)
8111bdb0:	dc80ad17 	ldw	r18,692(sp)
8111bdb4:	dc40ac17 	ldw	r17,688(sp)
8111bdb8:	dc00ab17 	ldw	r16,684(sp)
8111bdbc:	dec0b504 	addi	sp,sp,724
8111bdc0:	f800283a 	ret
8111bdc4:	a0800043 	ldbu	r2,1(r20)
8111bdc8:	3029883a 	mov	r20,r6
8111bdcc:	8c400414 	ori	r17,r17,16
8111bdd0:	10c03fcc 	andi	r3,r2,255
8111bdd4:	a1800044 	addi	r6,r20,1
8111bdd8:	20ff5e2e 	bgeu	r4,r3,8111bb54 <__reset+0xfb0fbb54>
8111bddc:	38c7883a 	add	r3,r7,r3
8111bde0:	18800043 	ldbu	r2,1(r3)
8111bde4:	d9809d15 	stw	r6,628(sp)
8111bde8:	00c00044 	movi	r3,1
8111bdec:	108000cc 	andi	r2,r2,3
8111bdf0:	10c18f26 	beq	r2,r3,8111c430 <__svfscanf_r+0xa10>
8111bdf4:	e0800117 	ldw	r2,4(fp)
8111bdf8:	00808716 	blt	zero,r2,8111c018 <__svfscanf_r+0x5f8>
8111bdfc:	e00b883a 	mov	r5,fp
8111be00:	b009883a 	mov	r4,r22
8111be04:	1116d000 	call	81116d00 <__srefill_r>
8111be08:	1001431e 	bne	r2,zero,8111c318 <__svfscanf_r+0x8f8>
8111be0c:	b9c00017 	ldw	r7,0(r23)
8111be10:	00008106 	br	8111c018 <__svfscanf_r+0x5f8>
8111be14:	e0800117 	ldw	r2,4(fp)
8111be18:	d9809d15 	stw	r6,628(sp)
8111be1c:	0081a30e 	bge	zero,r2,8111c4ac <__svfscanf_r+0xa8c>
8111be20:	00a044b4 	movhi	r2,33042
8111be24:	108f0c04 	addi	r2,r2,15408
8111be28:	02000284 	movi	r8,10
8111be2c:	d880a115 	stw	r2,644(sp)
8111be30:	da009e15 	stw	r8,632(sp)
8111be34:	050000c4 	movi	r20,3
8111be38:	e0c00017 	ldw	r3,0(fp)
8111be3c:	00000206 	br	8111be48 <__svfscanf_r+0x428>
8111be40:	18c00044 	addi	r3,r3,1
8111be44:	e0c00015 	stw	r3,0(fp)
8111be48:	19000003 	ldbu	r4,0(r3)
8111be4c:	20803fcc 	andi	r2,r4,255
8111be50:	3885883a 	add	r2,r7,r2
8111be54:	10800043 	ldbu	r2,1(r2)
8111be58:	1140020c 	andi	r5,r2,8
8111be5c:	2801ab26 	beq	r5,zero,8111c50c <__svfscanf_r+0xaec>
8111be60:	e0800117 	ldw	r2,4(fp)
8111be64:	94800044 	addi	r18,r18,1
8111be68:	10bfffc4 	addi	r2,r2,-1
8111be6c:	e0800115 	stw	r2,4(fp)
8111be70:	00bff316 	blt	zero,r2,8111be40 <__reset+0xfb0fbe40>
8111be74:	e00b883a 	mov	r5,fp
8111be78:	b009883a 	mov	r4,r22
8111be7c:	1116d000 	call	81116d00 <__srefill_r>
8111be80:	1001251e 	bne	r2,zero,8111c318 <__svfscanf_r+0x8f8>
8111be84:	b9c00017 	ldw	r7,0(r23)
8111be88:	003feb06 	br	8111be38 <__reset+0xfb0fbe38>
8111be8c:	e0800117 	ldw	r2,4(fp)
8111be90:	d9809d15 	stw	r6,628(sp)
8111be94:	00818b0e 	bge	zero,r2,8111c4c4 <__svfscanf_r+0xaa4>
8111be98:	05000084 	movi	r20,2
8111be9c:	003fe606 	br	8111be38 <__reset+0xfb0fbe38>
8111bea0:	e0800117 	ldw	r2,4(fp)
8111bea4:	d9809d15 	stw	r6,628(sp)
8111bea8:	8c408814 	ori	r17,r17,544
8111beac:	00801d0e 	bge	zero,r2,8111bf24 <__svfscanf_r+0x504>
8111beb0:	00a044b4 	movhi	r2,33042
8111beb4:	108f0c04 	addi	r2,r2,15408
8111beb8:	02000404 	movi	r8,16
8111bebc:	d880a115 	stw	r2,644(sp)
8111bec0:	da009e15 	stw	r8,632(sp)
8111bec4:	050000c4 	movi	r20,3
8111bec8:	003fdb06 	br	8111be38 <__reset+0xfb0fbe38>
8111becc:	e0800117 	ldw	r2,4(fp)
8111bed0:	d9809d15 	stw	r6,628(sp)
8111bed4:	8c400054 	ori	r17,r17,1
8111bed8:	00bfc80e 	bge	zero,r2,8111bdfc <__reset+0xfb0fbdfc>
8111bedc:	00e04474 	movhi	r3,33041
8111bee0:	18dcc104 	addi	r3,r3,29444
8111bee4:	02000284 	movi	r8,10
8111bee8:	d8c0a115 	stw	r3,644(sp)
8111beec:	da009e15 	stw	r8,632(sp)
8111bef0:	050000c4 	movi	r20,3
8111bef4:	003fd006 	br	8111be38 <__reset+0xfb0fbe38>
8111bef8:	9cc002a4 	muli	r19,r19,10
8111befc:	a0800043 	ldbu	r2,1(r20)
8111bf00:	3029883a 	mov	r20,r6
8111bf04:	98e7883a 	add	r19,r19,r3
8111bf08:	9cfff404 	addi	r19,r19,-48
8111bf0c:	10c03fcc 	andi	r3,r2,255
8111bf10:	003f0e06 	br	8111bb4c <__reset+0xfb0fbb4c>
8111bf14:	e0800117 	ldw	r2,4(fp)
8111bf18:	d9809d15 	stw	r6,628(sp)
8111bf1c:	8c408014 	ori	r17,r17,512
8111bf20:	00bfe316 	blt	zero,r2,8111beb0 <__reset+0xfb0fbeb0>
8111bf24:	e00b883a 	mov	r5,fp
8111bf28:	b009883a 	mov	r4,r22
8111bf2c:	1116d000 	call	81116d00 <__srefill_r>
8111bf30:	1000f91e 	bne	r2,zero,8111c318 <__svfscanf_r+0x8f8>
8111bf34:	b9c00017 	ldw	r7,0(r23)
8111bf38:	003fdd06 	br	8111beb0 <__reset+0xfb0fbeb0>
8111bf3c:	e0800117 	ldw	r2,4(fp)
8111bf40:	d9809d15 	stw	r6,628(sp)
8111bf44:	8c400054 	ori	r17,r17,1
8111bf48:	0080140e 	bge	zero,r2,8111bf9c <__svfscanf_r+0x57c>
8111bf4c:	00a044b4 	movhi	r2,33042
8111bf50:	108f0c04 	addi	r2,r2,15408
8111bf54:	02000204 	movi	r8,8
8111bf58:	d880a115 	stw	r2,644(sp)
8111bf5c:	da009e15 	stw	r8,632(sp)
8111bf60:	050000c4 	movi	r20,3
8111bf64:	003fb406 	br	8111be38 <__reset+0xfb0fbe38>
8111bf68:	a0800043 	ldbu	r2,1(r20)
8111bf6c:	8c400094 	ori	r17,r17,2
8111bf70:	3029883a 	mov	r20,r6
8111bf74:	10c03fcc 	andi	r3,r2,255
8111bf78:	003ef406 	br	8111bb4c <__reset+0xfb0fbb4c>
8111bf7c:	e0800117 	ldw	r2,4(fp)
8111bf80:	d9809d15 	stw	r6,628(sp)
8111bf84:	0081420e 	bge	zero,r2,8111c490 <__svfscanf_r+0xa70>
8111bf88:	05000104 	movi	r20,4
8111bf8c:	003faa06 	br	8111be38 <__reset+0xfb0fbe38>
8111bf90:	e0800117 	ldw	r2,4(fp)
8111bf94:	d9809d15 	stw	r6,628(sp)
8111bf98:	00bfec16 	blt	zero,r2,8111bf4c <__reset+0xfb0fbf4c>
8111bf9c:	e00b883a 	mov	r5,fp
8111bfa0:	b009883a 	mov	r4,r22
8111bfa4:	1116d000 	call	81116d00 <__srefill_r>
8111bfa8:	1000db1e 	bne	r2,zero,8111c318 <__svfscanf_r+0x8f8>
8111bfac:	b9c00017 	ldw	r7,0(r23)
8111bfb0:	003fe606 	br	8111bf4c <__reset+0xfb0fbf4c>
8111bfb4:	d9809d15 	stw	r6,628(sp)
8111bfb8:	8880040c 	andi	r2,r17,16
8111bfbc:	10009c1e 	bne	r2,zero,8111c230 <__svfscanf_r+0x810>
8111bfc0:	8880010c 	andi	r2,r17,4
8111bfc4:	10011e26 	beq	r2,zero,8111c440 <__svfscanf_r+0xa20>
8111bfc8:	da009c17 	ldw	r8,624(sp)
8111bfcc:	3029883a 	mov	r20,r6
8111bfd0:	40800017 	ldw	r2,0(r8)
8111bfd4:	42000104 	addi	r8,r8,4
8111bfd8:	da009c15 	stw	r8,624(sp)
8111bfdc:	1480000d 	sth	r18,0(r2)
8111bfe0:	003ecc06 	br	8111bb14 <__reset+0xfb0fbb14>
8111bfe4:	a0c00043 	ldbu	r3,1(r20)
8111bfe8:	19410c26 	beq	r3,r5,8111c41c <__svfscanf_r+0x9fc>
8111bfec:	8c400054 	ori	r17,r17,1
8111bff0:	3029883a 	mov	r20,r6
8111bff4:	003ed506 	br	8111bb4c <__reset+0xfb0fbb4c>
8111bff8:	a0800043 	ldbu	r2,1(r20)
8111bffc:	8c400114 	ori	r17,r17,4
8111c000:	3029883a 	mov	r20,r6
8111c004:	10c03fcc 	andi	r3,r2,255
8111c008:	003ed006 	br	8111bb4c <__reset+0xfb0fbb4c>
8111c00c:	e0800117 	ldw	r2,4(fp)
8111c010:	d9809d15 	stw	r6,628(sp)
8111c014:	00bf790e 	bge	zero,r2,8111bdfc <__reset+0xfb0fbdfc>
8111c018:	00a04474 	movhi	r2,33041
8111c01c:	109cc104 	addi	r2,r2,29444
8111c020:	02000284 	movi	r8,10
8111c024:	d880a115 	stw	r2,644(sp)
8111c028:	da009e15 	stw	r8,632(sp)
8111c02c:	050000c4 	movi	r20,3
8111c030:	003f8106 	br	8111be38 <__reset+0xfb0fbe38>
8111c034:	e0800117 	ldw	r2,4(fp)
8111c038:	d9809d15 	stw	r6,628(sp)
8111c03c:	0080c40e 	bge	zero,r2,8111c350 <__svfscanf_r+0x930>
8111c040:	9800011e 	bne	r19,zero,8111c048 <__svfscanf_r+0x628>
8111c044:	04c00044 	movi	r19,1
8111c048:	8880004c 	andi	r2,r17,1
8111c04c:	1000441e 	bne	r2,zero,8111c160 <__svfscanf_r+0x740>
8111c050:	8c40040c 	andi	r17,r17,16
8111c054:	8800da26 	beq	r17,zero,8111c3c0 <__svfscanf_r+0x9a0>
8111c058:	0021883a 	mov	r16,zero
8111c05c:	00000806 	br	8111c080 <__svfscanf_r+0x660>
8111c060:	1887883a 	add	r3,r3,r2
8111c064:	e00b883a 	mov	r5,fp
8111c068:	b009883a 	mov	r4,r22
8111c06c:	e0c00015 	stw	r3,0(fp)
8111c070:	80a1883a 	add	r16,r16,r2
8111c074:	98a7c83a 	sub	r19,r19,r2
8111c078:	1116d000 	call	81116d00 <__srefill_r>
8111c07c:	1000ca1e 	bne	r2,zero,8111c3a8 <__svfscanf_r+0x988>
8111c080:	e0800117 	ldw	r2,4(fp)
8111c084:	e0c00017 	ldw	r3,0(fp)
8111c088:	14fff516 	blt	r2,r19,8111c060 <__reset+0xfb0fc060>
8111c08c:	14c5c83a 	sub	r2,r2,r19
8111c090:	1cd5883a 	add	r10,r3,r19
8111c094:	84e1883a 	add	r16,r16,r19
8111c098:	e0800115 	stw	r2,4(fp)
8111c09c:	e2800015 	stw	r10,0(fp)
8111c0a0:	dd009d17 	ldw	r20,628(sp)
8111c0a4:	9425883a 	add	r18,r18,r16
8111c0a8:	a00d883a 	mov	r6,r20
8111c0ac:	003e9a06 	br	8111bb18 <__reset+0xfb0fbb18>
8111c0b0:	300b883a 	mov	r5,r6
8111c0b4:	d9005884 	addi	r4,sp,354
8111c0b8:	d9809d15 	stw	r6,628(sp)
8111c0bc:	11220080 	call	81122008 <__sccl>
8111c0c0:	1029883a 	mov	r20,r2
8111c0c4:	e0800117 	ldw	r2,4(fp)
8111c0c8:	0081050e 	bge	zero,r2,8111c4e0 <__svfscanf_r+0xac0>
8111c0cc:	e1000017 	ldw	r4,0(fp)
8111c0d0:	20800003 	ldbu	r2,0(r4)
8111c0d4:	98005926 	beq	r19,zero,8111c23c <__svfscanf_r+0x81c>
8111c0d8:	8c40040c 	andi	r17,r17,16
8111c0dc:	88005a26 	beq	r17,zero,8111c248 <__svfscanf_r+0x828>
8111c0e0:	9823883a 	mov	r17,r19
8111c0e4:	0021883a 	mov	r16,zero
8111c0e8:	00000106 	br	8111c0f0 <__svfscanf_r+0x6d0>
8111c0ec:	20800003 	ldbu	r2,0(r4)
8111c0f0:	10803fcc 	andi	r2,r2,255
8111c0f4:	d8c05884 	addi	r3,sp,354
8111c0f8:	1885883a 	add	r2,r3,r2
8111c0fc:	10800007 	ldb	r2,0(r2)
8111c100:	1000ad26 	beq	r2,zero,8111c3b8 <__svfscanf_r+0x998>
8111c104:	e0800117 	ldw	r2,4(fp)
8111c108:	21000044 	addi	r4,r4,1
8111c10c:	84000044 	addi	r16,r16,1
8111c110:	10bfffc4 	addi	r2,r2,-1
8111c114:	e0800115 	stw	r2,4(fp)
8111c118:	e1000015 	stw	r4,0(fp)
8111c11c:	84c0a026 	beq	r16,r19,8111c3a0 <__svfscanf_r+0x980>
8111c120:	00bff216 	blt	zero,r2,8111c0ec <__reset+0xfb0fc0ec>
8111c124:	e00b883a 	mov	r5,fp
8111c128:	b009883a 	mov	r4,r22
8111c12c:	1116d000 	call	81116d00 <__srefill_r>
8111c130:	10009a1e 	bne	r2,zero,8111c39c <__svfscanf_r+0x97c>
8111c134:	e1000017 	ldw	r4,0(fp)
8111c138:	003fec06 	br	8111c0ec <__reset+0xfb0fc0ec>
8111c13c:	e0800117 	ldw	r2,4(fp)
8111c140:	d9809d15 	stw	r6,628(sp)
8111c144:	0080eb0e 	bge	zero,r2,8111c4f4 <__svfscanf_r+0xad4>
8111c148:	00a04474 	movhi	r2,33041
8111c14c:	109cc104 	addi	r2,r2,29444
8111c150:	d880a115 	stw	r2,644(sp)
8111c154:	d8009e15 	stw	zero,632(sp)
8111c158:	050000c4 	movi	r20,3
8111c15c:	003f3606 	br	8111be38 <__reset+0xfb0fbe38>
8111c160:	dd409904 	addi	r21,sp,612
8111c164:	8c40040c 	andi	r17,r17,16
8111c168:	01800204 	movi	r6,8
8111c16c:	000b883a 	mov	r5,zero
8111c170:	a809883a 	mov	r4,r21
8111c174:	dc409f15 	stw	r17,636(sp)
8111c178:	11168840 	call	81116884 <memset>
8111c17c:	dc409f17 	ldw	r17,636(sp)
8111c180:	88006e26 	beq	r17,zero,8111c33c <__svfscanf_r+0x91c>
8111c184:	0029883a 	mov	r20,zero
8111c188:	0023883a 	mov	r17,zero
8111c18c:	11204240 	call	81120424 <__locale_mb_cur_max>
8111c190:	14406126 	beq	r2,r17,8111c318 <__svfscanf_r+0x8f8>
8111c194:	e0800017 	ldw	r2,0(fp)
8111c198:	e0c00117 	ldw	r3,4(fp)
8111c19c:	d9000104 	addi	r4,sp,4
8111c1a0:	12000003 	ldbu	r8,0(r2)
8111c1a4:	18ffffc4 	addi	r3,r3,-1
8111c1a8:	10800044 	addi	r2,r2,1
8111c1ac:	e0c00115 	stw	r3,4(fp)
8111c1b0:	e0800015 	stw	r2,0(fp)
8111c1b4:	8c000044 	addi	r16,r17,1
8111c1b8:	dd400015 	stw	r21,0(sp)
8111c1bc:	2463883a 	add	r17,r4,r17
8111c1c0:	200d883a 	mov	r6,r4
8111c1c4:	a00b883a 	mov	r5,r20
8111c1c8:	800f883a 	mov	r7,r16
8111c1cc:	b009883a 	mov	r4,r22
8111c1d0:	8a000005 	stb	r8,0(r17)
8111c1d4:	11204e00 	call	811204e0 <_mbrtowc_r>
8111c1d8:	017fffc4 	movi	r5,-1
8111c1dc:	11404e26 	beq	r2,r5,8111c318 <__svfscanf_r+0x8f8>
8111c1e0:	1000601e 	bne	r2,zero,8111c364 <__svfscanf_r+0x944>
8111c1e4:	da009f17 	ldw	r8,636(sp)
8111c1e8:	4000641e 	bne	r8,zero,8111c37c <__svfscanf_r+0x95c>
8111c1ec:	a0000015 	stw	zero,0(r20)
8111c1f0:	9425883a 	add	r18,r18,r16
8111c1f4:	9967883a 	add	r19,r19,r5
8111c1f8:	a5000104 	addi	r20,r20,4
8111c1fc:	e0800117 	ldw	r2,4(fp)
8111c200:	0023883a 	mov	r17,zero
8111c204:	00804b16 	blt	zero,r2,8111c334 <__svfscanf_r+0x914>
8111c208:	e00b883a 	mov	r5,fp
8111c20c:	b009883a 	mov	r4,r22
8111c210:	1116d000 	call	81116d00 <__srefill_r>
8111c214:	10004726 	beq	r2,zero,8111c334 <__svfscanf_r+0x914>
8111c218:	88003f1e 	bne	r17,zero,8111c318 <__svfscanf_r+0x8f8>
8111c21c:	d8c09f17 	ldw	r3,636(sp)
8111c220:	1800031e 	bne	r3,zero,8111c230 <__svfscanf_r+0x810>
8111c224:	da00a017 	ldw	r8,640(sp)
8111c228:	42000044 	addi	r8,r8,1
8111c22c:	da00a015 	stw	r8,640(sp)
8111c230:	dd009d17 	ldw	r20,628(sp)
8111c234:	a00d883a 	mov	r6,r20
8111c238:	003e3706 	br	8111bb18 <__reset+0xfb0fbb18>
8111c23c:	8c40040c 	andi	r17,r17,16
8111c240:	04ffffc4 	movi	r19,-1
8111c244:	883fa61e 	bne	r17,zero,8111c0e0 <__reset+0xfb0fc0e0>
8111c248:	da009c17 	ldw	r8,624(sp)
8111c24c:	9abfffc4 	addi	r10,r19,-1
8111c250:	44000017 	ldw	r16,0(r8)
8111c254:	44400104 	addi	r17,r8,4
8111c258:	8007883a 	mov	r3,r16
8111c25c:	82ab883a 	add	r21,r16,r10
8111c260:	00000306 	br	8111c270 <__svfscanf_r+0x850>
8111c264:	e1000017 	ldw	r4,0(fp)
8111c268:	9807883a 	mov	r3,r19
8111c26c:	20800003 	ldbu	r2,0(r4)
8111c270:	10803fcc 	andi	r2,r2,255
8111c274:	d9405884 	addi	r5,sp,354
8111c278:	2885883a 	add	r2,r5,r2
8111c27c:	10800007 	ldb	r2,0(r2)
8111c280:	10004b26 	beq	r2,zero,8111c3b0 <__svfscanf_r+0x990>
8111c284:	e0800117 	ldw	r2,4(fp)
8111c288:	21400044 	addi	r5,r4,1
8111c28c:	e1400015 	stw	r5,0(fp)
8111c290:	10bfffc4 	addi	r2,r2,-1
8111c294:	e0800115 	stw	r2,4(fp)
8111c298:	20800003 	ldbu	r2,0(r4)
8111c29c:	1cc00044 	addi	r19,r3,1
8111c2a0:	18800005 	stb	r2,0(r3)
8111c2a4:	1d400726 	beq	r3,r21,8111c2c4 <__svfscanf_r+0x8a4>
8111c2a8:	e0800117 	ldw	r2,4(fp)
8111c2ac:	00bfed16 	blt	zero,r2,8111c264 <__reset+0xfb0fc264>
8111c2b0:	e00b883a 	mov	r5,fp
8111c2b4:	b009883a 	mov	r4,r22
8111c2b8:	1116d000 	call	81116d00 <__srefill_r>
8111c2bc:	103fe926 	beq	r2,zero,8111c264 <__reset+0xfb0fc264>
8111c2c0:	84c01526 	beq	r16,r19,8111c318 <__svfscanf_r+0x8f8>
8111c2c4:	9c21c83a 	sub	r16,r19,r16
8111c2c8:	803e1726 	beq	r16,zero,8111bb28 <__reset+0xfb0fbb28>
8111c2cc:	da00a017 	ldw	r8,640(sp)
8111c2d0:	98000005 	stb	zero,0(r19)
8111c2d4:	dc409c15 	stw	r17,624(sp)
8111c2d8:	42000044 	addi	r8,r8,1
8111c2dc:	da00a015 	stw	r8,640(sp)
8111c2e0:	9425883a 	add	r18,r18,r16
8111c2e4:	a00d883a 	mov	r6,r20
8111c2e8:	003e0b06 	br	8111bb18 <__reset+0xfb0fbb18>
8111c2ec:	017fff84 	movi	r5,-2
8111c2f0:	11439b1e 	bne	r2,r5,8111d160 <__svfscanf_r+0x1740>
8111c2f4:	8821883a 	mov	r16,r17
8111c2f8:	e0800117 	ldw	r2,4(fp)
8111c2fc:	0082e516 	blt	zero,r2,8111ce94 <__svfscanf_r+0x1474>
8111c300:	e00b883a 	mov	r5,fp
8111c304:	b009883a 	mov	r4,r22
8111c308:	1116d000 	call	81116d00 <__srefill_r>
8111c30c:	1002e126 	beq	r2,zero,8111ce94 <__svfscanf_r+0x1474>
8111c310:	dc409f17 	ldw	r17,636(sp)
8111c314:	8002e826 	beq	r16,zero,8111ceb8 <__svfscanf_r+0x1498>
8111c318:	da00a017 	ldw	r8,640(sp)
8111c31c:	403e9c26 	beq	r8,zero,8111bd90 <__reset+0xfb0fbd90>
8111c320:	e080030b 	ldhu	r2,12(fp)
8111c324:	1080100c 	andi	r2,r2,64
8111c328:	103e991e 	bne	r2,zero,8111bd90 <__reset+0xfb0fbd90>
8111c32c:	4005883a 	mov	r2,r8
8111c330:	003e9806 	br	8111bd94 <__reset+0xfb0fbd94>
8111c334:	983f951e 	bne	r19,zero,8111c18c <__reset+0xfb0fc18c>
8111c338:	003fb806 	br	8111c21c <__reset+0xfb0fc21c>
8111c33c:	da009c17 	ldw	r8,624(sp)
8111c340:	45000017 	ldw	r20,0(r8)
8111c344:	42000104 	addi	r8,r8,4
8111c348:	da009c15 	stw	r8,624(sp)
8111c34c:	003f8e06 	br	8111c188 <__reset+0xfb0fc188>
8111c350:	e00b883a 	mov	r5,fp
8111c354:	b009883a 	mov	r4,r22
8111c358:	1116d000 	call	81116d00 <__srefill_r>
8111c35c:	103f3826 	beq	r2,zero,8111c040 <__reset+0xfb0fc040>
8111c360:	003fed06 	br	8111c318 <__reset+0xfb0fc318>
8111c364:	00ffff84 	movi	r3,-2
8111c368:	10c0071e 	bne	r2,r3,8111c388 <__svfscanf_r+0x968>
8111c36c:	e0800117 	ldw	r2,4(fp)
8111c370:	8023883a 	mov	r17,r16
8111c374:	00bf8516 	blt	zero,r2,8111c18c <__reset+0xfb0fc18c>
8111c378:	003fa306 	br	8111c208 <__reset+0xfb0fc208>
8111c37c:	9425883a 	add	r18,r18,r16
8111c380:	9cffffc4 	addi	r19,r19,-1
8111c384:	003f9d06 	br	8111c1fc <__reset+0xfb0fc1fc>
8111c388:	da009f17 	ldw	r8,636(sp)
8111c38c:	9425883a 	add	r18,r18,r16
8111c390:	9cffffc4 	addi	r19,r19,-1
8111c394:	403f9826 	beq	r8,zero,8111c1f8 <__reset+0xfb0fc1f8>
8111c398:	003f9806 	br	8111c1fc <__reset+0xfb0fc1fc>
8111c39c:	8023883a 	mov	r17,r16
8111c3a0:	8821883a 	mov	r16,r17
8111c3a4:	003fce06 	br	8111c2e0 <__reset+0xfb0fc2e0>
8111c3a8:	803f3d1e 	bne	r16,zero,8111c0a0 <__reset+0xfb0fc0a0>
8111c3ac:	003fda06 	br	8111c318 <__reset+0xfb0fc318>
8111c3b0:	1827883a 	mov	r19,r3
8111c3b4:	003fc306 	br	8111c2c4 <__reset+0xfb0fc2c4>
8111c3b8:	803fc91e 	bne	r16,zero,8111c2e0 <__reset+0xfb0fc2e0>
8111c3bc:	003dda06 	br	8111bb28 <__reset+0xfb0fbb28>
8111c3c0:	da009c17 	ldw	r8,624(sp)
8111c3c4:	df000015 	stw	fp,0(sp)
8111c3c8:	980f883a 	mov	r7,r19
8111c3cc:	41400017 	ldw	r5,0(r8)
8111c3d0:	01800044 	movi	r6,1
8111c3d4:	b009883a 	mov	r4,r22
8111c3d8:	111f5f80 	call	8111f5f8 <_fread_r>
8111c3dc:	da009c17 	ldw	r8,624(sp)
8111c3e0:	40c00104 	addi	r3,r8,4
8111c3e4:	103fcc26 	beq	r2,zero,8111c318 <__reset+0xfb0fc318>
8111c3e8:	da00a017 	ldw	r8,640(sp)
8111c3ec:	dd009d17 	ldw	r20,628(sp)
8111c3f0:	90a5883a 	add	r18,r18,r2
8111c3f4:	42000044 	addi	r8,r8,1
8111c3f8:	da00a015 	stw	r8,640(sp)
8111c3fc:	d8c09c15 	stw	r3,624(sp)
8111c400:	a00d883a 	mov	r6,r20
8111c404:	003dc406 	br	8111bb18 <__reset+0xfb0fbb18>
8111c408:	e00b883a 	mov	r5,fp
8111c40c:	b009883a 	mov	r4,r22
8111c410:	1116d000 	call	81116d00 <__srefill_r>
8111c414:	103e5226 	beq	r2,zero,8111bd60 <__reset+0xfb0fbd60>
8111c418:	003fbf06 	br	8111c318 <__reset+0xfb0fc318>
8111c41c:	a0800083 	ldbu	r2,2(r20)
8111c420:	8c400094 	ori	r17,r17,2
8111c424:	a5000084 	addi	r20,r20,2
8111c428:	10c03fcc 	andi	r3,r2,255
8111c42c:	003dc706 	br	8111bb4c <__reset+0xfb0fbb4c>
8111c430:	e0800117 	ldw	r2,4(fp)
8111c434:	88e2b03a 	or	r17,r17,r3
8111c438:	00bef716 	blt	zero,r2,8111c018 <__reset+0xfb0fc018>
8111c43c:	003e6f06 	br	8111bdfc <__reset+0xfb0fbdfc>
8111c440:	8880004c 	andi	r2,r17,1
8111c444:	10000b1e 	bne	r2,zero,8111c474 <__svfscanf_r+0xa54>
8111c448:	8c40008c 	andi	r17,r17,2
8111c44c:	88000926 	beq	r17,zero,8111c474 <__svfscanf_r+0xa54>
8111c450:	da009c17 	ldw	r8,624(sp)
8111c454:	9007d7fa 	srai	r3,r18,31
8111c458:	dd009d17 	ldw	r20,628(sp)
8111c45c:	40800017 	ldw	r2,0(r8)
8111c460:	42000104 	addi	r8,r8,4
8111c464:	da009c15 	stw	r8,624(sp)
8111c468:	14800015 	stw	r18,0(r2)
8111c46c:	10c00115 	stw	r3,4(r2)
8111c470:	003da806 	br	8111bb14 <__reset+0xfb0fbb14>
8111c474:	da009c17 	ldw	r8,624(sp)
8111c478:	dd009d17 	ldw	r20,628(sp)
8111c47c:	40800017 	ldw	r2,0(r8)
8111c480:	42000104 	addi	r8,r8,4
8111c484:	da009c15 	stw	r8,624(sp)
8111c488:	14800015 	stw	r18,0(r2)
8111c48c:	003da106 	br	8111bb14 <__reset+0xfb0fbb14>
8111c490:	e00b883a 	mov	r5,fp
8111c494:	b009883a 	mov	r4,r22
8111c498:	1116d000 	call	81116d00 <__srefill_r>
8111c49c:	103f9e1e 	bne	r2,zero,8111c318 <__reset+0xfb0fc318>
8111c4a0:	b9c00017 	ldw	r7,0(r23)
8111c4a4:	05000104 	movi	r20,4
8111c4a8:	003e6306 	br	8111be38 <__reset+0xfb0fbe38>
8111c4ac:	e00b883a 	mov	r5,fp
8111c4b0:	b009883a 	mov	r4,r22
8111c4b4:	1116d000 	call	81116d00 <__srefill_r>
8111c4b8:	103f971e 	bne	r2,zero,8111c318 <__reset+0xfb0fc318>
8111c4bc:	b9c00017 	ldw	r7,0(r23)
8111c4c0:	003e5706 	br	8111be20 <__reset+0xfb0fbe20>
8111c4c4:	e00b883a 	mov	r5,fp
8111c4c8:	b009883a 	mov	r4,r22
8111c4cc:	1116d000 	call	81116d00 <__srefill_r>
8111c4d0:	103f911e 	bne	r2,zero,8111c318 <__reset+0xfb0fc318>
8111c4d4:	b9c00017 	ldw	r7,0(r23)
8111c4d8:	05000084 	movi	r20,2
8111c4dc:	003e5606 	br	8111be38 <__reset+0xfb0fbe38>
8111c4e0:	e00b883a 	mov	r5,fp
8111c4e4:	b009883a 	mov	r4,r22
8111c4e8:	1116d000 	call	81116d00 <__srefill_r>
8111c4ec:	103ef726 	beq	r2,zero,8111c0cc <__reset+0xfb0fc0cc>
8111c4f0:	003f8906 	br	8111c318 <__reset+0xfb0fc318>
8111c4f4:	e00b883a 	mov	r5,fp
8111c4f8:	b009883a 	mov	r4,r22
8111c4fc:	1116d000 	call	81116d00 <__srefill_r>
8111c500:	103f851e 	bne	r2,zero,8111c318 <__reset+0xfb0fc318>
8111c504:	b9c00017 	ldw	r7,0(r23)
8111c508:	003f0f06 	br	8111c148 <__reset+0xfb0fc148>
8111c50c:	014000c4 	movi	r5,3
8111c510:	a1414a26 	beq	r20,r5,8111ca3c <__svfscanf_r+0x101c>
8111c514:	01000104 	movi	r4,4
8111c518:	a101f11e 	bne	r20,r4,8111cce0 <__svfscanf_r+0x12c0>
8111c51c:	b009883a 	mov	r4,r22
8111c520:	11204480 	call	81120448 <_localeconv_r>
8111c524:	10800017 	ldw	r2,0(r2)
8111c528:	98ffffc4 	addi	r3,r19,-1
8111c52c:	d880a315 	stw	r2,652(sp)
8111c530:	00805704 	movi	r2,348
8111c534:	10c21e2e 	bgeu	r2,r3,8111cdb0 <__svfscanf_r+0x1390>
8111c538:	9cffa8c4 	addi	r19,r19,-349
8111c53c:	dcc0a215 	stw	r19,648(sp)
8111c540:	04c05744 	movi	r19,349
8111c544:	8d01e014 	ori	r20,r17,1920
8111c548:	0023883a 	mov	r17,zero
8111c54c:	dc000104 	addi	r16,sp,4
8111c550:	8805883a 	mov	r2,r17
8111c554:	0019883a 	mov	r12,zero
8111c558:	8023883a 	mov	r17,r16
8111c55c:	b007883a 	mov	r3,r22
8111c560:	9821883a 	mov	r16,r19
8111c564:	002b883a 	mov	r21,zero
8111c568:	d800a515 	stw	zero,660(sp)
8111c56c:	d800a415 	stw	zero,656(sp)
8111c570:	d8009f15 	stw	zero,636(sp)
8111c574:	01c01384 	movi	r7,78
8111c578:	602d883a 	mov	r22,r12
8111c57c:	1027883a 	mov	r19,r2
8111c580:	e1000017 	ldw	r4,0(fp)
8111c584:	21400003 	ldbu	r5,0(r4)
8111c588:	28bff544 	addi	r2,r5,-43
8111c58c:	10803fcc 	andi	r2,r2,255
8111c590:	38810e36 	bltu	r7,r2,8111c9cc <__svfscanf_r+0xfac>
8111c594:	100490ba 	slli	r2,r2,2
8111c598:	01a044b4 	movhi	r6,33042
8111c59c:	31b16b04 	addi	r6,r6,-14932
8111c5a0:	1185883a 	add	r2,r2,r6
8111c5a4:	10800017 	ldw	r2,0(r2)
8111c5a8:	1000683a 	jmp	r2
8111c5ac:	8111c8a4 	muli	r4,r16,18210
8111c5b0:	8111c9cc 	andi	r4,r16,18215
8111c5b4:	8111c8a4 	muli	r4,r16,18210
8111c5b8:	8111c9cc 	andi	r4,r16,18215
8111c5bc:	8111c9cc 	andi	r4,r16,18215
8111c5c0:	8111c878 	rdprs	r4,r16,18209
8111c5c4:	8111c6e8 	cmpgeui	r4,r16,18203
8111c5c8:	8111c6e8 	cmpgeui	r4,r16,18203
8111c5cc:	8111c6e8 	cmpgeui	r4,r16,18203
8111c5d0:	8111c6e8 	cmpgeui	r4,r16,18203
8111c5d4:	8111c6e8 	cmpgeui	r4,r16,18203
8111c5d8:	8111c6e8 	cmpgeui	r4,r16,18203
8111c5dc:	8111c6e8 	cmpgeui	r4,r16,18203
8111c5e0:	8111c6e8 	cmpgeui	r4,r16,18203
8111c5e4:	8111c6e8 	cmpgeui	r4,r16,18203
8111c5e8:	8111c9cc 	andi	r4,r16,18215
8111c5ec:	8111c9cc 	andi	r4,r16,18215
8111c5f0:	8111c9cc 	andi	r4,r16,18215
8111c5f4:	8111c9cc 	andi	r4,r16,18215
8111c5f8:	8111c9cc 	andi	r4,r16,18215
8111c5fc:	8111c9cc 	andi	r4,r16,18215
8111c600:	8111c9cc 	andi	r4,r16,18215
8111c604:	8111c9bc 	xorhi	r4,r16,18214
8111c608:	8111c9cc 	andi	r4,r16,18215
8111c60c:	8111c9cc 	andi	r4,r16,18215
8111c610:	8111c9cc 	andi	r4,r16,18215
8111c614:	8111c978 	rdprs	r4,r16,18213
8111c618:	8111c95c 	xori	r4,r16,18213
8111c61c:	8111c9cc 	andi	r4,r16,18215
8111c620:	8111c9cc 	andi	r4,r16,18215
8111c624:	8111c928 	cmpgeui	r4,r16,18212
8111c628:	8111c9cc 	andi	r4,r16,18215
8111c62c:	8111c9cc 	andi	r4,r16,18215
8111c630:	8111c9cc 	andi	r4,r16,18215
8111c634:	8111c9cc 	andi	r4,r16,18215
8111c638:	8111c8f0 	cmpltui	r4,r16,18211
8111c63c:	8111c9cc 	andi	r4,r16,18215
8111c640:	8111c9cc 	andi	r4,r16,18215
8111c644:	8111c9cc 	andi	r4,r16,18215
8111c648:	8111c9cc 	andi	r4,r16,18215
8111c64c:	8111c9cc 	andi	r4,r16,18215
8111c650:	8111c8d4 	ori	r4,r16,18211
8111c654:	8111c9cc 	andi	r4,r16,18215
8111c658:	8111c9cc 	andi	r4,r16,18215
8111c65c:	8111c9cc 	andi	r4,r16,18215
8111c660:	8111c9cc 	andi	r4,r16,18215
8111c664:	8111c8b8 	rdprs	r4,r16,18210
8111c668:	8111c9cc 	andi	r4,r16,18215
8111c66c:	8111c9cc 	andi	r4,r16,18215
8111c670:	8111c9cc 	andi	r4,r16,18215
8111c674:	8111c9cc 	andi	r4,r16,18215
8111c678:	8111c9cc 	andi	r4,r16,18215
8111c67c:	8111c9cc 	andi	r4,r16,18215
8111c680:	8111c9cc 	andi	r4,r16,18215
8111c684:	8111c9bc 	xorhi	r4,r16,18214
8111c688:	8111c9cc 	andi	r4,r16,18215
8111c68c:	8111c9cc 	andi	r4,r16,18215
8111c690:	8111c9cc 	andi	r4,r16,18215
8111c694:	8111c978 	rdprs	r4,r16,18213
8111c698:	8111c95c 	xori	r4,r16,18213
8111c69c:	8111c9cc 	andi	r4,r16,18215
8111c6a0:	8111c9cc 	andi	r4,r16,18215
8111c6a4:	8111c928 	cmpgeui	r4,r16,18212
8111c6a8:	8111c9cc 	andi	r4,r16,18215
8111c6ac:	8111c9cc 	andi	r4,r16,18215
8111c6b0:	8111c9cc 	andi	r4,r16,18215
8111c6b4:	8111c9cc 	andi	r4,r16,18215
8111c6b8:	8111c8f0 	cmpltui	r4,r16,18211
8111c6bc:	8111c9cc 	andi	r4,r16,18215
8111c6c0:	8111c9cc 	andi	r4,r16,18215
8111c6c4:	8111c9cc 	andi	r4,r16,18215
8111c6c8:	8111c9cc 	andi	r4,r16,18215
8111c6cc:	8111c9cc 	andi	r4,r16,18215
8111c6d0:	8111c8d4 	ori	r4,r16,18211
8111c6d4:	8111c9cc 	andi	r4,r16,18215
8111c6d8:	8111c9cc 	andi	r4,r16,18215
8111c6dc:	8111c9cc 	andi	r4,r16,18215
8111c6e0:	8111c9cc 	andi	r4,r16,18215
8111c6e4:	8111c8b8 	rdprs	r4,r16,18210
8111c6e8:	a8803fcc 	andi	r2,r21,255
8111c6ec:	1080201c 	xori	r2,r2,128
8111c6f0:	10bfe004 	addi	r2,r2,-128
8111c6f4:	b085883a 	add	r2,r22,r2
8111c6f8:	10000d1e 	bne	r2,zero,8111c730 <__svfscanf_r+0xd10>
8111c6fc:	00bf9fc4 	movi	r2,-385
8111c700:	a0a8703a 	and	r20,r20,r2
8111c704:	89400005 	stb	r5,0(r17)
8111c708:	8c400044 	addi	r17,r17,1
8111c70c:	e0800117 	ldw	r2,4(fp)
8111c710:	843fffc4 	addi	r16,r16,-1
8111c714:	94800044 	addi	r18,r18,1
8111c718:	10bfffc4 	addi	r2,r2,-1
8111c71c:	e0800115 	stw	r2,4(fp)
8111c720:	0080b40e 	bge	zero,r2,8111c9f4 <__svfscanf_r+0xfd4>
8111c724:	21000044 	addi	r4,r4,1
8111c728:	e1000015 	stw	r4,0(fp)
8111c72c:	803f941e 	bne	r16,zero,8111c580 <__reset+0xfb0fc580>
8111c730:	8821883a 	mov	r16,r17
8111c734:	b019883a 	mov	r12,r22
8111c738:	9823883a 	mov	r17,r19
8111c73c:	182d883a 	mov	r22,r3
8111c740:	9801961e 	bne	r19,zero,8111cd9c <__svfscanf_r+0x137c>
8111c744:	633fffc4 	addi	r12,r12,-1
8111c748:	00800044 	movi	r2,1
8111c74c:	1302882e 	bgeu	r2,r12,8111d170 <__svfscanf_r+0x1750>
8111c750:	a8803fcc 	andi	r2,r21,255
8111c754:	1080201c 	xori	r2,r2,128
8111c758:	10bfe004 	addi	r2,r2,-128
8111c75c:	113fffc4 	addi	r4,r2,-1
8111c760:	01400184 	movi	r5,6
8111c764:	29001136 	bltu	r5,r4,8111c7ac <__svfscanf_r+0xd8c>
8111c768:	01000084 	movi	r4,2
8111c76c:	2082900e 	bge	r4,r2,8111d1b0 <__svfscanf_r+0x1790>
8111c770:	00c000c4 	movi	r3,3
8111c774:	10c00d26 	beq	r2,r3,8111c7ac <__svfscanf_r+0xd8c>
8111c778:	9425c83a 	sub	r18,r18,r16
8111c77c:	1827883a 	mov	r19,r3
8111c780:	843fffc4 	addi	r16,r16,-1
8111c784:	81400007 	ldb	r5,0(r16)
8111c788:	e00d883a 	mov	r6,fp
8111c78c:	b009883a 	mov	r4,r22
8111c790:	11256780 	call	81125678 <_ungetc_r>
8111c794:	a8bfffc4 	addi	r2,r21,-1
8111c798:	10c03fcc 	andi	r3,r2,255
8111c79c:	8493883a 	add	r9,r16,r18
8111c7a0:	102b883a 	mov	r21,r2
8111c7a4:	98fff636 	bltu	r19,r3,8111c780 <__reset+0xfb0fc780>
8111c7a8:	4825883a 	mov	r18,r9
8111c7ac:	a080400c 	andi	r2,r20,256
8111c7b0:	10001426 	beq	r2,zero,8111c804 <__svfscanf_r+0xde4>
8111c7b4:	a081000c 	andi	r2,r20,1024
8111c7b8:	1002571e 	bne	r2,zero,8111d118 <__svfscanf_r+0x16f8>
8111c7bc:	817fffc7 	ldb	r5,-1(r16)
8111c7c0:	00801944 	movi	r2,101
8111c7c4:	84ffffc4 	addi	r19,r16,-1
8111c7c8:	957fffc4 	addi	r21,r18,-1
8111c7cc:	28800826 	beq	r5,r2,8111c7f0 <__svfscanf_r+0xdd0>
8111c7d0:	00801144 	movi	r2,69
8111c7d4:	28800626 	beq	r5,r2,8111c7f0 <__svfscanf_r+0xdd0>
8111c7d8:	e00d883a 	mov	r6,fp
8111c7dc:	b009883a 	mov	r4,r22
8111c7e0:	11256780 	call	81125678 <_ungetc_r>
8111c7e4:	817fff87 	ldb	r5,-2(r16)
8111c7e8:	84ffff84 	addi	r19,r16,-2
8111c7ec:	957fff84 	addi	r21,r18,-2
8111c7f0:	e00d883a 	mov	r6,fp
8111c7f4:	b009883a 	mov	r4,r22
8111c7f8:	11256780 	call	81125678 <_ungetc_r>
8111c7fc:	a825883a 	mov	r18,r21
8111c800:	9821883a 	mov	r16,r19
8111c804:	a080040c 	andi	r2,r20,16
8111c808:	103e891e 	bne	r2,zero,8111c230 <__reset+0xfb0fc230>
8111c80c:	80000005 	stb	zero,0(r16)
8111c810:	a081800c 	andi	r2,r20,1536
8111c814:	01010004 	movi	r4,1024
8111c818:	1101dd26 	beq	r2,r4,8111cf90 <__svfscanf_r+0x1570>
8111c81c:	da00a417 	ldw	r8,656(sp)
8111c820:	4001e71e 	bne	r8,zero,8111cfc0 <__svfscanf_r+0x15a0>
8111c824:	000d883a 	mov	r6,zero
8111c828:	d9400104 	addi	r5,sp,4
8111c82c:	b009883a 	mov	r4,r22
8111c830:	11222280 	call	81122228 <_strtod_r>
8111c834:	1021883a 	mov	r16,r2
8111c838:	a080004c 	andi	r2,r20,1
8111c83c:	1000021e 	bne	r2,zero,8111c848 <__svfscanf_r+0xe28>
8111c840:	a2c0008c 	andi	r11,r20,2
8111c844:	5801e826 	beq	r11,zero,8111cfe8 <__svfscanf_r+0x15c8>
8111c848:	da009c17 	ldw	r8,624(sp)
8111c84c:	40800017 	ldw	r2,0(r8)
8111c850:	42000104 	addi	r8,r8,4
8111c854:	da009c15 	stw	r8,624(sp)
8111c858:	14000015 	stw	r16,0(r2)
8111c85c:	10c00115 	stw	r3,4(r2)
8111c860:	da00a017 	ldw	r8,640(sp)
8111c864:	dd009d17 	ldw	r20,628(sp)
8111c868:	42000044 	addi	r8,r8,1
8111c86c:	da00a015 	stw	r8,640(sp)
8111c870:	a00d883a 	mov	r6,r20
8111c874:	003ca806 	br	8111bb18 <__reset+0xfb0fbb18>
8111c878:	a080400c 	andi	r2,r20,256
8111c87c:	103f9a26 	beq	r2,zero,8111c6e8 <__reset+0xfb0fc6e8>
8111c880:	da00a217 	ldw	r8,648(sp)
8111c884:	00bfdfc4 	movi	r2,-129
8111c888:	a0a8703a 	and	r20,r20,r2
8111c88c:	9cc00044 	addi	r19,r19,1
8111c890:	403f9e26 	beq	r8,zero,8111c70c <__reset+0xfb0fc70c>
8111c894:	423fffc4 	addi	r8,r8,-1
8111c898:	da00a215 	stw	r8,648(sp)
8111c89c:	84000044 	addi	r16,r16,1
8111c8a0:	003f9a06 	br	8111c70c <__reset+0xfb0fc70c>
8111c8a4:	a080200c 	andi	r2,r20,128
8111c8a8:	103fa126 	beq	r2,zero,8111c730 <__reset+0xfb0fc730>
8111c8ac:	00bfdfc4 	movi	r2,-129
8111c8b0:	a0a8703a 	and	r20,r20,r2
8111c8b4:	003f9306 	br	8111c704 <__reset+0xfb0fc704>
8111c8b8:	a8803fcc 	andi	r2,r21,255
8111c8bc:	1080201c 	xori	r2,r2,128
8111c8c0:	10bfe004 	addi	r2,r2,-128
8111c8c4:	020001c4 	movi	r8,7
8111c8c8:	123f991e 	bne	r2,r8,8111c730 <__reset+0xfb0fc730>
8111c8cc:	05400204 	movi	r21,8
8111c8d0:	003f8c06 	br	8111c704 <__reset+0xfb0fc704>
8111c8d4:	a8803fcc 	andi	r2,r21,255
8111c8d8:	1080201c 	xori	r2,r2,128
8111c8dc:	10bfe004 	addi	r2,r2,-128
8111c8e0:	01800184 	movi	r6,6
8111c8e4:	11bf921e 	bne	r2,r6,8111c730 <__reset+0xfb0fc730>
8111c8e8:	054001c4 	movi	r21,7
8111c8ec:	003f8506 	br	8111c704 <__reset+0xfb0fc704>
8111c8f0:	b000491e 	bne	r22,zero,8111ca18 <__svfscanf_r+0xff8>
8111c8f4:	9800031e 	bne	r19,zero,8111c904 <__svfscanf_r+0xee4>
8111c8f8:	a081c00c 	andi	r2,r20,1792
8111c8fc:	0181c004 	movi	r6,1792
8111c900:	11819f26 	beq	r2,r6,8111cf80 <__svfscanf_r+0x1560>
8111c904:	a8803fcc 	andi	r2,r21,255
8111c908:	1080201c 	xori	r2,r2,128
8111c90c:	10bfe004 	addi	r2,r2,-128
8111c910:	01800044 	movi	r6,1
8111c914:	11800226 	beq	r2,r6,8111c920 <__svfscanf_r+0xf00>
8111c918:	01800104 	movi	r6,4
8111c91c:	11bf841e 	bne	r2,r6,8111c730 <__reset+0xfb0fc730>
8111c920:	ad400044 	addi	r21,r21,1
8111c924:	003f7706 	br	8111c704 <__reset+0xfb0fc704>
8111c928:	a8803fcc 	andi	r2,r21,255
8111c92c:	1080201c 	xori	r2,r2,128
8111c930:	10bfe004 	addi	r2,r2,-128
8111c934:	10003c1e 	bne	r2,zero,8111ca28 <__svfscanf_r+0x1008>
8111c938:	9801141e 	bne	r19,zero,8111cd8c <__svfscanf_r+0x136c>
8111c93c:	a081c00c 	andi	r2,r20,1792
8111c940:	0181c004 	movi	r6,1792
8111c944:	11818226 	beq	r2,r6,8111cf50 <__svfscanf_r+0x1530>
8111c948:	8821883a 	mov	r16,r17
8111c94c:	b019883a 	mov	r12,r22
8111c950:	9823883a 	mov	r17,r19
8111c954:	182d883a 	mov	r22,r3
8111c958:	003f7a06 	br	8111c744 <__reset+0xfb0fc744>
8111c95c:	a8803fcc 	andi	r2,r21,255
8111c960:	1080201c 	xori	r2,r2,128
8111c964:	10bfe004 	addi	r2,r2,-128
8111c968:	01800084 	movi	r6,2
8111c96c:	11bf701e 	bne	r2,r6,8111c730 <__reset+0xfb0fc730>
8111c970:	054000c4 	movi	r21,3
8111c974:	003f6306 	br	8111c704 <__reset+0xfb0fc704>
8111c978:	a081400c 	andi	r2,r20,1280
8111c97c:	01810004 	movi	r6,1024
8111c980:	11800326 	beq	r2,r6,8111c990 <__svfscanf_r+0xf70>
8111c984:	a184703a 	and	r2,r20,r6
8111c988:	103f6926 	beq	r2,zero,8111c730 <__reset+0xfb0fc730>
8111c98c:	983fee26 	beq	r19,zero,8111c948 <__reset+0xfb0fc948>
8111c990:	a080800c 	andi	r2,r20,512
8111c994:	1000041e 	bne	r2,zero,8111c9a8 <__svfscanf_r+0xf88>
8111c998:	da009f17 	ldw	r8,636(sp)
8111c99c:	dc40a515 	stw	r17,660(sp)
8111c9a0:	9a27c83a 	sub	r19,r19,r8
8111c9a4:	dcc0a415 	stw	r19,656(sp)
8111c9a8:	00be1fc4 	movi	r2,-1921
8111c9ac:	a0a8703a 	and	r20,r20,r2
8111c9b0:	a5006014 	ori	r20,r20,384
8111c9b4:	0027883a 	mov	r19,zero
8111c9b8:	003f5206 	br	8111c704 <__reset+0xfb0fc704>
8111c9bc:	00800044 	movi	r2,1
8111c9c0:	b0bf5b1e 	bne	r22,r2,8111c730 <__reset+0xfb0fc730>
8111c9c4:	05800084 	movi	r22,2
8111c9c8:	003f4e06 	br	8111c704 <__reset+0xfb0fc704>
8111c9cc:	d980a317 	ldw	r6,652(sp)
8111c9d0:	30800003 	ldbu	r2,0(r6)
8111c9d4:	29803fcc 	andi	r6,r5,255
8111c9d8:	30bf551e 	bne	r6,r2,8111c730 <__reset+0xfb0fc730>
8111c9dc:	a080800c 	andi	r2,r20,512
8111c9e0:	103f5326 	beq	r2,zero,8111c730 <__reset+0xfb0fc730>
8111c9e4:	023f5fc4 	movi	r8,-641
8111c9e8:	a228703a 	and	r20,r20,r8
8111c9ec:	dcc09f15 	stw	r19,636(sp)
8111c9f0:	003f4406 	br	8111c704 <__reset+0xfb0fc704>
8111c9f4:	1809883a 	mov	r4,r3
8111c9f8:	e00b883a 	mov	r5,fp
8111c9fc:	d8c0a615 	stw	r3,664(sp)
8111ca00:	d9c0aa15 	stw	r7,680(sp)
8111ca04:	1116d000 	call	81116d00 <__srefill_r>
8111ca08:	d8c0a617 	ldw	r3,664(sp)
8111ca0c:	d9c0aa17 	ldw	r7,680(sp)
8111ca10:	103f4626 	beq	r2,zero,8111c72c <__reset+0xfb0fc72c>
8111ca14:	003f4606 	br	8111c730 <__reset+0xfb0fc730>
8111ca18:	00800084 	movi	r2,2
8111ca1c:	b0bfb91e 	bne	r22,r2,8111c904 <__reset+0xfb0fc904>
8111ca20:	058000c4 	movi	r22,3
8111ca24:	003f3706 	br	8111c704 <__reset+0xfb0fc704>
8111ca28:	018000c4 	movi	r6,3
8111ca2c:	11bfbc26 	beq	r2,r6,8111c920 <__reset+0xfb0fc920>
8111ca30:	01800144 	movi	r6,5
8111ca34:	11bfba26 	beq	r2,r6,8111c920 <__reset+0xfb0fc920>
8111ca38:	003f3d06 	br	8111c730 <__reset+0xfb0fc730>
8111ca3c:	98bfffc4 	addi	r2,r19,-1
8111ca40:	01405704 	movi	r5,348
8111ca44:	2880d82e 	bgeu	r5,r2,8111cda8 <__svfscanf_r+0x1388>
8111ca48:	99ffa8c4 	addi	r7,r19,-349
8111ca4c:	04c05744 	movi	r19,349
8111ca50:	8c436014 	ori	r17,r17,3456
8111ca54:	9013883a 	mov	r9,r18
8111ca58:	8825883a 	mov	r18,r17
8111ca5c:	dc409e17 	ldw	r17,632(sp)
8111ca60:	0029883a 	mov	r20,zero
8111ca64:	dc000104 	addi	r16,sp,4
8111ca68:	05401344 	movi	r21,77
8111ca6c:	02c08004 	movi	r11,512
8111ca70:	01bf7fc4 	movi	r6,-513
8111ca74:	023fdfc4 	movi	r8,-129
8111ca78:	20bff544 	addi	r2,r4,-43
8111ca7c:	10803fcc 	andi	r2,r2,255
8111ca80:	a8807236 	bltu	r21,r2,8111cc4c <__svfscanf_r+0x122c>
8111ca84:	100490ba 	slli	r2,r2,2
8111ca88:	016044b4 	movhi	r5,33042
8111ca8c:	2972a704 	addi	r5,r5,-13668
8111ca90:	1145883a 	add	r2,r2,r5
8111ca94:	10800017 	ldw	r2,0(r2)
8111ca98:	1000683a 	jmp	r2
8111ca9c:	8111ccd0 	cmplti	r4,r16,18227
8111caa0:	8111cc4c 	andi	r4,r16,18225
8111caa4:	8111ccd0 	cmplti	r4,r16,18227
8111caa8:	8111cc4c 	andi	r4,r16,18225
8111caac:	8111cc4c 	andi	r4,r16,18225
8111cab0:	8111cca8 	cmpgeui	r4,r16,18226
8111cab4:	8111cc88 	cmpgei	r4,r16,18226
8111cab8:	8111cc88 	cmpgei	r4,r16,18226
8111cabc:	8111cc88 	cmpgei	r4,r16,18226
8111cac0:	8111cc88 	cmpgei	r4,r16,18226
8111cac4:	8111cc88 	cmpgei	r4,r16,18226
8111cac8:	8111cc88 	cmpgei	r4,r16,18226
8111cacc:	8111cc88 	cmpgei	r4,r16,18226
8111cad0:	8111cc30 	cmpltui	r4,r16,18224
8111cad4:	8111cc30 	cmpltui	r4,r16,18224
8111cad8:	8111cc4c 	andi	r4,r16,18225
8111cadc:	8111cc4c 	andi	r4,r16,18225
8111cae0:	8111cc4c 	andi	r4,r16,18225
8111cae4:	8111cc4c 	andi	r4,r16,18225
8111cae8:	8111cc4c 	andi	r4,r16,18225
8111caec:	8111cc4c 	andi	r4,r16,18225
8111caf0:	8111cc4c 	andi	r4,r16,18225
8111caf4:	8111cc1c 	xori	r4,r16,18224
8111caf8:	8111cc1c 	xori	r4,r16,18224
8111cafc:	8111cc1c 	xori	r4,r16,18224
8111cb00:	8111cc1c 	xori	r4,r16,18224
8111cb04:	8111cc1c 	xori	r4,r16,18224
8111cb08:	8111cc1c 	xori	r4,r16,18224
8111cb0c:	8111cc4c 	andi	r4,r16,18225
8111cb10:	8111cc4c 	andi	r4,r16,18225
8111cb14:	8111cc4c 	andi	r4,r16,18225
8111cb18:	8111cc4c 	andi	r4,r16,18225
8111cb1c:	8111cc4c 	andi	r4,r16,18225
8111cb20:	8111cc4c 	andi	r4,r16,18225
8111cb24:	8111cc4c 	andi	r4,r16,18225
8111cb28:	8111cc4c 	andi	r4,r16,18225
8111cb2c:	8111cc4c 	andi	r4,r16,18225
8111cb30:	8111cc4c 	andi	r4,r16,18225
8111cb34:	8111cc4c 	andi	r4,r16,18225
8111cb38:	8111cc4c 	andi	r4,r16,18225
8111cb3c:	8111cc4c 	andi	r4,r16,18225
8111cb40:	8111cc4c 	andi	r4,r16,18225
8111cb44:	8111cc4c 	andi	r4,r16,18225
8111cb48:	8111cc4c 	andi	r4,r16,18225
8111cb4c:	8111cc4c 	andi	r4,r16,18225
8111cb50:	8111cbd4 	ori	r4,r16,18223
8111cb54:	8111cc4c 	andi	r4,r16,18225
8111cb58:	8111cc4c 	andi	r4,r16,18225
8111cb5c:	8111cc4c 	andi	r4,r16,18225
8111cb60:	8111cc4c 	andi	r4,r16,18225
8111cb64:	8111cc4c 	andi	r4,r16,18225
8111cb68:	8111cc4c 	andi	r4,r16,18225
8111cb6c:	8111cc4c 	andi	r4,r16,18225
8111cb70:	8111cc4c 	andi	r4,r16,18225
8111cb74:	8111cc1c 	xori	r4,r16,18224
8111cb78:	8111cc1c 	xori	r4,r16,18224
8111cb7c:	8111cc1c 	xori	r4,r16,18224
8111cb80:	8111cc1c 	xori	r4,r16,18224
8111cb84:	8111cc1c 	xori	r4,r16,18224
8111cb88:	8111cc1c 	xori	r4,r16,18224
8111cb8c:	8111cc4c 	andi	r4,r16,18225
8111cb90:	8111cc4c 	andi	r4,r16,18225
8111cb94:	8111cc4c 	andi	r4,r16,18225
8111cb98:	8111cc4c 	andi	r4,r16,18225
8111cb9c:	8111cc4c 	andi	r4,r16,18225
8111cba0:	8111cc4c 	andi	r4,r16,18225
8111cba4:	8111cc4c 	andi	r4,r16,18225
8111cba8:	8111cc4c 	andi	r4,r16,18225
8111cbac:	8111cc4c 	andi	r4,r16,18225
8111cbb0:	8111cc4c 	andi	r4,r16,18225
8111cbb4:	8111cc4c 	andi	r4,r16,18225
8111cbb8:	8111cc4c 	andi	r4,r16,18225
8111cbbc:	8111cc4c 	andi	r4,r16,18225
8111cbc0:	8111cc4c 	andi	r4,r16,18225
8111cbc4:	8111cc4c 	andi	r4,r16,18225
8111cbc8:	8111cc4c 	andi	r4,r16,18225
8111cbcc:	8111cc4c 	andi	r4,r16,18225
8111cbd0:	8111cbd4 	ori	r4,r16,18223
8111cbd4:	9081800c 	andi	r2,r18,1536
8111cbd8:	12c01c1e 	bne	r2,r11,8111cc4c <__svfscanf_r+0x122c>
8111cbdc:	91a4703a 	and	r18,r18,r6
8111cbe0:	94814014 	ori	r18,r18,1280
8111cbe4:	04400404 	movi	r17,16
8111cbe8:	81000005 	stb	r4,0(r16)
8111cbec:	84000044 	addi	r16,r16,1
8111cbf0:	e0800117 	ldw	r2,4(fp)
8111cbf4:	10bfffc4 	addi	r2,r2,-1
8111cbf8:	e0800115 	stw	r2,4(fp)
8111cbfc:	0080540e 	bge	zero,r2,8111cd50 <__svfscanf_r+0x1330>
8111cc00:	18c00044 	addi	r3,r3,1
8111cc04:	e0c00015 	stw	r3,0(fp)
8111cc08:	9cffffc4 	addi	r19,r19,-1
8111cc0c:	98000f26 	beq	r19,zero,8111cc4c <__svfscanf_r+0x122c>
8111cc10:	e0c00017 	ldw	r3,0(fp)
8111cc14:	19000003 	ldbu	r4,0(r3)
8111cc18:	003f9706 	br	8111ca78 <__reset+0xfb0fca78>
8111cc1c:	00800284 	movi	r2,10
8111cc20:	14400a0e 	bge	r2,r17,8111cc4c <__svfscanf_r+0x122c>
8111cc24:	00bd1fc4 	movi	r2,-2945
8111cc28:	90a4703a 	and	r18,r18,r2
8111cc2c:	003fee06 	br	8111cbe8 <__reset+0xfb0fcbe8>
8111cc30:	01604534 	movhi	r5,33044
8111cc34:	8c63883a 	add	r17,r17,r17
8111cc38:	29513784 	addi	r5,r5,17630
8111cc3c:	2c45883a 	add	r2,r5,r17
8111cc40:	1440000f 	ldh	r17,0(r2)
8111cc44:	00800204 	movi	r2,8
8111cc48:	147ff616 	blt	r2,r17,8111cc24 <__reset+0xfb0fcc24>
8111cc4c:	dc409e15 	stw	r17,632(sp)
8111cc50:	9023883a 	mov	r17,r18
8111cc54:	8880400c 	andi	r2,r17,256
8111cc58:	4825883a 	mov	r18,r9
8111cc5c:	10000426 	beq	r2,zero,8111cc70 <__svfscanf_r+0x1250>
8111cc60:	d9800104 	addi	r6,sp,4
8111cc64:	3400be36 	bltu	r6,r16,8111cf60 <__svfscanf_r+0x1540>
8111cc68:	da000104 	addi	r8,sp,4
8111cc6c:	443bae26 	beq	r8,r16,8111bb28 <__reset+0xfb0fbb28>
8111cc70:	8880040c 	andi	r2,r17,16
8111cc74:	10009326 	beq	r2,zero,8111cec4 <__svfscanf_r+0x14a4>
8111cc78:	d8800104 	addi	r2,sp,4
8111cc7c:	80a1c83a 	sub	r16,r16,r2
8111cc80:	8521883a 	add	r16,r16,r20
8111cc84:	003d0606 	br	8111c0a0 <__reset+0xfb0fc0a0>
8111cc88:	01604534 	movhi	r5,33044
8111cc8c:	8c63883a 	add	r17,r17,r17
8111cc90:	29513784 	addi	r5,r5,17630
8111cc94:	2c45883a 	add	r2,r5,r17
8111cc98:	1440000f 	ldh	r17,0(r2)
8111cc9c:	00bd1fc4 	movi	r2,-2945
8111cca0:	90a4703a 	and	r18,r18,r2
8111cca4:	003fd006 	br	8111cbe8 <__reset+0xfb0fcbe8>
8111cca8:	9082000c 	andi	r2,r18,2048
8111ccac:	103fce26 	beq	r2,zero,8111cbe8 <__reset+0xfb0fcbe8>
8111ccb0:	8800021e 	bne	r17,zero,8111ccbc <__svfscanf_r+0x129c>
8111ccb4:	94808014 	ori	r18,r18,512
8111ccb8:	04400204 	movi	r17,8
8111ccbc:	9081000c 	andi	r2,r18,1024
8111ccc0:	10009426 	beq	r2,zero,8111cf14 <__svfscanf_r+0x14f4>
8111ccc4:	00be9fc4 	movi	r2,-1409
8111ccc8:	90a4703a 	and	r18,r18,r2
8111cccc:	003fc606 	br	8111cbe8 <__reset+0xfb0fcbe8>
8111ccd0:	9080200c 	andi	r2,r18,128
8111ccd4:	103fdd26 	beq	r2,zero,8111cc4c <__reset+0xfb0fcc4c>
8111ccd8:	9224703a 	and	r18,r18,r8
8111ccdc:	003fc206 	br	8111cbe8 <__reset+0xfb0fcbe8>
8111cce0:	9800011e 	bne	r19,zero,8111cce8 <__svfscanf_r+0x12c8>
8111cce4:	04ffffc4 	movi	r19,-1
8111cce8:	8900004c 	andi	r4,r17,1
8111ccec:	20005b1e 	bne	r4,zero,8111ce5c <__svfscanf_r+0x143c>
8111ccf0:	8c40040c 	andi	r17,r17,16
8111ccf4:	88003026 	beq	r17,zero,8111cdb8 <__svfscanf_r+0x1398>
8111ccf8:	0021883a 	mov	r16,zero
8111ccfc:	00000306 	br	8111cd0c <__svfscanf_r+0x12ec>
8111cd00:	18800003 	ldbu	r2,0(r3)
8111cd04:	3885883a 	add	r2,r7,r2
8111cd08:	10800043 	ldbu	r2,1(r2)
8111cd0c:	1080020c 	andi	r2,r2,8
8111cd10:	103ce31e 	bne	r2,zero,8111c0a0 <__reset+0xfb0fc0a0>
8111cd14:	e0800117 	ldw	r2,4(fp)
8111cd18:	18c00044 	addi	r3,r3,1
8111cd1c:	84000044 	addi	r16,r16,1
8111cd20:	10bfffc4 	addi	r2,r2,-1
8111cd24:	e0800115 	stw	r2,4(fp)
8111cd28:	e0c00015 	stw	r3,0(fp)
8111cd2c:	84fcdc26 	beq	r16,r19,8111c0a0 <__reset+0xfb0fc0a0>
8111cd30:	00bff316 	blt	zero,r2,8111cd00 <__reset+0xfb0fcd00>
8111cd34:	e00b883a 	mov	r5,fp
8111cd38:	b009883a 	mov	r4,r22
8111cd3c:	1116d000 	call	81116d00 <__srefill_r>
8111cd40:	103cd71e 	bne	r2,zero,8111c0a0 <__reset+0xfb0fc0a0>
8111cd44:	b9c00017 	ldw	r7,0(r23)
8111cd48:	e0c00017 	ldw	r3,0(fp)
8111cd4c:	003fec06 	br	8111cd00 <__reset+0xfb0fcd00>
8111cd50:	e00b883a 	mov	r5,fp
8111cd54:	b009883a 	mov	r4,r22
8111cd58:	d980a715 	stw	r6,668(sp)
8111cd5c:	d9c0aa15 	stw	r7,680(sp)
8111cd60:	da00a815 	stw	r8,672(sp)
8111cd64:	da40a915 	stw	r9,676(sp)
8111cd68:	dac0a615 	stw	r11,664(sp)
8111cd6c:	1116d000 	call	81116d00 <__srefill_r>
8111cd70:	d980a717 	ldw	r6,668(sp)
8111cd74:	d9c0aa17 	ldw	r7,680(sp)
8111cd78:	da00a817 	ldw	r8,672(sp)
8111cd7c:	da40a917 	ldw	r9,676(sp)
8111cd80:	dac0a617 	ldw	r11,664(sp)
8111cd84:	103fa026 	beq	r2,zero,8111cc08 <__reset+0xfb0fcc08>
8111cd88:	003fb006 	br	8111cc4c <__reset+0xfb0fcc4c>
8111cd8c:	8821883a 	mov	r16,r17
8111cd90:	b019883a 	mov	r12,r22
8111cd94:	9823883a 	mov	r17,r19
8111cd98:	182d883a 	mov	r22,r3
8111cd9c:	00bfbfc4 	movi	r2,-257
8111cda0:	a0a8703a 	and	r20,r20,r2
8111cda4:	003e6706 	br	8111c744 <__reset+0xfb0fc744>
8111cda8:	000f883a 	mov	r7,zero
8111cdac:	003f2806 	br	8111ca50 <__reset+0xfb0fca50>
8111cdb0:	d800a215 	stw	zero,648(sp)
8111cdb4:	003de306 	br	8111c544 <__reset+0xfb0fc544>
8111cdb8:	da009c17 	ldw	r8,624(sp)
8111cdbc:	9abfffc4 	addi	r10,r19,-1
8111cdc0:	44400017 	ldw	r17,0(r8)
8111cdc4:	44000104 	addi	r16,r8,4
8111cdc8:	880b883a 	mov	r5,r17
8111cdcc:	8aa9883a 	add	r20,r17,r10
8111cdd0:	00000606 	br	8111cdec <__svfscanf_r+0x13cc>
8111cdd4:	e0c00017 	ldw	r3,0(fp)
8111cdd8:	b9000017 	ldw	r4,0(r23)
8111cddc:	a80b883a 	mov	r5,r21
8111cde0:	18800003 	ldbu	r2,0(r3)
8111cde4:	2085883a 	add	r2,r4,r2
8111cde8:	10800043 	ldbu	r2,1(r2)
8111cdec:	1080020c 	andi	r2,r2,8
8111cdf0:	1000551e 	bne	r2,zero,8111cf48 <__svfscanf_r+0x1528>
8111cdf4:	e0800117 	ldw	r2,4(fp)
8111cdf8:	19000044 	addi	r4,r3,1
8111cdfc:	e1000015 	stw	r4,0(fp)
8111ce00:	10bfffc4 	addi	r2,r2,-1
8111ce04:	e0800115 	stw	r2,4(fp)
8111ce08:	18800003 	ldbu	r2,0(r3)
8111ce0c:	2d400044 	addi	r21,r5,1
8111ce10:	a827883a 	mov	r19,r21
8111ce14:	28800005 	stb	r2,0(r5)
8111ce18:	2d000626 	beq	r5,r20,8111ce34 <__svfscanf_r+0x1414>
8111ce1c:	e0800117 	ldw	r2,4(fp)
8111ce20:	00bfec16 	blt	zero,r2,8111cdd4 <__reset+0xfb0fcdd4>
8111ce24:	e00b883a 	mov	r5,fp
8111ce28:	b009883a 	mov	r4,r22
8111ce2c:	1116d000 	call	81116d00 <__srefill_r>
8111ce30:	103fe826 	beq	r2,zero,8111cdd4 <__reset+0xfb0fcdd4>
8111ce34:	da00a017 	ldw	r8,640(sp)
8111ce38:	dd009d17 	ldw	r20,628(sp)
8111ce3c:	9c63c83a 	sub	r17,r19,r17
8111ce40:	42000044 	addi	r8,r8,1
8111ce44:	98000005 	stb	zero,0(r19)
8111ce48:	9465883a 	add	r18,r18,r17
8111ce4c:	da00a015 	stw	r8,640(sp)
8111ce50:	dc009c15 	stw	r16,624(sp)
8111ce54:	a00d883a 	mov	r6,r20
8111ce58:	003b2f06 	br	8111bb18 <__reset+0xfb0fbb18>
8111ce5c:	dd409904 	addi	r21,sp,612
8111ce60:	8c40040c 	andi	r17,r17,16
8111ce64:	01800204 	movi	r6,8
8111ce68:	000b883a 	mov	r5,zero
8111ce6c:	a809883a 	mov	r4,r21
8111ce70:	11168840 	call	81116884 <memset>
8111ce74:	8800401e 	bne	r17,zero,8111cf78 <__svfscanf_r+0x1558>
8111ce78:	da009c17 	ldw	r8,624(sp)
8111ce7c:	45000017 	ldw	r20,0(r8)
8111ce80:	42000104 	addi	r8,r8,4
8111ce84:	da009c15 	stw	r8,624(sp)
8111ce88:	000d883a 	mov	r6,zero
8111ce8c:	3021883a 	mov	r16,r6
8111ce90:	dc409f15 	stw	r17,636(sp)
8111ce94:	e0800017 	ldw	r2,0(fp)
8111ce98:	b8c00017 	ldw	r3,0(r23)
8111ce9c:	10800003 	ldbu	r2,0(r2)
8111cea0:	1885883a 	add	r2,r3,r2
8111cea4:	10800043 	ldbu	r2,1(r2)
8111cea8:	1080020c 	andi	r2,r2,8
8111ceac:	1000011e 	bne	r2,zero,8111ceb4 <__svfscanf_r+0x1494>
8111ceb0:	9800701e 	bne	r19,zero,8111d074 <__svfscanf_r+0x1654>
8111ceb4:	dc409f17 	ldw	r17,636(sp)
8111ceb8:	883cdd1e 	bne	r17,zero,8111c230 <__reset+0xfb0fc230>
8111cebc:	a0000015 	stw	zero,0(r20)
8111cec0:	003cd806 	br	8111c224 <__reset+0xfb0fc224>
8111cec4:	d9c09e17 	ldw	r7,632(sp)
8111cec8:	da00a117 	ldw	r8,644(sp)
8111cecc:	000d883a 	mov	r6,zero
8111ced0:	d9400104 	addi	r5,sp,4
8111ced4:	b009883a 	mov	r4,r22
8111ced8:	80000005 	stb	zero,0(r16)
8111cedc:	403ee83a 	callr	r8
8111cee0:	88c0080c 	andi	r3,r17,32
8111cee4:	1800121e 	bne	r3,zero,8111cf30 <__svfscanf_r+0x1510>
8111cee8:	88c0010c 	andi	r3,r17,4
8111ceec:	18004d26 	beq	r3,zero,8111d024 <__svfscanf_r+0x1604>
8111cef0:	da009c17 	ldw	r8,624(sp)
8111cef4:	40c00017 	ldw	r3,0(r8)
8111cef8:	42000104 	addi	r8,r8,4
8111cefc:	da009c15 	stw	r8,624(sp)
8111cf00:	1880000d 	sth	r2,0(r3)
8111cf04:	da00a017 	ldw	r8,640(sp)
8111cf08:	42000044 	addi	r8,r8,1
8111cf0c:	da00a015 	stw	r8,640(sp)
8111cf10:	003f5906 	br	8111cc78 <__reset+0xfb0fcc78>
8111cf14:	00bf1fc4 	movi	r2,-897
8111cf18:	90a4703a 	and	r18,r18,r2
8111cf1c:	38000226 	beq	r7,zero,8111cf28 <__svfscanf_r+0x1508>
8111cf20:	39ffffc4 	addi	r7,r7,-1
8111cf24:	9cc00044 	addi	r19,r19,1
8111cf28:	a5000044 	addi	r20,r20,1
8111cf2c:	003f3006 	br	8111cbf0 <__reset+0xfb0fcbf0>
8111cf30:	da009c17 	ldw	r8,624(sp)
8111cf34:	40c00017 	ldw	r3,0(r8)
8111cf38:	42000104 	addi	r8,r8,4
8111cf3c:	da009c15 	stw	r8,624(sp)
8111cf40:	18800015 	stw	r2,0(r3)
8111cf44:	003fef06 	br	8111cf04 <__reset+0xfb0fcf04>
8111cf48:	2827883a 	mov	r19,r5
8111cf4c:	003fb906 	br	8111ce34 <__reset+0xfb0fce34>
8111cf50:	01be1fc4 	movi	r6,-1921
8111cf54:	a1a8703a 	and	r20,r20,r6
8111cf58:	05400044 	movi	r21,1
8111cf5c:	003de906 	br	8111c704 <__reset+0xfb0fc704>
8111cf60:	817fffc7 	ldb	r5,-1(r16)
8111cf64:	e00d883a 	mov	r6,fp
8111cf68:	b009883a 	mov	r4,r22
8111cf6c:	843fffc4 	addi	r16,r16,-1
8111cf70:	11256780 	call	81125678 <_ungetc_r>
8111cf74:	003f3c06 	br	8111cc68 <__reset+0xfb0fcc68>
8111cf78:	dd009b04 	addi	r20,sp,620
8111cf7c:	003fc206 	br	8111ce88 <__reset+0xfb0fce88>
8111cf80:	00be1fc4 	movi	r2,-1921
8111cf84:	a0a8703a 	and	r20,r20,r2
8111cf88:	05800044 	movi	r22,1
8111cf8c:	003ddd06 	br	8111c704 <__reset+0xfb0fc704>
8111cf90:	d8c09f17 	ldw	r3,636(sp)
8111cf94:	88e3c83a 	sub	r17,r17,r3
8111cf98:	044dc83a 	sub	r6,zero,r17
8111cf9c:	883e2126 	beq	r17,zero,8111c824 <__reset+0xfb0fc824>
8111cfa0:	d88055c4 	addi	r2,sp,343
8111cfa4:	80800136 	bltu	r16,r2,8111cfac <__svfscanf_r+0x158c>
8111cfa8:	dc005584 	addi	r16,sp,342
8111cfac:	01604534 	movhi	r5,33044
8111cfb0:	29513604 	addi	r5,r5,17624
8111cfb4:	8009883a 	mov	r4,r16
8111cfb8:	11170140 	call	81117014 <sprintf>
8111cfbc:	003e1906 	br	8111c824 <__reset+0xfb0fc824>
8111cfc0:	d8c0a517 	ldw	r3,660(sp)
8111cfc4:	000d883a 	mov	r6,zero
8111cfc8:	01c00284 	movi	r7,10
8111cfcc:	19400044 	addi	r5,r3,1
8111cfd0:	b009883a 	mov	r4,r22
8111cfd4:	11173040 	call	81117304 <_strtol_r>
8111cfd8:	da00a417 	ldw	r8,656(sp)
8111cfdc:	dc00a517 	ldw	r16,660(sp)
8111cfe0:	120dc83a 	sub	r6,r2,r8
8111cfe4:	003fee06 	br	8111cfa0 <__reset+0xfb0fcfa0>
8111cfe8:	da009c17 	ldw	r8,624(sp)
8111cfec:	180b883a 	mov	r5,r3
8111cff0:	8009883a 	mov	r4,r16
8111cff4:	45000017 	ldw	r20,0(r8)
8111cff8:	44400104 	addi	r17,r8,4
8111cffc:	d8c0a615 	stw	r3,664(sp)
8111d000:	1121f940 	call	81121f94 <__fpclassifyd>
8111d004:	d8c0a617 	ldw	r3,664(sp)
8111d008:	10006426 	beq	r2,zero,8111d19c <__svfscanf_r+0x177c>
8111d00c:	8009883a 	mov	r4,r16
8111d010:	180b883a 	mov	r5,r3
8111d014:	111531c0 	call	8111531c <__truncdfsf2>
8111d018:	a0800015 	stw	r2,0(r20)
8111d01c:	dc409c15 	stw	r17,624(sp)
8111d020:	003e0f06 	br	8111c860 <__reset+0xfb0fc860>
8111d024:	88c0004c 	andi	r3,r17,1
8111d028:	183fc11e 	bne	r3,zero,8111cf30 <__reset+0xfb0fcf30>
8111d02c:	8c40008c 	andi	r17,r17,2
8111d030:	883fbf26 	beq	r17,zero,8111cf30 <__reset+0xfb0fcf30>
8111d034:	da00a117 	ldw	r8,644(sp)
8111d038:	00a044b4 	movhi	r2,33042
8111d03c:	108f0c04 	addi	r2,r2,15408
8111d040:	d9c09e17 	ldw	r7,632(sp)
8111d044:	000d883a 	mov	r6,zero
8111d048:	d9400104 	addi	r5,sp,4
8111d04c:	b009883a 	mov	r4,r22
8111d050:	40806226 	beq	r8,r2,8111d1dc <__svfscanf_r+0x17bc>
8111d054:	11239480 	call	81123948 <_strtoll_r>
8111d058:	da009c17 	ldw	r8,624(sp)
8111d05c:	41000017 	ldw	r4,0(r8)
8111d060:	42000104 	addi	r8,r8,4
8111d064:	da009c15 	stw	r8,624(sp)
8111d068:	20800015 	stw	r2,0(r4)
8111d06c:	20c00115 	stw	r3,4(r4)
8111d070:	003fa406 	br	8111cf04 <__reset+0xfb0fcf04>
8111d074:	11204240 	call	81120424 <__locale_mb_cur_max>
8111d078:	80bca726 	beq	r16,r2,8111c318 <__reset+0xfb0fc318>
8111d07c:	e0800017 	ldw	r2,0(fp)
8111d080:	e1000117 	ldw	r4,4(fp)
8111d084:	d8c00104 	addi	r3,sp,4
8111d088:	12000003 	ldbu	r8,0(r2)
8111d08c:	213fffc4 	addi	r4,r4,-1
8111d090:	10800044 	addi	r2,r2,1
8111d094:	e1000115 	stw	r4,4(fp)
8111d098:	e0800015 	stw	r2,0(fp)
8111d09c:	84400044 	addi	r17,r16,1
8111d0a0:	dd400015 	stw	r21,0(sp)
8111d0a4:	1c21883a 	add	r16,r3,r16
8111d0a8:	b009883a 	mov	r4,r22
8111d0ac:	880f883a 	mov	r7,r17
8111d0b0:	180d883a 	mov	r6,r3
8111d0b4:	a00b883a 	mov	r5,r20
8111d0b8:	82000005 	stb	r8,0(r16)
8111d0bc:	11204e00 	call	811204e0 <_mbrtowc_r>
8111d0c0:	013fffc4 	movi	r4,-1
8111d0c4:	113c9426 	beq	r2,r4,8111c318 <__reset+0xfb0fc318>
8111d0c8:	103c881e 	bne	r2,zero,8111c2ec <__reset+0xfb0fc2ec>
8111d0cc:	a0000015 	stw	zero,0(r20)
8111d0d0:	0009883a 	mov	r4,zero
8111d0d4:	11203640 	call	81120364 <iswspace>
8111d0d8:	10001a26 	beq	r2,zero,8111d144 <__svfscanf_r+0x1724>
8111d0dc:	8821883a 	mov	r16,r17
8111d0e0:	dc409f17 	ldw	r17,636(sp)
8111d0e4:	803f7426 	beq	r16,zero,8111ceb8 <__reset+0xfb0fceb8>
8111d0e8:	843fffc4 	addi	r16,r16,-1
8111d0ec:	d9800104 	addi	r6,sp,4
8111d0f0:	342b883a 	add	r21,r6,r16
8111d0f4:	00000106 	br	8111d0fc <__svfscanf_r+0x16dc>
8111d0f8:	843fffc4 	addi	r16,r16,-1
8111d0fc:	a9400003 	ldbu	r5,0(r21)
8111d100:	e00d883a 	mov	r6,fp
8111d104:	b009883a 	mov	r4,r22
8111d108:	11256780 	call	81125678 <_ungetc_r>
8111d10c:	ad7fffc4 	addi	r21,r21,-1
8111d110:	803ff91e 	bne	r16,zero,8111d0f8 <__reset+0xfb0fd0f8>
8111d114:	003f6806 	br	8111ceb8 <__reset+0xfb0fceb8>
8111d118:	d9800104 	addi	r6,sp,4
8111d11c:	802b883a 	mov	r21,r16
8111d120:	343a812e 	bgeu	r6,r16,8111bb28 <__reset+0xfb0fbb28>
8111d124:	ad7fffc4 	addi	r21,r21,-1
8111d128:	a9400007 	ldb	r5,0(r21)
8111d12c:	e00d883a 	mov	r6,fp
8111d130:	b009883a 	mov	r4,r22
8111d134:	11256780 	call	81125678 <_ungetc_r>
8111d138:	da000104 	addi	r8,sp,4
8111d13c:	457ff91e 	bne	r8,r21,8111d124 <__reset+0xfb0fd124>
8111d140:	003a7906 	br	8111bb28 <__reset+0xfb0fbb28>
8111d144:	da009f17 	ldw	r8,636(sp)
8111d148:	9465883a 	add	r18,r18,r17
8111d14c:	9cffffc4 	addi	r19,r19,-1
8111d150:	4000051e 	bne	r8,zero,8111d168 <__svfscanf_r+0x1748>
8111d154:	a5000104 	addi	r20,r20,4
8111d158:	0021883a 	mov	r16,zero
8111d15c:	003c6606 	br	8111c2f8 <__reset+0xfb0fc2f8>
8111d160:	a1000017 	ldw	r4,0(r20)
8111d164:	003fdb06 	br	8111d0d4 <__reset+0xfb0fd0d4>
8111d168:	0021883a 	mov	r16,zero
8111d16c:	003c6206 	br	8111c2f8 <__reset+0xfb0fc2f8>
8111d170:	d8800104 	addi	r2,sp,4
8111d174:	802b883a 	mov	r21,r16
8111d178:	143a6b2e 	bgeu	r2,r16,8111bb28 <__reset+0xfb0fbb28>
8111d17c:	ad7fffc4 	addi	r21,r21,-1
8111d180:	a9400007 	ldb	r5,0(r21)
8111d184:	e00d883a 	mov	r6,fp
8111d188:	b009883a 	mov	r4,r22
8111d18c:	11256780 	call	81125678 <_ungetc_r>
8111d190:	d8c00104 	addi	r3,sp,4
8111d194:	1d7ff91e 	bne	r3,r21,8111d17c <__reset+0xfb0fd17c>
8111d198:	003a6306 	br	8111bb28 <__reset+0xfb0fbb28>
8111d19c:	0009883a 	mov	r4,zero
8111d1a0:	11220d80 	call	811220d8 <nanf>
8111d1a4:	a0800015 	stw	r2,0(r20)
8111d1a8:	dc409c15 	stw	r17,624(sp)
8111d1ac:	003dac06 	br	8111c860 <__reset+0xfb0fc860>
8111d1b0:	d9000104 	addi	r4,sp,4
8111d1b4:	802b883a 	mov	r21,r16
8111d1b8:	243a5b2e 	bgeu	r4,r16,8111bb28 <__reset+0xfb0fbb28>
8111d1bc:	ad7fffc4 	addi	r21,r21,-1
8111d1c0:	a9400007 	ldb	r5,0(r21)
8111d1c4:	e00d883a 	mov	r6,fp
8111d1c8:	b009883a 	mov	r4,r22
8111d1cc:	11256780 	call	81125678 <_ungetc_r>
8111d1d0:	d9400104 	addi	r5,sp,4
8111d1d4:	2d7ff91e 	bne	r5,r21,8111d1bc <__reset+0xfb0fd1bc>
8111d1d8:	003a5306 	br	8111bb28 <__reset+0xfb0fbb28>
8111d1dc:	1123ea00 	call	81123ea0 <_strtoull_r>
8111d1e0:	003f9d06 	br	8111d058 <__reset+0xfb0fd058>

8111d1e4 <vfscanf>:
8111d1e4:	00a04534 	movhi	r2,33044
8111d1e8:	defffb04 	addi	sp,sp,-20
8111d1ec:	109aed04 	addi	r2,r2,27572
8111d1f0:	de00012e 	bgeu	sp,et,8111d1f8 <vfscanf+0x14>
8111d1f4:	003b68fa 	trap	3
8111d1f8:	dc000215 	stw	r16,8(sp)
8111d1fc:	14000017 	ldw	r16,0(r2)
8111d200:	dc400315 	stw	r17,12(sp)
8111d204:	dfc00415 	stw	ra,16(sp)
8111d208:	2023883a 	mov	r17,r4
8111d20c:	80000826 	beq	r16,zero,8111d230 <vfscanf+0x4c>
8111d210:	80800e17 	ldw	r2,56(r16)
8111d214:	1000061e 	bne	r2,zero,8111d230 <vfscanf+0x4c>
8111d218:	8009883a 	mov	r4,r16
8111d21c:	d9400015 	stw	r5,0(sp)
8111d220:	d9800115 	stw	r6,4(sp)
8111d224:	111f4fc0 	call	8111f4fc <__sinit>
8111d228:	d9800117 	ldw	r6,4(sp)
8111d22c:	d9400017 	ldw	r5,0(sp)
8111d230:	300f883a 	mov	r7,r6
8111d234:	8009883a 	mov	r4,r16
8111d238:	280d883a 	mov	r6,r5
8111d23c:	880b883a 	mov	r5,r17
8111d240:	dfc00417 	ldw	ra,16(sp)
8111d244:	dc400317 	ldw	r17,12(sp)
8111d248:	dc000217 	ldw	r16,8(sp)
8111d24c:	dec00504 	addi	sp,sp,20
8111d250:	111ba201 	jmpi	8111ba20 <__svfscanf_r>

8111d254 <__svfscanf>:
8111d254:	00a04534 	movhi	r2,33044
8111d258:	109aed04 	addi	r2,r2,27572
8111d25c:	300f883a 	mov	r7,r6
8111d260:	280d883a 	mov	r6,r5
8111d264:	200b883a 	mov	r5,r4
8111d268:	11000017 	ldw	r4,0(r2)
8111d26c:	111ba201 	jmpi	8111ba20 <__svfscanf_r>

8111d270 <_vfscanf_r>:
8111d270:	defffb04 	addi	sp,sp,-20
8111d274:	de00012e 	bgeu	sp,et,8111d27c <_vfscanf_r+0xc>
8111d278:	003b68fa 	trap	3
8111d27c:	dc000315 	stw	r16,12(sp)
8111d280:	dfc00415 	stw	ra,16(sp)
8111d284:	2021883a 	mov	r16,r4
8111d288:	20000926 	beq	r4,zero,8111d2b0 <_vfscanf_r+0x40>
8111d28c:	20800e17 	ldw	r2,56(r4)
8111d290:	1000071e 	bne	r2,zero,8111d2b0 <_vfscanf_r+0x40>
8111d294:	d9400015 	stw	r5,0(sp)
8111d298:	d9800115 	stw	r6,4(sp)
8111d29c:	d9c00215 	stw	r7,8(sp)
8111d2a0:	111f4fc0 	call	8111f4fc <__sinit>
8111d2a4:	d9c00217 	ldw	r7,8(sp)
8111d2a8:	d9800117 	ldw	r6,4(sp)
8111d2ac:	d9400017 	ldw	r5,0(sp)
8111d2b0:	8009883a 	mov	r4,r16
8111d2b4:	dfc00417 	ldw	ra,16(sp)
8111d2b8:	dc000317 	ldw	r16,12(sp)
8111d2bc:	dec00504 	addi	sp,sp,20
8111d2c0:	111ba201 	jmpi	8111ba20 <__svfscanf_r>

8111d2c4 <__swbuf_r>:
8111d2c4:	defffb04 	addi	sp,sp,-20
8111d2c8:	de00012e 	bgeu	sp,et,8111d2d0 <__swbuf_r+0xc>
8111d2cc:	003b68fa 	trap	3
8111d2d0:	dcc00315 	stw	r19,12(sp)
8111d2d4:	dc800215 	stw	r18,8(sp)
8111d2d8:	dc000015 	stw	r16,0(sp)
8111d2dc:	dfc00415 	stw	ra,16(sp)
8111d2e0:	dc400115 	stw	r17,4(sp)
8111d2e4:	2025883a 	mov	r18,r4
8111d2e8:	2827883a 	mov	r19,r5
8111d2ec:	3021883a 	mov	r16,r6
8111d2f0:	20000226 	beq	r4,zero,8111d2fc <__swbuf_r+0x38>
8111d2f4:	20800e17 	ldw	r2,56(r4)
8111d2f8:	10004226 	beq	r2,zero,8111d404 <__swbuf_r+0x140>
8111d2fc:	80800617 	ldw	r2,24(r16)
8111d300:	8100030b 	ldhu	r4,12(r16)
8111d304:	80800215 	stw	r2,8(r16)
8111d308:	2080020c 	andi	r2,r4,8
8111d30c:	10003626 	beq	r2,zero,8111d3e8 <__swbuf_r+0x124>
8111d310:	80c00417 	ldw	r3,16(r16)
8111d314:	18003426 	beq	r3,zero,8111d3e8 <__swbuf_r+0x124>
8111d318:	2088000c 	andi	r2,r4,8192
8111d31c:	9c403fcc 	andi	r17,r19,255
8111d320:	10001a26 	beq	r2,zero,8111d38c <__swbuf_r+0xc8>
8111d324:	80800017 	ldw	r2,0(r16)
8111d328:	81000517 	ldw	r4,20(r16)
8111d32c:	10c7c83a 	sub	r3,r2,r3
8111d330:	1900200e 	bge	r3,r4,8111d3b4 <__swbuf_r+0xf0>
8111d334:	18c00044 	addi	r3,r3,1
8111d338:	81000217 	ldw	r4,8(r16)
8111d33c:	11400044 	addi	r5,r2,1
8111d340:	81400015 	stw	r5,0(r16)
8111d344:	213fffc4 	addi	r4,r4,-1
8111d348:	81000215 	stw	r4,8(r16)
8111d34c:	14c00005 	stb	r19,0(r2)
8111d350:	80800517 	ldw	r2,20(r16)
8111d354:	10c01e26 	beq	r2,r3,8111d3d0 <__swbuf_r+0x10c>
8111d358:	8080030b 	ldhu	r2,12(r16)
8111d35c:	1080004c 	andi	r2,r2,1
8111d360:	10000226 	beq	r2,zero,8111d36c <__swbuf_r+0xa8>
8111d364:	00800284 	movi	r2,10
8111d368:	88801926 	beq	r17,r2,8111d3d0 <__swbuf_r+0x10c>
8111d36c:	8805883a 	mov	r2,r17
8111d370:	dfc00417 	ldw	ra,16(sp)
8111d374:	dcc00317 	ldw	r19,12(sp)
8111d378:	dc800217 	ldw	r18,8(sp)
8111d37c:	dc400117 	ldw	r17,4(sp)
8111d380:	dc000017 	ldw	r16,0(sp)
8111d384:	dec00504 	addi	sp,sp,20
8111d388:	f800283a 	ret
8111d38c:	81401917 	ldw	r5,100(r16)
8111d390:	00b7ffc4 	movi	r2,-8193
8111d394:	21080014 	ori	r4,r4,8192
8111d398:	2884703a 	and	r2,r5,r2
8111d39c:	80801915 	stw	r2,100(r16)
8111d3a0:	80800017 	ldw	r2,0(r16)
8111d3a4:	8100030d 	sth	r4,12(r16)
8111d3a8:	81000517 	ldw	r4,20(r16)
8111d3ac:	10c7c83a 	sub	r3,r2,r3
8111d3b0:	193fe016 	blt	r3,r4,8111d334 <__reset+0xfb0fd334>
8111d3b4:	800b883a 	mov	r5,r16
8111d3b8:	9009883a 	mov	r4,r18
8111d3bc:	111f1000 	call	8111f100 <_fflush_r>
8111d3c0:	1000071e 	bne	r2,zero,8111d3e0 <__swbuf_r+0x11c>
8111d3c4:	80800017 	ldw	r2,0(r16)
8111d3c8:	00c00044 	movi	r3,1
8111d3cc:	003fda06 	br	8111d338 <__reset+0xfb0fd338>
8111d3d0:	800b883a 	mov	r5,r16
8111d3d4:	9009883a 	mov	r4,r18
8111d3d8:	111f1000 	call	8111f100 <_fflush_r>
8111d3dc:	103fe326 	beq	r2,zero,8111d36c <__reset+0xfb0fd36c>
8111d3e0:	00bfffc4 	movi	r2,-1
8111d3e4:	003fe206 	br	8111d370 <__reset+0xfb0fd370>
8111d3e8:	800b883a 	mov	r5,r16
8111d3ec:	9009883a 	mov	r4,r18
8111d3f0:	111d48c0 	call	8111d48c <__swsetup_r>
8111d3f4:	103ffa1e 	bne	r2,zero,8111d3e0 <__reset+0xfb0fd3e0>
8111d3f8:	8100030b 	ldhu	r4,12(r16)
8111d3fc:	80c00417 	ldw	r3,16(r16)
8111d400:	003fc506 	br	8111d318 <__reset+0xfb0fd318>
8111d404:	111f4fc0 	call	8111f4fc <__sinit>
8111d408:	003fbc06 	br	8111d2fc <__reset+0xfb0fd2fc>

8111d40c <__swbuf>:
8111d40c:	00a04534 	movhi	r2,33044
8111d410:	109aed04 	addi	r2,r2,27572
8111d414:	280d883a 	mov	r6,r5
8111d418:	200b883a 	mov	r5,r4
8111d41c:	11000017 	ldw	r4,0(r2)
8111d420:	111d2c41 	jmpi	8111d2c4 <__swbuf_r>

8111d424 <_write_r>:
8111d424:	defffd04 	addi	sp,sp,-12
8111d428:	de00012e 	bgeu	sp,et,8111d430 <_write_r+0xc>
8111d42c:	003b68fa 	trap	3
8111d430:	2805883a 	mov	r2,r5
8111d434:	dc000015 	stw	r16,0(sp)
8111d438:	04204534 	movhi	r16,33044
8111d43c:	dc400115 	stw	r17,4(sp)
8111d440:	300b883a 	mov	r5,r6
8111d444:	841b5004 	addi	r16,r16,27968
8111d448:	2023883a 	mov	r17,r4
8111d44c:	380d883a 	mov	r6,r7
8111d450:	1009883a 	mov	r4,r2
8111d454:	dfc00215 	stw	ra,8(sp)
8111d458:	80000015 	stw	zero,0(r16)
8111d45c:	112cadc0 	call	8112cadc <write>
8111d460:	00ffffc4 	movi	r3,-1
8111d464:	10c00526 	beq	r2,r3,8111d47c <_write_r+0x58>
8111d468:	dfc00217 	ldw	ra,8(sp)
8111d46c:	dc400117 	ldw	r17,4(sp)
8111d470:	dc000017 	ldw	r16,0(sp)
8111d474:	dec00304 	addi	sp,sp,12
8111d478:	f800283a 	ret
8111d47c:	80c00017 	ldw	r3,0(r16)
8111d480:	183ff926 	beq	r3,zero,8111d468 <__reset+0xfb0fd468>
8111d484:	88c00015 	stw	r3,0(r17)
8111d488:	003ff706 	br	8111d468 <__reset+0xfb0fd468>

8111d48c <__swsetup_r>:
8111d48c:	00a04534 	movhi	r2,33044
8111d490:	defffd04 	addi	sp,sp,-12
8111d494:	109aed04 	addi	r2,r2,27572
8111d498:	de00012e 	bgeu	sp,et,8111d4a0 <__swsetup_r+0x14>
8111d49c:	003b68fa 	trap	3
8111d4a0:	dc400115 	stw	r17,4(sp)
8111d4a4:	2023883a 	mov	r17,r4
8111d4a8:	11000017 	ldw	r4,0(r2)
8111d4ac:	dc000015 	stw	r16,0(sp)
8111d4b0:	dfc00215 	stw	ra,8(sp)
8111d4b4:	2821883a 	mov	r16,r5
8111d4b8:	20000226 	beq	r4,zero,8111d4c4 <__swsetup_r+0x38>
8111d4bc:	20800e17 	ldw	r2,56(r4)
8111d4c0:	10003126 	beq	r2,zero,8111d588 <__swsetup_r+0xfc>
8111d4c4:	8080030b 	ldhu	r2,12(r16)
8111d4c8:	10c0020c 	andi	r3,r2,8
8111d4cc:	1009883a 	mov	r4,r2
8111d4d0:	18000f26 	beq	r3,zero,8111d510 <__swsetup_r+0x84>
8111d4d4:	80c00417 	ldw	r3,16(r16)
8111d4d8:	18001526 	beq	r3,zero,8111d530 <__swsetup_r+0xa4>
8111d4dc:	1100004c 	andi	r4,r2,1
8111d4e0:	20001c1e 	bne	r4,zero,8111d554 <__swsetup_r+0xc8>
8111d4e4:	1080008c 	andi	r2,r2,2
8111d4e8:	1000291e 	bne	r2,zero,8111d590 <__swsetup_r+0x104>
8111d4ec:	80800517 	ldw	r2,20(r16)
8111d4f0:	80800215 	stw	r2,8(r16)
8111d4f4:	18001c26 	beq	r3,zero,8111d568 <__swsetup_r+0xdc>
8111d4f8:	0005883a 	mov	r2,zero
8111d4fc:	dfc00217 	ldw	ra,8(sp)
8111d500:	dc400117 	ldw	r17,4(sp)
8111d504:	dc000017 	ldw	r16,0(sp)
8111d508:	dec00304 	addi	sp,sp,12
8111d50c:	f800283a 	ret
8111d510:	2080040c 	andi	r2,r4,16
8111d514:	10002e26 	beq	r2,zero,8111d5d0 <__swsetup_r+0x144>
8111d518:	2080010c 	andi	r2,r4,4
8111d51c:	10001e1e 	bne	r2,zero,8111d598 <__swsetup_r+0x10c>
8111d520:	80c00417 	ldw	r3,16(r16)
8111d524:	20800214 	ori	r2,r4,8
8111d528:	8080030d 	sth	r2,12(r16)
8111d52c:	183feb1e 	bne	r3,zero,8111d4dc <__reset+0xfb0fd4dc>
8111d530:	1100a00c 	andi	r4,r2,640
8111d534:	01408004 	movi	r5,512
8111d538:	217fe826 	beq	r4,r5,8111d4dc <__reset+0xfb0fd4dc>
8111d53c:	800b883a 	mov	r5,r16
8111d540:	8809883a 	mov	r4,r17
8111d544:	1115d5c0 	call	81115d5c <__smakebuf_r>
8111d548:	8080030b 	ldhu	r2,12(r16)
8111d54c:	80c00417 	ldw	r3,16(r16)
8111d550:	003fe206 	br	8111d4dc <__reset+0xfb0fd4dc>
8111d554:	80800517 	ldw	r2,20(r16)
8111d558:	80000215 	stw	zero,8(r16)
8111d55c:	0085c83a 	sub	r2,zero,r2
8111d560:	80800615 	stw	r2,24(r16)
8111d564:	183fe41e 	bne	r3,zero,8111d4f8 <__reset+0xfb0fd4f8>
8111d568:	80c0030b 	ldhu	r3,12(r16)
8111d56c:	0005883a 	mov	r2,zero
8111d570:	1900200c 	andi	r4,r3,128
8111d574:	203fe126 	beq	r4,zero,8111d4fc <__reset+0xfb0fd4fc>
8111d578:	18c01014 	ori	r3,r3,64
8111d57c:	80c0030d 	sth	r3,12(r16)
8111d580:	00bfffc4 	movi	r2,-1
8111d584:	003fdd06 	br	8111d4fc <__reset+0xfb0fd4fc>
8111d588:	111f4fc0 	call	8111f4fc <__sinit>
8111d58c:	003fcd06 	br	8111d4c4 <__reset+0xfb0fd4c4>
8111d590:	0005883a 	mov	r2,zero
8111d594:	003fd606 	br	8111d4f0 <__reset+0xfb0fd4f0>
8111d598:	81400c17 	ldw	r5,48(r16)
8111d59c:	28000626 	beq	r5,zero,8111d5b8 <__swsetup_r+0x12c>
8111d5a0:	80801004 	addi	r2,r16,64
8111d5a4:	28800326 	beq	r5,r2,8111d5b4 <__swsetup_r+0x128>
8111d5a8:	8809883a 	mov	r4,r17
8111d5ac:	111f9940 	call	8111f994 <_free_r>
8111d5b0:	8100030b 	ldhu	r4,12(r16)
8111d5b4:	80000c15 	stw	zero,48(r16)
8111d5b8:	80c00417 	ldw	r3,16(r16)
8111d5bc:	00bff6c4 	movi	r2,-37
8111d5c0:	1108703a 	and	r4,r2,r4
8111d5c4:	80000115 	stw	zero,4(r16)
8111d5c8:	80c00015 	stw	r3,0(r16)
8111d5cc:	003fd506 	br	8111d524 <__reset+0xfb0fd524>
8111d5d0:	00800244 	movi	r2,9
8111d5d4:	88800015 	stw	r2,0(r17)
8111d5d8:	20801014 	ori	r2,r4,64
8111d5dc:	8080030d 	sth	r2,12(r16)
8111d5e0:	00bfffc4 	movi	r2,-1
8111d5e4:	003fc506 	br	8111d4fc <__reset+0xfb0fd4fc>

8111d5e8 <_close_r>:
8111d5e8:	defffd04 	addi	sp,sp,-12
8111d5ec:	de00012e 	bgeu	sp,et,8111d5f4 <_close_r+0xc>
8111d5f0:	003b68fa 	trap	3
8111d5f4:	dc000015 	stw	r16,0(sp)
8111d5f8:	04204534 	movhi	r16,33044
8111d5fc:	dc400115 	stw	r17,4(sp)
8111d600:	841b5004 	addi	r16,r16,27968
8111d604:	2023883a 	mov	r17,r4
8111d608:	2809883a 	mov	r4,r5
8111d60c:	dfc00215 	stw	ra,8(sp)
8111d610:	80000015 	stw	zero,0(r16)
8111d614:	112b05c0 	call	8112b05c <close>
8111d618:	00ffffc4 	movi	r3,-1
8111d61c:	10c00526 	beq	r2,r3,8111d634 <_close_r+0x4c>
8111d620:	dfc00217 	ldw	ra,8(sp)
8111d624:	dc400117 	ldw	r17,4(sp)
8111d628:	dc000017 	ldw	r16,0(sp)
8111d62c:	dec00304 	addi	sp,sp,12
8111d630:	f800283a 	ret
8111d634:	80c00017 	ldw	r3,0(r16)
8111d638:	183ff926 	beq	r3,zero,8111d620 <__reset+0xfb0fd620>
8111d63c:	88c00015 	stw	r3,0(r17)
8111d640:	003ff706 	br	8111d620 <__reset+0xfb0fd620>

8111d644 <quorem>:
8111d644:	defff704 	addi	sp,sp,-36
8111d648:	de00012e 	bgeu	sp,et,8111d650 <quorem+0xc>
8111d64c:	003b68fa 	trap	3
8111d650:	dc800215 	stw	r18,8(sp)
8111d654:	20800417 	ldw	r2,16(r4)
8111d658:	2c800417 	ldw	r18,16(r5)
8111d65c:	dfc00815 	stw	ra,32(sp)
8111d660:	ddc00715 	stw	r23,28(sp)
8111d664:	dd800615 	stw	r22,24(sp)
8111d668:	dd400515 	stw	r21,20(sp)
8111d66c:	dd000415 	stw	r20,16(sp)
8111d670:	dcc00315 	stw	r19,12(sp)
8111d674:	dc400115 	stw	r17,4(sp)
8111d678:	dc000015 	stw	r16,0(sp)
8111d67c:	14807116 	blt	r2,r18,8111d844 <quorem+0x200>
8111d680:	94bfffc4 	addi	r18,r18,-1
8111d684:	94ad883a 	add	r22,r18,r18
8111d688:	b5ad883a 	add	r22,r22,r22
8111d68c:	2c400504 	addi	r17,r5,20
8111d690:	8da9883a 	add	r20,r17,r22
8111d694:	25400504 	addi	r21,r4,20
8111d698:	282f883a 	mov	r23,r5
8111d69c:	adad883a 	add	r22,r21,r22
8111d6a0:	a1400017 	ldw	r5,0(r20)
8111d6a4:	2021883a 	mov	r16,r4
8111d6a8:	b1000017 	ldw	r4,0(r22)
8111d6ac:	29400044 	addi	r5,r5,1
8111d6b0:	1128d1c0 	call	81128d1c <__udivsi3>
8111d6b4:	1027883a 	mov	r19,r2
8111d6b8:	10002c26 	beq	r2,zero,8111d76c <quorem+0x128>
8111d6bc:	a813883a 	mov	r9,r21
8111d6c0:	880b883a 	mov	r5,r17
8111d6c4:	0009883a 	mov	r4,zero
8111d6c8:	000d883a 	mov	r6,zero
8111d6cc:	2a000017 	ldw	r8,0(r5)
8111d6d0:	49c00017 	ldw	r7,0(r9)
8111d6d4:	29400104 	addi	r5,r5,4
8111d6d8:	40bfffcc 	andi	r2,r8,65535
8111d6dc:	14c5383a 	mul	r2,r2,r19
8111d6e0:	4010d43a 	srli	r8,r8,16
8111d6e4:	38ffffcc 	andi	r3,r7,65535
8111d6e8:	1105883a 	add	r2,r2,r4
8111d6ec:	1008d43a 	srli	r4,r2,16
8111d6f0:	44d1383a 	mul	r8,r8,r19
8111d6f4:	198d883a 	add	r6,r3,r6
8111d6f8:	10ffffcc 	andi	r3,r2,65535
8111d6fc:	30c7c83a 	sub	r3,r6,r3
8111d700:	380ed43a 	srli	r7,r7,16
8111d704:	4105883a 	add	r2,r8,r4
8111d708:	180dd43a 	srai	r6,r3,16
8111d70c:	113fffcc 	andi	r4,r2,65535
8111d710:	390fc83a 	sub	r7,r7,r4
8111d714:	398d883a 	add	r6,r7,r6
8111d718:	300e943a 	slli	r7,r6,16
8111d71c:	18ffffcc 	andi	r3,r3,65535
8111d720:	1008d43a 	srli	r4,r2,16
8111d724:	38ceb03a 	or	r7,r7,r3
8111d728:	49c00015 	stw	r7,0(r9)
8111d72c:	300dd43a 	srai	r6,r6,16
8111d730:	4a400104 	addi	r9,r9,4
8111d734:	a17fe52e 	bgeu	r20,r5,8111d6cc <__reset+0xfb0fd6cc>
8111d738:	b0800017 	ldw	r2,0(r22)
8111d73c:	10000b1e 	bne	r2,zero,8111d76c <quorem+0x128>
8111d740:	b0bfff04 	addi	r2,r22,-4
8111d744:	a880082e 	bgeu	r21,r2,8111d768 <quorem+0x124>
8111d748:	b0ffff17 	ldw	r3,-4(r22)
8111d74c:	18000326 	beq	r3,zero,8111d75c <quorem+0x118>
8111d750:	00000506 	br	8111d768 <quorem+0x124>
8111d754:	10c00017 	ldw	r3,0(r2)
8111d758:	1800031e 	bne	r3,zero,8111d768 <quorem+0x124>
8111d75c:	10bfff04 	addi	r2,r2,-4
8111d760:	94bfffc4 	addi	r18,r18,-1
8111d764:	a8bffb36 	bltu	r21,r2,8111d754 <__reset+0xfb0fd754>
8111d768:	84800415 	stw	r18,16(r16)
8111d76c:	b80b883a 	mov	r5,r23
8111d770:	8009883a 	mov	r4,r16
8111d774:	11212640 	call	81121264 <__mcmp>
8111d778:	10002616 	blt	r2,zero,8111d814 <quorem+0x1d0>
8111d77c:	9cc00044 	addi	r19,r19,1
8111d780:	a805883a 	mov	r2,r21
8111d784:	000b883a 	mov	r5,zero
8111d788:	11000017 	ldw	r4,0(r2)
8111d78c:	89800017 	ldw	r6,0(r17)
8111d790:	10800104 	addi	r2,r2,4
8111d794:	20ffffcc 	andi	r3,r4,65535
8111d798:	194b883a 	add	r5,r3,r5
8111d79c:	30ffffcc 	andi	r3,r6,65535
8111d7a0:	28c7c83a 	sub	r3,r5,r3
8111d7a4:	300cd43a 	srli	r6,r6,16
8111d7a8:	2008d43a 	srli	r4,r4,16
8111d7ac:	180bd43a 	srai	r5,r3,16
8111d7b0:	18ffffcc 	andi	r3,r3,65535
8111d7b4:	2189c83a 	sub	r4,r4,r6
8111d7b8:	2149883a 	add	r4,r4,r5
8111d7bc:	200c943a 	slli	r6,r4,16
8111d7c0:	8c400104 	addi	r17,r17,4
8111d7c4:	200bd43a 	srai	r5,r4,16
8111d7c8:	30c6b03a 	or	r3,r6,r3
8111d7cc:	10ffff15 	stw	r3,-4(r2)
8111d7d0:	a47fed2e 	bgeu	r20,r17,8111d788 <__reset+0xfb0fd788>
8111d7d4:	9485883a 	add	r2,r18,r18
8111d7d8:	1085883a 	add	r2,r2,r2
8111d7dc:	a887883a 	add	r3,r21,r2
8111d7e0:	18800017 	ldw	r2,0(r3)
8111d7e4:	10000b1e 	bne	r2,zero,8111d814 <quorem+0x1d0>
8111d7e8:	18bfff04 	addi	r2,r3,-4
8111d7ec:	a880082e 	bgeu	r21,r2,8111d810 <quorem+0x1cc>
8111d7f0:	18ffff17 	ldw	r3,-4(r3)
8111d7f4:	18000326 	beq	r3,zero,8111d804 <quorem+0x1c0>
8111d7f8:	00000506 	br	8111d810 <quorem+0x1cc>
8111d7fc:	10c00017 	ldw	r3,0(r2)
8111d800:	1800031e 	bne	r3,zero,8111d810 <quorem+0x1cc>
8111d804:	10bfff04 	addi	r2,r2,-4
8111d808:	94bfffc4 	addi	r18,r18,-1
8111d80c:	a8bffb36 	bltu	r21,r2,8111d7fc <__reset+0xfb0fd7fc>
8111d810:	84800415 	stw	r18,16(r16)
8111d814:	9805883a 	mov	r2,r19
8111d818:	dfc00817 	ldw	ra,32(sp)
8111d81c:	ddc00717 	ldw	r23,28(sp)
8111d820:	dd800617 	ldw	r22,24(sp)
8111d824:	dd400517 	ldw	r21,20(sp)
8111d828:	dd000417 	ldw	r20,16(sp)
8111d82c:	dcc00317 	ldw	r19,12(sp)
8111d830:	dc800217 	ldw	r18,8(sp)
8111d834:	dc400117 	ldw	r17,4(sp)
8111d838:	dc000017 	ldw	r16,0(sp)
8111d83c:	dec00904 	addi	sp,sp,36
8111d840:	f800283a 	ret
8111d844:	0005883a 	mov	r2,zero
8111d848:	003ff306 	br	8111d818 <__reset+0xfb0fd818>

8111d84c <_dtoa_r>:
8111d84c:	deffde04 	addi	sp,sp,-136
8111d850:	de00012e 	bgeu	sp,et,8111d858 <_dtoa_r+0xc>
8111d854:	003b68fa 	trap	3
8111d858:	20801017 	ldw	r2,64(r4)
8111d85c:	df002015 	stw	fp,128(sp)
8111d860:	dcc01b15 	stw	r19,108(sp)
8111d864:	dc801a15 	stw	r18,104(sp)
8111d868:	dc401915 	stw	r17,100(sp)
8111d86c:	dc001815 	stw	r16,96(sp)
8111d870:	dfc02115 	stw	ra,132(sp)
8111d874:	ddc01f15 	stw	r23,124(sp)
8111d878:	dd801e15 	stw	r22,120(sp)
8111d87c:	dd401d15 	stw	r21,116(sp)
8111d880:	dd001c15 	stw	r20,112(sp)
8111d884:	d9c00315 	stw	r7,12(sp)
8111d888:	2039883a 	mov	fp,r4
8111d88c:	3023883a 	mov	r17,r6
8111d890:	2825883a 	mov	r18,r5
8111d894:	dc002417 	ldw	r16,144(sp)
8111d898:	3027883a 	mov	r19,r6
8111d89c:	10000826 	beq	r2,zero,8111d8c0 <_dtoa_r+0x74>
8111d8a0:	21801117 	ldw	r6,68(r4)
8111d8a4:	00c00044 	movi	r3,1
8111d8a8:	100b883a 	mov	r5,r2
8111d8ac:	1986983a 	sll	r3,r3,r6
8111d8b0:	11800115 	stw	r6,4(r2)
8111d8b4:	10c00215 	stw	r3,8(r2)
8111d8b8:	1120a140 	call	81120a14 <_Bfree>
8111d8bc:	e0001015 	stw	zero,64(fp)
8111d8c0:	88002e16 	blt	r17,zero,8111d97c <_dtoa_r+0x130>
8111d8c4:	80000015 	stw	zero,0(r16)
8111d8c8:	889ffc2c 	andhi	r2,r17,32752
8111d8cc:	00dffc34 	movhi	r3,32752
8111d8d0:	10c01c26 	beq	r2,r3,8111d944 <_dtoa_r+0xf8>
8111d8d4:	000d883a 	mov	r6,zero
8111d8d8:	000f883a 	mov	r7,zero
8111d8dc:	9009883a 	mov	r4,r18
8111d8e0:	980b883a 	mov	r5,r19
8111d8e4:	112a1780 	call	8112a178 <__eqdf2>
8111d8e8:	10002b1e 	bne	r2,zero,8111d998 <_dtoa_r+0x14c>
8111d8ec:	d9c02317 	ldw	r7,140(sp)
8111d8f0:	00800044 	movi	r2,1
8111d8f4:	38800015 	stw	r2,0(r7)
8111d8f8:	d8802517 	ldw	r2,148(sp)
8111d8fc:	10019e26 	beq	r2,zero,8111df78 <_dtoa_r+0x72c>
8111d900:	d8c02517 	ldw	r3,148(sp)
8111d904:	00a04534 	movhi	r2,33044
8111d908:	10912544 	addi	r2,r2,17557
8111d90c:	18800015 	stw	r2,0(r3)
8111d910:	10bfffc4 	addi	r2,r2,-1
8111d914:	dfc02117 	ldw	ra,132(sp)
8111d918:	df002017 	ldw	fp,128(sp)
8111d91c:	ddc01f17 	ldw	r23,124(sp)
8111d920:	dd801e17 	ldw	r22,120(sp)
8111d924:	dd401d17 	ldw	r21,116(sp)
8111d928:	dd001c17 	ldw	r20,112(sp)
8111d92c:	dcc01b17 	ldw	r19,108(sp)
8111d930:	dc801a17 	ldw	r18,104(sp)
8111d934:	dc401917 	ldw	r17,100(sp)
8111d938:	dc001817 	ldw	r16,96(sp)
8111d93c:	dec02204 	addi	sp,sp,136
8111d940:	f800283a 	ret
8111d944:	d8c02317 	ldw	r3,140(sp)
8111d948:	0089c3c4 	movi	r2,9999
8111d94c:	18800015 	stw	r2,0(r3)
8111d950:	90017726 	beq	r18,zero,8111df30 <_dtoa_r+0x6e4>
8111d954:	00a04534 	movhi	r2,33044
8111d958:	10914304 	addi	r2,r2,17676
8111d95c:	d9002517 	ldw	r4,148(sp)
8111d960:	203fec26 	beq	r4,zero,8111d914 <__reset+0xfb0fd914>
8111d964:	10c000c7 	ldb	r3,3(r2)
8111d968:	1801781e 	bne	r3,zero,8111df4c <_dtoa_r+0x700>
8111d96c:	10c000c4 	addi	r3,r2,3
8111d970:	d9802517 	ldw	r6,148(sp)
8111d974:	30c00015 	stw	r3,0(r6)
8111d978:	003fe606 	br	8111d914 <__reset+0xfb0fd914>
8111d97c:	04e00034 	movhi	r19,32768
8111d980:	9cffffc4 	addi	r19,r19,-1
8111d984:	00800044 	movi	r2,1
8111d988:	8ce6703a 	and	r19,r17,r19
8111d98c:	80800015 	stw	r2,0(r16)
8111d990:	9823883a 	mov	r17,r19
8111d994:	003fcc06 	br	8111d8c8 <__reset+0xfb0fd8c8>
8111d998:	d8800204 	addi	r2,sp,8
8111d99c:	d8800015 	stw	r2,0(sp)
8111d9a0:	d9c00104 	addi	r7,sp,4
8111d9a4:	900b883a 	mov	r5,r18
8111d9a8:	980d883a 	mov	r6,r19
8111d9ac:	e009883a 	mov	r4,fp
8111d9b0:	8820d53a 	srli	r16,r17,20
8111d9b4:	11216400 	call	81121640 <__d2b>
8111d9b8:	d8800915 	stw	r2,36(sp)
8111d9bc:	8001651e 	bne	r16,zero,8111df54 <_dtoa_r+0x708>
8111d9c0:	dd800217 	ldw	r22,8(sp)
8111d9c4:	dc000117 	ldw	r16,4(sp)
8111d9c8:	00800804 	movi	r2,32
8111d9cc:	b421883a 	add	r16,r22,r16
8111d9d0:	80c10c84 	addi	r3,r16,1074
8111d9d4:	10c2d10e 	bge	r2,r3,8111e51c <_dtoa_r+0xcd0>
8111d9d8:	00801004 	movi	r2,64
8111d9dc:	81010484 	addi	r4,r16,1042
8111d9e0:	10c7c83a 	sub	r3,r2,r3
8111d9e4:	9108d83a 	srl	r4,r18,r4
8111d9e8:	88e2983a 	sll	r17,r17,r3
8111d9ec:	2448b03a 	or	r4,r4,r17
8111d9f0:	112ae380 	call	8112ae38 <__floatunsidf>
8111d9f4:	017f8434 	movhi	r5,65040
8111d9f8:	01800044 	movi	r6,1
8111d9fc:	1009883a 	mov	r4,r2
8111da00:	194b883a 	add	r5,r3,r5
8111da04:	843fffc4 	addi	r16,r16,-1
8111da08:	d9801115 	stw	r6,68(sp)
8111da0c:	000d883a 	mov	r6,zero
8111da10:	01cffe34 	movhi	r7,16376
8111da14:	112a3d00 	call	8112a3d0 <__subdf3>
8111da18:	0198dbf4 	movhi	r6,25455
8111da1c:	01cff4f4 	movhi	r7,16339
8111da20:	3190d844 	addi	r6,r6,17249
8111da24:	39e1e9c4 	addi	r7,r7,-30809
8111da28:	1009883a 	mov	r4,r2
8111da2c:	180b883a 	mov	r5,r3
8111da30:	1114ae40 	call	81114ae4 <__muldf3>
8111da34:	01a2d874 	movhi	r6,35681
8111da38:	01cff1f4 	movhi	r7,16327
8111da3c:	31b22cc4 	addi	r6,r6,-14157
8111da40:	39e28a04 	addi	r7,r7,-30168
8111da44:	180b883a 	mov	r5,r3
8111da48:	1009883a 	mov	r4,r2
8111da4c:	1128fd40 	call	81128fd4 <__adddf3>
8111da50:	8009883a 	mov	r4,r16
8111da54:	1029883a 	mov	r20,r2
8111da58:	1823883a 	mov	r17,r3
8111da5c:	112ad540 	call	8112ad54 <__floatsidf>
8111da60:	019427f4 	movhi	r6,20639
8111da64:	01cff4f4 	movhi	r7,16339
8111da68:	319e7ec4 	addi	r6,r6,31227
8111da6c:	39d104c4 	addi	r7,r7,17427
8111da70:	1009883a 	mov	r4,r2
8111da74:	180b883a 	mov	r5,r3
8111da78:	1114ae40 	call	81114ae4 <__muldf3>
8111da7c:	100d883a 	mov	r6,r2
8111da80:	180f883a 	mov	r7,r3
8111da84:	a009883a 	mov	r4,r20
8111da88:	880b883a 	mov	r5,r17
8111da8c:	1128fd40 	call	81128fd4 <__adddf3>
8111da90:	1009883a 	mov	r4,r2
8111da94:	180b883a 	mov	r5,r3
8111da98:	1029883a 	mov	r20,r2
8111da9c:	1823883a 	mov	r17,r3
8111daa0:	112acd40 	call	8112acd4 <__fixdfsi>
8111daa4:	000d883a 	mov	r6,zero
8111daa8:	000f883a 	mov	r7,zero
8111daac:	a009883a 	mov	r4,r20
8111dab0:	880b883a 	mov	r5,r17
8111dab4:	d8800515 	stw	r2,20(sp)
8111dab8:	112a2dc0 	call	8112a2dc <__ledf2>
8111dabc:	10028716 	blt	r2,zero,8111e4dc <_dtoa_r+0xc90>
8111dac0:	d8c00517 	ldw	r3,20(sp)
8111dac4:	00800584 	movi	r2,22
8111dac8:	10c27536 	bltu	r2,r3,8111e4a0 <_dtoa_r+0xc54>
8111dacc:	180490fa 	slli	r2,r3,3
8111dad0:	00e04534 	movhi	r3,33044
8111dad4:	18d15e04 	addi	r3,r3,17784
8111dad8:	1885883a 	add	r2,r3,r2
8111dadc:	11000017 	ldw	r4,0(r2)
8111dae0:	11400117 	ldw	r5,4(r2)
8111dae4:	900d883a 	mov	r6,r18
8111dae8:	980f883a 	mov	r7,r19
8111daec:	112a2000 	call	8112a200 <__gedf2>
8111daf0:	00828d0e 	bge	zero,r2,8111e528 <_dtoa_r+0xcdc>
8111daf4:	d9000517 	ldw	r4,20(sp)
8111daf8:	d8000e15 	stw	zero,56(sp)
8111dafc:	213fffc4 	addi	r4,r4,-1
8111db00:	d9000515 	stw	r4,20(sp)
8111db04:	b42dc83a 	sub	r22,r22,r16
8111db08:	b5bfffc4 	addi	r22,r22,-1
8111db0c:	b0026f16 	blt	r22,zero,8111e4cc <_dtoa_r+0xc80>
8111db10:	d8000815 	stw	zero,32(sp)
8111db14:	d9c00517 	ldw	r7,20(sp)
8111db18:	38026416 	blt	r7,zero,8111e4ac <_dtoa_r+0xc60>
8111db1c:	b1ed883a 	add	r22,r22,r7
8111db20:	d9c00d15 	stw	r7,52(sp)
8111db24:	d8000a15 	stw	zero,40(sp)
8111db28:	d9800317 	ldw	r6,12(sp)
8111db2c:	00800244 	movi	r2,9
8111db30:	11811436 	bltu	r2,r6,8111df84 <_dtoa_r+0x738>
8111db34:	00800144 	movi	r2,5
8111db38:	1184e10e 	bge	r2,r6,8111eec0 <_dtoa_r+0x1674>
8111db3c:	31bfff04 	addi	r6,r6,-4
8111db40:	d9800315 	stw	r6,12(sp)
8111db44:	0023883a 	mov	r17,zero
8111db48:	d9800317 	ldw	r6,12(sp)
8111db4c:	008000c4 	movi	r2,3
8111db50:	30836726 	beq	r6,r2,8111e8f0 <_dtoa_r+0x10a4>
8111db54:	1183410e 	bge	r2,r6,8111e85c <_dtoa_r+0x1010>
8111db58:	d9c00317 	ldw	r7,12(sp)
8111db5c:	00800104 	movi	r2,4
8111db60:	38827c26 	beq	r7,r2,8111e554 <_dtoa_r+0xd08>
8111db64:	00800144 	movi	r2,5
8111db68:	3884c41e 	bne	r7,r2,8111ee7c <_dtoa_r+0x1630>
8111db6c:	00800044 	movi	r2,1
8111db70:	d8800b15 	stw	r2,44(sp)
8111db74:	d8c00517 	ldw	r3,20(sp)
8111db78:	d9002217 	ldw	r4,136(sp)
8111db7c:	1907883a 	add	r3,r3,r4
8111db80:	19800044 	addi	r6,r3,1
8111db84:	d8c00c15 	stw	r3,48(sp)
8111db88:	d9800615 	stw	r6,24(sp)
8111db8c:	0183a40e 	bge	zero,r6,8111ea20 <_dtoa_r+0x11d4>
8111db90:	d9800617 	ldw	r6,24(sp)
8111db94:	3021883a 	mov	r16,r6
8111db98:	e0001115 	stw	zero,68(fp)
8111db9c:	008005c4 	movi	r2,23
8111dba0:	1184c92e 	bgeu	r2,r6,8111eec8 <_dtoa_r+0x167c>
8111dba4:	00c00044 	movi	r3,1
8111dba8:	00800104 	movi	r2,4
8111dbac:	1085883a 	add	r2,r2,r2
8111dbb0:	11000504 	addi	r4,r2,20
8111dbb4:	180b883a 	mov	r5,r3
8111dbb8:	18c00044 	addi	r3,r3,1
8111dbbc:	313ffb2e 	bgeu	r6,r4,8111dbac <__reset+0xfb0fdbac>
8111dbc0:	e1401115 	stw	r5,68(fp)
8111dbc4:	e009883a 	mov	r4,fp
8111dbc8:	11209640 	call	81120964 <_Balloc>
8111dbcc:	d8800715 	stw	r2,28(sp)
8111dbd0:	e0801015 	stw	r2,64(fp)
8111dbd4:	00800384 	movi	r2,14
8111dbd8:	1400f736 	bltu	r2,r16,8111dfb8 <_dtoa_r+0x76c>
8111dbdc:	8800f626 	beq	r17,zero,8111dfb8 <_dtoa_r+0x76c>
8111dbe0:	d9c00517 	ldw	r7,20(sp)
8111dbe4:	01c39a0e 	bge	zero,r7,8111ea50 <_dtoa_r+0x1204>
8111dbe8:	388003cc 	andi	r2,r7,15
8111dbec:	100490fa 	slli	r2,r2,3
8111dbf0:	382bd13a 	srai	r21,r7,4
8111dbf4:	00e04534 	movhi	r3,33044
8111dbf8:	18d15e04 	addi	r3,r3,17784
8111dbfc:	1885883a 	add	r2,r3,r2
8111dc00:	a8c0040c 	andi	r3,r21,16
8111dc04:	12400017 	ldw	r9,0(r2)
8111dc08:	12000117 	ldw	r8,4(r2)
8111dc0c:	18037926 	beq	r3,zero,8111e9f4 <_dtoa_r+0x11a8>
8111dc10:	00a04534 	movhi	r2,33044
8111dc14:	10915404 	addi	r2,r2,17744
8111dc18:	11800817 	ldw	r6,32(r2)
8111dc1c:	11c00917 	ldw	r7,36(r2)
8111dc20:	9009883a 	mov	r4,r18
8111dc24:	980b883a 	mov	r5,r19
8111dc28:	da001715 	stw	r8,92(sp)
8111dc2c:	da401615 	stw	r9,88(sp)
8111dc30:	11298880 	call	81129888 <__divdf3>
8111dc34:	da001717 	ldw	r8,92(sp)
8111dc38:	da401617 	ldw	r9,88(sp)
8111dc3c:	ad4003cc 	andi	r21,r21,15
8111dc40:	040000c4 	movi	r16,3
8111dc44:	1023883a 	mov	r17,r2
8111dc48:	1829883a 	mov	r20,r3
8111dc4c:	a8001126 	beq	r21,zero,8111dc94 <_dtoa_r+0x448>
8111dc50:	05e04534 	movhi	r23,33044
8111dc54:	bdd15404 	addi	r23,r23,17744
8111dc58:	4805883a 	mov	r2,r9
8111dc5c:	4007883a 	mov	r3,r8
8111dc60:	a980004c 	andi	r6,r21,1
8111dc64:	1009883a 	mov	r4,r2
8111dc68:	a82bd07a 	srai	r21,r21,1
8111dc6c:	180b883a 	mov	r5,r3
8111dc70:	30000426 	beq	r6,zero,8111dc84 <_dtoa_r+0x438>
8111dc74:	b9800017 	ldw	r6,0(r23)
8111dc78:	b9c00117 	ldw	r7,4(r23)
8111dc7c:	84000044 	addi	r16,r16,1
8111dc80:	1114ae40 	call	81114ae4 <__muldf3>
8111dc84:	bdc00204 	addi	r23,r23,8
8111dc88:	a83ff51e 	bne	r21,zero,8111dc60 <__reset+0xfb0fdc60>
8111dc8c:	1013883a 	mov	r9,r2
8111dc90:	1811883a 	mov	r8,r3
8111dc94:	480d883a 	mov	r6,r9
8111dc98:	400f883a 	mov	r7,r8
8111dc9c:	8809883a 	mov	r4,r17
8111dca0:	a00b883a 	mov	r5,r20
8111dca4:	11298880 	call	81129888 <__divdf3>
8111dca8:	d8800f15 	stw	r2,60(sp)
8111dcac:	d8c01015 	stw	r3,64(sp)
8111dcb0:	d8c00e17 	ldw	r3,56(sp)
8111dcb4:	18000626 	beq	r3,zero,8111dcd0 <_dtoa_r+0x484>
8111dcb8:	d9000f17 	ldw	r4,60(sp)
8111dcbc:	d9401017 	ldw	r5,64(sp)
8111dcc0:	000d883a 	mov	r6,zero
8111dcc4:	01cffc34 	movhi	r7,16368
8111dcc8:	112a2dc0 	call	8112a2dc <__ledf2>
8111dccc:	10040b16 	blt	r2,zero,8111ecfc <_dtoa_r+0x14b0>
8111dcd0:	8009883a 	mov	r4,r16
8111dcd4:	112ad540 	call	8112ad54 <__floatsidf>
8111dcd8:	d9800f17 	ldw	r6,60(sp)
8111dcdc:	d9c01017 	ldw	r7,64(sp)
8111dce0:	1009883a 	mov	r4,r2
8111dce4:	180b883a 	mov	r5,r3
8111dce8:	1114ae40 	call	81114ae4 <__muldf3>
8111dcec:	000d883a 	mov	r6,zero
8111dcf0:	01d00734 	movhi	r7,16412
8111dcf4:	1009883a 	mov	r4,r2
8111dcf8:	180b883a 	mov	r5,r3
8111dcfc:	1128fd40 	call	81128fd4 <__adddf3>
8111dd00:	1021883a 	mov	r16,r2
8111dd04:	d8800617 	ldw	r2,24(sp)
8111dd08:	047f3034 	movhi	r17,64704
8111dd0c:	1c63883a 	add	r17,r3,r17
8111dd10:	10031826 	beq	r2,zero,8111e974 <_dtoa_r+0x1128>
8111dd14:	d8c00517 	ldw	r3,20(sp)
8111dd18:	db000617 	ldw	r12,24(sp)
8111dd1c:	d8c01315 	stw	r3,76(sp)
8111dd20:	d9000b17 	ldw	r4,44(sp)
8111dd24:	20038f26 	beq	r4,zero,8111eb64 <_dtoa_r+0x1318>
8111dd28:	60bfffc4 	addi	r2,r12,-1
8111dd2c:	100490fa 	slli	r2,r2,3
8111dd30:	00e04534 	movhi	r3,33044
8111dd34:	18d15e04 	addi	r3,r3,17784
8111dd38:	1885883a 	add	r2,r3,r2
8111dd3c:	11800017 	ldw	r6,0(r2)
8111dd40:	11c00117 	ldw	r7,4(r2)
8111dd44:	d8800717 	ldw	r2,28(sp)
8111dd48:	0009883a 	mov	r4,zero
8111dd4c:	014ff834 	movhi	r5,16352
8111dd50:	db001615 	stw	r12,88(sp)
8111dd54:	15c00044 	addi	r23,r2,1
8111dd58:	11298880 	call	81129888 <__divdf3>
8111dd5c:	800d883a 	mov	r6,r16
8111dd60:	880f883a 	mov	r7,r17
8111dd64:	1009883a 	mov	r4,r2
8111dd68:	180b883a 	mov	r5,r3
8111dd6c:	112a3d00 	call	8112a3d0 <__subdf3>
8111dd70:	d9401017 	ldw	r5,64(sp)
8111dd74:	d9000f17 	ldw	r4,60(sp)
8111dd78:	102b883a 	mov	r21,r2
8111dd7c:	d8c01215 	stw	r3,72(sp)
8111dd80:	112acd40 	call	8112acd4 <__fixdfsi>
8111dd84:	1009883a 	mov	r4,r2
8111dd88:	1029883a 	mov	r20,r2
8111dd8c:	112ad540 	call	8112ad54 <__floatsidf>
8111dd90:	d9000f17 	ldw	r4,60(sp)
8111dd94:	d9401017 	ldw	r5,64(sp)
8111dd98:	100d883a 	mov	r6,r2
8111dd9c:	180f883a 	mov	r7,r3
8111dda0:	112a3d00 	call	8112a3d0 <__subdf3>
8111dda4:	1823883a 	mov	r17,r3
8111dda8:	d8c00717 	ldw	r3,28(sp)
8111ddac:	d9401217 	ldw	r5,72(sp)
8111ddb0:	a2000c04 	addi	r8,r20,48
8111ddb4:	1021883a 	mov	r16,r2
8111ddb8:	1a000005 	stb	r8,0(r3)
8111ddbc:	800d883a 	mov	r6,r16
8111ddc0:	880f883a 	mov	r7,r17
8111ddc4:	a809883a 	mov	r4,r21
8111ddc8:	4029883a 	mov	r20,r8
8111ddcc:	112a2000 	call	8112a200 <__gedf2>
8111ddd0:	00841d16 	blt	zero,r2,8111ee48 <_dtoa_r+0x15fc>
8111ddd4:	800d883a 	mov	r6,r16
8111ddd8:	880f883a 	mov	r7,r17
8111dddc:	0009883a 	mov	r4,zero
8111dde0:	014ffc34 	movhi	r5,16368
8111dde4:	112a3d00 	call	8112a3d0 <__subdf3>
8111dde8:	d9401217 	ldw	r5,72(sp)
8111ddec:	100d883a 	mov	r6,r2
8111ddf0:	180f883a 	mov	r7,r3
8111ddf4:	a809883a 	mov	r4,r21
8111ddf8:	112a2000 	call	8112a200 <__gedf2>
8111ddfc:	db001617 	ldw	r12,88(sp)
8111de00:	00840e16 	blt	zero,r2,8111ee3c <_dtoa_r+0x15f0>
8111de04:	00800044 	movi	r2,1
8111de08:	13006b0e 	bge	r2,r12,8111dfb8 <_dtoa_r+0x76c>
8111de0c:	d9000717 	ldw	r4,28(sp)
8111de10:	dd800f15 	stw	r22,60(sp)
8111de14:	dcc01015 	stw	r19,64(sp)
8111de18:	2319883a 	add	r12,r4,r12
8111de1c:	dcc01217 	ldw	r19,72(sp)
8111de20:	602d883a 	mov	r22,r12
8111de24:	dc801215 	stw	r18,72(sp)
8111de28:	b825883a 	mov	r18,r23
8111de2c:	00000906 	br	8111de54 <_dtoa_r+0x608>
8111de30:	112a3d00 	call	8112a3d0 <__subdf3>
8111de34:	a80d883a 	mov	r6,r21
8111de38:	980f883a 	mov	r7,r19
8111de3c:	1009883a 	mov	r4,r2
8111de40:	180b883a 	mov	r5,r3
8111de44:	112a2dc0 	call	8112a2dc <__ledf2>
8111de48:	1003e816 	blt	r2,zero,8111edec <_dtoa_r+0x15a0>
8111de4c:	b825883a 	mov	r18,r23
8111de50:	bd83e926 	beq	r23,r22,8111edf8 <_dtoa_r+0x15ac>
8111de54:	a809883a 	mov	r4,r21
8111de58:	980b883a 	mov	r5,r19
8111de5c:	000d883a 	mov	r6,zero
8111de60:	01d00934 	movhi	r7,16420
8111de64:	1114ae40 	call	81114ae4 <__muldf3>
8111de68:	000d883a 	mov	r6,zero
8111de6c:	01d00934 	movhi	r7,16420
8111de70:	8009883a 	mov	r4,r16
8111de74:	880b883a 	mov	r5,r17
8111de78:	102b883a 	mov	r21,r2
8111de7c:	1827883a 	mov	r19,r3
8111de80:	1114ae40 	call	81114ae4 <__muldf3>
8111de84:	180b883a 	mov	r5,r3
8111de88:	1009883a 	mov	r4,r2
8111de8c:	1821883a 	mov	r16,r3
8111de90:	1023883a 	mov	r17,r2
8111de94:	112acd40 	call	8112acd4 <__fixdfsi>
8111de98:	1009883a 	mov	r4,r2
8111de9c:	1029883a 	mov	r20,r2
8111dea0:	112ad540 	call	8112ad54 <__floatsidf>
8111dea4:	8809883a 	mov	r4,r17
8111dea8:	800b883a 	mov	r5,r16
8111deac:	100d883a 	mov	r6,r2
8111deb0:	180f883a 	mov	r7,r3
8111deb4:	112a3d00 	call	8112a3d0 <__subdf3>
8111deb8:	a5000c04 	addi	r20,r20,48
8111debc:	a80d883a 	mov	r6,r21
8111dec0:	980f883a 	mov	r7,r19
8111dec4:	1009883a 	mov	r4,r2
8111dec8:	180b883a 	mov	r5,r3
8111decc:	95000005 	stb	r20,0(r18)
8111ded0:	1021883a 	mov	r16,r2
8111ded4:	1823883a 	mov	r17,r3
8111ded8:	112a2dc0 	call	8112a2dc <__ledf2>
8111dedc:	bdc00044 	addi	r23,r23,1
8111dee0:	800d883a 	mov	r6,r16
8111dee4:	880f883a 	mov	r7,r17
8111dee8:	0009883a 	mov	r4,zero
8111deec:	014ffc34 	movhi	r5,16368
8111def0:	103fcf0e 	bge	r2,zero,8111de30 <__reset+0xfb0fde30>
8111def4:	d8c01317 	ldw	r3,76(sp)
8111def8:	d8c00515 	stw	r3,20(sp)
8111defc:	d9400917 	ldw	r5,36(sp)
8111df00:	e009883a 	mov	r4,fp
8111df04:	1120a140 	call	81120a14 <_Bfree>
8111df08:	d9000517 	ldw	r4,20(sp)
8111df0c:	d9802317 	ldw	r6,140(sp)
8111df10:	d9c02517 	ldw	r7,148(sp)
8111df14:	b8000005 	stb	zero,0(r23)
8111df18:	20800044 	addi	r2,r4,1
8111df1c:	30800015 	stw	r2,0(r6)
8111df20:	3802aa26 	beq	r7,zero,8111e9cc <_dtoa_r+0x1180>
8111df24:	3dc00015 	stw	r23,0(r7)
8111df28:	d8800717 	ldw	r2,28(sp)
8111df2c:	003e7906 	br	8111d914 <__reset+0xfb0fd914>
8111df30:	00800434 	movhi	r2,16
8111df34:	10bfffc4 	addi	r2,r2,-1
8111df38:	88a2703a 	and	r17,r17,r2
8111df3c:	883e851e 	bne	r17,zero,8111d954 <__reset+0xfb0fd954>
8111df40:	00a04534 	movhi	r2,33044
8111df44:	10914004 	addi	r2,r2,17664
8111df48:	003e8406 	br	8111d95c <__reset+0xfb0fd95c>
8111df4c:	10c00204 	addi	r3,r2,8
8111df50:	003e8706 	br	8111d970 <__reset+0xfb0fd970>
8111df54:	01400434 	movhi	r5,16
8111df58:	297fffc4 	addi	r5,r5,-1
8111df5c:	994a703a 	and	r5,r19,r5
8111df60:	9009883a 	mov	r4,r18
8111df64:	843f0044 	addi	r16,r16,-1023
8111df68:	294ffc34 	orhi	r5,r5,16368
8111df6c:	dd800217 	ldw	r22,8(sp)
8111df70:	d8001115 	stw	zero,68(sp)
8111df74:	003ea506 	br	8111da0c <__reset+0xfb0fda0c>
8111df78:	00a04534 	movhi	r2,33044
8111df7c:	10912504 	addi	r2,r2,17556
8111df80:	003e6406 	br	8111d914 <__reset+0xfb0fd914>
8111df84:	e0001115 	stw	zero,68(fp)
8111df88:	000b883a 	mov	r5,zero
8111df8c:	e009883a 	mov	r4,fp
8111df90:	11209640 	call	81120964 <_Balloc>
8111df94:	01bfffc4 	movi	r6,-1
8111df98:	01c00044 	movi	r7,1
8111df9c:	d8800715 	stw	r2,28(sp)
8111dfa0:	d9800c15 	stw	r6,48(sp)
8111dfa4:	e0801015 	stw	r2,64(fp)
8111dfa8:	d8000315 	stw	zero,12(sp)
8111dfac:	d9c00b15 	stw	r7,44(sp)
8111dfb0:	d9800615 	stw	r6,24(sp)
8111dfb4:	d8002215 	stw	zero,136(sp)
8111dfb8:	d8800117 	ldw	r2,4(sp)
8111dfbc:	10008916 	blt	r2,zero,8111e1e4 <_dtoa_r+0x998>
8111dfc0:	d9000517 	ldw	r4,20(sp)
8111dfc4:	00c00384 	movi	r3,14
8111dfc8:	19008616 	blt	r3,r4,8111e1e4 <_dtoa_r+0x998>
8111dfcc:	200490fa 	slli	r2,r4,3
8111dfd0:	00e04534 	movhi	r3,33044
8111dfd4:	d9802217 	ldw	r6,136(sp)
8111dfd8:	18d15e04 	addi	r3,r3,17784
8111dfdc:	1885883a 	add	r2,r3,r2
8111dfe0:	14000017 	ldw	r16,0(r2)
8111dfe4:	14400117 	ldw	r17,4(r2)
8111dfe8:	30016316 	blt	r6,zero,8111e578 <_dtoa_r+0xd2c>
8111dfec:	800d883a 	mov	r6,r16
8111dff0:	880f883a 	mov	r7,r17
8111dff4:	9009883a 	mov	r4,r18
8111dff8:	980b883a 	mov	r5,r19
8111dffc:	11298880 	call	81129888 <__divdf3>
8111e000:	180b883a 	mov	r5,r3
8111e004:	1009883a 	mov	r4,r2
8111e008:	112acd40 	call	8112acd4 <__fixdfsi>
8111e00c:	1009883a 	mov	r4,r2
8111e010:	102b883a 	mov	r21,r2
8111e014:	112ad540 	call	8112ad54 <__floatsidf>
8111e018:	800d883a 	mov	r6,r16
8111e01c:	880f883a 	mov	r7,r17
8111e020:	1009883a 	mov	r4,r2
8111e024:	180b883a 	mov	r5,r3
8111e028:	1114ae40 	call	81114ae4 <__muldf3>
8111e02c:	100d883a 	mov	r6,r2
8111e030:	180f883a 	mov	r7,r3
8111e034:	9009883a 	mov	r4,r18
8111e038:	980b883a 	mov	r5,r19
8111e03c:	112a3d00 	call	8112a3d0 <__subdf3>
8111e040:	d9c00717 	ldw	r7,28(sp)
8111e044:	1009883a 	mov	r4,r2
8111e048:	a8800c04 	addi	r2,r21,48
8111e04c:	38800005 	stb	r2,0(r7)
8111e050:	3dc00044 	addi	r23,r7,1
8111e054:	d9c00617 	ldw	r7,24(sp)
8111e058:	01800044 	movi	r6,1
8111e05c:	180b883a 	mov	r5,r3
8111e060:	2005883a 	mov	r2,r4
8111e064:	39803826 	beq	r7,r6,8111e148 <_dtoa_r+0x8fc>
8111e068:	000d883a 	mov	r6,zero
8111e06c:	01d00934 	movhi	r7,16420
8111e070:	1114ae40 	call	81114ae4 <__muldf3>
8111e074:	000d883a 	mov	r6,zero
8111e078:	000f883a 	mov	r7,zero
8111e07c:	1009883a 	mov	r4,r2
8111e080:	180b883a 	mov	r5,r3
8111e084:	1025883a 	mov	r18,r2
8111e088:	1827883a 	mov	r19,r3
8111e08c:	112a1780 	call	8112a178 <__eqdf2>
8111e090:	103f9a26 	beq	r2,zero,8111defc <__reset+0xfb0fdefc>
8111e094:	d9c00617 	ldw	r7,24(sp)
8111e098:	d8c00717 	ldw	r3,28(sp)
8111e09c:	b829883a 	mov	r20,r23
8111e0a0:	38bfffc4 	addi	r2,r7,-1
8111e0a4:	18ad883a 	add	r22,r3,r2
8111e0a8:	00000a06 	br	8111e0d4 <_dtoa_r+0x888>
8111e0ac:	1114ae40 	call	81114ae4 <__muldf3>
8111e0b0:	000d883a 	mov	r6,zero
8111e0b4:	000f883a 	mov	r7,zero
8111e0b8:	1009883a 	mov	r4,r2
8111e0bc:	180b883a 	mov	r5,r3
8111e0c0:	1025883a 	mov	r18,r2
8111e0c4:	1827883a 	mov	r19,r3
8111e0c8:	b829883a 	mov	r20,r23
8111e0cc:	112a1780 	call	8112a178 <__eqdf2>
8111e0d0:	103f8a26 	beq	r2,zero,8111defc <__reset+0xfb0fdefc>
8111e0d4:	800d883a 	mov	r6,r16
8111e0d8:	880f883a 	mov	r7,r17
8111e0dc:	9009883a 	mov	r4,r18
8111e0e0:	980b883a 	mov	r5,r19
8111e0e4:	11298880 	call	81129888 <__divdf3>
8111e0e8:	180b883a 	mov	r5,r3
8111e0ec:	1009883a 	mov	r4,r2
8111e0f0:	112acd40 	call	8112acd4 <__fixdfsi>
8111e0f4:	1009883a 	mov	r4,r2
8111e0f8:	102b883a 	mov	r21,r2
8111e0fc:	112ad540 	call	8112ad54 <__floatsidf>
8111e100:	800d883a 	mov	r6,r16
8111e104:	880f883a 	mov	r7,r17
8111e108:	1009883a 	mov	r4,r2
8111e10c:	180b883a 	mov	r5,r3
8111e110:	1114ae40 	call	81114ae4 <__muldf3>
8111e114:	100d883a 	mov	r6,r2
8111e118:	180f883a 	mov	r7,r3
8111e11c:	9009883a 	mov	r4,r18
8111e120:	980b883a 	mov	r5,r19
8111e124:	112a3d00 	call	8112a3d0 <__subdf3>
8111e128:	aa000c04 	addi	r8,r21,48
8111e12c:	a2000005 	stb	r8,0(r20)
8111e130:	000d883a 	mov	r6,zero
8111e134:	01d00934 	movhi	r7,16420
8111e138:	1009883a 	mov	r4,r2
8111e13c:	180b883a 	mov	r5,r3
8111e140:	a5c00044 	addi	r23,r20,1
8111e144:	b53fd91e 	bne	r22,r20,8111e0ac <__reset+0xfb0fe0ac>
8111e148:	100d883a 	mov	r6,r2
8111e14c:	180f883a 	mov	r7,r3
8111e150:	1009883a 	mov	r4,r2
8111e154:	180b883a 	mov	r5,r3
8111e158:	1128fd40 	call	81128fd4 <__adddf3>
8111e15c:	100d883a 	mov	r6,r2
8111e160:	180f883a 	mov	r7,r3
8111e164:	8009883a 	mov	r4,r16
8111e168:	880b883a 	mov	r5,r17
8111e16c:	1027883a 	mov	r19,r2
8111e170:	1825883a 	mov	r18,r3
8111e174:	112a2dc0 	call	8112a2dc <__ledf2>
8111e178:	10000816 	blt	r2,zero,8111e19c <_dtoa_r+0x950>
8111e17c:	980d883a 	mov	r6,r19
8111e180:	900f883a 	mov	r7,r18
8111e184:	8009883a 	mov	r4,r16
8111e188:	880b883a 	mov	r5,r17
8111e18c:	112a1780 	call	8112a178 <__eqdf2>
8111e190:	103f5a1e 	bne	r2,zero,8111defc <__reset+0xfb0fdefc>
8111e194:	ad40004c 	andi	r21,r21,1
8111e198:	a83f5826 	beq	r21,zero,8111defc <__reset+0xfb0fdefc>
8111e19c:	bd3fffc3 	ldbu	r20,-1(r23)
8111e1a0:	b8bfffc4 	addi	r2,r23,-1
8111e1a4:	1007883a 	mov	r3,r2
8111e1a8:	01400e44 	movi	r5,57
8111e1ac:	d9800717 	ldw	r6,28(sp)
8111e1b0:	00000506 	br	8111e1c8 <_dtoa_r+0x97c>
8111e1b4:	18ffffc4 	addi	r3,r3,-1
8111e1b8:	11824726 	beq	r2,r6,8111ead8 <_dtoa_r+0x128c>
8111e1bc:	1d000003 	ldbu	r20,0(r3)
8111e1c0:	102f883a 	mov	r23,r2
8111e1c4:	10bfffc4 	addi	r2,r2,-1
8111e1c8:	a1003fcc 	andi	r4,r20,255
8111e1cc:	2100201c 	xori	r4,r4,128
8111e1d0:	213fe004 	addi	r4,r4,-128
8111e1d4:	217ff726 	beq	r4,r5,8111e1b4 <__reset+0xfb0fe1b4>
8111e1d8:	a2000044 	addi	r8,r20,1
8111e1dc:	12000005 	stb	r8,0(r2)
8111e1e0:	003f4606 	br	8111defc <__reset+0xfb0fdefc>
8111e1e4:	d9000b17 	ldw	r4,44(sp)
8111e1e8:	2000c826 	beq	r4,zero,8111e50c <_dtoa_r+0xcc0>
8111e1ec:	d9800317 	ldw	r6,12(sp)
8111e1f0:	00c00044 	movi	r3,1
8111e1f4:	1980f90e 	bge	r3,r6,8111e5dc <_dtoa_r+0xd90>
8111e1f8:	d8800617 	ldw	r2,24(sp)
8111e1fc:	d8c00a17 	ldw	r3,40(sp)
8111e200:	157fffc4 	addi	r21,r2,-1
8111e204:	1d41f316 	blt	r3,r21,8111e9d4 <_dtoa_r+0x1188>
8111e208:	1d6bc83a 	sub	r21,r3,r21
8111e20c:	d9c00617 	ldw	r7,24(sp)
8111e210:	3802aa16 	blt	r7,zero,8111ecbc <_dtoa_r+0x1470>
8111e214:	dd000817 	ldw	r20,32(sp)
8111e218:	d8800617 	ldw	r2,24(sp)
8111e21c:	d8c00817 	ldw	r3,32(sp)
8111e220:	01400044 	movi	r5,1
8111e224:	e009883a 	mov	r4,fp
8111e228:	1887883a 	add	r3,r3,r2
8111e22c:	d8c00815 	stw	r3,32(sp)
8111e230:	b0ad883a 	add	r22,r22,r2
8111e234:	1120d880 	call	81120d88 <__i2b>
8111e238:	1023883a 	mov	r17,r2
8111e23c:	a0000826 	beq	r20,zero,8111e260 <_dtoa_r+0xa14>
8111e240:	0580070e 	bge	zero,r22,8111e260 <_dtoa_r+0xa14>
8111e244:	a005883a 	mov	r2,r20
8111e248:	b500b916 	blt	r22,r20,8111e530 <_dtoa_r+0xce4>
8111e24c:	d9000817 	ldw	r4,32(sp)
8111e250:	a0a9c83a 	sub	r20,r20,r2
8111e254:	b0adc83a 	sub	r22,r22,r2
8111e258:	2089c83a 	sub	r4,r4,r2
8111e25c:	d9000815 	stw	r4,32(sp)
8111e260:	d9800a17 	ldw	r6,40(sp)
8111e264:	0181810e 	bge	zero,r6,8111e86c <_dtoa_r+0x1020>
8111e268:	d9c00b17 	ldw	r7,44(sp)
8111e26c:	3800b326 	beq	r7,zero,8111e53c <_dtoa_r+0xcf0>
8111e270:	a800b226 	beq	r21,zero,8111e53c <_dtoa_r+0xcf0>
8111e274:	880b883a 	mov	r5,r17
8111e278:	a80d883a 	mov	r6,r21
8111e27c:	e009883a 	mov	r4,fp
8111e280:	1120fcc0 	call	81120fcc <__pow5mult>
8111e284:	d9800917 	ldw	r6,36(sp)
8111e288:	100b883a 	mov	r5,r2
8111e28c:	e009883a 	mov	r4,fp
8111e290:	1023883a 	mov	r17,r2
8111e294:	1120dcc0 	call	81120dcc <__multiply>
8111e298:	1021883a 	mov	r16,r2
8111e29c:	d8800a17 	ldw	r2,40(sp)
8111e2a0:	d9400917 	ldw	r5,36(sp)
8111e2a4:	e009883a 	mov	r4,fp
8111e2a8:	1545c83a 	sub	r2,r2,r21
8111e2ac:	d8800a15 	stw	r2,40(sp)
8111e2b0:	1120a140 	call	81120a14 <_Bfree>
8111e2b4:	d8c00a17 	ldw	r3,40(sp)
8111e2b8:	18009f1e 	bne	r3,zero,8111e538 <_dtoa_r+0xcec>
8111e2bc:	05c00044 	movi	r23,1
8111e2c0:	e009883a 	mov	r4,fp
8111e2c4:	b80b883a 	mov	r5,r23
8111e2c8:	1120d880 	call	81120d88 <__i2b>
8111e2cc:	d9000d17 	ldw	r4,52(sp)
8111e2d0:	102b883a 	mov	r21,r2
8111e2d4:	2000ce26 	beq	r4,zero,8111e610 <_dtoa_r+0xdc4>
8111e2d8:	200d883a 	mov	r6,r4
8111e2dc:	100b883a 	mov	r5,r2
8111e2e0:	e009883a 	mov	r4,fp
8111e2e4:	1120fcc0 	call	81120fcc <__pow5mult>
8111e2e8:	d9800317 	ldw	r6,12(sp)
8111e2ec:	102b883a 	mov	r21,r2
8111e2f0:	b981810e 	bge	r23,r6,8111e8f8 <_dtoa_r+0x10ac>
8111e2f4:	0027883a 	mov	r19,zero
8111e2f8:	a8800417 	ldw	r2,16(r21)
8111e2fc:	05c00804 	movi	r23,32
8111e300:	10800104 	addi	r2,r2,4
8111e304:	1085883a 	add	r2,r2,r2
8111e308:	1085883a 	add	r2,r2,r2
8111e30c:	a885883a 	add	r2,r21,r2
8111e310:	11000017 	ldw	r4,0(r2)
8111e314:	1120c700 	call	81120c70 <__hi0bits>
8111e318:	b885c83a 	sub	r2,r23,r2
8111e31c:	1585883a 	add	r2,r2,r22
8111e320:	108007cc 	andi	r2,r2,31
8111e324:	1000b326 	beq	r2,zero,8111e5f4 <_dtoa_r+0xda8>
8111e328:	00c00804 	movi	r3,32
8111e32c:	1887c83a 	sub	r3,r3,r2
8111e330:	01000104 	movi	r4,4
8111e334:	20c2cd0e 	bge	r4,r3,8111ee6c <_dtoa_r+0x1620>
8111e338:	00c00704 	movi	r3,28
8111e33c:	1885c83a 	sub	r2,r3,r2
8111e340:	d8c00817 	ldw	r3,32(sp)
8111e344:	a0a9883a 	add	r20,r20,r2
8111e348:	b0ad883a 	add	r22,r22,r2
8111e34c:	1887883a 	add	r3,r3,r2
8111e350:	d8c00815 	stw	r3,32(sp)
8111e354:	d9800817 	ldw	r6,32(sp)
8111e358:	0180040e 	bge	zero,r6,8111e36c <_dtoa_r+0xb20>
8111e35c:	800b883a 	mov	r5,r16
8111e360:	e009883a 	mov	r4,fp
8111e364:	11211140 	call	81121114 <__lshift>
8111e368:	1021883a 	mov	r16,r2
8111e36c:	0580050e 	bge	zero,r22,8111e384 <_dtoa_r+0xb38>
8111e370:	a80b883a 	mov	r5,r21
8111e374:	b00d883a 	mov	r6,r22
8111e378:	e009883a 	mov	r4,fp
8111e37c:	11211140 	call	81121114 <__lshift>
8111e380:	102b883a 	mov	r21,r2
8111e384:	d9c00e17 	ldw	r7,56(sp)
8111e388:	3801211e 	bne	r7,zero,8111e810 <_dtoa_r+0xfc4>
8111e38c:	d9800617 	ldw	r6,24(sp)
8111e390:	0181380e 	bge	zero,r6,8111e874 <_dtoa_r+0x1028>
8111e394:	d8c00b17 	ldw	r3,44(sp)
8111e398:	1800ab1e 	bne	r3,zero,8111e648 <_dtoa_r+0xdfc>
8111e39c:	dc800717 	ldw	r18,28(sp)
8111e3a0:	dcc00617 	ldw	r19,24(sp)
8111e3a4:	9029883a 	mov	r20,r18
8111e3a8:	00000206 	br	8111e3b4 <_dtoa_r+0xb68>
8111e3ac:	1120a3c0 	call	81120a3c <__multadd>
8111e3b0:	1021883a 	mov	r16,r2
8111e3b4:	a80b883a 	mov	r5,r21
8111e3b8:	8009883a 	mov	r4,r16
8111e3bc:	111d6440 	call	8111d644 <quorem>
8111e3c0:	10800c04 	addi	r2,r2,48
8111e3c4:	90800005 	stb	r2,0(r18)
8111e3c8:	94800044 	addi	r18,r18,1
8111e3cc:	9507c83a 	sub	r3,r18,r20
8111e3d0:	000f883a 	mov	r7,zero
8111e3d4:	01800284 	movi	r6,10
8111e3d8:	800b883a 	mov	r5,r16
8111e3dc:	e009883a 	mov	r4,fp
8111e3e0:	1cfff216 	blt	r3,r19,8111e3ac <__reset+0xfb0fe3ac>
8111e3e4:	1011883a 	mov	r8,r2
8111e3e8:	d8800617 	ldw	r2,24(sp)
8111e3ec:	0082370e 	bge	zero,r2,8111eccc <_dtoa_r+0x1480>
8111e3f0:	d9000717 	ldw	r4,28(sp)
8111e3f4:	0025883a 	mov	r18,zero
8111e3f8:	20af883a 	add	r23,r4,r2
8111e3fc:	01800044 	movi	r6,1
8111e400:	800b883a 	mov	r5,r16
8111e404:	e009883a 	mov	r4,fp
8111e408:	da001715 	stw	r8,92(sp)
8111e40c:	11211140 	call	81121114 <__lshift>
8111e410:	a80b883a 	mov	r5,r21
8111e414:	1009883a 	mov	r4,r2
8111e418:	d8800915 	stw	r2,36(sp)
8111e41c:	11212640 	call	81121264 <__mcmp>
8111e420:	da001717 	ldw	r8,92(sp)
8111e424:	0081800e 	bge	zero,r2,8111ea28 <_dtoa_r+0x11dc>
8111e428:	b93fffc3 	ldbu	r4,-1(r23)
8111e42c:	b8bfffc4 	addi	r2,r23,-1
8111e430:	1007883a 	mov	r3,r2
8111e434:	01800e44 	movi	r6,57
8111e438:	d9c00717 	ldw	r7,28(sp)
8111e43c:	00000506 	br	8111e454 <_dtoa_r+0xc08>
8111e440:	18ffffc4 	addi	r3,r3,-1
8111e444:	11c12326 	beq	r2,r7,8111e8d4 <_dtoa_r+0x1088>
8111e448:	19000003 	ldbu	r4,0(r3)
8111e44c:	102f883a 	mov	r23,r2
8111e450:	10bfffc4 	addi	r2,r2,-1
8111e454:	21403fcc 	andi	r5,r4,255
8111e458:	2940201c 	xori	r5,r5,128
8111e45c:	297fe004 	addi	r5,r5,-128
8111e460:	29bff726 	beq	r5,r6,8111e440 <__reset+0xfb0fe440>
8111e464:	21000044 	addi	r4,r4,1
8111e468:	11000005 	stb	r4,0(r2)
8111e46c:	a80b883a 	mov	r5,r21
8111e470:	e009883a 	mov	r4,fp
8111e474:	1120a140 	call	81120a14 <_Bfree>
8111e478:	883ea026 	beq	r17,zero,8111defc <__reset+0xfb0fdefc>
8111e47c:	90000426 	beq	r18,zero,8111e490 <_dtoa_r+0xc44>
8111e480:	94400326 	beq	r18,r17,8111e490 <_dtoa_r+0xc44>
8111e484:	900b883a 	mov	r5,r18
8111e488:	e009883a 	mov	r4,fp
8111e48c:	1120a140 	call	81120a14 <_Bfree>
8111e490:	880b883a 	mov	r5,r17
8111e494:	e009883a 	mov	r4,fp
8111e498:	1120a140 	call	81120a14 <_Bfree>
8111e49c:	003e9706 	br	8111defc <__reset+0xfb0fdefc>
8111e4a0:	01800044 	movi	r6,1
8111e4a4:	d9800e15 	stw	r6,56(sp)
8111e4a8:	003d9606 	br	8111db04 <__reset+0xfb0fdb04>
8111e4ac:	d8800817 	ldw	r2,32(sp)
8111e4b0:	d8c00517 	ldw	r3,20(sp)
8111e4b4:	d8000d15 	stw	zero,52(sp)
8111e4b8:	10c5c83a 	sub	r2,r2,r3
8111e4bc:	00c9c83a 	sub	r4,zero,r3
8111e4c0:	d8800815 	stw	r2,32(sp)
8111e4c4:	d9000a15 	stw	r4,40(sp)
8111e4c8:	003d9706 	br	8111db28 <__reset+0xfb0fdb28>
8111e4cc:	05adc83a 	sub	r22,zero,r22
8111e4d0:	dd800815 	stw	r22,32(sp)
8111e4d4:	002d883a 	mov	r22,zero
8111e4d8:	003d8e06 	br	8111db14 <__reset+0xfb0fdb14>
8111e4dc:	d9000517 	ldw	r4,20(sp)
8111e4e0:	112ad540 	call	8112ad54 <__floatsidf>
8111e4e4:	100d883a 	mov	r6,r2
8111e4e8:	180f883a 	mov	r7,r3
8111e4ec:	a009883a 	mov	r4,r20
8111e4f0:	880b883a 	mov	r5,r17
8111e4f4:	112a1780 	call	8112a178 <__eqdf2>
8111e4f8:	103d7126 	beq	r2,zero,8111dac0 <__reset+0xfb0fdac0>
8111e4fc:	d9c00517 	ldw	r7,20(sp)
8111e500:	39ffffc4 	addi	r7,r7,-1
8111e504:	d9c00515 	stw	r7,20(sp)
8111e508:	003d6d06 	br	8111dac0 <__reset+0xfb0fdac0>
8111e50c:	dd400a17 	ldw	r21,40(sp)
8111e510:	dd000817 	ldw	r20,32(sp)
8111e514:	0023883a 	mov	r17,zero
8111e518:	003f4806 	br	8111e23c <__reset+0xfb0fe23c>
8111e51c:	10e3c83a 	sub	r17,r2,r3
8111e520:	9448983a 	sll	r4,r18,r17
8111e524:	003d3206 	br	8111d9f0 <__reset+0xfb0fd9f0>
8111e528:	d8000e15 	stw	zero,56(sp)
8111e52c:	003d7506 	br	8111db04 <__reset+0xfb0fdb04>
8111e530:	b005883a 	mov	r2,r22
8111e534:	003f4506 	br	8111e24c <__reset+0xfb0fe24c>
8111e538:	dc000915 	stw	r16,36(sp)
8111e53c:	d9800a17 	ldw	r6,40(sp)
8111e540:	d9400917 	ldw	r5,36(sp)
8111e544:	e009883a 	mov	r4,fp
8111e548:	1120fcc0 	call	81120fcc <__pow5mult>
8111e54c:	1021883a 	mov	r16,r2
8111e550:	003f5a06 	br	8111e2bc <__reset+0xfb0fe2bc>
8111e554:	01c00044 	movi	r7,1
8111e558:	d9c00b15 	stw	r7,44(sp)
8111e55c:	d8802217 	ldw	r2,136(sp)
8111e560:	0081280e 	bge	zero,r2,8111ea04 <_dtoa_r+0x11b8>
8111e564:	100d883a 	mov	r6,r2
8111e568:	1021883a 	mov	r16,r2
8111e56c:	d8800c15 	stw	r2,48(sp)
8111e570:	d8800615 	stw	r2,24(sp)
8111e574:	003d8806 	br	8111db98 <__reset+0xfb0fdb98>
8111e578:	d8800617 	ldw	r2,24(sp)
8111e57c:	00be9b16 	blt	zero,r2,8111dfec <__reset+0xfb0fdfec>
8111e580:	10010f1e 	bne	r2,zero,8111e9c0 <_dtoa_r+0x1174>
8111e584:	880b883a 	mov	r5,r17
8111e588:	000d883a 	mov	r6,zero
8111e58c:	01d00534 	movhi	r7,16404
8111e590:	8009883a 	mov	r4,r16
8111e594:	1114ae40 	call	81114ae4 <__muldf3>
8111e598:	900d883a 	mov	r6,r18
8111e59c:	980f883a 	mov	r7,r19
8111e5a0:	1009883a 	mov	r4,r2
8111e5a4:	180b883a 	mov	r5,r3
8111e5a8:	112a2000 	call	8112a200 <__gedf2>
8111e5ac:	002b883a 	mov	r21,zero
8111e5b0:	0023883a 	mov	r17,zero
8111e5b4:	1000bf16 	blt	r2,zero,8111e8b4 <_dtoa_r+0x1068>
8111e5b8:	d9802217 	ldw	r6,136(sp)
8111e5bc:	ddc00717 	ldw	r23,28(sp)
8111e5c0:	018c303a 	nor	r6,zero,r6
8111e5c4:	d9800515 	stw	r6,20(sp)
8111e5c8:	a80b883a 	mov	r5,r21
8111e5cc:	e009883a 	mov	r4,fp
8111e5d0:	1120a140 	call	81120a14 <_Bfree>
8111e5d4:	883e4926 	beq	r17,zero,8111defc <__reset+0xfb0fdefc>
8111e5d8:	003fad06 	br	8111e490 <__reset+0xfb0fe490>
8111e5dc:	d9c01117 	ldw	r7,68(sp)
8111e5e0:	3801bc26 	beq	r7,zero,8111ecd4 <_dtoa_r+0x1488>
8111e5e4:	10810cc4 	addi	r2,r2,1075
8111e5e8:	dd400a17 	ldw	r21,40(sp)
8111e5ec:	dd000817 	ldw	r20,32(sp)
8111e5f0:	003f0a06 	br	8111e21c <__reset+0xfb0fe21c>
8111e5f4:	00800704 	movi	r2,28
8111e5f8:	d9000817 	ldw	r4,32(sp)
8111e5fc:	a0a9883a 	add	r20,r20,r2
8111e600:	b0ad883a 	add	r22,r22,r2
8111e604:	2089883a 	add	r4,r4,r2
8111e608:	d9000815 	stw	r4,32(sp)
8111e60c:	003f5106 	br	8111e354 <__reset+0xfb0fe354>
8111e610:	d8c00317 	ldw	r3,12(sp)
8111e614:	b8c1fc0e 	bge	r23,r3,8111ee08 <_dtoa_r+0x15bc>
8111e618:	0027883a 	mov	r19,zero
8111e61c:	b805883a 	mov	r2,r23
8111e620:	003f3e06 	br	8111e31c <__reset+0xfb0fe31c>
8111e624:	880b883a 	mov	r5,r17
8111e628:	e009883a 	mov	r4,fp
8111e62c:	000f883a 	mov	r7,zero
8111e630:	01800284 	movi	r6,10
8111e634:	1120a3c0 	call	81120a3c <__multadd>
8111e638:	d9000c17 	ldw	r4,48(sp)
8111e63c:	1023883a 	mov	r17,r2
8111e640:	0102040e 	bge	zero,r4,8111ee54 <_dtoa_r+0x1608>
8111e644:	d9000615 	stw	r4,24(sp)
8111e648:	0500050e 	bge	zero,r20,8111e660 <_dtoa_r+0xe14>
8111e64c:	880b883a 	mov	r5,r17
8111e650:	a00d883a 	mov	r6,r20
8111e654:	e009883a 	mov	r4,fp
8111e658:	11211140 	call	81121114 <__lshift>
8111e65c:	1023883a 	mov	r17,r2
8111e660:	9801241e 	bne	r19,zero,8111eaf4 <_dtoa_r+0x12a8>
8111e664:	8829883a 	mov	r20,r17
8111e668:	d9000617 	ldw	r4,24(sp)
8111e66c:	dcc00717 	ldw	r19,28(sp)
8111e670:	9480004c 	andi	r18,r18,1
8111e674:	20bfffc4 	addi	r2,r4,-1
8111e678:	9885883a 	add	r2,r19,r2
8111e67c:	d8800415 	stw	r2,16(sp)
8111e680:	dc800615 	stw	r18,24(sp)
8111e684:	a80b883a 	mov	r5,r21
8111e688:	8009883a 	mov	r4,r16
8111e68c:	111d6440 	call	8111d644 <quorem>
8111e690:	880b883a 	mov	r5,r17
8111e694:	8009883a 	mov	r4,r16
8111e698:	102f883a 	mov	r23,r2
8111e69c:	11212640 	call	81121264 <__mcmp>
8111e6a0:	a80b883a 	mov	r5,r21
8111e6a4:	a00d883a 	mov	r6,r20
8111e6a8:	e009883a 	mov	r4,fp
8111e6ac:	102d883a 	mov	r22,r2
8111e6b0:	11212c40 	call	811212c4 <__mdiff>
8111e6b4:	1007883a 	mov	r3,r2
8111e6b8:	10800317 	ldw	r2,12(r2)
8111e6bc:	bc800c04 	addi	r18,r23,48
8111e6c0:	180b883a 	mov	r5,r3
8111e6c4:	10004e1e 	bne	r2,zero,8111e800 <_dtoa_r+0xfb4>
8111e6c8:	8009883a 	mov	r4,r16
8111e6cc:	d8c01615 	stw	r3,88(sp)
8111e6d0:	11212640 	call	81121264 <__mcmp>
8111e6d4:	d8c01617 	ldw	r3,88(sp)
8111e6d8:	e009883a 	mov	r4,fp
8111e6dc:	d8801615 	stw	r2,88(sp)
8111e6e0:	180b883a 	mov	r5,r3
8111e6e4:	1120a140 	call	81120a14 <_Bfree>
8111e6e8:	d8801617 	ldw	r2,88(sp)
8111e6ec:	1000041e 	bne	r2,zero,8111e700 <_dtoa_r+0xeb4>
8111e6f0:	d9800317 	ldw	r6,12(sp)
8111e6f4:	3000021e 	bne	r6,zero,8111e700 <_dtoa_r+0xeb4>
8111e6f8:	d8c00617 	ldw	r3,24(sp)
8111e6fc:	18003726 	beq	r3,zero,8111e7dc <_dtoa_r+0xf90>
8111e700:	b0002016 	blt	r22,zero,8111e784 <_dtoa_r+0xf38>
8111e704:	b000041e 	bne	r22,zero,8111e718 <_dtoa_r+0xecc>
8111e708:	d9000317 	ldw	r4,12(sp)
8111e70c:	2000021e 	bne	r4,zero,8111e718 <_dtoa_r+0xecc>
8111e710:	d8c00617 	ldw	r3,24(sp)
8111e714:	18001b26 	beq	r3,zero,8111e784 <_dtoa_r+0xf38>
8111e718:	00810716 	blt	zero,r2,8111eb38 <_dtoa_r+0x12ec>
8111e71c:	d8c00417 	ldw	r3,16(sp)
8111e720:	9d800044 	addi	r22,r19,1
8111e724:	9c800005 	stb	r18,0(r19)
8111e728:	b02f883a 	mov	r23,r22
8111e72c:	98c10626 	beq	r19,r3,8111eb48 <_dtoa_r+0x12fc>
8111e730:	800b883a 	mov	r5,r16
8111e734:	000f883a 	mov	r7,zero
8111e738:	01800284 	movi	r6,10
8111e73c:	e009883a 	mov	r4,fp
8111e740:	1120a3c0 	call	81120a3c <__multadd>
8111e744:	1021883a 	mov	r16,r2
8111e748:	000f883a 	mov	r7,zero
8111e74c:	01800284 	movi	r6,10
8111e750:	880b883a 	mov	r5,r17
8111e754:	e009883a 	mov	r4,fp
8111e758:	8d002526 	beq	r17,r20,8111e7f0 <_dtoa_r+0xfa4>
8111e75c:	1120a3c0 	call	81120a3c <__multadd>
8111e760:	a00b883a 	mov	r5,r20
8111e764:	000f883a 	mov	r7,zero
8111e768:	01800284 	movi	r6,10
8111e76c:	e009883a 	mov	r4,fp
8111e770:	1023883a 	mov	r17,r2
8111e774:	1120a3c0 	call	81120a3c <__multadd>
8111e778:	1029883a 	mov	r20,r2
8111e77c:	b027883a 	mov	r19,r22
8111e780:	003fc006 	br	8111e684 <__reset+0xfb0fe684>
8111e784:	9011883a 	mov	r8,r18
8111e788:	00800e0e 	bge	zero,r2,8111e7c4 <_dtoa_r+0xf78>
8111e78c:	800b883a 	mov	r5,r16
8111e790:	01800044 	movi	r6,1
8111e794:	e009883a 	mov	r4,fp
8111e798:	da001715 	stw	r8,92(sp)
8111e79c:	11211140 	call	81121114 <__lshift>
8111e7a0:	a80b883a 	mov	r5,r21
8111e7a4:	1009883a 	mov	r4,r2
8111e7a8:	1021883a 	mov	r16,r2
8111e7ac:	11212640 	call	81121264 <__mcmp>
8111e7b0:	da001717 	ldw	r8,92(sp)
8111e7b4:	0081960e 	bge	zero,r2,8111ee10 <_dtoa_r+0x15c4>
8111e7b8:	00800e44 	movi	r2,57
8111e7bc:	40817026 	beq	r8,r2,8111ed80 <_dtoa_r+0x1534>
8111e7c0:	ba000c44 	addi	r8,r23,49
8111e7c4:	8825883a 	mov	r18,r17
8111e7c8:	9dc00044 	addi	r23,r19,1
8111e7cc:	9a000005 	stb	r8,0(r19)
8111e7d0:	a023883a 	mov	r17,r20
8111e7d4:	dc000915 	stw	r16,36(sp)
8111e7d8:	003f2406 	br	8111e46c <__reset+0xfb0fe46c>
8111e7dc:	00800e44 	movi	r2,57
8111e7e0:	9011883a 	mov	r8,r18
8111e7e4:	90816626 	beq	r18,r2,8111ed80 <_dtoa_r+0x1534>
8111e7e8:	05bff516 	blt	zero,r22,8111e7c0 <__reset+0xfb0fe7c0>
8111e7ec:	003ff506 	br	8111e7c4 <__reset+0xfb0fe7c4>
8111e7f0:	1120a3c0 	call	81120a3c <__multadd>
8111e7f4:	1023883a 	mov	r17,r2
8111e7f8:	1029883a 	mov	r20,r2
8111e7fc:	003fdf06 	br	8111e77c <__reset+0xfb0fe77c>
8111e800:	e009883a 	mov	r4,fp
8111e804:	1120a140 	call	81120a14 <_Bfree>
8111e808:	00800044 	movi	r2,1
8111e80c:	003fbc06 	br	8111e700 <__reset+0xfb0fe700>
8111e810:	a80b883a 	mov	r5,r21
8111e814:	8009883a 	mov	r4,r16
8111e818:	11212640 	call	81121264 <__mcmp>
8111e81c:	103edb0e 	bge	r2,zero,8111e38c <__reset+0xfb0fe38c>
8111e820:	800b883a 	mov	r5,r16
8111e824:	000f883a 	mov	r7,zero
8111e828:	01800284 	movi	r6,10
8111e82c:	e009883a 	mov	r4,fp
8111e830:	1120a3c0 	call	81120a3c <__multadd>
8111e834:	1021883a 	mov	r16,r2
8111e838:	d8800517 	ldw	r2,20(sp)
8111e83c:	d8c00b17 	ldw	r3,44(sp)
8111e840:	10bfffc4 	addi	r2,r2,-1
8111e844:	d8800515 	stw	r2,20(sp)
8111e848:	183f761e 	bne	r3,zero,8111e624 <__reset+0xfb0fe624>
8111e84c:	d9000c17 	ldw	r4,48(sp)
8111e850:	0101730e 	bge	zero,r4,8111ee20 <_dtoa_r+0x15d4>
8111e854:	d9000615 	stw	r4,24(sp)
8111e858:	003ed006 	br	8111e39c <__reset+0xfb0fe39c>
8111e85c:	00800084 	movi	r2,2
8111e860:	3081861e 	bne	r6,r2,8111ee7c <_dtoa_r+0x1630>
8111e864:	d8000b15 	stw	zero,44(sp)
8111e868:	003f3c06 	br	8111e55c <__reset+0xfb0fe55c>
8111e86c:	dc000917 	ldw	r16,36(sp)
8111e870:	003e9206 	br	8111e2bc <__reset+0xfb0fe2bc>
8111e874:	d9c00317 	ldw	r7,12(sp)
8111e878:	00800084 	movi	r2,2
8111e87c:	11fec50e 	bge	r2,r7,8111e394 <__reset+0xfb0fe394>
8111e880:	d9000617 	ldw	r4,24(sp)
8111e884:	20013c1e 	bne	r4,zero,8111ed78 <_dtoa_r+0x152c>
8111e888:	a80b883a 	mov	r5,r21
8111e88c:	000f883a 	mov	r7,zero
8111e890:	01800144 	movi	r6,5
8111e894:	e009883a 	mov	r4,fp
8111e898:	1120a3c0 	call	81120a3c <__multadd>
8111e89c:	100b883a 	mov	r5,r2
8111e8a0:	8009883a 	mov	r4,r16
8111e8a4:	102b883a 	mov	r21,r2
8111e8a8:	11212640 	call	81121264 <__mcmp>
8111e8ac:	dc000915 	stw	r16,36(sp)
8111e8b0:	00bf410e 	bge	zero,r2,8111e5b8 <__reset+0xfb0fe5b8>
8111e8b4:	d9c00717 	ldw	r7,28(sp)
8111e8b8:	00800c44 	movi	r2,49
8111e8bc:	38800005 	stb	r2,0(r7)
8111e8c0:	d8800517 	ldw	r2,20(sp)
8111e8c4:	3dc00044 	addi	r23,r7,1
8111e8c8:	10800044 	addi	r2,r2,1
8111e8cc:	d8800515 	stw	r2,20(sp)
8111e8d0:	003f3d06 	br	8111e5c8 <__reset+0xfb0fe5c8>
8111e8d4:	d9800517 	ldw	r6,20(sp)
8111e8d8:	d9c00717 	ldw	r7,28(sp)
8111e8dc:	00800c44 	movi	r2,49
8111e8e0:	31800044 	addi	r6,r6,1
8111e8e4:	d9800515 	stw	r6,20(sp)
8111e8e8:	38800005 	stb	r2,0(r7)
8111e8ec:	003edf06 	br	8111e46c <__reset+0xfb0fe46c>
8111e8f0:	d8000b15 	stw	zero,44(sp)
8111e8f4:	003c9f06 	br	8111db74 <__reset+0xfb0fdb74>
8111e8f8:	903e7e1e 	bne	r18,zero,8111e2f4 <__reset+0xfb0fe2f4>
8111e8fc:	00800434 	movhi	r2,16
8111e900:	10bfffc4 	addi	r2,r2,-1
8111e904:	9884703a 	and	r2,r19,r2
8111e908:	1000ea1e 	bne	r2,zero,8111ecb4 <_dtoa_r+0x1468>
8111e90c:	9cdffc2c 	andhi	r19,r19,32752
8111e910:	9800e826 	beq	r19,zero,8111ecb4 <_dtoa_r+0x1468>
8111e914:	d9c00817 	ldw	r7,32(sp)
8111e918:	b5800044 	addi	r22,r22,1
8111e91c:	04c00044 	movi	r19,1
8111e920:	39c00044 	addi	r7,r7,1
8111e924:	d9c00815 	stw	r7,32(sp)
8111e928:	d8800d17 	ldw	r2,52(sp)
8111e92c:	103e721e 	bne	r2,zero,8111e2f8 <__reset+0xfb0fe2f8>
8111e930:	00800044 	movi	r2,1
8111e934:	003e7906 	br	8111e31c <__reset+0xfb0fe31c>
8111e938:	8009883a 	mov	r4,r16
8111e93c:	112ad540 	call	8112ad54 <__floatsidf>
8111e940:	d9800f17 	ldw	r6,60(sp)
8111e944:	d9c01017 	ldw	r7,64(sp)
8111e948:	1009883a 	mov	r4,r2
8111e94c:	180b883a 	mov	r5,r3
8111e950:	1114ae40 	call	81114ae4 <__muldf3>
8111e954:	000d883a 	mov	r6,zero
8111e958:	01d00734 	movhi	r7,16412
8111e95c:	1009883a 	mov	r4,r2
8111e960:	180b883a 	mov	r5,r3
8111e964:	1128fd40 	call	81128fd4 <__adddf3>
8111e968:	047f3034 	movhi	r17,64704
8111e96c:	1021883a 	mov	r16,r2
8111e970:	1c63883a 	add	r17,r3,r17
8111e974:	d9000f17 	ldw	r4,60(sp)
8111e978:	d9401017 	ldw	r5,64(sp)
8111e97c:	000d883a 	mov	r6,zero
8111e980:	01d00534 	movhi	r7,16404
8111e984:	112a3d00 	call	8112a3d0 <__subdf3>
8111e988:	800d883a 	mov	r6,r16
8111e98c:	880f883a 	mov	r7,r17
8111e990:	1009883a 	mov	r4,r2
8111e994:	180b883a 	mov	r5,r3
8111e998:	102b883a 	mov	r21,r2
8111e99c:	1829883a 	mov	r20,r3
8111e9a0:	112a2000 	call	8112a200 <__gedf2>
8111e9a4:	00806c16 	blt	zero,r2,8111eb58 <_dtoa_r+0x130c>
8111e9a8:	89e0003c 	xorhi	r7,r17,32768
8111e9ac:	800d883a 	mov	r6,r16
8111e9b0:	a809883a 	mov	r4,r21
8111e9b4:	a00b883a 	mov	r5,r20
8111e9b8:	112a2dc0 	call	8112a2dc <__ledf2>
8111e9bc:	103d7e0e 	bge	r2,zero,8111dfb8 <__reset+0xfb0fdfb8>
8111e9c0:	002b883a 	mov	r21,zero
8111e9c4:	0023883a 	mov	r17,zero
8111e9c8:	003efb06 	br	8111e5b8 <__reset+0xfb0fe5b8>
8111e9cc:	d8800717 	ldw	r2,28(sp)
8111e9d0:	003bd006 	br	8111d914 <__reset+0xfb0fd914>
8111e9d4:	d9000a17 	ldw	r4,40(sp)
8111e9d8:	d9800d17 	ldw	r6,52(sp)
8111e9dc:	dd400a15 	stw	r21,40(sp)
8111e9e0:	a905c83a 	sub	r2,r21,r4
8111e9e4:	308d883a 	add	r6,r6,r2
8111e9e8:	d9800d15 	stw	r6,52(sp)
8111e9ec:	002b883a 	mov	r21,zero
8111e9f0:	003e0606 	br	8111e20c <__reset+0xfb0fe20c>
8111e9f4:	9023883a 	mov	r17,r18
8111e9f8:	9829883a 	mov	r20,r19
8111e9fc:	04000084 	movi	r16,2
8111ea00:	003c9206 	br	8111dc4c <__reset+0xfb0fdc4c>
8111ea04:	04000044 	movi	r16,1
8111ea08:	dc000c15 	stw	r16,48(sp)
8111ea0c:	dc000615 	stw	r16,24(sp)
8111ea10:	dc002215 	stw	r16,136(sp)
8111ea14:	e0001115 	stw	zero,68(fp)
8111ea18:	000b883a 	mov	r5,zero
8111ea1c:	003c6906 	br	8111dbc4 <__reset+0xfb0fdbc4>
8111ea20:	3021883a 	mov	r16,r6
8111ea24:	003ffb06 	br	8111ea14 <__reset+0xfb0fea14>
8111ea28:	1000021e 	bne	r2,zero,8111ea34 <_dtoa_r+0x11e8>
8111ea2c:	4200004c 	andi	r8,r8,1
8111ea30:	403e7d1e 	bne	r8,zero,8111e428 <__reset+0xfb0fe428>
8111ea34:	01000c04 	movi	r4,48
8111ea38:	00000106 	br	8111ea40 <_dtoa_r+0x11f4>
8111ea3c:	102f883a 	mov	r23,r2
8111ea40:	b8bfffc4 	addi	r2,r23,-1
8111ea44:	10c00007 	ldb	r3,0(r2)
8111ea48:	193ffc26 	beq	r3,r4,8111ea3c <__reset+0xfb0fea3c>
8111ea4c:	003e8706 	br	8111e46c <__reset+0xfb0fe46c>
8111ea50:	d8800517 	ldw	r2,20(sp)
8111ea54:	00a3c83a 	sub	r17,zero,r2
8111ea58:	8800a426 	beq	r17,zero,8111ecec <_dtoa_r+0x14a0>
8111ea5c:	888003cc 	andi	r2,r17,15
8111ea60:	100490fa 	slli	r2,r2,3
8111ea64:	00e04534 	movhi	r3,33044
8111ea68:	18d15e04 	addi	r3,r3,17784
8111ea6c:	1885883a 	add	r2,r3,r2
8111ea70:	11800017 	ldw	r6,0(r2)
8111ea74:	11c00117 	ldw	r7,4(r2)
8111ea78:	9009883a 	mov	r4,r18
8111ea7c:	980b883a 	mov	r5,r19
8111ea80:	8823d13a 	srai	r17,r17,4
8111ea84:	1114ae40 	call	81114ae4 <__muldf3>
8111ea88:	d8800f15 	stw	r2,60(sp)
8111ea8c:	d8c01015 	stw	r3,64(sp)
8111ea90:	8800e826 	beq	r17,zero,8111ee34 <_dtoa_r+0x15e8>
8111ea94:	05204534 	movhi	r20,33044
8111ea98:	a5115404 	addi	r20,r20,17744
8111ea9c:	04000084 	movi	r16,2
8111eaa0:	8980004c 	andi	r6,r17,1
8111eaa4:	1009883a 	mov	r4,r2
8111eaa8:	8823d07a 	srai	r17,r17,1
8111eaac:	180b883a 	mov	r5,r3
8111eab0:	30000426 	beq	r6,zero,8111eac4 <_dtoa_r+0x1278>
8111eab4:	a1800017 	ldw	r6,0(r20)
8111eab8:	a1c00117 	ldw	r7,4(r20)
8111eabc:	84000044 	addi	r16,r16,1
8111eac0:	1114ae40 	call	81114ae4 <__muldf3>
8111eac4:	a5000204 	addi	r20,r20,8
8111eac8:	883ff51e 	bne	r17,zero,8111eaa0 <__reset+0xfb0feaa0>
8111eacc:	d8800f15 	stw	r2,60(sp)
8111ead0:	d8c01015 	stw	r3,64(sp)
8111ead4:	003c7606 	br	8111dcb0 <__reset+0xfb0fdcb0>
8111ead8:	00c00c04 	movi	r3,48
8111eadc:	10c00005 	stb	r3,0(r2)
8111eae0:	d8c00517 	ldw	r3,20(sp)
8111eae4:	bd3fffc3 	ldbu	r20,-1(r23)
8111eae8:	18c00044 	addi	r3,r3,1
8111eaec:	d8c00515 	stw	r3,20(sp)
8111eaf0:	003db906 	br	8111e1d8 <__reset+0xfb0fe1d8>
8111eaf4:	89400117 	ldw	r5,4(r17)
8111eaf8:	e009883a 	mov	r4,fp
8111eafc:	11209640 	call	81120964 <_Balloc>
8111eb00:	89800417 	ldw	r6,16(r17)
8111eb04:	89400304 	addi	r5,r17,12
8111eb08:	11000304 	addi	r4,r2,12
8111eb0c:	31800084 	addi	r6,r6,2
8111eb10:	318d883a 	add	r6,r6,r6
8111eb14:	318d883a 	add	r6,r6,r6
8111eb18:	1027883a 	mov	r19,r2
8111eb1c:	11167340 	call	81116734 <memcpy>
8111eb20:	01800044 	movi	r6,1
8111eb24:	980b883a 	mov	r5,r19
8111eb28:	e009883a 	mov	r4,fp
8111eb2c:	11211140 	call	81121114 <__lshift>
8111eb30:	1029883a 	mov	r20,r2
8111eb34:	003ecc06 	br	8111e668 <__reset+0xfb0fe668>
8111eb38:	00800e44 	movi	r2,57
8111eb3c:	90809026 	beq	r18,r2,8111ed80 <_dtoa_r+0x1534>
8111eb40:	92000044 	addi	r8,r18,1
8111eb44:	003f1f06 	br	8111e7c4 <__reset+0xfb0fe7c4>
8111eb48:	9011883a 	mov	r8,r18
8111eb4c:	8825883a 	mov	r18,r17
8111eb50:	a023883a 	mov	r17,r20
8111eb54:	003e2906 	br	8111e3fc <__reset+0xfb0fe3fc>
8111eb58:	002b883a 	mov	r21,zero
8111eb5c:	0023883a 	mov	r17,zero
8111eb60:	003f5406 	br	8111e8b4 <__reset+0xfb0fe8b4>
8111eb64:	61bfffc4 	addi	r6,r12,-1
8111eb68:	300490fa 	slli	r2,r6,3
8111eb6c:	00e04534 	movhi	r3,33044
8111eb70:	18d15e04 	addi	r3,r3,17784
8111eb74:	1885883a 	add	r2,r3,r2
8111eb78:	11000017 	ldw	r4,0(r2)
8111eb7c:	11400117 	ldw	r5,4(r2)
8111eb80:	d8800717 	ldw	r2,28(sp)
8111eb84:	880f883a 	mov	r7,r17
8111eb88:	d9801215 	stw	r6,72(sp)
8111eb8c:	800d883a 	mov	r6,r16
8111eb90:	db001615 	stw	r12,88(sp)
8111eb94:	15c00044 	addi	r23,r2,1
8111eb98:	1114ae40 	call	81114ae4 <__muldf3>
8111eb9c:	d9401017 	ldw	r5,64(sp)
8111eba0:	d9000f17 	ldw	r4,60(sp)
8111eba4:	d8c01515 	stw	r3,84(sp)
8111eba8:	d8801415 	stw	r2,80(sp)
8111ebac:	112acd40 	call	8112acd4 <__fixdfsi>
8111ebb0:	1009883a 	mov	r4,r2
8111ebb4:	1021883a 	mov	r16,r2
8111ebb8:	112ad540 	call	8112ad54 <__floatsidf>
8111ebbc:	d9000f17 	ldw	r4,60(sp)
8111ebc0:	d9401017 	ldw	r5,64(sp)
8111ebc4:	100d883a 	mov	r6,r2
8111ebc8:	180f883a 	mov	r7,r3
8111ebcc:	112a3d00 	call	8112a3d0 <__subdf3>
8111ebd0:	1829883a 	mov	r20,r3
8111ebd4:	d8c00717 	ldw	r3,28(sp)
8111ebd8:	84000c04 	addi	r16,r16,48
8111ebdc:	1023883a 	mov	r17,r2
8111ebe0:	1c000005 	stb	r16,0(r3)
8111ebe4:	db001617 	ldw	r12,88(sp)
8111ebe8:	00800044 	movi	r2,1
8111ebec:	60802226 	beq	r12,r2,8111ec78 <_dtoa_r+0x142c>
8111ebf0:	d9c00717 	ldw	r7,28(sp)
8111ebf4:	8805883a 	mov	r2,r17
8111ebf8:	b82b883a 	mov	r21,r23
8111ebfc:	3b19883a 	add	r12,r7,r12
8111ec00:	6023883a 	mov	r17,r12
8111ec04:	a007883a 	mov	r3,r20
8111ec08:	dc800f15 	stw	r18,60(sp)
8111ec0c:	000d883a 	mov	r6,zero
8111ec10:	01d00934 	movhi	r7,16420
8111ec14:	1009883a 	mov	r4,r2
8111ec18:	180b883a 	mov	r5,r3
8111ec1c:	1114ae40 	call	81114ae4 <__muldf3>
8111ec20:	180b883a 	mov	r5,r3
8111ec24:	1009883a 	mov	r4,r2
8111ec28:	1829883a 	mov	r20,r3
8111ec2c:	1025883a 	mov	r18,r2
8111ec30:	112acd40 	call	8112acd4 <__fixdfsi>
8111ec34:	1009883a 	mov	r4,r2
8111ec38:	1021883a 	mov	r16,r2
8111ec3c:	112ad540 	call	8112ad54 <__floatsidf>
8111ec40:	100d883a 	mov	r6,r2
8111ec44:	180f883a 	mov	r7,r3
8111ec48:	9009883a 	mov	r4,r18
8111ec4c:	a00b883a 	mov	r5,r20
8111ec50:	84000c04 	addi	r16,r16,48
8111ec54:	112a3d00 	call	8112a3d0 <__subdf3>
8111ec58:	ad400044 	addi	r21,r21,1
8111ec5c:	ac3fffc5 	stb	r16,-1(r21)
8111ec60:	ac7fea1e 	bne	r21,r17,8111ec0c <__reset+0xfb0fec0c>
8111ec64:	1023883a 	mov	r17,r2
8111ec68:	d8801217 	ldw	r2,72(sp)
8111ec6c:	dc800f17 	ldw	r18,60(sp)
8111ec70:	1829883a 	mov	r20,r3
8111ec74:	b8af883a 	add	r23,r23,r2
8111ec78:	d9001417 	ldw	r4,80(sp)
8111ec7c:	d9401517 	ldw	r5,84(sp)
8111ec80:	000d883a 	mov	r6,zero
8111ec84:	01cff834 	movhi	r7,16352
8111ec88:	1128fd40 	call	81128fd4 <__adddf3>
8111ec8c:	880d883a 	mov	r6,r17
8111ec90:	a00f883a 	mov	r7,r20
8111ec94:	1009883a 	mov	r4,r2
8111ec98:	180b883a 	mov	r5,r3
8111ec9c:	112a2dc0 	call	8112a2dc <__ledf2>
8111eca0:	10003e0e 	bge	r2,zero,8111ed9c <_dtoa_r+0x1550>
8111eca4:	d9001317 	ldw	r4,76(sp)
8111eca8:	bd3fffc3 	ldbu	r20,-1(r23)
8111ecac:	d9000515 	stw	r4,20(sp)
8111ecb0:	003d3b06 	br	8111e1a0 <__reset+0xfb0fe1a0>
8111ecb4:	0027883a 	mov	r19,zero
8111ecb8:	003f1b06 	br	8111e928 <__reset+0xfb0fe928>
8111ecbc:	d8800817 	ldw	r2,32(sp)
8111ecc0:	11e9c83a 	sub	r20,r2,r7
8111ecc4:	0005883a 	mov	r2,zero
8111ecc8:	003d5406 	br	8111e21c <__reset+0xfb0fe21c>
8111eccc:	00800044 	movi	r2,1
8111ecd0:	003dc706 	br	8111e3f0 <__reset+0xfb0fe3f0>
8111ecd4:	d8c00217 	ldw	r3,8(sp)
8111ecd8:	00800d84 	movi	r2,54
8111ecdc:	dd400a17 	ldw	r21,40(sp)
8111ece0:	10c5c83a 	sub	r2,r2,r3
8111ece4:	dd000817 	ldw	r20,32(sp)
8111ece8:	003d4c06 	br	8111e21c <__reset+0xfb0fe21c>
8111ecec:	dc800f15 	stw	r18,60(sp)
8111ecf0:	dcc01015 	stw	r19,64(sp)
8111ecf4:	04000084 	movi	r16,2
8111ecf8:	003bed06 	br	8111dcb0 <__reset+0xfb0fdcb0>
8111ecfc:	d9000617 	ldw	r4,24(sp)
8111ed00:	203f0d26 	beq	r4,zero,8111e938 <__reset+0xfb0fe938>
8111ed04:	d9800c17 	ldw	r6,48(sp)
8111ed08:	01bcab0e 	bge	zero,r6,8111dfb8 <__reset+0xfb0fdfb8>
8111ed0c:	d9401017 	ldw	r5,64(sp)
8111ed10:	d9000f17 	ldw	r4,60(sp)
8111ed14:	000d883a 	mov	r6,zero
8111ed18:	01d00934 	movhi	r7,16420
8111ed1c:	1114ae40 	call	81114ae4 <__muldf3>
8111ed20:	81000044 	addi	r4,r16,1
8111ed24:	d8800f15 	stw	r2,60(sp)
8111ed28:	d8c01015 	stw	r3,64(sp)
8111ed2c:	112ad540 	call	8112ad54 <__floatsidf>
8111ed30:	d9800f17 	ldw	r6,60(sp)
8111ed34:	d9c01017 	ldw	r7,64(sp)
8111ed38:	1009883a 	mov	r4,r2
8111ed3c:	180b883a 	mov	r5,r3
8111ed40:	1114ae40 	call	81114ae4 <__muldf3>
8111ed44:	01d00734 	movhi	r7,16412
8111ed48:	000d883a 	mov	r6,zero
8111ed4c:	1009883a 	mov	r4,r2
8111ed50:	180b883a 	mov	r5,r3
8111ed54:	1128fd40 	call	81128fd4 <__adddf3>
8111ed58:	d9c00517 	ldw	r7,20(sp)
8111ed5c:	047f3034 	movhi	r17,64704
8111ed60:	1021883a 	mov	r16,r2
8111ed64:	39ffffc4 	addi	r7,r7,-1
8111ed68:	d9c01315 	stw	r7,76(sp)
8111ed6c:	1c63883a 	add	r17,r3,r17
8111ed70:	db000c17 	ldw	r12,48(sp)
8111ed74:	003bea06 	br	8111dd20 <__reset+0xfb0fdd20>
8111ed78:	dc000915 	stw	r16,36(sp)
8111ed7c:	003e0e06 	br	8111e5b8 <__reset+0xfb0fe5b8>
8111ed80:	01000e44 	movi	r4,57
8111ed84:	8825883a 	mov	r18,r17
8111ed88:	9dc00044 	addi	r23,r19,1
8111ed8c:	99000005 	stb	r4,0(r19)
8111ed90:	a023883a 	mov	r17,r20
8111ed94:	dc000915 	stw	r16,36(sp)
8111ed98:	003da406 	br	8111e42c <__reset+0xfb0fe42c>
8111ed9c:	d9801417 	ldw	r6,80(sp)
8111eda0:	d9c01517 	ldw	r7,84(sp)
8111eda4:	0009883a 	mov	r4,zero
8111eda8:	014ff834 	movhi	r5,16352
8111edac:	112a3d00 	call	8112a3d0 <__subdf3>
8111edb0:	880d883a 	mov	r6,r17
8111edb4:	a00f883a 	mov	r7,r20
8111edb8:	1009883a 	mov	r4,r2
8111edbc:	180b883a 	mov	r5,r3
8111edc0:	112a2000 	call	8112a200 <__gedf2>
8111edc4:	00bc7c0e 	bge	zero,r2,8111dfb8 <__reset+0xfb0fdfb8>
8111edc8:	01000c04 	movi	r4,48
8111edcc:	00000106 	br	8111edd4 <_dtoa_r+0x1588>
8111edd0:	102f883a 	mov	r23,r2
8111edd4:	b8bfffc4 	addi	r2,r23,-1
8111edd8:	10c00007 	ldb	r3,0(r2)
8111eddc:	193ffc26 	beq	r3,r4,8111edd0 <__reset+0xfb0fedd0>
8111ede0:	d9801317 	ldw	r6,76(sp)
8111ede4:	d9800515 	stw	r6,20(sp)
8111ede8:	003c4406 	br	8111defc <__reset+0xfb0fdefc>
8111edec:	d9801317 	ldw	r6,76(sp)
8111edf0:	d9800515 	stw	r6,20(sp)
8111edf4:	003cea06 	br	8111e1a0 <__reset+0xfb0fe1a0>
8111edf8:	dd800f17 	ldw	r22,60(sp)
8111edfc:	dcc01017 	ldw	r19,64(sp)
8111ee00:	dc801217 	ldw	r18,72(sp)
8111ee04:	003c6c06 	br	8111dfb8 <__reset+0xfb0fdfb8>
8111ee08:	903e031e 	bne	r18,zero,8111e618 <__reset+0xfb0fe618>
8111ee0c:	003ebb06 	br	8111e8fc <__reset+0xfb0fe8fc>
8111ee10:	103e6c1e 	bne	r2,zero,8111e7c4 <__reset+0xfb0fe7c4>
8111ee14:	4080004c 	andi	r2,r8,1
8111ee18:	103e6a26 	beq	r2,zero,8111e7c4 <__reset+0xfb0fe7c4>
8111ee1c:	003e6606 	br	8111e7b8 <__reset+0xfb0fe7b8>
8111ee20:	d8c00317 	ldw	r3,12(sp)
8111ee24:	00800084 	movi	r2,2
8111ee28:	10c02916 	blt	r2,r3,8111eed0 <_dtoa_r+0x1684>
8111ee2c:	d9000c17 	ldw	r4,48(sp)
8111ee30:	003e8806 	br	8111e854 <__reset+0xfb0fe854>
8111ee34:	04000084 	movi	r16,2
8111ee38:	003b9d06 	br	8111dcb0 <__reset+0xfb0fdcb0>
8111ee3c:	d9001317 	ldw	r4,76(sp)
8111ee40:	d9000515 	stw	r4,20(sp)
8111ee44:	003cd606 	br	8111e1a0 <__reset+0xfb0fe1a0>
8111ee48:	d8801317 	ldw	r2,76(sp)
8111ee4c:	d8800515 	stw	r2,20(sp)
8111ee50:	003c2a06 	br	8111defc <__reset+0xfb0fdefc>
8111ee54:	d9800317 	ldw	r6,12(sp)
8111ee58:	00800084 	movi	r2,2
8111ee5c:	11801516 	blt	r2,r6,8111eeb4 <_dtoa_r+0x1668>
8111ee60:	d9c00c17 	ldw	r7,48(sp)
8111ee64:	d9c00615 	stw	r7,24(sp)
8111ee68:	003df706 	br	8111e648 <__reset+0xfb0fe648>
8111ee6c:	193d3926 	beq	r3,r4,8111e354 <__reset+0xfb0fe354>
8111ee70:	00c00f04 	movi	r3,60
8111ee74:	1885c83a 	sub	r2,r3,r2
8111ee78:	003ddf06 	br	8111e5f8 <__reset+0xfb0fe5f8>
8111ee7c:	e009883a 	mov	r4,fp
8111ee80:	e0001115 	stw	zero,68(fp)
8111ee84:	000b883a 	mov	r5,zero
8111ee88:	11209640 	call	81120964 <_Balloc>
8111ee8c:	d8800715 	stw	r2,28(sp)
8111ee90:	d8c00717 	ldw	r3,28(sp)
8111ee94:	00bfffc4 	movi	r2,-1
8111ee98:	01000044 	movi	r4,1
8111ee9c:	d8800c15 	stw	r2,48(sp)
8111eea0:	e0c01015 	stw	r3,64(fp)
8111eea4:	d9000b15 	stw	r4,44(sp)
8111eea8:	d8800615 	stw	r2,24(sp)
8111eeac:	d8002215 	stw	zero,136(sp)
8111eeb0:	003c4106 	br	8111dfb8 <__reset+0xfb0fdfb8>
8111eeb4:	d8c00c17 	ldw	r3,48(sp)
8111eeb8:	d8c00615 	stw	r3,24(sp)
8111eebc:	003e7006 	br	8111e880 <__reset+0xfb0fe880>
8111eec0:	04400044 	movi	r17,1
8111eec4:	003b2006 	br	8111db48 <__reset+0xfb0fdb48>
8111eec8:	000b883a 	mov	r5,zero
8111eecc:	003b3d06 	br	8111dbc4 <__reset+0xfb0fdbc4>
8111eed0:	d8800c17 	ldw	r2,48(sp)
8111eed4:	d8800615 	stw	r2,24(sp)
8111eed8:	003e6906 	br	8111e880 <__reset+0xfb0fe880>

8111eedc <__sflush_r>:
8111eedc:	defffb04 	addi	sp,sp,-20
8111eee0:	de00012e 	bgeu	sp,et,8111eee8 <__sflush_r+0xc>
8111eee4:	003b68fa 	trap	3
8111eee8:	2880030b 	ldhu	r2,12(r5)
8111eeec:	dcc00315 	stw	r19,12(sp)
8111eef0:	dc400115 	stw	r17,4(sp)
8111eef4:	dfc00415 	stw	ra,16(sp)
8111eef8:	dc800215 	stw	r18,8(sp)
8111eefc:	dc000015 	stw	r16,0(sp)
8111ef00:	10c0020c 	andi	r3,r2,8
8111ef04:	2823883a 	mov	r17,r5
8111ef08:	2027883a 	mov	r19,r4
8111ef0c:	1800311e 	bne	r3,zero,8111efd4 <__sflush_r+0xf8>
8111ef10:	28c00117 	ldw	r3,4(r5)
8111ef14:	10820014 	ori	r2,r2,2048
8111ef18:	2880030d 	sth	r2,12(r5)
8111ef1c:	00c04b0e 	bge	zero,r3,8111f04c <__sflush_r+0x170>
8111ef20:	8a000a17 	ldw	r8,40(r17)
8111ef24:	40002326 	beq	r8,zero,8111efb4 <__sflush_r+0xd8>
8111ef28:	9c000017 	ldw	r16,0(r19)
8111ef2c:	10c4000c 	andi	r3,r2,4096
8111ef30:	98000015 	stw	zero,0(r19)
8111ef34:	18004826 	beq	r3,zero,8111f058 <__sflush_r+0x17c>
8111ef38:	89801417 	ldw	r6,80(r17)
8111ef3c:	10c0010c 	andi	r3,r2,4
8111ef40:	18000626 	beq	r3,zero,8111ef5c <__sflush_r+0x80>
8111ef44:	88c00117 	ldw	r3,4(r17)
8111ef48:	88800c17 	ldw	r2,48(r17)
8111ef4c:	30cdc83a 	sub	r6,r6,r3
8111ef50:	10000226 	beq	r2,zero,8111ef5c <__sflush_r+0x80>
8111ef54:	88800f17 	ldw	r2,60(r17)
8111ef58:	308dc83a 	sub	r6,r6,r2
8111ef5c:	89400717 	ldw	r5,28(r17)
8111ef60:	000f883a 	mov	r7,zero
8111ef64:	9809883a 	mov	r4,r19
8111ef68:	403ee83a 	callr	r8
8111ef6c:	00ffffc4 	movi	r3,-1
8111ef70:	10c04426 	beq	r2,r3,8111f084 <__sflush_r+0x1a8>
8111ef74:	88c0030b 	ldhu	r3,12(r17)
8111ef78:	89000417 	ldw	r4,16(r17)
8111ef7c:	88000115 	stw	zero,4(r17)
8111ef80:	197dffcc 	andi	r5,r3,63487
8111ef84:	8940030d 	sth	r5,12(r17)
8111ef88:	89000015 	stw	r4,0(r17)
8111ef8c:	18c4000c 	andi	r3,r3,4096
8111ef90:	18002c1e 	bne	r3,zero,8111f044 <__sflush_r+0x168>
8111ef94:	89400c17 	ldw	r5,48(r17)
8111ef98:	9c000015 	stw	r16,0(r19)
8111ef9c:	28000526 	beq	r5,zero,8111efb4 <__sflush_r+0xd8>
8111efa0:	88801004 	addi	r2,r17,64
8111efa4:	28800226 	beq	r5,r2,8111efb0 <__sflush_r+0xd4>
8111efa8:	9809883a 	mov	r4,r19
8111efac:	111f9940 	call	8111f994 <_free_r>
8111efb0:	88000c15 	stw	zero,48(r17)
8111efb4:	0005883a 	mov	r2,zero
8111efb8:	dfc00417 	ldw	ra,16(sp)
8111efbc:	dcc00317 	ldw	r19,12(sp)
8111efc0:	dc800217 	ldw	r18,8(sp)
8111efc4:	dc400117 	ldw	r17,4(sp)
8111efc8:	dc000017 	ldw	r16,0(sp)
8111efcc:	dec00504 	addi	sp,sp,20
8111efd0:	f800283a 	ret
8111efd4:	2c800417 	ldw	r18,16(r5)
8111efd8:	903ff626 	beq	r18,zero,8111efb4 <__reset+0xfb0fefb4>
8111efdc:	2c000017 	ldw	r16,0(r5)
8111efe0:	108000cc 	andi	r2,r2,3
8111efe4:	2c800015 	stw	r18,0(r5)
8111efe8:	84a1c83a 	sub	r16,r16,r18
8111efec:	1000131e 	bne	r2,zero,8111f03c <__sflush_r+0x160>
8111eff0:	28800517 	ldw	r2,20(r5)
8111eff4:	88800215 	stw	r2,8(r17)
8111eff8:	04000316 	blt	zero,r16,8111f008 <__sflush_r+0x12c>
8111effc:	003fed06 	br	8111efb4 <__reset+0xfb0fefb4>
8111f000:	90a5883a 	add	r18,r18,r2
8111f004:	043feb0e 	bge	zero,r16,8111efb4 <__reset+0xfb0fefb4>
8111f008:	88800917 	ldw	r2,36(r17)
8111f00c:	89400717 	ldw	r5,28(r17)
8111f010:	800f883a 	mov	r7,r16
8111f014:	900d883a 	mov	r6,r18
8111f018:	9809883a 	mov	r4,r19
8111f01c:	103ee83a 	callr	r2
8111f020:	80a1c83a 	sub	r16,r16,r2
8111f024:	00bff616 	blt	zero,r2,8111f000 <__reset+0xfb0ff000>
8111f028:	88c0030b 	ldhu	r3,12(r17)
8111f02c:	00bfffc4 	movi	r2,-1
8111f030:	18c01014 	ori	r3,r3,64
8111f034:	88c0030d 	sth	r3,12(r17)
8111f038:	003fdf06 	br	8111efb8 <__reset+0xfb0fefb8>
8111f03c:	0005883a 	mov	r2,zero
8111f040:	003fec06 	br	8111eff4 <__reset+0xfb0feff4>
8111f044:	88801415 	stw	r2,80(r17)
8111f048:	003fd206 	br	8111ef94 <__reset+0xfb0fef94>
8111f04c:	28c00f17 	ldw	r3,60(r5)
8111f050:	00ffb316 	blt	zero,r3,8111ef20 <__reset+0xfb0fef20>
8111f054:	003fd706 	br	8111efb4 <__reset+0xfb0fefb4>
8111f058:	89400717 	ldw	r5,28(r17)
8111f05c:	000d883a 	mov	r6,zero
8111f060:	01c00044 	movi	r7,1
8111f064:	9809883a 	mov	r4,r19
8111f068:	403ee83a 	callr	r8
8111f06c:	100d883a 	mov	r6,r2
8111f070:	00bfffc4 	movi	r2,-1
8111f074:	30801426 	beq	r6,r2,8111f0c8 <__sflush_r+0x1ec>
8111f078:	8880030b 	ldhu	r2,12(r17)
8111f07c:	8a000a17 	ldw	r8,40(r17)
8111f080:	003fae06 	br	8111ef3c <__reset+0xfb0fef3c>
8111f084:	98c00017 	ldw	r3,0(r19)
8111f088:	183fba26 	beq	r3,zero,8111ef74 <__reset+0xfb0fef74>
8111f08c:	01000744 	movi	r4,29
8111f090:	19000626 	beq	r3,r4,8111f0ac <__sflush_r+0x1d0>
8111f094:	01000584 	movi	r4,22
8111f098:	19000426 	beq	r3,r4,8111f0ac <__sflush_r+0x1d0>
8111f09c:	88c0030b 	ldhu	r3,12(r17)
8111f0a0:	18c01014 	ori	r3,r3,64
8111f0a4:	88c0030d 	sth	r3,12(r17)
8111f0a8:	003fc306 	br	8111efb8 <__reset+0xfb0fefb8>
8111f0ac:	8880030b 	ldhu	r2,12(r17)
8111f0b0:	88c00417 	ldw	r3,16(r17)
8111f0b4:	88000115 	stw	zero,4(r17)
8111f0b8:	10bdffcc 	andi	r2,r2,63487
8111f0bc:	8880030d 	sth	r2,12(r17)
8111f0c0:	88c00015 	stw	r3,0(r17)
8111f0c4:	003fb306 	br	8111ef94 <__reset+0xfb0fef94>
8111f0c8:	98800017 	ldw	r2,0(r19)
8111f0cc:	103fea26 	beq	r2,zero,8111f078 <__reset+0xfb0ff078>
8111f0d0:	00c00744 	movi	r3,29
8111f0d4:	10c00226 	beq	r2,r3,8111f0e0 <__sflush_r+0x204>
8111f0d8:	00c00584 	movi	r3,22
8111f0dc:	10c0031e 	bne	r2,r3,8111f0ec <__sflush_r+0x210>
8111f0e0:	9c000015 	stw	r16,0(r19)
8111f0e4:	0005883a 	mov	r2,zero
8111f0e8:	003fb306 	br	8111efb8 <__reset+0xfb0fefb8>
8111f0ec:	88c0030b 	ldhu	r3,12(r17)
8111f0f0:	3005883a 	mov	r2,r6
8111f0f4:	18c01014 	ori	r3,r3,64
8111f0f8:	88c0030d 	sth	r3,12(r17)
8111f0fc:	003fae06 	br	8111efb8 <__reset+0xfb0fefb8>

8111f100 <_fflush_r>:
8111f100:	defffd04 	addi	sp,sp,-12
8111f104:	de00012e 	bgeu	sp,et,8111f10c <_fflush_r+0xc>
8111f108:	003b68fa 	trap	3
8111f10c:	dc000115 	stw	r16,4(sp)
8111f110:	dfc00215 	stw	ra,8(sp)
8111f114:	2021883a 	mov	r16,r4
8111f118:	20000226 	beq	r4,zero,8111f124 <_fflush_r+0x24>
8111f11c:	20800e17 	ldw	r2,56(r4)
8111f120:	10000c26 	beq	r2,zero,8111f154 <_fflush_r+0x54>
8111f124:	2880030f 	ldh	r2,12(r5)
8111f128:	1000051e 	bne	r2,zero,8111f140 <_fflush_r+0x40>
8111f12c:	0005883a 	mov	r2,zero
8111f130:	dfc00217 	ldw	ra,8(sp)
8111f134:	dc000117 	ldw	r16,4(sp)
8111f138:	dec00304 	addi	sp,sp,12
8111f13c:	f800283a 	ret
8111f140:	8009883a 	mov	r4,r16
8111f144:	dfc00217 	ldw	ra,8(sp)
8111f148:	dc000117 	ldw	r16,4(sp)
8111f14c:	dec00304 	addi	sp,sp,12
8111f150:	111eedc1 	jmpi	8111eedc <__sflush_r>
8111f154:	d9400015 	stw	r5,0(sp)
8111f158:	111f4fc0 	call	8111f4fc <__sinit>
8111f15c:	d9400017 	ldw	r5,0(sp)
8111f160:	003ff006 	br	8111f124 <__reset+0xfb0ff124>

8111f164 <fflush>:
8111f164:	20000526 	beq	r4,zero,8111f17c <fflush+0x18>
8111f168:	00a04534 	movhi	r2,33044
8111f16c:	109aed04 	addi	r2,r2,27572
8111f170:	200b883a 	mov	r5,r4
8111f174:	11000017 	ldw	r4,0(r2)
8111f178:	111f1001 	jmpi	8111f100 <_fflush_r>
8111f17c:	00a04534 	movhi	r2,33044
8111f180:	109aec04 	addi	r2,r2,27568
8111f184:	11000017 	ldw	r4,0(r2)
8111f188:	016044b4 	movhi	r5,33042
8111f18c:	297c4004 	addi	r5,r5,-3840
8111f190:	112023c1 	jmpi	8112023c <_fwalk_reent>

8111f194 <__fp_unlock>:
8111f194:	0005883a 	mov	r2,zero
8111f198:	f800283a 	ret

8111f19c <_cleanup_r>:
8111f19c:	016044b4 	movhi	r5,33042
8111f1a0:	295bd604 	addi	r5,r5,28504
8111f1a4:	112023c1 	jmpi	8112023c <_fwalk_reent>

8111f1a8 <__sinit.part.1>:
8111f1a8:	defff704 	addi	sp,sp,-36
8111f1ac:	00e044b4 	movhi	r3,33042
8111f1b0:	de00012e 	bgeu	sp,et,8111f1b8 <__sinit.part.1+0x10>
8111f1b4:	003b68fa 	trap	3
8111f1b8:	18fc6704 	addi	r3,r3,-3684
8111f1bc:	dfc00815 	stw	ra,32(sp)
8111f1c0:	ddc00715 	stw	r23,28(sp)
8111f1c4:	dd800615 	stw	r22,24(sp)
8111f1c8:	dd400515 	stw	r21,20(sp)
8111f1cc:	dd000415 	stw	r20,16(sp)
8111f1d0:	dcc00315 	stw	r19,12(sp)
8111f1d4:	dc800215 	stw	r18,8(sp)
8111f1d8:	dc400115 	stw	r17,4(sp)
8111f1dc:	dc000015 	stw	r16,0(sp)
8111f1e0:	24000117 	ldw	r16,4(r4)
8111f1e4:	20c00f15 	stw	r3,60(r4)
8111f1e8:	2080bb04 	addi	r2,r4,748
8111f1ec:	00c000c4 	movi	r3,3
8111f1f0:	20c0b915 	stw	r3,740(r4)
8111f1f4:	2080ba15 	stw	r2,744(r4)
8111f1f8:	2000b815 	stw	zero,736(r4)
8111f1fc:	05c00204 	movi	r23,8
8111f200:	00800104 	movi	r2,4
8111f204:	2025883a 	mov	r18,r4
8111f208:	b80d883a 	mov	r6,r23
8111f20c:	81001704 	addi	r4,r16,92
8111f210:	000b883a 	mov	r5,zero
8111f214:	80000015 	stw	zero,0(r16)
8111f218:	80000115 	stw	zero,4(r16)
8111f21c:	80000215 	stw	zero,8(r16)
8111f220:	8080030d 	sth	r2,12(r16)
8111f224:	80001915 	stw	zero,100(r16)
8111f228:	8000038d 	sth	zero,14(r16)
8111f22c:	80000415 	stw	zero,16(r16)
8111f230:	80000515 	stw	zero,20(r16)
8111f234:	80000615 	stw	zero,24(r16)
8111f238:	11168840 	call	81116884 <memset>
8111f23c:	05a04474 	movhi	r22,33041
8111f240:	94400217 	ldw	r17,8(r18)
8111f244:	05604474 	movhi	r21,33041
8111f248:	05204474 	movhi	r20,33041
8111f24c:	04e04474 	movhi	r19,33041
8111f250:	b59c2204 	addi	r22,r22,28808
8111f254:	ad5c3b04 	addi	r21,r21,28908
8111f258:	a51c5c04 	addi	r20,r20,29040
8111f25c:	9cdc7504 	addi	r19,r19,29140
8111f260:	85800815 	stw	r22,32(r16)
8111f264:	85400915 	stw	r21,36(r16)
8111f268:	85000a15 	stw	r20,40(r16)
8111f26c:	84c00b15 	stw	r19,44(r16)
8111f270:	84000715 	stw	r16,28(r16)
8111f274:	00800284 	movi	r2,10
8111f278:	8880030d 	sth	r2,12(r17)
8111f27c:	00800044 	movi	r2,1
8111f280:	b80d883a 	mov	r6,r23
8111f284:	89001704 	addi	r4,r17,92
8111f288:	000b883a 	mov	r5,zero
8111f28c:	88000015 	stw	zero,0(r17)
8111f290:	88000115 	stw	zero,4(r17)
8111f294:	88000215 	stw	zero,8(r17)
8111f298:	88001915 	stw	zero,100(r17)
8111f29c:	8880038d 	sth	r2,14(r17)
8111f2a0:	88000415 	stw	zero,16(r17)
8111f2a4:	88000515 	stw	zero,20(r17)
8111f2a8:	88000615 	stw	zero,24(r17)
8111f2ac:	11168840 	call	81116884 <memset>
8111f2b0:	94000317 	ldw	r16,12(r18)
8111f2b4:	00800484 	movi	r2,18
8111f2b8:	8c400715 	stw	r17,28(r17)
8111f2bc:	8d800815 	stw	r22,32(r17)
8111f2c0:	8d400915 	stw	r21,36(r17)
8111f2c4:	8d000a15 	stw	r20,40(r17)
8111f2c8:	8cc00b15 	stw	r19,44(r17)
8111f2cc:	8080030d 	sth	r2,12(r16)
8111f2d0:	00800084 	movi	r2,2
8111f2d4:	80000015 	stw	zero,0(r16)
8111f2d8:	80000115 	stw	zero,4(r16)
8111f2dc:	80000215 	stw	zero,8(r16)
8111f2e0:	80001915 	stw	zero,100(r16)
8111f2e4:	8080038d 	sth	r2,14(r16)
8111f2e8:	80000415 	stw	zero,16(r16)
8111f2ec:	80000515 	stw	zero,20(r16)
8111f2f0:	80000615 	stw	zero,24(r16)
8111f2f4:	b80d883a 	mov	r6,r23
8111f2f8:	000b883a 	mov	r5,zero
8111f2fc:	81001704 	addi	r4,r16,92
8111f300:	11168840 	call	81116884 <memset>
8111f304:	00800044 	movi	r2,1
8111f308:	84000715 	stw	r16,28(r16)
8111f30c:	85800815 	stw	r22,32(r16)
8111f310:	85400915 	stw	r21,36(r16)
8111f314:	85000a15 	stw	r20,40(r16)
8111f318:	84c00b15 	stw	r19,44(r16)
8111f31c:	90800e15 	stw	r2,56(r18)
8111f320:	dfc00817 	ldw	ra,32(sp)
8111f324:	ddc00717 	ldw	r23,28(sp)
8111f328:	dd800617 	ldw	r22,24(sp)
8111f32c:	dd400517 	ldw	r21,20(sp)
8111f330:	dd000417 	ldw	r20,16(sp)
8111f334:	dcc00317 	ldw	r19,12(sp)
8111f338:	dc800217 	ldw	r18,8(sp)
8111f33c:	dc400117 	ldw	r17,4(sp)
8111f340:	dc000017 	ldw	r16,0(sp)
8111f344:	dec00904 	addi	sp,sp,36
8111f348:	f800283a 	ret

8111f34c <__fp_lock>:
8111f34c:	0005883a 	mov	r2,zero
8111f350:	f800283a 	ret

8111f354 <__sfmoreglue>:
8111f354:	defffc04 	addi	sp,sp,-16
8111f358:	de00012e 	bgeu	sp,et,8111f360 <__sfmoreglue+0xc>
8111f35c:	003b68fa 	trap	3
8111f360:	dc400115 	stw	r17,4(sp)
8111f364:	2c7fffc4 	addi	r17,r5,-1
8111f368:	8c401a24 	muli	r17,r17,104
8111f36c:	dc800215 	stw	r18,8(sp)
8111f370:	2825883a 	mov	r18,r5
8111f374:	89401d04 	addi	r5,r17,116
8111f378:	dc000015 	stw	r16,0(sp)
8111f37c:	dfc00315 	stw	ra,12(sp)
8111f380:	1115f200 	call	81115f20 <_malloc_r>
8111f384:	1021883a 	mov	r16,r2
8111f388:	10000726 	beq	r2,zero,8111f3a8 <__sfmoreglue+0x54>
8111f38c:	11000304 	addi	r4,r2,12
8111f390:	10000015 	stw	zero,0(r2)
8111f394:	14800115 	stw	r18,4(r2)
8111f398:	11000215 	stw	r4,8(r2)
8111f39c:	89801a04 	addi	r6,r17,104
8111f3a0:	000b883a 	mov	r5,zero
8111f3a4:	11168840 	call	81116884 <memset>
8111f3a8:	8005883a 	mov	r2,r16
8111f3ac:	dfc00317 	ldw	ra,12(sp)
8111f3b0:	dc800217 	ldw	r18,8(sp)
8111f3b4:	dc400117 	ldw	r17,4(sp)
8111f3b8:	dc000017 	ldw	r16,0(sp)
8111f3bc:	dec00404 	addi	sp,sp,16
8111f3c0:	f800283a 	ret

8111f3c4 <__sfp>:
8111f3c4:	defffb04 	addi	sp,sp,-20
8111f3c8:	de00012e 	bgeu	sp,et,8111f3d0 <__sfp+0xc>
8111f3cc:	003b68fa 	trap	3
8111f3d0:	dc000015 	stw	r16,0(sp)
8111f3d4:	04204534 	movhi	r16,33044
8111f3d8:	841aec04 	addi	r16,r16,27568
8111f3dc:	dcc00315 	stw	r19,12(sp)
8111f3e0:	2027883a 	mov	r19,r4
8111f3e4:	81000017 	ldw	r4,0(r16)
8111f3e8:	dfc00415 	stw	ra,16(sp)
8111f3ec:	dc800215 	stw	r18,8(sp)
8111f3f0:	20800e17 	ldw	r2,56(r4)
8111f3f4:	dc400115 	stw	r17,4(sp)
8111f3f8:	1000021e 	bne	r2,zero,8111f404 <__sfp+0x40>
8111f3fc:	111f1a80 	call	8111f1a8 <__sinit.part.1>
8111f400:	81000017 	ldw	r4,0(r16)
8111f404:	2480b804 	addi	r18,r4,736
8111f408:	047fffc4 	movi	r17,-1
8111f40c:	91000117 	ldw	r4,4(r18)
8111f410:	94000217 	ldw	r16,8(r18)
8111f414:	213fffc4 	addi	r4,r4,-1
8111f418:	20000a16 	blt	r4,zero,8111f444 <__sfp+0x80>
8111f41c:	8080030f 	ldh	r2,12(r16)
8111f420:	10000c26 	beq	r2,zero,8111f454 <__sfp+0x90>
8111f424:	80c01d04 	addi	r3,r16,116
8111f428:	00000206 	br	8111f434 <__sfp+0x70>
8111f42c:	18bfe60f 	ldh	r2,-104(r3)
8111f430:	10000826 	beq	r2,zero,8111f454 <__sfp+0x90>
8111f434:	213fffc4 	addi	r4,r4,-1
8111f438:	1c3ffd04 	addi	r16,r3,-12
8111f43c:	18c01a04 	addi	r3,r3,104
8111f440:	247ffa1e 	bne	r4,r17,8111f42c <__reset+0xfb0ff42c>
8111f444:	90800017 	ldw	r2,0(r18)
8111f448:	10001d26 	beq	r2,zero,8111f4c0 <__sfp+0xfc>
8111f44c:	1025883a 	mov	r18,r2
8111f450:	003fee06 	br	8111f40c <__reset+0xfb0ff40c>
8111f454:	00bfffc4 	movi	r2,-1
8111f458:	8080038d 	sth	r2,14(r16)
8111f45c:	00800044 	movi	r2,1
8111f460:	8080030d 	sth	r2,12(r16)
8111f464:	80001915 	stw	zero,100(r16)
8111f468:	80000015 	stw	zero,0(r16)
8111f46c:	80000215 	stw	zero,8(r16)
8111f470:	80000115 	stw	zero,4(r16)
8111f474:	80000415 	stw	zero,16(r16)
8111f478:	80000515 	stw	zero,20(r16)
8111f47c:	80000615 	stw	zero,24(r16)
8111f480:	01800204 	movi	r6,8
8111f484:	000b883a 	mov	r5,zero
8111f488:	81001704 	addi	r4,r16,92
8111f48c:	11168840 	call	81116884 <memset>
8111f490:	8005883a 	mov	r2,r16
8111f494:	80000c15 	stw	zero,48(r16)
8111f498:	80000d15 	stw	zero,52(r16)
8111f49c:	80001115 	stw	zero,68(r16)
8111f4a0:	80001215 	stw	zero,72(r16)
8111f4a4:	dfc00417 	ldw	ra,16(sp)
8111f4a8:	dcc00317 	ldw	r19,12(sp)
8111f4ac:	dc800217 	ldw	r18,8(sp)
8111f4b0:	dc400117 	ldw	r17,4(sp)
8111f4b4:	dc000017 	ldw	r16,0(sp)
8111f4b8:	dec00504 	addi	sp,sp,20
8111f4bc:	f800283a 	ret
8111f4c0:	01400104 	movi	r5,4
8111f4c4:	9809883a 	mov	r4,r19
8111f4c8:	111f3540 	call	8111f354 <__sfmoreglue>
8111f4cc:	90800015 	stw	r2,0(r18)
8111f4d0:	103fde1e 	bne	r2,zero,8111f44c <__reset+0xfb0ff44c>
8111f4d4:	00800304 	movi	r2,12
8111f4d8:	98800015 	stw	r2,0(r19)
8111f4dc:	0005883a 	mov	r2,zero
8111f4e0:	003ff006 	br	8111f4a4 <__reset+0xfb0ff4a4>

8111f4e4 <_cleanup>:
8111f4e4:	00a04534 	movhi	r2,33044
8111f4e8:	109aec04 	addi	r2,r2,27568
8111f4ec:	11000017 	ldw	r4,0(r2)
8111f4f0:	016044b4 	movhi	r5,33042
8111f4f4:	295bd604 	addi	r5,r5,28504
8111f4f8:	112023c1 	jmpi	8112023c <_fwalk_reent>

8111f4fc <__sinit>:
8111f4fc:	20800e17 	ldw	r2,56(r4)
8111f500:	10000126 	beq	r2,zero,8111f508 <__sinit+0xc>
8111f504:	f800283a 	ret
8111f508:	111f1a81 	jmpi	8111f1a8 <__sinit.part.1>

8111f50c <__sfp_lock_acquire>:
8111f50c:	f800283a 	ret

8111f510 <__sfp_lock_release>:
8111f510:	f800283a 	ret

8111f514 <__sinit_lock_acquire>:
8111f514:	f800283a 	ret

8111f518 <__sinit_lock_release>:
8111f518:	f800283a 	ret

8111f51c <__fp_lock_all>:
8111f51c:	00a04534 	movhi	r2,33044
8111f520:	109aed04 	addi	r2,r2,27572
8111f524:	11000017 	ldw	r4,0(r2)
8111f528:	016044b4 	movhi	r5,33042
8111f52c:	297cd304 	addi	r5,r5,-3252
8111f530:	11201701 	jmpi	81120170 <_fwalk>

8111f534 <__fp_unlock_all>:
8111f534:	00a04534 	movhi	r2,33044
8111f538:	109aed04 	addi	r2,r2,27572
8111f53c:	11000017 	ldw	r4,0(r2)
8111f540:	016044b4 	movhi	r5,33042
8111f544:	297c6504 	addi	r5,r5,-3692
8111f548:	11201701 	jmpi	81120170 <_fwalk>

8111f54c <__sflags>:
8111f54c:	28800007 	ldb	r2,0(r5)
8111f550:	00c01c84 	movi	r3,114
8111f554:	10c02426 	beq	r2,r3,8111f5e8 <__sflags+0x9c>
8111f558:	00c01dc4 	movi	r3,119
8111f55c:	10c01e26 	beq	r2,r3,8111f5d8 <__sflags+0x8c>
8111f560:	00c01844 	movi	r3,97
8111f564:	10c00426 	beq	r2,r3,8111f578 <__sflags+0x2c>
8111f568:	00800584 	movi	r2,22
8111f56c:	20800015 	stw	r2,0(r4)
8111f570:	0005883a 	mov	r2,zero
8111f574:	f800283a 	ret
8111f578:	02c08204 	movi	r11,520
8111f57c:	01000044 	movi	r4,1
8111f580:	00804204 	movi	r2,264
8111f584:	01c00ac4 	movi	r7,43
8111f588:	02bff8c4 	movi	r10,-29
8111f58c:	027fff04 	movi	r9,-4
8111f590:	02001e04 	movi	r8,120
8111f594:	29400044 	addi	r5,r5,1
8111f598:	28c00007 	ldb	r3,0(r5)
8111f59c:	18000626 	beq	r3,zero,8111f5b8 <__sflags+0x6c>
8111f5a0:	19c00826 	beq	r3,r7,8111f5c4 <__sflags+0x78>
8111f5a4:	1a3ffb1e 	bne	r3,r8,8111f594 <__reset+0xfb0ff594>
8111f5a8:	29400044 	addi	r5,r5,1
8111f5ac:	28c00007 	ldb	r3,0(r5)
8111f5b0:	21020014 	ori	r4,r4,2048
8111f5b4:	183ffa1e 	bne	r3,zero,8111f5a0 <__reset+0xfb0ff5a0>
8111f5b8:	22c8b03a 	or	r4,r4,r11
8111f5bc:	31000015 	stw	r4,0(r6)
8111f5c0:	f800283a 	ret
8111f5c4:	1284703a 	and	r2,r2,r10
8111f5c8:	2248703a 	and	r4,r4,r9
8111f5cc:	10800414 	ori	r2,r2,16
8111f5d0:	21000094 	ori	r4,r4,2
8111f5d4:	003fef06 	br	8111f594 <__reset+0xfb0ff594>
8111f5d8:	02c18004 	movi	r11,1536
8111f5dc:	01000044 	movi	r4,1
8111f5e0:	00800204 	movi	r2,8
8111f5e4:	003fe706 	br	8111f584 <__reset+0xfb0ff584>
8111f5e8:	0017883a 	mov	r11,zero
8111f5ec:	0009883a 	mov	r4,zero
8111f5f0:	00800104 	movi	r2,4
8111f5f4:	003fe306 	br	8111f584 <__reset+0xfb0ff584>

8111f5f8 <_fread_r>:
8111f5f8:	defff404 	addi	sp,sp,-48
8111f5fc:	de00012e 	bgeu	sp,et,8111f604 <_fread_r+0xc>
8111f600:	003b68fa 	trap	3
8111f604:	dd800815 	stw	r22,32(sp)
8111f608:	39ad383a 	mul	r22,r7,r6
8111f60c:	dc000215 	stw	r16,8(sp)
8111f610:	dfc00b15 	stw	ra,44(sp)
8111f614:	df000a15 	stw	fp,40(sp)
8111f618:	ddc00915 	stw	r23,36(sp)
8111f61c:	dd400715 	stw	r21,28(sp)
8111f620:	dd000615 	stw	r20,24(sp)
8111f624:	dcc00515 	stw	r19,20(sp)
8111f628:	dc800415 	stw	r18,16(sp)
8111f62c:	dc400315 	stw	r17,12(sp)
8111f630:	dc000c17 	ldw	r16,48(sp)
8111f634:	b0003b26 	beq	r22,zero,8111f724 <_fread_r+0x12c>
8111f638:	302f883a 	mov	r23,r6
8111f63c:	382b883a 	mov	r21,r7
8111f640:	2029883a 	mov	r20,r4
8111f644:	2827883a 	mov	r19,r5
8111f648:	20000226 	beq	r4,zero,8111f654 <_fread_r+0x5c>
8111f64c:	20800e17 	ldw	r2,56(r4)
8111f650:	10006e26 	beq	r2,zero,8111f80c <_fread_r+0x214>
8111f654:	8080030b 	ldhu	r2,12(r16)
8111f658:	10c8000c 	andi	r3,r2,8192
8111f65c:	1800061e 	bne	r3,zero,8111f678 <_fread_r+0x80>
8111f660:	81001917 	ldw	r4,100(r16)
8111f664:	00f7ffc4 	movi	r3,-8193
8111f668:	10880014 	ori	r2,r2,8192
8111f66c:	20c6703a 	and	r3,r4,r3
8111f670:	8080030d 	sth	r2,12(r16)
8111f674:	80c01915 	stw	r3,100(r16)
8111f678:	84400117 	ldw	r17,4(r16)
8111f67c:	88005f16 	blt	r17,zero,8111f7fc <_fread_r+0x204>
8111f680:	8809883a 	mov	r4,r17
8111f684:	1080008c 	andi	r2,r2,2
8111f688:	1000281e 	bne	r2,zero,8111f72c <_fread_r+0x134>
8111f68c:	b025883a 	mov	r18,r22
8111f690:	00000b06 	br	8111f6c0 <_fread_r+0xc8>
8111f694:	11167340 	call	81116734 <memcpy>
8111f698:	80800017 	ldw	r2,0(r16)
8111f69c:	9c67883a 	add	r19,r19,r17
8111f6a0:	9465c83a 	sub	r18,r18,r17
8111f6a4:	1463883a 	add	r17,r2,r17
8111f6a8:	800b883a 	mov	r5,r16
8111f6ac:	a009883a 	mov	r4,r20
8111f6b0:	84400015 	stw	r17,0(r16)
8111f6b4:	1116d000 	call	81116d00 <__srefill_r>
8111f6b8:	10004c1e 	bne	r2,zero,8111f7ec <_fread_r+0x1f4>
8111f6bc:	84400117 	ldw	r17,4(r16)
8111f6c0:	880d883a 	mov	r6,r17
8111f6c4:	9809883a 	mov	r4,r19
8111f6c8:	81400017 	ldw	r5,0(r16)
8111f6cc:	8cbff136 	bltu	r17,r18,8111f694 <__reset+0xfb0ff694>
8111f6d0:	900d883a 	mov	r6,r18
8111f6d4:	11167340 	call	81116734 <memcpy>
8111f6d8:	80c00117 	ldw	r3,4(r16)
8111f6dc:	81000017 	ldw	r4,0(r16)
8111f6e0:	a805883a 	mov	r2,r21
8111f6e4:	1c87c83a 	sub	r3,r3,r18
8111f6e8:	24a5883a 	add	r18,r4,r18
8111f6ec:	80c00115 	stw	r3,4(r16)
8111f6f0:	84800015 	stw	r18,0(r16)
8111f6f4:	dfc00b17 	ldw	ra,44(sp)
8111f6f8:	df000a17 	ldw	fp,40(sp)
8111f6fc:	ddc00917 	ldw	r23,36(sp)
8111f700:	dd800817 	ldw	r22,32(sp)
8111f704:	dd400717 	ldw	r21,28(sp)
8111f708:	dd000617 	ldw	r20,24(sp)
8111f70c:	dcc00517 	ldw	r19,20(sp)
8111f710:	dc800417 	ldw	r18,16(sp)
8111f714:	dc400317 	ldw	r17,12(sp)
8111f718:	dc000217 	ldw	r16,8(sp)
8111f71c:	dec00c04 	addi	sp,sp,48
8111f720:	f800283a 	ret
8111f724:	0005883a 	mov	r2,zero
8111f728:	003ff206 	br	8111f6f4 <__reset+0xfb0ff6f4>
8111f72c:	b007883a 	mov	r3,r22
8111f730:	2580012e 	bgeu	r4,r22,8111f738 <_fread_r+0x140>
8111f734:	2007883a 	mov	r3,r4
8111f738:	81400017 	ldw	r5,0(r16)
8111f73c:	180d883a 	mov	r6,r3
8111f740:	9809883a 	mov	r4,r19
8111f744:	d8c00115 	stw	r3,4(sp)
8111f748:	11167340 	call	81116734 <memcpy>
8111f74c:	d8c00117 	ldw	r3,4(sp)
8111f750:	84400017 	ldw	r17,0(r16)
8111f754:	80800117 	ldw	r2,4(r16)
8111f758:	81400c17 	ldw	r5,48(r16)
8111f75c:	88e3883a 	add	r17,r17,r3
8111f760:	10c5c83a 	sub	r2,r2,r3
8111f764:	84400015 	stw	r17,0(r16)
8111f768:	80800115 	stw	r2,4(r16)
8111f76c:	b0e5c83a 	sub	r18,r22,r3
8111f770:	28002b26 	beq	r5,zero,8111f820 <_fread_r+0x228>
8111f774:	90002b26 	beq	r18,zero,8111f824 <_fread_r+0x22c>
8111f778:	80801004 	addi	r2,r16,64
8111f77c:	28800526 	beq	r5,r2,8111f794 <_fread_r+0x19c>
8111f780:	a009883a 	mov	r4,r20
8111f784:	d8c00115 	stw	r3,4(sp)
8111f788:	111f9940 	call	8111f994 <_free_r>
8111f78c:	d8c00117 	ldw	r3,4(sp)
8111f790:	84400017 	ldw	r17,0(r16)
8111f794:	80000c15 	stw	zero,48(r16)
8111f798:	80800517 	ldw	r2,20(r16)
8111f79c:	87000417 	ldw	fp,16(r16)
8111f7a0:	98e7883a 	add	r19,r19,r3
8111f7a4:	d8800015 	stw	r2,0(sp)
8111f7a8:	00000106 	br	8111f7b0 <_fread_r+0x1b8>
8111f7ac:	90001d26 	beq	r18,zero,8111f824 <_fread_r+0x22c>
8111f7b0:	84c00415 	stw	r19,16(r16)
8111f7b4:	84800515 	stw	r18,20(r16)
8111f7b8:	84c00015 	stw	r19,0(r16)
8111f7bc:	a009883a 	mov	r4,r20
8111f7c0:	800b883a 	mov	r5,r16
8111f7c4:	1116d000 	call	81116d00 <__srefill_r>
8111f7c8:	d9000017 	ldw	r4,0(sp)
8111f7cc:	80c00117 	ldw	r3,4(r16)
8111f7d0:	87000415 	stw	fp,16(r16)
8111f7d4:	81000515 	stw	r4,20(r16)
8111f7d8:	84400015 	stw	r17,0(r16)
8111f7dc:	80000115 	stw	zero,4(r16)
8111f7e0:	90e5c83a 	sub	r18,r18,r3
8111f7e4:	98e7883a 	add	r19,r19,r3
8111f7e8:	103ff026 	beq	r2,zero,8111f7ac <__reset+0xfb0ff7ac>
8111f7ec:	b80b883a 	mov	r5,r23
8111f7f0:	b489c83a 	sub	r4,r22,r18
8111f7f4:	1128d1c0 	call	81128d1c <__udivsi3>
8111f7f8:	003fbe06 	br	8111f6f4 <__reset+0xfb0ff6f4>
8111f7fc:	80000115 	stw	zero,4(r16)
8111f800:	0009883a 	mov	r4,zero
8111f804:	0023883a 	mov	r17,zero
8111f808:	003f9e06 	br	8111f684 <__reset+0xfb0ff684>
8111f80c:	111f4fc0 	call	8111f4fc <__sinit>
8111f810:	8080030b 	ldhu	r2,12(r16)
8111f814:	10c8000c 	andi	r3,r2,8192
8111f818:	183f971e 	bne	r3,zero,8111f678 <__reset+0xfb0ff678>
8111f81c:	003f9006 	br	8111f660 <__reset+0xfb0ff660>
8111f820:	903fdd1e 	bne	r18,zero,8111f798 <__reset+0xfb0ff798>
8111f824:	a805883a 	mov	r2,r21
8111f828:	003fb206 	br	8111f6f4 <__reset+0xfb0ff6f4>

8111f82c <fread>:
8111f82c:	defffe04 	addi	sp,sp,-8
8111f830:	00a04534 	movhi	r2,33044
8111f834:	de00012e 	bgeu	sp,et,8111f83c <fread+0x10>
8111f838:	003b68fa 	trap	3
8111f83c:	109aed04 	addi	r2,r2,27572
8111f840:	d9c00015 	stw	r7,0(sp)
8111f844:	300f883a 	mov	r7,r6
8111f848:	280d883a 	mov	r6,r5
8111f84c:	200b883a 	mov	r5,r4
8111f850:	11000017 	ldw	r4,0(r2)
8111f854:	dfc00115 	stw	ra,4(sp)
8111f858:	111f5f80 	call	8111f5f8 <_fread_r>
8111f85c:	dfc00117 	ldw	ra,4(sp)
8111f860:	dec00204 	addi	sp,sp,8
8111f864:	f800283a 	ret

8111f868 <_malloc_trim_r>:
8111f868:	defffb04 	addi	sp,sp,-20
8111f86c:	de00012e 	bgeu	sp,et,8111f874 <_malloc_trim_r+0xc>
8111f870:	003b68fa 	trap	3
8111f874:	dcc00315 	stw	r19,12(sp)
8111f878:	04e04534 	movhi	r19,33044
8111f87c:	dc800215 	stw	r18,8(sp)
8111f880:	dc400115 	stw	r17,4(sp)
8111f884:	dc000015 	stw	r16,0(sp)
8111f888:	dfc00415 	stw	ra,16(sp)
8111f88c:	2821883a 	mov	r16,r5
8111f890:	9cd4ab04 	addi	r19,r19,21164
8111f894:	2025883a 	mov	r18,r4
8111f898:	112cd1c0 	call	8112cd1c <__malloc_lock>
8111f89c:	98800217 	ldw	r2,8(r19)
8111f8a0:	14400117 	ldw	r17,4(r2)
8111f8a4:	00bfff04 	movi	r2,-4
8111f8a8:	88a2703a 	and	r17,r17,r2
8111f8ac:	8c21c83a 	sub	r16,r17,r16
8111f8b0:	8403fbc4 	addi	r16,r16,4079
8111f8b4:	8020d33a 	srli	r16,r16,12
8111f8b8:	0083ffc4 	movi	r2,4095
8111f8bc:	843fffc4 	addi	r16,r16,-1
8111f8c0:	8020933a 	slli	r16,r16,12
8111f8c4:	1400060e 	bge	r2,r16,8111f8e0 <_malloc_trim_r+0x78>
8111f8c8:	000b883a 	mov	r5,zero
8111f8cc:	9009883a 	mov	r4,r18
8111f8d0:	1116edc0 	call	81116edc <_sbrk_r>
8111f8d4:	98c00217 	ldw	r3,8(r19)
8111f8d8:	1c47883a 	add	r3,r3,r17
8111f8dc:	10c00a26 	beq	r2,r3,8111f908 <_malloc_trim_r+0xa0>
8111f8e0:	9009883a 	mov	r4,r18
8111f8e4:	112ce440 	call	8112ce44 <__malloc_unlock>
8111f8e8:	0005883a 	mov	r2,zero
8111f8ec:	dfc00417 	ldw	ra,16(sp)
8111f8f0:	dcc00317 	ldw	r19,12(sp)
8111f8f4:	dc800217 	ldw	r18,8(sp)
8111f8f8:	dc400117 	ldw	r17,4(sp)
8111f8fc:	dc000017 	ldw	r16,0(sp)
8111f900:	dec00504 	addi	sp,sp,20
8111f904:	f800283a 	ret
8111f908:	040bc83a 	sub	r5,zero,r16
8111f90c:	9009883a 	mov	r4,r18
8111f910:	1116edc0 	call	81116edc <_sbrk_r>
8111f914:	00ffffc4 	movi	r3,-1
8111f918:	10c00d26 	beq	r2,r3,8111f950 <_malloc_trim_r+0xe8>
8111f91c:	00e04534 	movhi	r3,33044
8111f920:	18dbf504 	addi	r3,r3,28628
8111f924:	18800017 	ldw	r2,0(r3)
8111f928:	99000217 	ldw	r4,8(r19)
8111f92c:	8c23c83a 	sub	r17,r17,r16
8111f930:	8c400054 	ori	r17,r17,1
8111f934:	1421c83a 	sub	r16,r2,r16
8111f938:	24400115 	stw	r17,4(r4)
8111f93c:	9009883a 	mov	r4,r18
8111f940:	1c000015 	stw	r16,0(r3)
8111f944:	112ce440 	call	8112ce44 <__malloc_unlock>
8111f948:	00800044 	movi	r2,1
8111f94c:	003fe706 	br	8111f8ec <__reset+0xfb0ff8ec>
8111f950:	000b883a 	mov	r5,zero
8111f954:	9009883a 	mov	r4,r18
8111f958:	1116edc0 	call	81116edc <_sbrk_r>
8111f95c:	99000217 	ldw	r4,8(r19)
8111f960:	014003c4 	movi	r5,15
8111f964:	1107c83a 	sub	r3,r2,r4
8111f968:	28ffdd0e 	bge	r5,r3,8111f8e0 <__reset+0xfb0ff8e0>
8111f96c:	01604534 	movhi	r5,33044
8111f970:	295aee04 	addi	r5,r5,27576
8111f974:	29400017 	ldw	r5,0(r5)
8111f978:	18c00054 	ori	r3,r3,1
8111f97c:	20c00115 	stw	r3,4(r4)
8111f980:	00e04534 	movhi	r3,33044
8111f984:	1145c83a 	sub	r2,r2,r5
8111f988:	18dbf504 	addi	r3,r3,28628
8111f98c:	18800015 	stw	r2,0(r3)
8111f990:	003fd306 	br	8111f8e0 <__reset+0xfb0ff8e0>

8111f994 <_free_r>:
8111f994:	28004326 	beq	r5,zero,8111faa4 <_free_r+0x110>
8111f998:	defffd04 	addi	sp,sp,-12
8111f99c:	de00012e 	bgeu	sp,et,8111f9a4 <_free_r+0x10>
8111f9a0:	003b68fa 	trap	3
8111f9a4:	dc400115 	stw	r17,4(sp)
8111f9a8:	dc000015 	stw	r16,0(sp)
8111f9ac:	2023883a 	mov	r17,r4
8111f9b0:	2821883a 	mov	r16,r5
8111f9b4:	dfc00215 	stw	ra,8(sp)
8111f9b8:	112cd1c0 	call	8112cd1c <__malloc_lock>
8111f9bc:	81ffff17 	ldw	r7,-4(r16)
8111f9c0:	00bfff84 	movi	r2,-2
8111f9c4:	01204534 	movhi	r4,33044
8111f9c8:	81bffe04 	addi	r6,r16,-8
8111f9cc:	3884703a 	and	r2,r7,r2
8111f9d0:	2114ab04 	addi	r4,r4,21164
8111f9d4:	308b883a 	add	r5,r6,r2
8111f9d8:	2a400117 	ldw	r9,4(r5)
8111f9dc:	22000217 	ldw	r8,8(r4)
8111f9e0:	00ffff04 	movi	r3,-4
8111f9e4:	48c6703a 	and	r3,r9,r3
8111f9e8:	2a005726 	beq	r5,r8,8111fb48 <_free_r+0x1b4>
8111f9ec:	28c00115 	stw	r3,4(r5)
8111f9f0:	39c0004c 	andi	r7,r7,1
8111f9f4:	3800091e 	bne	r7,zero,8111fa1c <_free_r+0x88>
8111f9f8:	823ffe17 	ldw	r8,-8(r16)
8111f9fc:	22400204 	addi	r9,r4,8
8111fa00:	320dc83a 	sub	r6,r6,r8
8111fa04:	31c00217 	ldw	r7,8(r6)
8111fa08:	1205883a 	add	r2,r2,r8
8111fa0c:	3a406526 	beq	r7,r9,8111fba4 <_free_r+0x210>
8111fa10:	32000317 	ldw	r8,12(r6)
8111fa14:	3a000315 	stw	r8,12(r7)
8111fa18:	41c00215 	stw	r7,8(r8)
8111fa1c:	28cf883a 	add	r7,r5,r3
8111fa20:	39c00117 	ldw	r7,4(r7)
8111fa24:	39c0004c 	andi	r7,r7,1
8111fa28:	38003a26 	beq	r7,zero,8111fb14 <_free_r+0x180>
8111fa2c:	10c00054 	ori	r3,r2,1
8111fa30:	30c00115 	stw	r3,4(r6)
8111fa34:	3087883a 	add	r3,r6,r2
8111fa38:	18800015 	stw	r2,0(r3)
8111fa3c:	00c07fc4 	movi	r3,511
8111fa40:	18801936 	bltu	r3,r2,8111faa8 <_free_r+0x114>
8111fa44:	1004d0fa 	srli	r2,r2,3
8111fa48:	01c00044 	movi	r7,1
8111fa4c:	21400117 	ldw	r5,4(r4)
8111fa50:	10c00044 	addi	r3,r2,1
8111fa54:	18c7883a 	add	r3,r3,r3
8111fa58:	1005d0ba 	srai	r2,r2,2
8111fa5c:	18c7883a 	add	r3,r3,r3
8111fa60:	18c7883a 	add	r3,r3,r3
8111fa64:	1907883a 	add	r3,r3,r4
8111fa68:	3884983a 	sll	r2,r7,r2
8111fa6c:	19c00017 	ldw	r7,0(r3)
8111fa70:	1a3ffe04 	addi	r8,r3,-8
8111fa74:	1144b03a 	or	r2,r2,r5
8111fa78:	32000315 	stw	r8,12(r6)
8111fa7c:	31c00215 	stw	r7,8(r6)
8111fa80:	20800115 	stw	r2,4(r4)
8111fa84:	19800015 	stw	r6,0(r3)
8111fa88:	39800315 	stw	r6,12(r7)
8111fa8c:	8809883a 	mov	r4,r17
8111fa90:	dfc00217 	ldw	ra,8(sp)
8111fa94:	dc400117 	ldw	r17,4(sp)
8111fa98:	dc000017 	ldw	r16,0(sp)
8111fa9c:	dec00304 	addi	sp,sp,12
8111faa0:	112ce441 	jmpi	8112ce44 <__malloc_unlock>
8111faa4:	f800283a 	ret
8111faa8:	100ad27a 	srli	r5,r2,9
8111faac:	00c00104 	movi	r3,4
8111fab0:	19404a36 	bltu	r3,r5,8111fbdc <_free_r+0x248>
8111fab4:	100ad1ba 	srli	r5,r2,6
8111fab8:	28c00e44 	addi	r3,r5,57
8111fabc:	18c7883a 	add	r3,r3,r3
8111fac0:	29400e04 	addi	r5,r5,56
8111fac4:	18c7883a 	add	r3,r3,r3
8111fac8:	18c7883a 	add	r3,r3,r3
8111facc:	1909883a 	add	r4,r3,r4
8111fad0:	20c00017 	ldw	r3,0(r4)
8111fad4:	01e04534 	movhi	r7,33044
8111fad8:	213ffe04 	addi	r4,r4,-8
8111fadc:	39d4ab04 	addi	r7,r7,21164
8111fae0:	20c04426 	beq	r4,r3,8111fbf4 <_free_r+0x260>
8111fae4:	01ffff04 	movi	r7,-4
8111fae8:	19400117 	ldw	r5,4(r3)
8111faec:	29ca703a 	and	r5,r5,r7
8111faf0:	1140022e 	bgeu	r2,r5,8111fafc <_free_r+0x168>
8111faf4:	18c00217 	ldw	r3,8(r3)
8111faf8:	20fffb1e 	bne	r4,r3,8111fae8 <__reset+0xfb0ffae8>
8111fafc:	19000317 	ldw	r4,12(r3)
8111fb00:	31000315 	stw	r4,12(r6)
8111fb04:	30c00215 	stw	r3,8(r6)
8111fb08:	21800215 	stw	r6,8(r4)
8111fb0c:	19800315 	stw	r6,12(r3)
8111fb10:	003fde06 	br	8111fa8c <__reset+0xfb0ffa8c>
8111fb14:	29c00217 	ldw	r7,8(r5)
8111fb18:	10c5883a 	add	r2,r2,r3
8111fb1c:	00e04534 	movhi	r3,33044
8111fb20:	18d4ad04 	addi	r3,r3,21172
8111fb24:	38c03b26 	beq	r7,r3,8111fc14 <_free_r+0x280>
8111fb28:	2a000317 	ldw	r8,12(r5)
8111fb2c:	11400054 	ori	r5,r2,1
8111fb30:	3087883a 	add	r3,r6,r2
8111fb34:	3a000315 	stw	r8,12(r7)
8111fb38:	41c00215 	stw	r7,8(r8)
8111fb3c:	31400115 	stw	r5,4(r6)
8111fb40:	18800015 	stw	r2,0(r3)
8111fb44:	003fbd06 	br	8111fa3c <__reset+0xfb0ffa3c>
8111fb48:	39c0004c 	andi	r7,r7,1
8111fb4c:	10c5883a 	add	r2,r2,r3
8111fb50:	3800071e 	bne	r7,zero,8111fb70 <_free_r+0x1dc>
8111fb54:	81fffe17 	ldw	r7,-8(r16)
8111fb58:	31cdc83a 	sub	r6,r6,r7
8111fb5c:	30c00317 	ldw	r3,12(r6)
8111fb60:	31400217 	ldw	r5,8(r6)
8111fb64:	11c5883a 	add	r2,r2,r7
8111fb68:	28c00315 	stw	r3,12(r5)
8111fb6c:	19400215 	stw	r5,8(r3)
8111fb70:	10c00054 	ori	r3,r2,1
8111fb74:	30c00115 	stw	r3,4(r6)
8111fb78:	00e04534 	movhi	r3,33044
8111fb7c:	18daef04 	addi	r3,r3,27580
8111fb80:	18c00017 	ldw	r3,0(r3)
8111fb84:	21800215 	stw	r6,8(r4)
8111fb88:	10ffc036 	bltu	r2,r3,8111fa8c <__reset+0xfb0ffa8c>
8111fb8c:	00a04534 	movhi	r2,33044
8111fb90:	109b5304 	addi	r2,r2,27980
8111fb94:	11400017 	ldw	r5,0(r2)
8111fb98:	8809883a 	mov	r4,r17
8111fb9c:	111f8680 	call	8111f868 <_malloc_trim_r>
8111fba0:	003fba06 	br	8111fa8c <__reset+0xfb0ffa8c>
8111fba4:	28c9883a 	add	r4,r5,r3
8111fba8:	21000117 	ldw	r4,4(r4)
8111fbac:	2100004c 	andi	r4,r4,1
8111fbb0:	2000391e 	bne	r4,zero,8111fc98 <_free_r+0x304>
8111fbb4:	29c00217 	ldw	r7,8(r5)
8111fbb8:	29000317 	ldw	r4,12(r5)
8111fbbc:	1885883a 	add	r2,r3,r2
8111fbc0:	10c00054 	ori	r3,r2,1
8111fbc4:	39000315 	stw	r4,12(r7)
8111fbc8:	21c00215 	stw	r7,8(r4)
8111fbcc:	30c00115 	stw	r3,4(r6)
8111fbd0:	308d883a 	add	r6,r6,r2
8111fbd4:	30800015 	stw	r2,0(r6)
8111fbd8:	003fac06 	br	8111fa8c <__reset+0xfb0ffa8c>
8111fbdc:	00c00504 	movi	r3,20
8111fbe0:	19401536 	bltu	r3,r5,8111fc38 <_free_r+0x2a4>
8111fbe4:	28c01704 	addi	r3,r5,92
8111fbe8:	18c7883a 	add	r3,r3,r3
8111fbec:	294016c4 	addi	r5,r5,91
8111fbf0:	003fb406 	br	8111fac4 <__reset+0xfb0ffac4>
8111fbf4:	280bd0ba 	srai	r5,r5,2
8111fbf8:	00c00044 	movi	r3,1
8111fbfc:	38800117 	ldw	r2,4(r7)
8111fc00:	194a983a 	sll	r5,r3,r5
8111fc04:	2007883a 	mov	r3,r4
8111fc08:	2884b03a 	or	r2,r5,r2
8111fc0c:	38800115 	stw	r2,4(r7)
8111fc10:	003fbb06 	br	8111fb00 <__reset+0xfb0ffb00>
8111fc14:	21800515 	stw	r6,20(r4)
8111fc18:	21800415 	stw	r6,16(r4)
8111fc1c:	10c00054 	ori	r3,r2,1
8111fc20:	31c00315 	stw	r7,12(r6)
8111fc24:	31c00215 	stw	r7,8(r6)
8111fc28:	30c00115 	stw	r3,4(r6)
8111fc2c:	308d883a 	add	r6,r6,r2
8111fc30:	30800015 	stw	r2,0(r6)
8111fc34:	003f9506 	br	8111fa8c <__reset+0xfb0ffa8c>
8111fc38:	00c01504 	movi	r3,84
8111fc3c:	19400536 	bltu	r3,r5,8111fc54 <_free_r+0x2c0>
8111fc40:	100ad33a 	srli	r5,r2,12
8111fc44:	28c01bc4 	addi	r3,r5,111
8111fc48:	18c7883a 	add	r3,r3,r3
8111fc4c:	29401b84 	addi	r5,r5,110
8111fc50:	003f9c06 	br	8111fac4 <__reset+0xfb0ffac4>
8111fc54:	00c05504 	movi	r3,340
8111fc58:	19400536 	bltu	r3,r5,8111fc70 <_free_r+0x2dc>
8111fc5c:	100ad3fa 	srli	r5,r2,15
8111fc60:	28c01e04 	addi	r3,r5,120
8111fc64:	18c7883a 	add	r3,r3,r3
8111fc68:	29401dc4 	addi	r5,r5,119
8111fc6c:	003f9506 	br	8111fac4 <__reset+0xfb0ffac4>
8111fc70:	00c15504 	movi	r3,1364
8111fc74:	19400536 	bltu	r3,r5,8111fc8c <_free_r+0x2f8>
8111fc78:	100ad4ba 	srli	r5,r2,18
8111fc7c:	28c01f44 	addi	r3,r5,125
8111fc80:	18c7883a 	add	r3,r3,r3
8111fc84:	29401f04 	addi	r5,r5,124
8111fc88:	003f8e06 	br	8111fac4 <__reset+0xfb0ffac4>
8111fc8c:	00c03f84 	movi	r3,254
8111fc90:	01401f84 	movi	r5,126
8111fc94:	003f8b06 	br	8111fac4 <__reset+0xfb0ffac4>
8111fc98:	10c00054 	ori	r3,r2,1
8111fc9c:	30c00115 	stw	r3,4(r6)
8111fca0:	308d883a 	add	r6,r6,r2
8111fca4:	30800015 	stw	r2,0(r6)
8111fca8:	003f7806 	br	8111fa8c <__reset+0xfb0ffa8c>

8111fcac <__sfvwrite_r>:
8111fcac:	30800217 	ldw	r2,8(r6)
8111fcb0:	10006926 	beq	r2,zero,8111fe58 <__sfvwrite_r+0x1ac>
8111fcb4:	defff404 	addi	sp,sp,-48
8111fcb8:	de00012e 	bgeu	sp,et,8111fcc0 <__sfvwrite_r+0x14>
8111fcbc:	003b68fa 	trap	3
8111fcc0:	28c0030b 	ldhu	r3,12(r5)
8111fcc4:	dd400715 	stw	r21,28(sp)
8111fcc8:	dd000615 	stw	r20,24(sp)
8111fccc:	dc000215 	stw	r16,8(sp)
8111fcd0:	dfc00b15 	stw	ra,44(sp)
8111fcd4:	df000a15 	stw	fp,40(sp)
8111fcd8:	ddc00915 	stw	r23,36(sp)
8111fcdc:	dd800815 	stw	r22,32(sp)
8111fce0:	dcc00515 	stw	r19,20(sp)
8111fce4:	dc800415 	stw	r18,16(sp)
8111fce8:	dc400315 	stw	r17,12(sp)
8111fcec:	1880020c 	andi	r2,r3,8
8111fcf0:	2821883a 	mov	r16,r5
8111fcf4:	202b883a 	mov	r21,r4
8111fcf8:	3029883a 	mov	r20,r6
8111fcfc:	10002726 	beq	r2,zero,8111fd9c <__sfvwrite_r+0xf0>
8111fd00:	28800417 	ldw	r2,16(r5)
8111fd04:	10002526 	beq	r2,zero,8111fd9c <__sfvwrite_r+0xf0>
8111fd08:	1880008c 	andi	r2,r3,2
8111fd0c:	a4400017 	ldw	r17,0(r20)
8111fd10:	10002a26 	beq	r2,zero,8111fdbc <__sfvwrite_r+0x110>
8111fd14:	05a00034 	movhi	r22,32768
8111fd18:	0027883a 	mov	r19,zero
8111fd1c:	0025883a 	mov	r18,zero
8111fd20:	b5bf0004 	addi	r22,r22,-1024
8111fd24:	980d883a 	mov	r6,r19
8111fd28:	a809883a 	mov	r4,r21
8111fd2c:	90004626 	beq	r18,zero,8111fe48 <__sfvwrite_r+0x19c>
8111fd30:	900f883a 	mov	r7,r18
8111fd34:	b480022e 	bgeu	r22,r18,8111fd40 <__sfvwrite_r+0x94>
8111fd38:	01e00034 	movhi	r7,32768
8111fd3c:	39ff0004 	addi	r7,r7,-1024
8111fd40:	80800917 	ldw	r2,36(r16)
8111fd44:	81400717 	ldw	r5,28(r16)
8111fd48:	103ee83a 	callr	r2
8111fd4c:	0080570e 	bge	zero,r2,8111feac <__sfvwrite_r+0x200>
8111fd50:	a0c00217 	ldw	r3,8(r20)
8111fd54:	98a7883a 	add	r19,r19,r2
8111fd58:	90a5c83a 	sub	r18,r18,r2
8111fd5c:	1885c83a 	sub	r2,r3,r2
8111fd60:	a0800215 	stw	r2,8(r20)
8111fd64:	103fef1e 	bne	r2,zero,8111fd24 <__reset+0xfb0ffd24>
8111fd68:	0005883a 	mov	r2,zero
8111fd6c:	dfc00b17 	ldw	ra,44(sp)
8111fd70:	df000a17 	ldw	fp,40(sp)
8111fd74:	ddc00917 	ldw	r23,36(sp)
8111fd78:	dd800817 	ldw	r22,32(sp)
8111fd7c:	dd400717 	ldw	r21,28(sp)
8111fd80:	dd000617 	ldw	r20,24(sp)
8111fd84:	dcc00517 	ldw	r19,20(sp)
8111fd88:	dc800417 	ldw	r18,16(sp)
8111fd8c:	dc400317 	ldw	r17,12(sp)
8111fd90:	dc000217 	ldw	r16,8(sp)
8111fd94:	dec00c04 	addi	sp,sp,48
8111fd98:	f800283a 	ret
8111fd9c:	800b883a 	mov	r5,r16
8111fda0:	a809883a 	mov	r4,r21
8111fda4:	111d48c0 	call	8111d48c <__swsetup_r>
8111fda8:	1000eb1e 	bne	r2,zero,81120158 <__sfvwrite_r+0x4ac>
8111fdac:	80c0030b 	ldhu	r3,12(r16)
8111fdb0:	a4400017 	ldw	r17,0(r20)
8111fdb4:	1880008c 	andi	r2,r3,2
8111fdb8:	103fd61e 	bne	r2,zero,8111fd14 <__reset+0xfb0ffd14>
8111fdbc:	1880004c 	andi	r2,r3,1
8111fdc0:	10003f1e 	bne	r2,zero,8111fec0 <__sfvwrite_r+0x214>
8111fdc4:	0039883a 	mov	fp,zero
8111fdc8:	0025883a 	mov	r18,zero
8111fdcc:	90001a26 	beq	r18,zero,8111fe38 <__sfvwrite_r+0x18c>
8111fdd0:	1880800c 	andi	r2,r3,512
8111fdd4:	84c00217 	ldw	r19,8(r16)
8111fdd8:	10002126 	beq	r2,zero,8111fe60 <__sfvwrite_r+0x1b4>
8111fddc:	982f883a 	mov	r23,r19
8111fde0:	94c09336 	bltu	r18,r19,81120030 <__sfvwrite_r+0x384>
8111fde4:	1881200c 	andi	r2,r3,1152
8111fde8:	10009e1e 	bne	r2,zero,81120064 <__sfvwrite_r+0x3b8>
8111fdec:	81000017 	ldw	r4,0(r16)
8111fdf0:	b80d883a 	mov	r6,r23
8111fdf4:	e00b883a 	mov	r5,fp
8111fdf8:	11208080 	call	81120808 <memmove>
8111fdfc:	80c00217 	ldw	r3,8(r16)
8111fe00:	81000017 	ldw	r4,0(r16)
8111fe04:	9005883a 	mov	r2,r18
8111fe08:	1ce7c83a 	sub	r19,r3,r19
8111fe0c:	25cf883a 	add	r7,r4,r23
8111fe10:	84c00215 	stw	r19,8(r16)
8111fe14:	81c00015 	stw	r7,0(r16)
8111fe18:	a0c00217 	ldw	r3,8(r20)
8111fe1c:	e0b9883a 	add	fp,fp,r2
8111fe20:	90a5c83a 	sub	r18,r18,r2
8111fe24:	18a7c83a 	sub	r19,r3,r2
8111fe28:	a4c00215 	stw	r19,8(r20)
8111fe2c:	983fce26 	beq	r19,zero,8111fd68 <__reset+0xfb0ffd68>
8111fe30:	80c0030b 	ldhu	r3,12(r16)
8111fe34:	903fe61e 	bne	r18,zero,8111fdd0 <__reset+0xfb0ffdd0>
8111fe38:	8f000017 	ldw	fp,0(r17)
8111fe3c:	8c800117 	ldw	r18,4(r17)
8111fe40:	8c400204 	addi	r17,r17,8
8111fe44:	003fe106 	br	8111fdcc <__reset+0xfb0ffdcc>
8111fe48:	8cc00017 	ldw	r19,0(r17)
8111fe4c:	8c800117 	ldw	r18,4(r17)
8111fe50:	8c400204 	addi	r17,r17,8
8111fe54:	003fb306 	br	8111fd24 <__reset+0xfb0ffd24>
8111fe58:	0005883a 	mov	r2,zero
8111fe5c:	f800283a 	ret
8111fe60:	81000017 	ldw	r4,0(r16)
8111fe64:	80800417 	ldw	r2,16(r16)
8111fe68:	11005736 	bltu	r2,r4,8111ffc8 <__sfvwrite_r+0x31c>
8111fe6c:	85c00517 	ldw	r23,20(r16)
8111fe70:	95c05536 	bltu	r18,r23,8111ffc8 <__sfvwrite_r+0x31c>
8111fe74:	00a00034 	movhi	r2,32768
8111fe78:	10bfffc4 	addi	r2,r2,-1
8111fe7c:	9009883a 	mov	r4,r18
8111fe80:	1480012e 	bgeu	r2,r18,8111fe88 <__sfvwrite_r+0x1dc>
8111fe84:	1009883a 	mov	r4,r2
8111fe88:	b80b883a 	mov	r5,r23
8111fe8c:	1128c240 	call	81128c24 <__divsi3>
8111fe90:	15cf383a 	mul	r7,r2,r23
8111fe94:	81400717 	ldw	r5,28(r16)
8111fe98:	80800917 	ldw	r2,36(r16)
8111fe9c:	e00d883a 	mov	r6,fp
8111fea0:	a809883a 	mov	r4,r21
8111fea4:	103ee83a 	callr	r2
8111fea8:	00bfdb16 	blt	zero,r2,8111fe18 <__reset+0xfb0ffe18>
8111feac:	8080030b 	ldhu	r2,12(r16)
8111feb0:	10801014 	ori	r2,r2,64
8111feb4:	8080030d 	sth	r2,12(r16)
8111feb8:	00bfffc4 	movi	r2,-1
8111febc:	003fab06 	br	8111fd6c <__reset+0xfb0ffd6c>
8111fec0:	0027883a 	mov	r19,zero
8111fec4:	0011883a 	mov	r8,zero
8111fec8:	0039883a 	mov	fp,zero
8111fecc:	0025883a 	mov	r18,zero
8111fed0:	90001f26 	beq	r18,zero,8111ff50 <__sfvwrite_r+0x2a4>
8111fed4:	40005a26 	beq	r8,zero,81120040 <__sfvwrite_r+0x394>
8111fed8:	982d883a 	mov	r22,r19
8111fedc:	94c0012e 	bgeu	r18,r19,8111fee4 <__sfvwrite_r+0x238>
8111fee0:	902d883a 	mov	r22,r18
8111fee4:	81000017 	ldw	r4,0(r16)
8111fee8:	80800417 	ldw	r2,16(r16)
8111feec:	b02f883a 	mov	r23,r22
8111fef0:	81c00517 	ldw	r7,20(r16)
8111fef4:	1100032e 	bgeu	r2,r4,8111ff04 <__sfvwrite_r+0x258>
8111fef8:	80c00217 	ldw	r3,8(r16)
8111fefc:	38c7883a 	add	r3,r7,r3
8111ff00:	1d801816 	blt	r3,r22,8111ff64 <__sfvwrite_r+0x2b8>
8111ff04:	b1c03e16 	blt	r22,r7,81120000 <__sfvwrite_r+0x354>
8111ff08:	80800917 	ldw	r2,36(r16)
8111ff0c:	81400717 	ldw	r5,28(r16)
8111ff10:	e00d883a 	mov	r6,fp
8111ff14:	da000115 	stw	r8,4(sp)
8111ff18:	a809883a 	mov	r4,r21
8111ff1c:	103ee83a 	callr	r2
8111ff20:	102f883a 	mov	r23,r2
8111ff24:	da000117 	ldw	r8,4(sp)
8111ff28:	00bfe00e 	bge	zero,r2,8111feac <__reset+0xfb0ffeac>
8111ff2c:	9de7c83a 	sub	r19,r19,r23
8111ff30:	98001f26 	beq	r19,zero,8111ffb0 <__sfvwrite_r+0x304>
8111ff34:	a0800217 	ldw	r2,8(r20)
8111ff38:	e5f9883a 	add	fp,fp,r23
8111ff3c:	95e5c83a 	sub	r18,r18,r23
8111ff40:	15efc83a 	sub	r23,r2,r23
8111ff44:	a5c00215 	stw	r23,8(r20)
8111ff48:	b83f8726 	beq	r23,zero,8111fd68 <__reset+0xfb0ffd68>
8111ff4c:	903fe11e 	bne	r18,zero,8111fed4 <__reset+0xfb0ffed4>
8111ff50:	8f000017 	ldw	fp,0(r17)
8111ff54:	8c800117 	ldw	r18,4(r17)
8111ff58:	0011883a 	mov	r8,zero
8111ff5c:	8c400204 	addi	r17,r17,8
8111ff60:	003fdb06 	br	8111fed0 <__reset+0xfb0ffed0>
8111ff64:	180d883a 	mov	r6,r3
8111ff68:	e00b883a 	mov	r5,fp
8111ff6c:	da000115 	stw	r8,4(sp)
8111ff70:	d8c00015 	stw	r3,0(sp)
8111ff74:	11208080 	call	81120808 <memmove>
8111ff78:	d8c00017 	ldw	r3,0(sp)
8111ff7c:	80800017 	ldw	r2,0(r16)
8111ff80:	800b883a 	mov	r5,r16
8111ff84:	a809883a 	mov	r4,r21
8111ff88:	10c5883a 	add	r2,r2,r3
8111ff8c:	80800015 	stw	r2,0(r16)
8111ff90:	d8c00015 	stw	r3,0(sp)
8111ff94:	111f1000 	call	8111f100 <_fflush_r>
8111ff98:	d8c00017 	ldw	r3,0(sp)
8111ff9c:	da000117 	ldw	r8,4(sp)
8111ffa0:	103fc21e 	bne	r2,zero,8111feac <__reset+0xfb0ffeac>
8111ffa4:	182f883a 	mov	r23,r3
8111ffa8:	9de7c83a 	sub	r19,r19,r23
8111ffac:	983fe11e 	bne	r19,zero,8111ff34 <__reset+0xfb0fff34>
8111ffb0:	800b883a 	mov	r5,r16
8111ffb4:	a809883a 	mov	r4,r21
8111ffb8:	111f1000 	call	8111f100 <_fflush_r>
8111ffbc:	103fbb1e 	bne	r2,zero,8111feac <__reset+0xfb0ffeac>
8111ffc0:	0011883a 	mov	r8,zero
8111ffc4:	003fdb06 	br	8111ff34 <__reset+0xfb0fff34>
8111ffc8:	94c0012e 	bgeu	r18,r19,8111ffd0 <__sfvwrite_r+0x324>
8111ffcc:	9027883a 	mov	r19,r18
8111ffd0:	980d883a 	mov	r6,r19
8111ffd4:	e00b883a 	mov	r5,fp
8111ffd8:	11208080 	call	81120808 <memmove>
8111ffdc:	80800217 	ldw	r2,8(r16)
8111ffe0:	80c00017 	ldw	r3,0(r16)
8111ffe4:	14c5c83a 	sub	r2,r2,r19
8111ffe8:	1cc7883a 	add	r3,r3,r19
8111ffec:	80800215 	stw	r2,8(r16)
8111fff0:	80c00015 	stw	r3,0(r16)
8111fff4:	10004326 	beq	r2,zero,81120104 <__sfvwrite_r+0x458>
8111fff8:	9805883a 	mov	r2,r19
8111fffc:	003f8606 	br	8111fe18 <__reset+0xfb0ffe18>
81120000:	b00d883a 	mov	r6,r22
81120004:	e00b883a 	mov	r5,fp
81120008:	da000115 	stw	r8,4(sp)
8112000c:	11208080 	call	81120808 <memmove>
81120010:	80800217 	ldw	r2,8(r16)
81120014:	80c00017 	ldw	r3,0(r16)
81120018:	da000117 	ldw	r8,4(sp)
8112001c:	1585c83a 	sub	r2,r2,r22
81120020:	1dad883a 	add	r22,r3,r22
81120024:	80800215 	stw	r2,8(r16)
81120028:	85800015 	stw	r22,0(r16)
8112002c:	003fbf06 	br	8111ff2c <__reset+0xfb0fff2c>
81120030:	81000017 	ldw	r4,0(r16)
81120034:	9027883a 	mov	r19,r18
81120038:	902f883a 	mov	r23,r18
8112003c:	003f6c06 	br	8111fdf0 <__reset+0xfb0ffdf0>
81120040:	900d883a 	mov	r6,r18
81120044:	01400284 	movi	r5,10
81120048:	e009883a 	mov	r4,fp
8112004c:	11207240 	call	81120724 <memchr>
81120050:	10003e26 	beq	r2,zero,8112014c <__sfvwrite_r+0x4a0>
81120054:	10800044 	addi	r2,r2,1
81120058:	1727c83a 	sub	r19,r2,fp
8112005c:	02000044 	movi	r8,1
81120060:	003f9d06 	br	8111fed8 <__reset+0xfb0ffed8>
81120064:	80800517 	ldw	r2,20(r16)
81120068:	81400417 	ldw	r5,16(r16)
8112006c:	81c00017 	ldw	r7,0(r16)
81120070:	10a7883a 	add	r19,r2,r2
81120074:	9885883a 	add	r2,r19,r2
81120078:	1026d7fa 	srli	r19,r2,31
8112007c:	396dc83a 	sub	r22,r7,r5
81120080:	b1000044 	addi	r4,r22,1
81120084:	9885883a 	add	r2,r19,r2
81120088:	1027d07a 	srai	r19,r2,1
8112008c:	2485883a 	add	r2,r4,r18
81120090:	980d883a 	mov	r6,r19
81120094:	9880022e 	bgeu	r19,r2,811200a0 <__sfvwrite_r+0x3f4>
81120098:	1027883a 	mov	r19,r2
8112009c:	100d883a 	mov	r6,r2
811200a0:	18c1000c 	andi	r3,r3,1024
811200a4:	18001c26 	beq	r3,zero,81120118 <__sfvwrite_r+0x46c>
811200a8:	300b883a 	mov	r5,r6
811200ac:	a809883a 	mov	r4,r21
811200b0:	1115f200 	call	81115f20 <_malloc_r>
811200b4:	102f883a 	mov	r23,r2
811200b8:	10002926 	beq	r2,zero,81120160 <__sfvwrite_r+0x4b4>
811200bc:	81400417 	ldw	r5,16(r16)
811200c0:	b00d883a 	mov	r6,r22
811200c4:	1009883a 	mov	r4,r2
811200c8:	11167340 	call	81116734 <memcpy>
811200cc:	8080030b 	ldhu	r2,12(r16)
811200d0:	00fedfc4 	movi	r3,-1153
811200d4:	10c4703a 	and	r2,r2,r3
811200d8:	10802014 	ori	r2,r2,128
811200dc:	8080030d 	sth	r2,12(r16)
811200e0:	bd89883a 	add	r4,r23,r22
811200e4:	9d8fc83a 	sub	r7,r19,r22
811200e8:	85c00415 	stw	r23,16(r16)
811200ec:	84c00515 	stw	r19,20(r16)
811200f0:	81000015 	stw	r4,0(r16)
811200f4:	9027883a 	mov	r19,r18
811200f8:	81c00215 	stw	r7,8(r16)
811200fc:	902f883a 	mov	r23,r18
81120100:	003f3b06 	br	8111fdf0 <__reset+0xfb0ffdf0>
81120104:	800b883a 	mov	r5,r16
81120108:	a809883a 	mov	r4,r21
8112010c:	111f1000 	call	8111f100 <_fflush_r>
81120110:	103fb926 	beq	r2,zero,8111fff8 <__reset+0xfb0ffff8>
81120114:	003f6506 	br	8111feac <__reset+0xfb0ffeac>
81120118:	a809883a 	mov	r4,r21
8112011c:	1121a280 	call	81121a28 <_realloc_r>
81120120:	102f883a 	mov	r23,r2
81120124:	103fee1e 	bne	r2,zero,811200e0 <__reset+0xfb1000e0>
81120128:	81400417 	ldw	r5,16(r16)
8112012c:	a809883a 	mov	r4,r21
81120130:	111f9940 	call	8111f994 <_free_r>
81120134:	8080030b 	ldhu	r2,12(r16)
81120138:	00ffdfc4 	movi	r3,-129
8112013c:	1884703a 	and	r2,r3,r2
81120140:	00c00304 	movi	r3,12
81120144:	a8c00015 	stw	r3,0(r21)
81120148:	003f5906 	br	8111feb0 <__reset+0xfb0ffeb0>
8112014c:	94c00044 	addi	r19,r18,1
81120150:	02000044 	movi	r8,1
81120154:	003f6006 	br	8111fed8 <__reset+0xfb0ffed8>
81120158:	00bfffc4 	movi	r2,-1
8112015c:	003f0306 	br	8111fd6c <__reset+0xfb0ffd6c>
81120160:	00800304 	movi	r2,12
81120164:	a8800015 	stw	r2,0(r21)
81120168:	8080030b 	ldhu	r2,12(r16)
8112016c:	003f5006 	br	8111feb0 <__reset+0xfb0ffeb0>

81120170 <_fwalk>:
81120170:	defff704 	addi	sp,sp,-36
81120174:	de00012e 	bgeu	sp,et,8112017c <_fwalk+0xc>
81120178:	003b68fa 	trap	3
8112017c:	dd000415 	stw	r20,16(sp)
81120180:	dfc00815 	stw	ra,32(sp)
81120184:	ddc00715 	stw	r23,28(sp)
81120188:	dd800615 	stw	r22,24(sp)
8112018c:	dd400515 	stw	r21,20(sp)
81120190:	dcc00315 	stw	r19,12(sp)
81120194:	dc800215 	stw	r18,8(sp)
81120198:	dc400115 	stw	r17,4(sp)
8112019c:	dc000015 	stw	r16,0(sp)
811201a0:	2500b804 	addi	r20,r4,736
811201a4:	a0002326 	beq	r20,zero,81120234 <_fwalk+0xc4>
811201a8:	282b883a 	mov	r21,r5
811201ac:	002f883a 	mov	r23,zero
811201b0:	05800044 	movi	r22,1
811201b4:	04ffffc4 	movi	r19,-1
811201b8:	a4400117 	ldw	r17,4(r20)
811201bc:	a4800217 	ldw	r18,8(r20)
811201c0:	8c7fffc4 	addi	r17,r17,-1
811201c4:	88000d16 	blt	r17,zero,811201fc <_fwalk+0x8c>
811201c8:	94000304 	addi	r16,r18,12
811201cc:	94800384 	addi	r18,r18,14
811201d0:	8080000b 	ldhu	r2,0(r16)
811201d4:	8c7fffc4 	addi	r17,r17,-1
811201d8:	813ffd04 	addi	r4,r16,-12
811201dc:	b080042e 	bgeu	r22,r2,811201f0 <_fwalk+0x80>
811201e0:	9080000f 	ldh	r2,0(r18)
811201e4:	14c00226 	beq	r2,r19,811201f0 <_fwalk+0x80>
811201e8:	a83ee83a 	callr	r21
811201ec:	b8aeb03a 	or	r23,r23,r2
811201f0:	84001a04 	addi	r16,r16,104
811201f4:	94801a04 	addi	r18,r18,104
811201f8:	8cfff51e 	bne	r17,r19,811201d0 <__reset+0xfb1001d0>
811201fc:	a5000017 	ldw	r20,0(r20)
81120200:	a03fed1e 	bne	r20,zero,811201b8 <__reset+0xfb1001b8>
81120204:	b805883a 	mov	r2,r23
81120208:	dfc00817 	ldw	ra,32(sp)
8112020c:	ddc00717 	ldw	r23,28(sp)
81120210:	dd800617 	ldw	r22,24(sp)
81120214:	dd400517 	ldw	r21,20(sp)
81120218:	dd000417 	ldw	r20,16(sp)
8112021c:	dcc00317 	ldw	r19,12(sp)
81120220:	dc800217 	ldw	r18,8(sp)
81120224:	dc400117 	ldw	r17,4(sp)
81120228:	dc000017 	ldw	r16,0(sp)
8112022c:	dec00904 	addi	sp,sp,36
81120230:	f800283a 	ret
81120234:	002f883a 	mov	r23,zero
81120238:	003ff206 	br	81120204 <__reset+0xfb100204>

8112023c <_fwalk_reent>:
8112023c:	defff704 	addi	sp,sp,-36
81120240:	de00012e 	bgeu	sp,et,81120248 <_fwalk_reent+0xc>
81120244:	003b68fa 	trap	3
81120248:	dd000415 	stw	r20,16(sp)
8112024c:	dfc00815 	stw	ra,32(sp)
81120250:	ddc00715 	stw	r23,28(sp)
81120254:	dd800615 	stw	r22,24(sp)
81120258:	dd400515 	stw	r21,20(sp)
8112025c:	dcc00315 	stw	r19,12(sp)
81120260:	dc800215 	stw	r18,8(sp)
81120264:	dc400115 	stw	r17,4(sp)
81120268:	dc000015 	stw	r16,0(sp)
8112026c:	2500b804 	addi	r20,r4,736
81120270:	a0002326 	beq	r20,zero,81120300 <_fwalk_reent+0xc4>
81120274:	282b883a 	mov	r21,r5
81120278:	2027883a 	mov	r19,r4
8112027c:	002f883a 	mov	r23,zero
81120280:	05800044 	movi	r22,1
81120284:	04bfffc4 	movi	r18,-1
81120288:	a4400117 	ldw	r17,4(r20)
8112028c:	a4000217 	ldw	r16,8(r20)
81120290:	8c7fffc4 	addi	r17,r17,-1
81120294:	88000c16 	blt	r17,zero,811202c8 <_fwalk_reent+0x8c>
81120298:	84000304 	addi	r16,r16,12
8112029c:	8080000b 	ldhu	r2,0(r16)
811202a0:	8c7fffc4 	addi	r17,r17,-1
811202a4:	817ffd04 	addi	r5,r16,-12
811202a8:	b080052e 	bgeu	r22,r2,811202c0 <_fwalk_reent+0x84>
811202ac:	8080008f 	ldh	r2,2(r16)
811202b0:	9809883a 	mov	r4,r19
811202b4:	14800226 	beq	r2,r18,811202c0 <_fwalk_reent+0x84>
811202b8:	a83ee83a 	callr	r21
811202bc:	b8aeb03a 	or	r23,r23,r2
811202c0:	84001a04 	addi	r16,r16,104
811202c4:	8cbff51e 	bne	r17,r18,8112029c <__reset+0xfb10029c>
811202c8:	a5000017 	ldw	r20,0(r20)
811202cc:	a03fee1e 	bne	r20,zero,81120288 <__reset+0xfb100288>
811202d0:	b805883a 	mov	r2,r23
811202d4:	dfc00817 	ldw	ra,32(sp)
811202d8:	ddc00717 	ldw	r23,28(sp)
811202dc:	dd800617 	ldw	r22,24(sp)
811202e0:	dd400517 	ldw	r21,20(sp)
811202e4:	dd000417 	ldw	r20,16(sp)
811202e8:	dcc00317 	ldw	r19,12(sp)
811202ec:	dc800217 	ldw	r18,8(sp)
811202f0:	dc400117 	ldw	r17,4(sp)
811202f4:	dc000017 	ldw	r16,0(sp)
811202f8:	dec00904 	addi	sp,sp,36
811202fc:	f800283a 	ret
81120300:	002f883a 	mov	r23,zero
81120304:	003ff206 	br	811202d0 <__reset+0xfb1002d0>

81120308 <_isatty_r>:
81120308:	defffd04 	addi	sp,sp,-12
8112030c:	de00012e 	bgeu	sp,et,81120314 <_isatty_r+0xc>
81120310:	003b68fa 	trap	3
81120314:	dc000015 	stw	r16,0(sp)
81120318:	04204534 	movhi	r16,33044
8112031c:	dc400115 	stw	r17,4(sp)
81120320:	841b5004 	addi	r16,r16,27968
81120324:	2023883a 	mov	r17,r4
81120328:	2809883a 	mov	r4,r5
8112032c:	dfc00215 	stw	ra,8(sp)
81120330:	80000015 	stw	zero,0(r16)
81120334:	112b4580 	call	8112b458 <isatty>
81120338:	00ffffc4 	movi	r3,-1
8112033c:	10c00526 	beq	r2,r3,81120354 <_isatty_r+0x4c>
81120340:	dfc00217 	ldw	ra,8(sp)
81120344:	dc400117 	ldw	r17,4(sp)
81120348:	dc000017 	ldw	r16,0(sp)
8112034c:	dec00304 	addi	sp,sp,12
81120350:	f800283a 	ret
81120354:	80c00017 	ldw	r3,0(r16)
81120358:	183ff926 	beq	r3,zero,81120340 <__reset+0xfb100340>
8112035c:	88c00015 	stw	r3,0(r17)
81120360:	003ff706 	br	81120340 <__reset+0xfb100340>

81120364 <iswspace>:
81120364:	00803fc4 	movi	r2,255
81120368:	11000836 	bltu	r2,r4,8112038c <iswspace+0x28>
8112036c:	00a04534 	movhi	r2,33044
81120370:	109aeb04 	addi	r2,r2,27564
81120374:	10800017 	ldw	r2,0(r2)
81120378:	1109883a 	add	r4,r2,r4
8112037c:	20800043 	ldbu	r2,1(r4)
81120380:	1080020c 	andi	r2,r2,8
81120384:	10803fcc 	andi	r2,r2,255
81120388:	f800283a 	ret
8112038c:	0005883a 	mov	r2,zero
81120390:	f800283a 	ret

81120394 <_setlocale_r>:
81120394:	30001d26 	beq	r6,zero,8112040c <_setlocale_r+0x78>
81120398:	01604534 	movhi	r5,33044
8112039c:	defffe04 	addi	sp,sp,-8
811203a0:	29514404 	addi	r5,r5,17680
811203a4:	3009883a 	mov	r4,r6
811203a8:	de00012e 	bgeu	sp,et,811203b0 <_setlocale_r+0x1c>
811203ac:	003b68fa 	trap	3
811203b0:	dc000015 	stw	r16,0(sp)
811203b4:	dfc00115 	stw	ra,4(sp)
811203b8:	3021883a 	mov	r16,r6
811203bc:	11220e00 	call	811220e0 <strcmp>
811203c0:	1000061e 	bne	r2,zero,811203dc <_setlocale_r+0x48>
811203c4:	00a04534 	movhi	r2,33044
811203c8:	10911304 	addi	r2,r2,17484
811203cc:	dfc00117 	ldw	ra,4(sp)
811203d0:	dc000017 	ldw	r16,0(sp)
811203d4:	dec00204 	addi	sp,sp,8
811203d8:	f800283a 	ret
811203dc:	01604534 	movhi	r5,33044
811203e0:	29511304 	addi	r5,r5,17484
811203e4:	8009883a 	mov	r4,r16
811203e8:	11220e00 	call	811220e0 <strcmp>
811203ec:	103ff526 	beq	r2,zero,811203c4 <__reset+0xfb1003c4>
811203f0:	01604534 	movhi	r5,33044
811203f4:	29511d04 	addi	r5,r5,17524
811203f8:	8009883a 	mov	r4,r16
811203fc:	11220e00 	call	811220e0 <strcmp>
81120400:	103ff026 	beq	r2,zero,811203c4 <__reset+0xfb1003c4>
81120404:	0005883a 	mov	r2,zero
81120408:	003ff006 	br	811203cc <__reset+0xfb1003cc>
8112040c:	00a04534 	movhi	r2,33044
81120410:	10911304 	addi	r2,r2,17484
81120414:	f800283a 	ret

81120418 <__locale_charset>:
81120418:	00a04534 	movhi	r2,33044
8112041c:	1095b504 	addi	r2,r2,22228
81120420:	f800283a 	ret

81120424 <__locale_mb_cur_max>:
81120424:	00a04534 	movhi	r2,33044
81120428:	109af004 	addi	r2,r2,27584
8112042c:	10800017 	ldw	r2,0(r2)
81120430:	f800283a 	ret

81120434 <__locale_msgcharset>:
81120434:	00a04534 	movhi	r2,33044
81120438:	1095ad04 	addi	r2,r2,22196
8112043c:	f800283a 	ret

81120440 <__locale_cjk_lang>:
81120440:	0005883a 	mov	r2,zero
81120444:	f800283a 	ret

81120448 <_localeconv_r>:
81120448:	00a04534 	movhi	r2,33044
8112044c:	1095bd04 	addi	r2,r2,22260
81120450:	f800283a 	ret

81120454 <setlocale>:
81120454:	00a04534 	movhi	r2,33044
81120458:	109aed04 	addi	r2,r2,27572
8112045c:	280d883a 	mov	r6,r5
81120460:	200b883a 	mov	r5,r4
81120464:	11000017 	ldw	r4,0(r2)
81120468:	11203941 	jmpi	81120394 <_setlocale_r>

8112046c <localeconv>:
8112046c:	00a04534 	movhi	r2,33044
81120470:	1095bd04 	addi	r2,r2,22260
81120474:	f800283a 	ret

81120478 <_lseek_r>:
81120478:	defffd04 	addi	sp,sp,-12
8112047c:	de00012e 	bgeu	sp,et,81120484 <_lseek_r+0xc>
81120480:	003b68fa 	trap	3
81120484:	2805883a 	mov	r2,r5
81120488:	dc000015 	stw	r16,0(sp)
8112048c:	04204534 	movhi	r16,33044
81120490:	dc400115 	stw	r17,4(sp)
81120494:	300b883a 	mov	r5,r6
81120498:	841b5004 	addi	r16,r16,27968
8112049c:	2023883a 	mov	r17,r4
811204a0:	380d883a 	mov	r6,r7
811204a4:	1009883a 	mov	r4,r2
811204a8:	dfc00215 	stw	ra,8(sp)
811204ac:	80000015 	stw	zero,0(r16)
811204b0:	112c0540 	call	8112c054 <lseek>
811204b4:	00ffffc4 	movi	r3,-1
811204b8:	10c00526 	beq	r2,r3,811204d0 <_lseek_r+0x58>
811204bc:	dfc00217 	ldw	ra,8(sp)
811204c0:	dc400117 	ldw	r17,4(sp)
811204c4:	dc000017 	ldw	r16,0(sp)
811204c8:	dec00304 	addi	sp,sp,12
811204cc:	f800283a 	ret
811204d0:	80c00017 	ldw	r3,0(r16)
811204d4:	183ff926 	beq	r3,zero,811204bc <__reset+0xfb1004bc>
811204d8:	88c00015 	stw	r3,0(r17)
811204dc:	003ff706 	br	811204bc <__reset+0xfb1004bc>

811204e0 <_mbrtowc_r>:
811204e0:	defff704 	addi	sp,sp,-36
811204e4:	00a04534 	movhi	r2,33044
811204e8:	de00012e 	bgeu	sp,et,811204f0 <_mbrtowc_r+0x10>
811204ec:	003b68fa 	trap	3
811204f0:	109af104 	addi	r2,r2,27588
811204f4:	dc800715 	stw	r18,28(sp)
811204f8:	dc400615 	stw	r17,24(sp)
811204fc:	dc000515 	stw	r16,20(sp)
81120500:	dfc00815 	stw	ra,32(sp)
81120504:	2021883a 	mov	r16,r4
81120508:	dc400917 	ldw	r17,36(sp)
8112050c:	14800017 	ldw	r18,0(r2)
81120510:	30001626 	beq	r6,zero,8112056c <_mbrtowc_r+0x8c>
81120514:	d9400215 	stw	r5,8(sp)
81120518:	d9800315 	stw	r6,12(sp)
8112051c:	d9c00415 	stw	r7,16(sp)
81120520:	11204180 	call	81120418 <__locale_charset>
81120524:	d9c00417 	ldw	r7,16(sp)
81120528:	d9800317 	ldw	r6,12(sp)
8112052c:	d9400217 	ldw	r5,8(sp)
81120530:	d8800015 	stw	r2,0(sp)
81120534:	dc400115 	stw	r17,4(sp)
81120538:	8009883a 	mov	r4,r16
8112053c:	903ee83a 	callr	r18
81120540:	00ffffc4 	movi	r3,-1
81120544:	10c0031e 	bne	r2,r3,81120554 <_mbrtowc_r+0x74>
81120548:	88000015 	stw	zero,0(r17)
8112054c:	00c02284 	movi	r3,138
81120550:	80c00015 	stw	r3,0(r16)
81120554:	dfc00817 	ldw	ra,32(sp)
81120558:	dc800717 	ldw	r18,28(sp)
8112055c:	dc400617 	ldw	r17,24(sp)
81120560:	dc000517 	ldw	r16,20(sp)
81120564:	dec00904 	addi	sp,sp,36
81120568:	f800283a 	ret
8112056c:	11204180 	call	81120418 <__locale_charset>
81120570:	01a04534 	movhi	r6,33044
81120574:	31911d04 	addi	r6,r6,17524
81120578:	dc400115 	stw	r17,4(sp)
8112057c:	d8800015 	stw	r2,0(sp)
81120580:	01c00044 	movi	r7,1
81120584:	000b883a 	mov	r5,zero
81120588:	8009883a 	mov	r4,r16
8112058c:	903ee83a 	callr	r18
81120590:	003feb06 	br	81120540 <__reset+0xfb100540>

81120594 <mbrtowc>:
81120594:	defff704 	addi	sp,sp,-36
81120598:	00a04534 	movhi	r2,33044
8112059c:	de00012e 	bgeu	sp,et,811205a4 <mbrtowc+0x10>
811205a0:	003b68fa 	trap	3
811205a4:	109aed04 	addi	r2,r2,27572
811205a8:	dc800415 	stw	r18,16(sp)
811205ac:	dc400315 	stw	r17,12(sp)
811205b0:	dfc00815 	stw	ra,32(sp)
811205b4:	dd400715 	stw	r21,28(sp)
811205b8:	dd000615 	stw	r20,24(sp)
811205bc:	dcc00515 	stw	r19,20(sp)
811205c0:	dc000215 	stw	r16,8(sp)
811205c4:	3825883a 	mov	r18,r7
811205c8:	14400017 	ldw	r17,0(r2)
811205cc:	28001c26 	beq	r5,zero,81120640 <mbrtowc+0xac>
811205d0:	00a04534 	movhi	r2,33044
811205d4:	109af104 	addi	r2,r2,27588
811205d8:	15400017 	ldw	r21,0(r2)
811205dc:	2821883a 	mov	r16,r5
811205e0:	2027883a 	mov	r19,r4
811205e4:	3029883a 	mov	r20,r6
811205e8:	11204180 	call	81120418 <__locale_charset>
811205ec:	d8800015 	stw	r2,0(sp)
811205f0:	dc800115 	stw	r18,4(sp)
811205f4:	a00f883a 	mov	r7,r20
811205f8:	800d883a 	mov	r6,r16
811205fc:	980b883a 	mov	r5,r19
81120600:	8809883a 	mov	r4,r17
81120604:	a83ee83a 	callr	r21
81120608:	00ffffc4 	movi	r3,-1
8112060c:	10c0031e 	bne	r2,r3,8112061c <mbrtowc+0x88>
81120610:	90000015 	stw	zero,0(r18)
81120614:	00c02284 	movi	r3,138
81120618:	88c00015 	stw	r3,0(r17)
8112061c:	dfc00817 	ldw	ra,32(sp)
81120620:	dd400717 	ldw	r21,28(sp)
81120624:	dd000617 	ldw	r20,24(sp)
81120628:	dcc00517 	ldw	r19,20(sp)
8112062c:	dc800417 	ldw	r18,16(sp)
81120630:	dc400317 	ldw	r17,12(sp)
81120634:	dc000217 	ldw	r16,8(sp)
81120638:	dec00904 	addi	sp,sp,36
8112063c:	f800283a 	ret
81120640:	00a04534 	movhi	r2,33044
81120644:	109af104 	addi	r2,r2,27588
81120648:	14000017 	ldw	r16,0(r2)
8112064c:	11204180 	call	81120418 <__locale_charset>
81120650:	01a04534 	movhi	r6,33044
81120654:	31911d04 	addi	r6,r6,17524
81120658:	dc800115 	stw	r18,4(sp)
8112065c:	d8800015 	stw	r2,0(sp)
81120660:	01c00044 	movi	r7,1
81120664:	000b883a 	mov	r5,zero
81120668:	8809883a 	mov	r4,r17
8112066c:	803ee83a 	callr	r16
81120670:	003fe506 	br	81120608 <__reset+0xfb100608>

81120674 <__ascii_mbtowc>:
81120674:	deffff04 	addi	sp,sp,-4
81120678:	de00012e 	bgeu	sp,et,81120680 <__ascii_mbtowc+0xc>
8112067c:	003b68fa 	trap	3
81120680:	28000826 	beq	r5,zero,811206a4 <__ascii_mbtowc+0x30>
81120684:	30000926 	beq	r6,zero,811206ac <__ascii_mbtowc+0x38>
81120688:	38000b26 	beq	r7,zero,811206b8 <__ascii_mbtowc+0x44>
8112068c:	30800003 	ldbu	r2,0(r6)
81120690:	28800015 	stw	r2,0(r5)
81120694:	30800003 	ldbu	r2,0(r6)
81120698:	1004c03a 	cmpne	r2,r2,zero
8112069c:	dec00104 	addi	sp,sp,4
811206a0:	f800283a 	ret
811206a4:	d80b883a 	mov	r5,sp
811206a8:	303ff71e 	bne	r6,zero,81120688 <__reset+0xfb100688>
811206ac:	0005883a 	mov	r2,zero
811206b0:	dec00104 	addi	sp,sp,4
811206b4:	f800283a 	ret
811206b8:	00bfff84 	movi	r2,-2
811206bc:	003ff706 	br	8112069c <__reset+0xfb10069c>

811206c0 <_mbtowc_r>:
811206c0:	00a04534 	movhi	r2,33044
811206c4:	defff804 	addi	sp,sp,-32
811206c8:	109af104 	addi	r2,r2,27588
811206cc:	de00012e 	bgeu	sp,et,811206d4 <_mbtowc_r+0x14>
811206d0:	003b68fa 	trap	3
811206d4:	dfc00715 	stw	ra,28(sp)
811206d8:	dc000615 	stw	r16,24(sp)
811206dc:	14000017 	ldw	r16,0(r2)
811206e0:	d9000215 	stw	r4,8(sp)
811206e4:	d9400315 	stw	r5,12(sp)
811206e8:	d9800415 	stw	r6,16(sp)
811206ec:	d9c00515 	stw	r7,20(sp)
811206f0:	11204180 	call	81120418 <__locale_charset>
811206f4:	d8800015 	stw	r2,0(sp)
811206f8:	d8800817 	ldw	r2,32(sp)
811206fc:	d9c00517 	ldw	r7,20(sp)
81120700:	d9800417 	ldw	r6,16(sp)
81120704:	d9400317 	ldw	r5,12(sp)
81120708:	d9000217 	ldw	r4,8(sp)
8112070c:	d8800115 	stw	r2,4(sp)
81120710:	803ee83a 	callr	r16
81120714:	dfc00717 	ldw	ra,28(sp)
81120718:	dc000617 	ldw	r16,24(sp)
8112071c:	dec00804 	addi	sp,sp,32
81120720:	f800283a 	ret

81120724 <memchr>:
81120724:	208000cc 	andi	r2,r4,3
81120728:	280f883a 	mov	r7,r5
8112072c:	10003426 	beq	r2,zero,81120800 <memchr+0xdc>
81120730:	30bfffc4 	addi	r2,r6,-1
81120734:	30001a26 	beq	r6,zero,811207a0 <memchr+0x7c>
81120738:	20c00003 	ldbu	r3,0(r4)
8112073c:	29803fcc 	andi	r6,r5,255
81120740:	30c0051e 	bne	r6,r3,81120758 <memchr+0x34>
81120744:	00001806 	br	811207a8 <memchr+0x84>
81120748:	10001526 	beq	r2,zero,811207a0 <memchr+0x7c>
8112074c:	20c00003 	ldbu	r3,0(r4)
81120750:	10bfffc4 	addi	r2,r2,-1
81120754:	30c01426 	beq	r6,r3,811207a8 <memchr+0x84>
81120758:	21000044 	addi	r4,r4,1
8112075c:	20c000cc 	andi	r3,r4,3
81120760:	183ff91e 	bne	r3,zero,81120748 <__reset+0xfb100748>
81120764:	020000c4 	movi	r8,3
81120768:	40801136 	bltu	r8,r2,811207b0 <memchr+0x8c>
8112076c:	10000c26 	beq	r2,zero,811207a0 <memchr+0x7c>
81120770:	20c00003 	ldbu	r3,0(r4)
81120774:	29403fcc 	andi	r5,r5,255
81120778:	28c00b26 	beq	r5,r3,811207a8 <memchr+0x84>
8112077c:	20c00044 	addi	r3,r4,1
81120780:	39803fcc 	andi	r6,r7,255
81120784:	2089883a 	add	r4,r4,r2
81120788:	00000306 	br	81120798 <memchr+0x74>
8112078c:	18c00044 	addi	r3,r3,1
81120790:	197fffc3 	ldbu	r5,-1(r3)
81120794:	31400526 	beq	r6,r5,811207ac <memchr+0x88>
81120798:	1805883a 	mov	r2,r3
8112079c:	20fffb1e 	bne	r4,r3,8112078c <__reset+0xfb10078c>
811207a0:	0005883a 	mov	r2,zero
811207a4:	f800283a 	ret
811207a8:	2005883a 	mov	r2,r4
811207ac:	f800283a 	ret
811207b0:	28c03fcc 	andi	r3,r5,255
811207b4:	1812923a 	slli	r9,r3,8
811207b8:	02ffbff4 	movhi	r11,65279
811207bc:	02a02074 	movhi	r10,32897
811207c0:	48d2b03a 	or	r9,r9,r3
811207c4:	4806943a 	slli	r3,r9,16
811207c8:	5affbfc4 	addi	r11,r11,-257
811207cc:	52a02004 	addi	r10,r10,-32640
811207d0:	48d2b03a 	or	r9,r9,r3
811207d4:	20c00017 	ldw	r3,0(r4)
811207d8:	48c6f03a 	xor	r3,r9,r3
811207dc:	1acd883a 	add	r6,r3,r11
811207e0:	00c6303a 	nor	r3,zero,r3
811207e4:	30c6703a 	and	r3,r6,r3
811207e8:	1a86703a 	and	r3,r3,r10
811207ec:	183fe01e 	bne	r3,zero,81120770 <__reset+0xfb100770>
811207f0:	10bfff04 	addi	r2,r2,-4
811207f4:	21000104 	addi	r4,r4,4
811207f8:	40bff636 	bltu	r8,r2,811207d4 <__reset+0xfb1007d4>
811207fc:	003fdb06 	br	8112076c <__reset+0xfb10076c>
81120800:	3005883a 	mov	r2,r6
81120804:	003fd706 	br	81120764 <__reset+0xfb100764>

81120808 <memmove>:
81120808:	2005883a 	mov	r2,r4
8112080c:	29000b2e 	bgeu	r5,r4,8112083c <memmove+0x34>
81120810:	298f883a 	add	r7,r5,r6
81120814:	21c0092e 	bgeu	r4,r7,8112083c <memmove+0x34>
81120818:	2187883a 	add	r3,r4,r6
8112081c:	198bc83a 	sub	r5,r3,r6
81120820:	30004826 	beq	r6,zero,81120944 <memmove+0x13c>
81120824:	39ffffc4 	addi	r7,r7,-1
81120828:	39000003 	ldbu	r4,0(r7)
8112082c:	18ffffc4 	addi	r3,r3,-1
81120830:	19000005 	stb	r4,0(r3)
81120834:	28fffb1e 	bne	r5,r3,81120824 <__reset+0xfb100824>
81120838:	f800283a 	ret
8112083c:	00c003c4 	movi	r3,15
81120840:	1980412e 	bgeu	r3,r6,81120948 <memmove+0x140>
81120844:	2886b03a 	or	r3,r5,r2
81120848:	18c000cc 	andi	r3,r3,3
8112084c:	1800401e 	bne	r3,zero,81120950 <memmove+0x148>
81120850:	33fffc04 	addi	r15,r6,-16
81120854:	781ed13a 	srli	r15,r15,4
81120858:	28c00104 	addi	r3,r5,4
8112085c:	13400104 	addi	r13,r2,4
81120860:	781c913a 	slli	r14,r15,4
81120864:	2b000204 	addi	r12,r5,8
81120868:	12c00204 	addi	r11,r2,8
8112086c:	73800504 	addi	r14,r14,20
81120870:	2a800304 	addi	r10,r5,12
81120874:	12400304 	addi	r9,r2,12
81120878:	2b9d883a 	add	r14,r5,r14
8112087c:	2811883a 	mov	r8,r5
81120880:	100f883a 	mov	r7,r2
81120884:	41000017 	ldw	r4,0(r8)
81120888:	39c00404 	addi	r7,r7,16
8112088c:	18c00404 	addi	r3,r3,16
81120890:	393ffc15 	stw	r4,-16(r7)
81120894:	193ffc17 	ldw	r4,-16(r3)
81120898:	6b400404 	addi	r13,r13,16
8112089c:	5ac00404 	addi	r11,r11,16
811208a0:	693ffc15 	stw	r4,-16(r13)
811208a4:	61000017 	ldw	r4,0(r12)
811208a8:	4a400404 	addi	r9,r9,16
811208ac:	42000404 	addi	r8,r8,16
811208b0:	593ffc15 	stw	r4,-16(r11)
811208b4:	51000017 	ldw	r4,0(r10)
811208b8:	63000404 	addi	r12,r12,16
811208bc:	52800404 	addi	r10,r10,16
811208c0:	493ffc15 	stw	r4,-16(r9)
811208c4:	1bbfef1e 	bne	r3,r14,81120884 <__reset+0xfb100884>
811208c8:	79000044 	addi	r4,r15,1
811208cc:	2008913a 	slli	r4,r4,4
811208d0:	328003cc 	andi	r10,r6,15
811208d4:	02c000c4 	movi	r11,3
811208d8:	1107883a 	add	r3,r2,r4
811208dc:	290b883a 	add	r5,r5,r4
811208e0:	5a801e2e 	bgeu	r11,r10,8112095c <memmove+0x154>
811208e4:	1813883a 	mov	r9,r3
811208e8:	2811883a 	mov	r8,r5
811208ec:	500f883a 	mov	r7,r10
811208f0:	41000017 	ldw	r4,0(r8)
811208f4:	4a400104 	addi	r9,r9,4
811208f8:	39ffff04 	addi	r7,r7,-4
811208fc:	493fff15 	stw	r4,-4(r9)
81120900:	42000104 	addi	r8,r8,4
81120904:	59fffa36 	bltu	r11,r7,811208f0 <__reset+0xfb1008f0>
81120908:	513fff04 	addi	r4,r10,-4
8112090c:	2008d0ba 	srli	r4,r4,2
81120910:	318000cc 	andi	r6,r6,3
81120914:	21000044 	addi	r4,r4,1
81120918:	2109883a 	add	r4,r4,r4
8112091c:	2109883a 	add	r4,r4,r4
81120920:	1907883a 	add	r3,r3,r4
81120924:	290b883a 	add	r5,r5,r4
81120928:	30000b26 	beq	r6,zero,81120958 <memmove+0x150>
8112092c:	198d883a 	add	r6,r3,r6
81120930:	29c00003 	ldbu	r7,0(r5)
81120934:	18c00044 	addi	r3,r3,1
81120938:	29400044 	addi	r5,r5,1
8112093c:	19ffffc5 	stb	r7,-1(r3)
81120940:	19bffb1e 	bne	r3,r6,81120930 <__reset+0xfb100930>
81120944:	f800283a 	ret
81120948:	1007883a 	mov	r3,r2
8112094c:	003ff606 	br	81120928 <__reset+0xfb100928>
81120950:	1007883a 	mov	r3,r2
81120954:	003ff506 	br	8112092c <__reset+0xfb10092c>
81120958:	f800283a 	ret
8112095c:	500d883a 	mov	r6,r10
81120960:	003ff106 	br	81120928 <__reset+0xfb100928>

81120964 <_Balloc>:
81120964:	defffc04 	addi	sp,sp,-16
81120968:	de00012e 	bgeu	sp,et,81120970 <_Balloc+0xc>
8112096c:	003b68fa 	trap	3
81120970:	20801317 	ldw	r2,76(r4)
81120974:	dc400115 	stw	r17,4(sp)
81120978:	dc000015 	stw	r16,0(sp)
8112097c:	dfc00315 	stw	ra,12(sp)
81120980:	dc800215 	stw	r18,8(sp)
81120984:	2023883a 	mov	r17,r4
81120988:	2821883a 	mov	r16,r5
8112098c:	10000f26 	beq	r2,zero,811209cc <_Balloc+0x68>
81120990:	8407883a 	add	r3,r16,r16
81120994:	18c7883a 	add	r3,r3,r3
81120998:	10c7883a 	add	r3,r2,r3
8112099c:	18800017 	ldw	r2,0(r3)
811209a0:	10001126 	beq	r2,zero,811209e8 <_Balloc+0x84>
811209a4:	11000017 	ldw	r4,0(r2)
811209a8:	19000015 	stw	r4,0(r3)
811209ac:	10000415 	stw	zero,16(r2)
811209b0:	10000315 	stw	zero,12(r2)
811209b4:	dfc00317 	ldw	ra,12(sp)
811209b8:	dc800217 	ldw	r18,8(sp)
811209bc:	dc400117 	ldw	r17,4(sp)
811209c0:	dc000017 	ldw	r16,0(sp)
811209c4:	dec00404 	addi	sp,sp,16
811209c8:	f800283a 	ret
811209cc:	01800844 	movi	r6,33
811209d0:	01400104 	movi	r5,4
811209d4:	1126e8c0 	call	81126e8c <_calloc_r>
811209d8:	88801315 	stw	r2,76(r17)
811209dc:	103fec1e 	bne	r2,zero,81120990 <__reset+0xfb100990>
811209e0:	0005883a 	mov	r2,zero
811209e4:	003ff306 	br	811209b4 <__reset+0xfb1009b4>
811209e8:	01400044 	movi	r5,1
811209ec:	2c24983a 	sll	r18,r5,r16
811209f0:	8809883a 	mov	r4,r17
811209f4:	91800144 	addi	r6,r18,5
811209f8:	318d883a 	add	r6,r6,r6
811209fc:	318d883a 	add	r6,r6,r6
81120a00:	1126e8c0 	call	81126e8c <_calloc_r>
81120a04:	103ff626 	beq	r2,zero,811209e0 <__reset+0xfb1009e0>
81120a08:	14000115 	stw	r16,4(r2)
81120a0c:	14800215 	stw	r18,8(r2)
81120a10:	003fe606 	br	811209ac <__reset+0xfb1009ac>

81120a14 <_Bfree>:
81120a14:	28000826 	beq	r5,zero,81120a38 <_Bfree+0x24>
81120a18:	28c00117 	ldw	r3,4(r5)
81120a1c:	20801317 	ldw	r2,76(r4)
81120a20:	18c7883a 	add	r3,r3,r3
81120a24:	18c7883a 	add	r3,r3,r3
81120a28:	10c5883a 	add	r2,r2,r3
81120a2c:	10c00017 	ldw	r3,0(r2)
81120a30:	28c00015 	stw	r3,0(r5)
81120a34:	11400015 	stw	r5,0(r2)
81120a38:	f800283a 	ret

81120a3c <__multadd>:
81120a3c:	defffa04 	addi	sp,sp,-24
81120a40:	de00012e 	bgeu	sp,et,81120a48 <__multadd+0xc>
81120a44:	003b68fa 	trap	3
81120a48:	0011883a 	mov	r8,zero
81120a4c:	dc800315 	stw	r18,12(sp)
81120a50:	dc400215 	stw	r17,8(sp)
81120a54:	dc000115 	stw	r16,4(sp)
81120a58:	2823883a 	mov	r17,r5
81120a5c:	2c000417 	ldw	r16,16(r5)
81120a60:	dfc00515 	stw	ra,20(sp)
81120a64:	dcc00415 	stw	r19,16(sp)
81120a68:	2025883a 	mov	r18,r4
81120a6c:	29400504 	addi	r5,r5,20
81120a70:	28c00017 	ldw	r3,0(r5)
81120a74:	29400104 	addi	r5,r5,4
81120a78:	42000044 	addi	r8,r8,1
81120a7c:	18bfffcc 	andi	r2,r3,65535
81120a80:	1185383a 	mul	r2,r2,r6
81120a84:	1806d43a 	srli	r3,r3,16
81120a88:	11cf883a 	add	r7,r2,r7
81120a8c:	3808d43a 	srli	r4,r7,16
81120a90:	1987383a 	mul	r3,r3,r6
81120a94:	38bfffcc 	andi	r2,r7,65535
81120a98:	1907883a 	add	r3,r3,r4
81120a9c:	1808943a 	slli	r4,r3,16
81120aa0:	180ed43a 	srli	r7,r3,16
81120aa4:	2085883a 	add	r2,r4,r2
81120aa8:	28bfff15 	stw	r2,-4(r5)
81120aac:	443ff016 	blt	r8,r16,81120a70 <__reset+0xfb100a70>
81120ab0:	38000926 	beq	r7,zero,81120ad8 <__multadd+0x9c>
81120ab4:	88800217 	ldw	r2,8(r17)
81120ab8:	80800f0e 	bge	r16,r2,81120af8 <__multadd+0xbc>
81120abc:	80800144 	addi	r2,r16,5
81120ac0:	1085883a 	add	r2,r2,r2
81120ac4:	1085883a 	add	r2,r2,r2
81120ac8:	8885883a 	add	r2,r17,r2
81120acc:	11c00015 	stw	r7,0(r2)
81120ad0:	84000044 	addi	r16,r16,1
81120ad4:	8c000415 	stw	r16,16(r17)
81120ad8:	8805883a 	mov	r2,r17
81120adc:	dfc00517 	ldw	ra,20(sp)
81120ae0:	dcc00417 	ldw	r19,16(sp)
81120ae4:	dc800317 	ldw	r18,12(sp)
81120ae8:	dc400217 	ldw	r17,8(sp)
81120aec:	dc000117 	ldw	r16,4(sp)
81120af0:	dec00604 	addi	sp,sp,24
81120af4:	f800283a 	ret
81120af8:	89400117 	ldw	r5,4(r17)
81120afc:	9009883a 	mov	r4,r18
81120b00:	d9c00015 	stw	r7,0(sp)
81120b04:	29400044 	addi	r5,r5,1
81120b08:	11209640 	call	81120964 <_Balloc>
81120b0c:	89800417 	ldw	r6,16(r17)
81120b10:	89400304 	addi	r5,r17,12
81120b14:	11000304 	addi	r4,r2,12
81120b18:	31800084 	addi	r6,r6,2
81120b1c:	318d883a 	add	r6,r6,r6
81120b20:	318d883a 	add	r6,r6,r6
81120b24:	1027883a 	mov	r19,r2
81120b28:	11167340 	call	81116734 <memcpy>
81120b2c:	d9c00017 	ldw	r7,0(sp)
81120b30:	88000a26 	beq	r17,zero,81120b5c <__multadd+0x120>
81120b34:	88c00117 	ldw	r3,4(r17)
81120b38:	90801317 	ldw	r2,76(r18)
81120b3c:	18c7883a 	add	r3,r3,r3
81120b40:	18c7883a 	add	r3,r3,r3
81120b44:	10c5883a 	add	r2,r2,r3
81120b48:	10c00017 	ldw	r3,0(r2)
81120b4c:	88c00015 	stw	r3,0(r17)
81120b50:	14400015 	stw	r17,0(r2)
81120b54:	9823883a 	mov	r17,r19
81120b58:	003fd806 	br	81120abc <__reset+0xfb100abc>
81120b5c:	9823883a 	mov	r17,r19
81120b60:	003fd606 	br	81120abc <__reset+0xfb100abc>

81120b64 <__s2b>:
81120b64:	defff904 	addi	sp,sp,-28
81120b68:	de00012e 	bgeu	sp,et,81120b70 <__s2b+0xc>
81120b6c:	003b68fa 	trap	3
81120b70:	dc400115 	stw	r17,4(sp)
81120b74:	dc000015 	stw	r16,0(sp)
81120b78:	2023883a 	mov	r17,r4
81120b7c:	2821883a 	mov	r16,r5
81120b80:	39000204 	addi	r4,r7,8
81120b84:	01400244 	movi	r5,9
81120b88:	dcc00315 	stw	r19,12(sp)
81120b8c:	dc800215 	stw	r18,8(sp)
81120b90:	dfc00615 	stw	ra,24(sp)
81120b94:	dd400515 	stw	r21,20(sp)
81120b98:	dd000415 	stw	r20,16(sp)
81120b9c:	3825883a 	mov	r18,r7
81120ba0:	3027883a 	mov	r19,r6
81120ba4:	1128c240 	call	81128c24 <__divsi3>
81120ba8:	00c00044 	movi	r3,1
81120bac:	000b883a 	mov	r5,zero
81120bb0:	1880030e 	bge	r3,r2,81120bc0 <__s2b+0x5c>
81120bb4:	18c7883a 	add	r3,r3,r3
81120bb8:	29400044 	addi	r5,r5,1
81120bbc:	18bffd16 	blt	r3,r2,81120bb4 <__reset+0xfb100bb4>
81120bc0:	8809883a 	mov	r4,r17
81120bc4:	11209640 	call	81120964 <_Balloc>
81120bc8:	d8c00717 	ldw	r3,28(sp)
81120bcc:	10c00515 	stw	r3,20(r2)
81120bd0:	00c00044 	movi	r3,1
81120bd4:	10c00415 	stw	r3,16(r2)
81120bd8:	00c00244 	movi	r3,9
81120bdc:	1cc0210e 	bge	r3,r19,81120c64 <__s2b+0x100>
81120be0:	80eb883a 	add	r21,r16,r3
81120be4:	a829883a 	mov	r20,r21
81120be8:	84e1883a 	add	r16,r16,r19
81120bec:	a1c00007 	ldb	r7,0(r20)
81120bf0:	01800284 	movi	r6,10
81120bf4:	a5000044 	addi	r20,r20,1
81120bf8:	100b883a 	mov	r5,r2
81120bfc:	39fff404 	addi	r7,r7,-48
81120c00:	8809883a 	mov	r4,r17
81120c04:	1120a3c0 	call	81120a3c <__multadd>
81120c08:	a43ff81e 	bne	r20,r16,81120bec <__reset+0xfb100bec>
81120c0c:	ace1883a 	add	r16,r21,r19
81120c10:	843ffe04 	addi	r16,r16,-8
81120c14:	9c800a0e 	bge	r19,r18,81120c40 <__s2b+0xdc>
81120c18:	94e5c83a 	sub	r18,r18,r19
81120c1c:	84a5883a 	add	r18,r16,r18
81120c20:	81c00007 	ldb	r7,0(r16)
81120c24:	01800284 	movi	r6,10
81120c28:	84000044 	addi	r16,r16,1
81120c2c:	100b883a 	mov	r5,r2
81120c30:	39fff404 	addi	r7,r7,-48
81120c34:	8809883a 	mov	r4,r17
81120c38:	1120a3c0 	call	81120a3c <__multadd>
81120c3c:	84bff81e 	bne	r16,r18,81120c20 <__reset+0xfb100c20>
81120c40:	dfc00617 	ldw	ra,24(sp)
81120c44:	dd400517 	ldw	r21,20(sp)
81120c48:	dd000417 	ldw	r20,16(sp)
81120c4c:	dcc00317 	ldw	r19,12(sp)
81120c50:	dc800217 	ldw	r18,8(sp)
81120c54:	dc400117 	ldw	r17,4(sp)
81120c58:	dc000017 	ldw	r16,0(sp)
81120c5c:	dec00704 	addi	sp,sp,28
81120c60:	f800283a 	ret
81120c64:	84000284 	addi	r16,r16,10
81120c68:	1827883a 	mov	r19,r3
81120c6c:	003fe906 	br	81120c14 <__reset+0xfb100c14>

81120c70 <__hi0bits>:
81120c70:	20bfffec 	andhi	r2,r4,65535
81120c74:	1000141e 	bne	r2,zero,81120cc8 <__hi0bits+0x58>
81120c78:	2008943a 	slli	r4,r4,16
81120c7c:	00800404 	movi	r2,16
81120c80:	20ffc02c 	andhi	r3,r4,65280
81120c84:	1800021e 	bne	r3,zero,81120c90 <__hi0bits+0x20>
81120c88:	2008923a 	slli	r4,r4,8
81120c8c:	10800204 	addi	r2,r2,8
81120c90:	20fc002c 	andhi	r3,r4,61440
81120c94:	1800021e 	bne	r3,zero,81120ca0 <__hi0bits+0x30>
81120c98:	2008913a 	slli	r4,r4,4
81120c9c:	10800104 	addi	r2,r2,4
81120ca0:	20f0002c 	andhi	r3,r4,49152
81120ca4:	1800031e 	bne	r3,zero,81120cb4 <__hi0bits+0x44>
81120ca8:	2109883a 	add	r4,r4,r4
81120cac:	10800084 	addi	r2,r2,2
81120cb0:	2109883a 	add	r4,r4,r4
81120cb4:	20000316 	blt	r4,zero,81120cc4 <__hi0bits+0x54>
81120cb8:	2110002c 	andhi	r4,r4,16384
81120cbc:	2000041e 	bne	r4,zero,81120cd0 <__hi0bits+0x60>
81120cc0:	00800804 	movi	r2,32
81120cc4:	f800283a 	ret
81120cc8:	0005883a 	mov	r2,zero
81120ccc:	003fec06 	br	81120c80 <__reset+0xfb100c80>
81120cd0:	10800044 	addi	r2,r2,1
81120cd4:	f800283a 	ret

81120cd8 <__lo0bits>:
81120cd8:	20c00017 	ldw	r3,0(r4)
81120cdc:	188001cc 	andi	r2,r3,7
81120ce0:	10000826 	beq	r2,zero,81120d04 <__lo0bits+0x2c>
81120ce4:	1880004c 	andi	r2,r3,1
81120ce8:	1000211e 	bne	r2,zero,81120d70 <__lo0bits+0x98>
81120cec:	1880008c 	andi	r2,r3,2
81120cf0:	1000211e 	bne	r2,zero,81120d78 <__lo0bits+0xa0>
81120cf4:	1806d0ba 	srli	r3,r3,2
81120cf8:	00800084 	movi	r2,2
81120cfc:	20c00015 	stw	r3,0(r4)
81120d00:	f800283a 	ret
81120d04:	18bfffcc 	andi	r2,r3,65535
81120d08:	10001326 	beq	r2,zero,81120d58 <__lo0bits+0x80>
81120d0c:	0005883a 	mov	r2,zero
81120d10:	19403fcc 	andi	r5,r3,255
81120d14:	2800021e 	bne	r5,zero,81120d20 <__lo0bits+0x48>
81120d18:	1806d23a 	srli	r3,r3,8
81120d1c:	10800204 	addi	r2,r2,8
81120d20:	194003cc 	andi	r5,r3,15
81120d24:	2800021e 	bne	r5,zero,81120d30 <__lo0bits+0x58>
81120d28:	1806d13a 	srli	r3,r3,4
81120d2c:	10800104 	addi	r2,r2,4
81120d30:	194000cc 	andi	r5,r3,3
81120d34:	2800021e 	bne	r5,zero,81120d40 <__lo0bits+0x68>
81120d38:	1806d0ba 	srli	r3,r3,2
81120d3c:	10800084 	addi	r2,r2,2
81120d40:	1940004c 	andi	r5,r3,1
81120d44:	2800081e 	bne	r5,zero,81120d68 <__lo0bits+0x90>
81120d48:	1806d07a 	srli	r3,r3,1
81120d4c:	1800051e 	bne	r3,zero,81120d64 <__lo0bits+0x8c>
81120d50:	00800804 	movi	r2,32
81120d54:	f800283a 	ret
81120d58:	1806d43a 	srli	r3,r3,16
81120d5c:	00800404 	movi	r2,16
81120d60:	003feb06 	br	81120d10 <__reset+0xfb100d10>
81120d64:	10800044 	addi	r2,r2,1
81120d68:	20c00015 	stw	r3,0(r4)
81120d6c:	f800283a 	ret
81120d70:	0005883a 	mov	r2,zero
81120d74:	f800283a 	ret
81120d78:	1806d07a 	srli	r3,r3,1
81120d7c:	00800044 	movi	r2,1
81120d80:	20c00015 	stw	r3,0(r4)
81120d84:	f800283a 	ret

81120d88 <__i2b>:
81120d88:	defffd04 	addi	sp,sp,-12
81120d8c:	de00012e 	bgeu	sp,et,81120d94 <__i2b+0xc>
81120d90:	003b68fa 	trap	3
81120d94:	dc000015 	stw	r16,0(sp)
81120d98:	04000044 	movi	r16,1
81120d9c:	dc400115 	stw	r17,4(sp)
81120da0:	2823883a 	mov	r17,r5
81120da4:	800b883a 	mov	r5,r16
81120da8:	dfc00215 	stw	ra,8(sp)
81120dac:	11209640 	call	81120964 <_Balloc>
81120db0:	14400515 	stw	r17,20(r2)
81120db4:	14000415 	stw	r16,16(r2)
81120db8:	dfc00217 	ldw	ra,8(sp)
81120dbc:	dc400117 	ldw	r17,4(sp)
81120dc0:	dc000017 	ldw	r16,0(sp)
81120dc4:	dec00304 	addi	sp,sp,12
81120dc8:	f800283a 	ret

81120dcc <__multiply>:
81120dcc:	defffa04 	addi	sp,sp,-24
81120dd0:	de00012e 	bgeu	sp,et,81120dd8 <__multiply+0xc>
81120dd4:	003b68fa 	trap	3
81120dd8:	dcc00315 	stw	r19,12(sp)
81120ddc:	dc800215 	stw	r18,8(sp)
81120de0:	34c00417 	ldw	r19,16(r6)
81120de4:	2c800417 	ldw	r18,16(r5)
81120de8:	dd000415 	stw	r20,16(sp)
81120dec:	dc400115 	stw	r17,4(sp)
81120df0:	dfc00515 	stw	ra,20(sp)
81120df4:	dc000015 	stw	r16,0(sp)
81120df8:	2829883a 	mov	r20,r5
81120dfc:	3023883a 	mov	r17,r6
81120e00:	94c0050e 	bge	r18,r19,81120e18 <__multiply+0x4c>
81120e04:	9007883a 	mov	r3,r18
81120e08:	3029883a 	mov	r20,r6
81120e0c:	9825883a 	mov	r18,r19
81120e10:	2823883a 	mov	r17,r5
81120e14:	1827883a 	mov	r19,r3
81120e18:	a0800217 	ldw	r2,8(r20)
81120e1c:	94e1883a 	add	r16,r18,r19
81120e20:	a1400117 	ldw	r5,4(r20)
81120e24:	1400010e 	bge	r2,r16,81120e2c <__multiply+0x60>
81120e28:	29400044 	addi	r5,r5,1
81120e2c:	11209640 	call	81120964 <_Balloc>
81120e30:	8415883a 	add	r10,r16,r16
81120e34:	12c00504 	addi	r11,r2,20
81120e38:	5295883a 	add	r10,r10,r10
81120e3c:	5a95883a 	add	r10,r11,r10
81120e40:	5807883a 	mov	r3,r11
81120e44:	5a80032e 	bgeu	r11,r10,81120e54 <__multiply+0x88>
81120e48:	18000015 	stw	zero,0(r3)
81120e4c:	18c00104 	addi	r3,r3,4
81120e50:	1abffd36 	bltu	r3,r10,81120e48 <__reset+0xfb100e48>
81120e54:	9ce7883a 	add	r19,r19,r19
81120e58:	94a5883a 	add	r18,r18,r18
81120e5c:	89800504 	addi	r6,r17,20
81120e60:	9ce7883a 	add	r19,r19,r19
81120e64:	a3400504 	addi	r13,r20,20
81120e68:	94a5883a 	add	r18,r18,r18
81120e6c:	34d9883a 	add	r12,r6,r19
81120e70:	6c93883a 	add	r9,r13,r18
81120e74:	3300422e 	bgeu	r6,r12,81120f80 <__multiply+0x1b4>
81120e78:	37c00017 	ldw	ra,0(r6)
81120e7c:	fbffffcc 	andi	r15,ra,65535
81120e80:	78001b26 	beq	r15,zero,81120ef0 <__multiply+0x124>
81120e84:	5811883a 	mov	r8,r11
81120e88:	681d883a 	mov	r14,r13
81120e8c:	000f883a 	mov	r7,zero
81120e90:	71000017 	ldw	r4,0(r14)
81120e94:	40c00017 	ldw	r3,0(r8)
81120e98:	73800104 	addi	r14,r14,4
81120e9c:	217fffcc 	andi	r5,r4,65535
81120ea0:	2bcb383a 	mul	r5,r5,r15
81120ea4:	2008d43a 	srli	r4,r4,16
81120ea8:	1c7fffcc 	andi	r17,r3,65535
81120eac:	2c4b883a 	add	r5,r5,r17
81120eb0:	29cb883a 	add	r5,r5,r7
81120eb4:	23c9383a 	mul	r4,r4,r15
81120eb8:	1806d43a 	srli	r3,r3,16
81120ebc:	280ed43a 	srli	r7,r5,16
81120ec0:	297fffcc 	andi	r5,r5,65535
81120ec4:	20c7883a 	add	r3,r4,r3
81120ec8:	19c7883a 	add	r3,r3,r7
81120ecc:	1808943a 	slli	r4,r3,16
81120ed0:	4023883a 	mov	r17,r8
81120ed4:	180ed43a 	srli	r7,r3,16
81120ed8:	214ab03a 	or	r5,r4,r5
81120edc:	41400015 	stw	r5,0(r8)
81120ee0:	42000104 	addi	r8,r8,4
81120ee4:	727fea36 	bltu	r14,r9,81120e90 <__reset+0xfb100e90>
81120ee8:	89c00115 	stw	r7,4(r17)
81120eec:	37c00017 	ldw	ra,0(r6)
81120ef0:	f83ed43a 	srli	ra,ra,16
81120ef4:	f8001f26 	beq	ra,zero,81120f74 <__multiply+0x1a8>
81120ef8:	58c00017 	ldw	r3,0(r11)
81120efc:	681d883a 	mov	r14,r13
81120f00:	581f883a 	mov	r15,r11
81120f04:	1811883a 	mov	r8,r3
81120f08:	5825883a 	mov	r18,r11
81120f0c:	000f883a 	mov	r7,zero
81120f10:	00000106 	br	81120f18 <__multiply+0x14c>
81120f14:	8825883a 	mov	r18,r17
81120f18:	7140000b 	ldhu	r5,0(r14)
81120f1c:	4010d43a 	srli	r8,r8,16
81120f20:	193fffcc 	andi	r4,r3,65535
81120f24:	2fcb383a 	mul	r5,r5,ra
81120f28:	7bc00104 	addi	r15,r15,4
81120f2c:	73800104 	addi	r14,r14,4
81120f30:	2a0b883a 	add	r5,r5,r8
81120f34:	29cb883a 	add	r5,r5,r7
81120f38:	2806943a 	slli	r3,r5,16
81120f3c:	94400104 	addi	r17,r18,4
81120f40:	280ad43a 	srli	r5,r5,16
81120f44:	1908b03a 	or	r4,r3,r4
81120f48:	793fff15 	stw	r4,-4(r15)
81120f4c:	70ffff17 	ldw	r3,-4(r14)
81120f50:	8a000017 	ldw	r8,0(r17)
81120f54:	1806d43a 	srli	r3,r3,16
81120f58:	413fffcc 	andi	r4,r8,65535
81120f5c:	1fc7383a 	mul	r3,r3,ra
81120f60:	1907883a 	add	r3,r3,r4
81120f64:	1947883a 	add	r3,r3,r5
81120f68:	180ed43a 	srli	r7,r3,16
81120f6c:	727fe936 	bltu	r14,r9,81120f14 <__reset+0xfb100f14>
81120f70:	90c00115 	stw	r3,4(r18)
81120f74:	31800104 	addi	r6,r6,4
81120f78:	5ac00104 	addi	r11,r11,4
81120f7c:	333fbe36 	bltu	r6,r12,81120e78 <__reset+0xfb100e78>
81120f80:	0400090e 	bge	zero,r16,81120fa8 <__multiply+0x1dc>
81120f84:	50ffff17 	ldw	r3,-4(r10)
81120f88:	52bfff04 	addi	r10,r10,-4
81120f8c:	18000326 	beq	r3,zero,81120f9c <__multiply+0x1d0>
81120f90:	00000506 	br	81120fa8 <__multiply+0x1dc>
81120f94:	50c00017 	ldw	r3,0(r10)
81120f98:	1800031e 	bne	r3,zero,81120fa8 <__multiply+0x1dc>
81120f9c:	843fffc4 	addi	r16,r16,-1
81120fa0:	52bfff04 	addi	r10,r10,-4
81120fa4:	803ffb1e 	bne	r16,zero,81120f94 <__reset+0xfb100f94>
81120fa8:	14000415 	stw	r16,16(r2)
81120fac:	dfc00517 	ldw	ra,20(sp)
81120fb0:	dd000417 	ldw	r20,16(sp)
81120fb4:	dcc00317 	ldw	r19,12(sp)
81120fb8:	dc800217 	ldw	r18,8(sp)
81120fbc:	dc400117 	ldw	r17,4(sp)
81120fc0:	dc000017 	ldw	r16,0(sp)
81120fc4:	dec00604 	addi	sp,sp,24
81120fc8:	f800283a 	ret

81120fcc <__pow5mult>:
81120fcc:	defffa04 	addi	sp,sp,-24
81120fd0:	de00012e 	bgeu	sp,et,81120fd8 <__pow5mult+0xc>
81120fd4:	003b68fa 	trap	3
81120fd8:	308000cc 	andi	r2,r6,3
81120fdc:	dcc00315 	stw	r19,12(sp)
81120fe0:	dc000015 	stw	r16,0(sp)
81120fe4:	dfc00515 	stw	ra,20(sp)
81120fe8:	dd000415 	stw	r20,16(sp)
81120fec:	dc800215 	stw	r18,8(sp)
81120ff0:	dc400115 	stw	r17,4(sp)
81120ff4:	3021883a 	mov	r16,r6
81120ff8:	2027883a 	mov	r19,r4
81120ffc:	10002f1e 	bne	r2,zero,811210bc <__pow5mult+0xf0>
81121000:	2825883a 	mov	r18,r5
81121004:	8021d0ba 	srai	r16,r16,2
81121008:	80001a26 	beq	r16,zero,81121074 <__pow5mult+0xa8>
8112100c:	9c401217 	ldw	r17,72(r19)
81121010:	8800061e 	bne	r17,zero,8112102c <__pow5mult+0x60>
81121014:	00003406 	br	811210e8 <__pow5mult+0x11c>
81121018:	8021d07a 	srai	r16,r16,1
8112101c:	80001526 	beq	r16,zero,81121074 <__pow5mult+0xa8>
81121020:	88800017 	ldw	r2,0(r17)
81121024:	10001c26 	beq	r2,zero,81121098 <__pow5mult+0xcc>
81121028:	1023883a 	mov	r17,r2
8112102c:	8080004c 	andi	r2,r16,1
81121030:	103ff926 	beq	r2,zero,81121018 <__reset+0xfb101018>
81121034:	880d883a 	mov	r6,r17
81121038:	900b883a 	mov	r5,r18
8112103c:	9809883a 	mov	r4,r19
81121040:	1120dcc0 	call	81120dcc <__multiply>
81121044:	90001b26 	beq	r18,zero,811210b4 <__pow5mult+0xe8>
81121048:	91000117 	ldw	r4,4(r18)
8112104c:	98c01317 	ldw	r3,76(r19)
81121050:	8021d07a 	srai	r16,r16,1
81121054:	2109883a 	add	r4,r4,r4
81121058:	2109883a 	add	r4,r4,r4
8112105c:	1907883a 	add	r3,r3,r4
81121060:	19000017 	ldw	r4,0(r3)
81121064:	91000015 	stw	r4,0(r18)
81121068:	1c800015 	stw	r18,0(r3)
8112106c:	1025883a 	mov	r18,r2
81121070:	803feb1e 	bne	r16,zero,81121020 <__reset+0xfb101020>
81121074:	9005883a 	mov	r2,r18
81121078:	dfc00517 	ldw	ra,20(sp)
8112107c:	dd000417 	ldw	r20,16(sp)
81121080:	dcc00317 	ldw	r19,12(sp)
81121084:	dc800217 	ldw	r18,8(sp)
81121088:	dc400117 	ldw	r17,4(sp)
8112108c:	dc000017 	ldw	r16,0(sp)
81121090:	dec00604 	addi	sp,sp,24
81121094:	f800283a 	ret
81121098:	880d883a 	mov	r6,r17
8112109c:	880b883a 	mov	r5,r17
811210a0:	9809883a 	mov	r4,r19
811210a4:	1120dcc0 	call	81120dcc <__multiply>
811210a8:	88800015 	stw	r2,0(r17)
811210ac:	10000015 	stw	zero,0(r2)
811210b0:	003fdd06 	br	81121028 <__reset+0xfb101028>
811210b4:	1025883a 	mov	r18,r2
811210b8:	003fd706 	br	81121018 <__reset+0xfb101018>
811210bc:	10bfffc4 	addi	r2,r2,-1
811210c0:	1085883a 	add	r2,r2,r2
811210c4:	00e04534 	movhi	r3,33044
811210c8:	18d14704 	addi	r3,r3,17692
811210cc:	1085883a 	add	r2,r2,r2
811210d0:	1885883a 	add	r2,r3,r2
811210d4:	11800017 	ldw	r6,0(r2)
811210d8:	000f883a 	mov	r7,zero
811210dc:	1120a3c0 	call	81120a3c <__multadd>
811210e0:	1025883a 	mov	r18,r2
811210e4:	003fc706 	br	81121004 <__reset+0xfb101004>
811210e8:	05000044 	movi	r20,1
811210ec:	a00b883a 	mov	r5,r20
811210f0:	9809883a 	mov	r4,r19
811210f4:	11209640 	call	81120964 <_Balloc>
811210f8:	1023883a 	mov	r17,r2
811210fc:	00809c44 	movi	r2,625
81121100:	88800515 	stw	r2,20(r17)
81121104:	8d000415 	stw	r20,16(r17)
81121108:	9c401215 	stw	r17,72(r19)
8112110c:	88000015 	stw	zero,0(r17)
81121110:	003fc606 	br	8112102c <__reset+0xfb10102c>

81121114 <__lshift>:
81121114:	defff904 	addi	sp,sp,-28
81121118:	de00012e 	bgeu	sp,et,81121120 <__lshift+0xc>
8112111c:	003b68fa 	trap	3
81121120:	dd400515 	stw	r21,20(sp)
81121124:	dcc00315 	stw	r19,12(sp)
81121128:	302bd17a 	srai	r21,r6,5
8112112c:	2cc00417 	ldw	r19,16(r5)
81121130:	28800217 	ldw	r2,8(r5)
81121134:	dd000415 	stw	r20,16(sp)
81121138:	ace7883a 	add	r19,r21,r19
8112113c:	dc800215 	stw	r18,8(sp)
81121140:	dc400115 	stw	r17,4(sp)
81121144:	dc000015 	stw	r16,0(sp)
81121148:	dfc00615 	stw	ra,24(sp)
8112114c:	9c000044 	addi	r16,r19,1
81121150:	2823883a 	mov	r17,r5
81121154:	3029883a 	mov	r20,r6
81121158:	2025883a 	mov	r18,r4
8112115c:	29400117 	ldw	r5,4(r5)
81121160:	1400030e 	bge	r2,r16,81121170 <__lshift+0x5c>
81121164:	1085883a 	add	r2,r2,r2
81121168:	29400044 	addi	r5,r5,1
8112116c:	143ffd16 	blt	r2,r16,81121164 <__reset+0xfb101164>
81121170:	9009883a 	mov	r4,r18
81121174:	11209640 	call	81120964 <_Balloc>
81121178:	10c00504 	addi	r3,r2,20
8112117c:	0540070e 	bge	zero,r21,8112119c <__lshift+0x88>
81121180:	ad6b883a 	add	r21,r21,r21
81121184:	ad6b883a 	add	r21,r21,r21
81121188:	1809883a 	mov	r4,r3
8112118c:	1d47883a 	add	r3,r3,r21
81121190:	20000015 	stw	zero,0(r4)
81121194:	21000104 	addi	r4,r4,4
81121198:	193ffd1e 	bne	r3,r4,81121190 <__reset+0xfb101190>
8112119c:	8a000417 	ldw	r8,16(r17)
811211a0:	89000504 	addi	r4,r17,20
811211a4:	a18007cc 	andi	r6,r20,31
811211a8:	4211883a 	add	r8,r8,r8
811211ac:	4211883a 	add	r8,r8,r8
811211b0:	2211883a 	add	r8,r4,r8
811211b4:	30002326 	beq	r6,zero,81121244 <__lshift+0x130>
811211b8:	02400804 	movi	r9,32
811211bc:	4993c83a 	sub	r9,r9,r6
811211c0:	000b883a 	mov	r5,zero
811211c4:	21c00017 	ldw	r7,0(r4)
811211c8:	1815883a 	mov	r10,r3
811211cc:	18c00104 	addi	r3,r3,4
811211d0:	398e983a 	sll	r7,r7,r6
811211d4:	21000104 	addi	r4,r4,4
811211d8:	394ab03a 	or	r5,r7,r5
811211dc:	197fff15 	stw	r5,-4(r3)
811211e0:	217fff17 	ldw	r5,-4(r4)
811211e4:	2a4ad83a 	srl	r5,r5,r9
811211e8:	223ff636 	bltu	r4,r8,811211c4 <__reset+0xfb1011c4>
811211ec:	51400115 	stw	r5,4(r10)
811211f0:	28001a1e 	bne	r5,zero,8112125c <__lshift+0x148>
811211f4:	843fffc4 	addi	r16,r16,-1
811211f8:	14000415 	stw	r16,16(r2)
811211fc:	88000826 	beq	r17,zero,81121220 <__lshift+0x10c>
81121200:	89000117 	ldw	r4,4(r17)
81121204:	90c01317 	ldw	r3,76(r18)
81121208:	2109883a 	add	r4,r4,r4
8112120c:	2109883a 	add	r4,r4,r4
81121210:	1907883a 	add	r3,r3,r4
81121214:	19000017 	ldw	r4,0(r3)
81121218:	89000015 	stw	r4,0(r17)
8112121c:	1c400015 	stw	r17,0(r3)
81121220:	dfc00617 	ldw	ra,24(sp)
81121224:	dd400517 	ldw	r21,20(sp)
81121228:	dd000417 	ldw	r20,16(sp)
8112122c:	dcc00317 	ldw	r19,12(sp)
81121230:	dc800217 	ldw	r18,8(sp)
81121234:	dc400117 	ldw	r17,4(sp)
81121238:	dc000017 	ldw	r16,0(sp)
8112123c:	dec00704 	addi	sp,sp,28
81121240:	f800283a 	ret
81121244:	21400017 	ldw	r5,0(r4)
81121248:	18c00104 	addi	r3,r3,4
8112124c:	21000104 	addi	r4,r4,4
81121250:	197fff15 	stw	r5,-4(r3)
81121254:	223ffb36 	bltu	r4,r8,81121244 <__reset+0xfb101244>
81121258:	003fe606 	br	811211f4 <__reset+0xfb1011f4>
8112125c:	9c000084 	addi	r16,r19,2
81121260:	003fe406 	br	811211f4 <__reset+0xfb1011f4>

81121264 <__mcmp>:
81121264:	20800417 	ldw	r2,16(r4)
81121268:	28c00417 	ldw	r3,16(r5)
8112126c:	10c5c83a 	sub	r2,r2,r3
81121270:	1000111e 	bne	r2,zero,811212b8 <__mcmp+0x54>
81121274:	18c7883a 	add	r3,r3,r3
81121278:	18c7883a 	add	r3,r3,r3
8112127c:	21000504 	addi	r4,r4,20
81121280:	29400504 	addi	r5,r5,20
81121284:	20c5883a 	add	r2,r4,r3
81121288:	28cb883a 	add	r5,r5,r3
8112128c:	00000106 	br	81121294 <__mcmp+0x30>
81121290:	20800a2e 	bgeu	r4,r2,811212bc <__mcmp+0x58>
81121294:	10bfff04 	addi	r2,r2,-4
81121298:	297fff04 	addi	r5,r5,-4
8112129c:	11800017 	ldw	r6,0(r2)
811212a0:	28c00017 	ldw	r3,0(r5)
811212a4:	30fffa26 	beq	r6,r3,81121290 <__reset+0xfb101290>
811212a8:	30c00236 	bltu	r6,r3,811212b4 <__mcmp+0x50>
811212ac:	00800044 	movi	r2,1
811212b0:	f800283a 	ret
811212b4:	00bfffc4 	movi	r2,-1
811212b8:	f800283a 	ret
811212bc:	0005883a 	mov	r2,zero
811212c0:	f800283a 	ret

811212c4 <__mdiff>:
811212c4:	defffa04 	addi	sp,sp,-24
811212c8:	de00012e 	bgeu	sp,et,811212d0 <__mdiff+0xc>
811212cc:	003b68fa 	trap	3
811212d0:	28c00417 	ldw	r3,16(r5)
811212d4:	30800417 	ldw	r2,16(r6)
811212d8:	dcc00315 	stw	r19,12(sp)
811212dc:	dc800215 	stw	r18,8(sp)
811212e0:	dfc00515 	stw	ra,20(sp)
811212e4:	dd000415 	stw	r20,16(sp)
811212e8:	dc400115 	stw	r17,4(sp)
811212ec:	dc000015 	stw	r16,0(sp)
811212f0:	1887c83a 	sub	r3,r3,r2
811212f4:	2825883a 	mov	r18,r5
811212f8:	3027883a 	mov	r19,r6
811212fc:	1800141e 	bne	r3,zero,81121350 <__mdiff+0x8c>
81121300:	1085883a 	add	r2,r2,r2
81121304:	1085883a 	add	r2,r2,r2
81121308:	2a000504 	addi	r8,r5,20
8112130c:	34000504 	addi	r16,r6,20
81121310:	4087883a 	add	r3,r8,r2
81121314:	8085883a 	add	r2,r16,r2
81121318:	00000106 	br	81121320 <__mdiff+0x5c>
8112131c:	40c0592e 	bgeu	r8,r3,81121484 <__mdiff+0x1c0>
81121320:	18ffff04 	addi	r3,r3,-4
81121324:	10bfff04 	addi	r2,r2,-4
81121328:	19c00017 	ldw	r7,0(r3)
8112132c:	11400017 	ldw	r5,0(r2)
81121330:	397ffa26 	beq	r7,r5,8112131c <__reset+0xfb10131c>
81121334:	3940592e 	bgeu	r7,r5,8112149c <__mdiff+0x1d8>
81121338:	9005883a 	mov	r2,r18
8112133c:	4023883a 	mov	r17,r8
81121340:	9825883a 	mov	r18,r19
81121344:	05000044 	movi	r20,1
81121348:	1027883a 	mov	r19,r2
8112134c:	00000406 	br	81121360 <__mdiff+0x9c>
81121350:	18005616 	blt	r3,zero,811214ac <__mdiff+0x1e8>
81121354:	34400504 	addi	r17,r6,20
81121358:	2c000504 	addi	r16,r5,20
8112135c:	0029883a 	mov	r20,zero
81121360:	91400117 	ldw	r5,4(r18)
81121364:	11209640 	call	81120964 <_Balloc>
81121368:	92400417 	ldw	r9,16(r18)
8112136c:	9b000417 	ldw	r12,16(r19)
81121370:	12c00504 	addi	r11,r2,20
81121374:	4a51883a 	add	r8,r9,r9
81121378:	6319883a 	add	r12,r12,r12
8112137c:	4211883a 	add	r8,r8,r8
81121380:	6319883a 	add	r12,r12,r12
81121384:	15000315 	stw	r20,12(r2)
81121388:	8211883a 	add	r8,r16,r8
8112138c:	8b19883a 	add	r12,r17,r12
81121390:	0007883a 	mov	r3,zero
81121394:	81400017 	ldw	r5,0(r16)
81121398:	89c00017 	ldw	r7,0(r17)
8112139c:	59800104 	addi	r6,r11,4
811213a0:	293fffcc 	andi	r4,r5,65535
811213a4:	20c7883a 	add	r3,r4,r3
811213a8:	393fffcc 	andi	r4,r7,65535
811213ac:	1909c83a 	sub	r4,r3,r4
811213b0:	280ad43a 	srli	r5,r5,16
811213b4:	380ed43a 	srli	r7,r7,16
811213b8:	2007d43a 	srai	r3,r4,16
811213bc:	213fffcc 	andi	r4,r4,65535
811213c0:	29cbc83a 	sub	r5,r5,r7
811213c4:	28c7883a 	add	r3,r5,r3
811213c8:	180a943a 	slli	r5,r3,16
811213cc:	8c400104 	addi	r17,r17,4
811213d0:	84000104 	addi	r16,r16,4
811213d4:	2908b03a 	or	r4,r5,r4
811213d8:	59000015 	stw	r4,0(r11)
811213dc:	1807d43a 	srai	r3,r3,16
811213e0:	3015883a 	mov	r10,r6
811213e4:	3017883a 	mov	r11,r6
811213e8:	8b3fea36 	bltu	r17,r12,81121394 <__reset+0xfb101394>
811213ec:	8200162e 	bgeu	r16,r8,81121448 <__mdiff+0x184>
811213f0:	8017883a 	mov	r11,r16
811213f4:	59400017 	ldw	r5,0(r11)
811213f8:	31800104 	addi	r6,r6,4
811213fc:	5ac00104 	addi	r11,r11,4
81121400:	293fffcc 	andi	r4,r5,65535
81121404:	20c7883a 	add	r3,r4,r3
81121408:	280ed43a 	srli	r7,r5,16
8112140c:	180bd43a 	srai	r5,r3,16
81121410:	193fffcc 	andi	r4,r3,65535
81121414:	3947883a 	add	r3,r7,r5
81121418:	180a943a 	slli	r5,r3,16
8112141c:	1807d43a 	srai	r3,r3,16
81121420:	2908b03a 	or	r4,r5,r4
81121424:	313fff15 	stw	r4,-4(r6)
81121428:	5a3ff236 	bltu	r11,r8,811213f4 <__reset+0xfb1013f4>
8112142c:	0406303a 	nor	r3,zero,r16
81121430:	1a07883a 	add	r3,r3,r8
81121434:	1806d0ba 	srli	r3,r3,2
81121438:	18c00044 	addi	r3,r3,1
8112143c:	18c7883a 	add	r3,r3,r3
81121440:	18c7883a 	add	r3,r3,r3
81121444:	50d5883a 	add	r10,r10,r3
81121448:	50ffff04 	addi	r3,r10,-4
8112144c:	2000041e 	bne	r4,zero,81121460 <__mdiff+0x19c>
81121450:	18ffff04 	addi	r3,r3,-4
81121454:	19000017 	ldw	r4,0(r3)
81121458:	4a7fffc4 	addi	r9,r9,-1
8112145c:	203ffc26 	beq	r4,zero,81121450 <__reset+0xfb101450>
81121460:	12400415 	stw	r9,16(r2)
81121464:	dfc00517 	ldw	ra,20(sp)
81121468:	dd000417 	ldw	r20,16(sp)
8112146c:	dcc00317 	ldw	r19,12(sp)
81121470:	dc800217 	ldw	r18,8(sp)
81121474:	dc400117 	ldw	r17,4(sp)
81121478:	dc000017 	ldw	r16,0(sp)
8112147c:	dec00604 	addi	sp,sp,24
81121480:	f800283a 	ret
81121484:	000b883a 	mov	r5,zero
81121488:	11209640 	call	81120964 <_Balloc>
8112148c:	00c00044 	movi	r3,1
81121490:	10c00415 	stw	r3,16(r2)
81121494:	10000515 	stw	zero,20(r2)
81121498:	003ff206 	br	81121464 <__reset+0xfb101464>
8112149c:	8023883a 	mov	r17,r16
811214a0:	0029883a 	mov	r20,zero
811214a4:	4021883a 	mov	r16,r8
811214a8:	003fad06 	br	81121360 <__reset+0xfb101360>
811214ac:	9005883a 	mov	r2,r18
811214b0:	94400504 	addi	r17,r18,20
811214b4:	9c000504 	addi	r16,r19,20
811214b8:	9825883a 	mov	r18,r19
811214bc:	05000044 	movi	r20,1
811214c0:	1027883a 	mov	r19,r2
811214c4:	003fa606 	br	81121360 <__reset+0xfb101360>

811214c8 <__ulp>:
811214c8:	295ffc2c 	andhi	r5,r5,32752
811214cc:	00bf3034 	movhi	r2,64704
811214d0:	2887883a 	add	r3,r5,r2
811214d4:	00c0020e 	bge	zero,r3,811214e0 <__ulp+0x18>
811214d8:	0005883a 	mov	r2,zero
811214dc:	f800283a 	ret
811214e0:	00c7c83a 	sub	r3,zero,r3
811214e4:	1807d53a 	srai	r3,r3,20
811214e8:	008004c4 	movi	r2,19
811214ec:	10c00b0e 	bge	r2,r3,8112151c <__ulp+0x54>
811214f0:	18bffb04 	addi	r2,r3,-20
811214f4:	01000784 	movi	r4,30
811214f8:	0007883a 	mov	r3,zero
811214fc:	20800516 	blt	r4,r2,81121514 <__ulp+0x4c>
81121500:	010007c4 	movi	r4,31
81121504:	2089c83a 	sub	r4,r4,r2
81121508:	00800044 	movi	r2,1
8112150c:	1104983a 	sll	r2,r2,r4
81121510:	f800283a 	ret
81121514:	00800044 	movi	r2,1
81121518:	f800283a 	ret
8112151c:	01400234 	movhi	r5,8
81121520:	28c7d83a 	sra	r3,r5,r3
81121524:	0005883a 	mov	r2,zero
81121528:	f800283a 	ret

8112152c <__b2d>:
8112152c:	defffa04 	addi	sp,sp,-24
81121530:	de00012e 	bgeu	sp,et,81121538 <__b2d+0xc>
81121534:	003b68fa 	trap	3
81121538:	dc000015 	stw	r16,0(sp)
8112153c:	24000417 	ldw	r16,16(r4)
81121540:	dc400115 	stw	r17,4(sp)
81121544:	24400504 	addi	r17,r4,20
81121548:	8421883a 	add	r16,r16,r16
8112154c:	8421883a 	add	r16,r16,r16
81121550:	8c21883a 	add	r16,r17,r16
81121554:	dc800215 	stw	r18,8(sp)
81121558:	84bfff17 	ldw	r18,-4(r16)
8112155c:	dd000415 	stw	r20,16(sp)
81121560:	dcc00315 	stw	r19,12(sp)
81121564:	9009883a 	mov	r4,r18
81121568:	2829883a 	mov	r20,r5
8112156c:	dfc00515 	stw	ra,20(sp)
81121570:	1120c700 	call	81120c70 <__hi0bits>
81121574:	00c00804 	movi	r3,32
81121578:	1889c83a 	sub	r4,r3,r2
8112157c:	a1000015 	stw	r4,0(r20)
81121580:	01000284 	movi	r4,10
81121584:	84ffff04 	addi	r19,r16,-4
81121588:	20801216 	blt	r4,r2,811215d4 <__b2d+0xa8>
8112158c:	018002c4 	movi	r6,11
81121590:	308dc83a 	sub	r6,r6,r2
81121594:	9186d83a 	srl	r3,r18,r6
81121598:	18cffc34 	orhi	r3,r3,16368
8112159c:	8cc0212e 	bgeu	r17,r19,81121624 <__b2d+0xf8>
811215a0:	813ffe17 	ldw	r4,-8(r16)
811215a4:	218cd83a 	srl	r6,r4,r6
811215a8:	10800544 	addi	r2,r2,21
811215ac:	9084983a 	sll	r2,r18,r2
811215b0:	1184b03a 	or	r2,r2,r6
811215b4:	dfc00517 	ldw	ra,20(sp)
811215b8:	dd000417 	ldw	r20,16(sp)
811215bc:	dcc00317 	ldw	r19,12(sp)
811215c0:	dc800217 	ldw	r18,8(sp)
811215c4:	dc400117 	ldw	r17,4(sp)
811215c8:	dc000017 	ldw	r16,0(sp)
811215cc:	dec00604 	addi	sp,sp,24
811215d0:	f800283a 	ret
811215d4:	8cc00f2e 	bgeu	r17,r19,81121614 <__b2d+0xe8>
811215d8:	117ffd44 	addi	r5,r2,-11
811215dc:	80bffe17 	ldw	r2,-8(r16)
811215e0:	28000e26 	beq	r5,zero,8112161c <__b2d+0xf0>
811215e4:	1949c83a 	sub	r4,r3,r5
811215e8:	9164983a 	sll	r18,r18,r5
811215ec:	1106d83a 	srl	r3,r2,r4
811215f0:	81bffe04 	addi	r6,r16,-8
811215f4:	948ffc34 	orhi	r18,r18,16368
811215f8:	90c6b03a 	or	r3,r18,r3
811215fc:	89800e2e 	bgeu	r17,r6,81121638 <__b2d+0x10c>
81121600:	81bffd17 	ldw	r6,-12(r16)
81121604:	1144983a 	sll	r2,r2,r5
81121608:	310ad83a 	srl	r5,r6,r4
8112160c:	2884b03a 	or	r2,r5,r2
81121610:	003fe806 	br	811215b4 <__reset+0xfb1015b4>
81121614:	10bffd44 	addi	r2,r2,-11
81121618:	1000041e 	bne	r2,zero,8112162c <__b2d+0x100>
8112161c:	90cffc34 	orhi	r3,r18,16368
81121620:	003fe406 	br	811215b4 <__reset+0xfb1015b4>
81121624:	000d883a 	mov	r6,zero
81121628:	003fdf06 	br	811215a8 <__reset+0xfb1015a8>
8112162c:	90a4983a 	sll	r18,r18,r2
81121630:	0005883a 	mov	r2,zero
81121634:	003ff906 	br	8112161c <__reset+0xfb10161c>
81121638:	1144983a 	sll	r2,r2,r5
8112163c:	003fdd06 	br	811215b4 <__reset+0xfb1015b4>

81121640 <__d2b>:
81121640:	defff804 	addi	sp,sp,-32
81121644:	de00012e 	bgeu	sp,et,8112164c <__d2b+0xc>
81121648:	003b68fa 	trap	3
8112164c:	dc000215 	stw	r16,8(sp)
81121650:	3021883a 	mov	r16,r6
81121654:	dc400315 	stw	r17,12(sp)
81121658:	8022907a 	slli	r17,r16,1
8112165c:	dd000615 	stw	r20,24(sp)
81121660:	2829883a 	mov	r20,r5
81121664:	01400044 	movi	r5,1
81121668:	dcc00515 	stw	r19,20(sp)
8112166c:	dc800415 	stw	r18,16(sp)
81121670:	dfc00715 	stw	ra,28(sp)
81121674:	3825883a 	mov	r18,r7
81121678:	8822d57a 	srli	r17,r17,21
8112167c:	11209640 	call	81120964 <_Balloc>
81121680:	1027883a 	mov	r19,r2
81121684:	00800434 	movhi	r2,16
81121688:	10bfffc4 	addi	r2,r2,-1
8112168c:	808c703a 	and	r6,r16,r2
81121690:	88000126 	beq	r17,zero,81121698 <__d2b+0x58>
81121694:	31800434 	orhi	r6,r6,16
81121698:	d9800015 	stw	r6,0(sp)
8112169c:	a0002426 	beq	r20,zero,81121730 <__d2b+0xf0>
811216a0:	d9000104 	addi	r4,sp,4
811216a4:	dd000115 	stw	r20,4(sp)
811216a8:	1120cd80 	call	81120cd8 <__lo0bits>
811216ac:	d8c00017 	ldw	r3,0(sp)
811216b0:	10002f1e 	bne	r2,zero,81121770 <__d2b+0x130>
811216b4:	d9000117 	ldw	r4,4(sp)
811216b8:	99000515 	stw	r4,20(r19)
811216bc:	1821003a 	cmpeq	r16,r3,zero
811216c0:	01000084 	movi	r4,2
811216c4:	2421c83a 	sub	r16,r4,r16
811216c8:	98c00615 	stw	r3,24(r19)
811216cc:	9c000415 	stw	r16,16(r19)
811216d0:	88001f1e 	bne	r17,zero,81121750 <__d2b+0x110>
811216d4:	10bef384 	addi	r2,r2,-1074
811216d8:	90800015 	stw	r2,0(r18)
811216dc:	00900034 	movhi	r2,16384
811216e0:	10bfffc4 	addi	r2,r2,-1
811216e4:	8085883a 	add	r2,r16,r2
811216e8:	1085883a 	add	r2,r2,r2
811216ec:	1085883a 	add	r2,r2,r2
811216f0:	9885883a 	add	r2,r19,r2
811216f4:	11000517 	ldw	r4,20(r2)
811216f8:	8020917a 	slli	r16,r16,5
811216fc:	1120c700 	call	81120c70 <__hi0bits>
81121700:	d8c00817 	ldw	r3,32(sp)
81121704:	8085c83a 	sub	r2,r16,r2
81121708:	18800015 	stw	r2,0(r3)
8112170c:	9805883a 	mov	r2,r19
81121710:	dfc00717 	ldw	ra,28(sp)
81121714:	dd000617 	ldw	r20,24(sp)
81121718:	dcc00517 	ldw	r19,20(sp)
8112171c:	dc800417 	ldw	r18,16(sp)
81121720:	dc400317 	ldw	r17,12(sp)
81121724:	dc000217 	ldw	r16,8(sp)
81121728:	dec00804 	addi	sp,sp,32
8112172c:	f800283a 	ret
81121730:	d809883a 	mov	r4,sp
81121734:	1120cd80 	call	81120cd8 <__lo0bits>
81121738:	d8c00017 	ldw	r3,0(sp)
8112173c:	04000044 	movi	r16,1
81121740:	9c000415 	stw	r16,16(r19)
81121744:	98c00515 	stw	r3,20(r19)
81121748:	10800804 	addi	r2,r2,32
8112174c:	883fe126 	beq	r17,zero,811216d4 <__reset+0xfb1016d4>
81121750:	00c00d44 	movi	r3,53
81121754:	8c7ef344 	addi	r17,r17,-1075
81121758:	88a3883a 	add	r17,r17,r2
8112175c:	1885c83a 	sub	r2,r3,r2
81121760:	d8c00817 	ldw	r3,32(sp)
81121764:	94400015 	stw	r17,0(r18)
81121768:	18800015 	stw	r2,0(r3)
8112176c:	003fe706 	br	8112170c <__reset+0xfb10170c>
81121770:	01000804 	movi	r4,32
81121774:	2089c83a 	sub	r4,r4,r2
81121778:	1908983a 	sll	r4,r3,r4
8112177c:	d9400117 	ldw	r5,4(sp)
81121780:	1886d83a 	srl	r3,r3,r2
81121784:	2148b03a 	or	r4,r4,r5
81121788:	99000515 	stw	r4,20(r19)
8112178c:	d8c00015 	stw	r3,0(sp)
81121790:	003fca06 	br	811216bc <__reset+0xfb1016bc>

81121794 <__ratio>:
81121794:	defff904 	addi	sp,sp,-28
81121798:	de00012e 	bgeu	sp,et,811217a0 <__ratio+0xc>
8112179c:	003b68fa 	trap	3
811217a0:	dc400315 	stw	r17,12(sp)
811217a4:	2823883a 	mov	r17,r5
811217a8:	d9400104 	addi	r5,sp,4
811217ac:	dfc00615 	stw	ra,24(sp)
811217b0:	dcc00515 	stw	r19,20(sp)
811217b4:	dc800415 	stw	r18,16(sp)
811217b8:	2027883a 	mov	r19,r4
811217bc:	dc000215 	stw	r16,8(sp)
811217c0:	112152c0 	call	8112152c <__b2d>
811217c4:	d80b883a 	mov	r5,sp
811217c8:	8809883a 	mov	r4,r17
811217cc:	1025883a 	mov	r18,r2
811217d0:	1821883a 	mov	r16,r3
811217d4:	112152c0 	call	8112152c <__b2d>
811217d8:	8a000417 	ldw	r8,16(r17)
811217dc:	99000417 	ldw	r4,16(r19)
811217e0:	d9400117 	ldw	r5,4(sp)
811217e4:	2209c83a 	sub	r4,r4,r8
811217e8:	2010917a 	slli	r8,r4,5
811217ec:	d9000017 	ldw	r4,0(sp)
811217f0:	2909c83a 	sub	r4,r5,r4
811217f4:	4109883a 	add	r4,r8,r4
811217f8:	01000e0e 	bge	zero,r4,81121834 <__ratio+0xa0>
811217fc:	2008953a 	slli	r4,r4,20
81121800:	2421883a 	add	r16,r4,r16
81121804:	100d883a 	mov	r6,r2
81121808:	180f883a 	mov	r7,r3
8112180c:	9009883a 	mov	r4,r18
81121810:	800b883a 	mov	r5,r16
81121814:	11298880 	call	81129888 <__divdf3>
81121818:	dfc00617 	ldw	ra,24(sp)
8112181c:	dcc00517 	ldw	r19,20(sp)
81121820:	dc800417 	ldw	r18,16(sp)
81121824:	dc400317 	ldw	r17,12(sp)
81121828:	dc000217 	ldw	r16,8(sp)
8112182c:	dec00704 	addi	sp,sp,28
81121830:	f800283a 	ret
81121834:	2008953a 	slli	r4,r4,20
81121838:	1907c83a 	sub	r3,r3,r4
8112183c:	003ff106 	br	81121804 <__reset+0xfb101804>

81121840 <_mprec_log10>:
81121840:	defffe04 	addi	sp,sp,-8
81121844:	de00012e 	bgeu	sp,et,8112184c <_mprec_log10+0xc>
81121848:	003b68fa 	trap	3
8112184c:	008005c4 	movi	r2,23
81121850:	dc000015 	stw	r16,0(sp)
81121854:	dfc00115 	stw	ra,4(sp)
81121858:	2021883a 	mov	r16,r4
8112185c:	11000d0e 	bge	r2,r4,81121894 <_mprec_log10+0x54>
81121860:	0005883a 	mov	r2,zero
81121864:	00cffc34 	movhi	r3,16368
81121868:	843fffc4 	addi	r16,r16,-1
8112186c:	000d883a 	mov	r6,zero
81121870:	01d00934 	movhi	r7,16420
81121874:	1009883a 	mov	r4,r2
81121878:	180b883a 	mov	r5,r3
8112187c:	1114ae40 	call	81114ae4 <__muldf3>
81121880:	803ff91e 	bne	r16,zero,81121868 <__reset+0xfb101868>
81121884:	dfc00117 	ldw	ra,4(sp)
81121888:	dc000017 	ldw	r16,0(sp)
8112188c:	dec00204 	addi	sp,sp,8
81121890:	f800283a 	ret
81121894:	202090fa 	slli	r16,r4,3
81121898:	00a04534 	movhi	r2,33044
8112189c:	10915e04 	addi	r2,r2,17784
811218a0:	1421883a 	add	r16,r2,r16
811218a4:	80800017 	ldw	r2,0(r16)
811218a8:	80c00117 	ldw	r3,4(r16)
811218ac:	dfc00117 	ldw	ra,4(sp)
811218b0:	dc000017 	ldw	r16,0(sp)
811218b4:	dec00204 	addi	sp,sp,8
811218b8:	f800283a 	ret

811218bc <__copybits>:
811218bc:	297fffc4 	addi	r5,r5,-1
811218c0:	280fd17a 	srai	r7,r5,5
811218c4:	30c00417 	ldw	r3,16(r6)
811218c8:	30800504 	addi	r2,r6,20
811218cc:	39c00044 	addi	r7,r7,1
811218d0:	18c7883a 	add	r3,r3,r3
811218d4:	39cf883a 	add	r7,r7,r7
811218d8:	18c7883a 	add	r3,r3,r3
811218dc:	39cf883a 	add	r7,r7,r7
811218e0:	10c7883a 	add	r3,r2,r3
811218e4:	21cf883a 	add	r7,r4,r7
811218e8:	10c00d2e 	bgeu	r2,r3,81121920 <__copybits+0x64>
811218ec:	200b883a 	mov	r5,r4
811218f0:	12000017 	ldw	r8,0(r2)
811218f4:	29400104 	addi	r5,r5,4
811218f8:	10800104 	addi	r2,r2,4
811218fc:	2a3fff15 	stw	r8,-4(r5)
81121900:	10fffb36 	bltu	r2,r3,811218f0 <__reset+0xfb1018f0>
81121904:	1985c83a 	sub	r2,r3,r6
81121908:	10bffac4 	addi	r2,r2,-21
8112190c:	1004d0ba 	srli	r2,r2,2
81121910:	10800044 	addi	r2,r2,1
81121914:	1085883a 	add	r2,r2,r2
81121918:	1085883a 	add	r2,r2,r2
8112191c:	2089883a 	add	r4,r4,r2
81121920:	21c0032e 	bgeu	r4,r7,81121930 <__copybits+0x74>
81121924:	20000015 	stw	zero,0(r4)
81121928:	21000104 	addi	r4,r4,4
8112192c:	21fffd36 	bltu	r4,r7,81121924 <__reset+0xfb101924>
81121930:	f800283a 	ret

81121934 <__any_on>:
81121934:	20c00417 	ldw	r3,16(r4)
81121938:	2805d17a 	srai	r2,r5,5
8112193c:	21000504 	addi	r4,r4,20
81121940:	18800d0e 	bge	r3,r2,81121978 <__any_on+0x44>
81121944:	18c7883a 	add	r3,r3,r3
81121948:	18c7883a 	add	r3,r3,r3
8112194c:	20c7883a 	add	r3,r4,r3
81121950:	20c0192e 	bgeu	r4,r3,811219b8 <__any_on+0x84>
81121954:	18bfff17 	ldw	r2,-4(r3)
81121958:	18ffff04 	addi	r3,r3,-4
8112195c:	1000041e 	bne	r2,zero,81121970 <__any_on+0x3c>
81121960:	20c0142e 	bgeu	r4,r3,811219b4 <__any_on+0x80>
81121964:	18ffff04 	addi	r3,r3,-4
81121968:	19400017 	ldw	r5,0(r3)
8112196c:	283ffc26 	beq	r5,zero,81121960 <__reset+0xfb101960>
81121970:	00800044 	movi	r2,1
81121974:	f800283a 	ret
81121978:	10c00a0e 	bge	r2,r3,811219a4 <__any_on+0x70>
8112197c:	1085883a 	add	r2,r2,r2
81121980:	1085883a 	add	r2,r2,r2
81121984:	294007cc 	andi	r5,r5,31
81121988:	2087883a 	add	r3,r4,r2
8112198c:	283ff026 	beq	r5,zero,81121950 <__reset+0xfb101950>
81121990:	19800017 	ldw	r6,0(r3)
81121994:	3144d83a 	srl	r2,r6,r5
81121998:	114a983a 	sll	r5,r2,r5
8112199c:	317ff41e 	bne	r6,r5,81121970 <__reset+0xfb101970>
811219a0:	003feb06 	br	81121950 <__reset+0xfb101950>
811219a4:	1085883a 	add	r2,r2,r2
811219a8:	1085883a 	add	r2,r2,r2
811219ac:	2087883a 	add	r3,r4,r2
811219b0:	003fe706 	br	81121950 <__reset+0xfb101950>
811219b4:	f800283a 	ret
811219b8:	0005883a 	mov	r2,zero
811219bc:	f800283a 	ret

811219c0 <_read_r>:
811219c0:	defffd04 	addi	sp,sp,-12
811219c4:	de00012e 	bgeu	sp,et,811219cc <_read_r+0xc>
811219c8:	003b68fa 	trap	3
811219cc:	2805883a 	mov	r2,r5
811219d0:	dc000015 	stw	r16,0(sp)
811219d4:	04204534 	movhi	r16,33044
811219d8:	dc400115 	stw	r17,4(sp)
811219dc:	300b883a 	mov	r5,r6
811219e0:	841b5004 	addi	r16,r16,27968
811219e4:	2023883a 	mov	r17,r4
811219e8:	380d883a 	mov	r6,r7
811219ec:	1009883a 	mov	r4,r2
811219f0:	dfc00215 	stw	ra,8(sp)
811219f4:	80000015 	stw	zero,0(r16)
811219f8:	112c53c0 	call	8112c53c <read>
811219fc:	00ffffc4 	movi	r3,-1
81121a00:	10c00526 	beq	r2,r3,81121a18 <_read_r+0x58>
81121a04:	dfc00217 	ldw	ra,8(sp)
81121a08:	dc400117 	ldw	r17,4(sp)
81121a0c:	dc000017 	ldw	r16,0(sp)
81121a10:	dec00304 	addi	sp,sp,12
81121a14:	f800283a 	ret
81121a18:	80c00017 	ldw	r3,0(r16)
81121a1c:	183ff926 	beq	r3,zero,81121a04 <__reset+0xfb101a04>
81121a20:	88c00015 	stw	r3,0(r17)
81121a24:	003ff706 	br	81121a04 <__reset+0xfb101a04>

81121a28 <_realloc_r>:
81121a28:	defff604 	addi	sp,sp,-40
81121a2c:	de00012e 	bgeu	sp,et,81121a34 <_realloc_r+0xc>
81121a30:	003b68fa 	trap	3
81121a34:	dc800215 	stw	r18,8(sp)
81121a38:	dfc00915 	stw	ra,36(sp)
81121a3c:	df000815 	stw	fp,32(sp)
81121a40:	ddc00715 	stw	r23,28(sp)
81121a44:	dd800615 	stw	r22,24(sp)
81121a48:	dd400515 	stw	r21,20(sp)
81121a4c:	dd000415 	stw	r20,16(sp)
81121a50:	dcc00315 	stw	r19,12(sp)
81121a54:	dc400115 	stw	r17,4(sp)
81121a58:	dc000015 	stw	r16,0(sp)
81121a5c:	3025883a 	mov	r18,r6
81121a60:	2800b726 	beq	r5,zero,81121d40 <_realloc_r+0x318>
81121a64:	282b883a 	mov	r21,r5
81121a68:	2029883a 	mov	r20,r4
81121a6c:	112cd1c0 	call	8112cd1c <__malloc_lock>
81121a70:	a8bfff17 	ldw	r2,-4(r21)
81121a74:	043fff04 	movi	r16,-4
81121a78:	90c002c4 	addi	r3,r18,11
81121a7c:	01000584 	movi	r4,22
81121a80:	acfffe04 	addi	r19,r21,-8
81121a84:	1420703a 	and	r16,r2,r16
81121a88:	20c0332e 	bgeu	r4,r3,81121b58 <_realloc_r+0x130>
81121a8c:	047ffe04 	movi	r17,-8
81121a90:	1c62703a 	and	r17,r3,r17
81121a94:	8807883a 	mov	r3,r17
81121a98:	88005816 	blt	r17,zero,81121bfc <_realloc_r+0x1d4>
81121a9c:	8c805736 	bltu	r17,r18,81121bfc <_realloc_r+0x1d4>
81121aa0:	80c0300e 	bge	r16,r3,81121b64 <_realloc_r+0x13c>
81121aa4:	07204534 	movhi	fp,33044
81121aa8:	e714ab04 	addi	fp,fp,21164
81121aac:	e1c00217 	ldw	r7,8(fp)
81121ab0:	9c09883a 	add	r4,r19,r16
81121ab4:	22000117 	ldw	r8,4(r4)
81121ab8:	21c06326 	beq	r4,r7,81121c48 <_realloc_r+0x220>
81121abc:	017fff84 	movi	r5,-2
81121ac0:	414a703a 	and	r5,r8,r5
81121ac4:	214b883a 	add	r5,r4,r5
81121ac8:	29800117 	ldw	r6,4(r5)
81121acc:	3180004c 	andi	r6,r6,1
81121ad0:	30003f26 	beq	r6,zero,81121bd0 <_realloc_r+0x1a8>
81121ad4:	1080004c 	andi	r2,r2,1
81121ad8:	10008326 	beq	r2,zero,81121ce8 <_realloc_r+0x2c0>
81121adc:	900b883a 	mov	r5,r18
81121ae0:	a009883a 	mov	r4,r20
81121ae4:	1115f200 	call	81115f20 <_malloc_r>
81121ae8:	1025883a 	mov	r18,r2
81121aec:	10011e26 	beq	r2,zero,81121f68 <_realloc_r+0x540>
81121af0:	a93fff17 	ldw	r4,-4(r21)
81121af4:	10fffe04 	addi	r3,r2,-8
81121af8:	00bfff84 	movi	r2,-2
81121afc:	2084703a 	and	r2,r4,r2
81121b00:	9885883a 	add	r2,r19,r2
81121b04:	1880ee26 	beq	r3,r2,81121ec0 <_realloc_r+0x498>
81121b08:	81bfff04 	addi	r6,r16,-4
81121b0c:	00800904 	movi	r2,36
81121b10:	1180b836 	bltu	r2,r6,81121df4 <_realloc_r+0x3cc>
81121b14:	00c004c4 	movi	r3,19
81121b18:	19809636 	bltu	r3,r6,81121d74 <_realloc_r+0x34c>
81121b1c:	9005883a 	mov	r2,r18
81121b20:	a807883a 	mov	r3,r21
81121b24:	19000017 	ldw	r4,0(r3)
81121b28:	11000015 	stw	r4,0(r2)
81121b2c:	19000117 	ldw	r4,4(r3)
81121b30:	11000115 	stw	r4,4(r2)
81121b34:	18c00217 	ldw	r3,8(r3)
81121b38:	10c00215 	stw	r3,8(r2)
81121b3c:	a80b883a 	mov	r5,r21
81121b40:	a009883a 	mov	r4,r20
81121b44:	111f9940 	call	8111f994 <_free_r>
81121b48:	a009883a 	mov	r4,r20
81121b4c:	112ce440 	call	8112ce44 <__malloc_unlock>
81121b50:	9005883a 	mov	r2,r18
81121b54:	00001206 	br	81121ba0 <_realloc_r+0x178>
81121b58:	00c00404 	movi	r3,16
81121b5c:	1823883a 	mov	r17,r3
81121b60:	003fce06 	br	81121a9c <__reset+0xfb101a9c>
81121b64:	a825883a 	mov	r18,r21
81121b68:	8445c83a 	sub	r2,r16,r17
81121b6c:	00c003c4 	movi	r3,15
81121b70:	18802636 	bltu	r3,r2,81121c0c <_realloc_r+0x1e4>
81121b74:	99800117 	ldw	r6,4(r19)
81121b78:	9c07883a 	add	r3,r19,r16
81121b7c:	3180004c 	andi	r6,r6,1
81121b80:	3420b03a 	or	r16,r6,r16
81121b84:	9c000115 	stw	r16,4(r19)
81121b88:	18800117 	ldw	r2,4(r3)
81121b8c:	10800054 	ori	r2,r2,1
81121b90:	18800115 	stw	r2,4(r3)
81121b94:	a009883a 	mov	r4,r20
81121b98:	112ce440 	call	8112ce44 <__malloc_unlock>
81121b9c:	9005883a 	mov	r2,r18
81121ba0:	dfc00917 	ldw	ra,36(sp)
81121ba4:	df000817 	ldw	fp,32(sp)
81121ba8:	ddc00717 	ldw	r23,28(sp)
81121bac:	dd800617 	ldw	r22,24(sp)
81121bb0:	dd400517 	ldw	r21,20(sp)
81121bb4:	dd000417 	ldw	r20,16(sp)
81121bb8:	dcc00317 	ldw	r19,12(sp)
81121bbc:	dc800217 	ldw	r18,8(sp)
81121bc0:	dc400117 	ldw	r17,4(sp)
81121bc4:	dc000017 	ldw	r16,0(sp)
81121bc8:	dec00a04 	addi	sp,sp,40
81121bcc:	f800283a 	ret
81121bd0:	017fff04 	movi	r5,-4
81121bd4:	414a703a 	and	r5,r8,r5
81121bd8:	814d883a 	add	r6,r16,r5
81121bdc:	30c01f16 	blt	r6,r3,81121c5c <_realloc_r+0x234>
81121be0:	20800317 	ldw	r2,12(r4)
81121be4:	20c00217 	ldw	r3,8(r4)
81121be8:	a825883a 	mov	r18,r21
81121bec:	3021883a 	mov	r16,r6
81121bf0:	18800315 	stw	r2,12(r3)
81121bf4:	10c00215 	stw	r3,8(r2)
81121bf8:	003fdb06 	br	81121b68 <__reset+0xfb101b68>
81121bfc:	00800304 	movi	r2,12
81121c00:	a0800015 	stw	r2,0(r20)
81121c04:	0005883a 	mov	r2,zero
81121c08:	003fe506 	br	81121ba0 <__reset+0xfb101ba0>
81121c0c:	98c00117 	ldw	r3,4(r19)
81121c10:	9c4b883a 	add	r5,r19,r17
81121c14:	11000054 	ori	r4,r2,1
81121c18:	18c0004c 	andi	r3,r3,1
81121c1c:	1c62b03a 	or	r17,r3,r17
81121c20:	9c400115 	stw	r17,4(r19)
81121c24:	29000115 	stw	r4,4(r5)
81121c28:	2885883a 	add	r2,r5,r2
81121c2c:	10c00117 	ldw	r3,4(r2)
81121c30:	29400204 	addi	r5,r5,8
81121c34:	a009883a 	mov	r4,r20
81121c38:	18c00054 	ori	r3,r3,1
81121c3c:	10c00115 	stw	r3,4(r2)
81121c40:	111f9940 	call	8111f994 <_free_r>
81121c44:	003fd306 	br	81121b94 <__reset+0xfb101b94>
81121c48:	017fff04 	movi	r5,-4
81121c4c:	414a703a 	and	r5,r8,r5
81121c50:	89800404 	addi	r6,r17,16
81121c54:	8151883a 	add	r8,r16,r5
81121c58:	4180590e 	bge	r8,r6,81121dc0 <_realloc_r+0x398>
81121c5c:	1080004c 	andi	r2,r2,1
81121c60:	103f9e1e 	bne	r2,zero,81121adc <__reset+0xfb101adc>
81121c64:	adbffe17 	ldw	r22,-8(r21)
81121c68:	00bfff04 	movi	r2,-4
81121c6c:	9dadc83a 	sub	r22,r19,r22
81121c70:	b1800117 	ldw	r6,4(r22)
81121c74:	3084703a 	and	r2,r6,r2
81121c78:	20002026 	beq	r4,zero,81121cfc <_realloc_r+0x2d4>
81121c7c:	80af883a 	add	r23,r16,r2
81121c80:	b96f883a 	add	r23,r23,r5
81121c84:	21c05f26 	beq	r4,r7,81121e04 <_realloc_r+0x3dc>
81121c88:	b8c01c16 	blt	r23,r3,81121cfc <_realloc_r+0x2d4>
81121c8c:	20800317 	ldw	r2,12(r4)
81121c90:	20c00217 	ldw	r3,8(r4)
81121c94:	81bfff04 	addi	r6,r16,-4
81121c98:	01000904 	movi	r4,36
81121c9c:	18800315 	stw	r2,12(r3)
81121ca0:	10c00215 	stw	r3,8(r2)
81121ca4:	b0c00217 	ldw	r3,8(r22)
81121ca8:	b0800317 	ldw	r2,12(r22)
81121cac:	b4800204 	addi	r18,r22,8
81121cb0:	18800315 	stw	r2,12(r3)
81121cb4:	10c00215 	stw	r3,8(r2)
81121cb8:	21801b36 	bltu	r4,r6,81121d28 <_realloc_r+0x300>
81121cbc:	008004c4 	movi	r2,19
81121cc0:	1180352e 	bgeu	r2,r6,81121d98 <_realloc_r+0x370>
81121cc4:	a8800017 	ldw	r2,0(r21)
81121cc8:	b0800215 	stw	r2,8(r22)
81121ccc:	a8800117 	ldw	r2,4(r21)
81121cd0:	b0800315 	stw	r2,12(r22)
81121cd4:	008006c4 	movi	r2,27
81121cd8:	11807f36 	bltu	r2,r6,81121ed8 <_realloc_r+0x4b0>
81121cdc:	b0800404 	addi	r2,r22,16
81121ce0:	ad400204 	addi	r21,r21,8
81121ce4:	00002d06 	br	81121d9c <_realloc_r+0x374>
81121ce8:	adbffe17 	ldw	r22,-8(r21)
81121cec:	00bfff04 	movi	r2,-4
81121cf0:	9dadc83a 	sub	r22,r19,r22
81121cf4:	b1000117 	ldw	r4,4(r22)
81121cf8:	2084703a 	and	r2,r4,r2
81121cfc:	b03f7726 	beq	r22,zero,81121adc <__reset+0xfb101adc>
81121d00:	80af883a 	add	r23,r16,r2
81121d04:	b8ff7516 	blt	r23,r3,81121adc <__reset+0xfb101adc>
81121d08:	b0800317 	ldw	r2,12(r22)
81121d0c:	b0c00217 	ldw	r3,8(r22)
81121d10:	81bfff04 	addi	r6,r16,-4
81121d14:	01000904 	movi	r4,36
81121d18:	18800315 	stw	r2,12(r3)
81121d1c:	10c00215 	stw	r3,8(r2)
81121d20:	b4800204 	addi	r18,r22,8
81121d24:	21bfe52e 	bgeu	r4,r6,81121cbc <__reset+0xfb101cbc>
81121d28:	a80b883a 	mov	r5,r21
81121d2c:	9009883a 	mov	r4,r18
81121d30:	11208080 	call	81120808 <memmove>
81121d34:	b821883a 	mov	r16,r23
81121d38:	b027883a 	mov	r19,r22
81121d3c:	003f8a06 	br	81121b68 <__reset+0xfb101b68>
81121d40:	300b883a 	mov	r5,r6
81121d44:	dfc00917 	ldw	ra,36(sp)
81121d48:	df000817 	ldw	fp,32(sp)
81121d4c:	ddc00717 	ldw	r23,28(sp)
81121d50:	dd800617 	ldw	r22,24(sp)
81121d54:	dd400517 	ldw	r21,20(sp)
81121d58:	dd000417 	ldw	r20,16(sp)
81121d5c:	dcc00317 	ldw	r19,12(sp)
81121d60:	dc800217 	ldw	r18,8(sp)
81121d64:	dc400117 	ldw	r17,4(sp)
81121d68:	dc000017 	ldw	r16,0(sp)
81121d6c:	dec00a04 	addi	sp,sp,40
81121d70:	1115f201 	jmpi	81115f20 <_malloc_r>
81121d74:	a8c00017 	ldw	r3,0(r21)
81121d78:	90c00015 	stw	r3,0(r18)
81121d7c:	a8c00117 	ldw	r3,4(r21)
81121d80:	90c00115 	stw	r3,4(r18)
81121d84:	00c006c4 	movi	r3,27
81121d88:	19804536 	bltu	r3,r6,81121ea0 <_realloc_r+0x478>
81121d8c:	90800204 	addi	r2,r18,8
81121d90:	a8c00204 	addi	r3,r21,8
81121d94:	003f6306 	br	81121b24 <__reset+0xfb101b24>
81121d98:	9005883a 	mov	r2,r18
81121d9c:	a8c00017 	ldw	r3,0(r21)
81121da0:	b821883a 	mov	r16,r23
81121da4:	b027883a 	mov	r19,r22
81121da8:	10c00015 	stw	r3,0(r2)
81121dac:	a8c00117 	ldw	r3,4(r21)
81121db0:	10c00115 	stw	r3,4(r2)
81121db4:	a8c00217 	ldw	r3,8(r21)
81121db8:	10c00215 	stw	r3,8(r2)
81121dbc:	003f6a06 	br	81121b68 <__reset+0xfb101b68>
81121dc0:	9c67883a 	add	r19,r19,r17
81121dc4:	4445c83a 	sub	r2,r8,r17
81121dc8:	e4c00215 	stw	r19,8(fp)
81121dcc:	10800054 	ori	r2,r2,1
81121dd0:	98800115 	stw	r2,4(r19)
81121dd4:	a8bfff17 	ldw	r2,-4(r21)
81121dd8:	a009883a 	mov	r4,r20
81121ddc:	1080004c 	andi	r2,r2,1
81121de0:	1462b03a 	or	r17,r2,r17
81121de4:	ac7fff15 	stw	r17,-4(r21)
81121de8:	112ce440 	call	8112ce44 <__malloc_unlock>
81121dec:	a805883a 	mov	r2,r21
81121df0:	003f6b06 	br	81121ba0 <__reset+0xfb101ba0>
81121df4:	a80b883a 	mov	r5,r21
81121df8:	9009883a 	mov	r4,r18
81121dfc:	11208080 	call	81120808 <memmove>
81121e00:	003f4e06 	br	81121b3c <__reset+0xfb101b3c>
81121e04:	89000404 	addi	r4,r17,16
81121e08:	b93fbc16 	blt	r23,r4,81121cfc <__reset+0xfb101cfc>
81121e0c:	b0800317 	ldw	r2,12(r22)
81121e10:	b0c00217 	ldw	r3,8(r22)
81121e14:	81bfff04 	addi	r6,r16,-4
81121e18:	01000904 	movi	r4,36
81121e1c:	18800315 	stw	r2,12(r3)
81121e20:	10c00215 	stw	r3,8(r2)
81121e24:	b4800204 	addi	r18,r22,8
81121e28:	21804336 	bltu	r4,r6,81121f38 <_realloc_r+0x510>
81121e2c:	008004c4 	movi	r2,19
81121e30:	11803f2e 	bgeu	r2,r6,81121f30 <_realloc_r+0x508>
81121e34:	a8800017 	ldw	r2,0(r21)
81121e38:	b0800215 	stw	r2,8(r22)
81121e3c:	a8800117 	ldw	r2,4(r21)
81121e40:	b0800315 	stw	r2,12(r22)
81121e44:	008006c4 	movi	r2,27
81121e48:	11803f36 	bltu	r2,r6,81121f48 <_realloc_r+0x520>
81121e4c:	b0800404 	addi	r2,r22,16
81121e50:	ad400204 	addi	r21,r21,8
81121e54:	a8c00017 	ldw	r3,0(r21)
81121e58:	10c00015 	stw	r3,0(r2)
81121e5c:	a8c00117 	ldw	r3,4(r21)
81121e60:	10c00115 	stw	r3,4(r2)
81121e64:	a8c00217 	ldw	r3,8(r21)
81121e68:	10c00215 	stw	r3,8(r2)
81121e6c:	b447883a 	add	r3,r22,r17
81121e70:	bc45c83a 	sub	r2,r23,r17
81121e74:	e0c00215 	stw	r3,8(fp)
81121e78:	10800054 	ori	r2,r2,1
81121e7c:	18800115 	stw	r2,4(r3)
81121e80:	b0800117 	ldw	r2,4(r22)
81121e84:	a009883a 	mov	r4,r20
81121e88:	1080004c 	andi	r2,r2,1
81121e8c:	1462b03a 	or	r17,r2,r17
81121e90:	b4400115 	stw	r17,4(r22)
81121e94:	112ce440 	call	8112ce44 <__malloc_unlock>
81121e98:	9005883a 	mov	r2,r18
81121e9c:	003f4006 	br	81121ba0 <__reset+0xfb101ba0>
81121ea0:	a8c00217 	ldw	r3,8(r21)
81121ea4:	90c00215 	stw	r3,8(r18)
81121ea8:	a8c00317 	ldw	r3,12(r21)
81121eac:	90c00315 	stw	r3,12(r18)
81121eb0:	30801126 	beq	r6,r2,81121ef8 <_realloc_r+0x4d0>
81121eb4:	90800404 	addi	r2,r18,16
81121eb8:	a8c00404 	addi	r3,r21,16
81121ebc:	003f1906 	br	81121b24 <__reset+0xfb101b24>
81121ec0:	90ffff17 	ldw	r3,-4(r18)
81121ec4:	00bfff04 	movi	r2,-4
81121ec8:	a825883a 	mov	r18,r21
81121ecc:	1884703a 	and	r2,r3,r2
81121ed0:	80a1883a 	add	r16,r16,r2
81121ed4:	003f2406 	br	81121b68 <__reset+0xfb101b68>
81121ed8:	a8800217 	ldw	r2,8(r21)
81121edc:	b0800415 	stw	r2,16(r22)
81121ee0:	a8800317 	ldw	r2,12(r21)
81121ee4:	b0800515 	stw	r2,20(r22)
81121ee8:	31000a26 	beq	r6,r4,81121f14 <_realloc_r+0x4ec>
81121eec:	b0800604 	addi	r2,r22,24
81121ef0:	ad400404 	addi	r21,r21,16
81121ef4:	003fa906 	br	81121d9c <__reset+0xfb101d9c>
81121ef8:	a9000417 	ldw	r4,16(r21)
81121efc:	90800604 	addi	r2,r18,24
81121f00:	a8c00604 	addi	r3,r21,24
81121f04:	91000415 	stw	r4,16(r18)
81121f08:	a9000517 	ldw	r4,20(r21)
81121f0c:	91000515 	stw	r4,20(r18)
81121f10:	003f0406 	br	81121b24 <__reset+0xfb101b24>
81121f14:	a8c00417 	ldw	r3,16(r21)
81121f18:	ad400604 	addi	r21,r21,24
81121f1c:	b0800804 	addi	r2,r22,32
81121f20:	b0c00615 	stw	r3,24(r22)
81121f24:	a8ffff17 	ldw	r3,-4(r21)
81121f28:	b0c00715 	stw	r3,28(r22)
81121f2c:	003f9b06 	br	81121d9c <__reset+0xfb101d9c>
81121f30:	9005883a 	mov	r2,r18
81121f34:	003fc706 	br	81121e54 <__reset+0xfb101e54>
81121f38:	a80b883a 	mov	r5,r21
81121f3c:	9009883a 	mov	r4,r18
81121f40:	11208080 	call	81120808 <memmove>
81121f44:	003fc906 	br	81121e6c <__reset+0xfb101e6c>
81121f48:	a8800217 	ldw	r2,8(r21)
81121f4c:	b0800415 	stw	r2,16(r22)
81121f50:	a8800317 	ldw	r2,12(r21)
81121f54:	b0800515 	stw	r2,20(r22)
81121f58:	31000726 	beq	r6,r4,81121f78 <_realloc_r+0x550>
81121f5c:	b0800604 	addi	r2,r22,24
81121f60:	ad400404 	addi	r21,r21,16
81121f64:	003fbb06 	br	81121e54 <__reset+0xfb101e54>
81121f68:	a009883a 	mov	r4,r20
81121f6c:	112ce440 	call	8112ce44 <__malloc_unlock>
81121f70:	0005883a 	mov	r2,zero
81121f74:	003f0a06 	br	81121ba0 <__reset+0xfb101ba0>
81121f78:	a8c00417 	ldw	r3,16(r21)
81121f7c:	ad400604 	addi	r21,r21,24
81121f80:	b0800804 	addi	r2,r22,32
81121f84:	b0c00615 	stw	r3,24(r22)
81121f88:	a8ffff17 	ldw	r3,-4(r21)
81121f8c:	b0c00715 	stw	r3,28(r22)
81121f90:	003fb006 	br	81121e54 <__reset+0xfb101e54>

81121f94 <__fpclassifyd>:
81121f94:	00a00034 	movhi	r2,32768
81121f98:	10bfffc4 	addi	r2,r2,-1
81121f9c:	2884703a 	and	r2,r5,r2
81121fa0:	10000726 	beq	r2,zero,81121fc0 <__fpclassifyd+0x2c>
81121fa4:	00fffc34 	movhi	r3,65520
81121fa8:	019ff834 	movhi	r6,32736
81121fac:	28c7883a 	add	r3,r5,r3
81121fb0:	31bfffc4 	addi	r6,r6,-1
81121fb4:	30c00536 	bltu	r6,r3,81121fcc <__fpclassifyd+0x38>
81121fb8:	00800104 	movi	r2,4
81121fbc:	f800283a 	ret
81121fc0:	2000021e 	bne	r4,zero,81121fcc <__fpclassifyd+0x38>
81121fc4:	00800084 	movi	r2,2
81121fc8:	f800283a 	ret
81121fcc:	00dffc34 	movhi	r3,32752
81121fd0:	019ff834 	movhi	r6,32736
81121fd4:	28cb883a 	add	r5,r5,r3
81121fd8:	31bfffc4 	addi	r6,r6,-1
81121fdc:	317ff62e 	bgeu	r6,r5,81121fb8 <__reset+0xfb101fb8>
81121fe0:	01400434 	movhi	r5,16
81121fe4:	297fffc4 	addi	r5,r5,-1
81121fe8:	28800236 	bltu	r5,r2,81121ff4 <__fpclassifyd+0x60>
81121fec:	008000c4 	movi	r2,3
81121ff0:	f800283a 	ret
81121ff4:	10c00226 	beq	r2,r3,81122000 <__fpclassifyd+0x6c>
81121ff8:	0005883a 	mov	r2,zero
81121ffc:	f800283a 	ret
81122000:	2005003a 	cmpeq	r2,r4,zero
81122004:	f800283a 	ret

81122008 <__sccl>:
81122008:	2a000003 	ldbu	r8,0(r5)
8112200c:	00801784 	movi	r2,94
81122010:	40802a26 	beq	r8,r2,811220bc <__sccl+0xb4>
81122014:	29400044 	addi	r5,r5,1
81122018:	000f883a 	mov	r7,zero
8112201c:	0013883a 	mov	r9,zero
81122020:	2007883a 	mov	r3,r4
81122024:	21804004 	addi	r6,r4,256
81122028:	19c00005 	stb	r7,0(r3)
8112202c:	18c00044 	addi	r3,r3,1
81122030:	19bffd1e 	bne	r3,r6,81122028 <__reset+0xfb102028>
81122034:	40001126 	beq	r8,zero,8112207c <__sccl+0x74>
81122038:	00800044 	movi	r2,1
8112203c:	124fc83a 	sub	r7,r2,r9
81122040:	02800b44 	movi	r10,45
81122044:	02c01744 	movi	r11,93
81122048:	2205883a 	add	r2,r4,r8
8112204c:	11c00005 	stb	r7,0(r2)
81122050:	28800044 	addi	r2,r5,1
81122054:	28c00003 	ldbu	r3,0(r5)
81122058:	1a800a26 	beq	r3,r10,81122084 <__sccl+0x7c>
8112205c:	1ac00426 	beq	r3,r11,81122070 <__sccl+0x68>
81122060:	18000426 	beq	r3,zero,81122074 <__sccl+0x6c>
81122064:	1811883a 	mov	r8,r3
81122068:	100b883a 	mov	r5,r2
8112206c:	003ff606 	br	81122048 <__reset+0xfb102048>
81122070:	f800283a 	ret
81122074:	2805883a 	mov	r2,r5
81122078:	f800283a 	ret
8112207c:	28bfffc4 	addi	r2,r5,-1
81122080:	f800283a 	ret
81122084:	12400003 	ldbu	r9,0(r2)
81122088:	4ac01126 	beq	r9,r11,811220d0 <__sccl+0xc8>
8112208c:	4a001016 	blt	r9,r8,811220d0 <__sccl+0xc8>
81122090:	41800044 	addi	r6,r8,1
81122094:	29400084 	addi	r5,r5,2
81122098:	2187883a 	add	r3,r4,r6
8112209c:	00000106 	br	811220a4 <__sccl+0x9c>
811220a0:	31800044 	addi	r6,r6,1
811220a4:	19c00005 	stb	r7,0(r3)
811220a8:	3011883a 	mov	r8,r6
811220ac:	18c00044 	addi	r3,r3,1
811220b0:	327ffb16 	blt	r6,r9,811220a0 <__reset+0xfb1020a0>
811220b4:	10800084 	addi	r2,r2,2
811220b8:	003fe606 	br	81122054 <__reset+0xfb102054>
811220bc:	2a000043 	ldbu	r8,1(r5)
811220c0:	01c00044 	movi	r7,1
811220c4:	29400084 	addi	r5,r5,2
811220c8:	02400044 	movi	r9,1
811220cc:	003fd406 	br	81122020 <__reset+0xfb102020>
811220d0:	5011883a 	mov	r8,r10
811220d4:	003fe406 	br	81122068 <__reset+0xfb102068>

811220d8 <nanf>:
811220d8:	009ff034 	movhi	r2,32704
811220dc:	f800283a 	ret

811220e0 <strcmp>:
811220e0:	2144b03a 	or	r2,r4,r5
811220e4:	108000cc 	andi	r2,r2,3
811220e8:	1000171e 	bne	r2,zero,81122148 <strcmp+0x68>
811220ec:	20800017 	ldw	r2,0(r4)
811220f0:	28c00017 	ldw	r3,0(r5)
811220f4:	10c0141e 	bne	r2,r3,81122148 <strcmp+0x68>
811220f8:	027fbff4 	movhi	r9,65279
811220fc:	4a7fbfc4 	addi	r9,r9,-257
81122100:	0086303a 	nor	r3,zero,r2
81122104:	02202074 	movhi	r8,32897
81122108:	1245883a 	add	r2,r2,r9
8112210c:	42202004 	addi	r8,r8,-32640
81122110:	10c4703a 	and	r2,r2,r3
81122114:	1204703a 	and	r2,r2,r8
81122118:	10000226 	beq	r2,zero,81122124 <strcmp+0x44>
8112211c:	00002306 	br	811221ac <strcmp+0xcc>
81122120:	1000221e 	bne	r2,zero,811221ac <strcmp+0xcc>
81122124:	21000104 	addi	r4,r4,4
81122128:	20c00017 	ldw	r3,0(r4)
8112212c:	29400104 	addi	r5,r5,4
81122130:	29800017 	ldw	r6,0(r5)
81122134:	1a4f883a 	add	r7,r3,r9
81122138:	00c4303a 	nor	r2,zero,r3
8112213c:	3884703a 	and	r2,r7,r2
81122140:	1204703a 	and	r2,r2,r8
81122144:	19bff626 	beq	r3,r6,81122120 <__reset+0xfb102120>
81122148:	20800003 	ldbu	r2,0(r4)
8112214c:	10c03fcc 	andi	r3,r2,255
81122150:	18c0201c 	xori	r3,r3,128
81122154:	18ffe004 	addi	r3,r3,-128
81122158:	18000c26 	beq	r3,zero,8112218c <strcmp+0xac>
8112215c:	29800007 	ldb	r6,0(r5)
81122160:	19800326 	beq	r3,r6,81122170 <strcmp+0x90>
81122164:	00001306 	br	811221b4 <strcmp+0xd4>
81122168:	29800007 	ldb	r6,0(r5)
8112216c:	11800b1e 	bne	r2,r6,8112219c <strcmp+0xbc>
81122170:	21000044 	addi	r4,r4,1
81122174:	20c00003 	ldbu	r3,0(r4)
81122178:	29400044 	addi	r5,r5,1
8112217c:	18803fcc 	andi	r2,r3,255
81122180:	1080201c 	xori	r2,r2,128
81122184:	10bfe004 	addi	r2,r2,-128
81122188:	103ff71e 	bne	r2,zero,81122168 <__reset+0xfb102168>
8112218c:	0007883a 	mov	r3,zero
81122190:	28800003 	ldbu	r2,0(r5)
81122194:	1885c83a 	sub	r2,r3,r2
81122198:	f800283a 	ret
8112219c:	28800003 	ldbu	r2,0(r5)
811221a0:	18c03fcc 	andi	r3,r3,255
811221a4:	1885c83a 	sub	r2,r3,r2
811221a8:	f800283a 	ret
811221ac:	0005883a 	mov	r2,zero
811221b0:	f800283a 	ret
811221b4:	10c03fcc 	andi	r3,r2,255
811221b8:	003ff506 	br	81122190 <__reset+0xfb102190>

811221bc <sulp>:
811221bc:	defffd04 	addi	sp,sp,-12
811221c0:	de00012e 	bgeu	sp,et,811221c8 <sulp+0xc>
811221c4:	003b68fa 	trap	3
811221c8:	dc400115 	stw	r17,4(sp)
811221cc:	3023883a 	mov	r17,r6
811221d0:	dc000015 	stw	r16,0(sp)
811221d4:	dfc00215 	stw	ra,8(sp)
811221d8:	2821883a 	mov	r16,r5
811221dc:	11214c80 	call	811214c8 <__ulp>
811221e0:	88000c26 	beq	r17,zero,81122214 <sulp+0x58>
811221e4:	841ffc2c 	andhi	r16,r16,32752
811221e8:	8020d53a 	srli	r16,r16,20
811221ec:	01c01ac4 	movi	r7,107
811221f0:	3c21c83a 	sub	r16,r7,r16
811221f4:	0400070e 	bge	zero,r16,81122214 <sulp+0x58>
811221f8:	8020953a 	slli	r16,r16,20
811221fc:	01cffc34 	movhi	r7,16368
81122200:	000d883a 	mov	r6,zero
81122204:	81cf883a 	add	r7,r16,r7
81122208:	1009883a 	mov	r4,r2
8112220c:	180b883a 	mov	r5,r3
81122210:	1114ae40 	call	81114ae4 <__muldf3>
81122214:	dfc00217 	ldw	ra,8(sp)
81122218:	dc400117 	ldw	r17,4(sp)
8112221c:	dc000017 	ldw	r16,0(sp)
81122220:	dec00304 	addi	sp,sp,12
81122224:	f800283a 	ret

81122228 <_strtod_r>:
81122228:	deffe204 	addi	sp,sp,-120
8112222c:	de00012e 	bgeu	sp,et,81122234 <_strtod_r+0xc>
81122230:	003b68fa 	trap	3
81122234:	ddc01b15 	stw	r23,108(sp)
81122238:	dd001815 	stw	r20,96(sp)
8112223c:	dc801615 	stw	r18,88(sp)
81122240:	dc401515 	stw	r17,84(sp)
81122244:	dc001415 	stw	r16,80(sp)
81122248:	d9400615 	stw	r5,24(sp)
8112224c:	dfc01d15 	stw	ra,116(sp)
81122250:	df001c15 	stw	fp,112(sp)
81122254:	dd801a15 	stw	r22,104(sp)
81122258:	dd401915 	stw	r21,100(sp)
8112225c:	dcc01715 	stw	r19,92(sp)
81122260:	2021883a 	mov	r16,r4
81122264:	d8000515 	stw	zero,20(sp)
81122268:	2809883a 	mov	r4,r5
8112226c:	20800003 	ldbu	r2,0(r4)
81122270:	01e044b4 	movhi	r7,33042
81122274:	282f883a 	mov	r23,r5
81122278:	10c03fcc 	andi	r3,r2,255
8112227c:	01400b44 	movi	r5,45
81122280:	39c8a904 	addi	r7,r7,8868
81122284:	3029883a 	mov	r20,r6
81122288:	0025883a 	mov	r18,zero
8112228c:	0023883a 	mov	r17,zero
81122290:	28c0ba36 	bltu	r5,r3,8112257c <_strtod_r+0x354>
81122294:	180690ba 	slli	r3,r3,2
81122298:	19c7883a 	add	r3,r3,r7
8112229c:	18c00017 	ldw	r3,0(r3)
811222a0:	1800683a 	jmp	r3
811222a4:	81122364 	muli	r4,r16,18573
811222a8:	8112257c 	xorhi	r4,r16,18581
811222ac:	8112257c 	xorhi	r4,r16,18581
811222b0:	8112257c 	xorhi	r4,r16,18581
811222b4:	8112257c 	xorhi	r4,r16,18581
811222b8:	8112257c 	xorhi	r4,r16,18581
811222bc:	8112257c 	xorhi	r4,r16,18581
811222c0:	8112257c 	xorhi	r4,r16,18581
811222c4:	8112257c 	xorhi	r4,r16,18581
811222c8:	81122568 	cmpgeui	r4,r16,18581
811222cc:	81122568 	cmpgeui	r4,r16,18581
811222d0:	81122568 	cmpgeui	r4,r16,18581
811222d4:	81122568 	cmpgeui	r4,r16,18581
811222d8:	81122568 	cmpgeui	r4,r16,18581
811222dc:	8112257c 	xorhi	r4,r16,18581
811222e0:	8112257c 	xorhi	r4,r16,18581
811222e4:	8112257c 	xorhi	r4,r16,18581
811222e8:	8112257c 	xorhi	r4,r16,18581
811222ec:	8112257c 	xorhi	r4,r16,18581
811222f0:	8112257c 	xorhi	r4,r16,18581
811222f4:	8112257c 	xorhi	r4,r16,18581
811222f8:	8112257c 	xorhi	r4,r16,18581
811222fc:	8112257c 	xorhi	r4,r16,18581
81122300:	8112257c 	xorhi	r4,r16,18581
81122304:	8112257c 	xorhi	r4,r16,18581
81122308:	8112257c 	xorhi	r4,r16,18581
8112230c:	8112257c 	xorhi	r4,r16,18581
81122310:	8112257c 	xorhi	r4,r16,18581
81122314:	8112257c 	xorhi	r4,r16,18581
81122318:	8112257c 	xorhi	r4,r16,18581
8112231c:	8112257c 	xorhi	r4,r16,18581
81122320:	8112257c 	xorhi	r4,r16,18581
81122324:	81122568 	cmpgeui	r4,r16,18581
81122328:	8112257c 	xorhi	r4,r16,18581
8112232c:	8112257c 	xorhi	r4,r16,18581
81122330:	8112257c 	xorhi	r4,r16,18581
81122334:	8112257c 	xorhi	r4,r16,18581
81122338:	8112257c 	xorhi	r4,r16,18581
8112233c:	8112257c 	xorhi	r4,r16,18581
81122340:	8112257c 	xorhi	r4,r16,18581
81122344:	8112257c 	xorhi	r4,r16,18581
81122348:	8112257c 	xorhi	r4,r16,18581
8112234c:	8112257c 	xorhi	r4,r16,18581
81122350:	811223bc 	xorhi	r4,r16,18574
81122354:	8112257c 	xorhi	r4,r16,18581
81122358:	8112255c 	xori	r4,r16,18581
8112235c:	00801244 	movi	r2,73
81122360:	88843526 	beq	r17,r2,81123438 <_strtod_r+0x1210>
81122364:	002b883a 	mov	r21,zero
81122368:	002d883a 	mov	r22,zero
8112236c:	a0000526 	beq	r20,zero,81122384 <_strtod_r+0x15c>
81122370:	d8000715 	stw	zero,28(sp)
81122374:	a5c00015 	stw	r23,0(r20)
81122378:	d9000717 	ldw	r4,28(sp)
8112237c:	20000126 	beq	r4,zero,81122384 <_strtod_r+0x15c>
81122380:	b5a0003c 	xorhi	r22,r22,32768
81122384:	a805883a 	mov	r2,r21
81122388:	b007883a 	mov	r3,r22
8112238c:	dfc01d17 	ldw	ra,116(sp)
81122390:	df001c17 	ldw	fp,112(sp)
81122394:	ddc01b17 	ldw	r23,108(sp)
81122398:	dd801a17 	ldw	r22,104(sp)
8112239c:	dd401917 	ldw	r21,100(sp)
811223a0:	dd001817 	ldw	r20,96(sp)
811223a4:	dcc01717 	ldw	r19,92(sp)
811223a8:	dc801617 	ldw	r18,88(sp)
811223ac:	dc401517 	ldw	r17,84(sp)
811223b0:	dc001417 	ldw	r16,80(sp)
811223b4:	dec01e04 	addi	sp,sp,120
811223b8:	f800283a 	ret
811223bc:	d8000715 	stw	zero,28(sp)
811223c0:	24c00044 	addi	r19,r4,1
811223c4:	dcc00615 	stw	r19,24(sp)
811223c8:	20800043 	ldbu	r2,1(r4)
811223cc:	10c03fcc 	andi	r3,r2,255
811223d0:	18c0201c 	xori	r3,r3,128
811223d4:	18ffe004 	addi	r3,r3,-128
811223d8:	183fe226 	beq	r3,zero,81122364 <__reset+0xfb102364>
811223dc:	11403fcc 	andi	r5,r2,255
811223e0:	2940201c 	xori	r5,r5,128
811223e4:	297fe004 	addi	r5,r5,-128
811223e8:	00c00c04 	movi	r3,48
811223ec:	28c0e526 	beq	r5,r3,81122784 <_strtod_r+0x55c>
811223f0:	dcc00815 	stw	r19,32(sp)
811223f4:	0025883a 	mov	r18,zero
811223f8:	10fff404 	addi	r3,r2,-48
811223fc:	18c03fcc 	andi	r3,r3,255
81122400:	01000244 	movi	r4,9
81122404:	20c37536 	bltu	r4,r3,811231dc <_strtod_r+0xfb4>
81122408:	dd400817 	ldw	r21,32(sp)
8112240c:	0027883a 	mov	r19,zero
81122410:	0039883a 	mov	fp,zero
81122414:	002d883a 	mov	r22,zero
81122418:	01400204 	movi	r5,8
8112241c:	2d805a16 	blt	r5,r22,81122588 <_strtod_r+0x360>
81122420:	e70002a4 	muli	fp,fp,10
81122424:	10c03fcc 	andi	r3,r2,255
81122428:	18c0201c 	xori	r3,r3,128
8112242c:	18ffe004 	addi	r3,r3,-128
81122430:	e0f9883a 	add	fp,fp,r3
81122434:	e73ff404 	addi	fp,fp,-48
81122438:	ad400044 	addi	r21,r21,1
8112243c:	dd400615 	stw	r21,24(sp)
81122440:	a8800003 	ldbu	r2,0(r21)
81122444:	b5800044 	addi	r22,r22,1
81122448:	10fff404 	addi	r3,r2,-48
8112244c:	18c03fcc 	andi	r3,r3,255
81122450:	20fff22e 	bgeu	r4,r3,8112241c <__reset+0xfb10241c>
81122454:	14403fcc 	andi	r17,r2,255
81122458:	8c40201c 	xori	r17,r17,128
8112245c:	8c7fe004 	addi	r17,r17,-128
81122460:	8009883a 	mov	r4,r16
81122464:	11204480 	call	81120448 <_localeconv_r>
81122468:	11400017 	ldw	r5,0(r2)
8112246c:	8009883a 	mov	r4,r16
81122470:	d9401315 	stw	r5,76(sp)
81122474:	11204480 	call	81120448 <_localeconv_r>
81122478:	11000017 	ldw	r4,0(r2)
8112247c:	11172280 	call	81117228 <strlen>
81122480:	d9401317 	ldw	r5,76(sp)
81122484:	100d883a 	mov	r6,r2
81122488:	a809883a 	mov	r4,r21
8112248c:	1127e180 	call	81127e18 <strncmp>
81122490:	1000ce26 	beq	r2,zero,811227cc <_strtod_r+0x5a4>
81122494:	b013883a 	mov	r9,r22
81122498:	000b883a 	mov	r5,zero
8112249c:	0015883a 	mov	r10,zero
811224a0:	0017883a 	mov	r11,zero
811224a4:	00801944 	movi	r2,101
811224a8:	88807826 	beq	r17,r2,8112268c <_strtod_r+0x464>
811224ac:	00801144 	movi	r2,69
811224b0:	88807626 	beq	r17,r2,8112268c <_strtod_r+0x464>
811224b4:	002b883a 	mov	r21,zero
811224b8:	48003d1e 	bne	r9,zero,811225b0 <_strtod_r+0x388>
811224bc:	2800391e 	bne	r5,zero,811225a4 <_strtod_r+0x37c>
811224c0:	9000381e 	bne	r18,zero,811225a4 <_strtod_r+0x37c>
811224c4:	583fa71e 	bne	r11,zero,81122364 <__reset+0xfb102364>
811224c8:	00801384 	movi	r2,78
811224cc:	88800526 	beq	r17,r2,811224e4 <_strtod_r+0x2bc>
811224d0:	147fa20e 	bge	r2,r17,8112235c <__reset+0xfb10235c>
811224d4:	00801a44 	movi	r2,105
811224d8:	8883d726 	beq	r17,r2,81123438 <_strtod_r+0x1210>
811224dc:	00801b84 	movi	r2,110
811224e0:	88bfa01e 	bne	r17,r2,81122364 <__reset+0xfb102364>
811224e4:	01604534 	movhi	r5,33044
811224e8:	d9000617 	ldw	r4,24(sp)
811224ec:	29519304 	addi	r5,r5,17996
811224f0:	01c00644 	movi	r7,25
811224f4:	00000b06 	br	81122524 <_strtod_r+0x2fc>
811224f8:	21000044 	addi	r4,r4,1
811224fc:	20800003 	ldbu	r2,0(r4)
81122500:	10ffefc4 	addi	r3,r2,-65
81122504:	10803fcc 	andi	r2,r2,255
81122508:	1080201c 	xori	r2,r2,128
8112250c:	18c03fcc 	andi	r3,r3,255
81122510:	10bfe004 	addi	r2,r2,-128
81122514:	38c00136 	bltu	r7,r3,8112251c <_strtod_r+0x2f4>
81122518:	10800804 	addi	r2,r2,32
8112251c:	29400044 	addi	r5,r5,1
81122520:	11bf901e 	bne	r2,r6,81122364 <__reset+0xfb102364>
81122524:	29800007 	ldb	r6,0(r5)
81122528:	303ff31e 	bne	r6,zero,811224f8 <__reset+0xfb1024f8>
8112252c:	20800044 	addi	r2,r4,1
81122530:	d8800615 	stw	r2,24(sp)
81122534:	20c00047 	ldb	r3,1(r4)
81122538:	00800a04 	movi	r2,40
8112253c:	18849d26 	beq	r3,r2,811237b4 <_strtod_r+0x158c>
81122540:	047ffe34 	movhi	r17,65528
81122544:	0025883a 	mov	r18,zero
81122548:	902b883a 	mov	r21,r18
8112254c:	882d883a 	mov	r22,r17
81122550:	a03f8926 	beq	r20,zero,81122378 <__reset+0xfb102378>
81122554:	ddc00617 	ldw	r23,24(sp)
81122558:	003f8606 	br	81122374 <__reset+0xfb102374>
8112255c:	00800044 	movi	r2,1
81122560:	d8800715 	stw	r2,28(sp)
81122564:	003f9606 	br	811223c0 <__reset+0xfb1023c0>
81122568:	21000044 	addi	r4,r4,1
8112256c:	d9000615 	stw	r4,24(sp)
81122570:	20800003 	ldbu	r2,0(r4)
81122574:	10c03fcc 	andi	r3,r2,255
81122578:	28ff462e 	bgeu	r5,r3,81122294 <__reset+0xfb102294>
8112257c:	2027883a 	mov	r19,r4
81122580:	d8000715 	stw	zero,28(sp)
81122584:	003f9506 	br	811223dc <__reset+0xfb1023dc>
81122588:	9cc002a4 	muli	r19,r19,10
8112258c:	10803fcc 	andi	r2,r2,255
81122590:	1080201c 	xori	r2,r2,128
81122594:	10bfe004 	addi	r2,r2,-128
81122598:	9885883a 	add	r2,r19,r2
8112259c:	14fff404 	addi	r19,r2,-48
811225a0:	003fa506 	br	81122438 <__reset+0xfb102438>
811225a4:	002b883a 	mov	r21,zero
811225a8:	002d883a 	mov	r22,zero
811225ac:	003fe806 	br	81122550 <__reset+0xfb102550>
811225b0:	aaabc83a 	sub	r21,r21,r10
811225b4:	b000011e 	bne	r22,zero,811225bc <_strtod_r+0x394>
811225b8:	482d883a 	mov	r22,r9
811225bc:	00800404 	movi	r2,16
811225c0:	482f883a 	mov	r23,r9
811225c4:	1240010e 	bge	r2,r9,811225cc <_strtod_r+0x3a4>
811225c8:	102f883a 	mov	r23,r2
811225cc:	e009883a 	mov	r4,fp
811225d0:	da401315 	stw	r9,76(sp)
811225d4:	112ae380 	call	8112ae38 <__floatunsidf>
811225d8:	1025883a 	mov	r18,r2
811225dc:	00800244 	movi	r2,9
811225e0:	1823883a 	mov	r17,r3
811225e4:	da401317 	ldw	r9,76(sp)
811225e8:	15c0160e 	bge	r2,r23,81122644 <_strtod_r+0x41c>
811225ec:	b8bffdc4 	addi	r2,r23,-9
811225f0:	100490fa 	slli	r2,r2,3
811225f4:	180b883a 	mov	r5,r3
811225f8:	00e04534 	movhi	r3,33044
811225fc:	18d15e04 	addi	r3,r3,17784
81122600:	1885883a 	add	r2,r3,r2
81122604:	11800017 	ldw	r6,0(r2)
81122608:	11c00117 	ldw	r7,4(r2)
8112260c:	9009883a 	mov	r4,r18
81122610:	1114ae40 	call	81114ae4 <__muldf3>
81122614:	9809883a 	mov	r4,r19
81122618:	1025883a 	mov	r18,r2
8112261c:	1823883a 	mov	r17,r3
81122620:	112ae380 	call	8112ae38 <__floatunsidf>
81122624:	9009883a 	mov	r4,r18
81122628:	880b883a 	mov	r5,r17
8112262c:	100d883a 	mov	r6,r2
81122630:	180f883a 	mov	r7,r3
81122634:	1128fd40 	call	81128fd4 <__adddf3>
81122638:	da401317 	ldw	r9,76(sp)
8112263c:	1025883a 	mov	r18,r2
81122640:	1823883a 	mov	r17,r3
81122644:	008003c4 	movi	r2,15
81122648:	12407b16 	blt	r2,r9,81122838 <_strtod_r+0x610>
8112264c:	a83fbe26 	beq	r21,zero,81122548 <__reset+0xfb102548>
81122650:	0543670e 	bge	zero,r21,811233f0 <_strtod_r+0x11c8>
81122654:	00c00584 	movi	r3,22
81122658:	1d42e816 	blt	r3,r21,811231fc <_strtod_r+0xfd4>
8112265c:	a82a90fa 	slli	r21,r21,3
81122660:	00a04534 	movhi	r2,33044
81122664:	10915e04 	addi	r2,r2,17784
81122668:	1545883a 	add	r2,r2,r21
8112266c:	11000017 	ldw	r4,0(r2)
81122670:	11400117 	ldw	r5,4(r2)
81122674:	900d883a 	mov	r6,r18
81122678:	880f883a 	mov	r7,r17
8112267c:	1114ae40 	call	81114ae4 <__muldf3>
81122680:	102b883a 	mov	r21,r2
81122684:	182d883a 	mov	r22,r3
81122688:	003fb106 	br	81122550 <__reset+0xfb102550>
8112268c:	4801b526 	beq	r9,zero,81122d64 <_strtod_r+0xb3c>
81122690:	ddc00617 	ldw	r23,24(sp)
81122694:	00c00ac4 	movi	r3,43
81122698:	b8800044 	addi	r2,r23,1
8112269c:	d8800615 	stw	r2,24(sp)
811226a0:	b8800047 	ldb	r2,1(r23)
811226a4:	10c1e926 	beq	r2,r3,81122e4c <_strtod_r+0xc24>
811226a8:	00c00b44 	movi	r3,45
811226ac:	10c1ec26 	beq	r2,r3,81122e60 <_strtod_r+0xc38>
811226b0:	1023883a 	mov	r17,r2
811226b4:	0019883a 	mov	r12,zero
811226b8:	88bff404 	addi	r2,r17,-48
811226bc:	00c00244 	movi	r3,9
811226c0:	1881b736 	bltu	r3,r2,81122da0 <_strtod_r+0xb78>
811226c4:	00800c04 	movi	r2,48
811226c8:	8880071e 	bne	r17,r2,811226e8 <_strtod_r+0x4c0>
811226cc:	d8800617 	ldw	r2,24(sp)
811226d0:	8807883a 	mov	r3,r17
811226d4:	10800044 	addi	r2,r2,1
811226d8:	d8800615 	stw	r2,24(sp)
811226dc:	14400007 	ldb	r17,0(r2)
811226e0:	10800044 	addi	r2,r2,1
811226e4:	88fffc26 	beq	r17,r3,811226d8 <__reset+0xfb1026d8>
811226e8:	88bff3c4 	addi	r2,r17,-49
811226ec:	00c00204 	movi	r3,8
811226f0:	18bf7036 	bltu	r3,r2,811224b4 <__reset+0xfb1024b4>
811226f4:	db800617 	ldw	r14,24(sp)
811226f8:	88bff404 	addi	r2,r17,-48
811226fc:	03400244 	movi	r13,9
81122700:	71c00044 	addi	r7,r14,1
81122704:	d9c00615 	stw	r7,24(sp)
81122708:	74400043 	ldbu	r17,1(r14)
8112270c:	88fff404 	addi	r3,r17,-48
81122710:	8c403fcc 	andi	r17,r17,255
81122714:	8c40201c 	xori	r17,r17,128
81122718:	18c03fcc 	andi	r3,r3,255
8112271c:	8c7fe004 	addi	r17,r17,-128
81122720:	68c00e36 	bltu	r13,r3,8112275c <_strtod_r+0x534>
81122724:	71000084 	addi	r4,r14,2
81122728:	d9000615 	stw	r4,24(sp)
8112272c:	108002a4 	muli	r2,r2,10
81122730:	21800003 	ldbu	r6,0(r4)
81122734:	200f883a 	mov	r7,r4
81122738:	1463883a 	add	r17,r2,r17
8112273c:	30fff404 	addi	r3,r6,-48
81122740:	88bff404 	addi	r2,r17,-48
81122744:	34403fcc 	andi	r17,r6,255
81122748:	8c40201c 	xori	r17,r17,128
8112274c:	18c03fcc 	andi	r3,r3,255
81122750:	8c7fe004 	addi	r17,r17,-128
81122754:	21000044 	addi	r4,r4,1
81122758:	68fff32e 	bgeu	r13,r3,81122728 <__reset+0xfb102728>
8112275c:	3b8fc83a 	sub	r7,r7,r14
81122760:	00c00204 	movi	r3,8
81122764:	19c29716 	blt	r3,r7,811231c4 <_strtod_r+0xf9c>
81122768:	102b883a 	mov	r21,r2
8112276c:	009387c4 	movi	r2,19999
81122770:	1540010e 	bge	r2,r21,81122778 <_strtod_r+0x550>
81122774:	102b883a 	mov	r21,r2
81122778:	603f4f26 	beq	r12,zero,811224b8 <__reset+0xfb1024b8>
8112277c:	056bc83a 	sub	r21,zero,r21
81122780:	003f4d06 	br	811224b8 <__reset+0xfb1024b8>
81122784:	98800047 	ldb	r2,1(r19)
81122788:	00c01604 	movi	r3,88
8112278c:	10c1de26 	beq	r2,r3,81122f08 <_strtod_r+0xce0>
81122790:	00c01e04 	movi	r3,120
81122794:	10c1dc26 	beq	r2,r3,81122f08 <_strtod_r+0xce0>
81122798:	98c00044 	addi	r3,r19,1
8112279c:	1827883a 	mov	r19,r3
811227a0:	d8c00615 	stw	r3,24(sp)
811227a4:	18c00044 	addi	r3,r3,1
811227a8:	18bfffc3 	ldbu	r2,-1(r3)
811227ac:	11003fcc 	andi	r4,r2,255
811227b0:	2100201c 	xori	r4,r4,128
811227b4:	213fe004 	addi	r4,r4,-128
811227b8:	217ff826 	beq	r4,r5,8112279c <__reset+0xfb10279c>
811227bc:	203f7926 	beq	r4,zero,811225a4 <__reset+0xfb1025a4>
811227c0:	dcc00815 	stw	r19,32(sp)
811227c4:	04800044 	movi	r18,1
811227c8:	003f0b06 	br	811223f8 <__reset+0xfb1023f8>
811227cc:	8009883a 	mov	r4,r16
811227d0:	11204480 	call	81120448 <_localeconv_r>
811227d4:	11000017 	ldw	r4,0(r2)
811227d8:	11172280 	call	81117228 <strlen>
811227dc:	d8c00617 	ldw	r3,24(sp)
811227e0:	1885883a 	add	r2,r3,r2
811227e4:	d8800615 	stw	r2,24(sp)
811227e8:	14400007 	ldb	r17,0(r2)
811227ec:	b001881e 	bne	r22,zero,81122e10 <_strtod_r+0xbe8>
811227f0:	00c00c04 	movi	r3,48
811227f4:	88c3391e 	bne	r17,r3,811234dc <_strtod_r+0x12b4>
811227f8:	10c00044 	addi	r3,r2,1
811227fc:	8809883a 	mov	r4,r17
81122800:	d8c00615 	stw	r3,24(sp)
81122804:	1c400007 	ldb	r17,0(r3)
81122808:	188bc83a 	sub	r5,r3,r2
8112280c:	18c00044 	addi	r3,r3,1
81122810:	893ffb26 	beq	r17,r4,81122800 <__reset+0xfb102800>
81122814:	88bff3c4 	addi	r2,r17,-49
81122818:	00c00204 	movi	r3,8
8112281c:	1882e72e 	bgeu	r3,r2,811233bc <_strtod_r+0x1194>
81122820:	00801944 	movi	r2,101
81122824:	88814d26 	beq	r17,r2,81122d5c <_strtod_r+0xb34>
81122828:	0013883a 	mov	r9,zero
8112282c:	0015883a 	mov	r10,zero
81122830:	02c00044 	movi	r11,1
81122834:	003f1d06 	br	811224ac <__reset+0xfb1024ac>
81122838:	4defc83a 	sub	r23,r9,r23
8112283c:	bd6f883a 	add	r23,r23,r21
81122840:	05c21e0e 	bge	zero,r23,811230bc <_strtod_r+0xe94>
81122844:	b88003cc 	andi	r2,r23,15
81122848:	10000d26 	beq	r2,zero,81122880 <_strtod_r+0x658>
8112284c:	100490fa 	slli	r2,r2,3
81122850:	00e04534 	movhi	r3,33044
81122854:	18d15e04 	addi	r3,r3,17784
81122858:	1885883a 	add	r2,r3,r2
8112285c:	11000017 	ldw	r4,0(r2)
81122860:	11400117 	ldw	r5,4(r2)
81122864:	900d883a 	mov	r6,r18
81122868:	880f883a 	mov	r7,r17
8112286c:	da401315 	stw	r9,76(sp)
81122870:	1114ae40 	call	81114ae4 <__muldf3>
81122874:	da401317 	ldw	r9,76(sp)
81122878:	1025883a 	mov	r18,r2
8112287c:	1823883a 	mov	r17,r3
81122880:	023ffc04 	movi	r8,-16
81122884:	ba10703a 	and	r8,r23,r8
81122888:	40003c26 	beq	r8,zero,8112297c <_strtod_r+0x754>
8112288c:	00804d04 	movi	r2,308
81122890:	1201cd16 	blt	r2,r8,81122fc8 <_strtod_r+0xda0>
81122894:	4011d13a 	srai	r8,r8,4
81122898:	03000044 	movi	r12,1
8112289c:	62037c0e 	bge	r12,r8,81123690 <_strtod_r+0x1468>
811228a0:	01204534 	movhi	r4,33044
811228a4:	21115404 	addi	r4,r4,17744
811228a8:	2015883a 	mov	r10,r4
811228ac:	0027883a 	mov	r19,zero
811228b0:	d9000915 	stw	r4,36(sp)
811228b4:	9005883a 	mov	r2,r18
811228b8:	8807883a 	mov	r3,r17
811228bc:	dc000c15 	stw	r16,48(sp)
811228c0:	dc800e15 	stw	r18,56(sp)
811228c4:	9821883a 	mov	r16,r19
811228c8:	0009883a 	mov	r4,zero
811228cc:	8827883a 	mov	r19,r17
811228d0:	602f883a 	mov	r23,r12
811228d4:	da400a15 	stw	r9,40(sp)
811228d8:	5025883a 	mov	r18,r10
811228dc:	4023883a 	mov	r17,r8
811228e0:	8980004c 	andi	r6,r17,1
811228e4:	30000626 	beq	r6,zero,81122900 <_strtod_r+0x6d8>
811228e8:	91800017 	ldw	r6,0(r18)
811228ec:	91c00117 	ldw	r7,4(r18)
811228f0:	1009883a 	mov	r4,r2
811228f4:	180b883a 	mov	r5,r3
811228f8:	1114ae40 	call	81114ae4 <__muldf3>
811228fc:	01000044 	movi	r4,1
81122900:	8823d07a 	srai	r17,r17,1
81122904:	84000044 	addi	r16,r16,1
81122908:	94800204 	addi	r18,r18,8
8112290c:	8dfff41e 	bne	r17,r23,811228e0 <__reset+0xfb1028e0>
81122910:	21003fcc 	andi	r4,r4,255
81122914:	9823883a 	mov	r17,r19
81122918:	da400a17 	ldw	r9,40(sp)
8112291c:	8027883a 	mov	r19,r16
81122920:	dc800e17 	ldw	r18,56(sp)
81122924:	dc000c17 	ldw	r16,48(sp)
81122928:	2003b11e 	bne	r4,zero,811237f0 <_strtod_r+0x15c8>
8112292c:	981690fa 	slli	r11,r19,3
81122930:	d8800917 	ldw	r2,36(sp)
81122934:	01ff2c34 	movhi	r7,64688
81122938:	900d883a 	mov	r6,r18
8112293c:	12ef883a 	add	r23,r2,r11
81122940:	b9000017 	ldw	r4,0(r23)
81122944:	b9400117 	ldw	r5,4(r23)
81122948:	89cf883a 	add	r7,r17,r7
8112294c:	da401315 	stw	r9,76(sp)
81122950:	1114ae40 	call	81114ae4 <__muldf3>
81122954:	1025883a 	mov	r18,r2
81122958:	011f2834 	movhi	r4,31904
8112295c:	189ffc2c 	andhi	r2,r3,32752
81122960:	da401317 	ldw	r9,76(sp)
81122964:	20819836 	bltu	r4,r2,81122fc8 <_strtod_r+0xda0>
81122968:	011f2434 	movhi	r4,31888
8112296c:	2083382e 	bgeu	r4,r2,81123650 <_strtod_r+0x1428>
81122970:	045ffc34 	movhi	r17,32752
81122974:	8c7fffc4 	addi	r17,r17,-1
81122978:	04bfffc4 	movi	r18,-1
8112297c:	d8000915 	stw	zero,36(sp)
81122980:	d9400817 	ldw	r5,32(sp)
81122984:	df000015 	stw	fp,0(sp)
81122988:	480f883a 	mov	r7,r9
8112298c:	b00d883a 	mov	r6,r22
81122990:	8009883a 	mov	r4,r16
81122994:	1120b640 	call	81120b64 <__s2b>
81122998:	d8800815 	stw	r2,32(sp)
8112299c:	10018a26 	beq	r2,zero,81122fc8 <_strtod_r+0xda0>
811229a0:	a807d7fa 	srai	r3,r21,31
811229a4:	0545c83a 	sub	r2,zero,r21
811229a8:	dd400a15 	stw	r21,40(sp)
811229ac:	1886703a 	and	r3,r3,r2
811229b0:	d8c00c15 	stw	r3,48(sp)
811229b4:	a8013516 	blt	r21,zero,81122e8c <_strtod_r+0xc64>
811229b8:	d9400817 	ldw	r5,32(sp)
811229bc:	0011883a 	mov	r8,zero
811229c0:	0027883a 	mov	r19,zero
811229c4:	29400304 	addi	r5,r5,12
811229c8:	d9400f15 	stw	r5,60(sp)
811229cc:	402b883a 	mov	r21,r8
811229d0:	dd001215 	stw	r20,72(sp)
811229d4:	d8800817 	ldw	r2,32(sp)
811229d8:	8009883a 	mov	r4,r16
811229dc:	11400117 	ldw	r5,4(r2)
811229e0:	11209640 	call	81120964 <_Balloc>
811229e4:	1029883a 	mov	r20,r2
811229e8:	10012d26 	beq	r2,zero,81122ea0 <_strtod_r+0xc78>
811229ec:	d8c00817 	ldw	r3,32(sp)
811229f0:	d9400f17 	ldw	r5,60(sp)
811229f4:	11000304 	addi	r4,r2,12
811229f8:	19800417 	ldw	r6,16(r3)
811229fc:	31800084 	addi	r6,r6,2
81122a00:	318d883a 	add	r6,r6,r6
81122a04:	318d883a 	add	r6,r6,r6
81122a08:	11167340 	call	81116734 <memcpy>
81122a0c:	d9000204 	addi	r4,sp,8
81122a10:	d9000015 	stw	r4,0(sp)
81122a14:	d9c00404 	addi	r7,sp,16
81122a18:	900b883a 	mov	r5,r18
81122a1c:	880d883a 	mov	r6,r17
81122a20:	8009883a 	mov	r4,r16
81122a24:	11216400 	call	81121640 <__d2b>
81122a28:	d8800515 	stw	r2,20(sp)
81122a2c:	dc801115 	stw	r18,68(sp)
81122a30:	dc401015 	stw	r17,64(sp)
81122a34:	10027c26 	beq	r2,zero,81123428 <_strtod_r+0x1200>
81122a38:	01400044 	movi	r5,1
81122a3c:	8009883a 	mov	r4,r16
81122a40:	1120d880 	call	81120d88 <__i2b>
81122a44:	1027883a 	mov	r19,r2
81122a48:	10011526 	beq	r2,zero,81122ea0 <_strtod_r+0xc78>
81122a4c:	d8800417 	ldw	r2,16(sp)
81122a50:	1000c816 	blt	r2,zero,81122d74 <_strtod_r+0xb4c>
81122a54:	d9400c17 	ldw	r5,48(sp)
81122a58:	d9000a17 	ldw	r4,40(sp)
81122a5c:	28ad883a 	add	r22,r5,r2
81122a60:	d9400917 	ldw	r5,36(sp)
81122a64:	df000217 	ldw	fp,8(sp)
81122a68:	05ff0084 	movi	r23,-1022
81122a6c:	1147c83a 	sub	r3,r2,r5
81122a70:	1f07883a 	add	r3,r3,fp
81122a74:	00800d84 	movi	r2,54
81122a78:	18ffffc4 	addi	r3,r3,-1
81122a7c:	1739c83a 	sub	fp,r2,fp
81122a80:	1dc0a50e 	bge	r3,r23,81122d18 <_strtod_r+0xaf0>
81122a84:	b8efc83a 	sub	r23,r23,r3
81122a88:	008007c4 	movi	r2,31
81122a8c:	e5f9c83a 	sub	fp,fp,r23
81122a90:	15c0bc16 	blt	r2,r23,81122d84 <_strtod_r+0xb5c>
81122a94:	00800044 	movi	r2,1
81122a98:	15c4983a 	sll	r2,r2,r23
81122a9c:	d8000b15 	stw	zero,44(sp)
81122aa0:	d8800d15 	stw	r2,52(sp)
81122aa4:	2707883a 	add	r3,r4,fp
81122aa8:	d9000917 	ldw	r4,36(sp)
81122aac:	b739883a 	add	fp,r22,fp
81122ab0:	20ef883a 	add	r23,r4,r3
81122ab4:	b009883a 	mov	r4,r22
81122ab8:	e580010e 	bge	fp,r22,81122ac0 <_strtod_r+0x898>
81122abc:	e009883a 	mov	r4,fp
81122ac0:	b805883a 	mov	r2,r23
81122ac4:	25c0010e 	bge	r4,r23,81122acc <_strtod_r+0x8a4>
81122ac8:	2005883a 	mov	r2,r4
81122acc:	0080030e 	bge	zero,r2,81122adc <_strtod_r+0x8b4>
81122ad0:	e0b9c83a 	sub	fp,fp,r2
81122ad4:	b8afc83a 	sub	r23,r23,r2
81122ad8:	b0adc83a 	sub	r22,r22,r2
81122adc:	d9400c17 	ldw	r5,48(sp)
81122ae0:	28001126 	beq	r5,zero,81122b28 <_strtod_r+0x900>
81122ae4:	280d883a 	mov	r6,r5
81122ae8:	8009883a 	mov	r4,r16
81122aec:	980b883a 	mov	r5,r19
81122af0:	1120fcc0 	call	81120fcc <__pow5mult>
81122af4:	1027883a 	mov	r19,r2
81122af8:	1000e926 	beq	r2,zero,81122ea0 <_strtod_r+0xc78>
81122afc:	d9800517 	ldw	r6,20(sp)
81122b00:	100b883a 	mov	r5,r2
81122b04:	8009883a 	mov	r4,r16
81122b08:	1120dcc0 	call	81120dcc <__multiply>
81122b0c:	1000e426 	beq	r2,zero,81122ea0 <_strtod_r+0xc78>
81122b10:	d9400517 	ldw	r5,20(sp)
81122b14:	8009883a 	mov	r4,r16
81122b18:	d8801315 	stw	r2,76(sp)
81122b1c:	1120a140 	call	81120a14 <_Bfree>
81122b20:	d8801317 	ldw	r2,76(sp)
81122b24:	d8800515 	stw	r2,20(sp)
81122b28:	0700060e 	bge	zero,fp,81122b44 <_strtod_r+0x91c>
81122b2c:	d9400517 	ldw	r5,20(sp)
81122b30:	e00d883a 	mov	r6,fp
81122b34:	8009883a 	mov	r4,r16
81122b38:	11211140 	call	81121114 <__lshift>
81122b3c:	d8800515 	stw	r2,20(sp)
81122b40:	10023926 	beq	r2,zero,81123428 <_strtod_r+0x1200>
81122b44:	d8800a17 	ldw	r2,40(sp)
81122b48:	10000626 	beq	r2,zero,81122b64 <_strtod_r+0x93c>
81122b4c:	d9800a17 	ldw	r6,40(sp)
81122b50:	a00b883a 	mov	r5,r20
81122b54:	8009883a 	mov	r4,r16
81122b58:	1120fcc0 	call	81120fcc <__pow5mult>
81122b5c:	1029883a 	mov	r20,r2
81122b60:	1000cf26 	beq	r2,zero,81122ea0 <_strtod_r+0xc78>
81122b64:	05c0060e 	bge	zero,r23,81122b80 <_strtod_r+0x958>
81122b68:	a00b883a 	mov	r5,r20
81122b6c:	b80d883a 	mov	r6,r23
81122b70:	8009883a 	mov	r4,r16
81122b74:	11211140 	call	81121114 <__lshift>
81122b78:	1029883a 	mov	r20,r2
81122b7c:	1000c826 	beq	r2,zero,81122ea0 <_strtod_r+0xc78>
81122b80:	0580060e 	bge	zero,r22,81122b9c <_strtod_r+0x974>
81122b84:	980b883a 	mov	r5,r19
81122b88:	b00d883a 	mov	r6,r22
81122b8c:	8009883a 	mov	r4,r16
81122b90:	11211140 	call	81121114 <__lshift>
81122b94:	1027883a 	mov	r19,r2
81122b98:	1000c126 	beq	r2,zero,81122ea0 <_strtod_r+0xc78>
81122b9c:	d9400517 	ldw	r5,20(sp)
81122ba0:	a00d883a 	mov	r6,r20
81122ba4:	8009883a 	mov	r4,r16
81122ba8:	11212c40 	call	811212c4 <__mdiff>
81122bac:	102b883a 	mov	r21,r2
81122bb0:	1000bb26 	beq	r2,zero,81122ea0 <_strtod_r+0xc78>
81122bb4:	10c00317 	ldw	r3,12(r2)
81122bb8:	980b883a 	mov	r5,r19
81122bbc:	10000315 	stw	zero,12(r2)
81122bc0:	1009883a 	mov	r4,r2
81122bc4:	d8c00e15 	stw	r3,56(sp)
81122bc8:	11212640 	call	81121264 <__mcmp>
81122bcc:	10027616 	blt	r2,zero,811235a8 <_strtod_r+0x1380>
81122bd0:	10024426 	beq	r2,zero,811234e4 <_strtod_r+0x12bc>
81122bd4:	980b883a 	mov	r5,r19
81122bd8:	a809883a 	mov	r4,r21
81122bdc:	11217940 	call	81121794 <__ratio>
81122be0:	000d883a 	mov	r6,zero
81122be4:	01d00034 	movhi	r7,16384
81122be8:	1009883a 	mov	r4,r2
81122bec:	180b883a 	mov	r5,r3
81122bf0:	102f883a 	mov	r23,r2
81122bf4:	182d883a 	mov	r22,r3
81122bf8:	112a2dc0 	call	8112a2dc <__ledf2>
81122bfc:	00804a16 	blt	zero,r2,81122d28 <_strtod_r+0xb00>
81122c00:	d9400e17 	ldw	r5,56(sp)
81122c04:	28006b26 	beq	r5,zero,81122db4 <_strtod_r+0xb8c>
81122c08:	058ffc34 	movhi	r22,16368
81122c0c:	d8000b15 	stw	zero,44(sp)
81122c10:	d8000d15 	stw	zero,52(sp)
81122c14:	b02f883a 	mov	r23,r22
81122c18:	8f1ffc2c 	andhi	fp,r17,32752
81122c1c:	009ff834 	movhi	r2,32736
81122c20:	e080cd26 	beq	fp,r2,81122f58 <_strtod_r+0xd30>
81122c24:	d9400917 	ldw	r5,36(sp)
81122c28:	28001a26 	beq	r5,zero,81122c94 <_strtod_r+0xa6c>
81122c2c:	0081a834 	movhi	r2,1696
81122c30:	17001836 	bltu	r2,fp,81122c94 <_strtod_r+0xa6c>
81122c34:	d9000d17 	ldw	r4,52(sp)
81122c38:	01d07834 	movhi	r7,16864
81122c3c:	39ffffc4 	addi	r7,r7,-1
81122c40:	01bff034 	movhi	r6,65472
81122c44:	b80b883a 	mov	r5,r23
81122c48:	112a2dc0 	call	8112a2dc <__ledf2>
81122c4c:	00800e16 	blt	zero,r2,81122c88 <_strtod_r+0xa60>
81122c50:	d9000d17 	ldw	r4,52(sp)
81122c54:	b80b883a 	mov	r5,r23
81122c58:	11280e80 	call	811280e8 <__fixunsdfsi>
81122c5c:	10018126 	beq	r2,zero,81123264 <_strtod_r+0x103c>
81122c60:	1009883a 	mov	r4,r2
81122c64:	112ae380 	call	8112ae38 <__floatunsidf>
81122c68:	d8800d15 	stw	r2,52(sp)
81122c6c:	182f883a 	mov	r23,r3
81122c70:	d8800e17 	ldw	r2,56(sp)
81122c74:	1001791e 	bne	r2,zero,8112325c <_strtod_r+0x1034>
81122c78:	ba20003c 	xorhi	r8,r23,32768
81122c7c:	d8c00d17 	ldw	r3,52(sp)
81122c80:	402d883a 	mov	r22,r8
81122c84:	d8c00b15 	stw	r3,44(sp)
81122c88:	0081ac34 	movhi	r2,1712
81122c8c:	b091883a 	add	r8,r22,r2
81122c90:	472dc83a 	sub	r22,r8,fp
81122c94:	9009883a 	mov	r4,r18
81122c98:	880b883a 	mov	r5,r17
81122c9c:	11214c80 	call	811214c8 <__ulp>
81122ca0:	d9000b17 	ldw	r4,44(sp)
81122ca4:	b00b883a 	mov	r5,r22
81122ca8:	100d883a 	mov	r6,r2
81122cac:	180f883a 	mov	r7,r3
81122cb0:	1114ae40 	call	81114ae4 <__muldf3>
81122cb4:	900d883a 	mov	r6,r18
81122cb8:	880f883a 	mov	r7,r17
81122cbc:	1009883a 	mov	r4,r2
81122cc0:	180b883a 	mov	r5,r3
81122cc4:	1128fd40 	call	81128fd4 <__adddf3>
81122cc8:	1025883a 	mov	r18,r2
81122ccc:	1823883a 	mov	r17,r3
81122cd0:	182d883a 	mov	r22,r3
81122cd4:	d9000917 	ldw	r4,36(sp)
81122cd8:	2000021e 	bne	r4,zero,81122ce4 <_strtod_r+0xabc>
81122cdc:	b09ffc2c 	andhi	r2,r22,32752
81122ce0:	e080be26 	beq	fp,r2,81122fdc <_strtod_r+0xdb4>
81122ce4:	d9400517 	ldw	r5,20(sp)
81122ce8:	8009883a 	mov	r4,r16
81122cec:	1120a140 	call	81120a14 <_Bfree>
81122cf0:	a00b883a 	mov	r5,r20
81122cf4:	8009883a 	mov	r4,r16
81122cf8:	1120a140 	call	81120a14 <_Bfree>
81122cfc:	980b883a 	mov	r5,r19
81122d00:	8009883a 	mov	r4,r16
81122d04:	1120a140 	call	81120a14 <_Bfree>
81122d08:	a80b883a 	mov	r5,r21
81122d0c:	8009883a 	mov	r4,r16
81122d10:	1120a140 	call	81120a14 <_Bfree>
81122d14:	003f2f06 	br	811229d4 <__reset+0xfb1029d4>
81122d18:	00c00044 	movi	r3,1
81122d1c:	d8000b15 	stw	zero,44(sp)
81122d20:	d8c00d15 	stw	r3,52(sp)
81122d24:	003f5f06 	br	81122aa4 <__reset+0xfb102aa4>
81122d28:	b809883a 	mov	r4,r23
81122d2c:	000d883a 	mov	r6,zero
81122d30:	01cff834 	movhi	r7,16352
81122d34:	b00b883a 	mov	r5,r22
81122d38:	1114ae40 	call	81114ae4 <__muldf3>
81122d3c:	d9000e17 	ldw	r4,56(sp)
81122d40:	d8800d15 	stw	r2,52(sp)
81122d44:	182f883a 	mov	r23,r3
81122d48:	2000181e 	bne	r4,zero,81122dac <_strtod_r+0xb84>
81122d4c:	1a20003c 	xorhi	r8,r3,32768
81122d50:	d8800b15 	stw	r2,44(sp)
81122d54:	402d883a 	mov	r22,r8
81122d58:	003faf06 	br	81122c18 <__reset+0xfb102c18>
81122d5c:	0015883a 	mov	r10,zero
81122d60:	02c00044 	movi	r11,1
81122d64:	2800011e 	bne	r5,zero,81122d6c <_strtod_r+0xb44>
81122d68:	903d7e26 	beq	r18,zero,81122364 <__reset+0xfb102364>
81122d6c:	0013883a 	mov	r9,zero
81122d70:	003e4706 	br	81122690 <__reset+0xfb102690>
81122d74:	d8c00a17 	ldw	r3,40(sp)
81122d78:	dd800c17 	ldw	r22,48(sp)
81122d7c:	1889c83a 	sub	r4,r3,r2
81122d80:	003f3706 	br	81122a60 <__reset+0xfb102a60>
81122d84:	00bef884 	movi	r2,-1054
81122d88:	05c00044 	movi	r23,1
81122d8c:	10c5c83a 	sub	r2,r2,r3
81122d90:	b884983a 	sll	r2,r23,r2
81122d94:	ddc00d15 	stw	r23,52(sp)
81122d98:	d8800b15 	stw	r2,44(sp)
81122d9c:	003f4106 	br	81122aa4 <__reset+0xfb102aa4>
81122da0:	ddc00615 	stw	r23,24(sp)
81122da4:	002b883a 	mov	r21,zero
81122da8:	003dc306 	br	811224b8 <__reset+0xfb1024b8>
81122dac:	1811883a 	mov	r8,r3
81122db0:	003fe706 	br	81122d50 <__reset+0xfb102d50>
81122db4:	90002e1e 	bne	r18,zero,81122e70 <_strtod_r+0xc48>
81122db8:	00c00434 	movhi	r3,16
81122dbc:	18ffffc4 	addi	r3,r3,-1
81122dc0:	88c4703a 	and	r2,r17,r3
81122dc4:	10002c1e 	bne	r2,zero,81122e78 <_strtod_r+0xc50>
81122dc8:	000d883a 	mov	r6,zero
81122dcc:	01cffc34 	movhi	r7,16368
81122dd0:	b809883a 	mov	r4,r23
81122dd4:	b00b883a 	mov	r5,r22
81122dd8:	112a2dc0 	call	8112a2dc <__ledf2>
81122ddc:	10021716 	blt	r2,zero,8112363c <_strtod_r+0x1414>
81122de0:	b809883a 	mov	r4,r23
81122de4:	b00b883a 	mov	r5,r22
81122de8:	000d883a 	mov	r6,zero
81122dec:	01cff834 	movhi	r7,16352
81122df0:	1114ae40 	call	81114ae4 <__muldf3>
81122df4:	d8800d15 	stw	r2,52(sp)
81122df8:	182f883a 	mov	r23,r3
81122dfc:	102d883a 	mov	r22,r2
81122e00:	1a20003c 	xorhi	r8,r3,32768
81122e04:	dd800b15 	stw	r22,44(sp)
81122e08:	402d883a 	mov	r22,r8
81122e0c:	003f8206 	br	81122c18 <__reset+0xfb102c18>
81122e10:	b013883a 	mov	r9,r22
81122e14:	000b883a 	mov	r5,zero
81122e18:	0015883a 	mov	r10,zero
81122e1c:	893ff404 	addi	r4,r17,-48
81122e20:	00800244 	movi	r2,9
81122e24:	11001036 	bltu	r2,r4,81122e68 <_strtod_r+0xc40>
81122e28:	28c00044 	addi	r3,r5,1
81122e2c:	2023883a 	mov	r17,r4
81122e30:	20014d1e 	bne	r4,zero,81123368 <_strtod_r+0x1140>
81122e34:	d9800617 	ldw	r6,24(sp)
81122e38:	180b883a 	mov	r5,r3
81122e3c:	30800044 	addi	r2,r6,1
81122e40:	d8800615 	stw	r2,24(sp)
81122e44:	34400047 	ldb	r17,1(r6)
81122e48:	003ff406 	br	81122e1c <__reset+0xfb102e1c>
81122e4c:	0019883a 	mov	r12,zero
81122e50:	b8800084 	addi	r2,r23,2
81122e54:	d8800615 	stw	r2,24(sp)
81122e58:	bc400087 	ldb	r17,2(r23)
81122e5c:	003e1606 	br	811226b8 <__reset+0xfb1026b8>
81122e60:	03000044 	movi	r12,1
81122e64:	003ffa06 	br	81122e50 <__reset+0xfb102e50>
81122e68:	02c00044 	movi	r11,1
81122e6c:	003d8d06 	br	811224a4 <__reset+0xfb1024a4>
81122e70:	00800044 	movi	r2,1
81122e74:	9080fe26 	beq	r18,r2,81123270 <_strtod_r+0x1048>
81122e78:	d8000b15 	stw	zero,44(sp)
81122e7c:	05affc34 	movhi	r22,49136
81122e80:	d8000d15 	stw	zero,52(sp)
81122e84:	05cffc34 	movhi	r23,16368
81122e88:	003f6306 	br	81122c18 <__reset+0xfb102c18>
81122e8c:	d8000a15 	stw	zero,40(sp)
81122e90:	003ec906 	br	811229b8 <__reset+0xfb1029b8>
81122e94:	d9001117 	ldw	r4,68(sp)
81122e98:	00bfffc4 	movi	r2,-1
81122e9c:	2080461e 	bne	r4,r2,81122fb8 <_strtod_r+0xd90>
81122ea0:	dd000a15 	stw	r20,40(sp)
81122ea4:	dd001217 	ldw	r20,72(sp)
81122ea8:	a811883a 	mov	r8,r21
81122eac:	d8800517 	ldw	r2,20(sp)
81122eb0:	00c00884 	movi	r3,34
81122eb4:	80c00015 	stw	r3,0(r16)
81122eb8:	002b883a 	mov	r21,zero
81122ebc:	059ffc34 	movhi	r22,32752
81122ec0:	100b883a 	mov	r5,r2
81122ec4:	8009883a 	mov	r4,r16
81122ec8:	da001315 	stw	r8,76(sp)
81122ecc:	1120a140 	call	81120a14 <_Bfree>
81122ed0:	d9400a17 	ldw	r5,40(sp)
81122ed4:	8009883a 	mov	r4,r16
81122ed8:	1120a140 	call	81120a14 <_Bfree>
81122edc:	980b883a 	mov	r5,r19
81122ee0:	8009883a 	mov	r4,r16
81122ee4:	1120a140 	call	81120a14 <_Bfree>
81122ee8:	d9400817 	ldw	r5,32(sp)
81122eec:	8009883a 	mov	r4,r16
81122ef0:	1120a140 	call	81120a14 <_Bfree>
81122ef4:	da001317 	ldw	r8,76(sp)
81122ef8:	8009883a 	mov	r4,r16
81122efc:	400b883a 	mov	r5,r8
81122f00:	1120a140 	call	81120a14 <_Bfree>
81122f04:	003d9206 	br	81122550 <__reset+0xfb102550>
81122f08:	d8c00717 	ldw	r3,28(sp)
81122f0c:	d8800504 	addi	r2,sp,20
81122f10:	01a04534 	movhi	r6,33044
81122f14:	31919904 	addi	r6,r6,18020
81122f18:	d8c00115 	stw	r3,4(sp)
81122f1c:	d8800015 	stw	r2,0(sp)
81122f20:	d9c00404 	addi	r7,sp,16
81122f24:	d9400604 	addi	r5,sp,24
81122f28:	8009883a 	mov	r4,r16
81122f2c:	112737c0 	call	8112737c <__gethex>
81122f30:	154001cc 	andi	r21,r2,7
81122f34:	a83d9b26 	beq	r21,zero,811225a4 <__reset+0xfb1025a4>
81122f38:	00c00184 	movi	r3,6
81122f3c:	a8c0d61e 	bne	r21,r3,81123298 <_strtod_r+0x1070>
81122f40:	9cc00044 	addi	r19,r19,1
81122f44:	dcc00615 	stw	r19,24(sp)
81122f48:	002b883a 	mov	r21,zero
81122f4c:	002d883a 	mov	r22,zero
81122f50:	d8000715 	stw	zero,28(sp)
81122f54:	003d7e06 	br	81122550 <__reset+0xfb102550>
81122f58:	00bf2c34 	movhi	r2,64688
81122f5c:	88a3883a 	add	r17,r17,r2
81122f60:	9009883a 	mov	r4,r18
81122f64:	880b883a 	mov	r5,r17
81122f68:	11214c80 	call	811214c8 <__ulp>
81122f6c:	d9000b17 	ldw	r4,44(sp)
81122f70:	100d883a 	mov	r6,r2
81122f74:	180f883a 	mov	r7,r3
81122f78:	b00b883a 	mov	r5,r22
81122f7c:	1114ae40 	call	81114ae4 <__muldf3>
81122f80:	900d883a 	mov	r6,r18
81122f84:	180b883a 	mov	r5,r3
81122f88:	880f883a 	mov	r7,r17
81122f8c:	1009883a 	mov	r4,r2
81122f90:	1128fd40 	call	81128fd4 <__adddf3>
81122f94:	015f2834 	movhi	r5,31904
81122f98:	1025883a 	mov	r18,r2
81122f9c:	297fffc4 	addi	r5,r5,-1
81122fa0:	189ffc2c 	andhi	r2,r3,32752
81122fa4:	2880892e 	bgeu	r5,r2,811231cc <_strtod_r+0xfa4>
81122fa8:	d8801017 	ldw	r2,64(sp)
81122fac:	00dffc34 	movhi	r3,32752
81122fb0:	18ffffc4 	addi	r3,r3,-1
81122fb4:	10ffb726 	beq	r2,r3,81122e94 <__reset+0xfb102e94>
81122fb8:	045ffc34 	movhi	r17,32752
81122fbc:	8c7fffc4 	addi	r17,r17,-1
81122fc0:	04bfffc4 	movi	r18,-1
81122fc4:	003f4706 	br	81122ce4 <__reset+0xfb102ce4>
81122fc8:	00800884 	movi	r2,34
81122fcc:	80800015 	stw	r2,0(r16)
81122fd0:	002b883a 	mov	r21,zero
81122fd4:	059ffc34 	movhi	r22,32752
81122fd8:	003d5d06 	br	81122550 <__reset+0xfb102550>
81122fdc:	d9000d17 	ldw	r4,52(sp)
81122fe0:	b80b883a 	mov	r5,r23
81122fe4:	112acd40 	call	8112acd4 <__fixdfsi>
81122fe8:	1009883a 	mov	r4,r2
81122fec:	112ad540 	call	8112ad54 <__floatsidf>
81122ff0:	d9000d17 	ldw	r4,52(sp)
81122ff4:	b80b883a 	mov	r5,r23
81122ff8:	100d883a 	mov	r6,r2
81122ffc:	180f883a 	mov	r7,r3
81123000:	112a3d00 	call	8112a3d0 <__subdf3>
81123004:	d9400e17 	ldw	r5,56(sp)
81123008:	1039883a 	mov	fp,r2
8112300c:	182f883a 	mov	r23,r3
81123010:	2800141e 	bne	r5,zero,81123064 <_strtod_r+0xe3c>
81123014:	9000131e 	bne	r18,zero,81123064 <_strtod_r+0xe3c>
81123018:	00800434 	movhi	r2,16
8112301c:	10bfffc4 	addi	r2,r2,-1
81123020:	b0ac703a 	and	r22,r22,r2
81123024:	b0000f1e 	bne	r22,zero,81123064 <_strtod_r+0xe3c>
81123028:	01a52834 	movhi	r6,38048
8112302c:	01cff434 	movhi	r7,16336
81123030:	318d6544 	addi	r6,r6,13717
81123034:	39ffffc4 	addi	r7,r7,-1
81123038:	e009883a 	mov	r4,fp
8112303c:	180b883a 	mov	r5,r3
81123040:	112a2dc0 	call	8112a2dc <__ledf2>
81123044:	103f270e 	bge	r2,zero,81122ce4 <__reset+0xfb102ce4>
81123048:	dd000a15 	stw	r20,40(sp)
8112304c:	a811883a 	mov	r8,r21
81123050:	dd001217 	ldw	r20,72(sp)
81123054:	d8800517 	ldw	r2,20(sp)
81123058:	002b883a 	mov	r21,zero
8112305c:	882d883a 	mov	r22,r17
81123060:	003f9706 	br	81122ec0 <__reset+0xfb102ec0>
81123064:	01a52834 	movhi	r6,38048
81123068:	01cff834 	movhi	r7,16352
8112306c:	318d6544 	addi	r6,r6,13717
81123070:	39ffffc4 	addi	r7,r7,-1
81123074:	e009883a 	mov	r4,fp
81123078:	b80b883a 	mov	r5,r23
8112307c:	112a2dc0 	call	8112a2dc <__ledf2>
81123080:	10000716 	blt	r2,zero,811230a0 <_strtod_r+0xe78>
81123084:	018d6c34 	movhi	r6,13744
81123088:	31b94d44 	addi	r6,r6,-6859
8112308c:	01cff834 	movhi	r7,16352
81123090:	e009883a 	mov	r4,fp
81123094:	b80b883a 	mov	r5,r23
81123098:	112a2000 	call	8112a200 <__gedf2>
8112309c:	00bf110e 	bge	zero,r2,81122ce4 <__reset+0xfb102ce4>
811230a0:	dd000a15 	stw	r20,40(sp)
811230a4:	a811883a 	mov	r8,r21
811230a8:	dd001217 	ldw	r20,72(sp)
811230ac:	d8800517 	ldw	r2,20(sp)
811230b0:	902b883a 	mov	r21,r18
811230b4:	882d883a 	mov	r22,r17
811230b8:	003f8106 	br	81122ec0 <__reset+0xfb102ec0>
811230bc:	b83e2f26 	beq	r23,zero,8112297c <__reset+0xfb10297c>
811230c0:	05efc83a 	sub	r23,zero,r23
811230c4:	b88003cc 	andi	r2,r23,15
811230c8:	10000d26 	beq	r2,zero,81123100 <_strtod_r+0xed8>
811230cc:	100490fa 	slli	r2,r2,3
811230d0:	00e04534 	movhi	r3,33044
811230d4:	18d15e04 	addi	r3,r3,17784
811230d8:	1885883a 	add	r2,r3,r2
811230dc:	11800017 	ldw	r6,0(r2)
811230e0:	11c00117 	ldw	r7,4(r2)
811230e4:	9009883a 	mov	r4,r18
811230e8:	880b883a 	mov	r5,r17
811230ec:	da401315 	stw	r9,76(sp)
811230f0:	11298880 	call	81129888 <__divdf3>
811230f4:	da401317 	ldw	r9,76(sp)
811230f8:	1025883a 	mov	r18,r2
811230fc:	1823883a 	mov	r17,r3
81123100:	b82fd13a 	srai	r23,r23,4
81123104:	b83e1d26 	beq	r23,zero,8112297c <__reset+0xfb10297c>
81123108:	008007c4 	movi	r2,31
8112310c:	15c02816 	blt	r2,r23,811231b0 <_strtod_r+0xf88>
81123110:	b880040c 	andi	r2,r23,16
81123114:	10019726 	beq	r2,zero,81123774 <_strtod_r+0x154c>
81123118:	05c1880e 	bge	zero,r23,8112373c <_strtod_r+0x1514>
8112311c:	00c01a84 	movi	r3,106
81123120:	d8c00915 	stw	r3,36(sp)
81123124:	04e04534 	movhi	r19,33044
81123128:	9cd19e04 	addi	r19,r19,18040
8112312c:	8807883a 	mov	r3,r17
81123130:	9005883a 	mov	r2,r18
81123134:	8023883a 	mov	r17,r16
81123138:	0009883a 	mov	r4,zero
8112313c:	9821883a 	mov	r16,r19
81123140:	da400a15 	stw	r9,40(sp)
81123144:	1827883a 	mov	r19,r3
81123148:	b980004c 	andi	r6,r23,1
8112314c:	30000626 	beq	r6,zero,81123168 <_strtod_r+0xf40>
81123150:	81800017 	ldw	r6,0(r16)
81123154:	81c00117 	ldw	r7,4(r16)
81123158:	1009883a 	mov	r4,r2
8112315c:	180b883a 	mov	r5,r3
81123160:	1114ae40 	call	81114ae4 <__muldf3>
81123164:	01000044 	movi	r4,1
81123168:	b82fd07a 	srai	r23,r23,1
8112316c:	84000204 	addi	r16,r16,8
81123170:	b83ff51e 	bne	r23,zero,81123148 <__reset+0xfb103148>
81123174:	21003fcc 	andi	r4,r4,255
81123178:	8821883a 	mov	r16,r17
8112317c:	da400a17 	ldw	r9,40(sp)
81123180:	9823883a 	mov	r17,r19
81123184:	2001a51e 	bne	r4,zero,8112381c <_strtod_r+0x15f4>
81123188:	d9000917 	ldw	r4,36(sp)
8112318c:	20016d1e 	bne	r4,zero,81123744 <_strtod_r+0x151c>
81123190:	000d883a 	mov	r6,zero
81123194:	000f883a 	mov	r7,zero
81123198:	9009883a 	mov	r4,r18
8112319c:	880b883a 	mov	r5,r17
811231a0:	da401315 	stw	r9,76(sp)
811231a4:	112a1780 	call	8112a178 <__eqdf2>
811231a8:	da401317 	ldw	r9,76(sp)
811231ac:	103df41e 	bne	r2,zero,81122980 <__reset+0xfb102980>
811231b0:	00800884 	movi	r2,34
811231b4:	80800015 	stw	r2,0(r16)
811231b8:	002b883a 	mov	r21,zero
811231bc:	002d883a 	mov	r22,zero
811231c0:	003ce306 	br	81122550 <__reset+0xfb102550>
811231c4:	055387c4 	movi	r21,19999
811231c8:	003d6b06 	br	81122778 <__reset+0xfb102778>
811231cc:	0440d434 	movhi	r17,848
811231d0:	1c63883a 	add	r17,r3,r17
811231d4:	882d883a 	mov	r22,r17
811231d8:	003ebe06 	br	81122cd4 <__reset+0xfb102cd4>
811231dc:	14403fcc 	andi	r17,r2,255
811231e0:	8c40201c 	xori	r17,r17,128
811231e4:	8c7fe004 	addi	r17,r17,-128
811231e8:	dd400817 	ldw	r21,32(sp)
811231ec:	0027883a 	mov	r19,zero
811231f0:	0039883a 	mov	fp,zero
811231f4:	002d883a 	mov	r22,zero
811231f8:	003c9906 	br	81122460 <__reset+0xfb102460>
811231fc:	00c00944 	movi	r3,37
81123200:	1a47c83a 	sub	r3,r3,r9
81123204:	1d7d8c16 	blt	r3,r21,81122838 <__reset+0xfb102838>
81123208:	1261c83a 	sub	r16,r2,r9
8112320c:	800490fa 	slli	r2,r16,3
81123210:	04e04534 	movhi	r19,33044
81123214:	9cd15e04 	addi	r19,r19,17784
81123218:	9885883a 	add	r2,r19,r2
8112321c:	11000017 	ldw	r4,0(r2)
81123220:	11400117 	ldw	r5,4(r2)
81123224:	900d883a 	mov	r6,r18
81123228:	880f883a 	mov	r7,r17
8112322c:	1114ae40 	call	81114ae4 <__muldf3>
81123230:	ac0dc83a 	sub	r6,r21,r16
81123234:	300c90fa 	slli	r6,r6,3
81123238:	1009883a 	mov	r4,r2
8112323c:	180b883a 	mov	r5,r3
81123240:	9985883a 	add	r2,r19,r6
81123244:	11800017 	ldw	r6,0(r2)
81123248:	11c00117 	ldw	r7,4(r2)
8112324c:	1114ae40 	call	81114ae4 <__muldf3>
81123250:	102b883a 	mov	r21,r2
81123254:	182d883a 	mov	r22,r3
81123258:	003cbd06 	br	81122550 <__reset+0xfb102550>
8112325c:	b811883a 	mov	r8,r23
81123260:	003e8606 	br	81122c7c <__reset+0xfb102c7c>
81123264:	d8000d15 	stw	zero,52(sp)
81123268:	05cffc34 	movhi	r23,16368
8112326c:	003e8006 	br	81122c70 <__reset+0xfb102c70>
81123270:	883f011e 	bne	r17,zero,81122e78 <__reset+0xfb102e78>
81123274:	dd000a15 	stw	r20,40(sp)
81123278:	dd001217 	ldw	r20,72(sp)
8112327c:	a811883a 	mov	r8,r21
81123280:	00800884 	movi	r2,34
81123284:	80800015 	stw	r2,0(r16)
81123288:	002b883a 	mov	r21,zero
8112328c:	d8800517 	ldw	r2,20(sp)
81123290:	002d883a 	mov	r22,zero
81123294:	003f0a06 	br	81122ec0 <__reset+0xfb102ec0>
81123298:	d9800517 	ldw	r6,20(sp)
8112329c:	30000826 	beq	r6,zero,811232c0 <_strtod_r+0x1098>
811232a0:	01400d44 	movi	r5,53
811232a4:	d9000204 	addi	r4,sp,8
811232a8:	d8801315 	stw	r2,76(sp)
811232ac:	11218bc0 	call	811218bc <__copybits>
811232b0:	d9400517 	ldw	r5,20(sp)
811232b4:	8009883a 	mov	r4,r16
811232b8:	1120a140 	call	81120a14 <_Bfree>
811232bc:	d8801317 	ldw	r2,76(sp)
811232c0:	00c00184 	movi	r3,6
811232c4:	1d400f36 	bltu	r3,r21,81123304 <_strtod_r+0x10dc>
811232c8:	a82a90ba 	slli	r21,r21,2
811232cc:	00e044b4 	movhi	r3,33042
811232d0:	18ccb804 	addi	r3,r3,13024
811232d4:	a8eb883a 	add	r21,r21,r3
811232d8:	a8c00017 	ldw	r3,0(r21)
811232dc:	1800683a 	jmp	r3
811232e0:	8112335c 	xori	r4,r16,18637
811232e4:	81123334 	orhi	r4,r16,18636
811232e8:	81123318 	cmpnei	r4,r16,18636
811232ec:	811232fc 	xorhi	r4,r16,18635
811232f0:	81123324 	muli	r4,r16,18636
811232f4:	81123334 	orhi	r4,r16,18636
811232f8:	8112335c 	xori	r4,r16,18637
811232fc:	045ffc34 	movhi	r17,32752
81123300:	0025883a 	mov	r18,zero
81123304:	1080020c 	andi	r2,r2,8
81123308:	902b883a 	mov	r21,r18
8112330c:	103c8f26 	beq	r2,zero,8112254c <__reset+0xfb10254c>
81123310:	8da00034 	orhi	r22,r17,32768
81123314:	003c8e06 	br	81122550 <__reset+0xfb102550>
81123318:	dc800217 	ldw	r18,8(sp)
8112331c:	dc400317 	ldw	r17,12(sp)
81123320:	003ff806 	br	81123304 <__reset+0xfb103304>
81123324:	04600034 	movhi	r17,32768
81123328:	8c7fffc4 	addi	r17,r17,-1
8112332c:	04bfffc4 	movi	r18,-1
81123330:	003ff406 	br	81123304 <__reset+0xfb103304>
81123334:	d8c00417 	ldw	r3,16(sp)
81123338:	dc400317 	ldw	r17,12(sp)
8112333c:	013ffc34 	movhi	r4,65520
81123340:	18c10cc4 	addi	r3,r3,1075
81123344:	1806953a 	slli	r3,r3,20
81123348:	213fffc4 	addi	r4,r4,-1
8112334c:	8922703a 	and	r17,r17,r4
81123350:	dc800217 	ldw	r18,8(sp)
81123354:	88e2b03a 	or	r17,r17,r3
81123358:	003fea06 	br	81123304 <__reset+0xfb103304>
8112335c:	0023883a 	mov	r17,zero
81123360:	0025883a 	mov	r18,zero
81123364:	003fe706 	br	81123304 <__reset+0xfb103304>
81123368:	01800044 	movi	r6,1
8112336c:	50d5883a 	add	r10,r10,r3
81123370:	2a4b883a 	add	r5,r5,r9
81123374:	19811a26 	beq	r3,r6,811237e0 <_strtod_r+0x15b8>
81123378:	01800204 	movi	r6,8
8112337c:	01c00404 	movi	r7,16
81123380:	4a400044 	addi	r9,r9,1
81123384:	48bfffc4 	addi	r2,r9,-1
81123388:	30801616 	blt	r6,r2,811233e4 <_strtod_r+0x11bc>
8112338c:	e70002a4 	muli	fp,fp,10
81123390:	497ffb1e 	bne	r9,r5,81123380 <__reset+0xfb103380>
81123394:	d9800617 	ldw	r6,24(sp)
81123398:	4a400044 	addi	r9,r9,1
8112339c:	00c00204 	movi	r3,8
811233a0:	19400c0e 	bge	r3,r5,811233d4 <_strtod_r+0x11ac>
811233a4:	00800404 	movi	r2,16
811233a8:	000b883a 	mov	r5,zero
811233ac:	127ea316 	blt	r2,r9,81122e3c <__reset+0xfb102e3c>
811233b0:	988002a4 	muli	r2,r19,10
811233b4:	20a7883a 	add	r19,r4,r2
811233b8:	003ea006 	br	81122e3c <__reset+0xfb102e3c>
811233bc:	d8800617 	ldw	r2,24(sp)
811233c0:	8c7ff404 	addi	r17,r17,-48
811233c4:	2a800044 	addi	r10,r5,1
811233c8:	d8800815 	stw	r2,32(sp)
811233cc:	100d883a 	mov	r6,r2
811233d0:	02400044 	movi	r9,1
811233d4:	e08002a4 	muli	r2,fp,10
811233d8:	000b883a 	mov	r5,zero
811233dc:	88b9883a 	add	fp,r17,r2
811233e0:	003e9606 	br	81122e3c <__reset+0xfb102e3c>
811233e4:	3a7fea16 	blt	r7,r9,81123390 <__reset+0xfb103390>
811233e8:	9cc002a4 	muli	r19,r19,10
811233ec:	003fe806 	br	81123390 <__reset+0xfb103390>
811233f0:	00bffa84 	movi	r2,-22
811233f4:	a8bd1016 	blt	r21,r2,81122838 <__reset+0xfb102838>
811233f8:	a82a90fa 	slli	r21,r21,3
811233fc:	00a04534 	movhi	r2,33044
81123400:	10915e04 	addi	r2,r2,17784
81123404:	1545c83a 	sub	r2,r2,r21
81123408:	11800017 	ldw	r6,0(r2)
8112340c:	11c00117 	ldw	r7,4(r2)
81123410:	9009883a 	mov	r4,r18
81123414:	880b883a 	mov	r5,r17
81123418:	11298880 	call	81129888 <__divdf3>
8112341c:	102b883a 	mov	r21,r2
81123420:	182d883a 	mov	r22,r3
81123424:	003c4a06 	br	81122550 <__reset+0xfb102550>
81123428:	dd000a15 	stw	r20,40(sp)
8112342c:	a811883a 	mov	r8,r21
81123430:	dd001217 	ldw	r20,72(sp)
81123434:	003e9e06 	br	81122eb0 <__reset+0xfb102eb0>
81123438:	01604534 	movhi	r5,33044
8112343c:	d9000617 	ldw	r4,24(sp)
81123440:	29519004 	addi	r5,r5,17984
81123444:	01c00644 	movi	r7,25
81123448:	00000b06 	br	81123478 <_strtod_r+0x1250>
8112344c:	21000044 	addi	r4,r4,1
81123450:	20800003 	ldbu	r2,0(r4)
81123454:	10ffefc4 	addi	r3,r2,-65
81123458:	10803fcc 	andi	r2,r2,255
8112345c:	1080201c 	xori	r2,r2,128
81123460:	18c03fcc 	andi	r3,r3,255
81123464:	10bfe004 	addi	r2,r2,-128
81123468:	38c00136 	bltu	r7,r3,81123470 <_strtod_r+0x1248>
8112346c:	10800804 	addi	r2,r2,32
81123470:	29400044 	addi	r5,r5,1
81123474:	11bbbb1e 	bne	r2,r6,81122364 <__reset+0xfb102364>
81123478:	29800007 	ldb	r6,0(r5)
8112347c:	303ff31e 	bne	r6,zero,8112344c <__reset+0xfb10344c>
81123480:	01a04534 	movhi	r6,33044
81123484:	d9000615 	stw	r4,24(sp)
81123488:	31919104 	addi	r6,r6,17988
8112348c:	200b883a 	mov	r5,r4
81123490:	02000644 	movi	r8,25
81123494:	00000a06 	br	811234c0 <_strtod_r+0x1298>
81123498:	28800003 	ldbu	r2,0(r5)
8112349c:	10ffefc4 	addi	r3,r2,-65
811234a0:	10803fcc 	andi	r2,r2,255
811234a4:	1080201c 	xori	r2,r2,128
811234a8:	18c03fcc 	andi	r3,r3,255
811234ac:	10bfe004 	addi	r2,r2,-128
811234b0:	40c00136 	bltu	r8,r3,811234b8 <_strtod_r+0x1290>
811234b4:	10800804 	addi	r2,r2,32
811234b8:	31800044 	addi	r6,r6,1
811234bc:	11c0711e 	bne	r2,r7,81123684 <_strtod_r+0x145c>
811234c0:	31c00007 	ldb	r7,0(r6)
811234c4:	29400044 	addi	r5,r5,1
811234c8:	383ff31e 	bne	r7,zero,81123498 <__reset+0xfb103498>
811234cc:	d9400615 	stw	r5,24(sp)
811234d0:	045ffc34 	movhi	r17,32752
811234d4:	0025883a 	mov	r18,zero
811234d8:	003c1b06 	br	81122548 <__reset+0xfb102548>
811234dc:	000b883a 	mov	r5,zero
811234e0:	003ccc06 	br	81122814 <__reset+0xfb102814>
811234e4:	d9400e17 	ldw	r5,56(sp)
811234e8:	dd000a15 	stw	r20,40(sp)
811234ec:	00800434 	movhi	r2,16
811234f0:	a811883a 	mov	r8,r21
811234f4:	dd001217 	ldw	r20,72(sp)
811234f8:	dd401117 	ldw	r21,68(sp)
811234fc:	dd801017 	ldw	r22,64(sp)
81123500:	10bfffc4 	addi	r2,r2,-1
81123504:	28005626 	beq	r5,zero,81123660 <_strtod_r+0x1438>
81123508:	8886703a 	and	r3,r17,r2
8112350c:	18807826 	beq	r3,r2,811236f0 <_strtod_r+0x14c8>
81123510:	d8c00b17 	ldw	r3,44(sp)
81123514:	18005726 	beq	r3,zero,81123674 <_strtod_r+0x144c>
81123518:	1c44703a 	and	r2,r3,r17
8112351c:	10000f26 	beq	r2,zero,8112355c <_strtod_r+0x1334>
81123520:	d9000e17 	ldw	r4,56(sp)
81123524:	d9800917 	ldw	r6,36(sp)
81123528:	20005e26 	beq	r4,zero,811236a4 <_strtod_r+0x147c>
8112352c:	9009883a 	mov	r4,r18
81123530:	880b883a 	mov	r5,r17
81123534:	da001315 	stw	r8,76(sp)
81123538:	11221bc0 	call	811221bc <sulp>
8112353c:	100d883a 	mov	r6,r2
81123540:	180f883a 	mov	r7,r3
81123544:	9009883a 	mov	r4,r18
81123548:	880b883a 	mov	r5,r17
8112354c:	1128fd40 	call	81128fd4 <__adddf3>
81123550:	da001317 	ldw	r8,76(sp)
81123554:	102b883a 	mov	r21,r2
81123558:	182d883a 	mov	r22,r3
8112355c:	d8c00917 	ldw	r3,36(sp)
81123560:	18000f26 	beq	r3,zero,811235a0 <_strtod_r+0x1378>
81123564:	a809883a 	mov	r4,r21
81123568:	b00b883a 	mov	r5,r22
8112356c:	000d883a 	mov	r6,zero
81123570:	01ce5434 	movhi	r7,14672
81123574:	da001315 	stw	r8,76(sp)
81123578:	1114ae40 	call	81114ae4 <__muldf3>
8112357c:	102b883a 	mov	r21,r2
81123580:	182d883a 	mov	r22,r3
81123584:	da001317 	ldw	r8,76(sp)
81123588:	1800051e 	bne	r3,zero,811235a0 <_strtod_r+0x1378>
8112358c:	d8800517 	ldw	r2,20(sp)
81123590:	a83e4b1e 	bne	r21,zero,81122ec0 <__reset+0xfb102ec0>
81123594:	00c00884 	movi	r3,34
81123598:	80c00015 	stw	r3,0(r16)
8112359c:	003e4806 	br	81122ec0 <__reset+0xfb102ec0>
811235a0:	d8800517 	ldw	r2,20(sp)
811235a4:	003e4606 	br	81122ec0 <__reset+0xfb102ec0>
811235a8:	d9000e17 	ldw	r4,56(sp)
811235ac:	dd000a15 	stw	r20,40(sp)
811235b0:	a811883a 	mov	r8,r21
811235b4:	dd001217 	ldw	r20,72(sp)
811235b8:	dd401117 	ldw	r21,68(sp)
811235bc:	dd801017 	ldw	r22,64(sp)
811235c0:	203fe61e 	bne	r4,zero,8112355c <__reset+0xfb10355c>
811235c4:	903fe51e 	bne	r18,zero,8112355c <__reset+0xfb10355c>
811235c8:	00800434 	movhi	r2,16
811235cc:	10bfffc4 	addi	r2,r2,-1
811235d0:	8884703a 	and	r2,r17,r2
811235d4:	103fe11e 	bne	r2,zero,8112355c <__reset+0xfb10355c>
811235d8:	8ddffc2c 	andhi	r23,r17,32752
811235dc:	0081ac34 	movhi	r2,1712
811235e0:	15ffde2e 	bgeu	r2,r23,8112355c <__reset+0xfb10355c>
811235e4:	40800517 	ldw	r2,20(r8)
811235e8:	1000031e 	bne	r2,zero,811235f8 <_strtod_r+0x13d0>
811235ec:	40800417 	ldw	r2,16(r8)
811235f0:	00c00044 	movi	r3,1
811235f4:	18bfd90e 	bge	r3,r2,8112355c <__reset+0xfb10355c>
811235f8:	400b883a 	mov	r5,r8
811235fc:	01800044 	movi	r6,1
81123600:	8009883a 	mov	r4,r16
81123604:	11211140 	call	81121114 <__lshift>
81123608:	980b883a 	mov	r5,r19
8112360c:	1009883a 	mov	r4,r2
81123610:	d8801315 	stw	r2,76(sp)
81123614:	11212640 	call	81121264 <__mcmp>
81123618:	da001317 	ldw	r8,76(sp)
8112361c:	00bfcf0e 	bge	zero,r2,8112355c <__reset+0xfb10355c>
81123620:	d8c00917 	ldw	r3,36(sp)
81123624:	18005c26 	beq	r3,zero,81123798 <_strtod_r+0x1570>
81123628:	0081ac34 	movhi	r2,1712
8112362c:	15c05a16 	blt	r2,r23,81123798 <_strtod_r+0x1570>
81123630:	0080dc34 	movhi	r2,880
81123634:	15ffcb16 	blt	r2,r23,81123564 <__reset+0xfb103564>
81123638:	003f1106 	br	81123280 <__reset+0xfb103280>
8112363c:	002d883a 	mov	r22,zero
81123640:	022ff834 	movhi	r8,49120
81123644:	d8000d15 	stw	zero,52(sp)
81123648:	05cff834 	movhi	r23,16352
8112364c:	003ded06 	br	81122e04 <__reset+0xfb102e04>
81123650:	0440d434 	movhi	r17,848
81123654:	1c63883a 	add	r17,r3,r17
81123658:	d8000915 	stw	zero,36(sp)
8112365c:	003cc806 	br	81122980 <__reset+0xfb102980>
81123660:	8884703a 	and	r2,r17,r2
81123664:	103faa1e 	bne	r2,zero,81123510 <__reset+0xfb103510>
81123668:	903fa91e 	bne	r18,zero,81123510 <__reset+0xfb103510>
8112366c:	8ddffc2c 	andhi	r23,r17,32752
81123670:	003feb06 	br	81123620 <__reset+0xfb103620>
81123674:	d8c00d17 	ldw	r3,52(sp)
81123678:	1cae703a 	and	r23,r3,r18
8112367c:	b83fb726 	beq	r23,zero,8112355c <__reset+0xfb10355c>
81123680:	003fa706 	br	81123520 <__reset+0xfb103520>
81123684:	21000044 	addi	r4,r4,1
81123688:	d9000615 	stw	r4,24(sp)
8112368c:	003f9006 	br	811234d0 <__reset+0xfb1034d0>
81123690:	01604534 	movhi	r5,33044
81123694:	29515404 	addi	r5,r5,17744
81123698:	d9400915 	stw	r5,36(sp)
8112369c:	0027883a 	mov	r19,zero
811236a0:	003ca206 	br	8112292c <__reset+0xfb10292c>
811236a4:	9009883a 	mov	r4,r18
811236a8:	880b883a 	mov	r5,r17
811236ac:	da001315 	stw	r8,76(sp)
811236b0:	11221bc0 	call	811221bc <sulp>
811236b4:	100d883a 	mov	r6,r2
811236b8:	180f883a 	mov	r7,r3
811236bc:	9009883a 	mov	r4,r18
811236c0:	880b883a 	mov	r5,r17
811236c4:	112a3d00 	call	8112a3d0 <__subdf3>
811236c8:	000d883a 	mov	r6,zero
811236cc:	000f883a 	mov	r7,zero
811236d0:	1009883a 	mov	r4,r2
811236d4:	180b883a 	mov	r5,r3
811236d8:	102b883a 	mov	r21,r2
811236dc:	182d883a 	mov	r22,r3
811236e0:	112a1780 	call	8112a178 <__eqdf2>
811236e4:	da001317 	ldw	r8,76(sp)
811236e8:	103ee526 	beq	r2,zero,81123280 <__reset+0xfb103280>
811236ec:	003f9b06 	br	8112355c <__reset+0xfb10355c>
811236f0:	d8800917 	ldw	r2,36(sp)
811236f4:	10002226 	beq	r2,zero,81123780 <_strtod_r+0x1558>
811236f8:	889ffc2c 	andhi	r2,r17,32752
811236fc:	00c1a834 	movhi	r3,1696
81123700:	18801f36 	bltu	r3,r2,81123780 <_strtod_r+0x1558>
81123704:	1004d53a 	srli	r2,r2,20
81123708:	00c01ac4 	movi	r3,107
8112370c:	1887c83a 	sub	r3,r3,r2
81123710:	00bfffc4 	movi	r2,-1
81123714:	10c4983a 	sll	r2,r2,r3
81123718:	14bf7d1e 	bne	r2,r18,81123510 <__reset+0xfb103510>
8112371c:	00dffc34 	movhi	r3,32752
81123720:	18ffffc4 	addi	r3,r3,-1
81123724:	88c03526 	beq	r17,r3,811237fc <_strtod_r+0x15d4>
81123728:	8c5ffc2c 	andhi	r17,r17,32752
8112372c:	00800434 	movhi	r2,16
81123730:	002b883a 	mov	r21,zero
81123734:	88ad883a 	add	r22,r17,r2
81123738:	003f8806 	br	8112355c <__reset+0xfb10355c>
8112373c:	01401a84 	movi	r5,106
81123740:	d9400915 	stw	r5,36(sp)
81123744:	8ddffc2c 	andhi	r23,r17,32752
81123748:	b82ed53a 	srli	r23,r23,20
8112374c:	00801ac4 	movi	r2,107
81123750:	15c5c83a 	sub	r2,r2,r23
81123754:	00be8e0e 	bge	zero,r2,81123190 <__reset+0xfb103190>
81123758:	00c007c4 	movi	r3,31
8112375c:	18800a0e 	bge	r3,r2,81123788 <_strtod_r+0x1560>
81123760:	00c00d04 	movi	r3,52
81123764:	0025883a 	mov	r18,zero
81123768:	1880270e 	bge	r3,r2,81123808 <_strtod_r+0x15e0>
8112376c:	0440dc34 	movhi	r17,880
81123770:	003e8706 	br	81123190 <__reset+0xfb103190>
81123774:	d8000915 	stw	zero,36(sp)
81123778:	05fe6a16 	blt	zero,r23,81123124 <__reset+0xfb103124>
8112377c:	003e8406 	br	81123190 <__reset+0xfb103190>
81123780:	00bfffc4 	movi	r2,-1
81123784:	003fe406 	br	81123718 <__reset+0xfb103718>
81123788:	00ffffc4 	movi	r3,-1
8112378c:	1884983a 	sll	r2,r3,r2
81123790:	14a4703a 	and	r18,r2,r18
81123794:	003e7e06 	br	81123190 <__reset+0xfb103190>
81123798:	00bffc34 	movhi	r2,65520
8112379c:	b8af883a 	add	r23,r23,r2
811237a0:	057fffc4 	movi	r21,-1
811237a4:	00800434 	movhi	r2,16
811237a8:	1545883a 	add	r2,r2,r21
811237ac:	b8acb03a 	or	r22,r23,r2
811237b0:	003f6a06 	br	8112355c <__reset+0xfb10355c>
811237b4:	01604534 	movhi	r5,33044
811237b8:	29519404 	addi	r5,r5,18000
811237bc:	d9800204 	addi	r6,sp,8
811237c0:	d9000604 	addi	r4,sp,24
811237c4:	1127bb40 	call	81127bb4 <__hexnan>
811237c8:	00c00144 	movi	r3,5
811237cc:	10fb5c1e 	bne	r2,r3,81122540 <__reset+0xfb102540>
811237d0:	dc400317 	ldw	r17,12(sp)
811237d4:	dc800217 	ldw	r18,8(sp)
811237d8:	8c5ffc34 	orhi	r17,r17,32752
811237dc:	003b5a06 	br	81122548 <__reset+0xfb102548>
811237e0:	480b883a 	mov	r5,r9
811237e4:	d9800617 	ldw	r6,24(sp)
811237e8:	4a400044 	addi	r9,r9,1
811237ec:	003eeb06 	br	8112339c <__reset+0xfb10339c>
811237f0:	1025883a 	mov	r18,r2
811237f4:	1823883a 	mov	r17,r3
811237f8:	003c4c06 	br	8112292c <__reset+0xfb10292c>
811237fc:	00ffffc4 	movi	r3,-1
81123800:	10ffc91e 	bne	r2,r3,81123728 <__reset+0xfb103728>
81123804:	003da906 	br	81122eac <__reset+0xfb102eac>
81123808:	10bff804 	addi	r2,r2,-32
8112380c:	00ffffc4 	movi	r3,-1
81123810:	1884983a 	sll	r2,r3,r2
81123814:	1462703a 	and	r17,r2,r17
81123818:	003e5d06 	br	81123190 <__reset+0xfb103190>
8112381c:	1025883a 	mov	r18,r2
81123820:	1823883a 	mov	r17,r3
81123824:	003e5806 	br	81123188 <__reset+0xfb103188>

81123828 <strtod>:
81123828:	00a04534 	movhi	r2,33044
8112382c:	109aed04 	addi	r2,r2,27572
81123830:	280d883a 	mov	r6,r5
81123834:	200b883a 	mov	r5,r4
81123838:	11000017 	ldw	r4,0(r2)
8112383c:	11222281 	jmpi	81122228 <_strtod_r>

81123840 <strtof>:
81123840:	defffb04 	addi	sp,sp,-20
81123844:	de00012e 	bgeu	sp,et,8112384c <strtof+0xc>
81123848:	003b68fa 	trap	3
8112384c:	dcc00315 	stw	r19,12(sp)
81123850:	04e04534 	movhi	r19,33044
81123854:	9cdaed04 	addi	r19,r19,27572
81123858:	280d883a 	mov	r6,r5
8112385c:	200b883a 	mov	r5,r4
81123860:	99000017 	ldw	r4,0(r19)
81123864:	dfc00415 	stw	ra,16(sp)
81123868:	dc800215 	stw	r18,8(sp)
8112386c:	dc400115 	stw	r17,4(sp)
81123870:	dc000015 	stw	r16,0(sp)
81123874:	11222280 	call	81122228 <_strtod_r>
81123878:	1009883a 	mov	r4,r2
8112387c:	180b883a 	mov	r5,r3
81123880:	1025883a 	mov	r18,r2
81123884:	1823883a 	mov	r17,r3
81123888:	111531c0 	call	8111531c <__truncdfsf2>
8112388c:	000b883a 	mov	r5,zero
81123890:	1009883a 	mov	r4,r2
81123894:	1021883a 	mov	r16,r2
81123898:	1128dd80 	call	81128dd8 <__eqsf2>
8112389c:	1000111e 	bne	r2,zero,811238e4 <strtof+0xa4>
811238a0:	000d883a 	mov	r6,zero
811238a4:	000f883a 	mov	r7,zero
811238a8:	9009883a 	mov	r4,r18
811238ac:	880b883a 	mov	r5,r17
811238b0:	112a1780 	call	8112a178 <__eqdf2>
811238b4:	10000b26 	beq	r2,zero,811238e4 <strtof+0xa4>
811238b8:	98800017 	ldw	r2,0(r19)
811238bc:	00c00884 	movi	r3,34
811238c0:	10c00015 	stw	r3,0(r2)
811238c4:	8005883a 	mov	r2,r16
811238c8:	dfc00417 	ldw	ra,16(sp)
811238cc:	dcc00317 	ldw	r19,12(sp)
811238d0:	dc800217 	ldw	r18,8(sp)
811238d4:	dc400117 	ldw	r17,4(sp)
811238d8:	dc000017 	ldw	r16,0(sp)
811238dc:	dec00504 	addi	sp,sp,20
811238e0:	f800283a 	ret
811238e4:	015fe034 	movhi	r5,32640
811238e8:	297fffc4 	addi	r5,r5,-1
811238ec:	8009883a 	mov	r4,r16
811238f0:	1128e500 	call	81128e50 <__gesf2>
811238f4:	0080070e 	bge	zero,r2,81123914 <strtof+0xd4>
811238f8:	01dffc34 	movhi	r7,32752
811238fc:	39ffffc4 	addi	r7,r7,-1
81123900:	01bfffc4 	movi	r6,-1
81123904:	9009883a 	mov	r4,r18
81123908:	880b883a 	mov	r5,r17
8112390c:	112a2000 	call	8112a200 <__gedf2>
81123910:	00bfe90e 	bge	zero,r2,811238b8 <__reset+0xfb1038b8>
81123914:	017fe034 	movhi	r5,65408
81123918:	297fffc4 	addi	r5,r5,-1
8112391c:	8009883a 	mov	r4,r16
81123920:	1128f0c0 	call	81128f0c <__lesf2>
81123924:	103fe70e 	bge	r2,zero,811238c4 <__reset+0xfb1038c4>
81123928:	01fffc34 	movhi	r7,65520
8112392c:	39ffffc4 	addi	r7,r7,-1
81123930:	01bfffc4 	movi	r6,-1
81123934:	9009883a 	mov	r4,r18
81123938:	880b883a 	mov	r5,r17
8112393c:	112a2dc0 	call	8112a2dc <__ledf2>
81123940:	103fdd0e 	bge	r2,zero,811238b8 <__reset+0xfb1038b8>
81123944:	003fdf06 	br	811238c4 <__reset+0xfb1038c4>

81123948 <_strtoll_r>:
81123948:	00a04534 	movhi	r2,33044
8112394c:	defff304 	addi	sp,sp,-52
81123950:	109aeb04 	addi	r2,r2,27564
81123954:	de00012e 	bgeu	sp,et,8112395c <_strtoll_r+0x14>
81123958:	003b68fa 	trap	3
8112395c:	dc800515 	stw	r18,20(sp)
81123960:	14800017 	ldw	r18,0(r2)
81123964:	dd800915 	stw	r22,36(sp)
81123968:	dd400815 	stw	r21,32(sp)
8112396c:	dcc00615 	stw	r19,24(sp)
81123970:	d9000015 	stw	r4,0(sp)
81123974:	dfc00c15 	stw	ra,48(sp)
81123978:	df000b15 	stw	fp,44(sp)
8112397c:	ddc00a15 	stw	r23,40(sp)
81123980:	dd000715 	stw	r20,28(sp)
81123984:	dc400415 	stw	r17,16(sp)
81123988:	dc000315 	stw	r16,12(sp)
8112398c:	282d883a 	mov	r22,r5
81123990:	302b883a 	mov	r21,r6
81123994:	3827883a 	mov	r19,r7
81123998:	2809883a 	mov	r4,r5
8112399c:	24000003 	ldbu	r16,0(r4)
811239a0:	24400044 	addi	r17,r4,1
811239a4:	2007883a 	mov	r3,r4
811239a8:	9405883a 	add	r2,r18,r16
811239ac:	10800043 	ldbu	r2,1(r2)
811239b0:	8809883a 	mov	r4,r17
811239b4:	1080020c 	andi	r2,r2,8
811239b8:	103ff81e 	bne	r2,zero,8112399c <__reset+0xfb10399c>
811239bc:	00800b44 	movi	r2,45
811239c0:	80807826 	beq	r16,r2,81123ba4 <_strtoll_r+0x25c>
811239c4:	00800ac4 	movi	r2,43
811239c8:	80807a26 	beq	r16,r2,81123bb4 <_strtoll_r+0x26c>
811239cc:	0039883a 	mov	fp,zero
811239d0:	98004e26 	beq	r19,zero,81123b0c <_strtoll_r+0x1c4>
811239d4:	00800404 	movi	r2,16
811239d8:	98808226 	beq	r19,r2,81123be4 <_strtoll_r+0x29c>
811239dc:	982fd7fa 	srai	r23,r19,31
811239e0:	9829883a 	mov	r20,r19
811239e4:	e0004f26 	beq	fp,zero,81123b24 <_strtoll_r+0x1dc>
811239e8:	0017883a 	mov	r11,zero
811239ec:	02a00034 	movhi	r10,32768
811239f0:	5809883a 	mov	r4,r11
811239f4:	500b883a 	mov	r5,r10
811239f8:	a00d883a 	mov	r6,r20
811239fc:	b80f883a 	mov	r7,r23
81123a00:	da800215 	stw	r10,8(sp)
81123a04:	dac00115 	stw	r11,4(sp)
81123a08:	11286e40 	call	811286e4 <__umoddi3>
81123a0c:	dac00117 	ldw	r11,4(sp)
81123a10:	da800217 	ldw	r10,8(sp)
81123a14:	a00d883a 	mov	r6,r20
81123a18:	5809883a 	mov	r4,r11
81123a1c:	500b883a 	mov	r5,r10
81123a20:	b80f883a 	mov	r7,r23
81123a24:	d8800115 	stw	r2,4(sp)
81123a28:	11281640 	call	81128164 <__udivdi3>
81123a2c:	9409883a 	add	r4,r18,r16
81123a30:	21000043 	ldbu	r4,1(r4)
81123a34:	1019883a 	mov	r12,r2
81123a38:	880b883a 	mov	r5,r17
81123a3c:	2240010c 	andi	r9,r4,4
81123a40:	0015883a 	mov	r10,zero
81123a44:	000d883a 	mov	r6,zero
81123a48:	000f883a 	mov	r7,zero
81123a4c:	03400044 	movi	r13,1
81123a50:	02ffffc4 	movi	r11,-1
81123a54:	da000117 	ldw	r8,4(sp)
81123a58:	48000d26 	beq	r9,zero,81123a90 <_strtoll_r+0x148>
81123a5c:	843ff404 	addi	r16,r16,-48
81123a60:	84c0110e 	bge	r16,r19,81123aa8 <_strtoll_r+0x160>
81123a64:	52c00426 	beq	r10,r11,81123a78 <_strtoll_r+0x130>
81123a68:	19c00236 	bltu	r3,r7,81123a74 <_strtoll_r+0x12c>
81123a6c:	38c0311e 	bne	r7,r3,81123b34 <_strtoll_r+0x1ec>
81123a70:	6180302e 	bgeu	r12,r6,81123b34 <_strtoll_r+0x1ec>
81123a74:	02bfffc4 	movi	r10,-1
81123a78:	2c000003 	ldbu	r16,0(r5)
81123a7c:	29400044 	addi	r5,r5,1
81123a80:	9409883a 	add	r4,r18,r16
81123a84:	21000043 	ldbu	r4,1(r4)
81123a88:	2240010c 	andi	r9,r4,4
81123a8c:	483ff31e 	bne	r9,zero,81123a5c <__reset+0xfb103a5c>
81123a90:	210000cc 	andi	r4,r4,3
81123a94:	20000426 	beq	r4,zero,81123aa8 <_strtoll_r+0x160>
81123a98:	23403426 	beq	r4,r13,81123b6c <_strtoll_r+0x224>
81123a9c:	008015c4 	movi	r2,87
81123aa0:	80a1c83a 	sub	r16,r16,r2
81123aa4:	84ffef16 	blt	r16,r19,81123a64 <__reset+0xfb103a64>
81123aa8:	00bfffc4 	movi	r2,-1
81123aac:	50803426 	beq	r10,r2,81123b80 <_strtoll_r+0x238>
81123ab0:	e0000426 	beq	fp,zero,81123ac4 <_strtoll_r+0x17c>
81123ab4:	018dc83a 	sub	r6,zero,r6
81123ab8:	3004c03a 	cmpne	r2,r6,zero
81123abc:	01e1c83a 	sub	r16,zero,r7
81123ac0:	808fc83a 	sub	r7,r16,r2
81123ac4:	3005883a 	mov	r2,r6
81123ac8:	3807883a 	mov	r3,r7
81123acc:	a8000326 	beq	r21,zero,81123adc <_strtoll_r+0x194>
81123ad0:	5000321e 	bne	r10,zero,81123b9c <_strtoll_r+0x254>
81123ad4:	b00b883a 	mov	r5,r22
81123ad8:	a9400015 	stw	r5,0(r21)
81123adc:	dfc00c17 	ldw	ra,48(sp)
81123ae0:	df000b17 	ldw	fp,44(sp)
81123ae4:	ddc00a17 	ldw	r23,40(sp)
81123ae8:	dd800917 	ldw	r22,36(sp)
81123aec:	dd400817 	ldw	r21,32(sp)
81123af0:	dd000717 	ldw	r20,28(sp)
81123af4:	dcc00617 	ldw	r19,24(sp)
81123af8:	dc800517 	ldw	r18,20(sp)
81123afc:	dc400417 	ldw	r17,16(sp)
81123b00:	dc000317 	ldw	r16,12(sp)
81123b04:	dec00d04 	addi	sp,sp,52
81123b08:	f800283a 	ret
81123b0c:	00800c04 	movi	r2,48
81123b10:	80802c26 	beq	r16,r2,81123bc4 <_strtoll_r+0x27c>
81123b14:	05000284 	movi	r20,10
81123b18:	002f883a 	mov	r23,zero
81123b1c:	a027883a 	mov	r19,r20
81123b20:	e03fb11e 	bne	fp,zero,811239e8 <__reset+0xfb1039e8>
81123b24:	02a00034 	movhi	r10,32768
81123b28:	52bfffc4 	addi	r10,r10,-1
81123b2c:	02ffffc4 	movi	r11,-1
81123b30:	003faf06 	br	811239f0 <__reset+0xfb1039f0>
81123b34:	33000f26 	beq	r6,r12,81123b74 <_strtoll_r+0x22c>
81123b38:	b985383a 	mul	r2,r23,r6
81123b3c:	3d0f383a 	mul	r7,r7,r20
81123b40:	3508383a 	mulxuu	r4,r6,r20
81123b44:	350d383a 	mul	r6,r6,r20
81123b48:	8013d7fa 	srai	r9,r16,31
81123b4c:	388f883a 	add	r7,r7,r2
81123b50:	818d883a 	add	r6,r16,r6
81123b54:	390f883a 	add	r7,r7,r4
81123b58:	3421803a 	cmpltu	r16,r6,r16
81123b5c:	49cf883a 	add	r7,r9,r7
81123b60:	81cf883a 	add	r7,r16,r7
81123b64:	02800044 	movi	r10,1
81123b68:	003fc306 	br	81123a78 <__reset+0xfb103a78>
81123b6c:	00800dc4 	movi	r2,55
81123b70:	003fcb06 	br	81123aa0 <__reset+0xfb103aa0>
81123b74:	38fff01e 	bne	r7,r3,81123b38 <__reset+0xfb103b38>
81123b78:	443fbe16 	blt	r8,r16,81123a74 <__reset+0xfb103a74>
81123b7c:	003fee06 	br	81123b38 <__reset+0xfb103b38>
81123b80:	e0002426 	beq	fp,zero,81123c14 <_strtoll_r+0x2cc>
81123b84:	0005883a 	mov	r2,zero
81123b88:	00e00034 	movhi	r3,32768
81123b8c:	d9800017 	ldw	r6,0(sp)
81123b90:	01000884 	movi	r4,34
81123b94:	31000015 	stw	r4,0(r6)
81123b98:	a83fd026 	beq	r21,zero,81123adc <__reset+0xfb103adc>
81123b9c:	297fffc4 	addi	r5,r5,-1
81123ba0:	003fcd06 	br	81123ad8 <__reset+0xfb103ad8>
81123ba4:	1c400084 	addi	r17,r3,2
81123ba8:	1c000043 	ldbu	r16,1(r3)
81123bac:	07000044 	movi	fp,1
81123bb0:	003f8706 	br	811239d0 <__reset+0xfb1039d0>
81123bb4:	1c400084 	addi	r17,r3,2
81123bb8:	1c000043 	ldbu	r16,1(r3)
81123bbc:	0039883a 	mov	fp,zero
81123bc0:	003f8306 	br	811239d0 <__reset+0xfb1039d0>
81123bc4:	88800003 	ldbu	r2,0(r17)
81123bc8:	00c01604 	movi	r3,88
81123bcc:	108037cc 	andi	r2,r2,223
81123bd0:	10c00a26 	beq	r2,r3,81123bfc <_strtoll_r+0x2b4>
81123bd4:	05000204 	movi	r20,8
81123bd8:	002f883a 	mov	r23,zero
81123bdc:	a027883a 	mov	r19,r20
81123be0:	003f8006 	br	811239e4 <__reset+0xfb1039e4>
81123be4:	00800c04 	movi	r2,48
81123be8:	80800e1e 	bne	r16,r2,81123c24 <_strtoll_r+0x2dc>
81123bec:	88800003 	ldbu	r2,0(r17)
81123bf0:	00c01604 	movi	r3,88
81123bf4:	108037cc 	andi	r2,r2,223
81123bf8:	10c00a1e 	bne	r2,r3,81123c24 <_strtoll_r+0x2dc>
81123bfc:	05000404 	movi	r20,16
81123c00:	8c000043 	ldbu	r16,1(r17)
81123c04:	002f883a 	mov	r23,zero
81123c08:	8c400084 	addi	r17,r17,2
81123c0c:	a027883a 	mov	r19,r20
81123c10:	003f7406 	br	811239e4 <__reset+0xfb1039e4>
81123c14:	00e00034 	movhi	r3,32768
81123c18:	18ffffc4 	addi	r3,r3,-1
81123c1c:	5005883a 	mov	r2,r10
81123c20:	003fda06 	br	81123b8c <__reset+0xfb103b8c>
81123c24:	9829883a 	mov	r20,r19
81123c28:	002f883a 	mov	r23,zero
81123c2c:	003f6d06 	br	811239e4 <__reset+0xfb1039e4>

81123c30 <_strtoul_r>:
81123c30:	00a04534 	movhi	r2,33044
81123c34:	defff604 	addi	sp,sp,-40
81123c38:	109aeb04 	addi	r2,r2,27564
81123c3c:	de00012e 	bgeu	sp,et,81123c44 <_strtoul_r+0x14>
81123c40:	003b68fa 	trap	3
81123c44:	dc800315 	stw	r18,12(sp)
81123c48:	14800017 	ldw	r18,0(r2)
81123c4c:	dd400615 	stw	r21,24(sp)
81123c50:	dd000515 	stw	r20,20(sp)
81123c54:	dcc00415 	stw	r19,16(sp)
81123c58:	2029883a 	mov	r20,r4
81123c5c:	dfc00915 	stw	ra,36(sp)
81123c60:	ddc00815 	stw	r23,32(sp)
81123c64:	dd800715 	stw	r22,28(sp)
81123c68:	dc400215 	stw	r17,8(sp)
81123c6c:	dc000115 	stw	r16,4(sp)
81123c70:	2827883a 	mov	r19,r5
81123c74:	382b883a 	mov	r21,r7
81123c78:	2809883a 	mov	r4,r5
81123c7c:	24000003 	ldbu	r16,0(r4)
81123c80:	24400044 	addi	r17,r4,1
81123c84:	2007883a 	mov	r3,r4
81123c88:	9405883a 	add	r2,r18,r16
81123c8c:	10800043 	ldbu	r2,1(r2)
81123c90:	8809883a 	mov	r4,r17
81123c94:	1080020c 	andi	r2,r2,8
81123c98:	103ff81e 	bne	r2,zero,81123c7c <__reset+0xfb103c7c>
81123c9c:	00800b44 	movi	r2,45
81123ca0:	80805326 	beq	r16,r2,81123df0 <_strtoul_r+0x1c0>
81123ca4:	00800ac4 	movi	r2,43
81123ca8:	80805526 	beq	r16,r2,81123e00 <_strtoul_r+0x1d0>
81123cac:	002f883a 	mov	r23,zero
81123cb0:	a8000f26 	beq	r21,zero,81123cf0 <_strtoul_r+0xc0>
81123cb4:	00800404 	movi	r2,16
81123cb8:	a8805f26 	beq	r21,r2,81123e38 <_strtoul_r+0x208>
81123cbc:	013fffc4 	movi	r4,-1
81123cc0:	a80b883a 	mov	r5,r21
81123cc4:	d9800015 	stw	r6,0(sp)
81123cc8:	1128d1c0 	call	81128d1c <__udivsi3>
81123ccc:	a80b883a 	mov	r5,r21
81123cd0:	013fffc4 	movi	r4,-1
81123cd4:	102d883a 	mov	r22,r2
81123cd8:	1128d800 	call	81128d80 <__umodsi3>
81123cdc:	d9800017 	ldw	r6,0(sp)
81123ce0:	1019883a 	mov	r12,r2
81123ce4:	a817883a 	mov	r11,r21
81123ce8:	b00f883a 	mov	r7,r22
81123cec:	00000706 	br	81123d0c <_strtoul_r+0xdc>
81123cf0:	00800c04 	movi	r2,48
81123cf4:	80804626 	beq	r16,r2,81123e10 <_strtoul_r+0x1e0>
81123cf8:	05400284 	movi	r21,10
81123cfc:	01c666b4 	movhi	r7,6554
81123d00:	03000144 	movi	r12,5
81123d04:	39e66644 	addi	r7,r7,-26215
81123d08:	a817883a 	mov	r11,r21
81123d0c:	9407883a 	add	r3,r18,r16
81123d10:	18c00043 	ldbu	r3,1(r3)
81123d14:	8809883a 	mov	r4,r17
81123d18:	0011883a 	mov	r8,zero
81123d1c:	1940010c 	andi	r5,r3,4
81123d20:	0005883a 	mov	r2,zero
81123d24:	02800044 	movi	r10,1
81123d28:	027fffc4 	movi	r9,-1
81123d2c:	28000e26 	beq	r5,zero,81123d68 <_strtoul_r+0x138>
81123d30:	843ff404 	addi	r16,r16,-48
81123d34:	8540120e 	bge	r16,r21,81123d80 <_strtoul_r+0x150>
81123d38:	42400526 	beq	r8,r9,81123d50 <_strtoul_r+0x120>
81123d3c:	38802236 	bltu	r7,r2,81123dc8 <_strtoul_r+0x198>
81123d40:	11c02026 	beq	r2,r7,81123dc4 <_strtoul_r+0x194>
81123d44:	12c5383a 	mul	r2,r2,r11
81123d48:	02000044 	movi	r8,1
81123d4c:	8085883a 	add	r2,r16,r2
81123d50:	24000003 	ldbu	r16,0(r4)
81123d54:	21000044 	addi	r4,r4,1
81123d58:	9407883a 	add	r3,r18,r16
81123d5c:	18c00043 	ldbu	r3,1(r3)
81123d60:	1940010c 	andi	r5,r3,4
81123d64:	283ff21e 	bne	r5,zero,81123d30 <__reset+0xfb103d30>
81123d68:	18c000cc 	andi	r3,r3,3
81123d6c:	18000426 	beq	r3,zero,81123d80 <_strtoul_r+0x150>
81123d70:	1a801726 	beq	r3,r10,81123dd0 <_strtoul_r+0x1a0>
81123d74:	00c015c4 	movi	r3,87
81123d78:	80e1c83a 	sub	r16,r16,r3
81123d7c:	857fee16 	blt	r16,r21,81123d38 <__reset+0xfb103d38>
81123d80:	40001516 	blt	r8,zero,81123dd8 <_strtoul_r+0x1a8>
81123d84:	b8000126 	beq	r23,zero,81123d8c <_strtoul_r+0x15c>
81123d88:	0085c83a 	sub	r2,zero,r2
81123d8c:	30000226 	beq	r6,zero,81123d98 <_strtoul_r+0x168>
81123d90:	4000151e 	bne	r8,zero,81123de8 <_strtoul_r+0x1b8>
81123d94:	34c00015 	stw	r19,0(r6)
81123d98:	dfc00917 	ldw	ra,36(sp)
81123d9c:	ddc00817 	ldw	r23,32(sp)
81123da0:	dd800717 	ldw	r22,28(sp)
81123da4:	dd400617 	ldw	r21,24(sp)
81123da8:	dd000517 	ldw	r20,20(sp)
81123dac:	dcc00417 	ldw	r19,16(sp)
81123db0:	dc800317 	ldw	r18,12(sp)
81123db4:	dc400217 	ldw	r17,8(sp)
81123db8:	dc000117 	ldw	r16,4(sp)
81123dbc:	dec00a04 	addi	sp,sp,40
81123dc0:	f800283a 	ret
81123dc4:	643fdf0e 	bge	r12,r16,81123d44 <__reset+0xfb103d44>
81123dc8:	023fffc4 	movi	r8,-1
81123dcc:	003fe006 	br	81123d50 <__reset+0xfb103d50>
81123dd0:	00c00dc4 	movi	r3,55
81123dd4:	003fe806 	br	81123d78 <__reset+0xfb103d78>
81123dd8:	00800884 	movi	r2,34
81123ddc:	a0800015 	stw	r2,0(r20)
81123de0:	00bfffc4 	movi	r2,-1
81123de4:	303fec26 	beq	r6,zero,81123d98 <__reset+0xfb103d98>
81123de8:	24ffffc4 	addi	r19,r4,-1
81123dec:	003fe906 	br	81123d94 <__reset+0xfb103d94>
81123df0:	1c400084 	addi	r17,r3,2
81123df4:	1c000043 	ldbu	r16,1(r3)
81123df8:	05c00044 	movi	r23,1
81123dfc:	003fac06 	br	81123cb0 <__reset+0xfb103cb0>
81123e00:	1c400084 	addi	r17,r3,2
81123e04:	1c000043 	ldbu	r16,1(r3)
81123e08:	002f883a 	mov	r23,zero
81123e0c:	003fa806 	br	81123cb0 <__reset+0xfb103cb0>
81123e10:	88800003 	ldbu	r2,0(r17)
81123e14:	00c01604 	movi	r3,88
81123e18:	108037cc 	andi	r2,r2,223
81123e1c:	10c00c26 	beq	r2,r3,81123e50 <_strtoul_r+0x220>
81123e20:	05400204 	movi	r21,8
81123e24:	01c80034 	movhi	r7,8192
81123e28:	030001c4 	movi	r12,7
81123e2c:	39ffffc4 	addi	r7,r7,-1
81123e30:	a817883a 	mov	r11,r21
81123e34:	003fb506 	br	81123d0c <__reset+0xfb103d0c>
81123e38:	00800c04 	movi	r2,48
81123e3c:	80800c1e 	bne	r16,r2,81123e70 <_strtoul_r+0x240>
81123e40:	88800003 	ldbu	r2,0(r17)
81123e44:	00c01604 	movi	r3,88
81123e48:	108037cc 	andi	r2,r2,223
81123e4c:	10c0081e 	bne	r2,r3,81123e70 <_strtoul_r+0x240>
81123e50:	02c00404 	movi	r11,16
81123e54:	05840034 	movhi	r22,4096
81123e58:	8c000043 	ldbu	r16,1(r17)
81123e5c:	030003c4 	movi	r12,15
81123e60:	8c400084 	addi	r17,r17,2
81123e64:	b5bfffc4 	addi	r22,r22,-1
81123e68:	582b883a 	mov	r21,r11
81123e6c:	003f9e06 	br	81123ce8 <__reset+0xfb103ce8>
81123e70:	01c40034 	movhi	r7,4096
81123e74:	030003c4 	movi	r12,15
81123e78:	39ffffc4 	addi	r7,r7,-1
81123e7c:	a817883a 	mov	r11,r21
81123e80:	003fa206 	br	81123d0c <__reset+0xfb103d0c>

81123e84 <strtoul>:
81123e84:	00a04534 	movhi	r2,33044
81123e88:	109aed04 	addi	r2,r2,27572
81123e8c:	300f883a 	mov	r7,r6
81123e90:	280d883a 	mov	r6,r5
81123e94:	200b883a 	mov	r5,r4
81123e98:	11000017 	ldw	r4,0(r2)
81123e9c:	1123c301 	jmpi	81123c30 <_strtoul_r>

81123ea0 <_strtoull_r>:
81123ea0:	00a04534 	movhi	r2,33044
81123ea4:	defff404 	addi	sp,sp,-48
81123ea8:	109aeb04 	addi	r2,r2,27564
81123eac:	de00012e 	bgeu	sp,et,81123eb4 <_strtoull_r+0x14>
81123eb0:	003b68fa 	trap	3
81123eb4:	dc400315 	stw	r17,12(sp)
81123eb8:	14400017 	ldw	r17,0(r2)
81123ebc:	dd400715 	stw	r21,28(sp)
81123ec0:	dd000615 	stw	r20,24(sp)
81123ec4:	dcc00515 	stw	r19,20(sp)
81123ec8:	dc800415 	stw	r18,16(sp)
81123ecc:	dfc00b15 	stw	ra,44(sp)
81123ed0:	df000a15 	stw	fp,40(sp)
81123ed4:	ddc00915 	stw	r23,36(sp)
81123ed8:	dd800815 	stw	r22,32(sp)
81123edc:	dc000215 	stw	r16,8(sp)
81123ee0:	2827883a 	mov	r19,r5
81123ee4:	202b883a 	mov	r21,r4
81123ee8:	3029883a 	mov	r20,r6
81123eec:	3825883a 	mov	r18,r7
81123ef0:	2807883a 	mov	r3,r5
81123ef4:	1c000003 	ldbu	r16,0(r3)
81123ef8:	1f000044 	addi	fp,r3,1
81123efc:	1809883a 	mov	r4,r3
81123f00:	8c05883a 	add	r2,r17,r16
81123f04:	10800043 	ldbu	r2,1(r2)
81123f08:	e007883a 	mov	r3,fp
81123f0c:	1080020c 	andi	r2,r2,8
81123f10:	103ff81e 	bne	r2,zero,81123ef4 <__reset+0xfb103ef4>
81123f14:	00800b44 	movi	r2,45
81123f18:	80806e26 	beq	r16,r2,811240d4 <_strtoull_r+0x234>
81123f1c:	00800ac4 	movi	r2,43
81123f20:	80807026 	beq	r16,r2,811240e4 <_strtoull_r+0x244>
81123f24:	002f883a 	mov	r23,zero
81123f28:	90001426 	beq	r18,zero,81123f7c <_strtoull_r+0xdc>
81123f2c:	00800404 	movi	r2,16
81123f30:	90807c26 	beq	r18,r2,81124124 <_strtoull_r+0x284>
81123f34:	902dd7fa 	srai	r22,r18,31
81123f38:	013fffc4 	movi	r4,-1
81123f3c:	200b883a 	mov	r5,r4
81123f40:	900d883a 	mov	r6,r18
81123f44:	b00f883a 	mov	r7,r22
81123f48:	11281640 	call	81128164 <__udivdi3>
81123f4c:	013fffc4 	movi	r4,-1
81123f50:	900d883a 	mov	r6,r18
81123f54:	b00f883a 	mov	r7,r22
81123f58:	200b883a 	mov	r5,r4
81123f5c:	d8c00115 	stw	r3,4(sp)
81123f60:	d8800015 	stw	r2,0(sp)
81123f64:	11286e40 	call	811286e4 <__umoddi3>
81123f68:	101b883a 	mov	r13,r2
81123f6c:	9015883a 	mov	r10,r18
81123f70:	dac00017 	ldw	r11,0(sp)
81123f74:	da000117 	ldw	r8,4(sp)
81123f78:	00000a06 	br	81123fa4 <_strtoull_r+0x104>
81123f7c:	00800c04 	movi	r2,48
81123f80:	80805c26 	beq	r16,r2,811240f4 <_strtoull_r+0x254>
81123f84:	02800284 	movi	r10,10
81123f88:	02e666b4 	movhi	r11,39322
81123f8c:	020666b4 	movhi	r8,6554
81123f90:	03400144 	movi	r13,5
81123f94:	5ae66644 	addi	r11,r11,-26215
81123f98:	42266644 	addi	r8,r8,-26215
81123f9c:	002d883a 	mov	r22,zero
81123fa0:	5025883a 	mov	r18,r10
81123fa4:	8c0b883a 	add	r5,r17,r16
81123fa8:	29400043 	ldbu	r5,1(r5)
81123fac:	e009883a 	mov	r4,fp
81123fb0:	000f883a 	mov	r7,zero
81123fb4:	2980010c 	andi	r6,r5,4
81123fb8:	0005883a 	mov	r2,zero
81123fbc:	0007883a 	mov	r3,zero
81123fc0:	03000044 	movi	r12,1
81123fc4:	027fffc4 	movi	r9,-1
81123fc8:	30000d26 	beq	r6,zero,81124000 <_strtoull_r+0x160>
81123fcc:	843ff404 	addi	r16,r16,-48
81123fd0:	8480110e 	bge	r16,r18,81124018 <_strtoull_r+0x178>
81123fd4:	3a400426 	beq	r7,r9,81123fe8 <_strtoull_r+0x148>
81123fd8:	40c00236 	bltu	r8,r3,81123fe4 <_strtoull_r+0x144>
81123fdc:	1a00231e 	bne	r3,r8,8112406c <_strtoull_r+0x1cc>
81123fe0:	5880222e 	bgeu	r11,r2,8112406c <_strtoull_r+0x1cc>
81123fe4:	01ffffc4 	movi	r7,-1
81123fe8:	24000003 	ldbu	r16,0(r4)
81123fec:	21000044 	addi	r4,r4,1
81123ff0:	8c0b883a 	add	r5,r17,r16
81123ff4:	29400043 	ldbu	r5,1(r5)
81123ff8:	2980010c 	andi	r6,r5,4
81123ffc:	303ff31e 	bne	r6,zero,81123fcc <__reset+0xfb103fcc>
81124000:	294000cc 	andi	r5,r5,3
81124004:	28000426 	beq	r5,zero,81124018 <_strtoull_r+0x178>
81124008:	2b002626 	beq	r5,r12,811240a4 <_strtoull_r+0x204>
8112400c:	014015c4 	movi	r5,87
81124010:	8161c83a 	sub	r16,r16,r5
81124014:	84bfef16 	blt	r16,r18,81123fd4 <__reset+0xfb103fd4>
81124018:	38002716 	blt	r7,zero,811240b8 <_strtoull_r+0x218>
8112401c:	b8000426 	beq	r23,zero,81124030 <_strtoull_r+0x190>
81124020:	0085c83a 	sub	r2,zero,r2
81124024:	100ac03a 	cmpne	r5,r2,zero
81124028:	00e1c83a 	sub	r16,zero,r3
8112402c:	8147c83a 	sub	r3,r16,r5
81124030:	a0000226 	beq	r20,zero,8112403c <_strtoull_r+0x19c>
81124034:	3800251e 	bne	r7,zero,811240cc <_strtoull_r+0x22c>
81124038:	a4c00015 	stw	r19,0(r20)
8112403c:	dfc00b17 	ldw	ra,44(sp)
81124040:	df000a17 	ldw	fp,40(sp)
81124044:	ddc00917 	ldw	r23,36(sp)
81124048:	dd800817 	ldw	r22,32(sp)
8112404c:	dd400717 	ldw	r21,28(sp)
81124050:	dd000617 	ldw	r20,24(sp)
81124054:	dcc00517 	ldw	r19,20(sp)
81124058:	dc800417 	ldw	r18,16(sp)
8112405c:	dc400317 	ldw	r17,12(sp)
81124060:	dc000217 	ldw	r16,8(sp)
81124064:	dec00c04 	addi	sp,sp,48
81124068:	f800283a 	ret
8112406c:	12c00f26 	beq	r2,r11,811240ac <_strtoull_r+0x20c>
81124070:	b08d383a 	mul	r6,r22,r2
81124074:	1a87383a 	mul	r3,r3,r10
81124078:	128a383a 	mulxuu	r5,r2,r10
8112407c:	1285383a 	mul	r2,r2,r10
81124080:	800fd7fa 	srai	r7,r16,31
81124084:	1987883a 	add	r3,r3,r6
81124088:	8085883a 	add	r2,r16,r2
8112408c:	1947883a 	add	r3,r3,r5
81124090:	38c7883a 	add	r3,r7,r3
81124094:	1421803a 	cmpltu	r16,r2,r16
81124098:	80c7883a 	add	r3,r16,r3
8112409c:	01c00044 	movi	r7,1
811240a0:	003fd106 	br	81123fe8 <__reset+0xfb103fe8>
811240a4:	01400dc4 	movi	r5,55
811240a8:	003fd906 	br	81124010 <__reset+0xfb104010>
811240ac:	1a3ff01e 	bne	r3,r8,81124070 <__reset+0xfb104070>
811240b0:	6c3fcc16 	blt	r13,r16,81123fe4 <__reset+0xfb103fe4>
811240b4:	003fee06 	br	81124070 <__reset+0xfb104070>
811240b8:	00800884 	movi	r2,34
811240bc:	a8800015 	stw	r2,0(r21)
811240c0:	00bfffc4 	movi	r2,-1
811240c4:	1007883a 	mov	r3,r2
811240c8:	a03fdc26 	beq	r20,zero,8112403c <__reset+0xfb10403c>
811240cc:	24ffffc4 	addi	r19,r4,-1
811240d0:	003fd906 	br	81124038 <__reset+0xfb104038>
811240d4:	27000084 	addi	fp,r4,2
811240d8:	24000043 	ldbu	r16,1(r4)
811240dc:	05c00044 	movi	r23,1
811240e0:	003f9106 	br	81123f28 <__reset+0xfb103f28>
811240e4:	27000084 	addi	fp,r4,2
811240e8:	24000043 	ldbu	r16,1(r4)
811240ec:	002f883a 	mov	r23,zero
811240f0:	003f8d06 	br	81123f28 <__reset+0xfb103f28>
811240f4:	e0800003 	ldbu	r2,0(fp)
811240f8:	00c01604 	movi	r3,88
811240fc:	108037cc 	andi	r2,r2,223
81124100:	10c00e26 	beq	r2,r3,8112413c <_strtoull_r+0x29c>
81124104:	02800204 	movi	r10,8
81124108:	02ffffc4 	movi	r11,-1
8112410c:	02080034 	movhi	r8,8192
81124110:	034001c4 	movi	r13,7
81124114:	42d1883a 	add	r8,r8,r11
81124118:	002d883a 	mov	r22,zero
8112411c:	5025883a 	mov	r18,r10
81124120:	003fa006 	br	81123fa4 <__reset+0xfb103fa4>
81124124:	00800c04 	movi	r2,48
81124128:	80800e1e 	bne	r16,r2,81124164 <_strtoull_r+0x2c4>
8112412c:	e0800003 	ldbu	r2,0(fp)
81124130:	00c01604 	movi	r3,88
81124134:	108037cc 	andi	r2,r2,223
81124138:	10c00a1e 	bne	r2,r3,81124164 <_strtoull_r+0x2c4>
8112413c:	02800404 	movi	r10,16
81124140:	02ffffc4 	movi	r11,-1
81124144:	02040034 	movhi	r8,4096
81124148:	e4000043 	ldbu	r16,1(fp)
8112414c:	034003c4 	movi	r13,15
81124150:	e7000084 	addi	fp,fp,2
81124154:	42d1883a 	add	r8,r8,r11
81124158:	002d883a 	mov	r22,zero
8112415c:	5025883a 	mov	r18,r10
81124160:	003f9006 	br	81123fa4 <__reset+0xfb103fa4>
81124164:	02ffffc4 	movi	r11,-1
81124168:	02040034 	movhi	r8,4096
8112416c:	034003c4 	movi	r13,15
81124170:	42d1883a 	add	r8,r8,r11
81124174:	9015883a 	mov	r10,r18
81124178:	002d883a 	mov	r22,zero
8112417c:	003f8906 	br	81123fa4 <__reset+0xfb103fa4>

81124180 <__ssprint_r>:
81124180:	defff604 	addi	sp,sp,-40
81124184:	de00012e 	bgeu	sp,et,8112418c <__ssprint_r+0xc>
81124188:	003b68fa 	trap	3
8112418c:	30800217 	ldw	r2,8(r6)
81124190:	dc800215 	stw	r18,8(sp)
81124194:	dfc00915 	stw	ra,36(sp)
81124198:	df000815 	stw	fp,32(sp)
8112419c:	ddc00715 	stw	r23,28(sp)
811241a0:	dd800615 	stw	r22,24(sp)
811241a4:	dd400515 	stw	r21,20(sp)
811241a8:	dd000415 	stw	r20,16(sp)
811241ac:	dcc00315 	stw	r19,12(sp)
811241b0:	dc400115 	stw	r17,4(sp)
811241b4:	dc000015 	stw	r16,0(sp)
811241b8:	3025883a 	mov	r18,r6
811241bc:	10005826 	beq	r2,zero,81124320 <__ssprint_r+0x1a0>
811241c0:	2027883a 	mov	r19,r4
811241c4:	35c00017 	ldw	r23,0(r6)
811241c8:	29000017 	ldw	r4,0(r5)
811241cc:	28800217 	ldw	r2,8(r5)
811241d0:	2823883a 	mov	r17,r5
811241d4:	0039883a 	mov	fp,zero
811241d8:	0021883a 	mov	r16,zero
811241dc:	80003926 	beq	r16,zero,811242c4 <__ssprint_r+0x144>
811241e0:	102b883a 	mov	r21,r2
811241e4:	102d883a 	mov	r22,r2
811241e8:	80803a36 	bltu	r16,r2,811242d4 <__ssprint_r+0x154>
811241ec:	88c0030b 	ldhu	r3,12(r17)
811241f0:	1881200c 	andi	r2,r3,1152
811241f4:	10002626 	beq	r2,zero,81124290 <__ssprint_r+0x110>
811241f8:	88800517 	ldw	r2,20(r17)
811241fc:	89400417 	ldw	r5,16(r17)
81124200:	81800044 	addi	r6,r16,1
81124204:	108f883a 	add	r7,r2,r2
81124208:	3885883a 	add	r2,r7,r2
8112420c:	100ed7fa 	srli	r7,r2,31
81124210:	216dc83a 	sub	r22,r4,r5
81124214:	3589883a 	add	r4,r6,r22
81124218:	3885883a 	add	r2,r7,r2
8112421c:	102bd07a 	srai	r21,r2,1
81124220:	a80d883a 	mov	r6,r21
81124224:	a900022e 	bgeu	r21,r4,81124230 <__ssprint_r+0xb0>
81124228:	202b883a 	mov	r21,r4
8112422c:	200d883a 	mov	r6,r4
81124230:	18c1000c 	andi	r3,r3,1024
81124234:	18002a26 	beq	r3,zero,811242e0 <__ssprint_r+0x160>
81124238:	300b883a 	mov	r5,r6
8112423c:	9809883a 	mov	r4,r19
81124240:	1115f200 	call	81115f20 <_malloc_r>
81124244:	1029883a 	mov	r20,r2
81124248:	10002c26 	beq	r2,zero,811242fc <__ssprint_r+0x17c>
8112424c:	89400417 	ldw	r5,16(r17)
81124250:	b00d883a 	mov	r6,r22
81124254:	1009883a 	mov	r4,r2
81124258:	11167340 	call	81116734 <memcpy>
8112425c:	8880030b 	ldhu	r2,12(r17)
81124260:	00fedfc4 	movi	r3,-1153
81124264:	10c4703a 	and	r2,r2,r3
81124268:	10802014 	ori	r2,r2,128
8112426c:	8880030d 	sth	r2,12(r17)
81124270:	a589883a 	add	r4,r20,r22
81124274:	adadc83a 	sub	r22,r21,r22
81124278:	8d400515 	stw	r21,20(r17)
8112427c:	8d800215 	stw	r22,8(r17)
81124280:	8d000415 	stw	r20,16(r17)
81124284:	89000015 	stw	r4,0(r17)
81124288:	802b883a 	mov	r21,r16
8112428c:	802d883a 	mov	r22,r16
81124290:	b00d883a 	mov	r6,r22
81124294:	e00b883a 	mov	r5,fp
81124298:	11208080 	call	81120808 <memmove>
8112429c:	88800217 	ldw	r2,8(r17)
811242a0:	89000017 	ldw	r4,0(r17)
811242a4:	90c00217 	ldw	r3,8(r18)
811242a8:	1545c83a 	sub	r2,r2,r21
811242ac:	2589883a 	add	r4,r4,r22
811242b0:	88800215 	stw	r2,8(r17)
811242b4:	89000015 	stw	r4,0(r17)
811242b8:	1c21c83a 	sub	r16,r3,r16
811242bc:	94000215 	stw	r16,8(r18)
811242c0:	80001726 	beq	r16,zero,81124320 <__ssprint_r+0x1a0>
811242c4:	bf000017 	ldw	fp,0(r23)
811242c8:	bc000117 	ldw	r16,4(r23)
811242cc:	bdc00204 	addi	r23,r23,8
811242d0:	003fc206 	br	811241dc <__reset+0xfb1041dc>
811242d4:	802b883a 	mov	r21,r16
811242d8:	802d883a 	mov	r22,r16
811242dc:	003fec06 	br	81124290 <__reset+0xfb104290>
811242e0:	9809883a 	mov	r4,r19
811242e4:	1121a280 	call	81121a28 <_realloc_r>
811242e8:	1029883a 	mov	r20,r2
811242ec:	103fe01e 	bne	r2,zero,81124270 <__reset+0xfb104270>
811242f0:	89400417 	ldw	r5,16(r17)
811242f4:	9809883a 	mov	r4,r19
811242f8:	111f9940 	call	8111f994 <_free_r>
811242fc:	88c0030b 	ldhu	r3,12(r17)
81124300:	00800304 	movi	r2,12
81124304:	98800015 	stw	r2,0(r19)
81124308:	18c01014 	ori	r3,r3,64
8112430c:	88c0030d 	sth	r3,12(r17)
81124310:	00bfffc4 	movi	r2,-1
81124314:	90000215 	stw	zero,8(r18)
81124318:	90000115 	stw	zero,4(r18)
8112431c:	00000206 	br	81124328 <__ssprint_r+0x1a8>
81124320:	90000115 	stw	zero,4(r18)
81124324:	0005883a 	mov	r2,zero
81124328:	dfc00917 	ldw	ra,36(sp)
8112432c:	df000817 	ldw	fp,32(sp)
81124330:	ddc00717 	ldw	r23,28(sp)
81124334:	dd800617 	ldw	r22,24(sp)
81124338:	dd400517 	ldw	r21,20(sp)
8112433c:	dd000417 	ldw	r20,16(sp)
81124340:	dcc00317 	ldw	r19,12(sp)
81124344:	dc800217 	ldw	r18,8(sp)
81124348:	dc400117 	ldw	r17,4(sp)
8112434c:	dc000017 	ldw	r16,0(sp)
81124350:	dec00a04 	addi	sp,sp,40
81124354:	f800283a 	ret

81124358 <___svfiprintf_internal_r>:
81124358:	deffc804 	addi	sp,sp,-224
8112435c:	de00012e 	bgeu	sp,et,81124364 <___svfiprintf_internal_r+0xc>
81124360:	003b68fa 	trap	3
81124364:	2880030b 	ldhu	r2,12(r5)
81124368:	dcc03115 	stw	r19,196(sp)
8112436c:	dfc03715 	stw	ra,220(sp)
81124370:	df003615 	stw	fp,216(sp)
81124374:	ddc03515 	stw	r23,212(sp)
81124378:	dd803415 	stw	r22,208(sp)
8112437c:	dd403315 	stw	r21,204(sp)
81124380:	dd003215 	stw	r20,200(sp)
81124384:	dc803015 	stw	r18,192(sp)
81124388:	dc402f15 	stw	r17,188(sp)
8112438c:	dc002e15 	stw	r16,184(sp)
81124390:	d9402715 	stw	r5,156(sp)
81124394:	d9002a15 	stw	r4,168(sp)
81124398:	1080200c 	andi	r2,r2,128
8112439c:	d9c02315 	stw	r7,140(sp)
811243a0:	3027883a 	mov	r19,r6
811243a4:	10000226 	beq	r2,zero,811243b0 <___svfiprintf_internal_r+0x58>
811243a8:	28800417 	ldw	r2,16(r5)
811243ac:	10041d26 	beq	r2,zero,81125424 <___svfiprintf_internal_r+0x10cc>
811243b0:	dac01a04 	addi	r11,sp,104
811243b4:	dac01e15 	stw	r11,120(sp)
811243b8:	d8801e17 	ldw	r2,120(sp)
811243bc:	dac019c4 	addi	r11,sp,103
811243c0:	dd402a17 	ldw	r21,168(sp)
811243c4:	ddc02717 	ldw	r23,156(sp)
811243c8:	05a04534 	movhi	r22,33044
811243cc:	05204534 	movhi	r20,33044
811243d0:	dac01f15 	stw	r11,124(sp)
811243d4:	12d7c83a 	sub	r11,r2,r11
811243d8:	b591ac04 	addi	r22,r22,18096
811243dc:	a511a804 	addi	r20,r20,18080
811243e0:	dec01a15 	stw	sp,104(sp)
811243e4:	d8001c15 	stw	zero,112(sp)
811243e8:	d8001b15 	stw	zero,108(sp)
811243ec:	d811883a 	mov	r8,sp
811243f0:	d8002915 	stw	zero,164(sp)
811243f4:	d8002515 	stw	zero,148(sp)
811243f8:	dac02b15 	stw	r11,172(sp)
811243fc:	98800007 	ldb	r2,0(r19)
81124400:	1002dd26 	beq	r2,zero,81124f78 <___svfiprintf_internal_r+0xc20>
81124404:	00c00944 	movi	r3,37
81124408:	9823883a 	mov	r17,r19
8112440c:	10c0021e 	bne	r2,r3,81124418 <___svfiprintf_internal_r+0xc0>
81124410:	00001406 	br	81124464 <___svfiprintf_internal_r+0x10c>
81124414:	10c00326 	beq	r2,r3,81124424 <___svfiprintf_internal_r+0xcc>
81124418:	8c400044 	addi	r17,r17,1
8112441c:	88800007 	ldb	r2,0(r17)
81124420:	103ffc1e 	bne	r2,zero,81124414 <__reset+0xfb104414>
81124424:	8ce1c83a 	sub	r16,r17,r19
81124428:	80000e26 	beq	r16,zero,81124464 <___svfiprintf_internal_r+0x10c>
8112442c:	d8c01c17 	ldw	r3,112(sp)
81124430:	d8801b17 	ldw	r2,108(sp)
81124434:	44c00015 	stw	r19,0(r8)
81124438:	1c07883a 	add	r3,r3,r16
8112443c:	10800044 	addi	r2,r2,1
81124440:	d8c01c15 	stw	r3,112(sp)
81124444:	44000115 	stw	r16,4(r8)
81124448:	d8801b15 	stw	r2,108(sp)
8112444c:	00c001c4 	movi	r3,7
81124450:	18831e16 	blt	r3,r2,811250cc <___svfiprintf_internal_r+0xd74>
81124454:	42000204 	addi	r8,r8,8
81124458:	dac02517 	ldw	r11,148(sp)
8112445c:	5c17883a 	add	r11,r11,r16
81124460:	dac02515 	stw	r11,148(sp)
81124464:	88800007 	ldb	r2,0(r17)
81124468:	1002c526 	beq	r2,zero,81124f80 <___svfiprintf_internal_r+0xc28>
8112446c:	88c00047 	ldb	r3,1(r17)
81124470:	8cc00044 	addi	r19,r17,1
81124474:	d8001d85 	stb	zero,118(sp)
81124478:	0009883a 	mov	r4,zero
8112447c:	000f883a 	mov	r7,zero
81124480:	043fffc4 	movi	r16,-1
81124484:	d8002415 	stw	zero,144(sp)
81124488:	0025883a 	mov	r18,zero
8112448c:	01401604 	movi	r5,88
81124490:	01800244 	movi	r6,9
81124494:	02800a84 	movi	r10,42
81124498:	02401b04 	movi	r9,108
8112449c:	9cc00044 	addi	r19,r19,1
811244a0:	18bff804 	addi	r2,r3,-32
811244a4:	2881dd36 	bltu	r5,r2,81124c1c <___svfiprintf_internal_r+0x8c4>
811244a8:	100490ba 	slli	r2,r2,2
811244ac:	02e044b4 	movhi	r11,33042
811244b0:	5ad13004 	addi	r11,r11,17600
811244b4:	12c5883a 	add	r2,r2,r11
811244b8:	10800017 	ldw	r2,0(r2)
811244bc:	1000683a 	jmp	r2
811244c0:	811246bc 	xorhi	r4,r16,18714
811244c4:	81124c1c 	xori	r4,r16,18736
811244c8:	81124c1c 	xori	r4,r16,18736
811244cc:	811246b0 	cmpltui	r4,r16,18714
811244d0:	81124c1c 	xori	r4,r16,18736
811244d4:	81124c1c 	xori	r4,r16,18736
811244d8:	81124c1c 	xori	r4,r16,18736
811244dc:	81124c1c 	xori	r4,r16,18736
811244e0:	81124c1c 	xori	r4,r16,18736
811244e4:	81124c1c 	xori	r4,r16,18736
811244e8:	81124624 	muli	r4,r16,18712
811244ec:	81124800 	call	88112480 <__reset+0x20f2480>
811244f0:	81124c1c 	xori	r4,r16,18736
811244f4:	81124650 	cmplti	r4,r16,18713
811244f8:	81124c50 	cmplti	r4,r16,18737
811244fc:	81124c1c 	xori	r4,r16,18736
81124500:	81124c44 	addi	r4,r16,18737
81124504:	81124be4 	muli	r4,r16,18735
81124508:	81124be4 	muli	r4,r16,18735
8112450c:	81124be4 	muli	r4,r16,18735
81124510:	81124be4 	muli	r4,r16,18735
81124514:	81124be4 	muli	r4,r16,18735
81124518:	81124be4 	muli	r4,r16,18735
8112451c:	81124be4 	muli	r4,r16,18735
81124520:	81124be4 	muli	r4,r16,18735
81124524:	81124be4 	muli	r4,r16,18735
81124528:	81124c1c 	xori	r4,r16,18736
8112452c:	81124c1c 	xori	r4,r16,18736
81124530:	81124c1c 	xori	r4,r16,18736
81124534:	81124c1c 	xori	r4,r16,18736
81124538:	81124c1c 	xori	r4,r16,18736
8112453c:	81124c1c 	xori	r4,r16,18736
81124540:	81124c1c 	xori	r4,r16,18736
81124544:	81124c1c 	xori	r4,r16,18736
81124548:	81124c1c 	xori	r4,r16,18736
8112454c:	81124c1c 	xori	r4,r16,18736
81124550:	81124b80 	call	881124b8 <__reset+0x20f24b8>
81124554:	81124c1c 	xori	r4,r16,18736
81124558:	81124c1c 	xori	r4,r16,18736
8112455c:	81124c1c 	xori	r4,r16,18736
81124560:	81124c1c 	xori	r4,r16,18736
81124564:	81124c1c 	xori	r4,r16,18736
81124568:	81124c1c 	xori	r4,r16,18736
8112456c:	81124c1c 	xori	r4,r16,18736
81124570:	81124c1c 	xori	r4,r16,18736
81124574:	81124c1c 	xori	r4,r16,18736
81124578:	81124c1c 	xori	r4,r16,18736
8112457c:	81124cf8 	rdprs	r4,r16,18739
81124580:	81124c1c 	xori	r4,r16,18736
81124584:	81124c1c 	xori	r4,r16,18736
81124588:	81124c1c 	xori	r4,r16,18736
8112458c:	81124c1c 	xori	r4,r16,18736
81124590:	81124c1c 	xori	r4,r16,18736
81124594:	81124c90 	cmplti	r4,r16,18738
81124598:	81124c1c 	xori	r4,r16,18736
8112459c:	81124c1c 	xori	r4,r16,18736
811245a0:	811249c4 	addi	r4,r16,18727
811245a4:	81124c1c 	xori	r4,r16,18736
811245a8:	81124c1c 	xori	r4,r16,18736
811245ac:	81124c1c 	xori	r4,r16,18736
811245b0:	81124c1c 	xori	r4,r16,18736
811245b4:	81124c1c 	xori	r4,r16,18736
811245b8:	81124c1c 	xori	r4,r16,18736
811245bc:	81124c1c 	xori	r4,r16,18736
811245c0:	81124c1c 	xori	r4,r16,18736
811245c4:	81124c1c 	xori	r4,r16,18736
811245c8:	81124c1c 	xori	r4,r16,18736
811245cc:	811248b4 	orhi	r4,r16,18722
811245d0:	81124a60 	cmpeqi	r4,r16,18729
811245d4:	81124c1c 	xori	r4,r16,18736
811245d8:	81124c1c 	xori	r4,r16,18736
811245dc:	81124c1c 	xori	r4,r16,18736
811245e0:	81124a54 	ori	r4,r16,18729
811245e4:	81124a60 	cmpeqi	r4,r16,18729
811245e8:	81124c1c 	xori	r4,r16,18736
811245ec:	81124c1c 	xori	r4,r16,18736
811245f0:	81124a44 	addi	r4,r16,18729
811245f4:	81124c1c 	xori	r4,r16,18736
811245f8:	81124a08 	cmpgei	r4,r16,18728
811245fc:	81124810 	cmplti	r4,r16,18720
81124600:	8112465c 	xori	r4,r16,18713
81124604:	81124b74 	orhi	r4,r16,18733
81124608:	81124c1c 	xori	r4,r16,18736
8112460c:	81124b28 	cmpgeui	r4,r16,18732
81124610:	81124c1c 	xori	r4,r16,18736
81124614:	81124780 	call	88112478 <__reset+0x20f2478>
81124618:	81124c1c 	xori	r4,r16,18736
8112461c:	81124c1c 	xori	r4,r16,18736
81124620:	811246dc 	xori	r4,r16,18715
81124624:	dac02317 	ldw	r11,140(sp)
81124628:	5ac00017 	ldw	r11,0(r11)
8112462c:	dac02415 	stw	r11,144(sp)
81124630:	dac02317 	ldw	r11,140(sp)
81124634:	58800104 	addi	r2,r11,4
81124638:	dac02417 	ldw	r11,144(sp)
8112463c:	5802e90e 	bge	r11,zero,811251e4 <___svfiprintf_internal_r+0xe8c>
81124640:	dac02417 	ldw	r11,144(sp)
81124644:	d8802315 	stw	r2,140(sp)
81124648:	02d7c83a 	sub	r11,zero,r11
8112464c:	dac02415 	stw	r11,144(sp)
81124650:	94800114 	ori	r18,r18,4
81124654:	98c00007 	ldb	r3,0(r19)
81124658:	003f9006 	br	8112449c <__reset+0xfb10449c>
8112465c:	00800c04 	movi	r2,48
81124660:	dac02317 	ldw	r11,140(sp)
81124664:	d8801d05 	stb	r2,116(sp)
81124668:	00801e04 	movi	r2,120
8112466c:	d8801d45 	stb	r2,117(sp)
81124670:	d8001d85 	stb	zero,118(sp)
81124674:	58c00104 	addi	r3,r11,4
81124678:	5f000017 	ldw	fp,0(r11)
8112467c:	0013883a 	mov	r9,zero
81124680:	90800094 	ori	r2,r18,2
81124684:	80032b16 	blt	r16,zero,81125334 <___svfiprintf_internal_r+0xfdc>
81124688:	00bfdfc4 	movi	r2,-129
8112468c:	90a4703a 	and	r18,r18,r2
81124690:	d8c02315 	stw	r3,140(sp)
81124694:	94800094 	ori	r18,r18,2
81124698:	e002dc26 	beq	fp,zero,8112520c <___svfiprintf_internal_r+0xeb4>
8112469c:	01204534 	movhi	r4,33044
811246a0:	21111e04 	addi	r4,r4,17528
811246a4:	0015883a 	mov	r10,zero
811246a8:	d9002915 	stw	r4,164(sp)
811246ac:	00002306 	br	8112473c <___svfiprintf_internal_r+0x3e4>
811246b0:	94800054 	ori	r18,r18,1
811246b4:	98c00007 	ldb	r3,0(r19)
811246b8:	003f7806 	br	8112449c <__reset+0xfb10449c>
811246bc:	38803fcc 	andi	r2,r7,255
811246c0:	1080201c 	xori	r2,r2,128
811246c4:	10bfe004 	addi	r2,r2,-128
811246c8:	1002f31e 	bne	r2,zero,81125298 <___svfiprintf_internal_r+0xf40>
811246cc:	01000044 	movi	r4,1
811246d0:	01c00804 	movi	r7,32
811246d4:	98c00007 	ldb	r3,0(r19)
811246d8:	003f7006 	br	8112449c <__reset+0xfb10449c>
811246dc:	21003fcc 	andi	r4,r4,255
811246e0:	2003aa1e 	bne	r4,zero,8112558c <___svfiprintf_internal_r+0x1234>
811246e4:	00a04534 	movhi	r2,33044
811246e8:	10911e04 	addi	r2,r2,17528
811246ec:	d8802915 	stw	r2,164(sp)
811246f0:	9080080c 	andi	r2,r18,32
811246f4:	1000ba26 	beq	r2,zero,811249e0 <___svfiprintf_internal_r+0x688>
811246f8:	dac02317 	ldw	r11,140(sp)
811246fc:	5f000017 	ldw	fp,0(r11)
81124700:	5a400117 	ldw	r9,4(r11)
81124704:	5ac00204 	addi	r11,r11,8
81124708:	dac02315 	stw	r11,140(sp)
8112470c:	9080004c 	andi	r2,r18,1
81124710:	10029026 	beq	r2,zero,81125154 <___svfiprintf_internal_r+0xdfc>
81124714:	e244b03a 	or	r2,fp,r9
81124718:	1002d41e 	bne	r2,zero,8112526c <___svfiprintf_internal_r+0xf14>
8112471c:	d8001d85 	stb	zero,118(sp)
81124720:	80030b16 	blt	r16,zero,81125350 <___svfiprintf_internal_r+0xff8>
81124724:	00bfdfc4 	movi	r2,-129
81124728:	90a4703a 	and	r18,r18,r2
8112472c:	0015883a 	mov	r10,zero
81124730:	80002426 	beq	r16,zero,811247c4 <___svfiprintf_internal_r+0x46c>
81124734:	0039883a 	mov	fp,zero
81124738:	0013883a 	mov	r9,zero
8112473c:	d9002917 	ldw	r4,164(sp)
81124740:	dc401a04 	addi	r17,sp,104
81124744:	e08003cc 	andi	r2,fp,15
81124748:	4806973a 	slli	r3,r9,28
8112474c:	2085883a 	add	r2,r4,r2
81124750:	e038d13a 	srli	fp,fp,4
81124754:	10800003 	ldbu	r2,0(r2)
81124758:	4812d13a 	srli	r9,r9,4
8112475c:	8c7fffc4 	addi	r17,r17,-1
81124760:	1f38b03a 	or	fp,r3,fp
81124764:	88800005 	stb	r2,0(r17)
81124768:	e244b03a 	or	r2,fp,r9
8112476c:	103ff51e 	bne	r2,zero,81124744 <__reset+0xfb104744>
81124770:	dac01e17 	ldw	r11,120(sp)
81124774:	5c57c83a 	sub	r11,r11,r17
81124778:	dac02115 	stw	r11,132(sp)
8112477c:	00001406 	br	811247d0 <___svfiprintf_internal_r+0x478>
81124780:	21003fcc 	andi	r4,r4,255
81124784:	2003741e 	bne	r4,zero,81125558 <___svfiprintf_internal_r+0x1200>
81124788:	9080080c 	andi	r2,r18,32
8112478c:	10014526 	beq	r2,zero,81124ca4 <___svfiprintf_internal_r+0x94c>
81124790:	dac02317 	ldw	r11,140(sp)
81124794:	d8001d85 	stb	zero,118(sp)
81124798:	58c00204 	addi	r3,r11,8
8112479c:	5f000017 	ldw	fp,0(r11)
811247a0:	5a400117 	ldw	r9,4(r11)
811247a4:	8002d916 	blt	r16,zero,8112530c <___svfiprintf_internal_r+0xfb4>
811247a8:	013fdfc4 	movi	r4,-129
811247ac:	e244b03a 	or	r2,fp,r9
811247b0:	d8c02315 	stw	r3,140(sp)
811247b4:	9124703a 	and	r18,r18,r4
811247b8:	0015883a 	mov	r10,zero
811247bc:	1000b91e 	bne	r2,zero,81124aa4 <___svfiprintf_internal_r+0x74c>
811247c0:	8002e61e 	bne	r16,zero,8112535c <___svfiprintf_internal_r+0x1004>
811247c4:	0021883a 	mov	r16,zero
811247c8:	d8002115 	stw	zero,132(sp)
811247cc:	dc401a04 	addi	r17,sp,104
811247d0:	d8c02117 	ldw	r3,132(sp)
811247d4:	dc002015 	stw	r16,128(sp)
811247d8:	80c0010e 	bge	r16,r3,811247e0 <___svfiprintf_internal_r+0x488>
811247dc:	d8c02015 	stw	r3,128(sp)
811247e0:	52803fcc 	andi	r10,r10,255
811247e4:	5280201c 	xori	r10,r10,128
811247e8:	52bfe004 	addi	r10,r10,-128
811247ec:	50003c26 	beq	r10,zero,811248e0 <___svfiprintf_internal_r+0x588>
811247f0:	dac02017 	ldw	r11,128(sp)
811247f4:	5ac00044 	addi	r11,r11,1
811247f8:	dac02015 	stw	r11,128(sp)
811247fc:	00003806 	br	811248e0 <___svfiprintf_internal_r+0x588>
81124800:	01000044 	movi	r4,1
81124804:	01c00ac4 	movi	r7,43
81124808:	98c00007 	ldb	r3,0(r19)
8112480c:	003f2306 	br	8112449c <__reset+0xfb10449c>
81124810:	21003fcc 	andi	r4,r4,255
81124814:	2003481e 	bne	r4,zero,81125538 <___svfiprintf_internal_r+0x11e0>
81124818:	9080080c 	andi	r2,r18,32
8112481c:	10013b26 	beq	r2,zero,81124d0c <___svfiprintf_internal_r+0x9b4>
81124820:	dac02317 	ldw	r11,140(sp)
81124824:	d8001d85 	stb	zero,118(sp)
81124828:	58800204 	addi	r2,r11,8
8112482c:	5f000017 	ldw	fp,0(r11)
81124830:	5a400117 	ldw	r9,4(r11)
81124834:	8002a816 	blt	r16,zero,811252d8 <___svfiprintf_internal_r+0xf80>
81124838:	013fdfc4 	movi	r4,-129
8112483c:	e246b03a 	or	r3,fp,r9
81124840:	d8802315 	stw	r2,140(sp)
81124844:	9124703a 	and	r18,r18,r4
81124848:	18013c26 	beq	r3,zero,81124d3c <___svfiprintf_internal_r+0x9e4>
8112484c:	0015883a 	mov	r10,zero
81124850:	dc401a04 	addi	r17,sp,104
81124854:	e006d0fa 	srli	r3,fp,3
81124858:	4808977a 	slli	r4,r9,29
8112485c:	4812d0fa 	srli	r9,r9,3
81124860:	e70001cc 	andi	fp,fp,7
81124864:	e0800c04 	addi	r2,fp,48
81124868:	8c7fffc4 	addi	r17,r17,-1
8112486c:	20f8b03a 	or	fp,r4,r3
81124870:	88800005 	stb	r2,0(r17)
81124874:	e246b03a 	or	r3,fp,r9
81124878:	183ff61e 	bne	r3,zero,81124854 <__reset+0xfb104854>
8112487c:	90c0004c 	andi	r3,r18,1
81124880:	1800a526 	beq	r3,zero,81124b18 <___svfiprintf_internal_r+0x7c0>
81124884:	10803fcc 	andi	r2,r2,255
81124888:	1080201c 	xori	r2,r2,128
8112488c:	10bfe004 	addi	r2,r2,-128
81124890:	00c00c04 	movi	r3,48
81124894:	10ffb626 	beq	r2,r3,81124770 <__reset+0xfb104770>
81124898:	88ffffc5 	stb	r3,-1(r17)
8112489c:	d8c01e17 	ldw	r3,120(sp)
811248a0:	88bfffc4 	addi	r2,r17,-1
811248a4:	1023883a 	mov	r17,r2
811248a8:	1887c83a 	sub	r3,r3,r2
811248ac:	d8c02115 	stw	r3,132(sp)
811248b0:	003fc706 	br	811247d0 <__reset+0xfb1047d0>
811248b4:	dac02317 	ldw	r11,140(sp)
811248b8:	00c00044 	movi	r3,1
811248bc:	d8c02015 	stw	r3,128(sp)
811248c0:	58800017 	ldw	r2,0(r11)
811248c4:	5ac00104 	addi	r11,r11,4
811248c8:	d8001d85 	stb	zero,118(sp)
811248cc:	d8801005 	stb	r2,64(sp)
811248d0:	dac02315 	stw	r11,140(sp)
811248d4:	d8c02115 	stw	r3,132(sp)
811248d8:	dc401004 	addi	r17,sp,64
811248dc:	0021883a 	mov	r16,zero
811248e0:	90c0008c 	andi	r3,r18,2
811248e4:	d8c02215 	stw	r3,136(sp)
811248e8:	18000326 	beq	r3,zero,811248f8 <___svfiprintf_internal_r+0x5a0>
811248ec:	dac02017 	ldw	r11,128(sp)
811248f0:	5ac00084 	addi	r11,r11,2
811248f4:	dac02015 	stw	r11,128(sp)
811248f8:	90c0210c 	andi	r3,r18,132
811248fc:	d8c02615 	stw	r3,152(sp)
81124900:	1801131e 	bne	r3,zero,81124d50 <___svfiprintf_internal_r+0x9f8>
81124904:	dac02417 	ldw	r11,144(sp)
81124908:	d8c02017 	ldw	r3,128(sp)
8112490c:	58f9c83a 	sub	fp,r11,r3
81124910:	07010f0e 	bge	zero,fp,81124d50 <___svfiprintf_internal_r+0x9f8>
81124914:	02400404 	movi	r9,16
81124918:	d8c01c17 	ldw	r3,112(sp)
8112491c:	d8801b17 	ldw	r2,108(sp)
81124920:	4f02d60e 	bge	r9,fp,8112547c <___svfiprintf_internal_r+0x1124>
81124924:	01604534 	movhi	r5,33044
81124928:	2951ac04 	addi	r5,r5,18096
8112492c:	d9402815 	stw	r5,160(sp)
81124930:	028001c4 	movi	r10,7
81124934:	00000306 	br	81124944 <___svfiprintf_internal_r+0x5ec>
81124938:	e73ffc04 	addi	fp,fp,-16
8112493c:	42000204 	addi	r8,r8,8
81124940:	4f00150e 	bge	r9,fp,81124998 <___svfiprintf_internal_r+0x640>
81124944:	18c00404 	addi	r3,r3,16
81124948:	10800044 	addi	r2,r2,1
8112494c:	45800015 	stw	r22,0(r8)
81124950:	42400115 	stw	r9,4(r8)
81124954:	d8c01c15 	stw	r3,112(sp)
81124958:	d8801b15 	stw	r2,108(sp)
8112495c:	50bff60e 	bge	r10,r2,81124938 <__reset+0xfb104938>
81124960:	d9801a04 	addi	r6,sp,104
81124964:	b80b883a 	mov	r5,r23
81124968:	a809883a 	mov	r4,r21
8112496c:	da402c15 	stw	r9,176(sp)
81124970:	da802d15 	stw	r10,180(sp)
81124974:	11241800 	call	81124180 <__ssprint_r>
81124978:	da402c17 	ldw	r9,176(sp)
8112497c:	da802d17 	ldw	r10,180(sp)
81124980:	1001851e 	bne	r2,zero,81124f98 <___svfiprintf_internal_r+0xc40>
81124984:	e73ffc04 	addi	fp,fp,-16
81124988:	d8c01c17 	ldw	r3,112(sp)
8112498c:	d8801b17 	ldw	r2,108(sp)
81124990:	d811883a 	mov	r8,sp
81124994:	4f3feb16 	blt	r9,fp,81124944 <__reset+0xfb104944>
81124998:	dac02817 	ldw	r11,160(sp)
8112499c:	e0c7883a 	add	r3,fp,r3
811249a0:	10800044 	addi	r2,r2,1
811249a4:	42c00015 	stw	r11,0(r8)
811249a8:	47000115 	stw	fp,4(r8)
811249ac:	d8c01c15 	stw	r3,112(sp)
811249b0:	d8801b15 	stw	r2,108(sp)
811249b4:	010001c4 	movi	r4,7
811249b8:	2081ee16 	blt	r4,r2,81125174 <___svfiprintf_internal_r+0xe1c>
811249bc:	42000204 	addi	r8,r8,8
811249c0:	0000e506 	br	81124d58 <___svfiprintf_internal_r+0xa00>
811249c4:	21003fcc 	andi	r4,r4,255
811249c8:	2002dd1e 	bne	r4,zero,81125540 <___svfiprintf_internal_r+0x11e8>
811249cc:	00a04534 	movhi	r2,33044
811249d0:	10911904 	addi	r2,r2,17508
811249d4:	d8802915 	stw	r2,164(sp)
811249d8:	9080080c 	andi	r2,r18,32
811249dc:	103f461e 	bne	r2,zero,811246f8 <__reset+0xfb1046f8>
811249e0:	9080040c 	andi	r2,r18,16
811249e4:	10022e1e 	bne	r2,zero,811252a0 <___svfiprintf_internal_r+0xf48>
811249e8:	9080100c 	andi	r2,r18,64
811249ec:	dac02317 	ldw	r11,140(sp)
811249f0:	10027326 	beq	r2,zero,811253c0 <___svfiprintf_internal_r+0x1068>
811249f4:	5f00000b 	ldhu	fp,0(r11)
811249f8:	5ac00104 	addi	r11,r11,4
811249fc:	0013883a 	mov	r9,zero
81124a00:	dac02315 	stw	r11,140(sp)
81124a04:	003f4106 	br	8112470c <__reset+0xfb10470c>
81124a08:	21003fcc 	andi	r4,r4,255
81124a0c:	2002e11e 	bne	r4,zero,81125594 <___svfiprintf_internal_r+0x123c>
81124a10:	9080080c 	andi	r2,r18,32
81124a14:	1002011e 	bne	r2,zero,8112521c <___svfiprintf_internal_r+0xec4>
81124a18:	9080040c 	andi	r2,r18,16
81124a1c:	10023e1e 	bne	r2,zero,81125318 <___svfiprintf_internal_r+0xfc0>
81124a20:	9480100c 	andi	r18,r18,64
81124a24:	90023c26 	beq	r18,zero,81125318 <___svfiprintf_internal_r+0xfc0>
81124a28:	dac02317 	ldw	r11,140(sp)
81124a2c:	58800017 	ldw	r2,0(r11)
81124a30:	5ac00104 	addi	r11,r11,4
81124a34:	dac02315 	stw	r11,140(sp)
81124a38:	dac02517 	ldw	r11,148(sp)
81124a3c:	12c0000d 	sth	r11,0(r2)
81124a40:	003e6e06 	br	811243fc <__reset+0xfb1043fc>
81124a44:	98c00007 	ldb	r3,0(r19)
81124a48:	1a422926 	beq	r3,r9,811252f0 <___svfiprintf_internal_r+0xf98>
81124a4c:	94800414 	ori	r18,r18,16
81124a50:	003e9206 	br	8112449c <__reset+0xfb10449c>
81124a54:	94801014 	ori	r18,r18,64
81124a58:	98c00007 	ldb	r3,0(r19)
81124a5c:	003e8f06 	br	8112449c <__reset+0xfb10449c>
81124a60:	21003fcc 	andi	r4,r4,255
81124a64:	2002c71e 	bne	r4,zero,81125584 <___svfiprintf_internal_r+0x122c>
81124a68:	9080080c 	andi	r2,r18,32
81124a6c:	10004926 	beq	r2,zero,81124b94 <___svfiprintf_internal_r+0x83c>
81124a70:	dac02317 	ldw	r11,140(sp)
81124a74:	58800117 	ldw	r2,4(r11)
81124a78:	5f000017 	ldw	fp,0(r11)
81124a7c:	5ac00204 	addi	r11,r11,8
81124a80:	dac02315 	stw	r11,140(sp)
81124a84:	1013883a 	mov	r9,r2
81124a88:	10004b16 	blt	r2,zero,81124bb8 <___svfiprintf_internal_r+0x860>
81124a8c:	da801d83 	ldbu	r10,118(sp)
81124a90:	8001cb16 	blt	r16,zero,811251c0 <___svfiprintf_internal_r+0xe68>
81124a94:	00ffdfc4 	movi	r3,-129
81124a98:	e244b03a 	or	r2,fp,r9
81124a9c:	90e4703a 	and	r18,r18,r3
81124aa0:	103f4726 	beq	r2,zero,811247c0 <__reset+0xfb1047c0>
81124aa4:	48008c26 	beq	r9,zero,81124cd8 <___svfiprintf_internal_r+0x980>
81124aa8:	dc802015 	stw	r18,128(sp)
81124aac:	dc002115 	stw	r16,132(sp)
81124ab0:	dc401a04 	addi	r17,sp,104
81124ab4:	e021883a 	mov	r16,fp
81124ab8:	da002215 	stw	r8,136(sp)
81124abc:	5039883a 	mov	fp,r10
81124ac0:	4825883a 	mov	r18,r9
81124ac4:	8009883a 	mov	r4,r16
81124ac8:	900b883a 	mov	r5,r18
81124acc:	01800284 	movi	r6,10
81124ad0:	000f883a 	mov	r7,zero
81124ad4:	11286e40 	call	811286e4 <__umoddi3>
81124ad8:	10800c04 	addi	r2,r2,48
81124adc:	8c7fffc4 	addi	r17,r17,-1
81124ae0:	8009883a 	mov	r4,r16
81124ae4:	900b883a 	mov	r5,r18
81124ae8:	88800005 	stb	r2,0(r17)
81124aec:	01800284 	movi	r6,10
81124af0:	000f883a 	mov	r7,zero
81124af4:	11281640 	call	81128164 <__udivdi3>
81124af8:	1021883a 	mov	r16,r2
81124afc:	10c4b03a 	or	r2,r2,r3
81124b00:	1825883a 	mov	r18,r3
81124b04:	103fef1e 	bne	r2,zero,81124ac4 <__reset+0xfb104ac4>
81124b08:	dc802017 	ldw	r18,128(sp)
81124b0c:	dc002117 	ldw	r16,132(sp)
81124b10:	da002217 	ldw	r8,136(sp)
81124b14:	e015883a 	mov	r10,fp
81124b18:	d8c01e17 	ldw	r3,120(sp)
81124b1c:	1c47c83a 	sub	r3,r3,r17
81124b20:	d8c02115 	stw	r3,132(sp)
81124b24:	003f2a06 	br	811247d0 <__reset+0xfb1047d0>
81124b28:	dac02317 	ldw	r11,140(sp)
81124b2c:	d8001d85 	stb	zero,118(sp)
81124b30:	5c400017 	ldw	r17,0(r11)
81124b34:	5f000104 	addi	fp,r11,4
81124b38:	88022f26 	beq	r17,zero,811253f8 <___svfiprintf_internal_r+0x10a0>
81124b3c:	80022516 	blt	r16,zero,811253d4 <___svfiprintf_internal_r+0x107c>
81124b40:	800d883a 	mov	r6,r16
81124b44:	000b883a 	mov	r5,zero
81124b48:	8809883a 	mov	r4,r17
81124b4c:	da002c15 	stw	r8,176(sp)
81124b50:	11207240 	call	81120724 <memchr>
81124b54:	da002c17 	ldw	r8,176(sp)
81124b58:	10026426 	beq	r2,zero,811254ec <___svfiprintf_internal_r+0x1194>
81124b5c:	1445c83a 	sub	r2,r2,r17
81124b60:	d8802115 	stw	r2,132(sp)
81124b64:	da801d83 	ldbu	r10,118(sp)
81124b68:	df002315 	stw	fp,140(sp)
81124b6c:	0021883a 	mov	r16,zero
81124b70:	003f1706 	br	811247d0 <__reset+0xfb1047d0>
81124b74:	94800814 	ori	r18,r18,32
81124b78:	98c00007 	ldb	r3,0(r19)
81124b7c:	003e4706 	br	8112449c <__reset+0xfb10449c>
81124b80:	21003fcc 	andi	r4,r4,255
81124b84:	2002701e 	bne	r4,zero,81125548 <___svfiprintf_internal_r+0x11f0>
81124b88:	94800414 	ori	r18,r18,16
81124b8c:	9080080c 	andi	r2,r18,32
81124b90:	103fb71e 	bne	r2,zero,81124a70 <__reset+0xfb104a70>
81124b94:	9080040c 	andi	r2,r18,16
81124b98:	1001ab26 	beq	r2,zero,81125248 <___svfiprintf_internal_r+0xef0>
81124b9c:	dac02317 	ldw	r11,140(sp)
81124ba0:	5f000017 	ldw	fp,0(r11)
81124ba4:	5ac00104 	addi	r11,r11,4
81124ba8:	dac02315 	stw	r11,140(sp)
81124bac:	e013d7fa 	srai	r9,fp,31
81124bb0:	4805883a 	mov	r2,r9
81124bb4:	103fb50e 	bge	r2,zero,81124a8c <__reset+0xfb104a8c>
81124bb8:	0739c83a 	sub	fp,zero,fp
81124bbc:	02800b44 	movi	r10,45
81124bc0:	e004c03a 	cmpne	r2,fp,zero
81124bc4:	0253c83a 	sub	r9,zero,r9
81124bc8:	da801d85 	stb	r10,118(sp)
81124bcc:	4893c83a 	sub	r9,r9,r2
81124bd0:	80023016 	blt	r16,zero,81125494 <___svfiprintf_internal_r+0x113c>
81124bd4:	00bfdfc4 	movi	r2,-129
81124bd8:	90a4703a 	and	r18,r18,r2
81124bdc:	483fb21e 	bne	r9,zero,81124aa8 <__reset+0xfb104aa8>
81124be0:	00003d06 	br	81124cd8 <___svfiprintf_internal_r+0x980>
81124be4:	9817883a 	mov	r11,r19
81124be8:	d8002415 	stw	zero,144(sp)
81124bec:	18bff404 	addi	r2,r3,-48
81124bf0:	0019883a 	mov	r12,zero
81124bf4:	58c00007 	ldb	r3,0(r11)
81124bf8:	630002a4 	muli	r12,r12,10
81124bfc:	9cc00044 	addi	r19,r19,1
81124c00:	9817883a 	mov	r11,r19
81124c04:	1319883a 	add	r12,r2,r12
81124c08:	18bff404 	addi	r2,r3,-48
81124c0c:	30bff92e 	bgeu	r6,r2,81124bf4 <__reset+0xfb104bf4>
81124c10:	db002415 	stw	r12,144(sp)
81124c14:	18bff804 	addi	r2,r3,-32
81124c18:	28be232e 	bgeu	r5,r2,811244a8 <__reset+0xfb1044a8>
81124c1c:	21003fcc 	andi	r4,r4,255
81124c20:	20024b1e 	bne	r4,zero,81125550 <___svfiprintf_internal_r+0x11f8>
81124c24:	1800d626 	beq	r3,zero,81124f80 <___svfiprintf_internal_r+0xc28>
81124c28:	02c00044 	movi	r11,1
81124c2c:	dac02015 	stw	r11,128(sp)
81124c30:	d8c01005 	stb	r3,64(sp)
81124c34:	d8001d85 	stb	zero,118(sp)
81124c38:	dac02115 	stw	r11,132(sp)
81124c3c:	dc401004 	addi	r17,sp,64
81124c40:	003f2606 	br	811248dc <__reset+0xfb1048dc>
81124c44:	94802014 	ori	r18,r18,128
81124c48:	98c00007 	ldb	r3,0(r19)
81124c4c:	003e1306 	br	8112449c <__reset+0xfb10449c>
81124c50:	98c00007 	ldb	r3,0(r19)
81124c54:	9ac00044 	addi	r11,r19,1
81124c58:	1a822b26 	beq	r3,r10,81125508 <___svfiprintf_internal_r+0x11b0>
81124c5c:	18bff404 	addi	r2,r3,-48
81124c60:	0021883a 	mov	r16,zero
81124c64:	30821e36 	bltu	r6,r2,811254e0 <___svfiprintf_internal_r+0x1188>
81124c68:	58c00007 	ldb	r3,0(r11)
81124c6c:	840002a4 	muli	r16,r16,10
81124c70:	5cc00044 	addi	r19,r11,1
81124c74:	9817883a 	mov	r11,r19
81124c78:	80a1883a 	add	r16,r16,r2
81124c7c:	18bff404 	addi	r2,r3,-48
81124c80:	30bff92e 	bgeu	r6,r2,81124c68 <__reset+0xfb104c68>
81124c84:	803e060e 	bge	r16,zero,811244a0 <__reset+0xfb1044a0>
81124c88:	043fffc4 	movi	r16,-1
81124c8c:	003e0406 	br	811244a0 <__reset+0xfb1044a0>
81124c90:	21003fcc 	andi	r4,r4,255
81124c94:	2002371e 	bne	r4,zero,81125574 <___svfiprintf_internal_r+0x121c>
81124c98:	94800414 	ori	r18,r18,16
81124c9c:	9080080c 	andi	r2,r18,32
81124ca0:	103ebb1e 	bne	r2,zero,81124790 <__reset+0xfb104790>
81124ca4:	9080040c 	andi	r2,r18,16
81124ca8:	10013b26 	beq	r2,zero,81125198 <___svfiprintf_internal_r+0xe40>
81124cac:	dac02317 	ldw	r11,140(sp)
81124cb0:	d8001d85 	stb	zero,118(sp)
81124cb4:	0013883a 	mov	r9,zero
81124cb8:	58800104 	addi	r2,r11,4
81124cbc:	5f000017 	ldw	fp,0(r11)
81124cc0:	80013d16 	blt	r16,zero,811251b8 <___svfiprintf_internal_r+0xe60>
81124cc4:	00ffdfc4 	movi	r3,-129
81124cc8:	d8802315 	stw	r2,140(sp)
81124ccc:	90e4703a 	and	r18,r18,r3
81124cd0:	0015883a 	mov	r10,zero
81124cd4:	e03eba26 	beq	fp,zero,811247c0 <__reset+0xfb1047c0>
81124cd8:	00800244 	movi	r2,9
81124cdc:	173f7236 	bltu	r2,fp,81124aa8 <__reset+0xfb104aa8>
81124ce0:	dac02b17 	ldw	r11,172(sp)
81124ce4:	e7000c04 	addi	fp,fp,48
81124ce8:	df0019c5 	stb	fp,103(sp)
81124cec:	dac02115 	stw	r11,132(sp)
81124cf0:	dc4019c4 	addi	r17,sp,103
81124cf4:	003eb606 	br	811247d0 <__reset+0xfb1047d0>
81124cf8:	21003fcc 	andi	r4,r4,255
81124cfc:	20021f1e 	bne	r4,zero,8112557c <___svfiprintf_internal_r+0x1224>
81124d00:	94800414 	ori	r18,r18,16
81124d04:	9080080c 	andi	r2,r18,32
81124d08:	103ec51e 	bne	r2,zero,81124820 <__reset+0xfb104820>
81124d0c:	9080040c 	andi	r2,r18,16
81124d10:	10016926 	beq	r2,zero,811252b8 <___svfiprintf_internal_r+0xf60>
81124d14:	dac02317 	ldw	r11,140(sp)
81124d18:	d8001d85 	stb	zero,118(sp)
81124d1c:	0013883a 	mov	r9,zero
81124d20:	58800104 	addi	r2,r11,4
81124d24:	5f000017 	ldw	fp,0(r11)
81124d28:	80016b16 	blt	r16,zero,811252d8 <___svfiprintf_internal_r+0xf80>
81124d2c:	00ffdfc4 	movi	r3,-129
81124d30:	d8802315 	stw	r2,140(sp)
81124d34:	90e4703a 	and	r18,r18,r3
81124d38:	e03ec41e 	bne	fp,zero,8112484c <__reset+0xfb10484c>
81124d3c:	0015883a 	mov	r10,zero
81124d40:	8001c226 	beq	r16,zero,8112544c <___svfiprintf_internal_r+0x10f4>
81124d44:	0039883a 	mov	fp,zero
81124d48:	0013883a 	mov	r9,zero
81124d4c:	003ec006 	br	81124850 <__reset+0xfb104850>
81124d50:	d8c01c17 	ldw	r3,112(sp)
81124d54:	d8801b17 	ldw	r2,108(sp)
81124d58:	d9001d87 	ldb	r4,118(sp)
81124d5c:	20000b26 	beq	r4,zero,81124d8c <___svfiprintf_internal_r+0xa34>
81124d60:	d9001d84 	addi	r4,sp,118
81124d64:	18c00044 	addi	r3,r3,1
81124d68:	10800044 	addi	r2,r2,1
81124d6c:	41000015 	stw	r4,0(r8)
81124d70:	01000044 	movi	r4,1
81124d74:	41000115 	stw	r4,4(r8)
81124d78:	d8c01c15 	stw	r3,112(sp)
81124d7c:	d8801b15 	stw	r2,108(sp)
81124d80:	010001c4 	movi	r4,7
81124d84:	2080e116 	blt	r4,r2,8112510c <___svfiprintf_internal_r+0xdb4>
81124d88:	42000204 	addi	r8,r8,8
81124d8c:	dac02217 	ldw	r11,136(sp)
81124d90:	58000b26 	beq	r11,zero,81124dc0 <___svfiprintf_internal_r+0xa68>
81124d94:	d9001d04 	addi	r4,sp,116
81124d98:	18c00084 	addi	r3,r3,2
81124d9c:	10800044 	addi	r2,r2,1
81124da0:	41000015 	stw	r4,0(r8)
81124da4:	01000084 	movi	r4,2
81124da8:	41000115 	stw	r4,4(r8)
81124dac:	d8c01c15 	stw	r3,112(sp)
81124db0:	d8801b15 	stw	r2,108(sp)
81124db4:	010001c4 	movi	r4,7
81124db8:	2080dd16 	blt	r4,r2,81125130 <___svfiprintf_internal_r+0xdd8>
81124dbc:	42000204 	addi	r8,r8,8
81124dc0:	dac02617 	ldw	r11,152(sp)
81124dc4:	01002004 	movi	r4,128
81124dc8:	59008426 	beq	r11,r4,81124fdc <___svfiprintf_internal_r+0xc84>
81124dcc:	dac02117 	ldw	r11,132(sp)
81124dd0:	82e1c83a 	sub	r16,r16,r11
81124dd4:	0400270e 	bge	zero,r16,81124e74 <___svfiprintf_internal_r+0xb1c>
81124dd8:	01c00404 	movi	r7,16
81124ddc:	3c016a0e 	bge	r7,r16,81125388 <___svfiprintf_internal_r+0x1030>
81124de0:	01604534 	movhi	r5,33044
81124de4:	2951a804 	addi	r5,r5,18080
81124de8:	d9402215 	stw	r5,136(sp)
81124dec:	070001c4 	movi	fp,7
81124df0:	00000306 	br	81124e00 <___svfiprintf_internal_r+0xaa8>
81124df4:	843ffc04 	addi	r16,r16,-16
81124df8:	42000204 	addi	r8,r8,8
81124dfc:	3c00130e 	bge	r7,r16,81124e4c <___svfiprintf_internal_r+0xaf4>
81124e00:	18c00404 	addi	r3,r3,16
81124e04:	10800044 	addi	r2,r2,1
81124e08:	45000015 	stw	r20,0(r8)
81124e0c:	41c00115 	stw	r7,4(r8)
81124e10:	d8c01c15 	stw	r3,112(sp)
81124e14:	d8801b15 	stw	r2,108(sp)
81124e18:	e0bff60e 	bge	fp,r2,81124df4 <__reset+0xfb104df4>
81124e1c:	d9801a04 	addi	r6,sp,104
81124e20:	b80b883a 	mov	r5,r23
81124e24:	a809883a 	mov	r4,r21
81124e28:	d9c02c15 	stw	r7,176(sp)
81124e2c:	11241800 	call	81124180 <__ssprint_r>
81124e30:	d9c02c17 	ldw	r7,176(sp)
81124e34:	1000581e 	bne	r2,zero,81124f98 <___svfiprintf_internal_r+0xc40>
81124e38:	843ffc04 	addi	r16,r16,-16
81124e3c:	d8c01c17 	ldw	r3,112(sp)
81124e40:	d8801b17 	ldw	r2,108(sp)
81124e44:	d811883a 	mov	r8,sp
81124e48:	3c3fed16 	blt	r7,r16,81124e00 <__reset+0xfb104e00>
81124e4c:	dac02217 	ldw	r11,136(sp)
81124e50:	1c07883a 	add	r3,r3,r16
81124e54:	10800044 	addi	r2,r2,1
81124e58:	42c00015 	stw	r11,0(r8)
81124e5c:	44000115 	stw	r16,4(r8)
81124e60:	d8c01c15 	stw	r3,112(sp)
81124e64:	d8801b15 	stw	r2,108(sp)
81124e68:	010001c4 	movi	r4,7
81124e6c:	20809e16 	blt	r4,r2,811250e8 <___svfiprintf_internal_r+0xd90>
81124e70:	42000204 	addi	r8,r8,8
81124e74:	dac02117 	ldw	r11,132(sp)
81124e78:	10800044 	addi	r2,r2,1
81124e7c:	44400015 	stw	r17,0(r8)
81124e80:	58c7883a 	add	r3,r11,r3
81124e84:	42c00115 	stw	r11,4(r8)
81124e88:	d8c01c15 	stw	r3,112(sp)
81124e8c:	d8801b15 	stw	r2,108(sp)
81124e90:	010001c4 	movi	r4,7
81124e94:	20807f16 	blt	r4,r2,81125094 <___svfiprintf_internal_r+0xd3c>
81124e98:	42000204 	addi	r8,r8,8
81124e9c:	9480010c 	andi	r18,r18,4
81124ea0:	90002926 	beq	r18,zero,81124f48 <___svfiprintf_internal_r+0xbf0>
81124ea4:	dac02417 	ldw	r11,144(sp)
81124ea8:	d8802017 	ldw	r2,128(sp)
81124eac:	58a1c83a 	sub	r16,r11,r2
81124eb0:	0400250e 	bge	zero,r16,81124f48 <___svfiprintf_internal_r+0xbf0>
81124eb4:	04400404 	movi	r17,16
81124eb8:	d8801b17 	ldw	r2,108(sp)
81124ebc:	8c017c0e 	bge	r17,r16,811254b0 <___svfiprintf_internal_r+0x1158>
81124ec0:	01604534 	movhi	r5,33044
81124ec4:	2951ac04 	addi	r5,r5,18096
81124ec8:	d9402815 	stw	r5,160(sp)
81124ecc:	048001c4 	movi	r18,7
81124ed0:	00000306 	br	81124ee0 <___svfiprintf_internal_r+0xb88>
81124ed4:	843ffc04 	addi	r16,r16,-16
81124ed8:	42000204 	addi	r8,r8,8
81124edc:	8c00110e 	bge	r17,r16,81124f24 <___svfiprintf_internal_r+0xbcc>
81124ee0:	18c00404 	addi	r3,r3,16
81124ee4:	10800044 	addi	r2,r2,1
81124ee8:	45800015 	stw	r22,0(r8)
81124eec:	44400115 	stw	r17,4(r8)
81124ef0:	d8c01c15 	stw	r3,112(sp)
81124ef4:	d8801b15 	stw	r2,108(sp)
81124ef8:	90bff60e 	bge	r18,r2,81124ed4 <__reset+0xfb104ed4>
81124efc:	d9801a04 	addi	r6,sp,104
81124f00:	b80b883a 	mov	r5,r23
81124f04:	a809883a 	mov	r4,r21
81124f08:	11241800 	call	81124180 <__ssprint_r>
81124f0c:	1000221e 	bne	r2,zero,81124f98 <___svfiprintf_internal_r+0xc40>
81124f10:	843ffc04 	addi	r16,r16,-16
81124f14:	d8c01c17 	ldw	r3,112(sp)
81124f18:	d8801b17 	ldw	r2,108(sp)
81124f1c:	d811883a 	mov	r8,sp
81124f20:	8c3fef16 	blt	r17,r16,81124ee0 <__reset+0xfb104ee0>
81124f24:	dac02817 	ldw	r11,160(sp)
81124f28:	1c07883a 	add	r3,r3,r16
81124f2c:	10800044 	addi	r2,r2,1
81124f30:	42c00015 	stw	r11,0(r8)
81124f34:	44000115 	stw	r16,4(r8)
81124f38:	d8c01c15 	stw	r3,112(sp)
81124f3c:	d8801b15 	stw	r2,108(sp)
81124f40:	010001c4 	movi	r4,7
81124f44:	2080aa16 	blt	r4,r2,811251f0 <___svfiprintf_internal_r+0xe98>
81124f48:	d8802417 	ldw	r2,144(sp)
81124f4c:	dac02017 	ldw	r11,128(sp)
81124f50:	12c0010e 	bge	r2,r11,81124f58 <___svfiprintf_internal_r+0xc00>
81124f54:	5805883a 	mov	r2,r11
81124f58:	dac02517 	ldw	r11,148(sp)
81124f5c:	5897883a 	add	r11,r11,r2
81124f60:	dac02515 	stw	r11,148(sp)
81124f64:	1800531e 	bne	r3,zero,811250b4 <___svfiprintf_internal_r+0xd5c>
81124f68:	98800007 	ldb	r2,0(r19)
81124f6c:	d8001b15 	stw	zero,108(sp)
81124f70:	d811883a 	mov	r8,sp
81124f74:	103d231e 	bne	r2,zero,81124404 <__reset+0xfb104404>
81124f78:	9823883a 	mov	r17,r19
81124f7c:	003d3906 	br	81124464 <__reset+0xfb104464>
81124f80:	d8801c17 	ldw	r2,112(sp)
81124f84:	10000426 	beq	r2,zero,81124f98 <___svfiprintf_internal_r+0xc40>
81124f88:	d9402717 	ldw	r5,156(sp)
81124f8c:	d9002a17 	ldw	r4,168(sp)
81124f90:	d9801a04 	addi	r6,sp,104
81124f94:	11241800 	call	81124180 <__ssprint_r>
81124f98:	dac02717 	ldw	r11,156(sp)
81124f9c:	d8802517 	ldw	r2,148(sp)
81124fa0:	58c0030b 	ldhu	r3,12(r11)
81124fa4:	18c0100c 	andi	r3,r3,64
81124fa8:	1801381e 	bne	r3,zero,8112548c <___svfiprintf_internal_r+0x1134>
81124fac:	dfc03717 	ldw	ra,220(sp)
81124fb0:	df003617 	ldw	fp,216(sp)
81124fb4:	ddc03517 	ldw	r23,212(sp)
81124fb8:	dd803417 	ldw	r22,208(sp)
81124fbc:	dd403317 	ldw	r21,204(sp)
81124fc0:	dd003217 	ldw	r20,200(sp)
81124fc4:	dcc03117 	ldw	r19,196(sp)
81124fc8:	dc803017 	ldw	r18,192(sp)
81124fcc:	dc402f17 	ldw	r17,188(sp)
81124fd0:	dc002e17 	ldw	r16,184(sp)
81124fd4:	dec03804 	addi	sp,sp,224
81124fd8:	f800283a 	ret
81124fdc:	dac02417 	ldw	r11,144(sp)
81124fe0:	d9002017 	ldw	r4,128(sp)
81124fe4:	5939c83a 	sub	fp,r11,r4
81124fe8:	073f780e 	bge	zero,fp,81124dcc <__reset+0xfb104dcc>
81124fec:	02400404 	movi	r9,16
81124ff0:	4f01370e 	bge	r9,fp,811254d0 <___svfiprintf_internal_r+0x1178>
81124ff4:	02e04534 	movhi	r11,33044
81124ff8:	5ad1a804 	addi	r11,r11,18080
81124ffc:	dac02215 	stw	r11,136(sp)
81125000:	028001c4 	movi	r10,7
81125004:	00000306 	br	81125014 <___svfiprintf_internal_r+0xcbc>
81125008:	e73ffc04 	addi	fp,fp,-16
8112500c:	42000204 	addi	r8,r8,8
81125010:	4f00150e 	bge	r9,fp,81125068 <___svfiprintf_internal_r+0xd10>
81125014:	18c00404 	addi	r3,r3,16
81125018:	10800044 	addi	r2,r2,1
8112501c:	45000015 	stw	r20,0(r8)
81125020:	42400115 	stw	r9,4(r8)
81125024:	d8c01c15 	stw	r3,112(sp)
81125028:	d8801b15 	stw	r2,108(sp)
8112502c:	50bff60e 	bge	r10,r2,81125008 <__reset+0xfb105008>
81125030:	d9801a04 	addi	r6,sp,104
81125034:	b80b883a 	mov	r5,r23
81125038:	a809883a 	mov	r4,r21
8112503c:	da402c15 	stw	r9,176(sp)
81125040:	da802d15 	stw	r10,180(sp)
81125044:	11241800 	call	81124180 <__ssprint_r>
81125048:	da402c17 	ldw	r9,176(sp)
8112504c:	da802d17 	ldw	r10,180(sp)
81125050:	103fd11e 	bne	r2,zero,81124f98 <__reset+0xfb104f98>
81125054:	e73ffc04 	addi	fp,fp,-16
81125058:	d8c01c17 	ldw	r3,112(sp)
8112505c:	d8801b17 	ldw	r2,108(sp)
81125060:	d811883a 	mov	r8,sp
81125064:	4f3feb16 	blt	r9,fp,81125014 <__reset+0xfb105014>
81125068:	dac02217 	ldw	r11,136(sp)
8112506c:	1f07883a 	add	r3,r3,fp
81125070:	10800044 	addi	r2,r2,1
81125074:	42c00015 	stw	r11,0(r8)
81125078:	47000115 	stw	fp,4(r8)
8112507c:	d8c01c15 	stw	r3,112(sp)
81125080:	d8801b15 	stw	r2,108(sp)
81125084:	010001c4 	movi	r4,7
81125088:	2080b616 	blt	r4,r2,81125364 <___svfiprintf_internal_r+0x100c>
8112508c:	42000204 	addi	r8,r8,8
81125090:	003f4e06 	br	81124dcc <__reset+0xfb104dcc>
81125094:	d9801a04 	addi	r6,sp,104
81125098:	b80b883a 	mov	r5,r23
8112509c:	a809883a 	mov	r4,r21
811250a0:	11241800 	call	81124180 <__ssprint_r>
811250a4:	103fbc1e 	bne	r2,zero,81124f98 <__reset+0xfb104f98>
811250a8:	d8c01c17 	ldw	r3,112(sp)
811250ac:	d811883a 	mov	r8,sp
811250b0:	003f7a06 	br	81124e9c <__reset+0xfb104e9c>
811250b4:	d9801a04 	addi	r6,sp,104
811250b8:	b80b883a 	mov	r5,r23
811250bc:	a809883a 	mov	r4,r21
811250c0:	11241800 	call	81124180 <__ssprint_r>
811250c4:	103fa826 	beq	r2,zero,81124f68 <__reset+0xfb104f68>
811250c8:	003fb306 	br	81124f98 <__reset+0xfb104f98>
811250cc:	d9801a04 	addi	r6,sp,104
811250d0:	b80b883a 	mov	r5,r23
811250d4:	a809883a 	mov	r4,r21
811250d8:	11241800 	call	81124180 <__ssprint_r>
811250dc:	103fae1e 	bne	r2,zero,81124f98 <__reset+0xfb104f98>
811250e0:	d811883a 	mov	r8,sp
811250e4:	003cdc06 	br	81124458 <__reset+0xfb104458>
811250e8:	d9801a04 	addi	r6,sp,104
811250ec:	b80b883a 	mov	r5,r23
811250f0:	a809883a 	mov	r4,r21
811250f4:	11241800 	call	81124180 <__ssprint_r>
811250f8:	103fa71e 	bne	r2,zero,81124f98 <__reset+0xfb104f98>
811250fc:	d8c01c17 	ldw	r3,112(sp)
81125100:	d8801b17 	ldw	r2,108(sp)
81125104:	d811883a 	mov	r8,sp
81125108:	003f5a06 	br	81124e74 <__reset+0xfb104e74>
8112510c:	d9801a04 	addi	r6,sp,104
81125110:	b80b883a 	mov	r5,r23
81125114:	a809883a 	mov	r4,r21
81125118:	11241800 	call	81124180 <__ssprint_r>
8112511c:	103f9e1e 	bne	r2,zero,81124f98 <__reset+0xfb104f98>
81125120:	d8c01c17 	ldw	r3,112(sp)
81125124:	d8801b17 	ldw	r2,108(sp)
81125128:	d811883a 	mov	r8,sp
8112512c:	003f1706 	br	81124d8c <__reset+0xfb104d8c>
81125130:	d9801a04 	addi	r6,sp,104
81125134:	b80b883a 	mov	r5,r23
81125138:	a809883a 	mov	r4,r21
8112513c:	11241800 	call	81124180 <__ssprint_r>
81125140:	103f951e 	bne	r2,zero,81124f98 <__reset+0xfb104f98>
81125144:	d8c01c17 	ldw	r3,112(sp)
81125148:	d8801b17 	ldw	r2,108(sp)
8112514c:	d811883a 	mov	r8,sp
81125150:	003f1b06 	br	81124dc0 <__reset+0xfb104dc0>
81125154:	d8001d85 	stb	zero,118(sp)
81125158:	80007b16 	blt	r16,zero,81125348 <___svfiprintf_internal_r+0xff0>
8112515c:	00ffdfc4 	movi	r3,-129
81125160:	e244b03a 	or	r2,fp,r9
81125164:	90e4703a 	and	r18,r18,r3
81125168:	103d7026 	beq	r2,zero,8112472c <__reset+0xfb10472c>
8112516c:	0015883a 	mov	r10,zero
81125170:	003d7206 	br	8112473c <__reset+0xfb10473c>
81125174:	d9801a04 	addi	r6,sp,104
81125178:	b80b883a 	mov	r5,r23
8112517c:	a809883a 	mov	r4,r21
81125180:	11241800 	call	81124180 <__ssprint_r>
81125184:	103f841e 	bne	r2,zero,81124f98 <__reset+0xfb104f98>
81125188:	d8c01c17 	ldw	r3,112(sp)
8112518c:	d8801b17 	ldw	r2,108(sp)
81125190:	d811883a 	mov	r8,sp
81125194:	003ef006 	br	81124d58 <__reset+0xfb104d58>
81125198:	9080100c 	andi	r2,r18,64
8112519c:	d8001d85 	stb	zero,118(sp)
811251a0:	dac02317 	ldw	r11,140(sp)
811251a4:	10008126 	beq	r2,zero,811253ac <___svfiprintf_internal_r+0x1054>
811251a8:	58800104 	addi	r2,r11,4
811251ac:	5f00000b 	ldhu	fp,0(r11)
811251b0:	0013883a 	mov	r9,zero
811251b4:	803ec30e 	bge	r16,zero,81124cc4 <__reset+0xfb104cc4>
811251b8:	d8802315 	stw	r2,140(sp)
811251bc:	0015883a 	mov	r10,zero
811251c0:	e244b03a 	or	r2,fp,r9
811251c4:	103e371e 	bne	r2,zero,81124aa4 <__reset+0xfb104aa4>
811251c8:	00800044 	movi	r2,1
811251cc:	10803fcc 	andi	r2,r2,255
811251d0:	00c00044 	movi	r3,1
811251d4:	10c06126 	beq	r2,r3,8112535c <___svfiprintf_internal_r+0x1004>
811251d8:	00c00084 	movi	r3,2
811251dc:	10fd5526 	beq	r2,r3,81124734 <__reset+0xfb104734>
811251e0:	003ed806 	br	81124d44 <__reset+0xfb104d44>
811251e4:	d8802315 	stw	r2,140(sp)
811251e8:	98c00007 	ldb	r3,0(r19)
811251ec:	003cab06 	br	8112449c <__reset+0xfb10449c>
811251f0:	d9801a04 	addi	r6,sp,104
811251f4:	b80b883a 	mov	r5,r23
811251f8:	a809883a 	mov	r4,r21
811251fc:	11241800 	call	81124180 <__ssprint_r>
81125200:	103f651e 	bne	r2,zero,81124f98 <__reset+0xfb104f98>
81125204:	d8c01c17 	ldw	r3,112(sp)
81125208:	003f4f06 	br	81124f48 <__reset+0xfb104f48>
8112520c:	00a04534 	movhi	r2,33044
81125210:	10911e04 	addi	r2,r2,17528
81125214:	d8802915 	stw	r2,164(sp)
81125218:	003d4406 	br	8112472c <__reset+0xfb10472c>
8112521c:	dac02317 	ldw	r11,140(sp)
81125220:	58800017 	ldw	r2,0(r11)
81125224:	dac02517 	ldw	r11,148(sp)
81125228:	5807d7fa 	srai	r3,r11,31
8112522c:	dac02317 	ldw	r11,140(sp)
81125230:	10c00115 	stw	r3,4(r2)
81125234:	5ac00104 	addi	r11,r11,4
81125238:	dac02315 	stw	r11,140(sp)
8112523c:	dac02517 	ldw	r11,148(sp)
81125240:	12c00015 	stw	r11,0(r2)
81125244:	003c6d06 	br	811243fc <__reset+0xfb1043fc>
81125248:	9080100c 	andi	r2,r18,64
8112524c:	dac02317 	ldw	r11,140(sp)
81125250:	103e5326 	beq	r2,zero,81124ba0 <__reset+0xfb104ba0>
81125254:	5f00000f 	ldh	fp,0(r11)
81125258:	5ac00104 	addi	r11,r11,4
8112525c:	dac02315 	stw	r11,140(sp)
81125260:	e013d7fa 	srai	r9,fp,31
81125264:	4805883a 	mov	r2,r9
81125268:	003e0706 	br	81124a88 <__reset+0xfb104a88>
8112526c:	00800c04 	movi	r2,48
81125270:	d8801d05 	stb	r2,116(sp)
81125274:	d8c01d45 	stb	r3,117(sp)
81125278:	d8001d85 	stb	zero,118(sp)
8112527c:	90800094 	ori	r2,r18,2
81125280:	80008f16 	blt	r16,zero,811254c0 <___svfiprintf_internal_r+0x1168>
81125284:	00bfdfc4 	movi	r2,-129
81125288:	90a4703a 	and	r18,r18,r2
8112528c:	94800094 	ori	r18,r18,2
81125290:	0015883a 	mov	r10,zero
81125294:	003d2906 	br	8112473c <__reset+0xfb10473c>
81125298:	98c00007 	ldb	r3,0(r19)
8112529c:	003c7f06 	br	8112449c <__reset+0xfb10449c>
811252a0:	dac02317 	ldw	r11,140(sp)
811252a4:	0013883a 	mov	r9,zero
811252a8:	5f000017 	ldw	fp,0(r11)
811252ac:	5ac00104 	addi	r11,r11,4
811252b0:	dac02315 	stw	r11,140(sp)
811252b4:	003d1506 	br	8112470c <__reset+0xfb10470c>
811252b8:	9080100c 	andi	r2,r18,64
811252bc:	d8001d85 	stb	zero,118(sp)
811252c0:	dac02317 	ldw	r11,140(sp)
811252c4:	10003426 	beq	r2,zero,81125398 <___svfiprintf_internal_r+0x1040>
811252c8:	58800104 	addi	r2,r11,4
811252cc:	5f00000b 	ldhu	fp,0(r11)
811252d0:	0013883a 	mov	r9,zero
811252d4:	803e950e 	bge	r16,zero,81124d2c <__reset+0xfb104d2c>
811252d8:	e246b03a 	or	r3,fp,r9
811252dc:	d8802315 	stw	r2,140(sp)
811252e0:	183d5a1e 	bne	r3,zero,8112484c <__reset+0xfb10484c>
811252e4:	0015883a 	mov	r10,zero
811252e8:	0005883a 	mov	r2,zero
811252ec:	003fb706 	br	811251cc <__reset+0xfb1051cc>
811252f0:	98c00043 	ldbu	r3,1(r19)
811252f4:	94800814 	ori	r18,r18,32
811252f8:	9cc00044 	addi	r19,r19,1
811252fc:	18c03fcc 	andi	r3,r3,255
81125300:	18c0201c 	xori	r3,r3,128
81125304:	18ffe004 	addi	r3,r3,-128
81125308:	003c6406 	br	8112449c <__reset+0xfb10449c>
8112530c:	d8c02315 	stw	r3,140(sp)
81125310:	0015883a 	mov	r10,zero
81125314:	003faa06 	br	811251c0 <__reset+0xfb1051c0>
81125318:	dac02317 	ldw	r11,140(sp)
8112531c:	58800017 	ldw	r2,0(r11)
81125320:	5ac00104 	addi	r11,r11,4
81125324:	dac02315 	stw	r11,140(sp)
81125328:	dac02517 	ldw	r11,148(sp)
8112532c:	12c00015 	stw	r11,0(r2)
81125330:	003c3206 	br	811243fc <__reset+0xfb1043fc>
81125334:	01204534 	movhi	r4,33044
81125338:	21111e04 	addi	r4,r4,17528
8112533c:	d9002915 	stw	r4,164(sp)
81125340:	d8c02315 	stw	r3,140(sp)
81125344:	1025883a 	mov	r18,r2
81125348:	e244b03a 	or	r2,fp,r9
8112534c:	103f871e 	bne	r2,zero,8112516c <__reset+0xfb10516c>
81125350:	0015883a 	mov	r10,zero
81125354:	00800084 	movi	r2,2
81125358:	003f9c06 	br	811251cc <__reset+0xfb1051cc>
8112535c:	0039883a 	mov	fp,zero
81125360:	003e5f06 	br	81124ce0 <__reset+0xfb104ce0>
81125364:	d9801a04 	addi	r6,sp,104
81125368:	b80b883a 	mov	r5,r23
8112536c:	a809883a 	mov	r4,r21
81125370:	11241800 	call	81124180 <__ssprint_r>
81125374:	103f081e 	bne	r2,zero,81124f98 <__reset+0xfb104f98>
81125378:	d8c01c17 	ldw	r3,112(sp)
8112537c:	d8801b17 	ldw	r2,108(sp)
81125380:	d811883a 	mov	r8,sp
81125384:	003e9106 	br	81124dcc <__reset+0xfb104dcc>
81125388:	01204534 	movhi	r4,33044
8112538c:	2111a804 	addi	r4,r4,18080
81125390:	d9002215 	stw	r4,136(sp)
81125394:	003ead06 	br	81124e4c <__reset+0xfb104e4c>
81125398:	58800104 	addi	r2,r11,4
8112539c:	5f000017 	ldw	fp,0(r11)
811253a0:	0013883a 	mov	r9,zero
811253a4:	803e610e 	bge	r16,zero,81124d2c <__reset+0xfb104d2c>
811253a8:	003fcb06 	br	811252d8 <__reset+0xfb1052d8>
811253ac:	58800104 	addi	r2,r11,4
811253b0:	5f000017 	ldw	fp,0(r11)
811253b4:	0013883a 	mov	r9,zero
811253b8:	803e420e 	bge	r16,zero,81124cc4 <__reset+0xfb104cc4>
811253bc:	003f7e06 	br	811251b8 <__reset+0xfb1051b8>
811253c0:	5f000017 	ldw	fp,0(r11)
811253c4:	5ac00104 	addi	r11,r11,4
811253c8:	0013883a 	mov	r9,zero
811253cc:	dac02315 	stw	r11,140(sp)
811253d0:	003cce06 	br	8112470c <__reset+0xfb10470c>
811253d4:	8809883a 	mov	r4,r17
811253d8:	da002c15 	stw	r8,176(sp)
811253dc:	11172280 	call	81117228 <strlen>
811253e0:	d8802115 	stw	r2,132(sp)
811253e4:	da801d83 	ldbu	r10,118(sp)
811253e8:	df002315 	stw	fp,140(sp)
811253ec:	0021883a 	mov	r16,zero
811253f0:	da002c17 	ldw	r8,176(sp)
811253f4:	003cf606 	br	811247d0 <__reset+0xfb1047d0>
811253f8:	00800184 	movi	r2,6
811253fc:	1400012e 	bgeu	r2,r16,81125404 <___svfiprintf_internal_r+0x10ac>
81125400:	1021883a 	mov	r16,r2
81125404:	dc002115 	stw	r16,132(sp)
81125408:	8005883a 	mov	r2,r16
8112540c:	80003c16 	blt	r16,zero,81125500 <___svfiprintf_internal_r+0x11a8>
81125410:	04604534 	movhi	r17,33044
81125414:	d8802015 	stw	r2,128(sp)
81125418:	df002315 	stw	fp,140(sp)
8112541c:	8c512304 	addi	r17,r17,17548
81125420:	003d2e06 	br	811248dc <__reset+0xfb1048dc>
81125424:	04001004 	movi	r16,64
81125428:	800b883a 	mov	r5,r16
8112542c:	1115f200 	call	81115f20 <_malloc_r>
81125430:	dac02717 	ldw	r11,156(sp)
81125434:	58800015 	stw	r2,0(r11)
81125438:	58800415 	stw	r2,16(r11)
8112543c:	10004826 	beq	r2,zero,81125560 <___svfiprintf_internal_r+0x1208>
81125440:	dac02717 	ldw	r11,156(sp)
81125444:	5c000515 	stw	r16,20(r11)
81125448:	003bd906 	br	811243b0 <__reset+0xfb1043b0>
8112544c:	9080004c 	andi	r2,r18,1
81125450:	0015883a 	mov	r10,zero
81125454:	10000626 	beq	r2,zero,81125470 <___svfiprintf_internal_r+0x1118>
81125458:	dac02b17 	ldw	r11,172(sp)
8112545c:	00800c04 	movi	r2,48
81125460:	d88019c5 	stb	r2,103(sp)
81125464:	dac02115 	stw	r11,132(sp)
81125468:	dc4019c4 	addi	r17,sp,103
8112546c:	003cd806 	br	811247d0 <__reset+0xfb1047d0>
81125470:	d8002115 	stw	zero,132(sp)
81125474:	dc401a04 	addi	r17,sp,104
81125478:	003cd506 	br	811247d0 <__reset+0xfb1047d0>
8112547c:	01204534 	movhi	r4,33044
81125480:	2111ac04 	addi	r4,r4,18096
81125484:	d9002815 	stw	r4,160(sp)
81125488:	003d4306 	br	81124998 <__reset+0xfb104998>
8112548c:	00bfffc4 	movi	r2,-1
81125490:	003ec606 	br	81124fac <__reset+0xfb104fac>
81125494:	00800044 	movi	r2,1
81125498:	10803fcc 	andi	r2,r2,255
8112549c:	00c00044 	movi	r3,1
811254a0:	10fd8026 	beq	r2,r3,81124aa4 <__reset+0xfb104aa4>
811254a4:	00c00084 	movi	r3,2
811254a8:	10fca426 	beq	r2,r3,8112473c <__reset+0xfb10473c>
811254ac:	003ce806 	br	81124850 <__reset+0xfb104850>
811254b0:	01204534 	movhi	r4,33044
811254b4:	2111ac04 	addi	r4,r4,18096
811254b8:	d9002815 	stw	r4,160(sp)
811254bc:	003e9906 	br	81124f24 <__reset+0xfb104f24>
811254c0:	1025883a 	mov	r18,r2
811254c4:	0015883a 	mov	r10,zero
811254c8:	00800084 	movi	r2,2
811254cc:	003ff206 	br	81125498 <__reset+0xfb105498>
811254d0:	01604534 	movhi	r5,33044
811254d4:	2951a804 	addi	r5,r5,18080
811254d8:	d9402215 	stw	r5,136(sp)
811254dc:	003ee206 	br	81125068 <__reset+0xfb105068>
811254e0:	5827883a 	mov	r19,r11
811254e4:	0021883a 	mov	r16,zero
811254e8:	003bed06 	br	811244a0 <__reset+0xfb1044a0>
811254ec:	dc002115 	stw	r16,132(sp)
811254f0:	da801d83 	ldbu	r10,118(sp)
811254f4:	df002315 	stw	fp,140(sp)
811254f8:	0021883a 	mov	r16,zero
811254fc:	003cb406 	br	811247d0 <__reset+0xfb1047d0>
81125500:	0005883a 	mov	r2,zero
81125504:	003fc206 	br	81125410 <__reset+0xfb105410>
81125508:	d8802317 	ldw	r2,140(sp)
8112550c:	98c00043 	ldbu	r3,1(r19)
81125510:	5827883a 	mov	r19,r11
81125514:	14000017 	ldw	r16,0(r2)
81125518:	10800104 	addi	r2,r2,4
8112551c:	d8802315 	stw	r2,140(sp)
81125520:	803f760e 	bge	r16,zero,811252fc <__reset+0xfb1052fc>
81125524:	18c03fcc 	andi	r3,r3,255
81125528:	18c0201c 	xori	r3,r3,128
8112552c:	043fffc4 	movi	r16,-1
81125530:	18ffe004 	addi	r3,r3,-128
81125534:	003bd906 	br	8112449c <__reset+0xfb10449c>
81125538:	d9c01d85 	stb	r7,118(sp)
8112553c:	003cb606 	br	81124818 <__reset+0xfb104818>
81125540:	d9c01d85 	stb	r7,118(sp)
81125544:	003d2106 	br	811249cc <__reset+0xfb1049cc>
81125548:	d9c01d85 	stb	r7,118(sp)
8112554c:	003d8e06 	br	81124b88 <__reset+0xfb104b88>
81125550:	d9c01d85 	stb	r7,118(sp)
81125554:	003db306 	br	81124c24 <__reset+0xfb104c24>
81125558:	d9c01d85 	stb	r7,118(sp)
8112555c:	003c8a06 	br	81124788 <__reset+0xfb104788>
81125560:	dac02a17 	ldw	r11,168(sp)
81125564:	00800304 	movi	r2,12
81125568:	58800015 	stw	r2,0(r11)
8112556c:	00bfffc4 	movi	r2,-1
81125570:	003e8e06 	br	81124fac <__reset+0xfb104fac>
81125574:	d9c01d85 	stb	r7,118(sp)
81125578:	003dc706 	br	81124c98 <__reset+0xfb104c98>
8112557c:	d9c01d85 	stb	r7,118(sp)
81125580:	003ddf06 	br	81124d00 <__reset+0xfb104d00>
81125584:	d9c01d85 	stb	r7,118(sp)
81125588:	003d3706 	br	81124a68 <__reset+0xfb104a68>
8112558c:	d9c01d85 	stb	r7,118(sp)
81125590:	003c5406 	br	811246e4 <__reset+0xfb1046e4>
81125594:	d9c01d85 	stb	r7,118(sp)
81125598:	003d1d06 	br	81124a10 <__reset+0xfb104a10>

8112559c <__submore>:
8112559c:	defffa04 	addi	sp,sp,-24
811255a0:	de00012e 	bgeu	sp,et,811255a8 <__submore+0xc>
811255a4:	003b68fa 	trap	3
811255a8:	dc000015 	stw	r16,0(sp)
811255ac:	2821883a 	mov	r16,r5
811255b0:	29400c17 	ldw	r5,48(r5)
811255b4:	dfc00515 	stw	ra,20(sp)
811255b8:	dd000415 	stw	r20,16(sp)
811255bc:	dcc00315 	stw	r19,12(sp)
811255c0:	dc800215 	stw	r18,8(sp)
811255c4:	dc400115 	stw	r17,4(sp)
811255c8:	80801004 	addi	r2,r16,64
811255cc:	28801726 	beq	r5,r2,8112562c <__submore+0x90>
811255d0:	84400d17 	ldw	r17,52(r16)
811255d4:	8c67883a 	add	r19,r17,r17
811255d8:	980d883a 	mov	r6,r19
811255dc:	1121a280 	call	81121a28 <_realloc_r>
811255e0:	1025883a 	mov	r18,r2
811255e4:	10002226 	beq	r2,zero,81125670 <__submore+0xd4>
811255e8:	1469883a 	add	r20,r2,r17
811255ec:	880d883a 	mov	r6,r17
811255f0:	100b883a 	mov	r5,r2
811255f4:	a009883a 	mov	r4,r20
811255f8:	11167340 	call	81116734 <memcpy>
811255fc:	0005883a 	mov	r2,zero
81125600:	85000015 	stw	r20,0(r16)
81125604:	84800c15 	stw	r18,48(r16)
81125608:	84c00d15 	stw	r19,52(r16)
8112560c:	dfc00517 	ldw	ra,20(sp)
81125610:	dd000417 	ldw	r20,16(sp)
81125614:	dcc00317 	ldw	r19,12(sp)
81125618:	dc800217 	ldw	r18,8(sp)
8112561c:	dc400117 	ldw	r17,4(sp)
81125620:	dc000017 	ldw	r16,0(sp)
81125624:	dec00604 	addi	sp,sp,24
81125628:	f800283a 	ret
8112562c:	04410004 	movi	r17,1024
81125630:	880b883a 	mov	r5,r17
81125634:	1115f200 	call	81115f20 <_malloc_r>
81125638:	1007883a 	mov	r3,r2
8112563c:	10000c26 	beq	r2,zero,81125670 <__submore+0xd4>
81125640:	80801083 	ldbu	r2,66(r16)
81125644:	80c00c15 	stw	r3,48(r16)
81125648:	84400d15 	stw	r17,52(r16)
8112564c:	1880ffc5 	stb	r2,1023(r3)
81125650:	81401043 	ldbu	r5,65(r16)
81125654:	1900ff44 	addi	r4,r3,1021
81125658:	0005883a 	mov	r2,zero
8112565c:	1940ff85 	stb	r5,1022(r3)
81125660:	81401003 	ldbu	r5,64(r16)
81125664:	1940ff45 	stb	r5,1021(r3)
81125668:	81000015 	stw	r4,0(r16)
8112566c:	003fe706 	br	8112560c <__reset+0xfb10560c>
81125670:	00bfffc4 	movi	r2,-1
81125674:	003fe506 	br	8112560c <__reset+0xfb10560c>

81125678 <_ungetc_r>:
81125678:	00bfffc4 	movi	r2,-1
8112567c:	28806326 	beq	r5,r2,8112580c <_ungetc_r+0x194>
81125680:	defffb04 	addi	sp,sp,-20
81125684:	de00012e 	bgeu	sp,et,8112568c <_ungetc_r+0x14>
81125688:	003b68fa 	trap	3
8112568c:	dcc00315 	stw	r19,12(sp)
81125690:	dc400115 	stw	r17,4(sp)
81125694:	dc000015 	stw	r16,0(sp)
81125698:	dfc00415 	stw	ra,16(sp)
8112569c:	dc800215 	stw	r18,8(sp)
811256a0:	2023883a 	mov	r17,r4
811256a4:	3021883a 	mov	r16,r6
811256a8:	2827883a 	mov	r19,r5
811256ac:	20000226 	beq	r4,zero,811256b8 <_ungetc_r+0x40>
811256b0:	20800e17 	ldw	r2,56(r4)
811256b4:	10002e26 	beq	r2,zero,81125770 <_ungetc_r+0xf8>
811256b8:	80c0030b 	ldhu	r3,12(r16)
811256bc:	1888000c 	andi	r2,r3,8192
811256c0:	1000051e 	bne	r2,zero,811256d8 <_ungetc_r+0x60>
811256c4:	81001917 	ldw	r4,100(r16)
811256c8:	00b7ffc4 	movi	r2,-8193
811256cc:	18c80014 	ori	r3,r3,8192
811256d0:	2084703a 	and	r2,r4,r2
811256d4:	80801915 	stw	r2,100(r16)
811256d8:	00bff7c4 	movi	r2,-33
811256dc:	1884703a 	and	r2,r3,r2
811256e0:	8080030d 	sth	r2,12(r16)
811256e4:	1900010c 	andi	r4,r3,4
811256e8:	2000061e 	bne	r4,zero,81125704 <_ungetc_r+0x8c>
811256ec:	1900040c 	andi	r4,r3,16
811256f0:	20001d26 	beq	r4,zero,81125768 <_ungetc_r+0xf0>
811256f4:	18c0020c 	andi	r3,r3,8
811256f8:	1800331e 	bne	r3,zero,811257c8 <_ungetc_r+0x150>
811256fc:	10800114 	ori	r2,r2,4
81125700:	8080030d 	sth	r2,12(r16)
81125704:	80800c17 	ldw	r2,48(r16)
81125708:	9c803fcc 	andi	r18,r19,255
8112570c:	10001a26 	beq	r2,zero,81125778 <_ungetc_r+0x100>
81125710:	80c00117 	ldw	r3,4(r16)
81125714:	80800d17 	ldw	r2,52(r16)
81125718:	18800f0e 	bge	r3,r2,81125758 <_ungetc_r+0xe0>
8112571c:	80c00017 	ldw	r3,0(r16)
81125720:	9005883a 	mov	r2,r18
81125724:	193fffc4 	addi	r4,r3,-1
81125728:	81000015 	stw	r4,0(r16)
8112572c:	1cffffc5 	stb	r19,-1(r3)
81125730:	80c00117 	ldw	r3,4(r16)
81125734:	18c00044 	addi	r3,r3,1
81125738:	80c00115 	stw	r3,4(r16)
8112573c:	dfc00417 	ldw	ra,16(sp)
81125740:	dcc00317 	ldw	r19,12(sp)
81125744:	dc800217 	ldw	r18,8(sp)
81125748:	dc400117 	ldw	r17,4(sp)
8112574c:	dc000017 	ldw	r16,0(sp)
81125750:	dec00504 	addi	sp,sp,20
81125754:	f800283a 	ret
81125758:	800b883a 	mov	r5,r16
8112575c:	8809883a 	mov	r4,r17
81125760:	112559c0 	call	8112559c <__submore>
81125764:	103fed26 	beq	r2,zero,8112571c <__reset+0xfb10571c>
81125768:	00bfffc4 	movi	r2,-1
8112576c:	003ff306 	br	8112573c <__reset+0xfb10573c>
81125770:	111f4fc0 	call	8111f4fc <__sinit>
81125774:	003fd006 	br	811256b8 <__reset+0xfb1056b8>
81125778:	80c00417 	ldw	r3,16(r16)
8112577c:	80800017 	ldw	r2,0(r16)
81125780:	18000326 	beq	r3,zero,81125790 <_ungetc_r+0x118>
81125784:	1880022e 	bgeu	r3,r2,81125790 <_ungetc_r+0x118>
81125788:	10ffffc3 	ldbu	r3,-1(r2)
8112578c:	90c01826 	beq	r18,r3,811257f0 <_ungetc_r+0x178>
81125790:	81400117 	ldw	r5,4(r16)
81125794:	80800e15 	stw	r2,56(r16)
81125798:	008000c4 	movi	r2,3
8112579c:	81001004 	addi	r4,r16,64
811257a0:	80c01084 	addi	r3,r16,66
811257a4:	80800d15 	stw	r2,52(r16)
811257a8:	00800044 	movi	r2,1
811257ac:	80800115 	stw	r2,4(r16)
811257b0:	81400f15 	stw	r5,60(r16)
811257b4:	81000c15 	stw	r4,48(r16)
811257b8:	84c01085 	stb	r19,66(r16)
811257bc:	80c00015 	stw	r3,0(r16)
811257c0:	9005883a 	mov	r2,r18
811257c4:	003fdd06 	br	8112573c <__reset+0xfb10573c>
811257c8:	800b883a 	mov	r5,r16
811257cc:	8809883a 	mov	r4,r17
811257d0:	111f1000 	call	8111f100 <_fflush_r>
811257d4:	103fe41e 	bne	r2,zero,81125768 <__reset+0xfb105768>
811257d8:	8080030b 	ldhu	r2,12(r16)
811257dc:	00fffdc4 	movi	r3,-9
811257e0:	80000215 	stw	zero,8(r16)
811257e4:	1884703a 	and	r2,r3,r2
811257e8:	80000615 	stw	zero,24(r16)
811257ec:	003fc306 	br	811256fc <__reset+0xfb1056fc>
811257f0:	80c00117 	ldw	r3,4(r16)
811257f4:	10bfffc4 	addi	r2,r2,-1
811257f8:	80800015 	stw	r2,0(r16)
811257fc:	18800044 	addi	r2,r3,1
81125800:	80800115 	stw	r2,4(r16)
81125804:	9005883a 	mov	r2,r18
81125808:	003fcc06 	br	8112573c <__reset+0xfb10573c>
8112580c:	00bfffc4 	movi	r2,-1
81125810:	f800283a 	ret

81125814 <ungetc>:
81125814:	00a04534 	movhi	r2,33044
81125818:	109aed04 	addi	r2,r2,27572
8112581c:	280d883a 	mov	r6,r5
81125820:	200b883a 	mov	r5,r4
81125824:	11000017 	ldw	r4,0(r2)
81125828:	11256781 	jmpi	81125678 <_ungetc_r>

8112582c <__sprint_r.part.0>:
8112582c:	defff604 	addi	sp,sp,-40
81125830:	de00012e 	bgeu	sp,et,81125838 <__sprint_r.part.0+0xc>
81125834:	003b68fa 	trap	3
81125838:	28801917 	ldw	r2,100(r5)
8112583c:	dd400515 	stw	r21,20(sp)
81125840:	dfc00915 	stw	ra,36(sp)
81125844:	df000815 	stw	fp,32(sp)
81125848:	ddc00715 	stw	r23,28(sp)
8112584c:	dd800615 	stw	r22,24(sp)
81125850:	dd000415 	stw	r20,16(sp)
81125854:	dcc00315 	stw	r19,12(sp)
81125858:	dc800215 	stw	r18,8(sp)
8112585c:	dc400115 	stw	r17,4(sp)
81125860:	dc000015 	stw	r16,0(sp)
81125864:	1088000c 	andi	r2,r2,8192
81125868:	302b883a 	mov	r21,r6
8112586c:	10002e26 	beq	r2,zero,81125928 <__sprint_r.part.0+0xfc>
81125870:	30800217 	ldw	r2,8(r6)
81125874:	35800017 	ldw	r22,0(r6)
81125878:	10002926 	beq	r2,zero,81125920 <__sprint_r.part.0+0xf4>
8112587c:	2827883a 	mov	r19,r5
81125880:	2029883a 	mov	r20,r4
81125884:	b5c00104 	addi	r23,r22,4
81125888:	04bfffc4 	movi	r18,-1
8112588c:	bc400017 	ldw	r17,0(r23)
81125890:	b4000017 	ldw	r16,0(r22)
81125894:	0039883a 	mov	fp,zero
81125898:	8822d0ba 	srli	r17,r17,2
8112589c:	8800031e 	bne	r17,zero,811258ac <__sprint_r.part.0+0x80>
811258a0:	00001806 	br	81125904 <__sprint_r.part.0+0xd8>
811258a4:	84000104 	addi	r16,r16,4
811258a8:	8f001526 	beq	r17,fp,81125900 <__sprint_r.part.0+0xd4>
811258ac:	81400017 	ldw	r5,0(r16)
811258b0:	980d883a 	mov	r6,r19
811258b4:	a009883a 	mov	r4,r20
811258b8:	11271d00 	call	811271d0 <_fputwc_r>
811258bc:	e7000044 	addi	fp,fp,1
811258c0:	14bff81e 	bne	r2,r18,811258a4 <__reset+0xfb1058a4>
811258c4:	9005883a 	mov	r2,r18
811258c8:	a8000215 	stw	zero,8(r21)
811258cc:	a8000115 	stw	zero,4(r21)
811258d0:	dfc00917 	ldw	ra,36(sp)
811258d4:	df000817 	ldw	fp,32(sp)
811258d8:	ddc00717 	ldw	r23,28(sp)
811258dc:	dd800617 	ldw	r22,24(sp)
811258e0:	dd400517 	ldw	r21,20(sp)
811258e4:	dd000417 	ldw	r20,16(sp)
811258e8:	dcc00317 	ldw	r19,12(sp)
811258ec:	dc800217 	ldw	r18,8(sp)
811258f0:	dc400117 	ldw	r17,4(sp)
811258f4:	dc000017 	ldw	r16,0(sp)
811258f8:	dec00a04 	addi	sp,sp,40
811258fc:	f800283a 	ret
81125900:	a8800217 	ldw	r2,8(r21)
81125904:	8c63883a 	add	r17,r17,r17
81125908:	8c63883a 	add	r17,r17,r17
8112590c:	1445c83a 	sub	r2,r2,r17
81125910:	a8800215 	stw	r2,8(r21)
81125914:	b5800204 	addi	r22,r22,8
81125918:	bdc00204 	addi	r23,r23,8
8112591c:	103fdb1e 	bne	r2,zero,8112588c <__reset+0xfb10588c>
81125920:	0005883a 	mov	r2,zero
81125924:	003fe806 	br	811258c8 <__reset+0xfb1058c8>
81125928:	111fcac0 	call	8111fcac <__sfvwrite_r>
8112592c:	003fe606 	br	811258c8 <__reset+0xfb1058c8>

81125930 <__sprint_r>:
81125930:	30c00217 	ldw	r3,8(r6)
81125934:	18000126 	beq	r3,zero,8112593c <__sprint_r+0xc>
81125938:	112582c1 	jmpi	8112582c <__sprint_r.part.0>
8112593c:	30000115 	stw	zero,4(r6)
81125940:	0005883a 	mov	r2,zero
81125944:	f800283a 	ret

81125948 <___vfiprintf_internal_r>:
81125948:	deffc904 	addi	sp,sp,-220
8112594c:	de00012e 	bgeu	sp,et,81125954 <___vfiprintf_internal_r+0xc>
81125950:	003b68fa 	trap	3
81125954:	df003515 	stw	fp,212(sp)
81125958:	dd003115 	stw	r20,196(sp)
8112595c:	dfc03615 	stw	ra,216(sp)
81125960:	ddc03415 	stw	r23,208(sp)
81125964:	dd803315 	stw	r22,204(sp)
81125968:	dd403215 	stw	r21,200(sp)
8112596c:	dcc03015 	stw	r19,192(sp)
81125970:	dc802f15 	stw	r18,188(sp)
81125974:	dc402e15 	stw	r17,184(sp)
81125978:	dc002d15 	stw	r16,180(sp)
8112597c:	d9002015 	stw	r4,128(sp)
81125980:	d9c02215 	stw	r7,136(sp)
81125984:	2829883a 	mov	r20,r5
81125988:	3039883a 	mov	fp,r6
8112598c:	20000226 	beq	r4,zero,81125998 <___vfiprintf_internal_r+0x50>
81125990:	20800e17 	ldw	r2,56(r4)
81125994:	1000cf26 	beq	r2,zero,81125cd4 <___vfiprintf_internal_r+0x38c>
81125998:	a080030b 	ldhu	r2,12(r20)
8112599c:	10c8000c 	andi	r3,r2,8192
811259a0:	1800061e 	bne	r3,zero,811259bc <___vfiprintf_internal_r+0x74>
811259a4:	a1001917 	ldw	r4,100(r20)
811259a8:	00f7ffc4 	movi	r3,-8193
811259ac:	10880014 	ori	r2,r2,8192
811259b0:	20c6703a 	and	r3,r4,r3
811259b4:	a080030d 	sth	r2,12(r20)
811259b8:	a0c01915 	stw	r3,100(r20)
811259bc:	10c0020c 	andi	r3,r2,8
811259c0:	1800a926 	beq	r3,zero,81125c68 <___vfiprintf_internal_r+0x320>
811259c4:	a0c00417 	ldw	r3,16(r20)
811259c8:	1800a726 	beq	r3,zero,81125c68 <___vfiprintf_internal_r+0x320>
811259cc:	1080068c 	andi	r2,r2,26
811259d0:	00c00284 	movi	r3,10
811259d4:	10c0ac26 	beq	r2,r3,81125c88 <___vfiprintf_internal_r+0x340>
811259d8:	da801a04 	addi	r10,sp,104
811259dc:	da801e15 	stw	r10,120(sp)
811259e0:	d8801e17 	ldw	r2,120(sp)
811259e4:	da8019c4 	addi	r10,sp,103
811259e8:	05a04534 	movhi	r22,33044
811259ec:	05e04534 	movhi	r23,33044
811259f0:	da801f15 	stw	r10,124(sp)
811259f4:	1295c83a 	sub	r10,r2,r10
811259f8:	b591b404 	addi	r22,r22,18128
811259fc:	bdd1b004 	addi	r23,r23,18112
81125a00:	dec01a15 	stw	sp,104(sp)
81125a04:	d8001c15 	stw	zero,112(sp)
81125a08:	d8001b15 	stw	zero,108(sp)
81125a0c:	d8002615 	stw	zero,152(sp)
81125a10:	d8002315 	stw	zero,140(sp)
81125a14:	da802715 	stw	r10,156(sp)
81125a18:	d811883a 	mov	r8,sp
81125a1c:	dd002115 	stw	r20,132(sp)
81125a20:	e021883a 	mov	r16,fp
81125a24:	80800007 	ldb	r2,0(r16)
81125a28:	1003ea26 	beq	r2,zero,811269d4 <___vfiprintf_internal_r+0x108c>
81125a2c:	00c00944 	movi	r3,37
81125a30:	8025883a 	mov	r18,r16
81125a34:	10c0021e 	bne	r2,r3,81125a40 <___vfiprintf_internal_r+0xf8>
81125a38:	00001606 	br	81125a94 <___vfiprintf_internal_r+0x14c>
81125a3c:	10c00326 	beq	r2,r3,81125a4c <___vfiprintf_internal_r+0x104>
81125a40:	94800044 	addi	r18,r18,1
81125a44:	90800007 	ldb	r2,0(r18)
81125a48:	103ffc1e 	bne	r2,zero,81125a3c <__reset+0xfb105a3c>
81125a4c:	9423c83a 	sub	r17,r18,r16
81125a50:	88001026 	beq	r17,zero,81125a94 <___vfiprintf_internal_r+0x14c>
81125a54:	d8c01c17 	ldw	r3,112(sp)
81125a58:	d8801b17 	ldw	r2,108(sp)
81125a5c:	44000015 	stw	r16,0(r8)
81125a60:	88c7883a 	add	r3,r17,r3
81125a64:	10800044 	addi	r2,r2,1
81125a68:	44400115 	stw	r17,4(r8)
81125a6c:	d8c01c15 	stw	r3,112(sp)
81125a70:	d8801b15 	stw	r2,108(sp)
81125a74:	010001c4 	movi	r4,7
81125a78:	2080760e 	bge	r4,r2,81125c54 <___vfiprintf_internal_r+0x30c>
81125a7c:	1803821e 	bne	r3,zero,81126888 <___vfiprintf_internal_r+0xf40>
81125a80:	da802317 	ldw	r10,140(sp)
81125a84:	d8001b15 	stw	zero,108(sp)
81125a88:	d811883a 	mov	r8,sp
81125a8c:	5455883a 	add	r10,r10,r17
81125a90:	da802315 	stw	r10,140(sp)
81125a94:	90800007 	ldb	r2,0(r18)
81125a98:	10044626 	beq	r2,zero,81126bb4 <___vfiprintf_internal_r+0x126c>
81125a9c:	90c00047 	ldb	r3,1(r18)
81125aa0:	94000044 	addi	r16,r18,1
81125aa4:	d8001d85 	stb	zero,118(sp)
81125aa8:	0009883a 	mov	r4,zero
81125aac:	000f883a 	mov	r7,zero
81125ab0:	027fffc4 	movi	r9,-1
81125ab4:	0023883a 	mov	r17,zero
81125ab8:	0029883a 	mov	r20,zero
81125abc:	01401604 	movi	r5,88
81125ac0:	01800244 	movi	r6,9
81125ac4:	03400a84 	movi	r13,42
81125ac8:	03001b04 	movi	r12,108
81125acc:	84000044 	addi	r16,r16,1
81125ad0:	18bff804 	addi	r2,r3,-32
81125ad4:	28827336 	bltu	r5,r2,811264a4 <___vfiprintf_internal_r+0xb5c>
81125ad8:	100490ba 	slli	r2,r2,2
81125adc:	02a044b4 	movhi	r10,33042
81125ae0:	5296bc04 	addi	r10,r10,23280
81125ae4:	1285883a 	add	r2,r2,r10
81125ae8:	10800017 	ldw	r2,0(r2)
81125aec:	1000683a 	jmp	r2
81125af0:	811261d8 	cmpnei	r4,r16,18823
81125af4:	811264a4 	muli	r4,r16,18834
81125af8:	811264a4 	muli	r4,r16,18834
81125afc:	811261f8 	rdprs	r4,r16,18823
81125b00:	811264a4 	muli	r4,r16,18834
81125b04:	811264a4 	muli	r4,r16,18834
81125b08:	811264a4 	muli	r4,r16,18834
81125b0c:	811264a4 	muli	r4,r16,18834
81125b10:	811264a4 	muli	r4,r16,18834
81125b14:	811264a4 	muli	r4,r16,18834
81125b18:	811263e0 	cmpeqi	r4,r16,18831
81125b1c:	811263fc 	xorhi	r4,r16,18831
81125b20:	811264a4 	muli	r4,r16,18834
81125b24:	81125ce4 	muli	r4,r16,18803
81125b28:	8112640c 	andi	r4,r16,18832
81125b2c:	811264a4 	muli	r4,r16,18834
81125b30:	81126204 	addi	r4,r16,18824
81125b34:	81126210 	cmplti	r4,r16,18824
81125b38:	81126210 	cmplti	r4,r16,18824
81125b3c:	81126210 	cmplti	r4,r16,18824
81125b40:	81126210 	cmplti	r4,r16,18824
81125b44:	81126210 	cmplti	r4,r16,18824
81125b48:	81126210 	cmplti	r4,r16,18824
81125b4c:	81126210 	cmplti	r4,r16,18824
81125b50:	81126210 	cmplti	r4,r16,18824
81125b54:	81126210 	cmplti	r4,r16,18824
81125b58:	811264a4 	muli	r4,r16,18834
81125b5c:	811264a4 	muli	r4,r16,18834
81125b60:	811264a4 	muli	r4,r16,18834
81125b64:	811264a4 	muli	r4,r16,18834
81125b68:	811264a4 	muli	r4,r16,18834
81125b6c:	811264a4 	muli	r4,r16,18834
81125b70:	811264a4 	muli	r4,r16,18834
81125b74:	811264a4 	muli	r4,r16,18834
81125b78:	811264a4 	muli	r4,r16,18834
81125b7c:	811264a4 	muli	r4,r16,18834
81125b80:	8112623c 	xorhi	r4,r16,18824
81125b84:	811264a4 	muli	r4,r16,18834
81125b88:	811264a4 	muli	r4,r16,18834
81125b8c:	811264a4 	muli	r4,r16,18834
81125b90:	811264a4 	muli	r4,r16,18834
81125b94:	811264a4 	muli	r4,r16,18834
81125b98:	811264a4 	muli	r4,r16,18834
81125b9c:	811264a4 	muli	r4,r16,18834
81125ba0:	811264a4 	muli	r4,r16,18834
81125ba4:	811264a4 	muli	r4,r16,18834
81125ba8:	811264a4 	muli	r4,r16,18834
81125bac:	81126274 	orhi	r4,r16,18825
81125bb0:	811264a4 	muli	r4,r16,18834
81125bb4:	811264a4 	muli	r4,r16,18834
81125bb8:	811264a4 	muli	r4,r16,18834
81125bbc:	811264a4 	muli	r4,r16,18834
81125bc0:	811264a4 	muli	r4,r16,18834
81125bc4:	811262cc 	andi	r4,r16,18827
81125bc8:	811264a4 	muli	r4,r16,18834
81125bcc:	811264a4 	muli	r4,r16,18834
81125bd0:	8112633c 	xorhi	r4,r16,18828
81125bd4:	811264a4 	muli	r4,r16,18834
81125bd8:	811264a4 	muli	r4,r16,18834
81125bdc:	811264a4 	muli	r4,r16,18834
81125be0:	811264a4 	muli	r4,r16,18834
81125be4:	811264a4 	muli	r4,r16,18834
81125be8:	811264a4 	muli	r4,r16,18834
81125bec:	811264a4 	muli	r4,r16,18834
81125bf0:	811264a4 	muli	r4,r16,18834
81125bf4:	811264a4 	muli	r4,r16,18834
81125bf8:	811264a4 	muli	r4,r16,18834
81125bfc:	811260e8 	cmpgeui	r4,r16,18819
81125c00:	81126114 	ori	r4,r16,18820
81125c04:	811264a4 	muli	r4,r16,18834
81125c08:	811264a4 	muli	r4,r16,18834
81125c0c:	811264a4 	muli	r4,r16,18834
81125c10:	8112644c 	andi	r4,r16,18833
81125c14:	81126114 	ori	r4,r16,18820
81125c18:	811264a4 	muli	r4,r16,18834
81125c1c:	811264a4 	muli	r4,r16,18834
81125c20:	81125fa8 	cmpgeui	r4,r16,18814
81125c24:	811264a4 	muli	r4,r16,18834
81125c28:	81125fb8 	rdprs	r4,r16,18814
81125c2c:	81125ff4 	orhi	r4,r16,18815
81125c30:	81125cf0 	cmpltui	r4,r16,18803
81125c34:	81125f9c 	xori	r4,r16,18814
81125c38:	811264a4 	muli	r4,r16,18834
81125c3c:	81126378 	rdprs	r4,r16,18829
81125c40:	811264a4 	muli	r4,r16,18834
81125c44:	811263d0 	cmplti	r4,r16,18831
81125c48:	811264a4 	muli	r4,r16,18834
81125c4c:	811264a4 	muli	r4,r16,18834
81125c50:	81126094 	ori	r4,r16,18818
81125c54:	42000204 	addi	r8,r8,8
81125c58:	da802317 	ldw	r10,140(sp)
81125c5c:	5455883a 	add	r10,r10,r17
81125c60:	da802315 	stw	r10,140(sp)
81125c64:	003f8b06 	br	81125a94 <__reset+0xfb105a94>
81125c68:	d9002017 	ldw	r4,128(sp)
81125c6c:	a00b883a 	mov	r5,r20
81125c70:	111d48c0 	call	8111d48c <__swsetup_r>
81125c74:	1003b11e 	bne	r2,zero,81126b3c <___vfiprintf_internal_r+0x11f4>
81125c78:	a080030b 	ldhu	r2,12(r20)
81125c7c:	00c00284 	movi	r3,10
81125c80:	1080068c 	andi	r2,r2,26
81125c84:	10ff541e 	bne	r2,r3,811259d8 <__reset+0xfb1059d8>
81125c88:	a080038f 	ldh	r2,14(r20)
81125c8c:	103f5216 	blt	r2,zero,811259d8 <__reset+0xfb1059d8>
81125c90:	d9c02217 	ldw	r7,136(sp)
81125c94:	d9002017 	ldw	r4,128(sp)
81125c98:	e00d883a 	mov	r6,fp
81125c9c:	a00b883a 	mov	r5,r20
81125ca0:	1126dc80 	call	81126dc8 <__sbprintf>
81125ca4:	dfc03617 	ldw	ra,216(sp)
81125ca8:	df003517 	ldw	fp,212(sp)
81125cac:	ddc03417 	ldw	r23,208(sp)
81125cb0:	dd803317 	ldw	r22,204(sp)
81125cb4:	dd403217 	ldw	r21,200(sp)
81125cb8:	dd003117 	ldw	r20,196(sp)
81125cbc:	dcc03017 	ldw	r19,192(sp)
81125cc0:	dc802f17 	ldw	r18,188(sp)
81125cc4:	dc402e17 	ldw	r17,184(sp)
81125cc8:	dc002d17 	ldw	r16,180(sp)
81125ccc:	dec03704 	addi	sp,sp,220
81125cd0:	f800283a 	ret
81125cd4:	111f4fc0 	call	8111f4fc <__sinit>
81125cd8:	003f2f06 	br	81125998 <__reset+0xfb105998>
81125cdc:	0463c83a 	sub	r17,zero,r17
81125ce0:	d8802215 	stw	r2,136(sp)
81125ce4:	a5000114 	ori	r20,r20,4
81125ce8:	80c00007 	ldb	r3,0(r16)
81125cec:	003f7706 	br	81125acc <__reset+0xfb105acc>
81125cf0:	00800c04 	movi	r2,48
81125cf4:	da802217 	ldw	r10,136(sp)
81125cf8:	d8801d05 	stb	r2,116(sp)
81125cfc:	00801e04 	movi	r2,120
81125d00:	d8801d45 	stb	r2,117(sp)
81125d04:	d8001d85 	stb	zero,118(sp)
81125d08:	50c00104 	addi	r3,r10,4
81125d0c:	54800017 	ldw	r18,0(r10)
81125d10:	0027883a 	mov	r19,zero
81125d14:	a0800094 	ori	r2,r20,2
81125d18:	48030b16 	blt	r9,zero,81126948 <___vfiprintf_internal_r+0x1000>
81125d1c:	00bfdfc4 	movi	r2,-129
81125d20:	a096703a 	and	r11,r20,r2
81125d24:	d8c02215 	stw	r3,136(sp)
81125d28:	5d000094 	ori	r20,r11,2
81125d2c:	90032b1e 	bne	r18,zero,811269dc <___vfiprintf_internal_r+0x1094>
81125d30:	00a04534 	movhi	r2,33044
81125d34:	10911e04 	addi	r2,r2,17528
81125d38:	d8802615 	stw	r2,152(sp)
81125d3c:	0039883a 	mov	fp,zero
81125d40:	48017b1e 	bne	r9,zero,81126330 <___vfiprintf_internal_r+0x9e8>
81125d44:	0013883a 	mov	r9,zero
81125d48:	0027883a 	mov	r19,zero
81125d4c:	dd401a04 	addi	r21,sp,104
81125d50:	4825883a 	mov	r18,r9
81125d54:	4cc0010e 	bge	r9,r19,81125d5c <___vfiprintf_internal_r+0x414>
81125d58:	9825883a 	mov	r18,r19
81125d5c:	e7003fcc 	andi	fp,fp,255
81125d60:	e700201c 	xori	fp,fp,128
81125d64:	e73fe004 	addi	fp,fp,-128
81125d68:	e0000126 	beq	fp,zero,81125d70 <___vfiprintf_internal_r+0x428>
81125d6c:	94800044 	addi	r18,r18,1
81125d70:	a380008c 	andi	r14,r20,2
81125d74:	70000126 	beq	r14,zero,81125d7c <___vfiprintf_internal_r+0x434>
81125d78:	94800084 	addi	r18,r18,2
81125d7c:	a700210c 	andi	fp,r20,132
81125d80:	e001df1e 	bne	fp,zero,81126500 <___vfiprintf_internal_r+0xbb8>
81125d84:	8c87c83a 	sub	r3,r17,r18
81125d88:	00c1dd0e 	bge	zero,r3,81126500 <___vfiprintf_internal_r+0xbb8>
81125d8c:	01c00404 	movi	r7,16
81125d90:	d8801c17 	ldw	r2,112(sp)
81125d94:	38c3ad0e 	bge	r7,r3,81126c4c <___vfiprintf_internal_r+0x1304>
81125d98:	02a04534 	movhi	r10,33044
81125d9c:	5291b404 	addi	r10,r10,18128
81125da0:	dc002915 	stw	r16,164(sp)
81125da4:	d9801b17 	ldw	r6,108(sp)
81125da8:	da802415 	stw	r10,144(sp)
81125dac:	03c001c4 	movi	r15,7
81125db0:	da402515 	stw	r9,148(sp)
81125db4:	db802815 	stw	r14,160(sp)
81125db8:	1821883a 	mov	r16,r3
81125dbc:	00000506 	br	81125dd4 <___vfiprintf_internal_r+0x48c>
81125dc0:	31400084 	addi	r5,r6,2
81125dc4:	42000204 	addi	r8,r8,8
81125dc8:	200d883a 	mov	r6,r4
81125dcc:	843ffc04 	addi	r16,r16,-16
81125dd0:	3c000d0e 	bge	r7,r16,81125e08 <___vfiprintf_internal_r+0x4c0>
81125dd4:	10800404 	addi	r2,r2,16
81125dd8:	31000044 	addi	r4,r6,1
81125ddc:	45800015 	stw	r22,0(r8)
81125de0:	41c00115 	stw	r7,4(r8)
81125de4:	d8801c15 	stw	r2,112(sp)
81125de8:	d9001b15 	stw	r4,108(sp)
81125dec:	793ff40e 	bge	r15,r4,81125dc0 <__reset+0xfb105dc0>
81125df0:	1001b51e 	bne	r2,zero,811264c8 <___vfiprintf_internal_r+0xb80>
81125df4:	843ffc04 	addi	r16,r16,-16
81125df8:	000d883a 	mov	r6,zero
81125dfc:	01400044 	movi	r5,1
81125e00:	d811883a 	mov	r8,sp
81125e04:	3c3ff316 	blt	r7,r16,81125dd4 <__reset+0xfb105dd4>
81125e08:	8007883a 	mov	r3,r16
81125e0c:	da402517 	ldw	r9,148(sp)
81125e10:	db802817 	ldw	r14,160(sp)
81125e14:	dc002917 	ldw	r16,164(sp)
81125e18:	da802417 	ldw	r10,144(sp)
81125e1c:	1885883a 	add	r2,r3,r2
81125e20:	40c00115 	stw	r3,4(r8)
81125e24:	42800015 	stw	r10,0(r8)
81125e28:	d8801c15 	stw	r2,112(sp)
81125e2c:	d9401b15 	stw	r5,108(sp)
81125e30:	00c001c4 	movi	r3,7
81125e34:	19426016 	blt	r3,r5,811267b8 <___vfiprintf_internal_r+0xe70>
81125e38:	d8c01d87 	ldb	r3,118(sp)
81125e3c:	42000204 	addi	r8,r8,8
81125e40:	29000044 	addi	r4,r5,1
81125e44:	1801b31e 	bne	r3,zero,81126514 <___vfiprintf_internal_r+0xbcc>
81125e48:	7001c026 	beq	r14,zero,8112654c <___vfiprintf_internal_r+0xc04>
81125e4c:	d8c01d04 	addi	r3,sp,116
81125e50:	10800084 	addi	r2,r2,2
81125e54:	40c00015 	stw	r3,0(r8)
81125e58:	00c00084 	movi	r3,2
81125e5c:	40c00115 	stw	r3,4(r8)
81125e60:	d8801c15 	stw	r2,112(sp)
81125e64:	d9001b15 	stw	r4,108(sp)
81125e68:	00c001c4 	movi	r3,7
81125e6c:	1902650e 	bge	r3,r4,81126804 <___vfiprintf_internal_r+0xebc>
81125e70:	10029a1e 	bne	r2,zero,811268dc <___vfiprintf_internal_r+0xf94>
81125e74:	00c02004 	movi	r3,128
81125e78:	01000044 	movi	r4,1
81125e7c:	000b883a 	mov	r5,zero
81125e80:	d811883a 	mov	r8,sp
81125e84:	e0c1b31e 	bne	fp,r3,81126554 <___vfiprintf_internal_r+0xc0c>
81125e88:	8cb9c83a 	sub	fp,r17,r18
81125e8c:	0701b10e 	bge	zero,fp,81126554 <___vfiprintf_internal_r+0xc0c>
81125e90:	01c00404 	movi	r7,16
81125e94:	3f03890e 	bge	r7,fp,81126cbc <___vfiprintf_internal_r+0x1374>
81125e98:	00e04534 	movhi	r3,33044
81125e9c:	18d1b004 	addi	r3,r3,18112
81125ea0:	d8c02415 	stw	r3,144(sp)
81125ea4:	8007883a 	mov	r3,r16
81125ea8:	034001c4 	movi	r13,7
81125eac:	e021883a 	mov	r16,fp
81125eb0:	da402515 	stw	r9,148(sp)
81125eb4:	1839883a 	mov	fp,r3
81125eb8:	00000506 	br	81125ed0 <___vfiprintf_internal_r+0x588>
81125ebc:	29800084 	addi	r6,r5,2
81125ec0:	42000204 	addi	r8,r8,8
81125ec4:	180b883a 	mov	r5,r3
81125ec8:	843ffc04 	addi	r16,r16,-16
81125ecc:	3c000d0e 	bge	r7,r16,81125f04 <___vfiprintf_internal_r+0x5bc>
81125ed0:	10800404 	addi	r2,r2,16
81125ed4:	28c00044 	addi	r3,r5,1
81125ed8:	45c00015 	stw	r23,0(r8)
81125edc:	41c00115 	stw	r7,4(r8)
81125ee0:	d8801c15 	stw	r2,112(sp)
81125ee4:	d8c01b15 	stw	r3,108(sp)
81125ee8:	68fff40e 	bge	r13,r3,81125ebc <__reset+0xfb105ebc>
81125eec:	1002241e 	bne	r2,zero,81126780 <___vfiprintf_internal_r+0xe38>
81125ef0:	843ffc04 	addi	r16,r16,-16
81125ef4:	01800044 	movi	r6,1
81125ef8:	000b883a 	mov	r5,zero
81125efc:	d811883a 	mov	r8,sp
81125f00:	3c3ff316 	blt	r7,r16,81125ed0 <__reset+0xfb105ed0>
81125f04:	da402517 	ldw	r9,148(sp)
81125f08:	e007883a 	mov	r3,fp
81125f0c:	8039883a 	mov	fp,r16
81125f10:	1821883a 	mov	r16,r3
81125f14:	d8c02417 	ldw	r3,144(sp)
81125f18:	1705883a 	add	r2,r2,fp
81125f1c:	47000115 	stw	fp,4(r8)
81125f20:	40c00015 	stw	r3,0(r8)
81125f24:	d8801c15 	stw	r2,112(sp)
81125f28:	d9801b15 	stw	r6,108(sp)
81125f2c:	00c001c4 	movi	r3,7
81125f30:	19827616 	blt	r3,r6,8112690c <___vfiprintf_internal_r+0xfc4>
81125f34:	4cf9c83a 	sub	fp,r9,r19
81125f38:	42000204 	addi	r8,r8,8
81125f3c:	31000044 	addi	r4,r6,1
81125f40:	300b883a 	mov	r5,r6
81125f44:	07018516 	blt	zero,fp,8112655c <___vfiprintf_internal_r+0xc14>
81125f48:	9885883a 	add	r2,r19,r2
81125f4c:	45400015 	stw	r21,0(r8)
81125f50:	44c00115 	stw	r19,4(r8)
81125f54:	d8801c15 	stw	r2,112(sp)
81125f58:	d9001b15 	stw	r4,108(sp)
81125f5c:	00c001c4 	movi	r3,7
81125f60:	1901dd0e 	bge	r3,r4,811266d8 <___vfiprintf_internal_r+0xd90>
81125f64:	1002401e 	bne	r2,zero,81126868 <___vfiprintf_internal_r+0xf20>
81125f68:	d8001b15 	stw	zero,108(sp)
81125f6c:	a2c0010c 	andi	r11,r20,4
81125f70:	58000226 	beq	r11,zero,81125f7c <___vfiprintf_internal_r+0x634>
81125f74:	8ca7c83a 	sub	r19,r17,r18
81125f78:	04c2f216 	blt	zero,r19,81126b44 <___vfiprintf_internal_r+0x11fc>
81125f7c:	8c80010e 	bge	r17,r18,81125f84 <___vfiprintf_internal_r+0x63c>
81125f80:	9023883a 	mov	r17,r18
81125f84:	da802317 	ldw	r10,140(sp)
81125f88:	5455883a 	add	r10,r10,r17
81125f8c:	da802315 	stw	r10,140(sp)
81125f90:	d8001b15 	stw	zero,108(sp)
81125f94:	d811883a 	mov	r8,sp
81125f98:	003ea206 	br	81125a24 <__reset+0xfb105a24>
81125f9c:	a5000814 	ori	r20,r20,32
81125fa0:	80c00007 	ldb	r3,0(r16)
81125fa4:	003ec906 	br	81125acc <__reset+0xfb105acc>
81125fa8:	80c00007 	ldb	r3,0(r16)
81125fac:	1b030926 	beq	r3,r12,81126bd4 <___vfiprintf_internal_r+0x128c>
81125fb0:	a5000414 	ori	r20,r20,16
81125fb4:	003ec506 	br	81125acc <__reset+0xfb105acc>
81125fb8:	21003fcc 	andi	r4,r4,255
81125fbc:	20035e1e 	bne	r4,zero,81126d38 <___vfiprintf_internal_r+0x13f0>
81125fc0:	a080080c 	andi	r2,r20,32
81125fc4:	1002a526 	beq	r2,zero,81126a5c <___vfiprintf_internal_r+0x1114>
81125fc8:	da802217 	ldw	r10,136(sp)
81125fcc:	50800017 	ldw	r2,0(r10)
81125fd0:	da802317 	ldw	r10,140(sp)
81125fd4:	5007d7fa 	srai	r3,r10,31
81125fd8:	da802217 	ldw	r10,136(sp)
81125fdc:	10c00115 	stw	r3,4(r2)
81125fe0:	52800104 	addi	r10,r10,4
81125fe4:	da802215 	stw	r10,136(sp)
81125fe8:	da802317 	ldw	r10,140(sp)
81125fec:	12800015 	stw	r10,0(r2)
81125ff0:	003e8c06 	br	81125a24 <__reset+0xfb105a24>
81125ff4:	21003fcc 	andi	r4,r4,255
81125ff8:	2003511e 	bne	r4,zero,81126d40 <___vfiprintf_internal_r+0x13f8>
81125ffc:	a080080c 	andi	r2,r20,32
81126000:	1000a126 	beq	r2,zero,81126288 <___vfiprintf_internal_r+0x940>
81126004:	da802217 	ldw	r10,136(sp)
81126008:	d8001d85 	stb	zero,118(sp)
8112600c:	50800204 	addi	r2,r10,8
81126010:	54800017 	ldw	r18,0(r10)
81126014:	54c00117 	ldw	r19,4(r10)
81126018:	4802b416 	blt	r9,zero,81126aec <___vfiprintf_internal_r+0x11a4>
8112601c:	013fdfc4 	movi	r4,-129
81126020:	94c6b03a 	or	r3,r18,r19
81126024:	d8802215 	stw	r2,136(sp)
81126028:	a128703a 	and	r20,r20,r4
8112602c:	1800a226 	beq	r3,zero,811262b8 <___vfiprintf_internal_r+0x970>
81126030:	0039883a 	mov	fp,zero
81126034:	dd401a04 	addi	r21,sp,104
81126038:	9006d0fa 	srli	r3,r18,3
8112603c:	9808977a 	slli	r4,r19,29
81126040:	9826d0fa 	srli	r19,r19,3
81126044:	948001cc 	andi	r18,r18,7
81126048:	90800c04 	addi	r2,r18,48
8112604c:	ad7fffc4 	addi	r21,r21,-1
81126050:	20e4b03a 	or	r18,r4,r3
81126054:	a8800005 	stb	r2,0(r21)
81126058:	94c6b03a 	or	r3,r18,r19
8112605c:	183ff61e 	bne	r3,zero,81126038 <__reset+0xfb106038>
81126060:	a0c0004c 	andi	r3,r20,1
81126064:	18005926 	beq	r3,zero,811261cc <___vfiprintf_internal_r+0x884>
81126068:	10803fcc 	andi	r2,r2,255
8112606c:	1080201c 	xori	r2,r2,128
81126070:	10bfe004 	addi	r2,r2,-128
81126074:	00c00c04 	movi	r3,48
81126078:	10c05426 	beq	r2,r3,811261cc <___vfiprintf_internal_r+0x884>
8112607c:	da801e17 	ldw	r10,120(sp)
81126080:	a8bfffc4 	addi	r2,r21,-1
81126084:	a8ffffc5 	stb	r3,-1(r21)
81126088:	50a7c83a 	sub	r19,r10,r2
8112608c:	102b883a 	mov	r21,r2
81126090:	003f2f06 	br	81125d50 <__reset+0xfb105d50>
81126094:	21003fcc 	andi	r4,r4,255
81126098:	2003421e 	bne	r4,zero,81126da4 <___vfiprintf_internal_r+0x145c>
8112609c:	00a04534 	movhi	r2,33044
811260a0:	10911e04 	addi	r2,r2,17528
811260a4:	d8802615 	stw	r2,152(sp)
811260a8:	a080080c 	andi	r2,r20,32
811260ac:	1000aa26 	beq	r2,zero,81126358 <___vfiprintf_internal_r+0xa10>
811260b0:	da802217 	ldw	r10,136(sp)
811260b4:	54800017 	ldw	r18,0(r10)
811260b8:	54c00117 	ldw	r19,4(r10)
811260bc:	52800204 	addi	r10,r10,8
811260c0:	da802215 	stw	r10,136(sp)
811260c4:	a080004c 	andi	r2,r20,1
811260c8:	1001d226 	beq	r2,zero,81126814 <___vfiprintf_internal_r+0xecc>
811260cc:	94c4b03a 	or	r2,r18,r19
811260d0:	1002351e 	bne	r2,zero,811269a8 <___vfiprintf_internal_r+0x1060>
811260d4:	d8001d85 	stb	zero,118(sp)
811260d8:	48022216 	blt	r9,zero,81126964 <___vfiprintf_internal_r+0x101c>
811260dc:	00bfdfc4 	movi	r2,-129
811260e0:	a0a8703a 	and	r20,r20,r2
811260e4:	003f1506 	br	81125d3c <__reset+0xfb105d3c>
811260e8:	da802217 	ldw	r10,136(sp)
811260ec:	04800044 	movi	r18,1
811260f0:	d8001d85 	stb	zero,118(sp)
811260f4:	50800017 	ldw	r2,0(r10)
811260f8:	52800104 	addi	r10,r10,4
811260fc:	da802215 	stw	r10,136(sp)
81126100:	d8801005 	stb	r2,64(sp)
81126104:	9027883a 	mov	r19,r18
81126108:	dd401004 	addi	r21,sp,64
8112610c:	0013883a 	mov	r9,zero
81126110:	003f1706 	br	81125d70 <__reset+0xfb105d70>
81126114:	21003fcc 	andi	r4,r4,255
81126118:	2003201e 	bne	r4,zero,81126d9c <___vfiprintf_internal_r+0x1454>
8112611c:	a080080c 	andi	r2,r20,32
81126120:	10004b26 	beq	r2,zero,81126250 <___vfiprintf_internal_r+0x908>
81126124:	da802217 	ldw	r10,136(sp)
81126128:	50800117 	ldw	r2,4(r10)
8112612c:	54800017 	ldw	r18,0(r10)
81126130:	52800204 	addi	r10,r10,8
81126134:	da802215 	stw	r10,136(sp)
81126138:	1027883a 	mov	r19,r2
8112613c:	10022c16 	blt	r2,zero,811269f0 <___vfiprintf_internal_r+0x10a8>
81126140:	df001d83 	ldbu	fp,118(sp)
81126144:	48007216 	blt	r9,zero,81126310 <___vfiprintf_internal_r+0x9c8>
81126148:	00ffdfc4 	movi	r3,-129
8112614c:	94c4b03a 	or	r2,r18,r19
81126150:	a0e8703a 	and	r20,r20,r3
81126154:	1000cc26 	beq	r2,zero,81126488 <___vfiprintf_internal_r+0xb40>
81126158:	98021026 	beq	r19,zero,8112699c <___vfiprintf_internal_r+0x1054>
8112615c:	dc402415 	stw	r17,144(sp)
81126160:	dc002515 	stw	r16,148(sp)
81126164:	9823883a 	mov	r17,r19
81126168:	9021883a 	mov	r16,r18
8112616c:	dd401a04 	addi	r21,sp,104
81126170:	4825883a 	mov	r18,r9
81126174:	4027883a 	mov	r19,r8
81126178:	8009883a 	mov	r4,r16
8112617c:	880b883a 	mov	r5,r17
81126180:	01800284 	movi	r6,10
81126184:	000f883a 	mov	r7,zero
81126188:	11286e40 	call	811286e4 <__umoddi3>
8112618c:	10800c04 	addi	r2,r2,48
81126190:	ad7fffc4 	addi	r21,r21,-1
81126194:	8009883a 	mov	r4,r16
81126198:	880b883a 	mov	r5,r17
8112619c:	a8800005 	stb	r2,0(r21)
811261a0:	01800284 	movi	r6,10
811261a4:	000f883a 	mov	r7,zero
811261a8:	11281640 	call	81128164 <__udivdi3>
811261ac:	1021883a 	mov	r16,r2
811261b0:	10c4b03a 	or	r2,r2,r3
811261b4:	1823883a 	mov	r17,r3
811261b8:	103fef1e 	bne	r2,zero,81126178 <__reset+0xfb106178>
811261bc:	dc402417 	ldw	r17,144(sp)
811261c0:	dc002517 	ldw	r16,148(sp)
811261c4:	9013883a 	mov	r9,r18
811261c8:	9811883a 	mov	r8,r19
811261cc:	da801e17 	ldw	r10,120(sp)
811261d0:	5567c83a 	sub	r19,r10,r21
811261d4:	003ede06 	br	81125d50 <__reset+0xfb105d50>
811261d8:	38803fcc 	andi	r2,r7,255
811261dc:	1080201c 	xori	r2,r2,128
811261e0:	10bfe004 	addi	r2,r2,-128
811261e4:	1002371e 	bne	r2,zero,81126ac4 <___vfiprintf_internal_r+0x117c>
811261e8:	01000044 	movi	r4,1
811261ec:	01c00804 	movi	r7,32
811261f0:	80c00007 	ldb	r3,0(r16)
811261f4:	003e3506 	br	81125acc <__reset+0xfb105acc>
811261f8:	a5000054 	ori	r20,r20,1
811261fc:	80c00007 	ldb	r3,0(r16)
81126200:	003e3206 	br	81125acc <__reset+0xfb105acc>
81126204:	a5002014 	ori	r20,r20,128
81126208:	80c00007 	ldb	r3,0(r16)
8112620c:	003e2f06 	br	81125acc <__reset+0xfb105acc>
81126210:	8015883a 	mov	r10,r16
81126214:	0023883a 	mov	r17,zero
81126218:	18bff404 	addi	r2,r3,-48
8112621c:	50c00007 	ldb	r3,0(r10)
81126220:	8c4002a4 	muli	r17,r17,10
81126224:	84000044 	addi	r16,r16,1
81126228:	8015883a 	mov	r10,r16
8112622c:	1463883a 	add	r17,r2,r17
81126230:	18bff404 	addi	r2,r3,-48
81126234:	30bff92e 	bgeu	r6,r2,8112621c <__reset+0xfb10621c>
81126238:	003e2506 	br	81125ad0 <__reset+0xfb105ad0>
8112623c:	21003fcc 	andi	r4,r4,255
81126240:	2002d41e 	bne	r4,zero,81126d94 <___vfiprintf_internal_r+0x144c>
81126244:	a5000414 	ori	r20,r20,16
81126248:	a080080c 	andi	r2,r20,32
8112624c:	103fb51e 	bne	r2,zero,81126124 <__reset+0xfb106124>
81126250:	a080040c 	andi	r2,r20,16
81126254:	1001f826 	beq	r2,zero,81126a38 <___vfiprintf_internal_r+0x10f0>
81126258:	da802217 	ldw	r10,136(sp)
8112625c:	54800017 	ldw	r18,0(r10)
81126260:	52800104 	addi	r10,r10,4
81126264:	da802215 	stw	r10,136(sp)
81126268:	9027d7fa 	srai	r19,r18,31
8112626c:	9805883a 	mov	r2,r19
81126270:	003fb206 	br	8112613c <__reset+0xfb10613c>
81126274:	21003fcc 	andi	r4,r4,255
81126278:	2002c41e 	bne	r4,zero,81126d8c <___vfiprintf_internal_r+0x1444>
8112627c:	a5000414 	ori	r20,r20,16
81126280:	a080080c 	andi	r2,r20,32
81126284:	103f5f1e 	bne	r2,zero,81126004 <__reset+0xfb106004>
81126288:	a080040c 	andi	r2,r20,16
8112628c:	10020f26 	beq	r2,zero,81126acc <___vfiprintf_internal_r+0x1184>
81126290:	da802217 	ldw	r10,136(sp)
81126294:	d8001d85 	stb	zero,118(sp)
81126298:	0027883a 	mov	r19,zero
8112629c:	50800104 	addi	r2,r10,4
811262a0:	54800017 	ldw	r18,0(r10)
811262a4:	48021116 	blt	r9,zero,81126aec <___vfiprintf_internal_r+0x11a4>
811262a8:	00ffdfc4 	movi	r3,-129
811262ac:	d8802215 	stw	r2,136(sp)
811262b0:	a0e8703a 	and	r20,r20,r3
811262b4:	903f5e1e 	bne	r18,zero,81126030 <__reset+0xfb106030>
811262b8:	0039883a 	mov	fp,zero
811262bc:	4802a626 	beq	r9,zero,81126d58 <___vfiprintf_internal_r+0x1410>
811262c0:	0025883a 	mov	r18,zero
811262c4:	0027883a 	mov	r19,zero
811262c8:	003f5a06 	br	81126034 <__reset+0xfb106034>
811262cc:	21003fcc 	andi	r4,r4,255
811262d0:	20029f1e 	bne	r4,zero,81126d50 <___vfiprintf_internal_r+0x1408>
811262d4:	a5000414 	ori	r20,r20,16
811262d8:	a080080c 	andi	r2,r20,32
811262dc:	10005e1e 	bne	r2,zero,81126458 <___vfiprintf_internal_r+0xb10>
811262e0:	a080040c 	andi	r2,r20,16
811262e4:	1001a21e 	bne	r2,zero,81126970 <___vfiprintf_internal_r+0x1028>
811262e8:	a080100c 	andi	r2,r20,64
811262ec:	d8001d85 	stb	zero,118(sp)
811262f0:	da802217 	ldw	r10,136(sp)
811262f4:	1002231e 	bne	r2,zero,81126b84 <___vfiprintf_internal_r+0x123c>
811262f8:	50800104 	addi	r2,r10,4
811262fc:	54800017 	ldw	r18,0(r10)
81126300:	0027883a 	mov	r19,zero
81126304:	4801a00e 	bge	r9,zero,81126988 <___vfiprintf_internal_r+0x1040>
81126308:	d8802215 	stw	r2,136(sp)
8112630c:	0039883a 	mov	fp,zero
81126310:	94c4b03a 	or	r2,r18,r19
81126314:	103f901e 	bne	r2,zero,81126158 <__reset+0xfb106158>
81126318:	00800044 	movi	r2,1
8112631c:	10803fcc 	andi	r2,r2,255
81126320:	00c00044 	movi	r3,1
81126324:	10c05926 	beq	r2,r3,8112648c <___vfiprintf_internal_r+0xb44>
81126328:	00c00084 	movi	r3,2
8112632c:	10ffe41e 	bne	r2,r3,811262c0 <__reset+0xfb1062c0>
81126330:	0025883a 	mov	r18,zero
81126334:	0027883a 	mov	r19,zero
81126338:	00013d06 	br	81126830 <___vfiprintf_internal_r+0xee8>
8112633c:	21003fcc 	andi	r4,r4,255
81126340:	2002811e 	bne	r4,zero,81126d48 <___vfiprintf_internal_r+0x1400>
81126344:	00a04534 	movhi	r2,33044
81126348:	10911904 	addi	r2,r2,17508
8112634c:	d8802615 	stw	r2,152(sp)
81126350:	a080080c 	andi	r2,r20,32
81126354:	103f561e 	bne	r2,zero,811260b0 <__reset+0xfb1060b0>
81126358:	a080040c 	andi	r2,r20,16
8112635c:	1001d126 	beq	r2,zero,81126aa4 <___vfiprintf_internal_r+0x115c>
81126360:	da802217 	ldw	r10,136(sp)
81126364:	0027883a 	mov	r19,zero
81126368:	54800017 	ldw	r18,0(r10)
8112636c:	52800104 	addi	r10,r10,4
81126370:	da802215 	stw	r10,136(sp)
81126374:	003f5306 	br	811260c4 <__reset+0xfb1060c4>
81126378:	da802217 	ldw	r10,136(sp)
8112637c:	d8001d85 	stb	zero,118(sp)
81126380:	55400017 	ldw	r21,0(r10)
81126384:	50c00104 	addi	r3,r10,4
81126388:	a8024226 	beq	r21,zero,81126c94 <___vfiprintf_internal_r+0x134c>
8112638c:	48021816 	blt	r9,zero,81126bf0 <___vfiprintf_internal_r+0x12a8>
81126390:	480d883a 	mov	r6,r9
81126394:	000b883a 	mov	r5,zero
81126398:	a809883a 	mov	r4,r21
8112639c:	d8c02a15 	stw	r3,168(sp)
811263a0:	da002b15 	stw	r8,172(sp)
811263a4:	da402c15 	stw	r9,176(sp)
811263a8:	11207240 	call	81120724 <memchr>
811263ac:	d8c02a17 	ldw	r3,168(sp)
811263b0:	da002b17 	ldw	r8,172(sp)
811263b4:	da402c17 	ldw	r9,176(sp)
811263b8:	10024826 	beq	r2,zero,81126cdc <___vfiprintf_internal_r+0x1394>
811263bc:	1567c83a 	sub	r19,r2,r21
811263c0:	df001d83 	ldbu	fp,118(sp)
811263c4:	d8c02215 	stw	r3,136(sp)
811263c8:	0013883a 	mov	r9,zero
811263cc:	003e6006 	br	81125d50 <__reset+0xfb105d50>
811263d0:	21003fcc 	andi	r4,r4,255
811263d4:	203fc026 	beq	r4,zero,811262d8 <__reset+0xfb1062d8>
811263d8:	d9c01d85 	stb	r7,118(sp)
811263dc:	003fbe06 	br	811262d8 <__reset+0xfb1062d8>
811263e0:	da802217 	ldw	r10,136(sp)
811263e4:	54400017 	ldw	r17,0(r10)
811263e8:	50800104 	addi	r2,r10,4
811263ec:	883e3b16 	blt	r17,zero,81125cdc <__reset+0xfb105cdc>
811263f0:	d8802215 	stw	r2,136(sp)
811263f4:	80c00007 	ldb	r3,0(r16)
811263f8:	003db406 	br	81125acc <__reset+0xfb105acc>
811263fc:	01000044 	movi	r4,1
81126400:	01c00ac4 	movi	r7,43
81126404:	80c00007 	ldb	r3,0(r16)
81126408:	003db006 	br	81125acc <__reset+0xfb105acc>
8112640c:	80c00007 	ldb	r3,0(r16)
81126410:	82800044 	addi	r10,r16,1
81126414:	1b423c26 	beq	r3,r13,81126d08 <___vfiprintf_internal_r+0x13c0>
81126418:	18bff404 	addi	r2,r3,-48
8112641c:	0013883a 	mov	r9,zero
81126420:	30822b36 	bltu	r6,r2,81126cd0 <___vfiprintf_internal_r+0x1388>
81126424:	50c00007 	ldb	r3,0(r10)
81126428:	4a4002a4 	muli	r9,r9,10
8112642c:	54000044 	addi	r16,r10,1
81126430:	8015883a 	mov	r10,r16
81126434:	4893883a 	add	r9,r9,r2
81126438:	18bff404 	addi	r2,r3,-48
8112643c:	30bff92e 	bgeu	r6,r2,81126424 <__reset+0xfb106424>
81126440:	483da30e 	bge	r9,zero,81125ad0 <__reset+0xfb105ad0>
81126444:	027fffc4 	movi	r9,-1
81126448:	003da106 	br	81125ad0 <__reset+0xfb105ad0>
8112644c:	a5001014 	ori	r20,r20,64
81126450:	80c00007 	ldb	r3,0(r16)
81126454:	003d9d06 	br	81125acc <__reset+0xfb105acc>
81126458:	da802217 	ldw	r10,136(sp)
8112645c:	d8001d85 	stb	zero,118(sp)
81126460:	50c00204 	addi	r3,r10,8
81126464:	54800017 	ldw	r18,0(r10)
81126468:	54c00117 	ldw	r19,4(r10)
8112646c:	4801ca16 	blt	r9,zero,81126b98 <___vfiprintf_internal_r+0x1250>
81126470:	013fdfc4 	movi	r4,-129
81126474:	94c4b03a 	or	r2,r18,r19
81126478:	d8c02215 	stw	r3,136(sp)
8112647c:	a128703a 	and	r20,r20,r4
81126480:	0039883a 	mov	fp,zero
81126484:	103f341e 	bne	r2,zero,81126158 <__reset+0xfb106158>
81126488:	483e2e26 	beq	r9,zero,81125d44 <__reset+0xfb105d44>
8112648c:	0025883a 	mov	r18,zero
81126490:	94800c04 	addi	r18,r18,48
81126494:	dc8019c5 	stb	r18,103(sp)
81126498:	dcc02717 	ldw	r19,156(sp)
8112649c:	dd4019c4 	addi	r21,sp,103
811264a0:	003e2b06 	br	81125d50 <__reset+0xfb105d50>
811264a4:	21003fcc 	andi	r4,r4,255
811264a8:	2002361e 	bne	r4,zero,81126d84 <___vfiprintf_internal_r+0x143c>
811264ac:	1801c126 	beq	r3,zero,81126bb4 <___vfiprintf_internal_r+0x126c>
811264b0:	04800044 	movi	r18,1
811264b4:	d8c01005 	stb	r3,64(sp)
811264b8:	d8001d85 	stb	zero,118(sp)
811264bc:	9027883a 	mov	r19,r18
811264c0:	dd401004 	addi	r21,sp,64
811264c4:	003f1106 	br	8112610c <__reset+0xfb10610c>
811264c8:	d9402117 	ldw	r5,132(sp)
811264cc:	d9002017 	ldw	r4,128(sp)
811264d0:	d9801a04 	addi	r6,sp,104
811264d4:	d9c02b15 	stw	r7,172(sp)
811264d8:	dbc02a15 	stw	r15,168(sp)
811264dc:	112582c0 	call	8112582c <__sprint_r.part.0>
811264e0:	d9c02b17 	ldw	r7,172(sp)
811264e4:	dbc02a17 	ldw	r15,168(sp)
811264e8:	10006d1e 	bne	r2,zero,811266a0 <___vfiprintf_internal_r+0xd58>
811264ec:	d9801b17 	ldw	r6,108(sp)
811264f0:	d8801c17 	ldw	r2,112(sp)
811264f4:	d811883a 	mov	r8,sp
811264f8:	31400044 	addi	r5,r6,1
811264fc:	003e3306 	br	81125dcc <__reset+0xfb105dcc>
81126500:	d9401b17 	ldw	r5,108(sp)
81126504:	d8801c17 	ldw	r2,112(sp)
81126508:	29000044 	addi	r4,r5,1
8112650c:	d8c01d87 	ldb	r3,118(sp)
81126510:	183e4d26 	beq	r3,zero,81125e48 <__reset+0xfb105e48>
81126514:	00c00044 	movi	r3,1
81126518:	d9401d84 	addi	r5,sp,118
8112651c:	10c5883a 	add	r2,r2,r3
81126520:	41400015 	stw	r5,0(r8)
81126524:	40c00115 	stw	r3,4(r8)
81126528:	d8801c15 	stw	r2,112(sp)
8112652c:	d9001b15 	stw	r4,108(sp)
81126530:	014001c4 	movi	r5,7
81126534:	2900a90e 	bge	r5,r4,811267dc <___vfiprintf_internal_r+0xe94>
81126538:	1000da1e 	bne	r2,zero,811268a4 <___vfiprintf_internal_r+0xf5c>
8112653c:	7000ab1e 	bne	r14,zero,811267ec <___vfiprintf_internal_r+0xea4>
81126540:	000b883a 	mov	r5,zero
81126544:	1809883a 	mov	r4,r3
81126548:	d811883a 	mov	r8,sp
8112654c:	00c02004 	movi	r3,128
81126550:	e0fe4d26 	beq	fp,r3,81125e88 <__reset+0xfb105e88>
81126554:	4cf9c83a 	sub	fp,r9,r19
81126558:	073e7b0e 	bge	zero,fp,81125f48 <__reset+0xfb105f48>
8112655c:	01c00404 	movi	r7,16
81126560:	3f01900e 	bge	r7,fp,81126ba4 <___vfiprintf_internal_r+0x125c>
81126564:	00e04534 	movhi	r3,33044
81126568:	18d1b004 	addi	r3,r3,18112
8112656c:	d8c02415 	stw	r3,144(sp)
81126570:	034001c4 	movi	r13,7
81126574:	00000506 	br	8112658c <___vfiprintf_internal_r+0xc44>
81126578:	29000084 	addi	r4,r5,2
8112657c:	42000204 	addi	r8,r8,8
81126580:	180b883a 	mov	r5,r3
81126584:	e73ffc04 	addi	fp,fp,-16
81126588:	3f000d0e 	bge	r7,fp,811265c0 <___vfiprintf_internal_r+0xc78>
8112658c:	10800404 	addi	r2,r2,16
81126590:	28c00044 	addi	r3,r5,1
81126594:	45c00015 	stw	r23,0(r8)
81126598:	41c00115 	stw	r7,4(r8)
8112659c:	d8801c15 	stw	r2,112(sp)
811265a0:	d8c01b15 	stw	r3,108(sp)
811265a4:	68fff40e 	bge	r13,r3,81126578 <__reset+0xfb106578>
811265a8:	1000101e 	bne	r2,zero,811265ec <___vfiprintf_internal_r+0xca4>
811265ac:	e73ffc04 	addi	fp,fp,-16
811265b0:	01000044 	movi	r4,1
811265b4:	000b883a 	mov	r5,zero
811265b8:	d811883a 	mov	r8,sp
811265bc:	3f3ff316 	blt	r7,fp,8112658c <__reset+0xfb10658c>
811265c0:	da802417 	ldw	r10,144(sp)
811265c4:	1705883a 	add	r2,r2,fp
811265c8:	47000115 	stw	fp,4(r8)
811265cc:	42800015 	stw	r10,0(r8)
811265d0:	d8801c15 	stw	r2,112(sp)
811265d4:	d9001b15 	stw	r4,108(sp)
811265d8:	00c001c4 	movi	r3,7
811265dc:	19003616 	blt	r3,r4,811266b8 <___vfiprintf_internal_r+0xd70>
811265e0:	42000204 	addi	r8,r8,8
811265e4:	21000044 	addi	r4,r4,1
811265e8:	003e5706 	br	81125f48 <__reset+0xfb105f48>
811265ec:	d9402117 	ldw	r5,132(sp)
811265f0:	d9002017 	ldw	r4,128(sp)
811265f4:	d9801a04 	addi	r6,sp,104
811265f8:	d9c02b15 	stw	r7,172(sp)
811265fc:	db402a15 	stw	r13,168(sp)
81126600:	112582c0 	call	8112582c <__sprint_r.part.0>
81126604:	d9c02b17 	ldw	r7,172(sp)
81126608:	db402a17 	ldw	r13,168(sp)
8112660c:	1000241e 	bne	r2,zero,811266a0 <___vfiprintf_internal_r+0xd58>
81126610:	d9401b17 	ldw	r5,108(sp)
81126614:	d8801c17 	ldw	r2,112(sp)
81126618:	d811883a 	mov	r8,sp
8112661c:	29000044 	addi	r4,r5,1
81126620:	003fd806 	br	81126584 <__reset+0xfb106584>
81126624:	d9401b17 	ldw	r5,108(sp)
81126628:	00e04534 	movhi	r3,33044
8112662c:	18d1b404 	addi	r3,r3,18128
81126630:	d8c02415 	stw	r3,144(sp)
81126634:	29400044 	addi	r5,r5,1
81126638:	d8c02417 	ldw	r3,144(sp)
8112663c:	14c5883a 	add	r2,r2,r19
81126640:	44c00115 	stw	r19,4(r8)
81126644:	40c00015 	stw	r3,0(r8)
81126648:	d8801c15 	stw	r2,112(sp)
8112664c:	d9401b15 	stw	r5,108(sp)
81126650:	00c001c4 	movi	r3,7
81126654:	1940070e 	bge	r3,r5,81126674 <___vfiprintf_internal_r+0xd2c>
81126658:	103e4826 	beq	r2,zero,81125f7c <__reset+0xfb105f7c>
8112665c:	d9402117 	ldw	r5,132(sp)
81126660:	d9002017 	ldw	r4,128(sp)
81126664:	d9801a04 	addi	r6,sp,104
81126668:	112582c0 	call	8112582c <__sprint_r.part.0>
8112666c:	10000c1e 	bne	r2,zero,811266a0 <___vfiprintf_internal_r+0xd58>
81126670:	d8801c17 	ldw	r2,112(sp)
81126674:	8c80010e 	bge	r17,r18,8112667c <___vfiprintf_internal_r+0xd34>
81126678:	9023883a 	mov	r17,r18
8112667c:	da802317 	ldw	r10,140(sp)
81126680:	5455883a 	add	r10,r10,r17
81126684:	da802315 	stw	r10,140(sp)
81126688:	103e4126 	beq	r2,zero,81125f90 <__reset+0xfb105f90>
8112668c:	d9402117 	ldw	r5,132(sp)
81126690:	d9002017 	ldw	r4,128(sp)
81126694:	d9801a04 	addi	r6,sp,104
81126698:	112582c0 	call	8112582c <__sprint_r.part.0>
8112669c:	103e3c26 	beq	r2,zero,81125f90 <__reset+0xfb105f90>
811266a0:	dd002117 	ldw	r20,132(sp)
811266a4:	a080030b 	ldhu	r2,12(r20)
811266a8:	1080100c 	andi	r2,r2,64
811266ac:	1001231e 	bne	r2,zero,81126b3c <___vfiprintf_internal_r+0x11f4>
811266b0:	d8802317 	ldw	r2,140(sp)
811266b4:	003d7b06 	br	81125ca4 <__reset+0xfb105ca4>
811266b8:	1000991e 	bne	r2,zero,81126920 <___vfiprintf_internal_r+0xfd8>
811266bc:	00c00044 	movi	r3,1
811266c0:	9805883a 	mov	r2,r19
811266c4:	dd400015 	stw	r21,0(sp)
811266c8:	dcc00115 	stw	r19,4(sp)
811266cc:	dcc01c15 	stw	r19,112(sp)
811266d0:	d8c01b15 	stw	r3,108(sp)
811266d4:	d811883a 	mov	r8,sp
811266d8:	42000204 	addi	r8,r8,8
811266dc:	a2c0010c 	andi	r11,r20,4
811266e0:	583fe426 	beq	r11,zero,81126674 <__reset+0xfb106674>
811266e4:	8ca7c83a 	sub	r19,r17,r18
811266e8:	04ffe20e 	bge	zero,r19,81126674 <__reset+0xfb106674>
811266ec:	01c00404 	movi	r7,16
811266f0:	3cffcc0e 	bge	r7,r19,81126624 <__reset+0xfb106624>
811266f4:	02a04534 	movhi	r10,33044
811266f8:	5291b404 	addi	r10,r10,18128
811266fc:	d9001b17 	ldw	r4,108(sp)
81126700:	da802415 	stw	r10,144(sp)
81126704:	382b883a 	mov	r21,r7
81126708:	050001c4 	movi	r20,7
8112670c:	df002017 	ldw	fp,128(sp)
81126710:	00000506 	br	81126728 <___vfiprintf_internal_r+0xde0>
81126714:	21400084 	addi	r5,r4,2
81126718:	42000204 	addi	r8,r8,8
8112671c:	1809883a 	mov	r4,r3
81126720:	9cfffc04 	addi	r19,r19,-16
81126724:	acffc40e 	bge	r21,r19,81126638 <__reset+0xfb106638>
81126728:	10800404 	addi	r2,r2,16
8112672c:	20c00044 	addi	r3,r4,1
81126730:	45800015 	stw	r22,0(r8)
81126734:	45400115 	stw	r21,4(r8)
81126738:	d8801c15 	stw	r2,112(sp)
8112673c:	d8c01b15 	stw	r3,108(sp)
81126740:	a0fff40e 	bge	r20,r3,81126714 <__reset+0xfb106714>
81126744:	1000041e 	bne	r2,zero,81126758 <___vfiprintf_internal_r+0xe10>
81126748:	01400044 	movi	r5,1
8112674c:	0009883a 	mov	r4,zero
81126750:	d811883a 	mov	r8,sp
81126754:	003ff206 	br	81126720 <__reset+0xfb106720>
81126758:	d9402117 	ldw	r5,132(sp)
8112675c:	d9801a04 	addi	r6,sp,104
81126760:	e009883a 	mov	r4,fp
81126764:	112582c0 	call	8112582c <__sprint_r.part.0>
81126768:	103fcd1e 	bne	r2,zero,811266a0 <__reset+0xfb1066a0>
8112676c:	d9001b17 	ldw	r4,108(sp)
81126770:	d8801c17 	ldw	r2,112(sp)
81126774:	d811883a 	mov	r8,sp
81126778:	21400044 	addi	r5,r4,1
8112677c:	003fe806 	br	81126720 <__reset+0xfb106720>
81126780:	d9402117 	ldw	r5,132(sp)
81126784:	d9002017 	ldw	r4,128(sp)
81126788:	d9801a04 	addi	r6,sp,104
8112678c:	d9c02b15 	stw	r7,172(sp)
81126790:	db402a15 	stw	r13,168(sp)
81126794:	112582c0 	call	8112582c <__sprint_r.part.0>
81126798:	d9c02b17 	ldw	r7,172(sp)
8112679c:	db402a17 	ldw	r13,168(sp)
811267a0:	103fbf1e 	bne	r2,zero,811266a0 <__reset+0xfb1066a0>
811267a4:	d9401b17 	ldw	r5,108(sp)
811267a8:	d8801c17 	ldw	r2,112(sp)
811267ac:	d811883a 	mov	r8,sp
811267b0:	29800044 	addi	r6,r5,1
811267b4:	003dc406 	br	81125ec8 <__reset+0xfb105ec8>
811267b8:	1000d21e 	bne	r2,zero,81126b04 <___vfiprintf_internal_r+0x11bc>
811267bc:	d8c01d87 	ldb	r3,118(sp)
811267c0:	18009526 	beq	r3,zero,81126a18 <___vfiprintf_internal_r+0x10d0>
811267c4:	00800044 	movi	r2,1
811267c8:	d8c01d84 	addi	r3,sp,118
811267cc:	1009883a 	mov	r4,r2
811267d0:	d8c00015 	stw	r3,0(sp)
811267d4:	d8800115 	stw	r2,4(sp)
811267d8:	d811883a 	mov	r8,sp
811267dc:	200b883a 	mov	r5,r4
811267e0:	42000204 	addi	r8,r8,8
811267e4:	21000044 	addi	r4,r4,1
811267e8:	003d9706 	br	81125e48 <__reset+0xfb105e48>
811267ec:	d9001d04 	addi	r4,sp,116
811267f0:	00800084 	movi	r2,2
811267f4:	d9000015 	stw	r4,0(sp)
811267f8:	d8800115 	stw	r2,4(sp)
811267fc:	1809883a 	mov	r4,r3
81126800:	d811883a 	mov	r8,sp
81126804:	200b883a 	mov	r5,r4
81126808:	42000204 	addi	r8,r8,8
8112680c:	21000044 	addi	r4,r4,1
81126810:	003f4e06 	br	8112654c <__reset+0xfb10654c>
81126814:	d8001d85 	stb	zero,118(sp)
81126818:	48005016 	blt	r9,zero,8112695c <___vfiprintf_internal_r+0x1014>
8112681c:	00ffdfc4 	movi	r3,-129
81126820:	94c4b03a 	or	r2,r18,r19
81126824:	a0e8703a 	and	r20,r20,r3
81126828:	103d4426 	beq	r2,zero,81125d3c <__reset+0xfb105d3c>
8112682c:	0039883a 	mov	fp,zero
81126830:	d9002617 	ldw	r4,152(sp)
81126834:	dd401a04 	addi	r21,sp,104
81126838:	908003cc 	andi	r2,r18,15
8112683c:	9806973a 	slli	r3,r19,28
81126840:	2085883a 	add	r2,r4,r2
81126844:	9024d13a 	srli	r18,r18,4
81126848:	10800003 	ldbu	r2,0(r2)
8112684c:	9826d13a 	srli	r19,r19,4
81126850:	ad7fffc4 	addi	r21,r21,-1
81126854:	1ca4b03a 	or	r18,r3,r18
81126858:	a8800005 	stb	r2,0(r21)
8112685c:	94c4b03a 	or	r2,r18,r19
81126860:	103ff51e 	bne	r2,zero,81126838 <__reset+0xfb106838>
81126864:	003e5906 	br	811261cc <__reset+0xfb1061cc>
81126868:	d9402117 	ldw	r5,132(sp)
8112686c:	d9002017 	ldw	r4,128(sp)
81126870:	d9801a04 	addi	r6,sp,104
81126874:	112582c0 	call	8112582c <__sprint_r.part.0>
81126878:	103f891e 	bne	r2,zero,811266a0 <__reset+0xfb1066a0>
8112687c:	d8801c17 	ldw	r2,112(sp)
81126880:	d811883a 	mov	r8,sp
81126884:	003f9506 	br	811266dc <__reset+0xfb1066dc>
81126888:	d9402117 	ldw	r5,132(sp)
8112688c:	d9002017 	ldw	r4,128(sp)
81126890:	d9801a04 	addi	r6,sp,104
81126894:	112582c0 	call	8112582c <__sprint_r.part.0>
81126898:	103f811e 	bne	r2,zero,811266a0 <__reset+0xfb1066a0>
8112689c:	d811883a 	mov	r8,sp
811268a0:	003ced06 	br	81125c58 <__reset+0xfb105c58>
811268a4:	d9402117 	ldw	r5,132(sp)
811268a8:	d9002017 	ldw	r4,128(sp)
811268ac:	d9801a04 	addi	r6,sp,104
811268b0:	da402c15 	stw	r9,176(sp)
811268b4:	db802a15 	stw	r14,168(sp)
811268b8:	112582c0 	call	8112582c <__sprint_r.part.0>
811268bc:	da402c17 	ldw	r9,176(sp)
811268c0:	db802a17 	ldw	r14,168(sp)
811268c4:	103f761e 	bne	r2,zero,811266a0 <__reset+0xfb1066a0>
811268c8:	d9401b17 	ldw	r5,108(sp)
811268cc:	d8801c17 	ldw	r2,112(sp)
811268d0:	d811883a 	mov	r8,sp
811268d4:	29000044 	addi	r4,r5,1
811268d8:	003d5b06 	br	81125e48 <__reset+0xfb105e48>
811268dc:	d9402117 	ldw	r5,132(sp)
811268e0:	d9002017 	ldw	r4,128(sp)
811268e4:	d9801a04 	addi	r6,sp,104
811268e8:	da402c15 	stw	r9,176(sp)
811268ec:	112582c0 	call	8112582c <__sprint_r.part.0>
811268f0:	da402c17 	ldw	r9,176(sp)
811268f4:	103f6a1e 	bne	r2,zero,811266a0 <__reset+0xfb1066a0>
811268f8:	d9401b17 	ldw	r5,108(sp)
811268fc:	d8801c17 	ldw	r2,112(sp)
81126900:	d811883a 	mov	r8,sp
81126904:	29000044 	addi	r4,r5,1
81126908:	003f1006 	br	8112654c <__reset+0xfb10654c>
8112690c:	1000c31e 	bne	r2,zero,81126c1c <___vfiprintf_internal_r+0x12d4>
81126910:	01000044 	movi	r4,1
81126914:	000b883a 	mov	r5,zero
81126918:	d811883a 	mov	r8,sp
8112691c:	003f0d06 	br	81126554 <__reset+0xfb106554>
81126920:	d9402117 	ldw	r5,132(sp)
81126924:	d9002017 	ldw	r4,128(sp)
81126928:	d9801a04 	addi	r6,sp,104
8112692c:	112582c0 	call	8112582c <__sprint_r.part.0>
81126930:	103f5b1e 	bne	r2,zero,811266a0 <__reset+0xfb1066a0>
81126934:	d9001b17 	ldw	r4,108(sp)
81126938:	d8801c17 	ldw	r2,112(sp)
8112693c:	d811883a 	mov	r8,sp
81126940:	21000044 	addi	r4,r4,1
81126944:	003d8006 	br	81125f48 <__reset+0xfb105f48>
81126948:	01204534 	movhi	r4,33044
8112694c:	21111e04 	addi	r4,r4,17528
81126950:	d9002615 	stw	r4,152(sp)
81126954:	d8c02215 	stw	r3,136(sp)
81126958:	1029883a 	mov	r20,r2
8112695c:	94c4b03a 	or	r2,r18,r19
81126960:	103fb21e 	bne	r2,zero,8112682c <__reset+0xfb10682c>
81126964:	0039883a 	mov	fp,zero
81126968:	00800084 	movi	r2,2
8112696c:	003e6b06 	br	8112631c <__reset+0xfb10631c>
81126970:	da802217 	ldw	r10,136(sp)
81126974:	d8001d85 	stb	zero,118(sp)
81126978:	0027883a 	mov	r19,zero
8112697c:	50800104 	addi	r2,r10,4
81126980:	54800017 	ldw	r18,0(r10)
81126984:	483e6016 	blt	r9,zero,81126308 <__reset+0xfb106308>
81126988:	00ffdfc4 	movi	r3,-129
8112698c:	d8802215 	stw	r2,136(sp)
81126990:	a0e8703a 	and	r20,r20,r3
81126994:	0039883a 	mov	fp,zero
81126998:	903ebb26 	beq	r18,zero,81126488 <__reset+0xfb106488>
8112699c:	00800244 	movi	r2,9
811269a0:	14bdee36 	bltu	r2,r18,8112615c <__reset+0xfb10615c>
811269a4:	003eba06 	br	81126490 <__reset+0xfb106490>
811269a8:	00800c04 	movi	r2,48
811269ac:	d8c01d45 	stb	r3,117(sp)
811269b0:	d8801d05 	stb	r2,116(sp)
811269b4:	d8001d85 	stb	zero,118(sp)
811269b8:	a0c00094 	ori	r3,r20,2
811269bc:	4800a916 	blt	r9,zero,81126c64 <___vfiprintf_internal_r+0x131c>
811269c0:	00bfdfc4 	movi	r2,-129
811269c4:	a096703a 	and	r11,r20,r2
811269c8:	5d000094 	ori	r20,r11,2
811269cc:	0039883a 	mov	fp,zero
811269d0:	003f9706 	br	81126830 <__reset+0xfb106830>
811269d4:	8025883a 	mov	r18,r16
811269d8:	003c2e06 	br	81125a94 <__reset+0xfb105a94>
811269dc:	00a04534 	movhi	r2,33044
811269e0:	10911e04 	addi	r2,r2,17528
811269e4:	0039883a 	mov	fp,zero
811269e8:	d8802615 	stw	r2,152(sp)
811269ec:	003f9006 	br	81126830 <__reset+0xfb106830>
811269f0:	04a5c83a 	sub	r18,zero,r18
811269f4:	07000b44 	movi	fp,45
811269f8:	9004c03a 	cmpne	r2,r18,zero
811269fc:	04e7c83a 	sub	r19,zero,r19
81126a00:	df001d85 	stb	fp,118(sp)
81126a04:	98a7c83a 	sub	r19,r19,r2
81126a08:	48009f16 	blt	r9,zero,81126c88 <___vfiprintf_internal_r+0x1340>
81126a0c:	00bfdfc4 	movi	r2,-129
81126a10:	a0a8703a 	and	r20,r20,r2
81126a14:	003dd006 	br	81126158 <__reset+0xfb106158>
81126a18:	70004c26 	beq	r14,zero,81126b4c <___vfiprintf_internal_r+0x1204>
81126a1c:	00800084 	movi	r2,2
81126a20:	d8c01d04 	addi	r3,sp,116
81126a24:	d8c00015 	stw	r3,0(sp)
81126a28:	d8800115 	stw	r2,4(sp)
81126a2c:	01000044 	movi	r4,1
81126a30:	d811883a 	mov	r8,sp
81126a34:	003f7306 	br	81126804 <__reset+0xfb106804>
81126a38:	a080100c 	andi	r2,r20,64
81126a3c:	da802217 	ldw	r10,136(sp)
81126a40:	103e0626 	beq	r2,zero,8112625c <__reset+0xfb10625c>
81126a44:	5480000f 	ldh	r18,0(r10)
81126a48:	52800104 	addi	r10,r10,4
81126a4c:	da802215 	stw	r10,136(sp)
81126a50:	9027d7fa 	srai	r19,r18,31
81126a54:	9805883a 	mov	r2,r19
81126a58:	003db806 	br	8112613c <__reset+0xfb10613c>
81126a5c:	a080040c 	andi	r2,r20,16
81126a60:	1000091e 	bne	r2,zero,81126a88 <___vfiprintf_internal_r+0x1140>
81126a64:	a2c0100c 	andi	r11,r20,64
81126a68:	58000726 	beq	r11,zero,81126a88 <___vfiprintf_internal_r+0x1140>
81126a6c:	da802217 	ldw	r10,136(sp)
81126a70:	50800017 	ldw	r2,0(r10)
81126a74:	52800104 	addi	r10,r10,4
81126a78:	da802215 	stw	r10,136(sp)
81126a7c:	da802317 	ldw	r10,140(sp)
81126a80:	1280000d 	sth	r10,0(r2)
81126a84:	003be706 	br	81125a24 <__reset+0xfb105a24>
81126a88:	da802217 	ldw	r10,136(sp)
81126a8c:	50800017 	ldw	r2,0(r10)
81126a90:	52800104 	addi	r10,r10,4
81126a94:	da802215 	stw	r10,136(sp)
81126a98:	da802317 	ldw	r10,140(sp)
81126a9c:	12800015 	stw	r10,0(r2)
81126aa0:	003be006 	br	81125a24 <__reset+0xfb105a24>
81126aa4:	a080100c 	andi	r2,r20,64
81126aa8:	da802217 	ldw	r10,136(sp)
81126aac:	10003026 	beq	r2,zero,81126b70 <___vfiprintf_internal_r+0x1228>
81126ab0:	5480000b 	ldhu	r18,0(r10)
81126ab4:	52800104 	addi	r10,r10,4
81126ab8:	0027883a 	mov	r19,zero
81126abc:	da802215 	stw	r10,136(sp)
81126ac0:	003d8006 	br	811260c4 <__reset+0xfb1060c4>
81126ac4:	80c00007 	ldb	r3,0(r16)
81126ac8:	003c0006 	br	81125acc <__reset+0xfb105acc>
81126acc:	a080100c 	andi	r2,r20,64
81126ad0:	d8001d85 	stb	zero,118(sp)
81126ad4:	da802217 	ldw	r10,136(sp)
81126ad8:	1000201e 	bne	r2,zero,81126b5c <___vfiprintf_internal_r+0x1214>
81126adc:	50800104 	addi	r2,r10,4
81126ae0:	54800017 	ldw	r18,0(r10)
81126ae4:	0027883a 	mov	r19,zero
81126ae8:	483def0e 	bge	r9,zero,811262a8 <__reset+0xfb1062a8>
81126aec:	94c6b03a 	or	r3,r18,r19
81126af0:	d8802215 	stw	r2,136(sp)
81126af4:	183d4e1e 	bne	r3,zero,81126030 <__reset+0xfb106030>
81126af8:	0039883a 	mov	fp,zero
81126afc:	0005883a 	mov	r2,zero
81126b00:	003e0606 	br	8112631c <__reset+0xfb10631c>
81126b04:	d9402117 	ldw	r5,132(sp)
81126b08:	d9002017 	ldw	r4,128(sp)
81126b0c:	d9801a04 	addi	r6,sp,104
81126b10:	da402c15 	stw	r9,176(sp)
81126b14:	db802a15 	stw	r14,168(sp)
81126b18:	112582c0 	call	8112582c <__sprint_r.part.0>
81126b1c:	da402c17 	ldw	r9,176(sp)
81126b20:	db802a17 	ldw	r14,168(sp)
81126b24:	103ede1e 	bne	r2,zero,811266a0 <__reset+0xfb1066a0>
81126b28:	d9401b17 	ldw	r5,108(sp)
81126b2c:	d8801c17 	ldw	r2,112(sp)
81126b30:	d811883a 	mov	r8,sp
81126b34:	29000044 	addi	r4,r5,1
81126b38:	003e7406 	br	8112650c <__reset+0xfb10650c>
81126b3c:	00bfffc4 	movi	r2,-1
81126b40:	003c5806 	br	81125ca4 <__reset+0xfb105ca4>
81126b44:	d811883a 	mov	r8,sp
81126b48:	003ee806 	br	811266ec <__reset+0xfb1066ec>
81126b4c:	000b883a 	mov	r5,zero
81126b50:	01000044 	movi	r4,1
81126b54:	d811883a 	mov	r8,sp
81126b58:	003e7c06 	br	8112654c <__reset+0xfb10654c>
81126b5c:	50800104 	addi	r2,r10,4
81126b60:	5480000b 	ldhu	r18,0(r10)
81126b64:	0027883a 	mov	r19,zero
81126b68:	483dcf0e 	bge	r9,zero,811262a8 <__reset+0xfb1062a8>
81126b6c:	003fdf06 	br	81126aec <__reset+0xfb106aec>
81126b70:	54800017 	ldw	r18,0(r10)
81126b74:	52800104 	addi	r10,r10,4
81126b78:	0027883a 	mov	r19,zero
81126b7c:	da802215 	stw	r10,136(sp)
81126b80:	003d5006 	br	811260c4 <__reset+0xfb1060c4>
81126b84:	50800104 	addi	r2,r10,4
81126b88:	5480000b 	ldhu	r18,0(r10)
81126b8c:	0027883a 	mov	r19,zero
81126b90:	483f7d0e 	bge	r9,zero,81126988 <__reset+0xfb106988>
81126b94:	003ddc06 	br	81126308 <__reset+0xfb106308>
81126b98:	d8c02215 	stw	r3,136(sp)
81126b9c:	0039883a 	mov	fp,zero
81126ba0:	003ddb06 	br	81126310 <__reset+0xfb106310>
81126ba4:	02a04534 	movhi	r10,33044
81126ba8:	5291b004 	addi	r10,r10,18112
81126bac:	da802415 	stw	r10,144(sp)
81126bb0:	003e8306 	br	811265c0 <__reset+0xfb1065c0>
81126bb4:	d8801c17 	ldw	r2,112(sp)
81126bb8:	dd002117 	ldw	r20,132(sp)
81126bbc:	103eb926 	beq	r2,zero,811266a4 <__reset+0xfb1066a4>
81126bc0:	d9002017 	ldw	r4,128(sp)
81126bc4:	d9801a04 	addi	r6,sp,104
81126bc8:	a00b883a 	mov	r5,r20
81126bcc:	112582c0 	call	8112582c <__sprint_r.part.0>
81126bd0:	003eb406 	br	811266a4 <__reset+0xfb1066a4>
81126bd4:	80c00043 	ldbu	r3,1(r16)
81126bd8:	a5000814 	ori	r20,r20,32
81126bdc:	84000044 	addi	r16,r16,1
81126be0:	18c03fcc 	andi	r3,r3,255
81126be4:	18c0201c 	xori	r3,r3,128
81126be8:	18ffe004 	addi	r3,r3,-128
81126bec:	003bb706 	br	81125acc <__reset+0xfb105acc>
81126bf0:	a809883a 	mov	r4,r21
81126bf4:	d8c02a15 	stw	r3,168(sp)
81126bf8:	da002b15 	stw	r8,172(sp)
81126bfc:	11172280 	call	81117228 <strlen>
81126c00:	d8c02a17 	ldw	r3,168(sp)
81126c04:	1027883a 	mov	r19,r2
81126c08:	df001d83 	ldbu	fp,118(sp)
81126c0c:	d8c02215 	stw	r3,136(sp)
81126c10:	0013883a 	mov	r9,zero
81126c14:	da002b17 	ldw	r8,172(sp)
81126c18:	003c4d06 	br	81125d50 <__reset+0xfb105d50>
81126c1c:	d9402117 	ldw	r5,132(sp)
81126c20:	d9002017 	ldw	r4,128(sp)
81126c24:	d9801a04 	addi	r6,sp,104
81126c28:	da402c15 	stw	r9,176(sp)
81126c2c:	112582c0 	call	8112582c <__sprint_r.part.0>
81126c30:	da402c17 	ldw	r9,176(sp)
81126c34:	103e9a1e 	bne	r2,zero,811266a0 <__reset+0xfb1066a0>
81126c38:	d9401b17 	ldw	r5,108(sp)
81126c3c:	d8801c17 	ldw	r2,112(sp)
81126c40:	d811883a 	mov	r8,sp
81126c44:	29000044 	addi	r4,r5,1
81126c48:	003e4206 	br	81126554 <__reset+0xfb106554>
81126c4c:	d9401b17 	ldw	r5,108(sp)
81126c50:	01204534 	movhi	r4,33044
81126c54:	2111b404 	addi	r4,r4,18128
81126c58:	d9002415 	stw	r4,144(sp)
81126c5c:	29400044 	addi	r5,r5,1
81126c60:	003c6d06 	br	81125e18 <__reset+0xfb105e18>
81126c64:	0039883a 	mov	fp,zero
81126c68:	00800084 	movi	r2,2
81126c6c:	10803fcc 	andi	r2,r2,255
81126c70:	01000044 	movi	r4,1
81126c74:	11001e26 	beq	r2,r4,81126cf0 <___vfiprintf_internal_r+0x13a8>
81126c78:	01000084 	movi	r4,2
81126c7c:	11001e1e 	bne	r2,r4,81126cf8 <___vfiprintf_internal_r+0x13b0>
81126c80:	1829883a 	mov	r20,r3
81126c84:	003eea06 	br	81126830 <__reset+0xfb106830>
81126c88:	a007883a 	mov	r3,r20
81126c8c:	00800044 	movi	r2,1
81126c90:	003ff606 	br	81126c6c <__reset+0xfb106c6c>
81126c94:	00800184 	movi	r2,6
81126c98:	1240012e 	bgeu	r2,r9,81126ca0 <___vfiprintf_internal_r+0x1358>
81126c9c:	1013883a 	mov	r9,r2
81126ca0:	4827883a 	mov	r19,r9
81126ca4:	4825883a 	mov	r18,r9
81126ca8:	48001516 	blt	r9,zero,81126d00 <___vfiprintf_internal_r+0x13b8>
81126cac:	05604534 	movhi	r21,33044
81126cb0:	d8c02215 	stw	r3,136(sp)
81126cb4:	ad512304 	addi	r21,r21,17548
81126cb8:	003d1406 	br	8112610c <__reset+0xfb10610c>
81126cbc:	02a04534 	movhi	r10,33044
81126cc0:	5291b004 	addi	r10,r10,18112
81126cc4:	da802415 	stw	r10,144(sp)
81126cc8:	200d883a 	mov	r6,r4
81126ccc:	003c9106 	br	81125f14 <__reset+0xfb105f14>
81126cd0:	5021883a 	mov	r16,r10
81126cd4:	0013883a 	mov	r9,zero
81126cd8:	003b7d06 	br	81125ad0 <__reset+0xfb105ad0>
81126cdc:	4827883a 	mov	r19,r9
81126ce0:	df001d83 	ldbu	fp,118(sp)
81126ce4:	d8c02215 	stw	r3,136(sp)
81126ce8:	0013883a 	mov	r9,zero
81126cec:	003c1806 	br	81125d50 <__reset+0xfb105d50>
81126cf0:	1829883a 	mov	r20,r3
81126cf4:	003d1806 	br	81126158 <__reset+0xfb106158>
81126cf8:	1829883a 	mov	r20,r3
81126cfc:	003ccd06 	br	81126034 <__reset+0xfb106034>
81126d00:	0025883a 	mov	r18,zero
81126d04:	003fe906 	br	81126cac <__reset+0xfb106cac>
81126d08:	d8802217 	ldw	r2,136(sp)
81126d0c:	80c00043 	ldbu	r3,1(r16)
81126d10:	5021883a 	mov	r16,r10
81126d14:	12400017 	ldw	r9,0(r2)
81126d18:	10800104 	addi	r2,r2,4
81126d1c:	d8802215 	stw	r2,136(sp)
81126d20:	483faf0e 	bge	r9,zero,81126be0 <__reset+0xfb106be0>
81126d24:	18c03fcc 	andi	r3,r3,255
81126d28:	18c0201c 	xori	r3,r3,128
81126d2c:	027fffc4 	movi	r9,-1
81126d30:	18ffe004 	addi	r3,r3,-128
81126d34:	003b6506 	br	81125acc <__reset+0xfb105acc>
81126d38:	d9c01d85 	stb	r7,118(sp)
81126d3c:	003ca006 	br	81125fc0 <__reset+0xfb105fc0>
81126d40:	d9c01d85 	stb	r7,118(sp)
81126d44:	003cad06 	br	81125ffc <__reset+0xfb105ffc>
81126d48:	d9c01d85 	stb	r7,118(sp)
81126d4c:	003d7d06 	br	81126344 <__reset+0xfb106344>
81126d50:	d9c01d85 	stb	r7,118(sp)
81126d54:	003d5f06 	br	811262d4 <__reset+0xfb1062d4>
81126d58:	a080004c 	andi	r2,r20,1
81126d5c:	0039883a 	mov	fp,zero
81126d60:	10000526 	beq	r2,zero,81126d78 <___vfiprintf_internal_r+0x1430>
81126d64:	00800c04 	movi	r2,48
81126d68:	d88019c5 	stb	r2,103(sp)
81126d6c:	dcc02717 	ldw	r19,156(sp)
81126d70:	dd4019c4 	addi	r21,sp,103
81126d74:	003bf606 	br	81125d50 <__reset+0xfb105d50>
81126d78:	0027883a 	mov	r19,zero
81126d7c:	dd401a04 	addi	r21,sp,104
81126d80:	003bf306 	br	81125d50 <__reset+0xfb105d50>
81126d84:	d9c01d85 	stb	r7,118(sp)
81126d88:	003dc806 	br	811264ac <__reset+0xfb1064ac>
81126d8c:	d9c01d85 	stb	r7,118(sp)
81126d90:	003d3a06 	br	8112627c <__reset+0xfb10627c>
81126d94:	d9c01d85 	stb	r7,118(sp)
81126d98:	003d2a06 	br	81126244 <__reset+0xfb106244>
81126d9c:	d9c01d85 	stb	r7,118(sp)
81126da0:	003cde06 	br	8112611c <__reset+0xfb10611c>
81126da4:	d9c01d85 	stb	r7,118(sp)
81126da8:	003cbc06 	br	8112609c <__reset+0xfb10609c>

81126dac <__vfiprintf_internal>:
81126dac:	00a04534 	movhi	r2,33044
81126db0:	109aed04 	addi	r2,r2,27572
81126db4:	300f883a 	mov	r7,r6
81126db8:	280d883a 	mov	r6,r5
81126dbc:	200b883a 	mov	r5,r4
81126dc0:	11000017 	ldw	r4,0(r2)
81126dc4:	11259481 	jmpi	81125948 <___vfiprintf_internal_r>

81126dc8 <__sbprintf>:
81126dc8:	defee204 	addi	sp,sp,-1144
81126dcc:	de00012e 	bgeu	sp,et,81126dd4 <__sbprintf+0xc>
81126dd0:	003b68fa 	trap	3
81126dd4:	2880030b 	ldhu	r2,12(r5)
81126dd8:	2ac01917 	ldw	r11,100(r5)
81126ddc:	2a80038b 	ldhu	r10,14(r5)
81126de0:	2a400717 	ldw	r9,28(r5)
81126de4:	2a000917 	ldw	r8,36(r5)
81126de8:	00c10004 	movi	r3,1024
81126dec:	dc011a15 	stw	r16,1128(sp)
81126df0:	10bfff4c 	andi	r2,r2,65533
81126df4:	2821883a 	mov	r16,r5
81126df8:	d8cb883a 	add	r5,sp,r3
81126dfc:	dc811c15 	stw	r18,1136(sp)
81126e00:	dc411b15 	stw	r17,1132(sp)
81126e04:	dfc11d15 	stw	ra,1140(sp)
81126e08:	2025883a 	mov	r18,r4
81126e0c:	d881030d 	sth	r2,1036(sp)
81126e10:	dac11915 	stw	r11,1124(sp)
81126e14:	da81038d 	sth	r10,1038(sp)
81126e18:	da410715 	stw	r9,1052(sp)
81126e1c:	da010915 	stw	r8,1060(sp)
81126e20:	dec10015 	stw	sp,1024(sp)
81126e24:	dec10415 	stw	sp,1040(sp)
81126e28:	d8c10215 	stw	r3,1032(sp)
81126e2c:	d8c10515 	stw	r3,1044(sp)
81126e30:	d8010615 	stw	zero,1048(sp)
81126e34:	11259480 	call	81125948 <___vfiprintf_internal_r>
81126e38:	1023883a 	mov	r17,r2
81126e3c:	10000416 	blt	r2,zero,81126e50 <__sbprintf+0x88>
81126e40:	d9410004 	addi	r5,sp,1024
81126e44:	9009883a 	mov	r4,r18
81126e48:	111f1000 	call	8111f100 <_fflush_r>
81126e4c:	10000d1e 	bne	r2,zero,81126e84 <__sbprintf+0xbc>
81126e50:	d881030b 	ldhu	r2,1036(sp)
81126e54:	1080100c 	andi	r2,r2,64
81126e58:	10000326 	beq	r2,zero,81126e68 <__sbprintf+0xa0>
81126e5c:	8080030b 	ldhu	r2,12(r16)
81126e60:	10801014 	ori	r2,r2,64
81126e64:	8080030d 	sth	r2,12(r16)
81126e68:	8805883a 	mov	r2,r17
81126e6c:	dfc11d17 	ldw	ra,1140(sp)
81126e70:	dc811c17 	ldw	r18,1136(sp)
81126e74:	dc411b17 	ldw	r17,1132(sp)
81126e78:	dc011a17 	ldw	r16,1128(sp)
81126e7c:	dec11e04 	addi	sp,sp,1144
81126e80:	f800283a 	ret
81126e84:	047fffc4 	movi	r17,-1
81126e88:	003ff106 	br	81126e50 <__reset+0xfb106e50>

81126e8c <_calloc_r>:
81126e8c:	298b383a 	mul	r5,r5,r6
81126e90:	defffe04 	addi	sp,sp,-8
81126e94:	de00012e 	bgeu	sp,et,81126e9c <_calloc_r+0x10>
81126e98:	003b68fa 	trap	3
81126e9c:	dfc00115 	stw	ra,4(sp)
81126ea0:	dc000015 	stw	r16,0(sp)
81126ea4:	1115f200 	call	81115f20 <_malloc_r>
81126ea8:	10002926 	beq	r2,zero,81126f50 <_calloc_r+0xc4>
81126eac:	11bfff17 	ldw	r6,-4(r2)
81126eb0:	1021883a 	mov	r16,r2
81126eb4:	00bfff04 	movi	r2,-4
81126eb8:	308c703a 	and	r6,r6,r2
81126ebc:	00c00904 	movi	r3,36
81126ec0:	308d883a 	add	r6,r6,r2
81126ec4:	19801636 	bltu	r3,r6,81126f20 <_calloc_r+0x94>
81126ec8:	008004c4 	movi	r2,19
81126ecc:	11800b2e 	bgeu	r2,r6,81126efc <_calloc_r+0x70>
81126ed0:	80000015 	stw	zero,0(r16)
81126ed4:	80000115 	stw	zero,4(r16)
81126ed8:	008006c4 	movi	r2,27
81126edc:	11801a2e 	bgeu	r2,r6,81126f48 <_calloc_r+0xbc>
81126ee0:	80000215 	stw	zero,8(r16)
81126ee4:	80000315 	stw	zero,12(r16)
81126ee8:	30c0151e 	bne	r6,r3,81126f40 <_calloc_r+0xb4>
81126eec:	80000415 	stw	zero,16(r16)
81126ef0:	80800604 	addi	r2,r16,24
81126ef4:	80000515 	stw	zero,20(r16)
81126ef8:	00000106 	br	81126f00 <_calloc_r+0x74>
81126efc:	8005883a 	mov	r2,r16
81126f00:	10000015 	stw	zero,0(r2)
81126f04:	10000115 	stw	zero,4(r2)
81126f08:	10000215 	stw	zero,8(r2)
81126f0c:	8005883a 	mov	r2,r16
81126f10:	dfc00117 	ldw	ra,4(sp)
81126f14:	dc000017 	ldw	r16,0(sp)
81126f18:	dec00204 	addi	sp,sp,8
81126f1c:	f800283a 	ret
81126f20:	000b883a 	mov	r5,zero
81126f24:	8009883a 	mov	r4,r16
81126f28:	11168840 	call	81116884 <memset>
81126f2c:	8005883a 	mov	r2,r16
81126f30:	dfc00117 	ldw	ra,4(sp)
81126f34:	dc000017 	ldw	r16,0(sp)
81126f38:	dec00204 	addi	sp,sp,8
81126f3c:	f800283a 	ret
81126f40:	80800404 	addi	r2,r16,16
81126f44:	003fee06 	br	81126f00 <__reset+0xfb106f00>
81126f48:	80800204 	addi	r2,r16,8
81126f4c:	003fec06 	br	81126f00 <__reset+0xfb106f00>
81126f50:	0005883a 	mov	r2,zero
81126f54:	003fee06 	br	81126f10 <__reset+0xfb106f10>

81126f58 <_fclose_r>:
81126f58:	28003b26 	beq	r5,zero,81127048 <_fclose_r+0xf0>
81126f5c:	defffc04 	addi	sp,sp,-16
81126f60:	de00012e 	bgeu	sp,et,81126f68 <_fclose_r+0x10>
81126f64:	003b68fa 	trap	3
81126f68:	dc400115 	stw	r17,4(sp)
81126f6c:	dc000015 	stw	r16,0(sp)
81126f70:	dfc00315 	stw	ra,12(sp)
81126f74:	dc800215 	stw	r18,8(sp)
81126f78:	2023883a 	mov	r17,r4
81126f7c:	2821883a 	mov	r16,r5
81126f80:	20000226 	beq	r4,zero,81126f8c <_fclose_r+0x34>
81126f84:	20800e17 	ldw	r2,56(r4)
81126f88:	10002726 	beq	r2,zero,81127028 <_fclose_r+0xd0>
81126f8c:	8080030f 	ldh	r2,12(r16)
81126f90:	1000071e 	bne	r2,zero,81126fb0 <_fclose_r+0x58>
81126f94:	0005883a 	mov	r2,zero
81126f98:	dfc00317 	ldw	ra,12(sp)
81126f9c:	dc800217 	ldw	r18,8(sp)
81126fa0:	dc400117 	ldw	r17,4(sp)
81126fa4:	dc000017 	ldw	r16,0(sp)
81126fa8:	dec00404 	addi	sp,sp,16
81126fac:	f800283a 	ret
81126fb0:	800b883a 	mov	r5,r16
81126fb4:	8809883a 	mov	r4,r17
81126fb8:	111eedc0 	call	8111eedc <__sflush_r>
81126fbc:	1025883a 	mov	r18,r2
81126fc0:	80800b17 	ldw	r2,44(r16)
81126fc4:	10000426 	beq	r2,zero,81126fd8 <_fclose_r+0x80>
81126fc8:	81400717 	ldw	r5,28(r16)
81126fcc:	8809883a 	mov	r4,r17
81126fd0:	103ee83a 	callr	r2
81126fd4:	10001616 	blt	r2,zero,81127030 <_fclose_r+0xd8>
81126fd8:	8080030b 	ldhu	r2,12(r16)
81126fdc:	1080200c 	andi	r2,r2,128
81126fe0:	1000151e 	bne	r2,zero,81127038 <_fclose_r+0xe0>
81126fe4:	81400c17 	ldw	r5,48(r16)
81126fe8:	28000526 	beq	r5,zero,81127000 <_fclose_r+0xa8>
81126fec:	80801004 	addi	r2,r16,64
81126ff0:	28800226 	beq	r5,r2,81126ffc <_fclose_r+0xa4>
81126ff4:	8809883a 	mov	r4,r17
81126ff8:	111f9940 	call	8111f994 <_free_r>
81126ffc:	80000c15 	stw	zero,48(r16)
81127000:	81401117 	ldw	r5,68(r16)
81127004:	28000326 	beq	r5,zero,81127014 <_fclose_r+0xbc>
81127008:	8809883a 	mov	r4,r17
8112700c:	111f9940 	call	8111f994 <_free_r>
81127010:	80001115 	stw	zero,68(r16)
81127014:	111f50c0 	call	8111f50c <__sfp_lock_acquire>
81127018:	8000030d 	sth	zero,12(r16)
8112701c:	111f5100 	call	8111f510 <__sfp_lock_release>
81127020:	9005883a 	mov	r2,r18
81127024:	003fdc06 	br	81126f98 <__reset+0xfb106f98>
81127028:	111f4fc0 	call	8111f4fc <__sinit>
8112702c:	003fd706 	br	81126f8c <__reset+0xfb106f8c>
81127030:	04bfffc4 	movi	r18,-1
81127034:	003fe806 	br	81126fd8 <__reset+0xfb106fd8>
81127038:	81400417 	ldw	r5,16(r16)
8112703c:	8809883a 	mov	r4,r17
81127040:	111f9940 	call	8111f994 <_free_r>
81127044:	003fe706 	br	81126fe4 <__reset+0xfb106fe4>
81127048:	0005883a 	mov	r2,zero
8112704c:	f800283a 	ret

81127050 <fclose>:
81127050:	00a04534 	movhi	r2,33044
81127054:	109aed04 	addi	r2,r2,27572
81127058:	200b883a 	mov	r5,r4
8112705c:	11000017 	ldw	r4,0(r2)
81127060:	1126f581 	jmpi	81126f58 <_fclose_r>

81127064 <__fputwc>:
81127064:	defff804 	addi	sp,sp,-32
81127068:	de00012e 	bgeu	sp,et,81127070 <__fputwc+0xc>
8112706c:	003b68fa 	trap	3
81127070:	dcc00415 	stw	r19,16(sp)
81127074:	dc800315 	stw	r18,12(sp)
81127078:	dc000115 	stw	r16,4(sp)
8112707c:	dfc00715 	stw	ra,28(sp)
81127080:	dd400615 	stw	r21,24(sp)
81127084:	dd000515 	stw	r20,20(sp)
81127088:	dc400215 	stw	r17,8(sp)
8112708c:	2027883a 	mov	r19,r4
81127090:	2825883a 	mov	r18,r5
81127094:	3021883a 	mov	r16,r6
81127098:	11204240 	call	81120424 <__locale_mb_cur_max>
8112709c:	00c00044 	movi	r3,1
811270a0:	10c03e26 	beq	r2,r3,8112719c <__fputwc+0x138>
811270a4:	81c01704 	addi	r7,r16,92
811270a8:	900d883a 	mov	r6,r18
811270ac:	d80b883a 	mov	r5,sp
811270b0:	9809883a 	mov	r4,r19
811270b4:	1127ee80 	call	81127ee8 <_wcrtomb_r>
811270b8:	1029883a 	mov	r20,r2
811270bc:	00bfffc4 	movi	r2,-1
811270c0:	a0802026 	beq	r20,r2,81127144 <__fputwc+0xe0>
811270c4:	d9400003 	ldbu	r5,0(sp)
811270c8:	a0001c26 	beq	r20,zero,8112713c <__fputwc+0xd8>
811270cc:	0023883a 	mov	r17,zero
811270d0:	05400284 	movi	r21,10
811270d4:	00000906 	br	811270fc <__fputwc+0x98>
811270d8:	80800017 	ldw	r2,0(r16)
811270dc:	11400005 	stb	r5,0(r2)
811270e0:	80c00017 	ldw	r3,0(r16)
811270e4:	18c00044 	addi	r3,r3,1
811270e8:	80c00015 	stw	r3,0(r16)
811270ec:	8c400044 	addi	r17,r17,1
811270f0:	dc45883a 	add	r2,sp,r17
811270f4:	8d00112e 	bgeu	r17,r20,8112713c <__fputwc+0xd8>
811270f8:	11400003 	ldbu	r5,0(r2)
811270fc:	80c00217 	ldw	r3,8(r16)
81127100:	18ffffc4 	addi	r3,r3,-1
81127104:	80c00215 	stw	r3,8(r16)
81127108:	183ff30e 	bge	r3,zero,811270d8 <__reset+0xfb1070d8>
8112710c:	80800617 	ldw	r2,24(r16)
81127110:	18801916 	blt	r3,r2,81127178 <__fputwc+0x114>
81127114:	80800017 	ldw	r2,0(r16)
81127118:	11400005 	stb	r5,0(r2)
8112711c:	80800017 	ldw	r2,0(r16)
81127120:	10c00003 	ldbu	r3,0(r2)
81127124:	10800044 	addi	r2,r2,1
81127128:	1d402326 	beq	r3,r21,811271b8 <__fputwc+0x154>
8112712c:	80800015 	stw	r2,0(r16)
81127130:	8c400044 	addi	r17,r17,1
81127134:	dc45883a 	add	r2,sp,r17
81127138:	8d3fef36 	bltu	r17,r20,811270f8 <__reset+0xfb1070f8>
8112713c:	9005883a 	mov	r2,r18
81127140:	00000406 	br	81127154 <__fputwc+0xf0>
81127144:	80c0030b 	ldhu	r3,12(r16)
81127148:	a005883a 	mov	r2,r20
8112714c:	18c01014 	ori	r3,r3,64
81127150:	80c0030d 	sth	r3,12(r16)
81127154:	dfc00717 	ldw	ra,28(sp)
81127158:	dd400617 	ldw	r21,24(sp)
8112715c:	dd000517 	ldw	r20,20(sp)
81127160:	dcc00417 	ldw	r19,16(sp)
81127164:	dc800317 	ldw	r18,12(sp)
81127168:	dc400217 	ldw	r17,8(sp)
8112716c:	dc000117 	ldw	r16,4(sp)
81127170:	dec00804 	addi	sp,sp,32
81127174:	f800283a 	ret
81127178:	800d883a 	mov	r6,r16
8112717c:	29403fcc 	andi	r5,r5,255
81127180:	9809883a 	mov	r4,r19
81127184:	111d2c40 	call	8111d2c4 <__swbuf_r>
81127188:	10bfffe0 	cmpeqi	r2,r2,-1
8112718c:	10803fcc 	andi	r2,r2,255
81127190:	103fd626 	beq	r2,zero,811270ec <__reset+0xfb1070ec>
81127194:	00bfffc4 	movi	r2,-1
81127198:	003fee06 	br	81127154 <__reset+0xfb107154>
8112719c:	90ffffc4 	addi	r3,r18,-1
811271a0:	01003f84 	movi	r4,254
811271a4:	20ffbf36 	bltu	r4,r3,811270a4 <__reset+0xfb1070a4>
811271a8:	900b883a 	mov	r5,r18
811271ac:	dc800005 	stb	r18,0(sp)
811271b0:	1029883a 	mov	r20,r2
811271b4:	003fc506 	br	811270cc <__reset+0xfb1070cc>
811271b8:	800d883a 	mov	r6,r16
811271bc:	a80b883a 	mov	r5,r21
811271c0:	9809883a 	mov	r4,r19
811271c4:	111d2c40 	call	8111d2c4 <__swbuf_r>
811271c8:	10bfffe0 	cmpeqi	r2,r2,-1
811271cc:	003fef06 	br	8112718c <__reset+0xfb10718c>

811271d0 <_fputwc_r>:
811271d0:	3080030b 	ldhu	r2,12(r6)
811271d4:	10c8000c 	andi	r3,r2,8192
811271d8:	1800051e 	bne	r3,zero,811271f0 <_fputwc_r+0x20>
811271dc:	30c01917 	ldw	r3,100(r6)
811271e0:	10880014 	ori	r2,r2,8192
811271e4:	3080030d 	sth	r2,12(r6)
811271e8:	18880014 	ori	r2,r3,8192
811271ec:	30801915 	stw	r2,100(r6)
811271f0:	11270641 	jmpi	81127064 <__fputwc>

811271f4 <fputwc>:
811271f4:	00a04534 	movhi	r2,33044
811271f8:	defffc04 	addi	sp,sp,-16
811271fc:	109aed04 	addi	r2,r2,27572
81127200:	de00012e 	bgeu	sp,et,81127208 <fputwc+0x14>
81127204:	003b68fa 	trap	3
81127208:	dc000115 	stw	r16,4(sp)
8112720c:	14000017 	ldw	r16,0(r2)
81127210:	dc400215 	stw	r17,8(sp)
81127214:	dfc00315 	stw	ra,12(sp)
81127218:	2023883a 	mov	r17,r4
8112721c:	80000226 	beq	r16,zero,81127228 <fputwc+0x34>
81127220:	80800e17 	ldw	r2,56(r16)
81127224:	10001026 	beq	r2,zero,81127268 <fputwc+0x74>
81127228:	2880030b 	ldhu	r2,12(r5)
8112722c:	10c8000c 	andi	r3,r2,8192
81127230:	1800051e 	bne	r3,zero,81127248 <fputwc+0x54>
81127234:	28c01917 	ldw	r3,100(r5)
81127238:	10880014 	ori	r2,r2,8192
8112723c:	2880030d 	sth	r2,12(r5)
81127240:	18880014 	ori	r2,r3,8192
81127244:	28801915 	stw	r2,100(r5)
81127248:	280d883a 	mov	r6,r5
8112724c:	8009883a 	mov	r4,r16
81127250:	880b883a 	mov	r5,r17
81127254:	dfc00317 	ldw	ra,12(sp)
81127258:	dc400217 	ldw	r17,8(sp)
8112725c:	dc000117 	ldw	r16,4(sp)
81127260:	dec00404 	addi	sp,sp,16
81127264:	11270641 	jmpi	81127064 <__fputwc>
81127268:	8009883a 	mov	r4,r16
8112726c:	d9400015 	stw	r5,0(sp)
81127270:	111f4fc0 	call	8111f4fc <__sinit>
81127274:	d9400017 	ldw	r5,0(sp)
81127278:	003feb06 	br	81127228 <__reset+0xfb107228>

8112727c <rshift>:
8112727c:	2807d17a 	srai	r3,r5,5
81127280:	20800417 	ldw	r2,16(r4)
81127284:	22000504 	addi	r8,r4,20
81127288:	1880250e 	bge	r3,r2,81127320 <rshift+0xa4>
8112728c:	1085883a 	add	r2,r2,r2
81127290:	18c7883a 	add	r3,r3,r3
81127294:	1085883a 	add	r2,r2,r2
81127298:	18c7883a 	add	r3,r3,r3
8112729c:	294007cc 	andi	r5,r5,31
811272a0:	4085883a 	add	r2,r8,r2
811272a4:	40c7883a 	add	r3,r8,r3
811272a8:	28002026 	beq	r5,zero,8112732c <rshift+0xb0>
811272ac:	19800017 	ldw	r6,0(r3)
811272b0:	02c00804 	movi	r11,32
811272b4:	19c00104 	addi	r7,r3,4
811272b8:	5957c83a 	sub	r11,r11,r5
811272bc:	314cd83a 	srl	r6,r6,r5
811272c0:	38802c2e 	bgeu	r7,r2,81127374 <rshift+0xf8>
811272c4:	4015883a 	mov	r10,r8
811272c8:	3a400017 	ldw	r9,0(r7)
811272cc:	52800104 	addi	r10,r10,4
811272d0:	39c00104 	addi	r7,r7,4
811272d4:	4ad2983a 	sll	r9,r9,r11
811272d8:	498cb03a 	or	r6,r9,r6
811272dc:	51bfff15 	stw	r6,-4(r10)
811272e0:	39bfff17 	ldw	r6,-4(r7)
811272e4:	314cd83a 	srl	r6,r6,r5
811272e8:	38bff736 	bltu	r7,r2,811272c8 <__reset+0xfb1072c8>
811272ec:	10c7c83a 	sub	r3,r2,r3
811272f0:	18fffec4 	addi	r3,r3,-5
811272f4:	1806d0ba 	srli	r3,r3,2
811272f8:	18c00044 	addi	r3,r3,1
811272fc:	18c7883a 	add	r3,r3,r3
81127300:	18c7883a 	add	r3,r3,r3
81127304:	40c7883a 	add	r3,r8,r3
81127308:	19800015 	stw	r6,0(r3)
8112730c:	30000126 	beq	r6,zero,81127314 <rshift+0x98>
81127310:	18c00104 	addi	r3,r3,4
81127314:	1a05c83a 	sub	r2,r3,r8
81127318:	1005d0ba 	srai	r2,r2,2
8112731c:	00001206 	br	81127368 <rshift+0xec>
81127320:	20000415 	stw	zero,16(r4)
81127324:	20000515 	stw	zero,20(r4)
81127328:	f800283a 	ret
8112732c:	18bffc2e 	bgeu	r3,r2,81127320 <__reset+0xfb107320>
81127330:	180d883a 	mov	r6,r3
81127334:	400b883a 	mov	r5,r8
81127338:	31c00017 	ldw	r7,0(r6)
8112733c:	29400104 	addi	r5,r5,4
81127340:	31800104 	addi	r6,r6,4
81127344:	29ffff15 	stw	r7,-4(r5)
81127348:	30bffb36 	bltu	r6,r2,81127338 <__reset+0xfb107338>
8112734c:	00c6303a 	nor	r3,zero,r3
81127350:	1885883a 	add	r2,r3,r2
81127354:	1004d0ba 	srli	r2,r2,2
81127358:	10800044 	addi	r2,r2,1
8112735c:	1085883a 	add	r2,r2,r2
81127360:	1085883a 	add	r2,r2,r2
81127364:	1005d0ba 	srai	r2,r2,2
81127368:	20800415 	stw	r2,16(r4)
8112736c:	103fed26 	beq	r2,zero,81127324 <__reset+0xfb107324>
81127370:	f800283a 	ret
81127374:	4007883a 	mov	r3,r8
81127378:	003fe306 	br	81127308 <__reset+0xfb107308>

8112737c <__gethex>:
8112737c:	deffeb04 	addi	sp,sp,-84
81127380:	de00012e 	bgeu	sp,et,81127388 <__gethex+0xc>
81127384:	003b68fa 	trap	3
81127388:	dfc01415 	stw	ra,80(sp)
8112738c:	dd801115 	stw	r22,68(sp)
81127390:	dcc00e15 	stw	r19,56(sp)
81127394:	dc800d15 	stw	r18,52(sp)
81127398:	2827883a 	mov	r19,r5
8112739c:	d9000115 	stw	r4,4(sp)
811273a0:	d9800015 	stw	r6,0(sp)
811273a4:	d9c00415 	stw	r7,16(sp)
811273a8:	df001315 	stw	fp,76(sp)
811273ac:	ddc01215 	stw	r23,72(sp)
811273b0:	dd401015 	stw	r21,64(sp)
811273b4:	dd000f15 	stw	r20,60(sp)
811273b8:	dc400c15 	stw	r17,48(sp)
811273bc:	dc000b15 	stw	r16,44(sp)
811273c0:	11204480 	call	81120448 <_localeconv_r>
811273c4:	14800017 	ldw	r18,0(r2)
811273c8:	9009883a 	mov	r4,r18
811273cc:	11172280 	call	81117228 <strlen>
811273d0:	98c00017 	ldw	r3,0(r19)
811273d4:	102d883a 	mov	r22,r2
811273d8:	9085883a 	add	r2,r18,r2
811273dc:	10bfffc3 	ldbu	r2,-1(r2)
811273e0:	19000083 	ldbu	r4,2(r3)
811273e4:	d8800305 	stb	r2,12(sp)
811273e8:	00800c04 	movi	r2,48
811273ec:	2081521e 	bne	r4,r2,81127938 <__gethex+0x5bc>
811273f0:	017fff84 	movi	r5,-2
811273f4:	188000c4 	addi	r2,r3,3
811273f8:	28cbc83a 	sub	r5,r5,r3
811273fc:	200d883a 	mov	r6,r4
81127400:	28a3883a 	add	r17,r5,r2
81127404:	102b883a 	mov	r21,r2
81127408:	10800044 	addi	r2,r2,1
8112740c:	113fffc3 	ldbu	r4,-1(r2)
81127410:	21bffb26 	beq	r4,r6,81127400 <__reset+0xfb107400>
81127414:	05204534 	movhi	r20,33044
81127418:	a511b804 	addi	r20,r20,18144
8112741c:	a109883a 	add	r4,r20,r4
81127420:	20800003 	ldbu	r2,0(r4)
81127424:	10008826 	beq	r2,zero,81127648 <__gethex+0x2cc>
81127428:	a8800003 	ldbu	r2,0(r21)
8112742c:	0015883a 	mov	r10,zero
81127430:	002f883a 	mov	r23,zero
81127434:	a085883a 	add	r2,r20,r2
81127438:	10800003 	ldbu	r2,0(r2)
8112743c:	a821883a 	mov	r16,r21
81127440:	10000526 	beq	r2,zero,81127458 <__gethex+0xdc>
81127444:	84000044 	addi	r16,r16,1
81127448:	80800003 	ldbu	r2,0(r16)
8112744c:	a085883a 	add	r2,r20,r2
81127450:	10800003 	ldbu	r2,0(r2)
81127454:	103ffb1e 	bne	r2,zero,81127444 <__reset+0xfb107444>
81127458:	b00d883a 	mov	r6,r22
8112745c:	900b883a 	mov	r5,r18
81127460:	8009883a 	mov	r4,r16
81127464:	da800a15 	stw	r10,40(sp)
81127468:	1127e180 	call	81127e18 <strncmp>
8112746c:	da800a17 	ldw	r10,40(sp)
81127470:	1000031e 	bne	r2,zero,81127480 <__gethex+0x104>
81127474:	b8015226 	beq	r23,zero,811279c0 <__gethex+0x644>
81127478:	80800003 	ldbu	r2,0(r16)
8112747c:	00000206 	br	81127488 <__gethex+0x10c>
81127480:	80800003 	ldbu	r2,0(r16)
81127484:	b8011f26 	beq	r23,zero,81127904 <__gethex+0x588>
81127488:	85efc83a 	sub	r23,r16,r23
8112748c:	bdef883a 	add	r23,r23,r23
81127490:	bdef883a 	add	r23,r23,r23
81127494:	05efc83a 	sub	r23,zero,r23
81127498:	10803fcc 	andi	r2,r2,255
8112749c:	01001404 	movi	r4,80
811274a0:	11008626 	beq	r2,r4,811276bc <__gethex+0x340>
811274a4:	01001c04 	movi	r4,112
811274a8:	11008426 	beq	r2,r4,811276bc <__gethex+0x340>
811274ac:	8039883a 	mov	fp,r16
811274b0:	9c000015 	stw	r16,0(r19)
811274b4:	5000711e 	bne	r10,zero,8112767c <__gethex+0x300>
811274b8:	e545c83a 	sub	r2,fp,r21
811274bc:	10bfffc4 	addi	r2,r2,-1
811274c0:	010001c4 	movi	r4,7
811274c4:	000b883a 	mov	r5,zero
811274c8:	2080030e 	bge	r4,r2,811274d8 <__gethex+0x15c>
811274cc:	1005d07a 	srai	r2,r2,1
811274d0:	29400044 	addi	r5,r5,1
811274d4:	20bffd16 	blt	r4,r2,811274cc <__reset+0xfb1074cc>
811274d8:	d9000117 	ldw	r4,4(sp)
811274dc:	11209640 	call	81120964 <_Balloc>
811274e0:	10c00504 	addi	r3,r2,20
811274e4:	d8c00215 	stw	r3,8(sp)
811274e8:	1021883a 	mov	r16,r2
811274ec:	af01732e 	bgeu	r21,fp,81127abc <__gethex+0x740>
811274f0:	dc400303 	ldbu	r17,12(sp)
811274f4:	03400044 	movi	r13,1
811274f8:	1815883a 	mov	r10,r3
811274fc:	0013883a 	mov	r9,zero
81127500:	0027883a 	mov	r19,zero
81127504:	6d9bc83a 	sub	r13,r13,r22
81127508:	02c00804 	movi	r11,32
8112750c:	e0bfffc3 	ldbu	r2,-1(fp)
81127510:	e3bfffc4 	addi	r14,fp,-1
81127514:	88803026 	beq	r17,r2,811275d8 <__gethex+0x25c>
81127518:	9ac04526 	beq	r19,r11,81127630 <__gethex+0x2b4>
8112751c:	980b883a 	mov	r5,r19
81127520:	9cc00104 	addi	r19,r19,4
81127524:	e13fffc3 	ldbu	r4,-1(fp)
81127528:	7039883a 	mov	fp,r14
8112752c:	a109883a 	add	r4,r20,r4
81127530:	20800003 	ldbu	r2,0(r4)
81127534:	108003cc 	andi	r2,r2,15
81127538:	1144983a 	sll	r2,r2,r5
8112753c:	4892b03a 	or	r9,r9,r2
81127540:	af3ff236 	bltu	r21,fp,8112750c <__reset+0xfb10750c>
81127544:	d8c00217 	ldw	r3,8(sp)
81127548:	50800104 	addi	r2,r10,4
8112754c:	52400015 	stw	r9,0(r10)
81127550:	10c5c83a 	sub	r2,r2,r3
81127554:	1005d0ba 	srai	r2,r2,2
81127558:	4809883a 	mov	r4,r9
8112755c:	80800415 	stw	r2,16(r16)
81127560:	1022917a 	slli	r17,r2,5
81127564:	1120c700 	call	81120c70 <__hi0bits>
81127568:	d8c00017 	ldw	r3,0(sp)
8112756c:	8885c83a 	sub	r2,r17,r2
81127570:	1c800017 	ldw	r18,0(r3)
81127574:	9080c716 	blt	r18,r2,81127894 <__gethex+0x518>
81127578:	1480e416 	blt	r2,r18,8112790c <__gethex+0x590>
8112757c:	0027883a 	mov	r19,zero
81127580:	d8c00017 	ldw	r3,0(sp)
81127584:	18800217 	ldw	r2,8(r3)
81127588:	15c08d16 	blt	r2,r23,811277c0 <__gethex+0x444>
8112758c:	d8c00017 	ldw	r3,0(sp)
81127590:	18800117 	ldw	r2,4(r3)
81127594:	b880aa0e 	bge	r23,r2,81127840 <__gethex+0x4c4>
81127598:	15efc83a 	sub	r23,r2,r23
8112759c:	bc80ed16 	blt	r23,r18,81127954 <__gethex+0x5d8>
811275a0:	18c00317 	ldw	r3,12(r3)
811275a4:	01000084 	movi	r4,2
811275a8:	19014926 	beq	r3,r4,81127ad0 <__gethex+0x754>
811275ac:	010000c4 	movi	r4,3
811275b0:	19012e26 	beq	r3,r4,81127a6c <__gethex+0x6f0>
811275b4:	01000044 	movi	r4,1
811275b8:	19014826 	beq	r3,r4,81127adc <__gethex+0x760>
811275bc:	d9000117 	ldw	r4,4(sp)
811275c0:	800b883a 	mov	r5,r16
811275c4:	1120a140 	call	81120a14 <_Bfree>
811275c8:	d8801517 	ldw	r2,84(sp)
811275cc:	10000015 	stw	zero,0(r2)
811275d0:	00801404 	movi	r2,80
811275d4:	00002b06 	br	81127684 <__gethex+0x308>
811275d8:	735f883a 	add	r15,r14,r13
811275dc:	7d7fce36 	bltu	r15,r21,81127518 <__reset+0xfb107518>
811275e0:	7809883a 	mov	r4,r15
811275e4:	b00d883a 	mov	r6,r22
811275e8:	900b883a 	mov	r5,r18
811275ec:	da400515 	stw	r9,20(sp)
811275f0:	da800a15 	stw	r10,40(sp)
811275f4:	dac00915 	stw	r11,36(sp)
811275f8:	db400815 	stw	r13,32(sp)
811275fc:	db800615 	stw	r14,24(sp)
81127600:	dbc00715 	stw	r15,28(sp)
81127604:	1127e180 	call	81127e18 <strncmp>
81127608:	da400517 	ldw	r9,20(sp)
8112760c:	da800a17 	ldw	r10,40(sp)
81127610:	dac00917 	ldw	r11,36(sp)
81127614:	db400817 	ldw	r13,32(sp)
81127618:	db800617 	ldw	r14,24(sp)
8112761c:	dbc00717 	ldw	r15,28(sp)
81127620:	103fbd1e 	bne	r2,zero,81127518 <__reset+0xfb107518>
81127624:	7839883a 	mov	fp,r15
81127628:	af3fb836 	bltu	r21,fp,8112750c <__reset+0xfb10750c>
8112762c:	003fc506 	br	81127544 <__reset+0xfb107544>
81127630:	04c00104 	movi	r19,4
81127634:	52400015 	stw	r9,0(r10)
81127638:	000b883a 	mov	r5,zero
8112763c:	54d5883a 	add	r10,r10,r19
81127640:	0013883a 	mov	r9,zero
81127644:	003fb706 	br	81127524 <__reset+0xfb107524>
81127648:	b00d883a 	mov	r6,r22
8112764c:	900b883a 	mov	r5,r18
81127650:	a809883a 	mov	r4,r21
81127654:	1127e180 	call	81127e18 <strncmp>
81127658:	10006426 	beq	r2,zero,811277ec <__gethex+0x470>
8112765c:	a8800003 	ldbu	r2,0(r21)
81127660:	a821883a 	mov	r16,r21
81127664:	10803fcc 	andi	r2,r2,255
81127668:	01001404 	movi	r4,80
8112766c:	11001126 	beq	r2,r4,811276b4 <__gethex+0x338>
81127670:	01001c04 	movi	r4,112
81127674:	11000f26 	beq	r2,r4,811276b4 <__gethex+0x338>
81127678:	9c000015 	stw	r16,0(r19)
8112767c:	8800831e 	bne	r17,zero,8112788c <__gethex+0x510>
81127680:	00800184 	movi	r2,6
81127684:	dfc01417 	ldw	ra,80(sp)
81127688:	df001317 	ldw	fp,76(sp)
8112768c:	ddc01217 	ldw	r23,72(sp)
81127690:	dd801117 	ldw	r22,68(sp)
81127694:	dd401017 	ldw	r21,64(sp)
81127698:	dd000f17 	ldw	r20,60(sp)
8112769c:	dcc00e17 	ldw	r19,56(sp)
811276a0:	dc800d17 	ldw	r18,52(sp)
811276a4:	dc400c17 	ldw	r17,48(sp)
811276a8:	dc000b17 	ldw	r16,44(sp)
811276ac:	dec01504 	addi	sp,sp,84
811276b0:	f800283a 	ret
811276b4:	002f883a 	mov	r23,zero
811276b8:	02800044 	movi	r10,1
811276bc:	80800043 	ldbu	r2,1(r16)
811276c0:	01400ac4 	movi	r5,43
811276c4:	11003fcc 	andi	r4,r2,255
811276c8:	21406e26 	beq	r4,r5,81127884 <__gethex+0x508>
811276cc:	01400b44 	movi	r5,45
811276d0:	21404226 	beq	r4,r5,811277dc <__gethex+0x460>
811276d4:	81400044 	addi	r5,r16,1
811276d8:	000d883a 	mov	r6,zero
811276dc:	10803fcc 	andi	r2,r2,255
811276e0:	a085883a 	add	r2,r20,r2
811276e4:	11000003 	ldbu	r4,0(r2)
811276e8:	03000604 	movi	r12,24
811276ec:	20bfffc4 	addi	r2,r4,-1
811276f0:	10803fcc 	andi	r2,r2,255
811276f4:	60bf6d36 	bltu	r12,r2,811274ac <__reset+0xfb1074ac>
811276f8:	2ac00043 	ldbu	r11,1(r5)
811276fc:	20803fcc 	andi	r2,r4,255
81127700:	01204534 	movhi	r4,33044
81127704:	2111b804 	addi	r4,r4,18144
81127708:	22c9883a 	add	r4,r4,r11
8112770c:	23400003 	ldbu	r13,0(r4)
81127710:	10bffc04 	addi	r2,r2,-16
81127714:	29400044 	addi	r5,r5,1
81127718:	693fffc4 	addi	r4,r13,-1
8112771c:	21003fcc 	andi	r4,r4,255
81127720:	6b403fcc 	andi	r13,r13,255
81127724:	61000b36 	bltu	r12,r4,81127754 <__gethex+0x3d8>
81127728:	29400044 	addi	r5,r5,1
8112772c:	29000003 	ldbu	r4,0(r5)
81127730:	108002a4 	muli	r2,r2,10
81127734:	a109883a 	add	r4,r20,r4
81127738:	22c00003 	ldbu	r11,0(r4)
8112773c:	1345883a 	add	r2,r2,r13
81127740:	10bffc04 	addi	r2,r2,-16
81127744:	593fffc4 	addi	r4,r11,-1
81127748:	21003fcc 	andi	r4,r4,255
8112774c:	5b403fcc 	andi	r13,r11,255
81127750:	613ff52e 	bgeu	r12,r4,81127728 <__reset+0xfb107728>
81127754:	30000126 	beq	r6,zero,8112775c <__gethex+0x3e0>
81127758:	0085c83a 	sub	r2,zero,r2
8112775c:	8039883a 	mov	fp,r16
81127760:	b8af883a 	add	r23,r23,r2
81127764:	2821883a 	mov	r16,r5
81127768:	003f5106 	br	811274b0 <__reset+0xfb1074b0>
8112776c:	80800217 	ldw	r2,8(r16)
81127770:	e080f00e 	bge	fp,r2,81127b34 <__gethex+0x7b8>
81127774:	e007883a 	mov	r3,fp
81127778:	18800144 	addi	r2,r3,5
8112777c:	1085883a 	add	r2,r2,r2
81127780:	18c00044 	addi	r3,r3,1
81127784:	1085883a 	add	r2,r2,r2
81127788:	8085883a 	add	r2,r16,r2
8112778c:	80c00415 	stw	r3,16(r16)
81127790:	01000044 	movi	r4,1
81127794:	11000015 	stw	r4,0(r2)
81127798:	00800084 	movi	r2,2
8112779c:	8880d826 	beq	r17,r2,81127b00 <__gethex+0x784>
811277a0:	e0c0ac0e 	bge	fp,r3,81127a54 <__gethex+0x6d8>
811277a4:	01400044 	movi	r5,1
811277a8:	8009883a 	mov	r4,r16
811277ac:	112727c0 	call	8112727c <rshift>
811277b0:	d8c00017 	ldw	r3,0(sp)
811277b4:	bdc00044 	addi	r23,r23,1
811277b8:	18800217 	ldw	r2,8(r3)
811277bc:	15c0a70e 	bge	r2,r23,81127a5c <__gethex+0x6e0>
811277c0:	d9000117 	ldw	r4,4(sp)
811277c4:	800b883a 	mov	r5,r16
811277c8:	1120a140 	call	81120a14 <_Bfree>
811277cc:	d9001517 	ldw	r4,84(sp)
811277d0:	008028c4 	movi	r2,163
811277d4:	20000015 	stw	zero,0(r4)
811277d8:	003faa06 	br	81127684 <__reset+0xfb107684>
811277dc:	01800044 	movi	r6,1
811277e0:	80800083 	ldbu	r2,2(r16)
811277e4:	81400084 	addi	r5,r16,2
811277e8:	003fbc06 	br	811276dc <__reset+0xfb1076dc>
811277ec:	ada1883a 	add	r16,r21,r22
811277f0:	81000003 	ldbu	r4,0(r16)
811277f4:	21403fcc 	andi	r5,r4,255
811277f8:	a145883a 	add	r2,r20,r5
811277fc:	10800003 	ldbu	r2,0(r2)
81127800:	11803fcc 	andi	r6,r2,255
81127804:	30004f26 	beq	r6,zero,81127944 <__gethex+0x5c8>
81127808:	00c00c04 	movi	r3,48
8112780c:	802b883a 	mov	r21,r16
81127810:	28c0061e 	bne	r5,r3,8112782c <__gethex+0x4b0>
81127814:	2809883a 	mov	r4,r5
81127818:	ad400044 	addi	r21,r21,1
8112781c:	a8800003 	ldbu	r2,0(r21)
81127820:	113ffd26 	beq	r2,r4,81127818 <__reset+0xfb107818>
81127824:	a085883a 	add	r2,r20,r2
81127828:	10800003 	ldbu	r2,0(r2)
8112782c:	10803fcc 	andi	r2,r2,255
81127830:	1015003a 	cmpeq	r10,r2,zero
81127834:	802f883a 	mov	r23,r16
81127838:	04400044 	movi	r17,1
8112783c:	003eff06 	br	8112743c <__reset+0xfb10743c>
81127840:	04400044 	movi	r17,1
81127844:	98000926 	beq	r19,zero,8112786c <__gethex+0x4f0>
81127848:	d8c00017 	ldw	r3,0(sp)
8112784c:	18800317 	ldw	r2,12(r3)
81127850:	00c00084 	movi	r3,2
81127854:	10c06826 	beq	r2,r3,811279f8 <__gethex+0x67c>
81127858:	00c000c4 	movi	r3,3
8112785c:	10c06a26 	beq	r2,r3,81127a08 <__gethex+0x68c>
81127860:	00c00044 	movi	r3,1
81127864:	10c08d26 	beq	r2,r3,81127a9c <__gethex+0x720>
81127868:	8c400414 	ori	r17,r17,16
8112786c:	d9001517 	ldw	r4,84(sp)
81127870:	d8c00417 	ldw	r3,16(sp)
81127874:	8805883a 	mov	r2,r17
81127878:	24000015 	stw	r16,0(r4)
8112787c:	1dc00015 	stw	r23,0(r3)
81127880:	003f8006 	br	81127684 <__reset+0xfb107684>
81127884:	000d883a 	mov	r6,zero
81127888:	003fd506 	br	811277e0 <__reset+0xfb1077e0>
8112788c:	0005883a 	mov	r2,zero
81127890:	003f7c06 	br	81127684 <__reset+0xfb107684>
81127894:	14a3c83a 	sub	r17,r2,r18
81127898:	880b883a 	mov	r5,r17
8112789c:	8009883a 	mov	r4,r16
811278a0:	11219340 	call	81121934 <__any_on>
811278a4:	10002926 	beq	r2,zero,8112794c <__gethex+0x5d0>
811278a8:	897fffc4 	addi	r5,r17,-1
811278ac:	2807d17a 	srai	r3,r5,5
811278b0:	d8800217 	ldw	r2,8(sp)
811278b4:	290007cc 	andi	r4,r5,31
811278b8:	18c7883a 	add	r3,r3,r3
811278bc:	18c7883a 	add	r3,r3,r3
811278c0:	04c00044 	movi	r19,1
811278c4:	10c7883a 	add	r3,r2,r3
811278c8:	9908983a 	sll	r4,r19,r4
811278cc:	18c00017 	ldw	r3,0(r3)
811278d0:	20c6703a 	and	r3,r4,r3
811278d4:	18000626 	beq	r3,zero,811278f0 <__gethex+0x574>
811278d8:	99407b0e 	bge	r19,r5,81127ac8 <__gethex+0x74c>
811278dc:	897fff84 	addi	r5,r17,-2
811278e0:	8009883a 	mov	r4,r16
811278e4:	11219340 	call	81121934 <__any_on>
811278e8:	10007726 	beq	r2,zero,81127ac8 <__gethex+0x74c>
811278ec:	04c000c4 	movi	r19,3
811278f0:	880b883a 	mov	r5,r17
811278f4:	8009883a 	mov	r4,r16
811278f8:	112727c0 	call	8112727c <rshift>
811278fc:	bc6f883a 	add	r23,r23,r17
81127900:	003f1f06 	br	81127580 <__reset+0xfb107580>
81127904:	002f883a 	mov	r23,zero
81127908:	003ee306 	br	81127498 <__reset+0xfb107498>
8112790c:	d9000117 	ldw	r4,4(sp)
81127910:	90a3c83a 	sub	r17,r18,r2
81127914:	800b883a 	mov	r5,r16
81127918:	880d883a 	mov	r6,r17
8112791c:	11211140 	call	81121114 <__lshift>
81127920:	10c00504 	addi	r3,r2,20
81127924:	1021883a 	mov	r16,r2
81127928:	bc6fc83a 	sub	r23,r23,r17
8112792c:	d8c00215 	stw	r3,8(sp)
81127930:	0027883a 	mov	r19,zero
81127934:	003f1206 	br	81127580 <__reset+0xfb107580>
81127938:	1d400084 	addi	r21,r3,2
8112793c:	0023883a 	mov	r17,zero
81127940:	003eb406 	br	81127414 <__reset+0xfb107414>
81127944:	2005883a 	mov	r2,r4
81127948:	003f4606 	br	81127664 <__reset+0xfb107664>
8112794c:	0027883a 	mov	r19,zero
81127950:	003fe706 	br	811278f0 <__reset+0xfb1078f0>
81127954:	bc7fffc4 	addi	r17,r23,-1
81127958:	9800421e 	bne	r19,zero,81127a64 <__gethex+0x6e8>
8112795c:	88000426 	beq	r17,zero,81127970 <__gethex+0x5f4>
81127960:	880b883a 	mov	r5,r17
81127964:	8009883a 	mov	r4,r16
81127968:	11219340 	call	81121934 <__any_on>
8112796c:	1027883a 	mov	r19,r2
81127970:	8805d17a 	srai	r2,r17,5
81127974:	d8c00217 	ldw	r3,8(sp)
81127978:	8c4007cc 	andi	r17,r17,31
8112797c:	1085883a 	add	r2,r2,r2
81127980:	1085883a 	add	r2,r2,r2
81127984:	1885883a 	add	r2,r3,r2
81127988:	00c00044 	movi	r3,1
8112798c:	1c62983a 	sll	r17,r3,r17
81127990:	10800017 	ldw	r2,0(r2)
81127994:	8884703a 	and	r2,r17,r2
81127998:	10000126 	beq	r2,zero,811279a0 <__gethex+0x624>
8112799c:	9cc00094 	ori	r19,r19,2
811279a0:	b80b883a 	mov	r5,r23
811279a4:	8009883a 	mov	r4,r16
811279a8:	112727c0 	call	8112727c <rshift>
811279ac:	d8c00017 	ldw	r3,0(sp)
811279b0:	95e5c83a 	sub	r18,r18,r23
811279b4:	04400084 	movi	r17,2
811279b8:	1dc00117 	ldw	r23,4(r3)
811279bc:	003fa106 	br	81127844 <__reset+0xfb107844>
811279c0:	85af883a 	add	r23,r16,r22
811279c4:	b8800003 	ldbu	r2,0(r23)
811279c8:	b821883a 	mov	r16,r23
811279cc:	11003fcc 	andi	r4,r2,255
811279d0:	a109883a 	add	r4,r20,r4
811279d4:	21000003 	ldbu	r4,0(r4)
811279d8:	203eaa26 	beq	r4,zero,81127484 <__reset+0xfb107484>
811279dc:	84000044 	addi	r16,r16,1
811279e0:	80800003 	ldbu	r2,0(r16)
811279e4:	11003fcc 	andi	r4,r2,255
811279e8:	a109883a 	add	r4,r20,r4
811279ec:	21000003 	ldbu	r4,0(r4)
811279f0:	203ffa1e 	bne	r4,zero,811279dc <__reset+0xfb1079dc>
811279f4:	003ea306 	br	81127484 <__reset+0xfb107484>
811279f8:	d9001617 	ldw	r4,88(sp)
811279fc:	00800044 	movi	r2,1
81127a00:	1109c83a 	sub	r4,r2,r4
81127a04:	d9001615 	stw	r4,88(sp)
81127a08:	d8801617 	ldw	r2,88(sp)
81127a0c:	103f9626 	beq	r2,zero,81127868 <__reset+0xfb107868>
81127a10:	87000417 	ldw	fp,16(r16)
81127a14:	d9800217 	ldw	r6,8(sp)
81127a18:	013fffc4 	movi	r4,-1
81127a1c:	e727883a 	add	r19,fp,fp
81127a20:	9ce7883a 	add	r19,r19,r19
81127a24:	3005883a 	mov	r2,r6
81127a28:	34cb883a 	add	r5,r6,r19
81127a2c:	00000306 	br	81127a3c <__gethex+0x6c0>
81127a30:	10000015 	stw	zero,0(r2)
81127a34:	10800104 	addi	r2,r2,4
81127a38:	117f4c2e 	bgeu	r2,r5,8112776c <__reset+0xfb10776c>
81127a3c:	10c00017 	ldw	r3,0(r2)
81127a40:	193ffb26 	beq	r3,r4,81127a30 <__reset+0xfb107a30>
81127a44:	18c00044 	addi	r3,r3,1
81127a48:	10c00015 	stw	r3,0(r2)
81127a4c:	00800084 	movi	r2,2
81127a50:	88802b26 	beq	r17,r2,81127b00 <__gethex+0x784>
81127a54:	948007cc 	andi	r18,r18,31
81127a58:	90002f1e 	bne	r18,zero,81127b18 <__gethex+0x79c>
81127a5c:	04400844 	movi	r17,33
81127a60:	003f8206 	br	8112786c <__reset+0xfb10786c>
81127a64:	04c00044 	movi	r19,1
81127a68:	003fc106 	br	81127970 <__reset+0xfb107970>
81127a6c:	d8c01617 	ldw	r3,88(sp)
81127a70:	183ed226 	beq	r3,zero,811275bc <__reset+0xfb1075bc>
81127a74:	d8c00417 	ldw	r3,16(sp)
81127a78:	d9001517 	ldw	r4,84(sp)
81127a7c:	18800015 	stw	r2,0(r3)
81127a80:	d8c00217 	ldw	r3,8(sp)
81127a84:	00800044 	movi	r2,1
81127a88:	80800415 	stw	r2,16(r16)
81127a8c:	18800015 	stw	r2,0(r3)
81127a90:	24000015 	stw	r16,0(r4)
81127a94:	00801884 	movi	r2,98
81127a98:	003efa06 	br	81127684 <__reset+0xfb107684>
81127a9c:	9880008c 	andi	r2,r19,2
81127aa0:	103f7126 	beq	r2,zero,81127868 <__reset+0xfb107868>
81127aa4:	d8c00217 	ldw	r3,8(sp)
81127aa8:	18800017 	ldw	r2,0(r3)
81127aac:	9884b03a 	or	r2,r19,r2
81127ab0:	1080004c 	andi	r2,r2,1
81127ab4:	103fd61e 	bne	r2,zero,81127a10 <__reset+0xfb107a10>
81127ab8:	003f6b06 	br	81127868 <__reset+0xfb107868>
81127abc:	da800217 	ldw	r10,8(sp)
81127ac0:	0013883a 	mov	r9,zero
81127ac4:	003e9f06 	br	81127544 <__reset+0xfb107544>
81127ac8:	04c00084 	movi	r19,2
81127acc:	003f8806 	br	811278f0 <__reset+0xfb1078f0>
81127ad0:	d9001617 	ldw	r4,88(sp)
81127ad4:	203fe726 	beq	r4,zero,81127a74 <__reset+0xfb107a74>
81127ad8:	003eb806 	br	811275bc <__reset+0xfb1075bc>
81127adc:	95feb71e 	bne	r18,r23,811275bc <__reset+0xfb1075bc>
81127ae0:	1cbfe40e 	bge	r3,r18,81127a74 <__reset+0xfb107a74>
81127ae4:	917fffc4 	addi	r5,r18,-1
81127ae8:	8009883a 	mov	r4,r16
81127aec:	11219340 	call	81121934 <__any_on>
81127af0:	103eb226 	beq	r2,zero,811275bc <__reset+0xfb1075bc>
81127af4:	d8c00017 	ldw	r3,0(sp)
81127af8:	18800117 	ldw	r2,4(r3)
81127afc:	003fdd06 	br	81127a74 <__reset+0xfb107a74>
81127b00:	d8c00017 	ldw	r3,0(sp)
81127b04:	18800017 	ldw	r2,0(r3)
81127b08:	10bfffc4 	addi	r2,r2,-1
81127b0c:	90801c26 	beq	r18,r2,81127b80 <__gethex+0x804>
81127b10:	04400884 	movi	r17,34
81127b14:	003f5506 	br	8112786c <__reset+0xfb10786c>
81127b18:	34c5883a 	add	r2,r6,r19
81127b1c:	113fff17 	ldw	r4,-4(r2)
81127b20:	1120c700 	call	81120c70 <__hi0bits>
81127b24:	00c00804 	movi	r3,32
81127b28:	1ca5c83a 	sub	r18,r3,r18
81127b2c:	14bfcb0e 	bge	r2,r18,81127a5c <__reset+0xfb107a5c>
81127b30:	003f1c06 	br	811277a4 <__reset+0xfb1077a4>
81127b34:	81400117 	ldw	r5,4(r16)
81127b38:	d9000117 	ldw	r4,4(sp)
81127b3c:	29400044 	addi	r5,r5,1
81127b40:	11209640 	call	81120964 <_Balloc>
81127b44:	81800417 	ldw	r6,16(r16)
81127b48:	81400304 	addi	r5,r16,12
81127b4c:	11000304 	addi	r4,r2,12
81127b50:	31800084 	addi	r6,r6,2
81127b54:	318d883a 	add	r6,r6,r6
81127b58:	318d883a 	add	r6,r6,r6
81127b5c:	1029883a 	mov	r20,r2
81127b60:	11167340 	call	81116734 <memcpy>
81127b64:	d9000117 	ldw	r4,4(sp)
81127b68:	800b883a 	mov	r5,r16
81127b6c:	a021883a 	mov	r16,r20
81127b70:	1120a140 	call	81120a14 <_Bfree>
81127b74:	a0c00417 	ldw	r3,16(r20)
81127b78:	a1800504 	addi	r6,r20,20
81127b7c:	003efe06 	br	81127778 <__reset+0xfb107778>
81127b80:	9005d17a 	srai	r2,r18,5
81127b84:	944007cc 	andi	r17,r18,31
81127b88:	1085883a 	add	r2,r2,r2
81127b8c:	1085883a 	add	r2,r2,r2
81127b90:	3087883a 	add	r3,r6,r2
81127b94:	00800044 	movi	r2,1
81127b98:	1462983a 	sll	r17,r2,r17
81127b9c:	18800017 	ldw	r2,0(r3)
81127ba0:	8884703a 	and	r2,r17,r2
81127ba4:	1022c03a 	cmpne	r17,r2,zero
81127ba8:	00800884 	movi	r2,34
81127bac:	1463c83a 	sub	r17,r2,r17
81127bb0:	003f2e06 	br	8112786c <__reset+0xfb10786c>

81127bb4 <__hexnan>:
81127bb4:	defff904 	addi	sp,sp,-28
81127bb8:	de00012e 	bgeu	sp,et,81127bc0 <__hexnan+0xc>
81127bbc:	003b68fa 	trap	3
81127bc0:	dc800215 	stw	r18,8(sp)
81127bc4:	2c800017 	ldw	r18,0(r5)
81127bc8:	dfc00615 	stw	ra,24(sp)
81127bcc:	dd400515 	stw	r21,20(sp)
81127bd0:	901fd17a 	srai	r15,r18,5
81127bd4:	dd000415 	stw	r20,16(sp)
81127bd8:	dcc00315 	stw	r19,12(sp)
81127bdc:	7bdf883a 	add	r15,r15,r15
81127be0:	7bdf883a 	add	r15,r15,r15
81127be4:	dc400115 	stw	r17,4(sp)
81127be8:	dc000015 	stw	r16,0(sp)
81127bec:	948007cc 	andi	r18,r18,31
81127bf0:	33df883a 	add	r15,r6,r15
81127bf4:	90000126 	beq	r18,zero,81127bfc <__hexnan+0x48>
81127bf8:	7bc00104 	addi	r15,r15,4
81127bfc:	22000017 	ldw	r8,0(r4)
81127c00:	7affff04 	addi	r11,r15,-4
81127c04:	03a04534 	movhi	r14,33044
81127c08:	783fff15 	stw	zero,-4(r15)
81127c0c:	581b883a 	mov	r13,r11
81127c10:	580b883a 	mov	r5,r11
81127c14:	000f883a 	mov	r7,zero
81127c18:	003f883a 	mov	ra,zero
81127c1c:	0019883a 	mov	r12,zero
81127c20:	7391b804 	addi	r14,r14,18144
81127c24:	04400204 	movi	r17,8
81127c28:	04000804 	movi	r16,32
81127c2c:	04c001c4 	movi	r19,7
81127c30:	42000044 	addi	r8,r8,1
81127c34:	40c00003 	ldbu	r3,0(r8)
81127c38:	18001d26 	beq	r3,zero,81127cb0 <__hexnan+0xfc>
81127c3c:	70c5883a 	add	r2,r14,r3
81127c40:	10800003 	ldbu	r2,0(r2)
81127c44:	12403fcc 	andi	r9,r2,255
81127c48:	4800301e 	bne	r9,zero,81127d0c <__hexnan+0x158>
81127c4c:	80c04236 	bltu	r16,r3,81127d58 <__hexnan+0x1a4>
81127c50:	fb3ff70e 	bge	ra,r12,81127c30 <__reset+0xfb107c30>
81127c54:	2b40112e 	bgeu	r5,r13,81127c9c <__hexnan+0xe8>
81127c58:	99c01016 	blt	r19,r7,81127c9c <__hexnan+0xe8>
81127c5c:	89e9c83a 	sub	r20,r17,r7
81127c60:	a529883a 	add	r20,r20,r20
81127c64:	2a800017 	ldw	r10,0(r5)
81127c68:	a529883a 	add	r20,r20,r20
81127c6c:	852bc83a 	sub	r21,r16,r20
81127c70:	28c00104 	addi	r3,r5,4
81127c74:	2805883a 	mov	r2,r5
81127c78:	19c00017 	ldw	r7,0(r3)
81127c7c:	10800104 	addi	r2,r2,4
81127c80:	18c00104 	addi	r3,r3,4
81127c84:	3d52983a 	sll	r9,r7,r21
81127c88:	4a92b03a 	or	r9,r9,r10
81127c8c:	3d14d83a 	srl	r10,r7,r20
81127c90:	127fff15 	stw	r9,-4(r2)
81127c94:	1abfff15 	stw	r10,-4(r3)
81127c98:	137ff736 	bltu	r2,r13,81127c78 <__reset+0xfb107c78>
81127c9c:	31402836 	bltu	r6,r5,81127d40 <__hexnan+0x18c>
81127ca0:	42000044 	addi	r8,r8,1
81127ca4:	40c00003 	ldbu	r3,0(r8)
81127ca8:	01c00204 	movi	r7,8
81127cac:	183fe31e 	bne	r3,zero,81127c3c <__reset+0xfb107c3c>
81127cb0:	60002b26 	beq	r12,zero,81127d60 <__hexnan+0x1ac>
81127cb4:	2b40022e 	bgeu	r5,r13,81127cc0 <__hexnan+0x10c>
81127cb8:	008001c4 	movi	r2,7
81127cbc:	11c0430e 	bge	r2,r7,81127dcc <__hexnan+0x218>
81127cc0:	3140312e 	bgeu	r6,r5,81127d88 <__hexnan+0x1d4>
81127cc4:	3007883a 	mov	r3,r6
81127cc8:	29000017 	ldw	r4,0(r5)
81127ccc:	18800104 	addi	r2,r3,4
81127cd0:	29400104 	addi	r5,r5,4
81127cd4:	19000015 	stw	r4,0(r3)
81127cd8:	1007883a 	mov	r3,r2
81127cdc:	597ffa2e 	bgeu	r11,r5,81127cc8 <__reset+0xfb107cc8>
81127ce0:	10000015 	stw	zero,0(r2)
81127ce4:	10800104 	addi	r2,r2,4
81127ce8:	58bffd2e 	bgeu	r11,r2,81127ce0 <__reset+0xfb107ce0>
81127cec:	78bfff17 	ldw	r2,-4(r15)
81127cf0:	1000041e 	bne	r2,zero,81127d04 <__hexnan+0x150>
81127cf4:	32c02d26 	beq	r6,r11,81127dac <__hexnan+0x1f8>
81127cf8:	5affff04 	addi	r11,r11,-4
81127cfc:	58800017 	ldw	r2,0(r11)
81127d00:	103ffc26 	beq	r2,zero,81127cf4 <__reset+0xfb107cf4>
81127d04:	00800144 	movi	r2,5
81127d08:	00001606 	br	81127d64 <__hexnan+0x1b0>
81127d0c:	39c00044 	addi	r7,r7,1
81127d10:	63000044 	addi	r12,r12,1
81127d14:	89c0040e 	bge	r17,r7,81127d28 <__hexnan+0x174>
81127d18:	317fc52e 	bgeu	r6,r5,81127c30 <__reset+0xfb107c30>
81127d1c:	283fff15 	stw	zero,-4(r5)
81127d20:	01c00044 	movi	r7,1
81127d24:	297fff04 	addi	r5,r5,-4
81127d28:	28c00017 	ldw	r3,0(r5)
81127d2c:	108003cc 	andi	r2,r2,15
81127d30:	1806913a 	slli	r3,r3,4
81127d34:	1884b03a 	or	r2,r3,r2
81127d38:	28800015 	stw	r2,0(r5)
81127d3c:	003fbc06 	br	81127c30 <__reset+0xfb107c30>
81127d40:	2b7fff04 	addi	r13,r5,-4
81127d44:	283fff15 	stw	zero,-4(r5)
81127d48:	603f883a 	mov	ra,r12
81127d4c:	680b883a 	mov	r5,r13
81127d50:	000f883a 	mov	r7,zero
81127d54:	003fb606 	br	81127c30 <__reset+0xfb107c30>
81127d58:	00800a44 	movi	r2,41
81127d5c:	18801726 	beq	r3,r2,81127dbc <__hexnan+0x208>
81127d60:	00800104 	movi	r2,4
81127d64:	dfc00617 	ldw	ra,24(sp)
81127d68:	dd400517 	ldw	r21,20(sp)
81127d6c:	dd000417 	ldw	r20,16(sp)
81127d70:	dcc00317 	ldw	r19,12(sp)
81127d74:	dc800217 	ldw	r18,8(sp)
81127d78:	dc400117 	ldw	r17,4(sp)
81127d7c:	dc000017 	ldw	r16,0(sp)
81127d80:	dec00704 	addi	sp,sp,28
81127d84:	f800283a 	ret
81127d88:	903fd826 	beq	r18,zero,81127cec <__reset+0xfb107cec>
81127d8c:	00c00804 	movi	r3,32
81127d90:	1ca5c83a 	sub	r18,r3,r18
81127d94:	00ffffc4 	movi	r3,-1
81127d98:	78bfff17 	ldw	r2,-4(r15)
81127d9c:	1c86d83a 	srl	r3,r3,r18
81127da0:	1884703a 	and	r2,r3,r2
81127da4:	78bfff15 	stw	r2,-4(r15)
81127da8:	003fd106 	br	81127cf0 <__reset+0xfb107cf0>
81127dac:	00800044 	movi	r2,1
81127db0:	58800015 	stw	r2,0(r11)
81127db4:	00800144 	movi	r2,5
81127db8:	003fea06 	br	81127d64 <__reset+0xfb107d64>
81127dbc:	42000044 	addi	r8,r8,1
81127dc0:	22000015 	stw	r8,0(r4)
81127dc4:	603fbb1e 	bne	r12,zero,81127cb4 <__reset+0xfb107cb4>
81127dc8:	003fe506 	br	81127d60 <__reset+0xfb107d60>
81127dcc:	02400204 	movi	r9,8
81127dd0:	49d3c83a 	sub	r9,r9,r7
81127dd4:	4a53883a 	add	r9,r9,r9
81127dd8:	2a000017 	ldw	r8,0(r5)
81127ddc:	4a53883a 	add	r9,r9,r9
81127de0:	02800804 	movi	r10,32
81127de4:	5255c83a 	sub	r10,r10,r9
81127de8:	28c00104 	addi	r3,r5,4
81127dec:	2805883a 	mov	r2,r5
81127df0:	19c00017 	ldw	r7,0(r3)
81127df4:	10800104 	addi	r2,r2,4
81127df8:	18c00104 	addi	r3,r3,4
81127dfc:	3a88983a 	sll	r4,r7,r10
81127e00:	2208b03a 	or	r4,r4,r8
81127e04:	3a50d83a 	srl	r8,r7,r9
81127e08:	113fff15 	stw	r4,-4(r2)
81127e0c:	1a3fff15 	stw	r8,-4(r3)
81127e10:	137ff736 	bltu	r2,r13,81127df0 <__reset+0xfb107df0>
81127e14:	003faa06 	br	81127cc0 <__reset+0xfb107cc0>

81127e18 <strncmp>:
81127e18:	30003126 	beq	r6,zero,81127ee0 <strncmp+0xc8>
81127e1c:	2144b03a 	or	r2,r4,r5
81127e20:	108000cc 	andi	r2,r2,3
81127e24:	10001e1e 	bne	r2,zero,81127ea0 <strncmp+0x88>
81127e28:	024000c4 	movi	r9,3
81127e2c:	49801c2e 	bgeu	r9,r6,81127ea0 <strncmp+0x88>
81127e30:	20800017 	ldw	r2,0(r4)
81127e34:	28c00017 	ldw	r3,0(r5)
81127e38:	10c0191e 	bne	r2,r3,81127ea0 <strncmp+0x88>
81127e3c:	31bfff04 	addi	r6,r6,-4
81127e40:	30002726 	beq	r6,zero,81127ee0 <strncmp+0xc8>
81127e44:	02ffbff4 	movhi	r11,65279
81127e48:	5affbfc4 	addi	r11,r11,-257
81127e4c:	0086303a 	nor	r3,zero,r2
81127e50:	02a02074 	movhi	r10,32897
81127e54:	12c5883a 	add	r2,r2,r11
81127e58:	52a02004 	addi	r10,r10,-32640
81127e5c:	10c4703a 	and	r2,r2,r3
81127e60:	1284703a 	and	r2,r2,r10
81127e64:	10000b26 	beq	r2,zero,81127e94 <strncmp+0x7c>
81127e68:	00001d06 	br	81127ee0 <strncmp+0xc8>
81127e6c:	20c00017 	ldw	r3,0(r4)
81127e70:	29c00017 	ldw	r7,0(r5)
81127e74:	1ad1883a 	add	r8,r3,r11
81127e78:	00c4303a 	nor	r2,zero,r3
81127e7c:	4084703a 	and	r2,r8,r2
81127e80:	1284703a 	and	r2,r2,r10
81127e84:	19c0061e 	bne	r3,r7,81127ea0 <strncmp+0x88>
81127e88:	31bfff04 	addi	r6,r6,-4
81127e8c:	30001426 	beq	r6,zero,81127ee0 <strncmp+0xc8>
81127e90:	1000131e 	bne	r2,zero,81127ee0 <strncmp+0xc8>
81127e94:	21000104 	addi	r4,r4,4
81127e98:	29400104 	addi	r5,r5,4
81127e9c:	49bff336 	bltu	r9,r6,81127e6c <__reset+0xfb107e6c>
81127ea0:	28800007 	ldb	r2,0(r5)
81127ea4:	20c00007 	ldb	r3,0(r4)
81127ea8:	31bfffc4 	addi	r6,r6,-1
81127eac:	10c0081e 	bne	r2,r3,81127ed0 <strncmp+0xb8>
81127eb0:	30000b26 	beq	r6,zero,81127ee0 <strncmp+0xc8>
81127eb4:	10000a26 	beq	r2,zero,81127ee0 <strncmp+0xc8>
81127eb8:	21000044 	addi	r4,r4,1
81127ebc:	29400044 	addi	r5,r5,1
81127ec0:	20800007 	ldb	r2,0(r4)
81127ec4:	28c00007 	ldb	r3,0(r5)
81127ec8:	31bfffc4 	addi	r6,r6,-1
81127ecc:	10fff826 	beq	r2,r3,81127eb0 <__reset+0xfb107eb0>
81127ed0:	20800003 	ldbu	r2,0(r4)
81127ed4:	28c00003 	ldbu	r3,0(r5)
81127ed8:	10c5c83a 	sub	r2,r2,r3
81127edc:	f800283a 	ret
81127ee0:	0005883a 	mov	r2,zero
81127ee4:	f800283a 	ret

81127ee8 <_wcrtomb_r>:
81127ee8:	defff604 	addi	sp,sp,-40
81127eec:	00a04534 	movhi	r2,33044
81127ef0:	de00012e 	bgeu	sp,et,81127ef8 <_wcrtomb_r+0x10>
81127ef4:	003b68fa 	trap	3
81127ef8:	109af204 	addi	r2,r2,27592
81127efc:	dc800815 	stw	r18,32(sp)
81127f00:	dc400715 	stw	r17,28(sp)
81127f04:	dc000615 	stw	r16,24(sp)
81127f08:	dfc00915 	stw	ra,36(sp)
81127f0c:	2021883a 	mov	r16,r4
81127f10:	3823883a 	mov	r17,r7
81127f14:	14800017 	ldw	r18,0(r2)
81127f18:	28001426 	beq	r5,zero,81127f6c <_wcrtomb_r+0x84>
81127f1c:	d9400415 	stw	r5,16(sp)
81127f20:	d9800515 	stw	r6,20(sp)
81127f24:	11204180 	call	81120418 <__locale_charset>
81127f28:	d9800517 	ldw	r6,20(sp)
81127f2c:	d9400417 	ldw	r5,16(sp)
81127f30:	100f883a 	mov	r7,r2
81127f34:	dc400015 	stw	r17,0(sp)
81127f38:	8009883a 	mov	r4,r16
81127f3c:	903ee83a 	callr	r18
81127f40:	00ffffc4 	movi	r3,-1
81127f44:	10c0031e 	bne	r2,r3,81127f54 <_wcrtomb_r+0x6c>
81127f48:	88000015 	stw	zero,0(r17)
81127f4c:	00c02284 	movi	r3,138
81127f50:	80c00015 	stw	r3,0(r16)
81127f54:	dfc00917 	ldw	ra,36(sp)
81127f58:	dc800817 	ldw	r18,32(sp)
81127f5c:	dc400717 	ldw	r17,28(sp)
81127f60:	dc000617 	ldw	r16,24(sp)
81127f64:	dec00a04 	addi	sp,sp,40
81127f68:	f800283a 	ret
81127f6c:	11204180 	call	81120418 <__locale_charset>
81127f70:	100f883a 	mov	r7,r2
81127f74:	dc400015 	stw	r17,0(sp)
81127f78:	000d883a 	mov	r6,zero
81127f7c:	d9400104 	addi	r5,sp,4
81127f80:	8009883a 	mov	r4,r16
81127f84:	903ee83a 	callr	r18
81127f88:	003fed06 	br	81127f40 <__reset+0xfb107f40>

81127f8c <wcrtomb>:
81127f8c:	defff604 	addi	sp,sp,-40
81127f90:	00a04534 	movhi	r2,33044
81127f94:	de00012e 	bgeu	sp,et,81127f9c <wcrtomb+0x10>
81127f98:	003b68fa 	trap	3
81127f9c:	109aed04 	addi	r2,r2,27572
81127fa0:	dc800615 	stw	r18,24(sp)
81127fa4:	dc400515 	stw	r17,20(sp)
81127fa8:	dfc00915 	stw	ra,36(sp)
81127fac:	dd000815 	stw	r20,32(sp)
81127fb0:	dcc00715 	stw	r19,28(sp)
81127fb4:	dc000415 	stw	r16,16(sp)
81127fb8:	3025883a 	mov	r18,r6
81127fbc:	14400017 	ldw	r17,0(r2)
81127fc0:	20001926 	beq	r4,zero,81128028 <wcrtomb+0x9c>
81127fc4:	00a04534 	movhi	r2,33044
81127fc8:	109af204 	addi	r2,r2,27592
81127fcc:	15000017 	ldw	r20,0(r2)
81127fd0:	2021883a 	mov	r16,r4
81127fd4:	2827883a 	mov	r19,r5
81127fd8:	11204180 	call	81120418 <__locale_charset>
81127fdc:	100f883a 	mov	r7,r2
81127fe0:	dc800015 	stw	r18,0(sp)
81127fe4:	980d883a 	mov	r6,r19
81127fe8:	800b883a 	mov	r5,r16
81127fec:	8809883a 	mov	r4,r17
81127ff0:	a03ee83a 	callr	r20
81127ff4:	00ffffc4 	movi	r3,-1
81127ff8:	10c0031e 	bne	r2,r3,81128008 <wcrtomb+0x7c>
81127ffc:	90000015 	stw	zero,0(r18)
81128000:	00c02284 	movi	r3,138
81128004:	88c00015 	stw	r3,0(r17)
81128008:	dfc00917 	ldw	ra,36(sp)
8112800c:	dd000817 	ldw	r20,32(sp)
81128010:	dcc00717 	ldw	r19,28(sp)
81128014:	dc800617 	ldw	r18,24(sp)
81128018:	dc400517 	ldw	r17,20(sp)
8112801c:	dc000417 	ldw	r16,16(sp)
81128020:	dec00a04 	addi	sp,sp,40
81128024:	f800283a 	ret
81128028:	00a04534 	movhi	r2,33044
8112802c:	109af204 	addi	r2,r2,27592
81128030:	14000017 	ldw	r16,0(r2)
81128034:	11204180 	call	81120418 <__locale_charset>
81128038:	100f883a 	mov	r7,r2
8112803c:	dc800015 	stw	r18,0(sp)
81128040:	000d883a 	mov	r6,zero
81128044:	d9400104 	addi	r5,sp,4
81128048:	8809883a 	mov	r4,r17
8112804c:	803ee83a 	callr	r16
81128050:	003fe806 	br	81127ff4 <__reset+0xfb107ff4>

81128054 <__ascii_wctomb>:
81128054:	28000526 	beq	r5,zero,8112806c <__ascii_wctomb+0x18>
81128058:	00803fc4 	movi	r2,255
8112805c:	11800536 	bltu	r2,r6,81128074 <__ascii_wctomb+0x20>
81128060:	29800005 	stb	r6,0(r5)
81128064:	00800044 	movi	r2,1
81128068:	f800283a 	ret
8112806c:	0005883a 	mov	r2,zero
81128070:	f800283a 	ret
81128074:	00802284 	movi	r2,138
81128078:	20800015 	stw	r2,0(r4)
8112807c:	00bfffc4 	movi	r2,-1
81128080:	f800283a 	ret

81128084 <_wctomb_r>:
81128084:	00a04534 	movhi	r2,33044
81128088:	defff904 	addi	sp,sp,-28
8112808c:	109af204 	addi	r2,r2,27592
81128090:	de00012e 	bgeu	sp,et,81128098 <_wctomb_r+0x14>
81128094:	003b68fa 	trap	3
81128098:	dfc00615 	stw	ra,24(sp)
8112809c:	dc400515 	stw	r17,20(sp)
811280a0:	dc000415 	stw	r16,16(sp)
811280a4:	3823883a 	mov	r17,r7
811280a8:	14000017 	ldw	r16,0(r2)
811280ac:	d9000115 	stw	r4,4(sp)
811280b0:	d9400215 	stw	r5,8(sp)
811280b4:	d9800315 	stw	r6,12(sp)
811280b8:	11204180 	call	81120418 <__locale_charset>
811280bc:	d9800317 	ldw	r6,12(sp)
811280c0:	d9400217 	ldw	r5,8(sp)
811280c4:	d9000117 	ldw	r4,4(sp)
811280c8:	100f883a 	mov	r7,r2
811280cc:	dc400015 	stw	r17,0(sp)
811280d0:	803ee83a 	callr	r16
811280d4:	dfc00617 	ldw	ra,24(sp)
811280d8:	dc400517 	ldw	r17,20(sp)
811280dc:	dc000417 	ldw	r16,16(sp)
811280e0:	dec00704 	addi	sp,sp,28
811280e4:	f800283a 	ret

811280e8 <__fixunsdfsi>:
811280e8:	defffd04 	addi	sp,sp,-12
811280ec:	000d883a 	mov	r6,zero
811280f0:	01d07834 	movhi	r7,16864
811280f4:	de00012e 	bgeu	sp,et,811280fc <__fixunsdfsi+0x14>
811280f8:	003b68fa 	trap	3
811280fc:	dc400115 	stw	r17,4(sp)
81128100:	dc000015 	stw	r16,0(sp)
81128104:	dfc00215 	stw	ra,8(sp)
81128108:	2023883a 	mov	r17,r4
8112810c:	2821883a 	mov	r16,r5
81128110:	112a2000 	call	8112a200 <__gedf2>
81128114:	1000080e 	bge	r2,zero,81128138 <__fixunsdfsi+0x50>
81128118:	8809883a 	mov	r4,r17
8112811c:	800b883a 	mov	r5,r16
81128120:	112acd40 	call	8112acd4 <__fixdfsi>
81128124:	dfc00217 	ldw	ra,8(sp)
81128128:	dc400117 	ldw	r17,4(sp)
8112812c:	dc000017 	ldw	r16,0(sp)
81128130:	dec00304 	addi	sp,sp,12
81128134:	f800283a 	ret
81128138:	000d883a 	mov	r6,zero
8112813c:	01d07834 	movhi	r7,16864
81128140:	8809883a 	mov	r4,r17
81128144:	800b883a 	mov	r5,r16
81128148:	112a3d00 	call	8112a3d0 <__subdf3>
8112814c:	180b883a 	mov	r5,r3
81128150:	1009883a 	mov	r4,r2
81128154:	112acd40 	call	8112acd4 <__fixdfsi>
81128158:	00e00034 	movhi	r3,32768
8112815c:	10c5883a 	add	r2,r2,r3
81128160:	003ff006 	br	81128124 <__reset+0xfb108124>

81128164 <__udivdi3>:
81128164:	defff504 	addi	sp,sp,-44
81128168:	de00012e 	bgeu	sp,et,81128170 <__udivdi3+0xc>
8112816c:	003b68fa 	trap	3
81128170:	dcc00415 	stw	r19,16(sp)
81128174:	dc000115 	stw	r16,4(sp)
81128178:	dfc00a15 	stw	ra,40(sp)
8112817c:	df000915 	stw	fp,36(sp)
81128180:	ddc00815 	stw	r23,32(sp)
81128184:	dd800715 	stw	r22,28(sp)
81128188:	dd400615 	stw	r21,24(sp)
8112818c:	dd000515 	stw	r20,20(sp)
81128190:	dc800315 	stw	r18,12(sp)
81128194:	dc400215 	stw	r17,8(sp)
81128198:	2027883a 	mov	r19,r4
8112819c:	2821883a 	mov	r16,r5
811281a0:	3800411e 	bne	r7,zero,811282a8 <__udivdi3+0x144>
811281a4:	3023883a 	mov	r17,r6
811281a8:	2025883a 	mov	r18,r4
811281ac:	2980522e 	bgeu	r5,r6,811282f8 <__udivdi3+0x194>
811281b0:	00bfffd4 	movui	r2,65535
811281b4:	282d883a 	mov	r22,r5
811281b8:	1180a836 	bltu	r2,r6,8112845c <__udivdi3+0x2f8>
811281bc:	00803fc4 	movi	r2,255
811281c0:	1185803a 	cmpltu	r2,r2,r6
811281c4:	100490fa 	slli	r2,r2,3
811281c8:	3086d83a 	srl	r3,r6,r2
811281cc:	01204534 	movhi	r4,33044
811281d0:	21103204 	addi	r4,r4,16584
811281d4:	20c7883a 	add	r3,r4,r3
811281d8:	18c00003 	ldbu	r3,0(r3)
811281dc:	1885883a 	add	r2,r3,r2
811281e0:	00c00804 	movi	r3,32
811281e4:	1887c83a 	sub	r3,r3,r2
811281e8:	18000526 	beq	r3,zero,81128200 <__udivdi3+0x9c>
811281ec:	80e0983a 	sll	r16,r16,r3
811281f0:	9884d83a 	srl	r2,r19,r2
811281f4:	30e2983a 	sll	r17,r6,r3
811281f8:	98e4983a 	sll	r18,r19,r3
811281fc:	142cb03a 	or	r22,r2,r16
81128200:	882ad43a 	srli	r21,r17,16
81128204:	b009883a 	mov	r4,r22
81128208:	8d3fffcc 	andi	r20,r17,65535
8112820c:	a80b883a 	mov	r5,r21
81128210:	1128d800 	call	81128d80 <__umodsi3>
81128214:	b009883a 	mov	r4,r22
81128218:	a80b883a 	mov	r5,r21
8112821c:	1027883a 	mov	r19,r2
81128220:	1128d1c0 	call	81128d1c <__udivsi3>
81128224:	102d883a 	mov	r22,r2
81128228:	9826943a 	slli	r19,r19,16
8112822c:	9004d43a 	srli	r2,r18,16
81128230:	a5a1383a 	mul	r16,r20,r22
81128234:	14c4b03a 	or	r2,r2,r19
81128238:	1400052e 	bgeu	r2,r16,81128250 <__udivdi3+0xec>
8112823c:	1445883a 	add	r2,r2,r17
81128240:	b0ffffc4 	addi	r3,r22,-1
81128244:	14400136 	bltu	r2,r17,8112824c <__udivdi3+0xe8>
81128248:	14012336 	bltu	r2,r16,811286d8 <__udivdi3+0x574>
8112824c:	182d883a 	mov	r22,r3
81128250:	1421c83a 	sub	r16,r2,r16
81128254:	a80b883a 	mov	r5,r21
81128258:	8009883a 	mov	r4,r16
8112825c:	1128d800 	call	81128d80 <__umodsi3>
81128260:	1027883a 	mov	r19,r2
81128264:	a80b883a 	mov	r5,r21
81128268:	8009883a 	mov	r4,r16
8112826c:	1128d1c0 	call	81128d1c <__udivsi3>
81128270:	9826943a 	slli	r19,r19,16
81128274:	a0a9383a 	mul	r20,r20,r2
81128278:	94bfffcc 	andi	r18,r18,65535
8112827c:	94e4b03a 	or	r18,r18,r19
81128280:	9500052e 	bgeu	r18,r20,81128298 <__udivdi3+0x134>
81128284:	8ca5883a 	add	r18,r17,r18
81128288:	10ffffc4 	addi	r3,r2,-1
8112828c:	9440f136 	bltu	r18,r17,81128654 <__udivdi3+0x4f0>
81128290:	9500f02e 	bgeu	r18,r20,81128654 <__udivdi3+0x4f0>
81128294:	10bfff84 	addi	r2,r2,-2
81128298:	b00c943a 	slli	r6,r22,16
8112829c:	0007883a 	mov	r3,zero
811282a0:	3084b03a 	or	r2,r6,r2
811282a4:	00005906 	br	8112840c <__udivdi3+0x2a8>
811282a8:	29c05636 	bltu	r5,r7,81128404 <__udivdi3+0x2a0>
811282ac:	00bfffd4 	movui	r2,65535
811282b0:	11c0622e 	bgeu	r2,r7,8112843c <__udivdi3+0x2d8>
811282b4:	00804034 	movhi	r2,256
811282b8:	10bfffc4 	addi	r2,r2,-1
811282bc:	11c0ee36 	bltu	r2,r7,81128678 <__udivdi3+0x514>
811282c0:	00800404 	movi	r2,16
811282c4:	3886d83a 	srl	r3,r7,r2
811282c8:	01204534 	movhi	r4,33044
811282cc:	21103204 	addi	r4,r4,16584
811282d0:	20c7883a 	add	r3,r4,r3
811282d4:	18c00003 	ldbu	r3,0(r3)
811282d8:	05400804 	movi	r21,32
811282dc:	1885883a 	add	r2,r3,r2
811282e0:	a8abc83a 	sub	r21,r21,r2
811282e4:	a800621e 	bne	r21,zero,81128470 <__udivdi3+0x30c>
811282e8:	3c00e936 	bltu	r7,r16,81128690 <__udivdi3+0x52c>
811282ec:	9985403a 	cmpgeu	r2,r19,r6
811282f0:	0007883a 	mov	r3,zero
811282f4:	00004506 	br	8112840c <__udivdi3+0x2a8>
811282f8:	3000041e 	bne	r6,zero,8112830c <__udivdi3+0x1a8>
811282fc:	000b883a 	mov	r5,zero
81128300:	01000044 	movi	r4,1
81128304:	1128d1c0 	call	81128d1c <__udivsi3>
81128308:	1023883a 	mov	r17,r2
8112830c:	00bfffd4 	movui	r2,65535
81128310:	14404e2e 	bgeu	r2,r17,8112844c <__udivdi3+0x2e8>
81128314:	00804034 	movhi	r2,256
81128318:	10bfffc4 	addi	r2,r2,-1
8112831c:	1440d836 	bltu	r2,r17,81128680 <__udivdi3+0x51c>
81128320:	00800404 	movi	r2,16
81128324:	8886d83a 	srl	r3,r17,r2
81128328:	01204534 	movhi	r4,33044
8112832c:	21103204 	addi	r4,r4,16584
81128330:	20c7883a 	add	r3,r4,r3
81128334:	18c00003 	ldbu	r3,0(r3)
81128338:	1885883a 	add	r2,r3,r2
8112833c:	00c00804 	movi	r3,32
81128340:	1887c83a 	sub	r3,r3,r2
81128344:	18008f1e 	bne	r3,zero,81128584 <__udivdi3+0x420>
81128348:	882ad43a 	srli	r21,r17,16
8112834c:	8461c83a 	sub	r16,r16,r17
81128350:	8d3fffcc 	andi	r20,r17,65535
81128354:	00c00044 	movi	r3,1
81128358:	8009883a 	mov	r4,r16
8112835c:	a80b883a 	mov	r5,r21
81128360:	d8c00015 	stw	r3,0(sp)
81128364:	1128d800 	call	81128d80 <__umodsi3>
81128368:	8009883a 	mov	r4,r16
8112836c:	a80b883a 	mov	r5,r21
81128370:	1027883a 	mov	r19,r2
81128374:	1128d1c0 	call	81128d1c <__udivsi3>
81128378:	9826943a 	slli	r19,r19,16
8112837c:	9008d43a 	srli	r4,r18,16
81128380:	1521383a 	mul	r16,r2,r20
81128384:	102d883a 	mov	r22,r2
81128388:	24c8b03a 	or	r4,r4,r19
8112838c:	d8c00017 	ldw	r3,0(sp)
81128390:	2400052e 	bgeu	r4,r16,811283a8 <__udivdi3+0x244>
81128394:	2449883a 	add	r4,r4,r17
81128398:	b0bfffc4 	addi	r2,r22,-1
8112839c:	24400136 	bltu	r4,r17,811283a4 <__udivdi3+0x240>
811283a0:	2400ca36 	bltu	r4,r16,811286cc <__udivdi3+0x568>
811283a4:	102d883a 	mov	r22,r2
811283a8:	2421c83a 	sub	r16,r4,r16
811283ac:	a80b883a 	mov	r5,r21
811283b0:	8009883a 	mov	r4,r16
811283b4:	d8c00015 	stw	r3,0(sp)
811283b8:	1128d800 	call	81128d80 <__umodsi3>
811283bc:	1027883a 	mov	r19,r2
811283c0:	a80b883a 	mov	r5,r21
811283c4:	8009883a 	mov	r4,r16
811283c8:	1128d1c0 	call	81128d1c <__udivsi3>
811283cc:	9826943a 	slli	r19,r19,16
811283d0:	1529383a 	mul	r20,r2,r20
811283d4:	94bfffcc 	andi	r18,r18,65535
811283d8:	94e4b03a 	or	r18,r18,r19
811283dc:	d8c00017 	ldw	r3,0(sp)
811283e0:	9500052e 	bgeu	r18,r20,811283f8 <__udivdi3+0x294>
811283e4:	8ca5883a 	add	r18,r17,r18
811283e8:	113fffc4 	addi	r4,r2,-1
811283ec:	94409736 	bltu	r18,r17,8112864c <__udivdi3+0x4e8>
811283f0:	9500962e 	bgeu	r18,r20,8112864c <__udivdi3+0x4e8>
811283f4:	10bfff84 	addi	r2,r2,-2
811283f8:	b00c943a 	slli	r6,r22,16
811283fc:	3084b03a 	or	r2,r6,r2
81128400:	00000206 	br	8112840c <__udivdi3+0x2a8>
81128404:	0007883a 	mov	r3,zero
81128408:	0005883a 	mov	r2,zero
8112840c:	dfc00a17 	ldw	ra,40(sp)
81128410:	df000917 	ldw	fp,36(sp)
81128414:	ddc00817 	ldw	r23,32(sp)
81128418:	dd800717 	ldw	r22,28(sp)
8112841c:	dd400617 	ldw	r21,24(sp)
81128420:	dd000517 	ldw	r20,20(sp)
81128424:	dcc00417 	ldw	r19,16(sp)
81128428:	dc800317 	ldw	r18,12(sp)
8112842c:	dc400217 	ldw	r17,8(sp)
81128430:	dc000117 	ldw	r16,4(sp)
81128434:	dec00b04 	addi	sp,sp,44
81128438:	f800283a 	ret
8112843c:	00803fc4 	movi	r2,255
81128440:	11c5803a 	cmpltu	r2,r2,r7
81128444:	100490fa 	slli	r2,r2,3
81128448:	003f9e06 	br	811282c4 <__reset+0xfb1082c4>
8112844c:	00803fc4 	movi	r2,255
81128450:	1445803a 	cmpltu	r2,r2,r17
81128454:	100490fa 	slli	r2,r2,3
81128458:	003fb206 	br	81128324 <__reset+0xfb108324>
8112845c:	00804034 	movhi	r2,256
81128460:	10bfffc4 	addi	r2,r2,-1
81128464:	11808836 	bltu	r2,r6,81128688 <__udivdi3+0x524>
81128468:	00800404 	movi	r2,16
8112846c:	003f5606 	br	811281c8 <__reset+0xfb1081c8>
81128470:	30aed83a 	srl	r23,r6,r2
81128474:	3d4e983a 	sll	r7,r7,r21
81128478:	80acd83a 	srl	r22,r16,r2
8112847c:	9884d83a 	srl	r2,r19,r2
81128480:	3deeb03a 	or	r23,r7,r23
81128484:	b824d43a 	srli	r18,r23,16
81128488:	8560983a 	sll	r16,r16,r21
8112848c:	b009883a 	mov	r4,r22
81128490:	900b883a 	mov	r5,r18
81128494:	3568983a 	sll	r20,r6,r21
81128498:	1420b03a 	or	r16,r2,r16
8112849c:	1128d800 	call	81128d80 <__umodsi3>
811284a0:	b009883a 	mov	r4,r22
811284a4:	900b883a 	mov	r5,r18
811284a8:	1023883a 	mov	r17,r2
811284ac:	1128d1c0 	call	81128d1c <__udivsi3>
811284b0:	8808943a 	slli	r4,r17,16
811284b4:	bf3fffcc 	andi	fp,r23,65535
811284b8:	8006d43a 	srli	r3,r16,16
811284bc:	e0a3383a 	mul	r17,fp,r2
811284c0:	100d883a 	mov	r6,r2
811284c4:	1906b03a 	or	r3,r3,r4
811284c8:	1c40042e 	bgeu	r3,r17,811284dc <__udivdi3+0x378>
811284cc:	1dc7883a 	add	r3,r3,r23
811284d0:	10bfffc4 	addi	r2,r2,-1
811284d4:	1dc0752e 	bgeu	r3,r23,811286ac <__udivdi3+0x548>
811284d8:	100d883a 	mov	r6,r2
811284dc:	1c63c83a 	sub	r17,r3,r17
811284e0:	900b883a 	mov	r5,r18
811284e4:	8809883a 	mov	r4,r17
811284e8:	d9800015 	stw	r6,0(sp)
811284ec:	1128d800 	call	81128d80 <__umodsi3>
811284f0:	102d883a 	mov	r22,r2
811284f4:	8809883a 	mov	r4,r17
811284f8:	900b883a 	mov	r5,r18
811284fc:	1128d1c0 	call	81128d1c <__udivsi3>
81128500:	b02c943a 	slli	r22,r22,16
81128504:	e089383a 	mul	r4,fp,r2
81128508:	843fffcc 	andi	r16,r16,65535
8112850c:	85a0b03a 	or	r16,r16,r22
81128510:	d9800017 	ldw	r6,0(sp)
81128514:	8100042e 	bgeu	r16,r4,81128528 <__udivdi3+0x3c4>
81128518:	85e1883a 	add	r16,r16,r23
8112851c:	10ffffc4 	addi	r3,r2,-1
81128520:	85c05e2e 	bgeu	r16,r23,8112869c <__udivdi3+0x538>
81128524:	1805883a 	mov	r2,r3
81128528:	300c943a 	slli	r6,r6,16
8112852c:	a17fffcc 	andi	r5,r20,65535
81128530:	a028d43a 	srli	r20,r20,16
81128534:	3084b03a 	or	r2,r6,r2
81128538:	10ffffcc 	andi	r3,r2,65535
8112853c:	100cd43a 	srli	r6,r2,16
81128540:	194f383a 	mul	r7,r3,r5
81128544:	1d07383a 	mul	r3,r3,r20
81128548:	314b383a 	mul	r5,r6,r5
8112854c:	3810d43a 	srli	r8,r7,16
81128550:	8121c83a 	sub	r16,r16,r4
81128554:	1947883a 	add	r3,r3,r5
81128558:	40c7883a 	add	r3,r8,r3
8112855c:	350d383a 	mul	r6,r6,r20
81128560:	1940022e 	bgeu	r3,r5,8112856c <__udivdi3+0x408>
81128564:	01000074 	movhi	r4,1
81128568:	310d883a 	add	r6,r6,r4
8112856c:	1828d43a 	srli	r20,r3,16
81128570:	a18d883a 	add	r6,r20,r6
81128574:	81803e36 	bltu	r16,r6,81128670 <__udivdi3+0x50c>
81128578:	81803826 	beq	r16,r6,8112865c <__udivdi3+0x4f8>
8112857c:	0007883a 	mov	r3,zero
81128580:	003fa206 	br	8112840c <__reset+0xfb10840c>
81128584:	88e2983a 	sll	r17,r17,r3
81128588:	80a8d83a 	srl	r20,r16,r2
8112858c:	80e0983a 	sll	r16,r16,r3
81128590:	882ad43a 	srli	r21,r17,16
81128594:	9884d83a 	srl	r2,r19,r2
81128598:	a009883a 	mov	r4,r20
8112859c:	a80b883a 	mov	r5,r21
811285a0:	142eb03a 	or	r23,r2,r16
811285a4:	98e4983a 	sll	r18,r19,r3
811285a8:	1128d800 	call	81128d80 <__umodsi3>
811285ac:	a009883a 	mov	r4,r20
811285b0:	a80b883a 	mov	r5,r21
811285b4:	1021883a 	mov	r16,r2
811285b8:	1128d1c0 	call	81128d1c <__udivsi3>
811285bc:	1039883a 	mov	fp,r2
811285c0:	8d3fffcc 	andi	r20,r17,65535
811285c4:	8020943a 	slli	r16,r16,16
811285c8:	b804d43a 	srli	r2,r23,16
811285cc:	a72d383a 	mul	r22,r20,fp
811285d0:	1404b03a 	or	r2,r2,r16
811285d4:	1580062e 	bgeu	r2,r22,811285f0 <__udivdi3+0x48c>
811285d8:	1445883a 	add	r2,r2,r17
811285dc:	e0ffffc4 	addi	r3,fp,-1
811285e0:	14403836 	bltu	r2,r17,811286c4 <__udivdi3+0x560>
811285e4:	1580372e 	bgeu	r2,r22,811286c4 <__udivdi3+0x560>
811285e8:	e73fff84 	addi	fp,fp,-2
811285ec:	1445883a 	add	r2,r2,r17
811285f0:	15adc83a 	sub	r22,r2,r22
811285f4:	a80b883a 	mov	r5,r21
811285f8:	b009883a 	mov	r4,r22
811285fc:	1128d800 	call	81128d80 <__umodsi3>
81128600:	1027883a 	mov	r19,r2
81128604:	b009883a 	mov	r4,r22
81128608:	a80b883a 	mov	r5,r21
8112860c:	1128d1c0 	call	81128d1c <__udivsi3>
81128610:	9826943a 	slli	r19,r19,16
81128614:	a0a1383a 	mul	r16,r20,r2
81128618:	b93fffcc 	andi	r4,r23,65535
8112861c:	24c8b03a 	or	r4,r4,r19
81128620:	2400062e 	bgeu	r4,r16,8112863c <__udivdi3+0x4d8>
81128624:	2449883a 	add	r4,r4,r17
81128628:	10ffffc4 	addi	r3,r2,-1
8112862c:	24402336 	bltu	r4,r17,811286bc <__udivdi3+0x558>
81128630:	2400222e 	bgeu	r4,r16,811286bc <__udivdi3+0x558>
81128634:	10bfff84 	addi	r2,r2,-2
81128638:	2449883a 	add	r4,r4,r17
8112863c:	e038943a 	slli	fp,fp,16
81128640:	2421c83a 	sub	r16,r4,r16
81128644:	e086b03a 	or	r3,fp,r2
81128648:	003f4306 	br	81128358 <__reset+0xfb108358>
8112864c:	2005883a 	mov	r2,r4
81128650:	003f6906 	br	811283f8 <__reset+0xfb1083f8>
81128654:	1805883a 	mov	r2,r3
81128658:	003f0f06 	br	81128298 <__reset+0xfb108298>
8112865c:	1806943a 	slli	r3,r3,16
81128660:	9d66983a 	sll	r19,r19,r21
81128664:	39ffffcc 	andi	r7,r7,65535
81128668:	19c7883a 	add	r3,r3,r7
8112866c:	98ffc32e 	bgeu	r19,r3,8112857c <__reset+0xfb10857c>
81128670:	10bfffc4 	addi	r2,r2,-1
81128674:	003fc106 	br	8112857c <__reset+0xfb10857c>
81128678:	00800604 	movi	r2,24
8112867c:	003f1106 	br	811282c4 <__reset+0xfb1082c4>
81128680:	00800604 	movi	r2,24
81128684:	003f2706 	br	81128324 <__reset+0xfb108324>
81128688:	00800604 	movi	r2,24
8112868c:	003ece06 	br	811281c8 <__reset+0xfb1081c8>
81128690:	0007883a 	mov	r3,zero
81128694:	00800044 	movi	r2,1
81128698:	003f5c06 	br	8112840c <__reset+0xfb10840c>
8112869c:	813fa12e 	bgeu	r16,r4,81128524 <__reset+0xfb108524>
811286a0:	10bfff84 	addi	r2,r2,-2
811286a4:	85e1883a 	add	r16,r16,r23
811286a8:	003f9f06 	br	81128528 <__reset+0xfb108528>
811286ac:	1c7f8a2e 	bgeu	r3,r17,811284d8 <__reset+0xfb1084d8>
811286b0:	31bfff84 	addi	r6,r6,-2
811286b4:	1dc7883a 	add	r3,r3,r23
811286b8:	003f8806 	br	811284dc <__reset+0xfb1084dc>
811286bc:	1805883a 	mov	r2,r3
811286c0:	003fde06 	br	8112863c <__reset+0xfb10863c>
811286c4:	1839883a 	mov	fp,r3
811286c8:	003fc906 	br	811285f0 <__reset+0xfb1085f0>
811286cc:	b5bfff84 	addi	r22,r22,-2
811286d0:	2449883a 	add	r4,r4,r17
811286d4:	003f3406 	br	811283a8 <__reset+0xfb1083a8>
811286d8:	b5bfff84 	addi	r22,r22,-2
811286dc:	1445883a 	add	r2,r2,r17
811286e0:	003edb06 	br	81128250 <__reset+0xfb108250>

811286e4 <__umoddi3>:
811286e4:	defff404 	addi	sp,sp,-48
811286e8:	de00012e 	bgeu	sp,et,811286f0 <__umoddi3+0xc>
811286ec:	003b68fa 	trap	3
811286f0:	df000a15 	stw	fp,40(sp)
811286f4:	dc400315 	stw	r17,12(sp)
811286f8:	dc000215 	stw	r16,8(sp)
811286fc:	dfc00b15 	stw	ra,44(sp)
81128700:	ddc00915 	stw	r23,36(sp)
81128704:	dd800815 	stw	r22,32(sp)
81128708:	dd400715 	stw	r21,28(sp)
8112870c:	dd000615 	stw	r20,24(sp)
81128710:	dcc00515 	stw	r19,20(sp)
81128714:	dc800415 	stw	r18,16(sp)
81128718:	2021883a 	mov	r16,r4
8112871c:	2823883a 	mov	r17,r5
81128720:	2839883a 	mov	fp,r5
81128724:	38003c1e 	bne	r7,zero,81128818 <__umoddi3+0x134>
81128728:	3027883a 	mov	r19,r6
8112872c:	2029883a 	mov	r20,r4
81128730:	2980512e 	bgeu	r5,r6,81128878 <__umoddi3+0x194>
81128734:	00bfffd4 	movui	r2,65535
81128738:	11809a36 	bltu	r2,r6,811289a4 <__umoddi3+0x2c0>
8112873c:	01003fc4 	movi	r4,255
81128740:	2189803a 	cmpltu	r4,r4,r6
81128744:	200890fa 	slli	r4,r4,3
81128748:	3104d83a 	srl	r2,r6,r4
8112874c:	00e04534 	movhi	r3,33044
81128750:	18d03204 	addi	r3,r3,16584
81128754:	1885883a 	add	r2,r3,r2
81128758:	10c00003 	ldbu	r3,0(r2)
8112875c:	00800804 	movi	r2,32
81128760:	1909883a 	add	r4,r3,r4
81128764:	1125c83a 	sub	r18,r2,r4
81128768:	90000526 	beq	r18,zero,81128780 <__umoddi3+0x9c>
8112876c:	8ca2983a 	sll	r17,r17,r18
81128770:	8108d83a 	srl	r4,r16,r4
81128774:	34a6983a 	sll	r19,r6,r18
81128778:	84a8983a 	sll	r20,r16,r18
8112877c:	2478b03a 	or	fp,r4,r17
81128780:	982ed43a 	srli	r23,r19,16
81128784:	e009883a 	mov	r4,fp
81128788:	9dbfffcc 	andi	r22,r19,65535
8112878c:	b80b883a 	mov	r5,r23
81128790:	1128d800 	call	81128d80 <__umodsi3>
81128794:	e009883a 	mov	r4,fp
81128798:	b80b883a 	mov	r5,r23
8112879c:	102b883a 	mov	r21,r2
811287a0:	1128d1c0 	call	81128d1c <__udivsi3>
811287a4:	a806943a 	slli	r3,r21,16
811287a8:	a008d43a 	srli	r4,r20,16
811287ac:	b085383a 	mul	r2,r22,r2
811287b0:	20c8b03a 	or	r4,r4,r3
811287b4:	2080032e 	bgeu	r4,r2,811287c4 <__umoddi3+0xe0>
811287b8:	24c9883a 	add	r4,r4,r19
811287bc:	24c00136 	bltu	r4,r19,811287c4 <__umoddi3+0xe0>
811287c0:	20811036 	bltu	r4,r2,81128c04 <__umoddi3+0x520>
811287c4:	20abc83a 	sub	r21,r4,r2
811287c8:	b80b883a 	mov	r5,r23
811287cc:	a809883a 	mov	r4,r21
811287d0:	1128d800 	call	81128d80 <__umodsi3>
811287d4:	1023883a 	mov	r17,r2
811287d8:	b80b883a 	mov	r5,r23
811287dc:	a809883a 	mov	r4,r21
811287e0:	1128d1c0 	call	81128d1c <__udivsi3>
811287e4:	8822943a 	slli	r17,r17,16
811287e8:	b085383a 	mul	r2,r22,r2
811287ec:	a0ffffcc 	andi	r3,r20,65535
811287f0:	1c46b03a 	or	r3,r3,r17
811287f4:	1880042e 	bgeu	r3,r2,81128808 <__umoddi3+0x124>
811287f8:	1cc7883a 	add	r3,r3,r19
811287fc:	1cc00236 	bltu	r3,r19,81128808 <__umoddi3+0x124>
81128800:	1880012e 	bgeu	r3,r2,81128808 <__umoddi3+0x124>
81128804:	1cc7883a 	add	r3,r3,r19
81128808:	1885c83a 	sub	r2,r3,r2
8112880c:	1484d83a 	srl	r2,r2,r18
81128810:	0007883a 	mov	r3,zero
81128814:	00004f06 	br	81128954 <__umoddi3+0x270>
81128818:	29c04c36 	bltu	r5,r7,8112894c <__umoddi3+0x268>
8112881c:	00bfffd4 	movui	r2,65535
81128820:	11c0582e 	bgeu	r2,r7,81128984 <__umoddi3+0x2a0>
81128824:	00804034 	movhi	r2,256
81128828:	10bfffc4 	addi	r2,r2,-1
8112882c:	11c0e736 	bltu	r2,r7,81128bcc <__umoddi3+0x4e8>
81128830:	01000404 	movi	r4,16
81128834:	3904d83a 	srl	r2,r7,r4
81128838:	00e04534 	movhi	r3,33044
8112883c:	18d03204 	addi	r3,r3,16584
81128840:	1885883a 	add	r2,r3,r2
81128844:	14c00003 	ldbu	r19,0(r2)
81128848:	00c00804 	movi	r3,32
8112884c:	9927883a 	add	r19,r19,r4
81128850:	1ce9c83a 	sub	r20,r3,r19
81128854:	a000581e 	bne	r20,zero,811289b8 <__umoddi3+0x2d4>
81128858:	3c400136 	bltu	r7,r17,81128860 <__umoddi3+0x17c>
8112885c:	8180eb36 	bltu	r16,r6,81128c0c <__umoddi3+0x528>
81128860:	8185c83a 	sub	r2,r16,r6
81128864:	89e3c83a 	sub	r17,r17,r7
81128868:	8089803a 	cmpltu	r4,r16,r2
8112886c:	8939c83a 	sub	fp,r17,r4
81128870:	e007883a 	mov	r3,fp
81128874:	00003706 	br	81128954 <__umoddi3+0x270>
81128878:	3000041e 	bne	r6,zero,8112888c <__umoddi3+0x1a8>
8112887c:	000b883a 	mov	r5,zero
81128880:	01000044 	movi	r4,1
81128884:	1128d1c0 	call	81128d1c <__udivsi3>
81128888:	1027883a 	mov	r19,r2
8112888c:	00bfffd4 	movui	r2,65535
81128890:	14c0402e 	bgeu	r2,r19,81128994 <__umoddi3+0x2b0>
81128894:	00804034 	movhi	r2,256
81128898:	10bfffc4 	addi	r2,r2,-1
8112889c:	14c0cd36 	bltu	r2,r19,81128bd4 <__umoddi3+0x4f0>
811288a0:	00800404 	movi	r2,16
811288a4:	9886d83a 	srl	r3,r19,r2
811288a8:	01204534 	movhi	r4,33044
811288ac:	21103204 	addi	r4,r4,16584
811288b0:	20c7883a 	add	r3,r4,r3
811288b4:	18c00003 	ldbu	r3,0(r3)
811288b8:	1887883a 	add	r3,r3,r2
811288bc:	00800804 	movi	r2,32
811288c0:	10e5c83a 	sub	r18,r2,r3
811288c4:	9000901e 	bne	r18,zero,81128b08 <__umoddi3+0x424>
811288c8:	982cd43a 	srli	r22,r19,16
811288cc:	8ce3c83a 	sub	r17,r17,r19
811288d0:	9d7fffcc 	andi	r21,r19,65535
811288d4:	b00b883a 	mov	r5,r22
811288d8:	8809883a 	mov	r4,r17
811288dc:	1128d800 	call	81128d80 <__umodsi3>
811288e0:	8809883a 	mov	r4,r17
811288e4:	b00b883a 	mov	r5,r22
811288e8:	1021883a 	mov	r16,r2
811288ec:	1128d1c0 	call	81128d1c <__udivsi3>
811288f0:	8006943a 	slli	r3,r16,16
811288f4:	a008d43a 	srli	r4,r20,16
811288f8:	1545383a 	mul	r2,r2,r21
811288fc:	20c8b03a 	or	r4,r4,r3
81128900:	2080042e 	bgeu	r4,r2,81128914 <__umoddi3+0x230>
81128904:	24c9883a 	add	r4,r4,r19
81128908:	24c00236 	bltu	r4,r19,81128914 <__umoddi3+0x230>
8112890c:	2080012e 	bgeu	r4,r2,81128914 <__umoddi3+0x230>
81128910:	24c9883a 	add	r4,r4,r19
81128914:	20a1c83a 	sub	r16,r4,r2
81128918:	b00b883a 	mov	r5,r22
8112891c:	8009883a 	mov	r4,r16
81128920:	1128d800 	call	81128d80 <__umodsi3>
81128924:	1023883a 	mov	r17,r2
81128928:	b00b883a 	mov	r5,r22
8112892c:	8009883a 	mov	r4,r16
81128930:	1128d1c0 	call	81128d1c <__udivsi3>
81128934:	8822943a 	slli	r17,r17,16
81128938:	1545383a 	mul	r2,r2,r21
8112893c:	a53fffcc 	andi	r20,r20,65535
81128940:	a446b03a 	or	r3,r20,r17
81128944:	18bfb02e 	bgeu	r3,r2,81128808 <__reset+0xfb108808>
81128948:	003fab06 	br	811287f8 <__reset+0xfb1087f8>
8112894c:	2005883a 	mov	r2,r4
81128950:	2807883a 	mov	r3,r5
81128954:	dfc00b17 	ldw	ra,44(sp)
81128958:	df000a17 	ldw	fp,40(sp)
8112895c:	ddc00917 	ldw	r23,36(sp)
81128960:	dd800817 	ldw	r22,32(sp)
81128964:	dd400717 	ldw	r21,28(sp)
81128968:	dd000617 	ldw	r20,24(sp)
8112896c:	dcc00517 	ldw	r19,20(sp)
81128970:	dc800417 	ldw	r18,16(sp)
81128974:	dc400317 	ldw	r17,12(sp)
81128978:	dc000217 	ldw	r16,8(sp)
8112897c:	dec00c04 	addi	sp,sp,48
81128980:	f800283a 	ret
81128984:	04c03fc4 	movi	r19,255
81128988:	99c9803a 	cmpltu	r4,r19,r7
8112898c:	200890fa 	slli	r4,r4,3
81128990:	003fa806 	br	81128834 <__reset+0xfb108834>
81128994:	00803fc4 	movi	r2,255
81128998:	14c5803a 	cmpltu	r2,r2,r19
8112899c:	100490fa 	slli	r2,r2,3
811289a0:	003fc006 	br	811288a4 <__reset+0xfb1088a4>
811289a4:	00804034 	movhi	r2,256
811289a8:	10bfffc4 	addi	r2,r2,-1
811289ac:	11808b36 	bltu	r2,r6,81128bdc <__umoddi3+0x4f8>
811289b0:	01000404 	movi	r4,16
811289b4:	003f6406 	br	81128748 <__reset+0xfb108748>
811289b8:	34c4d83a 	srl	r2,r6,r19
811289bc:	3d0e983a 	sll	r7,r7,r20
811289c0:	8cf8d83a 	srl	fp,r17,r19
811289c4:	8d10983a 	sll	r8,r17,r20
811289c8:	38aab03a 	or	r21,r7,r2
811289cc:	a82cd43a 	srli	r22,r21,16
811289d0:	84e2d83a 	srl	r17,r16,r19
811289d4:	e009883a 	mov	r4,fp
811289d8:	b00b883a 	mov	r5,r22
811289dc:	8a22b03a 	or	r17,r17,r8
811289e0:	3524983a 	sll	r18,r6,r20
811289e4:	1128d800 	call	81128d80 <__umodsi3>
811289e8:	e009883a 	mov	r4,fp
811289ec:	b00b883a 	mov	r5,r22
811289f0:	102f883a 	mov	r23,r2
811289f4:	1128d1c0 	call	81128d1c <__udivsi3>
811289f8:	100d883a 	mov	r6,r2
811289fc:	b808943a 	slli	r4,r23,16
81128a00:	aa3fffcc 	andi	r8,r21,65535
81128a04:	8804d43a 	srli	r2,r17,16
81128a08:	41af383a 	mul	r23,r8,r6
81128a0c:	8520983a 	sll	r16,r16,r20
81128a10:	1104b03a 	or	r2,r2,r4
81128a14:	15c0042e 	bgeu	r2,r23,81128a28 <__umoddi3+0x344>
81128a18:	1545883a 	add	r2,r2,r21
81128a1c:	30ffffc4 	addi	r3,r6,-1
81128a20:	1540742e 	bgeu	r2,r21,81128bf4 <__umoddi3+0x510>
81128a24:	180d883a 	mov	r6,r3
81128a28:	15efc83a 	sub	r23,r2,r23
81128a2c:	b00b883a 	mov	r5,r22
81128a30:	b809883a 	mov	r4,r23
81128a34:	d9800115 	stw	r6,4(sp)
81128a38:	da000015 	stw	r8,0(sp)
81128a3c:	1128d800 	call	81128d80 <__umodsi3>
81128a40:	b00b883a 	mov	r5,r22
81128a44:	b809883a 	mov	r4,r23
81128a48:	1039883a 	mov	fp,r2
81128a4c:	1128d1c0 	call	81128d1c <__udivsi3>
81128a50:	da000017 	ldw	r8,0(sp)
81128a54:	e038943a 	slli	fp,fp,16
81128a58:	100b883a 	mov	r5,r2
81128a5c:	4089383a 	mul	r4,r8,r2
81128a60:	8a3fffcc 	andi	r8,r17,65535
81128a64:	4710b03a 	or	r8,r8,fp
81128a68:	d9800117 	ldw	r6,4(sp)
81128a6c:	4100042e 	bgeu	r8,r4,81128a80 <__umoddi3+0x39c>
81128a70:	4551883a 	add	r8,r8,r21
81128a74:	10bfffc4 	addi	r2,r2,-1
81128a78:	45405a2e 	bgeu	r8,r21,81128be4 <__umoddi3+0x500>
81128a7c:	100b883a 	mov	r5,r2
81128a80:	300c943a 	slli	r6,r6,16
81128a84:	91ffffcc 	andi	r7,r18,65535
81128a88:	9004d43a 	srli	r2,r18,16
81128a8c:	314cb03a 	or	r6,r6,r5
81128a90:	317fffcc 	andi	r5,r6,65535
81128a94:	300cd43a 	srli	r6,r6,16
81128a98:	29d3383a 	mul	r9,r5,r7
81128a9c:	288b383a 	mul	r5,r5,r2
81128aa0:	31cf383a 	mul	r7,r6,r7
81128aa4:	4806d43a 	srli	r3,r9,16
81128aa8:	4111c83a 	sub	r8,r8,r4
81128aac:	29cb883a 	add	r5,r5,r7
81128ab0:	194b883a 	add	r5,r3,r5
81128ab4:	3085383a 	mul	r2,r6,r2
81128ab8:	29c0022e 	bgeu	r5,r7,81128ac4 <__umoddi3+0x3e0>
81128abc:	00c00074 	movhi	r3,1
81128ac0:	10c5883a 	add	r2,r2,r3
81128ac4:	2808d43a 	srli	r4,r5,16
81128ac8:	280a943a 	slli	r5,r5,16
81128acc:	4a7fffcc 	andi	r9,r9,65535
81128ad0:	2085883a 	add	r2,r4,r2
81128ad4:	2a4b883a 	add	r5,r5,r9
81128ad8:	40803636 	bltu	r8,r2,81128bb4 <__umoddi3+0x4d0>
81128adc:	40804d26 	beq	r8,r2,81128c14 <__umoddi3+0x530>
81128ae0:	4089c83a 	sub	r4,r8,r2
81128ae4:	280f883a 	mov	r7,r5
81128ae8:	81cfc83a 	sub	r7,r16,r7
81128aec:	81c7803a 	cmpltu	r3,r16,r7
81128af0:	20c7c83a 	sub	r3,r4,r3
81128af4:	1cc4983a 	sll	r2,r3,r19
81128af8:	3d0ed83a 	srl	r7,r7,r20
81128afc:	1d06d83a 	srl	r3,r3,r20
81128b00:	11c4b03a 	or	r2,r2,r7
81128b04:	003f9306 	br	81128954 <__reset+0xfb108954>
81128b08:	9ca6983a 	sll	r19,r19,r18
81128b0c:	88e8d83a 	srl	r20,r17,r3
81128b10:	80c4d83a 	srl	r2,r16,r3
81128b14:	982cd43a 	srli	r22,r19,16
81128b18:	8ca2983a 	sll	r17,r17,r18
81128b1c:	a009883a 	mov	r4,r20
81128b20:	b00b883a 	mov	r5,r22
81128b24:	1478b03a 	or	fp,r2,r17
81128b28:	1128d800 	call	81128d80 <__umodsi3>
81128b2c:	a009883a 	mov	r4,r20
81128b30:	b00b883a 	mov	r5,r22
81128b34:	1023883a 	mov	r17,r2
81128b38:	1128d1c0 	call	81128d1c <__udivsi3>
81128b3c:	9d7fffcc 	andi	r21,r19,65535
81128b40:	880a943a 	slli	r5,r17,16
81128b44:	e008d43a 	srli	r4,fp,16
81128b48:	a885383a 	mul	r2,r21,r2
81128b4c:	84a8983a 	sll	r20,r16,r18
81128b50:	2148b03a 	or	r4,r4,r5
81128b54:	2080042e 	bgeu	r4,r2,81128b68 <__umoddi3+0x484>
81128b58:	24c9883a 	add	r4,r4,r19
81128b5c:	24c00236 	bltu	r4,r19,81128b68 <__umoddi3+0x484>
81128b60:	2080012e 	bgeu	r4,r2,81128b68 <__umoddi3+0x484>
81128b64:	24c9883a 	add	r4,r4,r19
81128b68:	20a3c83a 	sub	r17,r4,r2
81128b6c:	b00b883a 	mov	r5,r22
81128b70:	8809883a 	mov	r4,r17
81128b74:	1128d800 	call	81128d80 <__umodsi3>
81128b78:	102f883a 	mov	r23,r2
81128b7c:	8809883a 	mov	r4,r17
81128b80:	b00b883a 	mov	r5,r22
81128b84:	1128d1c0 	call	81128d1c <__udivsi3>
81128b88:	b82e943a 	slli	r23,r23,16
81128b8c:	a885383a 	mul	r2,r21,r2
81128b90:	e13fffcc 	andi	r4,fp,65535
81128b94:	25c8b03a 	or	r4,r4,r23
81128b98:	2080042e 	bgeu	r4,r2,81128bac <__umoddi3+0x4c8>
81128b9c:	24c9883a 	add	r4,r4,r19
81128ba0:	24c00236 	bltu	r4,r19,81128bac <__umoddi3+0x4c8>
81128ba4:	2080012e 	bgeu	r4,r2,81128bac <__umoddi3+0x4c8>
81128ba8:	24c9883a 	add	r4,r4,r19
81128bac:	20a3c83a 	sub	r17,r4,r2
81128bb0:	003f4806 	br	811288d4 <__reset+0xfb1088d4>
81128bb4:	2c8fc83a 	sub	r7,r5,r18
81128bb8:	1545c83a 	sub	r2,r2,r21
81128bbc:	29cb803a 	cmpltu	r5,r5,r7
81128bc0:	1145c83a 	sub	r2,r2,r5
81128bc4:	4089c83a 	sub	r4,r8,r2
81128bc8:	003fc706 	br	81128ae8 <__reset+0xfb108ae8>
81128bcc:	01000604 	movi	r4,24
81128bd0:	003f1806 	br	81128834 <__reset+0xfb108834>
81128bd4:	00800604 	movi	r2,24
81128bd8:	003f3206 	br	811288a4 <__reset+0xfb1088a4>
81128bdc:	01000604 	movi	r4,24
81128be0:	003ed906 	br	81128748 <__reset+0xfb108748>
81128be4:	413fa52e 	bgeu	r8,r4,81128a7c <__reset+0xfb108a7c>
81128be8:	297fff84 	addi	r5,r5,-2
81128bec:	4551883a 	add	r8,r8,r21
81128bf0:	003fa306 	br	81128a80 <__reset+0xfb108a80>
81128bf4:	15ff8b2e 	bgeu	r2,r23,81128a24 <__reset+0xfb108a24>
81128bf8:	31bfff84 	addi	r6,r6,-2
81128bfc:	1545883a 	add	r2,r2,r21
81128c00:	003f8906 	br	81128a28 <__reset+0xfb108a28>
81128c04:	24c9883a 	add	r4,r4,r19
81128c08:	003eee06 	br	811287c4 <__reset+0xfb1087c4>
81128c0c:	8005883a 	mov	r2,r16
81128c10:	003f1706 	br	81128870 <__reset+0xfb108870>
81128c14:	817fe736 	bltu	r16,r5,81128bb4 <__reset+0xfb108bb4>
81128c18:	280f883a 	mov	r7,r5
81128c1c:	0009883a 	mov	r4,zero
81128c20:	003fb106 	br	81128ae8 <__reset+0xfb108ae8>

81128c24 <__divsi3>:
81128c24:	20001b16 	blt	r4,zero,81128c94 <__divsi3+0x70>
81128c28:	000f883a 	mov	r7,zero
81128c2c:	28001616 	blt	r5,zero,81128c88 <__divsi3+0x64>
81128c30:	200d883a 	mov	r6,r4
81128c34:	29001a2e 	bgeu	r5,r4,81128ca0 <__divsi3+0x7c>
81128c38:	00800804 	movi	r2,32
81128c3c:	00c00044 	movi	r3,1
81128c40:	00000106 	br	81128c48 <__divsi3+0x24>
81128c44:	10000d26 	beq	r2,zero,81128c7c <__divsi3+0x58>
81128c48:	294b883a 	add	r5,r5,r5
81128c4c:	10bfffc4 	addi	r2,r2,-1
81128c50:	18c7883a 	add	r3,r3,r3
81128c54:	293ffb36 	bltu	r5,r4,81128c44 <__reset+0xfb108c44>
81128c58:	0005883a 	mov	r2,zero
81128c5c:	18000726 	beq	r3,zero,81128c7c <__divsi3+0x58>
81128c60:	0005883a 	mov	r2,zero
81128c64:	31400236 	bltu	r6,r5,81128c70 <__divsi3+0x4c>
81128c68:	314dc83a 	sub	r6,r6,r5
81128c6c:	10c4b03a 	or	r2,r2,r3
81128c70:	1806d07a 	srli	r3,r3,1
81128c74:	280ad07a 	srli	r5,r5,1
81128c78:	183ffa1e 	bne	r3,zero,81128c64 <__reset+0xfb108c64>
81128c7c:	38000126 	beq	r7,zero,81128c84 <__divsi3+0x60>
81128c80:	0085c83a 	sub	r2,zero,r2
81128c84:	f800283a 	ret
81128c88:	014bc83a 	sub	r5,zero,r5
81128c8c:	39c0005c 	xori	r7,r7,1
81128c90:	003fe706 	br	81128c30 <__reset+0xfb108c30>
81128c94:	0109c83a 	sub	r4,zero,r4
81128c98:	01c00044 	movi	r7,1
81128c9c:	003fe306 	br	81128c2c <__reset+0xfb108c2c>
81128ca0:	00c00044 	movi	r3,1
81128ca4:	003fee06 	br	81128c60 <__reset+0xfb108c60>

81128ca8 <__modsi3>:
81128ca8:	20001716 	blt	r4,zero,81128d08 <__modsi3+0x60>
81128cac:	000f883a 	mov	r7,zero
81128cb0:	2005883a 	mov	r2,r4
81128cb4:	28001216 	blt	r5,zero,81128d00 <__modsi3+0x58>
81128cb8:	2900162e 	bgeu	r5,r4,81128d14 <__modsi3+0x6c>
81128cbc:	01800804 	movi	r6,32
81128cc0:	00c00044 	movi	r3,1
81128cc4:	00000106 	br	81128ccc <__modsi3+0x24>
81128cc8:	30000a26 	beq	r6,zero,81128cf4 <__modsi3+0x4c>
81128ccc:	294b883a 	add	r5,r5,r5
81128cd0:	31bfffc4 	addi	r6,r6,-1
81128cd4:	18c7883a 	add	r3,r3,r3
81128cd8:	293ffb36 	bltu	r5,r4,81128cc8 <__reset+0xfb108cc8>
81128cdc:	18000526 	beq	r3,zero,81128cf4 <__modsi3+0x4c>
81128ce0:	1806d07a 	srli	r3,r3,1
81128ce4:	11400136 	bltu	r2,r5,81128cec <__modsi3+0x44>
81128ce8:	1145c83a 	sub	r2,r2,r5
81128cec:	280ad07a 	srli	r5,r5,1
81128cf0:	183ffb1e 	bne	r3,zero,81128ce0 <__reset+0xfb108ce0>
81128cf4:	38000126 	beq	r7,zero,81128cfc <__modsi3+0x54>
81128cf8:	0085c83a 	sub	r2,zero,r2
81128cfc:	f800283a 	ret
81128d00:	014bc83a 	sub	r5,zero,r5
81128d04:	003fec06 	br	81128cb8 <__reset+0xfb108cb8>
81128d08:	0109c83a 	sub	r4,zero,r4
81128d0c:	01c00044 	movi	r7,1
81128d10:	003fe706 	br	81128cb0 <__reset+0xfb108cb0>
81128d14:	00c00044 	movi	r3,1
81128d18:	003ff106 	br	81128ce0 <__reset+0xfb108ce0>

81128d1c <__udivsi3>:
81128d1c:	200d883a 	mov	r6,r4
81128d20:	2900152e 	bgeu	r5,r4,81128d78 <__udivsi3+0x5c>
81128d24:	28001416 	blt	r5,zero,81128d78 <__udivsi3+0x5c>
81128d28:	00800804 	movi	r2,32
81128d2c:	00c00044 	movi	r3,1
81128d30:	00000206 	br	81128d3c <__udivsi3+0x20>
81128d34:	10000e26 	beq	r2,zero,81128d70 <__udivsi3+0x54>
81128d38:	28000516 	blt	r5,zero,81128d50 <__udivsi3+0x34>
81128d3c:	294b883a 	add	r5,r5,r5
81128d40:	10bfffc4 	addi	r2,r2,-1
81128d44:	18c7883a 	add	r3,r3,r3
81128d48:	293ffa36 	bltu	r5,r4,81128d34 <__reset+0xfb108d34>
81128d4c:	18000826 	beq	r3,zero,81128d70 <__udivsi3+0x54>
81128d50:	0005883a 	mov	r2,zero
81128d54:	31400236 	bltu	r6,r5,81128d60 <__udivsi3+0x44>
81128d58:	314dc83a 	sub	r6,r6,r5
81128d5c:	10c4b03a 	or	r2,r2,r3
81128d60:	1806d07a 	srli	r3,r3,1
81128d64:	280ad07a 	srli	r5,r5,1
81128d68:	183ffa1e 	bne	r3,zero,81128d54 <__reset+0xfb108d54>
81128d6c:	f800283a 	ret
81128d70:	0005883a 	mov	r2,zero
81128d74:	f800283a 	ret
81128d78:	00c00044 	movi	r3,1
81128d7c:	003ff406 	br	81128d50 <__reset+0xfb108d50>

81128d80 <__umodsi3>:
81128d80:	2005883a 	mov	r2,r4
81128d84:	2900122e 	bgeu	r5,r4,81128dd0 <__umodsi3+0x50>
81128d88:	28001116 	blt	r5,zero,81128dd0 <__umodsi3+0x50>
81128d8c:	01800804 	movi	r6,32
81128d90:	00c00044 	movi	r3,1
81128d94:	00000206 	br	81128da0 <__umodsi3+0x20>
81128d98:	30000c26 	beq	r6,zero,81128dcc <__umodsi3+0x4c>
81128d9c:	28000516 	blt	r5,zero,81128db4 <__umodsi3+0x34>
81128da0:	294b883a 	add	r5,r5,r5
81128da4:	31bfffc4 	addi	r6,r6,-1
81128da8:	18c7883a 	add	r3,r3,r3
81128dac:	293ffa36 	bltu	r5,r4,81128d98 <__reset+0xfb108d98>
81128db0:	18000626 	beq	r3,zero,81128dcc <__umodsi3+0x4c>
81128db4:	1806d07a 	srli	r3,r3,1
81128db8:	11400136 	bltu	r2,r5,81128dc0 <__umodsi3+0x40>
81128dbc:	1145c83a 	sub	r2,r2,r5
81128dc0:	280ad07a 	srli	r5,r5,1
81128dc4:	183ffb1e 	bne	r3,zero,81128db4 <__reset+0xfb108db4>
81128dc8:	f800283a 	ret
81128dcc:	f800283a 	ret
81128dd0:	00c00044 	movi	r3,1
81128dd4:	003ff706 	br	81128db4 <__reset+0xfb108db4>

81128dd8 <__eqsf2>:
81128dd8:	2006d5fa 	srli	r3,r4,23
81128ddc:	280cd5fa 	srli	r6,r5,23
81128de0:	01c02034 	movhi	r7,128
81128de4:	39ffffc4 	addi	r7,r7,-1
81128de8:	18c03fcc 	andi	r3,r3,255
81128dec:	02003fc4 	movi	r8,255
81128df0:	3904703a 	and	r2,r7,r4
81128df4:	31803fcc 	andi	r6,r6,255
81128df8:	394e703a 	and	r7,r7,r5
81128dfc:	2008d7fa 	srli	r4,r4,31
81128e00:	280ad7fa 	srli	r5,r5,31
81128e04:	1a000d26 	beq	r3,r8,81128e3c <__eqsf2+0x64>
81128e08:	02003fc4 	movi	r8,255
81128e0c:	32000826 	beq	r6,r8,81128e30 <__eqsf2+0x58>
81128e10:	19800226 	beq	r3,r6,81128e1c <__eqsf2+0x44>
81128e14:	00800044 	movi	r2,1
81128e18:	f800283a 	ret
81128e1c:	11fffd1e 	bne	r2,r7,81128e14 <__reset+0xfb108e14>
81128e20:	21400926 	beq	r4,r5,81128e48 <__eqsf2+0x70>
81128e24:	183ffb1e 	bne	r3,zero,81128e14 <__reset+0xfb108e14>
81128e28:	1004c03a 	cmpne	r2,r2,zero
81128e2c:	f800283a 	ret
81128e30:	383ff726 	beq	r7,zero,81128e10 <__reset+0xfb108e10>
81128e34:	00800044 	movi	r2,1
81128e38:	f800283a 	ret
81128e3c:	103ff226 	beq	r2,zero,81128e08 <__reset+0xfb108e08>
81128e40:	00800044 	movi	r2,1
81128e44:	f800283a 	ret
81128e48:	0005883a 	mov	r2,zero
81128e4c:	f800283a 	ret

81128e50 <__gesf2>:
81128e50:	2004d5fa 	srli	r2,r4,23
81128e54:	2806d5fa 	srli	r3,r5,23
81128e58:	01802034 	movhi	r6,128
81128e5c:	31bfffc4 	addi	r6,r6,-1
81128e60:	10803fcc 	andi	r2,r2,255
81128e64:	01c03fc4 	movi	r7,255
81128e68:	3110703a 	and	r8,r6,r4
81128e6c:	18c03fcc 	andi	r3,r3,255
81128e70:	314c703a 	and	r6,r6,r5
81128e74:	2008d7fa 	srli	r4,r4,31
81128e78:	280ad7fa 	srli	r5,r5,31
81128e7c:	11c01926 	beq	r2,r7,81128ee4 <__gesf2+0x94>
81128e80:	01c03fc4 	movi	r7,255
81128e84:	19c00f26 	beq	r3,r7,81128ec4 <__gesf2+0x74>
81128e88:	1000061e 	bne	r2,zero,81128ea4 <__gesf2+0x54>
81128e8c:	400f003a 	cmpeq	r7,r8,zero
81128e90:	1800071e 	bne	r3,zero,81128eb0 <__gesf2+0x60>
81128e94:	3000061e 	bne	r6,zero,81128eb0 <__gesf2+0x60>
81128e98:	0005883a 	mov	r2,zero
81128e9c:	40000e1e 	bne	r8,zero,81128ed8 <__gesf2+0x88>
81128ea0:	f800283a 	ret
81128ea4:	18000a1e 	bne	r3,zero,81128ed0 <__gesf2+0x80>
81128ea8:	30000b26 	beq	r6,zero,81128ed8 <__gesf2+0x88>
81128eac:	000f883a 	mov	r7,zero
81128eb0:	29403fcc 	andi	r5,r5,255
81128eb4:	38000726 	beq	r7,zero,81128ed4 <__gesf2+0x84>
81128eb8:	28000826 	beq	r5,zero,81128edc <__gesf2+0x8c>
81128ebc:	00800044 	movi	r2,1
81128ec0:	f800283a 	ret
81128ec4:	303ff026 	beq	r6,zero,81128e88 <__reset+0xfb108e88>
81128ec8:	00bfff84 	movi	r2,-2
81128ecc:	f800283a 	ret
81128ed0:	29403fcc 	andi	r5,r5,255
81128ed4:	21400526 	beq	r4,r5,81128eec <__gesf2+0x9c>
81128ed8:	203ff826 	beq	r4,zero,81128ebc <__reset+0xfb108ebc>
81128edc:	00bfffc4 	movi	r2,-1
81128ee0:	f800283a 	ret
81128ee4:	403fe626 	beq	r8,zero,81128e80 <__reset+0xfb108e80>
81128ee8:	003ff706 	br	81128ec8 <__reset+0xfb108ec8>
81128eec:	18bffa16 	blt	r3,r2,81128ed8 <__reset+0xfb108ed8>
81128ef0:	10c00216 	blt	r2,r3,81128efc <__gesf2+0xac>
81128ef4:	323ff836 	bltu	r6,r8,81128ed8 <__reset+0xfb108ed8>
81128ef8:	4180022e 	bgeu	r8,r6,81128f04 <__gesf2+0xb4>
81128efc:	203fef1e 	bne	r4,zero,81128ebc <__reset+0xfb108ebc>
81128f00:	003ff606 	br	81128edc <__reset+0xfb108edc>
81128f04:	0005883a 	mov	r2,zero
81128f08:	f800283a 	ret

81128f0c <__lesf2>:
81128f0c:	2004d5fa 	srli	r2,r4,23
81128f10:	280cd5fa 	srli	r6,r5,23
81128f14:	00c02034 	movhi	r3,128
81128f18:	18ffffc4 	addi	r3,r3,-1
81128f1c:	10803fcc 	andi	r2,r2,255
81128f20:	01c03fc4 	movi	r7,255
81128f24:	1910703a 	and	r8,r3,r4
81128f28:	31803fcc 	andi	r6,r6,255
81128f2c:	1946703a 	and	r3,r3,r5
81128f30:	2008d7fa 	srli	r4,r4,31
81128f34:	280ad7fa 	srli	r5,r5,31
81128f38:	11c01b26 	beq	r2,r7,81128fa8 <__lesf2+0x9c>
81128f3c:	01c03fc4 	movi	r7,255
81128f40:	31c01126 	beq	r6,r7,81128f88 <__lesf2+0x7c>
81128f44:	1000071e 	bne	r2,zero,81128f64 <__lesf2+0x58>
81128f48:	400f003a 	cmpeq	r7,r8,zero
81128f4c:	21003fcc 	andi	r4,r4,255
81128f50:	3000081e 	bne	r6,zero,81128f74 <__lesf2+0x68>
81128f54:	1800071e 	bne	r3,zero,81128f74 <__lesf2+0x68>
81128f58:	0005883a 	mov	r2,zero
81128f5c:	40000f1e 	bne	r8,zero,81128f9c <__lesf2+0x90>
81128f60:	f800283a 	ret
81128f64:	21003fcc 	andi	r4,r4,255
81128f68:	30000a1e 	bne	r6,zero,81128f94 <__lesf2+0x88>
81128f6c:	18000b26 	beq	r3,zero,81128f9c <__lesf2+0x90>
81128f70:	000f883a 	mov	r7,zero
81128f74:	29403fcc 	andi	r5,r5,255
81128f78:	38000726 	beq	r7,zero,81128f98 <__lesf2+0x8c>
81128f7c:	28000826 	beq	r5,zero,81128fa0 <__lesf2+0x94>
81128f80:	00800044 	movi	r2,1
81128f84:	f800283a 	ret
81128f88:	183fee26 	beq	r3,zero,81128f44 <__reset+0xfb108f44>
81128f8c:	00800084 	movi	r2,2
81128f90:	f800283a 	ret
81128f94:	29403fcc 	andi	r5,r5,255
81128f98:	21400626 	beq	r4,r5,81128fb4 <__lesf2+0xa8>
81128f9c:	203ff826 	beq	r4,zero,81128f80 <__reset+0xfb108f80>
81128fa0:	00bfffc4 	movi	r2,-1
81128fa4:	f800283a 	ret
81128fa8:	403fe426 	beq	r8,zero,81128f3c <__reset+0xfb108f3c>
81128fac:	00800084 	movi	r2,2
81128fb0:	f800283a 	ret
81128fb4:	30bff916 	blt	r6,r2,81128f9c <__reset+0xfb108f9c>
81128fb8:	11800216 	blt	r2,r6,81128fc4 <__lesf2+0xb8>
81128fbc:	1a3ff736 	bltu	r3,r8,81128f9c <__reset+0xfb108f9c>
81128fc0:	40c0022e 	bgeu	r8,r3,81128fcc <__lesf2+0xc0>
81128fc4:	203fee1e 	bne	r4,zero,81128f80 <__reset+0xfb108f80>
81128fc8:	003ff506 	br	81128fa0 <__reset+0xfb108fa0>
81128fcc:	0005883a 	mov	r2,zero
81128fd0:	f800283a 	ret

81128fd4 <__adddf3>:
81128fd4:	02c00434 	movhi	r11,16
81128fd8:	5affffc4 	addi	r11,r11,-1
81128fdc:	2806d7fa 	srli	r3,r5,31
81128fe0:	2ad4703a 	and	r10,r5,r11
81128fe4:	3ad2703a 	and	r9,r7,r11
81128fe8:	3804d53a 	srli	r2,r7,20
81128fec:	3018d77a 	srli	r12,r6,29
81128ff0:	280ad53a 	srli	r5,r5,20
81128ff4:	501490fa 	slli	r10,r10,3
81128ff8:	2010d77a 	srli	r8,r4,29
81128ffc:	481290fa 	slli	r9,r9,3
81129000:	380ed7fa 	srli	r7,r7,31
81129004:	defffb04 	addi	sp,sp,-20
81129008:	de00012e 	bgeu	sp,et,81129010 <__adddf3+0x3c>
8112900c:	003b68fa 	trap	3
81129010:	dc800215 	stw	r18,8(sp)
81129014:	dc400115 	stw	r17,4(sp)
81129018:	dc000015 	stw	r16,0(sp)
8112901c:	dfc00415 	stw	ra,16(sp)
81129020:	dcc00315 	stw	r19,12(sp)
81129024:	1c803fcc 	andi	r18,r3,255
81129028:	2c01ffcc 	andi	r16,r5,2047
8112902c:	5210b03a 	or	r8,r10,r8
81129030:	202290fa 	slli	r17,r4,3
81129034:	1081ffcc 	andi	r2,r2,2047
81129038:	4b12b03a 	or	r9,r9,r12
8112903c:	300c90fa 	slli	r6,r6,3
81129040:	91c07526 	beq	r18,r7,81129218 <__adddf3+0x244>
81129044:	8087c83a 	sub	r3,r16,r2
81129048:	00c0ab0e 	bge	zero,r3,811292f8 <__adddf3+0x324>
8112904c:	10002a1e 	bne	r2,zero,811290f8 <__adddf3+0x124>
81129050:	4984b03a 	or	r2,r9,r6
81129054:	1000961e 	bne	r2,zero,811292b0 <__adddf3+0x2dc>
81129058:	888001cc 	andi	r2,r17,7
8112905c:	10000726 	beq	r2,zero,8112907c <__adddf3+0xa8>
81129060:	888003cc 	andi	r2,r17,15
81129064:	00c00104 	movi	r3,4
81129068:	10c00426 	beq	r2,r3,8112907c <__adddf3+0xa8>
8112906c:	88c7883a 	add	r3,r17,r3
81129070:	1c63803a 	cmpltu	r17,r3,r17
81129074:	4451883a 	add	r8,r8,r17
81129078:	1823883a 	mov	r17,r3
8112907c:	4080202c 	andhi	r2,r8,128
81129080:	10005926 	beq	r2,zero,811291e8 <__adddf3+0x214>
81129084:	84000044 	addi	r16,r16,1
81129088:	0081ffc4 	movi	r2,2047
8112908c:	8080ba26 	beq	r16,r2,81129378 <__adddf3+0x3a4>
81129090:	00bfe034 	movhi	r2,65408
81129094:	10bfffc4 	addi	r2,r2,-1
81129098:	4090703a 	and	r8,r8,r2
8112909c:	4004977a 	slli	r2,r8,29
811290a0:	4010927a 	slli	r8,r8,9
811290a4:	8822d0fa 	srli	r17,r17,3
811290a8:	8401ffcc 	andi	r16,r16,2047
811290ac:	4010d33a 	srli	r8,r8,12
811290b0:	9007883a 	mov	r3,r18
811290b4:	1444b03a 	or	r2,r2,r17
811290b8:	8401ffcc 	andi	r16,r16,2047
811290bc:	8020953a 	slli	r16,r16,20
811290c0:	18c03fcc 	andi	r3,r3,255
811290c4:	01000434 	movhi	r4,16
811290c8:	213fffc4 	addi	r4,r4,-1
811290cc:	180697fa 	slli	r3,r3,31
811290d0:	4110703a 	and	r8,r8,r4
811290d4:	4410b03a 	or	r8,r8,r16
811290d8:	40c6b03a 	or	r3,r8,r3
811290dc:	dfc00417 	ldw	ra,16(sp)
811290e0:	dcc00317 	ldw	r19,12(sp)
811290e4:	dc800217 	ldw	r18,8(sp)
811290e8:	dc400117 	ldw	r17,4(sp)
811290ec:	dc000017 	ldw	r16,0(sp)
811290f0:	dec00504 	addi	sp,sp,20
811290f4:	f800283a 	ret
811290f8:	0081ffc4 	movi	r2,2047
811290fc:	80bfd626 	beq	r16,r2,81129058 <__reset+0xfb109058>
81129100:	4a402034 	orhi	r9,r9,128
81129104:	00800e04 	movi	r2,56
81129108:	10c09f16 	blt	r2,r3,81129388 <__adddf3+0x3b4>
8112910c:	008007c4 	movi	r2,31
81129110:	10c0c216 	blt	r2,r3,8112941c <__adddf3+0x448>
81129114:	00800804 	movi	r2,32
81129118:	10c5c83a 	sub	r2,r2,r3
8112911c:	488a983a 	sll	r5,r9,r2
81129120:	30c8d83a 	srl	r4,r6,r3
81129124:	3084983a 	sll	r2,r6,r2
81129128:	48c6d83a 	srl	r3,r9,r3
8112912c:	290cb03a 	or	r6,r5,r4
81129130:	1004c03a 	cmpne	r2,r2,zero
81129134:	308cb03a 	or	r6,r6,r2
81129138:	898dc83a 	sub	r6,r17,r6
8112913c:	89a3803a 	cmpltu	r17,r17,r6
81129140:	40d1c83a 	sub	r8,r8,r3
81129144:	4451c83a 	sub	r8,r8,r17
81129148:	3023883a 	mov	r17,r6
8112914c:	4080202c 	andhi	r2,r8,128
81129150:	10002326 	beq	r2,zero,811291e0 <__adddf3+0x20c>
81129154:	04c02034 	movhi	r19,128
81129158:	9cffffc4 	addi	r19,r19,-1
8112915c:	44e6703a 	and	r19,r8,r19
81129160:	98007626 	beq	r19,zero,8112933c <__adddf3+0x368>
81129164:	9809883a 	mov	r4,r19
81129168:	11154c40 	call	811154c4 <__clzsi2>
8112916c:	10fffe04 	addi	r3,r2,-8
81129170:	010007c4 	movi	r4,31
81129174:	20c07716 	blt	r4,r3,81129354 <__adddf3+0x380>
81129178:	00800804 	movi	r2,32
8112917c:	10c5c83a 	sub	r2,r2,r3
81129180:	8884d83a 	srl	r2,r17,r2
81129184:	98d0983a 	sll	r8,r19,r3
81129188:	88e2983a 	sll	r17,r17,r3
8112918c:	1204b03a 	or	r2,r2,r8
81129190:	1c007416 	blt	r3,r16,81129364 <__adddf3+0x390>
81129194:	1c21c83a 	sub	r16,r3,r16
81129198:	82000044 	addi	r8,r16,1
8112919c:	00c007c4 	movi	r3,31
811291a0:	1a009116 	blt	r3,r8,811293e8 <__adddf3+0x414>
811291a4:	00c00804 	movi	r3,32
811291a8:	1a07c83a 	sub	r3,r3,r8
811291ac:	8a08d83a 	srl	r4,r17,r8
811291b0:	88e2983a 	sll	r17,r17,r3
811291b4:	10c6983a 	sll	r3,r2,r3
811291b8:	1210d83a 	srl	r8,r2,r8
811291bc:	8804c03a 	cmpne	r2,r17,zero
811291c0:	1906b03a 	or	r3,r3,r4
811291c4:	18a2b03a 	or	r17,r3,r2
811291c8:	0021883a 	mov	r16,zero
811291cc:	003fa206 	br	81129058 <__reset+0xfb109058>
811291d0:	1890b03a 	or	r8,r3,r2
811291d4:	40017d26 	beq	r8,zero,811297cc <__adddf3+0x7f8>
811291d8:	1011883a 	mov	r8,r2
811291dc:	1823883a 	mov	r17,r3
811291e0:	888001cc 	andi	r2,r17,7
811291e4:	103f9e1e 	bne	r2,zero,81129060 <__reset+0xfb109060>
811291e8:	4004977a 	slli	r2,r8,29
811291ec:	8822d0fa 	srli	r17,r17,3
811291f0:	4010d0fa 	srli	r8,r8,3
811291f4:	9007883a 	mov	r3,r18
811291f8:	1444b03a 	or	r2,r2,r17
811291fc:	0101ffc4 	movi	r4,2047
81129200:	81002426 	beq	r16,r4,81129294 <__adddf3+0x2c0>
81129204:	8120703a 	and	r16,r16,r4
81129208:	01000434 	movhi	r4,16
8112920c:	213fffc4 	addi	r4,r4,-1
81129210:	4110703a 	and	r8,r8,r4
81129214:	003fa806 	br	811290b8 <__reset+0xfb1090b8>
81129218:	8089c83a 	sub	r4,r16,r2
8112921c:	01005e0e 	bge	zero,r4,81129398 <__adddf3+0x3c4>
81129220:	10002b26 	beq	r2,zero,811292d0 <__adddf3+0x2fc>
81129224:	0081ffc4 	movi	r2,2047
81129228:	80bf8b26 	beq	r16,r2,81129058 <__reset+0xfb109058>
8112922c:	4a402034 	orhi	r9,r9,128
81129230:	00800e04 	movi	r2,56
81129234:	1100a40e 	bge	r2,r4,811294c8 <__adddf3+0x4f4>
81129238:	498cb03a 	or	r6,r9,r6
8112923c:	300ac03a 	cmpne	r5,r6,zero
81129240:	0013883a 	mov	r9,zero
81129244:	2c4b883a 	add	r5,r5,r17
81129248:	2c63803a 	cmpltu	r17,r5,r17
8112924c:	4a11883a 	add	r8,r9,r8
81129250:	8a11883a 	add	r8,r17,r8
81129254:	2823883a 	mov	r17,r5
81129258:	4080202c 	andhi	r2,r8,128
8112925c:	103fe026 	beq	r2,zero,811291e0 <__reset+0xfb1091e0>
81129260:	84000044 	addi	r16,r16,1
81129264:	0081ffc4 	movi	r2,2047
81129268:	8080d226 	beq	r16,r2,811295b4 <__adddf3+0x5e0>
8112926c:	00bfe034 	movhi	r2,65408
81129270:	10bfffc4 	addi	r2,r2,-1
81129274:	4090703a 	and	r8,r8,r2
81129278:	880ad07a 	srli	r5,r17,1
8112927c:	400897fa 	slli	r4,r8,31
81129280:	88c0004c 	andi	r3,r17,1
81129284:	28e2b03a 	or	r17,r5,r3
81129288:	4010d07a 	srli	r8,r8,1
8112928c:	2462b03a 	or	r17,r4,r17
81129290:	003f7106 	br	81129058 <__reset+0xfb109058>
81129294:	4088b03a 	or	r4,r8,r2
81129298:	20014526 	beq	r4,zero,811297b0 <__adddf3+0x7dc>
8112929c:	01000434 	movhi	r4,16
811292a0:	42000234 	orhi	r8,r8,8
811292a4:	213fffc4 	addi	r4,r4,-1
811292a8:	4110703a 	and	r8,r8,r4
811292ac:	003f8206 	br	811290b8 <__reset+0xfb1090b8>
811292b0:	18ffffc4 	addi	r3,r3,-1
811292b4:	1800491e 	bne	r3,zero,811293dc <__adddf3+0x408>
811292b8:	898bc83a 	sub	r5,r17,r6
811292bc:	8963803a 	cmpltu	r17,r17,r5
811292c0:	4251c83a 	sub	r8,r8,r9
811292c4:	4451c83a 	sub	r8,r8,r17
811292c8:	2823883a 	mov	r17,r5
811292cc:	003f9f06 	br	8112914c <__reset+0xfb10914c>
811292d0:	4984b03a 	or	r2,r9,r6
811292d4:	103f6026 	beq	r2,zero,81129058 <__reset+0xfb109058>
811292d8:	213fffc4 	addi	r4,r4,-1
811292dc:	2000931e 	bne	r4,zero,8112952c <__adddf3+0x558>
811292e0:	898d883a 	add	r6,r17,r6
811292e4:	3463803a 	cmpltu	r17,r6,r17
811292e8:	4251883a 	add	r8,r8,r9
811292ec:	8a11883a 	add	r8,r17,r8
811292f0:	3023883a 	mov	r17,r6
811292f4:	003fd806 	br	81129258 <__reset+0xfb109258>
811292f8:	1800541e 	bne	r3,zero,8112944c <__adddf3+0x478>
811292fc:	80800044 	addi	r2,r16,1
81129300:	1081ffcc 	andi	r2,r2,2047
81129304:	00c00044 	movi	r3,1
81129308:	1880a00e 	bge	r3,r2,8112958c <__adddf3+0x5b8>
8112930c:	8989c83a 	sub	r4,r17,r6
81129310:	8905803a 	cmpltu	r2,r17,r4
81129314:	4267c83a 	sub	r19,r8,r9
81129318:	98a7c83a 	sub	r19,r19,r2
8112931c:	9880202c 	andhi	r2,r19,128
81129320:	10006326 	beq	r2,zero,811294b0 <__adddf3+0x4dc>
81129324:	3463c83a 	sub	r17,r6,r17
81129328:	4a07c83a 	sub	r3,r9,r8
8112932c:	344d803a 	cmpltu	r6,r6,r17
81129330:	19a7c83a 	sub	r19,r3,r6
81129334:	3825883a 	mov	r18,r7
81129338:	983f8a1e 	bne	r19,zero,81129164 <__reset+0xfb109164>
8112933c:	8809883a 	mov	r4,r17
81129340:	11154c40 	call	811154c4 <__clzsi2>
81129344:	10800804 	addi	r2,r2,32
81129348:	10fffe04 	addi	r3,r2,-8
8112934c:	010007c4 	movi	r4,31
81129350:	20ff890e 	bge	r4,r3,81129178 <__reset+0xfb109178>
81129354:	10bff604 	addi	r2,r2,-40
81129358:	8884983a 	sll	r2,r17,r2
8112935c:	0023883a 	mov	r17,zero
81129360:	1c3f8c0e 	bge	r3,r16,81129194 <__reset+0xfb109194>
81129364:	023fe034 	movhi	r8,65408
81129368:	423fffc4 	addi	r8,r8,-1
8112936c:	80e1c83a 	sub	r16,r16,r3
81129370:	1210703a 	and	r8,r2,r8
81129374:	003f3806 	br	81129058 <__reset+0xfb109058>
81129378:	9007883a 	mov	r3,r18
8112937c:	0011883a 	mov	r8,zero
81129380:	0005883a 	mov	r2,zero
81129384:	003f4c06 	br	811290b8 <__reset+0xfb1090b8>
81129388:	498cb03a 	or	r6,r9,r6
8112938c:	300cc03a 	cmpne	r6,r6,zero
81129390:	0007883a 	mov	r3,zero
81129394:	003f6806 	br	81129138 <__reset+0xfb109138>
81129398:	20009c1e 	bne	r4,zero,8112960c <__adddf3+0x638>
8112939c:	80800044 	addi	r2,r16,1
811293a0:	1141ffcc 	andi	r5,r2,2047
811293a4:	01000044 	movi	r4,1
811293a8:	2140670e 	bge	r4,r5,81129548 <__adddf3+0x574>
811293ac:	0101ffc4 	movi	r4,2047
811293b0:	11007f26 	beq	r2,r4,811295b0 <__adddf3+0x5dc>
811293b4:	898d883a 	add	r6,r17,r6
811293b8:	4247883a 	add	r3,r8,r9
811293bc:	3451803a 	cmpltu	r8,r6,r17
811293c0:	40d1883a 	add	r8,r8,r3
811293c4:	402297fa 	slli	r17,r8,31
811293c8:	300cd07a 	srli	r6,r6,1
811293cc:	4010d07a 	srli	r8,r8,1
811293d0:	1021883a 	mov	r16,r2
811293d4:	89a2b03a 	or	r17,r17,r6
811293d8:	003f1f06 	br	81129058 <__reset+0xfb109058>
811293dc:	0081ffc4 	movi	r2,2047
811293e0:	80bf481e 	bne	r16,r2,81129104 <__reset+0xfb109104>
811293e4:	003f1c06 	br	81129058 <__reset+0xfb109058>
811293e8:	843ff844 	addi	r16,r16,-31
811293ec:	01000804 	movi	r4,32
811293f0:	1406d83a 	srl	r3,r2,r16
811293f4:	41005026 	beq	r8,r4,81129538 <__adddf3+0x564>
811293f8:	01001004 	movi	r4,64
811293fc:	2211c83a 	sub	r8,r4,r8
81129400:	1204983a 	sll	r2,r2,r8
81129404:	88a2b03a 	or	r17,r17,r2
81129408:	8822c03a 	cmpne	r17,r17,zero
8112940c:	1c62b03a 	or	r17,r3,r17
81129410:	0011883a 	mov	r8,zero
81129414:	0021883a 	mov	r16,zero
81129418:	003f7106 	br	811291e0 <__reset+0xfb1091e0>
8112941c:	193ff804 	addi	r4,r3,-32
81129420:	00800804 	movi	r2,32
81129424:	4908d83a 	srl	r4,r9,r4
81129428:	18804526 	beq	r3,r2,81129540 <__adddf3+0x56c>
8112942c:	00801004 	movi	r2,64
81129430:	10c5c83a 	sub	r2,r2,r3
81129434:	4886983a 	sll	r3,r9,r2
81129438:	198cb03a 	or	r6,r3,r6
8112943c:	300cc03a 	cmpne	r6,r6,zero
81129440:	218cb03a 	or	r6,r4,r6
81129444:	0007883a 	mov	r3,zero
81129448:	003f3b06 	br	81129138 <__reset+0xfb109138>
8112944c:	80002a26 	beq	r16,zero,811294f8 <__adddf3+0x524>
81129450:	0101ffc4 	movi	r4,2047
81129454:	11006826 	beq	r2,r4,811295f8 <__adddf3+0x624>
81129458:	00c7c83a 	sub	r3,zero,r3
8112945c:	42002034 	orhi	r8,r8,128
81129460:	01000e04 	movi	r4,56
81129464:	20c07c16 	blt	r4,r3,81129658 <__adddf3+0x684>
81129468:	010007c4 	movi	r4,31
8112946c:	20c0da16 	blt	r4,r3,811297d8 <__adddf3+0x804>
81129470:	01000804 	movi	r4,32
81129474:	20c9c83a 	sub	r4,r4,r3
81129478:	4114983a 	sll	r10,r8,r4
8112947c:	88cad83a 	srl	r5,r17,r3
81129480:	8908983a 	sll	r4,r17,r4
81129484:	40c6d83a 	srl	r3,r8,r3
81129488:	5162b03a 	or	r17,r10,r5
8112948c:	2008c03a 	cmpne	r4,r4,zero
81129490:	8922b03a 	or	r17,r17,r4
81129494:	3463c83a 	sub	r17,r6,r17
81129498:	48c7c83a 	sub	r3,r9,r3
8112949c:	344d803a 	cmpltu	r6,r6,r17
811294a0:	1991c83a 	sub	r8,r3,r6
811294a4:	1021883a 	mov	r16,r2
811294a8:	3825883a 	mov	r18,r7
811294ac:	003f2706 	br	8112914c <__reset+0xfb10914c>
811294b0:	24d0b03a 	or	r8,r4,r19
811294b4:	40001b1e 	bne	r8,zero,81129524 <__adddf3+0x550>
811294b8:	0005883a 	mov	r2,zero
811294bc:	0007883a 	mov	r3,zero
811294c0:	0021883a 	mov	r16,zero
811294c4:	003f4d06 	br	811291fc <__reset+0xfb1091fc>
811294c8:	008007c4 	movi	r2,31
811294cc:	11003c16 	blt	r2,r4,811295c0 <__adddf3+0x5ec>
811294d0:	00800804 	movi	r2,32
811294d4:	1105c83a 	sub	r2,r2,r4
811294d8:	488e983a 	sll	r7,r9,r2
811294dc:	310ad83a 	srl	r5,r6,r4
811294e0:	3084983a 	sll	r2,r6,r2
811294e4:	4912d83a 	srl	r9,r9,r4
811294e8:	394ab03a 	or	r5,r7,r5
811294ec:	1004c03a 	cmpne	r2,r2,zero
811294f0:	288ab03a 	or	r5,r5,r2
811294f4:	003f5306 	br	81129244 <__reset+0xfb109244>
811294f8:	4448b03a 	or	r4,r8,r17
811294fc:	20003e26 	beq	r4,zero,811295f8 <__adddf3+0x624>
81129500:	00c6303a 	nor	r3,zero,r3
81129504:	18003a1e 	bne	r3,zero,811295f0 <__adddf3+0x61c>
81129508:	3463c83a 	sub	r17,r6,r17
8112950c:	4a07c83a 	sub	r3,r9,r8
81129510:	344d803a 	cmpltu	r6,r6,r17
81129514:	1991c83a 	sub	r8,r3,r6
81129518:	1021883a 	mov	r16,r2
8112951c:	3825883a 	mov	r18,r7
81129520:	003f0a06 	br	8112914c <__reset+0xfb10914c>
81129524:	2023883a 	mov	r17,r4
81129528:	003f0d06 	br	81129160 <__reset+0xfb109160>
8112952c:	0081ffc4 	movi	r2,2047
81129530:	80bf3f1e 	bne	r16,r2,81129230 <__reset+0xfb109230>
81129534:	003ec806 	br	81129058 <__reset+0xfb109058>
81129538:	0005883a 	mov	r2,zero
8112953c:	003fb106 	br	81129404 <__reset+0xfb109404>
81129540:	0007883a 	mov	r3,zero
81129544:	003fbc06 	br	81129438 <__reset+0xfb109438>
81129548:	4444b03a 	or	r2,r8,r17
8112954c:	8000871e 	bne	r16,zero,8112976c <__adddf3+0x798>
81129550:	1000ba26 	beq	r2,zero,8112983c <__adddf3+0x868>
81129554:	4984b03a 	or	r2,r9,r6
81129558:	103ebf26 	beq	r2,zero,81129058 <__reset+0xfb109058>
8112955c:	8985883a 	add	r2,r17,r6
81129560:	4247883a 	add	r3,r8,r9
81129564:	1451803a 	cmpltu	r8,r2,r17
81129568:	40d1883a 	add	r8,r8,r3
8112956c:	40c0202c 	andhi	r3,r8,128
81129570:	1023883a 	mov	r17,r2
81129574:	183f1a26 	beq	r3,zero,811291e0 <__reset+0xfb1091e0>
81129578:	00bfe034 	movhi	r2,65408
8112957c:	10bfffc4 	addi	r2,r2,-1
81129580:	2021883a 	mov	r16,r4
81129584:	4090703a 	and	r8,r8,r2
81129588:	003eb306 	br	81129058 <__reset+0xfb109058>
8112958c:	4444b03a 	or	r2,r8,r17
81129590:	8000291e 	bne	r16,zero,81129638 <__adddf3+0x664>
81129594:	10004b1e 	bne	r2,zero,811296c4 <__adddf3+0x6f0>
81129598:	4990b03a 	or	r8,r9,r6
8112959c:	40008b26 	beq	r8,zero,811297cc <__adddf3+0x7f8>
811295a0:	4811883a 	mov	r8,r9
811295a4:	3023883a 	mov	r17,r6
811295a8:	3825883a 	mov	r18,r7
811295ac:	003eaa06 	br	81129058 <__reset+0xfb109058>
811295b0:	1021883a 	mov	r16,r2
811295b4:	0011883a 	mov	r8,zero
811295b8:	0005883a 	mov	r2,zero
811295bc:	003f0f06 	br	811291fc <__reset+0xfb1091fc>
811295c0:	217ff804 	addi	r5,r4,-32
811295c4:	00800804 	movi	r2,32
811295c8:	494ad83a 	srl	r5,r9,r5
811295cc:	20807d26 	beq	r4,r2,811297c4 <__adddf3+0x7f0>
811295d0:	00801004 	movi	r2,64
811295d4:	1109c83a 	sub	r4,r2,r4
811295d8:	4912983a 	sll	r9,r9,r4
811295dc:	498cb03a 	or	r6,r9,r6
811295e0:	300cc03a 	cmpne	r6,r6,zero
811295e4:	298ab03a 	or	r5,r5,r6
811295e8:	0013883a 	mov	r9,zero
811295ec:	003f1506 	br	81129244 <__reset+0xfb109244>
811295f0:	0101ffc4 	movi	r4,2047
811295f4:	113f9a1e 	bne	r2,r4,81129460 <__reset+0xfb109460>
811295f8:	4811883a 	mov	r8,r9
811295fc:	3023883a 	mov	r17,r6
81129600:	1021883a 	mov	r16,r2
81129604:	3825883a 	mov	r18,r7
81129608:	003e9306 	br	81129058 <__reset+0xfb109058>
8112960c:	8000161e 	bne	r16,zero,81129668 <__adddf3+0x694>
81129610:	444ab03a 	or	r5,r8,r17
81129614:	28005126 	beq	r5,zero,8112975c <__adddf3+0x788>
81129618:	0108303a 	nor	r4,zero,r4
8112961c:	20004d1e 	bne	r4,zero,81129754 <__adddf3+0x780>
81129620:	89a3883a 	add	r17,r17,r6
81129624:	4253883a 	add	r9,r8,r9
81129628:	898d803a 	cmpltu	r6,r17,r6
8112962c:	3251883a 	add	r8,r6,r9
81129630:	1021883a 	mov	r16,r2
81129634:	003f0806 	br	81129258 <__reset+0xfb109258>
81129638:	1000301e 	bne	r2,zero,811296fc <__adddf3+0x728>
8112963c:	4984b03a 	or	r2,r9,r6
81129640:	10007126 	beq	r2,zero,81129808 <__adddf3+0x834>
81129644:	4811883a 	mov	r8,r9
81129648:	3023883a 	mov	r17,r6
8112964c:	3825883a 	mov	r18,r7
81129650:	0401ffc4 	movi	r16,2047
81129654:	003e8006 	br	81129058 <__reset+0xfb109058>
81129658:	4462b03a 	or	r17,r8,r17
8112965c:	8822c03a 	cmpne	r17,r17,zero
81129660:	0007883a 	mov	r3,zero
81129664:	003f8b06 	br	81129494 <__reset+0xfb109494>
81129668:	0141ffc4 	movi	r5,2047
8112966c:	11403b26 	beq	r2,r5,8112975c <__adddf3+0x788>
81129670:	0109c83a 	sub	r4,zero,r4
81129674:	42002034 	orhi	r8,r8,128
81129678:	01400e04 	movi	r5,56
8112967c:	29006716 	blt	r5,r4,8112981c <__adddf3+0x848>
81129680:	014007c4 	movi	r5,31
81129684:	29007016 	blt	r5,r4,81129848 <__adddf3+0x874>
81129688:	01400804 	movi	r5,32
8112968c:	290bc83a 	sub	r5,r5,r4
81129690:	4154983a 	sll	r10,r8,r5
81129694:	890ed83a 	srl	r7,r17,r4
81129698:	894a983a 	sll	r5,r17,r5
8112969c:	4108d83a 	srl	r4,r8,r4
811296a0:	51e2b03a 	or	r17,r10,r7
811296a4:	280ac03a 	cmpne	r5,r5,zero
811296a8:	8962b03a 	or	r17,r17,r5
811296ac:	89a3883a 	add	r17,r17,r6
811296b0:	2253883a 	add	r9,r4,r9
811296b4:	898d803a 	cmpltu	r6,r17,r6
811296b8:	3251883a 	add	r8,r6,r9
811296bc:	1021883a 	mov	r16,r2
811296c0:	003ee506 	br	81129258 <__reset+0xfb109258>
811296c4:	4984b03a 	or	r2,r9,r6
811296c8:	103e6326 	beq	r2,zero,81129058 <__reset+0xfb109058>
811296cc:	8987c83a 	sub	r3,r17,r6
811296d0:	88c9803a 	cmpltu	r4,r17,r3
811296d4:	4245c83a 	sub	r2,r8,r9
811296d8:	1105c83a 	sub	r2,r2,r4
811296dc:	1100202c 	andhi	r4,r2,128
811296e0:	203ebb26 	beq	r4,zero,811291d0 <__reset+0xfb1091d0>
811296e4:	3463c83a 	sub	r17,r6,r17
811296e8:	4a07c83a 	sub	r3,r9,r8
811296ec:	344d803a 	cmpltu	r6,r6,r17
811296f0:	1991c83a 	sub	r8,r3,r6
811296f4:	3825883a 	mov	r18,r7
811296f8:	003e5706 	br	81129058 <__reset+0xfb109058>
811296fc:	4984b03a 	or	r2,r9,r6
81129700:	10002e26 	beq	r2,zero,811297bc <__adddf3+0x7e8>
81129704:	4004d0fa 	srli	r2,r8,3
81129708:	8822d0fa 	srli	r17,r17,3
8112970c:	4010977a 	slli	r8,r8,29
81129710:	10c0022c 	andhi	r3,r2,8
81129714:	4462b03a 	or	r17,r8,r17
81129718:	18000826 	beq	r3,zero,8112973c <__adddf3+0x768>
8112971c:	4808d0fa 	srli	r4,r9,3
81129720:	20c0022c 	andhi	r3,r4,8
81129724:	1800051e 	bne	r3,zero,8112973c <__adddf3+0x768>
81129728:	300cd0fa 	srli	r6,r6,3
8112972c:	4806977a 	slli	r3,r9,29
81129730:	2005883a 	mov	r2,r4
81129734:	3825883a 	mov	r18,r7
81129738:	19a2b03a 	or	r17,r3,r6
8112973c:	8810d77a 	srli	r8,r17,29
81129740:	100490fa 	slli	r2,r2,3
81129744:	882290fa 	slli	r17,r17,3
81129748:	0401ffc4 	movi	r16,2047
8112974c:	4090b03a 	or	r8,r8,r2
81129750:	003e4106 	br	81129058 <__reset+0xfb109058>
81129754:	0141ffc4 	movi	r5,2047
81129758:	117fc71e 	bne	r2,r5,81129678 <__reset+0xfb109678>
8112975c:	4811883a 	mov	r8,r9
81129760:	3023883a 	mov	r17,r6
81129764:	1021883a 	mov	r16,r2
81129768:	003e3b06 	br	81129058 <__reset+0xfb109058>
8112976c:	10002f26 	beq	r2,zero,8112982c <__adddf3+0x858>
81129770:	4984b03a 	or	r2,r9,r6
81129774:	10001126 	beq	r2,zero,811297bc <__adddf3+0x7e8>
81129778:	4004d0fa 	srli	r2,r8,3
8112977c:	8822d0fa 	srli	r17,r17,3
81129780:	4010977a 	slli	r8,r8,29
81129784:	10c0022c 	andhi	r3,r2,8
81129788:	4462b03a 	or	r17,r8,r17
8112978c:	183feb26 	beq	r3,zero,8112973c <__reset+0xfb10973c>
81129790:	4808d0fa 	srli	r4,r9,3
81129794:	20c0022c 	andhi	r3,r4,8
81129798:	183fe81e 	bne	r3,zero,8112973c <__reset+0xfb10973c>
8112979c:	300cd0fa 	srli	r6,r6,3
811297a0:	4806977a 	slli	r3,r9,29
811297a4:	2005883a 	mov	r2,r4
811297a8:	19a2b03a 	or	r17,r3,r6
811297ac:	003fe306 	br	8112973c <__reset+0xfb10973c>
811297b0:	0011883a 	mov	r8,zero
811297b4:	0005883a 	mov	r2,zero
811297b8:	003e3f06 	br	811290b8 <__reset+0xfb1090b8>
811297bc:	0401ffc4 	movi	r16,2047
811297c0:	003e2506 	br	81129058 <__reset+0xfb109058>
811297c4:	0013883a 	mov	r9,zero
811297c8:	003f8406 	br	811295dc <__reset+0xfb1095dc>
811297cc:	0005883a 	mov	r2,zero
811297d0:	0007883a 	mov	r3,zero
811297d4:	003e8906 	br	811291fc <__reset+0xfb1091fc>
811297d8:	197ff804 	addi	r5,r3,-32
811297dc:	01000804 	movi	r4,32
811297e0:	414ad83a 	srl	r5,r8,r5
811297e4:	19002426 	beq	r3,r4,81129878 <__adddf3+0x8a4>
811297e8:	01001004 	movi	r4,64
811297ec:	20c7c83a 	sub	r3,r4,r3
811297f0:	40c6983a 	sll	r3,r8,r3
811297f4:	1c46b03a 	or	r3,r3,r17
811297f8:	1806c03a 	cmpne	r3,r3,zero
811297fc:	28e2b03a 	or	r17,r5,r3
81129800:	0007883a 	mov	r3,zero
81129804:	003f2306 	br	81129494 <__reset+0xfb109494>
81129808:	0007883a 	mov	r3,zero
8112980c:	5811883a 	mov	r8,r11
81129810:	00bfffc4 	movi	r2,-1
81129814:	0401ffc4 	movi	r16,2047
81129818:	003e7806 	br	811291fc <__reset+0xfb1091fc>
8112981c:	4462b03a 	or	r17,r8,r17
81129820:	8822c03a 	cmpne	r17,r17,zero
81129824:	0009883a 	mov	r4,zero
81129828:	003fa006 	br	811296ac <__reset+0xfb1096ac>
8112982c:	4811883a 	mov	r8,r9
81129830:	3023883a 	mov	r17,r6
81129834:	0401ffc4 	movi	r16,2047
81129838:	003e0706 	br	81129058 <__reset+0xfb109058>
8112983c:	4811883a 	mov	r8,r9
81129840:	3023883a 	mov	r17,r6
81129844:	003e0406 	br	81129058 <__reset+0xfb109058>
81129848:	21fff804 	addi	r7,r4,-32
8112984c:	01400804 	movi	r5,32
81129850:	41ced83a 	srl	r7,r8,r7
81129854:	21400a26 	beq	r4,r5,81129880 <__adddf3+0x8ac>
81129858:	01401004 	movi	r5,64
8112985c:	2909c83a 	sub	r4,r5,r4
81129860:	4108983a 	sll	r4,r8,r4
81129864:	2448b03a 	or	r4,r4,r17
81129868:	2008c03a 	cmpne	r4,r4,zero
8112986c:	3922b03a 	or	r17,r7,r4
81129870:	0009883a 	mov	r4,zero
81129874:	003f8d06 	br	811296ac <__reset+0xfb1096ac>
81129878:	0007883a 	mov	r3,zero
8112987c:	003fdd06 	br	811297f4 <__reset+0xfb1097f4>
81129880:	0009883a 	mov	r4,zero
81129884:	003ff706 	br	81129864 <__reset+0xfb109864>

81129888 <__divdf3>:
81129888:	defff204 	addi	sp,sp,-56
8112988c:	de00012e 	bgeu	sp,et,81129894 <__divdf3+0xc>
81129890:	003b68fa 	trap	3
81129894:	dd400915 	stw	r21,36(sp)
81129898:	282ad53a 	srli	r21,r5,20
8112989c:	dd000815 	stw	r20,32(sp)
811298a0:	2828d7fa 	srli	r20,r5,31
811298a4:	dc000415 	stw	r16,16(sp)
811298a8:	04000434 	movhi	r16,16
811298ac:	df000c15 	stw	fp,48(sp)
811298b0:	843fffc4 	addi	r16,r16,-1
811298b4:	dfc00d15 	stw	ra,52(sp)
811298b8:	ddc00b15 	stw	r23,44(sp)
811298bc:	dd800a15 	stw	r22,40(sp)
811298c0:	dcc00715 	stw	r19,28(sp)
811298c4:	dc800615 	stw	r18,24(sp)
811298c8:	dc400515 	stw	r17,20(sp)
811298cc:	ad41ffcc 	andi	r21,r21,2047
811298d0:	2c20703a 	and	r16,r5,r16
811298d4:	a7003fcc 	andi	fp,r20,255
811298d8:	a8006126 	beq	r21,zero,81129a60 <__divdf3+0x1d8>
811298dc:	0081ffc4 	movi	r2,2047
811298e0:	2025883a 	mov	r18,r4
811298e4:	a8803726 	beq	r21,r2,811299c4 <__divdf3+0x13c>
811298e8:	80800434 	orhi	r2,r16,16
811298ec:	100490fa 	slli	r2,r2,3
811298f0:	2020d77a 	srli	r16,r4,29
811298f4:	202490fa 	slli	r18,r4,3
811298f8:	ad7f0044 	addi	r21,r21,-1023
811298fc:	80a0b03a 	or	r16,r16,r2
81129900:	0027883a 	mov	r19,zero
81129904:	0013883a 	mov	r9,zero
81129908:	3804d53a 	srli	r2,r7,20
8112990c:	382cd7fa 	srli	r22,r7,31
81129910:	04400434 	movhi	r17,16
81129914:	8c7fffc4 	addi	r17,r17,-1
81129918:	1081ffcc 	andi	r2,r2,2047
8112991c:	3011883a 	mov	r8,r6
81129920:	3c62703a 	and	r17,r7,r17
81129924:	b5c03fcc 	andi	r23,r22,255
81129928:	10006c26 	beq	r2,zero,81129adc <__divdf3+0x254>
8112992c:	00c1ffc4 	movi	r3,2047
81129930:	10c06426 	beq	r2,r3,81129ac4 <__divdf3+0x23c>
81129934:	88c00434 	orhi	r3,r17,16
81129938:	180690fa 	slli	r3,r3,3
8112993c:	3022d77a 	srli	r17,r6,29
81129940:	301090fa 	slli	r8,r6,3
81129944:	10bf0044 	addi	r2,r2,-1023
81129948:	88e2b03a 	or	r17,r17,r3
8112994c:	000f883a 	mov	r7,zero
81129950:	a58cf03a 	xor	r6,r20,r22
81129954:	3cc8b03a 	or	r4,r7,r19
81129958:	a8abc83a 	sub	r21,r21,r2
8112995c:	008003c4 	movi	r2,15
81129960:	3007883a 	mov	r3,r6
81129964:	34c03fcc 	andi	r19,r6,255
81129968:	11009036 	bltu	r2,r4,81129bac <__divdf3+0x324>
8112996c:	200890ba 	slli	r4,r4,2
81129970:	00a044f4 	movhi	r2,33043
81129974:	10a66104 	addi	r2,r2,-26236
81129978:	2089883a 	add	r4,r4,r2
8112997c:	20800017 	ldw	r2,0(r4)
81129980:	1000683a 	jmp	r2
81129984:	81129bac 	andhi	r4,r16,19054
81129988:	811299fc 	xorhi	r4,r16,19047
8112998c:	81129b9c 	xori	r4,r16,19054
81129990:	811299f0 	cmpltui	r4,r16,19047
81129994:	81129b9c 	xori	r4,r16,19054
81129998:	81129b70 	cmpltui	r4,r16,19053
8112999c:	81129b9c 	xori	r4,r16,19054
811299a0:	811299f0 	cmpltui	r4,r16,19047
811299a4:	811299fc 	xorhi	r4,r16,19047
811299a8:	811299fc 	xorhi	r4,r16,19047
811299ac:	81129b70 	cmpltui	r4,r16,19053
811299b0:	811299f0 	cmpltui	r4,r16,19047
811299b4:	811299e0 	cmpeqi	r4,r16,19047
811299b8:	811299e0 	cmpeqi	r4,r16,19047
811299bc:	811299e0 	cmpeqi	r4,r16,19047
811299c0:	81129e90 	cmplti	r4,r16,19066
811299c4:	2404b03a 	or	r2,r4,r16
811299c8:	1000661e 	bne	r2,zero,81129b64 <__divdf3+0x2dc>
811299cc:	04c00204 	movi	r19,8
811299d0:	0021883a 	mov	r16,zero
811299d4:	0025883a 	mov	r18,zero
811299d8:	02400084 	movi	r9,2
811299dc:	003fca06 	br	81129908 <__reset+0xfb109908>
811299e0:	8023883a 	mov	r17,r16
811299e4:	9011883a 	mov	r8,r18
811299e8:	e02f883a 	mov	r23,fp
811299ec:	480f883a 	mov	r7,r9
811299f0:	00800084 	movi	r2,2
811299f4:	3881311e 	bne	r7,r2,81129ebc <__divdf3+0x634>
811299f8:	b827883a 	mov	r19,r23
811299fc:	98c0004c 	andi	r3,r19,1
81129a00:	0081ffc4 	movi	r2,2047
81129a04:	000b883a 	mov	r5,zero
81129a08:	0025883a 	mov	r18,zero
81129a0c:	1004953a 	slli	r2,r2,20
81129a10:	18c03fcc 	andi	r3,r3,255
81129a14:	04400434 	movhi	r17,16
81129a18:	8c7fffc4 	addi	r17,r17,-1
81129a1c:	180697fa 	slli	r3,r3,31
81129a20:	2c4a703a 	and	r5,r5,r17
81129a24:	288ab03a 	or	r5,r5,r2
81129a28:	28c6b03a 	or	r3,r5,r3
81129a2c:	9005883a 	mov	r2,r18
81129a30:	dfc00d17 	ldw	ra,52(sp)
81129a34:	df000c17 	ldw	fp,48(sp)
81129a38:	ddc00b17 	ldw	r23,44(sp)
81129a3c:	dd800a17 	ldw	r22,40(sp)
81129a40:	dd400917 	ldw	r21,36(sp)
81129a44:	dd000817 	ldw	r20,32(sp)
81129a48:	dcc00717 	ldw	r19,28(sp)
81129a4c:	dc800617 	ldw	r18,24(sp)
81129a50:	dc400517 	ldw	r17,20(sp)
81129a54:	dc000417 	ldw	r16,16(sp)
81129a58:	dec00e04 	addi	sp,sp,56
81129a5c:	f800283a 	ret
81129a60:	2404b03a 	or	r2,r4,r16
81129a64:	2027883a 	mov	r19,r4
81129a68:	10003926 	beq	r2,zero,81129b50 <__divdf3+0x2c8>
81129a6c:	80012e26 	beq	r16,zero,81129f28 <__divdf3+0x6a0>
81129a70:	8009883a 	mov	r4,r16
81129a74:	d9800315 	stw	r6,12(sp)
81129a78:	d9c00215 	stw	r7,8(sp)
81129a7c:	11154c40 	call	811154c4 <__clzsi2>
81129a80:	d9800317 	ldw	r6,12(sp)
81129a84:	d9c00217 	ldw	r7,8(sp)
81129a88:	113ffd44 	addi	r4,r2,-11
81129a8c:	00c00704 	movi	r3,28
81129a90:	19012116 	blt	r3,r4,81129f18 <__divdf3+0x690>
81129a94:	00c00744 	movi	r3,29
81129a98:	147ffe04 	addi	r17,r2,-8
81129a9c:	1907c83a 	sub	r3,r3,r4
81129aa0:	8460983a 	sll	r16,r16,r17
81129aa4:	98c6d83a 	srl	r3,r19,r3
81129aa8:	9c64983a 	sll	r18,r19,r17
81129aac:	1c20b03a 	or	r16,r3,r16
81129ab0:	1080fcc4 	addi	r2,r2,1011
81129ab4:	00abc83a 	sub	r21,zero,r2
81129ab8:	0027883a 	mov	r19,zero
81129abc:	0013883a 	mov	r9,zero
81129ac0:	003f9106 	br	81129908 <__reset+0xfb109908>
81129ac4:	3446b03a 	or	r3,r6,r17
81129ac8:	18001f1e 	bne	r3,zero,81129b48 <__divdf3+0x2c0>
81129acc:	0023883a 	mov	r17,zero
81129ad0:	0011883a 	mov	r8,zero
81129ad4:	01c00084 	movi	r7,2
81129ad8:	003f9d06 	br	81129950 <__reset+0xfb109950>
81129adc:	3446b03a 	or	r3,r6,r17
81129ae0:	18001526 	beq	r3,zero,81129b38 <__divdf3+0x2b0>
81129ae4:	88011b26 	beq	r17,zero,81129f54 <__divdf3+0x6cc>
81129ae8:	8809883a 	mov	r4,r17
81129aec:	d9800315 	stw	r6,12(sp)
81129af0:	da400115 	stw	r9,4(sp)
81129af4:	11154c40 	call	811154c4 <__clzsi2>
81129af8:	d9800317 	ldw	r6,12(sp)
81129afc:	da400117 	ldw	r9,4(sp)
81129b00:	113ffd44 	addi	r4,r2,-11
81129b04:	00c00704 	movi	r3,28
81129b08:	19010e16 	blt	r3,r4,81129f44 <__divdf3+0x6bc>
81129b0c:	00c00744 	movi	r3,29
81129b10:	123ffe04 	addi	r8,r2,-8
81129b14:	1907c83a 	sub	r3,r3,r4
81129b18:	8a22983a 	sll	r17,r17,r8
81129b1c:	30c6d83a 	srl	r3,r6,r3
81129b20:	3210983a 	sll	r8,r6,r8
81129b24:	1c62b03a 	or	r17,r3,r17
81129b28:	1080fcc4 	addi	r2,r2,1011
81129b2c:	0085c83a 	sub	r2,zero,r2
81129b30:	000f883a 	mov	r7,zero
81129b34:	003f8606 	br	81129950 <__reset+0xfb109950>
81129b38:	0023883a 	mov	r17,zero
81129b3c:	0011883a 	mov	r8,zero
81129b40:	01c00044 	movi	r7,1
81129b44:	003f8206 	br	81129950 <__reset+0xfb109950>
81129b48:	01c000c4 	movi	r7,3
81129b4c:	003f8006 	br	81129950 <__reset+0xfb109950>
81129b50:	04c00104 	movi	r19,4
81129b54:	0021883a 	mov	r16,zero
81129b58:	0025883a 	mov	r18,zero
81129b5c:	02400044 	movi	r9,1
81129b60:	003f6906 	br	81129908 <__reset+0xfb109908>
81129b64:	04c00304 	movi	r19,12
81129b68:	024000c4 	movi	r9,3
81129b6c:	003f6606 	br	81129908 <__reset+0xfb109908>
81129b70:	01400434 	movhi	r5,16
81129b74:	0007883a 	mov	r3,zero
81129b78:	297fffc4 	addi	r5,r5,-1
81129b7c:	04bfffc4 	movi	r18,-1
81129b80:	0081ffc4 	movi	r2,2047
81129b84:	003fa106 	br	81129a0c <__reset+0xfb109a0c>
81129b88:	00c00044 	movi	r3,1
81129b8c:	1887c83a 	sub	r3,r3,r2
81129b90:	01000e04 	movi	r4,56
81129b94:	20c1210e 	bge	r4,r3,8112a01c <__divdf3+0x794>
81129b98:	98c0004c 	andi	r3,r19,1
81129b9c:	0005883a 	mov	r2,zero
81129ba0:	000b883a 	mov	r5,zero
81129ba4:	0025883a 	mov	r18,zero
81129ba8:	003f9806 	br	81129a0c <__reset+0xfb109a0c>
81129bac:	8c00fd36 	bltu	r17,r16,81129fa4 <__divdf3+0x71c>
81129bb0:	8440fb26 	beq	r16,r17,81129fa0 <__divdf3+0x718>
81129bb4:	8007883a 	mov	r3,r16
81129bb8:	ad7fffc4 	addi	r21,r21,-1
81129bbc:	0021883a 	mov	r16,zero
81129bc0:	4004d63a 	srli	r2,r8,24
81129bc4:	8822923a 	slli	r17,r17,8
81129bc8:	1809883a 	mov	r4,r3
81129bcc:	402c923a 	slli	r22,r8,8
81129bd0:	88b8b03a 	or	fp,r17,r2
81129bd4:	e028d43a 	srli	r20,fp,16
81129bd8:	d8c00015 	stw	r3,0(sp)
81129bdc:	e5ffffcc 	andi	r23,fp,65535
81129be0:	a00b883a 	mov	r5,r20
81129be4:	1128d1c0 	call	81128d1c <__udivsi3>
81129be8:	d8c00017 	ldw	r3,0(sp)
81129bec:	a00b883a 	mov	r5,r20
81129bf0:	d8800315 	stw	r2,12(sp)
81129bf4:	1809883a 	mov	r4,r3
81129bf8:	1128d800 	call	81128d80 <__umodsi3>
81129bfc:	d9800317 	ldw	r6,12(sp)
81129c00:	1006943a 	slli	r3,r2,16
81129c04:	9004d43a 	srli	r2,r18,16
81129c08:	b9a3383a 	mul	r17,r23,r6
81129c0c:	10c4b03a 	or	r2,r2,r3
81129c10:	1440062e 	bgeu	r2,r17,81129c2c <__divdf3+0x3a4>
81129c14:	1705883a 	add	r2,r2,fp
81129c18:	30ffffc4 	addi	r3,r6,-1
81129c1c:	1700ee36 	bltu	r2,fp,81129fd8 <__divdf3+0x750>
81129c20:	1440ed2e 	bgeu	r2,r17,81129fd8 <__divdf3+0x750>
81129c24:	31bfff84 	addi	r6,r6,-2
81129c28:	1705883a 	add	r2,r2,fp
81129c2c:	1463c83a 	sub	r17,r2,r17
81129c30:	a00b883a 	mov	r5,r20
81129c34:	8809883a 	mov	r4,r17
81129c38:	d9800315 	stw	r6,12(sp)
81129c3c:	1128d1c0 	call	81128d1c <__udivsi3>
81129c40:	a00b883a 	mov	r5,r20
81129c44:	8809883a 	mov	r4,r17
81129c48:	d8800215 	stw	r2,8(sp)
81129c4c:	1128d800 	call	81128d80 <__umodsi3>
81129c50:	d9c00217 	ldw	r7,8(sp)
81129c54:	1004943a 	slli	r2,r2,16
81129c58:	94bfffcc 	andi	r18,r18,65535
81129c5c:	b9d1383a 	mul	r8,r23,r7
81129c60:	90a4b03a 	or	r18,r18,r2
81129c64:	d9800317 	ldw	r6,12(sp)
81129c68:	9200062e 	bgeu	r18,r8,81129c84 <__divdf3+0x3fc>
81129c6c:	9725883a 	add	r18,r18,fp
81129c70:	38bfffc4 	addi	r2,r7,-1
81129c74:	9700d636 	bltu	r18,fp,81129fd0 <__divdf3+0x748>
81129c78:	9200d52e 	bgeu	r18,r8,81129fd0 <__divdf3+0x748>
81129c7c:	39ffff84 	addi	r7,r7,-2
81129c80:	9725883a 	add	r18,r18,fp
81129c84:	3004943a 	slli	r2,r6,16
81129c88:	b012d43a 	srli	r9,r22,16
81129c8c:	b1bfffcc 	andi	r6,r22,65535
81129c90:	11e2b03a 	or	r17,r2,r7
81129c94:	8806d43a 	srli	r3,r17,16
81129c98:	893fffcc 	andi	r4,r17,65535
81129c9c:	218b383a 	mul	r5,r4,r6
81129ca0:	30c5383a 	mul	r2,r6,r3
81129ca4:	2249383a 	mul	r4,r4,r9
81129ca8:	280ed43a 	srli	r7,r5,16
81129cac:	9225c83a 	sub	r18,r18,r8
81129cb0:	2089883a 	add	r4,r4,r2
81129cb4:	3909883a 	add	r4,r7,r4
81129cb8:	1a47383a 	mul	r3,r3,r9
81129cbc:	2080022e 	bgeu	r4,r2,81129cc8 <__divdf3+0x440>
81129cc0:	00800074 	movhi	r2,1
81129cc4:	1887883a 	add	r3,r3,r2
81129cc8:	2004d43a 	srli	r2,r4,16
81129ccc:	2008943a 	slli	r4,r4,16
81129cd0:	297fffcc 	andi	r5,r5,65535
81129cd4:	10c7883a 	add	r3,r2,r3
81129cd8:	2149883a 	add	r4,r4,r5
81129cdc:	90c0a536 	bltu	r18,r3,81129f74 <__divdf3+0x6ec>
81129ce0:	90c0bf26 	beq	r18,r3,81129fe0 <__divdf3+0x758>
81129ce4:	90c7c83a 	sub	r3,r18,r3
81129ce8:	810fc83a 	sub	r7,r16,r4
81129cec:	81e5803a 	cmpltu	r18,r16,r7
81129cf0:	1ca5c83a 	sub	r18,r3,r18
81129cf4:	e480c126 	beq	fp,r18,81129ffc <__divdf3+0x774>
81129cf8:	a00b883a 	mov	r5,r20
81129cfc:	9009883a 	mov	r4,r18
81129d00:	d9800315 	stw	r6,12(sp)
81129d04:	d9c00215 	stw	r7,8(sp)
81129d08:	da400115 	stw	r9,4(sp)
81129d0c:	1128d1c0 	call	81128d1c <__udivsi3>
81129d10:	a00b883a 	mov	r5,r20
81129d14:	9009883a 	mov	r4,r18
81129d18:	d8800015 	stw	r2,0(sp)
81129d1c:	1128d800 	call	81128d80 <__umodsi3>
81129d20:	d9c00217 	ldw	r7,8(sp)
81129d24:	da000017 	ldw	r8,0(sp)
81129d28:	1006943a 	slli	r3,r2,16
81129d2c:	3804d43a 	srli	r2,r7,16
81129d30:	ba21383a 	mul	r16,r23,r8
81129d34:	d9800317 	ldw	r6,12(sp)
81129d38:	10c4b03a 	or	r2,r2,r3
81129d3c:	da400117 	ldw	r9,4(sp)
81129d40:	1400062e 	bgeu	r2,r16,81129d5c <__divdf3+0x4d4>
81129d44:	1705883a 	add	r2,r2,fp
81129d48:	40ffffc4 	addi	r3,r8,-1
81129d4c:	1700ad36 	bltu	r2,fp,8112a004 <__divdf3+0x77c>
81129d50:	1400ac2e 	bgeu	r2,r16,8112a004 <__divdf3+0x77c>
81129d54:	423fff84 	addi	r8,r8,-2
81129d58:	1705883a 	add	r2,r2,fp
81129d5c:	1421c83a 	sub	r16,r2,r16
81129d60:	a00b883a 	mov	r5,r20
81129d64:	8009883a 	mov	r4,r16
81129d68:	d9800315 	stw	r6,12(sp)
81129d6c:	d9c00215 	stw	r7,8(sp)
81129d70:	da000015 	stw	r8,0(sp)
81129d74:	da400115 	stw	r9,4(sp)
81129d78:	1128d1c0 	call	81128d1c <__udivsi3>
81129d7c:	8009883a 	mov	r4,r16
81129d80:	a00b883a 	mov	r5,r20
81129d84:	1025883a 	mov	r18,r2
81129d88:	1128d800 	call	81128d80 <__umodsi3>
81129d8c:	d9c00217 	ldw	r7,8(sp)
81129d90:	1004943a 	slli	r2,r2,16
81129d94:	bcaf383a 	mul	r23,r23,r18
81129d98:	393fffcc 	andi	r4,r7,65535
81129d9c:	2088b03a 	or	r4,r4,r2
81129da0:	d9800317 	ldw	r6,12(sp)
81129da4:	da000017 	ldw	r8,0(sp)
81129da8:	da400117 	ldw	r9,4(sp)
81129dac:	25c0062e 	bgeu	r4,r23,81129dc8 <__divdf3+0x540>
81129db0:	2709883a 	add	r4,r4,fp
81129db4:	90bfffc4 	addi	r2,r18,-1
81129db8:	27009436 	bltu	r4,fp,8112a00c <__divdf3+0x784>
81129dbc:	25c0932e 	bgeu	r4,r23,8112a00c <__divdf3+0x784>
81129dc0:	94bfff84 	addi	r18,r18,-2
81129dc4:	2709883a 	add	r4,r4,fp
81129dc8:	4004943a 	slli	r2,r8,16
81129dcc:	25efc83a 	sub	r23,r4,r23
81129dd0:	1490b03a 	or	r8,r2,r18
81129dd4:	4008d43a 	srli	r4,r8,16
81129dd8:	40ffffcc 	andi	r3,r8,65535
81129ddc:	30c5383a 	mul	r2,r6,r3
81129de0:	1a47383a 	mul	r3,r3,r9
81129de4:	310d383a 	mul	r6,r6,r4
81129de8:	100ad43a 	srli	r5,r2,16
81129dec:	4913383a 	mul	r9,r9,r4
81129df0:	1987883a 	add	r3,r3,r6
81129df4:	28c7883a 	add	r3,r5,r3
81129df8:	1980022e 	bgeu	r3,r6,81129e04 <__divdf3+0x57c>
81129dfc:	01000074 	movhi	r4,1
81129e00:	4913883a 	add	r9,r9,r4
81129e04:	1808d43a 	srli	r4,r3,16
81129e08:	1806943a 	slli	r3,r3,16
81129e0c:	10bfffcc 	andi	r2,r2,65535
81129e10:	2253883a 	add	r9,r4,r9
81129e14:	1887883a 	add	r3,r3,r2
81129e18:	ba403836 	bltu	r23,r9,81129efc <__divdf3+0x674>
81129e1c:	ba403626 	beq	r23,r9,81129ef8 <__divdf3+0x670>
81129e20:	42000054 	ori	r8,r8,1
81129e24:	a880ffc4 	addi	r2,r21,1023
81129e28:	00bf570e 	bge	zero,r2,81129b88 <__reset+0xfb109b88>
81129e2c:	40c001cc 	andi	r3,r8,7
81129e30:	18000726 	beq	r3,zero,81129e50 <__divdf3+0x5c8>
81129e34:	40c003cc 	andi	r3,r8,15
81129e38:	01000104 	movi	r4,4
81129e3c:	19000426 	beq	r3,r4,81129e50 <__divdf3+0x5c8>
81129e40:	4107883a 	add	r3,r8,r4
81129e44:	1a11803a 	cmpltu	r8,r3,r8
81129e48:	8a23883a 	add	r17,r17,r8
81129e4c:	1811883a 	mov	r8,r3
81129e50:	88c0402c 	andhi	r3,r17,256
81129e54:	18000426 	beq	r3,zero,81129e68 <__divdf3+0x5e0>
81129e58:	00ffc034 	movhi	r3,65280
81129e5c:	18ffffc4 	addi	r3,r3,-1
81129e60:	a8810004 	addi	r2,r21,1024
81129e64:	88e2703a 	and	r17,r17,r3
81129e68:	00c1ff84 	movi	r3,2046
81129e6c:	18bee316 	blt	r3,r2,811299fc <__reset+0xfb1099fc>
81129e70:	8824977a 	slli	r18,r17,29
81129e74:	4010d0fa 	srli	r8,r8,3
81129e78:	8822927a 	slli	r17,r17,9
81129e7c:	1081ffcc 	andi	r2,r2,2047
81129e80:	9224b03a 	or	r18,r18,r8
81129e84:	880ad33a 	srli	r5,r17,12
81129e88:	98c0004c 	andi	r3,r19,1
81129e8c:	003edf06 	br	81129a0c <__reset+0xfb109a0c>
81129e90:	8080022c 	andhi	r2,r16,8
81129e94:	10001226 	beq	r2,zero,81129ee0 <__divdf3+0x658>
81129e98:	8880022c 	andhi	r2,r17,8
81129e9c:	1000101e 	bne	r2,zero,81129ee0 <__divdf3+0x658>
81129ea0:	00800434 	movhi	r2,16
81129ea4:	89400234 	orhi	r5,r17,8
81129ea8:	10bfffc4 	addi	r2,r2,-1
81129eac:	b007883a 	mov	r3,r22
81129eb0:	288a703a 	and	r5,r5,r2
81129eb4:	4025883a 	mov	r18,r8
81129eb8:	003f3106 	br	81129b80 <__reset+0xfb109b80>
81129ebc:	008000c4 	movi	r2,3
81129ec0:	3880a626 	beq	r7,r2,8112a15c <__divdf3+0x8d4>
81129ec4:	00800044 	movi	r2,1
81129ec8:	3880521e 	bne	r7,r2,8112a014 <__divdf3+0x78c>
81129ecc:	b807883a 	mov	r3,r23
81129ed0:	0005883a 	mov	r2,zero
81129ed4:	000b883a 	mov	r5,zero
81129ed8:	0025883a 	mov	r18,zero
81129edc:	003ecb06 	br	81129a0c <__reset+0xfb109a0c>
81129ee0:	00800434 	movhi	r2,16
81129ee4:	81400234 	orhi	r5,r16,8
81129ee8:	10bfffc4 	addi	r2,r2,-1
81129eec:	a007883a 	mov	r3,r20
81129ef0:	288a703a 	and	r5,r5,r2
81129ef4:	003f2206 	br	81129b80 <__reset+0xfb109b80>
81129ef8:	183fca26 	beq	r3,zero,81129e24 <__reset+0xfb109e24>
81129efc:	e5ef883a 	add	r23,fp,r23
81129f00:	40bfffc4 	addi	r2,r8,-1
81129f04:	bf00392e 	bgeu	r23,fp,81129fec <__divdf3+0x764>
81129f08:	1011883a 	mov	r8,r2
81129f0c:	ba7fc41e 	bne	r23,r9,81129e20 <__reset+0xfb109e20>
81129f10:	b0ffc31e 	bne	r22,r3,81129e20 <__reset+0xfb109e20>
81129f14:	003fc306 	br	81129e24 <__reset+0xfb109e24>
81129f18:	143ff604 	addi	r16,r2,-40
81129f1c:	9c20983a 	sll	r16,r19,r16
81129f20:	0025883a 	mov	r18,zero
81129f24:	003ee206 	br	81129ab0 <__reset+0xfb109ab0>
81129f28:	d9800315 	stw	r6,12(sp)
81129f2c:	d9c00215 	stw	r7,8(sp)
81129f30:	11154c40 	call	811154c4 <__clzsi2>
81129f34:	10800804 	addi	r2,r2,32
81129f38:	d9c00217 	ldw	r7,8(sp)
81129f3c:	d9800317 	ldw	r6,12(sp)
81129f40:	003ed106 	br	81129a88 <__reset+0xfb109a88>
81129f44:	147ff604 	addi	r17,r2,-40
81129f48:	3462983a 	sll	r17,r6,r17
81129f4c:	0011883a 	mov	r8,zero
81129f50:	003ef506 	br	81129b28 <__reset+0xfb109b28>
81129f54:	3009883a 	mov	r4,r6
81129f58:	d9800315 	stw	r6,12(sp)
81129f5c:	da400115 	stw	r9,4(sp)
81129f60:	11154c40 	call	811154c4 <__clzsi2>
81129f64:	10800804 	addi	r2,r2,32
81129f68:	da400117 	ldw	r9,4(sp)
81129f6c:	d9800317 	ldw	r6,12(sp)
81129f70:	003ee306 	br	81129b00 <__reset+0xfb109b00>
81129f74:	85a1883a 	add	r16,r16,r22
81129f78:	8585803a 	cmpltu	r2,r16,r22
81129f7c:	1705883a 	add	r2,r2,fp
81129f80:	14a5883a 	add	r18,r2,r18
81129f84:	88bfffc4 	addi	r2,r17,-1
81129f88:	e4800c2e 	bgeu	fp,r18,81129fbc <__divdf3+0x734>
81129f8c:	90c03e36 	bltu	r18,r3,8112a088 <__divdf3+0x800>
81129f90:	1c806926 	beq	r3,r18,8112a138 <__divdf3+0x8b0>
81129f94:	90c7c83a 	sub	r3,r18,r3
81129f98:	1023883a 	mov	r17,r2
81129f9c:	003f5206 	br	81129ce8 <__reset+0xfb109ce8>
81129fa0:	923f0436 	bltu	r18,r8,81129bb4 <__reset+0xfb109bb4>
81129fa4:	800897fa 	slli	r4,r16,31
81129fa8:	9004d07a 	srli	r2,r18,1
81129fac:	8006d07a 	srli	r3,r16,1
81129fb0:	902097fa 	slli	r16,r18,31
81129fb4:	20a4b03a 	or	r18,r4,r2
81129fb8:	003f0106 	br	81129bc0 <__reset+0xfb109bc0>
81129fbc:	e4bff51e 	bne	fp,r18,81129f94 <__reset+0xfb109f94>
81129fc0:	85bff22e 	bgeu	r16,r22,81129f8c <__reset+0xfb109f8c>
81129fc4:	e0c7c83a 	sub	r3,fp,r3
81129fc8:	1023883a 	mov	r17,r2
81129fcc:	003f4606 	br	81129ce8 <__reset+0xfb109ce8>
81129fd0:	100f883a 	mov	r7,r2
81129fd4:	003f2b06 	br	81129c84 <__reset+0xfb109c84>
81129fd8:	180d883a 	mov	r6,r3
81129fdc:	003f1306 	br	81129c2c <__reset+0xfb109c2c>
81129fe0:	813fe436 	bltu	r16,r4,81129f74 <__reset+0xfb109f74>
81129fe4:	0007883a 	mov	r3,zero
81129fe8:	003f3f06 	br	81129ce8 <__reset+0xfb109ce8>
81129fec:	ba402c36 	bltu	r23,r9,8112a0a0 <__divdf3+0x818>
81129ff0:	4dc05426 	beq	r9,r23,8112a144 <__divdf3+0x8bc>
81129ff4:	1011883a 	mov	r8,r2
81129ff8:	003f8906 	br	81129e20 <__reset+0xfb109e20>
81129ffc:	023fffc4 	movi	r8,-1
8112a000:	003f8806 	br	81129e24 <__reset+0xfb109e24>
8112a004:	1811883a 	mov	r8,r3
8112a008:	003f5406 	br	81129d5c <__reset+0xfb109d5c>
8112a00c:	1025883a 	mov	r18,r2
8112a010:	003f6d06 	br	81129dc8 <__reset+0xfb109dc8>
8112a014:	b827883a 	mov	r19,r23
8112a018:	003f8206 	br	81129e24 <__reset+0xfb109e24>
8112a01c:	010007c4 	movi	r4,31
8112a020:	20c02616 	blt	r4,r3,8112a0bc <__divdf3+0x834>
8112a024:	00800804 	movi	r2,32
8112a028:	10c5c83a 	sub	r2,r2,r3
8112a02c:	888a983a 	sll	r5,r17,r2
8112a030:	40c8d83a 	srl	r4,r8,r3
8112a034:	4084983a 	sll	r2,r8,r2
8112a038:	88e2d83a 	srl	r17,r17,r3
8112a03c:	2906b03a 	or	r3,r5,r4
8112a040:	1004c03a 	cmpne	r2,r2,zero
8112a044:	1886b03a 	or	r3,r3,r2
8112a048:	188001cc 	andi	r2,r3,7
8112a04c:	10000726 	beq	r2,zero,8112a06c <__divdf3+0x7e4>
8112a050:	188003cc 	andi	r2,r3,15
8112a054:	01000104 	movi	r4,4
8112a058:	11000426 	beq	r2,r4,8112a06c <__divdf3+0x7e4>
8112a05c:	1805883a 	mov	r2,r3
8112a060:	10c00104 	addi	r3,r2,4
8112a064:	1885803a 	cmpltu	r2,r3,r2
8112a068:	88a3883a 	add	r17,r17,r2
8112a06c:	8880202c 	andhi	r2,r17,128
8112a070:	10002726 	beq	r2,zero,8112a110 <__divdf3+0x888>
8112a074:	98c0004c 	andi	r3,r19,1
8112a078:	00800044 	movi	r2,1
8112a07c:	000b883a 	mov	r5,zero
8112a080:	0025883a 	mov	r18,zero
8112a084:	003e6106 	br	81129a0c <__reset+0xfb109a0c>
8112a088:	85a1883a 	add	r16,r16,r22
8112a08c:	8585803a 	cmpltu	r2,r16,r22
8112a090:	1705883a 	add	r2,r2,fp
8112a094:	14a5883a 	add	r18,r2,r18
8112a098:	8c7fff84 	addi	r17,r17,-2
8112a09c:	003f1106 	br	81129ce4 <__reset+0xfb109ce4>
8112a0a0:	b589883a 	add	r4,r22,r22
8112a0a4:	25ad803a 	cmpltu	r22,r4,r22
8112a0a8:	b739883a 	add	fp,r22,fp
8112a0ac:	40bfff84 	addi	r2,r8,-2
8112a0b0:	bf2f883a 	add	r23,r23,fp
8112a0b4:	202d883a 	mov	r22,r4
8112a0b8:	003f9306 	br	81129f08 <__reset+0xfb109f08>
8112a0bc:	013ff844 	movi	r4,-31
8112a0c0:	2085c83a 	sub	r2,r4,r2
8112a0c4:	8888d83a 	srl	r4,r17,r2
8112a0c8:	00800804 	movi	r2,32
8112a0cc:	18802126 	beq	r3,r2,8112a154 <__divdf3+0x8cc>
8112a0d0:	00801004 	movi	r2,64
8112a0d4:	10c5c83a 	sub	r2,r2,r3
8112a0d8:	8884983a 	sll	r2,r17,r2
8112a0dc:	1204b03a 	or	r2,r2,r8
8112a0e0:	1004c03a 	cmpne	r2,r2,zero
8112a0e4:	2084b03a 	or	r2,r4,r2
8112a0e8:	144001cc 	andi	r17,r2,7
8112a0ec:	88000d1e 	bne	r17,zero,8112a124 <__divdf3+0x89c>
8112a0f0:	000b883a 	mov	r5,zero
8112a0f4:	1024d0fa 	srli	r18,r2,3
8112a0f8:	98c0004c 	andi	r3,r19,1
8112a0fc:	0005883a 	mov	r2,zero
8112a100:	9464b03a 	or	r18,r18,r17
8112a104:	003e4106 	br	81129a0c <__reset+0xfb109a0c>
8112a108:	1007883a 	mov	r3,r2
8112a10c:	0023883a 	mov	r17,zero
8112a110:	880a927a 	slli	r5,r17,9
8112a114:	1805883a 	mov	r2,r3
8112a118:	8822977a 	slli	r17,r17,29
8112a11c:	280ad33a 	srli	r5,r5,12
8112a120:	003ff406 	br	8112a0f4 <__reset+0xfb10a0f4>
8112a124:	10c003cc 	andi	r3,r2,15
8112a128:	01000104 	movi	r4,4
8112a12c:	193ff626 	beq	r3,r4,8112a108 <__reset+0xfb10a108>
8112a130:	0023883a 	mov	r17,zero
8112a134:	003fca06 	br	8112a060 <__reset+0xfb10a060>
8112a138:	813fd336 	bltu	r16,r4,8112a088 <__reset+0xfb10a088>
8112a13c:	1023883a 	mov	r17,r2
8112a140:	003fa806 	br	81129fe4 <__reset+0xfb109fe4>
8112a144:	b0ffd636 	bltu	r22,r3,8112a0a0 <__reset+0xfb10a0a0>
8112a148:	1011883a 	mov	r8,r2
8112a14c:	b0ff341e 	bne	r22,r3,81129e20 <__reset+0xfb109e20>
8112a150:	003f3406 	br	81129e24 <__reset+0xfb109e24>
8112a154:	0005883a 	mov	r2,zero
8112a158:	003fe006 	br	8112a0dc <__reset+0xfb10a0dc>
8112a15c:	00800434 	movhi	r2,16
8112a160:	89400234 	orhi	r5,r17,8
8112a164:	10bfffc4 	addi	r2,r2,-1
8112a168:	b807883a 	mov	r3,r23
8112a16c:	288a703a 	and	r5,r5,r2
8112a170:	4025883a 	mov	r18,r8
8112a174:	003e8206 	br	81129b80 <__reset+0xfb109b80>

8112a178 <__eqdf2>:
8112a178:	2804d53a 	srli	r2,r5,20
8112a17c:	3806d53a 	srli	r3,r7,20
8112a180:	02000434 	movhi	r8,16
8112a184:	423fffc4 	addi	r8,r8,-1
8112a188:	1081ffcc 	andi	r2,r2,2047
8112a18c:	0281ffc4 	movi	r10,2047
8112a190:	2a12703a 	and	r9,r5,r8
8112a194:	18c1ffcc 	andi	r3,r3,2047
8112a198:	3a10703a 	and	r8,r7,r8
8112a19c:	280ad7fa 	srli	r5,r5,31
8112a1a0:	380ed7fa 	srli	r7,r7,31
8112a1a4:	12801026 	beq	r2,r10,8112a1e8 <__eqdf2+0x70>
8112a1a8:	0281ffc4 	movi	r10,2047
8112a1ac:	1a800a26 	beq	r3,r10,8112a1d8 <__eqdf2+0x60>
8112a1b0:	10c00226 	beq	r2,r3,8112a1bc <__eqdf2+0x44>
8112a1b4:	00800044 	movi	r2,1
8112a1b8:	f800283a 	ret
8112a1bc:	4a3ffd1e 	bne	r9,r8,8112a1b4 <__reset+0xfb10a1b4>
8112a1c0:	21bffc1e 	bne	r4,r6,8112a1b4 <__reset+0xfb10a1b4>
8112a1c4:	29c00c26 	beq	r5,r7,8112a1f8 <__eqdf2+0x80>
8112a1c8:	103ffa1e 	bne	r2,zero,8112a1b4 <__reset+0xfb10a1b4>
8112a1cc:	2244b03a 	or	r2,r4,r9
8112a1d0:	1004c03a 	cmpne	r2,r2,zero
8112a1d4:	f800283a 	ret
8112a1d8:	3214b03a 	or	r10,r6,r8
8112a1dc:	503ff426 	beq	r10,zero,8112a1b0 <__reset+0xfb10a1b0>
8112a1e0:	00800044 	movi	r2,1
8112a1e4:	f800283a 	ret
8112a1e8:	2254b03a 	or	r10,r4,r9
8112a1ec:	503fee26 	beq	r10,zero,8112a1a8 <__reset+0xfb10a1a8>
8112a1f0:	00800044 	movi	r2,1
8112a1f4:	f800283a 	ret
8112a1f8:	0005883a 	mov	r2,zero
8112a1fc:	f800283a 	ret

8112a200 <__gedf2>:
8112a200:	2804d53a 	srli	r2,r5,20
8112a204:	3806d53a 	srli	r3,r7,20
8112a208:	02000434 	movhi	r8,16
8112a20c:	423fffc4 	addi	r8,r8,-1
8112a210:	1081ffcc 	andi	r2,r2,2047
8112a214:	0241ffc4 	movi	r9,2047
8112a218:	2a14703a 	and	r10,r5,r8
8112a21c:	18c1ffcc 	andi	r3,r3,2047
8112a220:	3a10703a 	and	r8,r7,r8
8112a224:	280ad7fa 	srli	r5,r5,31
8112a228:	380ed7fa 	srli	r7,r7,31
8112a22c:	12401d26 	beq	r2,r9,8112a2a4 <__gedf2+0xa4>
8112a230:	0241ffc4 	movi	r9,2047
8112a234:	1a401226 	beq	r3,r9,8112a280 <__gedf2+0x80>
8112a238:	1000081e 	bne	r2,zero,8112a25c <__gedf2+0x5c>
8112a23c:	2296b03a 	or	r11,r4,r10
8112a240:	5813003a 	cmpeq	r9,r11,zero
8112a244:	1800091e 	bne	r3,zero,8112a26c <__gedf2+0x6c>
8112a248:	3218b03a 	or	r12,r6,r8
8112a24c:	6000071e 	bne	r12,zero,8112a26c <__gedf2+0x6c>
8112a250:	0005883a 	mov	r2,zero
8112a254:	5800101e 	bne	r11,zero,8112a298 <__gedf2+0x98>
8112a258:	f800283a 	ret
8112a25c:	18000c1e 	bne	r3,zero,8112a290 <__gedf2+0x90>
8112a260:	3212b03a 	or	r9,r6,r8
8112a264:	48000c26 	beq	r9,zero,8112a298 <__gedf2+0x98>
8112a268:	0013883a 	mov	r9,zero
8112a26c:	39c03fcc 	andi	r7,r7,255
8112a270:	48000826 	beq	r9,zero,8112a294 <__gedf2+0x94>
8112a274:	38000926 	beq	r7,zero,8112a29c <__gedf2+0x9c>
8112a278:	00800044 	movi	r2,1
8112a27c:	f800283a 	ret
8112a280:	3212b03a 	or	r9,r6,r8
8112a284:	483fec26 	beq	r9,zero,8112a238 <__reset+0xfb10a238>
8112a288:	00bfff84 	movi	r2,-2
8112a28c:	f800283a 	ret
8112a290:	39c03fcc 	andi	r7,r7,255
8112a294:	29c00626 	beq	r5,r7,8112a2b0 <__gedf2+0xb0>
8112a298:	283ff726 	beq	r5,zero,8112a278 <__reset+0xfb10a278>
8112a29c:	00bfffc4 	movi	r2,-1
8112a2a0:	f800283a 	ret
8112a2a4:	2292b03a 	or	r9,r4,r10
8112a2a8:	483fe126 	beq	r9,zero,8112a230 <__reset+0xfb10a230>
8112a2ac:	003ff606 	br	8112a288 <__reset+0xfb10a288>
8112a2b0:	18bff916 	blt	r3,r2,8112a298 <__reset+0xfb10a298>
8112a2b4:	10c00316 	blt	r2,r3,8112a2c4 <__gedf2+0xc4>
8112a2b8:	42bff736 	bltu	r8,r10,8112a298 <__reset+0xfb10a298>
8112a2bc:	52000326 	beq	r10,r8,8112a2cc <__gedf2+0xcc>
8112a2c0:	5200042e 	bgeu	r10,r8,8112a2d4 <__gedf2+0xd4>
8112a2c4:	283fec1e 	bne	r5,zero,8112a278 <__reset+0xfb10a278>
8112a2c8:	003ff406 	br	8112a29c <__reset+0xfb10a29c>
8112a2cc:	313ff236 	bltu	r6,r4,8112a298 <__reset+0xfb10a298>
8112a2d0:	21bffc36 	bltu	r4,r6,8112a2c4 <__reset+0xfb10a2c4>
8112a2d4:	0005883a 	mov	r2,zero
8112a2d8:	f800283a 	ret

8112a2dc <__ledf2>:
8112a2dc:	2804d53a 	srli	r2,r5,20
8112a2e0:	3810d53a 	srli	r8,r7,20
8112a2e4:	00c00434 	movhi	r3,16
8112a2e8:	18ffffc4 	addi	r3,r3,-1
8112a2ec:	1081ffcc 	andi	r2,r2,2047
8112a2f0:	0241ffc4 	movi	r9,2047
8112a2f4:	28d4703a 	and	r10,r5,r3
8112a2f8:	4201ffcc 	andi	r8,r8,2047
8112a2fc:	38c6703a 	and	r3,r7,r3
8112a300:	280ad7fa 	srli	r5,r5,31
8112a304:	380ed7fa 	srli	r7,r7,31
8112a308:	12401f26 	beq	r2,r9,8112a388 <__ledf2+0xac>
8112a30c:	0241ffc4 	movi	r9,2047
8112a310:	42401426 	beq	r8,r9,8112a364 <__ledf2+0x88>
8112a314:	1000091e 	bne	r2,zero,8112a33c <__ledf2+0x60>
8112a318:	2296b03a 	or	r11,r4,r10
8112a31c:	5813003a 	cmpeq	r9,r11,zero
8112a320:	29403fcc 	andi	r5,r5,255
8112a324:	40000a1e 	bne	r8,zero,8112a350 <__ledf2+0x74>
8112a328:	30d8b03a 	or	r12,r6,r3
8112a32c:	6000081e 	bne	r12,zero,8112a350 <__ledf2+0x74>
8112a330:	0005883a 	mov	r2,zero
8112a334:	5800111e 	bne	r11,zero,8112a37c <__ledf2+0xa0>
8112a338:	f800283a 	ret
8112a33c:	29403fcc 	andi	r5,r5,255
8112a340:	40000c1e 	bne	r8,zero,8112a374 <__ledf2+0x98>
8112a344:	30d2b03a 	or	r9,r6,r3
8112a348:	48000c26 	beq	r9,zero,8112a37c <__ledf2+0xa0>
8112a34c:	0013883a 	mov	r9,zero
8112a350:	39c03fcc 	andi	r7,r7,255
8112a354:	48000826 	beq	r9,zero,8112a378 <__ledf2+0x9c>
8112a358:	38001126 	beq	r7,zero,8112a3a0 <__ledf2+0xc4>
8112a35c:	00800044 	movi	r2,1
8112a360:	f800283a 	ret
8112a364:	30d2b03a 	or	r9,r6,r3
8112a368:	483fea26 	beq	r9,zero,8112a314 <__reset+0xfb10a314>
8112a36c:	00800084 	movi	r2,2
8112a370:	f800283a 	ret
8112a374:	39c03fcc 	andi	r7,r7,255
8112a378:	39400726 	beq	r7,r5,8112a398 <__ledf2+0xbc>
8112a37c:	2800081e 	bne	r5,zero,8112a3a0 <__ledf2+0xc4>
8112a380:	00800044 	movi	r2,1
8112a384:	f800283a 	ret
8112a388:	2292b03a 	or	r9,r4,r10
8112a38c:	483fdf26 	beq	r9,zero,8112a30c <__reset+0xfb10a30c>
8112a390:	00800084 	movi	r2,2
8112a394:	f800283a 	ret
8112a398:	4080030e 	bge	r8,r2,8112a3a8 <__ledf2+0xcc>
8112a39c:	383fef26 	beq	r7,zero,8112a35c <__reset+0xfb10a35c>
8112a3a0:	00bfffc4 	movi	r2,-1
8112a3a4:	f800283a 	ret
8112a3a8:	123feb16 	blt	r2,r8,8112a358 <__reset+0xfb10a358>
8112a3ac:	1abff336 	bltu	r3,r10,8112a37c <__reset+0xfb10a37c>
8112a3b0:	50c00326 	beq	r10,r3,8112a3c0 <__ledf2+0xe4>
8112a3b4:	50c0042e 	bgeu	r10,r3,8112a3c8 <__ledf2+0xec>
8112a3b8:	283fe81e 	bne	r5,zero,8112a35c <__reset+0xfb10a35c>
8112a3bc:	003ff806 	br	8112a3a0 <__reset+0xfb10a3a0>
8112a3c0:	313fee36 	bltu	r6,r4,8112a37c <__reset+0xfb10a37c>
8112a3c4:	21bffc36 	bltu	r4,r6,8112a3b8 <__reset+0xfb10a3b8>
8112a3c8:	0005883a 	mov	r2,zero
8112a3cc:	f800283a 	ret

8112a3d0 <__subdf3>:
8112a3d0:	02000434 	movhi	r8,16
8112a3d4:	423fffc4 	addi	r8,r8,-1
8112a3d8:	defffb04 	addi	sp,sp,-20
8112a3dc:	2a14703a 	and	r10,r5,r8
8112a3e0:	3812d53a 	srli	r9,r7,20
8112a3e4:	3a10703a 	and	r8,r7,r8
8112a3e8:	de00012e 	bgeu	sp,et,8112a3f0 <__subdf3+0x20>
8112a3ec:	003b68fa 	trap	3
8112a3f0:	2006d77a 	srli	r3,r4,29
8112a3f4:	3004d77a 	srli	r2,r6,29
8112a3f8:	dc000015 	stw	r16,0(sp)
8112a3fc:	501490fa 	slli	r10,r10,3
8112a400:	2820d53a 	srli	r16,r5,20
8112a404:	401090fa 	slli	r8,r8,3
8112a408:	dc800215 	stw	r18,8(sp)
8112a40c:	dc400115 	stw	r17,4(sp)
8112a410:	dfc00415 	stw	ra,16(sp)
8112a414:	202290fa 	slli	r17,r4,3
8112a418:	dcc00315 	stw	r19,12(sp)
8112a41c:	4a41ffcc 	andi	r9,r9,2047
8112a420:	0101ffc4 	movi	r4,2047
8112a424:	2824d7fa 	srli	r18,r5,31
8112a428:	8401ffcc 	andi	r16,r16,2047
8112a42c:	50c6b03a 	or	r3,r10,r3
8112a430:	380ed7fa 	srli	r7,r7,31
8112a434:	408ab03a 	or	r5,r8,r2
8112a438:	300c90fa 	slli	r6,r6,3
8112a43c:	49009626 	beq	r9,r4,8112a698 <__subdf3+0x2c8>
8112a440:	39c0005c 	xori	r7,r7,1
8112a444:	8245c83a 	sub	r2,r16,r9
8112a448:	3c807426 	beq	r7,r18,8112a61c <__subdf3+0x24c>
8112a44c:	0080af0e 	bge	zero,r2,8112a70c <__subdf3+0x33c>
8112a450:	48002a1e 	bne	r9,zero,8112a4fc <__subdf3+0x12c>
8112a454:	2988b03a 	or	r4,r5,r6
8112a458:	20009a1e 	bne	r4,zero,8112a6c4 <__subdf3+0x2f4>
8112a45c:	888001cc 	andi	r2,r17,7
8112a460:	10000726 	beq	r2,zero,8112a480 <__subdf3+0xb0>
8112a464:	888003cc 	andi	r2,r17,15
8112a468:	01000104 	movi	r4,4
8112a46c:	11000426 	beq	r2,r4,8112a480 <__subdf3+0xb0>
8112a470:	890b883a 	add	r5,r17,r4
8112a474:	2c63803a 	cmpltu	r17,r5,r17
8112a478:	1c47883a 	add	r3,r3,r17
8112a47c:	2823883a 	mov	r17,r5
8112a480:	1880202c 	andhi	r2,r3,128
8112a484:	10005926 	beq	r2,zero,8112a5ec <__subdf3+0x21c>
8112a488:	84000044 	addi	r16,r16,1
8112a48c:	0081ffc4 	movi	r2,2047
8112a490:	8080be26 	beq	r16,r2,8112a78c <__subdf3+0x3bc>
8112a494:	017fe034 	movhi	r5,65408
8112a498:	297fffc4 	addi	r5,r5,-1
8112a49c:	1946703a 	and	r3,r3,r5
8112a4a0:	1804977a 	slli	r2,r3,29
8112a4a4:	1806927a 	slli	r3,r3,9
8112a4a8:	8822d0fa 	srli	r17,r17,3
8112a4ac:	8401ffcc 	andi	r16,r16,2047
8112a4b0:	180ad33a 	srli	r5,r3,12
8112a4b4:	9100004c 	andi	r4,r18,1
8112a4b8:	1444b03a 	or	r2,r2,r17
8112a4bc:	80c1ffcc 	andi	r3,r16,2047
8112a4c0:	1820953a 	slli	r16,r3,20
8112a4c4:	20c03fcc 	andi	r3,r4,255
8112a4c8:	180897fa 	slli	r4,r3,31
8112a4cc:	00c00434 	movhi	r3,16
8112a4d0:	18ffffc4 	addi	r3,r3,-1
8112a4d4:	28c6703a 	and	r3,r5,r3
8112a4d8:	1c06b03a 	or	r3,r3,r16
8112a4dc:	1906b03a 	or	r3,r3,r4
8112a4e0:	dfc00417 	ldw	ra,16(sp)
8112a4e4:	dcc00317 	ldw	r19,12(sp)
8112a4e8:	dc800217 	ldw	r18,8(sp)
8112a4ec:	dc400117 	ldw	r17,4(sp)
8112a4f0:	dc000017 	ldw	r16,0(sp)
8112a4f4:	dec00504 	addi	sp,sp,20
8112a4f8:	f800283a 	ret
8112a4fc:	0101ffc4 	movi	r4,2047
8112a500:	813fd626 	beq	r16,r4,8112a45c <__reset+0xfb10a45c>
8112a504:	29402034 	orhi	r5,r5,128
8112a508:	01000e04 	movi	r4,56
8112a50c:	2080a316 	blt	r4,r2,8112a79c <__subdf3+0x3cc>
8112a510:	010007c4 	movi	r4,31
8112a514:	2080c616 	blt	r4,r2,8112a830 <__subdf3+0x460>
8112a518:	01000804 	movi	r4,32
8112a51c:	2089c83a 	sub	r4,r4,r2
8112a520:	2910983a 	sll	r8,r5,r4
8112a524:	308ed83a 	srl	r7,r6,r2
8112a528:	3108983a 	sll	r4,r6,r4
8112a52c:	2884d83a 	srl	r2,r5,r2
8112a530:	41ccb03a 	or	r6,r8,r7
8112a534:	2008c03a 	cmpne	r4,r4,zero
8112a538:	310cb03a 	or	r6,r6,r4
8112a53c:	898dc83a 	sub	r6,r17,r6
8112a540:	89a3803a 	cmpltu	r17,r17,r6
8112a544:	1887c83a 	sub	r3,r3,r2
8112a548:	1c47c83a 	sub	r3,r3,r17
8112a54c:	3023883a 	mov	r17,r6
8112a550:	1880202c 	andhi	r2,r3,128
8112a554:	10002326 	beq	r2,zero,8112a5e4 <__subdf3+0x214>
8112a558:	04c02034 	movhi	r19,128
8112a55c:	9cffffc4 	addi	r19,r19,-1
8112a560:	1ce6703a 	and	r19,r3,r19
8112a564:	98007a26 	beq	r19,zero,8112a750 <__subdf3+0x380>
8112a568:	9809883a 	mov	r4,r19
8112a56c:	11154c40 	call	811154c4 <__clzsi2>
8112a570:	113ffe04 	addi	r4,r2,-8
8112a574:	00c007c4 	movi	r3,31
8112a578:	19007b16 	blt	r3,r4,8112a768 <__subdf3+0x398>
8112a57c:	00800804 	movi	r2,32
8112a580:	1105c83a 	sub	r2,r2,r4
8112a584:	8884d83a 	srl	r2,r17,r2
8112a588:	9906983a 	sll	r3,r19,r4
8112a58c:	8922983a 	sll	r17,r17,r4
8112a590:	10c4b03a 	or	r2,r2,r3
8112a594:	24007816 	blt	r4,r16,8112a778 <__subdf3+0x3a8>
8112a598:	2421c83a 	sub	r16,r4,r16
8112a59c:	80c00044 	addi	r3,r16,1
8112a5a0:	010007c4 	movi	r4,31
8112a5a4:	20c09516 	blt	r4,r3,8112a7fc <__subdf3+0x42c>
8112a5a8:	01400804 	movi	r5,32
8112a5ac:	28cbc83a 	sub	r5,r5,r3
8112a5b0:	88c8d83a 	srl	r4,r17,r3
8112a5b4:	8962983a 	sll	r17,r17,r5
8112a5b8:	114a983a 	sll	r5,r2,r5
8112a5bc:	10c6d83a 	srl	r3,r2,r3
8112a5c0:	8804c03a 	cmpne	r2,r17,zero
8112a5c4:	290ab03a 	or	r5,r5,r4
8112a5c8:	28a2b03a 	or	r17,r5,r2
8112a5cc:	0021883a 	mov	r16,zero
8112a5d0:	003fa206 	br	8112a45c <__reset+0xfb10a45c>
8112a5d4:	2090b03a 	or	r8,r4,r2
8112a5d8:	40018e26 	beq	r8,zero,8112ac14 <__subdf3+0x844>
8112a5dc:	1007883a 	mov	r3,r2
8112a5e0:	2023883a 	mov	r17,r4
8112a5e4:	888001cc 	andi	r2,r17,7
8112a5e8:	103f9e1e 	bne	r2,zero,8112a464 <__reset+0xfb10a464>
8112a5ec:	1804977a 	slli	r2,r3,29
8112a5f0:	8822d0fa 	srli	r17,r17,3
8112a5f4:	1810d0fa 	srli	r8,r3,3
8112a5f8:	9100004c 	andi	r4,r18,1
8112a5fc:	1444b03a 	or	r2,r2,r17
8112a600:	00c1ffc4 	movi	r3,2047
8112a604:	80c02826 	beq	r16,r3,8112a6a8 <__subdf3+0x2d8>
8112a608:	01400434 	movhi	r5,16
8112a60c:	297fffc4 	addi	r5,r5,-1
8112a610:	80e0703a 	and	r16,r16,r3
8112a614:	414a703a 	and	r5,r8,r5
8112a618:	003fa806 	br	8112a4bc <__reset+0xfb10a4bc>
8112a61c:	0080630e 	bge	zero,r2,8112a7ac <__subdf3+0x3dc>
8112a620:	48003026 	beq	r9,zero,8112a6e4 <__subdf3+0x314>
8112a624:	0101ffc4 	movi	r4,2047
8112a628:	813f8c26 	beq	r16,r4,8112a45c <__reset+0xfb10a45c>
8112a62c:	29402034 	orhi	r5,r5,128
8112a630:	01000e04 	movi	r4,56
8112a634:	2080a90e 	bge	r4,r2,8112a8dc <__subdf3+0x50c>
8112a638:	298cb03a 	or	r6,r5,r6
8112a63c:	3012c03a 	cmpne	r9,r6,zero
8112a640:	0005883a 	mov	r2,zero
8112a644:	4c53883a 	add	r9,r9,r17
8112a648:	4c63803a 	cmpltu	r17,r9,r17
8112a64c:	10c7883a 	add	r3,r2,r3
8112a650:	88c7883a 	add	r3,r17,r3
8112a654:	4823883a 	mov	r17,r9
8112a658:	1880202c 	andhi	r2,r3,128
8112a65c:	1000d026 	beq	r2,zero,8112a9a0 <__subdf3+0x5d0>
8112a660:	84000044 	addi	r16,r16,1
8112a664:	0081ffc4 	movi	r2,2047
8112a668:	8080fe26 	beq	r16,r2,8112aa64 <__subdf3+0x694>
8112a66c:	00bfe034 	movhi	r2,65408
8112a670:	10bfffc4 	addi	r2,r2,-1
8112a674:	1886703a 	and	r3,r3,r2
8112a678:	880ad07a 	srli	r5,r17,1
8112a67c:	180497fa 	slli	r2,r3,31
8112a680:	8900004c 	andi	r4,r17,1
8112a684:	2922b03a 	or	r17,r5,r4
8112a688:	1806d07a 	srli	r3,r3,1
8112a68c:	1462b03a 	or	r17,r2,r17
8112a690:	3825883a 	mov	r18,r7
8112a694:	003f7106 	br	8112a45c <__reset+0xfb10a45c>
8112a698:	2984b03a 	or	r2,r5,r6
8112a69c:	103f6826 	beq	r2,zero,8112a440 <__reset+0xfb10a440>
8112a6a0:	39c03fcc 	andi	r7,r7,255
8112a6a4:	003f6706 	br	8112a444 <__reset+0xfb10a444>
8112a6a8:	4086b03a 	or	r3,r8,r2
8112a6ac:	18015226 	beq	r3,zero,8112abf8 <__subdf3+0x828>
8112a6b0:	00c00434 	movhi	r3,16
8112a6b4:	41400234 	orhi	r5,r8,8
8112a6b8:	18ffffc4 	addi	r3,r3,-1
8112a6bc:	28ca703a 	and	r5,r5,r3
8112a6c0:	003f7e06 	br	8112a4bc <__reset+0xfb10a4bc>
8112a6c4:	10bfffc4 	addi	r2,r2,-1
8112a6c8:	1000491e 	bne	r2,zero,8112a7f0 <__subdf3+0x420>
8112a6cc:	898fc83a 	sub	r7,r17,r6
8112a6d0:	89e3803a 	cmpltu	r17,r17,r7
8112a6d4:	1947c83a 	sub	r3,r3,r5
8112a6d8:	1c47c83a 	sub	r3,r3,r17
8112a6dc:	3823883a 	mov	r17,r7
8112a6e0:	003f9b06 	br	8112a550 <__reset+0xfb10a550>
8112a6e4:	2988b03a 	or	r4,r5,r6
8112a6e8:	203f5c26 	beq	r4,zero,8112a45c <__reset+0xfb10a45c>
8112a6ec:	10bfffc4 	addi	r2,r2,-1
8112a6f0:	1000931e 	bne	r2,zero,8112a940 <__subdf3+0x570>
8112a6f4:	898d883a 	add	r6,r17,r6
8112a6f8:	3463803a 	cmpltu	r17,r6,r17
8112a6fc:	1947883a 	add	r3,r3,r5
8112a700:	88c7883a 	add	r3,r17,r3
8112a704:	3023883a 	mov	r17,r6
8112a708:	003fd306 	br	8112a658 <__reset+0xfb10a658>
8112a70c:	1000541e 	bne	r2,zero,8112a860 <__subdf3+0x490>
8112a710:	80800044 	addi	r2,r16,1
8112a714:	1081ffcc 	andi	r2,r2,2047
8112a718:	01000044 	movi	r4,1
8112a71c:	2080a20e 	bge	r4,r2,8112a9a8 <__subdf3+0x5d8>
8112a720:	8989c83a 	sub	r4,r17,r6
8112a724:	8905803a 	cmpltu	r2,r17,r4
8112a728:	1967c83a 	sub	r19,r3,r5
8112a72c:	98a7c83a 	sub	r19,r19,r2
8112a730:	9880202c 	andhi	r2,r19,128
8112a734:	10006326 	beq	r2,zero,8112a8c4 <__subdf3+0x4f4>
8112a738:	3463c83a 	sub	r17,r6,r17
8112a73c:	28c7c83a 	sub	r3,r5,r3
8112a740:	344d803a 	cmpltu	r6,r6,r17
8112a744:	19a7c83a 	sub	r19,r3,r6
8112a748:	3825883a 	mov	r18,r7
8112a74c:	983f861e 	bne	r19,zero,8112a568 <__reset+0xfb10a568>
8112a750:	8809883a 	mov	r4,r17
8112a754:	11154c40 	call	811154c4 <__clzsi2>
8112a758:	10800804 	addi	r2,r2,32
8112a75c:	113ffe04 	addi	r4,r2,-8
8112a760:	00c007c4 	movi	r3,31
8112a764:	193f850e 	bge	r3,r4,8112a57c <__reset+0xfb10a57c>
8112a768:	10bff604 	addi	r2,r2,-40
8112a76c:	8884983a 	sll	r2,r17,r2
8112a770:	0023883a 	mov	r17,zero
8112a774:	243f880e 	bge	r4,r16,8112a598 <__reset+0xfb10a598>
8112a778:	00ffe034 	movhi	r3,65408
8112a77c:	18ffffc4 	addi	r3,r3,-1
8112a780:	8121c83a 	sub	r16,r16,r4
8112a784:	10c6703a 	and	r3,r2,r3
8112a788:	003f3406 	br	8112a45c <__reset+0xfb10a45c>
8112a78c:	9100004c 	andi	r4,r18,1
8112a790:	000b883a 	mov	r5,zero
8112a794:	0005883a 	mov	r2,zero
8112a798:	003f4806 	br	8112a4bc <__reset+0xfb10a4bc>
8112a79c:	298cb03a 	or	r6,r5,r6
8112a7a0:	300cc03a 	cmpne	r6,r6,zero
8112a7a4:	0005883a 	mov	r2,zero
8112a7a8:	003f6406 	br	8112a53c <__reset+0xfb10a53c>
8112a7ac:	10009a1e 	bne	r2,zero,8112aa18 <__subdf3+0x648>
8112a7b0:	82400044 	addi	r9,r16,1
8112a7b4:	4881ffcc 	andi	r2,r9,2047
8112a7b8:	02800044 	movi	r10,1
8112a7bc:	5080670e 	bge	r10,r2,8112a95c <__subdf3+0x58c>
8112a7c0:	0081ffc4 	movi	r2,2047
8112a7c4:	4880af26 	beq	r9,r2,8112aa84 <__subdf3+0x6b4>
8112a7c8:	898d883a 	add	r6,r17,r6
8112a7cc:	1945883a 	add	r2,r3,r5
8112a7d0:	3447803a 	cmpltu	r3,r6,r17
8112a7d4:	1887883a 	add	r3,r3,r2
8112a7d8:	182297fa 	slli	r17,r3,31
8112a7dc:	300cd07a 	srli	r6,r6,1
8112a7e0:	1806d07a 	srli	r3,r3,1
8112a7e4:	4821883a 	mov	r16,r9
8112a7e8:	89a2b03a 	or	r17,r17,r6
8112a7ec:	003f1b06 	br	8112a45c <__reset+0xfb10a45c>
8112a7f0:	0101ffc4 	movi	r4,2047
8112a7f4:	813f441e 	bne	r16,r4,8112a508 <__reset+0xfb10a508>
8112a7f8:	003f1806 	br	8112a45c <__reset+0xfb10a45c>
8112a7fc:	843ff844 	addi	r16,r16,-31
8112a800:	01400804 	movi	r5,32
8112a804:	1408d83a 	srl	r4,r2,r16
8112a808:	19405026 	beq	r3,r5,8112a94c <__subdf3+0x57c>
8112a80c:	01401004 	movi	r5,64
8112a810:	28c7c83a 	sub	r3,r5,r3
8112a814:	10c4983a 	sll	r2,r2,r3
8112a818:	88a2b03a 	or	r17,r17,r2
8112a81c:	8822c03a 	cmpne	r17,r17,zero
8112a820:	2462b03a 	or	r17,r4,r17
8112a824:	0007883a 	mov	r3,zero
8112a828:	0021883a 	mov	r16,zero
8112a82c:	003f6d06 	br	8112a5e4 <__reset+0xfb10a5e4>
8112a830:	11fff804 	addi	r7,r2,-32
8112a834:	01000804 	movi	r4,32
8112a838:	29ced83a 	srl	r7,r5,r7
8112a83c:	11004526 	beq	r2,r4,8112a954 <__subdf3+0x584>
8112a840:	01001004 	movi	r4,64
8112a844:	2089c83a 	sub	r4,r4,r2
8112a848:	2904983a 	sll	r2,r5,r4
8112a84c:	118cb03a 	or	r6,r2,r6
8112a850:	300cc03a 	cmpne	r6,r6,zero
8112a854:	398cb03a 	or	r6,r7,r6
8112a858:	0005883a 	mov	r2,zero
8112a85c:	003f3706 	br	8112a53c <__reset+0xfb10a53c>
8112a860:	80002a26 	beq	r16,zero,8112a90c <__subdf3+0x53c>
8112a864:	0101ffc4 	movi	r4,2047
8112a868:	49006626 	beq	r9,r4,8112aa04 <__subdf3+0x634>
8112a86c:	0085c83a 	sub	r2,zero,r2
8112a870:	18c02034 	orhi	r3,r3,128
8112a874:	01000e04 	movi	r4,56
8112a878:	20807e16 	blt	r4,r2,8112aa74 <__subdf3+0x6a4>
8112a87c:	010007c4 	movi	r4,31
8112a880:	2080e716 	blt	r4,r2,8112ac20 <__subdf3+0x850>
8112a884:	01000804 	movi	r4,32
8112a888:	2089c83a 	sub	r4,r4,r2
8112a88c:	1914983a 	sll	r10,r3,r4
8112a890:	8890d83a 	srl	r8,r17,r2
8112a894:	8908983a 	sll	r4,r17,r4
8112a898:	1884d83a 	srl	r2,r3,r2
8112a89c:	5222b03a 	or	r17,r10,r8
8112a8a0:	2006c03a 	cmpne	r3,r4,zero
8112a8a4:	88e2b03a 	or	r17,r17,r3
8112a8a8:	3463c83a 	sub	r17,r6,r17
8112a8ac:	2885c83a 	sub	r2,r5,r2
8112a8b0:	344d803a 	cmpltu	r6,r6,r17
8112a8b4:	1187c83a 	sub	r3,r2,r6
8112a8b8:	4821883a 	mov	r16,r9
8112a8bc:	3825883a 	mov	r18,r7
8112a8c0:	003f2306 	br	8112a550 <__reset+0xfb10a550>
8112a8c4:	24d0b03a 	or	r8,r4,r19
8112a8c8:	40001b1e 	bne	r8,zero,8112a938 <__subdf3+0x568>
8112a8cc:	0005883a 	mov	r2,zero
8112a8d0:	0009883a 	mov	r4,zero
8112a8d4:	0021883a 	mov	r16,zero
8112a8d8:	003f4906 	br	8112a600 <__reset+0xfb10a600>
8112a8dc:	010007c4 	movi	r4,31
8112a8e0:	20803a16 	blt	r4,r2,8112a9cc <__subdf3+0x5fc>
8112a8e4:	01000804 	movi	r4,32
8112a8e8:	2089c83a 	sub	r4,r4,r2
8112a8ec:	2912983a 	sll	r9,r5,r4
8112a8f0:	3090d83a 	srl	r8,r6,r2
8112a8f4:	3108983a 	sll	r4,r6,r4
8112a8f8:	2884d83a 	srl	r2,r5,r2
8112a8fc:	4a12b03a 	or	r9,r9,r8
8112a900:	2008c03a 	cmpne	r4,r4,zero
8112a904:	4912b03a 	or	r9,r9,r4
8112a908:	003f4e06 	br	8112a644 <__reset+0xfb10a644>
8112a90c:	1c48b03a 	or	r4,r3,r17
8112a910:	20003c26 	beq	r4,zero,8112aa04 <__subdf3+0x634>
8112a914:	0084303a 	nor	r2,zero,r2
8112a918:	1000381e 	bne	r2,zero,8112a9fc <__subdf3+0x62c>
8112a91c:	3463c83a 	sub	r17,r6,r17
8112a920:	28c5c83a 	sub	r2,r5,r3
8112a924:	344d803a 	cmpltu	r6,r6,r17
8112a928:	1187c83a 	sub	r3,r2,r6
8112a92c:	4821883a 	mov	r16,r9
8112a930:	3825883a 	mov	r18,r7
8112a934:	003f0606 	br	8112a550 <__reset+0xfb10a550>
8112a938:	2023883a 	mov	r17,r4
8112a93c:	003f0906 	br	8112a564 <__reset+0xfb10a564>
8112a940:	0101ffc4 	movi	r4,2047
8112a944:	813f3a1e 	bne	r16,r4,8112a630 <__reset+0xfb10a630>
8112a948:	003ec406 	br	8112a45c <__reset+0xfb10a45c>
8112a94c:	0005883a 	mov	r2,zero
8112a950:	003fb106 	br	8112a818 <__reset+0xfb10a818>
8112a954:	0005883a 	mov	r2,zero
8112a958:	003fbc06 	br	8112a84c <__reset+0xfb10a84c>
8112a95c:	1c44b03a 	or	r2,r3,r17
8112a960:	80008e1e 	bne	r16,zero,8112ab9c <__subdf3+0x7cc>
8112a964:	1000c826 	beq	r2,zero,8112ac88 <__subdf3+0x8b8>
8112a968:	2984b03a 	or	r2,r5,r6
8112a96c:	103ebb26 	beq	r2,zero,8112a45c <__reset+0xfb10a45c>
8112a970:	8989883a 	add	r4,r17,r6
8112a974:	1945883a 	add	r2,r3,r5
8112a978:	2447803a 	cmpltu	r3,r4,r17
8112a97c:	1887883a 	add	r3,r3,r2
8112a980:	1880202c 	andhi	r2,r3,128
8112a984:	2023883a 	mov	r17,r4
8112a988:	103f1626 	beq	r2,zero,8112a5e4 <__reset+0xfb10a5e4>
8112a98c:	00bfe034 	movhi	r2,65408
8112a990:	10bfffc4 	addi	r2,r2,-1
8112a994:	5021883a 	mov	r16,r10
8112a998:	1886703a 	and	r3,r3,r2
8112a99c:	003eaf06 	br	8112a45c <__reset+0xfb10a45c>
8112a9a0:	3825883a 	mov	r18,r7
8112a9a4:	003f0f06 	br	8112a5e4 <__reset+0xfb10a5e4>
8112a9a8:	1c44b03a 	or	r2,r3,r17
8112a9ac:	8000251e 	bne	r16,zero,8112aa44 <__subdf3+0x674>
8112a9b0:	1000661e 	bne	r2,zero,8112ab4c <__subdf3+0x77c>
8112a9b4:	2990b03a 	or	r8,r5,r6
8112a9b8:	40009626 	beq	r8,zero,8112ac14 <__subdf3+0x844>
8112a9bc:	2807883a 	mov	r3,r5
8112a9c0:	3023883a 	mov	r17,r6
8112a9c4:	3825883a 	mov	r18,r7
8112a9c8:	003ea406 	br	8112a45c <__reset+0xfb10a45c>
8112a9cc:	127ff804 	addi	r9,r2,-32
8112a9d0:	01000804 	movi	r4,32
8112a9d4:	2a52d83a 	srl	r9,r5,r9
8112a9d8:	11008c26 	beq	r2,r4,8112ac0c <__subdf3+0x83c>
8112a9dc:	01001004 	movi	r4,64
8112a9e0:	2085c83a 	sub	r2,r4,r2
8112a9e4:	2884983a 	sll	r2,r5,r2
8112a9e8:	118cb03a 	or	r6,r2,r6
8112a9ec:	300cc03a 	cmpne	r6,r6,zero
8112a9f0:	4992b03a 	or	r9,r9,r6
8112a9f4:	0005883a 	mov	r2,zero
8112a9f8:	003f1206 	br	8112a644 <__reset+0xfb10a644>
8112a9fc:	0101ffc4 	movi	r4,2047
8112aa00:	493f9c1e 	bne	r9,r4,8112a874 <__reset+0xfb10a874>
8112aa04:	2807883a 	mov	r3,r5
8112aa08:	3023883a 	mov	r17,r6
8112aa0c:	4821883a 	mov	r16,r9
8112aa10:	3825883a 	mov	r18,r7
8112aa14:	003e9106 	br	8112a45c <__reset+0xfb10a45c>
8112aa18:	80001f1e 	bne	r16,zero,8112aa98 <__subdf3+0x6c8>
8112aa1c:	1c48b03a 	or	r4,r3,r17
8112aa20:	20005a26 	beq	r4,zero,8112ab8c <__subdf3+0x7bc>
8112aa24:	0084303a 	nor	r2,zero,r2
8112aa28:	1000561e 	bne	r2,zero,8112ab84 <__subdf3+0x7b4>
8112aa2c:	89a3883a 	add	r17,r17,r6
8112aa30:	1945883a 	add	r2,r3,r5
8112aa34:	898d803a 	cmpltu	r6,r17,r6
8112aa38:	3087883a 	add	r3,r6,r2
8112aa3c:	4821883a 	mov	r16,r9
8112aa40:	003f0506 	br	8112a658 <__reset+0xfb10a658>
8112aa44:	10002b1e 	bne	r2,zero,8112aaf4 <__subdf3+0x724>
8112aa48:	2984b03a 	or	r2,r5,r6
8112aa4c:	10008026 	beq	r2,zero,8112ac50 <__subdf3+0x880>
8112aa50:	2807883a 	mov	r3,r5
8112aa54:	3023883a 	mov	r17,r6
8112aa58:	3825883a 	mov	r18,r7
8112aa5c:	0401ffc4 	movi	r16,2047
8112aa60:	003e7e06 	br	8112a45c <__reset+0xfb10a45c>
8112aa64:	3809883a 	mov	r4,r7
8112aa68:	0011883a 	mov	r8,zero
8112aa6c:	0005883a 	mov	r2,zero
8112aa70:	003ee306 	br	8112a600 <__reset+0xfb10a600>
8112aa74:	1c62b03a 	or	r17,r3,r17
8112aa78:	8822c03a 	cmpne	r17,r17,zero
8112aa7c:	0005883a 	mov	r2,zero
8112aa80:	003f8906 	br	8112a8a8 <__reset+0xfb10a8a8>
8112aa84:	3809883a 	mov	r4,r7
8112aa88:	4821883a 	mov	r16,r9
8112aa8c:	0011883a 	mov	r8,zero
8112aa90:	0005883a 	mov	r2,zero
8112aa94:	003eda06 	br	8112a600 <__reset+0xfb10a600>
8112aa98:	0101ffc4 	movi	r4,2047
8112aa9c:	49003b26 	beq	r9,r4,8112ab8c <__subdf3+0x7bc>
8112aaa0:	0085c83a 	sub	r2,zero,r2
8112aaa4:	18c02034 	orhi	r3,r3,128
8112aaa8:	01000e04 	movi	r4,56
8112aaac:	20806e16 	blt	r4,r2,8112ac68 <__subdf3+0x898>
8112aab0:	010007c4 	movi	r4,31
8112aab4:	20807716 	blt	r4,r2,8112ac94 <__subdf3+0x8c4>
8112aab8:	01000804 	movi	r4,32
8112aabc:	2089c83a 	sub	r4,r4,r2
8112aac0:	1914983a 	sll	r10,r3,r4
8112aac4:	8890d83a 	srl	r8,r17,r2
8112aac8:	8908983a 	sll	r4,r17,r4
8112aacc:	1884d83a 	srl	r2,r3,r2
8112aad0:	5222b03a 	or	r17,r10,r8
8112aad4:	2006c03a 	cmpne	r3,r4,zero
8112aad8:	88e2b03a 	or	r17,r17,r3
8112aadc:	89a3883a 	add	r17,r17,r6
8112aae0:	1145883a 	add	r2,r2,r5
8112aae4:	898d803a 	cmpltu	r6,r17,r6
8112aae8:	3087883a 	add	r3,r6,r2
8112aaec:	4821883a 	mov	r16,r9
8112aaf0:	003ed906 	br	8112a658 <__reset+0xfb10a658>
8112aaf4:	2984b03a 	or	r2,r5,r6
8112aaf8:	10004226 	beq	r2,zero,8112ac04 <__subdf3+0x834>
8112aafc:	1808d0fa 	srli	r4,r3,3
8112ab00:	8822d0fa 	srli	r17,r17,3
8112ab04:	1806977a 	slli	r3,r3,29
8112ab08:	2080022c 	andhi	r2,r4,8
8112ab0c:	1c62b03a 	or	r17,r3,r17
8112ab10:	10000826 	beq	r2,zero,8112ab34 <__subdf3+0x764>
8112ab14:	2812d0fa 	srli	r9,r5,3
8112ab18:	4880022c 	andhi	r2,r9,8
8112ab1c:	1000051e 	bne	r2,zero,8112ab34 <__subdf3+0x764>
8112ab20:	300cd0fa 	srli	r6,r6,3
8112ab24:	2804977a 	slli	r2,r5,29
8112ab28:	4809883a 	mov	r4,r9
8112ab2c:	3825883a 	mov	r18,r7
8112ab30:	11a2b03a 	or	r17,r2,r6
8112ab34:	8806d77a 	srli	r3,r17,29
8112ab38:	200890fa 	slli	r4,r4,3
8112ab3c:	882290fa 	slli	r17,r17,3
8112ab40:	0401ffc4 	movi	r16,2047
8112ab44:	1906b03a 	or	r3,r3,r4
8112ab48:	003e4406 	br	8112a45c <__reset+0xfb10a45c>
8112ab4c:	2984b03a 	or	r2,r5,r6
8112ab50:	103e4226 	beq	r2,zero,8112a45c <__reset+0xfb10a45c>
8112ab54:	8989c83a 	sub	r4,r17,r6
8112ab58:	8911803a 	cmpltu	r8,r17,r4
8112ab5c:	1945c83a 	sub	r2,r3,r5
8112ab60:	1205c83a 	sub	r2,r2,r8
8112ab64:	1200202c 	andhi	r8,r2,128
8112ab68:	403e9a26 	beq	r8,zero,8112a5d4 <__reset+0xfb10a5d4>
8112ab6c:	3463c83a 	sub	r17,r6,r17
8112ab70:	28c5c83a 	sub	r2,r5,r3
8112ab74:	344d803a 	cmpltu	r6,r6,r17
8112ab78:	1187c83a 	sub	r3,r2,r6
8112ab7c:	3825883a 	mov	r18,r7
8112ab80:	003e3606 	br	8112a45c <__reset+0xfb10a45c>
8112ab84:	0101ffc4 	movi	r4,2047
8112ab88:	493fc71e 	bne	r9,r4,8112aaa8 <__reset+0xfb10aaa8>
8112ab8c:	2807883a 	mov	r3,r5
8112ab90:	3023883a 	mov	r17,r6
8112ab94:	4821883a 	mov	r16,r9
8112ab98:	003e3006 	br	8112a45c <__reset+0xfb10a45c>
8112ab9c:	10003626 	beq	r2,zero,8112ac78 <__subdf3+0x8a8>
8112aba0:	2984b03a 	or	r2,r5,r6
8112aba4:	10001726 	beq	r2,zero,8112ac04 <__subdf3+0x834>
8112aba8:	1808d0fa 	srli	r4,r3,3
8112abac:	8822d0fa 	srli	r17,r17,3
8112abb0:	1806977a 	slli	r3,r3,29
8112abb4:	2080022c 	andhi	r2,r4,8
8112abb8:	1c62b03a 	or	r17,r3,r17
8112abbc:	10000726 	beq	r2,zero,8112abdc <__subdf3+0x80c>
8112abc0:	2812d0fa 	srli	r9,r5,3
8112abc4:	4880022c 	andhi	r2,r9,8
8112abc8:	1000041e 	bne	r2,zero,8112abdc <__subdf3+0x80c>
8112abcc:	300cd0fa 	srli	r6,r6,3
8112abd0:	2804977a 	slli	r2,r5,29
8112abd4:	4809883a 	mov	r4,r9
8112abd8:	11a2b03a 	or	r17,r2,r6
8112abdc:	8806d77a 	srli	r3,r17,29
8112abe0:	200890fa 	slli	r4,r4,3
8112abe4:	882290fa 	slli	r17,r17,3
8112abe8:	3825883a 	mov	r18,r7
8112abec:	1906b03a 	or	r3,r3,r4
8112abf0:	0401ffc4 	movi	r16,2047
8112abf4:	003e1906 	br	8112a45c <__reset+0xfb10a45c>
8112abf8:	000b883a 	mov	r5,zero
8112abfc:	0005883a 	mov	r2,zero
8112ac00:	003e2e06 	br	8112a4bc <__reset+0xfb10a4bc>
8112ac04:	0401ffc4 	movi	r16,2047
8112ac08:	003e1406 	br	8112a45c <__reset+0xfb10a45c>
8112ac0c:	0005883a 	mov	r2,zero
8112ac10:	003f7506 	br	8112a9e8 <__reset+0xfb10a9e8>
8112ac14:	0005883a 	mov	r2,zero
8112ac18:	0009883a 	mov	r4,zero
8112ac1c:	003e7806 	br	8112a600 <__reset+0xfb10a600>
8112ac20:	123ff804 	addi	r8,r2,-32
8112ac24:	01000804 	movi	r4,32
8112ac28:	1a10d83a 	srl	r8,r3,r8
8112ac2c:	11002526 	beq	r2,r4,8112acc4 <__subdf3+0x8f4>
8112ac30:	01001004 	movi	r4,64
8112ac34:	2085c83a 	sub	r2,r4,r2
8112ac38:	1884983a 	sll	r2,r3,r2
8112ac3c:	1444b03a 	or	r2,r2,r17
8112ac40:	1004c03a 	cmpne	r2,r2,zero
8112ac44:	40a2b03a 	or	r17,r8,r2
8112ac48:	0005883a 	mov	r2,zero
8112ac4c:	003f1606 	br	8112a8a8 <__reset+0xfb10a8a8>
8112ac50:	02000434 	movhi	r8,16
8112ac54:	0009883a 	mov	r4,zero
8112ac58:	423fffc4 	addi	r8,r8,-1
8112ac5c:	00bfffc4 	movi	r2,-1
8112ac60:	0401ffc4 	movi	r16,2047
8112ac64:	003e6606 	br	8112a600 <__reset+0xfb10a600>
8112ac68:	1c62b03a 	or	r17,r3,r17
8112ac6c:	8822c03a 	cmpne	r17,r17,zero
8112ac70:	0005883a 	mov	r2,zero
8112ac74:	003f9906 	br	8112aadc <__reset+0xfb10aadc>
8112ac78:	2807883a 	mov	r3,r5
8112ac7c:	3023883a 	mov	r17,r6
8112ac80:	0401ffc4 	movi	r16,2047
8112ac84:	003df506 	br	8112a45c <__reset+0xfb10a45c>
8112ac88:	2807883a 	mov	r3,r5
8112ac8c:	3023883a 	mov	r17,r6
8112ac90:	003df206 	br	8112a45c <__reset+0xfb10a45c>
8112ac94:	123ff804 	addi	r8,r2,-32
8112ac98:	01000804 	movi	r4,32
8112ac9c:	1a10d83a 	srl	r8,r3,r8
8112aca0:	11000a26 	beq	r2,r4,8112accc <__subdf3+0x8fc>
8112aca4:	01001004 	movi	r4,64
8112aca8:	2085c83a 	sub	r2,r4,r2
8112acac:	1884983a 	sll	r2,r3,r2
8112acb0:	1444b03a 	or	r2,r2,r17
8112acb4:	1004c03a 	cmpne	r2,r2,zero
8112acb8:	40a2b03a 	or	r17,r8,r2
8112acbc:	0005883a 	mov	r2,zero
8112acc0:	003f8606 	br	8112aadc <__reset+0xfb10aadc>
8112acc4:	0005883a 	mov	r2,zero
8112acc8:	003fdc06 	br	8112ac3c <__reset+0xfb10ac3c>
8112accc:	0005883a 	mov	r2,zero
8112acd0:	003ff706 	br	8112acb0 <__reset+0xfb10acb0>

8112acd4 <__fixdfsi>:
8112acd4:	280cd53a 	srli	r6,r5,20
8112acd8:	00c00434 	movhi	r3,16
8112acdc:	18ffffc4 	addi	r3,r3,-1
8112ace0:	3181ffcc 	andi	r6,r6,2047
8112ace4:	01c0ff84 	movi	r7,1022
8112ace8:	28c6703a 	and	r3,r5,r3
8112acec:	280ad7fa 	srli	r5,r5,31
8112acf0:	3980120e 	bge	r7,r6,8112ad3c <__fixdfsi+0x68>
8112acf4:	00810744 	movi	r2,1053
8112acf8:	11800c16 	blt	r2,r6,8112ad2c <__fixdfsi+0x58>
8112acfc:	00810cc4 	movi	r2,1075
8112ad00:	1185c83a 	sub	r2,r2,r6
8112ad04:	01c007c4 	movi	r7,31
8112ad08:	18c00434 	orhi	r3,r3,16
8112ad0c:	38800d16 	blt	r7,r2,8112ad44 <__fixdfsi+0x70>
8112ad10:	31befb44 	addi	r6,r6,-1043
8112ad14:	2084d83a 	srl	r2,r4,r2
8112ad18:	1986983a 	sll	r3,r3,r6
8112ad1c:	1884b03a 	or	r2,r3,r2
8112ad20:	28000726 	beq	r5,zero,8112ad40 <__fixdfsi+0x6c>
8112ad24:	0085c83a 	sub	r2,zero,r2
8112ad28:	f800283a 	ret
8112ad2c:	00a00034 	movhi	r2,32768
8112ad30:	10bfffc4 	addi	r2,r2,-1
8112ad34:	2885883a 	add	r2,r5,r2
8112ad38:	f800283a 	ret
8112ad3c:	0005883a 	mov	r2,zero
8112ad40:	f800283a 	ret
8112ad44:	008104c4 	movi	r2,1043
8112ad48:	1185c83a 	sub	r2,r2,r6
8112ad4c:	1884d83a 	srl	r2,r3,r2
8112ad50:	003ff306 	br	8112ad20 <__reset+0xfb10ad20>

8112ad54 <__floatsidf>:
8112ad54:	defffd04 	addi	sp,sp,-12
8112ad58:	de00012e 	bgeu	sp,et,8112ad60 <__floatsidf+0xc>
8112ad5c:	003b68fa 	trap	3
8112ad60:	dfc00215 	stw	ra,8(sp)
8112ad64:	dc400115 	stw	r17,4(sp)
8112ad68:	dc000015 	stw	r16,0(sp)
8112ad6c:	20002b26 	beq	r4,zero,8112ae1c <__floatsidf+0xc8>
8112ad70:	2023883a 	mov	r17,r4
8112ad74:	2020d7fa 	srli	r16,r4,31
8112ad78:	20002d16 	blt	r4,zero,8112ae30 <__floatsidf+0xdc>
8112ad7c:	8809883a 	mov	r4,r17
8112ad80:	11154c40 	call	811154c4 <__clzsi2>
8112ad84:	01410784 	movi	r5,1054
8112ad88:	288bc83a 	sub	r5,r5,r2
8112ad8c:	01010cc4 	movi	r4,1075
8112ad90:	2149c83a 	sub	r4,r4,r5
8112ad94:	00c007c4 	movi	r3,31
8112ad98:	1900160e 	bge	r3,r4,8112adf4 <__floatsidf+0xa0>
8112ad9c:	00c104c4 	movi	r3,1043
8112ada0:	1947c83a 	sub	r3,r3,r5
8112ada4:	88c6983a 	sll	r3,r17,r3
8112ada8:	00800434 	movhi	r2,16
8112adac:	10bfffc4 	addi	r2,r2,-1
8112adb0:	1886703a 	and	r3,r3,r2
8112adb4:	2941ffcc 	andi	r5,r5,2047
8112adb8:	800d883a 	mov	r6,r16
8112adbc:	0005883a 	mov	r2,zero
8112adc0:	280a953a 	slli	r5,r5,20
8112adc4:	31803fcc 	andi	r6,r6,255
8112adc8:	01000434 	movhi	r4,16
8112adcc:	300c97fa 	slli	r6,r6,31
8112add0:	213fffc4 	addi	r4,r4,-1
8112add4:	1906703a 	and	r3,r3,r4
8112add8:	1946b03a 	or	r3,r3,r5
8112addc:	1986b03a 	or	r3,r3,r6
8112ade0:	dfc00217 	ldw	ra,8(sp)
8112ade4:	dc400117 	ldw	r17,4(sp)
8112ade8:	dc000017 	ldw	r16,0(sp)
8112adec:	dec00304 	addi	sp,sp,12
8112adf0:	f800283a 	ret
8112adf4:	00c002c4 	movi	r3,11
8112adf8:	1887c83a 	sub	r3,r3,r2
8112adfc:	88c6d83a 	srl	r3,r17,r3
8112ae00:	8904983a 	sll	r2,r17,r4
8112ae04:	01000434 	movhi	r4,16
8112ae08:	213fffc4 	addi	r4,r4,-1
8112ae0c:	2941ffcc 	andi	r5,r5,2047
8112ae10:	1906703a 	and	r3,r3,r4
8112ae14:	800d883a 	mov	r6,r16
8112ae18:	003fe906 	br	8112adc0 <__reset+0xfb10adc0>
8112ae1c:	000d883a 	mov	r6,zero
8112ae20:	000b883a 	mov	r5,zero
8112ae24:	0007883a 	mov	r3,zero
8112ae28:	0005883a 	mov	r2,zero
8112ae2c:	003fe406 	br	8112adc0 <__reset+0xfb10adc0>
8112ae30:	0123c83a 	sub	r17,zero,r4
8112ae34:	003fd106 	br	8112ad7c <__reset+0xfb10ad7c>

8112ae38 <__floatunsidf>:
8112ae38:	defffe04 	addi	sp,sp,-8
8112ae3c:	de00012e 	bgeu	sp,et,8112ae44 <__floatunsidf+0xc>
8112ae40:	003b68fa 	trap	3
8112ae44:	dc000015 	stw	r16,0(sp)
8112ae48:	dfc00115 	stw	ra,4(sp)
8112ae4c:	2021883a 	mov	r16,r4
8112ae50:	20002226 	beq	r4,zero,8112aedc <__floatunsidf+0xa4>
8112ae54:	11154c40 	call	811154c4 <__clzsi2>
8112ae58:	01010784 	movi	r4,1054
8112ae5c:	2089c83a 	sub	r4,r4,r2
8112ae60:	01810cc4 	movi	r6,1075
8112ae64:	310dc83a 	sub	r6,r6,r4
8112ae68:	00c007c4 	movi	r3,31
8112ae6c:	1980120e 	bge	r3,r6,8112aeb8 <__floatunsidf+0x80>
8112ae70:	00c104c4 	movi	r3,1043
8112ae74:	1907c83a 	sub	r3,r3,r4
8112ae78:	80ca983a 	sll	r5,r16,r3
8112ae7c:	00800434 	movhi	r2,16
8112ae80:	10bfffc4 	addi	r2,r2,-1
8112ae84:	2101ffcc 	andi	r4,r4,2047
8112ae88:	0021883a 	mov	r16,zero
8112ae8c:	288a703a 	and	r5,r5,r2
8112ae90:	2008953a 	slli	r4,r4,20
8112ae94:	00c00434 	movhi	r3,16
8112ae98:	18ffffc4 	addi	r3,r3,-1
8112ae9c:	28c6703a 	and	r3,r5,r3
8112aea0:	8005883a 	mov	r2,r16
8112aea4:	1906b03a 	or	r3,r3,r4
8112aea8:	dfc00117 	ldw	ra,4(sp)
8112aeac:	dc000017 	ldw	r16,0(sp)
8112aeb0:	dec00204 	addi	sp,sp,8
8112aeb4:	f800283a 	ret
8112aeb8:	00c002c4 	movi	r3,11
8112aebc:	188bc83a 	sub	r5,r3,r2
8112aec0:	814ad83a 	srl	r5,r16,r5
8112aec4:	00c00434 	movhi	r3,16
8112aec8:	18ffffc4 	addi	r3,r3,-1
8112aecc:	81a0983a 	sll	r16,r16,r6
8112aed0:	2101ffcc 	andi	r4,r4,2047
8112aed4:	28ca703a 	and	r5,r5,r3
8112aed8:	003fed06 	br	8112ae90 <__reset+0xfb10ae90>
8112aedc:	0009883a 	mov	r4,zero
8112aee0:	000b883a 	mov	r5,zero
8112aee4:	003fea06 	br	8112ae90 <__reset+0xfb10ae90>

8112aee8 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
8112aee8:	defffb04 	addi	sp,sp,-20
8112aeec:	de00012e 	bgeu	sp,et,8112aef4 <alt_busy_sleep+0xc>
8112aef0:	003b68fa 	trap	3
8112aef4:	df000415 	stw	fp,16(sp)
8112aef8:	df000404 	addi	fp,sp,16
8112aefc:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
8112af00:	008000c4 	movi	r2,3
8112af04:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
8112af08:	e0fffd17 	ldw	r3,-12(fp)
8112af0c:	008003f4 	movhi	r2,15
8112af10:	10909004 	addi	r2,r2,16960
8112af14:	1887383a 	mul	r3,r3,r2
8112af18:	00817db4 	movhi	r2,1526
8112af1c:	10b84004 	addi	r2,r2,-7936
8112af20:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
8112af24:	00a00034 	movhi	r2,32768
8112af28:	10bfffc4 	addi	r2,r2,-1
8112af2c:	10c5203a 	divu	r2,r2,r3
8112af30:	e0ffff17 	ldw	r3,-4(fp)
8112af34:	1885203a 	divu	r2,r3,r2
8112af38:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
8112af3c:	e0bffe17 	ldw	r2,-8(fp)
8112af40:	10002526 	beq	r2,zero,8112afd8 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
8112af44:	e03ffc15 	stw	zero,-16(fp)
8112af48:	00001406 	br	8112af9c <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
8112af4c:	00a00034 	movhi	r2,32768
8112af50:	10bfffc4 	addi	r2,r2,-1
8112af54:	10bfffc4 	addi	r2,r2,-1
8112af58:	103ffe1e 	bne	r2,zero,8112af54 <__reset+0xfb10af54>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
8112af5c:	e0fffd17 	ldw	r3,-12(fp)
8112af60:	008003f4 	movhi	r2,15
8112af64:	10909004 	addi	r2,r2,16960
8112af68:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
8112af6c:	00817db4 	movhi	r2,1526
8112af70:	10b84004 	addi	r2,r2,-7936
8112af74:	10c7203a 	divu	r3,r2,r3
8112af78:	00a00034 	movhi	r2,32768
8112af7c:	10bfffc4 	addi	r2,r2,-1
8112af80:	10c5203a 	divu	r2,r2,r3
8112af84:	e0ffff17 	ldw	r3,-4(fp)
8112af88:	1885c83a 	sub	r2,r3,r2
8112af8c:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
8112af90:	e0bffc17 	ldw	r2,-16(fp)
8112af94:	10800044 	addi	r2,r2,1
8112af98:	e0bffc15 	stw	r2,-16(fp)
8112af9c:	e0fffc17 	ldw	r3,-16(fp)
8112afa0:	e0bffe17 	ldw	r2,-8(fp)
8112afa4:	18bfe916 	blt	r3,r2,8112af4c <__reset+0xfb10af4c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8112afa8:	e0fffd17 	ldw	r3,-12(fp)
8112afac:	008003f4 	movhi	r2,15
8112afb0:	10909004 	addi	r2,r2,16960
8112afb4:	1887383a 	mul	r3,r3,r2
8112afb8:	00817db4 	movhi	r2,1526
8112afbc:	10b84004 	addi	r2,r2,-7936
8112afc0:	10c7203a 	divu	r3,r2,r3
8112afc4:	e0bfff17 	ldw	r2,-4(fp)
8112afc8:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
8112afcc:	10bfffc4 	addi	r2,r2,-1
8112afd0:	103ffe1e 	bne	r2,zero,8112afcc <__reset+0xfb10afcc>
8112afd4:	00000b06 	br	8112b004 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8112afd8:	e0fffd17 	ldw	r3,-12(fp)
8112afdc:	008003f4 	movhi	r2,15
8112afe0:	10909004 	addi	r2,r2,16960
8112afe4:	1887383a 	mul	r3,r3,r2
8112afe8:	00817db4 	movhi	r2,1526
8112afec:	10b84004 	addi	r2,r2,-7936
8112aff0:	10c7203a 	divu	r3,r2,r3
8112aff4:	e0bfff17 	ldw	r2,-4(fp)
8112aff8:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
8112affc:	10bfffc4 	addi	r2,r2,-1
8112b000:	00bffe16 	blt	zero,r2,8112affc <__reset+0xfb10affc>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
8112b004:	0005883a 	mov	r2,zero
}
8112b008:	e037883a 	mov	sp,fp
8112b00c:	df000017 	ldw	fp,0(sp)
8112b010:	dec00104 	addi	sp,sp,4
8112b014:	f800283a 	ret

8112b018 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112b018:	defffe04 	addi	sp,sp,-8
8112b01c:	de00012e 	bgeu	sp,et,8112b024 <alt_get_errno+0xc>
8112b020:	003b68fa 	trap	3
8112b024:	dfc00115 	stw	ra,4(sp)
8112b028:	df000015 	stw	fp,0(sp)
8112b02c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112b030:	d0a01017 	ldw	r2,-32704(gp)
8112b034:	10000326 	beq	r2,zero,8112b044 <alt_get_errno+0x2c>
8112b038:	d0a01017 	ldw	r2,-32704(gp)
8112b03c:	103ee83a 	callr	r2
8112b040:	00000106 	br	8112b048 <alt_get_errno+0x30>
8112b044:	d0a06804 	addi	r2,gp,-32352
}
8112b048:	e037883a 	mov	sp,fp
8112b04c:	dfc00117 	ldw	ra,4(sp)
8112b050:	df000017 	ldw	fp,0(sp)
8112b054:	dec00204 	addi	sp,sp,8
8112b058:	f800283a 	ret

8112b05c <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
8112b05c:	defffb04 	addi	sp,sp,-20
8112b060:	de00012e 	bgeu	sp,et,8112b068 <close+0xc>
8112b064:	003b68fa 	trap	3
8112b068:	dfc00415 	stw	ra,16(sp)
8112b06c:	df000315 	stw	fp,12(sp)
8112b070:	df000304 	addi	fp,sp,12
8112b074:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
8112b078:	e0bfff17 	ldw	r2,-4(fp)
8112b07c:	10000616 	blt	r2,zero,8112b098 <close+0x3c>
8112b080:	e0bfff17 	ldw	r2,-4(fp)
8112b084:	10c00324 	muli	r3,r2,12
8112b088:	00a04534 	movhi	r2,33044
8112b08c:	1095d504 	addi	r2,r2,22356
8112b090:	1885883a 	add	r2,r3,r2
8112b094:	00000106 	br	8112b09c <close+0x40>
8112b098:	0005883a 	mov	r2,zero
8112b09c:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
8112b0a0:	e0bffd17 	ldw	r2,-12(fp)
8112b0a4:	10001926 	beq	r2,zero,8112b10c <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
8112b0a8:	e0bffd17 	ldw	r2,-12(fp)
8112b0ac:	10800017 	ldw	r2,0(r2)
8112b0b0:	10800417 	ldw	r2,16(r2)
8112b0b4:	10000626 	beq	r2,zero,8112b0d0 <close+0x74>
8112b0b8:	e0bffd17 	ldw	r2,-12(fp)
8112b0bc:	10800017 	ldw	r2,0(r2)
8112b0c0:	10800417 	ldw	r2,16(r2)
8112b0c4:	e13ffd17 	ldw	r4,-12(fp)
8112b0c8:	103ee83a 	callr	r2
8112b0cc:	00000106 	br	8112b0d4 <close+0x78>
8112b0d0:	0005883a 	mov	r2,zero
8112b0d4:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
8112b0d8:	e13fff17 	ldw	r4,-4(fp)
8112b0dc:	112c6400 	call	8112c640 <alt_release_fd>
    if (rval < 0)
8112b0e0:	e0bffe17 	ldw	r2,-8(fp)
8112b0e4:	1000070e 	bge	r2,zero,8112b104 <close+0xa8>
    {
      ALT_ERRNO = -rval;
8112b0e8:	112b0180 	call	8112b018 <alt_get_errno>
8112b0ec:	1007883a 	mov	r3,r2
8112b0f0:	e0bffe17 	ldw	r2,-8(fp)
8112b0f4:	0085c83a 	sub	r2,zero,r2
8112b0f8:	18800015 	stw	r2,0(r3)
      return -1;
8112b0fc:	00bfffc4 	movi	r2,-1
8112b100:	00000706 	br	8112b120 <close+0xc4>
    }
    return 0;
8112b104:	0005883a 	mov	r2,zero
8112b108:	00000506 	br	8112b120 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
8112b10c:	112b0180 	call	8112b018 <alt_get_errno>
8112b110:	1007883a 	mov	r3,r2
8112b114:	00801444 	movi	r2,81
8112b118:	18800015 	stw	r2,0(r3)
    return -1;
8112b11c:	00bfffc4 	movi	r2,-1
  }
}
8112b120:	e037883a 	mov	sp,fp
8112b124:	dfc00117 	ldw	ra,4(sp)
8112b128:	df000017 	ldw	fp,0(sp)
8112b12c:	dec00204 	addi	sp,sp,8
8112b130:	f800283a 	ret

8112b134 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
8112b134:	deffff04 	addi	sp,sp,-4
8112b138:	de00012e 	bgeu	sp,et,8112b140 <alt_dcache_flush_all+0xc>
8112b13c:	003b68fa 	trap	3
8112b140:	df000015 	stw	fp,0(sp)
8112b144:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
8112b148:	0001883a 	nop
8112b14c:	e037883a 	mov	sp,fp
8112b150:	df000017 	ldw	fp,0(sp)
8112b154:	dec00104 	addi	sp,sp,4
8112b158:	f800283a 	ret

8112b15c <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
8112b15c:	defffc04 	addi	sp,sp,-16
8112b160:	de00012e 	bgeu	sp,et,8112b168 <alt_dev_null_write+0xc>
8112b164:	003b68fa 	trap	3
8112b168:	df000315 	stw	fp,12(sp)
8112b16c:	df000304 	addi	fp,sp,12
8112b170:	e13ffd15 	stw	r4,-12(fp)
8112b174:	e17ffe15 	stw	r5,-8(fp)
8112b178:	e1bfff15 	stw	r6,-4(fp)
  return len;
8112b17c:	e0bfff17 	ldw	r2,-4(fp)
}
8112b180:	e037883a 	mov	sp,fp
8112b184:	df000017 	ldw	fp,0(sp)
8112b188:	dec00104 	addi	sp,sp,4
8112b18c:	f800283a 	ret

8112b190 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112b190:	defffe04 	addi	sp,sp,-8
8112b194:	de00012e 	bgeu	sp,et,8112b19c <alt_get_errno+0xc>
8112b198:	003b68fa 	trap	3
8112b19c:	dfc00115 	stw	ra,4(sp)
8112b1a0:	df000015 	stw	fp,0(sp)
8112b1a4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112b1a8:	d0a01017 	ldw	r2,-32704(gp)
8112b1ac:	10000326 	beq	r2,zero,8112b1bc <alt_get_errno+0x2c>
8112b1b0:	d0a01017 	ldw	r2,-32704(gp)
8112b1b4:	103ee83a 	callr	r2
8112b1b8:	00000106 	br	8112b1c0 <alt_get_errno+0x30>
8112b1bc:	d0a06804 	addi	r2,gp,-32352
}
8112b1c0:	e037883a 	mov	sp,fp
8112b1c4:	dfc00117 	ldw	ra,4(sp)
8112b1c8:	df000017 	ldw	fp,0(sp)
8112b1cc:	dec00204 	addi	sp,sp,8
8112b1d0:	f800283a 	ret

8112b1d4 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
8112b1d4:	defffb04 	addi	sp,sp,-20
8112b1d8:	de00012e 	bgeu	sp,et,8112b1e0 <fstat+0xc>
8112b1dc:	003b68fa 	trap	3
8112b1e0:	dfc00415 	stw	ra,16(sp)
8112b1e4:	df000315 	stw	fp,12(sp)
8112b1e8:	df000304 	addi	fp,sp,12
8112b1ec:	e13ffe15 	stw	r4,-8(fp)
8112b1f0:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112b1f4:	e0bffe17 	ldw	r2,-8(fp)
8112b1f8:	10000616 	blt	r2,zero,8112b214 <fstat+0x40>
8112b1fc:	e0bffe17 	ldw	r2,-8(fp)
8112b200:	10c00324 	muli	r3,r2,12
8112b204:	00a04534 	movhi	r2,33044
8112b208:	1095d504 	addi	r2,r2,22356
8112b20c:	1885883a 	add	r2,r3,r2
8112b210:	00000106 	br	8112b218 <fstat+0x44>
8112b214:	0005883a 	mov	r2,zero
8112b218:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
8112b21c:	e0bffd17 	ldw	r2,-12(fp)
8112b220:	10001026 	beq	r2,zero,8112b264 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
8112b224:	e0bffd17 	ldw	r2,-12(fp)
8112b228:	10800017 	ldw	r2,0(r2)
8112b22c:	10800817 	ldw	r2,32(r2)
8112b230:	10000726 	beq	r2,zero,8112b250 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
8112b234:	e0bffd17 	ldw	r2,-12(fp)
8112b238:	10800017 	ldw	r2,0(r2)
8112b23c:	10800817 	ldw	r2,32(r2)
8112b240:	e17fff17 	ldw	r5,-4(fp)
8112b244:	e13ffd17 	ldw	r4,-12(fp)
8112b248:	103ee83a 	callr	r2
8112b24c:	00000a06 	br	8112b278 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
8112b250:	e0bfff17 	ldw	r2,-4(fp)
8112b254:	00c80004 	movi	r3,8192
8112b258:	10c00115 	stw	r3,4(r2)
      return 0;
8112b25c:	0005883a 	mov	r2,zero
8112b260:	00000506 	br	8112b278 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8112b264:	112b1900 	call	8112b190 <alt_get_errno>
8112b268:	1007883a 	mov	r3,r2
8112b26c:	00801444 	movi	r2,81
8112b270:	18800015 	stw	r2,0(r3)
    return -1;
8112b274:	00bfffc4 	movi	r2,-1
  }
}
8112b278:	e037883a 	mov	sp,fp
8112b27c:	dfc00117 	ldw	ra,4(sp)
8112b280:	df000017 	ldw	fp,0(sp)
8112b284:	dec00204 	addi	sp,sp,8
8112b288:	f800283a 	ret

8112b28c <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
8112b28c:	defff004 	addi	sp,sp,-64
8112b290:	de00012e 	bgeu	sp,et,8112b298 <alt_irq_register+0xc>
8112b294:	003b68fa 	trap	3
8112b298:	df000f15 	stw	fp,60(sp)
8112b29c:	df000f04 	addi	fp,sp,60
8112b2a0:	e13ffd15 	stw	r4,-12(fp)
8112b2a4:	e17ffe15 	stw	r5,-8(fp)
8112b2a8:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
8112b2ac:	00bffa84 	movi	r2,-22
8112b2b0:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8112b2b4:	e0bffd17 	ldw	r2,-12(fp)
8112b2b8:	10800828 	cmpgeui	r2,r2,32
8112b2bc:	1000501e 	bne	r2,zero,8112b400 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112b2c0:	0005303a 	rdctl	r2,status
8112b2c4:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112b2c8:	e0fff617 	ldw	r3,-40(fp)
8112b2cc:	00bfff84 	movi	r2,-2
8112b2d0:	1884703a 	and	r2,r3,r2
8112b2d4:	1001703a 	wrctl	status,r2
  
  return context;
8112b2d8:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
8112b2dc:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
8112b2e0:	00a045b4 	movhi	r2,33046
8112b2e4:	10813504 	addi	r2,r2,1236
8112b2e8:	e0fffd17 	ldw	r3,-12(fp)
8112b2ec:	180690fa 	slli	r3,r3,3
8112b2f0:	10c5883a 	add	r2,r2,r3
8112b2f4:	e0ffff17 	ldw	r3,-4(fp)
8112b2f8:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
8112b2fc:	00a045b4 	movhi	r2,33046
8112b300:	10813504 	addi	r2,r2,1236
8112b304:	e0fffd17 	ldw	r3,-12(fp)
8112b308:	180690fa 	slli	r3,r3,3
8112b30c:	10c5883a 	add	r2,r2,r3
8112b310:	10800104 	addi	r2,r2,4
8112b314:	e0fffe17 	ldw	r3,-8(fp)
8112b318:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
8112b31c:	e0bfff17 	ldw	r2,-4(fp)
8112b320:	10001926 	beq	r2,zero,8112b388 <alt_irq_register+0xfc>
8112b324:	e0bffd17 	ldw	r2,-12(fp)
8112b328:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112b32c:	0005303a 	rdctl	r2,status
8112b330:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112b334:	e0fff717 	ldw	r3,-36(fp)
8112b338:	00bfff84 	movi	r2,-2
8112b33c:	1884703a 	and	r2,r3,r2
8112b340:	1001703a 	wrctl	status,r2
  
  return context;
8112b344:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8112b348:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
8112b34c:	00c00044 	movi	r3,1
8112b350:	e0bff217 	ldw	r2,-56(fp)
8112b354:	1884983a 	sll	r2,r3,r2
8112b358:	1007883a 	mov	r3,r2
8112b35c:	d0a07017 	ldw	r2,-32320(gp)
8112b360:	1884b03a 	or	r2,r3,r2
8112b364:	d0a07015 	stw	r2,-32320(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8112b368:	d0a07017 	ldw	r2,-32320(gp)
8112b36c:	100170fa 	wrctl	ienable,r2
8112b370:	e0bff817 	ldw	r2,-32(fp)
8112b374:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112b378:	e0bff917 	ldw	r2,-28(fp)
8112b37c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8112b380:	0005883a 	mov	r2,zero
8112b384:	00001906 	br	8112b3ec <alt_irq_register+0x160>
8112b388:	e0bffd17 	ldw	r2,-12(fp)
8112b38c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112b390:	0005303a 	rdctl	r2,status
8112b394:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112b398:	e0fffa17 	ldw	r3,-24(fp)
8112b39c:	00bfff84 	movi	r2,-2
8112b3a0:	1884703a 	and	r2,r3,r2
8112b3a4:	1001703a 	wrctl	status,r2
  
  return context;
8112b3a8:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8112b3ac:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
8112b3b0:	00c00044 	movi	r3,1
8112b3b4:	e0bff417 	ldw	r2,-48(fp)
8112b3b8:	1884983a 	sll	r2,r3,r2
8112b3bc:	0084303a 	nor	r2,zero,r2
8112b3c0:	1007883a 	mov	r3,r2
8112b3c4:	d0a07017 	ldw	r2,-32320(gp)
8112b3c8:	1884703a 	and	r2,r3,r2
8112b3cc:	d0a07015 	stw	r2,-32320(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8112b3d0:	d0a07017 	ldw	r2,-32320(gp)
8112b3d4:	100170fa 	wrctl	ienable,r2
8112b3d8:	e0bffb17 	ldw	r2,-20(fp)
8112b3dc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112b3e0:	e0bffc17 	ldw	r2,-16(fp)
8112b3e4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8112b3e8:	0005883a 	mov	r2,zero
8112b3ec:	e0bff115 	stw	r2,-60(fp)
8112b3f0:	e0bff317 	ldw	r2,-52(fp)
8112b3f4:	e0bff515 	stw	r2,-44(fp)
8112b3f8:	e0bff517 	ldw	r2,-44(fp)
8112b3fc:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
8112b400:	e0bff117 	ldw	r2,-60(fp)
}
8112b404:	e037883a 	mov	sp,fp
8112b408:	df000017 	ldw	fp,0(sp)
8112b40c:	dec00104 	addi	sp,sp,4
8112b410:	f800283a 	ret

8112b414 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112b414:	defffe04 	addi	sp,sp,-8
8112b418:	de00012e 	bgeu	sp,et,8112b420 <alt_get_errno+0xc>
8112b41c:	003b68fa 	trap	3
8112b420:	dfc00115 	stw	ra,4(sp)
8112b424:	df000015 	stw	fp,0(sp)
8112b428:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112b42c:	d0a01017 	ldw	r2,-32704(gp)
8112b430:	10000326 	beq	r2,zero,8112b440 <alt_get_errno+0x2c>
8112b434:	d0a01017 	ldw	r2,-32704(gp)
8112b438:	103ee83a 	callr	r2
8112b43c:	00000106 	br	8112b444 <alt_get_errno+0x30>
8112b440:	d0a06804 	addi	r2,gp,-32352
}
8112b444:	e037883a 	mov	sp,fp
8112b448:	dfc00117 	ldw	ra,4(sp)
8112b44c:	df000017 	ldw	fp,0(sp)
8112b450:	dec00204 	addi	sp,sp,8
8112b454:	f800283a 	ret

8112b458 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
8112b458:	deffed04 	addi	sp,sp,-76
8112b45c:	de00012e 	bgeu	sp,et,8112b464 <isatty+0xc>
8112b460:	003b68fa 	trap	3
8112b464:	dfc01215 	stw	ra,72(sp)
8112b468:	df001115 	stw	fp,68(sp)
8112b46c:	df001104 	addi	fp,sp,68
8112b470:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112b474:	e0bfff17 	ldw	r2,-4(fp)
8112b478:	10000616 	blt	r2,zero,8112b494 <isatty+0x3c>
8112b47c:	e0bfff17 	ldw	r2,-4(fp)
8112b480:	10c00324 	muli	r3,r2,12
8112b484:	00a04534 	movhi	r2,33044
8112b488:	1095d504 	addi	r2,r2,22356
8112b48c:	1885883a 	add	r2,r3,r2
8112b490:	00000106 	br	8112b498 <isatty+0x40>
8112b494:	0005883a 	mov	r2,zero
8112b498:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
8112b49c:	e0bfef17 	ldw	r2,-68(fp)
8112b4a0:	10000e26 	beq	r2,zero,8112b4dc <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
8112b4a4:	e0bfef17 	ldw	r2,-68(fp)
8112b4a8:	10800017 	ldw	r2,0(r2)
8112b4ac:	10800817 	ldw	r2,32(r2)
8112b4b0:	1000021e 	bne	r2,zero,8112b4bc <isatty+0x64>
    {
      return 1;
8112b4b4:	00800044 	movi	r2,1
8112b4b8:	00000d06 	br	8112b4f0 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
8112b4bc:	e0bff004 	addi	r2,fp,-64
8112b4c0:	100b883a 	mov	r5,r2
8112b4c4:	e13fff17 	ldw	r4,-4(fp)
8112b4c8:	112b1d40 	call	8112b1d4 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
8112b4cc:	e0bff117 	ldw	r2,-60(fp)
8112b4d0:	10880020 	cmpeqi	r2,r2,8192
8112b4d4:	10803fcc 	andi	r2,r2,255
8112b4d8:	00000506 	br	8112b4f0 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8112b4dc:	112b4140 	call	8112b414 <alt_get_errno>
8112b4e0:	1007883a 	mov	r3,r2
8112b4e4:	00801444 	movi	r2,81
8112b4e8:	18800015 	stw	r2,0(r3)
    return 0;
8112b4ec:	0005883a 	mov	r2,zero
  }
}
8112b4f0:	e037883a 	mov	sp,fp
8112b4f4:	dfc00117 	ldw	ra,4(sp)
8112b4f8:	df000017 	ldw	fp,0(sp)
8112b4fc:	dec00204 	addi	sp,sp,8
8112b500:	f800283a 	ret

8112b504 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
8112b504:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
8112b508:	318c2404 	addi	r6,r6,12432

8112b50c <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
8112b50c:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
8112b510:	01c00826 	beq	zero,r7,8112b534 <end_tx>

8112b514 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
8112b514:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
8112b518:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
8112b51c:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
8112b520:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
8112b524:	283ffb26 	beq	r5,zero,8112b514 <__reset+0xfb10b514>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
8112b528:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
8112b52c:	21000044 	addi	r4,r4,1
	br tx_next_char
8112b530:	003ff606 	br	8112b50c <__reset+0xfb10b50c>

8112b534 <end_tx>:
end_tx:	
        ret
8112b534:	f800283a 	ret

8112b538 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
8112b538:	defffd04 	addi	sp,sp,-12
8112b53c:	de00012e 	bgeu	sp,et,8112b544 <alt_log_txchar+0xc>
8112b540:	003b68fa 	trap	3
8112b544:	df000215 	stw	fp,8(sp)
8112b548:	df000204 	addi	fp,sp,8
8112b54c:	e13ffe15 	stw	r4,-8(fp)
8112b550:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
8112b554:	0001883a 	nop
8112b558:	e0bfff17 	ldw	r2,-4(fp)
8112b55c:	10800104 	addi	r2,r2,4
8112b560:	10800037 	ldwio	r2,0(r2)
8112b564:	10bfffec 	andhi	r2,r2,65535
8112b568:	103ffb26 	beq	r2,zero,8112b558 <__reset+0xfb10b558>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
8112b56c:	e0bfff17 	ldw	r2,-4(fp)
8112b570:	e0fffe17 	ldw	r3,-8(fp)
8112b574:	10c00035 	stwio	r3,0(r2)
}
8112b578:	0001883a 	nop
8112b57c:	e037883a 	mov	sp,fp
8112b580:	df000017 	ldw	fp,0(sp)
8112b584:	dec00104 	addi	sp,sp,4
8112b588:	f800283a 	ret

8112b58c <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
8112b58c:	defffb04 	addi	sp,sp,-20
8112b590:	de00012e 	bgeu	sp,et,8112b598 <alt_log_repchar+0xc>
8112b594:	003b68fa 	trap	3
8112b598:	dfc00415 	stw	ra,16(sp)
8112b59c:	df000315 	stw	fp,12(sp)
8112b5a0:	df000304 	addi	fp,sp,12
8112b5a4:	2005883a 	mov	r2,r4
8112b5a8:	e17ffe15 	stw	r5,-8(fp)
8112b5ac:	e1bfff15 	stw	r6,-4(fp)
8112b5b0:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
8112b5b4:	00000506 	br	8112b5cc <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
8112b5b8:	e0bffd07 	ldb	r2,-12(fp)
8112b5bc:	e0ffff17 	ldw	r3,-4(fp)
8112b5c0:	180b883a 	mov	r5,r3
8112b5c4:	1009883a 	mov	r4,r2
8112b5c8:	112b5380 	call	8112b538 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
8112b5cc:	e0bffe17 	ldw	r2,-8(fp)
8112b5d0:	10ffffc4 	addi	r3,r2,-1
8112b5d4:	e0fffe15 	stw	r3,-8(fp)
8112b5d8:	00bff716 	blt	zero,r2,8112b5b8 <__reset+0xfb10b5b8>
    alt_log_txchar(c,(char*) base);
}
8112b5dc:	0001883a 	nop
8112b5e0:	e037883a 	mov	sp,fp
8112b5e4:	dfc00117 	ldw	ra,4(sp)
8112b5e8:	df000017 	ldw	fp,0(sp)
8112b5ec:	dec00204 	addi	sp,sp,8
8112b5f0:	f800283a 	ret

8112b5f4 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
8112b5f4:	deffe904 	addi	sp,sp,-92
8112b5f8:	de00012e 	bgeu	sp,et,8112b600 <alt_log_private_printf+0xc>
8112b5fc:	003b68fa 	trap	3
8112b600:	dfc01615 	stw	ra,88(sp)
8112b604:	df001515 	stw	fp,84(sp)
8112b608:	dc001415 	stw	r16,80(sp)
8112b60c:	df001504 	addi	fp,sp,84
8112b610:	e13ffc15 	stw	r4,-16(fp)
8112b614:	e17ffd15 	stw	r5,-12(fp)
8112b618:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
8112b61c:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
8112b620:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
8112b624:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
8112b628:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
8112b62c:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
8112b630:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
8112b634:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
8112b638:	e0bffc17 	ldw	r2,-16(fp)
8112b63c:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
8112b640:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
8112b644:	00014b06 	br	8112bb74 <alt_log_private_printf+0x580>
    {
    switch(state)
8112b648:	e0bfec17 	ldw	r2,-80(fp)
8112b64c:	10c00060 	cmpeqi	r3,r2,1
8112b650:	18001b1e 	bne	r3,zero,8112b6c0 <alt_log_private_printf+0xcc>
8112b654:	10c000a0 	cmpeqi	r3,r2,2
8112b658:	18002d1e 	bne	r3,zero,8112b710 <alt_log_private_printf+0x11c>
8112b65c:	10000126 	beq	r2,zero,8112b664 <alt_log_private_printf+0x70>
8112b660:	00014406 	br	8112bb74 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
8112b664:	e0bffb07 	ldb	r2,-20(fp)
8112b668:	10800958 	cmpnei	r2,r2,37
8112b66c:	10000e1e 	bne	r2,zero,8112b6a8 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
8112b670:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
8112b674:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
8112b678:	00800284 	movi	r2,10
8112b67c:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
8112b680:	00800044 	movi	r2,1
8112b684:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
8112b688:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
8112b68c:	00bfffc4 	movi	r2,-1
8112b690:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
8112b694:	00bfffc4 	movi	r2,-1
8112b698:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
8112b69c:	00800044 	movi	r2,1
8112b6a0:	e0bfec15 	stw	r2,-80(fp)
8112b6a4:	00013306 	br	8112bb74 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
8112b6a8:	e0bffb07 	ldb	r2,-20(fp)
8112b6ac:	e0fffd17 	ldw	r3,-12(fp)
8112b6b0:	180b883a 	mov	r5,r3
8112b6b4:	1009883a 	mov	r4,r2
8112b6b8:	112b5380 	call	8112b538 <alt_log_txchar>
        }
        break;
8112b6bc:	00012d06 	br	8112bb74 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
8112b6c0:	e0bffb07 	ldb	r2,-20(fp)
8112b6c4:	10800c18 	cmpnei	r2,r2,48
8112b6c8:	1000051e 	bne	r2,zero,8112b6e0 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
8112b6cc:	00800044 	movi	r2,1
8112b6d0:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
8112b6d4:	00800084 	movi	r2,2
8112b6d8:	e0bfec15 	stw	r2,-80(fp)
8112b6dc:	00012506 	br	8112bb74 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
8112b6e0:	e0bffb07 	ldb	r2,-20(fp)
8112b6e4:	10800958 	cmpnei	r2,r2,37
8112b6e8:	1000071e 	bne	r2,zero,8112b708 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
8112b6ec:	e0bffb07 	ldb	r2,-20(fp)
8112b6f0:	e0fffd17 	ldw	r3,-12(fp)
8112b6f4:	180b883a 	mov	r5,r3
8112b6f8:	1009883a 	mov	r4,r2
8112b6fc:	112b5380 	call	8112b538 <alt_log_txchar>
          state = pfState_chars;
8112b700:	e03fec15 	stw	zero,-80(fp)
8112b704:	00011b06 	br	8112bb74 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
8112b708:	00800084 	movi	r2,2
8112b70c:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
8112b710:	e0bffb07 	ldb	r2,-20(fp)
8112b714:	10800b98 	cmpnei	r2,r2,46
8112b718:	1000021e 	bne	r2,zero,8112b724 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
8112b71c:	e03ff015 	stw	zero,-64(fp)
8112b720:	00011306 	br	8112bb70 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
8112b724:	e0bffb07 	ldb	r2,-20(fp)
8112b728:	10800c10 	cmplti	r2,r2,48
8112b72c:	10001a1e 	bne	r2,zero,8112b798 <alt_log_private_printf+0x1a4>
8112b730:	e0bffb07 	ldb	r2,-20(fp)
8112b734:	10800e88 	cmpgei	r2,r2,58
8112b738:	1000171e 	bne	r2,zero,8112b798 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
8112b73c:	e0bffb03 	ldbu	r2,-20(fp)
8112b740:	10bff404 	addi	r2,r2,-48
8112b744:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
8112b748:	e0bff017 	ldw	r2,-64(fp)
8112b74c:	10000c0e 	bge	r2,zero,8112b780 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
8112b750:	e0bfef17 	ldw	r2,-68(fp)
8112b754:	1000020e 	bge	r2,zero,8112b760 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
8112b758:	e03fef15 	stw	zero,-68(fp)
8112b75c:	00000306 	br	8112b76c <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
8112b760:	e0bfef17 	ldw	r2,-68(fp)
8112b764:	108002a4 	muli	r2,r2,10
8112b768:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
8112b76c:	e0bffb07 	ldb	r2,-20(fp)
8112b770:	e0ffef17 	ldw	r3,-68(fp)
8112b774:	1885883a 	add	r2,r3,r2
8112b778:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
8112b77c:	0000fc06 	br	8112bb70 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
8112b780:	e0bff017 	ldw	r2,-64(fp)
8112b784:	10c002a4 	muli	r3,r2,10
8112b788:	e0bffb07 	ldb	r2,-20(fp)
8112b78c:	1885883a 	add	r2,r3,r2
8112b790:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
8112b794:	0000f606 	br	8112bb70 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
8112b798:	e0bffb07 	ldb	r2,-20(fp)
8112b79c:	10801b18 	cmpnei	r2,r2,108
8112b7a0:	1000031e 	bne	r2,zero,8112b7b0 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
8112b7a4:	00800044 	movi	r2,1
8112b7a8:	e0bfee15 	stw	r2,-72(fp)
8112b7ac:	0000f006 	br	8112bb70 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
8112b7b0:	e0bffb07 	ldb	r2,-20(fp)
8112b7b4:	10bfea04 	addi	r2,r2,-88
8112b7b8:	10c00868 	cmpgeui	r3,r2,33
8112b7bc:	1800eb1e 	bne	r3,zero,8112bb6c <alt_log_private_printf+0x578>
8112b7c0:	100690ba 	slli	r3,r2,2
8112b7c4:	00a044f4 	movhi	r2,33043
8112b7c8:	10adf604 	addi	r2,r2,-18472
8112b7cc:	1885883a 	add	r2,r3,r2
8112b7d0:	10800017 	ldw	r2,0(r2)
8112b7d4:	1000683a 	jmp	r2
8112b7d8:	8112ba98 	cmpnei	r4,r16,19178
8112b7dc:	8112bb6c 	andhi	r4,r16,19181
8112b7e0:	8112bb6c 	andhi	r4,r16,19181
8112b7e4:	8112bb6c 	andhi	r4,r16,19181
8112b7e8:	8112bb6c 	andhi	r4,r16,19181
8112b7ec:	8112bb6c 	andhi	r4,r16,19181
8112b7f0:	8112bb6c 	andhi	r4,r16,19181
8112b7f4:	8112bb6c 	andhi	r4,r16,19181
8112b7f8:	8112bb6c 	andhi	r4,r16,19181
8112b7fc:	8112bb6c 	andhi	r4,r16,19181
8112b800:	8112bb6c 	andhi	r4,r16,19181
8112b804:	8112bab0 	cmpltui	r4,r16,19178
8112b808:	8112b85c 	xori	r4,r16,19169
8112b80c:	8112bb6c 	andhi	r4,r16,19181
8112b810:	8112bb6c 	andhi	r4,r16,19181
8112b814:	8112bb6c 	andhi	r4,r16,19181
8112b818:	8112bb6c 	andhi	r4,r16,19181
8112b81c:	8112b85c 	xori	r4,r16,19169
8112b820:	8112bb6c 	andhi	r4,r16,19181
8112b824:	8112bb6c 	andhi	r4,r16,19181
8112b828:	8112bb6c 	andhi	r4,r16,19181
8112b82c:	8112bb6c 	andhi	r4,r16,19181
8112b830:	8112bb6c 	andhi	r4,r16,19181
8112b834:	8112ba78 	rdprs	r4,r16,19177
8112b838:	8112bb6c 	andhi	r4,r16,19181
8112b83c:	8112bb6c 	andhi	r4,r16,19181
8112b840:	8112bb6c 	andhi	r4,r16,19181
8112b844:	8112baec 	andhi	r4,r16,19179
8112b848:	8112bb6c 	andhi	r4,r16,19181
8112b84c:	8112ba70 	cmpltui	r4,r16,19177
8112b850:	8112bb6c 	andhi	r4,r16,19181
8112b854:	8112bb6c 	andhi	r4,r16,19181
8112b858:	8112ba88 	cmpgei	r4,r16,19178
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
8112b85c:	e0bfee17 	ldw	r2,-72(fp)
8112b860:	10000e26 	beq	r2,zero,8112b89c <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
8112b864:	e0bff217 	ldw	r2,-56(fp)
8112b868:	10000626 	beq	r2,zero,8112b884 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
8112b86c:	e0bffe17 	ldw	r2,-8(fp)
8112b870:	10c00104 	addi	r3,r2,4
8112b874:	e0fffe15 	stw	r3,-8(fp)
8112b878:	10800017 	ldw	r2,0(r2)
8112b87c:	e0bff415 	stw	r2,-48(fp)
8112b880:	00001306 	br	8112b8d0 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
8112b884:	e0bffe17 	ldw	r2,-8(fp)
8112b888:	10c00104 	addi	r3,r2,4
8112b88c:	e0fffe15 	stw	r3,-8(fp)
8112b890:	10800017 	ldw	r2,0(r2)
8112b894:	e0bff415 	stw	r2,-48(fp)
8112b898:	00000d06 	br	8112b8d0 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
8112b89c:	e0bff217 	ldw	r2,-56(fp)
8112b8a0:	10000626 	beq	r2,zero,8112b8bc <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
8112b8a4:	e0bffe17 	ldw	r2,-8(fp)
8112b8a8:	10c00104 	addi	r3,r2,4
8112b8ac:	e0fffe15 	stw	r3,-8(fp)
8112b8b0:	10800017 	ldw	r2,0(r2)
8112b8b4:	e0bff415 	stw	r2,-48(fp)
8112b8b8:	00000506 	br	8112b8d0 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
8112b8bc:	e0bffe17 	ldw	r2,-8(fp)
8112b8c0:	10c00104 	addi	r3,r2,4
8112b8c4:	e0fffe15 	stw	r3,-8(fp)
8112b8c8:	10800017 	ldw	r2,0(r2)
8112b8cc:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
8112b8d0:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
8112b8d4:	e0bff217 	ldw	r2,-56(fp)
8112b8d8:	10000726 	beq	r2,zero,8112b8f8 <alt_log_private_printf+0x304>
8112b8dc:	e0bff417 	ldw	r2,-48(fp)
8112b8e0:	1000050e 	bge	r2,zero,8112b8f8 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
8112b8e4:	e0bff417 	ldw	r2,-48(fp)
8112b8e8:	0085c83a 	sub	r2,zero,r2
8112b8ec:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
8112b8f0:	00800044 	movi	r2,1
8112b8f4:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
8112b8f8:	e0bff417 	ldw	r2,-48(fp)
8112b8fc:	e0bff615 	stw	r2,-40(fp)
                p = 1;
8112b900:	00800044 	movi	r2,1
8112b904:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
8112b908:	00800044 	movi	r2,1
8112b90c:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
8112b910:	00000706 	br	8112b930 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
8112b914:	e0bff817 	ldw	r2,-32(fp)
8112b918:	10800044 	addi	r2,r2,1
8112b91c:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
8112b920:	e0bff117 	ldw	r2,-60(fp)
8112b924:	e0fff517 	ldw	r3,-44(fp)
8112b928:	1885383a 	mul	r2,r3,r2
8112b92c:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
8112b930:	e0bff117 	ldw	r2,-60(fp)
8112b934:	e0fff617 	ldw	r3,-40(fp)
8112b938:	1885203a 	divu	r2,r3,r2
8112b93c:	e0bff615 	stw	r2,-40(fp)
8112b940:	e0bff617 	ldw	r2,-40(fp)
8112b944:	103ff31e 	bne	r2,zero,8112b914 <__reset+0xfb10b914>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
8112b948:	e0ffef17 	ldw	r3,-68(fp)
8112b94c:	e0bff817 	ldw	r2,-32(fp)
8112b950:	1885c83a 	sub	r2,r3,r2
8112b954:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
8112b958:	e0bfed17 	ldw	r2,-76(fp)
8112b95c:	10000e26 	beq	r2,zero,8112b998 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
8112b960:	e0bff717 	ldw	r2,-36(fp)
8112b964:	10000726 	beq	r2,zero,8112b984 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
8112b968:	e0bffd17 	ldw	r2,-12(fp)
8112b96c:	100b883a 	mov	r5,r2
8112b970:	01000b44 	movi	r4,45
8112b974:	112b5380 	call	8112b538 <alt_log_txchar>
                    fmtBeforeDecimal--;
8112b978:	e0bfef17 	ldw	r2,-68(fp)
8112b97c:	10bfffc4 	addi	r2,r2,-1
8112b980:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
8112b984:	e1bffd17 	ldw	r6,-12(fp)
8112b988:	e17fef17 	ldw	r5,-68(fp)
8112b98c:	01000c04 	movi	r4,48
8112b990:	112b58c0 	call	8112b58c <alt_log_repchar>
8112b994:	00003206 	br	8112ba60 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
8112b998:	e0bff717 	ldw	r2,-36(fp)
8112b99c:	10000326 	beq	r2,zero,8112b9ac <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
8112b9a0:	e0bfef17 	ldw	r2,-68(fp)
8112b9a4:	10bfffc4 	addi	r2,r2,-1
8112b9a8:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
8112b9ac:	e1bffd17 	ldw	r6,-12(fp)
8112b9b0:	e17fef17 	ldw	r5,-68(fp)
8112b9b4:	01000804 	movi	r4,32
8112b9b8:	112b58c0 	call	8112b58c <alt_log_repchar>
                    if(sign)
8112b9bc:	e0bff717 	ldw	r2,-36(fp)
8112b9c0:	10002726 	beq	r2,zero,8112ba60 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
8112b9c4:	e0bffd17 	ldw	r2,-12(fp)
8112b9c8:	100b883a 	mov	r5,r2
8112b9cc:	01000b44 	movi	r4,45
8112b9d0:	112b5380 	call	8112b538 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
8112b9d4:	00002206 	br	8112ba60 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
8112b9d8:	e0fff417 	ldw	r3,-48(fp)
8112b9dc:	e0bff517 	ldw	r2,-44(fp)
8112b9e0:	1885203a 	divu	r2,r3,r2
8112b9e4:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
8112b9e8:	e0bff903 	ldbu	r2,-28(fp)
8112b9ec:	10800c04 	addi	r2,r2,48
8112b9f0:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
8112b9f4:	e0bff903 	ldbu	r2,-28(fp)
8112b9f8:	10800eb0 	cmpltui	r2,r2,58
8112b9fc:	1000081e 	bne	r2,zero,8112ba20 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
8112ba00:	e0bff317 	ldw	r2,-52(fp)
8112ba04:	10000226 	beq	r2,zero,8112ba10 <alt_log_private_printf+0x41c>
8112ba08:	008001c4 	movi	r2,7
8112ba0c:	00000106 	br	8112ba14 <alt_log_private_printf+0x420>
8112ba10:	008009c4 	movi	r2,39
8112ba14:	e0fff903 	ldbu	r3,-28(fp)
8112ba18:	10c5883a 	add	r2,r2,r3
8112ba1c:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
8112ba20:	e0bff903 	ldbu	r2,-28(fp)
8112ba24:	e0fffd17 	ldw	r3,-12(fp)
8112ba28:	180b883a 	mov	r5,r3
8112ba2c:	1009883a 	mov	r4,r2
8112ba30:	112b5380 	call	8112b538 <alt_log_txchar>

                  v = v % p;
8112ba34:	e0bff417 	ldw	r2,-48(fp)
8112ba38:	e0fff517 	ldw	r3,-44(fp)
8112ba3c:	10c9203a 	divu	r4,r2,r3
8112ba40:	e0fff517 	ldw	r3,-44(fp)
8112ba44:	20c7383a 	mul	r3,r4,r3
8112ba48:	10c5c83a 	sub	r2,r2,r3
8112ba4c:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
8112ba50:	e0bff117 	ldw	r2,-60(fp)
8112ba54:	e0fff517 	ldw	r3,-44(fp)
8112ba58:	1885203a 	divu	r2,r3,r2
8112ba5c:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
8112ba60:	e0bff517 	ldw	r2,-44(fp)
8112ba64:	103fdc1e 	bne	r2,zero,8112b9d8 <__reset+0xfb10b9d8>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
8112ba68:	e03fec15 	stw	zero,-80(fp)
              break;
8112ba6c:	00003f06 	br	8112bb6c <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
8112ba70:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
8112ba74:	003f7906 	br	8112b85c <__reset+0xfb10b85c>
            case 'o':
              fmtSigned = 0;
8112ba78:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
8112ba7c:	00800204 	movi	r2,8
8112ba80:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
8112ba84:	003f7506 	br	8112b85c <__reset+0xfb10b85c>
            case 'x':
              fmtSigned = 0;
8112ba88:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
8112ba8c:	00800404 	movi	r2,16
8112ba90:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
8112ba94:	003f7106 	br	8112b85c <__reset+0xfb10b85c>
            case 'X':
              fmtSigned = 0;
8112ba98:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
8112ba9c:	00800404 	movi	r2,16
8112baa0:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
8112baa4:	00800044 	movi	r2,1
8112baa8:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
8112baac:	003f6b06 	br	8112b85c <__reset+0xfb10b85c>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
8112bab0:	e0bfef17 	ldw	r2,-68(fp)
8112bab4:	10bfffc4 	addi	r2,r2,-1
8112bab8:	e1bffd17 	ldw	r6,-12(fp)
8112babc:	100b883a 	mov	r5,r2
8112bac0:	01000804 	movi	r4,32
8112bac4:	112b58c0 	call	8112b58c <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
8112bac8:	e0bffe17 	ldw	r2,-8(fp)
8112bacc:	10c00104 	addi	r3,r2,4
8112bad0:	e0fffe15 	stw	r3,-8(fp)
8112bad4:	10800017 	ldw	r2,0(r2)
8112bad8:	e0fffd17 	ldw	r3,-12(fp)
8112badc:	180b883a 	mov	r5,r3
8112bae0:	1009883a 	mov	r4,r2
8112bae4:	112b5380 	call	8112b538 <alt_log_txchar>
              break;
8112bae8:	00002006 	br	8112bb6c <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
8112baec:	e0bffe17 	ldw	r2,-8(fp)
8112baf0:	10c00104 	addi	r3,r2,4
8112baf4:	e0fffe15 	stw	r3,-8(fp)
8112baf8:	10800017 	ldw	r2,0(r2)
8112bafc:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
8112bb00:	e43fef17 	ldw	r16,-68(fp)
8112bb04:	e13ffa17 	ldw	r4,-24(fp)
8112bb08:	11172280 	call	81117228 <strlen>
8112bb0c:	8085c83a 	sub	r2,r16,r2
8112bb10:	e1bffd17 	ldw	r6,-12(fp)
8112bb14:	100b883a 	mov	r5,r2
8112bb18:	01000804 	movi	r4,32
8112bb1c:	112b58c0 	call	8112b58c <alt_log_repchar>

                while(*s)
8112bb20:	00000b06 	br	8112bb50 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
8112bb24:	e0bffa17 	ldw	r2,-24(fp)
8112bb28:	10c00044 	addi	r3,r2,1
8112bb2c:	e0fffa15 	stw	r3,-24(fp)
8112bb30:	10800003 	ldbu	r2,0(r2)
8112bb34:	10803fcc 	andi	r2,r2,255
8112bb38:	1080201c 	xori	r2,r2,128
8112bb3c:	10bfe004 	addi	r2,r2,-128
8112bb40:	e0fffd17 	ldw	r3,-12(fp)
8112bb44:	180b883a 	mov	r5,r3
8112bb48:	1009883a 	mov	r4,r2
8112bb4c:	112b5380 	call	8112b538 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
8112bb50:	e0bffa17 	ldw	r2,-24(fp)
8112bb54:	10800003 	ldbu	r2,0(r2)
8112bb58:	10803fcc 	andi	r2,r2,255
8112bb5c:	1080201c 	xori	r2,r2,128
8112bb60:	10bfe004 	addi	r2,r2,-128
8112bb64:	103fef1e 	bne	r2,zero,8112bb24 <__reset+0xfb10bb24>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
8112bb68:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
8112bb6c:	e03fec15 	stw	zero,-80(fp)
          }
        break;
8112bb70:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
8112bb74:	e0bfeb17 	ldw	r2,-84(fp)
8112bb78:	10c00044 	addi	r3,r2,1
8112bb7c:	e0ffeb15 	stw	r3,-84(fp)
8112bb80:	10800003 	ldbu	r2,0(r2)
8112bb84:	e0bffb05 	stb	r2,-20(fp)
8112bb88:	e0bffb07 	ldb	r2,-20(fp)
8112bb8c:	103eae1e 	bne	r2,zero,8112b648 <__reset+0xfb10b648>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
8112bb90:	0001883a 	nop
8112bb94:	e6ffff04 	addi	sp,fp,-4
8112bb98:	dfc00217 	ldw	ra,8(sp)
8112bb9c:	df000117 	ldw	fp,4(sp)
8112bba0:	dc000017 	ldw	r16,0(sp)
8112bba4:	dec00304 	addi	sp,sp,12
8112bba8:	f800283a 	ret

8112bbac <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
8112bbac:	defff904 	addi	sp,sp,-28
8112bbb0:	de00012e 	bgeu	sp,et,8112bbb8 <alt_log_printf_proc+0xc>
8112bbb4:	003b68fa 	trap	3
8112bbb8:	dfc00315 	stw	ra,12(sp)
8112bbbc:	df000215 	stw	fp,8(sp)
8112bbc0:	df000204 	addi	fp,sp,8
8112bbc4:	e13fff15 	stw	r4,-4(fp)
8112bbc8:	e1400215 	stw	r5,8(fp)
8112bbcc:	e1800315 	stw	r6,12(fp)
8112bbd0:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
8112bbd4:	e0800204 	addi	r2,fp,8
8112bbd8:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
8112bbdc:	e0bffe17 	ldw	r2,-8(fp)
8112bbe0:	100d883a 	mov	r6,r2
8112bbe4:	01604834 	movhi	r5,33056
8112bbe8:	294c2404 	addi	r5,r5,12432
8112bbec:	e13fff17 	ldw	r4,-4(fp)
8112bbf0:	112b5f40 	call	8112b5f4 <alt_log_private_printf>
    return (0);
8112bbf4:	0005883a 	mov	r2,zero
}
8112bbf8:	e037883a 	mov	sp,fp
8112bbfc:	dfc00117 	ldw	ra,4(sp)
8112bc00:	df000017 	ldw	fp,0(sp)
8112bc04:	dec00504 	addi	sp,sp,20
8112bc08:	f800283a 	ret

8112bc0c <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
8112bc0c:	defff904 	addi	sp,sp,-28
8112bc10:	de00012e 	bgeu	sp,et,8112bc18 <altera_avalon_jtag_uart_report_log+0xc>
8112bc14:	003b68fa 	trap	3
8112bc18:	dfc00615 	stw	ra,24(sp)
8112bc1c:	df000515 	stw	fp,20(sp)
8112bc20:	dc400415 	stw	r17,16(sp)
8112bc24:	dc000315 	stw	r16,12(sp)
8112bc28:	df000504 	addi	fp,sp,20
8112bc2c:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
8112bc30:	d0a07183 	ldbu	r2,-32314(gp)
8112bc34:	10803fcc 	andi	r2,r2,255
8112bc38:	10001426 	beq	r2,zero,8112bc8c <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
8112bc3c:	e0bffd17 	ldw	r2,-12(fp)
8112bc40:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
8112bc44:	00a04534 	movhi	r2,33044
8112bc48:	1091fb04 	addi	r2,r2,18412
8112bc4c:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
8112bc50:	e0bffb17 	ldw	r2,-20(fp)
8112bc54:	10800017 	ldw	r2,0(r2)
8112bc58:	e1bffc17 	ldw	r6,-16(fp)
8112bc5c:	100b883a 	mov	r5,r2
8112bc60:	e13ffb17 	ldw	r4,-20(fp)
8112bc64:	112bcac0 	call	8112bcac <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8112bc68:	d0e07817 	ldw	r3,-32288(gp)
        return ALT_LOG_JTAG_UART_TICKS;
8112bc6c:	00b33374 	movhi	r2,52429
8112bc70:	10b33344 	addi	r2,r2,-13107
8112bc74:	1888383a 	mulxuu	r4,r3,r2
8112bc78:	1885383a 	mul	r2,r3,r2
8112bc7c:	1021883a 	mov	r16,r2
8112bc80:	2023883a 	mov	r17,r4
8112bc84:	8804d0fa 	srli	r2,r17,3
8112bc88:	00000106 	br	8112bc90 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
8112bc8c:	0005883a 	mov	r2,zero
    }
}
8112bc90:	e6fffe04 	addi	sp,fp,-8
8112bc94:	dfc00317 	ldw	ra,12(sp)
8112bc98:	df000217 	ldw	fp,8(sp)
8112bc9c:	dc400117 	ldw	r17,4(sp)
8112bca0:	dc000017 	ldw	r16,0(sp)
8112bca4:	dec00404 	addi	sp,sp,16
8112bca8:	f800283a 	ret

8112bcac <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
8112bcac:	deffef04 	addi	sp,sp,-68
8112bcb0:	de00012e 	bgeu	sp,et,8112bcb8 <alt_log_jtag_uart_print_control_reg+0xc>
8112bcb4:	003b68fa 	trap	3
8112bcb8:	dfc01015 	stw	ra,64(sp)
8112bcbc:	df000f15 	stw	fp,60(sp)
8112bcc0:	df000f04 	addi	fp,sp,60
8112bcc4:	e13ffd15 	stw	r4,-12(fp)
8112bcc8:	e17ffe15 	stw	r5,-8(fp)
8112bccc:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8112bcd0:	e0bffe17 	ldw	r2,-8(fp)
8112bcd4:	10800104 	addi	r2,r2,4
8112bcd8:	10800037 	ldwio	r2,0(r2)
8112bcdc:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
8112bce0:	e0bff617 	ldw	r2,-40(fp)
8112bce4:	1004d43a 	srli	r2,r2,16
8112bce8:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
8112bcec:	e0bff617 	ldw	r2,-40(fp)
8112bcf0:	1080008c 	andi	r2,r2,2
8112bcf4:	1004d07a 	srli	r2,r2,1
8112bcf8:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
8112bcfc:	e0bff617 	ldw	r2,-40(fp)
8112bd00:	1080004c 	andi	r2,r2,1
8112bd04:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
8112bd08:	e0bff617 	ldw	r2,-40(fp)
8112bd0c:	1080400c 	andi	r2,r2,256
8112bd10:	1004d23a 	srli	r2,r2,8
8112bd14:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
8112bd18:	e0bff617 	ldw	r2,-40(fp)
8112bd1c:	1080800c 	andi	r2,r2,512
8112bd20:	1004d27a 	srli	r2,r2,9
8112bd24:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
8112bd28:	e0bff617 	ldw	r2,-40(fp)
8112bd2c:	1081000c 	andi	r2,r2,1024
8112bd30:	1004d2ba 	srli	r2,r2,10
8112bd34:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
8112bd38:	e0bffd17 	ldw	r2,-12(fp)
8112bd3c:	10c01017 	ldw	r3,64(r2)
8112bd40:	e0bffd17 	ldw	r2,-12(fp)
8112bd44:	10800f17 	ldw	r2,60(r2)
8112bd48:	1887c83a 	sub	r3,r3,r2
8112bd4c:	e0bff917 	ldw	r2,-28(fp)
8112bd50:	d8800415 	stw	r2,16(sp)
8112bd54:	e0bff817 	ldw	r2,-32(fp)
8112bd58:	d8800315 	stw	r2,12(sp)
8112bd5c:	e0bffa17 	ldw	r2,-24(fp)
8112bd60:	d8800215 	stw	r2,8(sp)
8112bd64:	e0bffb17 	ldw	r2,-20(fp)
8112bd68:	d8800115 	stw	r2,4(sp)
8112bd6c:	e0bffc17 	ldw	r2,-16(fp)
8112bd70:	d8800015 	stw	r2,0(sp)
8112bd74:	e1fff717 	ldw	r7,-36(fp)
8112bd78:	180d883a 	mov	r6,r3
8112bd7c:	e17fff17 	ldw	r5,-4(fp)
8112bd80:	01204534 	movhi	r4,33044
8112bd84:	2111fe04 	addi	r4,r4,18424
8112bd88:	112bbac0 	call	8112bbac <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
8112bd8c:	0001883a 	nop

}
8112bd90:	e037883a 	mov	sp,fp
8112bd94:	dfc00117 	ldw	ra,4(sp)
8112bd98:	df000017 	ldw	fp,0(sp)
8112bd9c:	dec00204 	addi	sp,sp,8
8112bda0:	f800283a 	ret

8112bda4 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
8112bda4:	defffb04 	addi	sp,sp,-20
8112bda8:	de00012e 	bgeu	sp,et,8112bdb0 <alt_log_jtag_uart_startup_info+0xc>
8112bdac:	003b68fa 	trap	3
8112bdb0:	dfc00415 	stw	ra,16(sp)
8112bdb4:	df000315 	stw	fp,12(sp)
8112bdb8:	df000304 	addi	fp,sp,12
8112bdbc:	e13ffe15 	stw	r4,-8(fp)
8112bdc0:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
8112bdc4:	00a04534 	movhi	r2,33044
8112bdc8:	10921004 	addi	r2,r2,18496
8112bdcc:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
8112bdd0:	e1bffd17 	ldw	r6,-12(fp)
8112bdd4:	e17fff17 	ldw	r5,-4(fp)
8112bdd8:	e13ffe17 	ldw	r4,-8(fp)
8112bddc:	112bcac0 	call	8112bcac <alt_log_jtag_uart_print_control_reg>
     return;
8112bde0:	0001883a 	nop
}
8112bde4:	e037883a 	mov	sp,fp
8112bde8:	dfc00117 	ldw	ra,4(sp)
8112bdec:	df000017 	ldw	fp,0(sp)
8112bdf0:	dec00204 	addi	sp,sp,8
8112bdf4:	f800283a 	ret

8112bdf8 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
8112bdf8:	defffb04 	addi	sp,sp,-20
8112bdfc:	de00012e 	bgeu	sp,et,8112be04 <alt_log_jtag_uart_isr_proc+0xc>
8112be00:	003b68fa 	trap	3
8112be04:	dfc00415 	stw	ra,16(sp)
8112be08:	df000315 	stw	fp,12(sp)
8112be0c:	df000304 	addi	fp,sp,12
8112be10:	e13ffe15 	stw	r4,-8(fp)
8112be14:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
8112be18:	d0a071c3 	ldbu	r2,-32313(gp)
8112be1c:	10803fcc 	andi	r2,r2,255
8112be20:	10000826 	beq	r2,zero,8112be44 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
8112be24:	00a04534 	movhi	r2,33044
8112be28:	10921504 	addi	r2,r2,18516
8112be2c:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
8112be30:	e1bffd17 	ldw	r6,-12(fp)
8112be34:	e17ffe17 	ldw	r5,-8(fp)
8112be38:	e13fff17 	ldw	r4,-4(fp)
8112be3c:	112bcac0 	call	8112bcac <alt_log_jtag_uart_print_control_reg>
    }
    return;
8112be40:	0001883a 	nop
8112be44:	0001883a 	nop
}
8112be48:	e037883a 	mov	sp,fp
8112be4c:	dfc00117 	ldw	ra,4(sp)
8112be50:	df000017 	ldw	fp,0(sp)
8112be54:	dec00204 	addi	sp,sp,8
8112be58:	f800283a 	ret

8112be5c <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
8112be5c:	defffa04 	addi	sp,sp,-24
8112be60:	de00012e 	bgeu	sp,et,8112be68 <alt_log_write+0xc>
8112be64:	003b68fa 	trap	3
8112be68:	dfc00515 	stw	ra,20(sp)
8112be6c:	df000415 	stw	fp,16(sp)
8112be70:	df000404 	addi	fp,sp,16
8112be74:	e13ffe15 	stw	r4,-8(fp)
8112be78:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
8112be7c:	d0a07103 	ldbu	r2,-32316(gp)
8112be80:	10803fcc 	andi	r2,r2,255
8112be84:	10004026 	beq	r2,zero,8112bf88 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
8112be88:	e0bfff17 	ldw	r2,-4(fp)
8112be8c:	10c00430 	cmpltui	r3,r2,16
8112be90:	1800011e 	bne	r3,zero,8112be98 <alt_log_write+0x3c>
8112be94:	008003c4 	movi	r2,15
8112be98:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
8112be9c:	e0bffd17 	ldw	r2,-12(fp)
8112bea0:	10800088 	cmpgei	r2,r2,2
8112bea4:	10003726 	beq	r2,zero,8112bf84 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
8112bea8:	e0bffd17 	ldw	r2,-12(fp)
8112beac:	100d883a 	mov	r6,r2
8112beb0:	e17ffe17 	ldw	r5,-8(fp)
8112beb4:	012045b4 	movhi	r4,33046
8112beb8:	21299904 	addi	r4,r4,-22940
8112bebc:	113fc740 	call	8113fc74 <strncpy>
    alt_log_write_buf[length-1]='\n';
8112bec0:	e0bffd17 	ldw	r2,-12(fp)
8112bec4:	10ffffc4 	addi	r3,r2,-1
8112bec8:	00a045b4 	movhi	r2,33046
8112becc:	10a99904 	addi	r2,r2,-22940
8112bed0:	10c5883a 	add	r2,r2,r3
8112bed4:	00c00284 	movi	r3,10
8112bed8:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
8112bedc:	00a045b4 	movhi	r2,33046
8112bee0:	10a99904 	addi	r2,r2,-22940
8112bee4:	e0fffd17 	ldw	r3,-12(fp)
8112bee8:	10c5883a 	add	r2,r2,r3
8112beec:	00c00344 	movi	r3,13
8112bef0:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
8112bef4:	e0bffd17 	ldw	r2,-12(fp)
8112bef8:	10c00044 	addi	r3,r2,1
8112befc:	00a045b4 	movhi	r2,33046
8112bf00:	10a99904 	addi	r2,r2,-22940
8112bf04:	10c5883a 	add	r2,r2,r3
8112bf08:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
8112bf0c:	e03ffc15 	stw	zero,-16(fp)
8112bf10:	00001306 	br	8112bf60 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
8112bf14:	00a045b4 	movhi	r2,33046
8112bf18:	10a99904 	addi	r2,r2,-22940
8112bf1c:	e0fffc17 	ldw	r3,-16(fp)
8112bf20:	10c5883a 	add	r2,r2,r3
8112bf24:	10800003 	ldbu	r2,0(r2)
8112bf28:	10803fcc 	andi	r2,r2,255
8112bf2c:	1080201c 	xori	r2,r2,128
8112bf30:	10bfe004 	addi	r2,r2,-128
8112bf34:	10800118 	cmpnei	r2,r2,4
8112bf38:	1000061e 	bne	r2,zero,8112bf54 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
8112bf3c:	00a045b4 	movhi	r2,33046
8112bf40:	10a99904 	addi	r2,r2,-22940
8112bf44:	e0fffc17 	ldw	r3,-16(fp)
8112bf48:	10c5883a 	add	r2,r2,r3
8112bf4c:	00c01104 	movi	r3,68
8112bf50:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
8112bf54:	e0bffc17 	ldw	r2,-16(fp)
8112bf58:	10800044 	addi	r2,r2,1
8112bf5c:	e0bffc15 	stw	r2,-16(fp)
8112bf60:	e0fffc17 	ldw	r3,-16(fp)
8112bf64:	e0bffd17 	ldw	r2,-12(fp)
8112bf68:	18bfea16 	blt	r3,r2,8112bf14 <__reset+0xfb10bf14>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
8112bf6c:	016045b4 	movhi	r5,33046
8112bf70:	29699904 	addi	r5,r5,-22940
8112bf74:	01204534 	movhi	r4,33044
8112bf78:	21121804 	addi	r4,r4,18528
8112bf7c:	112bbac0 	call	8112bbac <alt_log_printf_proc>
8112bf80:	00000106 	br	8112bf88 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
8112bf84:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
8112bf88:	e037883a 	mov	sp,fp
8112bf8c:	dfc00117 	ldw	ra,4(sp)
8112bf90:	df000017 	ldw	fp,0(sp)
8112bf94:	dec00204 	addi	sp,sp,8
8112bf98:	f800283a 	ret

8112bf9c <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
8112bf9c:	defffe04 	addi	sp,sp,-8
8112bfa0:	de00012e 	bgeu	sp,et,8112bfa8 <alt_log_system_clock+0xc>
8112bfa4:	003b68fa 	trap	3
8112bfa8:	dfc00115 	stw	ra,4(sp)
8112bfac:	df000015 	stw	fp,0(sp)
8112bfb0:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
8112bfb4:	d0a07143 	ldbu	r2,-32315(gp)
8112bfb8:	10803fcc 	andi	r2,r2,255
8112bfbc:	10000e26 	beq	r2,zero,8112bff8 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
8112bfc0:	d0a07417 	ldw	r2,-32304(gp)
8112bfc4:	10800044 	addi	r2,r2,1
8112bfc8:	d0a07415 	stw	r2,-32304(gp)
8112bfcc:	d0a07817 	ldw	r2,-32288(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
8112bfd0:	d0e07417 	ldw	r3,-32304(gp)
8112bfd4:	10c0082e 	bgeu	r2,r3,8112bff8 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
8112bfd8:	d0207415 	stw	zero,-32304(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
8112bfdc:	d0a07317 	ldw	r2,-32308(gp)
8112bfe0:	10c00044 	addi	r3,r2,1
8112bfe4:	d0e07315 	stw	r3,-32308(gp)
8112bfe8:	100b883a 	mov	r5,r2
8112bfec:	01204534 	movhi	r4,33044
8112bff0:	21121c04 	addi	r4,r4,18544
8112bff4:	112bbac0 	call	8112bbac <alt_log_printf_proc>
        }
    }
}
8112bff8:	0001883a 	nop
8112bffc:	e037883a 	mov	sp,fp
8112c000:	dfc00117 	ldw	ra,4(sp)
8112c004:	df000017 	ldw	fp,0(sp)
8112c008:	dec00204 	addi	sp,sp,8
8112c00c:	f800283a 	ret

8112c010 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112c010:	defffe04 	addi	sp,sp,-8
8112c014:	de00012e 	bgeu	sp,et,8112c01c <alt_get_errno+0xc>
8112c018:	003b68fa 	trap	3
8112c01c:	dfc00115 	stw	ra,4(sp)
8112c020:	df000015 	stw	fp,0(sp)
8112c024:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112c028:	d0a01017 	ldw	r2,-32704(gp)
8112c02c:	10000326 	beq	r2,zero,8112c03c <alt_get_errno+0x2c>
8112c030:	d0a01017 	ldw	r2,-32704(gp)
8112c034:	103ee83a 	callr	r2
8112c038:	00000106 	br	8112c040 <alt_get_errno+0x30>
8112c03c:	d0a06804 	addi	r2,gp,-32352
}
8112c040:	e037883a 	mov	sp,fp
8112c044:	dfc00117 	ldw	ra,4(sp)
8112c048:	df000017 	ldw	fp,0(sp)
8112c04c:	dec00204 	addi	sp,sp,8
8112c050:	f800283a 	ret

8112c054 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
8112c054:	defff904 	addi	sp,sp,-28
8112c058:	de00012e 	bgeu	sp,et,8112c060 <lseek+0xc>
8112c05c:	003b68fa 	trap	3
8112c060:	dfc00615 	stw	ra,24(sp)
8112c064:	df000515 	stw	fp,20(sp)
8112c068:	df000504 	addi	fp,sp,20
8112c06c:	e13ffd15 	stw	r4,-12(fp)
8112c070:	e17ffe15 	stw	r5,-8(fp)
8112c074:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
8112c078:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112c07c:	e0bffd17 	ldw	r2,-12(fp)
8112c080:	10000616 	blt	r2,zero,8112c09c <lseek+0x48>
8112c084:	e0bffd17 	ldw	r2,-12(fp)
8112c088:	10c00324 	muli	r3,r2,12
8112c08c:	00a04534 	movhi	r2,33044
8112c090:	1095d504 	addi	r2,r2,22356
8112c094:	1885883a 	add	r2,r3,r2
8112c098:	00000106 	br	8112c0a0 <lseek+0x4c>
8112c09c:	0005883a 	mov	r2,zero
8112c0a0:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
8112c0a4:	e0bffc17 	ldw	r2,-16(fp)
8112c0a8:	10001026 	beq	r2,zero,8112c0ec <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
8112c0ac:	e0bffc17 	ldw	r2,-16(fp)
8112c0b0:	10800017 	ldw	r2,0(r2)
8112c0b4:	10800717 	ldw	r2,28(r2)
8112c0b8:	10000926 	beq	r2,zero,8112c0e0 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
8112c0bc:	e0bffc17 	ldw	r2,-16(fp)
8112c0c0:	10800017 	ldw	r2,0(r2)
8112c0c4:	10800717 	ldw	r2,28(r2)
8112c0c8:	e1bfff17 	ldw	r6,-4(fp)
8112c0cc:	e17ffe17 	ldw	r5,-8(fp)
8112c0d0:	e13ffc17 	ldw	r4,-16(fp)
8112c0d4:	103ee83a 	callr	r2
8112c0d8:	e0bffb15 	stw	r2,-20(fp)
8112c0dc:	00000506 	br	8112c0f4 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
8112c0e0:	00bfde84 	movi	r2,-134
8112c0e4:	e0bffb15 	stw	r2,-20(fp)
8112c0e8:	00000206 	br	8112c0f4 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
8112c0ec:	00bfebc4 	movi	r2,-81
8112c0f0:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
8112c0f4:	e0bffb17 	ldw	r2,-20(fp)
8112c0f8:	1000070e 	bge	r2,zero,8112c118 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
8112c0fc:	112c0100 	call	8112c010 <alt_get_errno>
8112c100:	1007883a 	mov	r3,r2
8112c104:	e0bffb17 	ldw	r2,-20(fp)
8112c108:	0085c83a 	sub	r2,zero,r2
8112c10c:	18800015 	stw	r2,0(r3)
    rc = -1;
8112c110:	00bfffc4 	movi	r2,-1
8112c114:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
8112c118:	e0bffb17 	ldw	r2,-20(fp)
}
8112c11c:	e037883a 	mov	sp,fp
8112c120:	dfc00117 	ldw	ra,4(sp)
8112c124:	df000017 	ldw	fp,0(sp)
8112c128:	dec00204 	addi	sp,sp,8
8112c12c:	f800283a 	ret

8112c130 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
8112c130:	defff904 	addi	sp,sp,-28
8112c134:	de00012e 	bgeu	sp,et,8112c13c <alt_main+0xc>
8112c138:	003b68fa 	trap	3
8112c13c:	dfc00615 	stw	ra,24(sp)
8112c140:	df000515 	stw	fp,20(sp)
8112c144:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
8112c148:	d0a01217 	ldw	r2,-32696(gp)
8112c14c:	10800058 	cmpnei	r2,r2,1
8112c150:	1000031e 	bne	r2,zero,8112c160 <alt_main+0x30>
8112c154:	01204534 	movhi	r4,33044
8112c158:	21122204 	addi	r4,r4,18568
8112c15c:	112bbac0 	call	8112bbac <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
8112c160:	0009883a 	mov	r4,zero
8112c164:	1136ad40 	call	81136ad4 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
8112c168:	d0a01217 	ldw	r2,-32696(gp)
8112c16c:	10800058 	cmpnei	r2,r2,1
8112c170:	1000031e 	bne	r2,zero,8112c180 <alt_main+0x50>
8112c174:	01204534 	movhi	r4,33044
8112c178:	21123004 	addi	r4,r4,18624
8112c17c:	112bbac0 	call	8112bbac <alt_log_printf_proc>
  ALT_OS_INIT();
8112c180:	112d71c0 	call	8112d71c <OSInit>
8112c184:	01000044 	movi	r4,1
8112c188:	11334380 	call	81133438 <OSSemCreate>
8112c18c:	d0a07b15 	stw	r2,-32276(gp)
8112c190:	01000044 	movi	r4,1
8112c194:	11334380 	call	81133438 <OSSemCreate>
8112c198:	d0a07d15 	stw	r2,-32268(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
8112c19c:	d0a01217 	ldw	r2,-32696(gp)
8112c1a0:	10800058 	cmpnei	r2,r2,1
8112c1a4:	1000031e 	bne	r2,zero,8112c1b4 <alt_main+0x84>
8112c1a8:	01204534 	movhi	r4,33044
8112c1ac:	21123e04 	addi	r4,r4,18680
8112c1b0:	112bbac0 	call	8112bbac <alt_log_printf_proc>
8112c1b4:	d0a06f04 	addi	r2,gp,-32324
8112c1b8:	e0bffc15 	stw	r2,-16(fp)
8112c1bc:	00800044 	movi	r2,1
8112c1c0:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8112c1c4:	e0bffd0b 	ldhu	r2,-12(fp)
8112c1c8:	1009883a 	mov	r4,r2
8112c1cc:	11334380 	call	81133438 <OSSemCreate>
8112c1d0:	1007883a 	mov	r3,r2
8112c1d4:	e0bffc17 	ldw	r2,-16(fp)
8112c1d8:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
8112c1dc:	d0a01217 	ldw	r2,-32696(gp)
8112c1e0:	10800058 	cmpnei	r2,r2,1
8112c1e4:	1000031e 	bne	r2,zero,8112c1f4 <alt_main+0xc4>
8112c1e8:	01204534 	movhi	r4,33044
8112c1ec:	21124c04 	addi	r4,r4,18736
8112c1f0:	112bbac0 	call	8112bbac <alt_log_printf_proc>
  alt_sys_init();
8112c1f4:	1136b140 	call	81136b14 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
8112c1f8:	d0a01217 	ldw	r2,-32696(gp)
8112c1fc:	10800058 	cmpnei	r2,r2,1
8112c200:	1000031e 	bne	r2,zero,8112c210 <alt_main+0xe0>
8112c204:	01204534 	movhi	r4,33044
8112c208:	21125604 	addi	r4,r4,18776
8112c20c:	112bbac0 	call	8112bbac <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
8112c210:	d0a01217 	ldw	r2,-32696(gp)
8112c214:	10800058 	cmpnei	r2,r2,1
8112c218:	1000031e 	bne	r2,zero,8112c228 <alt_main+0xf8>
8112c21c:	01204534 	movhi	r4,33044
8112c220:	21125f04 	addi	r4,r4,18812
8112c224:	112bbac0 	call	8112bbac <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
8112c228:	01a04534 	movhi	r6,33044
8112c22c:	31926704 	addi	r6,r6,18844
8112c230:	01604534 	movhi	r5,33044
8112c234:	29526c04 	addi	r5,r5,18864
8112c238:	01204534 	movhi	r4,33044
8112c23c:	21126c04 	addi	r4,r4,18864
8112c240:	113f4040 	call	8113f404 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
8112c244:	d0a01217 	ldw	r2,-32696(gp)
8112c248:	10800058 	cmpnei	r2,r2,1
8112c24c:	1000031e 	bne	r2,zero,8112c25c <alt_main+0x12c>
8112c250:	01204534 	movhi	r4,33044
8112c254:	21127004 	addi	r4,r4,18880
8112c258:	112bbac0 	call	8112bbac <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
8112c25c:	d0a07517 	ldw	r2,-32300(gp)
8112c260:	d0e07617 	ldw	r3,-32296(gp)
8112c264:	d1207717 	ldw	r4,-32292(gp)
8112c268:	200d883a 	mov	r6,r4
8112c26c:	180b883a 	mov	r5,r3
8112c270:	1009883a 	mov	r4,r2
8112c274:	110eb6c0 	call	8110eb6c <main>
8112c278:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
8112c27c:	01000044 	movi	r4,1
8112c280:	112b05c0 	call	8112b05c <close>
  exit (result);
8112c284:	e13ffb17 	ldw	r4,-20(fp)
8112c288:	113fbb80 	call	8113fbb8 <exit>

8112c28c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112c28c:	defffe04 	addi	sp,sp,-8
8112c290:	de00012e 	bgeu	sp,et,8112c298 <alt_get_errno+0xc>
8112c294:	003b68fa 	trap	3
8112c298:	dfc00115 	stw	ra,4(sp)
8112c29c:	df000015 	stw	fp,0(sp)
8112c2a0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112c2a4:	d0a01017 	ldw	r2,-32704(gp)
8112c2a8:	10000326 	beq	r2,zero,8112c2b8 <alt_get_errno+0x2c>
8112c2ac:	d0a01017 	ldw	r2,-32704(gp)
8112c2b0:	103ee83a 	callr	r2
8112c2b4:	00000106 	br	8112c2bc <alt_get_errno+0x30>
8112c2b8:	d0a06804 	addi	r2,gp,-32352
}
8112c2bc:	e037883a 	mov	sp,fp
8112c2c0:	dfc00117 	ldw	ra,4(sp)
8112c2c4:	df000017 	ldw	fp,0(sp)
8112c2c8:	dec00204 	addi	sp,sp,8
8112c2cc:	f800283a 	ret

8112c2d0 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
8112c2d0:	defffd04 	addi	sp,sp,-12
8112c2d4:	de00012e 	bgeu	sp,et,8112c2dc <alt_file_locked+0xc>
8112c2d8:	003b68fa 	trap	3
8112c2dc:	df000215 	stw	fp,8(sp)
8112c2e0:	df000204 	addi	fp,sp,8
8112c2e4:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
8112c2e8:	e0bfff17 	ldw	r2,-4(fp)
8112c2ec:	10800217 	ldw	r2,8(r2)
8112c2f0:	10d00034 	orhi	r3,r2,16384
8112c2f4:	e0bfff17 	ldw	r2,-4(fp)
8112c2f8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
8112c2fc:	e03ffe15 	stw	zero,-8(fp)
8112c300:	00001d06 	br	8112c378 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
8112c304:	00a04534 	movhi	r2,33044
8112c308:	1095d504 	addi	r2,r2,22356
8112c30c:	e0fffe17 	ldw	r3,-8(fp)
8112c310:	18c00324 	muli	r3,r3,12
8112c314:	10c5883a 	add	r2,r2,r3
8112c318:	10c00017 	ldw	r3,0(r2)
8112c31c:	e0bfff17 	ldw	r2,-4(fp)
8112c320:	10800017 	ldw	r2,0(r2)
8112c324:	1880111e 	bne	r3,r2,8112c36c <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
8112c328:	00a04534 	movhi	r2,33044
8112c32c:	1095d504 	addi	r2,r2,22356
8112c330:	e0fffe17 	ldw	r3,-8(fp)
8112c334:	18c00324 	muli	r3,r3,12
8112c338:	10c5883a 	add	r2,r2,r3
8112c33c:	10800204 	addi	r2,r2,8
8112c340:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
8112c344:	1000090e 	bge	r2,zero,8112c36c <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
8112c348:	e0bffe17 	ldw	r2,-8(fp)
8112c34c:	10c00324 	muli	r3,r2,12
8112c350:	00a04534 	movhi	r2,33044
8112c354:	1095d504 	addi	r2,r2,22356
8112c358:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
8112c35c:	e0bfff17 	ldw	r2,-4(fp)
8112c360:	18800226 	beq	r3,r2,8112c36c <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
8112c364:	00bffcc4 	movi	r2,-13
8112c368:	00000806 	br	8112c38c <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
8112c36c:	e0bffe17 	ldw	r2,-8(fp)
8112c370:	10800044 	addi	r2,r2,1
8112c374:	e0bffe15 	stw	r2,-8(fp)
8112c378:	d0a00f17 	ldw	r2,-32708(gp)
8112c37c:	1007883a 	mov	r3,r2
8112c380:	e0bffe17 	ldw	r2,-8(fp)
8112c384:	18bfdf2e 	bgeu	r3,r2,8112c304 <__reset+0xfb10c304>
    }
  }
  
  /* The device is not locked */
 
  return 0;
8112c388:	0005883a 	mov	r2,zero
}
8112c38c:	e037883a 	mov	sp,fp
8112c390:	df000017 	ldw	fp,0(sp)
8112c394:	dec00104 	addi	sp,sp,4
8112c398:	f800283a 	ret

8112c39c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
8112c39c:	defff604 	addi	sp,sp,-40
8112c3a0:	de00012e 	bgeu	sp,et,8112c3a8 <open+0xc>
8112c3a4:	003b68fa 	trap	3
8112c3a8:	dfc00915 	stw	ra,36(sp)
8112c3ac:	df000815 	stw	fp,32(sp)
8112c3b0:	df000804 	addi	fp,sp,32
8112c3b4:	e13ffd15 	stw	r4,-12(fp)
8112c3b8:	e17ffe15 	stw	r5,-8(fp)
8112c3bc:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
8112c3c0:	00bfffc4 	movi	r2,-1
8112c3c4:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
8112c3c8:	00bffb44 	movi	r2,-19
8112c3cc:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
8112c3d0:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
8112c3d4:	d1600d04 	addi	r5,gp,-32716
8112c3d8:	e13ffd17 	ldw	r4,-12(fp)
8112c3dc:	113ede40 	call	8113ede4 <alt_find_dev>
8112c3e0:	e0bff815 	stw	r2,-32(fp)
8112c3e4:	e0bff817 	ldw	r2,-32(fp)
8112c3e8:	1000051e 	bne	r2,zero,8112c400 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
8112c3ec:	e13ffd17 	ldw	r4,-12(fp)
8112c3f0:	113ee7c0 	call	8113ee7c <alt_find_file>
8112c3f4:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
8112c3f8:	00800044 	movi	r2,1
8112c3fc:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
8112c400:	e0bff817 	ldw	r2,-32(fp)
8112c404:	10002926 	beq	r2,zero,8112c4ac <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
8112c408:	e13ff817 	ldw	r4,-32(fp)
8112c40c:	113ef8c0 	call	8113ef8c <alt_get_fd>
8112c410:	e0bff915 	stw	r2,-28(fp)
8112c414:	e0bff917 	ldw	r2,-28(fp)
8112c418:	1000030e 	bge	r2,zero,8112c428 <open+0x8c>
    {
      status = index;
8112c41c:	e0bff917 	ldw	r2,-28(fp)
8112c420:	e0bffa15 	stw	r2,-24(fp)
8112c424:	00002306 	br	8112c4b4 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
8112c428:	e0bff917 	ldw	r2,-28(fp)
8112c42c:	10c00324 	muli	r3,r2,12
8112c430:	00a04534 	movhi	r2,33044
8112c434:	1095d504 	addi	r2,r2,22356
8112c438:	1885883a 	add	r2,r3,r2
8112c43c:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
8112c440:	e0fffe17 	ldw	r3,-8(fp)
8112c444:	00900034 	movhi	r2,16384
8112c448:	10bfffc4 	addi	r2,r2,-1
8112c44c:	1886703a 	and	r3,r3,r2
8112c450:	e0bffc17 	ldw	r2,-16(fp)
8112c454:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
8112c458:	e0bffb17 	ldw	r2,-20(fp)
8112c45c:	1000051e 	bne	r2,zero,8112c474 <open+0xd8>
8112c460:	e13ffc17 	ldw	r4,-16(fp)
8112c464:	112c2d00 	call	8112c2d0 <alt_file_locked>
8112c468:	e0bffa15 	stw	r2,-24(fp)
8112c46c:	e0bffa17 	ldw	r2,-24(fp)
8112c470:	10001016 	blt	r2,zero,8112c4b4 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
8112c474:	e0bff817 	ldw	r2,-32(fp)
8112c478:	10800317 	ldw	r2,12(r2)
8112c47c:	10000826 	beq	r2,zero,8112c4a0 <open+0x104>
8112c480:	e0bff817 	ldw	r2,-32(fp)
8112c484:	10800317 	ldw	r2,12(r2)
8112c488:	e1ffff17 	ldw	r7,-4(fp)
8112c48c:	e1bffe17 	ldw	r6,-8(fp)
8112c490:	e17ffd17 	ldw	r5,-12(fp)
8112c494:	e13ffc17 	ldw	r4,-16(fp)
8112c498:	103ee83a 	callr	r2
8112c49c:	00000106 	br	8112c4a4 <open+0x108>
8112c4a0:	0005883a 	mov	r2,zero
8112c4a4:	e0bffa15 	stw	r2,-24(fp)
8112c4a8:	00000206 	br	8112c4b4 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
8112c4ac:	00bffb44 	movi	r2,-19
8112c4b0:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
8112c4b4:	e0bffa17 	ldw	r2,-24(fp)
8112c4b8:	1000090e 	bge	r2,zero,8112c4e0 <open+0x144>
  {
    alt_release_fd (index);  
8112c4bc:	e13ff917 	ldw	r4,-28(fp)
8112c4c0:	112c6400 	call	8112c640 <alt_release_fd>
    ALT_ERRNO = -status;
8112c4c4:	112c28c0 	call	8112c28c <alt_get_errno>
8112c4c8:	1007883a 	mov	r3,r2
8112c4cc:	e0bffa17 	ldw	r2,-24(fp)
8112c4d0:	0085c83a 	sub	r2,zero,r2
8112c4d4:	18800015 	stw	r2,0(r3)
    return -1;
8112c4d8:	00bfffc4 	movi	r2,-1
8112c4dc:	00000106 	br	8112c4e4 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
8112c4e0:	e0bff917 	ldw	r2,-28(fp)
}
8112c4e4:	e037883a 	mov	sp,fp
8112c4e8:	dfc00117 	ldw	ra,4(sp)
8112c4ec:	df000017 	ldw	fp,0(sp)
8112c4f0:	dec00204 	addi	sp,sp,8
8112c4f4:	f800283a 	ret

8112c4f8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112c4f8:	defffe04 	addi	sp,sp,-8
8112c4fc:	de00012e 	bgeu	sp,et,8112c504 <alt_get_errno+0xc>
8112c500:	003b68fa 	trap	3
8112c504:	dfc00115 	stw	ra,4(sp)
8112c508:	df000015 	stw	fp,0(sp)
8112c50c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112c510:	d0a01017 	ldw	r2,-32704(gp)
8112c514:	10000326 	beq	r2,zero,8112c524 <alt_get_errno+0x2c>
8112c518:	d0a01017 	ldw	r2,-32704(gp)
8112c51c:	103ee83a 	callr	r2
8112c520:	00000106 	br	8112c528 <alt_get_errno+0x30>
8112c524:	d0a06804 	addi	r2,gp,-32352
}
8112c528:	e037883a 	mov	sp,fp
8112c52c:	dfc00117 	ldw	ra,4(sp)
8112c530:	df000017 	ldw	fp,0(sp)
8112c534:	dec00204 	addi	sp,sp,8
8112c538:	f800283a 	ret

8112c53c <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
8112c53c:	defff904 	addi	sp,sp,-28
8112c540:	de00012e 	bgeu	sp,et,8112c548 <read+0xc>
8112c544:	003b68fa 	trap	3
8112c548:	dfc00615 	stw	ra,24(sp)
8112c54c:	df000515 	stw	fp,20(sp)
8112c550:	df000504 	addi	fp,sp,20
8112c554:	e13ffd15 	stw	r4,-12(fp)
8112c558:	e17ffe15 	stw	r5,-8(fp)
8112c55c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112c560:	e0bffd17 	ldw	r2,-12(fp)
8112c564:	10000616 	blt	r2,zero,8112c580 <read+0x44>
8112c568:	e0bffd17 	ldw	r2,-12(fp)
8112c56c:	10c00324 	muli	r3,r2,12
8112c570:	00a04534 	movhi	r2,33044
8112c574:	1095d504 	addi	r2,r2,22356
8112c578:	1885883a 	add	r2,r3,r2
8112c57c:	00000106 	br	8112c584 <read+0x48>
8112c580:	0005883a 	mov	r2,zero
8112c584:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
8112c588:	e0bffb17 	ldw	r2,-20(fp)
8112c58c:	10002226 	beq	r2,zero,8112c618 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
8112c590:	e0bffb17 	ldw	r2,-20(fp)
8112c594:	10800217 	ldw	r2,8(r2)
8112c598:	108000cc 	andi	r2,r2,3
8112c59c:	10800060 	cmpeqi	r2,r2,1
8112c5a0:	1000181e 	bne	r2,zero,8112c604 <read+0xc8>
        (fd->dev->read))
8112c5a4:	e0bffb17 	ldw	r2,-20(fp)
8112c5a8:	10800017 	ldw	r2,0(r2)
8112c5ac:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
8112c5b0:	10001426 	beq	r2,zero,8112c604 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
8112c5b4:	e0bffb17 	ldw	r2,-20(fp)
8112c5b8:	10800017 	ldw	r2,0(r2)
8112c5bc:	10800517 	ldw	r2,20(r2)
8112c5c0:	e0ffff17 	ldw	r3,-4(fp)
8112c5c4:	180d883a 	mov	r6,r3
8112c5c8:	e17ffe17 	ldw	r5,-8(fp)
8112c5cc:	e13ffb17 	ldw	r4,-20(fp)
8112c5d0:	103ee83a 	callr	r2
8112c5d4:	e0bffc15 	stw	r2,-16(fp)
8112c5d8:	e0bffc17 	ldw	r2,-16(fp)
8112c5dc:	1000070e 	bge	r2,zero,8112c5fc <read+0xc0>
        {
          ALT_ERRNO = -rval;
8112c5e0:	112c4f80 	call	8112c4f8 <alt_get_errno>
8112c5e4:	1007883a 	mov	r3,r2
8112c5e8:	e0bffc17 	ldw	r2,-16(fp)
8112c5ec:	0085c83a 	sub	r2,zero,r2
8112c5f0:	18800015 	stw	r2,0(r3)
          return -1;
8112c5f4:	00bfffc4 	movi	r2,-1
8112c5f8:	00000c06 	br	8112c62c <read+0xf0>
        }
        return rval;
8112c5fc:	e0bffc17 	ldw	r2,-16(fp)
8112c600:	00000a06 	br	8112c62c <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
8112c604:	112c4f80 	call	8112c4f8 <alt_get_errno>
8112c608:	1007883a 	mov	r3,r2
8112c60c:	00800344 	movi	r2,13
8112c610:	18800015 	stw	r2,0(r3)
8112c614:	00000406 	br	8112c628 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
8112c618:	112c4f80 	call	8112c4f8 <alt_get_errno>
8112c61c:	1007883a 	mov	r3,r2
8112c620:	00801444 	movi	r2,81
8112c624:	18800015 	stw	r2,0(r3)
  }
  return -1;
8112c628:	00bfffc4 	movi	r2,-1
}
8112c62c:	e037883a 	mov	sp,fp
8112c630:	dfc00117 	ldw	ra,4(sp)
8112c634:	df000017 	ldw	fp,0(sp)
8112c638:	dec00204 	addi	sp,sp,8
8112c63c:	f800283a 	ret

8112c640 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
8112c640:	defffe04 	addi	sp,sp,-8
8112c644:	de00012e 	bgeu	sp,et,8112c64c <alt_release_fd+0xc>
8112c648:	003b68fa 	trap	3
8112c64c:	df000115 	stw	fp,4(sp)
8112c650:	df000104 	addi	fp,sp,4
8112c654:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
8112c658:	e0bfff17 	ldw	r2,-4(fp)
8112c65c:	108000d0 	cmplti	r2,r2,3
8112c660:	10000d1e 	bne	r2,zero,8112c698 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
8112c664:	00a04534 	movhi	r2,33044
8112c668:	1095d504 	addi	r2,r2,22356
8112c66c:	e0ffff17 	ldw	r3,-4(fp)
8112c670:	18c00324 	muli	r3,r3,12
8112c674:	10c5883a 	add	r2,r2,r3
8112c678:	10800204 	addi	r2,r2,8
8112c67c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
8112c680:	00a04534 	movhi	r2,33044
8112c684:	1095d504 	addi	r2,r2,22356
8112c688:	e0ffff17 	ldw	r3,-4(fp)
8112c68c:	18c00324 	muli	r3,r3,12
8112c690:	10c5883a 	add	r2,r2,r3
8112c694:	10000015 	stw	zero,0(r2)
  }
}
8112c698:	0001883a 	nop
8112c69c:	e037883a 	mov	sp,fp
8112c6a0:	df000017 	ldw	fp,0(sp)
8112c6a4:	dec00104 	addi	sp,sp,4
8112c6a8:	f800283a 	ret

8112c6ac <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
8112c6ac:	defff604 	addi	sp,sp,-40
8112c6b0:	de00012e 	bgeu	sp,et,8112c6b8 <sbrk+0xc>
8112c6b4:	003b68fa 	trap	3
8112c6b8:	df000915 	stw	fp,36(sp)
8112c6bc:	df000904 	addi	fp,sp,36
8112c6c0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112c6c4:	0005303a 	rdctl	r2,status
8112c6c8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112c6cc:	e0fffe17 	ldw	r3,-8(fp)
8112c6d0:	00bfff84 	movi	r2,-2
8112c6d4:	1884703a 	and	r2,r3,r2
8112c6d8:	1001703a 	wrctl	status,r2
  
  return context;
8112c6dc:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
8112c6e0:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
8112c6e4:	d0a01317 	ldw	r2,-32692(gp)
8112c6e8:	10c000c4 	addi	r3,r2,3
8112c6ec:	00bfff04 	movi	r2,-4
8112c6f0:	1884703a 	and	r2,r3,r2
8112c6f4:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
8112c6f8:	d0e01317 	ldw	r3,-32692(gp)
8112c6fc:	e0bfff17 	ldw	r2,-4(fp)
8112c700:	1887883a 	add	r3,r3,r2
8112c704:	00a04834 	movhi	r2,33056
8112c708:	10a80004 	addi	r2,r2,-24576
8112c70c:	10c0062e 	bgeu	r2,r3,8112c728 <sbrk+0x7c>
8112c710:	e0bff817 	ldw	r2,-32(fp)
8112c714:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112c718:	e0bff717 	ldw	r2,-36(fp)
8112c71c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
8112c720:	00bfffc4 	movi	r2,-1
8112c724:	00001c06 	br	8112c798 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
8112c728:	d0a01317 	ldw	r2,-32692(gp)
8112c72c:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
8112c730:	d0e01317 	ldw	r3,-32692(gp)
8112c734:	e0bfff17 	ldw	r2,-4(fp)
8112c738:	1885883a 	add	r2,r3,r2
8112c73c:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
8112c740:	c005883a 	mov	r2,et
8112c744:	e0bff915 	stw	r2,-28(fp)

  return limit; 
8112c748:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
8112c74c:	e0bffa17 	ldw	r2,-24(fp)
8112c750:	18800c1e 	bne	r3,r2,8112c784 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
8112c754:	d805883a 	mov	r2,sp
8112c758:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
8112c75c:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
8112c760:	d0e01317 	ldw	r3,-32692(gp)
8112c764:	18800136 	bltu	r3,r2,8112c76c <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
8112c768:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
8112c76c:	d0a01317 	ldw	r2,-32692(gp)
8112c770:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
8112c774:	e0bffc17 	ldw	r2,-16(fp)
8112c778:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
8112c77c:	e0bffc17 	ldw	r2,-16(fp)
8112c780:	1031883a 	mov	et,r2
8112c784:	e0bff817 	ldw	r2,-32(fp)
8112c788:	e0bffd15 	stw	r2,-12(fp)
8112c78c:	e0bffd17 	ldw	r2,-12(fp)
8112c790:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
8112c794:	e0bffa17 	ldw	r2,-24(fp)
} 
8112c798:	e037883a 	mov	sp,fp
8112c79c:	df000017 	ldw	fp,0(sp)
8112c7a0:	dec00104 	addi	sp,sp,4
8112c7a4:	f800283a 	ret

8112c7a8 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
8112c7a8:	defffa04 	addi	sp,sp,-24
8112c7ac:	de00012e 	bgeu	sp,et,8112c7b4 <alt_alarm_stop+0xc>
8112c7b0:	003b68fa 	trap	3
8112c7b4:	df000515 	stw	fp,20(sp)
8112c7b8:	df000504 	addi	fp,sp,20
8112c7bc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112c7c0:	0005303a 	rdctl	r2,status
8112c7c4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112c7c8:	e0fffc17 	ldw	r3,-16(fp)
8112c7cc:	00bfff84 	movi	r2,-2
8112c7d0:	1884703a 	and	r2,r3,r2
8112c7d4:	1001703a 	wrctl	status,r2
  
  return context;
8112c7d8:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
8112c7dc:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
8112c7e0:	e0bfff17 	ldw	r2,-4(fp)
8112c7e4:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
8112c7e8:	e0bffd17 	ldw	r2,-12(fp)
8112c7ec:	10800017 	ldw	r2,0(r2)
8112c7f0:	e0fffd17 	ldw	r3,-12(fp)
8112c7f4:	18c00117 	ldw	r3,4(r3)
8112c7f8:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
8112c7fc:	e0bffd17 	ldw	r2,-12(fp)
8112c800:	10800117 	ldw	r2,4(r2)
8112c804:	e0fffd17 	ldw	r3,-12(fp)
8112c808:	18c00017 	ldw	r3,0(r3)
8112c80c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
8112c810:	e0bffd17 	ldw	r2,-12(fp)
8112c814:	e0fffd17 	ldw	r3,-12(fp)
8112c818:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
8112c81c:	e0bffd17 	ldw	r2,-12(fp)
8112c820:	e0fffd17 	ldw	r3,-12(fp)
8112c824:	10c00015 	stw	r3,0(r2)
8112c828:	e0bffb17 	ldw	r2,-20(fp)
8112c82c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112c830:	e0bffe17 	ldw	r2,-8(fp)
8112c834:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
8112c838:	0001883a 	nop
8112c83c:	e037883a 	mov	sp,fp
8112c840:	df000017 	ldw	fp,0(sp)
8112c844:	dec00104 	addi	sp,sp,4
8112c848:	f800283a 	ret

8112c84c <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
8112c84c:	defffb04 	addi	sp,sp,-20
8112c850:	de00012e 	bgeu	sp,et,8112c858 <alt_tick+0xc>
8112c854:	003b68fa 	trap	3
8112c858:	dfc00415 	stw	ra,16(sp)
8112c85c:	df000315 	stw	fp,12(sp)
8112c860:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
8112c864:	d0a01417 	ldw	r2,-32688(gp)
8112c868:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
8112c86c:	d0a07917 	ldw	r2,-32284(gp)
8112c870:	10800044 	addi	r2,r2,1
8112c874:	d0a07915 	stw	r2,-32284(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
8112c878:	00002e06 	br	8112c934 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
8112c87c:	e0bffd17 	ldw	r2,-12(fp)
8112c880:	10800017 	ldw	r2,0(r2)
8112c884:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
8112c888:	e0bffd17 	ldw	r2,-12(fp)
8112c88c:	10800403 	ldbu	r2,16(r2)
8112c890:	10803fcc 	andi	r2,r2,255
8112c894:	10000426 	beq	r2,zero,8112c8a8 <alt_tick+0x5c>
8112c898:	d0a07917 	ldw	r2,-32284(gp)
8112c89c:	1000021e 	bne	r2,zero,8112c8a8 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
8112c8a0:	e0bffd17 	ldw	r2,-12(fp)
8112c8a4:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
8112c8a8:	e0bffd17 	ldw	r2,-12(fp)
8112c8ac:	10800217 	ldw	r2,8(r2)
8112c8b0:	d0e07917 	ldw	r3,-32284(gp)
8112c8b4:	18801d36 	bltu	r3,r2,8112c92c <alt_tick+0xe0>
8112c8b8:	e0bffd17 	ldw	r2,-12(fp)
8112c8bc:	10800403 	ldbu	r2,16(r2)
8112c8c0:	10803fcc 	andi	r2,r2,255
8112c8c4:	1000191e 	bne	r2,zero,8112c92c <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
8112c8c8:	e0bffd17 	ldw	r2,-12(fp)
8112c8cc:	10800317 	ldw	r2,12(r2)
8112c8d0:	e0fffd17 	ldw	r3,-12(fp)
8112c8d4:	18c00517 	ldw	r3,20(r3)
8112c8d8:	1809883a 	mov	r4,r3
8112c8dc:	103ee83a 	callr	r2
8112c8e0:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
8112c8e4:	e0bfff17 	ldw	r2,-4(fp)
8112c8e8:	1000031e 	bne	r2,zero,8112c8f8 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
8112c8ec:	e13ffd17 	ldw	r4,-12(fp)
8112c8f0:	112c7a80 	call	8112c7a8 <alt_alarm_stop>
8112c8f4:	00000d06 	br	8112c92c <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
8112c8f8:	e0bffd17 	ldw	r2,-12(fp)
8112c8fc:	10c00217 	ldw	r3,8(r2)
8112c900:	e0bfff17 	ldw	r2,-4(fp)
8112c904:	1887883a 	add	r3,r3,r2
8112c908:	e0bffd17 	ldw	r2,-12(fp)
8112c90c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
8112c910:	e0bffd17 	ldw	r2,-12(fp)
8112c914:	10c00217 	ldw	r3,8(r2)
8112c918:	d0a07917 	ldw	r2,-32284(gp)
8112c91c:	1880032e 	bgeu	r3,r2,8112c92c <alt_tick+0xe0>
        {
          alarm->rollover = 1;
8112c920:	e0bffd17 	ldw	r2,-12(fp)
8112c924:	00c00044 	movi	r3,1
8112c928:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
8112c92c:	e0bffe17 	ldw	r2,-8(fp)
8112c930:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
8112c934:	e0fffd17 	ldw	r3,-12(fp)
8112c938:	d0a01404 	addi	r2,gp,-32688
8112c93c:	18bfcf1e 	bne	r3,r2,8112c87c <__reset+0xfb10c87c>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
8112c940:	112db7c0 	call	8112db7c <OSTimeTick>
}
8112c944:	0001883a 	nop
8112c948:	e037883a 	mov	sp,fp
8112c94c:	dfc00117 	ldw	ra,4(sp)
8112c950:	df000017 	ldw	fp,0(sp)
8112c954:	dec00204 	addi	sp,sp,8
8112c958:	f800283a 	ret

8112c95c <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
8112c95c:	defffb04 	addi	sp,sp,-20
8112c960:	de00012e 	bgeu	sp,et,8112c968 <usleep+0xc>
8112c964:	003b68fa 	trap	3
8112c968:	dfc00415 	stw	ra,16(sp)
8112c96c:	df000315 	stw	fp,12(sp)
8112c970:	df000304 	addi	fp,sp,12
8112c974:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
8112c978:	d0a08103 	ldbu	r2,-32252(gp)
8112c97c:	10803fcc 	andi	r2,r2,255
8112c980:	1000031e 	bne	r2,zero,8112c990 <usleep+0x34>
  {
    return alt_busy_sleep (us);
8112c984:	e13fff17 	ldw	r4,-4(fp)
8112c988:	112aee80 	call	8112aee8 <alt_busy_sleep>
8112c98c:	00003d06 	br	8112ca84 <usleep+0x128>
8112c990:	d0a07817 	ldw	r2,-32288(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
8112c994:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
8112c998:	e0ffff17 	ldw	r3,-4(fp)
8112c99c:	0090c734 	movhi	r2,17180
8112c9a0:	10b7a0c4 	addi	r2,r2,-8573
8112c9a4:	1888383a 	mulxuu	r4,r3,r2
8112c9a8:	1885383a 	mul	r2,r3,r2
8112c9ac:	1013883a 	mov	r9,r2
8112c9b0:	2015883a 	mov	r10,r4
8112c9b4:	5006d4ba 	srli	r3,r10,18
8112c9b8:	e0bffe17 	ldw	r2,-8(fp)
8112c9bc:	1893383a 	mul	r9,r3,r2
8112c9c0:	e0ffff17 	ldw	r3,-4(fp)
8112c9c4:	0090c734 	movhi	r2,17180
8112c9c8:	10b7a0c4 	addi	r2,r2,-8573
8112c9cc:	1888383a 	mulxuu	r4,r3,r2
8112c9d0:	1885383a 	mul	r2,r3,r2
8112c9d4:	100f883a 	mov	r7,r2
8112c9d8:	2011883a 	mov	r8,r4
8112c9dc:	4004d4ba 	srli	r2,r8,18
8112c9e0:	010003f4 	movhi	r4,15
8112c9e4:	21109004 	addi	r4,r4,16960
8112c9e8:	1105383a 	mul	r2,r2,r4
8112c9ec:	1885c83a 	sub	r2,r3,r2
8112c9f0:	e0fffe17 	ldw	r3,-8(fp)
8112c9f4:	10c7383a 	mul	r3,r2,r3
8112c9f8:	0090c734 	movhi	r2,17180
8112c9fc:	10b7a0c4 	addi	r2,r2,-8573
8112ca00:	1888383a 	mulxuu	r4,r3,r2
8112ca04:	1885383a 	mul	r2,r3,r2
8112ca08:	100b883a 	mov	r5,r2
8112ca0c:	200d883a 	mov	r6,r4
8112ca10:	3004d4ba 	srli	r2,r6,18
8112ca14:	4885883a 	add	r2,r9,r2
8112ca18:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
8112ca1c:	00000706 	br	8112ca3c <usleep+0xe0>
  {
    OSTimeDly(0xffff);
8112ca20:	013fffd4 	movui	r4,65535
8112ca24:	11354380 	call	81135438 <OSTimeDly>
    ticks -= 0xffff;
8112ca28:	e0fffd17 	ldw	r3,-12(fp)
8112ca2c:	00bffff4 	movhi	r2,65535
8112ca30:	10800044 	addi	r2,r2,1
8112ca34:	1885883a 	add	r2,r3,r2
8112ca38:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
8112ca3c:	e0bffd17 	ldw	r2,-12(fp)
8112ca40:	00ffffd4 	movui	r3,65535
8112ca44:	18bff636 	bltu	r3,r2,8112ca20 <__reset+0xfb10ca20>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
8112ca48:	e0bffd17 	ldw	r2,-12(fp)
8112ca4c:	10bfffcc 	andi	r2,r2,65535
8112ca50:	1009883a 	mov	r4,r2
8112ca54:	11354380 	call	81135438 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
8112ca58:	008003f4 	movhi	r2,15
8112ca5c:	10909004 	addi	r2,r2,16960
8112ca60:	e0fffe17 	ldw	r3,-8(fp)
8112ca64:	10c7203a 	divu	r3,r2,r3
8112ca68:	e0bfff17 	ldw	r2,-4(fp)
8112ca6c:	10c9203a 	divu	r4,r2,r3
8112ca70:	20c7383a 	mul	r3,r4,r3
8112ca74:	10c5c83a 	sub	r2,r2,r3
8112ca78:	1009883a 	mov	r4,r2
8112ca7c:	112aee80 	call	8112aee8 <alt_busy_sleep>

  return 0;  
8112ca80:	0005883a 	mov	r2,zero
}
8112ca84:	e037883a 	mov	sp,fp
8112ca88:	dfc00117 	ldw	ra,4(sp)
8112ca8c:	df000017 	ldw	fp,0(sp)
8112ca90:	dec00204 	addi	sp,sp,8
8112ca94:	f800283a 	ret

8112ca98 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112ca98:	defffe04 	addi	sp,sp,-8
8112ca9c:	de00012e 	bgeu	sp,et,8112caa4 <alt_get_errno+0xc>
8112caa0:	003b68fa 	trap	3
8112caa4:	dfc00115 	stw	ra,4(sp)
8112caa8:	df000015 	stw	fp,0(sp)
8112caac:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112cab0:	d0a01017 	ldw	r2,-32704(gp)
8112cab4:	10000326 	beq	r2,zero,8112cac4 <alt_get_errno+0x2c>
8112cab8:	d0a01017 	ldw	r2,-32704(gp)
8112cabc:	103ee83a 	callr	r2
8112cac0:	00000106 	br	8112cac8 <alt_get_errno+0x30>
8112cac4:	d0a06804 	addi	r2,gp,-32352
}
8112cac8:	e037883a 	mov	sp,fp
8112cacc:	dfc00117 	ldw	ra,4(sp)
8112cad0:	df000017 	ldw	fp,0(sp)
8112cad4:	dec00204 	addi	sp,sp,8
8112cad8:	f800283a 	ret

8112cadc <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
8112cadc:	defff904 	addi	sp,sp,-28
8112cae0:	de00012e 	bgeu	sp,et,8112cae8 <write+0xc>
8112cae4:	003b68fa 	trap	3
8112cae8:	dfc00615 	stw	ra,24(sp)
8112caec:	df000515 	stw	fp,20(sp)
8112caf0:	df000504 	addi	fp,sp,20
8112caf4:	e13ffd15 	stw	r4,-12(fp)
8112caf8:	e17ffe15 	stw	r5,-8(fp)
8112cafc:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112cb00:	e0bffd17 	ldw	r2,-12(fp)
8112cb04:	10000616 	blt	r2,zero,8112cb20 <write+0x44>
8112cb08:	e0bffd17 	ldw	r2,-12(fp)
8112cb0c:	10c00324 	muli	r3,r2,12
8112cb10:	00a04534 	movhi	r2,33044
8112cb14:	1095d504 	addi	r2,r2,22356
8112cb18:	1885883a 	add	r2,r3,r2
8112cb1c:	00000106 	br	8112cb24 <write+0x48>
8112cb20:	0005883a 	mov	r2,zero
8112cb24:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
8112cb28:	e0bffb17 	ldw	r2,-20(fp)
8112cb2c:	10002426 	beq	r2,zero,8112cbc0 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
8112cb30:	e0bffb17 	ldw	r2,-20(fp)
8112cb34:	10800217 	ldw	r2,8(r2)
8112cb38:	108000cc 	andi	r2,r2,3
8112cb3c:	10001b26 	beq	r2,zero,8112cbac <write+0xd0>
8112cb40:	e0bffb17 	ldw	r2,-20(fp)
8112cb44:	10800017 	ldw	r2,0(r2)
8112cb48:	10800617 	ldw	r2,24(r2)
8112cb4c:	10001726 	beq	r2,zero,8112cbac <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
8112cb50:	e17fff17 	ldw	r5,-4(fp)
8112cb54:	e13ffe17 	ldw	r4,-8(fp)
8112cb58:	112be5c0 	call	8112be5c <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
8112cb5c:	e0bffb17 	ldw	r2,-20(fp)
8112cb60:	10800017 	ldw	r2,0(r2)
8112cb64:	10800617 	ldw	r2,24(r2)
8112cb68:	e0ffff17 	ldw	r3,-4(fp)
8112cb6c:	180d883a 	mov	r6,r3
8112cb70:	e17ffe17 	ldw	r5,-8(fp)
8112cb74:	e13ffb17 	ldw	r4,-20(fp)
8112cb78:	103ee83a 	callr	r2
8112cb7c:	e0bffc15 	stw	r2,-16(fp)
8112cb80:	e0bffc17 	ldw	r2,-16(fp)
8112cb84:	1000070e 	bge	r2,zero,8112cba4 <write+0xc8>
      {
        ALT_ERRNO = -rval;
8112cb88:	112ca980 	call	8112ca98 <alt_get_errno>
8112cb8c:	1007883a 	mov	r3,r2
8112cb90:	e0bffc17 	ldw	r2,-16(fp)
8112cb94:	0085c83a 	sub	r2,zero,r2
8112cb98:	18800015 	stw	r2,0(r3)
        return -1;
8112cb9c:	00bfffc4 	movi	r2,-1
8112cba0:	00000c06 	br	8112cbd4 <write+0xf8>
      }
      return rval;
8112cba4:	e0bffc17 	ldw	r2,-16(fp)
8112cba8:	00000a06 	br	8112cbd4 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
8112cbac:	112ca980 	call	8112ca98 <alt_get_errno>
8112cbb0:	1007883a 	mov	r3,r2
8112cbb4:	00800344 	movi	r2,13
8112cbb8:	18800015 	stw	r2,0(r3)
8112cbbc:	00000406 	br	8112cbd0 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
8112cbc0:	112ca980 	call	8112ca98 <alt_get_errno>
8112cbc4:	1007883a 	mov	r3,r2
8112cbc8:	00801444 	movi	r2,81
8112cbcc:	18800015 	stw	r2,0(r3)
  }
  return -1;
8112cbd0:	00bfffc4 	movi	r2,-1
}
8112cbd4:	e037883a 	mov	sp,fp
8112cbd8:	dfc00117 	ldw	ra,4(sp)
8112cbdc:	df000017 	ldw	fp,0(sp)
8112cbe0:	dec00204 	addi	sp,sp,8
8112cbe4:	f800283a 	ret

8112cbe8 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
8112cbe8:	deffde04 	addi	sp,sp,-136
8112cbec:	de00012e 	bgeu	sp,et,8112cbf4 <__env_lock+0xc>
8112cbf0:	003b68fa 	trap	3
8112cbf4:	dfc02115 	stw	ra,132(sp)
8112cbf8:	df002015 	stw	fp,128(sp)
8112cbfc:	df002004 	addi	fp,sp,128
8112cc00:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
8112cc04:	e0bfe104 	addi	r2,fp,-124
8112cc08:	100b883a 	mov	r5,r2
8112cc0c:	01003fc4 	movi	r4,255
8112cc10:	11352940 	call	81135294 <OSTaskQuery>
8112cc14:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
8112cc18:	e0bffe83 	ldbu	r2,-6(fp)
8112cc1c:	10803fcc 	andi	r2,r2,255
8112cc20:	10001e1e 	bne	r2,zero,8112cc9c <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
8112cc24:	e0bfed83 	ldbu	r2,-74(fp)
8112cc28:	10803fcc 	andi	r2,r2,255
8112cc2c:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
8112cc30:	d0a07b17 	ldw	r2,-32276(gp)
8112cc34:	e0fffc04 	addi	r3,fp,-16
8112cc38:	180b883a 	mov	r5,r3
8112cc3c:	1009883a 	mov	r4,r2
8112cc40:	1133c000 	call	81133c00 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
8112cc44:	e0bffe03 	ldbu	r2,-8(fp)
8112cc48:	10803fcc 	andi	r2,r2,255
8112cc4c:	10000726 	beq	r2,zero,8112cc6c <__env_lock+0x84>
8112cc50:	d0a01617 	ldw	r2,-32680(gp)
8112cc54:	e0ffe017 	ldw	r3,-128(fp)
8112cc58:	1880041e 	bne	r3,r2,8112cc6c <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
8112cc5c:	d0a07a17 	ldw	r2,-32280(gp)
8112cc60:	10800044 	addi	r2,r2,1
8112cc64:	d0a07a15 	stw	r2,-32280(gp)
8112cc68:	00000a06 	br	8112cc94 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
8112cc6c:	d0a07b17 	ldw	r2,-32276(gp)
8112cc70:	e0fffe84 	addi	r3,fp,-6
8112cc74:	180d883a 	mov	r6,r3
8112cc78:	000b883a 	mov	r5,zero
8112cc7c:	1009883a 	mov	r4,r2
8112cc80:	11337600 	call	81133760 <OSSemPend>
    locks  = 1;
8112cc84:	00800044 	movi	r2,1
8112cc88:	d0a07a15 	stw	r2,-32280(gp)
    lockid = id;
8112cc8c:	e0bfe017 	ldw	r2,-128(fp)
8112cc90:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
8112cc94:	0001883a 	nop
8112cc98:	00000106 	br	8112cca0 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
8112cc9c:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
8112cca0:	e037883a 	mov	sp,fp
8112cca4:	dfc00117 	ldw	ra,4(sp)
8112cca8:	df000017 	ldw	fp,0(sp)
8112ccac:	dec00204 	addi	sp,sp,8
8112ccb0:	f800283a 	ret

8112ccb4 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
8112ccb4:	defffd04 	addi	sp,sp,-12
8112ccb8:	de00012e 	bgeu	sp,et,8112ccc0 <__env_unlock+0xc>
8112ccbc:	003b68fa 	trap	3
8112ccc0:	dfc00215 	stw	ra,8(sp)
8112ccc4:	df000115 	stw	fp,4(sp)
8112ccc8:	df000104 	addi	fp,sp,4
8112cccc:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
8112ccd0:	d0a07a17 	ldw	r2,-32280(gp)
8112ccd4:	10000b26 	beq	r2,zero,8112cd04 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
8112ccd8:	d0a07a17 	ldw	r2,-32280(gp)
8112ccdc:	10bfffc4 	addi	r2,r2,-1
8112cce0:	d0a07a15 	stw	r2,-32280(gp)
8112cce4:	d0a07a17 	ldw	r2,-32280(gp)
8112cce8:	1000071e 	bne	r2,zero,8112cd08 <__env_unlock+0x54>
  {
    lockid = -1;
8112ccec:	00bfffc4 	movi	r2,-1
8112ccf0:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
8112ccf4:	d0a07b17 	ldw	r2,-32276(gp)
8112ccf8:	1009883a 	mov	r4,r2
8112ccfc:	1133ae80 	call	81133ae8 <OSSemPost>
8112cd00:	00000106 	br	8112cd08 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
8112cd04:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
8112cd08:	e037883a 	mov	sp,fp
8112cd0c:	dfc00117 	ldw	ra,4(sp)
8112cd10:	df000017 	ldw	fp,0(sp)
8112cd14:	dec00204 	addi	sp,sp,8
8112cd18:	f800283a 	ret

8112cd1c <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
8112cd1c:	deffda04 	addi	sp,sp,-152
8112cd20:	de00012e 	bgeu	sp,et,8112cd28 <__malloc_lock+0xc>
8112cd24:	003b68fa 	trap	3
8112cd28:	dfc02515 	stw	ra,148(sp)
8112cd2c:	df002415 	stw	fp,144(sp)
8112cd30:	df002404 	addi	fp,sp,144
8112cd34:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112cd38:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
8112cd3c:	d0a08103 	ldbu	r2,-32252(gp)
8112cd40:	10803fcc 	andi	r2,r2,255
8112cd44:	10800060 	cmpeqi	r2,r2,1
8112cd48:	10003626 	beq	r2,zero,8112ce24 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
8112cd4c:	e0bfe104 	addi	r2,fp,-124
8112cd50:	100b883a 	mov	r5,r2
8112cd54:	01003fc4 	movi	r4,255
8112cd58:	11352940 	call	81135294 <OSTaskQuery>
8112cd5c:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
8112cd60:	e0bffe83 	ldbu	r2,-6(fp)
8112cd64:	10803fcc 	andi	r2,r2,255
8112cd68:	1000301e 	bne	r2,zero,8112ce2c <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
8112cd6c:	e0bfed83 	ldbu	r2,-74(fp)
8112cd70:	10803fcc 	andi	r2,r2,255
8112cd74:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
8112cd78:	d0a07d17 	ldw	r2,-32268(gp)
8112cd7c:	e0fffc04 	addi	r3,fp,-16
8112cd80:	180b883a 	mov	r5,r3
8112cd84:	1009883a 	mov	r4,r2
8112cd88:	1133c000 	call	81133c00 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112cd8c:	0005303a 	rdctl	r2,status
8112cd90:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112cd94:	e0ffe017 	ldw	r3,-128(fp)
8112cd98:	00bfff84 	movi	r2,-2
8112cd9c:	1884703a 	and	r2,r3,r2
8112cda0:	1001703a 	wrctl	status,r2
  
  return context;
8112cda4:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
8112cda8:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
8112cdac:	e0bffc0b 	ldhu	r2,-16(fp)
8112cdb0:	10bfffcc 	andi	r2,r2,65535
8112cdb4:	10000b1e 	bne	r2,zero,8112cde4 <__malloc_lock+0xc8>
8112cdb8:	d0a01717 	ldw	r2,-32676(gp)
8112cdbc:	e0ffdd17 	ldw	r3,-140(fp)
8112cdc0:	1880081e 	bne	r3,r2,8112cde4 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
8112cdc4:	d0a07c17 	ldw	r2,-32272(gp)
8112cdc8:	10800044 	addi	r2,r2,1
8112cdcc:	d0a07c15 	stw	r2,-32272(gp)
8112cdd0:	e0bfdc17 	ldw	r2,-144(fp)
8112cdd4:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112cdd8:	e0bfde17 	ldw	r2,-136(fp)
8112cddc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
8112cde0:	00000e06 	br	8112ce1c <__malloc_lock+0x100>
8112cde4:	e0bfdc17 	ldw	r2,-144(fp)
8112cde8:	e0bfdf15 	stw	r2,-132(fp)
8112cdec:	e0bfdf17 	ldw	r2,-132(fp)
8112cdf0:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
8112cdf4:	d0a07d17 	ldw	r2,-32268(gp)
8112cdf8:	e0fffe84 	addi	r3,fp,-6
8112cdfc:	180d883a 	mov	r6,r3
8112ce00:	000b883a 	mov	r5,zero
8112ce04:	1009883a 	mov	r4,r2
8112ce08:	11337600 	call	81133760 <OSSemPend>
    locks  = 1;
8112ce0c:	00800044 	movi	r2,1
8112ce10:	d0a07c15 	stw	r2,-32272(gp)
    lockid = id;
8112ce14:	e0bfdd17 	ldw	r2,-140(fp)
8112ce18:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
8112ce1c:	0001883a 	nop
8112ce20:	00000306 	br	8112ce30 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
8112ce24:	0001883a 	nop
8112ce28:	00000106 	br	8112ce30 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
8112ce2c:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
8112ce30:	e037883a 	mov	sp,fp
8112ce34:	dfc00117 	ldw	ra,4(sp)
8112ce38:	df000017 	ldw	fp,0(sp)
8112ce3c:	dec00204 	addi	sp,sp,8
8112ce40:	f800283a 	ret

8112ce44 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
8112ce44:	defff804 	addi	sp,sp,-32
8112ce48:	de00012e 	bgeu	sp,et,8112ce50 <__malloc_unlock+0xc>
8112ce4c:	003b68fa 	trap	3
8112ce50:	dfc00715 	stw	ra,28(sp)
8112ce54:	df000615 	stw	fp,24(sp)
8112ce58:	df000604 	addi	fp,sp,24
8112ce5c:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112ce60:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
8112ce64:	d0a08103 	ldbu	r2,-32252(gp)
8112ce68:	10803fcc 	andi	r2,r2,255
8112ce6c:	10800060 	cmpeqi	r2,r2,1
8112ce70:	10002326 	beq	r2,zero,8112cf00 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ce74:	0005303a 	rdctl	r2,status
8112ce78:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ce7c:	e0fffe17 	ldw	r3,-8(fp)
8112ce80:	00bfff84 	movi	r2,-2
8112ce84:	1884703a 	and	r2,r3,r2
8112ce88:	1001703a 	wrctl	status,r2
  
  return context;
8112ce8c:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
8112ce90:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
8112ce94:	d0a07c17 	ldw	r2,-32272(gp)
8112ce98:	1000051e 	bne	r2,zero,8112ceb0 <__malloc_unlock+0x6c>
8112ce9c:	e0bffa17 	ldw	r2,-24(fp)
8112cea0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112cea4:	e0bffb17 	ldw	r2,-20(fp)
8112cea8:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
8112ceac:	00001506 	br	8112cf04 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
8112ceb0:	d0a07c17 	ldw	r2,-32272(gp)
8112ceb4:	10bfffc4 	addi	r2,r2,-1
8112ceb8:	d0a07c15 	stw	r2,-32272(gp)
8112cebc:	d0a07c17 	ldw	r2,-32272(gp)
8112cec0:	10000a1e 	bne	r2,zero,8112ceec <__malloc_unlock+0xa8>
  {
    lockid = -1;
8112cec4:	00bfffc4 	movi	r2,-1
8112cec8:	d0a01715 	stw	r2,-32676(gp)
8112cecc:	e0bffa17 	ldw	r2,-24(fp)
8112ced0:	e0bffc15 	stw	r2,-16(fp)
8112ced4:	e0bffc17 	ldw	r2,-16(fp)
8112ced8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
8112cedc:	d0a07d17 	ldw	r2,-32268(gp)
8112cee0:	1009883a 	mov	r4,r2
8112cee4:	1133ae80 	call	81133ae8 <OSSemPost>
8112cee8:	00000606 	br	8112cf04 <__malloc_unlock+0xc0>
8112ceec:	e0bffa17 	ldw	r2,-24(fp)
8112cef0:	e0bffd15 	stw	r2,-12(fp)
8112cef4:	e0bffd17 	ldw	r2,-12(fp)
8112cef8:	1001703a 	wrctl	status,r2
8112cefc:	00000106 	br	8112cf04 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
8112cf00:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
8112cf04:	e037883a 	mov	sp,fp
8112cf08:	dfc00117 	ldw	ra,4(sp)
8112cf0c:	df000017 	ldw	fp,0(sp)
8112cf10:	dec00204 	addi	sp,sp,8
8112cf14:	f800283a 	ret

8112cf18 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8112cf18:	defff704 	addi	sp,sp,-36
8112cf1c:	de00012e 	bgeu	sp,et,8112cf24 <OSEventNameGet+0xc>
8112cf20:	003b68fa 	trap	3
8112cf24:	dfc00815 	stw	ra,32(sp)
8112cf28:	df000715 	stw	fp,28(sp)
8112cf2c:	df000704 	addi	fp,sp,28
8112cf30:	e13ffd15 	stw	r4,-12(fp)
8112cf34:	e17ffe15 	stw	r5,-8(fp)
8112cf38:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112cf3c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112cf40:	e0bfff17 	ldw	r2,-4(fp)
8112cf44:	1000021e 	bne	r2,zero,8112cf50 <OSEventNameGet+0x38>
        return (0);
8112cf48:	0005883a 	mov	r2,zero
8112cf4c:	00003706 	br	8112d02c <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8112cf50:	e0bffd17 	ldw	r2,-12(fp)
8112cf54:	1000051e 	bne	r2,zero,8112cf6c <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
8112cf58:	e0bfff17 	ldw	r2,-4(fp)
8112cf5c:	00c00104 	movi	r3,4
8112cf60:	10c00005 	stb	r3,0(r2)
        return (0);
8112cf64:	0005883a 	mov	r2,zero
8112cf68:	00003006 	br	8112d02c <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112cf6c:	e0bffe17 	ldw	r2,-8(fp)
8112cf70:	1000051e 	bne	r2,zero,8112cf88 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8112cf74:	e0bfff17 	ldw	r2,-4(fp)
8112cf78:	00c00304 	movi	r3,12
8112cf7c:	10c00005 	stb	r3,0(r2)
        return (0);
8112cf80:	0005883a 	mov	r2,zero
8112cf84:	00002906 	br	8112d02c <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112cf88:	d0a09103 	ldbu	r2,-32188(gp)
8112cf8c:	10803fcc 	andi	r2,r2,255
8112cf90:	10000526 	beq	r2,zero,8112cfa8 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
8112cf94:	e0bfff17 	ldw	r2,-4(fp)
8112cf98:	00c00444 	movi	r3,17
8112cf9c:	10c00005 	stb	r3,0(r2)
        return (0);
8112cfa0:	0005883a 	mov	r2,zero
8112cfa4:	00002106 	br	8112d02c <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
8112cfa8:	e0bffd17 	ldw	r2,-12(fp)
8112cfac:	10800003 	ldbu	r2,0(r2)
8112cfb0:	10803fcc 	andi	r2,r2,255
8112cfb4:	10bfffc4 	addi	r2,r2,-1
8112cfb8:	10800128 	cmpgeui	r2,r2,4
8112cfbc:	10000526 	beq	r2,zero,8112cfd4 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8112cfc0:	e0bfff17 	ldw	r2,-4(fp)
8112cfc4:	00c00044 	movi	r3,1
8112cfc8:	10c00005 	stb	r3,0(r2)
             return (0);
8112cfcc:	0005883a 	mov	r2,zero
8112cfd0:	00001606 	br	8112d02c <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8112cfd4:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112cfd8:	0005303a 	rdctl	r2,status
8112cfdc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112cfe0:	e0fffb17 	ldw	r3,-20(fp)
8112cfe4:	00bfff84 	movi	r2,-2
8112cfe8:	1884703a 	and	r2,r3,r2
8112cfec:	1001703a 	wrctl	status,r2
  
  return context;
8112cff0:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
8112cff4:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
8112cff8:	e0bffd17 	ldw	r2,-12(fp)
8112cffc:	10800444 	addi	r2,r2,17
8112d000:	100b883a 	mov	r5,r2
8112d004:	e13ffe17 	ldw	r4,-8(fp)
8112d008:	112ea040 	call	8112ea04 <OS_StrCopy>
8112d00c:	e0bffa05 	stb	r2,-24(fp)
8112d010:	e0bff917 	ldw	r2,-28(fp)
8112d014:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d018:	e0bffc17 	ldw	r2,-16(fp)
8112d01c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112d020:	e0bfff17 	ldw	r2,-4(fp)
8112d024:	10000005 	stb	zero,0(r2)
    return (len);
8112d028:	e0bffa03 	ldbu	r2,-24(fp)
}
8112d02c:	e037883a 	mov	sp,fp
8112d030:	dfc00117 	ldw	ra,4(sp)
8112d034:	df000017 	ldw	fp,0(sp)
8112d038:	dec00204 	addi	sp,sp,8
8112d03c:	f800283a 	ret

8112d040 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8112d040:	defff604 	addi	sp,sp,-40
8112d044:	de00012e 	bgeu	sp,et,8112d04c <OSEventNameSet+0xc>
8112d048:	003b68fa 	trap	3
8112d04c:	dfc00915 	stw	ra,36(sp)
8112d050:	df000815 	stw	fp,32(sp)
8112d054:	df000804 	addi	fp,sp,32
8112d058:	e13ffd15 	stw	r4,-12(fp)
8112d05c:	e17ffe15 	stw	r5,-8(fp)
8112d060:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112d064:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112d068:	e0bfff17 	ldw	r2,-4(fp)
8112d06c:	10004026 	beq	r2,zero,8112d170 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8112d070:	e0bffd17 	ldw	r2,-12(fp)
8112d074:	1000041e 	bne	r2,zero,8112d088 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8112d078:	e0bfff17 	ldw	r2,-4(fp)
8112d07c:	00c00104 	movi	r3,4
8112d080:	10c00005 	stb	r3,0(r2)
        return;
8112d084:	00003b06 	br	8112d174 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112d088:	e0bffe17 	ldw	r2,-8(fp)
8112d08c:	1000041e 	bne	r2,zero,8112d0a0 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8112d090:	e0bfff17 	ldw	r2,-4(fp)
8112d094:	00c00304 	movi	r3,12
8112d098:	10c00005 	stb	r3,0(r2)
        return;
8112d09c:	00003506 	br	8112d174 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112d0a0:	d0a09103 	ldbu	r2,-32188(gp)
8112d0a4:	10803fcc 	andi	r2,r2,255
8112d0a8:	10000426 	beq	r2,zero,8112d0bc <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8112d0ac:	e0bfff17 	ldw	r2,-4(fp)
8112d0b0:	00c00484 	movi	r3,18
8112d0b4:	10c00005 	stb	r3,0(r2)
        return;
8112d0b8:	00002e06 	br	8112d174 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
8112d0bc:	e0bffd17 	ldw	r2,-12(fp)
8112d0c0:	10800003 	ldbu	r2,0(r2)
8112d0c4:	10803fcc 	andi	r2,r2,255
8112d0c8:	10bfffc4 	addi	r2,r2,-1
8112d0cc:	10800128 	cmpgeui	r2,r2,4
8112d0d0:	10000426 	beq	r2,zero,8112d0e4 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8112d0d4:	e0bfff17 	ldw	r2,-4(fp)
8112d0d8:	00c00044 	movi	r3,1
8112d0dc:	10c00005 	stb	r3,0(r2)
             return;
8112d0e0:	00002406 	br	8112d174 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8112d0e4:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d0e8:	0005303a 	rdctl	r2,status
8112d0ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d0f0:	e0fffc17 	ldw	r3,-16(fp)
8112d0f4:	00bfff84 	movi	r2,-2
8112d0f8:	1884703a 	and	r2,r3,r2
8112d0fc:	1001703a 	wrctl	status,r2
  
  return context;
8112d100:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
8112d104:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
8112d108:	e13ffe17 	ldw	r4,-8(fp)
8112d10c:	112ea800 	call	8112ea80 <OS_StrLen>
8112d110:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
8112d114:	e0bffa03 	ldbu	r2,-24(fp)
8112d118:	10800830 	cmpltui	r2,r2,32
8112d11c:	1000081e 	bne	r2,zero,8112d140 <OSEventNameSet+0x100>
8112d120:	e0bff817 	ldw	r2,-32(fp)
8112d124:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d128:	e0bff917 	ldw	r2,-28(fp)
8112d12c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
8112d130:	e0bfff17 	ldw	r2,-4(fp)
8112d134:	00c002c4 	movi	r3,11
8112d138:	10c00005 	stb	r3,0(r2)
        return;
8112d13c:	00000d06 	br	8112d174 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
8112d140:	e0bffd17 	ldw	r2,-12(fp)
8112d144:	10800444 	addi	r2,r2,17
8112d148:	e17ffe17 	ldw	r5,-8(fp)
8112d14c:	1009883a 	mov	r4,r2
8112d150:	112ea040 	call	8112ea04 <OS_StrCopy>
8112d154:	e0bff817 	ldw	r2,-32(fp)
8112d158:	e0bffb15 	stw	r2,-20(fp)
8112d15c:	e0bffb17 	ldw	r2,-20(fp)
8112d160:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112d164:	e0bfff17 	ldw	r2,-4(fp)
8112d168:	10000005 	stb	zero,0(r2)
8112d16c:	00000106 	br	8112d174 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8112d170:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8112d174:	e037883a 	mov	sp,fp
8112d178:	dfc00117 	ldw	ra,4(sp)
8112d17c:	df000017 	ldw	fp,0(sp)
8112d180:	dec00204 	addi	sp,sp,8
8112d184:	f800283a 	ret

8112d188 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
8112d188:	deffed04 	addi	sp,sp,-76
8112d18c:	de00012e 	bgeu	sp,et,8112d194 <OSEventPendMulti+0xc>
8112d190:	003b68fa 	trap	3
8112d194:	dfc01215 	stw	ra,72(sp)
8112d198:	df001115 	stw	fp,68(sp)
8112d19c:	df001104 	addi	fp,sp,68
8112d1a0:	e13ffc15 	stw	r4,-16(fp)
8112d1a4:	e17ffd15 	stw	r5,-12(fp)
8112d1a8:	e1bffe15 	stw	r6,-8(fp)
8112d1ac:	3805883a 	mov	r2,r7
8112d1b0:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
8112d1b4:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
8112d1b8:	e0800217 	ldw	r2,8(fp)
8112d1bc:	1000021e 	bne	r2,zero,8112d1c8 <OSEventPendMulti+0x40>
        return (0);
8112d1c0:	0005883a 	mov	r2,zero
8112d1c4:	00015006 	br	8112d708 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
8112d1c8:	e0bffc17 	ldw	r2,-16(fp)
8112d1cc:	1000051e 	bne	r2,zero,8112d1e4 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
8112d1d0:	e0800217 	ldw	r2,8(fp)
8112d1d4:	00c00104 	movi	r3,4
8112d1d8:	10c00005 	stb	r3,0(r2)
        return (0);
8112d1dc:	0005883a 	mov	r2,zero
8112d1e0:	00014906 	br	8112d708 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
8112d1e4:	e0bffd17 	ldw	r2,-12(fp)
8112d1e8:	1000051e 	bne	r2,zero,8112d200 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
8112d1ec:	e0800217 	ldw	r2,8(fp)
8112d1f0:	00c00104 	movi	r3,4
8112d1f4:	10c00005 	stb	r3,0(r2)
        return (0);
8112d1f8:	0005883a 	mov	r2,zero
8112d1fc:	00014206 	br	8112d708 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
8112d200:	e0bffe17 	ldw	r2,-8(fp)
8112d204:	1000051e 	bne	r2,zero,8112d21c <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
8112d208:	e0800217 	ldw	r2,8(fp)
8112d20c:	00c00104 	movi	r3,4
8112d210:	10c00005 	stb	r3,0(r2)
        return (0);
8112d214:	0005883a 	mov	r2,zero
8112d218:	00013b06 	br	8112d708 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
8112d21c:	e0bffd17 	ldw	r2,-12(fp)
8112d220:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
8112d224:	e0bffc17 	ldw	r2,-16(fp)
8112d228:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
8112d22c:	e0bfef17 	ldw	r2,-68(fp)
8112d230:	10800017 	ldw	r2,0(r2)
8112d234:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
8112d238:	00001506 	br	8112d290 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
8112d23c:	e0bff017 	ldw	r2,-64(fp)
8112d240:	10800003 	ldbu	r2,0(r2)
8112d244:	10803fcc 	andi	r2,r2,255
8112d248:	10c000a0 	cmpeqi	r3,r2,2
8112d24c:	1800071e 	bne	r3,zero,8112d26c <OSEventPendMulti+0xe4>
8112d250:	108000e0 	cmpeqi	r2,r2,3
8112d254:	1000071e 	bne	r2,zero,8112d274 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
8112d258:	e0800217 	ldw	r2,8(fp)
8112d25c:	00c00044 	movi	r3,1
8112d260:	10c00005 	stb	r3,0(r2)
                 return (0);
8112d264:	0005883a 	mov	r2,zero
8112d268:	00012706 	br	8112d708 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
8112d26c:	0001883a 	nop
8112d270:	00000106 	br	8112d278 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
8112d274:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
8112d278:	e0bfef17 	ldw	r2,-68(fp)
8112d27c:	10800104 	addi	r2,r2,4
8112d280:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8112d284:	e0bfef17 	ldw	r2,-68(fp)
8112d288:	10800017 	ldw	r2,0(r2)
8112d28c:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
8112d290:	e0bff017 	ldw	r2,-64(fp)
8112d294:	103fe91e 	bne	r2,zero,8112d23c <__reset+0xfb10d23c>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
8112d298:	d0a09103 	ldbu	r2,-32188(gp)
8112d29c:	10803fcc 	andi	r2,r2,255
8112d2a0:	10000526 	beq	r2,zero,8112d2b8 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
8112d2a4:	e0800217 	ldw	r2,8(fp)
8112d2a8:	00c00084 	movi	r3,2
8112d2ac:	10c00005 	stb	r3,0(r2)
        return (0);
8112d2b0:	0005883a 	mov	r2,zero
8112d2b4:	00011406 	br	8112d708 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
8112d2b8:	d0a07f03 	ldbu	r2,-32260(gp)
8112d2bc:	10803fcc 	andi	r2,r2,255
8112d2c0:	10000526 	beq	r2,zero,8112d2d8 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
8112d2c4:	e0800217 	ldw	r2,8(fp)
8112d2c8:	00c00344 	movi	r3,13
8112d2cc:	10c00005 	stb	r3,0(r2)
        return (0);
8112d2d0:	0005883a 	mov	r2,zero
8112d2d4:	00010c06 	br	8112d708 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d2d8:	0005303a 	rdctl	r2,status
8112d2dc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d2e0:	e0fffb17 	ldw	r3,-20(fp)
8112d2e4:	00bfff84 	movi	r2,-2
8112d2e8:	1884703a 	and	r2,r3,r2
8112d2ec:	1001703a 	wrctl	status,r2
  
  return context;
8112d2f0:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
8112d2f4:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
8112d2f8:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
8112d2fc:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
8112d300:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
8112d304:	e0bffc17 	ldw	r2,-16(fp)
8112d308:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
8112d30c:	e0bfef17 	ldw	r2,-68(fp)
8112d310:	10800017 	ldw	r2,0(r2)
8112d314:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8112d318:	00006406 	br	8112d4ac <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
8112d31c:	e0bff017 	ldw	r2,-64(fp)
8112d320:	10800003 	ldbu	r2,0(r2)
8112d324:	10803fcc 	andi	r2,r2,255
8112d328:	10c000a0 	cmpeqi	r3,r2,2
8112d32c:	18001f1e 	bne	r3,zero,8112d3ac <OSEventPendMulti+0x224>
8112d330:	108000e0 	cmpeqi	r2,r2,3
8112d334:	10004c26 	beq	r2,zero,8112d468 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
8112d338:	e0bff017 	ldw	r2,-64(fp)
8112d33c:	1080020b 	ldhu	r2,8(r2)
8112d340:	10bfffcc 	andi	r2,r2,65535
8112d344:	10001526 	beq	r2,zero,8112d39c <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
8112d348:	e0bff017 	ldw	r2,-64(fp)
8112d34c:	1080020b 	ldhu	r2,8(r2)
8112d350:	10bfffc4 	addi	r2,r2,-1
8112d354:	1007883a 	mov	r3,r2
8112d358:	e0bff017 	ldw	r2,-64(fp)
8112d35c:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
8112d360:	e0bffd17 	ldw	r2,-12(fp)
8112d364:	10c00104 	addi	r3,r2,4
8112d368:	e0fffd15 	stw	r3,-12(fp)
8112d36c:	e0fff017 	ldw	r3,-64(fp)
8112d370:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
8112d374:	00800044 	movi	r2,1
8112d378:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
8112d37c:	e0bffe17 	ldw	r2,-8(fp)
8112d380:	10c00104 	addi	r3,r2,4
8112d384:	e0fffe15 	stw	r3,-8(fp)
8112d388:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
8112d38c:	e0bff18b 	ldhu	r2,-58(fp)
8112d390:	10800044 	addi	r2,r2,1
8112d394:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
8112d398:	00003e06 	br	8112d494 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
8112d39c:	e0bff203 	ldbu	r2,-56(fp)
8112d3a0:	10800054 	ori	r2,r2,1
8112d3a4:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8112d3a8:	00003a06 	br	8112d494 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
8112d3ac:	e0bff017 	ldw	r2,-64(fp)
8112d3b0:	10800117 	ldw	r2,4(r2)
8112d3b4:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
8112d3b8:	e0bff517 	ldw	r2,-44(fp)
8112d3bc:	1080058b 	ldhu	r2,22(r2)
8112d3c0:	10bfffcc 	andi	r2,r2,65535
8112d3c4:	10002426 	beq	r2,zero,8112d458 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
8112d3c8:	e0bffe17 	ldw	r2,-8(fp)
8112d3cc:	10c00104 	addi	r3,r2,4
8112d3d0:	e0fffe15 	stw	r3,-8(fp)
8112d3d4:	e0fff517 	ldw	r3,-44(fp)
8112d3d8:	18c00417 	ldw	r3,16(r3)
8112d3dc:	19400104 	addi	r5,r3,4
8112d3e0:	e13ff517 	ldw	r4,-44(fp)
8112d3e4:	21400415 	stw	r5,16(r4)
8112d3e8:	18c00017 	ldw	r3,0(r3)
8112d3ec:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
8112d3f0:	e0bff517 	ldw	r2,-44(fp)
8112d3f4:	10c00417 	ldw	r3,16(r2)
8112d3f8:	e0bff517 	ldw	r2,-44(fp)
8112d3fc:	10800217 	ldw	r2,8(r2)
8112d400:	1880041e 	bne	r3,r2,8112d414 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
8112d404:	e0bff517 	ldw	r2,-44(fp)
8112d408:	10c00117 	ldw	r3,4(r2)
8112d40c:	e0bff517 	ldw	r2,-44(fp)
8112d410:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
8112d414:	e0bff517 	ldw	r2,-44(fp)
8112d418:	1080058b 	ldhu	r2,22(r2)
8112d41c:	10bfffc4 	addi	r2,r2,-1
8112d420:	1007883a 	mov	r3,r2
8112d424:	e0bff517 	ldw	r2,-44(fp)
8112d428:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
8112d42c:	e0bffd17 	ldw	r2,-12(fp)
8112d430:	10c00104 	addi	r3,r2,4
8112d434:	e0fffd15 	stw	r3,-12(fp)
8112d438:	e0fff017 	ldw	r3,-64(fp)
8112d43c:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
8112d440:	00800044 	movi	r2,1
8112d444:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
8112d448:	e0bff18b 	ldhu	r2,-58(fp)
8112d44c:	10800044 	addi	r2,r2,1
8112d450:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
8112d454:	00000f06 	br	8112d494 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
8112d458:	e0bff203 	ldbu	r2,-56(fp)
8112d45c:	10800114 	ori	r2,r2,4
8112d460:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8112d464:	00000b06 	br	8112d494 <OSEventPendMulti+0x30c>
8112d468:	e0bff317 	ldw	r2,-52(fp)
8112d46c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d470:	e0bff417 	ldw	r2,-48(fp)
8112d474:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
8112d478:	e0bffd17 	ldw	r2,-12(fp)
8112d47c:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
8112d480:	e0800217 	ldw	r2,8(fp)
8112d484:	00c00044 	movi	r3,1
8112d488:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
8112d48c:	e0bff18b 	ldhu	r2,-58(fp)
8112d490:	00009d06 	br	8112d708 <OSEventPendMulti+0x580>
        }
        pevents++;
8112d494:	e0bfef17 	ldw	r2,-68(fp)
8112d498:	10800104 	addi	r2,r2,4
8112d49c:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8112d4a0:	e0bfef17 	ldw	r2,-68(fp)
8112d4a4:	10800017 	ldw	r2,0(r2)
8112d4a8:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8112d4ac:	e0bff017 	ldw	r2,-64(fp)
8112d4b0:	103f9a1e 	bne	r2,zero,8112d31c <__reset+0xfb10d31c>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
8112d4b4:	e0bff103 	ldbu	r2,-60(fp)
8112d4b8:	10800058 	cmpnei	r2,r2,1
8112d4bc:	10000a1e 	bne	r2,zero,8112d4e8 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
8112d4c0:	e0bffd17 	ldw	r2,-12(fp)
8112d4c4:	10000015 	stw	zero,0(r2)
8112d4c8:	e0bff317 	ldw	r2,-52(fp)
8112d4cc:	e0bff615 	stw	r2,-40(fp)
8112d4d0:	e0bff617 	ldw	r2,-40(fp)
8112d4d4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
8112d4d8:	e0800217 	ldw	r2,8(fp)
8112d4dc:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
8112d4e0:	e0bff18b 	ldhu	r2,-58(fp)
8112d4e4:	00008806 	br	8112d708 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
8112d4e8:	d0a09217 	ldw	r2,-32184(gp)
8112d4ec:	d0e09217 	ldw	r3,-32184(gp)
8112d4f0:	19000c03 	ldbu	r4,48(r3)
8112d4f4:	e0fff203 	ldbu	r3,-56(fp)
8112d4f8:	20c6b03a 	or	r3,r4,r3
8112d4fc:	1809883a 	mov	r4,r3
8112d500:	00ffe004 	movi	r3,-128
8112d504:	20c6b03a 	or	r3,r4,r3
8112d508:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8112d50c:	d0a09217 	ldw	r2,-32184(gp)
8112d510:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
8112d514:	d0a09217 	ldw	r2,-32184(gp)
8112d518:	e0ffff0b 	ldhu	r3,-4(fp)
8112d51c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
8112d520:	e13ffc17 	ldw	r4,-16(fp)
8112d524:	112e0ac0 	call	8112e0ac <OS_EventTaskWaitMulti>
8112d528:	e0bff317 	ldw	r2,-52(fp)
8112d52c:	e0bff915 	stw	r2,-28(fp)
8112d530:	e0bff917 	ldw	r2,-28(fp)
8112d534:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
8112d538:	112e8b00 	call	8112e8b0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d53c:	0005303a 	rdctl	r2,status
8112d540:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d544:	e0fff717 	ldw	r3,-36(fp)
8112d548:	00bfff84 	movi	r2,-2
8112d54c:	1884703a 	and	r2,r3,r2
8112d550:	1001703a 	wrctl	status,r2
  
  return context;
8112d554:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
8112d558:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
8112d55c:	d0a09217 	ldw	r2,-32184(gp)
8112d560:	10800c43 	ldbu	r2,49(r2)
8112d564:	10803fcc 	andi	r2,r2,255
8112d568:	10000226 	beq	r2,zero,8112d574 <OSEventPendMulti+0x3ec>
8112d56c:	108000a0 	cmpeqi	r2,r2,2
8112d570:	10001826 	beq	r2,zero,8112d5d4 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
8112d574:	d0a09217 	ldw	r2,-32184(gp)
8112d578:	10800717 	ldw	r2,28(r2)
8112d57c:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
8112d580:	e0bff017 	ldw	r2,-64(fp)
8112d584:	10000b26 	beq	r2,zero,8112d5b4 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
8112d588:	e0bffd17 	ldw	r2,-12(fp)
8112d58c:	10c00104 	addi	r3,r2,4
8112d590:	e0fffd15 	stw	r3,-12(fp)
8112d594:	e0fff017 	ldw	r3,-64(fp)
8112d598:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
8112d59c:	e0bffd17 	ldw	r2,-12(fp)
8112d5a0:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
8112d5a4:	e0bff18b 	ldhu	r2,-58(fp)
8112d5a8:	10800044 	addi	r2,r2,1
8112d5ac:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
8112d5b0:	00000d06 	br	8112d5e8 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
8112d5b4:	d0a09217 	ldw	r2,-32184(gp)
8112d5b8:	00c00044 	movi	r3,1
8112d5bc:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8112d5c0:	d0a09217 	ldw	r2,-32184(gp)
8112d5c4:	e17ffc17 	ldw	r5,-16(fp)
8112d5c8:	1009883a 	mov	r4,r2
8112d5cc:	112e2c40 	call	8112e2c4 <OS_EventTaskRemoveMulti>
             }
			 break;
8112d5d0:	00000506 	br	8112d5e8 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8112d5d4:	d0a09217 	ldw	r2,-32184(gp)
8112d5d8:	e17ffc17 	ldw	r5,-16(fp)
8112d5dc:	1009883a 	mov	r4,r2
8112d5e0:	112e2c40 	call	8112e2c4 <OS_EventTaskRemoveMulti>
             break;
8112d5e4:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
8112d5e8:	d0a09217 	ldw	r2,-32184(gp)
8112d5ec:	10800c43 	ldbu	r2,49(r2)
8112d5f0:	10803fcc 	andi	r2,r2,255
8112d5f4:	10000326 	beq	r2,zero,8112d604 <OSEventPendMulti+0x47c>
8112d5f8:	108000a0 	cmpeqi	r2,r2,2
8112d5fc:	1000231e 	bne	r2,zero,8112d68c <OSEventPendMulti+0x504>
8112d600:	00002a06 	br	8112d6ac <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
8112d604:	e0bff017 	ldw	r2,-64(fp)
8112d608:	10800003 	ldbu	r2,0(r2)
8112d60c:	10803fcc 	andi	r2,r2,255
8112d610:	0080100e 	bge	zero,r2,8112d654 <OSEventPendMulti+0x4cc>
8112d614:	10c000d0 	cmplti	r3,r2,3
8112d618:	1800071e 	bne	r3,zero,8112d638 <OSEventPendMulti+0x4b0>
8112d61c:	108000e0 	cmpeqi	r2,r2,3
8112d620:	10000c26 	beq	r2,zero,8112d654 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
8112d624:	e0bffe17 	ldw	r2,-8(fp)
8112d628:	10c00104 	addi	r3,r2,4
8112d62c:	e0fffe15 	stw	r3,-8(fp)
8112d630:	10000015 	stw	zero,0(r2)
                      break;
8112d634:	00001206 	br	8112d680 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
8112d638:	e0bffe17 	ldw	r2,-8(fp)
8112d63c:	10c00104 	addi	r3,r2,4
8112d640:	e0fffe15 	stw	r3,-8(fp)
8112d644:	d0e09217 	ldw	r3,-32184(gp)
8112d648:	18c00917 	ldw	r3,36(r3)
8112d64c:	10c00015 	stw	r3,0(r2)
                      break;
8112d650:	00000b06 	br	8112d680 <OSEventPendMulti+0x4f8>
8112d654:	e0bff317 	ldw	r2,-52(fp)
8112d658:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d65c:	e0bff817 	ldw	r2,-32(fp)
8112d660:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
8112d664:	e0bffd17 	ldw	r2,-12(fp)
8112d668:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
8112d66c:	e0800217 	ldw	r2,8(fp)
8112d670:	00c00044 	movi	r3,1
8112d674:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
8112d678:	e0bff18b 	ldhu	r2,-58(fp)
8112d67c:	00002206 	br	8112d708 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
8112d680:	e0800217 	ldw	r2,8(fp)
8112d684:	10000005 	stb	zero,0(r2)
             break;
8112d688:	00001006 	br	8112d6cc <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
8112d68c:	e0bffe17 	ldw	r2,-8(fp)
8112d690:	10c00104 	addi	r3,r2,4
8112d694:	e0fffe15 	stw	r3,-8(fp)
8112d698:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
8112d69c:	e0800217 	ldw	r2,8(fp)
8112d6a0:	00c00384 	movi	r3,14
8112d6a4:	10c00005 	stb	r3,0(r2)
             break;
8112d6a8:	00000806 	br	8112d6cc <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
8112d6ac:	e0bffe17 	ldw	r2,-8(fp)
8112d6b0:	10c00104 	addi	r3,r2,4
8112d6b4:	e0fffe15 	stw	r3,-8(fp)
8112d6b8:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
8112d6bc:	e0800217 	ldw	r2,8(fp)
8112d6c0:	00c00284 	movi	r3,10
8112d6c4:	10c00005 	stb	r3,0(r2)
             break;
8112d6c8:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
8112d6cc:	d0a09217 	ldw	r2,-32184(gp)
8112d6d0:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
8112d6d4:	d0a09217 	ldw	r2,-32184(gp)
8112d6d8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
8112d6dc:	d0a09217 	ldw	r2,-32184(gp)
8112d6e0:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8112d6e4:	d0a09217 	ldw	r2,-32184(gp)
8112d6e8:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
8112d6ec:	d0a09217 	ldw	r2,-32184(gp)
8112d6f0:	10000915 	stw	zero,36(r2)
8112d6f4:	e0bff317 	ldw	r2,-52(fp)
8112d6f8:	e0bffa15 	stw	r2,-24(fp)
8112d6fc:	e0bffa17 	ldw	r2,-24(fp)
8112d700:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
8112d704:	e0bff18b 	ldhu	r2,-58(fp)
}
8112d708:	e037883a 	mov	sp,fp
8112d70c:	dfc00117 	ldw	ra,4(sp)
8112d710:	df000017 	ldw	fp,0(sp)
8112d714:	dec00204 	addi	sp,sp,8
8112d718:	f800283a 	ret

8112d71c <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
8112d71c:	defffe04 	addi	sp,sp,-8
8112d720:	de00012e 	bgeu	sp,et,8112d728 <OSInit+0xc>
8112d724:	003b68fa 	trap	3
8112d728:	dfc00115 	stw	ra,4(sp)
8112d72c:	df000015 	stw	fp,0(sp)
8112d730:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
8112d734:	113fa6c0 	call	8113fa6c <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
8112d738:	112e5240 	call	8112e524 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
8112d73c:	112e5740 	call	8112e574 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
8112d740:	112e6f80 	call	8112e6f8 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
8112d744:	112e43c0 	call	8112e43c <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
8112d748:	11306b80 	call	811306b8 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
8112d74c:	11310000 	call	81131000 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
8112d750:	11332d00 	call	811332d0 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
8112d754:	112e5e80 	call	8112e5e8 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
8112d758:	112e6700 	call	8112e670 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
8112d75c:	11364c00 	call	811364c0 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
8112d760:	113fa980 	call	8113fa98 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
8112d764:	112efd40 	call	8112efd4 <OSDebugInit>
#endif
}
8112d768:	0001883a 	nop
8112d76c:	e037883a 	mov	sp,fp
8112d770:	dfc00117 	ldw	ra,4(sp)
8112d774:	df000017 	ldw	fp,0(sp)
8112d778:	dec00204 	addi	sp,sp,8
8112d77c:	f800283a 	ret

8112d780 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
8112d780:	deffff04 	addi	sp,sp,-4
8112d784:	de00012e 	bgeu	sp,et,8112d78c <OSIntEnter+0xc>
8112d788:	003b68fa 	trap	3
8112d78c:	df000015 	stw	fp,0(sp)
8112d790:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
8112d794:	d0a08103 	ldbu	r2,-32252(gp)
8112d798:	10803fcc 	andi	r2,r2,255
8112d79c:	10800058 	cmpnei	r2,r2,1
8112d7a0:	1000071e 	bne	r2,zero,8112d7c0 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
8112d7a4:	d0a09103 	ldbu	r2,-32188(gp)
8112d7a8:	10803fcc 	andi	r2,r2,255
8112d7ac:	10803fe0 	cmpeqi	r2,r2,255
8112d7b0:	1000031e 	bne	r2,zero,8112d7c0 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
8112d7b4:	d0a09103 	ldbu	r2,-32188(gp)
8112d7b8:	10800044 	addi	r2,r2,1
8112d7bc:	d0a09105 	stb	r2,-32188(gp)
        }
    }
}
8112d7c0:	0001883a 	nop
8112d7c4:	e037883a 	mov	sp,fp
8112d7c8:	df000017 	ldw	fp,0(sp)
8112d7cc:	dec00104 	addi	sp,sp,4
8112d7d0:	f800283a 	ret

8112d7d4 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
8112d7d4:	defffb04 	addi	sp,sp,-20
8112d7d8:	de00012e 	bgeu	sp,et,8112d7e0 <OSIntExit+0xc>
8112d7dc:	003b68fa 	trap	3
8112d7e0:	dfc00415 	stw	ra,16(sp)
8112d7e4:	df000315 	stw	fp,12(sp)
8112d7e8:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112d7ec:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
8112d7f0:	d0a08103 	ldbu	r2,-32252(gp)
8112d7f4:	10803fcc 	andi	r2,r2,255
8112d7f8:	10800058 	cmpnei	r2,r2,1
8112d7fc:	10002f1e 	bne	r2,zero,8112d8bc <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d800:	0005303a 	rdctl	r2,status
8112d804:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d808:	e0ffff17 	ldw	r3,-4(fp)
8112d80c:	00bfff84 	movi	r2,-2
8112d810:	1884703a 	and	r2,r3,r2
8112d814:	1001703a 	wrctl	status,r2
  
  return context;
8112d818:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8112d81c:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
8112d820:	d0a09103 	ldbu	r2,-32188(gp)
8112d824:	10803fcc 	andi	r2,r2,255
8112d828:	10000326 	beq	r2,zero,8112d838 <OSIntExit+0x64>
            OSIntNesting--;
8112d82c:	d0a09103 	ldbu	r2,-32188(gp)
8112d830:	10bfffc4 	addi	r2,r2,-1
8112d834:	d0a09105 	stb	r2,-32188(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
8112d838:	d0a09103 	ldbu	r2,-32188(gp)
8112d83c:	10803fcc 	andi	r2,r2,255
8112d840:	10001a1e 	bne	r2,zero,8112d8ac <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
8112d844:	d0a07f03 	ldbu	r2,-32260(gp)
8112d848:	10803fcc 	andi	r2,r2,255
8112d84c:	1000171e 	bne	r2,zero,8112d8ac <OSIntExit+0xd8>
                OS_SchedNew();
8112d850:	112e9880 	call	8112e988 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
8112d854:	d0e08383 	ldbu	r3,-32242(gp)
8112d858:	d0a083c3 	ldbu	r2,-32241(gp)
8112d85c:	18c03fcc 	andi	r3,r3,255
8112d860:	10803fcc 	andi	r2,r2,255
8112d864:	18801126 	beq	r3,r2,8112d8ac <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
8112d868:	d0a08383 	ldbu	r2,-32242(gp)
8112d86c:	10c03fcc 	andi	r3,r2,255
8112d870:	00a045b4 	movhi	r2,33046
8112d874:	10bfb204 	addi	r2,r2,-312
8112d878:	18c7883a 	add	r3,r3,r3
8112d87c:	18c7883a 	add	r3,r3,r3
8112d880:	10c5883a 	add	r2,r2,r3
8112d884:	10800017 	ldw	r2,0(r2)
8112d888:	d0a08c15 	stw	r2,-32208(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
8112d88c:	d0a08c17 	ldw	r2,-32208(gp)
8112d890:	10c00e17 	ldw	r3,56(r2)
8112d894:	18c00044 	addi	r3,r3,1
8112d898:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
8112d89c:	d0a08617 	ldw	r2,-32232(gp)
8112d8a0:	10800044 	addi	r2,r2,1
8112d8a4:	d0a08615 	stw	r2,-32232(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
8112d8a8:	113f72c0 	call	8113f72c <OSCtxSw>
8112d8ac:	e0bffd17 	ldw	r2,-12(fp)
8112d8b0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d8b4:	e0bffe17 	ldw	r2,-8(fp)
8112d8b8:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8112d8bc:	0001883a 	nop
8112d8c0:	e037883a 	mov	sp,fp
8112d8c4:	dfc00117 	ldw	ra,4(sp)
8112d8c8:	df000017 	ldw	fp,0(sp)
8112d8cc:	dec00204 	addi	sp,sp,8
8112d8d0:	f800283a 	ret

8112d8d4 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
8112d8d4:	defffc04 	addi	sp,sp,-16
8112d8d8:	de00012e 	bgeu	sp,et,8112d8e0 <OSSchedLock+0xc>
8112d8dc:	003b68fa 	trap	3
8112d8e0:	df000315 	stw	fp,12(sp)
8112d8e4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112d8e8:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
8112d8ec:	d0a08103 	ldbu	r2,-32252(gp)
8112d8f0:	10803fcc 	andi	r2,r2,255
8112d8f4:	10800058 	cmpnei	r2,r2,1
8112d8f8:	1000161e 	bne	r2,zero,8112d954 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d8fc:	0005303a 	rdctl	r2,status
8112d900:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d904:	e0ffff17 	ldw	r3,-4(fp)
8112d908:	00bfff84 	movi	r2,-2
8112d90c:	1884703a 	and	r2,r3,r2
8112d910:	1001703a 	wrctl	status,r2
  
  return context;
8112d914:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8112d918:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
8112d91c:	d0a09103 	ldbu	r2,-32188(gp)
8112d920:	10803fcc 	andi	r2,r2,255
8112d924:	1000071e 	bne	r2,zero,8112d944 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
8112d928:	d0a07f03 	ldbu	r2,-32260(gp)
8112d92c:	10803fcc 	andi	r2,r2,255
8112d930:	10803fe0 	cmpeqi	r2,r2,255
8112d934:	1000031e 	bne	r2,zero,8112d944 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
8112d938:	d0a07f03 	ldbu	r2,-32260(gp)
8112d93c:	10800044 	addi	r2,r2,1
8112d940:	d0a07f05 	stb	r2,-32260(gp)
8112d944:	e0bffd17 	ldw	r2,-12(fp)
8112d948:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d94c:	e0bffe17 	ldw	r2,-8(fp)
8112d950:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8112d954:	0001883a 	nop
8112d958:	e037883a 	mov	sp,fp
8112d95c:	df000017 	ldw	fp,0(sp)
8112d960:	dec00104 	addi	sp,sp,4
8112d964:	f800283a 	ret

8112d968 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
8112d968:	defff804 	addi	sp,sp,-32
8112d96c:	de00012e 	bgeu	sp,et,8112d974 <OSSchedUnlock+0xc>
8112d970:	003b68fa 	trap	3
8112d974:	dfc00715 	stw	ra,28(sp)
8112d978:	df000615 	stw	fp,24(sp)
8112d97c:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112d980:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
8112d984:	d0a08103 	ldbu	r2,-32252(gp)
8112d988:	10803fcc 	andi	r2,r2,255
8112d98c:	10800058 	cmpnei	r2,r2,1
8112d990:	1000281e 	bne	r2,zero,8112da34 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d994:	0005303a 	rdctl	r2,status
8112d998:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d99c:	e0ffff17 	ldw	r3,-4(fp)
8112d9a0:	00bfff84 	movi	r2,-2
8112d9a4:	1884703a 	and	r2,r3,r2
8112d9a8:	1001703a 	wrctl	status,r2
  
  return context;
8112d9ac:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8112d9b0:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
8112d9b4:	d0a07f03 	ldbu	r2,-32260(gp)
8112d9b8:	10803fcc 	andi	r2,r2,255
8112d9bc:	10001926 	beq	r2,zero,8112da24 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
8112d9c0:	d0a07f03 	ldbu	r2,-32260(gp)
8112d9c4:	10bfffc4 	addi	r2,r2,-1
8112d9c8:	d0a07f05 	stb	r2,-32260(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
8112d9cc:	d0a07f03 	ldbu	r2,-32260(gp)
8112d9d0:	10803fcc 	andi	r2,r2,255
8112d9d4:	10000e1e 	bne	r2,zero,8112da10 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
8112d9d8:	d0a09103 	ldbu	r2,-32188(gp)
8112d9dc:	10803fcc 	andi	r2,r2,255
8112d9e0:	1000061e 	bne	r2,zero,8112d9fc <OSSchedUnlock+0x94>
8112d9e4:	e0bffa17 	ldw	r2,-24(fp)
8112d9e8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d9ec:	e0bffb17 	ldw	r2,-20(fp)
8112d9f0:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
8112d9f4:	112e8b00 	call	8112e8b0 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
8112d9f8:	00000e06 	br	8112da34 <OSSchedUnlock+0xcc>
8112d9fc:	e0bffa17 	ldw	r2,-24(fp)
8112da00:	e0bffc15 	stw	r2,-16(fp)
8112da04:	e0bffc17 	ldw	r2,-16(fp)
8112da08:	1001703a 	wrctl	status,r2
8112da0c:	00000906 	br	8112da34 <OSSchedUnlock+0xcc>
8112da10:	e0bffa17 	ldw	r2,-24(fp)
8112da14:	e0bffd15 	stw	r2,-12(fp)
8112da18:	e0bffd17 	ldw	r2,-12(fp)
8112da1c:	1001703a 	wrctl	status,r2
8112da20:	00000406 	br	8112da34 <OSSchedUnlock+0xcc>
8112da24:	e0bffa17 	ldw	r2,-24(fp)
8112da28:	e0bffe15 	stw	r2,-8(fp)
8112da2c:	e0bffe17 	ldw	r2,-8(fp)
8112da30:	1001703a 	wrctl	status,r2
8112da34:	0001883a 	nop
8112da38:	e037883a 	mov	sp,fp
8112da3c:	dfc00117 	ldw	ra,4(sp)
8112da40:	df000017 	ldw	fp,0(sp)
8112da44:	dec00204 	addi	sp,sp,8
8112da48:	f800283a 	ret

8112da4c <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
8112da4c:	defffe04 	addi	sp,sp,-8
8112da50:	de00012e 	bgeu	sp,et,8112da58 <OSStart+0xc>
8112da54:	003b68fa 	trap	3
8112da58:	dfc00115 	stw	ra,4(sp)
8112da5c:	df000015 	stw	fp,0(sp)
8112da60:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
8112da64:	d0a08103 	ldbu	r2,-32252(gp)
8112da68:	10803fcc 	andi	r2,r2,255
8112da6c:	10000f1e 	bne	r2,zero,8112daac <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
8112da70:	112e9880 	call	8112e988 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
8112da74:	d0a08383 	ldbu	r2,-32242(gp)
8112da78:	d0a083c5 	stb	r2,-32241(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
8112da7c:	d0a08383 	ldbu	r2,-32242(gp)
8112da80:	10c03fcc 	andi	r3,r2,255
8112da84:	00a045b4 	movhi	r2,33046
8112da88:	10bfb204 	addi	r2,r2,-312
8112da8c:	18c7883a 	add	r3,r3,r3
8112da90:	18c7883a 	add	r3,r3,r3
8112da94:	10c5883a 	add	r2,r2,r3
8112da98:	10800017 	ldw	r2,0(r2)
8112da9c:	d0a08c15 	stw	r2,-32208(gp)
        OSTCBCur      = OSTCBHighRdy;
8112daa0:	d0a08c17 	ldw	r2,-32208(gp)
8112daa4:	d0a09215 	stw	r2,-32184(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
8112daa8:	113f7c80 	call	8113f7c8 <OSStartHighRdy>
    }
}
8112daac:	0001883a 	nop
8112dab0:	e037883a 	mov	sp,fp
8112dab4:	dfc00117 	ldw	ra,4(sp)
8112dab8:	df000017 	ldw	fp,0(sp)
8112dabc:	dec00204 	addi	sp,sp,8
8112dac0:	f800283a 	ret

8112dac4 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
8112dac4:	defff904 	addi	sp,sp,-28
8112dac8:	de00012e 	bgeu	sp,et,8112dad0 <OSStatInit+0xc>
8112dacc:	003b68fa 	trap	3
8112dad0:	dfc00615 	stw	ra,24(sp)
8112dad4:	df000515 	stw	fp,20(sp)
8112dad8:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112dadc:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
8112dae0:	01000084 	movi	r4,2
8112dae4:	11354380 	call	81135438 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112dae8:	0005303a 	rdctl	r2,status
8112daec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112daf0:	e0fffc17 	ldw	r3,-16(fp)
8112daf4:	00bfff84 	movi	r2,-2
8112daf8:	1884703a 	and	r2,r3,r2
8112dafc:	1001703a 	wrctl	status,r2
  
  return context;
8112db00:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
8112db04:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
8112db08:	d0208215 	stw	zero,-32248(gp)
8112db0c:	e0bffb17 	ldw	r2,-20(fp)
8112db10:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112db14:	e0bffd17 	ldw	r2,-12(fp)
8112db18:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
8112db1c:	01001904 	movi	r4,100
8112db20:	11354380 	call	81135438 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112db24:	0005303a 	rdctl	r2,status
8112db28:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112db2c:	e0fffe17 	ldw	r3,-8(fp)
8112db30:	00bfff84 	movi	r2,-2
8112db34:	1884703a 	and	r2,r3,r2
8112db38:	1001703a 	wrctl	status,r2
  
  return context;
8112db3c:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
8112db40:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
8112db44:	d0a08217 	ldw	r2,-32248(gp)
8112db48:	d0a08815 	stw	r2,-32224(gp)
    OSStatRdy    = OS_TRUE;
8112db4c:	00800044 	movi	r2,1
8112db50:	d0a09705 	stb	r2,-32164(gp)
8112db54:	e0bffb17 	ldw	r2,-20(fp)
8112db58:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112db5c:	e0bfff17 	ldw	r2,-4(fp)
8112db60:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8112db64:	0001883a 	nop
8112db68:	e037883a 	mov	sp,fp
8112db6c:	dfc00117 	ldw	ra,4(sp)
8112db70:	df000017 	ldw	fp,0(sp)
8112db74:	dec00204 	addi	sp,sp,8
8112db78:	f800283a 	ret

8112db7c <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
8112db7c:	defff704 	addi	sp,sp,-36
8112db80:	de00012e 	bgeu	sp,et,8112db88 <OSTimeTick+0xc>
8112db84:	003b68fa 	trap	3
8112db88:	dfc00815 	stw	ra,32(sp)
8112db8c:	df000715 	stw	fp,28(sp)
8112db90:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8112db94:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
8112db98:	113fa180 	call	8113fa18 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112db9c:	0005303a 	rdctl	r2,status
8112dba0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112dba4:	e0fffd17 	ldw	r3,-12(fp)
8112dba8:	00bfff84 	movi	r2,-2
8112dbac:	1884703a 	and	r2,r3,r2
8112dbb0:	1001703a 	wrctl	status,r2
  
  return context;
8112dbb4:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
8112dbb8:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
8112dbbc:	d0a09417 	ldw	r2,-32176(gp)
8112dbc0:	10800044 	addi	r2,r2,1
8112dbc4:	d0a09415 	stw	r2,-32176(gp)
8112dbc8:	e0bffb17 	ldw	r2,-20(fp)
8112dbcc:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112dbd0:	e0bfff17 	ldw	r2,-4(fp)
8112dbd4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
8112dbd8:	d0a08103 	ldbu	r2,-32252(gp)
8112dbdc:	10803fcc 	andi	r2,r2,255
8112dbe0:	10800058 	cmpnei	r2,r2,1
8112dbe4:	10006a1e 	bne	r2,zero,8112dd90 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
8112dbe8:	d0a08503 	ldbu	r2,-32236(gp)
8112dbec:	10803fcc 	andi	r2,r2,255
8112dbf0:	10c00060 	cmpeqi	r3,r2,1
8112dbf4:	1800061e 	bne	r3,zero,8112dc10 <OSTimeTick+0x94>
8112dbf8:	10c000a0 	cmpeqi	r3,r2,2
8112dbfc:	1800061e 	bne	r3,zero,8112dc18 <OSTimeTick+0x9c>
8112dc00:	10000a1e 	bne	r2,zero,8112dc2c <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
8112dc04:	00800044 	movi	r2,1
8112dc08:	e0bffa05 	stb	r2,-24(fp)
                 break;
8112dc0c:	00000b06 	br	8112dc3c <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
8112dc10:	e03ffa05 	stb	zero,-24(fp)
                 break;
8112dc14:	00000906 	br	8112dc3c <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
8112dc18:	00800044 	movi	r2,1
8112dc1c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
8112dc20:	00800044 	movi	r2,1
8112dc24:	d0a08505 	stb	r2,-32236(gp)
                 break;
8112dc28:	00000406 	br	8112dc3c <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
8112dc2c:	00800044 	movi	r2,1
8112dc30:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
8112dc34:	d0208505 	stb	zero,-32236(gp)
                 break;
8112dc38:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
8112dc3c:	e0bffa03 	ldbu	r2,-24(fp)
8112dc40:	10005226 	beq	r2,zero,8112dd8c <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
8112dc44:	d0a08417 	ldw	r2,-32240(gp)
8112dc48:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8112dc4c:	00004906 	br	8112dd74 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112dc50:	0005303a 	rdctl	r2,status
8112dc54:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112dc58:	e0fffc17 	ldw	r3,-16(fp)
8112dc5c:	00bfff84 	movi	r2,-2
8112dc60:	1884703a 	and	r2,r3,r2
8112dc64:	1001703a 	wrctl	status,r2
  
  return context;
8112dc68:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
8112dc6c:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
8112dc70:	e0bff917 	ldw	r2,-28(fp)
8112dc74:	10800b8b 	ldhu	r2,46(r2)
8112dc78:	10bfffcc 	andi	r2,r2,65535
8112dc7c:	10003626 	beq	r2,zero,8112dd58 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
8112dc80:	e0bff917 	ldw	r2,-28(fp)
8112dc84:	10800b8b 	ldhu	r2,46(r2)
8112dc88:	10bfffc4 	addi	r2,r2,-1
8112dc8c:	1007883a 	mov	r3,r2
8112dc90:	e0bff917 	ldw	r2,-28(fp)
8112dc94:	10c00b8d 	sth	r3,46(r2)
8112dc98:	e0bff917 	ldw	r2,-28(fp)
8112dc9c:	10800b8b 	ldhu	r2,46(r2)
8112dca0:	10bfffcc 	andi	r2,r2,65535
8112dca4:	10002c1e 	bne	r2,zero,8112dd58 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8112dca8:	e0bff917 	ldw	r2,-28(fp)
8112dcac:	10800c03 	ldbu	r2,48(r2)
8112dcb0:	10803fcc 	andi	r2,r2,255
8112dcb4:	10800dcc 	andi	r2,r2,55
8112dcb8:	10000b26 	beq	r2,zero,8112dce8 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
8112dcbc:	e0bff917 	ldw	r2,-28(fp)
8112dcc0:	10c00c03 	ldbu	r3,48(r2)
8112dcc4:	00bff204 	movi	r2,-56
8112dcc8:	1884703a 	and	r2,r3,r2
8112dccc:	1007883a 	mov	r3,r2
8112dcd0:	e0bff917 	ldw	r2,-28(fp)
8112dcd4:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
8112dcd8:	e0bff917 	ldw	r2,-28(fp)
8112dcdc:	00c00044 	movi	r3,1
8112dce0:	10c00c45 	stb	r3,49(r2)
8112dce4:	00000206 	br	8112dcf0 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8112dce8:	e0bff917 	ldw	r2,-28(fp)
8112dcec:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
8112dcf0:	e0bff917 	ldw	r2,-28(fp)
8112dcf4:	10800c03 	ldbu	r2,48(r2)
8112dcf8:	10803fcc 	andi	r2,r2,255
8112dcfc:	1080020c 	andi	r2,r2,8
8112dd00:	1000151e 	bne	r2,zero,8112dd58 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
8112dd04:	e0bff917 	ldw	r2,-28(fp)
8112dd08:	10c00d83 	ldbu	r3,54(r2)
8112dd0c:	d0a08e03 	ldbu	r2,-32200(gp)
8112dd10:	1884b03a 	or	r2,r3,r2
8112dd14:	d0a08e05 	stb	r2,-32200(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8112dd18:	e0bff917 	ldw	r2,-28(fp)
8112dd1c:	10800d03 	ldbu	r2,52(r2)
8112dd20:	10c03fcc 	andi	r3,r2,255
8112dd24:	e0bff917 	ldw	r2,-28(fp)
8112dd28:	10800d03 	ldbu	r2,52(r2)
8112dd2c:	11003fcc 	andi	r4,r2,255
8112dd30:	d0a08e44 	addi	r2,gp,-32199
8112dd34:	2085883a 	add	r2,r4,r2
8112dd38:	11000003 	ldbu	r4,0(r2)
8112dd3c:	e0bff917 	ldw	r2,-28(fp)
8112dd40:	10800d43 	ldbu	r2,53(r2)
8112dd44:	2084b03a 	or	r2,r4,r2
8112dd48:	1009883a 	mov	r4,r2
8112dd4c:	d0a08e44 	addi	r2,gp,-32199
8112dd50:	1885883a 	add	r2,r3,r2
8112dd54:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
8112dd58:	e0bff917 	ldw	r2,-28(fp)
8112dd5c:	10800517 	ldw	r2,20(r2)
8112dd60:	e0bff915 	stw	r2,-28(fp)
8112dd64:	e0bffb17 	ldw	r2,-20(fp)
8112dd68:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112dd6c:	e0bffe17 	ldw	r2,-8(fp)
8112dd70:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8112dd74:	e0bff917 	ldw	r2,-28(fp)
8112dd78:	10800c83 	ldbu	r2,50(r2)
8112dd7c:	10803fcc 	andi	r2,r2,255
8112dd80:	10800a18 	cmpnei	r2,r2,40
8112dd84:	103fb21e 	bne	r2,zero,8112dc50 <__reset+0xfb10dc50>
8112dd88:	00000106 	br	8112dd90 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
8112dd8c:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
8112dd90:	e037883a 	mov	sp,fp
8112dd94:	dfc00117 	ldw	ra,4(sp)
8112dd98:	df000017 	ldw	fp,0(sp)
8112dd9c:	dec00204 	addi	sp,sp,8
8112dda0:	f800283a 	ret

8112dda4 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
8112dda4:	deffff04 	addi	sp,sp,-4
8112dda8:	de00012e 	bgeu	sp,et,8112ddb0 <OSVersion+0xc>
8112ddac:	003b68fa 	trap	3
8112ddb0:	df000015 	stw	fp,0(sp)
8112ddb4:	d839883a 	mov	fp,sp
    return (OS_VERSION);
8112ddb8:	00804784 	movi	r2,286
}
8112ddbc:	e037883a 	mov	sp,fp
8112ddc0:	df000017 	ldw	fp,0(sp)
8112ddc4:	dec00104 	addi	sp,sp,4
8112ddc8:	f800283a 	ret

8112ddcc <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
8112ddcc:	deffff04 	addi	sp,sp,-4
8112ddd0:	de00012e 	bgeu	sp,et,8112ddd8 <OS_Dummy+0xc>
8112ddd4:	003b68fa 	trap	3
8112ddd8:	df000015 	stw	fp,0(sp)
8112dddc:	d839883a 	mov	fp,sp
}
8112dde0:	0001883a 	nop
8112dde4:	e037883a 	mov	sp,fp
8112dde8:	df000017 	ldw	fp,0(sp)
8112ddec:	dec00104 	addi	sp,sp,4
8112ddf0:	f800283a 	ret

8112ddf4 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
8112ddf4:	defff804 	addi	sp,sp,-32
8112ddf8:	de00012e 	bgeu	sp,et,8112de00 <OS_EventTaskRdy+0xc>
8112ddfc:	003b68fa 	trap	3
8112de00:	dfc00715 	stw	ra,28(sp)
8112de04:	df000615 	stw	fp,24(sp)
8112de08:	df000604 	addi	fp,sp,24
8112de0c:	e13ffc15 	stw	r4,-16(fp)
8112de10:	e17ffd15 	stw	r5,-12(fp)
8112de14:	3007883a 	mov	r3,r6
8112de18:	3805883a 	mov	r2,r7
8112de1c:	e0fffe05 	stb	r3,-8(fp)
8112de20:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
8112de24:	e0bffc17 	ldw	r2,-16(fp)
8112de28:	10800283 	ldbu	r2,10(r2)
8112de2c:	10c03fcc 	andi	r3,r2,255
8112de30:	00a04534 	movhi	r2,33044
8112de34:	10927804 	addi	r2,r2,18912
8112de38:	10c5883a 	add	r2,r2,r3
8112de3c:	10800003 	ldbu	r2,0(r2)
8112de40:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
8112de44:	e0bffa03 	ldbu	r2,-24(fp)
8112de48:	e0fffc17 	ldw	r3,-16(fp)
8112de4c:	1885883a 	add	r2,r3,r2
8112de50:	108002c4 	addi	r2,r2,11
8112de54:	10800003 	ldbu	r2,0(r2)
8112de58:	10c03fcc 	andi	r3,r2,255
8112de5c:	00a04534 	movhi	r2,33044
8112de60:	10927804 	addi	r2,r2,18912
8112de64:	10c5883a 	add	r2,r2,r3
8112de68:	10800003 	ldbu	r2,0(r2)
8112de6c:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
8112de70:	e0bffa03 	ldbu	r2,-24(fp)
8112de74:	100490fa 	slli	r2,r2,3
8112de78:	1007883a 	mov	r3,r2
8112de7c:	e0bffa43 	ldbu	r2,-23(fp)
8112de80:	1885883a 	add	r2,r3,r2
8112de84:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
8112de88:	e0fffa83 	ldbu	r3,-22(fp)
8112de8c:	00a045b4 	movhi	r2,33046
8112de90:	10bfb204 	addi	r2,r2,-312
8112de94:	18c7883a 	add	r3,r3,r3
8112de98:	18c7883a 	add	r3,r3,r3
8112de9c:	10c5883a 	add	r2,r2,r3
8112dea0:	10800017 	ldw	r2,0(r2)
8112dea4:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
8112dea8:	e0bffb17 	ldw	r2,-20(fp)
8112deac:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
8112deb0:	e0bffb17 	ldw	r2,-20(fp)
8112deb4:	e0fffd17 	ldw	r3,-12(fp)
8112deb8:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
8112debc:	e0bffb17 	ldw	r2,-20(fp)
8112dec0:	10800c03 	ldbu	r2,48(r2)
8112dec4:	1007883a 	mov	r3,r2
8112dec8:	e0bffe03 	ldbu	r2,-8(fp)
8112decc:	0084303a 	nor	r2,zero,r2
8112ded0:	1884703a 	and	r2,r3,r2
8112ded4:	1007883a 	mov	r3,r2
8112ded8:	e0bffb17 	ldw	r2,-20(fp)
8112dedc:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
8112dee0:	e0bffb17 	ldw	r2,-20(fp)
8112dee4:	e0ffff03 	ldbu	r3,-4(fp)
8112dee8:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
8112deec:	e0bffb17 	ldw	r2,-20(fp)
8112def0:	10800c03 	ldbu	r2,48(r2)
8112def4:	10803fcc 	andi	r2,r2,255
8112def8:	1080020c 	andi	r2,r2,8
8112defc:	1000111e 	bne	r2,zero,8112df44 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
8112df00:	e0bffb17 	ldw	r2,-20(fp)
8112df04:	10c00d83 	ldbu	r3,54(r2)
8112df08:	d0a08e03 	ldbu	r2,-32200(gp)
8112df0c:	1884b03a 	or	r2,r3,r2
8112df10:	d0a08e05 	stb	r2,-32200(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
8112df14:	e0fffa03 	ldbu	r3,-24(fp)
8112df18:	e13ffa03 	ldbu	r4,-24(fp)
8112df1c:	d0a08e44 	addi	r2,gp,-32199
8112df20:	2085883a 	add	r2,r4,r2
8112df24:	11000003 	ldbu	r4,0(r2)
8112df28:	e0bffb17 	ldw	r2,-20(fp)
8112df2c:	10800d43 	ldbu	r2,53(r2)
8112df30:	2084b03a 	or	r2,r4,r2
8112df34:	1009883a 	mov	r4,r2
8112df38:	d0a08e44 	addi	r2,gp,-32199
8112df3c:	1885883a 	add	r2,r3,r2
8112df40:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
8112df44:	e17ffc17 	ldw	r5,-16(fp)
8112df48:	e13ffb17 	ldw	r4,-20(fp)
8112df4c:	112e2040 	call	8112e204 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
8112df50:	e0bffb17 	ldw	r2,-20(fp)
8112df54:	10800817 	ldw	r2,32(r2)
8112df58:	10000826 	beq	r2,zero,8112df7c <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8112df5c:	e0bffb17 	ldw	r2,-20(fp)
8112df60:	10800817 	ldw	r2,32(r2)
8112df64:	100b883a 	mov	r5,r2
8112df68:	e13ffb17 	ldw	r4,-20(fp)
8112df6c:	112e2c40 	call	8112e2c4 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
8112df70:	e0bffb17 	ldw	r2,-20(fp)
8112df74:	e0fffc17 	ldw	r3,-16(fp)
8112df78:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
8112df7c:	e0bffa83 	ldbu	r2,-22(fp)
}
8112df80:	e037883a 	mov	sp,fp
8112df84:	dfc00117 	ldw	ra,4(sp)
8112df88:	df000017 	ldw	fp,0(sp)
8112df8c:	dec00204 	addi	sp,sp,8
8112df90:	f800283a 	ret

8112df94 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
8112df94:	defffd04 	addi	sp,sp,-12
8112df98:	de00012e 	bgeu	sp,et,8112dfa0 <OS_EventTaskWait+0xc>
8112df9c:	003b68fa 	trap	3
8112dfa0:	df000215 	stw	fp,8(sp)
8112dfa4:	df000204 	addi	fp,sp,8
8112dfa8:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
8112dfac:	d0a09217 	ldw	r2,-32184(gp)
8112dfb0:	e0ffff17 	ldw	r3,-4(fp)
8112dfb4:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
8112dfb8:	d0a09217 	ldw	r2,-32184(gp)
8112dfbc:	10800d03 	ldbu	r2,52(r2)
8112dfc0:	10803fcc 	andi	r2,r2,255
8112dfc4:	d0e09217 	ldw	r3,-32184(gp)
8112dfc8:	18c00d03 	ldbu	r3,52(r3)
8112dfcc:	18c03fcc 	andi	r3,r3,255
8112dfd0:	e13fff17 	ldw	r4,-4(fp)
8112dfd4:	20c7883a 	add	r3,r4,r3
8112dfd8:	18c002c4 	addi	r3,r3,11
8112dfdc:	19000003 	ldbu	r4,0(r3)
8112dfe0:	d0e09217 	ldw	r3,-32184(gp)
8112dfe4:	18c00d43 	ldbu	r3,53(r3)
8112dfe8:	20c6b03a 	or	r3,r4,r3
8112dfec:	1809883a 	mov	r4,r3
8112dff0:	e0ffff17 	ldw	r3,-4(fp)
8112dff4:	1885883a 	add	r2,r3,r2
8112dff8:	108002c4 	addi	r2,r2,11
8112dffc:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8112e000:	e0bfff17 	ldw	r2,-4(fp)
8112e004:	10c00283 	ldbu	r3,10(r2)
8112e008:	d0a09217 	ldw	r2,-32184(gp)
8112e00c:	10800d83 	ldbu	r2,54(r2)
8112e010:	1884b03a 	or	r2,r3,r2
8112e014:	1007883a 	mov	r3,r2
8112e018:	e0bfff17 	ldw	r2,-4(fp)
8112e01c:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8112e020:	d0a09217 	ldw	r2,-32184(gp)
8112e024:	10800d03 	ldbu	r2,52(r2)
8112e028:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8112e02c:	e0fffe03 	ldbu	r3,-8(fp)
8112e030:	e13ffe03 	ldbu	r4,-8(fp)
8112e034:	d0a08e44 	addi	r2,gp,-32199
8112e038:	2085883a 	add	r2,r4,r2
8112e03c:	10800003 	ldbu	r2,0(r2)
8112e040:	1009883a 	mov	r4,r2
8112e044:	d0a09217 	ldw	r2,-32184(gp)
8112e048:	10800d43 	ldbu	r2,53(r2)
8112e04c:	0084303a 	nor	r2,zero,r2
8112e050:	2084703a 	and	r2,r4,r2
8112e054:	1009883a 	mov	r4,r2
8112e058:	d0a08e44 	addi	r2,gp,-32199
8112e05c:	1885883a 	add	r2,r3,r2
8112e060:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8112e064:	e0fffe03 	ldbu	r3,-8(fp)
8112e068:	d0a08e44 	addi	r2,gp,-32199
8112e06c:	1885883a 	add	r2,r3,r2
8112e070:	10800003 	ldbu	r2,0(r2)
8112e074:	10803fcc 	andi	r2,r2,255
8112e078:	1000071e 	bne	r2,zero,8112e098 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8112e07c:	d0a09217 	ldw	r2,-32184(gp)
8112e080:	10800d83 	ldbu	r2,54(r2)
8112e084:	0084303a 	nor	r2,zero,r2
8112e088:	1007883a 	mov	r3,r2
8112e08c:	d0a08e03 	ldbu	r2,-32200(gp)
8112e090:	1884703a 	and	r2,r3,r2
8112e094:	d0a08e05 	stb	r2,-32200(gp)
    }
}
8112e098:	0001883a 	nop
8112e09c:	e037883a 	mov	sp,fp
8112e0a0:	df000017 	ldw	fp,0(sp)
8112e0a4:	dec00104 	addi	sp,sp,4
8112e0a8:	f800283a 	ret

8112e0ac <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
8112e0ac:	defffb04 	addi	sp,sp,-20
8112e0b0:	de00012e 	bgeu	sp,et,8112e0b8 <OS_EventTaskWaitMulti+0xc>
8112e0b4:	003b68fa 	trap	3
8112e0b8:	df000415 	stw	fp,16(sp)
8112e0bc:	df000404 	addi	fp,sp,16
8112e0c0:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
8112e0c4:	d0a09217 	ldw	r2,-32184(gp)
8112e0c8:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
8112e0cc:	d0a09217 	ldw	r2,-32184(gp)
8112e0d0:	e0ffff17 	ldw	r3,-4(fp)
8112e0d4:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
8112e0d8:	e0bfff17 	ldw	r2,-4(fp)
8112e0dc:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
8112e0e0:	e0bffc17 	ldw	r2,-16(fp)
8112e0e4:	10800017 	ldw	r2,0(r2)
8112e0e8:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8112e0ec:	00002006 	br	8112e170 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
8112e0f0:	d0a09217 	ldw	r2,-32184(gp)
8112e0f4:	10800d03 	ldbu	r2,52(r2)
8112e0f8:	10803fcc 	andi	r2,r2,255
8112e0fc:	d0e09217 	ldw	r3,-32184(gp)
8112e100:	18c00d03 	ldbu	r3,52(r3)
8112e104:	18c03fcc 	andi	r3,r3,255
8112e108:	e13ffd17 	ldw	r4,-12(fp)
8112e10c:	20c7883a 	add	r3,r4,r3
8112e110:	18c002c4 	addi	r3,r3,11
8112e114:	19000003 	ldbu	r4,0(r3)
8112e118:	d0e09217 	ldw	r3,-32184(gp)
8112e11c:	18c00d43 	ldbu	r3,53(r3)
8112e120:	20c6b03a 	or	r3,r4,r3
8112e124:	1809883a 	mov	r4,r3
8112e128:	e0fffd17 	ldw	r3,-12(fp)
8112e12c:	1885883a 	add	r2,r3,r2
8112e130:	108002c4 	addi	r2,r2,11
8112e134:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8112e138:	e0bffd17 	ldw	r2,-12(fp)
8112e13c:	10c00283 	ldbu	r3,10(r2)
8112e140:	d0a09217 	ldw	r2,-32184(gp)
8112e144:	10800d83 	ldbu	r2,54(r2)
8112e148:	1884b03a 	or	r2,r3,r2
8112e14c:	1007883a 	mov	r3,r2
8112e150:	e0bffd17 	ldw	r2,-12(fp)
8112e154:	10c00285 	stb	r3,10(r2)
        pevents++;
8112e158:	e0bffc17 	ldw	r2,-16(fp)
8112e15c:	10800104 	addi	r2,r2,4
8112e160:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
8112e164:	e0bffc17 	ldw	r2,-16(fp)
8112e168:	10800017 	ldw	r2,0(r2)
8112e16c:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8112e170:	e0bffd17 	ldw	r2,-12(fp)
8112e174:	103fde1e 	bne	r2,zero,8112e0f0 <__reset+0xfb10e0f0>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8112e178:	d0a09217 	ldw	r2,-32184(gp)
8112e17c:	10800d03 	ldbu	r2,52(r2)
8112e180:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8112e184:	e0fffe03 	ldbu	r3,-8(fp)
8112e188:	e13ffe03 	ldbu	r4,-8(fp)
8112e18c:	d0a08e44 	addi	r2,gp,-32199
8112e190:	2085883a 	add	r2,r4,r2
8112e194:	10800003 	ldbu	r2,0(r2)
8112e198:	1009883a 	mov	r4,r2
8112e19c:	d0a09217 	ldw	r2,-32184(gp)
8112e1a0:	10800d43 	ldbu	r2,53(r2)
8112e1a4:	0084303a 	nor	r2,zero,r2
8112e1a8:	2084703a 	and	r2,r4,r2
8112e1ac:	1009883a 	mov	r4,r2
8112e1b0:	d0a08e44 	addi	r2,gp,-32199
8112e1b4:	1885883a 	add	r2,r3,r2
8112e1b8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8112e1bc:	e0fffe03 	ldbu	r3,-8(fp)
8112e1c0:	d0a08e44 	addi	r2,gp,-32199
8112e1c4:	1885883a 	add	r2,r3,r2
8112e1c8:	10800003 	ldbu	r2,0(r2)
8112e1cc:	10803fcc 	andi	r2,r2,255
8112e1d0:	1000071e 	bne	r2,zero,8112e1f0 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8112e1d4:	d0a09217 	ldw	r2,-32184(gp)
8112e1d8:	10800d83 	ldbu	r2,54(r2)
8112e1dc:	0084303a 	nor	r2,zero,r2
8112e1e0:	1007883a 	mov	r3,r2
8112e1e4:	d0a08e03 	ldbu	r2,-32200(gp)
8112e1e8:	1884703a 	and	r2,r3,r2
8112e1ec:	d0a08e05 	stb	r2,-32200(gp)
    }
}
8112e1f0:	0001883a 	nop
8112e1f4:	e037883a 	mov	sp,fp
8112e1f8:	df000017 	ldw	fp,0(sp)
8112e1fc:	dec00104 	addi	sp,sp,4
8112e200:	f800283a 	ret

8112e204 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
8112e204:	defffc04 	addi	sp,sp,-16
8112e208:	de00012e 	bgeu	sp,et,8112e210 <OS_EventTaskRemove+0xc>
8112e20c:	003b68fa 	trap	3
8112e210:	df000315 	stw	fp,12(sp)
8112e214:	df000304 	addi	fp,sp,12
8112e218:	e13ffe15 	stw	r4,-8(fp)
8112e21c:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
8112e220:	e0bffe17 	ldw	r2,-8(fp)
8112e224:	10800d03 	ldbu	r2,52(r2)
8112e228:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
8112e22c:	e0bffd03 	ldbu	r2,-12(fp)
8112e230:	e0fffd03 	ldbu	r3,-12(fp)
8112e234:	e13fff17 	ldw	r4,-4(fp)
8112e238:	20c7883a 	add	r3,r4,r3
8112e23c:	18c002c4 	addi	r3,r3,11
8112e240:	18c00003 	ldbu	r3,0(r3)
8112e244:	1809883a 	mov	r4,r3
8112e248:	e0fffe17 	ldw	r3,-8(fp)
8112e24c:	18c00d43 	ldbu	r3,53(r3)
8112e250:	00c6303a 	nor	r3,zero,r3
8112e254:	20c6703a 	and	r3,r4,r3
8112e258:	1809883a 	mov	r4,r3
8112e25c:	e0ffff17 	ldw	r3,-4(fp)
8112e260:	1885883a 	add	r2,r3,r2
8112e264:	108002c4 	addi	r2,r2,11
8112e268:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
8112e26c:	e0bffd03 	ldbu	r2,-12(fp)
8112e270:	e0ffff17 	ldw	r3,-4(fp)
8112e274:	1885883a 	add	r2,r3,r2
8112e278:	108002c4 	addi	r2,r2,11
8112e27c:	10800003 	ldbu	r2,0(r2)
8112e280:	10803fcc 	andi	r2,r2,255
8112e284:	10000a1e 	bne	r2,zero,8112e2b0 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
8112e288:	e0bfff17 	ldw	r2,-4(fp)
8112e28c:	10800283 	ldbu	r2,10(r2)
8112e290:	1007883a 	mov	r3,r2
8112e294:	e0bffe17 	ldw	r2,-8(fp)
8112e298:	10800d83 	ldbu	r2,54(r2)
8112e29c:	0084303a 	nor	r2,zero,r2
8112e2a0:	1884703a 	and	r2,r3,r2
8112e2a4:	1007883a 	mov	r3,r2
8112e2a8:	e0bfff17 	ldw	r2,-4(fp)
8112e2ac:	10c00285 	stb	r3,10(r2)
    }
}
8112e2b0:	0001883a 	nop
8112e2b4:	e037883a 	mov	sp,fp
8112e2b8:	df000017 	ldw	fp,0(sp)
8112e2bc:	dec00104 	addi	sp,sp,4
8112e2c0:	f800283a 	ret

8112e2c4 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
8112e2c4:	defffa04 	addi	sp,sp,-24
8112e2c8:	de00012e 	bgeu	sp,et,8112e2d0 <OS_EventTaskRemoveMulti+0xc>
8112e2cc:	003b68fa 	trap	3
8112e2d0:	df000515 	stw	fp,20(sp)
8112e2d4:	df000504 	addi	fp,sp,20
8112e2d8:	e13ffe15 	stw	r4,-8(fp)
8112e2dc:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
8112e2e0:	e0bffe17 	ldw	r2,-8(fp)
8112e2e4:	10800d03 	ldbu	r2,52(r2)
8112e2e8:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
8112e2ec:	e0bffe17 	ldw	r2,-8(fp)
8112e2f0:	10800d83 	ldbu	r2,54(r2)
8112e2f4:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
8112e2f8:	e0bffe17 	ldw	r2,-8(fp)
8112e2fc:	10800d43 	ldbu	r2,53(r2)
8112e300:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
8112e304:	e0bfff17 	ldw	r2,-4(fp)
8112e308:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
8112e30c:	e0bffb17 	ldw	r2,-20(fp)
8112e310:	10800017 	ldw	r2,0(r2)
8112e314:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8112e318:	00002506 	br	8112e3b0 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
8112e31c:	e0bffd03 	ldbu	r2,-12(fp)
8112e320:	e0fffd03 	ldbu	r3,-12(fp)
8112e324:	e13ffc17 	ldw	r4,-16(fp)
8112e328:	20c7883a 	add	r3,r4,r3
8112e32c:	18c002c4 	addi	r3,r3,11
8112e330:	18c00003 	ldbu	r3,0(r3)
8112e334:	1809883a 	mov	r4,r3
8112e338:	e0fffd83 	ldbu	r3,-10(fp)
8112e33c:	00c6303a 	nor	r3,zero,r3
8112e340:	20c6703a 	and	r3,r4,r3
8112e344:	1809883a 	mov	r4,r3
8112e348:	e0fffc17 	ldw	r3,-16(fp)
8112e34c:	1885883a 	add	r2,r3,r2
8112e350:	108002c4 	addi	r2,r2,11
8112e354:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
8112e358:	e0bffd03 	ldbu	r2,-12(fp)
8112e35c:	e0fffc17 	ldw	r3,-16(fp)
8112e360:	1885883a 	add	r2,r3,r2
8112e364:	108002c4 	addi	r2,r2,11
8112e368:	10800003 	ldbu	r2,0(r2)
8112e36c:	10803fcc 	andi	r2,r2,255
8112e370:	1000091e 	bne	r2,zero,8112e398 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8112e374:	e0bffc17 	ldw	r2,-16(fp)
8112e378:	10800283 	ldbu	r2,10(r2)
8112e37c:	1007883a 	mov	r3,r2
8112e380:	e0bffd43 	ldbu	r2,-11(fp)
8112e384:	0084303a 	nor	r2,zero,r2
8112e388:	1884703a 	and	r2,r3,r2
8112e38c:	1007883a 	mov	r3,r2
8112e390:	e0bffc17 	ldw	r2,-16(fp)
8112e394:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
8112e398:	e0bffb17 	ldw	r2,-20(fp)
8112e39c:	10800104 	addi	r2,r2,4
8112e3a0:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
8112e3a4:	e0bffb17 	ldw	r2,-20(fp)
8112e3a8:	10800017 	ldw	r2,0(r2)
8112e3ac:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8112e3b0:	e0bffc17 	ldw	r2,-16(fp)
8112e3b4:	103fd91e 	bne	r2,zero,8112e31c <__reset+0xfb10e31c>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
8112e3b8:	0001883a 	nop
8112e3bc:	e037883a 	mov	sp,fp
8112e3c0:	df000017 	ldw	fp,0(sp)
8112e3c4:	dec00104 	addi	sp,sp,4
8112e3c8:	f800283a 	ret

8112e3cc <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
8112e3cc:	defffc04 	addi	sp,sp,-16
8112e3d0:	de00012e 	bgeu	sp,et,8112e3d8 <OS_EventWaitListInit+0xc>
8112e3d4:	003b68fa 	trap	3
8112e3d8:	df000315 	stw	fp,12(sp)
8112e3dc:	df000304 	addi	fp,sp,12
8112e3e0:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
8112e3e4:	e0bfff17 	ldw	r2,-4(fp)
8112e3e8:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
8112e3ec:	e0bfff17 	ldw	r2,-4(fp)
8112e3f0:	108002c4 	addi	r2,r2,11
8112e3f4:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112e3f8:	e03ffe05 	stb	zero,-8(fp)
8112e3fc:	00000706 	br	8112e41c <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
8112e400:	e0bffd17 	ldw	r2,-12(fp)
8112e404:	10c00044 	addi	r3,r2,1
8112e408:	e0fffd15 	stw	r3,-12(fp)
8112e40c:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112e410:	e0bffe03 	ldbu	r2,-8(fp)
8112e414:	10800044 	addi	r2,r2,1
8112e418:	e0bffe05 	stb	r2,-8(fp)
8112e41c:	e0bffe03 	ldbu	r2,-8(fp)
8112e420:	108001b0 	cmpltui	r2,r2,6
8112e424:	103ff61e 	bne	r2,zero,8112e400 <__reset+0xfb10e400>
        *ptbl++ = 0;
    }
}
8112e428:	0001883a 	nop
8112e42c:	e037883a 	mov	sp,fp
8112e430:	df000017 	ldw	fp,0(sp)
8112e434:	dec00104 	addi	sp,sp,4
8112e438:	f800283a 	ret

8112e43c <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
8112e43c:	defffb04 	addi	sp,sp,-20
8112e440:	de00012e 	bgeu	sp,et,8112e448 <OS_InitEventList+0xc>
8112e444:	003b68fa 	trap	3
8112e448:	dfc00415 	stw	ra,16(sp)
8112e44c:	df000315 	stw	fp,12(sp)
8112e450:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8112e454:	01434004 	movi	r5,3328
8112e458:	012045b4 	movhi	r4,33046
8112e45c:	2138dc04 	addi	r4,r4,-7312
8112e460:	112e7e40 	call	8112e7e4 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8112e464:	00a045b4 	movhi	r2,33046
8112e468:	10b8dc04 	addi	r2,r2,-7312
8112e46c:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
8112e470:	00a045b4 	movhi	r2,33046
8112e474:	10b8e904 	addi	r2,r2,-7260
8112e478:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8112e47c:	e03ffd0d 	sth	zero,-12(fp)
8112e480:	00001306 	br	8112e4d0 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8112e484:	e0bffe17 	ldw	r2,-8(fp)
8112e488:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
8112e48c:	e0bffe17 	ldw	r2,-8(fp)
8112e490:	e0ffff17 	ldw	r3,-4(fp)
8112e494:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
8112e498:	e0bffe17 	ldw	r2,-8(fp)
8112e49c:	00c00fc4 	movi	r3,63
8112e4a0:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
8112e4a4:	e0bffe17 	ldw	r2,-8(fp)
8112e4a8:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
8112e4ac:	e0bffe17 	ldw	r2,-8(fp)
8112e4b0:	10800d04 	addi	r2,r2,52
8112e4b4:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
8112e4b8:	e0bfff17 	ldw	r2,-4(fp)
8112e4bc:	10800d04 	addi	r2,r2,52
8112e4c0:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8112e4c4:	e0bffd0b 	ldhu	r2,-12(fp)
8112e4c8:	10800044 	addi	r2,r2,1
8112e4cc:	e0bffd0d 	sth	r2,-12(fp)
8112e4d0:	e0bffd0b 	ldhu	r2,-12(fp)
8112e4d4:	10800ff0 	cmpltui	r2,r2,63
8112e4d8:	103fea1e 	bne	r2,zero,8112e484 <__reset+0xfb10e484>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
8112e4dc:	e0bffe17 	ldw	r2,-8(fp)
8112e4e0:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
8112e4e4:	e0bffe17 	ldw	r2,-8(fp)
8112e4e8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
8112e4ec:	e0bffe17 	ldw	r2,-8(fp)
8112e4f0:	00c00fc4 	movi	r3,63
8112e4f4:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
8112e4f8:	e0bffe17 	ldw	r2,-8(fp)
8112e4fc:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
8112e500:	00a045b4 	movhi	r2,33046
8112e504:	10b8dc04 	addi	r2,r2,-7312
8112e508:	d0a09015 	stw	r2,-32192(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
8112e50c:	0001883a 	nop
8112e510:	e037883a 	mov	sp,fp
8112e514:	dfc00117 	ldw	ra,4(sp)
8112e518:	df000017 	ldw	fp,0(sp)
8112e51c:	dec00204 	addi	sp,sp,8
8112e520:	f800283a 	ret

8112e524 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
8112e524:	deffff04 	addi	sp,sp,-4
8112e528:	de00012e 	bgeu	sp,et,8112e530 <OS_InitMisc+0xc>
8112e52c:	003b68fa 	trap	3
8112e530:	df000015 	stw	fp,0(sp)
8112e534:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
8112e538:	d0209415 	stw	zero,-32176(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
8112e53c:	d0209105 	stb	zero,-32188(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
8112e540:	d0207f05 	stb	zero,-32260(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
8112e544:	d0208a45 	stb	zero,-32215(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
8112e548:	d0208105 	stb	zero,-32252(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
8112e54c:	d0208615 	stw	zero,-32232(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
8112e550:	d0208215 	stw	zero,-32248(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8112e554:	d0209815 	stw	zero,-32160(gp)
    OSIdleCtrMax  = 0L;
8112e558:	d0208815 	stw	zero,-32224(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
8112e55c:	d0209705 	stb	zero,-32164(gp)
#endif
}
8112e560:	0001883a 	nop
8112e564:	e037883a 	mov	sp,fp
8112e568:	df000017 	ldw	fp,0(sp)
8112e56c:	dec00104 	addi	sp,sp,4
8112e570:	f800283a 	ret

8112e574 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8112e574:	defffd04 	addi	sp,sp,-12
8112e578:	de00012e 	bgeu	sp,et,8112e580 <OS_InitRdyList+0xc>
8112e57c:	003b68fa 	trap	3
8112e580:	df000215 	stw	fp,8(sp)
8112e584:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
8112e588:	d0208e05 	stb	zero,-32200(gp)
    prdytbl       = &OSRdyTbl[0];
8112e58c:	d0a08e44 	addi	r2,gp,-32199
8112e590:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8112e594:	e03ffe05 	stb	zero,-8(fp)
8112e598:	00000706 	br	8112e5b8 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
8112e59c:	e0bfff17 	ldw	r2,-4(fp)
8112e5a0:	10c00044 	addi	r3,r2,1
8112e5a4:	e0ffff15 	stw	r3,-4(fp)
8112e5a8:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8112e5ac:	e0bffe03 	ldbu	r2,-8(fp)
8112e5b0:	10800044 	addi	r2,r2,1
8112e5b4:	e0bffe05 	stb	r2,-8(fp)
8112e5b8:	e0bffe03 	ldbu	r2,-8(fp)
8112e5bc:	108001b0 	cmpltui	r2,r2,6
8112e5c0:	103ff61e 	bne	r2,zero,8112e59c <__reset+0xfb10e59c>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
8112e5c4:	d02083c5 	stb	zero,-32241(gp)
    OSPrioHighRdy = 0;
8112e5c8:	d0208385 	stb	zero,-32242(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
8112e5cc:	d0208c15 	stw	zero,-32208(gp)
    OSTCBCur      = (OS_TCB *)0;
8112e5d0:	d0209215 	stw	zero,-32184(gp)
}
8112e5d4:	0001883a 	nop
8112e5d8:	e037883a 	mov	sp,fp
8112e5dc:	df000017 	ldw	fp,0(sp)
8112e5e0:	dec00104 	addi	sp,sp,4
8112e5e4:	f800283a 	ret

8112e5e8 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
8112e5e8:	defff804 	addi	sp,sp,-32
8112e5ec:	de00012e 	bgeu	sp,et,8112e5f4 <OS_InitTaskIdle+0xc>
8112e5f0:	003b68fa 	trap	3
8112e5f4:	dfc00715 	stw	ra,28(sp)
8112e5f8:	df000615 	stw	fp,24(sp)
8112e5fc:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
8112e600:	008000c4 	movi	r2,3
8112e604:	d8800415 	stw	r2,16(sp)
8112e608:	d8000315 	stw	zero,12(sp)
8112e60c:	00810004 	movi	r2,1024
8112e610:	d8800215 	stw	r2,8(sp)
8112e614:	00a045b4 	movhi	r2,33046
8112e618:	10b4dc04 	addi	r2,r2,-11408
8112e61c:	d8800115 	stw	r2,4(sp)
8112e620:	00bfffd4 	movui	r2,65535
8112e624:	d8800015 	stw	r2,0(sp)
8112e628:	01c00a04 	movi	r7,40
8112e62c:	01a045b4 	movhi	r6,33046
8112e630:	31b8db04 	addi	r6,r6,-7316
8112e634:	000b883a 	mov	r5,zero
8112e638:	012044f4 	movhi	r4,33043
8112e63c:	213ab704 	addi	r4,r4,-5412
8112e640:	11343180 	call	81134318 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
8112e644:	e1bfff04 	addi	r6,fp,-4
8112e648:	01604534 	movhi	r5,33044
8112e64c:	2952b804 	addi	r5,r5,19168
8112e650:	01000a04 	movi	r4,40
8112e654:	1134b480 	call	81134b48 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
8112e658:	0001883a 	nop
8112e65c:	e037883a 	mov	sp,fp
8112e660:	dfc00117 	ldw	ra,4(sp)
8112e664:	df000017 	ldw	fp,0(sp)
8112e668:	dec00204 	addi	sp,sp,8
8112e66c:	f800283a 	ret

8112e670 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
8112e670:	defff804 	addi	sp,sp,-32
8112e674:	de00012e 	bgeu	sp,et,8112e67c <OS_InitTaskStat+0xc>
8112e678:	003b68fa 	trap	3
8112e67c:	dfc00715 	stw	ra,28(sp)
8112e680:	df000615 	stw	fp,24(sp)
8112e684:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
8112e688:	008000c4 	movi	r2,3
8112e68c:	d8800415 	stw	r2,16(sp)
8112e690:	d8000315 	stw	zero,12(sp)
8112e694:	00810004 	movi	r2,1024
8112e698:	d8800215 	stw	r2,8(sp)
8112e69c:	00a045b4 	movhi	r2,33046
8112e6a0:	10ae7c04 	addi	r2,r2,-17936
8112e6a4:	d8800115 	stw	r2,4(sp)
8112e6a8:	00bfff94 	movui	r2,65534
8112e6ac:	d8800015 	stw	r2,0(sp)
8112e6b0:	01c009c4 	movi	r7,39
8112e6b4:	01a045b4 	movhi	r6,33046
8112e6b8:	31b27b04 	addi	r6,r6,-13844
8112e6bc:	000b883a 	mov	r5,zero
8112e6c0:	012044f4 	movhi	r4,33043
8112e6c4:	213ad004 	addi	r4,r4,-5312
8112e6c8:	11343180 	call	81134318 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
8112e6cc:	e1bfff04 	addi	r6,fp,-4
8112e6d0:	01604534 	movhi	r5,33044
8112e6d4:	2952bc04 	addi	r5,r5,19184
8112e6d8:	010009c4 	movi	r4,39
8112e6dc:	1134b480 	call	81134b48 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
8112e6e0:	0001883a 	nop
8112e6e4:	e037883a 	mov	sp,fp
8112e6e8:	dfc00117 	ldw	ra,4(sp)
8112e6ec:	df000017 	ldw	fp,0(sp)
8112e6f0:	dec00204 	addi	sp,sp,8
8112e6f4:	f800283a 	ret

8112e6f8 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
8112e6f8:	defffb04 	addi	sp,sp,-20
8112e6fc:	de00012e 	bgeu	sp,et,8112e704 <OS_InitTCBList+0xc>
8112e700:	003b68fa 	trap	3
8112e704:	dfc00415 	stw	ra,16(sp)
8112e708:	df000315 	stw	fp,12(sp)
8112e70c:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
8112e710:	01439604 	movi	r5,3672
8112e714:	012045b4 	movhi	r4,33046
8112e718:	213c1c04 	addi	r4,r4,-3984
8112e71c:	112e7e40 	call	8112e7e4 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
8112e720:	01402904 	movi	r5,164
8112e724:	012045b4 	movhi	r4,33046
8112e728:	213fb204 	addi	r4,r4,-312
8112e72c:	112e7e40 	call	8112e7e4 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
8112e730:	00a045b4 	movhi	r2,33046
8112e734:	10bc1c04 	addi	r2,r2,-3984
8112e738:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
8112e73c:	00a045b4 	movhi	r2,33046
8112e740:	10bc3704 	addi	r2,r2,-3876
8112e744:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8112e748:	e03ffd05 	stb	zero,-12(fp)
8112e74c:	00001106 	br	8112e794 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
8112e750:	e0bffe17 	ldw	r2,-8(fp)
8112e754:	e0ffff17 	ldw	r3,-4(fp)
8112e758:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
8112e75c:	e0bffe17 	ldw	r2,-8(fp)
8112e760:	00c00fc4 	movi	r3,63
8112e764:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8112e768:	e0bffe17 	ldw	r2,-8(fp)
8112e76c:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
8112e770:	e0bffe17 	ldw	r2,-8(fp)
8112e774:	10801b04 	addi	r2,r2,108
8112e778:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
8112e77c:	e0bfff17 	ldw	r2,-4(fp)
8112e780:	10801b04 	addi	r2,r2,108
8112e784:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8112e788:	e0bffd03 	ldbu	r2,-12(fp)
8112e78c:	10800044 	addi	r2,r2,1
8112e790:	e0bffd05 	stb	r2,-12(fp)
8112e794:	e0bffd03 	ldbu	r2,-12(fp)
8112e798:	10800870 	cmpltui	r2,r2,33
8112e79c:	103fec1e 	bne	r2,zero,8112e750 <__reset+0xfb10e750>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
8112e7a0:	e0bffe17 	ldw	r2,-8(fp)
8112e7a4:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
8112e7a8:	e0bffe17 	ldw	r2,-8(fp)
8112e7ac:	00c00fc4 	movi	r3,63
8112e7b0:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8112e7b4:	e0bffe17 	ldw	r2,-8(fp)
8112e7b8:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
8112e7bc:	d0208415 	stw	zero,-32240(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
8112e7c0:	00a045b4 	movhi	r2,33046
8112e7c4:	10bc1c04 	addi	r2,r2,-3984
8112e7c8:	d0a08915 	stw	r2,-32220(gp)
}
8112e7cc:	0001883a 	nop
8112e7d0:	e037883a 	mov	sp,fp
8112e7d4:	dfc00117 	ldw	ra,4(sp)
8112e7d8:	df000017 	ldw	fp,0(sp)
8112e7dc:	dec00204 	addi	sp,sp,8
8112e7e0:	f800283a 	ret

8112e7e4 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
8112e7e4:	defffd04 	addi	sp,sp,-12
8112e7e8:	de00012e 	bgeu	sp,et,8112e7f0 <OS_MemClr+0xc>
8112e7ec:	003b68fa 	trap	3
8112e7f0:	df000215 	stw	fp,8(sp)
8112e7f4:	df000204 	addi	fp,sp,8
8112e7f8:	e13ffe15 	stw	r4,-8(fp)
8112e7fc:	2805883a 	mov	r2,r5
8112e800:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8112e804:	00000706 	br	8112e824 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
8112e808:	e0bffe17 	ldw	r2,-8(fp)
8112e80c:	10c00044 	addi	r3,r2,1
8112e810:	e0fffe15 	stw	r3,-8(fp)
8112e814:	10000005 	stb	zero,0(r2)
        size--;
8112e818:	e0bfff0b 	ldhu	r2,-4(fp)
8112e81c:	10bfffc4 	addi	r2,r2,-1
8112e820:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
8112e824:	e0bfff0b 	ldhu	r2,-4(fp)
8112e828:	103ff71e 	bne	r2,zero,8112e808 <__reset+0xfb10e808>
        *pdest++ = (INT8U)0;
        size--;
    }
}
8112e82c:	0001883a 	nop
8112e830:	e037883a 	mov	sp,fp
8112e834:	df000017 	ldw	fp,0(sp)
8112e838:	dec00104 	addi	sp,sp,4
8112e83c:	f800283a 	ret

8112e840 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
8112e840:	defffc04 	addi	sp,sp,-16
8112e844:	de00012e 	bgeu	sp,et,8112e84c <OS_MemCopy+0xc>
8112e848:	003b68fa 	trap	3
8112e84c:	df000315 	stw	fp,12(sp)
8112e850:	df000304 	addi	fp,sp,12
8112e854:	e13ffd15 	stw	r4,-12(fp)
8112e858:	e17ffe15 	stw	r5,-8(fp)
8112e85c:	3005883a 	mov	r2,r6
8112e860:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8112e864:	00000b06 	br	8112e894 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
8112e868:	e0bffd17 	ldw	r2,-12(fp)
8112e86c:	10c00044 	addi	r3,r2,1
8112e870:	e0fffd15 	stw	r3,-12(fp)
8112e874:	e0fffe17 	ldw	r3,-8(fp)
8112e878:	19000044 	addi	r4,r3,1
8112e87c:	e13ffe15 	stw	r4,-8(fp)
8112e880:	18c00003 	ldbu	r3,0(r3)
8112e884:	10c00005 	stb	r3,0(r2)
        size--;
8112e888:	e0bfff0b 	ldhu	r2,-4(fp)
8112e88c:	10bfffc4 	addi	r2,r2,-1
8112e890:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
8112e894:	e0bfff0b 	ldhu	r2,-4(fp)
8112e898:	103ff31e 	bne	r2,zero,8112e868 <__reset+0xfb10e868>
        *pdest++ = *psrc++;
        size--;
    }
}
8112e89c:	0001883a 	nop
8112e8a0:	e037883a 	mov	sp,fp
8112e8a4:	df000017 	ldw	fp,0(sp)
8112e8a8:	dec00104 	addi	sp,sp,4
8112e8ac:	f800283a 	ret

8112e8b0 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
8112e8b0:	defffb04 	addi	sp,sp,-20
8112e8b4:	de00012e 	bgeu	sp,et,8112e8bc <OS_Sched+0xc>
8112e8b8:	003b68fa 	trap	3
8112e8bc:	dfc00415 	stw	ra,16(sp)
8112e8c0:	df000315 	stw	fp,12(sp)
8112e8c4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8112e8c8:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e8cc:	0005303a 	rdctl	r2,status
8112e8d0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e8d4:	e0ffff17 	ldw	r3,-4(fp)
8112e8d8:	00bfff84 	movi	r2,-2
8112e8dc:	1884703a 	and	r2,r3,r2
8112e8e0:	1001703a 	wrctl	status,r2
  
  return context;
8112e8e4:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
8112e8e8:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
8112e8ec:	d0a09103 	ldbu	r2,-32188(gp)
8112e8f0:	10803fcc 	andi	r2,r2,255
8112e8f4:	10001a1e 	bne	r2,zero,8112e960 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
8112e8f8:	d0a07f03 	ldbu	r2,-32260(gp)
8112e8fc:	10803fcc 	andi	r2,r2,255
8112e900:	1000171e 	bne	r2,zero,8112e960 <OS_Sched+0xb0>
            OS_SchedNew();
8112e904:	112e9880 	call	8112e988 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
8112e908:	d0e08383 	ldbu	r3,-32242(gp)
8112e90c:	d0a083c3 	ldbu	r2,-32241(gp)
8112e910:	18c03fcc 	andi	r3,r3,255
8112e914:	10803fcc 	andi	r2,r2,255
8112e918:	18801126 	beq	r3,r2,8112e960 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
8112e91c:	d0a08383 	ldbu	r2,-32242(gp)
8112e920:	10c03fcc 	andi	r3,r2,255
8112e924:	00a045b4 	movhi	r2,33046
8112e928:	10bfb204 	addi	r2,r2,-312
8112e92c:	18c7883a 	add	r3,r3,r3
8112e930:	18c7883a 	add	r3,r3,r3
8112e934:	10c5883a 	add	r2,r2,r3
8112e938:	10800017 	ldw	r2,0(r2)
8112e93c:	d0a08c15 	stw	r2,-32208(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
8112e940:	d0a08c17 	ldw	r2,-32208(gp)
8112e944:	10c00e17 	ldw	r3,56(r2)
8112e948:	18c00044 	addi	r3,r3,1
8112e94c:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
8112e950:	d0a08617 	ldw	r2,-32232(gp)
8112e954:	10800044 	addi	r2,r2,1
8112e958:	d0a08615 	stw	r2,-32232(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
8112e95c:	113f72c0 	call	8113f72c <OSCtxSw>
8112e960:	e0bffd17 	ldw	r2,-12(fp)
8112e964:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e968:	e0bffe17 	ldw	r2,-8(fp)
8112e96c:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
8112e970:	0001883a 	nop
8112e974:	e037883a 	mov	sp,fp
8112e978:	dfc00117 	ldw	ra,4(sp)
8112e97c:	df000017 	ldw	fp,0(sp)
8112e980:	dec00204 	addi	sp,sp,8
8112e984:	f800283a 	ret

8112e988 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
8112e988:	defffe04 	addi	sp,sp,-8
8112e98c:	de00012e 	bgeu	sp,et,8112e994 <OS_SchedNew+0xc>
8112e990:	003b68fa 	trap	3
8112e994:	df000115 	stw	fp,4(sp)
8112e998:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
8112e99c:	d0a08e03 	ldbu	r2,-32200(gp)
8112e9a0:	10c03fcc 	andi	r3,r2,255
8112e9a4:	00a04534 	movhi	r2,33044
8112e9a8:	10927804 	addi	r2,r2,18912
8112e9ac:	10c5883a 	add	r2,r2,r3
8112e9b0:	10800003 	ldbu	r2,0(r2)
8112e9b4:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
8112e9b8:	e0bfff03 	ldbu	r2,-4(fp)
8112e9bc:	100490fa 	slli	r2,r2,3
8112e9c0:	1009883a 	mov	r4,r2
8112e9c4:	e0ffff03 	ldbu	r3,-4(fp)
8112e9c8:	d0a08e44 	addi	r2,gp,-32199
8112e9cc:	1885883a 	add	r2,r3,r2
8112e9d0:	10800003 	ldbu	r2,0(r2)
8112e9d4:	10c03fcc 	andi	r3,r2,255
8112e9d8:	00a04534 	movhi	r2,33044
8112e9dc:	10927804 	addi	r2,r2,18912
8112e9e0:	10c5883a 	add	r2,r2,r3
8112e9e4:	10800003 	ldbu	r2,0(r2)
8112e9e8:	2085883a 	add	r2,r4,r2
8112e9ec:	d0a08385 	stb	r2,-32242(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
8112e9f0:	0001883a 	nop
8112e9f4:	e037883a 	mov	sp,fp
8112e9f8:	df000017 	ldw	fp,0(sp)
8112e9fc:	dec00104 	addi	sp,sp,4
8112ea00:	f800283a 	ret

8112ea04 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
8112ea04:	defffc04 	addi	sp,sp,-16
8112ea08:	de00012e 	bgeu	sp,et,8112ea10 <OS_StrCopy+0xc>
8112ea0c:	003b68fa 	trap	3
8112ea10:	df000315 	stw	fp,12(sp)
8112ea14:	df000304 	addi	fp,sp,12
8112ea18:	e13ffe15 	stw	r4,-8(fp)
8112ea1c:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
8112ea20:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
8112ea24:	00000b06 	br	8112ea54 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
8112ea28:	e0bffe17 	ldw	r2,-8(fp)
8112ea2c:	10c00044 	addi	r3,r2,1
8112ea30:	e0fffe15 	stw	r3,-8(fp)
8112ea34:	e0ffff17 	ldw	r3,-4(fp)
8112ea38:	19000044 	addi	r4,r3,1
8112ea3c:	e13fff15 	stw	r4,-4(fp)
8112ea40:	18c00003 	ldbu	r3,0(r3)
8112ea44:	10c00005 	stb	r3,0(r2)
        len++;
8112ea48:	e0bffd03 	ldbu	r2,-12(fp)
8112ea4c:	10800044 	addi	r2,r2,1
8112ea50:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8112ea54:	e0bfff17 	ldw	r2,-4(fp)
8112ea58:	10800003 	ldbu	r2,0(r2)
8112ea5c:	10803fcc 	andi	r2,r2,255
8112ea60:	103ff11e 	bne	r2,zero,8112ea28 <__reset+0xfb10ea28>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
8112ea64:	e0bffe17 	ldw	r2,-8(fp)
8112ea68:	10000005 	stb	zero,0(r2)
    return (len);
8112ea6c:	e0bffd03 	ldbu	r2,-12(fp)
}
8112ea70:	e037883a 	mov	sp,fp
8112ea74:	df000017 	ldw	fp,0(sp)
8112ea78:	dec00104 	addi	sp,sp,4
8112ea7c:	f800283a 	ret

8112ea80 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
8112ea80:	defffd04 	addi	sp,sp,-12
8112ea84:	de00012e 	bgeu	sp,et,8112ea8c <OS_StrLen+0xc>
8112ea88:	003b68fa 	trap	3
8112ea8c:	df000215 	stw	fp,8(sp)
8112ea90:	df000204 	addi	fp,sp,8
8112ea94:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
8112ea98:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
8112ea9c:	00000606 	br	8112eab8 <OS_StrLen+0x38>
        psrc++;
8112eaa0:	e0bfff17 	ldw	r2,-4(fp)
8112eaa4:	10800044 	addi	r2,r2,1
8112eaa8:	e0bfff15 	stw	r2,-4(fp)
        len++;
8112eaac:	e0bffe03 	ldbu	r2,-8(fp)
8112eab0:	10800044 	addi	r2,r2,1
8112eab4:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8112eab8:	e0bfff17 	ldw	r2,-4(fp)
8112eabc:	10800003 	ldbu	r2,0(r2)
8112eac0:	10803fcc 	andi	r2,r2,255
8112eac4:	103ff61e 	bne	r2,zero,8112eaa0 <__reset+0xfb10eaa0>
        psrc++;
        len++;
    }
    return (len);
8112eac8:	e0bffe03 	ldbu	r2,-8(fp)
}
8112eacc:	e037883a 	mov	sp,fp
8112ead0:	df000017 	ldw	fp,0(sp)
8112ead4:	dec00104 	addi	sp,sp,4
8112ead8:	f800283a 	ret

8112eadc <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
8112eadc:	defffa04 	addi	sp,sp,-24
8112eae0:	de00012e 	bgeu	sp,et,8112eae8 <OS_TaskIdle+0xc>
8112eae4:	003b68fa 	trap	3
8112eae8:	dfc00515 	stw	ra,20(sp)
8112eaec:	df000415 	stw	fp,16(sp)
8112eaf0:	df000404 	addi	fp,sp,16
8112eaf4:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112eaf8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112eafc:	0005303a 	rdctl	r2,status
8112eb00:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112eb04:	e0fffd17 	ldw	r3,-12(fp)
8112eb08:	00bfff84 	movi	r2,-2
8112eb0c:	1884703a 	and	r2,r3,r2
8112eb10:	1001703a 	wrctl	status,r2
  
  return context;
8112eb14:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
8112eb18:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
8112eb1c:	d0a08217 	ldw	r2,-32248(gp)
8112eb20:	10800044 	addi	r2,r2,1
8112eb24:	d0a08215 	stw	r2,-32248(gp)
8112eb28:	e0bffc17 	ldw	r2,-16(fp)
8112eb2c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112eb30:	e0bffe17 	ldw	r2,-8(fp)
8112eb34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
8112eb38:	113fac00 	call	8113fac0 <OSTaskIdleHook>
    }
8112eb3c:	003fef06 	br	8112eafc <__reset+0xfb10eafc>

8112eb40 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
8112eb40:	defff804 	addi	sp,sp,-32
8112eb44:	de00012e 	bgeu	sp,et,8112eb4c <OS_TaskStat+0xc>
8112eb48:	003b68fa 	trap	3
8112eb4c:	dfc00715 	stw	ra,28(sp)
8112eb50:	df000615 	stw	fp,24(sp)
8112eb54:	dc400515 	stw	r17,20(sp)
8112eb58:	dc000415 	stw	r16,16(sp)
8112eb5c:	df000604 	addi	fp,sp,24
8112eb60:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112eb64:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8112eb68:	00000206 	br	8112eb74 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
8112eb6c:	01003204 	movi	r4,200
8112eb70:	11354380 	call	81135438 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8112eb74:	d0a09703 	ldbu	r2,-32164(gp)
8112eb78:	10803fcc 	andi	r2,r2,255
8112eb7c:	103ffb26 	beq	r2,zero,8112eb6c <__reset+0xfb10eb6c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
8112eb80:	d0e08817 	ldw	r3,-32224(gp)
8112eb84:	00947b34 	movhi	r2,20972
8112eb88:	10a147c4 	addi	r2,r2,-31457
8112eb8c:	1888383a 	mulxuu	r4,r3,r2
8112eb90:	1885383a 	mul	r2,r3,r2
8112eb94:	1021883a 	mov	r16,r2
8112eb98:	2023883a 	mov	r17,r4
8112eb9c:	8804d17a 	srli	r2,r17,5
8112eba0:	d0a08815 	stw	r2,-32224(gp)
    if (OSIdleCtrMax == 0L) {
8112eba4:	d0a08817 	ldw	r2,-32224(gp)
8112eba8:	1000031e 	bne	r2,zero,8112ebb8 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
8112ebac:	d0208a05 	stb	zero,-32216(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
8112ebb0:	01003fc4 	movi	r4,255
8112ebb4:	11350a80 	call	811350a8 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ebb8:	0005303a 	rdctl	r2,status
8112ebbc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ebc0:	e0fffb17 	ldw	r3,-20(fp)
8112ebc4:	00bfff84 	movi	r2,-2
8112ebc8:	1884703a 	and	r2,r3,r2
8112ebcc:	1001703a 	wrctl	status,r2
  
  return context;
8112ebd0:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
8112ebd4:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
8112ebd8:	d0a08217 	ldw	r2,-32248(gp)
8112ebdc:	d0a09815 	stw	r2,-32160(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
8112ebe0:	d0208215 	stw	zero,-32248(gp)
8112ebe4:	e0bffa17 	ldw	r2,-24(fp)
8112ebe8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ebec:	e0bffc17 	ldw	r2,-16(fp)
8112ebf0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
8112ebf4:	d0e09817 	ldw	r3,-32160(gp)
8112ebf8:	d0a08817 	ldw	r2,-32224(gp)
8112ebfc:	1885203a 	divu	r2,r3,r2
8112ec00:	1007883a 	mov	r3,r2
8112ec04:	00801904 	movi	r2,100
8112ec08:	10c5c83a 	sub	r2,r2,r3
8112ec0c:	d0a08a05 	stb	r2,-32216(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
8112ec10:	113f9f00 	call	8113f9f0 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
8112ec14:	112ec240 	call	8112ec24 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
8112ec18:	01001904 	movi	r4,100
8112ec1c:	11354380 	call	81135438 <OSTimeDly>
    }
8112ec20:	003fe506 	br	8112ebb8 <__reset+0xfb10ebb8>

8112ec24 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
8112ec24:	defffa04 	addi	sp,sp,-24
8112ec28:	de00012e 	bgeu	sp,et,8112ec30 <OS_TaskStatStkChk+0xc>
8112ec2c:	003b68fa 	trap	3
8112ec30:	dfc00515 	stw	ra,20(sp)
8112ec34:	df000415 	stw	fp,16(sp)
8112ec38:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8112ec3c:	e03ffc05 	stb	zero,-16(fp)
8112ec40:	00002406 	br	8112ecd4 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
8112ec44:	e0bffc03 	ldbu	r2,-16(fp)
8112ec48:	e0fffe04 	addi	r3,fp,-8
8112ec4c:	180b883a 	mov	r5,r3
8112ec50:	1009883a 	mov	r4,r2
8112ec54:	1134ee00 	call	81134ee0 <OSTaskStkChk>
8112ec58:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
8112ec5c:	e0bffc43 	ldbu	r2,-15(fp)
8112ec60:	1000191e 	bne	r2,zero,8112ecc8 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
8112ec64:	e0fffc03 	ldbu	r3,-16(fp)
8112ec68:	00a045b4 	movhi	r2,33046
8112ec6c:	10bfb204 	addi	r2,r2,-312
8112ec70:	18c7883a 	add	r3,r3,r3
8112ec74:	18c7883a 	add	r3,r3,r3
8112ec78:	10c5883a 	add	r2,r2,r3
8112ec7c:	10800017 	ldw	r2,0(r2)
8112ec80:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8112ec84:	e0bffd17 	ldw	r2,-12(fp)
8112ec88:	10000f26 	beq	r2,zero,8112ecc8 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
8112ec8c:	e0bffd17 	ldw	r2,-12(fp)
8112ec90:	10800060 	cmpeqi	r2,r2,1
8112ec94:	10000c1e 	bne	r2,zero,8112ecc8 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
8112ec98:	e0bffd17 	ldw	r2,-12(fp)
8112ec9c:	10c00217 	ldw	r3,8(r2)
8112eca0:	e0bffd17 	ldw	r2,-12(fp)
8112eca4:	10800317 	ldw	r2,12(r2)
8112eca8:	1085883a 	add	r2,r2,r2
8112ecac:	1085883a 	add	r2,r2,r2
8112ecb0:	1887883a 	add	r3,r3,r2
8112ecb4:	e0bffd17 	ldw	r2,-12(fp)
8112ecb8:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
8112ecbc:	e0ffff17 	ldw	r3,-4(fp)
8112ecc0:	e0bffd17 	ldw	r2,-12(fp)
8112ecc4:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8112ecc8:	e0bffc03 	ldbu	r2,-16(fp)
8112eccc:	10800044 	addi	r2,r2,1
8112ecd0:	e0bffc05 	stb	r2,-16(fp)
8112ecd4:	e0bffc03 	ldbu	r2,-16(fp)
8112ecd8:	10800a70 	cmpltui	r2,r2,41
8112ecdc:	103fd91e 	bne	r2,zero,8112ec44 <__reset+0xfb10ec44>
#endif
                }
            }
        }
    }
}
8112ece0:	0001883a 	nop
8112ece4:	e037883a 	mov	sp,fp
8112ece8:	dfc00117 	ldw	ra,4(sp)
8112ecec:	df000017 	ldw	fp,0(sp)
8112ecf0:	dec00204 	addi	sp,sp,8
8112ecf4:	f800283a 	ret

8112ecf8 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
8112ecf8:	defff204 	addi	sp,sp,-56
8112ecfc:	de00012e 	bgeu	sp,et,8112ed04 <OS_TCBInit+0xc>
8112ed00:	003b68fa 	trap	3
8112ed04:	dfc00d15 	stw	ra,52(sp)
8112ed08:	df000c15 	stw	fp,48(sp)
8112ed0c:	df000c04 	addi	fp,sp,48
8112ed10:	e17ffc15 	stw	r5,-16(fp)
8112ed14:	e1bffd15 	stw	r6,-12(fp)
8112ed18:	3807883a 	mov	r3,r7
8112ed1c:	e0800417 	ldw	r2,16(fp)
8112ed20:	e13ffb05 	stb	r4,-20(fp)
8112ed24:	e0fffe0d 	sth	r3,-8(fp)
8112ed28:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112ed2c:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ed30:	0005303a 	rdctl	r2,status
8112ed34:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ed38:	e0fffa17 	ldw	r3,-24(fp)
8112ed3c:	00bfff84 	movi	r2,-2
8112ed40:	1884703a 	and	r2,r3,r2
8112ed44:	1001703a 	wrctl	status,r2
  
  return context;
8112ed48:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
8112ed4c:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
8112ed50:	d0a08917 	ldw	r2,-32220(gp)
8112ed54:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
8112ed58:	e0bff617 	ldw	r2,-40(fp)
8112ed5c:	10009326 	beq	r2,zero,8112efac <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
8112ed60:	e0bff617 	ldw	r2,-40(fp)
8112ed64:	10800517 	ldw	r2,20(r2)
8112ed68:	d0a08915 	stw	r2,-32220(gp)
8112ed6c:	e0bff417 	ldw	r2,-48(fp)
8112ed70:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ed74:	e0bff817 	ldw	r2,-32(fp)
8112ed78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
8112ed7c:	e0bff617 	ldw	r2,-40(fp)
8112ed80:	e0fffc17 	ldw	r3,-16(fp)
8112ed84:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
8112ed88:	e0bff617 	ldw	r2,-40(fp)
8112ed8c:	e0fffb03 	ldbu	r3,-20(fp)
8112ed90:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
8112ed94:	e0bff617 	ldw	r2,-40(fp)
8112ed98:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
8112ed9c:	e0bff617 	ldw	r2,-40(fp)
8112eda0:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
8112eda4:	e0bff617 	ldw	r2,-40(fp)
8112eda8:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
8112edac:	e0bff617 	ldw	r2,-40(fp)
8112edb0:	e0c00317 	ldw	r3,12(fp)
8112edb4:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
8112edb8:	e0bff617 	ldw	r2,-40(fp)
8112edbc:	e0c00217 	ldw	r3,8(fp)
8112edc0:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
8112edc4:	e0bff617 	ldw	r2,-40(fp)
8112edc8:	e0fffd17 	ldw	r3,-12(fp)
8112edcc:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
8112edd0:	e0bff617 	ldw	r2,-40(fp)
8112edd4:	e0ffff0b 	ldhu	r3,-4(fp)
8112edd8:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
8112eddc:	e0bff617 	ldw	r2,-40(fp)
8112ede0:	e0fffe0b 	ldhu	r3,-8(fp)
8112ede4:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
8112ede8:	e0bff617 	ldw	r2,-40(fp)
8112edec:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
8112edf0:	e0bffb03 	ldbu	r2,-20(fp)
8112edf4:	1004d0fa 	srli	r2,r2,3
8112edf8:	1007883a 	mov	r3,r2
8112edfc:	e0bff617 	ldw	r2,-40(fp)
8112ee00:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
8112ee04:	e0bffb03 	ldbu	r2,-20(fp)
8112ee08:	108001cc 	andi	r2,r2,7
8112ee0c:	1007883a 	mov	r3,r2
8112ee10:	e0bff617 	ldw	r2,-40(fp)
8112ee14:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
8112ee18:	e0bff617 	ldw	r2,-40(fp)
8112ee1c:	10800d03 	ldbu	r2,52(r2)
8112ee20:	10803fcc 	andi	r2,r2,255
8112ee24:	00c00044 	movi	r3,1
8112ee28:	1884983a 	sll	r2,r3,r2
8112ee2c:	1007883a 	mov	r3,r2
8112ee30:	e0bff617 	ldw	r2,-40(fp)
8112ee34:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
8112ee38:	e0bff617 	ldw	r2,-40(fp)
8112ee3c:	10800cc3 	ldbu	r2,51(r2)
8112ee40:	10803fcc 	andi	r2,r2,255
8112ee44:	00c00044 	movi	r3,1
8112ee48:	1884983a 	sll	r2,r3,r2
8112ee4c:	1007883a 	mov	r3,r2
8112ee50:	e0bff617 	ldw	r2,-40(fp)
8112ee54:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
8112ee58:	e0bff617 	ldw	r2,-40(fp)
8112ee5c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
8112ee60:	e0bff617 	ldw	r2,-40(fp)
8112ee64:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
8112ee68:	e0bff617 	ldw	r2,-40(fp)
8112ee6c:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
8112ee70:	e0bff617 	ldw	r2,-40(fp)
8112ee74:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
8112ee78:	e0bff617 	ldw	r2,-40(fp)
8112ee7c:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
8112ee80:	e0bff617 	ldw	r2,-40(fp)
8112ee84:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
8112ee88:	e0bff617 	ldw	r2,-40(fp)
8112ee8c:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
8112ee90:	e0bff617 	ldw	r2,-40(fp)
8112ee94:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
8112ee98:	e0bff617 	ldw	r2,-40(fp)
8112ee9c:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
8112eea0:	e0bff617 	ldw	r2,-40(fp)
8112eea4:	00c00fc4 	movi	r3,63
8112eea8:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8112eeac:	e0bff617 	ldw	r2,-40(fp)
8112eeb0:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
8112eeb4:	e13ff617 	ldw	r4,-40(fp)
8112eeb8:	113fae80 	call	8113fae8 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
8112eebc:	e13ff617 	ldw	r4,-40(fp)
8112eec0:	113f9700 	call	8113f970 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112eec4:	0005303a 	rdctl	r2,status
8112eec8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112eecc:	e0fff517 	ldw	r3,-44(fp)
8112eed0:	00bfff84 	movi	r2,-2
8112eed4:	1884703a 	and	r2,r3,r2
8112eed8:	1001703a 	wrctl	status,r2
  
  return context;
8112eedc:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
8112eee0:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8112eee4:	e0fffb03 	ldbu	r3,-20(fp)
8112eee8:	00a045b4 	movhi	r2,33046
8112eeec:	10bfb204 	addi	r2,r2,-312
8112eef0:	18c7883a 	add	r3,r3,r3
8112eef4:	18c7883a 	add	r3,r3,r3
8112eef8:	10c5883a 	add	r2,r2,r3
8112eefc:	e0fff617 	ldw	r3,-40(fp)
8112ef00:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8112ef04:	d0e08417 	ldw	r3,-32240(gp)
8112ef08:	e0bff617 	ldw	r2,-40(fp)
8112ef0c:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
8112ef10:	e0bff617 	ldw	r2,-40(fp)
8112ef14:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
8112ef18:	d0a08417 	ldw	r2,-32240(gp)
8112ef1c:	10000326 	beq	r2,zero,8112ef2c <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
8112ef20:	d0a08417 	ldw	r2,-32240(gp)
8112ef24:	e0fff617 	ldw	r3,-40(fp)
8112ef28:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
8112ef2c:	e0bff617 	ldw	r2,-40(fp)
8112ef30:	d0a08415 	stw	r2,-32240(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
8112ef34:	e0bff617 	ldw	r2,-40(fp)
8112ef38:	10c00d83 	ldbu	r3,54(r2)
8112ef3c:	d0a08e03 	ldbu	r2,-32200(gp)
8112ef40:	1884b03a 	or	r2,r3,r2
8112ef44:	d0a08e05 	stb	r2,-32200(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8112ef48:	e0bff617 	ldw	r2,-40(fp)
8112ef4c:	10800d03 	ldbu	r2,52(r2)
8112ef50:	10c03fcc 	andi	r3,r2,255
8112ef54:	e0bff617 	ldw	r2,-40(fp)
8112ef58:	10800d03 	ldbu	r2,52(r2)
8112ef5c:	11003fcc 	andi	r4,r2,255
8112ef60:	d0a08e44 	addi	r2,gp,-32199
8112ef64:	2085883a 	add	r2,r4,r2
8112ef68:	11000003 	ldbu	r4,0(r2)
8112ef6c:	e0bff617 	ldw	r2,-40(fp)
8112ef70:	10800d43 	ldbu	r2,53(r2)
8112ef74:	2084b03a 	or	r2,r4,r2
8112ef78:	1009883a 	mov	r4,r2
8112ef7c:	d0a08e44 	addi	r2,gp,-32199
8112ef80:	1885883a 	add	r2,r3,r2
8112ef84:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
8112ef88:	d0a08a43 	ldbu	r2,-32215(gp)
8112ef8c:	10800044 	addi	r2,r2,1
8112ef90:	d0a08a45 	stb	r2,-32215(gp)
8112ef94:	e0bff417 	ldw	r2,-48(fp)
8112ef98:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ef9c:	e0bff717 	ldw	r2,-36(fp)
8112efa0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8112efa4:	0005883a 	mov	r2,zero
8112efa8:	00000506 	br	8112efc0 <OS_TCBInit+0x2c8>
8112efac:	e0bff417 	ldw	r2,-48(fp)
8112efb0:	e0bff915 	stw	r2,-28(fp)
8112efb4:	e0bff917 	ldw	r2,-28(fp)
8112efb8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
8112efbc:	00801084 	movi	r2,66
}
8112efc0:	e037883a 	mov	sp,fp
8112efc4:	dfc00117 	ldw	ra,4(sp)
8112efc8:	df000017 	ldw	fp,0(sp)
8112efcc:	dec00204 	addi	sp,sp,8
8112efd0:	f800283a 	ret

8112efd4 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
8112efd4:	defffe04 	addi	sp,sp,-8
8112efd8:	de00012e 	bgeu	sp,et,8112efe0 <OSDebugInit+0xc>
8112efdc:	003b68fa 	trap	3
8112efe0:	df000115 	stw	fp,4(sp)
8112efe4:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
8112efe8:	d0a01804 	addi	r2,gp,-32672
8112efec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
8112eff0:	d0a01904 	addi	r2,gp,-32668
8112eff4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
8112eff8:	d0a01a84 	addi	r2,gp,-32662
8112effc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
8112f000:	d0a01b04 	addi	r2,gp,-32660
8112f004:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
8112f008:	d0a01a04 	addi	r2,gp,-32664
8112f00c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
8112f010:	d0a01b84 	addi	r2,gp,-32658
8112f014:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
8112f018:	d0a01c04 	addi	r2,gp,-32656
8112f01c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
8112f020:	d0a01c84 	addi	r2,gp,-32654
8112f024:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
8112f028:	d0a01d04 	addi	r2,gp,-32652
8112f02c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
8112f030:	d0a01d84 	addi	r2,gp,-32650
8112f034:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
8112f038:	d0a01e04 	addi	r2,gp,-32648
8112f03c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
8112f040:	d0a01e84 	addi	r2,gp,-32646
8112f044:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
8112f048:	d0a01f04 	addi	r2,gp,-32644
8112f04c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
8112f050:	d0a01f84 	addi	r2,gp,-32642
8112f054:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
8112f058:	d0a02004 	addi	r2,gp,-32640
8112f05c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
8112f060:	d0a02084 	addi	r2,gp,-32638
8112f064:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
8112f068:	d0a02104 	addi	r2,gp,-32636
8112f06c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
8112f070:	d0a02184 	addi	r2,gp,-32634
8112f074:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
8112f078:	d0a02204 	addi	r2,gp,-32632
8112f07c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
8112f080:	d0a02284 	addi	r2,gp,-32630
8112f084:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
8112f088:	d0a02304 	addi	r2,gp,-32628
8112f08c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
8112f090:	d0a02384 	addi	r2,gp,-32626
8112f094:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
8112f098:	d0a02404 	addi	r2,gp,-32624
8112f09c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
8112f0a0:	d0a02484 	addi	r2,gp,-32622
8112f0a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
8112f0a8:	d0a02504 	addi	r2,gp,-32620
8112f0ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
8112f0b0:	d0a02584 	addi	r2,gp,-32618
8112f0b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
8112f0b8:	d0a02604 	addi	r2,gp,-32616
8112f0bc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
8112f0c0:	d0a02684 	addi	r2,gp,-32614
8112f0c4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
8112f0c8:	d0a02704 	addi	r2,gp,-32612
8112f0cc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
8112f0d0:	d0a02784 	addi	r2,gp,-32610
8112f0d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
8112f0d8:	d0a02804 	addi	r2,gp,-32608
8112f0dc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
8112f0e0:	d0a02884 	addi	r2,gp,-32606
8112f0e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
8112f0e8:	d0a02904 	addi	r2,gp,-32604
8112f0ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
8112f0f0:	d0a02984 	addi	r2,gp,-32602
8112f0f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
8112f0f8:	d0a02a04 	addi	r2,gp,-32600
8112f0fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
8112f100:	d0a02a84 	addi	r2,gp,-32598
8112f104:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
8112f108:	d0a02b04 	addi	r2,gp,-32596
8112f10c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
8112f110:	d0a02b84 	addi	r2,gp,-32594
8112f114:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
8112f118:	d0a02c04 	addi	r2,gp,-32592
8112f11c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
8112f120:	d0a02c84 	addi	r2,gp,-32590
8112f124:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
8112f128:	d0a02d04 	addi	r2,gp,-32588
8112f12c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
8112f130:	d0a02d84 	addi	r2,gp,-32586
8112f134:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
8112f138:	d0a02e04 	addi	r2,gp,-32584
8112f13c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
8112f140:	d0a02e84 	addi	r2,gp,-32582
8112f144:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
8112f148:	00a045b4 	movhi	r2,33046
8112f14c:	10ab0804 	addi	r2,r2,-21472
8112f150:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
8112f154:	00a045b4 	movhi	r2,33046
8112f158:	10a9a404 	addi	r2,r2,-22896
8112f15c:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
8112f160:	d0a02f84 	addi	r2,gp,-32578
8112f164:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
8112f168:	d0a03004 	addi	r2,gp,-32576
8112f16c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
8112f170:	d0a03084 	addi	r2,gp,-32574
8112f174:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
8112f178:	d0a03104 	addi	r2,gp,-32572
8112f17c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
8112f180:	d0a03184 	addi	r2,gp,-32570
8112f184:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
8112f188:	d0a03204 	addi	r2,gp,-32568
8112f18c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
8112f190:	d0a03284 	addi	r2,gp,-32566
8112f194:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
8112f198:	d0a03304 	addi	r2,gp,-32564
8112f19c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
8112f1a0:	d0a03384 	addi	r2,gp,-32562
8112f1a4:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
8112f1a8:	d0a02f04 	addi	r2,gp,-32580
8112f1ac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
8112f1b0:	d0a03404 	addi	r2,gp,-32560
8112f1b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
8112f1b8:	0001883a 	nop
8112f1bc:	e037883a 	mov	sp,fp
8112f1c0:	df000017 	ldw	fp,0(sp)
8112f1c4:	dec00104 	addi	sp,sp,4
8112f1c8:	f800283a 	ret

8112f1cc <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
8112f1cc:	defff204 	addi	sp,sp,-56
8112f1d0:	de00012e 	bgeu	sp,et,8112f1d8 <OSFlagAccept+0xc>
8112f1d4:	003b68fa 	trap	3
8112f1d8:	df000d15 	stw	fp,52(sp)
8112f1dc:	df000d04 	addi	fp,sp,52
8112f1e0:	e13ffc15 	stw	r4,-16(fp)
8112f1e4:	2807883a 	mov	r3,r5
8112f1e8:	3005883a 	mov	r2,r6
8112f1ec:	e1ffff15 	stw	r7,-4(fp)
8112f1f0:	e0fffd0d 	sth	r3,-12(fp)
8112f1f4:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8112f1f8:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112f1fc:	e0bfff17 	ldw	r2,-4(fp)
8112f200:	1000021e 	bne	r2,zero,8112f20c <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8112f204:	0005883a 	mov	r2,zero
8112f208:	0000b006 	br	8112f4cc <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8112f20c:	e0bffc17 	ldw	r2,-16(fp)
8112f210:	1000051e 	bne	r2,zero,8112f228 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112f214:	e0bfff17 	ldw	r2,-4(fp)
8112f218:	00c01b84 	movi	r3,110
8112f21c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112f220:	0005883a 	mov	r2,zero
8112f224:	0000a906 	br	8112f4cc <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8112f228:	e0bffc17 	ldw	r2,-16(fp)
8112f22c:	10800003 	ldbu	r2,0(r2)
8112f230:	10803fcc 	andi	r2,r2,255
8112f234:	10800160 	cmpeqi	r2,r2,5
8112f238:	1000051e 	bne	r2,zero,8112f250 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
8112f23c:	e0bfff17 	ldw	r2,-4(fp)
8112f240:	00c00044 	movi	r3,1
8112f244:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112f248:	0005883a 	mov	r2,zero
8112f24c:	00009f06 	br	8112f4cc <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8112f250:	e0fffe03 	ldbu	r3,-8(fp)
8112f254:	00bfe004 	movi	r2,-128
8112f258:	1884703a 	and	r2,r3,r2
8112f25c:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
8112f260:	e0bff503 	ldbu	r2,-44(fp)
8112f264:	10000626 	beq	r2,zero,8112f280 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
8112f268:	e0bffe03 	ldbu	r2,-8(fp)
8112f26c:	10801fcc 	andi	r2,r2,127
8112f270:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8112f274:	00800044 	movi	r2,1
8112f278:	e0bff385 	stb	r2,-50(fp)
8112f27c:	00000106 	br	8112f284 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
8112f280:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8112f284:	e0bfff17 	ldw	r2,-4(fp)
8112f288:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f28c:	0005303a 	rdctl	r2,status
8112f290:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f294:	e0fffb17 	ldw	r3,-20(fp)
8112f298:	00bfff84 	movi	r2,-2
8112f29c:	1884703a 	and	r2,r3,r2
8112f2a0:	1001703a 	wrctl	status,r2
  
  return context;
8112f2a4:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8112f2a8:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
8112f2ac:	e0bffe03 	ldbu	r2,-8(fp)
8112f2b0:	10c00060 	cmpeqi	r3,r2,1
8112f2b4:	18005f1e 	bne	r3,zero,8112f434 <OSFlagAccept+0x268>
8112f2b8:	10c00088 	cmpgei	r3,r2,2
8112f2bc:	1800021e 	bne	r3,zero,8112f2c8 <OSFlagAccept+0xfc>
8112f2c0:	10003f26 	beq	r2,zero,8112f3c0 <OSFlagAccept+0x1f4>
8112f2c4:	00007706 	br	8112f4a4 <OSFlagAccept+0x2d8>
8112f2c8:	10c000a0 	cmpeqi	r3,r2,2
8112f2cc:	1800031e 	bne	r3,zero,8112f2dc <OSFlagAccept+0x110>
8112f2d0:	108000e0 	cmpeqi	r2,r2,3
8112f2d4:	10001e1e 	bne	r2,zero,8112f350 <OSFlagAccept+0x184>
8112f2d8:	00007206 	br	8112f4a4 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8112f2dc:	e0bffc17 	ldw	r2,-16(fp)
8112f2e0:	10c0020b 	ldhu	r3,8(r2)
8112f2e4:	e0bffd0b 	ldhu	r2,-12(fp)
8112f2e8:	1884703a 	and	r2,r3,r2
8112f2ec:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8112f2f0:	e0fff30b 	ldhu	r3,-52(fp)
8112f2f4:	e0bffd0b 	ldhu	r2,-12(fp)
8112f2f8:	18800d1e 	bne	r3,r2,8112f330 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112f2fc:	e0bff383 	ldbu	r2,-50(fp)
8112f300:	10800058 	cmpnei	r2,r2,1
8112f304:	10000d1e 	bne	r2,zero,8112f33c <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8112f308:	e0bffc17 	ldw	r2,-16(fp)
8112f30c:	1080020b 	ldhu	r2,8(r2)
8112f310:	1007883a 	mov	r3,r2
8112f314:	e0bff30b 	ldhu	r2,-52(fp)
8112f318:	0084303a 	nor	r2,zero,r2
8112f31c:	1884703a 	and	r2,r3,r2
8112f320:	1007883a 	mov	r3,r2
8112f324:	e0bffc17 	ldw	r2,-16(fp)
8112f328:	10c0020d 	sth	r3,8(r2)
8112f32c:	00000306 	br	8112f33c <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8112f330:	e0bfff17 	ldw	r2,-4(fp)
8112f334:	00c01c04 	movi	r3,112
8112f338:	10c00005 	stb	r3,0(r2)
8112f33c:	e0bff417 	ldw	r2,-48(fp)
8112f340:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f344:	e0bff617 	ldw	r2,-40(fp)
8112f348:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8112f34c:	00005e06 	br	8112f4c8 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8112f350:	e0bffc17 	ldw	r2,-16(fp)
8112f354:	10c0020b 	ldhu	r3,8(r2)
8112f358:	e0bffd0b 	ldhu	r2,-12(fp)
8112f35c:	1884703a 	and	r2,r3,r2
8112f360:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8112f364:	e0bff30b 	ldhu	r2,-52(fp)
8112f368:	10000d26 	beq	r2,zero,8112f3a0 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112f36c:	e0bff383 	ldbu	r2,-50(fp)
8112f370:	10800058 	cmpnei	r2,r2,1
8112f374:	10000d1e 	bne	r2,zero,8112f3ac <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8112f378:	e0bffc17 	ldw	r2,-16(fp)
8112f37c:	1080020b 	ldhu	r2,8(r2)
8112f380:	1007883a 	mov	r3,r2
8112f384:	e0bff30b 	ldhu	r2,-52(fp)
8112f388:	0084303a 	nor	r2,zero,r2
8112f38c:	1884703a 	and	r2,r3,r2
8112f390:	1007883a 	mov	r3,r2
8112f394:	e0bffc17 	ldw	r2,-16(fp)
8112f398:	10c0020d 	sth	r3,8(r2)
8112f39c:	00000306 	br	8112f3ac <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8112f3a0:	e0bfff17 	ldw	r2,-4(fp)
8112f3a4:	00c01c04 	movi	r3,112
8112f3a8:	10c00005 	stb	r3,0(r2)
8112f3ac:	e0bff417 	ldw	r2,-48(fp)
8112f3b0:	e0bff715 	stw	r2,-36(fp)
8112f3b4:	e0bff717 	ldw	r2,-36(fp)
8112f3b8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8112f3bc:	00004206 	br	8112f4c8 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8112f3c0:	e0bffc17 	ldw	r2,-16(fp)
8112f3c4:	1080020b 	ldhu	r2,8(r2)
8112f3c8:	0084303a 	nor	r2,zero,r2
8112f3cc:	1007883a 	mov	r3,r2
8112f3d0:	e0bffd0b 	ldhu	r2,-12(fp)
8112f3d4:	1884703a 	and	r2,r3,r2
8112f3d8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8112f3dc:	e0fff30b 	ldhu	r3,-52(fp)
8112f3e0:	e0bffd0b 	ldhu	r2,-12(fp)
8112f3e4:	18800b1e 	bne	r3,r2,8112f414 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112f3e8:	e0bff383 	ldbu	r2,-50(fp)
8112f3ec:	10800058 	cmpnei	r2,r2,1
8112f3f0:	10000b1e 	bne	r2,zero,8112f420 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8112f3f4:	e0bffc17 	ldw	r2,-16(fp)
8112f3f8:	10c0020b 	ldhu	r3,8(r2)
8112f3fc:	e0bff30b 	ldhu	r2,-52(fp)
8112f400:	1884b03a 	or	r2,r3,r2
8112f404:	1007883a 	mov	r3,r2
8112f408:	e0bffc17 	ldw	r2,-16(fp)
8112f40c:	10c0020d 	sth	r3,8(r2)
8112f410:	00000306 	br	8112f420 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8112f414:	e0bfff17 	ldw	r2,-4(fp)
8112f418:	00c01c04 	movi	r3,112
8112f41c:	10c00005 	stb	r3,0(r2)
8112f420:	e0bff417 	ldw	r2,-48(fp)
8112f424:	e0bff815 	stw	r2,-32(fp)
8112f428:	e0bff817 	ldw	r2,-32(fp)
8112f42c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8112f430:	00002506 	br	8112f4c8 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8112f434:	e0bffc17 	ldw	r2,-16(fp)
8112f438:	1080020b 	ldhu	r2,8(r2)
8112f43c:	0084303a 	nor	r2,zero,r2
8112f440:	1007883a 	mov	r3,r2
8112f444:	e0bffd0b 	ldhu	r2,-12(fp)
8112f448:	1884703a 	and	r2,r3,r2
8112f44c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8112f450:	e0bff30b 	ldhu	r2,-52(fp)
8112f454:	10000b26 	beq	r2,zero,8112f484 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112f458:	e0bff383 	ldbu	r2,-50(fp)
8112f45c:	10800058 	cmpnei	r2,r2,1
8112f460:	10000b1e 	bne	r2,zero,8112f490 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8112f464:	e0bffc17 	ldw	r2,-16(fp)
8112f468:	10c0020b 	ldhu	r3,8(r2)
8112f46c:	e0bff30b 	ldhu	r2,-52(fp)
8112f470:	1884b03a 	or	r2,r3,r2
8112f474:	1007883a 	mov	r3,r2
8112f478:	e0bffc17 	ldw	r2,-16(fp)
8112f47c:	10c0020d 	sth	r3,8(r2)
8112f480:	00000306 	br	8112f490 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8112f484:	e0bfff17 	ldw	r2,-4(fp)
8112f488:	00c01c04 	movi	r3,112
8112f48c:	10c00005 	stb	r3,0(r2)
8112f490:	e0bff417 	ldw	r2,-48(fp)
8112f494:	e0bff915 	stw	r2,-28(fp)
8112f498:	e0bff917 	ldw	r2,-28(fp)
8112f49c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8112f4a0:	00000906 	br	8112f4c8 <OSFlagAccept+0x2fc>
8112f4a4:	e0bff417 	ldw	r2,-48(fp)
8112f4a8:	e0bffa15 	stw	r2,-24(fp)
8112f4ac:	e0bffa17 	ldw	r2,-24(fp)
8112f4b0:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8112f4b4:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
8112f4b8:	e0bfff17 	ldw	r2,-4(fp)
8112f4bc:	00c01bc4 	movi	r3,111
8112f4c0:	10c00005 	stb	r3,0(r2)
             break;
8112f4c4:	0001883a 	nop
    }
    return (flags_rdy);
8112f4c8:	e0bff30b 	ldhu	r2,-52(fp)
}
8112f4cc:	e037883a 	mov	sp,fp
8112f4d0:	df000017 	ldw	fp,0(sp)
8112f4d4:	dec00104 	addi	sp,sp,4
8112f4d8:	f800283a 	ret

8112f4dc <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
8112f4dc:	defff804 	addi	sp,sp,-32
8112f4e0:	de00012e 	bgeu	sp,et,8112f4e8 <OSFlagCreate+0xc>
8112f4e4:	003b68fa 	trap	3
8112f4e8:	df000715 	stw	fp,28(sp)
8112f4ec:	df000704 	addi	fp,sp,28
8112f4f0:	2005883a 	mov	r2,r4
8112f4f4:	e17fff15 	stw	r5,-4(fp)
8112f4f8:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
8112f4fc:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
8112f500:	e0bfff17 	ldw	r2,-4(fp)
8112f504:	1000021e 	bne	r2,zero,8112f510 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
8112f508:	0005883a 	mov	r2,zero
8112f50c:	00003306 	br	8112f5dc <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
8112f510:	d0a09103 	ldbu	r2,-32188(gp)
8112f514:	10803fcc 	andi	r2,r2,255
8112f518:	10000526 	beq	r2,zero,8112f530 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
8112f51c:	e0bfff17 	ldw	r2,-4(fp)
8112f520:	00c00404 	movi	r3,16
8112f524:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
8112f528:	0005883a 	mov	r2,zero
8112f52c:	00002b06 	br	8112f5dc <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f530:	0005303a 	rdctl	r2,status
8112f534:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f538:	e0fffd17 	ldw	r3,-12(fp)
8112f53c:	00bfff84 	movi	r2,-2
8112f540:	1884703a 	and	r2,r3,r2
8112f544:	1001703a 	wrctl	status,r2
  
  return context;
8112f548:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8112f54c:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8112f550:	d0a09617 	ldw	r2,-32168(gp)
8112f554:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
8112f558:	e0bffb17 	ldw	r2,-20(fp)
8112f55c:	10001726 	beq	r2,zero,8112f5bc <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8112f560:	d0a09617 	ldw	r2,-32168(gp)
8112f564:	10800117 	ldw	r2,4(r2)
8112f568:	d0a09615 	stw	r2,-32168(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
8112f56c:	e0bffb17 	ldw	r2,-20(fp)
8112f570:	00c00144 	movi	r3,5
8112f574:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
8112f578:	e0bffb17 	ldw	r2,-20(fp)
8112f57c:	e0fffe0b 	ldhu	r3,-8(fp)
8112f580:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8112f584:	e0bffb17 	ldw	r2,-20(fp)
8112f588:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
8112f58c:	e0bffb17 	ldw	r2,-20(fp)
8112f590:	00c00fc4 	movi	r3,63
8112f594:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8112f598:	e0bffb17 	ldw	r2,-20(fp)
8112f59c:	100002c5 	stb	zero,11(r2)
8112f5a0:	e0bff917 	ldw	r2,-28(fp)
8112f5a4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f5a8:	e0bffa17 	ldw	r2,-24(fp)
8112f5ac:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
8112f5b0:	e0bfff17 	ldw	r2,-4(fp)
8112f5b4:	10000005 	stb	zero,0(r2)
8112f5b8:	00000706 	br	8112f5d8 <OSFlagCreate+0xfc>
8112f5bc:	e0bff917 	ldw	r2,-28(fp)
8112f5c0:	e0bffc15 	stw	r2,-16(fp)
8112f5c4:	e0bffc17 	ldw	r2,-16(fp)
8112f5c8:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
8112f5cc:	e0bfff17 	ldw	r2,-4(fp)
8112f5d0:	00c01c84 	movi	r3,114
8112f5d4:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
8112f5d8:	e0bffb17 	ldw	r2,-20(fp)
}
8112f5dc:	e037883a 	mov	sp,fp
8112f5e0:	df000017 	ldw	fp,0(sp)
8112f5e4:	dec00104 	addi	sp,sp,4
8112f5e8:	f800283a 	ret

8112f5ec <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
8112f5ec:	defff204 	addi	sp,sp,-56
8112f5f0:	de00012e 	bgeu	sp,et,8112f5f8 <OSFlagDel+0xc>
8112f5f4:	003b68fa 	trap	3
8112f5f8:	dfc00d15 	stw	ra,52(sp)
8112f5fc:	df000c15 	stw	fp,48(sp)
8112f600:	df000c04 	addi	fp,sp,48
8112f604:	e13ffd15 	stw	r4,-12(fp)
8112f608:	2805883a 	mov	r2,r5
8112f60c:	e1bfff15 	stw	r6,-4(fp)
8112f610:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8112f614:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112f618:	e0bfff17 	ldw	r2,-4(fp)
8112f61c:	1000021e 	bne	r2,zero,8112f628 <OSFlagDel+0x3c>
        return (pgrp);
8112f620:	e0bffd17 	ldw	r2,-12(fp)
8112f624:	00008006 	br	8112f828 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8112f628:	e0bffd17 	ldw	r2,-12(fp)
8112f62c:	1000051e 	bne	r2,zero,8112f644 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112f630:	e0bfff17 	ldw	r2,-4(fp)
8112f634:	00c01b84 	movi	r3,110
8112f638:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8112f63c:	e0bffd17 	ldw	r2,-12(fp)
8112f640:	00007906 	br	8112f828 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112f644:	d0a09103 	ldbu	r2,-32188(gp)
8112f648:	10803fcc 	andi	r2,r2,255
8112f64c:	10000526 	beq	r2,zero,8112f664 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8112f650:	e0bfff17 	ldw	r2,-4(fp)
8112f654:	00c003c4 	movi	r3,15
8112f658:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8112f65c:	e0bffd17 	ldw	r2,-12(fp)
8112f660:	00007106 	br	8112f828 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
8112f664:	e0bffd17 	ldw	r2,-12(fp)
8112f668:	10800003 	ldbu	r2,0(r2)
8112f66c:	10803fcc 	andi	r2,r2,255
8112f670:	10800160 	cmpeqi	r2,r2,5
8112f674:	1000051e 	bne	r2,zero,8112f68c <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
8112f678:	e0bfff17 	ldw	r2,-4(fp)
8112f67c:	00c00044 	movi	r3,1
8112f680:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8112f684:	e0bffd17 	ldw	r2,-12(fp)
8112f688:	00006706 	br	8112f828 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f68c:	0005303a 	rdctl	r2,status
8112f690:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f694:	e0fffc17 	ldw	r3,-16(fp)
8112f698:	00bfff84 	movi	r2,-2
8112f69c:	1884703a 	and	r2,r3,r2
8112f6a0:	1001703a 	wrctl	status,r2
  
  return context;
8112f6a4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112f6a8:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
8112f6ac:	e0bffd17 	ldw	r2,-12(fp)
8112f6b0:	10800117 	ldw	r2,4(r2)
8112f6b4:	10000326 	beq	r2,zero,8112f6c4 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8112f6b8:	00800044 	movi	r2,1
8112f6bc:	e0bff405 	stb	r2,-48(fp)
8112f6c0:	00000106 	br	8112f6c8 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8112f6c4:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8112f6c8:	e0bffe03 	ldbu	r2,-8(fp)
8112f6cc:	10000326 	beq	r2,zero,8112f6dc <OSFlagDel+0xf0>
8112f6d0:	10800060 	cmpeqi	r2,r2,1
8112f6d4:	1000231e 	bne	r2,zero,8112f764 <OSFlagDel+0x178>
8112f6d8:	00004806 	br	8112f7fc <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
8112f6dc:	e0bff403 	ldbu	r2,-48(fp)
8112f6e0:	1000161e 	bne	r2,zero,8112f73c <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
8112f6e4:	e0bffd17 	ldw	r2,-12(fp)
8112f6e8:	00c00fc4 	movi	r3,63
8112f6ec:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8112f6f0:	e0bffd17 	ldw	r2,-12(fp)
8112f6f4:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8112f6f8:	e0bffd17 	ldw	r2,-12(fp)
8112f6fc:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
8112f700:	d0e09617 	ldw	r3,-32168(gp)
8112f704:	e0bffd17 	ldw	r2,-12(fp)
8112f708:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
8112f70c:	e0bffd17 	ldw	r2,-12(fp)
8112f710:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
8112f714:	e0bffd17 	ldw	r2,-12(fp)
8112f718:	d0a09615 	stw	r2,-32168(gp)
8112f71c:	e0bff717 	ldw	r2,-36(fp)
8112f720:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f724:	e0bff817 	ldw	r2,-32(fp)
8112f728:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
8112f72c:	e0bfff17 	ldw	r2,-4(fp)
8112f730:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
8112f734:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
8112f738:	00003a06 	br	8112f824 <OSFlagDel+0x238>
8112f73c:	e0bff717 	ldw	r2,-36(fp)
8112f740:	e0bff915 	stw	r2,-28(fp)
8112f744:	e0bff917 	ldw	r2,-28(fp)
8112f748:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
8112f74c:	e0bfff17 	ldw	r2,-4(fp)
8112f750:	00c01244 	movi	r3,73
8112f754:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
8112f758:	e0bffd17 	ldw	r2,-12(fp)
8112f75c:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8112f760:	00003006 	br	8112f824 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8112f764:	e0bffd17 	ldw	r2,-12(fp)
8112f768:	10800117 	ldw	r2,4(r2)
8112f76c:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8112f770:	00000606 	br	8112f78c <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8112f774:	000b883a 	mov	r5,zero
8112f778:	e13ff517 	ldw	r4,-44(fp)
8112f77c:	11307a00 	call	811307a0 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8112f780:	e0bff517 	ldw	r2,-44(fp)
8112f784:	10800017 	ldw	r2,0(r2)
8112f788:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8112f78c:	e0bff517 	ldw	r2,-44(fp)
8112f790:	103ff81e 	bne	r2,zero,8112f774 <__reset+0xfb10f774>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
8112f794:	e0bffd17 	ldw	r2,-12(fp)
8112f798:	00c00fc4 	movi	r3,63
8112f79c:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8112f7a0:	e0bffd17 	ldw	r2,-12(fp)
8112f7a4:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8112f7a8:	e0bffd17 	ldw	r2,-12(fp)
8112f7ac:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
8112f7b0:	d0e09617 	ldw	r3,-32168(gp)
8112f7b4:	e0bffd17 	ldw	r2,-12(fp)
8112f7b8:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
8112f7bc:	e0bffd17 	ldw	r2,-12(fp)
8112f7c0:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
8112f7c4:	e0bffd17 	ldw	r2,-12(fp)
8112f7c8:	d0a09615 	stw	r2,-32168(gp)
8112f7cc:	e0bff717 	ldw	r2,-36(fp)
8112f7d0:	e0bffa15 	stw	r2,-24(fp)
8112f7d4:	e0bffa17 	ldw	r2,-24(fp)
8112f7d8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8112f7dc:	e0bff403 	ldbu	r2,-48(fp)
8112f7e0:	10800058 	cmpnei	r2,r2,1
8112f7e4:	1000011e 	bne	r2,zero,8112f7ec <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8112f7e8:	112e8b00 	call	8112e8b0 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
8112f7ec:	e0bfff17 	ldw	r2,-4(fp)
8112f7f0:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8112f7f4:	e03ff615 	stw	zero,-40(fp)
             break;
8112f7f8:	00000a06 	br	8112f824 <OSFlagDel+0x238>
8112f7fc:	e0bff717 	ldw	r2,-36(fp)
8112f800:	e0bffb15 	stw	r2,-20(fp)
8112f804:	e0bffb17 	ldw	r2,-20(fp)
8112f808:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
8112f80c:	e0bfff17 	ldw	r2,-4(fp)
8112f810:	00c001c4 	movi	r3,7
8112f814:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
8112f818:	e0bffd17 	ldw	r2,-12(fp)
8112f81c:	e0bff615 	stw	r2,-40(fp)
             break;
8112f820:	0001883a 	nop
    }
    return (pgrp_return);
8112f824:	e0bff617 	ldw	r2,-40(fp)
}
8112f828:	e037883a 	mov	sp,fp
8112f82c:	dfc00117 	ldw	ra,4(sp)
8112f830:	df000017 	ldw	fp,0(sp)
8112f834:	dec00204 	addi	sp,sp,8
8112f838:	f800283a 	ret

8112f83c <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8112f83c:	defff604 	addi	sp,sp,-40
8112f840:	de00012e 	bgeu	sp,et,8112f848 <OSFlagNameGet+0xc>
8112f844:	003b68fa 	trap	3
8112f848:	dfc00915 	stw	ra,36(sp)
8112f84c:	df000815 	stw	fp,32(sp)
8112f850:	df000804 	addi	fp,sp,32
8112f854:	e13ffd15 	stw	r4,-12(fp)
8112f858:	e17ffe15 	stw	r5,-8(fp)
8112f85c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112f860:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112f864:	e0bfff17 	ldw	r2,-4(fp)
8112f868:	1000021e 	bne	r2,zero,8112f874 <OSFlagNameGet+0x38>
        return (0);
8112f86c:	0005883a 	mov	r2,zero
8112f870:	00003906 	br	8112f958 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8112f874:	e0bffd17 	ldw	r2,-12(fp)
8112f878:	1000051e 	bne	r2,zero,8112f890 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112f87c:	e0bfff17 	ldw	r2,-4(fp)
8112f880:	00c01b84 	movi	r3,110
8112f884:	10c00005 	stb	r3,0(r2)
        return (0);
8112f888:	0005883a 	mov	r2,zero
8112f88c:	00003206 	br	8112f958 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112f890:	e0bffe17 	ldw	r2,-8(fp)
8112f894:	1000051e 	bne	r2,zero,8112f8ac <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8112f898:	e0bfff17 	ldw	r2,-4(fp)
8112f89c:	00c00304 	movi	r3,12
8112f8a0:	10c00005 	stb	r3,0(r2)
        return (0);
8112f8a4:	0005883a 	mov	r2,zero
8112f8a8:	00002b06 	br	8112f958 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112f8ac:	d0a09103 	ldbu	r2,-32188(gp)
8112f8b0:	10803fcc 	andi	r2,r2,255
8112f8b4:	10000526 	beq	r2,zero,8112f8cc <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8112f8b8:	e0bfff17 	ldw	r2,-4(fp)
8112f8bc:	00c00444 	movi	r3,17
8112f8c0:	10c00005 	stb	r3,0(r2)
        return (0);
8112f8c4:	0005883a 	mov	r2,zero
8112f8c8:	00002306 	br	8112f958 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f8cc:	0005303a 	rdctl	r2,status
8112f8d0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f8d4:	e0fffc17 	ldw	r3,-16(fp)
8112f8d8:	00bfff84 	movi	r2,-2
8112f8dc:	1884703a 	and	r2,r3,r2
8112f8e0:	1001703a 	wrctl	status,r2
  
  return context;
8112f8e4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112f8e8:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8112f8ec:	e0bffd17 	ldw	r2,-12(fp)
8112f8f0:	10800003 	ldbu	r2,0(r2)
8112f8f4:	10803fcc 	andi	r2,r2,255
8112f8f8:	10800160 	cmpeqi	r2,r2,5
8112f8fc:	1000091e 	bne	r2,zero,8112f924 <OSFlagNameGet+0xe8>
8112f900:	e0bff817 	ldw	r2,-32(fp)
8112f904:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f908:	e0bff917 	ldw	r2,-28(fp)
8112f90c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8112f910:	e0bfff17 	ldw	r2,-4(fp)
8112f914:	00c00044 	movi	r3,1
8112f918:	10c00005 	stb	r3,0(r2)
        return (0);
8112f91c:	0005883a 	mov	r2,zero
8112f920:	00000d06 	br	8112f958 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
8112f924:	e0bffd17 	ldw	r2,-12(fp)
8112f928:	10800284 	addi	r2,r2,10
8112f92c:	100b883a 	mov	r5,r2
8112f930:	e13ffe17 	ldw	r4,-8(fp)
8112f934:	112ea040 	call	8112ea04 <OS_StrCopy>
8112f938:	e0bffb05 	stb	r2,-20(fp)
8112f93c:	e0bff817 	ldw	r2,-32(fp)
8112f940:	e0bffa15 	stw	r2,-24(fp)
8112f944:	e0bffa17 	ldw	r2,-24(fp)
8112f948:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112f94c:	e0bfff17 	ldw	r2,-4(fp)
8112f950:	10000005 	stb	zero,0(r2)
    return (len);
8112f954:	e0bffb03 	ldbu	r2,-20(fp)
}
8112f958:	e037883a 	mov	sp,fp
8112f95c:	dfc00117 	ldw	ra,4(sp)
8112f960:	df000017 	ldw	fp,0(sp)
8112f964:	dec00204 	addi	sp,sp,8
8112f968:	f800283a 	ret

8112f96c <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8112f96c:	defff504 	addi	sp,sp,-44
8112f970:	de00012e 	bgeu	sp,et,8112f978 <OSFlagNameSet+0xc>
8112f974:	003b68fa 	trap	3
8112f978:	dfc00a15 	stw	ra,40(sp)
8112f97c:	df000915 	stw	fp,36(sp)
8112f980:	df000904 	addi	fp,sp,36
8112f984:	e13ffd15 	stw	r4,-12(fp)
8112f988:	e17ffe15 	stw	r5,-8(fp)
8112f98c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112f990:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112f994:	e0bfff17 	ldw	r2,-4(fp)
8112f998:	10004326 	beq	r2,zero,8112faa8 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8112f99c:	e0bffd17 	ldw	r2,-12(fp)
8112f9a0:	1000041e 	bne	r2,zero,8112f9b4 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112f9a4:	e0bfff17 	ldw	r2,-4(fp)
8112f9a8:	00c01b84 	movi	r3,110
8112f9ac:	10c00005 	stb	r3,0(r2)
        return;
8112f9b0:	00003e06 	br	8112faac <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112f9b4:	e0bffe17 	ldw	r2,-8(fp)
8112f9b8:	1000041e 	bne	r2,zero,8112f9cc <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8112f9bc:	e0bfff17 	ldw	r2,-4(fp)
8112f9c0:	00c00304 	movi	r3,12
8112f9c4:	10c00005 	stb	r3,0(r2)
        return;
8112f9c8:	00003806 	br	8112faac <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112f9cc:	d0a09103 	ldbu	r2,-32188(gp)
8112f9d0:	10803fcc 	andi	r2,r2,255
8112f9d4:	10000426 	beq	r2,zero,8112f9e8 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8112f9d8:	e0bfff17 	ldw	r2,-4(fp)
8112f9dc:	00c00484 	movi	r3,18
8112f9e0:	10c00005 	stb	r3,0(r2)
        return;
8112f9e4:	00003106 	br	8112faac <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f9e8:	0005303a 	rdctl	r2,status
8112f9ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f9f0:	e0fffc17 	ldw	r3,-16(fp)
8112f9f4:	00bfff84 	movi	r2,-2
8112f9f8:	1884703a 	and	r2,r3,r2
8112f9fc:	1001703a 	wrctl	status,r2
  
  return context;
8112fa00:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112fa04:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8112fa08:	e0bffd17 	ldw	r2,-12(fp)
8112fa0c:	10800003 	ldbu	r2,0(r2)
8112fa10:	10803fcc 	andi	r2,r2,255
8112fa14:	10800160 	cmpeqi	r2,r2,5
8112fa18:	1000081e 	bne	r2,zero,8112fa3c <OSFlagNameSet+0xd0>
8112fa1c:	e0bff717 	ldw	r2,-36(fp)
8112fa20:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112fa24:	e0bff817 	ldw	r2,-32(fp)
8112fa28:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8112fa2c:	e0bfff17 	ldw	r2,-4(fp)
8112fa30:	00c00044 	movi	r3,1
8112fa34:	10c00005 	stb	r3,0(r2)
        return;
8112fa38:	00001c06 	br	8112faac <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8112fa3c:	e13ffe17 	ldw	r4,-8(fp)
8112fa40:	112ea800 	call	8112ea80 <OS_StrLen>
8112fa44:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
8112fa48:	e0bffa03 	ldbu	r2,-24(fp)
8112fa4c:	10800830 	cmpltui	r2,r2,32
8112fa50:	1000081e 	bne	r2,zero,8112fa74 <OSFlagNameSet+0x108>
8112fa54:	e0bff717 	ldw	r2,-36(fp)
8112fa58:	e0bff915 	stw	r2,-28(fp)
8112fa5c:	e0bff917 	ldw	r2,-28(fp)
8112fa60:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
8112fa64:	e0bfff17 	ldw	r2,-4(fp)
8112fa68:	00c01cc4 	movi	r3,115
8112fa6c:	10c00005 	stb	r3,0(r2)
        return;
8112fa70:	00000e06 	br	8112faac <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8112fa74:	e0bffd17 	ldw	r2,-12(fp)
8112fa78:	10800284 	addi	r2,r2,10
8112fa7c:	e17ffe17 	ldw	r5,-8(fp)
8112fa80:	1009883a 	mov	r4,r2
8112fa84:	112ea040 	call	8112ea04 <OS_StrCopy>
8112fa88:	e0bff717 	ldw	r2,-36(fp)
8112fa8c:	e0bffb15 	stw	r2,-20(fp)
8112fa90:	e0bffb17 	ldw	r2,-20(fp)
8112fa94:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112fa98:	e0bfff17 	ldw	r2,-4(fp)
8112fa9c:	10000005 	stb	zero,0(r2)
    return;
8112faa0:	0001883a 	nop
8112faa4:	00000106 	br	8112faac <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8112faa8:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
8112faac:	e037883a 	mov	sp,fp
8112fab0:	dfc00117 	ldw	ra,4(sp)
8112fab4:	df000017 	ldw	fp,0(sp)
8112fab8:	dec00204 	addi	sp,sp,8
8112fabc:	f800283a 	ret

8112fac0 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8112fac0:	deffe104 	addi	sp,sp,-124
8112fac4:	de00012e 	bgeu	sp,et,8112facc <OSFlagPend+0xc>
8112fac8:	003b68fa 	trap	3
8112facc:	dfc01e15 	stw	ra,120(sp)
8112fad0:	df001d15 	stw	fp,116(sp)
8112fad4:	df001d04 	addi	fp,sp,116
8112fad8:	e13ffc15 	stw	r4,-16(fp)
8112fadc:	2809883a 	mov	r4,r5
8112fae0:	3007883a 	mov	r3,r6
8112fae4:	3805883a 	mov	r2,r7
8112fae8:	e13ffd0d 	sth	r4,-12(fp)
8112faec:	e0fffe05 	stb	r3,-8(fp)
8112faf0:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8112faf4:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112faf8:	e0800217 	ldw	r2,8(fp)
8112fafc:	1000021e 	bne	r2,zero,8112fb08 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8112fb00:	0005883a 	mov	r2,zero
8112fb04:	00015906 	br	8113006c <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8112fb08:	e0bffc17 	ldw	r2,-16(fp)
8112fb0c:	1000051e 	bne	r2,zero,8112fb24 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112fb10:	e0800217 	ldw	r2,8(fp)
8112fb14:	00c01b84 	movi	r3,110
8112fb18:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112fb1c:	0005883a 	mov	r2,zero
8112fb20:	00015206 	br	8113006c <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112fb24:	d0a09103 	ldbu	r2,-32188(gp)
8112fb28:	10803fcc 	andi	r2,r2,255
8112fb2c:	10000526 	beq	r2,zero,8112fb44 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8112fb30:	e0800217 	ldw	r2,8(fp)
8112fb34:	00c00084 	movi	r3,2
8112fb38:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112fb3c:	0005883a 	mov	r2,zero
8112fb40:	00014a06 	br	8113006c <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8112fb44:	d0a07f03 	ldbu	r2,-32260(gp)
8112fb48:	10803fcc 	andi	r2,r2,255
8112fb4c:	10000526 	beq	r2,zero,8112fb64 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8112fb50:	e0800217 	ldw	r2,8(fp)
8112fb54:	00c00344 	movi	r3,13
8112fb58:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112fb5c:	0005883a 	mov	r2,zero
8112fb60:	00014206 	br	8113006c <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8112fb64:	e0bffc17 	ldw	r2,-16(fp)
8112fb68:	10800003 	ldbu	r2,0(r2)
8112fb6c:	10803fcc 	andi	r2,r2,255
8112fb70:	10800160 	cmpeqi	r2,r2,5
8112fb74:	1000051e 	bne	r2,zero,8112fb8c <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
8112fb78:	e0800217 	ldw	r2,8(fp)
8112fb7c:	00c00044 	movi	r3,1
8112fb80:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112fb84:	0005883a 	mov	r2,zero
8112fb88:	00013806 	br	8113006c <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8112fb8c:	e0fffe03 	ldbu	r3,-8(fp)
8112fb90:	00bfe004 	movi	r2,-128
8112fb94:	1884703a 	and	r2,r3,r2
8112fb98:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
8112fb9c:	e0bfe603 	ldbu	r2,-104(fp)
8112fba0:	10000626 	beq	r2,zero,8112fbbc <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8112fba4:	e0bffe03 	ldbu	r2,-8(fp)
8112fba8:	10801fcc 	andi	r2,r2,127
8112fbac:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8112fbb0:	00800044 	movi	r2,1
8112fbb4:	e0bfe405 	stb	r2,-112(fp)
8112fbb8:	00000106 	br	8112fbc0 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
8112fbbc:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112fbc0:	0005303a 	rdctl	r2,status
8112fbc4:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112fbc8:	e0fff617 	ldw	r3,-40(fp)
8112fbcc:	00bfff84 	movi	r2,-2
8112fbd0:	1884703a 	and	r2,r3,r2
8112fbd4:	1001703a 	wrctl	status,r2
  
  return context;
8112fbd8:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8112fbdc:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8112fbe0:	e0bffe03 	ldbu	r2,-8(fp)
8112fbe4:	10c00060 	cmpeqi	r3,r2,1
8112fbe8:	1800921e 	bne	r3,zero,8112fe34 <OSFlagPend+0x374>
8112fbec:	10c00088 	cmpgei	r3,r2,2
8112fbf0:	1800021e 	bne	r3,zero,8112fbfc <OSFlagPend+0x13c>
8112fbf4:	10006126 	beq	r2,zero,8112fd7c <OSFlagPend+0x2bc>
8112fbf8:	0000bb06 	br	8112fee8 <OSFlagPend+0x428>
8112fbfc:	10c000a0 	cmpeqi	r3,r2,2
8112fc00:	1800031e 	bne	r3,zero,8112fc10 <OSFlagPend+0x150>
8112fc04:	108000e0 	cmpeqi	r2,r2,3
8112fc08:	10002f1e 	bne	r2,zero,8112fcc8 <OSFlagPend+0x208>
8112fc0c:	0000b606 	br	8112fee8 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8112fc10:	e0bffc17 	ldw	r2,-16(fp)
8112fc14:	10c0020b 	ldhu	r3,8(r2)
8112fc18:	e0bffd0b 	ldhu	r2,-12(fp)
8112fc1c:	1884703a 	and	r2,r3,r2
8112fc20:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8112fc24:	e0ffe80b 	ldhu	r3,-96(fp)
8112fc28:	e0bffd0b 	ldhu	r2,-12(fp)
8112fc2c:	1880171e 	bne	r3,r2,8112fc8c <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112fc30:	e0bfe403 	ldbu	r2,-112(fp)
8112fc34:	10800058 	cmpnei	r2,r2,1
8112fc38:	1000091e 	bne	r2,zero,8112fc60 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8112fc3c:	e0bffc17 	ldw	r2,-16(fp)
8112fc40:	1080020b 	ldhu	r2,8(r2)
8112fc44:	1007883a 	mov	r3,r2
8112fc48:	e0bfe80b 	ldhu	r2,-96(fp)
8112fc4c:	0084303a 	nor	r2,zero,r2
8112fc50:	1884703a 	and	r2,r3,r2
8112fc54:	1007883a 	mov	r3,r2
8112fc58:	e0bffc17 	ldw	r2,-16(fp)
8112fc5c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8112fc60:	d0a09217 	ldw	r2,-32184(gp)
8112fc64:	e0ffe80b 	ldhu	r3,-96(fp)
8112fc68:	10c00b0d 	sth	r3,44(r2)
8112fc6c:	e0bfe517 	ldw	r2,-108(fp)
8112fc70:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112fc74:	e0bfe717 	ldw	r2,-100(fp)
8112fc78:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8112fc7c:	e0800217 	ldw	r2,8(fp)
8112fc80:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8112fc84:	e0bfe80b 	ldhu	r2,-96(fp)
8112fc88:	0000f806 	br	8113006c <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8112fc8c:	e13ffd0b 	ldhu	r4,-12(fp)
8112fc90:	e17ffe03 	ldbu	r5,-8(fp)
8112fc94:	e0bfff0b 	ldhu	r2,-4(fp)
8112fc98:	e0fff704 	addi	r3,fp,-36
8112fc9c:	d8800015 	stw	r2,0(sp)
8112fca0:	280f883a 	mov	r7,r5
8112fca4:	200d883a 	mov	r6,r4
8112fca8:	180b883a 	mov	r5,r3
8112fcac:	e13ffc17 	ldw	r4,-16(fp)
8112fcb0:	11305500 	call	81130550 <OS_FlagBlock>
8112fcb4:	e0bfe517 	ldw	r2,-108(fp)
8112fcb8:	e0bfe915 	stw	r2,-92(fp)
8112fcbc:	e0bfe917 	ldw	r2,-92(fp)
8112fcc0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8112fcc4:	00009206 	br	8112ff10 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8112fcc8:	e0bffc17 	ldw	r2,-16(fp)
8112fccc:	10c0020b 	ldhu	r3,8(r2)
8112fcd0:	e0bffd0b 	ldhu	r2,-12(fp)
8112fcd4:	1884703a 	and	r2,r3,r2
8112fcd8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8112fcdc:	e0bfe80b 	ldhu	r2,-96(fp)
8112fce0:	10001726 	beq	r2,zero,8112fd40 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112fce4:	e0bfe403 	ldbu	r2,-112(fp)
8112fce8:	10800058 	cmpnei	r2,r2,1
8112fcec:	1000091e 	bne	r2,zero,8112fd14 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8112fcf0:	e0bffc17 	ldw	r2,-16(fp)
8112fcf4:	1080020b 	ldhu	r2,8(r2)
8112fcf8:	1007883a 	mov	r3,r2
8112fcfc:	e0bfe80b 	ldhu	r2,-96(fp)
8112fd00:	0084303a 	nor	r2,zero,r2
8112fd04:	1884703a 	and	r2,r3,r2
8112fd08:	1007883a 	mov	r3,r2
8112fd0c:	e0bffc17 	ldw	r2,-16(fp)
8112fd10:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8112fd14:	d0a09217 	ldw	r2,-32184(gp)
8112fd18:	e0ffe80b 	ldhu	r3,-96(fp)
8112fd1c:	10c00b0d 	sth	r3,44(r2)
8112fd20:	e0bfe517 	ldw	r2,-108(fp)
8112fd24:	e0bfea15 	stw	r2,-88(fp)
8112fd28:	e0bfea17 	ldw	r2,-88(fp)
8112fd2c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8112fd30:	e0800217 	ldw	r2,8(fp)
8112fd34:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8112fd38:	e0bfe80b 	ldhu	r2,-96(fp)
8112fd3c:	0000cb06 	br	8113006c <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8112fd40:	e13ffd0b 	ldhu	r4,-12(fp)
8112fd44:	e17ffe03 	ldbu	r5,-8(fp)
8112fd48:	e0bfff0b 	ldhu	r2,-4(fp)
8112fd4c:	e0fff704 	addi	r3,fp,-36
8112fd50:	d8800015 	stw	r2,0(sp)
8112fd54:	280f883a 	mov	r7,r5
8112fd58:	200d883a 	mov	r6,r4
8112fd5c:	180b883a 	mov	r5,r3
8112fd60:	e13ffc17 	ldw	r4,-16(fp)
8112fd64:	11305500 	call	81130550 <OS_FlagBlock>
8112fd68:	e0bfe517 	ldw	r2,-108(fp)
8112fd6c:	e0bfeb15 	stw	r2,-84(fp)
8112fd70:	e0bfeb17 	ldw	r2,-84(fp)
8112fd74:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8112fd78:	00006506 	br	8112ff10 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8112fd7c:	e0bffc17 	ldw	r2,-16(fp)
8112fd80:	1080020b 	ldhu	r2,8(r2)
8112fd84:	0084303a 	nor	r2,zero,r2
8112fd88:	1007883a 	mov	r3,r2
8112fd8c:	e0bffd0b 	ldhu	r2,-12(fp)
8112fd90:	1884703a 	and	r2,r3,r2
8112fd94:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8112fd98:	e0ffe80b 	ldhu	r3,-96(fp)
8112fd9c:	e0bffd0b 	ldhu	r2,-12(fp)
8112fda0:	1880151e 	bne	r3,r2,8112fdf8 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112fda4:	e0bfe403 	ldbu	r2,-112(fp)
8112fda8:	10800058 	cmpnei	r2,r2,1
8112fdac:	1000071e 	bne	r2,zero,8112fdcc <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8112fdb0:	e0bffc17 	ldw	r2,-16(fp)
8112fdb4:	10c0020b 	ldhu	r3,8(r2)
8112fdb8:	e0bfe80b 	ldhu	r2,-96(fp)
8112fdbc:	1884b03a 	or	r2,r3,r2
8112fdc0:	1007883a 	mov	r3,r2
8112fdc4:	e0bffc17 	ldw	r2,-16(fp)
8112fdc8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8112fdcc:	d0a09217 	ldw	r2,-32184(gp)
8112fdd0:	e0ffe80b 	ldhu	r3,-96(fp)
8112fdd4:	10c00b0d 	sth	r3,44(r2)
8112fdd8:	e0bfe517 	ldw	r2,-108(fp)
8112fddc:	e0bfec15 	stw	r2,-80(fp)
8112fde0:	e0bfec17 	ldw	r2,-80(fp)
8112fde4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8112fde8:	e0800217 	ldw	r2,8(fp)
8112fdec:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8112fdf0:	e0bfe80b 	ldhu	r2,-96(fp)
8112fdf4:	00009d06 	br	8113006c <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8112fdf8:	e13ffd0b 	ldhu	r4,-12(fp)
8112fdfc:	e17ffe03 	ldbu	r5,-8(fp)
8112fe00:	e0bfff0b 	ldhu	r2,-4(fp)
8112fe04:	e0fff704 	addi	r3,fp,-36
8112fe08:	d8800015 	stw	r2,0(sp)
8112fe0c:	280f883a 	mov	r7,r5
8112fe10:	200d883a 	mov	r6,r4
8112fe14:	180b883a 	mov	r5,r3
8112fe18:	e13ffc17 	ldw	r4,-16(fp)
8112fe1c:	11305500 	call	81130550 <OS_FlagBlock>
8112fe20:	e0bfe517 	ldw	r2,-108(fp)
8112fe24:	e0bfed15 	stw	r2,-76(fp)
8112fe28:	e0bfed17 	ldw	r2,-76(fp)
8112fe2c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8112fe30:	00003706 	br	8112ff10 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8112fe34:	e0bffc17 	ldw	r2,-16(fp)
8112fe38:	1080020b 	ldhu	r2,8(r2)
8112fe3c:	0084303a 	nor	r2,zero,r2
8112fe40:	1007883a 	mov	r3,r2
8112fe44:	e0bffd0b 	ldhu	r2,-12(fp)
8112fe48:	1884703a 	and	r2,r3,r2
8112fe4c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8112fe50:	e0bfe80b 	ldhu	r2,-96(fp)
8112fe54:	10001526 	beq	r2,zero,8112feac <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112fe58:	e0bfe403 	ldbu	r2,-112(fp)
8112fe5c:	10800058 	cmpnei	r2,r2,1
8112fe60:	1000071e 	bne	r2,zero,8112fe80 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8112fe64:	e0bffc17 	ldw	r2,-16(fp)
8112fe68:	10c0020b 	ldhu	r3,8(r2)
8112fe6c:	e0bfe80b 	ldhu	r2,-96(fp)
8112fe70:	1884b03a 	or	r2,r3,r2
8112fe74:	1007883a 	mov	r3,r2
8112fe78:	e0bffc17 	ldw	r2,-16(fp)
8112fe7c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8112fe80:	d0a09217 	ldw	r2,-32184(gp)
8112fe84:	e0ffe80b 	ldhu	r3,-96(fp)
8112fe88:	10c00b0d 	sth	r3,44(r2)
8112fe8c:	e0bfe517 	ldw	r2,-108(fp)
8112fe90:	e0bfee15 	stw	r2,-72(fp)
8112fe94:	e0bfee17 	ldw	r2,-72(fp)
8112fe98:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8112fe9c:	e0800217 	ldw	r2,8(fp)
8112fea0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8112fea4:	e0bfe80b 	ldhu	r2,-96(fp)
8112fea8:	00007006 	br	8113006c <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8112feac:	e13ffd0b 	ldhu	r4,-12(fp)
8112feb0:	e17ffe03 	ldbu	r5,-8(fp)
8112feb4:	e0bfff0b 	ldhu	r2,-4(fp)
8112feb8:	e0fff704 	addi	r3,fp,-36
8112febc:	d8800015 	stw	r2,0(sp)
8112fec0:	280f883a 	mov	r7,r5
8112fec4:	200d883a 	mov	r6,r4
8112fec8:	180b883a 	mov	r5,r3
8112fecc:	e13ffc17 	ldw	r4,-16(fp)
8112fed0:	11305500 	call	81130550 <OS_FlagBlock>
8112fed4:	e0bfe517 	ldw	r2,-108(fp)
8112fed8:	e0bfef15 	stw	r2,-68(fp)
8112fedc:	e0bfef17 	ldw	r2,-68(fp)
8112fee0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8112fee4:	00000a06 	br	8112ff10 <OSFlagPend+0x450>
8112fee8:	e0bfe517 	ldw	r2,-108(fp)
8112feec:	e0bff015 	stw	r2,-64(fp)
8112fef0:	e0bff017 	ldw	r2,-64(fp)
8112fef4:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8112fef8:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
8112fefc:	e0800217 	ldw	r2,8(fp)
8112ff00:	00c01bc4 	movi	r3,111
8112ff04:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8112ff08:	e0bfe80b 	ldhu	r2,-96(fp)
8112ff0c:	00005706 	br	8113006c <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
8112ff10:	112e8b00 	call	8112e8b0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ff14:	0005303a 	rdctl	r2,status
8112ff18:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ff1c:	e0fff117 	ldw	r3,-60(fp)
8112ff20:	00bfff84 	movi	r2,-2
8112ff24:	1884703a 	and	r2,r3,r2
8112ff28:	1001703a 	wrctl	status,r2
  
  return context;
8112ff2c:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8112ff30:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8112ff34:	d0a09217 	ldw	r2,-32184(gp)
8112ff38:	10800c43 	ldbu	r2,49(r2)
8112ff3c:	10803fcc 	andi	r2,r2,255
8112ff40:	10001c26 	beq	r2,zero,8112ffb4 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8112ff44:	d0a09217 	ldw	r2,-32184(gp)
8112ff48:	10800c43 	ldbu	r2,49(r2)
8112ff4c:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8112ff50:	d0a09217 	ldw	r2,-32184(gp)
8112ff54:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
8112ff58:	e0bff704 	addi	r2,fp,-36
8112ff5c:	1009883a 	mov	r4,r2
8112ff60:	113089c0 	call	8113089c <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8112ff64:	d0a09217 	ldw	r2,-32184(gp)
8112ff68:	10000c05 	stb	zero,48(r2)
8112ff6c:	e0bfe517 	ldw	r2,-108(fp)
8112ff70:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ff74:	e0bff217 	ldw	r2,-56(fp)
8112ff78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
8112ff7c:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8112ff80:	e0bff303 	ldbu	r2,-52(fp)
8112ff84:	108000a0 	cmpeqi	r2,r2,2
8112ff88:	10000426 	beq	r2,zero,8112ff9c <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
8112ff8c:	e0800217 	ldw	r2,8(fp)
8112ff90:	00c00384 	movi	r3,14
8112ff94:	10c00005 	stb	r3,0(r2)
                 break;
8112ff98:	00000406 	br	8112ffac <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
8112ff9c:	e0800217 	ldw	r2,8(fp)
8112ffa0:	00c00284 	movi	r3,10
8112ffa4:	10c00005 	stb	r3,0(r2)
                 break;
8112ffa8:	0001883a 	nop
        }
        return (flags_rdy);
8112ffac:	e0bfe80b 	ldhu	r2,-96(fp)
8112ffb0:	00002e06 	br	8113006c <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8112ffb4:	d0a09217 	ldw	r2,-32184(gp)
8112ffb8:	10800b0b 	ldhu	r2,44(r2)
8112ffbc:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8112ffc0:	e0bfe403 	ldbu	r2,-112(fp)
8112ffc4:	10800058 	cmpnei	r2,r2,1
8112ffc8:	1000211e 	bne	r2,zero,81130050 <OSFlagPend+0x590>
        switch (wait_type) {
8112ffcc:	e0bffe03 	ldbu	r2,-8(fp)
8112ffd0:	10001616 	blt	r2,zero,8113002c <OSFlagPend+0x56c>
8112ffd4:	10c00090 	cmplti	r3,r2,2
8112ffd8:	18000c1e 	bne	r3,zero,8113000c <OSFlagPend+0x54c>
8112ffdc:	10800108 	cmpgei	r2,r2,4
8112ffe0:	1000121e 	bne	r2,zero,8113002c <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8112ffe4:	e0bffc17 	ldw	r2,-16(fp)
8112ffe8:	1080020b 	ldhu	r2,8(r2)
8112ffec:	1007883a 	mov	r3,r2
8112fff0:	e0bfe80b 	ldhu	r2,-96(fp)
8112fff4:	0084303a 	nor	r2,zero,r2
8112fff8:	1884703a 	and	r2,r3,r2
8112fffc:	1007883a 	mov	r3,r2
81130000:	e0bffc17 	ldw	r2,-16(fp)
81130004:	10c0020d 	sth	r3,8(r2)
                 break;
81130008:	00001106 	br	81130050 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
8113000c:	e0bffc17 	ldw	r2,-16(fp)
81130010:	10c0020b 	ldhu	r3,8(r2)
81130014:	e0bfe80b 	ldhu	r2,-96(fp)
81130018:	1884b03a 	or	r2,r3,r2
8113001c:	1007883a 	mov	r3,r2
81130020:	e0bffc17 	ldw	r2,-16(fp)
81130024:	10c0020d 	sth	r3,8(r2)
                 break;
81130028:	00000906 	br	81130050 <OSFlagPend+0x590>
8113002c:	e0bfe517 	ldw	r2,-108(fp)
81130030:	e0bff415 	stw	r2,-48(fp)
81130034:	e0bff417 	ldw	r2,-48(fp)
81130038:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113003c:	e0800217 	ldw	r2,8(fp)
81130040:	00c01bc4 	movi	r3,111
81130044:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81130048:	0005883a 	mov	r2,zero
8113004c:	00000706 	br	8113006c <OSFlagPend+0x5ac>
81130050:	e0bfe517 	ldw	r2,-108(fp)
81130054:	e0bff515 	stw	r2,-44(fp)
81130058:	e0bff517 	ldw	r2,-44(fp)
8113005c:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
81130060:	e0800217 	ldw	r2,8(fp)
81130064:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
81130068:	e0bfe80b 	ldhu	r2,-96(fp)
}
8113006c:	e037883a 	mov	sp,fp
81130070:	dfc00117 	ldw	ra,4(sp)
81130074:	df000017 	ldw	fp,0(sp)
81130078:	dec00204 	addi	sp,sp,8
8113007c:	f800283a 	ret

81130080 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
81130080:	defffb04 	addi	sp,sp,-20
81130084:	de00012e 	bgeu	sp,et,8113008c <OSFlagPendGetFlagsRdy+0xc>
81130088:	003b68fa 	trap	3
8113008c:	df000415 	stw	fp,16(sp)
81130090:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81130094:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130098:	0005303a 	rdctl	r2,status
8113009c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811300a0:	e0fffe17 	ldw	r3,-8(fp)
811300a4:	00bfff84 	movi	r2,-2
811300a8:	1884703a 	and	r2,r3,r2
811300ac:	1001703a 	wrctl	status,r2
  
  return context;
811300b0:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
811300b4:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
811300b8:	d0a09217 	ldw	r2,-32184(gp)
811300bc:	10800b0b 	ldhu	r2,44(r2)
811300c0:	e0bffd0d 	sth	r2,-12(fp)
811300c4:	e0bffc17 	ldw	r2,-16(fp)
811300c8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811300cc:	e0bfff17 	ldw	r2,-4(fp)
811300d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
811300d4:	e0bffd0b 	ldhu	r2,-12(fp)
}
811300d8:	e037883a 	mov	sp,fp
811300dc:	df000017 	ldw	fp,0(sp)
811300e0:	dec00104 	addi	sp,sp,4
811300e4:	f800283a 	ret

811300e8 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
811300e8:	deffef04 	addi	sp,sp,-68
811300ec:	de00012e 	bgeu	sp,et,811300f4 <OSFlagPost+0xc>
811300f0:	003b68fa 	trap	3
811300f4:	dfc01015 	stw	ra,64(sp)
811300f8:	df000f15 	stw	fp,60(sp)
811300fc:	df000f04 	addi	fp,sp,60
81130100:	e13ffc15 	stw	r4,-16(fp)
81130104:	2807883a 	mov	r3,r5
81130108:	3005883a 	mov	r2,r6
8113010c:	e1ffff15 	stw	r7,-4(fp)
81130110:	e0fffd0d 	sth	r3,-12(fp)
81130114:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
81130118:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113011c:	e0bfff17 	ldw	r2,-4(fp)
81130120:	1000021e 	bne	r2,zero,8113012c <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
81130124:	0005883a 	mov	r2,zero
81130128:	0000d106 	br	81130470 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
8113012c:	e0bffc17 	ldw	r2,-16(fp)
81130130:	1000051e 	bne	r2,zero,81130148 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81130134:	e0bfff17 	ldw	r2,-4(fp)
81130138:	00c01b84 	movi	r3,110
8113013c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81130140:	0005883a 	mov	r2,zero
81130144:	0000ca06 	br	81130470 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
81130148:	e0bffc17 	ldw	r2,-16(fp)
8113014c:	10800003 	ldbu	r2,0(r2)
81130150:	10803fcc 	andi	r2,r2,255
81130154:	10800160 	cmpeqi	r2,r2,5
81130158:	1000051e 	bne	r2,zero,81130170 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
8113015c:	e0bfff17 	ldw	r2,-4(fp)
81130160:	00c00044 	movi	r3,1
81130164:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81130168:	0005883a 	mov	r2,zero
8113016c:	0000c006 	br	81130470 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130170:	0005303a 	rdctl	r2,status
81130174:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130178:	e0fffb17 	ldw	r3,-20(fp)
8113017c:	00bfff84 	movi	r2,-2
81130180:	1884703a 	and	r2,r3,r2
81130184:	1001703a 	wrctl	status,r2
  
  return context;
81130188:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113018c:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
81130190:	e0bffe03 	ldbu	r2,-8(fp)
81130194:	10000326 	beq	r2,zero,811301a4 <OSFlagPost+0xbc>
81130198:	10800060 	cmpeqi	r2,r2,1
8113019c:	10000b1e 	bne	r2,zero,811301cc <OSFlagPost+0xe4>
811301a0:	00001206 	br	811301ec <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
811301a4:	e0bffc17 	ldw	r2,-16(fp)
811301a8:	1080020b 	ldhu	r2,8(r2)
811301ac:	1007883a 	mov	r3,r2
811301b0:	e0bffd0b 	ldhu	r2,-12(fp)
811301b4:	0084303a 	nor	r2,zero,r2
811301b8:	1884703a 	and	r2,r3,r2
811301bc:	1007883a 	mov	r3,r2
811301c0:	e0bffc17 	ldw	r2,-16(fp)
811301c4:	10c0020d 	sth	r3,8(r2)
             break;
811301c8:	00001106 	br	81130210 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
811301cc:	e0bffc17 	ldw	r2,-16(fp)
811301d0:	10c0020b 	ldhu	r3,8(r2)
811301d4:	e0bffd0b 	ldhu	r2,-12(fp)
811301d8:	1884b03a 	or	r2,r3,r2
811301dc:	1007883a 	mov	r3,r2
811301e0:	e0bffc17 	ldw	r2,-16(fp)
811301e4:	10c0020d 	sth	r3,8(r2)
             break;
811301e8:	00000906 	br	81130210 <OSFlagPost+0x128>
811301ec:	e0bff317 	ldw	r2,-52(fp)
811301f0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811301f4:	e0bff417 	ldw	r2,-48(fp)
811301f8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
811301fc:	e0bfff17 	ldw	r2,-4(fp)
81130200:	00c01c44 	movi	r3,113
81130204:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
81130208:	0005883a 	mov	r2,zero
8113020c:	00009806 	br	81130470 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
81130210:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81130214:	e0bffc17 	ldw	r2,-16(fp)
81130218:	10800117 	ldw	r2,4(r2)
8113021c:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81130220:	00007706 	br	81130400 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
81130224:	e0bff117 	ldw	r2,-60(fp)
81130228:	10800483 	ldbu	r2,18(r2)
8113022c:	10803fcc 	andi	r2,r2,255
81130230:	10c00060 	cmpeqi	r3,r2,1
81130234:	18004a1e 	bne	r3,zero,81130360 <OSFlagPost+0x278>
81130238:	10c00088 	cmpgei	r3,r2,2
8113023c:	1800021e 	bne	r3,zero,81130248 <OSFlagPost+0x160>
81130240:	10002f26 	beq	r2,zero,81130300 <OSFlagPost+0x218>
81130244:	00005b06 	br	811303b4 <OSFlagPost+0x2cc>
81130248:	10c000a0 	cmpeqi	r3,r2,2
8113024c:	1800031e 	bne	r3,zero,8113025c <OSFlagPost+0x174>
81130250:	108000e0 	cmpeqi	r2,r2,3
81130254:	1000171e 	bne	r2,zero,811302b4 <OSFlagPost+0x1cc>
81130258:	00005606 	br	811303b4 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113025c:	e0bffc17 	ldw	r2,-16(fp)
81130260:	10c0020b 	ldhu	r3,8(r2)
81130264:	e0bff117 	ldw	r2,-60(fp)
81130268:	1080040b 	ldhu	r2,16(r2)
8113026c:	1884703a 	and	r2,r3,r2
81130270:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
81130274:	e0bff117 	ldw	r2,-60(fp)
81130278:	1080040b 	ldhu	r2,16(r2)
8113027c:	10ffffcc 	andi	r3,r2,65535
81130280:	e0bff60b 	ldhu	r2,-40(fp)
81130284:	1880541e 	bne	r3,r2,811303d8 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81130288:	e0bff60b 	ldhu	r2,-40(fp)
8113028c:	100b883a 	mov	r5,r2
81130290:	e13ff117 	ldw	r4,-60(fp)
81130294:	11307a00 	call	811307a0 <OS_FlagTaskRdy>
81130298:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113029c:	e0bff683 	ldbu	r2,-38(fp)
811302a0:	10800058 	cmpnei	r2,r2,1
811302a4:	10004c1e 	bne	r2,zero,811303d8 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811302a8:	00800044 	movi	r2,1
811302ac:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811302b0:	00004906 	br	811303d8 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811302b4:	e0bffc17 	ldw	r2,-16(fp)
811302b8:	10c0020b 	ldhu	r3,8(r2)
811302bc:	e0bff117 	ldw	r2,-60(fp)
811302c0:	1080040b 	ldhu	r2,16(r2)
811302c4:	1884703a 	and	r2,r3,r2
811302c8:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
811302cc:	e0bff60b 	ldhu	r2,-40(fp)
811302d0:	10004326 	beq	r2,zero,811303e0 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811302d4:	e0bff60b 	ldhu	r2,-40(fp)
811302d8:	100b883a 	mov	r5,r2
811302dc:	e13ff117 	ldw	r4,-60(fp)
811302e0:	11307a00 	call	811307a0 <OS_FlagTaskRdy>
811302e4:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811302e8:	e0bff683 	ldbu	r2,-38(fp)
811302ec:	10800058 	cmpnei	r2,r2,1
811302f0:	10003b1e 	bne	r2,zero,811303e0 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811302f4:	00800044 	movi	r2,1
811302f8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811302fc:	00003806 	br	811303e0 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81130300:	e0bffc17 	ldw	r2,-16(fp)
81130304:	1080020b 	ldhu	r2,8(r2)
81130308:	0084303a 	nor	r2,zero,r2
8113030c:	1007883a 	mov	r3,r2
81130310:	e0bff117 	ldw	r2,-60(fp)
81130314:	1080040b 	ldhu	r2,16(r2)
81130318:	1884703a 	and	r2,r3,r2
8113031c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
81130320:	e0bff117 	ldw	r2,-60(fp)
81130324:	1080040b 	ldhu	r2,16(r2)
81130328:	10ffffcc 	andi	r3,r2,65535
8113032c:	e0bff60b 	ldhu	r2,-40(fp)
81130330:	18802d1e 	bne	r3,r2,811303e8 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81130334:	e0bff60b 	ldhu	r2,-40(fp)
81130338:	100b883a 	mov	r5,r2
8113033c:	e13ff117 	ldw	r4,-60(fp)
81130340:	11307a00 	call	811307a0 <OS_FlagTaskRdy>
81130344:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81130348:	e0bff683 	ldbu	r2,-38(fp)
8113034c:	10800058 	cmpnei	r2,r2,1
81130350:	1000251e 	bne	r2,zero,811303e8 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81130354:	00800044 	movi	r2,1
81130358:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113035c:	00002206 	br	811303e8 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81130360:	e0bffc17 	ldw	r2,-16(fp)
81130364:	1080020b 	ldhu	r2,8(r2)
81130368:	0084303a 	nor	r2,zero,r2
8113036c:	1007883a 	mov	r3,r2
81130370:	e0bff117 	ldw	r2,-60(fp)
81130374:	1080040b 	ldhu	r2,16(r2)
81130378:	1884703a 	and	r2,r3,r2
8113037c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81130380:	e0bff60b 	ldhu	r2,-40(fp)
81130384:	10001a26 	beq	r2,zero,811303f0 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81130388:	e0bff60b 	ldhu	r2,-40(fp)
8113038c:	100b883a 	mov	r5,r2
81130390:	e13ff117 	ldw	r4,-60(fp)
81130394:	11307a00 	call	811307a0 <OS_FlagTaskRdy>
81130398:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113039c:	e0bff683 	ldbu	r2,-38(fp)
811303a0:	10800058 	cmpnei	r2,r2,1
811303a4:	1000121e 	bne	r2,zero,811303f0 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811303a8:	00800044 	movi	r2,1
811303ac:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811303b0:	00000f06 	br	811303f0 <OSFlagPost+0x308>
811303b4:	e0bff317 	ldw	r2,-52(fp)
811303b8:	e0bff515 	stw	r2,-44(fp)
811303bc:	e0bff517 	ldw	r2,-44(fp)
811303c0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
811303c4:	e0bfff17 	ldw	r2,-4(fp)
811303c8:	00c01bc4 	movi	r3,111
811303cc:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
811303d0:	0005883a 	mov	r2,zero
811303d4:	00002606 	br	81130470 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811303d8:	0001883a 	nop
811303dc:	00000506 	br	811303f4 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811303e0:	0001883a 	nop
811303e4:	00000306 	br	811303f4 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811303e8:	0001883a 	nop
811303ec:	00000106 	br	811303f4 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811303f0:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
811303f4:	e0bff117 	ldw	r2,-60(fp)
811303f8:	10800017 	ldw	r2,0(r2)
811303fc:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81130400:	e0bff117 	ldw	r2,-60(fp)
81130404:	103f871e 	bne	r2,zero,81130224 <__reset+0xfb110224>
81130408:	e0bff317 	ldw	r2,-52(fp)
8113040c:	e0bff715 	stw	r2,-36(fp)
81130410:	e0bff717 	ldw	r2,-36(fp)
81130414:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
81130418:	e0bff203 	ldbu	r2,-56(fp)
8113041c:	10800058 	cmpnei	r2,r2,1
81130420:	1000011e 	bne	r2,zero,81130428 <OSFlagPost+0x340>
        OS_Sched();
81130424:	112e8b00 	call	8112e8b0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130428:	0005303a 	rdctl	r2,status
8113042c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130430:	e0fffa17 	ldw	r3,-24(fp)
81130434:	00bfff84 	movi	r2,-2
81130438:	1884703a 	and	r2,r3,r2
8113043c:	1001703a 	wrctl	status,r2
  
  return context;
81130440:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
81130444:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
81130448:	e0bffc17 	ldw	r2,-16(fp)
8113044c:	1080020b 	ldhu	r2,8(r2)
81130450:	e0bff90d 	sth	r2,-28(fp)
81130454:	e0bff317 	ldw	r2,-52(fp)
81130458:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113045c:	e0bff817 	ldw	r2,-32(fp)
81130460:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
81130464:	e0bfff17 	ldw	r2,-4(fp)
81130468:	10000005 	stb	zero,0(r2)
    return (flags_cur);
8113046c:	e0bff90b 	ldhu	r2,-28(fp)
}
81130470:	e037883a 	mov	sp,fp
81130474:	dfc00117 	ldw	ra,4(sp)
81130478:	df000017 	ldw	fp,0(sp)
8113047c:	dec00204 	addi	sp,sp,8
81130480:	f800283a 	ret

81130484 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
81130484:	defff904 	addi	sp,sp,-28
81130488:	de00012e 	bgeu	sp,et,81130490 <OSFlagQuery+0xc>
8113048c:	003b68fa 	trap	3
81130490:	df000615 	stw	fp,24(sp)
81130494:	df000604 	addi	fp,sp,24
81130498:	e13ffe15 	stw	r4,-8(fp)
8113049c:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
811304a0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
811304a4:	e0bfff17 	ldw	r2,-4(fp)
811304a8:	1000021e 	bne	r2,zero,811304b4 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
811304ac:	0005883a 	mov	r2,zero
811304b0:	00002306 	br	81130540 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
811304b4:	e0bffe17 	ldw	r2,-8(fp)
811304b8:	1000051e 	bne	r2,zero,811304d0 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811304bc:	e0bfff17 	ldw	r2,-4(fp)
811304c0:	00c01b84 	movi	r3,110
811304c4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811304c8:	0005883a 	mov	r2,zero
811304cc:	00001c06 	br	81130540 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
811304d0:	e0bffe17 	ldw	r2,-8(fp)
811304d4:	10800003 	ldbu	r2,0(r2)
811304d8:	10803fcc 	andi	r2,r2,255
811304dc:	10800160 	cmpeqi	r2,r2,5
811304e0:	1000051e 	bne	r2,zero,811304f8 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
811304e4:	e0bfff17 	ldw	r2,-4(fp)
811304e8:	00c00044 	movi	r3,1
811304ec:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811304f0:	0005883a 	mov	r2,zero
811304f4:	00001206 	br	81130540 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811304f8:	0005303a 	rdctl	r2,status
811304fc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130500:	e0fffc17 	ldw	r3,-16(fp)
81130504:	00bfff84 	movi	r2,-2
81130508:	1884703a 	and	r2,r3,r2
8113050c:	1001703a 	wrctl	status,r2
  
  return context;
81130510:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81130514:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
81130518:	e0bffe17 	ldw	r2,-8(fp)
8113051c:	1080020b 	ldhu	r2,8(r2)
81130520:	e0bffb0d 	sth	r2,-20(fp)
81130524:	e0bffa17 	ldw	r2,-24(fp)
81130528:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113052c:	e0bffd17 	ldw	r2,-12(fp)
81130530:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81130534:	e0bfff17 	ldw	r2,-4(fp)
81130538:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
8113053c:	e0bffb0b 	ldhu	r2,-20(fp)
}
81130540:	e037883a 	mov	sp,fp
81130544:	df000017 	ldw	fp,0(sp)
81130548:	dec00104 	addi	sp,sp,4
8113054c:	f800283a 	ret

81130550 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
81130550:	defff804 	addi	sp,sp,-32
81130554:	de00012e 	bgeu	sp,et,8113055c <OS_FlagBlock+0xc>
81130558:	003b68fa 	trap	3
8113055c:	df000715 	stw	fp,28(sp)
81130560:	df000704 	addi	fp,sp,28
81130564:	e13ffb15 	stw	r4,-20(fp)
81130568:	e17ffc15 	stw	r5,-16(fp)
8113056c:	3009883a 	mov	r4,r6
81130570:	3807883a 	mov	r3,r7
81130574:	e0800117 	ldw	r2,4(fp)
81130578:	e13ffd0d 	sth	r4,-12(fp)
8113057c:	e0fffe05 	stb	r3,-8(fp)
81130580:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
81130584:	d0a09217 	ldw	r2,-32184(gp)
81130588:	d0e09217 	ldw	r3,-32184(gp)
8113058c:	18c00c03 	ldbu	r3,48(r3)
81130590:	18c00814 	ori	r3,r3,32
81130594:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
81130598:	d0a09217 	ldw	r2,-32184(gp)
8113059c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
811305a0:	d0a09217 	ldw	r2,-32184(gp)
811305a4:	e0ffff0b 	ldhu	r3,-4(fp)
811305a8:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
811305ac:	d0a09217 	ldw	r2,-32184(gp)
811305b0:	e0fffc17 	ldw	r3,-16(fp)
811305b4:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
811305b8:	e0bffc17 	ldw	r2,-16(fp)
811305bc:	e0fffd0b 	ldhu	r3,-12(fp)
811305c0:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
811305c4:	e0bffc17 	ldw	r2,-16(fp)
811305c8:	e0fffe03 	ldbu	r3,-8(fp)
811305cc:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
811305d0:	d0e09217 	ldw	r3,-32184(gp)
811305d4:	e0bffc17 	ldw	r2,-16(fp)
811305d8:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
811305dc:	e0bffb17 	ldw	r2,-20(fp)
811305e0:	10c00117 	ldw	r3,4(r2)
811305e4:	e0bffc17 	ldw	r2,-16(fp)
811305e8:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
811305ec:	e0bffc17 	ldw	r2,-16(fp)
811305f0:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
811305f4:	e0bffc17 	ldw	r2,-16(fp)
811305f8:	e0fffb17 	ldw	r3,-20(fp)
811305fc:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81130600:	e0bffb17 	ldw	r2,-20(fp)
81130604:	10800117 	ldw	r2,4(r2)
81130608:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8113060c:	e0bff917 	ldw	r2,-28(fp)
81130610:	10000326 	beq	r2,zero,81130620 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
81130614:	e0bff917 	ldw	r2,-28(fp)
81130618:	e0fffc17 	ldw	r3,-16(fp)
8113061c:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
81130620:	e0bffb17 	ldw	r2,-20(fp)
81130624:	e0fffc17 	ldw	r3,-16(fp)
81130628:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
8113062c:	d0a09217 	ldw	r2,-32184(gp)
81130630:	10800d03 	ldbu	r2,52(r2)
81130634:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81130638:	e0fffa03 	ldbu	r3,-24(fp)
8113063c:	e13ffa03 	ldbu	r4,-24(fp)
81130640:	d0a08e44 	addi	r2,gp,-32199
81130644:	2085883a 	add	r2,r4,r2
81130648:	10800003 	ldbu	r2,0(r2)
8113064c:	1009883a 	mov	r4,r2
81130650:	d0a09217 	ldw	r2,-32184(gp)
81130654:	10800d43 	ldbu	r2,53(r2)
81130658:	0084303a 	nor	r2,zero,r2
8113065c:	2084703a 	and	r2,r4,r2
81130660:	1009883a 	mov	r4,r2
81130664:	d0a08e44 	addi	r2,gp,-32199
81130668:	1885883a 	add	r2,r3,r2
8113066c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
81130670:	e0fffa03 	ldbu	r3,-24(fp)
81130674:	d0a08e44 	addi	r2,gp,-32199
81130678:	1885883a 	add	r2,r3,r2
8113067c:	10800003 	ldbu	r2,0(r2)
81130680:	10803fcc 	andi	r2,r2,255
81130684:	1000071e 	bne	r2,zero,811306a4 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81130688:	d0a09217 	ldw	r2,-32184(gp)
8113068c:	10800d83 	ldbu	r2,54(r2)
81130690:	0084303a 	nor	r2,zero,r2
81130694:	1007883a 	mov	r3,r2
81130698:	d0a08e03 	ldbu	r2,-32200(gp)
8113069c:	1884703a 	and	r2,r3,r2
811306a0:	d0a08e05 	stb	r2,-32200(gp)
    }
}
811306a4:	0001883a 	nop
811306a8:	e037883a 	mov	sp,fp
811306ac:	df000017 	ldw	fp,0(sp)
811306b0:	dec00104 	addi	sp,sp,4
811306b4:	f800283a 	ret

811306b8 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
811306b8:	defffb04 	addi	sp,sp,-20
811306bc:	de00012e 	bgeu	sp,et,811306c4 <OS_FlagInit+0xc>
811306c0:	003b68fa 	trap	3
811306c4:	dfc00415 	stw	ra,16(sp)
811306c8:	df000315 	stw	fp,12(sp)
811306cc:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
811306d0:	01416004 	movi	r5,1408
811306d4:	012045b4 	movhi	r4,33046
811306d8:	2129a804 	addi	r4,r4,-22880
811306dc:	112e7e40 	call	8112e7e4 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
811306e0:	00a045b4 	movhi	r2,33046
811306e4:	10a9a804 	addi	r2,r2,-22880
811306e8:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
811306ec:	00a045b4 	movhi	r2,33046
811306f0:	10a9b304 	addi	r2,r2,-22836
811306f4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
811306f8:	e03ffd0d 	sth	zero,-12(fp)
811306fc:	00001306 	br	8113074c <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81130700:	e0bffe17 	ldw	r2,-8(fp)
81130704:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
81130708:	e0bffe17 	ldw	r2,-8(fp)
8113070c:	e0ffff17 	ldw	r3,-4(fp)
81130710:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
81130714:	e0bffe17 	ldw	r2,-8(fp)
81130718:	00c00fc4 	movi	r3,63
8113071c:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81130720:	e0bffe17 	ldw	r2,-8(fp)
81130724:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
81130728:	e0bffe17 	ldw	r2,-8(fp)
8113072c:	10800b04 	addi	r2,r2,44
81130730:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
81130734:	e0bfff17 	ldw	r2,-4(fp)
81130738:	10800b04 	addi	r2,r2,44
8113073c:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81130740:	e0bffd0b 	ldhu	r2,-12(fp)
81130744:	10800044 	addi	r2,r2,1
81130748:	e0bffd0d 	sth	r2,-12(fp)
8113074c:	e0bffd0b 	ldhu	r2,-12(fp)
81130750:	108007f0 	cmpltui	r2,r2,31
81130754:	103fea1e 	bne	r2,zero,81130700 <__reset+0xfb110700>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81130758:	e0bffe17 	ldw	r2,-8(fp)
8113075c:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
81130760:	e0bffe17 	ldw	r2,-8(fp)
81130764:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
81130768:	e0bffe17 	ldw	r2,-8(fp)
8113076c:	00c00fc4 	movi	r3,63
81130770:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81130774:	e0bffe17 	ldw	r2,-8(fp)
81130778:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8113077c:	00a045b4 	movhi	r2,33046
81130780:	10a9a804 	addi	r2,r2,-22880
81130784:	d0a09615 	stw	r2,-32168(gp)
#endif
}
81130788:	0001883a 	nop
8113078c:	e037883a 	mov	sp,fp
81130790:	dfc00117 	ldw	ra,4(sp)
81130794:	df000017 	ldw	fp,0(sp)
81130798:	dec00204 	addi	sp,sp,8
8113079c:	f800283a 	ret

811307a0 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
811307a0:	defffa04 	addi	sp,sp,-24
811307a4:	de00012e 	bgeu	sp,et,811307ac <OS_FlagTaskRdy+0xc>
811307a8:	003b68fa 	trap	3
811307ac:	dfc00515 	stw	ra,20(sp)
811307b0:	df000415 	stw	fp,16(sp)
811307b4:	df000404 	addi	fp,sp,16
811307b8:	e13ffe15 	stw	r4,-8(fp)
811307bc:	2805883a 	mov	r2,r5
811307c0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
811307c4:	e0bffe17 	ldw	r2,-8(fp)
811307c8:	10800217 	ldw	r2,8(r2)
811307cc:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
811307d0:	e0bffd17 	ldw	r2,-12(fp)
811307d4:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
811307d8:	e0bffd17 	ldw	r2,-12(fp)
811307dc:	e0ffff0b 	ldhu	r3,-4(fp)
811307e0:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
811307e4:	e0bffd17 	ldw	r2,-12(fp)
811307e8:	10c00c03 	ldbu	r3,48(r2)
811307ec:	00bff7c4 	movi	r2,-33
811307f0:	1884703a 	and	r2,r3,r2
811307f4:	1007883a 	mov	r3,r2
811307f8:	e0bffd17 	ldw	r2,-12(fp)
811307fc:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
81130800:	e0bffd17 	ldw	r2,-12(fp)
81130804:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
81130808:	e0bffd17 	ldw	r2,-12(fp)
8113080c:	10800c03 	ldbu	r2,48(r2)
81130810:	10803fcc 	andi	r2,r2,255
81130814:	1000181e 	bne	r2,zero,81130878 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
81130818:	e0bffd17 	ldw	r2,-12(fp)
8113081c:	10c00d83 	ldbu	r3,54(r2)
81130820:	d0a08e03 	ldbu	r2,-32200(gp)
81130824:	1884b03a 	or	r2,r3,r2
81130828:	d0a08e05 	stb	r2,-32200(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113082c:	e0bffd17 	ldw	r2,-12(fp)
81130830:	10800d03 	ldbu	r2,52(r2)
81130834:	10c03fcc 	andi	r3,r2,255
81130838:	e0bffd17 	ldw	r2,-12(fp)
8113083c:	10800d03 	ldbu	r2,52(r2)
81130840:	11003fcc 	andi	r4,r2,255
81130844:	d0a08e44 	addi	r2,gp,-32199
81130848:	2085883a 	add	r2,r4,r2
8113084c:	11000003 	ldbu	r4,0(r2)
81130850:	e0bffd17 	ldw	r2,-12(fp)
81130854:	10800d43 	ldbu	r2,53(r2)
81130858:	2084b03a 	or	r2,r4,r2
8113085c:	1009883a 	mov	r4,r2
81130860:	d0a08e44 	addi	r2,gp,-32199
81130864:	1885883a 	add	r2,r3,r2
81130868:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
8113086c:	00800044 	movi	r2,1
81130870:	e0bffc05 	stb	r2,-16(fp)
81130874:	00000106 	br	8113087c <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
81130878:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8113087c:	e13ffe17 	ldw	r4,-8(fp)
81130880:	113089c0 	call	8113089c <OS_FlagUnlink>
    return (sched);
81130884:	e0bffc03 	ldbu	r2,-16(fp)
}
81130888:	e037883a 	mov	sp,fp
8113088c:	dfc00117 	ldw	ra,4(sp)
81130890:	df000017 	ldw	fp,0(sp)
81130894:	dec00204 	addi	sp,sp,8
81130898:	f800283a 	ret

8113089c <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8113089c:	defffa04 	addi	sp,sp,-24
811308a0:	de00012e 	bgeu	sp,et,811308a8 <OS_FlagUnlink+0xc>
811308a4:	003b68fa 	trap	3
811308a8:	df000515 	stw	fp,20(sp)
811308ac:	df000504 	addi	fp,sp,20
811308b0:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
811308b4:	e0bfff17 	ldw	r2,-4(fp)
811308b8:	10800117 	ldw	r2,4(r2)
811308bc:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
811308c0:	e0bfff17 	ldw	r2,-4(fp)
811308c4:	10800017 	ldw	r2,0(r2)
811308c8:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
811308cc:	e0bffb17 	ldw	r2,-20(fp)
811308d0:	10000b1e 	bne	r2,zero,81130900 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
811308d4:	e0bfff17 	ldw	r2,-4(fp)
811308d8:	10800317 	ldw	r2,12(r2)
811308dc:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
811308e0:	e0bffd17 	ldw	r2,-12(fp)
811308e4:	e0fffc17 	ldw	r3,-16(fp)
811308e8:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
811308ec:	e0bffc17 	ldw	r2,-16(fp)
811308f0:	10000b26 	beq	r2,zero,81130920 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
811308f4:	e0bffc17 	ldw	r2,-16(fp)
811308f8:	10000115 	stw	zero,4(r2)
811308fc:	00000806 	br	81130920 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
81130900:	e0bffb17 	ldw	r2,-20(fp)
81130904:	e0fffc17 	ldw	r3,-16(fp)
81130908:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8113090c:	e0bffc17 	ldw	r2,-16(fp)
81130910:	10000326 	beq	r2,zero,81130920 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
81130914:	e0bffc17 	ldw	r2,-16(fp)
81130918:	e0fffb17 	ldw	r3,-20(fp)
8113091c:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
81130920:	e0bfff17 	ldw	r2,-4(fp)
81130924:	10800217 	ldw	r2,8(r2)
81130928:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
8113092c:	e0bffe17 	ldw	r2,-8(fp)
81130930:	10000a15 	stw	zero,40(r2)
#endif
}
81130934:	0001883a 	nop
81130938:	e037883a 	mov	sp,fp
8113093c:	df000017 	ldw	fp,0(sp)
81130940:	dec00104 	addi	sp,sp,4
81130944:	f800283a 	ret

81130948 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
81130948:	defff404 	addi	sp,sp,-48
8113094c:	de00012e 	bgeu	sp,et,81130954 <OSMemCreate+0xc>
81130950:	003b68fa 	trap	3
81130954:	df000b15 	stw	fp,44(sp)
81130958:	df000b04 	addi	fp,sp,44
8113095c:	e13ffc15 	stw	r4,-16(fp)
81130960:	e17ffd15 	stw	r5,-12(fp)
81130964:	e1bffe15 	stw	r6,-8(fp)
81130968:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113096c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81130970:	e0bfff17 	ldw	r2,-4(fp)
81130974:	1000021e 	bne	r2,zero,81130980 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
81130978:	0005883a 	mov	r2,zero
8113097c:	00006506 	br	81130b14 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
81130980:	e0bffc17 	ldw	r2,-16(fp)
81130984:	1000051e 	bne	r2,zero,8113099c <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81130988:	e0bfff17 	ldw	r2,-4(fp)
8113098c:	00c01884 	movi	r3,98
81130990:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81130994:	0005883a 	mov	r2,zero
81130998:	00005e06 	br	81130b14 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8113099c:	e0bffc17 	ldw	r2,-16(fp)
811309a0:	108000cc 	andi	r2,r2,3
811309a4:	10000526 	beq	r2,zero,811309bc <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
811309a8:	e0bfff17 	ldw	r2,-4(fp)
811309ac:	00c01884 	movi	r3,98
811309b0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811309b4:	0005883a 	mov	r2,zero
811309b8:	00005606 	br	81130b14 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
811309bc:	e0bffd17 	ldw	r2,-12(fp)
811309c0:	108000a8 	cmpgeui	r2,r2,2
811309c4:	1000051e 	bne	r2,zero,811309dc <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
811309c8:	e0bfff17 	ldw	r2,-4(fp)
811309cc:	00c016c4 	movi	r3,91
811309d0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811309d4:	0005883a 	mov	r2,zero
811309d8:	00004e06 	br	81130b14 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
811309dc:	e0bffe17 	ldw	r2,-8(fp)
811309e0:	10800128 	cmpgeui	r2,r2,4
811309e4:	1000051e 	bne	r2,zero,811309fc <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
811309e8:	e0bfff17 	ldw	r2,-4(fp)
811309ec:	00c01704 	movi	r3,92
811309f0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811309f4:	0005883a 	mov	r2,zero
811309f8:	00004606 	br	81130b14 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811309fc:	0005303a 	rdctl	r2,status
81130a00:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130a04:	e0fffb17 	ldw	r3,-20(fp)
81130a08:	00bfff84 	movi	r2,-2
81130a0c:	1884703a 	and	r2,r3,r2
81130a10:	1001703a 	wrctl	status,r2
  
  return context;
81130a14:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81130a18:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
81130a1c:	d0a08b17 	ldw	r2,-32212(gp)
81130a20:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
81130a24:	d0a08b17 	ldw	r2,-32212(gp)
81130a28:	10000326 	beq	r2,zero,81130a38 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
81130a2c:	d0a08b17 	ldw	r2,-32212(gp)
81130a30:	10800117 	ldw	r2,4(r2)
81130a34:	d0a08b15 	stw	r2,-32212(gp)
81130a38:	e0bff817 	ldw	r2,-32(fp)
81130a3c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130a40:	e0bff917 	ldw	r2,-28(fp)
81130a44:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
81130a48:	e0bffa17 	ldw	r2,-24(fp)
81130a4c:	1000051e 	bne	r2,zero,81130a64 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
81130a50:	e0bfff17 	ldw	r2,-4(fp)
81130a54:	00c01684 	movi	r3,90
81130a58:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81130a5c:	0005883a 	mov	r2,zero
81130a60:	00002c06 	br	81130b14 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
81130a64:	e0bffc17 	ldw	r2,-16(fp)
81130a68:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
81130a6c:	e0fffc17 	ldw	r3,-16(fp)
81130a70:	e0bffe17 	ldw	r2,-8(fp)
81130a74:	1885883a 	add	r2,r3,r2
81130a78:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
81130a7c:	e03ff715 	stw	zero,-36(fp)
81130a80:	00000c06 	br	81130ab4 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
81130a84:	e0bff617 	ldw	r2,-40(fp)
81130a88:	e0fff517 	ldw	r3,-44(fp)
81130a8c:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
81130a90:	e0bff517 	ldw	r2,-44(fp)
81130a94:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
81130a98:	e0fff517 	ldw	r3,-44(fp)
81130a9c:	e0bffe17 	ldw	r2,-8(fp)
81130aa0:	1885883a 	add	r2,r3,r2
81130aa4:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
81130aa8:	e0bff717 	ldw	r2,-36(fp)
81130aac:	10800044 	addi	r2,r2,1
81130ab0:	e0bff715 	stw	r2,-36(fp)
81130ab4:	e0bffd17 	ldw	r2,-12(fp)
81130ab8:	10bfffc4 	addi	r2,r2,-1
81130abc:	e0fff717 	ldw	r3,-36(fp)
81130ac0:	18bff036 	bltu	r3,r2,81130a84 <__reset+0xfb110a84>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
81130ac4:	e0bff617 	ldw	r2,-40(fp)
81130ac8:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
81130acc:	e0bffa17 	ldw	r2,-24(fp)
81130ad0:	e0fffc17 	ldw	r3,-16(fp)
81130ad4:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
81130ad8:	e0bffa17 	ldw	r2,-24(fp)
81130adc:	e0fffc17 	ldw	r3,-16(fp)
81130ae0:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
81130ae4:	e0bffa17 	ldw	r2,-24(fp)
81130ae8:	e0fffd17 	ldw	r3,-12(fp)
81130aec:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
81130af0:	e0bffa17 	ldw	r2,-24(fp)
81130af4:	e0fffd17 	ldw	r3,-12(fp)
81130af8:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
81130afc:	e0bffa17 	ldw	r2,-24(fp)
81130b00:	e0fffe17 	ldw	r3,-8(fp)
81130b04:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
81130b08:	e0bfff17 	ldw	r2,-4(fp)
81130b0c:	10000005 	stb	zero,0(r2)
    return (pmem);
81130b10:	e0bffa17 	ldw	r2,-24(fp)
}
81130b14:	e037883a 	mov	sp,fp
81130b18:	df000017 	ldw	fp,0(sp)
81130b1c:	dec00104 	addi	sp,sp,4
81130b20:	f800283a 	ret

81130b24 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
81130b24:	defff804 	addi	sp,sp,-32
81130b28:	de00012e 	bgeu	sp,et,81130b30 <OSMemGet+0xc>
81130b2c:	003b68fa 	trap	3
81130b30:	df000715 	stw	fp,28(sp)
81130b34:	df000704 	addi	fp,sp,28
81130b38:	e13ffe15 	stw	r4,-8(fp)
81130b3c:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81130b40:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81130b44:	e0bfff17 	ldw	r2,-4(fp)
81130b48:	1000021e 	bne	r2,zero,81130b54 <OSMemGet+0x30>
        return ((void *)0);
81130b4c:	0005883a 	mov	r2,zero
81130b50:	00002e06 	br	81130c0c <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
81130b54:	e0bffe17 	ldw	r2,-8(fp)
81130b58:	1000051e 	bne	r2,zero,81130b70 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81130b5c:	e0bfff17 	ldw	r2,-4(fp)
81130b60:	00c01804 	movi	r3,96
81130b64:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81130b68:	0005883a 	mov	r2,zero
81130b6c:	00002706 	br	81130c0c <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130b70:	0005303a 	rdctl	r2,status
81130b74:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130b78:	e0fffd17 	ldw	r3,-12(fp)
81130b7c:	00bfff84 	movi	r2,-2
81130b80:	1884703a 	and	r2,r3,r2
81130b84:	1001703a 	wrctl	status,r2
  
  return context;
81130b88:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81130b8c:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
81130b90:	e0bffe17 	ldw	r2,-8(fp)
81130b94:	10800417 	ldw	r2,16(r2)
81130b98:	10001426 	beq	r2,zero,81130bec <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
81130b9c:	e0bffe17 	ldw	r2,-8(fp)
81130ba0:	10800117 	ldw	r2,4(r2)
81130ba4:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
81130ba8:	e0bffb17 	ldw	r2,-20(fp)
81130bac:	10c00017 	ldw	r3,0(r2)
81130bb0:	e0bffe17 	ldw	r2,-8(fp)
81130bb4:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
81130bb8:	e0bffe17 	ldw	r2,-8(fp)
81130bbc:	10800417 	ldw	r2,16(r2)
81130bc0:	10ffffc4 	addi	r3,r2,-1
81130bc4:	e0bffe17 	ldw	r2,-8(fp)
81130bc8:	10c00415 	stw	r3,16(r2)
81130bcc:	e0bff917 	ldw	r2,-28(fp)
81130bd0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130bd4:	e0bffa17 	ldw	r2,-24(fp)
81130bd8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
81130bdc:	e0bfff17 	ldw	r2,-4(fp)
81130be0:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
81130be4:	e0bffb17 	ldw	r2,-20(fp)
81130be8:	00000806 	br	81130c0c <OSMemGet+0xe8>
81130bec:	e0bff917 	ldw	r2,-28(fp)
81130bf0:	e0bffc15 	stw	r2,-16(fp)
81130bf4:	e0bffc17 	ldw	r2,-16(fp)
81130bf8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
81130bfc:	e0bfff17 	ldw	r2,-4(fp)
81130c00:	00c01744 	movi	r3,93
81130c04:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
81130c08:	0005883a 	mov	r2,zero
}
81130c0c:	e037883a 	mov	sp,fp
81130c10:	df000017 	ldw	fp,0(sp)
81130c14:	dec00104 	addi	sp,sp,4
81130c18:	f800283a 	ret

81130c1c <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81130c1c:	defff704 	addi	sp,sp,-36
81130c20:	de00012e 	bgeu	sp,et,81130c28 <OSMemNameGet+0xc>
81130c24:	003b68fa 	trap	3
81130c28:	dfc00815 	stw	ra,32(sp)
81130c2c:	df000715 	stw	fp,28(sp)
81130c30:	df000704 	addi	fp,sp,28
81130c34:	e13ffd15 	stw	r4,-12(fp)
81130c38:	e17ffe15 	stw	r5,-8(fp)
81130c3c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130c40:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81130c44:	e0bfff17 	ldw	r2,-4(fp)
81130c48:	1000021e 	bne	r2,zero,81130c54 <OSMemNameGet+0x38>
        return (0);
81130c4c:	0005883a 	mov	r2,zero
81130c50:	00002b06 	br	81130d00 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81130c54:	e0bffd17 	ldw	r2,-12(fp)
81130c58:	1000051e 	bne	r2,zero,81130c70 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81130c5c:	e0bfff17 	ldw	r2,-4(fp)
81130c60:	00c01804 	movi	r3,96
81130c64:	10c00005 	stb	r3,0(r2)
        return (0);
81130c68:	0005883a 	mov	r2,zero
81130c6c:	00002406 	br	81130d00 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81130c70:	e0bffe17 	ldw	r2,-8(fp)
81130c74:	1000051e 	bne	r2,zero,81130c8c <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81130c78:	e0bfff17 	ldw	r2,-4(fp)
81130c7c:	00c00304 	movi	r3,12
81130c80:	10c00005 	stb	r3,0(r2)
        return (0);
81130c84:	0005883a 	mov	r2,zero
81130c88:	00001d06 	br	81130d00 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81130c8c:	d0a09103 	ldbu	r2,-32188(gp)
81130c90:	10803fcc 	andi	r2,r2,255
81130c94:	10000526 	beq	r2,zero,81130cac <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81130c98:	e0bfff17 	ldw	r2,-4(fp)
81130c9c:	00c00444 	movi	r3,17
81130ca0:	10c00005 	stb	r3,0(r2)
        return (0);
81130ca4:	0005883a 	mov	r2,zero
81130ca8:	00001506 	br	81130d00 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130cac:	0005303a 	rdctl	r2,status
81130cb0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130cb4:	e0fffb17 	ldw	r3,-20(fp)
81130cb8:	00bfff84 	movi	r2,-2
81130cbc:	1884703a 	and	r2,r3,r2
81130cc0:	1001703a 	wrctl	status,r2
  
  return context;
81130cc4:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
81130cc8:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
81130ccc:	e0bffd17 	ldw	r2,-12(fp)
81130cd0:	10800504 	addi	r2,r2,20
81130cd4:	100b883a 	mov	r5,r2
81130cd8:	e13ffe17 	ldw	r4,-8(fp)
81130cdc:	112ea040 	call	8112ea04 <OS_StrCopy>
81130ce0:	e0bffa05 	stb	r2,-24(fp)
81130ce4:	e0bff917 	ldw	r2,-28(fp)
81130ce8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130cec:	e0bffc17 	ldw	r2,-16(fp)
81130cf0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81130cf4:	e0bfff17 	ldw	r2,-4(fp)
81130cf8:	10000005 	stb	zero,0(r2)
    return (len);
81130cfc:	e0bffa03 	ldbu	r2,-24(fp)
}
81130d00:	e037883a 	mov	sp,fp
81130d04:	dfc00117 	ldw	ra,4(sp)
81130d08:	df000017 	ldw	fp,0(sp)
81130d0c:	dec00204 	addi	sp,sp,8
81130d10:	f800283a 	ret

81130d14 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81130d14:	defff604 	addi	sp,sp,-40
81130d18:	de00012e 	bgeu	sp,et,81130d20 <OSMemNameSet+0xc>
81130d1c:	003b68fa 	trap	3
81130d20:	dfc00915 	stw	ra,36(sp)
81130d24:	df000815 	stw	fp,32(sp)
81130d28:	df000804 	addi	fp,sp,32
81130d2c:	e13ffd15 	stw	r4,-12(fp)
81130d30:	e17ffe15 	stw	r5,-8(fp)
81130d34:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130d38:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81130d3c:	e0bfff17 	ldw	r2,-4(fp)
81130d40:	10003526 	beq	r2,zero,81130e18 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81130d44:	e0bffd17 	ldw	r2,-12(fp)
81130d48:	1000041e 	bne	r2,zero,81130d5c <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81130d4c:	e0bfff17 	ldw	r2,-4(fp)
81130d50:	00c01804 	movi	r3,96
81130d54:	10c00005 	stb	r3,0(r2)
        return;
81130d58:	00003006 	br	81130e1c <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81130d5c:	e0bffe17 	ldw	r2,-8(fp)
81130d60:	1000041e 	bne	r2,zero,81130d74 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81130d64:	e0bfff17 	ldw	r2,-4(fp)
81130d68:	00c00304 	movi	r3,12
81130d6c:	10c00005 	stb	r3,0(r2)
        return;
81130d70:	00002a06 	br	81130e1c <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81130d74:	d0a09103 	ldbu	r2,-32188(gp)
81130d78:	10803fcc 	andi	r2,r2,255
81130d7c:	10000426 	beq	r2,zero,81130d90 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81130d80:	e0bfff17 	ldw	r2,-4(fp)
81130d84:	00c00484 	movi	r3,18
81130d88:	10c00005 	stb	r3,0(r2)
        return;
81130d8c:	00002306 	br	81130e1c <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130d90:	0005303a 	rdctl	r2,status
81130d94:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130d98:	e0fffc17 	ldw	r3,-16(fp)
81130d9c:	00bfff84 	movi	r2,-2
81130da0:	1884703a 	and	r2,r3,r2
81130da4:	1001703a 	wrctl	status,r2
  
  return context;
81130da8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81130dac:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81130db0:	e13ffe17 	ldw	r4,-8(fp)
81130db4:	112ea800 	call	8112ea80 <OS_StrLen>
81130db8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
81130dbc:	e0bffa03 	ldbu	r2,-24(fp)
81130dc0:	10800830 	cmpltui	r2,r2,32
81130dc4:	1000081e 	bne	r2,zero,81130de8 <OSMemNameSet+0xd4>
81130dc8:	e0bff817 	ldw	r2,-32(fp)
81130dcc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130dd0:	e0bff917 	ldw	r2,-28(fp)
81130dd4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
81130dd8:	e0bfff17 	ldw	r2,-4(fp)
81130ddc:	00c018c4 	movi	r3,99
81130de0:	10c00005 	stb	r3,0(r2)
        return;
81130de4:	00000d06 	br	81130e1c <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
81130de8:	e0bffd17 	ldw	r2,-12(fp)
81130dec:	10800504 	addi	r2,r2,20
81130df0:	e17ffe17 	ldw	r5,-8(fp)
81130df4:	1009883a 	mov	r4,r2
81130df8:	112ea040 	call	8112ea04 <OS_StrCopy>
81130dfc:	e0bff817 	ldw	r2,-32(fp)
81130e00:	e0bffb15 	stw	r2,-20(fp)
81130e04:	e0bffb17 	ldw	r2,-20(fp)
81130e08:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81130e0c:	e0bfff17 	ldw	r2,-4(fp)
81130e10:	10000005 	stb	zero,0(r2)
81130e14:	00000106 	br	81130e1c <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81130e18:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81130e1c:	e037883a 	mov	sp,fp
81130e20:	dfc00117 	ldw	ra,4(sp)
81130e24:	df000017 	ldw	fp,0(sp)
81130e28:	dec00204 	addi	sp,sp,8
81130e2c:	f800283a 	ret

81130e30 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
81130e30:	defff904 	addi	sp,sp,-28
81130e34:	de00012e 	bgeu	sp,et,81130e3c <OSMemPut+0xc>
81130e38:	003b68fa 	trap	3
81130e3c:	df000615 	stw	fp,24(sp)
81130e40:	df000604 	addi	fp,sp,24
81130e44:	e13ffe15 	stw	r4,-8(fp)
81130e48:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130e4c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
81130e50:	e0bffe17 	ldw	r2,-8(fp)
81130e54:	1000021e 	bne	r2,zero,81130e60 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81130e58:	00801804 	movi	r2,96
81130e5c:	00002806 	br	81130f00 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
81130e60:	e0bfff17 	ldw	r2,-4(fp)
81130e64:	1000021e 	bne	r2,zero,81130e70 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
81130e68:	008017c4 	movi	r2,95
81130e6c:	00002406 	br	81130f00 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130e70:	0005303a 	rdctl	r2,status
81130e74:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130e78:	e0fffd17 	ldw	r3,-12(fp)
81130e7c:	00bfff84 	movi	r2,-2
81130e80:	1884703a 	and	r2,r3,r2
81130e84:	1001703a 	wrctl	status,r2
  
  return context;
81130e88:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81130e8c:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
81130e90:	e0bffe17 	ldw	r2,-8(fp)
81130e94:	10c00417 	ldw	r3,16(r2)
81130e98:	e0bffe17 	ldw	r2,-8(fp)
81130e9c:	10800317 	ldw	r2,12(r2)
81130ea0:	18800636 	bltu	r3,r2,81130ebc <OSMemPut+0x8c>
81130ea4:	e0bffa17 	ldw	r2,-24(fp)
81130ea8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130eac:	e0bffb17 	ldw	r2,-20(fp)
81130eb0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
81130eb4:	00801784 	movi	r2,94
81130eb8:	00001106 	br	81130f00 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
81130ebc:	e0bffe17 	ldw	r2,-8(fp)
81130ec0:	10c00117 	ldw	r3,4(r2)
81130ec4:	e0bfff17 	ldw	r2,-4(fp)
81130ec8:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
81130ecc:	e0bffe17 	ldw	r2,-8(fp)
81130ed0:	e0ffff17 	ldw	r3,-4(fp)
81130ed4:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
81130ed8:	e0bffe17 	ldw	r2,-8(fp)
81130edc:	10800417 	ldw	r2,16(r2)
81130ee0:	10c00044 	addi	r3,r2,1
81130ee4:	e0bffe17 	ldw	r2,-8(fp)
81130ee8:	10c00415 	stw	r3,16(r2)
81130eec:	e0bffa17 	ldw	r2,-24(fp)
81130ef0:	e0bffc15 	stw	r2,-16(fp)
81130ef4:	e0bffc17 	ldw	r2,-16(fp)
81130ef8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
81130efc:	0005883a 	mov	r2,zero
}
81130f00:	e037883a 	mov	sp,fp
81130f04:	df000017 	ldw	fp,0(sp)
81130f08:	dec00104 	addi	sp,sp,4
81130f0c:	f800283a 	ret

81130f10 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
81130f10:	defffa04 	addi	sp,sp,-24
81130f14:	de00012e 	bgeu	sp,et,81130f1c <OSMemQuery+0xc>
81130f18:	003b68fa 	trap	3
81130f1c:	df000515 	stw	fp,20(sp)
81130f20:	df000504 	addi	fp,sp,20
81130f24:	e13ffe15 	stw	r4,-8(fp)
81130f28:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130f2c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
81130f30:	e0bffe17 	ldw	r2,-8(fp)
81130f34:	1000021e 	bne	r2,zero,81130f40 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81130f38:	00801804 	movi	r2,96
81130f3c:	00002c06 	br	81130ff0 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
81130f40:	e0bfff17 	ldw	r2,-4(fp)
81130f44:	1000021e 	bne	r2,zero,81130f50 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
81130f48:	00801844 	movi	r2,97
81130f4c:	00002806 	br	81130ff0 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130f50:	0005303a 	rdctl	r2,status
81130f54:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130f58:	e0fffc17 	ldw	r3,-16(fp)
81130f5c:	00bfff84 	movi	r2,-2
81130f60:	1884703a 	and	r2,r3,r2
81130f64:	1001703a 	wrctl	status,r2
  
  return context;
81130f68:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81130f6c:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
81130f70:	e0bffe17 	ldw	r2,-8(fp)
81130f74:	10c00017 	ldw	r3,0(r2)
81130f78:	e0bfff17 	ldw	r2,-4(fp)
81130f7c:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
81130f80:	e0bffe17 	ldw	r2,-8(fp)
81130f84:	10c00117 	ldw	r3,4(r2)
81130f88:	e0bfff17 	ldw	r2,-4(fp)
81130f8c:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
81130f90:	e0bffe17 	ldw	r2,-8(fp)
81130f94:	10c00217 	ldw	r3,8(r2)
81130f98:	e0bfff17 	ldw	r2,-4(fp)
81130f9c:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
81130fa0:	e0bffe17 	ldw	r2,-8(fp)
81130fa4:	10c00317 	ldw	r3,12(r2)
81130fa8:	e0bfff17 	ldw	r2,-4(fp)
81130fac:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
81130fb0:	e0bffe17 	ldw	r2,-8(fp)
81130fb4:	10c00417 	ldw	r3,16(r2)
81130fb8:	e0bfff17 	ldw	r2,-4(fp)
81130fbc:	10c00415 	stw	r3,16(r2)
81130fc0:	e0bffb17 	ldw	r2,-20(fp)
81130fc4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130fc8:	e0bffd17 	ldw	r2,-12(fp)
81130fcc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
81130fd0:	e0bfff17 	ldw	r2,-4(fp)
81130fd4:	10c00317 	ldw	r3,12(r2)
81130fd8:	e0bfff17 	ldw	r2,-4(fp)
81130fdc:	10800417 	ldw	r2,16(r2)
81130fe0:	1887c83a 	sub	r3,r3,r2
81130fe4:	e0bfff17 	ldw	r2,-4(fp)
81130fe8:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
81130fec:	0005883a 	mov	r2,zero
}
81130ff0:	e037883a 	mov	sp,fp
81130ff4:	df000017 	ldw	fp,0(sp)
81130ff8:	dec00104 	addi	sp,sp,4
81130ffc:	f800283a 	ret

81131000 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
81131000:	defffc04 	addi	sp,sp,-16
81131004:	de00012e 	bgeu	sp,et,8113100c <OS_MemInit+0xc>
81131008:	003b68fa 	trap	3
8113100c:	dfc00315 	stw	ra,12(sp)
81131010:	df000215 	stw	fp,8(sp)
81131014:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
81131018:	01430c04 	movi	r5,3120
8113101c:	012045b4 	movhi	r4,33046
81131020:	212b7004 	addi	r4,r4,-21056
81131024:	112e7e40 	call	8112e7e4 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
81131028:	00a045b4 	movhi	r2,33046
8113102c:	10ab7004 	addi	r2,r2,-21056
81131030:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81131034:	e03fff0d 	sth	zero,-4(fp)
81131038:	00001306 	br	81131088 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8113103c:	e0bfff0b 	ldhu	r2,-4(fp)
81131040:	10800044 	addi	r2,r2,1
81131044:	10c00d24 	muli	r3,r2,52
81131048:	00a045b4 	movhi	r2,33046
8113104c:	10ab7004 	addi	r2,r2,-21056
81131050:	1887883a 	add	r3,r3,r2
81131054:	e0bffe17 	ldw	r2,-8(fp)
81131058:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8113105c:	e0bffe17 	ldw	r2,-8(fp)
81131060:	00c00fc4 	movi	r3,63
81131064:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
81131068:	e0bffe17 	ldw	r2,-8(fp)
8113106c:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
81131070:	e0bffe17 	ldw	r2,-8(fp)
81131074:	10800d04 	addi	r2,r2,52
81131078:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113107c:	e0bfff0b 	ldhu	r2,-4(fp)
81131080:	10800044 	addi	r2,r2,1
81131084:	e0bfff0d 	sth	r2,-4(fp)
81131088:	e0bfff0b 	ldhu	r2,-4(fp)
8113108c:	10800ef0 	cmpltui	r2,r2,59
81131090:	103fea1e 	bne	r2,zero,8113103c <__reset+0xfb11103c>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
81131094:	e0bffe17 	ldw	r2,-8(fp)
81131098:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113109c:	e0bffe17 	ldw	r2,-8(fp)
811310a0:	00c00fc4 	movi	r3,63
811310a4:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
811310a8:	e0bffe17 	ldw	r2,-8(fp)
811310ac:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
811310b0:	00a045b4 	movhi	r2,33046
811310b4:	10ab7004 	addi	r2,r2,-21056
811310b8:	d0a08b15 	stw	r2,-32212(gp)
#endif
}
811310bc:	0001883a 	nop
811310c0:	e037883a 	mov	sp,fp
811310c4:	dfc00117 	ldw	ra,4(sp)
811310c8:	df000017 	ldw	fp,0(sp)
811310cc:	dec00204 	addi	sp,sp,8
811310d0:	f800283a 	ret

811310d4 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
811310d4:	defff704 	addi	sp,sp,-36
811310d8:	de00012e 	bgeu	sp,et,811310e0 <OSMutexAccept+0xc>
811310dc:	003b68fa 	trap	3
811310e0:	df000815 	stw	fp,32(sp)
811310e4:	df000804 	addi	fp,sp,32
811310e8:	e13ffe15 	stw	r4,-8(fp)
811310ec:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811310f0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
811310f4:	e0bfff17 	ldw	r2,-4(fp)
811310f8:	1000021e 	bne	r2,zero,81131104 <OSMutexAccept+0x30>
        return (OS_FALSE);
811310fc:	0005883a 	mov	r2,zero
81131100:	00005b06 	br	81131270 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81131104:	e0bffe17 	ldw	r2,-8(fp)
81131108:	1000051e 	bne	r2,zero,81131120 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113110c:	e0bfff17 	ldw	r2,-4(fp)
81131110:	00c00104 	movi	r3,4
81131114:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81131118:	0005883a 	mov	r2,zero
8113111c:	00005406 	br	81131270 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
81131120:	e0bffe17 	ldw	r2,-8(fp)
81131124:	10800003 	ldbu	r2,0(r2)
81131128:	10803fcc 	andi	r2,r2,255
8113112c:	10800120 	cmpeqi	r2,r2,4
81131130:	1000051e 	bne	r2,zero,81131148 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81131134:	e0bfff17 	ldw	r2,-4(fp)
81131138:	00c00044 	movi	r3,1
8113113c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81131140:	0005883a 	mov	r2,zero
81131144:	00004a06 	br	81131270 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
81131148:	d0a09103 	ldbu	r2,-32188(gp)
8113114c:	10803fcc 	andi	r2,r2,255
81131150:	10000526 	beq	r2,zero,81131168 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
81131154:	e0bfff17 	ldw	r2,-4(fp)
81131158:	00c00084 	movi	r3,2
8113115c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81131160:	0005883a 	mov	r2,zero
81131164:	00004206 	br	81131270 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131168:	0005303a 	rdctl	r2,status
8113116c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131170:	e0fffd17 	ldw	r3,-12(fp)
81131174:	00bfff84 	movi	r2,-2
81131178:	1884703a 	and	r2,r3,r2
8113117c:	1001703a 	wrctl	status,r2
  
  return context;
81131180:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
81131184:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
81131188:	e0bffe17 	ldw	r2,-8(fp)
8113118c:	1080020b 	ldhu	r2,8(r2)
81131190:	10bfffcc 	andi	r2,r2,65535
81131194:	1004d23a 	srli	r2,r2,8
81131198:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113119c:	e0bffe17 	ldw	r2,-8(fp)
811311a0:	1080020b 	ldhu	r2,8(r2)
811311a4:	10bfffcc 	andi	r2,r2,65535
811311a8:	10803fcc 	andi	r2,r2,255
811311ac:	10803fd8 	cmpnei	r2,r2,255
811311b0:	1000281e 	bne	r2,zero,81131254 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
811311b4:	e0bffe17 	ldw	r2,-8(fp)
811311b8:	10c0020b 	ldhu	r3,8(r2)
811311bc:	00bfc004 	movi	r2,-256
811311c0:	1884703a 	and	r2,r3,r2
811311c4:	1007883a 	mov	r3,r2
811311c8:	e0bffe17 	ldw	r2,-8(fp)
811311cc:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
811311d0:	e0bffe17 	ldw	r2,-8(fp)
811311d4:	10c0020b 	ldhu	r3,8(r2)
811311d8:	d0a09217 	ldw	r2,-32184(gp)
811311dc:	10800c83 	ldbu	r2,50(r2)
811311e0:	10803fcc 	andi	r2,r2,255
811311e4:	1884b03a 	or	r2,r3,r2
811311e8:	1007883a 	mov	r3,r2
811311ec:	e0bffe17 	ldw	r2,-8(fp)
811311f0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
811311f4:	d0e09217 	ldw	r3,-32184(gp)
811311f8:	e0bffe17 	ldw	r2,-8(fp)
811311fc:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
81131200:	d0a09217 	ldw	r2,-32184(gp)
81131204:	10800c83 	ldbu	r2,50(r2)
81131208:	10803fcc 	andi	r2,r2,255
8113120c:	e0fffa03 	ldbu	r3,-24(fp)
81131210:	18800836 	bltu	r3,r2,81131234 <OSMutexAccept+0x160>
81131214:	e0bff817 	ldw	r2,-32(fp)
81131218:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113121c:	e0bff917 	ldw	r2,-28(fp)
81131220:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
81131224:	e0bfff17 	ldw	r2,-4(fp)
81131228:	00c01e04 	movi	r3,120
8113122c:	10c00005 	stb	r3,0(r2)
81131230:	00000606 	br	8113124c <OSMutexAccept+0x178>
81131234:	e0bff817 	ldw	r2,-32(fp)
81131238:	e0bffb15 	stw	r2,-20(fp)
8113123c:	e0bffb17 	ldw	r2,-20(fp)
81131240:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
81131244:	e0bfff17 	ldw	r2,-4(fp)
81131248:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8113124c:	00800044 	movi	r2,1
81131250:	00000706 	br	81131270 <OSMutexAccept+0x19c>
81131254:	e0bff817 	ldw	r2,-32(fp)
81131258:	e0bffc15 	stw	r2,-16(fp)
8113125c:	e0bffc17 	ldw	r2,-16(fp)
81131260:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81131264:	e0bfff17 	ldw	r2,-4(fp)
81131268:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8113126c:	0005883a 	mov	r2,zero
}
81131270:	e037883a 	mov	sp,fp
81131274:	df000017 	ldw	fp,0(sp)
81131278:	dec00104 	addi	sp,sp,4
8113127c:	f800283a 	ret

81131280 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
81131280:	defff604 	addi	sp,sp,-40
81131284:	de00012e 	bgeu	sp,et,8113128c <OSMutexCreate+0xc>
81131288:	003b68fa 	trap	3
8113128c:	dfc00915 	stw	ra,36(sp)
81131290:	df000815 	stw	fp,32(sp)
81131294:	df000804 	addi	fp,sp,32
81131298:	2005883a 	mov	r2,r4
8113129c:	e17fff15 	stw	r5,-4(fp)
811312a0:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811312a4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811312a8:	e0bfff17 	ldw	r2,-4(fp)
811312ac:	1000021e 	bne	r2,zero,811312b8 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
811312b0:	0005883a 	mov	r2,zero
811312b4:	00006106 	br	8113143c <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
811312b8:	e0bffe03 	ldbu	r2,-8(fp)
811312bc:	10800a30 	cmpltui	r2,r2,40
811312c0:	1000051e 	bne	r2,zero,811312d8 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
811312c4:	e0bfff17 	ldw	r2,-4(fp)
811312c8:	00c00a84 	movi	r3,42
811312cc:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
811312d0:	0005883a 	mov	r2,zero
811312d4:	00005906 	br	8113143c <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811312d8:	d0a09103 	ldbu	r2,-32188(gp)
811312dc:	10803fcc 	andi	r2,r2,255
811312e0:	10000526 	beq	r2,zero,811312f8 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
811312e4:	e0bfff17 	ldw	r2,-4(fp)
811312e8:	00c00404 	movi	r3,16
811312ec:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
811312f0:	0005883a 	mov	r2,zero
811312f4:	00005106 	br	8113143c <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811312f8:	0005303a 	rdctl	r2,status
811312fc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131300:	e0fffd17 	ldw	r3,-12(fp)
81131304:	00bfff84 	movi	r2,-2
81131308:	1884703a 	and	r2,r3,r2
8113130c:	1001703a 	wrctl	status,r2
  
  return context;
81131310:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81131314:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
81131318:	e0fffe03 	ldbu	r3,-8(fp)
8113131c:	00a045b4 	movhi	r2,33046
81131320:	10bfb204 	addi	r2,r2,-312
81131324:	18c7883a 	add	r3,r3,r3
81131328:	18c7883a 	add	r3,r3,r3
8113132c:	10c5883a 	add	r2,r2,r3
81131330:	10800017 	ldw	r2,0(r2)
81131334:	10000926 	beq	r2,zero,8113135c <OSMutexCreate+0xdc>
81131338:	e0bff817 	ldw	r2,-32(fp)
8113133c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131340:	e0bff917 	ldw	r2,-28(fp)
81131344:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
81131348:	e0bfff17 	ldw	r2,-4(fp)
8113134c:	00c00a04 	movi	r3,40
81131350:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81131354:	0005883a 	mov	r2,zero
81131358:	00003806 	br	8113143c <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8113135c:	e0fffe03 	ldbu	r3,-8(fp)
81131360:	00a045b4 	movhi	r2,33046
81131364:	10bfb204 	addi	r2,r2,-312
81131368:	18c7883a 	add	r3,r3,r3
8113136c:	18c7883a 	add	r3,r3,r3
81131370:	10c5883a 	add	r2,r2,r3
81131374:	00c00044 	movi	r3,1
81131378:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113137c:	d0a09017 	ldw	r2,-32192(gp)
81131380:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
81131384:	e0bffb17 	ldw	r2,-20(fp)
81131388:	1000101e 	bne	r2,zero,811313cc <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113138c:	e0fffe03 	ldbu	r3,-8(fp)
81131390:	00a045b4 	movhi	r2,33046
81131394:	10bfb204 	addi	r2,r2,-312
81131398:	18c7883a 	add	r3,r3,r3
8113139c:	18c7883a 	add	r3,r3,r3
811313a0:	10c5883a 	add	r2,r2,r3
811313a4:	10000015 	stw	zero,0(r2)
811313a8:	e0bff817 	ldw	r2,-32(fp)
811313ac:	e0bffa15 	stw	r2,-24(fp)
811313b0:	e0bffa17 	ldw	r2,-24(fp)
811313b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
811313b8:	e0bfff17 	ldw	r2,-4(fp)
811313bc:	00c00104 	movi	r3,4
811313c0:	10c00005 	stb	r3,0(r2)
        return (pevent);
811313c4:	e0bffb17 	ldw	r2,-20(fp)
811313c8:	00001c06 	br	8113143c <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
811313cc:	d0a09017 	ldw	r2,-32192(gp)
811313d0:	10800117 	ldw	r2,4(r2)
811313d4:	d0a09015 	stw	r2,-32192(gp)
811313d8:	e0bff817 	ldw	r2,-32(fp)
811313dc:	e0bffc15 	stw	r2,-16(fp)
811313e0:	e0bffc17 	ldw	r2,-16(fp)
811313e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
811313e8:	e0bffb17 	ldw	r2,-20(fp)
811313ec:	00c00104 	movi	r3,4
811313f0:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
811313f4:	e0bffe03 	ldbu	r2,-8(fp)
811313f8:	1004923a 	slli	r2,r2,8
811313fc:	10803fd4 	ori	r2,r2,255
81131400:	1007883a 	mov	r3,r2
81131404:	e0bffb17 	ldw	r2,-20(fp)
81131408:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113140c:	e0bffb17 	ldw	r2,-20(fp)
81131410:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
81131414:	e0bffb17 	ldw	r2,-20(fp)
81131418:	00c00fc4 	movi	r3,63
8113141c:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
81131420:	e0bffb17 	ldw	r2,-20(fp)
81131424:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
81131428:	e13ffb17 	ldw	r4,-20(fp)
8113142c:	112e3cc0 	call	8112e3cc <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
81131430:	e0bfff17 	ldw	r2,-4(fp)
81131434:	10000005 	stb	zero,0(r2)
    return (pevent);
81131438:	e0bffb17 	ldw	r2,-20(fp)
}
8113143c:	e037883a 	mov	sp,fp
81131440:	dfc00117 	ldw	ra,4(sp)
81131444:	df000017 	ldw	fp,0(sp)
81131448:	dec00204 	addi	sp,sp,8
8113144c:	f800283a 	ret

81131450 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81131450:	defff004 	addi	sp,sp,-64
81131454:	de00012e 	bgeu	sp,et,8113145c <OSMutexDel+0xc>
81131458:	003b68fa 	trap	3
8113145c:	dfc00f15 	stw	ra,60(sp)
81131460:	df000e15 	stw	fp,56(sp)
81131464:	df000e04 	addi	fp,sp,56
81131468:	e13ffd15 	stw	r4,-12(fp)
8113146c:	2805883a 	mov	r2,r5
81131470:	e1bfff15 	stw	r6,-4(fp)
81131474:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81131478:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113147c:	e0bfff17 	ldw	r2,-4(fp)
81131480:	1000021e 	bne	r2,zero,8113148c <OSMutexDel+0x3c>
        return (pevent);
81131484:	e0bffd17 	ldw	r2,-12(fp)
81131488:	0000ad06 	br	81131740 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113148c:	e0bffd17 	ldw	r2,-12(fp)
81131490:	1000051e 	bne	r2,zero,811314a8 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81131494:	e0bfff17 	ldw	r2,-4(fp)
81131498:	00c00104 	movi	r3,4
8113149c:	10c00005 	stb	r3,0(r2)
        return (pevent);
811314a0:	e0bffd17 	ldw	r2,-12(fp)
811314a4:	0000a606 	br	81131740 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
811314a8:	e0bffd17 	ldw	r2,-12(fp)
811314ac:	10800003 	ldbu	r2,0(r2)
811314b0:	10803fcc 	andi	r2,r2,255
811314b4:	10800120 	cmpeqi	r2,r2,4
811314b8:	1000051e 	bne	r2,zero,811314d0 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811314bc:	e0bfff17 	ldw	r2,-4(fp)
811314c0:	00c00044 	movi	r3,1
811314c4:	10c00005 	stb	r3,0(r2)
        return (pevent);
811314c8:	e0bffd17 	ldw	r2,-12(fp)
811314cc:	00009c06 	br	81131740 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811314d0:	d0a09103 	ldbu	r2,-32188(gp)
811314d4:	10803fcc 	andi	r2,r2,255
811314d8:	10000526 	beq	r2,zero,811314f0 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
811314dc:	e0bfff17 	ldw	r2,-4(fp)
811314e0:	00c003c4 	movi	r3,15
811314e4:	10c00005 	stb	r3,0(r2)
        return (pevent);
811314e8:	e0bffd17 	ldw	r2,-12(fp)
811314ec:	00009406 	br	81131740 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811314f0:	0005303a 	rdctl	r2,status
811314f4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811314f8:	e0fffc17 	ldw	r3,-16(fp)
811314fc:	00bfff84 	movi	r2,-2
81131500:	1884703a 	and	r2,r3,r2
81131504:	1001703a 	wrctl	status,r2
  
  return context;
81131508:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113150c:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
81131510:	e0bffd17 	ldw	r2,-12(fp)
81131514:	10800283 	ldbu	r2,10(r2)
81131518:	10803fcc 	andi	r2,r2,255
8113151c:	10000326 	beq	r2,zero,8113152c <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81131520:	00800044 	movi	r2,1
81131524:	e0bff205 	stb	r2,-56(fp)
81131528:	00000106 	br	81131530 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113152c:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
81131530:	e0bffe03 	ldbu	r2,-8(fp)
81131534:	10000326 	beq	r2,zero,81131544 <OSMutexDel+0xf4>
81131538:	10800060 	cmpeqi	r2,r2,1
8113153c:	10002f1e 	bne	r2,zero,811315fc <OSMutexDel+0x1ac>
81131540:	00007406 	br	81131714 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
81131544:	e0bff203 	ldbu	r2,-56(fp)
81131548:	1000221e 	bne	r2,zero,811315d4 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113154c:	e0bffd17 	ldw	r2,-12(fp)
81131550:	00c00fc4 	movi	r3,63
81131554:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81131558:	e0bffd17 	ldw	r2,-12(fp)
8113155c:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81131560:	e0bffd17 	ldw	r2,-12(fp)
81131564:	1080020b 	ldhu	r2,8(r2)
81131568:	10bfffcc 	andi	r2,r2,65535
8113156c:	1004d23a 	srli	r2,r2,8
81131570:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
81131574:	e0fff603 	ldbu	r3,-40(fp)
81131578:	00a045b4 	movhi	r2,33046
8113157c:	10bfb204 	addi	r2,r2,-312
81131580:	18c7883a 	add	r3,r3,r3
81131584:	18c7883a 	add	r3,r3,r3
81131588:	10c5883a 	add	r2,r2,r3
8113158c:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
81131590:	e0bffd17 	ldw	r2,-12(fp)
81131594:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
81131598:	d0e09017 	ldw	r3,-32192(gp)
8113159c:	e0bffd17 	ldw	r2,-12(fp)
811315a0:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
811315a4:	e0bffd17 	ldw	r2,-12(fp)
811315a8:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
811315ac:	e0bffd17 	ldw	r2,-12(fp)
811315b0:	d0a09015 	stw	r2,-32192(gp)
811315b4:	e0bff417 	ldw	r2,-48(fp)
811315b8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811315bc:	e0bff517 	ldw	r2,-44(fp)
811315c0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
811315c4:	e0bfff17 	ldw	r2,-4(fp)
811315c8:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
811315cc:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
811315d0:	00005a06 	br	8113173c <OSMutexDel+0x2ec>
811315d4:	e0bff417 	ldw	r2,-48(fp)
811315d8:	e0bff715 	stw	r2,-36(fp)
811315dc:	e0bff717 	ldw	r2,-36(fp)
811315e0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
811315e4:	e0bfff17 	ldw	r2,-4(fp)
811315e8:	00c01244 	movi	r3,73
811315ec:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
811315f0:	e0bffd17 	ldw	r2,-12(fp)
811315f4:	e0bff315 	stw	r2,-52(fp)
             }
             break;
811315f8:	00005006 	br	8113173c <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
811315fc:	e0bffd17 	ldw	r2,-12(fp)
81131600:	1080020b 	ldhu	r2,8(r2)
81131604:	10bfffcc 	andi	r2,r2,65535
81131608:	1004d23a 	srli	r2,r2,8
8113160c:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
81131610:	e0bffd17 	ldw	r2,-12(fp)
81131614:	1080020b 	ldhu	r2,8(r2)
81131618:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8113161c:	e0bffd17 	ldw	r2,-12(fp)
81131620:	10800117 	ldw	r2,4(r2)
81131624:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
81131628:	e0bffa17 	ldw	r2,-24(fp)
8113162c:	10000f26 	beq	r2,zero,8113166c <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
81131630:	e0bffa17 	ldw	r2,-24(fp)
81131634:	10800c83 	ldbu	r2,50(r2)
81131638:	10c03fcc 	andi	r3,r2,255
8113163c:	e0bff603 	ldbu	r2,-40(fp)
81131640:	18800a1e 	bne	r3,r2,8113166c <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
81131644:	e0bff903 	ldbu	r2,-28(fp)
81131648:	100b883a 	mov	r5,r2
8113164c:	e13ffa17 	ldw	r4,-24(fp)
81131650:	113208c0 	call	8113208c <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81131654:	00000506 	br	8113166c <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81131658:	000f883a 	mov	r7,zero
8113165c:	01800404 	movi	r6,16
81131660:	000b883a 	mov	r5,zero
81131664:	e13ffd17 	ldw	r4,-12(fp)
81131668:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113166c:	e0bffd17 	ldw	r2,-12(fp)
81131670:	10800283 	ldbu	r2,10(r2)
81131674:	10803fcc 	andi	r2,r2,255
81131678:	103ff71e 	bne	r2,zero,81131658 <__reset+0xfb111658>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113167c:	e0bffd17 	ldw	r2,-12(fp)
81131680:	00c00fc4 	movi	r3,63
81131684:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81131688:	e0bffd17 	ldw	r2,-12(fp)
8113168c:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81131690:	e0bffd17 	ldw	r2,-12(fp)
81131694:	1080020b 	ldhu	r2,8(r2)
81131698:	10bfffcc 	andi	r2,r2,65535
8113169c:	1004d23a 	srli	r2,r2,8
811316a0:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
811316a4:	e0fff603 	ldbu	r3,-40(fp)
811316a8:	00a045b4 	movhi	r2,33046
811316ac:	10bfb204 	addi	r2,r2,-312
811316b0:	18c7883a 	add	r3,r3,r3
811316b4:	18c7883a 	add	r3,r3,r3
811316b8:	10c5883a 	add	r2,r2,r3
811316bc:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
811316c0:	e0bffd17 	ldw	r2,-12(fp)
811316c4:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
811316c8:	d0e09017 	ldw	r3,-32192(gp)
811316cc:	e0bffd17 	ldw	r2,-12(fp)
811316d0:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
811316d4:	e0bffd17 	ldw	r2,-12(fp)
811316d8:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
811316dc:	e0bffd17 	ldw	r2,-12(fp)
811316e0:	d0a09015 	stw	r2,-32192(gp)
811316e4:	e0bff417 	ldw	r2,-48(fp)
811316e8:	e0bff815 	stw	r2,-32(fp)
811316ec:	e0bff817 	ldw	r2,-32(fp)
811316f0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
811316f4:	e0bff203 	ldbu	r2,-56(fp)
811316f8:	10800058 	cmpnei	r2,r2,1
811316fc:	1000011e 	bne	r2,zero,81131704 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81131700:	112e8b00 	call	8112e8b0 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
81131704:	e0bfff17 	ldw	r2,-4(fp)
81131708:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113170c:	e03ff315 	stw	zero,-52(fp)
             break;
81131710:	00000a06 	br	8113173c <OSMutexDel+0x2ec>
81131714:	e0bff417 	ldw	r2,-48(fp)
81131718:	e0bffb15 	stw	r2,-20(fp)
8113171c:	e0bffb17 	ldw	r2,-20(fp)
81131720:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
81131724:	e0bfff17 	ldw	r2,-4(fp)
81131728:	00c001c4 	movi	r3,7
8113172c:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
81131730:	e0bffd17 	ldw	r2,-12(fp)
81131734:	e0bff315 	stw	r2,-52(fp)
             break;
81131738:	0001883a 	nop
    }
    return (pevent_return);
8113173c:	e0bff317 	ldw	r2,-52(fp)
}
81131740:	e037883a 	mov	sp,fp
81131744:	dfc00117 	ldw	ra,4(sp)
81131748:	df000017 	ldw	fp,0(sp)
8113174c:	dec00204 	addi	sp,sp,8
81131750:	f800283a 	ret

81131754 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81131754:	deffee04 	addi	sp,sp,-72
81131758:	de00012e 	bgeu	sp,et,81131760 <OSMutexPend+0xc>
8113175c:	003b68fa 	trap	3
81131760:	dfc01115 	stw	ra,68(sp)
81131764:	df001015 	stw	fp,64(sp)
81131768:	df001004 	addi	fp,sp,64
8113176c:	e13ffd15 	stw	r4,-12(fp)
81131770:	2805883a 	mov	r2,r5
81131774:	e1bfff15 	stw	r6,-4(fp)
81131778:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113177c:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81131780:	e0bfff17 	ldw	r2,-4(fp)
81131784:	10015626 	beq	r2,zero,81131ce0 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81131788:	e0bffd17 	ldw	r2,-12(fp)
8113178c:	1000041e 	bne	r2,zero,811317a0 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81131790:	e0bfff17 	ldw	r2,-4(fp)
81131794:	00c00104 	movi	r3,4
81131798:	10c00005 	stb	r3,0(r2)
        return;
8113179c:	00015106 	br	81131ce4 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
811317a0:	e0bffd17 	ldw	r2,-12(fp)
811317a4:	10800003 	ldbu	r2,0(r2)
811317a8:	10803fcc 	andi	r2,r2,255
811317ac:	10800120 	cmpeqi	r2,r2,4
811317b0:	1000041e 	bne	r2,zero,811317c4 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
811317b4:	e0bfff17 	ldw	r2,-4(fp)
811317b8:	00c00044 	movi	r3,1
811317bc:	10c00005 	stb	r3,0(r2)
        return;
811317c0:	00014806 	br	81131ce4 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811317c4:	d0a09103 	ldbu	r2,-32188(gp)
811317c8:	10803fcc 	andi	r2,r2,255
811317cc:	10000426 	beq	r2,zero,811317e0 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
811317d0:	e0bfff17 	ldw	r2,-4(fp)
811317d4:	00c00084 	movi	r3,2
811317d8:	10c00005 	stb	r3,0(r2)
        return;
811317dc:	00014106 	br	81131ce4 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
811317e0:	d0a07f03 	ldbu	r2,-32260(gp)
811317e4:	10803fcc 	andi	r2,r2,255
811317e8:	10000426 	beq	r2,zero,811317fc <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
811317ec:	e0bfff17 	ldw	r2,-4(fp)
811317f0:	00c00344 	movi	r3,13
811317f4:	10c00005 	stb	r3,0(r2)
        return;
811317f8:	00013a06 	br	81131ce4 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811317fc:	0005303a 	rdctl	r2,status
81131800:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131804:	e0fffc17 	ldw	r3,-16(fp)
81131808:	00bfff84 	movi	r2,-2
8113180c:	1884703a 	and	r2,r3,r2
81131810:	1001703a 	wrctl	status,r2
  
  return context;
81131814:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81131818:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8113181c:	e0bffd17 	ldw	r2,-12(fp)
81131820:	1080020b 	ldhu	r2,8(r2)
81131824:	10bfffcc 	andi	r2,r2,65535
81131828:	1004d23a 	srli	r2,r2,8
8113182c:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81131830:	e0bffd17 	ldw	r2,-12(fp)
81131834:	1080020b 	ldhu	r2,8(r2)
81131838:	10803fcc 	andi	r2,r2,255
8113183c:	10803fd8 	cmpnei	r2,r2,255
81131840:	1000271e 	bne	r2,zero,811318e0 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
81131844:	e0bffd17 	ldw	r2,-12(fp)
81131848:	10c0020b 	ldhu	r3,8(r2)
8113184c:	00bfc004 	movi	r2,-256
81131850:	1884703a 	and	r2,r3,r2
81131854:	1007883a 	mov	r3,r2
81131858:	e0bffd17 	ldw	r2,-12(fp)
8113185c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
81131860:	e0bffd17 	ldw	r2,-12(fp)
81131864:	10c0020b 	ldhu	r3,8(r2)
81131868:	d0a09217 	ldw	r2,-32184(gp)
8113186c:	10800c83 	ldbu	r2,50(r2)
81131870:	10803fcc 	andi	r2,r2,255
81131874:	1884b03a 	or	r2,r3,r2
81131878:	1007883a 	mov	r3,r2
8113187c:	e0bffd17 	ldw	r2,-12(fp)
81131880:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
81131884:	d0e09217 	ldw	r3,-32184(gp)
81131888:	e0bffd17 	ldw	r2,-12(fp)
8113188c:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
81131890:	d0a09217 	ldw	r2,-32184(gp)
81131894:	10800c83 	ldbu	r2,50(r2)
81131898:	10803fcc 	andi	r2,r2,255
8113189c:	e0fff303 	ldbu	r3,-52(fp)
811318a0:	18800836 	bltu	r3,r2,811318c4 <OSMutexPend+0x170>
811318a4:	e0bff117 	ldw	r2,-60(fp)
811318a8:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811318ac:	e0bff217 	ldw	r2,-56(fp)
811318b0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
811318b4:	e0bfff17 	ldw	r2,-4(fp)
811318b8:	00c01e04 	movi	r3,120
811318bc:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
811318c0:	00010806 	br	81131ce4 <OSMutexPend+0x590>
811318c4:	e0bff117 	ldw	r2,-60(fp)
811318c8:	e0bff415 	stw	r2,-48(fp)
811318cc:	e0bff417 	ldw	r2,-48(fp)
811318d0:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
811318d4:	e0bfff17 	ldw	r2,-4(fp)
811318d8:	10000005 	stb	zero,0(r2)
        }
        return;
811318dc:	00010106 	br	81131ce4 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
811318e0:	e0bffd17 	ldw	r2,-12(fp)
811318e4:	1080020b 	ldhu	r2,8(r2)
811318e8:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
811318ec:	e0bffd17 	ldw	r2,-12(fp)
811318f0:	10800117 	ldw	r2,4(r2)
811318f4:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
811318f8:	e0bff717 	ldw	r2,-36(fp)
811318fc:	10800c83 	ldbu	r2,50(r2)
81131900:	10803fcc 	andi	r2,r2,255
81131904:	e0fff303 	ldbu	r3,-52(fp)
81131908:	1880b92e 	bgeu	r3,r2,81131bf0 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113190c:	d0a09217 	ldw	r2,-32184(gp)
81131910:	10800c83 	ldbu	r2,50(r2)
81131914:	10c03fcc 	andi	r3,r2,255
81131918:	e0bff603 	ldbu	r2,-40(fp)
8113191c:	1880b42e 	bgeu	r3,r2,81131bf0 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
81131920:	e0bff717 	ldw	r2,-36(fp)
81131924:	10800d03 	ldbu	r2,52(r2)
81131928:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8113192c:	e0fff803 	ldbu	r3,-32(fp)
81131930:	d0a08e44 	addi	r2,gp,-32199
81131934:	1885883a 	add	r2,r3,r2
81131938:	10c00003 	ldbu	r3,0(r2)
8113193c:	e0bff717 	ldw	r2,-36(fp)
81131940:	10800d43 	ldbu	r2,53(r2)
81131944:	1884703a 	and	r2,r3,r2
81131948:	10803fcc 	andi	r2,r2,255
8113194c:	10001e26 	beq	r2,zero,811319c8 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
81131950:	e0fff803 	ldbu	r3,-32(fp)
81131954:	e13ff803 	ldbu	r4,-32(fp)
81131958:	d0a08e44 	addi	r2,gp,-32199
8113195c:	2085883a 	add	r2,r4,r2
81131960:	10800003 	ldbu	r2,0(r2)
81131964:	1009883a 	mov	r4,r2
81131968:	e0bff717 	ldw	r2,-36(fp)
8113196c:	10800d43 	ldbu	r2,53(r2)
81131970:	0084303a 	nor	r2,zero,r2
81131974:	2084703a 	and	r2,r4,r2
81131978:	1009883a 	mov	r4,r2
8113197c:	d0a08e44 	addi	r2,gp,-32199
81131980:	1885883a 	add	r2,r3,r2
81131984:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
81131988:	e0fff803 	ldbu	r3,-32(fp)
8113198c:	d0a08e44 	addi	r2,gp,-32199
81131990:	1885883a 	add	r2,r3,r2
81131994:	10800003 	ldbu	r2,0(r2)
81131998:	10803fcc 	andi	r2,r2,255
8113199c:	1000071e 	bne	r2,zero,811319bc <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
811319a0:	e0bff717 	ldw	r2,-36(fp)
811319a4:	10800d83 	ldbu	r2,54(r2)
811319a8:	0084303a 	nor	r2,zero,r2
811319ac:	1007883a 	mov	r3,r2
811319b0:	d0a08e03 	ldbu	r2,-32200(gp)
811319b4:	1884703a 	and	r2,r3,r2
811319b8:	d0a08e05 	stb	r2,-32200(gp)
                }
                rdy = OS_TRUE;
811319bc:	00800044 	movi	r2,1
811319c0:	e0bff005 	stb	r2,-64(fp)
811319c4:	00002a06 	br	81131a70 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
811319c8:	e0bff717 	ldw	r2,-36(fp)
811319cc:	10800717 	ldw	r2,28(r2)
811319d0:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
811319d4:	e0bff917 	ldw	r2,-28(fp)
811319d8:	10002426 	beq	r2,zero,81131a6c <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
811319dc:	e0bff717 	ldw	r2,-36(fp)
811319e0:	10800d03 	ldbu	r2,52(r2)
811319e4:	10803fcc 	andi	r2,r2,255
811319e8:	e0fff717 	ldw	r3,-36(fp)
811319ec:	18c00d03 	ldbu	r3,52(r3)
811319f0:	18c03fcc 	andi	r3,r3,255
811319f4:	e13ff917 	ldw	r4,-28(fp)
811319f8:	20c7883a 	add	r3,r4,r3
811319fc:	18c002c4 	addi	r3,r3,11
81131a00:	18c00003 	ldbu	r3,0(r3)
81131a04:	1809883a 	mov	r4,r3
81131a08:	e0fff717 	ldw	r3,-36(fp)
81131a0c:	18c00d43 	ldbu	r3,53(r3)
81131a10:	00c6303a 	nor	r3,zero,r3
81131a14:	20c6703a 	and	r3,r4,r3
81131a18:	1809883a 	mov	r4,r3
81131a1c:	e0fff917 	ldw	r3,-28(fp)
81131a20:	1887883a 	add	r3,r3,r2
81131a24:	18c002c4 	addi	r3,r3,11
81131a28:	19000005 	stb	r4,0(r3)
81131a2c:	e0fff917 	ldw	r3,-28(fp)
81131a30:	1885883a 	add	r2,r3,r2
81131a34:	108002c4 	addi	r2,r2,11
81131a38:	10800003 	ldbu	r2,0(r2)
81131a3c:	10803fcc 	andi	r2,r2,255
81131a40:	10000a1e 	bne	r2,zero,81131a6c <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
81131a44:	e0bff917 	ldw	r2,-28(fp)
81131a48:	10800283 	ldbu	r2,10(r2)
81131a4c:	1007883a 	mov	r3,r2
81131a50:	e0bff717 	ldw	r2,-36(fp)
81131a54:	10800d83 	ldbu	r2,54(r2)
81131a58:	0084303a 	nor	r2,zero,r2
81131a5c:	1884703a 	and	r2,r3,r2
81131a60:	1007883a 	mov	r3,r2
81131a64:	e0bff917 	ldw	r2,-28(fp)
81131a68:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
81131a6c:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
81131a70:	e0bff717 	ldw	r2,-36(fp)
81131a74:	e0fff303 	ldbu	r3,-52(fp)
81131a78:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
81131a7c:	e0bff717 	ldw	r2,-36(fp)
81131a80:	10800c83 	ldbu	r2,50(r2)
81131a84:	10803fcc 	andi	r2,r2,255
81131a88:	1004d0fa 	srli	r2,r2,3
81131a8c:	1007883a 	mov	r3,r2
81131a90:	e0bff717 	ldw	r2,-36(fp)
81131a94:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
81131a98:	e0bff717 	ldw	r2,-36(fp)
81131a9c:	10800c83 	ldbu	r2,50(r2)
81131aa0:	108001cc 	andi	r2,r2,7
81131aa4:	1007883a 	mov	r3,r2
81131aa8:	e0bff717 	ldw	r2,-36(fp)
81131aac:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
81131ab0:	e0bff717 	ldw	r2,-36(fp)
81131ab4:	10800d03 	ldbu	r2,52(r2)
81131ab8:	10803fcc 	andi	r2,r2,255
81131abc:	00c00044 	movi	r3,1
81131ac0:	1884983a 	sll	r2,r3,r2
81131ac4:	1007883a 	mov	r3,r2
81131ac8:	e0bff717 	ldw	r2,-36(fp)
81131acc:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
81131ad0:	e0bff717 	ldw	r2,-36(fp)
81131ad4:	10800cc3 	ldbu	r2,51(r2)
81131ad8:	10803fcc 	andi	r2,r2,255
81131adc:	00c00044 	movi	r3,1
81131ae0:	1884983a 	sll	r2,r3,r2
81131ae4:	1007883a 	mov	r3,r2
81131ae8:	e0bff717 	ldw	r2,-36(fp)
81131aec:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
81131af0:	e0bff003 	ldbu	r2,-64(fp)
81131af4:	10800058 	cmpnei	r2,r2,1
81131af8:	1000161e 	bne	r2,zero,81131b54 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
81131afc:	e0bff717 	ldw	r2,-36(fp)
81131b00:	10c00d83 	ldbu	r3,54(r2)
81131b04:	d0a08e03 	ldbu	r2,-32200(gp)
81131b08:	1884b03a 	or	r2,r3,r2
81131b0c:	d0a08e05 	stb	r2,-32200(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81131b10:	e0bff717 	ldw	r2,-36(fp)
81131b14:	10800d03 	ldbu	r2,52(r2)
81131b18:	10c03fcc 	andi	r3,r2,255
81131b1c:	e0bff717 	ldw	r2,-36(fp)
81131b20:	10800d03 	ldbu	r2,52(r2)
81131b24:	11003fcc 	andi	r4,r2,255
81131b28:	d0a08e44 	addi	r2,gp,-32199
81131b2c:	2085883a 	add	r2,r4,r2
81131b30:	11000003 	ldbu	r4,0(r2)
81131b34:	e0bff717 	ldw	r2,-36(fp)
81131b38:	10800d43 	ldbu	r2,53(r2)
81131b3c:	2084b03a 	or	r2,r4,r2
81131b40:	1009883a 	mov	r4,r2
81131b44:	d0a08e44 	addi	r2,gp,-32199
81131b48:	1885883a 	add	r2,r3,r2
81131b4c:	11000005 	stb	r4,0(r2)
81131b50:	00001f06 	br	81131bd0 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81131b54:	e0bff717 	ldw	r2,-36(fp)
81131b58:	10800717 	ldw	r2,28(r2)
81131b5c:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
81131b60:	e0bff917 	ldw	r2,-28(fp)
81131b64:	10001a26 	beq	r2,zero,81131bd0 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
81131b68:	e0bff917 	ldw	r2,-28(fp)
81131b6c:	10c00283 	ldbu	r3,10(r2)
81131b70:	e0bff717 	ldw	r2,-36(fp)
81131b74:	10800d83 	ldbu	r2,54(r2)
81131b78:	1884b03a 	or	r2,r3,r2
81131b7c:	1007883a 	mov	r3,r2
81131b80:	e0bff917 	ldw	r2,-28(fp)
81131b84:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81131b88:	e0bff717 	ldw	r2,-36(fp)
81131b8c:	10800d03 	ldbu	r2,52(r2)
81131b90:	10803fcc 	andi	r2,r2,255
81131b94:	e0fff717 	ldw	r3,-36(fp)
81131b98:	18c00d03 	ldbu	r3,52(r3)
81131b9c:	18c03fcc 	andi	r3,r3,255
81131ba0:	e13ff917 	ldw	r4,-28(fp)
81131ba4:	20c7883a 	add	r3,r4,r3
81131ba8:	18c002c4 	addi	r3,r3,11
81131bac:	19000003 	ldbu	r4,0(r3)
81131bb0:	e0fff717 	ldw	r3,-36(fp)
81131bb4:	18c00d43 	ldbu	r3,53(r3)
81131bb8:	20c6b03a 	or	r3,r4,r3
81131bbc:	1809883a 	mov	r4,r3
81131bc0:	e0fff917 	ldw	r3,-28(fp)
81131bc4:	1885883a 	add	r2,r3,r2
81131bc8:	108002c4 	addi	r2,r2,11
81131bcc:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
81131bd0:	e0fff303 	ldbu	r3,-52(fp)
81131bd4:	00a045b4 	movhi	r2,33046
81131bd8:	10bfb204 	addi	r2,r2,-312
81131bdc:	18c7883a 	add	r3,r3,r3
81131be0:	18c7883a 	add	r3,r3,r3
81131be4:	10c5883a 	add	r2,r2,r3
81131be8:	e0fff717 	ldw	r3,-36(fp)
81131bec:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
81131bf0:	d0a09217 	ldw	r2,-32184(gp)
81131bf4:	d0e09217 	ldw	r3,-32184(gp)
81131bf8:	18c00c03 	ldbu	r3,48(r3)
81131bfc:	18c00414 	ori	r3,r3,16
81131c00:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81131c04:	d0a09217 	ldw	r2,-32184(gp)
81131c08:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
81131c0c:	d0a09217 	ldw	r2,-32184(gp)
81131c10:	e0fffe0b 	ldhu	r3,-8(fp)
81131c14:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81131c18:	e13ffd17 	ldw	r4,-12(fp)
81131c1c:	112df940 	call	8112df94 <OS_EventTaskWait>
81131c20:	e0bff117 	ldw	r2,-60(fp)
81131c24:	e0bffb15 	stw	r2,-20(fp)
81131c28:	e0bffb17 	ldw	r2,-20(fp)
81131c2c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
81131c30:	112e8b00 	call	8112e8b0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131c34:	0005303a 	rdctl	r2,status
81131c38:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131c3c:	e0fff517 	ldw	r3,-44(fp)
81131c40:	00bfff84 	movi	r2,-2
81131c44:	1884703a 	and	r2,r3,r2
81131c48:	1001703a 	wrctl	status,r2
  
  return context;
81131c4c:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
81131c50:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81131c54:	d0a09217 	ldw	r2,-32184(gp)
81131c58:	10800c43 	ldbu	r2,49(r2)
81131c5c:	10803fcc 	andi	r2,r2,255
81131c60:	10000326 	beq	r2,zero,81131c70 <OSMutexPend+0x51c>
81131c64:	108000a0 	cmpeqi	r2,r2,2
81131c68:	1000041e 	bne	r2,zero,81131c7c <OSMutexPend+0x528>
81131c6c:	00000706 	br	81131c8c <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81131c70:	e0bfff17 	ldw	r2,-4(fp)
81131c74:	10000005 	stb	zero,0(r2)
             break;
81131c78:	00000c06 	br	81131cac <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
81131c7c:	e0bfff17 	ldw	r2,-4(fp)
81131c80:	00c00384 	movi	r3,14
81131c84:	10c00005 	stb	r3,0(r2)
             break;
81131c88:	00000806 	br	81131cac <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81131c8c:	d0a09217 	ldw	r2,-32184(gp)
81131c90:	e17ffd17 	ldw	r5,-12(fp)
81131c94:	1009883a 	mov	r4,r2
81131c98:	112e2040 	call	8112e204 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
81131c9c:	e0bfff17 	ldw	r2,-4(fp)
81131ca0:	00c00284 	movi	r3,10
81131ca4:	10c00005 	stb	r3,0(r2)
             break;
81131ca8:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81131cac:	d0a09217 	ldw	r2,-32184(gp)
81131cb0:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81131cb4:	d0a09217 	ldw	r2,-32184(gp)
81131cb8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81131cbc:	d0a09217 	ldw	r2,-32184(gp)
81131cc0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81131cc4:	d0a09217 	ldw	r2,-32184(gp)
81131cc8:	10000815 	stw	zero,32(r2)
81131ccc:	e0bff117 	ldw	r2,-60(fp)
81131cd0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131cd4:	e0bffa17 	ldw	r2,-24(fp)
81131cd8:	1001703a 	wrctl	status,r2
81131cdc:	00000106 	br	81131ce4 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
81131ce0:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81131ce4:	e037883a 	mov	sp,fp
81131ce8:	dfc00117 	ldw	ra,4(sp)
81131cec:	df000017 	ldw	fp,0(sp)
81131cf0:	dec00204 	addi	sp,sp,8
81131cf4:	f800283a 	ret

81131cf8 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
81131cf8:	defff604 	addi	sp,sp,-40
81131cfc:	de00012e 	bgeu	sp,et,81131d04 <OSMutexPost+0xc>
81131d00:	003b68fa 	trap	3
81131d04:	dfc00915 	stw	ra,36(sp)
81131d08:	df000815 	stw	fp,32(sp)
81131d0c:	df000804 	addi	fp,sp,32
81131d10:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81131d14:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
81131d18:	d0a09103 	ldbu	r2,-32188(gp)
81131d1c:	10803fcc 	andi	r2,r2,255
81131d20:	10000226 	beq	r2,zero,81131d2c <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
81131d24:	00800144 	movi	r2,5
81131d28:	00007606 	br	81131f04 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81131d2c:	e0bfff17 	ldw	r2,-4(fp)
81131d30:	1000021e 	bne	r2,zero,81131d3c <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
81131d34:	00800104 	movi	r2,4
81131d38:	00007206 	br	81131f04 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
81131d3c:	e0bfff17 	ldw	r2,-4(fp)
81131d40:	10800003 	ldbu	r2,0(r2)
81131d44:	10803fcc 	andi	r2,r2,255
81131d48:	10800120 	cmpeqi	r2,r2,4
81131d4c:	1000021e 	bne	r2,zero,81131d58 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
81131d50:	00800044 	movi	r2,1
81131d54:	00006b06 	br	81131f04 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131d58:	0005303a 	rdctl	r2,status
81131d5c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131d60:	e0fffe17 	ldw	r3,-8(fp)
81131d64:	00bfff84 	movi	r2,-2
81131d68:	1884703a 	and	r2,r3,r2
81131d6c:	1001703a 	wrctl	status,r2
  
  return context;
81131d70:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81131d74:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
81131d78:	e0bfff17 	ldw	r2,-4(fp)
81131d7c:	1080020b 	ldhu	r2,8(r2)
81131d80:	10bfffcc 	andi	r2,r2,65535
81131d84:	1004d23a 	srli	r2,r2,8
81131d88:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
81131d8c:	e0bfff17 	ldw	r2,-4(fp)
81131d90:	1080020b 	ldhu	r2,8(r2)
81131d94:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
81131d98:	e0bfff17 	ldw	r2,-4(fp)
81131d9c:	10c00117 	ldw	r3,4(r2)
81131da0:	d0a09217 	ldw	r2,-32184(gp)
81131da4:	18800626 	beq	r3,r2,81131dc0 <OSMutexPost+0xc8>
81131da8:	e0bff817 	ldw	r2,-32(fp)
81131dac:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131db0:	e0bff917 	ldw	r2,-28(fp)
81131db4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
81131db8:	00801904 	movi	r2,100
81131dbc:	00005106 	br	81131f04 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
81131dc0:	d0a09217 	ldw	r2,-32184(gp)
81131dc4:	10800c83 	ldbu	r2,50(r2)
81131dc8:	10c03fcc 	andi	r3,r2,255
81131dcc:	e0bffa03 	ldbu	r2,-24(fp)
81131dd0:	1880051e 	bne	r3,r2,81131de8 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
81131dd4:	d0a09217 	ldw	r2,-32184(gp)
81131dd8:	e0fffa43 	ldbu	r3,-23(fp)
81131ddc:	180b883a 	mov	r5,r3
81131de0:	1009883a 	mov	r4,r2
81131de4:	113208c0 	call	8113208c <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
81131de8:	e0fffa03 	ldbu	r3,-24(fp)
81131dec:	00a045b4 	movhi	r2,33046
81131df0:	10bfb204 	addi	r2,r2,-312
81131df4:	18c7883a 	add	r3,r3,r3
81131df8:	18c7883a 	add	r3,r3,r3
81131dfc:	10c5883a 	add	r2,r2,r3
81131e00:	00c00044 	movi	r3,1
81131e04:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
81131e08:	e0bfff17 	ldw	r2,-4(fp)
81131e0c:	10800283 	ldbu	r2,10(r2)
81131e10:	10803fcc 	andi	r2,r2,255
81131e14:	10002e26 	beq	r2,zero,81131ed0 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81131e18:	000f883a 	mov	r7,zero
81131e1c:	01800404 	movi	r6,16
81131e20:	000b883a 	mov	r5,zero
81131e24:	e13fff17 	ldw	r4,-4(fp)
81131e28:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
81131e2c:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
81131e30:	e0bfff17 	ldw	r2,-4(fp)
81131e34:	10c0020b 	ldhu	r3,8(r2)
81131e38:	00bfc004 	movi	r2,-256
81131e3c:	1884703a 	and	r2,r3,r2
81131e40:	1007883a 	mov	r3,r2
81131e44:	e0bfff17 	ldw	r2,-4(fp)
81131e48:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
81131e4c:	e0bfff17 	ldw	r2,-4(fp)
81131e50:	10c0020b 	ldhu	r3,8(r2)
81131e54:	e0bffa43 	ldbu	r2,-23(fp)
81131e58:	1884b03a 	or	r2,r3,r2
81131e5c:	1007883a 	mov	r3,r2
81131e60:	e0bfff17 	ldw	r2,-4(fp)
81131e64:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
81131e68:	e0fffa43 	ldbu	r3,-23(fp)
81131e6c:	00a045b4 	movhi	r2,33046
81131e70:	10bfb204 	addi	r2,r2,-312
81131e74:	18c7883a 	add	r3,r3,r3
81131e78:	18c7883a 	add	r3,r3,r3
81131e7c:	10c5883a 	add	r2,r2,r3
81131e80:	10c00017 	ldw	r3,0(r2)
81131e84:	e0bfff17 	ldw	r2,-4(fp)
81131e88:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
81131e8c:	e0bffa43 	ldbu	r2,-23(fp)
81131e90:	e0fffa03 	ldbu	r3,-24(fp)
81131e94:	18800736 	bltu	r3,r2,81131eb4 <OSMutexPost+0x1bc>
81131e98:	e0bff817 	ldw	r2,-32(fp)
81131e9c:	e0bffb15 	stw	r2,-20(fp)
81131ea0:	e0bffb17 	ldw	r2,-20(fp)
81131ea4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
81131ea8:	112e8b00 	call	8112e8b0 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
81131eac:	00801e04 	movi	r2,120
81131eb0:	00001406 	br	81131f04 <OSMutexPost+0x20c>
81131eb4:	e0bff817 	ldw	r2,-32(fp)
81131eb8:	e0bffc15 	stw	r2,-16(fp)
81131ebc:	e0bffc17 	ldw	r2,-16(fp)
81131ec0:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
81131ec4:	112e8b00 	call	8112e8b0 <OS_Sched>
            return (OS_ERR_NONE);
81131ec8:	0005883a 	mov	r2,zero
81131ecc:	00000d06 	br	81131f04 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
81131ed0:	e0bfff17 	ldw	r2,-4(fp)
81131ed4:	1080020b 	ldhu	r2,8(r2)
81131ed8:	10803fd4 	ori	r2,r2,255
81131edc:	1007883a 	mov	r3,r2
81131ee0:	e0bfff17 	ldw	r2,-4(fp)
81131ee4:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
81131ee8:	e0bfff17 	ldw	r2,-4(fp)
81131eec:	10000115 	stw	zero,4(r2)
81131ef0:	e0bff817 	ldw	r2,-32(fp)
81131ef4:	e0bffd15 	stw	r2,-12(fp)
81131ef8:	e0bffd17 	ldw	r2,-12(fp)
81131efc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81131f00:	0005883a 	mov	r2,zero
}
81131f04:	e037883a 	mov	sp,fp
81131f08:	dfc00117 	ldw	ra,4(sp)
81131f0c:	df000017 	ldw	fp,0(sp)
81131f10:	dec00204 	addi	sp,sp,8
81131f14:	f800283a 	ret

81131f18 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
81131f18:	defff704 	addi	sp,sp,-36
81131f1c:	de00012e 	bgeu	sp,et,81131f24 <OSMutexQuery+0xc>
81131f20:	003b68fa 	trap	3
81131f24:	df000815 	stw	fp,32(sp)
81131f28:	df000804 	addi	fp,sp,32
81131f2c:	e13ffe15 	stw	r4,-8(fp)
81131f30:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81131f34:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81131f38:	d0a09103 	ldbu	r2,-32188(gp)
81131f3c:	10803fcc 	andi	r2,r2,255
81131f40:	10000226 	beq	r2,zero,81131f4c <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
81131f44:	00800184 	movi	r2,6
81131f48:	00004c06 	br	8113207c <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81131f4c:	e0bffe17 	ldw	r2,-8(fp)
81131f50:	1000021e 	bne	r2,zero,81131f5c <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
81131f54:	00800104 	movi	r2,4
81131f58:	00004806 	br	8113207c <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
81131f5c:	e0bfff17 	ldw	r2,-4(fp)
81131f60:	1000021e 	bne	r2,zero,81131f6c <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
81131f64:	00800244 	movi	r2,9
81131f68:	00004406 	br	8113207c <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81131f6c:	e0bffe17 	ldw	r2,-8(fp)
81131f70:	10800003 	ldbu	r2,0(r2)
81131f74:	10803fcc 	andi	r2,r2,255
81131f78:	10800120 	cmpeqi	r2,r2,4
81131f7c:	1000021e 	bne	r2,zero,81131f88 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
81131f80:	00800044 	movi	r2,1
81131f84:	00003d06 	br	8113207c <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131f88:	0005303a 	rdctl	r2,status
81131f8c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131f90:	e0fffd17 	ldw	r3,-12(fp)
81131f94:	00bfff84 	movi	r2,-2
81131f98:	1884703a 	and	r2,r3,r2
81131f9c:	1001703a 	wrctl	status,r2
  
  return context;
81131fa0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81131fa4:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
81131fa8:	e0bffe17 	ldw	r2,-8(fp)
81131fac:	1080020b 	ldhu	r2,8(r2)
81131fb0:	10bfffcc 	andi	r2,r2,65535
81131fb4:	1004d23a 	srli	r2,r2,8
81131fb8:	1007883a 	mov	r3,r2
81131fbc:	e0bfff17 	ldw	r2,-4(fp)
81131fc0:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
81131fc4:	e0bffe17 	ldw	r2,-8(fp)
81131fc8:	1080020b 	ldhu	r2,8(r2)
81131fcc:	1007883a 	mov	r3,r2
81131fd0:	e0bfff17 	ldw	r2,-4(fp)
81131fd4:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
81131fd8:	e0bfff17 	ldw	r2,-4(fp)
81131fdc:	10800203 	ldbu	r2,8(r2)
81131fe0:	10803fcc 	andi	r2,r2,255
81131fe4:	10803fd8 	cmpnei	r2,r2,255
81131fe8:	1000041e 	bne	r2,zero,81131ffc <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
81131fec:	e0bfff17 	ldw	r2,-4(fp)
81131ff0:	00c00044 	movi	r3,1
81131ff4:	10c001c5 	stb	r3,7(r2)
81131ff8:	00000206 	br	81132004 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
81131ffc:	e0bfff17 	ldw	r2,-4(fp)
81132000:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
81132004:	e0bffe17 	ldw	r2,-8(fp)
81132008:	10c00283 	ldbu	r3,10(r2)
8113200c:	e0bfff17 	ldw	r2,-4(fp)
81132010:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
81132014:	e0bffe17 	ldw	r2,-8(fp)
81132018:	108002c4 	addi	r2,r2,11
8113201c:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
81132020:	e0bfff17 	ldw	r2,-4(fp)
81132024:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81132028:	e03ff805 	stb	zero,-32(fp)
8113202c:	00000b06 	br	8113205c <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
81132030:	e0bffa17 	ldw	r2,-24(fp)
81132034:	10c00044 	addi	r3,r2,1
81132038:	e0fffa15 	stw	r3,-24(fp)
8113203c:	e0fff917 	ldw	r3,-28(fp)
81132040:	19000044 	addi	r4,r3,1
81132044:	e13ff915 	stw	r4,-28(fp)
81132048:	18c00003 	ldbu	r3,0(r3)
8113204c:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81132050:	e0bff803 	ldbu	r2,-32(fp)
81132054:	10800044 	addi	r2,r2,1
81132058:	e0bff805 	stb	r2,-32(fp)
8113205c:	e0bff803 	ldbu	r2,-32(fp)
81132060:	108001b0 	cmpltui	r2,r2,6
81132064:	103ff21e 	bne	r2,zero,81132030 <__reset+0xfb112030>
81132068:	e0bffb17 	ldw	r2,-20(fp)
8113206c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132070:	e0bffc17 	ldw	r2,-16(fp)
81132074:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81132078:	0005883a 	mov	r2,zero
}
8113207c:	e037883a 	mov	sp,fp
81132080:	df000017 	ldw	fp,0(sp)
81132084:	dec00104 	addi	sp,sp,4
81132088:	f800283a 	ret

8113208c <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113208c:	defffc04 	addi	sp,sp,-16
81132090:	de00012e 	bgeu	sp,et,81132098 <OSMutex_RdyAtPrio+0xc>
81132094:	003b68fa 	trap	3
81132098:	df000315 	stw	fp,12(sp)
8113209c:	df000304 	addi	fp,sp,12
811320a0:	e13ffe15 	stw	r4,-8(fp)
811320a4:	2805883a 	mov	r2,r5
811320a8:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
811320ac:	e0bffe17 	ldw	r2,-8(fp)
811320b0:	10800d03 	ldbu	r2,52(r2)
811320b4:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
811320b8:	e0fffd03 	ldbu	r3,-12(fp)
811320bc:	e13ffd03 	ldbu	r4,-12(fp)
811320c0:	d0a08e44 	addi	r2,gp,-32199
811320c4:	2085883a 	add	r2,r4,r2
811320c8:	10800003 	ldbu	r2,0(r2)
811320cc:	1009883a 	mov	r4,r2
811320d0:	e0bffe17 	ldw	r2,-8(fp)
811320d4:	10800d43 	ldbu	r2,53(r2)
811320d8:	0084303a 	nor	r2,zero,r2
811320dc:	2084703a 	and	r2,r4,r2
811320e0:	1009883a 	mov	r4,r2
811320e4:	d0a08e44 	addi	r2,gp,-32199
811320e8:	1885883a 	add	r2,r3,r2
811320ec:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811320f0:	e0fffd03 	ldbu	r3,-12(fp)
811320f4:	d0a08e44 	addi	r2,gp,-32199
811320f8:	1885883a 	add	r2,r3,r2
811320fc:	10800003 	ldbu	r2,0(r2)
81132100:	10803fcc 	andi	r2,r2,255
81132104:	1000071e 	bne	r2,zero,81132124 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
81132108:	e0bffe17 	ldw	r2,-8(fp)
8113210c:	10800d83 	ldbu	r2,54(r2)
81132110:	0084303a 	nor	r2,zero,r2
81132114:	1007883a 	mov	r3,r2
81132118:	d0a08e03 	ldbu	r2,-32200(gp)
8113211c:	1884703a 	and	r2,r3,r2
81132120:	d0a08e05 	stb	r2,-32200(gp)
    }
    ptcb->OSTCBPrio         = prio;
81132124:	e0bffe17 	ldw	r2,-8(fp)
81132128:	e0ffff03 	ldbu	r3,-4(fp)
8113212c:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
81132130:	e0bfff03 	ldbu	r2,-4(fp)
81132134:	1004d0fa 	srli	r2,r2,3
81132138:	108001cc 	andi	r2,r2,7
8113213c:	1007883a 	mov	r3,r2
81132140:	e0bffe17 	ldw	r2,-8(fp)
81132144:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
81132148:	e0bfff03 	ldbu	r2,-4(fp)
8113214c:	108001cc 	andi	r2,r2,7
81132150:	1007883a 	mov	r3,r2
81132154:	e0bffe17 	ldw	r2,-8(fp)
81132158:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113215c:	e0bffe17 	ldw	r2,-8(fp)
81132160:	10800d03 	ldbu	r2,52(r2)
81132164:	10803fcc 	andi	r2,r2,255
81132168:	00c00044 	movi	r3,1
8113216c:	1884983a 	sll	r2,r3,r2
81132170:	1007883a 	mov	r3,r2
81132174:	e0bffe17 	ldw	r2,-8(fp)
81132178:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113217c:	e0bffe17 	ldw	r2,-8(fp)
81132180:	10800cc3 	ldbu	r2,51(r2)
81132184:	10803fcc 	andi	r2,r2,255
81132188:	00c00044 	movi	r3,1
8113218c:	1884983a 	sll	r2,r3,r2
81132190:	1007883a 	mov	r3,r2
81132194:	e0bffe17 	ldw	r2,-8(fp)
81132198:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113219c:	e0bffe17 	ldw	r2,-8(fp)
811321a0:	10c00d83 	ldbu	r3,54(r2)
811321a4:	d0a08e03 	ldbu	r2,-32200(gp)
811321a8:	1884b03a 	or	r2,r3,r2
811321ac:	d0a08e05 	stb	r2,-32200(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811321b0:	e0bffe17 	ldw	r2,-8(fp)
811321b4:	10800d03 	ldbu	r2,52(r2)
811321b8:	10c03fcc 	andi	r3,r2,255
811321bc:	e0bffe17 	ldw	r2,-8(fp)
811321c0:	10800d03 	ldbu	r2,52(r2)
811321c4:	11003fcc 	andi	r4,r2,255
811321c8:	d0a08e44 	addi	r2,gp,-32199
811321cc:	2085883a 	add	r2,r4,r2
811321d0:	11000003 	ldbu	r4,0(r2)
811321d4:	e0bffe17 	ldw	r2,-8(fp)
811321d8:	10800d43 	ldbu	r2,53(r2)
811321dc:	2084b03a 	or	r2,r4,r2
811321e0:	1009883a 	mov	r4,r2
811321e4:	d0a08e44 	addi	r2,gp,-32199
811321e8:	1885883a 	add	r2,r3,r2
811321ec:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
811321f0:	e0ffff03 	ldbu	r3,-4(fp)
811321f4:	00a045b4 	movhi	r2,33046
811321f8:	10bfb204 	addi	r2,r2,-312
811321fc:	18c7883a 	add	r3,r3,r3
81132200:	18c7883a 	add	r3,r3,r3
81132204:	10c5883a 	add	r2,r2,r3
81132208:	e0fffe17 	ldw	r3,-8(fp)
8113220c:	10c00015 	stw	r3,0(r2)
}
81132210:	0001883a 	nop
81132214:	e037883a 	mov	sp,fp
81132218:	df000017 	ldw	fp,0(sp)
8113221c:	dec00104 	addi	sp,sp,4
81132220:	f800283a 	ret

81132224 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
81132224:	defff804 	addi	sp,sp,-32
81132228:	de00012e 	bgeu	sp,et,81132230 <OSQAccept+0xc>
8113222c:	003b68fa 	trap	3
81132230:	df000715 	stw	fp,28(sp)
81132234:	df000704 	addi	fp,sp,28
81132238:	e13ffe15 	stw	r4,-8(fp)
8113223c:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132240:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81132244:	e0bfff17 	ldw	r2,-4(fp)
81132248:	1000021e 	bne	r2,zero,81132254 <OSQAccept+0x30>
        return ((void *)0);
8113224c:	0005883a 	mov	r2,zero
81132250:	00004206 	br	8113235c <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
81132254:	e0bffe17 	ldw	r2,-8(fp)
81132258:	1000051e 	bne	r2,zero,81132270 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113225c:	e0bfff17 	ldw	r2,-4(fp)
81132260:	00c00104 	movi	r3,4
81132264:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81132268:	0005883a 	mov	r2,zero
8113226c:	00003b06 	br	8113235c <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81132270:	e0bffe17 	ldw	r2,-8(fp)
81132274:	10800003 	ldbu	r2,0(r2)
81132278:	10803fcc 	andi	r2,r2,255
8113227c:	108000a0 	cmpeqi	r2,r2,2
81132280:	1000051e 	bne	r2,zero,81132298 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81132284:	e0bfff17 	ldw	r2,-4(fp)
81132288:	00c00044 	movi	r3,1
8113228c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81132290:	0005883a 	mov	r2,zero
81132294:	00003106 	br	8113235c <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132298:	0005303a 	rdctl	r2,status
8113229c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811322a0:	e0fffd17 	ldw	r3,-12(fp)
811322a4:	00bfff84 	movi	r2,-2
811322a8:	1884703a 	and	r2,r3,r2
811322ac:	1001703a 	wrctl	status,r2
  
  return context;
811322b0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811322b4:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
811322b8:	e0bffe17 	ldw	r2,-8(fp)
811322bc:	10800117 	ldw	r2,4(r2)
811322c0:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
811322c4:	e0bffc17 	ldw	r2,-16(fp)
811322c8:	1080058b 	ldhu	r2,22(r2)
811322cc:	10bfffcc 	andi	r2,r2,65535
811322d0:	10001926 	beq	r2,zero,81132338 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
811322d4:	e0bffc17 	ldw	r2,-16(fp)
811322d8:	10800417 	ldw	r2,16(r2)
811322dc:	11000104 	addi	r4,r2,4
811322e0:	e0fffc17 	ldw	r3,-16(fp)
811322e4:	19000415 	stw	r4,16(r3)
811322e8:	10800017 	ldw	r2,0(r2)
811322ec:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
811322f0:	e0bffc17 	ldw	r2,-16(fp)
811322f4:	1080058b 	ldhu	r2,22(r2)
811322f8:	10bfffc4 	addi	r2,r2,-1
811322fc:	1007883a 	mov	r3,r2
81132300:	e0bffc17 	ldw	r2,-16(fp)
81132304:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81132308:	e0bffc17 	ldw	r2,-16(fp)
8113230c:	10c00417 	ldw	r3,16(r2)
81132310:	e0bffc17 	ldw	r2,-16(fp)
81132314:	10800217 	ldw	r2,8(r2)
81132318:	1880041e 	bne	r3,r2,8113232c <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113231c:	e0bffc17 	ldw	r2,-16(fp)
81132320:	10c00117 	ldw	r3,4(r2)
81132324:	e0bffc17 	ldw	r2,-16(fp)
81132328:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113232c:	e0bfff17 	ldw	r2,-4(fp)
81132330:	10000005 	stb	zero,0(r2)
81132334:	00000406 	br	81132348 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
81132338:	e0bfff17 	ldw	r2,-4(fp)
8113233c:	00c007c4 	movi	r3,31
81132340:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
81132344:	e03ff915 	stw	zero,-28(fp)
81132348:	e0bffa17 	ldw	r2,-24(fp)
8113234c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132350:	e0bffb17 	ldw	r2,-20(fp)
81132354:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
81132358:	e0bff917 	ldw	r2,-28(fp)
}
8113235c:	e037883a 	mov	sp,fp
81132360:	df000017 	ldw	fp,0(sp)
81132364:	dec00104 	addi	sp,sp,4
81132368:	f800283a 	ret

8113236c <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113236c:	defff404 	addi	sp,sp,-48
81132370:	de00012e 	bgeu	sp,et,81132378 <OSQCreate+0xc>
81132374:	003b68fa 	trap	3
81132378:	dfc00b15 	stw	ra,44(sp)
8113237c:	df000a15 	stw	fp,40(sp)
81132380:	df000a04 	addi	fp,sp,40
81132384:	e13ffe15 	stw	r4,-8(fp)
81132388:	2805883a 	mov	r2,r5
8113238c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132390:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
81132394:	d0a09103 	ldbu	r2,-32188(gp)
81132398:	10803fcc 	andi	r2,r2,255
8113239c:	10000226 	beq	r2,zero,811323a8 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
811323a0:	0005883a 	mov	r2,zero
811323a4:	00005906 	br	8113250c <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811323a8:	0005303a 	rdctl	r2,status
811323ac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811323b0:	e0fffd17 	ldw	r3,-12(fp)
811323b4:	00bfff84 	movi	r2,-2
811323b8:	1884703a 	and	r2,r3,r2
811323bc:	1001703a 	wrctl	status,r2
  
  return context;
811323c0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811323c4:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
811323c8:	d0a09017 	ldw	r2,-32192(gp)
811323cc:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
811323d0:	d0a09017 	ldw	r2,-32192(gp)
811323d4:	10000326 	beq	r2,zero,811323e4 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
811323d8:	d0a09017 	ldw	r2,-32192(gp)
811323dc:	10800117 	ldw	r2,4(r2)
811323e0:	d0a09015 	stw	r2,-32192(gp)
811323e4:	e0bff717 	ldw	r2,-36(fp)
811323e8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811323ec:	e0bff817 	ldw	r2,-32(fp)
811323f0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
811323f4:	e0bff617 	ldw	r2,-40(fp)
811323f8:	10004326 	beq	r2,zero,81132508 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811323fc:	0005303a 	rdctl	r2,status
81132400:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132404:	e0fff917 	ldw	r3,-28(fp)
81132408:	00bfff84 	movi	r2,-2
8113240c:	1884703a 	and	r2,r3,r2
81132410:	1001703a 	wrctl	status,r2
  
  return context;
81132414:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
81132418:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113241c:	d0a08d17 	ldw	r2,-32204(gp)
81132420:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
81132424:	e0bffb17 	ldw	r2,-20(fp)
81132428:	10002d26 	beq	r2,zero,811324e0 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113242c:	d0a08d17 	ldw	r2,-32204(gp)
81132430:	10800017 	ldw	r2,0(r2)
81132434:	d0a08d15 	stw	r2,-32204(gp)
81132438:	e0bff717 	ldw	r2,-36(fp)
8113243c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132440:	e0bffa17 	ldw	r2,-24(fp)
81132444:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
81132448:	e0bffb17 	ldw	r2,-20(fp)
8113244c:	e0fffe17 	ldw	r3,-8(fp)
81132450:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
81132454:	e0bfff0b 	ldhu	r2,-4(fp)
81132458:	1085883a 	add	r2,r2,r2
8113245c:	1085883a 	add	r2,r2,r2
81132460:	1007883a 	mov	r3,r2
81132464:	e0bffe17 	ldw	r2,-8(fp)
81132468:	10c7883a 	add	r3,r2,r3
8113246c:	e0bffb17 	ldw	r2,-20(fp)
81132470:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
81132474:	e0bffb17 	ldw	r2,-20(fp)
81132478:	e0fffe17 	ldw	r3,-8(fp)
8113247c:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
81132480:	e0bffb17 	ldw	r2,-20(fp)
81132484:	e0fffe17 	ldw	r3,-8(fp)
81132488:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113248c:	e0bffb17 	ldw	r2,-20(fp)
81132490:	e0ffff0b 	ldhu	r3,-4(fp)
81132494:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
81132498:	e0bffb17 	ldw	r2,-20(fp)
8113249c:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
811324a0:	e0bff617 	ldw	r2,-40(fp)
811324a4:	00c00084 	movi	r3,2
811324a8:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
811324ac:	e0bff617 	ldw	r2,-40(fp)
811324b0:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
811324b4:	e0bff617 	ldw	r2,-40(fp)
811324b8:	e0fffb17 	ldw	r3,-20(fp)
811324bc:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
811324c0:	e0bff617 	ldw	r2,-40(fp)
811324c4:	00c00fc4 	movi	r3,63
811324c8:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
811324cc:	e0bff617 	ldw	r2,-40(fp)
811324d0:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
811324d4:	e13ff617 	ldw	r4,-40(fp)
811324d8:	112e3cc0 	call	8112e3cc <OS_EventWaitListInit>
811324dc:	00000a06 	br	81132508 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
811324e0:	d0e09017 	ldw	r3,-32192(gp)
811324e4:	e0bff617 	ldw	r2,-40(fp)
811324e8:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
811324ec:	e0bff617 	ldw	r2,-40(fp)
811324f0:	d0a09015 	stw	r2,-32192(gp)
811324f4:	e0bff717 	ldw	r2,-36(fp)
811324f8:	e0bffc15 	stw	r2,-16(fp)
811324fc:	e0bffc17 	ldw	r2,-16(fp)
81132500:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
81132504:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
81132508:	e0bff617 	ldw	r2,-40(fp)
}
8113250c:	e037883a 	mov	sp,fp
81132510:	dfc00117 	ldw	ra,4(sp)
81132514:	df000017 	ldw	fp,0(sp)
81132518:	dec00204 	addi	sp,sp,8
8113251c:	f800283a 	ret

81132520 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81132520:	defff204 	addi	sp,sp,-56
81132524:	de00012e 	bgeu	sp,et,8113252c <OSQDel+0xc>
81132528:	003b68fa 	trap	3
8113252c:	dfc00d15 	stw	ra,52(sp)
81132530:	df000c15 	stw	fp,48(sp)
81132534:	df000c04 	addi	fp,sp,48
81132538:	e13ffd15 	stw	r4,-12(fp)
8113253c:	2805883a 	mov	r2,r5
81132540:	e1bfff15 	stw	r6,-4(fp)
81132544:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81132548:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113254c:	e0bfff17 	ldw	r2,-4(fp)
81132550:	1000021e 	bne	r2,zero,8113255c <OSQDel+0x3c>
        return (pevent);
81132554:	e0bffd17 	ldw	r2,-12(fp)
81132558:	00008e06 	br	81132794 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113255c:	e0bffd17 	ldw	r2,-12(fp)
81132560:	1000051e 	bne	r2,zero,81132578 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81132564:	e0bfff17 	ldw	r2,-4(fp)
81132568:	00c00104 	movi	r3,4
8113256c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81132570:	e0bffd17 	ldw	r2,-12(fp)
81132574:	00008706 	br	81132794 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81132578:	e0bffd17 	ldw	r2,-12(fp)
8113257c:	10800003 	ldbu	r2,0(r2)
81132580:	10803fcc 	andi	r2,r2,255
81132584:	108000a0 	cmpeqi	r2,r2,2
81132588:	1000051e 	bne	r2,zero,811325a0 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113258c:	e0bfff17 	ldw	r2,-4(fp)
81132590:	00c00044 	movi	r3,1
81132594:	10c00005 	stb	r3,0(r2)
        return (pevent);
81132598:	e0bffd17 	ldw	r2,-12(fp)
8113259c:	00007d06 	br	81132794 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811325a0:	d0a09103 	ldbu	r2,-32188(gp)
811325a4:	10803fcc 	andi	r2,r2,255
811325a8:	10000526 	beq	r2,zero,811325c0 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
811325ac:	e0bfff17 	ldw	r2,-4(fp)
811325b0:	00c003c4 	movi	r3,15
811325b4:	10c00005 	stb	r3,0(r2)
        return (pevent);
811325b8:	e0bffd17 	ldw	r2,-12(fp)
811325bc:	00007506 	br	81132794 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811325c0:	0005303a 	rdctl	r2,status
811325c4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811325c8:	e0fffc17 	ldw	r3,-16(fp)
811325cc:	00bfff84 	movi	r2,-2
811325d0:	1884703a 	and	r2,r3,r2
811325d4:	1001703a 	wrctl	status,r2
  
  return context;
811325d8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811325dc:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
811325e0:	e0bffd17 	ldw	r2,-12(fp)
811325e4:	10800283 	ldbu	r2,10(r2)
811325e8:	10803fcc 	andi	r2,r2,255
811325ec:	10000326 	beq	r2,zero,811325fc <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811325f0:	00800044 	movi	r2,1
811325f4:	e0bff405 	stb	r2,-48(fp)
811325f8:	00000106 	br	81132600 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811325fc:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81132600:	e0bffe03 	ldbu	r2,-8(fp)
81132604:	10000326 	beq	r2,zero,81132614 <OSQDel+0xf4>
81132608:	10800060 	cmpeqi	r2,r2,1
8113260c:	1000301e 	bne	r2,zero,811326d0 <OSQDel+0x1b0>
81132610:	00005506 	br	81132768 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
81132614:	e0bff403 	ldbu	r2,-48(fp)
81132618:	10001e1e 	bne	r2,zero,81132694 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113261c:	e0bffd17 	ldw	r2,-12(fp)
81132620:	00c00fc4 	movi	r3,63
81132624:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81132628:	e0bffd17 	ldw	r2,-12(fp)
8113262c:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
81132630:	e0bffd17 	ldw	r2,-12(fp)
81132634:	10800117 	ldw	r2,4(r2)
81132638:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113263c:	d0e08d17 	ldw	r3,-32204(gp)
81132640:	e0bff817 	ldw	r2,-32(fp)
81132644:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
81132648:	e0bff817 	ldw	r2,-32(fp)
8113264c:	d0a08d15 	stw	r2,-32204(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81132650:	e0bffd17 	ldw	r2,-12(fp)
81132654:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
81132658:	d0e09017 	ldw	r3,-32192(gp)
8113265c:	e0bffd17 	ldw	r2,-12(fp)
81132660:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81132664:	e0bffd17 	ldw	r2,-12(fp)
81132668:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113266c:	e0bffd17 	ldw	r2,-12(fp)
81132670:	d0a09015 	stw	r2,-32192(gp)
81132674:	e0bff617 	ldw	r2,-40(fp)
81132678:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113267c:	e0bff717 	ldw	r2,-36(fp)
81132680:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81132684:	e0bfff17 	ldw	r2,-4(fp)
81132688:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113268c:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81132690:	00003f06 	br	81132790 <OSQDel+0x270>
81132694:	e0bff617 	ldw	r2,-40(fp)
81132698:	e0bff915 	stw	r2,-28(fp)
8113269c:	e0bff917 	ldw	r2,-28(fp)
811326a0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
811326a4:	e0bfff17 	ldw	r2,-4(fp)
811326a8:	00c01244 	movi	r3,73
811326ac:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
811326b0:	e0bffd17 	ldw	r2,-12(fp)
811326b4:	e0bff515 	stw	r2,-44(fp)
             }
             break;
811326b8:	00003506 	br	81132790 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
811326bc:	000f883a 	mov	r7,zero
811326c0:	01800104 	movi	r6,4
811326c4:	000b883a 	mov	r5,zero
811326c8:	e13ffd17 	ldw	r4,-12(fp)
811326cc:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
811326d0:	e0bffd17 	ldw	r2,-12(fp)
811326d4:	10800283 	ldbu	r2,10(r2)
811326d8:	10803fcc 	andi	r2,r2,255
811326dc:	103ff71e 	bne	r2,zero,811326bc <__reset+0xfb1126bc>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
811326e0:	e0bffd17 	ldw	r2,-12(fp)
811326e4:	00c00fc4 	movi	r3,63
811326e8:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
811326ec:	e0bffd17 	ldw	r2,-12(fp)
811326f0:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
811326f4:	e0bffd17 	ldw	r2,-12(fp)
811326f8:	10800117 	ldw	r2,4(r2)
811326fc:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
81132700:	d0e08d17 	ldw	r3,-32204(gp)
81132704:	e0bff817 	ldw	r2,-32(fp)
81132708:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113270c:	e0bff817 	ldw	r2,-32(fp)
81132710:	d0a08d15 	stw	r2,-32204(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81132714:	e0bffd17 	ldw	r2,-12(fp)
81132718:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113271c:	d0e09017 	ldw	r3,-32192(gp)
81132720:	e0bffd17 	ldw	r2,-12(fp)
81132724:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
81132728:	e0bffd17 	ldw	r2,-12(fp)
8113272c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
81132730:	e0bffd17 	ldw	r2,-12(fp)
81132734:	d0a09015 	stw	r2,-32192(gp)
81132738:	e0bff617 	ldw	r2,-40(fp)
8113273c:	e0bffa15 	stw	r2,-24(fp)
81132740:	e0bffa17 	ldw	r2,-24(fp)
81132744:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81132748:	e0bff403 	ldbu	r2,-48(fp)
8113274c:	10800058 	cmpnei	r2,r2,1
81132750:	1000011e 	bne	r2,zero,81132758 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81132754:	112e8b00 	call	8112e8b0 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81132758:	e0bfff17 	ldw	r2,-4(fp)
8113275c:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
81132760:	e03ff515 	stw	zero,-44(fp)
             break;
81132764:	00000a06 	br	81132790 <OSQDel+0x270>
81132768:	e0bff617 	ldw	r2,-40(fp)
8113276c:	e0bffb15 	stw	r2,-20(fp)
81132770:	e0bffb17 	ldw	r2,-20(fp)
81132774:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81132778:	e0bfff17 	ldw	r2,-4(fp)
8113277c:	00c001c4 	movi	r3,7
81132780:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81132784:	e0bffd17 	ldw	r2,-12(fp)
81132788:	e0bff515 	stw	r2,-44(fp)
             break;
8113278c:	0001883a 	nop
    }
    return (pevent_return);
81132790:	e0bff517 	ldw	r2,-44(fp)
}
81132794:	e037883a 	mov	sp,fp
81132798:	dfc00117 	ldw	ra,4(sp)
8113279c:	df000017 	ldw	fp,0(sp)
811327a0:	dec00204 	addi	sp,sp,8
811327a4:	f800283a 	ret

811327a8 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
811327a8:	defffa04 	addi	sp,sp,-24
811327ac:	de00012e 	bgeu	sp,et,811327b4 <OSQFlush+0xc>
811327b0:	003b68fa 	trap	3
811327b4:	df000515 	stw	fp,20(sp)
811327b8:	df000504 	addi	fp,sp,20
811327bc:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811327c0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811327c4:	e0bfff17 	ldw	r2,-4(fp)
811327c8:	1000021e 	bne	r2,zero,811327d4 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
811327cc:	00800104 	movi	r2,4
811327d0:	00002106 	br	81132858 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
811327d4:	e0bfff17 	ldw	r2,-4(fp)
811327d8:	10800003 	ldbu	r2,0(r2)
811327dc:	10803fcc 	andi	r2,r2,255
811327e0:	108000a0 	cmpeqi	r2,r2,2
811327e4:	1000021e 	bne	r2,zero,811327f0 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
811327e8:	00800044 	movi	r2,1
811327ec:	00001a06 	br	81132858 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811327f0:	0005303a 	rdctl	r2,status
811327f4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811327f8:	e0fffd17 	ldw	r3,-12(fp)
811327fc:	00bfff84 	movi	r2,-2
81132800:	1884703a 	and	r2,r3,r2
81132804:	1001703a 	wrctl	status,r2
  
  return context;
81132808:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113280c:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
81132810:	e0bfff17 	ldw	r2,-4(fp)
81132814:	10800117 	ldw	r2,4(r2)
81132818:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113281c:	e0bffc17 	ldw	r2,-16(fp)
81132820:	10c00117 	ldw	r3,4(r2)
81132824:	e0bffc17 	ldw	r2,-16(fp)
81132828:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113282c:	e0bffc17 	ldw	r2,-16(fp)
81132830:	10c00117 	ldw	r3,4(r2)
81132834:	e0bffc17 	ldw	r2,-16(fp)
81132838:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113283c:	e0bffc17 	ldw	r2,-16(fp)
81132840:	1000058d 	sth	zero,22(r2)
81132844:	e0bffb17 	ldw	r2,-20(fp)
81132848:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113284c:	e0bffe17 	ldw	r2,-8(fp)
81132850:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81132854:	0005883a 	mov	r2,zero
}
81132858:	e037883a 	mov	sp,fp
8113285c:	df000017 	ldw	fp,0(sp)
81132860:	dec00104 	addi	sp,sp,4
81132864:	f800283a 	ret

81132868 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81132868:	defff304 	addi	sp,sp,-52
8113286c:	de00012e 	bgeu	sp,et,81132874 <OSQPend+0xc>
81132870:	003b68fa 	trap	3
81132874:	dfc00c15 	stw	ra,48(sp)
81132878:	df000b15 	stw	fp,44(sp)
8113287c:	df000b04 	addi	fp,sp,44
81132880:	e13ffd15 	stw	r4,-12(fp)
81132884:	2805883a 	mov	r2,r5
81132888:	e1bfff15 	stw	r6,-4(fp)
8113288c:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132890:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81132894:	e0bfff17 	ldw	r2,-4(fp)
81132898:	1000021e 	bne	r2,zero,811328a4 <OSQPend+0x3c>
        return ((void *)0);
8113289c:	0005883a 	mov	r2,zero
811328a0:	00009106 	br	81132ae8 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
811328a4:	e0bffd17 	ldw	r2,-12(fp)
811328a8:	1000051e 	bne	r2,zero,811328c0 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811328ac:	e0bfff17 	ldw	r2,-4(fp)
811328b0:	00c00104 	movi	r3,4
811328b4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
811328b8:	0005883a 	mov	r2,zero
811328bc:	00008a06 	br	81132ae8 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
811328c0:	e0bffd17 	ldw	r2,-12(fp)
811328c4:	10800003 	ldbu	r2,0(r2)
811328c8:	10803fcc 	andi	r2,r2,255
811328cc:	108000a0 	cmpeqi	r2,r2,2
811328d0:	1000051e 	bne	r2,zero,811328e8 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811328d4:	e0bfff17 	ldw	r2,-4(fp)
811328d8:	00c00044 	movi	r3,1
811328dc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
811328e0:	0005883a 	mov	r2,zero
811328e4:	00008006 	br	81132ae8 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
811328e8:	d0a09103 	ldbu	r2,-32188(gp)
811328ec:	10803fcc 	andi	r2,r2,255
811328f0:	10000526 	beq	r2,zero,81132908 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
811328f4:	e0bfff17 	ldw	r2,-4(fp)
811328f8:	00c00084 	movi	r3,2
811328fc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81132900:	0005883a 	mov	r2,zero
81132904:	00007806 	br	81132ae8 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
81132908:	d0a07f03 	ldbu	r2,-32260(gp)
8113290c:	10803fcc 	andi	r2,r2,255
81132910:	10000526 	beq	r2,zero,81132928 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
81132914:	e0bfff17 	ldw	r2,-4(fp)
81132918:	00c00344 	movi	r3,13
8113291c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81132920:	0005883a 	mov	r2,zero
81132924:	00007006 	br	81132ae8 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132928:	0005303a 	rdctl	r2,status
8113292c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132930:	e0fffc17 	ldw	r3,-16(fp)
81132934:	00bfff84 	movi	r2,-2
81132938:	1884703a 	and	r2,r3,r2
8113293c:	1001703a 	wrctl	status,r2
  
  return context;
81132940:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81132944:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81132948:	e0bffd17 	ldw	r2,-12(fp)
8113294c:	10800117 	ldw	r2,4(r2)
81132950:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
81132954:	e0bff817 	ldw	r2,-32(fp)
81132958:	1080058b 	ldhu	r2,22(r2)
8113295c:	10bfffcc 	andi	r2,r2,65535
81132960:	10001e26 	beq	r2,zero,811329dc <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
81132964:	e0bff817 	ldw	r2,-32(fp)
81132968:	10800417 	ldw	r2,16(r2)
8113296c:	11000104 	addi	r4,r2,4
81132970:	e0fff817 	ldw	r3,-32(fp)
81132974:	19000415 	stw	r4,16(r3)
81132978:	10800017 	ldw	r2,0(r2)
8113297c:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81132980:	e0bff817 	ldw	r2,-32(fp)
81132984:	1080058b 	ldhu	r2,22(r2)
81132988:	10bfffc4 	addi	r2,r2,-1
8113298c:	1007883a 	mov	r3,r2
81132990:	e0bff817 	ldw	r2,-32(fp)
81132994:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81132998:	e0bff817 	ldw	r2,-32(fp)
8113299c:	10c00417 	ldw	r3,16(r2)
811329a0:	e0bff817 	ldw	r2,-32(fp)
811329a4:	10800217 	ldw	r2,8(r2)
811329a8:	1880041e 	bne	r3,r2,811329bc <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
811329ac:	e0bff817 	ldw	r2,-32(fp)
811329b0:	10c00117 	ldw	r3,4(r2)
811329b4:	e0bff817 	ldw	r2,-32(fp)
811329b8:	10c00415 	stw	r3,16(r2)
811329bc:	e0bff617 	ldw	r2,-40(fp)
811329c0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811329c4:	e0bff717 	ldw	r2,-36(fp)
811329c8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
811329cc:	e0bfff17 	ldw	r2,-4(fp)
811329d0:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
811329d4:	e0bff517 	ldw	r2,-44(fp)
811329d8:	00004306 	br	81132ae8 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
811329dc:	d0a09217 	ldw	r2,-32184(gp)
811329e0:	d0e09217 	ldw	r3,-32184(gp)
811329e4:	18c00c03 	ldbu	r3,48(r3)
811329e8:	18c00114 	ori	r3,r3,4
811329ec:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
811329f0:	d0a09217 	ldw	r2,-32184(gp)
811329f4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
811329f8:	d0a09217 	ldw	r2,-32184(gp)
811329fc:	e0fffe0b 	ldhu	r3,-8(fp)
81132a00:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
81132a04:	e13ffd17 	ldw	r4,-12(fp)
81132a08:	112df940 	call	8112df94 <OS_EventTaskWait>
81132a0c:	e0bff617 	ldw	r2,-40(fp)
81132a10:	e0bffb15 	stw	r2,-20(fp)
81132a14:	e0bffb17 	ldw	r2,-20(fp)
81132a18:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
81132a1c:	112e8b00 	call	8112e8b0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132a20:	0005303a 	rdctl	r2,status
81132a24:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132a28:	e0fff917 	ldw	r3,-28(fp)
81132a2c:	00bfff84 	movi	r2,-2
81132a30:	1884703a 	and	r2,r3,r2
81132a34:	1001703a 	wrctl	status,r2
  
  return context;
81132a38:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81132a3c:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81132a40:	d0a09217 	ldw	r2,-32184(gp)
81132a44:	10800c43 	ldbu	r2,49(r2)
81132a48:	10803fcc 	andi	r2,r2,255
81132a4c:	10000326 	beq	r2,zero,81132a5c <OSQPend+0x1f4>
81132a50:	108000a0 	cmpeqi	r2,r2,2
81132a54:	1000071e 	bne	r2,zero,81132a74 <OSQPend+0x20c>
81132a58:	00000b06 	br	81132a88 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
81132a5c:	d0a09217 	ldw	r2,-32184(gp)
81132a60:	10800917 	ldw	r2,36(r2)
81132a64:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
81132a68:	e0bfff17 	ldw	r2,-4(fp)
81132a6c:	10000005 	stb	zero,0(r2)
             break;
81132a70:	00000e06 	br	81132aac <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
81132a74:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81132a78:	e0bfff17 	ldw	r2,-4(fp)
81132a7c:	00c00384 	movi	r3,14
81132a80:	10c00005 	stb	r3,0(r2)
             break;
81132a84:	00000906 	br	81132aac <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81132a88:	d0a09217 	ldw	r2,-32184(gp)
81132a8c:	e17ffd17 	ldw	r5,-12(fp)
81132a90:	1009883a 	mov	r4,r2
81132a94:	112e2040 	call	8112e204 <OS_EventTaskRemove>
             pmsg = (void *)0;
81132a98:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81132a9c:	e0bfff17 	ldw	r2,-4(fp)
81132aa0:	00c00284 	movi	r3,10
81132aa4:	10c00005 	stb	r3,0(r2)
             break;
81132aa8:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81132aac:	d0a09217 	ldw	r2,-32184(gp)
81132ab0:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81132ab4:	d0a09217 	ldw	r2,-32184(gp)
81132ab8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81132abc:	d0a09217 	ldw	r2,-32184(gp)
81132ac0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81132ac4:	d0a09217 	ldw	r2,-32184(gp)
81132ac8:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
81132acc:	d0a09217 	ldw	r2,-32184(gp)
81132ad0:	10000915 	stw	zero,36(r2)
81132ad4:	e0bff617 	ldw	r2,-40(fp)
81132ad8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132adc:	e0bffa17 	ldw	r2,-24(fp)
81132ae0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
81132ae4:	e0bff517 	ldw	r2,-44(fp)
}
81132ae8:	e037883a 	mov	sp,fp
81132aec:	dfc00117 	ldw	ra,4(sp)
81132af0:	df000017 	ldw	fp,0(sp)
81132af4:	dec00204 	addi	sp,sp,8
81132af8:	f800283a 	ret

81132afc <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81132afc:	defff604 	addi	sp,sp,-40
81132b00:	de00012e 	bgeu	sp,et,81132b08 <OSQPendAbort+0xc>
81132b04:	003b68fa 	trap	3
81132b08:	dfc00915 	stw	ra,36(sp)
81132b0c:	df000815 	stw	fp,32(sp)
81132b10:	df000804 	addi	fp,sp,32
81132b14:	e13ffd15 	stw	r4,-12(fp)
81132b18:	2805883a 	mov	r2,r5
81132b1c:	e1bfff15 	stw	r6,-4(fp)
81132b20:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81132b24:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81132b28:	e0bfff17 	ldw	r2,-4(fp)
81132b2c:	1000021e 	bne	r2,zero,81132b38 <OSQPendAbort+0x3c>
        return (0);
81132b30:	0005883a 	mov	r2,zero
81132b34:	00004906 	br	81132c5c <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81132b38:	e0bffd17 	ldw	r2,-12(fp)
81132b3c:	1000051e 	bne	r2,zero,81132b54 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81132b40:	e0bfff17 	ldw	r2,-4(fp)
81132b44:	00c00104 	movi	r3,4
81132b48:	10c00005 	stb	r3,0(r2)
        return (0);
81132b4c:	0005883a 	mov	r2,zero
81132b50:	00004206 	br	81132c5c <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81132b54:	e0bffd17 	ldw	r2,-12(fp)
81132b58:	10800003 	ldbu	r2,0(r2)
81132b5c:	10803fcc 	andi	r2,r2,255
81132b60:	108000a0 	cmpeqi	r2,r2,2
81132b64:	1000051e 	bne	r2,zero,81132b7c <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81132b68:	e0bfff17 	ldw	r2,-4(fp)
81132b6c:	00c00044 	movi	r3,1
81132b70:	10c00005 	stb	r3,0(r2)
        return (0);
81132b74:	0005883a 	mov	r2,zero
81132b78:	00003806 	br	81132c5c <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132b7c:	0005303a 	rdctl	r2,status
81132b80:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132b84:	e0fffc17 	ldw	r3,-16(fp)
81132b88:	00bfff84 	movi	r2,-2
81132b8c:	1884703a 	and	r2,r3,r2
81132b90:	1001703a 	wrctl	status,r2
  
  return context;
81132b94:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81132b98:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
81132b9c:	e0bffd17 	ldw	r2,-12(fp)
81132ba0:	10800283 	ldbu	r2,10(r2)
81132ba4:	10803fcc 	andi	r2,r2,255
81132ba8:	10002526 	beq	r2,zero,81132c40 <OSQPendAbort+0x144>
        nbr_tasks = 0;
81132bac:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81132bb0:	e0bffe03 	ldbu	r2,-8(fp)
81132bb4:	10800060 	cmpeqi	r2,r2,1
81132bb8:	10000e26 	beq	r2,zero,81132bf4 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81132bbc:	00000806 	br	81132be0 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81132bc0:	01c00084 	movi	r7,2
81132bc4:	01800104 	movi	r6,4
81132bc8:	000b883a 	mov	r5,zero
81132bcc:	e13ffd17 	ldw	r4,-12(fp)
81132bd0:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
                     nbr_tasks++;
81132bd4:	e0bff803 	ldbu	r2,-32(fp)
81132bd8:	10800044 	addi	r2,r2,1
81132bdc:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81132be0:	e0bffd17 	ldw	r2,-12(fp)
81132be4:	10800283 	ldbu	r2,10(r2)
81132be8:	10803fcc 	andi	r2,r2,255
81132bec:	103ff41e 	bne	r2,zero,81132bc0 <__reset+0xfb112bc0>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81132bf0:	00000906 	br	81132c18 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81132bf4:	01c00084 	movi	r7,2
81132bf8:	01800104 	movi	r6,4
81132bfc:	000b883a 	mov	r5,zero
81132c00:	e13ffd17 	ldw	r4,-12(fp)
81132c04:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
                 nbr_tasks++;
81132c08:	e0bff803 	ldbu	r2,-32(fp)
81132c0c:	10800044 	addi	r2,r2,1
81132c10:	e0bff805 	stb	r2,-32(fp)
                 break;
81132c14:	0001883a 	nop
81132c18:	e0bff917 	ldw	r2,-28(fp)
81132c1c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132c20:	e0bffa17 	ldw	r2,-24(fp)
81132c24:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
81132c28:	112e8b00 	call	8112e8b0 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81132c2c:	e0bfff17 	ldw	r2,-4(fp)
81132c30:	00c00384 	movi	r3,14
81132c34:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81132c38:	e0bff803 	ldbu	r2,-32(fp)
81132c3c:	00000706 	br	81132c5c <OSQPendAbort+0x160>
81132c40:	e0bff917 	ldw	r2,-28(fp)
81132c44:	e0bffb15 	stw	r2,-20(fp)
81132c48:	e0bffb17 	ldw	r2,-20(fp)
81132c4c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81132c50:	e0bfff17 	ldw	r2,-4(fp)
81132c54:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
81132c58:	0005883a 	mov	r2,zero
}
81132c5c:	e037883a 	mov	sp,fp
81132c60:	dfc00117 	ldw	ra,4(sp)
81132c64:	df000017 	ldw	fp,0(sp)
81132c68:	dec00204 	addi	sp,sp,8
81132c6c:	f800283a 	ret

81132c70 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
81132c70:	defff604 	addi	sp,sp,-40
81132c74:	de00012e 	bgeu	sp,et,81132c7c <OSQPost+0xc>
81132c78:	003b68fa 	trap	3
81132c7c:	dfc00915 	stw	ra,36(sp)
81132c80:	df000815 	stw	fp,32(sp)
81132c84:	df000804 	addi	fp,sp,32
81132c88:	e13ffe15 	stw	r4,-8(fp)
81132c8c:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81132c90:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81132c94:	e0bffe17 	ldw	r2,-8(fp)
81132c98:	1000021e 	bne	r2,zero,81132ca4 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
81132c9c:	00800104 	movi	r2,4
81132ca0:	00004a06 	br	81132dcc <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
81132ca4:	e0bffe17 	ldw	r2,-8(fp)
81132ca8:	10800003 	ldbu	r2,0(r2)
81132cac:	10803fcc 	andi	r2,r2,255
81132cb0:	108000a0 	cmpeqi	r2,r2,2
81132cb4:	1000021e 	bne	r2,zero,81132cc0 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
81132cb8:	00800044 	movi	r2,1
81132cbc:	00004306 	br	81132dcc <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132cc0:	0005303a 	rdctl	r2,status
81132cc4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132cc8:	e0fffd17 	ldw	r3,-12(fp)
81132ccc:	00bfff84 	movi	r2,-2
81132cd0:	1884703a 	and	r2,r3,r2
81132cd4:	1001703a 	wrctl	status,r2
  
  return context;
81132cd8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81132cdc:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
81132ce0:	e0bffe17 	ldw	r2,-8(fp)
81132ce4:	10800283 	ldbu	r2,10(r2)
81132ce8:	10803fcc 	andi	r2,r2,255
81132cec:	10000c26 	beq	r2,zero,81132d20 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81132cf0:	000f883a 	mov	r7,zero
81132cf4:	01800104 	movi	r6,4
81132cf8:	e17fff17 	ldw	r5,-4(fp)
81132cfc:	e13ffe17 	ldw	r4,-8(fp)
81132d00:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
81132d04:	e0bff817 	ldw	r2,-32(fp)
81132d08:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132d0c:	e0bff917 	ldw	r2,-28(fp)
81132d10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
81132d14:	112e8b00 	call	8112e8b0 <OS_Sched>
        return (OS_ERR_NONE);
81132d18:	0005883a 	mov	r2,zero
81132d1c:	00002b06 	br	81132dcc <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
81132d20:	e0bffe17 	ldw	r2,-8(fp)
81132d24:	10800117 	ldw	r2,4(r2)
81132d28:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
81132d2c:	e0bffb17 	ldw	r2,-20(fp)
81132d30:	10c0058b 	ldhu	r3,22(r2)
81132d34:	e0bffb17 	ldw	r2,-20(fp)
81132d38:	1080050b 	ldhu	r2,20(r2)
81132d3c:	18ffffcc 	andi	r3,r3,65535
81132d40:	10bfffcc 	andi	r2,r2,65535
81132d44:	18800636 	bltu	r3,r2,81132d60 <OSQPost+0xf0>
81132d48:	e0bff817 	ldw	r2,-32(fp)
81132d4c:	e0bffa15 	stw	r2,-24(fp)
81132d50:	e0bffa17 	ldw	r2,-24(fp)
81132d54:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81132d58:	00800784 	movi	r2,30
81132d5c:	00001b06 	br	81132dcc <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
81132d60:	e0bffb17 	ldw	r2,-20(fp)
81132d64:	10800317 	ldw	r2,12(r2)
81132d68:	11000104 	addi	r4,r2,4
81132d6c:	e0fffb17 	ldw	r3,-20(fp)
81132d70:	19000315 	stw	r4,12(r3)
81132d74:	e0ffff17 	ldw	r3,-4(fp)
81132d78:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
81132d7c:	e0bffb17 	ldw	r2,-20(fp)
81132d80:	1080058b 	ldhu	r2,22(r2)
81132d84:	10800044 	addi	r2,r2,1
81132d88:	1007883a 	mov	r3,r2
81132d8c:	e0bffb17 	ldw	r2,-20(fp)
81132d90:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
81132d94:	e0bffb17 	ldw	r2,-20(fp)
81132d98:	10c00317 	ldw	r3,12(r2)
81132d9c:	e0bffb17 	ldw	r2,-20(fp)
81132da0:	10800217 	ldw	r2,8(r2)
81132da4:	1880041e 	bne	r3,r2,81132db8 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
81132da8:	e0bffb17 	ldw	r2,-20(fp)
81132dac:	10c00117 	ldw	r3,4(r2)
81132db0:	e0bffb17 	ldw	r2,-20(fp)
81132db4:	10c00315 	stw	r3,12(r2)
81132db8:	e0bff817 	ldw	r2,-32(fp)
81132dbc:	e0bffc15 	stw	r2,-16(fp)
81132dc0:	e0bffc17 	ldw	r2,-16(fp)
81132dc4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81132dc8:	0005883a 	mov	r2,zero
}
81132dcc:	e037883a 	mov	sp,fp
81132dd0:	dfc00117 	ldw	ra,4(sp)
81132dd4:	df000017 	ldw	fp,0(sp)
81132dd8:	dec00204 	addi	sp,sp,8
81132ddc:	f800283a 	ret

81132de0 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
81132de0:	defff604 	addi	sp,sp,-40
81132de4:	de00012e 	bgeu	sp,et,81132dec <OSQPostFront+0xc>
81132de8:	003b68fa 	trap	3
81132dec:	dfc00915 	stw	ra,36(sp)
81132df0:	df000815 	stw	fp,32(sp)
81132df4:	df000804 	addi	fp,sp,32
81132df8:	e13ffe15 	stw	r4,-8(fp)
81132dfc:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81132e00:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81132e04:	e0bffe17 	ldw	r2,-8(fp)
81132e08:	1000021e 	bne	r2,zero,81132e14 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
81132e0c:	00800104 	movi	r2,4
81132e10:	00004c06 	br	81132f44 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81132e14:	e0bffe17 	ldw	r2,-8(fp)
81132e18:	10800003 	ldbu	r2,0(r2)
81132e1c:	10803fcc 	andi	r2,r2,255
81132e20:	108000a0 	cmpeqi	r2,r2,2
81132e24:	1000021e 	bne	r2,zero,81132e30 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
81132e28:	00800044 	movi	r2,1
81132e2c:	00004506 	br	81132f44 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132e30:	0005303a 	rdctl	r2,status
81132e34:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132e38:	e0fffd17 	ldw	r3,-12(fp)
81132e3c:	00bfff84 	movi	r2,-2
81132e40:	1884703a 	and	r2,r3,r2
81132e44:	1001703a 	wrctl	status,r2
  
  return context;
81132e48:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81132e4c:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
81132e50:	e0bffe17 	ldw	r2,-8(fp)
81132e54:	10800283 	ldbu	r2,10(r2)
81132e58:	10803fcc 	andi	r2,r2,255
81132e5c:	10000c26 	beq	r2,zero,81132e90 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81132e60:	000f883a 	mov	r7,zero
81132e64:	01800104 	movi	r6,4
81132e68:	e17fff17 	ldw	r5,-4(fp)
81132e6c:	e13ffe17 	ldw	r4,-8(fp)
81132e70:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
81132e74:	e0bff817 	ldw	r2,-32(fp)
81132e78:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132e7c:	e0bff917 	ldw	r2,-28(fp)
81132e80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
81132e84:	112e8b00 	call	8112e8b0 <OS_Sched>
        return (OS_ERR_NONE);
81132e88:	0005883a 	mov	r2,zero
81132e8c:	00002d06 	br	81132f44 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81132e90:	e0bffe17 	ldw	r2,-8(fp)
81132e94:	10800117 	ldw	r2,4(r2)
81132e98:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81132e9c:	e0bffb17 	ldw	r2,-20(fp)
81132ea0:	10c0058b 	ldhu	r3,22(r2)
81132ea4:	e0bffb17 	ldw	r2,-20(fp)
81132ea8:	1080050b 	ldhu	r2,20(r2)
81132eac:	18ffffcc 	andi	r3,r3,65535
81132eb0:	10bfffcc 	andi	r2,r2,65535
81132eb4:	18800636 	bltu	r3,r2,81132ed0 <OSQPostFront+0xf0>
81132eb8:	e0bff817 	ldw	r2,-32(fp)
81132ebc:	e0bffa15 	stw	r2,-24(fp)
81132ec0:	e0bffa17 	ldw	r2,-24(fp)
81132ec4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81132ec8:	00800784 	movi	r2,30
81132ecc:	00001d06 	br	81132f44 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
81132ed0:	e0bffb17 	ldw	r2,-20(fp)
81132ed4:	10c00417 	ldw	r3,16(r2)
81132ed8:	e0bffb17 	ldw	r2,-20(fp)
81132edc:	10800117 	ldw	r2,4(r2)
81132ee0:	1880041e 	bne	r3,r2,81132ef4 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
81132ee4:	e0bffb17 	ldw	r2,-20(fp)
81132ee8:	10c00217 	ldw	r3,8(r2)
81132eec:	e0bffb17 	ldw	r2,-20(fp)
81132ef0:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
81132ef4:	e0bffb17 	ldw	r2,-20(fp)
81132ef8:	10800417 	ldw	r2,16(r2)
81132efc:	10ffff04 	addi	r3,r2,-4
81132f00:	e0bffb17 	ldw	r2,-20(fp)
81132f04:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
81132f08:	e0bffb17 	ldw	r2,-20(fp)
81132f0c:	10800417 	ldw	r2,16(r2)
81132f10:	e0ffff17 	ldw	r3,-4(fp)
81132f14:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
81132f18:	e0bffb17 	ldw	r2,-20(fp)
81132f1c:	1080058b 	ldhu	r2,22(r2)
81132f20:	10800044 	addi	r2,r2,1
81132f24:	1007883a 	mov	r3,r2
81132f28:	e0bffb17 	ldw	r2,-20(fp)
81132f2c:	10c0058d 	sth	r3,22(r2)
81132f30:	e0bff817 	ldw	r2,-32(fp)
81132f34:	e0bffc15 	stw	r2,-16(fp)
81132f38:	e0bffc17 	ldw	r2,-16(fp)
81132f3c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81132f40:	0005883a 	mov	r2,zero
}
81132f44:	e037883a 	mov	sp,fp
81132f48:	dfc00117 	ldw	ra,4(sp)
81132f4c:	df000017 	ldw	fp,0(sp)
81132f50:	dec00204 	addi	sp,sp,8
81132f54:	f800283a 	ret

81132f58 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
81132f58:	defff504 	addi	sp,sp,-44
81132f5c:	de00012e 	bgeu	sp,et,81132f64 <OSQPostOpt+0xc>
81132f60:	003b68fa 	trap	3
81132f64:	dfc00a15 	stw	ra,40(sp)
81132f68:	df000915 	stw	fp,36(sp)
81132f6c:	df000904 	addi	fp,sp,36
81132f70:	e13ffd15 	stw	r4,-12(fp)
81132f74:	e17ffe15 	stw	r5,-8(fp)
81132f78:	3005883a 	mov	r2,r6
81132f7c:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81132f80:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81132f84:	e0bffd17 	ldw	r2,-12(fp)
81132f88:	1000021e 	bne	r2,zero,81132f94 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
81132f8c:	00800104 	movi	r2,4
81132f90:	00007106 	br	81133158 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81132f94:	e0bffd17 	ldw	r2,-12(fp)
81132f98:	10800003 	ldbu	r2,0(r2)
81132f9c:	10803fcc 	andi	r2,r2,255
81132fa0:	108000a0 	cmpeqi	r2,r2,2
81132fa4:	1000021e 	bne	r2,zero,81132fb0 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
81132fa8:	00800044 	movi	r2,1
81132fac:	00006a06 	br	81133158 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132fb0:	0005303a 	rdctl	r2,status
81132fb4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132fb8:	e0fffc17 	ldw	r3,-16(fp)
81132fbc:	00bfff84 	movi	r2,-2
81132fc0:	1884703a 	and	r2,r3,r2
81132fc4:	1001703a 	wrctl	status,r2
  
  return context;
81132fc8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81132fcc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
81132fd0:	e0bffd17 	ldw	r2,-12(fp)
81132fd4:	10800283 	ldbu	r2,10(r2)
81132fd8:	10803fcc 	andi	r2,r2,255
81132fdc:	10001d26 	beq	r2,zero,81133054 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
81132fe0:	e0bfff03 	ldbu	r2,-4(fp)
81132fe4:	1080004c 	andi	r2,r2,1
81132fe8:	10000b26 	beq	r2,zero,81133018 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81132fec:	00000506 	br	81133004 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81132ff0:	000f883a 	mov	r7,zero
81132ff4:	01800104 	movi	r6,4
81132ff8:	e17ffe17 	ldw	r5,-8(fp)
81132ffc:	e13ffd17 	ldw	r4,-12(fp)
81133000:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81133004:	e0bffd17 	ldw	r2,-12(fp)
81133008:	10800283 	ldbu	r2,10(r2)
8113300c:	10803fcc 	andi	r2,r2,255
81133010:	103ff71e 	bne	r2,zero,81132ff0 <__reset+0xfb112ff0>
81133014:	00000506 	br	8113302c <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81133018:	000f883a 	mov	r7,zero
8113301c:	01800104 	movi	r6,4
81133020:	e17ffe17 	ldw	r5,-8(fp)
81133024:	e13ffd17 	ldw	r4,-12(fp)
81133028:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
8113302c:	e0bff717 	ldw	r2,-36(fp)
81133030:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133034:	e0bff817 	ldw	r2,-32(fp)
81133038:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8113303c:	e0bfff03 	ldbu	r2,-4(fp)
81133040:	1080010c 	andi	r2,r2,4
81133044:	1000011e 	bne	r2,zero,8113304c <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
81133048:	112e8b00 	call	8112e8b0 <OS_Sched>
        }
        return (OS_ERR_NONE);
8113304c:	0005883a 	mov	r2,zero
81133050:	00004106 	br	81133158 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81133054:	e0bffd17 	ldw	r2,-12(fp)
81133058:	10800117 	ldw	r2,4(r2)
8113305c:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81133060:	e0bffa17 	ldw	r2,-24(fp)
81133064:	10c0058b 	ldhu	r3,22(r2)
81133068:	e0bffa17 	ldw	r2,-24(fp)
8113306c:	1080050b 	ldhu	r2,20(r2)
81133070:	18ffffcc 	andi	r3,r3,65535
81133074:	10bfffcc 	andi	r2,r2,65535
81133078:	18800636 	bltu	r3,r2,81133094 <OSQPostOpt+0x13c>
8113307c:	e0bff717 	ldw	r2,-36(fp)
81133080:	e0bff915 	stw	r2,-28(fp)
81133084:	e0bff917 	ldw	r2,-28(fp)
81133088:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113308c:	00800784 	movi	r2,30
81133090:	00003106 	br	81133158 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
81133094:	e0bfff03 	ldbu	r2,-4(fp)
81133098:	1080008c 	andi	r2,r2,2
8113309c:	10001326 	beq	r2,zero,811330ec <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
811330a0:	e0bffa17 	ldw	r2,-24(fp)
811330a4:	10c00417 	ldw	r3,16(r2)
811330a8:	e0bffa17 	ldw	r2,-24(fp)
811330ac:	10800117 	ldw	r2,4(r2)
811330b0:	1880041e 	bne	r3,r2,811330c4 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
811330b4:	e0bffa17 	ldw	r2,-24(fp)
811330b8:	10c00217 	ldw	r3,8(r2)
811330bc:	e0bffa17 	ldw	r2,-24(fp)
811330c0:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
811330c4:	e0bffa17 	ldw	r2,-24(fp)
811330c8:	10800417 	ldw	r2,16(r2)
811330cc:	10ffff04 	addi	r3,r2,-4
811330d0:	e0bffa17 	ldw	r2,-24(fp)
811330d4:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
811330d8:	e0bffa17 	ldw	r2,-24(fp)
811330dc:	10800417 	ldw	r2,16(r2)
811330e0:	e0fffe17 	ldw	r3,-8(fp)
811330e4:	10c00015 	stw	r3,0(r2)
811330e8:	00001006 	br	8113312c <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
811330ec:	e0bffa17 	ldw	r2,-24(fp)
811330f0:	10800317 	ldw	r2,12(r2)
811330f4:	11000104 	addi	r4,r2,4
811330f8:	e0fffa17 	ldw	r3,-24(fp)
811330fc:	19000315 	stw	r4,12(r3)
81133100:	e0fffe17 	ldw	r3,-8(fp)
81133104:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
81133108:	e0bffa17 	ldw	r2,-24(fp)
8113310c:	10c00317 	ldw	r3,12(r2)
81133110:	e0bffa17 	ldw	r2,-24(fp)
81133114:	10800217 	ldw	r2,8(r2)
81133118:	1880041e 	bne	r3,r2,8113312c <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8113311c:	e0bffa17 	ldw	r2,-24(fp)
81133120:	10c00117 	ldw	r3,4(r2)
81133124:	e0bffa17 	ldw	r2,-24(fp)
81133128:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113312c:	e0bffa17 	ldw	r2,-24(fp)
81133130:	1080058b 	ldhu	r2,22(r2)
81133134:	10800044 	addi	r2,r2,1
81133138:	1007883a 	mov	r3,r2
8113313c:	e0bffa17 	ldw	r2,-24(fp)
81133140:	10c0058d 	sth	r3,22(r2)
81133144:	e0bff717 	ldw	r2,-36(fp)
81133148:	e0bffb15 	stw	r2,-20(fp)
8113314c:	e0bffb17 	ldw	r2,-20(fp)
81133150:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81133154:	0005883a 	mov	r2,zero
}
81133158:	e037883a 	mov	sp,fp
8113315c:	dfc00117 	ldw	ra,4(sp)
81133160:	df000017 	ldw	fp,0(sp)
81133164:	dec00204 	addi	sp,sp,8
81133168:	f800283a 	ret

8113316c <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8113316c:	defff604 	addi	sp,sp,-40
81133170:	de00012e 	bgeu	sp,et,81133178 <OSQQuery+0xc>
81133174:	003b68fa 	trap	3
81133178:	df000915 	stw	fp,36(sp)
8113317c:	df000904 	addi	fp,sp,36
81133180:	e13ffe15 	stw	r4,-8(fp)
81133184:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81133188:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113318c:	e0bffe17 	ldw	r2,-8(fp)
81133190:	1000021e 	bne	r2,zero,8113319c <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81133194:	00800104 	movi	r2,4
81133198:	00004906 	br	811332c0 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8113319c:	e0bfff17 	ldw	r2,-4(fp)
811331a0:	1000021e 	bne	r2,zero,811331ac <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
811331a4:	00800244 	movi	r2,9
811331a8:	00004506 	br	811332c0 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
811331ac:	e0bffe17 	ldw	r2,-8(fp)
811331b0:	10800003 	ldbu	r2,0(r2)
811331b4:	10803fcc 	andi	r2,r2,255
811331b8:	108000a0 	cmpeqi	r2,r2,2
811331bc:	1000021e 	bne	r2,zero,811331c8 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
811331c0:	00800044 	movi	r2,1
811331c4:	00003e06 	br	811332c0 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811331c8:	0005303a 	rdctl	r2,status
811331cc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811331d0:	e0fffd17 	ldw	r3,-12(fp)
811331d4:	00bfff84 	movi	r2,-2
811331d8:	1884703a 	and	r2,r3,r2
811331dc:	1001703a 	wrctl	status,r2
  
  return context;
811331e0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811331e4:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
811331e8:	e0bffe17 	ldw	r2,-8(fp)
811331ec:	10c00283 	ldbu	r3,10(r2)
811331f0:	e0bfff17 	ldw	r2,-4(fp)
811331f4:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
811331f8:	e0bffe17 	ldw	r2,-8(fp)
811331fc:	108002c4 	addi	r2,r2,11
81133200:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
81133204:	e0bfff17 	ldw	r2,-4(fp)
81133208:	10800204 	addi	r2,r2,8
8113320c:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81133210:	e03ff705 	stb	zero,-36(fp)
81133214:	00000b06 	br	81133244 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
81133218:	e0bff917 	ldw	r2,-28(fp)
8113321c:	10c00044 	addi	r3,r2,1
81133220:	e0fff915 	stw	r3,-28(fp)
81133224:	e0fff817 	ldw	r3,-32(fp)
81133228:	19000044 	addi	r4,r3,1
8113322c:	e13ff815 	stw	r4,-32(fp)
81133230:	18c00003 	ldbu	r3,0(r3)
81133234:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81133238:	e0bff703 	ldbu	r2,-36(fp)
8113323c:	10800044 	addi	r2,r2,1
81133240:	e0bff705 	stb	r2,-36(fp)
81133244:	e0bff703 	ldbu	r2,-36(fp)
81133248:	108001b0 	cmpltui	r2,r2,6
8113324c:	103ff21e 	bne	r2,zero,81133218 <__reset+0xfb113218>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
81133250:	e0bffe17 	ldw	r2,-8(fp)
81133254:	10800117 	ldw	r2,4(r2)
81133258:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8113325c:	e0bffc17 	ldw	r2,-16(fp)
81133260:	1080058b 	ldhu	r2,22(r2)
81133264:	10bfffcc 	andi	r2,r2,65535
81133268:	10000626 	beq	r2,zero,81133284 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8113326c:	e0bffc17 	ldw	r2,-16(fp)
81133270:	10800417 	ldw	r2,16(r2)
81133274:	10c00017 	ldw	r3,0(r2)
81133278:	e0bfff17 	ldw	r2,-4(fp)
8113327c:	10c00015 	stw	r3,0(r2)
81133280:	00000206 	br	8113328c <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
81133284:	e0bfff17 	ldw	r2,-4(fp)
81133288:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8113328c:	e0bffc17 	ldw	r2,-16(fp)
81133290:	10c0058b 	ldhu	r3,22(r2)
81133294:	e0bfff17 	ldw	r2,-4(fp)
81133298:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8113329c:	e0bffc17 	ldw	r2,-16(fp)
811332a0:	10c0050b 	ldhu	r3,20(r2)
811332a4:	e0bfff17 	ldw	r2,-4(fp)
811332a8:	10c0018d 	sth	r3,6(r2)
811332ac:	e0bffa17 	ldw	r2,-24(fp)
811332b0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811332b4:	e0bffb17 	ldw	r2,-20(fp)
811332b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811332bc:	0005883a 	mov	r2,zero
}
811332c0:	e037883a 	mov	sp,fp
811332c4:	df000017 	ldw	fp,0(sp)
811332c8:	dec00104 	addi	sp,sp,4
811332cc:	f800283a 	ret

811332d0 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
811332d0:	defffb04 	addi	sp,sp,-20
811332d4:	de00012e 	bgeu	sp,et,811332dc <OS_QInit+0xc>
811332d8:	003b68fa 	trap	3
811332dc:	dfc00415 	stw	ra,16(sp)
811332e0:	df000315 	stw	fp,12(sp)
811332e4:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
811332e8:	01406004 	movi	r5,384
811332ec:	012045b4 	movhi	r4,33046
811332f0:	21327c04 	addi	r4,r4,-13840
811332f4:	112e7e40 	call	8112e7e4 <OS_MemClr>
    pq1 = &OSQTbl[0];
811332f8:	00a045b4 	movhi	r2,33046
811332fc:	10b27c04 	addi	r2,r2,-13840
81133300:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
81133304:	00a045b4 	movhi	r2,33046
81133308:	10b28204 	addi	r2,r2,-13816
8113330c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
81133310:	e03ffd0d 	sth	zero,-12(fp)
81133314:	00000c06 	br	81133348 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
81133318:	e0bffe17 	ldw	r2,-8(fp)
8113331c:	e0ffff17 	ldw	r3,-4(fp)
81133320:	10c00015 	stw	r3,0(r2)
        pq1++;
81133324:	e0bffe17 	ldw	r2,-8(fp)
81133328:	10800604 	addi	r2,r2,24
8113332c:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
81133330:	e0bfff17 	ldw	r2,-4(fp)
81133334:	10800604 	addi	r2,r2,24
81133338:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113333c:	e0bffd0b 	ldhu	r2,-12(fp)
81133340:	10800044 	addi	r2,r2,1
81133344:	e0bffd0d 	sth	r2,-12(fp)
81133348:	e0bffd0b 	ldhu	r2,-12(fp)
8113334c:	108003f0 	cmpltui	r2,r2,15
81133350:	103ff11e 	bne	r2,zero,81133318 <__reset+0xfb113318>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
81133354:	e0bffe17 	ldw	r2,-8(fp)
81133358:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8113335c:	00a045b4 	movhi	r2,33046
81133360:	10b27c04 	addi	r2,r2,-13840
81133364:	d0a08d15 	stw	r2,-32204(gp)
#endif
}
81133368:	0001883a 	nop
8113336c:	e037883a 	mov	sp,fp
81133370:	dfc00117 	ldw	ra,4(sp)
81133374:	df000017 	ldw	fp,0(sp)
81133378:	dec00204 	addi	sp,sp,8
8113337c:	f800283a 	ret

81133380 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
81133380:	defffa04 	addi	sp,sp,-24
81133384:	de00012e 	bgeu	sp,et,8113338c <OSSemAccept+0xc>
81133388:	003b68fa 	trap	3
8113338c:	df000515 	stw	fp,20(sp)
81133390:	df000504 	addi	fp,sp,20
81133394:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81133398:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113339c:	e0bfff17 	ldw	r2,-4(fp)
811333a0:	1000021e 	bne	r2,zero,811333ac <OSSemAccept+0x2c>
        return (0);
811333a4:	0005883a 	mov	r2,zero
811333a8:	00001f06 	br	81133428 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811333ac:	e0bfff17 	ldw	r2,-4(fp)
811333b0:	10800003 	ldbu	r2,0(r2)
811333b4:	10803fcc 	andi	r2,r2,255
811333b8:	108000e0 	cmpeqi	r2,r2,3
811333bc:	1000021e 	bne	r2,zero,811333c8 <OSSemAccept+0x48>
        return (0);
811333c0:	0005883a 	mov	r2,zero
811333c4:	00001806 	br	81133428 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811333c8:	0005303a 	rdctl	r2,status
811333cc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811333d0:	e0fffe17 	ldw	r3,-8(fp)
811333d4:	00bfff84 	movi	r2,-2
811333d8:	1884703a 	and	r2,r3,r2
811333dc:	1001703a 	wrctl	status,r2
  
  return context;
811333e0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811333e4:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
811333e8:	e0bfff17 	ldw	r2,-4(fp)
811333ec:	1080020b 	ldhu	r2,8(r2)
811333f0:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
811333f4:	e0bffd0b 	ldhu	r2,-12(fp)
811333f8:	10000626 	beq	r2,zero,81133414 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
811333fc:	e0bfff17 	ldw	r2,-4(fp)
81133400:	1080020b 	ldhu	r2,8(r2)
81133404:	10bfffc4 	addi	r2,r2,-1
81133408:	1007883a 	mov	r3,r2
8113340c:	e0bfff17 	ldw	r2,-4(fp)
81133410:	10c0020d 	sth	r3,8(r2)
81133414:	e0bffb17 	ldw	r2,-20(fp)
81133418:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113341c:	e0bffc17 	ldw	r2,-16(fp)
81133420:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
81133424:	e0bffd0b 	ldhu	r2,-12(fp)
}
81133428:	e037883a 	mov	sp,fp
8113342c:	df000017 	ldw	fp,0(sp)
81133430:	dec00104 	addi	sp,sp,4
81133434:	f800283a 	ret

81133438 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
81133438:	defff904 	addi	sp,sp,-28
8113343c:	de00012e 	bgeu	sp,et,81133444 <OSSemCreate+0xc>
81133440:	003b68fa 	trap	3
81133444:	dfc00615 	stw	ra,24(sp)
81133448:	df000515 	stw	fp,20(sp)
8113344c:	df000504 	addi	fp,sp,20
81133450:	2005883a 	mov	r2,r4
81133454:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81133458:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113345c:	d0a09103 	ldbu	r2,-32188(gp)
81133460:	10803fcc 	andi	r2,r2,255
81133464:	10000226 	beq	r2,zero,81133470 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
81133468:	0005883a 	mov	r2,zero
8113346c:	00002506 	br	81133504 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133470:	0005303a 	rdctl	r2,status
81133474:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133478:	e0fffe17 	ldw	r3,-8(fp)
8113347c:	00bfff84 	movi	r2,-2
81133480:	1884703a 	and	r2,r3,r2
81133484:	1001703a 	wrctl	status,r2
  
  return context;
81133488:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113348c:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
81133490:	d0a09017 	ldw	r2,-32192(gp)
81133494:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
81133498:	d0a09017 	ldw	r2,-32192(gp)
8113349c:	10000326 	beq	r2,zero,811334ac <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
811334a0:	d0a09017 	ldw	r2,-32192(gp)
811334a4:	10800117 	ldw	r2,4(r2)
811334a8:	d0a09015 	stw	r2,-32192(gp)
811334ac:	e0bffb17 	ldw	r2,-20(fp)
811334b0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811334b4:	e0bffc17 	ldw	r2,-16(fp)
811334b8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
811334bc:	e0bffd17 	ldw	r2,-12(fp)
811334c0:	10000f26 	beq	r2,zero,81133500 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
811334c4:	e0bffd17 	ldw	r2,-12(fp)
811334c8:	00c000c4 	movi	r3,3
811334cc:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
811334d0:	e0bffd17 	ldw	r2,-12(fp)
811334d4:	e0ffff0b 	ldhu	r3,-4(fp)
811334d8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
811334dc:	e0bffd17 	ldw	r2,-12(fp)
811334e0:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
811334e4:	e0bffd17 	ldw	r2,-12(fp)
811334e8:	00c00fc4 	movi	r3,63
811334ec:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
811334f0:	e0bffd17 	ldw	r2,-12(fp)
811334f4:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
811334f8:	e13ffd17 	ldw	r4,-12(fp)
811334fc:	112e3cc0 	call	8112e3cc <OS_EventWaitListInit>
    }
    return (pevent);
81133500:	e0bffd17 	ldw	r2,-12(fp)
}
81133504:	e037883a 	mov	sp,fp
81133508:	dfc00117 	ldw	ra,4(sp)
8113350c:	df000017 	ldw	fp,0(sp)
81133510:	dec00204 	addi	sp,sp,8
81133514:	f800283a 	ret

81133518 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81133518:	defff304 	addi	sp,sp,-52
8113351c:	de00012e 	bgeu	sp,et,81133524 <OSSemDel+0xc>
81133520:	003b68fa 	trap	3
81133524:	dfc00c15 	stw	ra,48(sp)
81133528:	df000b15 	stw	fp,44(sp)
8113352c:	df000b04 	addi	fp,sp,44
81133530:	e13ffd15 	stw	r4,-12(fp)
81133534:	2805883a 	mov	r2,r5
81133538:	e1bfff15 	stw	r6,-4(fp)
8113353c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81133540:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81133544:	e0bfff17 	ldw	r2,-4(fp)
81133548:	1000021e 	bne	r2,zero,81133554 <OSSemDel+0x3c>
        return (pevent);
8113354c:	e0bffd17 	ldw	r2,-12(fp)
81133550:	00007e06 	br	8113374c <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81133554:	e0bffd17 	ldw	r2,-12(fp)
81133558:	1000051e 	bne	r2,zero,81133570 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113355c:	e0bfff17 	ldw	r2,-4(fp)
81133560:	00c00104 	movi	r3,4
81133564:	10c00005 	stb	r3,0(r2)
        return (pevent);
81133568:	e0bffd17 	ldw	r2,-12(fp)
8113356c:	00007706 	br	8113374c <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
81133570:	e0bffd17 	ldw	r2,-12(fp)
81133574:	10800003 	ldbu	r2,0(r2)
81133578:	10803fcc 	andi	r2,r2,255
8113357c:	108000e0 	cmpeqi	r2,r2,3
81133580:	1000051e 	bne	r2,zero,81133598 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81133584:	e0bfff17 	ldw	r2,-4(fp)
81133588:	00c00044 	movi	r3,1
8113358c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81133590:	e0bffd17 	ldw	r2,-12(fp)
81133594:	00006d06 	br	8113374c <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81133598:	d0a09103 	ldbu	r2,-32188(gp)
8113359c:	10803fcc 	andi	r2,r2,255
811335a0:	10000526 	beq	r2,zero,811335b8 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
811335a4:	e0bfff17 	ldw	r2,-4(fp)
811335a8:	00c003c4 	movi	r3,15
811335ac:	10c00005 	stb	r3,0(r2)
        return (pevent);
811335b0:	e0bffd17 	ldw	r2,-12(fp)
811335b4:	00006506 	br	8113374c <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811335b8:	0005303a 	rdctl	r2,status
811335bc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811335c0:	e0fffc17 	ldw	r3,-16(fp)
811335c4:	00bfff84 	movi	r2,-2
811335c8:	1884703a 	and	r2,r3,r2
811335cc:	1001703a 	wrctl	status,r2
  
  return context;
811335d0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811335d4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
811335d8:	e0bffd17 	ldw	r2,-12(fp)
811335dc:	10800283 	ldbu	r2,10(r2)
811335e0:	10803fcc 	andi	r2,r2,255
811335e4:	10000326 	beq	r2,zero,811335f4 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811335e8:	00800044 	movi	r2,1
811335ec:	e0bff505 	stb	r2,-44(fp)
811335f0:	00000106 	br	811335f8 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811335f4:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
811335f8:	e0bffe03 	ldbu	r2,-8(fp)
811335fc:	10000326 	beq	r2,zero,8113360c <OSSemDel+0xf4>
81133600:	10800060 	cmpeqi	r2,r2,1
81133604:	1000281e 	bne	r2,zero,811336a8 <OSSemDel+0x190>
81133608:	00004506 	br	81133720 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113360c:	e0bff503 	ldbu	r2,-44(fp)
81133610:	1000161e 	bne	r2,zero,8113366c <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81133614:	e0bffd17 	ldw	r2,-12(fp)
81133618:	00c00fc4 	movi	r3,63
8113361c:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81133620:	e0bffd17 	ldw	r2,-12(fp)
81133624:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81133628:	e0bffd17 	ldw	r2,-12(fp)
8113362c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
81133630:	d0e09017 	ldw	r3,-32192(gp)
81133634:	e0bffd17 	ldw	r2,-12(fp)
81133638:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113363c:	e0bffd17 	ldw	r2,-12(fp)
81133640:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81133644:	e0bffd17 	ldw	r2,-12(fp)
81133648:	d0a09015 	stw	r2,-32192(gp)
8113364c:	e0bff717 	ldw	r2,-36(fp)
81133650:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133654:	e0bff817 	ldw	r2,-32(fp)
81133658:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113365c:	e0bfff17 	ldw	r2,-4(fp)
81133660:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
81133664:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81133668:	00003706 	br	81133748 <OSSemDel+0x230>
8113366c:	e0bff717 	ldw	r2,-36(fp)
81133670:	e0bff915 	stw	r2,-28(fp)
81133674:	e0bff917 	ldw	r2,-28(fp)
81133678:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113367c:	e0bfff17 	ldw	r2,-4(fp)
81133680:	00c01244 	movi	r3,73
81133684:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81133688:	e0bffd17 	ldw	r2,-12(fp)
8113368c:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81133690:	00002d06 	br	81133748 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81133694:	000f883a 	mov	r7,zero
81133698:	01800044 	movi	r6,1
8113369c:	000b883a 	mov	r5,zero
811336a0:	e13ffd17 	ldw	r4,-12(fp)
811336a4:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
811336a8:	e0bffd17 	ldw	r2,-12(fp)
811336ac:	10800283 	ldbu	r2,10(r2)
811336b0:	10803fcc 	andi	r2,r2,255
811336b4:	103ff71e 	bne	r2,zero,81133694 <__reset+0xfb113694>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
811336b8:	e0bffd17 	ldw	r2,-12(fp)
811336bc:	00c00fc4 	movi	r3,63
811336c0:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
811336c4:	e0bffd17 	ldw	r2,-12(fp)
811336c8:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
811336cc:	e0bffd17 	ldw	r2,-12(fp)
811336d0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
811336d4:	d0e09017 	ldw	r3,-32192(gp)
811336d8:	e0bffd17 	ldw	r2,-12(fp)
811336dc:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
811336e0:	e0bffd17 	ldw	r2,-12(fp)
811336e4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
811336e8:	e0bffd17 	ldw	r2,-12(fp)
811336ec:	d0a09015 	stw	r2,-32192(gp)
811336f0:	e0bff717 	ldw	r2,-36(fp)
811336f4:	e0bffa15 	stw	r2,-24(fp)
811336f8:	e0bffa17 	ldw	r2,-24(fp)
811336fc:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81133700:	e0bff503 	ldbu	r2,-44(fp)
81133704:	10800058 	cmpnei	r2,r2,1
81133708:	1000011e 	bne	r2,zero,81133710 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113370c:	112e8b00 	call	8112e8b0 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81133710:	e0bfff17 	ldw	r2,-4(fp)
81133714:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
81133718:	e03ff615 	stw	zero,-40(fp)
             break;
8113371c:	00000a06 	br	81133748 <OSSemDel+0x230>
81133720:	e0bff717 	ldw	r2,-36(fp)
81133724:	e0bffb15 	stw	r2,-20(fp)
81133728:	e0bffb17 	ldw	r2,-20(fp)
8113372c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81133730:	e0bfff17 	ldw	r2,-4(fp)
81133734:	00c001c4 	movi	r3,7
81133738:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113373c:	e0bffd17 	ldw	r2,-12(fp)
81133740:	e0bff615 	stw	r2,-40(fp)
             break;
81133744:	0001883a 	nop
    }
    return (pevent_return);
81133748:	e0bff617 	ldw	r2,-40(fp)
}
8113374c:	e037883a 	mov	sp,fp
81133750:	dfc00117 	ldw	ra,4(sp)
81133754:	df000017 	ldw	fp,0(sp)
81133758:	dec00204 	addi	sp,sp,8
8113375c:	f800283a 	ret

81133760 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81133760:	defff504 	addi	sp,sp,-44
81133764:	de00012e 	bgeu	sp,et,8113376c <OSSemPend+0xc>
81133768:	003b68fa 	trap	3
8113376c:	dfc00a15 	stw	ra,40(sp)
81133770:	df000915 	stw	fp,36(sp)
81133774:	df000904 	addi	fp,sp,36
81133778:	e13ffd15 	stw	r4,-12(fp)
8113377c:	2805883a 	mov	r2,r5
81133780:	e1bfff15 	stw	r6,-4(fp)
81133784:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81133788:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113378c:	e0bfff17 	ldw	r2,-4(fp)
81133790:	10007226 	beq	r2,zero,8113395c <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81133794:	e0bffd17 	ldw	r2,-12(fp)
81133798:	1000041e 	bne	r2,zero,811337ac <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113379c:	e0bfff17 	ldw	r2,-4(fp)
811337a0:	00c00104 	movi	r3,4
811337a4:	10c00005 	stb	r3,0(r2)
        return;
811337a8:	00006d06 	br	81133960 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811337ac:	e0bffd17 	ldw	r2,-12(fp)
811337b0:	10800003 	ldbu	r2,0(r2)
811337b4:	10803fcc 	andi	r2,r2,255
811337b8:	108000e0 	cmpeqi	r2,r2,3
811337bc:	1000041e 	bne	r2,zero,811337d0 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
811337c0:	e0bfff17 	ldw	r2,-4(fp)
811337c4:	00c00044 	movi	r3,1
811337c8:	10c00005 	stb	r3,0(r2)
        return;
811337cc:	00006406 	br	81133960 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
811337d0:	d0a09103 	ldbu	r2,-32188(gp)
811337d4:	10803fcc 	andi	r2,r2,255
811337d8:	10000426 	beq	r2,zero,811337ec <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
811337dc:	e0bfff17 	ldw	r2,-4(fp)
811337e0:	00c00084 	movi	r3,2
811337e4:	10c00005 	stb	r3,0(r2)
        return;
811337e8:	00005d06 	br	81133960 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
811337ec:	d0a07f03 	ldbu	r2,-32260(gp)
811337f0:	10803fcc 	andi	r2,r2,255
811337f4:	10000426 	beq	r2,zero,81133808 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
811337f8:	e0bfff17 	ldw	r2,-4(fp)
811337fc:	00c00344 	movi	r3,13
81133800:	10c00005 	stb	r3,0(r2)
        return;
81133804:	00005606 	br	81133960 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133808:	0005303a 	rdctl	r2,status
8113380c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133810:	e0fffc17 	ldw	r3,-16(fp)
81133814:	00bfff84 	movi	r2,-2
81133818:	1884703a 	and	r2,r3,r2
8113381c:	1001703a 	wrctl	status,r2
  
  return context;
81133820:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81133824:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
81133828:	e0bffd17 	ldw	r2,-12(fp)
8113382c:	1080020b 	ldhu	r2,8(r2)
81133830:	10bfffcc 	andi	r2,r2,65535
81133834:	10000d26 	beq	r2,zero,8113386c <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
81133838:	e0bffd17 	ldw	r2,-12(fp)
8113383c:	1080020b 	ldhu	r2,8(r2)
81133840:	10bfffc4 	addi	r2,r2,-1
81133844:	1007883a 	mov	r3,r2
81133848:	e0bffd17 	ldw	r2,-12(fp)
8113384c:	10c0020d 	sth	r3,8(r2)
81133850:	e0bff717 	ldw	r2,-36(fp)
81133854:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133858:	e0bff817 	ldw	r2,-32(fp)
8113385c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81133860:	e0bfff17 	ldw	r2,-4(fp)
81133864:	10000005 	stb	zero,0(r2)
        return;
81133868:	00003d06 	br	81133960 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113386c:	d0a09217 	ldw	r2,-32184(gp)
81133870:	d0e09217 	ldw	r3,-32184(gp)
81133874:	18c00c03 	ldbu	r3,48(r3)
81133878:	18c00054 	ori	r3,r3,1
8113387c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81133880:	d0a09217 	ldw	r2,-32184(gp)
81133884:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
81133888:	d0a09217 	ldw	r2,-32184(gp)
8113388c:	e0fffe0b 	ldhu	r3,-8(fp)
81133890:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81133894:	e13ffd17 	ldw	r4,-12(fp)
81133898:	112df940 	call	8112df94 <OS_EventTaskWait>
8113389c:	e0bff717 	ldw	r2,-36(fp)
811338a0:	e0bffb15 	stw	r2,-20(fp)
811338a4:	e0bffb17 	ldw	r2,-20(fp)
811338a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
811338ac:	112e8b00 	call	8112e8b0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811338b0:	0005303a 	rdctl	r2,status
811338b4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811338b8:	e0fff917 	ldw	r3,-28(fp)
811338bc:	00bfff84 	movi	r2,-2
811338c0:	1884703a 	and	r2,r3,r2
811338c4:	1001703a 	wrctl	status,r2
  
  return context;
811338c8:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
811338cc:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
811338d0:	d0a09217 	ldw	r2,-32184(gp)
811338d4:	10800c43 	ldbu	r2,49(r2)
811338d8:	10803fcc 	andi	r2,r2,255
811338dc:	10000326 	beq	r2,zero,811338ec <OSSemPend+0x18c>
811338e0:	108000a0 	cmpeqi	r2,r2,2
811338e4:	1000041e 	bne	r2,zero,811338f8 <OSSemPend+0x198>
811338e8:	00000706 	br	81133908 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
811338ec:	e0bfff17 	ldw	r2,-4(fp)
811338f0:	10000005 	stb	zero,0(r2)
             break;
811338f4:	00000c06 	br	81133928 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
811338f8:	e0bfff17 	ldw	r2,-4(fp)
811338fc:	00c00384 	movi	r3,14
81133900:	10c00005 	stb	r3,0(r2)
             break;
81133904:	00000806 	br	81133928 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
81133908:	d0a09217 	ldw	r2,-32184(gp)
8113390c:	e17ffd17 	ldw	r5,-12(fp)
81133910:	1009883a 	mov	r4,r2
81133914:	112e2040 	call	8112e204 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81133918:	e0bfff17 	ldw	r2,-4(fp)
8113391c:	00c00284 	movi	r3,10
81133920:	10c00005 	stb	r3,0(r2)
             break;
81133924:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81133928:	d0a09217 	ldw	r2,-32184(gp)
8113392c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81133930:	d0a09217 	ldw	r2,-32184(gp)
81133934:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81133938:	d0a09217 	ldw	r2,-32184(gp)
8113393c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81133940:	d0a09217 	ldw	r2,-32184(gp)
81133944:	10000815 	stw	zero,32(r2)
81133948:	e0bff717 	ldw	r2,-36(fp)
8113394c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133950:	e0bffa17 	ldw	r2,-24(fp)
81133954:	1001703a 	wrctl	status,r2
81133958:	00000106 	br	81133960 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113395c:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81133960:	e037883a 	mov	sp,fp
81133964:	dfc00117 	ldw	ra,4(sp)
81133968:	df000017 	ldw	fp,0(sp)
8113396c:	dec00204 	addi	sp,sp,8
81133970:	f800283a 	ret

81133974 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81133974:	defff604 	addi	sp,sp,-40
81133978:	de00012e 	bgeu	sp,et,81133980 <OSSemPendAbort+0xc>
8113397c:	003b68fa 	trap	3
81133980:	dfc00915 	stw	ra,36(sp)
81133984:	df000815 	stw	fp,32(sp)
81133988:	df000804 	addi	fp,sp,32
8113398c:	e13ffd15 	stw	r4,-12(fp)
81133990:	2805883a 	mov	r2,r5
81133994:	e1bfff15 	stw	r6,-4(fp)
81133998:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113399c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
811339a0:	e0bfff17 	ldw	r2,-4(fp)
811339a4:	1000021e 	bne	r2,zero,811339b0 <OSSemPendAbort+0x3c>
        return (0);
811339a8:	0005883a 	mov	r2,zero
811339ac:	00004906 	br	81133ad4 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811339b0:	e0bffd17 	ldw	r2,-12(fp)
811339b4:	1000051e 	bne	r2,zero,811339cc <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811339b8:	e0bfff17 	ldw	r2,-4(fp)
811339bc:	00c00104 	movi	r3,4
811339c0:	10c00005 	stb	r3,0(r2)
        return (0);
811339c4:	0005883a 	mov	r2,zero
811339c8:	00004206 	br	81133ad4 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811339cc:	e0bffd17 	ldw	r2,-12(fp)
811339d0:	10800003 	ldbu	r2,0(r2)
811339d4:	10803fcc 	andi	r2,r2,255
811339d8:	108000e0 	cmpeqi	r2,r2,3
811339dc:	1000051e 	bne	r2,zero,811339f4 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811339e0:	e0bfff17 	ldw	r2,-4(fp)
811339e4:	00c00044 	movi	r3,1
811339e8:	10c00005 	stb	r3,0(r2)
        return (0);
811339ec:	0005883a 	mov	r2,zero
811339f0:	00003806 	br	81133ad4 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811339f4:	0005303a 	rdctl	r2,status
811339f8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811339fc:	e0fffc17 	ldw	r3,-16(fp)
81133a00:	00bfff84 	movi	r2,-2
81133a04:	1884703a 	and	r2,r3,r2
81133a08:	1001703a 	wrctl	status,r2
  
  return context;
81133a0c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81133a10:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
81133a14:	e0bffd17 	ldw	r2,-12(fp)
81133a18:	10800283 	ldbu	r2,10(r2)
81133a1c:	10803fcc 	andi	r2,r2,255
81133a20:	10002526 	beq	r2,zero,81133ab8 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
81133a24:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81133a28:	e0bffe03 	ldbu	r2,-8(fp)
81133a2c:	10800060 	cmpeqi	r2,r2,1
81133a30:	10000e26 	beq	r2,zero,81133a6c <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81133a34:	00000806 	br	81133a58 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81133a38:	01c00084 	movi	r7,2
81133a3c:	01800044 	movi	r6,1
81133a40:	000b883a 	mov	r5,zero
81133a44:	e13ffd17 	ldw	r4,-12(fp)
81133a48:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
                     nbr_tasks++;
81133a4c:	e0bff803 	ldbu	r2,-32(fp)
81133a50:	10800044 	addi	r2,r2,1
81133a54:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81133a58:	e0bffd17 	ldw	r2,-12(fp)
81133a5c:	10800283 	ldbu	r2,10(r2)
81133a60:	10803fcc 	andi	r2,r2,255
81133a64:	103ff41e 	bne	r2,zero,81133a38 <__reset+0xfb113a38>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81133a68:	00000906 	br	81133a90 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81133a6c:	01c00084 	movi	r7,2
81133a70:	01800044 	movi	r6,1
81133a74:	000b883a 	mov	r5,zero
81133a78:	e13ffd17 	ldw	r4,-12(fp)
81133a7c:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
                 nbr_tasks++;
81133a80:	e0bff803 	ldbu	r2,-32(fp)
81133a84:	10800044 	addi	r2,r2,1
81133a88:	e0bff805 	stb	r2,-32(fp)
                 break;
81133a8c:	0001883a 	nop
81133a90:	e0bff917 	ldw	r2,-28(fp)
81133a94:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133a98:	e0bffa17 	ldw	r2,-24(fp)
81133a9c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81133aa0:	112e8b00 	call	8112e8b0 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81133aa4:	e0bfff17 	ldw	r2,-4(fp)
81133aa8:	00c00384 	movi	r3,14
81133aac:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81133ab0:	e0bff803 	ldbu	r2,-32(fp)
81133ab4:	00000706 	br	81133ad4 <OSSemPendAbort+0x160>
81133ab8:	e0bff917 	ldw	r2,-28(fp)
81133abc:	e0bffb15 	stw	r2,-20(fp)
81133ac0:	e0bffb17 	ldw	r2,-20(fp)
81133ac4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81133ac8:	e0bfff17 	ldw	r2,-4(fp)
81133acc:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
81133ad0:	0005883a 	mov	r2,zero
}
81133ad4:	e037883a 	mov	sp,fp
81133ad8:	dfc00117 	ldw	ra,4(sp)
81133adc:	df000017 	ldw	fp,0(sp)
81133ae0:	dec00204 	addi	sp,sp,8
81133ae4:	f800283a 	ret

81133ae8 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
81133ae8:	defff804 	addi	sp,sp,-32
81133aec:	de00012e 	bgeu	sp,et,81133af4 <OSSemPost+0xc>
81133af0:	003b68fa 	trap	3
81133af4:	dfc00715 	stw	ra,28(sp)
81133af8:	df000615 	stw	fp,24(sp)
81133afc:	df000604 	addi	fp,sp,24
81133b00:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81133b04:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81133b08:	e0bfff17 	ldw	r2,-4(fp)
81133b0c:	1000021e 	bne	r2,zero,81133b18 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
81133b10:	00800104 	movi	r2,4
81133b14:	00003506 	br	81133bec <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81133b18:	e0bfff17 	ldw	r2,-4(fp)
81133b1c:	10800003 	ldbu	r2,0(r2)
81133b20:	10803fcc 	andi	r2,r2,255
81133b24:	108000e0 	cmpeqi	r2,r2,3
81133b28:	1000021e 	bne	r2,zero,81133b34 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
81133b2c:	00800044 	movi	r2,1
81133b30:	00002e06 	br	81133bec <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133b34:	0005303a 	rdctl	r2,status
81133b38:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133b3c:	e0fffe17 	ldw	r3,-8(fp)
81133b40:	00bfff84 	movi	r2,-2
81133b44:	1884703a 	and	r2,r3,r2
81133b48:	1001703a 	wrctl	status,r2
  
  return context;
81133b4c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81133b50:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
81133b54:	e0bfff17 	ldw	r2,-4(fp)
81133b58:	10800283 	ldbu	r2,10(r2)
81133b5c:	10803fcc 	andi	r2,r2,255
81133b60:	10000c26 	beq	r2,zero,81133b94 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81133b64:	000f883a 	mov	r7,zero
81133b68:	01800044 	movi	r6,1
81133b6c:	000b883a 	mov	r5,zero
81133b70:	e13fff17 	ldw	r4,-4(fp)
81133b74:	112ddf40 	call	8112ddf4 <OS_EventTaskRdy>
81133b78:	e0bffa17 	ldw	r2,-24(fp)
81133b7c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133b80:	e0bffb17 	ldw	r2,-20(fp)
81133b84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81133b88:	112e8b00 	call	8112e8b0 <OS_Sched>
        return (OS_ERR_NONE);
81133b8c:	0005883a 	mov	r2,zero
81133b90:	00001606 	br	81133bec <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
81133b94:	e0bfff17 	ldw	r2,-4(fp)
81133b98:	1080020b 	ldhu	r2,8(r2)
81133b9c:	10ffffcc 	andi	r3,r2,65535
81133ba0:	00bfffd4 	movui	r2,65535
81133ba4:	18800c26 	beq	r3,r2,81133bd8 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
81133ba8:	e0bfff17 	ldw	r2,-4(fp)
81133bac:	1080020b 	ldhu	r2,8(r2)
81133bb0:	10800044 	addi	r2,r2,1
81133bb4:	1007883a 	mov	r3,r2
81133bb8:	e0bfff17 	ldw	r2,-4(fp)
81133bbc:	10c0020d 	sth	r3,8(r2)
81133bc0:	e0bffa17 	ldw	r2,-24(fp)
81133bc4:	e0bffc15 	stw	r2,-16(fp)
81133bc8:	e0bffc17 	ldw	r2,-16(fp)
81133bcc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81133bd0:	0005883a 	mov	r2,zero
81133bd4:	00000506 	br	81133bec <OSSemPost+0x104>
81133bd8:	e0bffa17 	ldw	r2,-24(fp)
81133bdc:	e0bffd15 	stw	r2,-12(fp)
81133be0:	e0bffd17 	ldw	r2,-12(fp)
81133be4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
81133be8:	00800c84 	movi	r2,50
}
81133bec:	e037883a 	mov	sp,fp
81133bf0:	dfc00117 	ldw	ra,4(sp)
81133bf4:	df000017 	ldw	fp,0(sp)
81133bf8:	dec00204 	addi	sp,sp,8
81133bfc:	f800283a 	ret

81133c00 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
81133c00:	defff704 	addi	sp,sp,-36
81133c04:	de00012e 	bgeu	sp,et,81133c0c <OSSemQuery+0xc>
81133c08:	003b68fa 	trap	3
81133c0c:	df000815 	stw	fp,32(sp)
81133c10:	df000804 	addi	fp,sp,32
81133c14:	e13ffe15 	stw	r4,-8(fp)
81133c18:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81133c1c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81133c20:	e0bffe17 	ldw	r2,-8(fp)
81133c24:	1000021e 	bne	r2,zero,81133c30 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81133c28:	00800104 	movi	r2,4
81133c2c:	00003606 	br	81133d08 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
81133c30:	e0bfff17 	ldw	r2,-4(fp)
81133c34:	1000021e 	bne	r2,zero,81133c40 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81133c38:	00800244 	movi	r2,9
81133c3c:	00003206 	br	81133d08 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
81133c40:	e0bffe17 	ldw	r2,-8(fp)
81133c44:	10800003 	ldbu	r2,0(r2)
81133c48:	10803fcc 	andi	r2,r2,255
81133c4c:	108000e0 	cmpeqi	r2,r2,3
81133c50:	1000021e 	bne	r2,zero,81133c5c <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81133c54:	00800044 	movi	r2,1
81133c58:	00002b06 	br	81133d08 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133c5c:	0005303a 	rdctl	r2,status
81133c60:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133c64:	e0fffd17 	ldw	r3,-12(fp)
81133c68:	00bfff84 	movi	r2,-2
81133c6c:	1884703a 	and	r2,r3,r2
81133c70:	1001703a 	wrctl	status,r2
  
  return context;
81133c74:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81133c78:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
81133c7c:	e0bffe17 	ldw	r2,-8(fp)
81133c80:	10c00283 	ldbu	r3,10(r2)
81133c84:	e0bfff17 	ldw	r2,-4(fp)
81133c88:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
81133c8c:	e0bffe17 	ldw	r2,-8(fp)
81133c90:	108002c4 	addi	r2,r2,11
81133c94:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
81133c98:	e0bfff17 	ldw	r2,-4(fp)
81133c9c:	10800084 	addi	r2,r2,2
81133ca0:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81133ca4:	e03ffa05 	stb	zero,-24(fp)
81133ca8:	00000b06 	br	81133cd8 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
81133cac:	e0bff917 	ldw	r2,-28(fp)
81133cb0:	10c00044 	addi	r3,r2,1
81133cb4:	e0fff915 	stw	r3,-28(fp)
81133cb8:	e0fff817 	ldw	r3,-32(fp)
81133cbc:	19000044 	addi	r4,r3,1
81133cc0:	e13ff815 	stw	r4,-32(fp)
81133cc4:	18c00003 	ldbu	r3,0(r3)
81133cc8:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81133ccc:	e0bffa03 	ldbu	r2,-24(fp)
81133cd0:	10800044 	addi	r2,r2,1
81133cd4:	e0bffa05 	stb	r2,-24(fp)
81133cd8:	e0bffa03 	ldbu	r2,-24(fp)
81133cdc:	108001b0 	cmpltui	r2,r2,6
81133ce0:	103ff21e 	bne	r2,zero,81133cac <__reset+0xfb113cac>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
81133ce4:	e0bffe17 	ldw	r2,-8(fp)
81133ce8:	10c0020b 	ldhu	r3,8(r2)
81133cec:	e0bfff17 	ldw	r2,-4(fp)
81133cf0:	10c0000d 	sth	r3,0(r2)
81133cf4:	e0bffb17 	ldw	r2,-20(fp)
81133cf8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133cfc:	e0bffc17 	ldw	r2,-16(fp)
81133d00:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81133d04:	0005883a 	mov	r2,zero
}
81133d08:	e037883a 	mov	sp,fp
81133d0c:	df000017 	ldw	fp,0(sp)
81133d10:	dec00104 	addi	sp,sp,4
81133d14:	f800283a 	ret

81133d18 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
81133d18:	defff904 	addi	sp,sp,-28
81133d1c:	de00012e 	bgeu	sp,et,81133d24 <OSSemSet+0xc>
81133d20:	003b68fa 	trap	3
81133d24:	df000615 	stw	fp,24(sp)
81133d28:	df000604 	addi	fp,sp,24
81133d2c:	e13ffd15 	stw	r4,-12(fp)
81133d30:	2805883a 	mov	r2,r5
81133d34:	e1bfff15 	stw	r6,-4(fp)
81133d38:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81133d3c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81133d40:	e0bfff17 	ldw	r2,-4(fp)
81133d44:	10003126 	beq	r2,zero,81133e0c <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81133d48:	e0bffd17 	ldw	r2,-12(fp)
81133d4c:	1000041e 	bne	r2,zero,81133d60 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81133d50:	e0bfff17 	ldw	r2,-4(fp)
81133d54:	00c00104 	movi	r3,4
81133d58:	10c00005 	stb	r3,0(r2)
        return;
81133d5c:	00002c06 	br	81133e10 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81133d60:	e0bffd17 	ldw	r2,-12(fp)
81133d64:	10800003 	ldbu	r2,0(r2)
81133d68:	10803fcc 	andi	r2,r2,255
81133d6c:	108000e0 	cmpeqi	r2,r2,3
81133d70:	1000041e 	bne	r2,zero,81133d84 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
81133d74:	e0bfff17 	ldw	r2,-4(fp)
81133d78:	00c00044 	movi	r3,1
81133d7c:	10c00005 	stb	r3,0(r2)
        return;
81133d80:	00002306 	br	81133e10 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133d84:	0005303a 	rdctl	r2,status
81133d88:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133d8c:	e0fffc17 	ldw	r3,-16(fp)
81133d90:	00bfff84 	movi	r2,-2
81133d94:	1884703a 	and	r2,r3,r2
81133d98:	1001703a 	wrctl	status,r2
  
  return context;
81133d9c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81133da0:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
81133da4:	e0bfff17 	ldw	r2,-4(fp)
81133da8:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
81133dac:	e0bffd17 	ldw	r2,-12(fp)
81133db0:	1080020b 	ldhu	r2,8(r2)
81133db4:	10bfffcc 	andi	r2,r2,65535
81133db8:	10000426 	beq	r2,zero,81133dcc <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
81133dbc:	e0bffd17 	ldw	r2,-12(fp)
81133dc0:	e0fffe0b 	ldhu	r3,-8(fp)
81133dc4:	10c0020d 	sth	r3,8(r2)
81133dc8:	00000b06 	br	81133df8 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
81133dcc:	e0bffd17 	ldw	r2,-12(fp)
81133dd0:	10800283 	ldbu	r2,10(r2)
81133dd4:	10803fcc 	andi	r2,r2,255
81133dd8:	1000041e 	bne	r2,zero,81133dec <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
81133ddc:	e0bffd17 	ldw	r2,-12(fp)
81133de0:	e0fffe0b 	ldhu	r3,-8(fp)
81133de4:	10c0020d 	sth	r3,8(r2)
81133de8:	00000306 	br	81133df8 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
81133dec:	e0bfff17 	ldw	r2,-4(fp)
81133df0:	00c01244 	movi	r3,73
81133df4:	10c00005 	stb	r3,0(r2)
81133df8:	e0bffa17 	ldw	r2,-24(fp)
81133dfc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133e00:	e0bffb17 	ldw	r2,-20(fp)
81133e04:	1001703a 	wrctl	status,r2
81133e08:	00000106 	br	81133e10 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81133e0c:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
81133e10:	e037883a 	mov	sp,fp
81133e14:	df000017 	ldw	fp,0(sp)
81133e18:	dec00104 	addi	sp,sp,4
81133e1c:	f800283a 	ret

81133e20 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
81133e20:	defff104 	addi	sp,sp,-60
81133e24:	de00012e 	bgeu	sp,et,81133e2c <OSTaskChangePrio+0xc>
81133e28:	003b68fa 	trap	3
81133e2c:	dfc00e15 	stw	ra,56(sp)
81133e30:	df000d15 	stw	fp,52(sp)
81133e34:	df000d04 	addi	fp,sp,52
81133e38:	2007883a 	mov	r3,r4
81133e3c:	2805883a 	mov	r2,r5
81133e40:	e0fffe05 	stb	r3,-8(fp)
81133e44:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
81133e48:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
81133e4c:	e0bffe03 	ldbu	r2,-8(fp)
81133e50:	10800a30 	cmpltui	r2,r2,40
81133e54:	1000051e 	bne	r2,zero,81133e6c <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
81133e58:	e0bffe03 	ldbu	r2,-8(fp)
81133e5c:	10803fe0 	cmpeqi	r2,r2,255
81133e60:	1000021e 	bne	r2,zero,81133e6c <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
81133e64:	00800a84 	movi	r2,42
81133e68:	00012606 	br	81134304 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
81133e6c:	e0bfff03 	ldbu	r2,-4(fp)
81133e70:	10800a30 	cmpltui	r2,r2,40
81133e74:	1000021e 	bne	r2,zero,81133e80 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
81133e78:	00800a84 	movi	r2,42
81133e7c:	00012106 	br	81134304 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133e80:	0005303a 	rdctl	r2,status
81133e84:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133e88:	e0fffd17 	ldw	r3,-12(fp)
81133e8c:	00bfff84 	movi	r2,-2
81133e90:	1884703a 	and	r2,r3,r2
81133e94:	1001703a 	wrctl	status,r2
  
  return context;
81133e98:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81133e9c:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
81133ea0:	e0ffff03 	ldbu	r3,-4(fp)
81133ea4:	00a045b4 	movhi	r2,33046
81133ea8:	10bfb204 	addi	r2,r2,-312
81133eac:	18c7883a 	add	r3,r3,r3
81133eb0:	18c7883a 	add	r3,r3,r3
81133eb4:	10c5883a 	add	r2,r2,r3
81133eb8:	10800017 	ldw	r2,0(r2)
81133ebc:	10000626 	beq	r2,zero,81133ed8 <OSTaskChangePrio+0xb8>
81133ec0:	e0bff517 	ldw	r2,-44(fp)
81133ec4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133ec8:	e0bff617 	ldw	r2,-40(fp)
81133ecc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
81133ed0:	00800a04 	movi	r2,40
81133ed4:	00010b06 	br	81134304 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
81133ed8:	e0bffe03 	ldbu	r2,-8(fp)
81133edc:	10803fd8 	cmpnei	r2,r2,255
81133ee0:	1000031e 	bne	r2,zero,81133ef0 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
81133ee4:	d0a09217 	ldw	r2,-32184(gp)
81133ee8:	10800c83 	ldbu	r2,50(r2)
81133eec:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
81133ef0:	e0fffe03 	ldbu	r3,-8(fp)
81133ef4:	00a045b4 	movhi	r2,33046
81133ef8:	10bfb204 	addi	r2,r2,-312
81133efc:	18c7883a 	add	r3,r3,r3
81133f00:	18c7883a 	add	r3,r3,r3
81133f04:	10c5883a 	add	r2,r2,r3
81133f08:	10800017 	ldw	r2,0(r2)
81133f0c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
81133f10:	e0bff817 	ldw	r2,-32(fp)
81133f14:	1000061e 	bne	r2,zero,81133f30 <OSTaskChangePrio+0x110>
81133f18:	e0bff517 	ldw	r2,-44(fp)
81133f1c:	e0bff715 	stw	r2,-36(fp)
81133f20:	e0bff717 	ldw	r2,-36(fp)
81133f24:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
81133f28:	00800a44 	movi	r2,41
81133f2c:	0000f506 	br	81134304 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
81133f30:	e0bff817 	ldw	r2,-32(fp)
81133f34:	10800058 	cmpnei	r2,r2,1
81133f38:	1000061e 	bne	r2,zero,81133f54 <OSTaskChangePrio+0x134>
81133f3c:	e0bff517 	ldw	r2,-44(fp)
81133f40:	e0bff915 	stw	r2,-28(fp)
81133f44:	e0bff917 	ldw	r2,-28(fp)
81133f48:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
81133f4c:	008010c4 	movi	r2,67
81133f50:	0000ec06 	br	81134304 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
81133f54:	e0bfff03 	ldbu	r2,-4(fp)
81133f58:	1004d0fa 	srli	r2,r2,3
81133f5c:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
81133f60:	e0bfff03 	ldbu	r2,-4(fp)
81133f64:	108001cc 	andi	r2,r2,7
81133f68:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
81133f6c:	e0bffb03 	ldbu	r2,-20(fp)
81133f70:	00c00044 	movi	r3,1
81133f74:	1884983a 	sll	r2,r3,r2
81133f78:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
81133f7c:	e0bffb43 	ldbu	r2,-19(fp)
81133f80:	00c00044 	movi	r3,1
81133f84:	1884983a 	sll	r2,r3,r2
81133f88:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
81133f8c:	e0fffe03 	ldbu	r3,-8(fp)
81133f90:	00a045b4 	movhi	r2,33046
81133f94:	10bfb204 	addi	r2,r2,-312
81133f98:	18c7883a 	add	r3,r3,r3
81133f9c:	18c7883a 	add	r3,r3,r3
81133fa0:	10c5883a 	add	r2,r2,r3
81133fa4:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
81133fa8:	e0ffff03 	ldbu	r3,-4(fp)
81133fac:	00a045b4 	movhi	r2,33046
81133fb0:	10bfb204 	addi	r2,r2,-312
81133fb4:	18c7883a 	add	r3,r3,r3
81133fb8:	18c7883a 	add	r3,r3,r3
81133fbc:	10c5883a 	add	r2,r2,r3
81133fc0:	e0fff817 	ldw	r3,-32(fp)
81133fc4:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
81133fc8:	e0bff817 	ldw	r2,-32(fp)
81133fcc:	10800d03 	ldbu	r2,52(r2)
81133fd0:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
81133fd4:	e0bff817 	ldw	r2,-32(fp)
81133fd8:	10800d83 	ldbu	r2,54(r2)
81133fdc:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
81133fe0:	e0bff817 	ldw	r2,-32(fp)
81133fe4:	10800d43 	ldbu	r2,53(r2)
81133fe8:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
81133fec:	e0fffc03 	ldbu	r3,-16(fp)
81133ff0:	d0a08e44 	addi	r2,gp,-32199
81133ff4:	1885883a 	add	r2,r3,r2
81133ff8:	10c00003 	ldbu	r3,0(r2)
81133ffc:	e0bffc83 	ldbu	r2,-14(fp)
81134000:	1884703a 	and	r2,r3,r2
81134004:	10803fcc 	andi	r2,r2,255
81134008:	10002826 	beq	r2,zero,811340ac <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8113400c:	e0fffc03 	ldbu	r3,-16(fp)
81134010:	e13ffc03 	ldbu	r4,-16(fp)
81134014:	d0a08e44 	addi	r2,gp,-32199
81134018:	2085883a 	add	r2,r4,r2
8113401c:	10800003 	ldbu	r2,0(r2)
81134020:	1009883a 	mov	r4,r2
81134024:	e0bffc83 	ldbu	r2,-14(fp)
81134028:	0084303a 	nor	r2,zero,r2
8113402c:	2084703a 	and	r2,r4,r2
81134030:	1009883a 	mov	r4,r2
81134034:	d0a08e44 	addi	r2,gp,-32199
81134038:	1885883a 	add	r2,r3,r2
8113403c:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
81134040:	e0fffc03 	ldbu	r3,-16(fp)
81134044:	d0a08e44 	addi	r2,gp,-32199
81134048:	1885883a 	add	r2,r3,r2
8113404c:	10800003 	ldbu	r2,0(r2)
81134050:	10803fcc 	andi	r2,r2,255
81134054:	1000061e 	bne	r2,zero,81134070 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
81134058:	e0bffc43 	ldbu	r2,-15(fp)
8113405c:	0084303a 	nor	r2,zero,r2
81134060:	1007883a 	mov	r3,r2
81134064:	d0a08e03 	ldbu	r2,-32200(gp)
81134068:	1884703a 	and	r2,r3,r2
8113406c:	d0a08e05 	stb	r2,-32200(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
81134070:	d0e08e03 	ldbu	r3,-32200(gp)
81134074:	e0bffb83 	ldbu	r2,-18(fp)
81134078:	1884b03a 	or	r2,r3,r2
8113407c:	d0a08e05 	stb	r2,-32200(gp)
         OSRdyTbl[y_new] |= bitx_new;
81134080:	e0fffb03 	ldbu	r3,-20(fp)
81134084:	e13ffb03 	ldbu	r4,-20(fp)
81134088:	d0a08e44 	addi	r2,gp,-32199
8113408c:	2085883a 	add	r2,r4,r2
81134090:	11000003 	ldbu	r4,0(r2)
81134094:	e0bffbc3 	ldbu	r2,-17(fp)
81134098:	2084b03a 	or	r2,r4,r2
8113409c:	1009883a 	mov	r4,r2
811340a0:	d0a08e44 	addi	r2,gp,-32199
811340a4:	1885883a 	add	r2,r3,r2
811340a8:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
811340ac:	e0bff817 	ldw	r2,-32(fp)
811340b0:	10800717 	ldw	r2,28(r2)
811340b4:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
811340b8:	e0bff317 	ldw	r2,-52(fp)
811340bc:	10003326 	beq	r2,zero,8113418c <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
811340c0:	e0bffc03 	ldbu	r2,-16(fp)
811340c4:	e0fffc03 	ldbu	r3,-16(fp)
811340c8:	e13ff317 	ldw	r4,-52(fp)
811340cc:	20c7883a 	add	r3,r4,r3
811340d0:	18c002c4 	addi	r3,r3,11
811340d4:	18c00003 	ldbu	r3,0(r3)
811340d8:	1809883a 	mov	r4,r3
811340dc:	e0fffc83 	ldbu	r3,-14(fp)
811340e0:	00c6303a 	nor	r3,zero,r3
811340e4:	20c6703a 	and	r3,r4,r3
811340e8:	1809883a 	mov	r4,r3
811340ec:	e0fff317 	ldw	r3,-52(fp)
811340f0:	1885883a 	add	r2,r3,r2
811340f4:	108002c4 	addi	r2,r2,11
811340f8:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
811340fc:	e0bffc03 	ldbu	r2,-16(fp)
81134100:	e0fff317 	ldw	r3,-52(fp)
81134104:	1885883a 	add	r2,r3,r2
81134108:	108002c4 	addi	r2,r2,11
8113410c:	10800003 	ldbu	r2,0(r2)
81134110:	10803fcc 	andi	r2,r2,255
81134114:	1000091e 	bne	r2,zero,8113413c <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
81134118:	e0bff317 	ldw	r2,-52(fp)
8113411c:	10800283 	ldbu	r2,10(r2)
81134120:	1007883a 	mov	r3,r2
81134124:	e0bffc43 	ldbu	r2,-15(fp)
81134128:	0084303a 	nor	r2,zero,r2
8113412c:	1884703a 	and	r2,r3,r2
81134130:	1007883a 	mov	r3,r2
81134134:	e0bff317 	ldw	r2,-52(fp)
81134138:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8113413c:	e0bff317 	ldw	r2,-52(fp)
81134140:	10c00283 	ldbu	r3,10(r2)
81134144:	e0bffb83 	ldbu	r2,-18(fp)
81134148:	1884b03a 	or	r2,r3,r2
8113414c:	1007883a 	mov	r3,r2
81134150:	e0bff317 	ldw	r2,-52(fp)
81134154:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
81134158:	e0bffb03 	ldbu	r2,-20(fp)
8113415c:	e0fffb03 	ldbu	r3,-20(fp)
81134160:	e13ff317 	ldw	r4,-52(fp)
81134164:	20c7883a 	add	r3,r4,r3
81134168:	18c002c4 	addi	r3,r3,11
8113416c:	19000003 	ldbu	r4,0(r3)
81134170:	e0fffbc3 	ldbu	r3,-17(fp)
81134174:	20c6b03a 	or	r3,r4,r3
81134178:	1809883a 	mov	r4,r3
8113417c:	e0fff317 	ldw	r3,-52(fp)
81134180:	1885883a 	add	r2,r3,r2
81134184:	108002c4 	addi	r2,r2,11
81134188:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8113418c:	e0bff817 	ldw	r2,-32(fp)
81134190:	10800817 	ldw	r2,32(r2)
81134194:	10004226 	beq	r2,zero,811342a0 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
81134198:	e0bff817 	ldw	r2,-32(fp)
8113419c:	10800817 	ldw	r2,32(r2)
811341a0:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
811341a4:	e0bff417 	ldw	r2,-48(fp)
811341a8:	10800017 	ldw	r2,0(r2)
811341ac:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
811341b0:	00003906 	br	81134298 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
811341b4:	e0bffc03 	ldbu	r2,-16(fp)
811341b8:	e0fffc03 	ldbu	r3,-16(fp)
811341bc:	e13ff317 	ldw	r4,-52(fp)
811341c0:	20c7883a 	add	r3,r4,r3
811341c4:	18c002c4 	addi	r3,r3,11
811341c8:	18c00003 	ldbu	r3,0(r3)
811341cc:	1809883a 	mov	r4,r3
811341d0:	e0fffc83 	ldbu	r3,-14(fp)
811341d4:	00c6303a 	nor	r3,zero,r3
811341d8:	20c6703a 	and	r3,r4,r3
811341dc:	1809883a 	mov	r4,r3
811341e0:	e0fff317 	ldw	r3,-52(fp)
811341e4:	1885883a 	add	r2,r3,r2
811341e8:	108002c4 	addi	r2,r2,11
811341ec:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
811341f0:	e0bffc03 	ldbu	r2,-16(fp)
811341f4:	e0fff317 	ldw	r3,-52(fp)
811341f8:	1885883a 	add	r2,r3,r2
811341fc:	108002c4 	addi	r2,r2,11
81134200:	10800003 	ldbu	r2,0(r2)
81134204:	10803fcc 	andi	r2,r2,255
81134208:	1000091e 	bne	r2,zero,81134230 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8113420c:	e0bff317 	ldw	r2,-52(fp)
81134210:	10800283 	ldbu	r2,10(r2)
81134214:	1007883a 	mov	r3,r2
81134218:	e0bffc43 	ldbu	r2,-15(fp)
8113421c:	0084303a 	nor	r2,zero,r2
81134220:	1884703a 	and	r2,r3,r2
81134224:	1007883a 	mov	r3,r2
81134228:	e0bff317 	ldw	r2,-52(fp)
8113422c:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
81134230:	e0bff317 	ldw	r2,-52(fp)
81134234:	10c00283 	ldbu	r3,10(r2)
81134238:	e0bffb83 	ldbu	r2,-18(fp)
8113423c:	1884b03a 	or	r2,r3,r2
81134240:	1007883a 	mov	r3,r2
81134244:	e0bff317 	ldw	r2,-52(fp)
81134248:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8113424c:	e0bffb03 	ldbu	r2,-20(fp)
81134250:	e0fffb03 	ldbu	r3,-20(fp)
81134254:	e13ff317 	ldw	r4,-52(fp)
81134258:	20c7883a 	add	r3,r4,r3
8113425c:	18c002c4 	addi	r3,r3,11
81134260:	19000003 	ldbu	r4,0(r3)
81134264:	e0fffbc3 	ldbu	r3,-17(fp)
81134268:	20c6b03a 	or	r3,r4,r3
8113426c:	1809883a 	mov	r4,r3
81134270:	e0fff317 	ldw	r3,-52(fp)
81134274:	1885883a 	add	r2,r3,r2
81134278:	108002c4 	addi	r2,r2,11
8113427c:	11000005 	stb	r4,0(r2)
            pevents++;
81134280:	e0bff417 	ldw	r2,-48(fp)
81134284:	10800104 	addi	r2,r2,4
81134288:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8113428c:	e0bff417 	ldw	r2,-48(fp)
81134290:	10800017 	ldw	r2,0(r2)
81134294:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
81134298:	e0bff317 	ldw	r2,-52(fp)
8113429c:	103fc51e 	bne	r2,zero,811341b4 <__reset+0xfb1141b4>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
811342a0:	e0bff817 	ldw	r2,-32(fp)
811342a4:	e0ffff03 	ldbu	r3,-4(fp)
811342a8:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
811342ac:	e0bff817 	ldw	r2,-32(fp)
811342b0:	e0fffb03 	ldbu	r3,-20(fp)
811342b4:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
811342b8:	e0bff817 	ldw	r2,-32(fp)
811342bc:	e0fffb43 	ldbu	r3,-19(fp)
811342c0:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
811342c4:	e0bff817 	ldw	r2,-32(fp)
811342c8:	e0fffb83 	ldbu	r3,-18(fp)
811342cc:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
811342d0:	e0bff817 	ldw	r2,-32(fp)
811342d4:	e0fffbc3 	ldbu	r3,-17(fp)
811342d8:	10c00d45 	stb	r3,53(r2)
811342dc:	e0bff517 	ldw	r2,-44(fp)
811342e0:	e0bffa15 	stw	r2,-24(fp)
811342e4:	e0bffa17 	ldw	r2,-24(fp)
811342e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
811342ec:	d0a08103 	ldbu	r2,-32252(gp)
811342f0:	10803fcc 	andi	r2,r2,255
811342f4:	10800058 	cmpnei	r2,r2,1
811342f8:	1000011e 	bne	r2,zero,81134300 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
811342fc:	112e8b00 	call	8112e8b0 <OS_Sched>
    }
    return (OS_ERR_NONE);
81134300:	0005883a 	mov	r2,zero
}
81134304:	e037883a 	mov	sp,fp
81134308:	dfc00117 	ldw	ra,4(sp)
8113430c:	df000017 	ldw	fp,0(sp)
81134310:	dec00204 	addi	sp,sp,8
81134314:	f800283a 	ret

81134318 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
81134318:	deffec04 	addi	sp,sp,-80
8113431c:	de00012e 	bgeu	sp,et,81134324 <OSTaskCreateExt+0xc>
81134320:	003b68fa 	trap	3
81134324:	dfc01315 	stw	ra,76(sp)
81134328:	df001215 	stw	fp,72(sp)
8113432c:	df001204 	addi	fp,sp,72
81134330:	e13ffa15 	stw	r4,-24(fp)
81134334:	e17ffb15 	stw	r5,-20(fp)
81134338:	e1bffc15 	stw	r6,-16(fp)
8113433c:	3809883a 	mov	r4,r7
81134340:	e0c00217 	ldw	r3,8(fp)
81134344:	e0800617 	ldw	r2,24(fp)
81134348:	e13ffd05 	stb	r4,-12(fp)
8113434c:	e0fffe0d 	sth	r3,-8(fp)
81134350:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
81134354:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81134358:	e0bffd03 	ldbu	r2,-12(fp)
8113435c:	10800a70 	cmpltui	r2,r2,41
81134360:	1000021e 	bne	r2,zero,8113436c <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
81134364:	00800a84 	movi	r2,42
81134368:	00006106 	br	811344f0 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113436c:	0005303a 	rdctl	r2,status
81134370:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134374:	e0fff917 	ldw	r3,-28(fp)
81134378:	00bfff84 	movi	r2,-2
8113437c:	1884703a 	and	r2,r3,r2
81134380:	1001703a 	wrctl	status,r2
  
  return context;
81134384:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81134388:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113438c:	d0a09103 	ldbu	r2,-32188(gp)
81134390:	10803fcc 	andi	r2,r2,255
81134394:	10000626 	beq	r2,zero,811343b0 <OSTaskCreateExt+0x98>
81134398:	e0bff117 	ldw	r2,-60(fp)
8113439c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811343a0:	e0bff217 	ldw	r2,-56(fp)
811343a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
811343a8:	00800f04 	movi	r2,60
811343ac:	00005006 	br	811344f0 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
811343b0:	e0fffd03 	ldbu	r3,-12(fp)
811343b4:	00a045b4 	movhi	r2,33046
811343b8:	10bfb204 	addi	r2,r2,-312
811343bc:	18c7883a 	add	r3,r3,r3
811343c0:	18c7883a 	add	r3,r3,r3
811343c4:	10c5883a 	add	r2,r2,r3
811343c8:	10800017 	ldw	r2,0(r2)
811343cc:	1000431e 	bne	r2,zero,811344dc <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
811343d0:	e0fffd03 	ldbu	r3,-12(fp)
811343d4:	00a045b4 	movhi	r2,33046
811343d8:	10bfb204 	addi	r2,r2,-312
811343dc:	18c7883a 	add	r3,r3,r3
811343e0:	18c7883a 	add	r3,r3,r3
811343e4:	10c5883a 	add	r2,r2,r3
811343e8:	00c00044 	movi	r3,1
811343ec:	10c00015 	stw	r3,0(r2)
811343f0:	e0bff117 	ldw	r2,-60(fp)
811343f4:	e0bff315 	stw	r2,-52(fp)
811343f8:	e0bff317 	ldw	r2,-52(fp)
811343fc:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
81134400:	e0bfff0b 	ldhu	r2,-4(fp)
81134404:	100d883a 	mov	r6,r2
81134408:	e1400417 	ldw	r5,16(fp)
8113440c:	e1000317 	ldw	r4,12(fp)
81134410:	11353c00 	call	811353c0 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
81134414:	e0bfff0b 	ldhu	r2,-4(fp)
81134418:	100f883a 	mov	r7,r2
8113441c:	e1bffc17 	ldw	r6,-16(fp)
81134420:	e17ffb17 	ldw	r5,-20(fp)
81134424:	e13ffa17 	ldw	r4,-24(fp)
81134428:	113f80c0 	call	8113f80c <OSTaskStkInit>
8113442c:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
81134430:	e0fffd03 	ldbu	r3,-12(fp)
81134434:	e13ffe0b 	ldhu	r4,-8(fp)
81134438:	e0bfff0b 	ldhu	r2,-4(fp)
8113443c:	d8800215 	stw	r2,8(sp)
81134440:	e0800517 	ldw	r2,20(fp)
81134444:	d8800115 	stw	r2,4(sp)
81134448:	e0800417 	ldw	r2,16(fp)
8113444c:	d8800015 	stw	r2,0(sp)
81134450:	200f883a 	mov	r7,r4
81134454:	e1800317 	ldw	r6,12(fp)
81134458:	e17ff517 	ldw	r5,-44(fp)
8113445c:	1809883a 	mov	r4,r3
81134460:	112ecf80 	call	8112ecf8 <OS_TCBInit>
81134464:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
81134468:	e0bff603 	ldbu	r2,-40(fp)
8113446c:	1000061e 	bne	r2,zero,81134488 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
81134470:	d0a08103 	ldbu	r2,-32252(gp)
81134474:	10803fcc 	andi	r2,r2,255
81134478:	10800058 	cmpnei	r2,r2,1
8113447c:	1000151e 	bne	r2,zero,811344d4 <OSTaskCreateExt+0x1bc>
                OS_Sched();
81134480:	112e8b00 	call	8112e8b0 <OS_Sched>
81134484:	00001306 	br	811344d4 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134488:	0005303a 	rdctl	r2,status
8113448c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134490:	e0fff817 	ldw	r3,-32(fp)
81134494:	00bfff84 	movi	r2,-2
81134498:	1884703a 	and	r2,r3,r2
8113449c:	1001703a 	wrctl	status,r2
  
  return context;
811344a0:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
811344a4:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
811344a8:	e0fffd03 	ldbu	r3,-12(fp)
811344ac:	00a045b4 	movhi	r2,33046
811344b0:	10bfb204 	addi	r2,r2,-312
811344b4:	18c7883a 	add	r3,r3,r3
811344b8:	18c7883a 	add	r3,r3,r3
811344bc:	10c5883a 	add	r2,r2,r3
811344c0:	10000015 	stw	zero,0(r2)
811344c4:	e0bff117 	ldw	r2,-60(fp)
811344c8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811344cc:	e0bff417 	ldw	r2,-48(fp)
811344d0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
811344d4:	e0bff603 	ldbu	r2,-40(fp)
811344d8:	00000506 	br	811344f0 <OSTaskCreateExt+0x1d8>
811344dc:	e0bff117 	ldw	r2,-60(fp)
811344e0:	e0bff715 	stw	r2,-36(fp)
811344e4:	e0bff717 	ldw	r2,-36(fp)
811344e8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
811344ec:	00800a04 	movi	r2,40
}
811344f0:	e037883a 	mov	sp,fp
811344f4:	dfc00117 	ldw	ra,4(sp)
811344f8:	df000017 	ldw	fp,0(sp)
811344fc:	dec00204 	addi	sp,sp,8
81134500:	f800283a 	ret

81134504 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
81134504:	defff404 	addi	sp,sp,-48
81134508:	de00012e 	bgeu	sp,et,81134510 <OSTaskDel+0xc>
8113450c:	003b68fa 	trap	3
81134510:	dfc00b15 	stw	ra,44(sp)
81134514:	df000a15 	stw	fp,40(sp)
81134518:	df000a04 	addi	fp,sp,40
8113451c:	2005883a 	mov	r2,r4
81134520:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
81134524:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
81134528:	d0a09103 	ldbu	r2,-32188(gp)
8113452c:	10803fcc 	andi	r2,r2,255
81134530:	10000226 	beq	r2,zero,8113453c <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
81134534:	00801004 	movi	r2,64
81134538:	0000c006 	br	8113483c <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113453c:	e0bfff03 	ldbu	r2,-4(fp)
81134540:	10800a18 	cmpnei	r2,r2,40
81134544:	1000021e 	bne	r2,zero,81134550 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
81134548:	00800f84 	movi	r2,62
8113454c:	0000bb06 	br	8113483c <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
81134550:	e0bfff03 	ldbu	r2,-4(fp)
81134554:	10800a30 	cmpltui	r2,r2,40
81134558:	1000051e 	bne	r2,zero,81134570 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113455c:	e0bfff03 	ldbu	r2,-4(fp)
81134560:	10803fe0 	cmpeqi	r2,r2,255
81134564:	1000021e 	bne	r2,zero,81134570 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
81134568:	00800a84 	movi	r2,42
8113456c:	0000b306 	br	8113483c <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134570:	0005303a 	rdctl	r2,status
81134574:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134578:	e0fffe17 	ldw	r3,-8(fp)
8113457c:	00bfff84 	movi	r2,-2
81134580:	1884703a 	and	r2,r3,r2
81134584:	1001703a 	wrctl	status,r2
  
  return context;
81134588:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113458c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
81134590:	e0bfff03 	ldbu	r2,-4(fp)
81134594:	10803fd8 	cmpnei	r2,r2,255
81134598:	1000031e 	bne	r2,zero,811345a8 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113459c:	d0a09217 	ldw	r2,-32184(gp)
811345a0:	10800c83 	ldbu	r2,50(r2)
811345a4:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811345a8:	e0ffff03 	ldbu	r3,-4(fp)
811345ac:	00a045b4 	movhi	r2,33046
811345b0:	10bfb204 	addi	r2,r2,-312
811345b4:	18c7883a 	add	r3,r3,r3
811345b8:	18c7883a 	add	r3,r3,r3
811345bc:	10c5883a 	add	r2,r2,r3
811345c0:	10800017 	ldw	r2,0(r2)
811345c4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
811345c8:	e0bff817 	ldw	r2,-32(fp)
811345cc:	1000061e 	bne	r2,zero,811345e8 <OSTaskDel+0xe4>
811345d0:	e0bff617 	ldw	r2,-40(fp)
811345d4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811345d8:	e0bff717 	ldw	r2,-36(fp)
811345dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811345e0:	008010c4 	movi	r2,67
811345e4:	00009506 	br	8113483c <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
811345e8:	e0bff817 	ldw	r2,-32(fp)
811345ec:	10800058 	cmpnei	r2,r2,1
811345f0:	1000061e 	bne	r2,zero,8113460c <OSTaskDel+0x108>
811345f4:	e0bff617 	ldw	r2,-40(fp)
811345f8:	e0bff915 	stw	r2,-28(fp)
811345fc:	e0bff917 	ldw	r2,-28(fp)
81134600:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81134604:	00800f44 	movi	r2,61
81134608:	00008c06 	br	8113483c <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113460c:	e0bff817 	ldw	r2,-32(fp)
81134610:	10800d03 	ldbu	r2,52(r2)
81134614:	10c03fcc 	andi	r3,r2,255
81134618:	e0bff817 	ldw	r2,-32(fp)
8113461c:	10800d03 	ldbu	r2,52(r2)
81134620:	11003fcc 	andi	r4,r2,255
81134624:	d0a08e44 	addi	r2,gp,-32199
81134628:	2085883a 	add	r2,r4,r2
8113462c:	10800003 	ldbu	r2,0(r2)
81134630:	1009883a 	mov	r4,r2
81134634:	e0bff817 	ldw	r2,-32(fp)
81134638:	10800d43 	ldbu	r2,53(r2)
8113463c:	0084303a 	nor	r2,zero,r2
81134640:	2084703a 	and	r2,r4,r2
81134644:	1009883a 	mov	r4,r2
81134648:	d0a08e44 	addi	r2,gp,-32199
8113464c:	1885883a 	add	r2,r3,r2
81134650:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
81134654:	e0bff817 	ldw	r2,-32(fp)
81134658:	10800d03 	ldbu	r2,52(r2)
8113465c:	10c03fcc 	andi	r3,r2,255
81134660:	d0a08e44 	addi	r2,gp,-32199
81134664:	1885883a 	add	r2,r3,r2
81134668:	10800003 	ldbu	r2,0(r2)
8113466c:	10803fcc 	andi	r2,r2,255
81134670:	1000071e 	bne	r2,zero,81134690 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
81134674:	e0bff817 	ldw	r2,-32(fp)
81134678:	10800d83 	ldbu	r2,54(r2)
8113467c:	0084303a 	nor	r2,zero,r2
81134680:	1007883a 	mov	r3,r2
81134684:	d0a08e03 	ldbu	r2,-32200(gp)
81134688:	1884703a 	and	r2,r3,r2
8113468c:	d0a08e05 	stb	r2,-32200(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
81134690:	e0bff817 	ldw	r2,-32(fp)
81134694:	10800717 	ldw	r2,28(r2)
81134698:	10000526 	beq	r2,zero,811346b0 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113469c:	e0bff817 	ldw	r2,-32(fp)
811346a0:	10800717 	ldw	r2,28(r2)
811346a4:	100b883a 	mov	r5,r2
811346a8:	e13ff817 	ldw	r4,-32(fp)
811346ac:	112e2040 	call	8112e204 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
811346b0:	e0bff817 	ldw	r2,-32(fp)
811346b4:	10800817 	ldw	r2,32(r2)
811346b8:	10000526 	beq	r2,zero,811346d0 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
811346bc:	e0bff817 	ldw	r2,-32(fp)
811346c0:	10800817 	ldw	r2,32(r2)
811346c4:	100b883a 	mov	r5,r2
811346c8:	e13ff817 	ldw	r4,-32(fp)
811346cc:	112e2c40 	call	8112e2c4 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
811346d0:	e0bff817 	ldw	r2,-32(fp)
811346d4:	10800a17 	ldw	r2,40(r2)
811346d8:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
811346dc:	e0bffb17 	ldw	r2,-20(fp)
811346e0:	10000226 	beq	r2,zero,811346ec <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
811346e4:	e13ffb17 	ldw	r4,-20(fp)
811346e8:	113089c0 	call	8113089c <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
811346ec:	e0bff817 	ldw	r2,-32(fp)
811346f0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
811346f4:	e0bff817 	ldw	r2,-32(fp)
811346f8:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
811346fc:	e0bff817 	ldw	r2,-32(fp)
81134700:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
81134704:	d0a07f03 	ldbu	r2,-32260(gp)
81134708:	10803fcc 	andi	r2,r2,255
8113470c:	10803fe0 	cmpeqi	r2,r2,255
81134710:	1000031e 	bne	r2,zero,81134720 <OSTaskDel+0x21c>
        OSLockNesting++;
81134714:	d0a07f03 	ldbu	r2,-32260(gp)
81134718:	10800044 	addi	r2,r2,1
8113471c:	d0a07f05 	stb	r2,-32260(gp)
81134720:	e0bff617 	ldw	r2,-40(fp)
81134724:	e0bffd15 	stw	r2,-12(fp)
81134728:	e0bffd17 	ldw	r2,-12(fp)
8113472c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
81134730:	112ddcc0 	call	8112ddcc <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134734:	0005303a 	rdctl	r2,status
81134738:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113473c:	e0fffa17 	ldw	r3,-24(fp)
81134740:	00bfff84 	movi	r2,-2
81134744:	1884703a 	and	r2,r3,r2
81134748:	1001703a 	wrctl	status,r2
  
  return context;
8113474c:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
81134750:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
81134754:	d0a07f03 	ldbu	r2,-32260(gp)
81134758:	10803fcc 	andi	r2,r2,255
8113475c:	10000326 	beq	r2,zero,8113476c <OSTaskDel+0x268>
        OSLockNesting--;
81134760:	d0a07f03 	ldbu	r2,-32260(gp)
81134764:	10bfffc4 	addi	r2,r2,-1
81134768:	d0a07f05 	stb	r2,-32260(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113476c:	e13ff817 	ldw	r4,-32(fp)
81134770:	113f99c0 	call	8113f99c <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
81134774:	d0a08a43 	ldbu	r2,-32215(gp)
81134778:	10bfffc4 	addi	r2,r2,-1
8113477c:	d0a08a45 	stb	r2,-32215(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
81134780:	e0ffff03 	ldbu	r3,-4(fp)
81134784:	00a045b4 	movhi	r2,33046
81134788:	10bfb204 	addi	r2,r2,-312
8113478c:	18c7883a 	add	r3,r3,r3
81134790:	18c7883a 	add	r3,r3,r3
81134794:	10c5883a 	add	r2,r2,r3
81134798:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113479c:	e0bff817 	ldw	r2,-32(fp)
811347a0:	10800617 	ldw	r2,24(r2)
811347a4:	1000071e 	bne	r2,zero,811347c4 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
811347a8:	e0bff817 	ldw	r2,-32(fp)
811347ac:	10800517 	ldw	r2,20(r2)
811347b0:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
811347b4:	e0bff817 	ldw	r2,-32(fp)
811347b8:	10800517 	ldw	r2,20(r2)
811347bc:	d0a08415 	stw	r2,-32240(gp)
811347c0:	00000a06 	br	811347ec <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
811347c4:	e0bff817 	ldw	r2,-32(fp)
811347c8:	10800617 	ldw	r2,24(r2)
811347cc:	e0fff817 	ldw	r3,-32(fp)
811347d0:	18c00517 	ldw	r3,20(r3)
811347d4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
811347d8:	e0bff817 	ldw	r2,-32(fp)
811347dc:	10800517 	ldw	r2,20(r2)
811347e0:	e0fff817 	ldw	r3,-32(fp)
811347e4:	18c00617 	ldw	r3,24(r3)
811347e8:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
811347ec:	d0e08917 	ldw	r3,-32220(gp)
811347f0:	e0bff817 	ldw	r2,-32(fp)
811347f4:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
811347f8:	e0bff817 	ldw	r2,-32(fp)
811347fc:	d0a08915 	stw	r2,-32220(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
81134800:	e0bff817 	ldw	r2,-32(fp)
81134804:	00c00fc4 	movi	r3,63
81134808:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113480c:	e0bff817 	ldw	r2,-32(fp)
81134810:	10001345 	stb	zero,77(r2)
81134814:	e0bff617 	ldw	r2,-40(fp)
81134818:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113481c:	e0bffc17 	ldw	r2,-16(fp)
81134820:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81134824:	d0a08103 	ldbu	r2,-32252(gp)
81134828:	10803fcc 	andi	r2,r2,255
8113482c:	10800058 	cmpnei	r2,r2,1
81134830:	1000011e 	bne	r2,zero,81134838 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
81134834:	112e8b00 	call	8112e8b0 <OS_Sched>
    }
    return (OS_ERR_NONE);
81134838:	0005883a 	mov	r2,zero
}
8113483c:	e037883a 	mov	sp,fp
81134840:	dfc00117 	ldw	ra,4(sp)
81134844:	df000017 	ldw	fp,0(sp)
81134848:	dec00204 	addi	sp,sp,8
8113484c:	f800283a 	ret

81134850 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
81134850:	defff504 	addi	sp,sp,-44
81134854:	de00012e 	bgeu	sp,et,8113485c <OSTaskDelReq+0xc>
81134858:	003b68fa 	trap	3
8113485c:	df000a15 	stw	fp,40(sp)
81134860:	df000a04 	addi	fp,sp,40
81134864:	2005883a 	mov	r2,r4
81134868:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113486c:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
81134870:	e0bfff03 	ldbu	r2,-4(fp)
81134874:	10800a18 	cmpnei	r2,r2,40
81134878:	1000021e 	bne	r2,zero,81134884 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113487c:	00800f84 	movi	r2,62
81134880:	00004506 	br	81134998 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81134884:	e0bfff03 	ldbu	r2,-4(fp)
81134888:	10800a30 	cmpltui	r2,r2,40
8113488c:	1000051e 	bne	r2,zero,811348a4 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
81134890:	e0bfff03 	ldbu	r2,-4(fp)
81134894:	10803fe0 	cmpeqi	r2,r2,255
81134898:	1000021e 	bne	r2,zero,811348a4 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113489c:	00800a84 	movi	r2,42
811348a0:	00003d06 	br	81134998 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
811348a4:	e0bfff03 	ldbu	r2,-4(fp)
811348a8:	10803fd8 	cmpnei	r2,r2,255
811348ac:	1000111e 	bne	r2,zero,811348f4 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811348b0:	0005303a 	rdctl	r2,status
811348b4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811348b8:	e0fff917 	ldw	r3,-28(fp)
811348bc:	00bfff84 	movi	r2,-2
811348c0:	1884703a 	and	r2,r3,r2
811348c4:	1001703a 	wrctl	status,r2
  
  return context;
811348c8:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
811348cc:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
811348d0:	d0a09217 	ldw	r2,-32184(gp)
811348d4:	10800dc3 	ldbu	r2,55(r2)
811348d8:	e0bff805 	stb	r2,-32(fp)
811348dc:	e0bff617 	ldw	r2,-40(fp)
811348e0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811348e4:	e0bffe17 	ldw	r2,-8(fp)
811348e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
811348ec:	e0bff803 	ldbu	r2,-32(fp)
811348f0:	00002906 	br	81134998 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811348f4:	0005303a 	rdctl	r2,status
811348f8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811348fc:	e0fff717 	ldw	r3,-36(fp)
81134900:	00bfff84 	movi	r2,-2
81134904:	1884703a 	and	r2,r3,r2
81134908:	1001703a 	wrctl	status,r2
  
  return context;
8113490c:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
81134910:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81134914:	e0ffff03 	ldbu	r3,-4(fp)
81134918:	00a045b4 	movhi	r2,33046
8113491c:	10bfb204 	addi	r2,r2,-312
81134920:	18c7883a 	add	r3,r3,r3
81134924:	18c7883a 	add	r3,r3,r3
81134928:	10c5883a 	add	r2,r2,r3
8113492c:	10800017 	ldw	r2,0(r2)
81134930:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
81134934:	e0bffb17 	ldw	r2,-20(fp)
81134938:	1000061e 	bne	r2,zero,81134954 <OSTaskDelReq+0x104>
8113493c:	e0bff617 	ldw	r2,-40(fp)
81134940:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134944:	e0bffa17 	ldw	r2,-24(fp)
81134948:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113494c:	008010c4 	movi	r2,67
81134950:	00001106 	br	81134998 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
81134954:	e0bffb17 	ldw	r2,-20(fp)
81134958:	10800058 	cmpnei	r2,r2,1
8113495c:	1000061e 	bne	r2,zero,81134978 <OSTaskDelReq+0x128>
81134960:	e0bff617 	ldw	r2,-40(fp)
81134964:	e0bffc15 	stw	r2,-16(fp)
81134968:	e0bffc17 	ldw	r2,-16(fp)
8113496c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81134970:	00800f44 	movi	r2,61
81134974:	00000806 	br	81134998 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
81134978:	e0bffb17 	ldw	r2,-20(fp)
8113497c:	00c00fc4 	movi	r3,63
81134980:	10c00dc5 	stb	r3,55(r2)
81134984:	e0bff617 	ldw	r2,-40(fp)
81134988:	e0bffd15 	stw	r2,-12(fp)
8113498c:	e0bffd17 	ldw	r2,-12(fp)
81134990:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81134994:	0005883a 	mov	r2,zero
}
81134998:	e037883a 	mov	sp,fp
8113499c:	df000017 	ldw	fp,0(sp)
811349a0:	dec00104 	addi	sp,sp,4
811349a4:	f800283a 	ret

811349a8 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
811349a8:	defff404 	addi	sp,sp,-48
811349ac:	de00012e 	bgeu	sp,et,811349b4 <OSTaskNameGet+0xc>
811349b0:	003b68fa 	trap	3
811349b4:	dfc00b15 	stw	ra,44(sp)
811349b8:	df000a15 	stw	fp,40(sp)
811349bc:	df000a04 	addi	fp,sp,40
811349c0:	2005883a 	mov	r2,r4
811349c4:	e17ffe15 	stw	r5,-8(fp)
811349c8:	e1bfff15 	stw	r6,-4(fp)
811349cc:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
811349d0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
811349d4:	e0bfff17 	ldw	r2,-4(fp)
811349d8:	1000021e 	bne	r2,zero,811349e4 <OSTaskNameGet+0x3c>
        return (0);
811349dc:	0005883a 	mov	r2,zero
811349e0:	00005406 	br	81134b34 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
811349e4:	e0bffd03 	ldbu	r2,-12(fp)
811349e8:	10800a70 	cmpltui	r2,r2,41
811349ec:	1000081e 	bne	r2,zero,81134a10 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
811349f0:	e0bffd03 	ldbu	r2,-12(fp)
811349f4:	10803fe0 	cmpeqi	r2,r2,255
811349f8:	1000051e 	bne	r2,zero,81134a10 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
811349fc:	e0bfff17 	ldw	r2,-4(fp)
81134a00:	00c00a84 	movi	r3,42
81134a04:	10c00005 	stb	r3,0(r2)
            return (0);
81134a08:	0005883a 	mov	r2,zero
81134a0c:	00004906 	br	81134b34 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
81134a10:	e0bffe17 	ldw	r2,-8(fp)
81134a14:	1000051e 	bne	r2,zero,81134a2c <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
81134a18:	e0bfff17 	ldw	r2,-4(fp)
81134a1c:	00c00304 	movi	r3,12
81134a20:	10c00005 	stb	r3,0(r2)
        return (0);
81134a24:	0005883a 	mov	r2,zero
81134a28:	00004206 	br	81134b34 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
81134a2c:	d0a09103 	ldbu	r2,-32188(gp)
81134a30:	10803fcc 	andi	r2,r2,255
81134a34:	10000526 	beq	r2,zero,81134a4c <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
81134a38:	e0bfff17 	ldw	r2,-4(fp)
81134a3c:	00c00444 	movi	r3,17
81134a40:	10c00005 	stb	r3,0(r2)
        return (0);
81134a44:	0005883a 	mov	r2,zero
81134a48:	00003a06 	br	81134b34 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134a4c:	0005303a 	rdctl	r2,status
81134a50:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134a54:	e0fffc17 	ldw	r3,-16(fp)
81134a58:	00bfff84 	movi	r2,-2
81134a5c:	1884703a 	and	r2,r3,r2
81134a60:	1001703a 	wrctl	status,r2
  
  return context;
81134a64:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134a68:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
81134a6c:	e0bffd03 	ldbu	r2,-12(fp)
81134a70:	10803fd8 	cmpnei	r2,r2,255
81134a74:	1000031e 	bne	r2,zero,81134a84 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
81134a78:	d0a09217 	ldw	r2,-32184(gp)
81134a7c:	10800c83 	ldbu	r2,50(r2)
81134a80:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81134a84:	e0fffd03 	ldbu	r3,-12(fp)
81134a88:	00a045b4 	movhi	r2,33046
81134a8c:	10bfb204 	addi	r2,r2,-312
81134a90:	18c7883a 	add	r3,r3,r3
81134a94:	18c7883a 	add	r3,r3,r3
81134a98:	10c5883a 	add	r2,r2,r3
81134a9c:	10800017 	ldw	r2,0(r2)
81134aa0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
81134aa4:	e0bff817 	ldw	r2,-32(fp)
81134aa8:	1000091e 	bne	r2,zero,81134ad0 <OSTaskNameGet+0x128>
81134aac:	e0bff617 	ldw	r2,-40(fp)
81134ab0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134ab4:	e0bff717 	ldw	r2,-36(fp)
81134ab8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
81134abc:	e0bfff17 	ldw	r2,-4(fp)
81134ac0:	00c010c4 	movi	r3,67
81134ac4:	10c00005 	stb	r3,0(r2)
        return (0);
81134ac8:	0005883a 	mov	r2,zero
81134acc:	00001906 	br	81134b34 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
81134ad0:	e0bff817 	ldw	r2,-32(fp)
81134ad4:	10800058 	cmpnei	r2,r2,1
81134ad8:	1000091e 	bne	r2,zero,81134b00 <OSTaskNameGet+0x158>
81134adc:	e0bff617 	ldw	r2,-40(fp)
81134ae0:	e0bff915 	stw	r2,-28(fp)
81134ae4:	e0bff917 	ldw	r2,-28(fp)
81134ae8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
81134aec:	e0bfff17 	ldw	r2,-4(fp)
81134af0:	00c010c4 	movi	r3,67
81134af4:	10c00005 	stb	r3,0(r2)
        return (0);
81134af8:	0005883a 	mov	r2,zero
81134afc:	00000d06 	br	81134b34 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
81134b00:	e0bff817 	ldw	r2,-32(fp)
81134b04:	10801304 	addi	r2,r2,76
81134b08:	100b883a 	mov	r5,r2
81134b0c:	e13ffe17 	ldw	r4,-8(fp)
81134b10:	112ea040 	call	8112ea04 <OS_StrCopy>
81134b14:	e0bffb05 	stb	r2,-20(fp)
81134b18:	e0bff617 	ldw	r2,-40(fp)
81134b1c:	e0bffa15 	stw	r2,-24(fp)
81134b20:	e0bffa17 	ldw	r2,-24(fp)
81134b24:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81134b28:	e0bfff17 	ldw	r2,-4(fp)
81134b2c:	10000005 	stb	zero,0(r2)
    return (len);
81134b30:	e0bffb03 	ldbu	r2,-20(fp)
}
81134b34:	e037883a 	mov	sp,fp
81134b38:	dfc00117 	ldw	ra,4(sp)
81134b3c:	df000017 	ldw	fp,0(sp)
81134b40:	dec00204 	addi	sp,sp,8
81134b44:	f800283a 	ret

81134b48 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
81134b48:	defff304 	addi	sp,sp,-52
81134b4c:	de00012e 	bgeu	sp,et,81134b54 <OSTaskNameSet+0xc>
81134b50:	003b68fa 	trap	3
81134b54:	dfc00c15 	stw	ra,48(sp)
81134b58:	df000b15 	stw	fp,44(sp)
81134b5c:	df000b04 	addi	fp,sp,44
81134b60:	2005883a 	mov	r2,r4
81134b64:	e17ffe15 	stw	r5,-8(fp)
81134b68:	e1bfff15 	stw	r6,-4(fp)
81134b6c:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81134b70:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
81134b74:	e0bfff17 	ldw	r2,-4(fp)
81134b78:	10005c26 	beq	r2,zero,81134cec <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
81134b7c:	e0bffd03 	ldbu	r2,-12(fp)
81134b80:	10800a70 	cmpltui	r2,r2,41
81134b84:	1000071e 	bne	r2,zero,81134ba4 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
81134b88:	e0bffd03 	ldbu	r2,-12(fp)
81134b8c:	10803fe0 	cmpeqi	r2,r2,255
81134b90:	1000041e 	bne	r2,zero,81134ba4 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
81134b94:	e0bfff17 	ldw	r2,-4(fp)
81134b98:	00c00a84 	movi	r3,42
81134b9c:	10c00005 	stb	r3,0(r2)
            return;
81134ba0:	00005306 	br	81134cf0 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
81134ba4:	e0bffe17 	ldw	r2,-8(fp)
81134ba8:	1000041e 	bne	r2,zero,81134bbc <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
81134bac:	e0bfff17 	ldw	r2,-4(fp)
81134bb0:	00c00304 	movi	r3,12
81134bb4:	10c00005 	stb	r3,0(r2)
        return;
81134bb8:	00004d06 	br	81134cf0 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
81134bbc:	d0a09103 	ldbu	r2,-32188(gp)
81134bc0:	10803fcc 	andi	r2,r2,255
81134bc4:	10000426 	beq	r2,zero,81134bd8 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
81134bc8:	e0bfff17 	ldw	r2,-4(fp)
81134bcc:	00c00484 	movi	r3,18
81134bd0:	10c00005 	stb	r3,0(r2)
        return;
81134bd4:	00004606 	br	81134cf0 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134bd8:	0005303a 	rdctl	r2,status
81134bdc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134be0:	e0fffc17 	ldw	r3,-16(fp)
81134be4:	00bfff84 	movi	r2,-2
81134be8:	1884703a 	and	r2,r3,r2
81134bec:	1001703a 	wrctl	status,r2
  
  return context;
81134bf0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134bf4:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
81134bf8:	e0bffd03 	ldbu	r2,-12(fp)
81134bfc:	10803fd8 	cmpnei	r2,r2,255
81134c00:	1000031e 	bne	r2,zero,81134c10 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
81134c04:	d0a09217 	ldw	r2,-32184(gp)
81134c08:	10800c83 	ldbu	r2,50(r2)
81134c0c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81134c10:	e0fffd03 	ldbu	r3,-12(fp)
81134c14:	00a045b4 	movhi	r2,33046
81134c18:	10bfb204 	addi	r2,r2,-312
81134c1c:	18c7883a 	add	r3,r3,r3
81134c20:	18c7883a 	add	r3,r3,r3
81134c24:	10c5883a 	add	r2,r2,r3
81134c28:	10800017 	ldw	r2,0(r2)
81134c2c:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
81134c30:	e0bff717 	ldw	r2,-36(fp)
81134c34:	1000081e 	bne	r2,zero,81134c58 <OSTaskNameSet+0x110>
81134c38:	e0bff517 	ldw	r2,-44(fp)
81134c3c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134c40:	e0bff617 	ldw	r2,-40(fp)
81134c44:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
81134c48:	e0bfff17 	ldw	r2,-4(fp)
81134c4c:	00c010c4 	movi	r3,67
81134c50:	10c00005 	stb	r3,0(r2)
        return;
81134c54:	00002606 	br	81134cf0 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
81134c58:	e0bff717 	ldw	r2,-36(fp)
81134c5c:	10800058 	cmpnei	r2,r2,1
81134c60:	1000081e 	bne	r2,zero,81134c84 <OSTaskNameSet+0x13c>
81134c64:	e0bff517 	ldw	r2,-44(fp)
81134c68:	e0bff815 	stw	r2,-32(fp)
81134c6c:	e0bff817 	ldw	r2,-32(fp)
81134c70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
81134c74:	e0bfff17 	ldw	r2,-4(fp)
81134c78:	00c010c4 	movi	r3,67
81134c7c:	10c00005 	stb	r3,0(r2)
        return;
81134c80:	00001b06 	br	81134cf0 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
81134c84:	e13ffe17 	ldw	r4,-8(fp)
81134c88:	112ea800 	call	8112ea80 <OS_StrLen>
81134c8c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
81134c90:	e0bffa03 	ldbu	r2,-24(fp)
81134c94:	10800830 	cmpltui	r2,r2,32
81134c98:	1000081e 	bne	r2,zero,81134cbc <OSTaskNameSet+0x174>
81134c9c:	e0bff517 	ldw	r2,-44(fp)
81134ca0:	e0bff915 	stw	r2,-28(fp)
81134ca4:	e0bff917 	ldw	r2,-28(fp)
81134ca8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
81134cac:	e0bfff17 	ldw	r2,-4(fp)
81134cb0:	00c01044 	movi	r3,65
81134cb4:	10c00005 	stb	r3,0(r2)
        return;
81134cb8:	00000d06 	br	81134cf0 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
81134cbc:	e0bff717 	ldw	r2,-36(fp)
81134cc0:	10801304 	addi	r2,r2,76
81134cc4:	e17ffe17 	ldw	r5,-8(fp)
81134cc8:	1009883a 	mov	r4,r2
81134ccc:	112ea040 	call	8112ea04 <OS_StrCopy>
81134cd0:	e0bff517 	ldw	r2,-44(fp)
81134cd4:	e0bffb15 	stw	r2,-20(fp)
81134cd8:	e0bffb17 	ldw	r2,-20(fp)
81134cdc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81134ce0:	e0bfff17 	ldw	r2,-4(fp)
81134ce4:	10000005 	stb	zero,0(r2)
81134ce8:	00000106 	br	81134cf0 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
81134cec:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81134cf0:	e037883a 	mov	sp,fp
81134cf4:	dfc00117 	ldw	ra,4(sp)
81134cf8:	df000017 	ldw	fp,0(sp)
81134cfc:	dec00204 	addi	sp,sp,8
81134d00:	f800283a 	ret

81134d04 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
81134d04:	defff404 	addi	sp,sp,-48
81134d08:	de00012e 	bgeu	sp,et,81134d10 <OSTaskResume+0xc>
81134d0c:	003b68fa 	trap	3
81134d10:	dfc00b15 	stw	ra,44(sp)
81134d14:	df000a15 	stw	fp,40(sp)
81134d18:	df000a04 	addi	fp,sp,40
81134d1c:	2005883a 	mov	r2,r4
81134d20:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81134d24:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
81134d28:	e0bfff03 	ldbu	r2,-4(fp)
81134d2c:	10800a30 	cmpltui	r2,r2,40
81134d30:	1000021e 	bne	r2,zero,81134d3c <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81134d34:	00800a84 	movi	r2,42
81134d38:	00006406 	br	81134ecc <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134d3c:	0005303a 	rdctl	r2,status
81134d40:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134d44:	e0fffe17 	ldw	r3,-8(fp)
81134d48:	00bfff84 	movi	r2,-2
81134d4c:	1884703a 	and	r2,r3,r2
81134d50:	1001703a 	wrctl	status,r2
  
  return context;
81134d54:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81134d58:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81134d5c:	e0ffff03 	ldbu	r3,-4(fp)
81134d60:	00a045b4 	movhi	r2,33046
81134d64:	10bfb204 	addi	r2,r2,-312
81134d68:	18c7883a 	add	r3,r3,r3
81134d6c:	18c7883a 	add	r3,r3,r3
81134d70:	10c5883a 	add	r2,r2,r3
81134d74:	10800017 	ldw	r2,0(r2)
81134d78:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
81134d7c:	e0bff817 	ldw	r2,-32(fp)
81134d80:	1000061e 	bne	r2,zero,81134d9c <OSTaskResume+0x98>
81134d84:	e0bff617 	ldw	r2,-40(fp)
81134d88:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134d8c:	e0bff717 	ldw	r2,-36(fp)
81134d90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
81134d94:	00801184 	movi	r2,70
81134d98:	00004c06 	br	81134ecc <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
81134d9c:	e0bff817 	ldw	r2,-32(fp)
81134da0:	10800058 	cmpnei	r2,r2,1
81134da4:	1000061e 	bne	r2,zero,81134dc0 <OSTaskResume+0xbc>
81134da8:	e0bff617 	ldw	r2,-40(fp)
81134dac:	e0bff915 	stw	r2,-28(fp)
81134db0:	e0bff917 	ldw	r2,-28(fp)
81134db4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81134db8:	008010c4 	movi	r2,67
81134dbc:	00004306 	br	81134ecc <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
81134dc0:	e0bff817 	ldw	r2,-32(fp)
81134dc4:	10800c03 	ldbu	r2,48(r2)
81134dc8:	10803fcc 	andi	r2,r2,255
81134dcc:	1080020c 	andi	r2,r2,8
81134dd0:	10003926 	beq	r2,zero,81134eb8 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
81134dd4:	e0bff817 	ldw	r2,-32(fp)
81134dd8:	10c00c03 	ldbu	r3,48(r2)
81134ddc:	00bffdc4 	movi	r2,-9
81134de0:	1884703a 	and	r2,r3,r2
81134de4:	1007883a 	mov	r3,r2
81134de8:	e0bff817 	ldw	r2,-32(fp)
81134dec:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
81134df0:	e0bff817 	ldw	r2,-32(fp)
81134df4:	10800c03 	ldbu	r2,48(r2)
81134df8:	10803fcc 	andi	r2,r2,255
81134dfc:	1000281e 	bne	r2,zero,81134ea0 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
81134e00:	e0bff817 	ldw	r2,-32(fp)
81134e04:	10800b8b 	ldhu	r2,46(r2)
81134e08:	10bfffcc 	andi	r2,r2,65535
81134e0c:	10001f1e 	bne	r2,zero,81134e8c <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
81134e10:	e0bff817 	ldw	r2,-32(fp)
81134e14:	10c00d83 	ldbu	r3,54(r2)
81134e18:	d0a08e03 	ldbu	r2,-32200(gp)
81134e1c:	1884b03a 	or	r2,r3,r2
81134e20:	d0a08e05 	stb	r2,-32200(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81134e24:	e0bff817 	ldw	r2,-32(fp)
81134e28:	10800d03 	ldbu	r2,52(r2)
81134e2c:	10c03fcc 	andi	r3,r2,255
81134e30:	e0bff817 	ldw	r2,-32(fp)
81134e34:	10800d03 	ldbu	r2,52(r2)
81134e38:	11003fcc 	andi	r4,r2,255
81134e3c:	d0a08e44 	addi	r2,gp,-32199
81134e40:	2085883a 	add	r2,r4,r2
81134e44:	11000003 	ldbu	r4,0(r2)
81134e48:	e0bff817 	ldw	r2,-32(fp)
81134e4c:	10800d43 	ldbu	r2,53(r2)
81134e50:	2084b03a 	or	r2,r4,r2
81134e54:	1009883a 	mov	r4,r2
81134e58:	d0a08e44 	addi	r2,gp,-32199
81134e5c:	1885883a 	add	r2,r3,r2
81134e60:	11000005 	stb	r4,0(r2)
81134e64:	e0bff617 	ldw	r2,-40(fp)
81134e68:	e0bffa15 	stw	r2,-24(fp)
81134e6c:	e0bffa17 	ldw	r2,-24(fp)
81134e70:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
81134e74:	d0a08103 	ldbu	r2,-32252(gp)
81134e78:	10803fcc 	andi	r2,r2,255
81134e7c:	10800058 	cmpnei	r2,r2,1
81134e80:	10000b1e 	bne	r2,zero,81134eb0 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
81134e84:	112e8b00 	call	8112e8b0 <OS_Sched>
81134e88:	00000906 	br	81134eb0 <OSTaskResume+0x1ac>
81134e8c:	e0bff617 	ldw	r2,-40(fp)
81134e90:	e0bffb15 	stw	r2,-20(fp)
81134e94:	e0bffb17 	ldw	r2,-20(fp)
81134e98:	1001703a 	wrctl	status,r2
81134e9c:	00000406 	br	81134eb0 <OSTaskResume+0x1ac>
81134ea0:	e0bff617 	ldw	r2,-40(fp)
81134ea4:	e0bffc15 	stw	r2,-16(fp)
81134ea8:	e0bffc17 	ldw	r2,-16(fp)
81134eac:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
81134eb0:	0005883a 	mov	r2,zero
81134eb4:	00000506 	br	81134ecc <OSTaskResume+0x1c8>
81134eb8:	e0bff617 	ldw	r2,-40(fp)
81134ebc:	e0bffd15 	stw	r2,-12(fp)
81134ec0:	e0bffd17 	ldw	r2,-12(fp)
81134ec4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
81134ec8:	00801104 	movi	r2,68
}
81134ecc:	e037883a 	mov	sp,fp
81134ed0:	dfc00117 	ldw	ra,4(sp)
81134ed4:	df000017 	ldw	fp,0(sp)
81134ed8:	dec00204 	addi	sp,sp,8
81134edc:	f800283a 	ret

81134ee0 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
81134ee0:	defff304 	addi	sp,sp,-52
81134ee4:	de00012e 	bgeu	sp,et,81134eec <OSTaskStkChk+0xc>
81134ee8:	003b68fa 	trap	3
81134eec:	df000c15 	stw	fp,48(sp)
81134ef0:	df000c04 	addi	fp,sp,48
81134ef4:	2005883a 	mov	r2,r4
81134ef8:	e17fff15 	stw	r5,-4(fp)
81134efc:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81134f00:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
81134f04:	e0bffe03 	ldbu	r2,-8(fp)
81134f08:	10800a70 	cmpltui	r2,r2,41
81134f0c:	1000051e 	bne	r2,zero,81134f24 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
81134f10:	e0bffe03 	ldbu	r2,-8(fp)
81134f14:	10803fe0 	cmpeqi	r2,r2,255
81134f18:	1000021e 	bne	r2,zero,81134f24 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
81134f1c:	00800a84 	movi	r2,42
81134f20:	00005d06 	br	81135098 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
81134f24:	e0bfff17 	ldw	r2,-4(fp)
81134f28:	1000021e 	bne	r2,zero,81134f34 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
81134f2c:	00800244 	movi	r2,9
81134f30:	00005906 	br	81135098 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
81134f34:	e0bfff17 	ldw	r2,-4(fp)
81134f38:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
81134f3c:	e0bfff17 	ldw	r2,-4(fp)
81134f40:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134f44:	0005303a 	rdctl	r2,status
81134f48:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134f4c:	e0fffd17 	ldw	r3,-12(fp)
81134f50:	00bfff84 	movi	r2,-2
81134f54:	1884703a 	and	r2,r3,r2
81134f58:	1001703a 	wrctl	status,r2
  
  return context;
81134f5c:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
81134f60:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
81134f64:	e0bffe03 	ldbu	r2,-8(fp)
81134f68:	10803fd8 	cmpnei	r2,r2,255
81134f6c:	1000031e 	bne	r2,zero,81134f7c <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
81134f70:	d0a09217 	ldw	r2,-32184(gp)
81134f74:	10800c83 	ldbu	r2,50(r2)
81134f78:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81134f7c:	e0fffe03 	ldbu	r3,-8(fp)
81134f80:	00a045b4 	movhi	r2,33046
81134f84:	10bfb204 	addi	r2,r2,-312
81134f88:	18c7883a 	add	r3,r3,r3
81134f8c:	18c7883a 	add	r3,r3,r3
81134f90:	10c5883a 	add	r2,r2,r3
81134f94:	10800017 	ldw	r2,0(r2)
81134f98:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
81134f9c:	e0bff817 	ldw	r2,-32(fp)
81134fa0:	1000061e 	bne	r2,zero,81134fbc <OSTaskStkChk+0xdc>
81134fa4:	e0bff617 	ldw	r2,-40(fp)
81134fa8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134fac:	e0bff717 	ldw	r2,-36(fp)
81134fb0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81134fb4:	008010c4 	movi	r2,67
81134fb8:	00003706 	br	81135098 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81134fbc:	e0bff817 	ldw	r2,-32(fp)
81134fc0:	10800058 	cmpnei	r2,r2,1
81134fc4:	1000061e 	bne	r2,zero,81134fe0 <OSTaskStkChk+0x100>
81134fc8:	e0bff617 	ldw	r2,-40(fp)
81134fcc:	e0bff915 	stw	r2,-28(fp)
81134fd0:	e0bff917 	ldw	r2,-28(fp)
81134fd4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81134fd8:	008010c4 	movi	r2,67
81134fdc:	00002e06 	br	81135098 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
81134fe0:	e0bff817 	ldw	r2,-32(fp)
81134fe4:	1080040b 	ldhu	r2,16(r2)
81134fe8:	10bfffcc 	andi	r2,r2,65535
81134fec:	1080004c 	andi	r2,r2,1
81134ff0:	1000061e 	bne	r2,zero,8113500c <OSTaskStkChk+0x12c>
81134ff4:	e0bff617 	ldw	r2,-40(fp)
81134ff8:	e0bffa15 	stw	r2,-24(fp)
81134ffc:	e0bffa17 	ldw	r2,-24(fp)
81135000:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
81135004:	00801144 	movi	r2,69
81135008:	00002306 	br	81135098 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8113500c:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
81135010:	e0bff817 	ldw	r2,-32(fp)
81135014:	10800317 	ldw	r2,12(r2)
81135018:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8113501c:	e0bff817 	ldw	r2,-32(fp)
81135020:	10800217 	ldw	r2,8(r2)
81135024:	e0bff415 	stw	r2,-48(fp)
81135028:	e0bff617 	ldw	r2,-40(fp)
8113502c:	e0bffb15 	stw	r2,-20(fp)
81135030:	e0bffb17 	ldw	r2,-20(fp)
81135034:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
81135038:	00000306 	br	81135048 <OSTaskStkChk+0x168>
        nfree++;
8113503c:	e0bff517 	ldw	r2,-44(fp)
81135040:	10800044 	addi	r2,r2,1
81135044:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
81135048:	e0bff417 	ldw	r2,-48(fp)
8113504c:	10c00104 	addi	r3,r2,4
81135050:	e0fff415 	stw	r3,-48(fp)
81135054:	10800017 	ldw	r2,0(r2)
81135058:	103ff826 	beq	r2,zero,8113503c <__reset+0xfb11503c>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8113505c:	e0bff517 	ldw	r2,-44(fp)
81135060:	1085883a 	add	r2,r2,r2
81135064:	1085883a 	add	r2,r2,r2
81135068:	1007883a 	mov	r3,r2
8113506c:	e0bfff17 	ldw	r2,-4(fp)
81135070:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
81135074:	e0fffc17 	ldw	r3,-16(fp)
81135078:	e0bff517 	ldw	r2,-44(fp)
8113507c:	1885c83a 	sub	r2,r3,r2
81135080:	1085883a 	add	r2,r2,r2
81135084:	1085883a 	add	r2,r2,r2
81135088:	1007883a 	mov	r3,r2
8113508c:	e0bfff17 	ldw	r2,-4(fp)
81135090:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
81135094:	0005883a 	mov	r2,zero
}
81135098:	e037883a 	mov	sp,fp
8113509c:	df000017 	ldw	fp,0(sp)
811350a0:	dec00104 	addi	sp,sp,4
811350a4:	f800283a 	ret

811350a8 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
811350a8:	defff504 	addi	sp,sp,-44
811350ac:	de00012e 	bgeu	sp,et,811350b4 <OSTaskSuspend+0xc>
811350b0:	003b68fa 	trap	3
811350b4:	dfc00a15 	stw	ra,40(sp)
811350b8:	df000915 	stw	fp,36(sp)
811350bc:	df000904 	addi	fp,sp,36
811350c0:	2005883a 	mov	r2,r4
811350c4:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811350c8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
811350cc:	e0bfff03 	ldbu	r2,-4(fp)
811350d0:	10800a18 	cmpnei	r2,r2,40
811350d4:	1000021e 	bne	r2,zero,811350e0 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
811350d8:	008011c4 	movi	r2,71
811350dc:	00006806 	br	81135280 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
811350e0:	e0bfff03 	ldbu	r2,-4(fp)
811350e4:	10800a30 	cmpltui	r2,r2,40
811350e8:	1000051e 	bne	r2,zero,81135100 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
811350ec:	e0bfff03 	ldbu	r2,-4(fp)
811350f0:	10803fe0 	cmpeqi	r2,r2,255
811350f4:	1000021e 	bne	r2,zero,81135100 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
811350f8:	00800a84 	movi	r2,42
811350fc:	00006006 	br	81135280 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135100:	0005303a 	rdctl	r2,status
81135104:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135108:	e0fffe17 	ldw	r3,-8(fp)
8113510c:	00bfff84 	movi	r2,-2
81135110:	1884703a 	and	r2,r3,r2
81135114:	1001703a 	wrctl	status,r2
  
  return context;
81135118:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8113511c:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
81135120:	e0bfff03 	ldbu	r2,-4(fp)
81135124:	10803fd8 	cmpnei	r2,r2,255
81135128:	1000061e 	bne	r2,zero,81135144 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113512c:	d0a09217 	ldw	r2,-32184(gp)
81135130:	10800c83 	ldbu	r2,50(r2)
81135134:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
81135138:	00800044 	movi	r2,1
8113513c:	e0bff705 	stb	r2,-36(fp)
81135140:	00000906 	br	81135168 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
81135144:	d0a09217 	ldw	r2,-32184(gp)
81135148:	10800c83 	ldbu	r2,50(r2)
8113514c:	10c03fcc 	andi	r3,r2,255
81135150:	e0bfff03 	ldbu	r2,-4(fp)
81135154:	1880031e 	bne	r3,r2,81135164 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
81135158:	00800044 	movi	r2,1
8113515c:	e0bff705 	stb	r2,-36(fp)
81135160:	00000106 	br	81135168 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
81135164:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81135168:	e0ffff03 	ldbu	r3,-4(fp)
8113516c:	00a045b4 	movhi	r2,33046
81135170:	10bfb204 	addi	r2,r2,-312
81135174:	18c7883a 	add	r3,r3,r3
81135178:	18c7883a 	add	r3,r3,r3
8113517c:	10c5883a 	add	r2,r2,r3
81135180:	10800017 	ldw	r2,0(r2)
81135184:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
81135188:	e0bffa17 	ldw	r2,-24(fp)
8113518c:	1000061e 	bne	r2,zero,811351a8 <OSTaskSuspend+0x100>
81135190:	e0bff817 	ldw	r2,-32(fp)
81135194:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135198:	e0bff917 	ldw	r2,-28(fp)
8113519c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
811351a0:	00801204 	movi	r2,72
811351a4:	00003606 	br	81135280 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
811351a8:	e0bffa17 	ldw	r2,-24(fp)
811351ac:	10800058 	cmpnei	r2,r2,1
811351b0:	1000061e 	bne	r2,zero,811351cc <OSTaskSuspend+0x124>
811351b4:	e0bff817 	ldw	r2,-32(fp)
811351b8:	e0bffb15 	stw	r2,-20(fp)
811351bc:	e0bffb17 	ldw	r2,-20(fp)
811351c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811351c4:	008010c4 	movi	r2,67
811351c8:	00002d06 	br	81135280 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
811351cc:	e0bffa17 	ldw	r2,-24(fp)
811351d0:	10800d03 	ldbu	r2,52(r2)
811351d4:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
811351d8:	e0fffd03 	ldbu	r3,-12(fp)
811351dc:	e13ffd03 	ldbu	r4,-12(fp)
811351e0:	d0a08e44 	addi	r2,gp,-32199
811351e4:	2085883a 	add	r2,r4,r2
811351e8:	10800003 	ldbu	r2,0(r2)
811351ec:	1009883a 	mov	r4,r2
811351f0:	e0bffa17 	ldw	r2,-24(fp)
811351f4:	10800d43 	ldbu	r2,53(r2)
811351f8:	0084303a 	nor	r2,zero,r2
811351fc:	2084703a 	and	r2,r4,r2
81135200:	1009883a 	mov	r4,r2
81135204:	d0a08e44 	addi	r2,gp,-32199
81135208:	1885883a 	add	r2,r3,r2
8113520c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81135210:	e0fffd03 	ldbu	r3,-12(fp)
81135214:	d0a08e44 	addi	r2,gp,-32199
81135218:	1885883a 	add	r2,r3,r2
8113521c:	10800003 	ldbu	r2,0(r2)
81135220:	10803fcc 	andi	r2,r2,255
81135224:	1000071e 	bne	r2,zero,81135244 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
81135228:	e0bffa17 	ldw	r2,-24(fp)
8113522c:	10800d83 	ldbu	r2,54(r2)
81135230:	0084303a 	nor	r2,zero,r2
81135234:	1007883a 	mov	r3,r2
81135238:	d0a08e03 	ldbu	r2,-32200(gp)
8113523c:	1884703a 	and	r2,r3,r2
81135240:	d0a08e05 	stb	r2,-32200(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
81135244:	e0bffa17 	ldw	r2,-24(fp)
81135248:	10800c03 	ldbu	r2,48(r2)
8113524c:	10800214 	ori	r2,r2,8
81135250:	1007883a 	mov	r3,r2
81135254:	e0bffa17 	ldw	r2,-24(fp)
81135258:	10c00c05 	stb	r3,48(r2)
8113525c:	e0bff817 	ldw	r2,-32(fp)
81135260:	e0bffc15 	stw	r2,-16(fp)
81135264:	e0bffc17 	ldw	r2,-16(fp)
81135268:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8113526c:	e0bff703 	ldbu	r2,-36(fp)
81135270:	10800058 	cmpnei	r2,r2,1
81135274:	1000011e 	bne	r2,zero,8113527c <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
81135278:	112e8b00 	call	8112e8b0 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113527c:	0005883a 	mov	r2,zero
}
81135280:	e037883a 	mov	sp,fp
81135284:	dfc00117 	ldw	ra,4(sp)
81135288:	df000017 	ldw	fp,0(sp)
8113528c:	dec00204 	addi	sp,sp,8
81135290:	f800283a 	ret

81135294 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
81135294:	defff604 	addi	sp,sp,-40
81135298:	de00012e 	bgeu	sp,et,811352a0 <OSTaskQuery+0xc>
8113529c:	003b68fa 	trap	3
811352a0:	dfc00915 	stw	ra,36(sp)
811352a4:	df000815 	stw	fp,32(sp)
811352a8:	df000804 	addi	fp,sp,32
811352ac:	2005883a 	mov	r2,r4
811352b0:	e17fff15 	stw	r5,-4(fp)
811352b4:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811352b8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
811352bc:	e0bffe03 	ldbu	r2,-8(fp)
811352c0:	10800a70 	cmpltui	r2,r2,41
811352c4:	1000051e 	bne	r2,zero,811352dc <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
811352c8:	e0bffe03 	ldbu	r2,-8(fp)
811352cc:	10803fe0 	cmpeqi	r2,r2,255
811352d0:	1000021e 	bne	r2,zero,811352dc <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
811352d4:	00800a84 	movi	r2,42
811352d8:	00003406 	br	811353ac <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
811352dc:	e0bfff17 	ldw	r2,-4(fp)
811352e0:	1000021e 	bne	r2,zero,811352ec <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
811352e4:	00800244 	movi	r2,9
811352e8:	00003006 	br	811353ac <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811352ec:	0005303a 	rdctl	r2,status
811352f0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811352f4:	e0fffd17 	ldw	r3,-12(fp)
811352f8:	00bfff84 	movi	r2,-2
811352fc:	1884703a 	and	r2,r3,r2
81135300:	1001703a 	wrctl	status,r2
  
  return context;
81135304:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81135308:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8113530c:	e0bffe03 	ldbu	r2,-8(fp)
81135310:	10803fd8 	cmpnei	r2,r2,255
81135314:	1000031e 	bne	r2,zero,81135324 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
81135318:	d0a09217 	ldw	r2,-32184(gp)
8113531c:	10800c83 	ldbu	r2,50(r2)
81135320:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81135324:	e0fffe03 	ldbu	r3,-8(fp)
81135328:	00a045b4 	movhi	r2,33046
8113532c:	10bfb204 	addi	r2,r2,-312
81135330:	18c7883a 	add	r3,r3,r3
81135334:	18c7883a 	add	r3,r3,r3
81135338:	10c5883a 	add	r2,r2,r3
8113533c:	10800017 	ldw	r2,0(r2)
81135340:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
81135344:	e0bffa17 	ldw	r2,-24(fp)
81135348:	1000061e 	bne	r2,zero,81135364 <OSTaskQuery+0xd0>
8113534c:	e0bff817 	ldw	r2,-32(fp)
81135350:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135354:	e0bff917 	ldw	r2,-28(fp)
81135358:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8113535c:	00800a44 	movi	r2,41
81135360:	00001206 	br	811353ac <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
81135364:	e0bffa17 	ldw	r2,-24(fp)
81135368:	10800058 	cmpnei	r2,r2,1
8113536c:	1000061e 	bne	r2,zero,81135388 <OSTaskQuery+0xf4>
81135370:	e0bff817 	ldw	r2,-32(fp)
81135374:	e0bffb15 	stw	r2,-20(fp)
81135378:	e0bffb17 	ldw	r2,-20(fp)
8113537c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81135380:	008010c4 	movi	r2,67
81135384:	00000906 	br	811353ac <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
81135388:	01801b04 	movi	r6,108
8113538c:	e17ffa17 	ldw	r5,-24(fp)
81135390:	e13fff17 	ldw	r4,-4(fp)
81135394:	112e8400 	call	8112e840 <OS_MemCopy>
81135398:	e0bff817 	ldw	r2,-32(fp)
8113539c:	e0bffc15 	stw	r2,-16(fp)
811353a0:	e0bffc17 	ldw	r2,-16(fp)
811353a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811353a8:	0005883a 	mov	r2,zero
}
811353ac:	e037883a 	mov	sp,fp
811353b0:	dfc00117 	ldw	ra,4(sp)
811353b4:	df000017 	ldw	fp,0(sp)
811353b8:	dec00204 	addi	sp,sp,8
811353bc:	f800283a 	ret

811353c0 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
811353c0:	defffc04 	addi	sp,sp,-16
811353c4:	de00012e 	bgeu	sp,et,811353cc <OS_TaskStkClr+0xc>
811353c8:	003b68fa 	trap	3
811353cc:	df000315 	stw	fp,12(sp)
811353d0:	df000304 	addi	fp,sp,12
811353d4:	e13ffd15 	stw	r4,-12(fp)
811353d8:	e17ffe15 	stw	r5,-8(fp)
811353dc:	3005883a 	mov	r2,r6
811353e0:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
811353e4:	e0bfff0b 	ldhu	r2,-4(fp)
811353e8:	1080004c 	andi	r2,r2,1
811353ec:	10000d26 	beq	r2,zero,81135424 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
811353f0:	e0bfff0b 	ldhu	r2,-4(fp)
811353f4:	1080008c 	andi	r2,r2,2
811353f8:	10000a26 	beq	r2,zero,81135424 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
811353fc:	00000706 	br	8113541c <OS_TaskStkClr+0x5c>
                size--;
81135400:	e0bffe17 	ldw	r2,-8(fp)
81135404:	10bfffc4 	addi	r2,r2,-1
81135408:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8113540c:	e0bffd17 	ldw	r2,-12(fp)
81135410:	10c00104 	addi	r3,r2,4
81135414:	e0fffd15 	stw	r3,-12(fp)
81135418:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113541c:	e0bffe17 	ldw	r2,-8(fp)
81135420:	103ff71e 	bne	r2,zero,81135400 <__reset+0xfb115400>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
81135424:	0001883a 	nop
81135428:	e037883a 	mov	sp,fp
8113542c:	df000017 	ldw	fp,0(sp)
81135430:	dec00104 	addi	sp,sp,4
81135434:	f800283a 	ret

81135438 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
81135438:	defff904 	addi	sp,sp,-28
8113543c:	de00012e 	bgeu	sp,et,81135444 <OSTimeDly+0xc>
81135440:	003b68fa 	trap	3
81135444:	dfc00615 	stw	ra,24(sp)
81135448:	df000515 	stw	fp,20(sp)
8113544c:	df000504 	addi	fp,sp,20
81135450:	2005883a 	mov	r2,r4
81135454:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135458:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113545c:	d0a09103 	ldbu	r2,-32188(gp)
81135460:	10803fcc 	andi	r2,r2,255
81135464:	1000311e 	bne	r2,zero,8113552c <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
81135468:	e0bfff0b 	ldhu	r2,-4(fp)
8113546c:	10003026 	beq	r2,zero,81135530 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135470:	0005303a 	rdctl	r2,status
81135474:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135478:	e0fffe17 	ldw	r3,-8(fp)
8113547c:	00bfff84 	movi	r2,-2
81135480:	1884703a 	and	r2,r3,r2
81135484:	1001703a 	wrctl	status,r2
  
  return context;
81135488:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8113548c:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
81135490:	d0a09217 	ldw	r2,-32184(gp)
81135494:	10800d03 	ldbu	r2,52(r2)
81135498:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113549c:	e0fffd03 	ldbu	r3,-12(fp)
811354a0:	e13ffd03 	ldbu	r4,-12(fp)
811354a4:	d0a08e44 	addi	r2,gp,-32199
811354a8:	2085883a 	add	r2,r4,r2
811354ac:	10800003 	ldbu	r2,0(r2)
811354b0:	1009883a 	mov	r4,r2
811354b4:	d0a09217 	ldw	r2,-32184(gp)
811354b8:	10800d43 	ldbu	r2,53(r2)
811354bc:	0084303a 	nor	r2,zero,r2
811354c0:	2084703a 	and	r2,r4,r2
811354c4:	1009883a 	mov	r4,r2
811354c8:	d0a08e44 	addi	r2,gp,-32199
811354cc:	1885883a 	add	r2,r3,r2
811354d0:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
811354d4:	e0fffd03 	ldbu	r3,-12(fp)
811354d8:	d0a08e44 	addi	r2,gp,-32199
811354dc:	1885883a 	add	r2,r3,r2
811354e0:	10800003 	ldbu	r2,0(r2)
811354e4:	10803fcc 	andi	r2,r2,255
811354e8:	1000071e 	bne	r2,zero,81135508 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
811354ec:	d0a09217 	ldw	r2,-32184(gp)
811354f0:	10800d83 	ldbu	r2,54(r2)
811354f4:	0084303a 	nor	r2,zero,r2
811354f8:	1007883a 	mov	r3,r2
811354fc:	d0a08e03 	ldbu	r2,-32200(gp)
81135500:	1884703a 	and	r2,r3,r2
81135504:	d0a08e05 	stb	r2,-32200(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
81135508:	d0a09217 	ldw	r2,-32184(gp)
8113550c:	e0ffff0b 	ldhu	r3,-4(fp)
81135510:	10c00b8d 	sth	r3,46(r2)
81135514:	e0bffb17 	ldw	r2,-20(fp)
81135518:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113551c:	e0bffc17 	ldw	r2,-16(fp)
81135520:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
81135524:	112e8b00 	call	8112e8b0 <OS_Sched>
81135528:	00000106 	br	81135530 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
8113552c:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
81135530:	e037883a 	mov	sp,fp
81135534:	dfc00117 	ldw	ra,4(sp)
81135538:	df000017 	ldw	fp,0(sp)
8113553c:	dec00204 	addi	sp,sp,8
81135540:	f800283a 	ret

81135544 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
81135544:	defff804 	addi	sp,sp,-32
81135548:	de00012e 	bgeu	sp,et,81135550 <OSTimeDlyHMSM+0xc>
8113554c:	003b68fa 	trap	3
81135550:	dfc00715 	stw	ra,28(sp)
81135554:	df000615 	stw	fp,24(sp)
81135558:	df000604 	addi	fp,sp,24
8113555c:	2015883a 	mov	r10,r4
81135560:	2809883a 	mov	r4,r5
81135564:	3007883a 	mov	r3,r6
81135568:	3805883a 	mov	r2,r7
8113556c:	e2bffc05 	stb	r10,-16(fp)
81135570:	e13ffd05 	stb	r4,-12(fp)
81135574:	e0fffe05 	stb	r3,-8(fp)
81135578:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113557c:	d0a09103 	ldbu	r2,-32188(gp)
81135580:	10803fcc 	andi	r2,r2,255
81135584:	10000226 	beq	r2,zero,81135590 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
81135588:	00801544 	movi	r2,85
8113558c:	00004106 	br	81135694 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
81135590:	e0bffc03 	ldbu	r2,-16(fp)
81135594:	1000081e 	bne	r2,zero,811355b8 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
81135598:	e0bffd03 	ldbu	r2,-12(fp)
8113559c:	1000061e 	bne	r2,zero,811355b8 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
811355a0:	e0bffe03 	ldbu	r2,-8(fp)
811355a4:	1000041e 	bne	r2,zero,811355b8 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
811355a8:	e0bfff0b 	ldhu	r2,-4(fp)
811355ac:	1000021e 	bne	r2,zero,811355b8 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
811355b0:	00801504 	movi	r2,84
811355b4:	00003706 	br	81135694 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
811355b8:	e0bffd03 	ldbu	r2,-12(fp)
811355bc:	10800f30 	cmpltui	r2,r2,60
811355c0:	1000021e 	bne	r2,zero,811355cc <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
811355c4:	00801444 	movi	r2,81
811355c8:	00003206 	br	81135694 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
811355cc:	e0bffe03 	ldbu	r2,-8(fp)
811355d0:	10800f30 	cmpltui	r2,r2,60
811355d4:	1000021e 	bne	r2,zero,811355e0 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
811355d8:	00801484 	movi	r2,82
811355dc:	00002d06 	br	81135694 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
811355e0:	e0bfff0b 	ldhu	r2,-4(fp)
811355e4:	1080fa30 	cmpltui	r2,r2,1000
811355e8:	1000021e 	bne	r2,zero,811355f4 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
811355ec:	008014c4 	movi	r2,83
811355f0:	00002806 	br	81135694 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
811355f4:	e0bffc03 	ldbu	r2,-16(fp)
811355f8:	10c38424 	muli	r3,r2,3600
811355fc:	e0bffd03 	ldbu	r2,-12(fp)
81135600:	10800f24 	muli	r2,r2,60
81135604:	1887883a 	add	r3,r3,r2
81135608:	e0bffe03 	ldbu	r2,-8(fp)
8113560c:	1885883a 	add	r2,r3,r2
81135610:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
81135614:	e0bfff0b 	ldhu	r2,-4(fp)
81135618:	10c0fa24 	muli	r3,r2,1000
8113561c:	008418b4 	movhi	r2,4194
81135620:	109374c4 	addi	r2,r2,19923
81135624:	188a383a 	mulxuu	r5,r3,r2
81135628:	1885383a 	mul	r2,r3,r2
8113562c:	1011883a 	mov	r8,r2
81135630:	2813883a 	mov	r9,r5
81135634:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81135638:	2085883a 	add	r2,r4,r2
8113563c:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
81135640:	e0bffb17 	ldw	r2,-20(fp)
81135644:	1004d43a 	srli	r2,r2,16
81135648:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8113564c:	e0bffb17 	ldw	r2,-20(fp)
81135650:	10bfffcc 	andi	r2,r2,65535
81135654:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
81135658:	e0bffb17 	ldw	r2,-20(fp)
8113565c:	10bfffcc 	andi	r2,r2,65535
81135660:	1009883a 	mov	r4,r2
81135664:	11354380 	call	81135438 <OSTimeDly>
    while (loops > 0) {
81135668:	00000706 	br	81135688 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8113566c:	01200014 	movui	r4,32768
81135670:	11354380 	call	81135438 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81135674:	01200014 	movui	r4,32768
81135678:	11354380 	call	81135438 <OSTimeDly>
        loops--;
8113567c:	e0bffa0b 	ldhu	r2,-24(fp)
81135680:	10bfffc4 	addi	r2,r2,-1
81135684:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
81135688:	e0bffa0b 	ldhu	r2,-24(fp)
8113568c:	103ff71e 	bne	r2,zero,8113566c <__reset+0xfb11566c>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
81135690:	0005883a 	mov	r2,zero
}
81135694:	e037883a 	mov	sp,fp
81135698:	dfc00117 	ldw	ra,4(sp)
8113569c:	df000017 	ldw	fp,0(sp)
811356a0:	dec00204 	addi	sp,sp,8
811356a4:	f800283a 	ret

811356a8 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
811356a8:	defff504 	addi	sp,sp,-44
811356ac:	de00012e 	bgeu	sp,et,811356b4 <OSTimeDlyResume+0xc>
811356b0:	003b68fa 	trap	3
811356b4:	dfc00a15 	stw	ra,40(sp)
811356b8:	df000915 	stw	fp,36(sp)
811356bc:	df000904 	addi	fp,sp,36
811356c0:	2005883a 	mov	r2,r4
811356c4:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811356c8:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
811356cc:	e0bfff03 	ldbu	r2,-4(fp)
811356d0:	10800a30 	cmpltui	r2,r2,40
811356d4:	1000021e 	bne	r2,zero,811356e0 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
811356d8:	00800a84 	movi	r2,42
811356dc:	00006406 	br	81135870 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811356e0:	0005303a 	rdctl	r2,status
811356e4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811356e8:	e0fffe17 	ldw	r3,-8(fp)
811356ec:	00bfff84 	movi	r2,-2
811356f0:	1884703a 	and	r2,r3,r2
811356f4:	1001703a 	wrctl	status,r2
  
  return context;
811356f8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811356fc:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
81135700:	e0ffff03 	ldbu	r3,-4(fp)
81135704:	00a045b4 	movhi	r2,33046
81135708:	10bfb204 	addi	r2,r2,-312
8113570c:	18c7883a 	add	r3,r3,r3
81135710:	18c7883a 	add	r3,r3,r3
81135714:	10c5883a 	add	r2,r2,r3
81135718:	10800017 	ldw	r2,0(r2)
8113571c:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
81135720:	e0bff917 	ldw	r2,-28(fp)
81135724:	1000061e 	bne	r2,zero,81135740 <OSTimeDlyResume+0x98>
81135728:	e0bff717 	ldw	r2,-36(fp)
8113572c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135730:	e0bff817 	ldw	r2,-32(fp)
81135734:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81135738:	008010c4 	movi	r2,67
8113573c:	00004c06 	br	81135870 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81135740:	e0bff917 	ldw	r2,-28(fp)
81135744:	10800058 	cmpnei	r2,r2,1
81135748:	1000061e 	bne	r2,zero,81135764 <OSTimeDlyResume+0xbc>
8113574c:	e0bff717 	ldw	r2,-36(fp)
81135750:	e0bffa15 	stw	r2,-24(fp)
81135754:	e0bffa17 	ldw	r2,-24(fp)
81135758:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113575c:	008010c4 	movi	r2,67
81135760:	00004306 	br	81135870 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81135764:	e0bff917 	ldw	r2,-28(fp)
81135768:	10800b8b 	ldhu	r2,46(r2)
8113576c:	10bfffcc 	andi	r2,r2,65535
81135770:	1000061e 	bne	r2,zero,8113578c <OSTimeDlyResume+0xe4>
81135774:	e0bff717 	ldw	r2,-36(fp)
81135778:	e0bffb15 	stw	r2,-20(fp)
8113577c:	e0bffb17 	ldw	r2,-20(fp)
81135780:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
81135784:	00801404 	movi	r2,80
81135788:	00003906 	br	81135870 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8113578c:	e0bff917 	ldw	r2,-28(fp)
81135790:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81135794:	e0bff917 	ldw	r2,-28(fp)
81135798:	10800c03 	ldbu	r2,48(r2)
8113579c:	10803fcc 	andi	r2,r2,255
811357a0:	10800dcc 	andi	r2,r2,55
811357a4:	10000b26 	beq	r2,zero,811357d4 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
811357a8:	e0bff917 	ldw	r2,-28(fp)
811357ac:	10c00c03 	ldbu	r3,48(r2)
811357b0:	00bff204 	movi	r2,-56
811357b4:	1884703a 	and	r2,r3,r2
811357b8:	1007883a 	mov	r3,r2
811357bc:	e0bff917 	ldw	r2,-28(fp)
811357c0:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
811357c4:	e0bff917 	ldw	r2,-28(fp)
811357c8:	00c00044 	movi	r3,1
811357cc:	10c00c45 	stb	r3,49(r2)
811357d0:	00000206 	br	811357dc <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
811357d4:	e0bff917 	ldw	r2,-28(fp)
811357d8:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
811357dc:	e0bff917 	ldw	r2,-28(fp)
811357e0:	10800c03 	ldbu	r2,48(r2)
811357e4:	10803fcc 	andi	r2,r2,255
811357e8:	1080020c 	andi	r2,r2,8
811357ec:	10001b1e 	bne	r2,zero,8113585c <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
811357f0:	e0bff917 	ldw	r2,-28(fp)
811357f4:	10c00d83 	ldbu	r3,54(r2)
811357f8:	d0a08e03 	ldbu	r2,-32200(gp)
811357fc:	1884b03a 	or	r2,r3,r2
81135800:	d0a08e05 	stb	r2,-32200(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81135804:	e0bff917 	ldw	r2,-28(fp)
81135808:	10800d03 	ldbu	r2,52(r2)
8113580c:	10c03fcc 	andi	r3,r2,255
81135810:	e0bff917 	ldw	r2,-28(fp)
81135814:	10800d03 	ldbu	r2,52(r2)
81135818:	11003fcc 	andi	r4,r2,255
8113581c:	d0a08e44 	addi	r2,gp,-32199
81135820:	2085883a 	add	r2,r4,r2
81135824:	11000003 	ldbu	r4,0(r2)
81135828:	e0bff917 	ldw	r2,-28(fp)
8113582c:	10800d43 	ldbu	r2,53(r2)
81135830:	2084b03a 	or	r2,r4,r2
81135834:	1009883a 	mov	r4,r2
81135838:	d0a08e44 	addi	r2,gp,-32199
8113583c:	1885883a 	add	r2,r3,r2
81135840:	11000005 	stb	r4,0(r2)
81135844:	e0bff717 	ldw	r2,-36(fp)
81135848:	e0bffc15 	stw	r2,-16(fp)
8113584c:	e0bffc17 	ldw	r2,-16(fp)
81135850:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
81135854:	112e8b00 	call	8112e8b0 <OS_Sched>
81135858:	00000406 	br	8113586c <OSTimeDlyResume+0x1c4>
8113585c:	e0bff717 	ldw	r2,-36(fp)
81135860:	e0bffd15 	stw	r2,-12(fp)
81135864:	e0bffd17 	ldw	r2,-12(fp)
81135868:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8113586c:	0005883a 	mov	r2,zero
}
81135870:	e037883a 	mov	sp,fp
81135874:	dfc00117 	ldw	ra,4(sp)
81135878:	df000017 	ldw	fp,0(sp)
8113587c:	dec00204 	addi	sp,sp,8
81135880:	f800283a 	ret

81135884 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
81135884:	defffb04 	addi	sp,sp,-20
81135888:	de00012e 	bgeu	sp,et,81135890 <OSTimeGet+0xc>
8113588c:	003b68fa 	trap	3
81135890:	df000415 	stw	fp,16(sp)
81135894:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135898:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113589c:	0005303a 	rdctl	r2,status
811358a0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811358a4:	e0fffe17 	ldw	r3,-8(fp)
811358a8:	00bfff84 	movi	r2,-2
811358ac:	1884703a 	and	r2,r3,r2
811358b0:	1001703a 	wrctl	status,r2
  
  return context;
811358b4:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
811358b8:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
811358bc:	d0a09417 	ldw	r2,-32176(gp)
811358c0:	e0bffd15 	stw	r2,-12(fp)
811358c4:	e0bffc17 	ldw	r2,-16(fp)
811358c8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811358cc:	e0bfff17 	ldw	r2,-4(fp)
811358d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
811358d4:	e0bffd17 	ldw	r2,-12(fp)
}
811358d8:	e037883a 	mov	sp,fp
811358dc:	df000017 	ldw	fp,0(sp)
811358e0:	dec00104 	addi	sp,sp,4
811358e4:	f800283a 	ret

811358e8 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
811358e8:	defffb04 	addi	sp,sp,-20
811358ec:	de00012e 	bgeu	sp,et,811358f4 <OSTimeSet+0xc>
811358f0:	003b68fa 	trap	3
811358f4:	df000415 	stw	fp,16(sp)
811358f8:	df000404 	addi	fp,sp,16
811358fc:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135900:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135904:	0005303a 	rdctl	r2,status
81135908:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113590c:	e0fffd17 	ldw	r3,-12(fp)
81135910:	00bfff84 	movi	r2,-2
81135914:	1884703a 	and	r2,r3,r2
81135918:	1001703a 	wrctl	status,r2
  
  return context;
8113591c:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
81135920:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
81135924:	e0bfff17 	ldw	r2,-4(fp)
81135928:	d0a09415 	stw	r2,-32176(gp)
8113592c:	e0bffc17 	ldw	r2,-16(fp)
81135930:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135934:	e0bffe17 	ldw	r2,-8(fp)
81135938:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113593c:	0001883a 	nop
81135940:	e037883a 	mov	sp,fp
81135944:	df000017 	ldw	fp,0(sp)
81135948:	dec00104 	addi	sp,sp,4
8113594c:	f800283a 	ret

81135950 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
81135950:	defff804 	addi	sp,sp,-32
81135954:	de00012e 	bgeu	sp,et,8113595c <OSTmrCreate+0xc>
81135958:	003b68fa 	trap	3
8113595c:	dfc00715 	stw	ra,28(sp)
81135960:	df000615 	stw	fp,24(sp)
81135964:	df000604 	addi	fp,sp,24
81135968:	e13ffc15 	stw	r4,-16(fp)
8113596c:	e17ffd15 	stw	r5,-12(fp)
81135970:	3005883a 	mov	r2,r6
81135974:	e1ffff15 	stw	r7,-4(fp)
81135978:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113597c:	e0800417 	ldw	r2,16(fp)
81135980:	1000021e 	bne	r2,zero,8113598c <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
81135984:	0005883a 	mov	r2,zero
81135988:	00005d06 	br	81135b00 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
8113598c:	e0bffe03 	ldbu	r2,-8(fp)
81135990:	10c00060 	cmpeqi	r3,r2,1
81135994:	1800091e 	bne	r3,zero,811359bc <OSTmrCreate+0x6c>
81135998:	108000a0 	cmpeqi	r2,r2,2
8113599c:	10000e26 	beq	r2,zero,811359d8 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
811359a0:	e0bffd17 	ldw	r2,-12(fp)
811359a4:	1000111e 	bne	r2,zero,811359ec <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
811359a8:	e0800417 	ldw	r2,16(fp)
811359ac:	00ffe0c4 	movi	r3,-125
811359b0:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
811359b4:	0005883a 	mov	r2,zero
811359b8:	00005106 	br	81135b00 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
811359bc:	e0bffc17 	ldw	r2,-16(fp)
811359c0:	10000c1e 	bne	r2,zero,811359f4 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
811359c4:	e0800417 	ldw	r2,16(fp)
811359c8:	00ffe084 	movi	r3,-126
811359cc:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
811359d0:	0005883a 	mov	r2,zero
811359d4:	00004a06 	br	81135b00 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
811359d8:	e0800417 	ldw	r2,16(fp)
811359dc:	00ffe104 	movi	r3,-124
811359e0:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
811359e4:	0005883a 	mov	r2,zero
811359e8:	00004506 	br	81135b00 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
811359ec:	0001883a 	nop
811359f0:	00000106 	br	811359f8 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
811359f4:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
811359f8:	d0a09103 	ldbu	r2,-32188(gp)
811359fc:	10803fcc 	andi	r2,r2,255
81135a00:	10000526 	beq	r2,zero,81135a18 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
81135a04:	e0800417 	ldw	r2,16(fp)
81135a08:	00ffe2c4 	movi	r3,-117
81135a0c:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81135a10:	0005883a 	mov	r2,zero
81135a14:	00003a06 	br	81135b00 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
81135a18:	11369080 	call	81136908 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
81135a1c:	11363a80 	call	811363a8 <OSTmr_Alloc>
81135a20:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
81135a24:	e0bffa17 	ldw	r2,-24(fp)
81135a28:	1000061e 	bne	r2,zero,81135a44 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
81135a2c:	113694c0 	call	8113694c <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
81135a30:	e0800417 	ldw	r2,16(fp)
81135a34:	00ffe184 	movi	r3,-122
81135a38:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81135a3c:	0005883a 	mov	r2,zero
81135a40:	00002f06 	br	81135b00 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
81135a44:	e0bffa17 	ldw	r2,-24(fp)
81135a48:	00c00044 	movi	r3,1
81135a4c:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81135a50:	e0bffa17 	ldw	r2,-24(fp)
81135a54:	e0fffc17 	ldw	r3,-16(fp)
81135a58:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
81135a5c:	e0bffa17 	ldw	r2,-24(fp)
81135a60:	e0fffd17 	ldw	r3,-12(fp)
81135a64:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
81135a68:	e0bffa17 	ldw	r2,-24(fp)
81135a6c:	e0fffe03 	ldbu	r3,-8(fp)
81135a70:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
81135a74:	e0bffa17 	ldw	r2,-24(fp)
81135a78:	e0ffff17 	ldw	r3,-4(fp)
81135a7c:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
81135a80:	e0bffa17 	ldw	r2,-24(fp)
81135a84:	e0c00217 	ldw	r3,8(fp)
81135a88:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
81135a8c:	e0800317 	ldw	r2,12(fp)
81135a90:	10001726 	beq	r2,zero,81135af0 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
81135a94:	e1000317 	ldw	r4,12(fp)
81135a98:	112ea800 	call	8112ea80 <OS_StrLen>
81135a9c:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
81135aa0:	e0bffb03 	ldbu	r2,-20(fp)
81135aa4:	10800428 	cmpgeui	r2,r2,16
81135aa8:	1000061e 	bne	r2,zero,81135ac4 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
81135aac:	e0bffa17 	ldw	r2,-24(fp)
81135ab0:	10800804 	addi	r2,r2,32
81135ab4:	e1400317 	ldw	r5,12(fp)
81135ab8:	1009883a 	mov	r4,r2
81135abc:	112ea040 	call	8112ea04 <OS_StrCopy>
81135ac0:	00000b06 	br	81135af0 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
81135ac4:	e0bffa17 	ldw	r2,-24(fp)
81135ac8:	00c008c4 	movi	r3,35
81135acc:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
81135ad0:	e0bffa17 	ldw	r2,-24(fp)
81135ad4:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
81135ad8:	e0800417 	ldw	r2,16(fp)
81135adc:	00ffe304 	movi	r3,-116
81135ae0:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
81135ae4:	113694c0 	call	8113694c <OSTmr_Unlock>
            return (ptmr);
81135ae8:	e0bffa17 	ldw	r2,-24(fp)
81135aec:	00000406 	br	81135b00 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81135af0:	113694c0 	call	8113694c <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
81135af4:	e0800417 	ldw	r2,16(fp)
81135af8:	10000005 	stb	zero,0(r2)
    return (ptmr);
81135afc:	e0bffa17 	ldw	r2,-24(fp)
}
81135b00:	e037883a 	mov	sp,fp
81135b04:	dfc00117 	ldw	ra,4(sp)
81135b08:	df000017 	ldw	fp,0(sp)
81135b0c:	dec00204 	addi	sp,sp,8
81135b10:	f800283a 	ret

81135b14 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
81135b14:	defffc04 	addi	sp,sp,-16
81135b18:	de00012e 	bgeu	sp,et,81135b20 <OSTmrDel+0xc>
81135b1c:	003b68fa 	trap	3
81135b20:	dfc00315 	stw	ra,12(sp)
81135b24:	df000215 	stw	fp,8(sp)
81135b28:	df000204 	addi	fp,sp,8
81135b2c:	e13ffe15 	stw	r4,-8(fp)
81135b30:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81135b34:	e0bfff17 	ldw	r2,-4(fp)
81135b38:	1000021e 	bne	r2,zero,81135b44 <OSTmrDel+0x30>
        return (OS_FALSE);
81135b3c:	0005883a 	mov	r2,zero
81135b40:	00003f06 	br	81135c40 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81135b44:	e0bffe17 	ldw	r2,-8(fp)
81135b48:	1000051e 	bne	r2,zero,81135b60 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81135b4c:	e0bfff17 	ldw	r2,-4(fp)
81135b50:	00ffe284 	movi	r3,-118
81135b54:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81135b58:	0005883a 	mov	r2,zero
81135b5c:	00003806 	br	81135c40 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81135b60:	e0bffe17 	ldw	r2,-8(fp)
81135b64:	10800003 	ldbu	r2,0(r2)
81135b68:	10803fcc 	andi	r2,r2,255
81135b6c:	10801920 	cmpeqi	r2,r2,100
81135b70:	1000051e 	bne	r2,zero,81135b88 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81135b74:	e0bfff17 	ldw	r2,-4(fp)
81135b78:	00ffe244 	movi	r3,-119
81135b7c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81135b80:	0005883a 	mov	r2,zero
81135b84:	00002e06 	br	81135c40 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81135b88:	d0a09103 	ldbu	r2,-32188(gp)
81135b8c:	10803fcc 	andi	r2,r2,255
81135b90:	10000526 	beq	r2,zero,81135ba8 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
81135b94:	e0bfff17 	ldw	r2,-4(fp)
81135b98:	00ffe2c4 	movi	r3,-117
81135b9c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81135ba0:	0005883a 	mov	r2,zero
81135ba4:	00002606 	br	81135c40 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
81135ba8:	11369080 	call	81136908 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81135bac:	e0bffe17 	ldw	r2,-8(fp)
81135bb0:	10800c43 	ldbu	r2,49(r2)
81135bb4:	10803fcc 	andi	r2,r2,255
81135bb8:	10c000c8 	cmpgei	r3,r2,3
81135bbc:	1800031e 	bne	r3,zero,81135bcc <OSTmrDel+0xb8>
81135bc0:	00800d16 	blt	zero,r2,81135bf8 <OSTmrDel+0xe4>
81135bc4:	10001326 	beq	r2,zero,81135c14 <OSTmrDel+0x100>
81135bc8:	00001806 	br	81135c2c <OSTmrDel+0x118>
81135bcc:	108000e0 	cmpeqi	r2,r2,3
81135bd0:	10001626 	beq	r2,zero,81135c2c <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
81135bd4:	e13ffe17 	ldw	r4,-8(fp)
81135bd8:	113680c0 	call	8113680c <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81135bdc:	e13ffe17 	ldw	r4,-8(fp)
81135be0:	113641c0 	call	8113641c <OSTmr_Free>
             OSTmr_Unlock();
81135be4:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81135be8:	e0bfff17 	ldw	r2,-4(fp)
81135bec:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81135bf0:	00800044 	movi	r2,1
81135bf4:	00001206 	br	81135c40 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81135bf8:	e13ffe17 	ldw	r4,-8(fp)
81135bfc:	113641c0 	call	8113641c <OSTmr_Free>
             OSTmr_Unlock();
81135c00:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81135c04:	e0bfff17 	ldw	r2,-4(fp)
81135c08:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81135c0c:	00800044 	movi	r2,1
81135c10:	00000b06 	br	81135c40 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
81135c14:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81135c18:	e0bfff17 	ldw	r2,-4(fp)
81135c1c:	00ffe1c4 	movi	r3,-121
81135c20:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81135c24:	0005883a 	mov	r2,zero
81135c28:	00000506 	br	81135c40 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
81135c2c:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81135c30:	e0bfff17 	ldw	r2,-4(fp)
81135c34:	00ffe344 	movi	r3,-115
81135c38:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81135c3c:	0005883a 	mov	r2,zero
    }
}
81135c40:	e037883a 	mov	sp,fp
81135c44:	dfc00117 	ldw	ra,4(sp)
81135c48:	df000017 	ldw	fp,0(sp)
81135c4c:	dec00204 	addi	sp,sp,8
81135c50:	f800283a 	ret

81135c54 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
81135c54:	defffa04 	addi	sp,sp,-24
81135c58:	de00012e 	bgeu	sp,et,81135c60 <OSTmrNameGet+0xc>
81135c5c:	003b68fa 	trap	3
81135c60:	dfc00515 	stw	ra,20(sp)
81135c64:	df000415 	stw	fp,16(sp)
81135c68:	df000404 	addi	fp,sp,16
81135c6c:	e13ffd15 	stw	r4,-12(fp)
81135c70:	e17ffe15 	stw	r5,-8(fp)
81135c74:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81135c78:	e0bfff17 	ldw	r2,-4(fp)
81135c7c:	1000021e 	bne	r2,zero,81135c88 <OSTmrNameGet+0x34>
        return (0);
81135c80:	0005883a 	mov	r2,zero
81135c84:	00003e06 	br	81135d80 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
81135c88:	e0bffe17 	ldw	r2,-8(fp)
81135c8c:	1000051e 	bne	r2,zero,81135ca4 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
81135c90:	e0bfff17 	ldw	r2,-4(fp)
81135c94:	00ffe204 	movi	r3,-120
81135c98:	10c00005 	stb	r3,0(r2)
        return (0);
81135c9c:	0005883a 	mov	r2,zero
81135ca0:	00003706 	br	81135d80 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81135ca4:	e0bffd17 	ldw	r2,-12(fp)
81135ca8:	1000051e 	bne	r2,zero,81135cc0 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
81135cac:	e0bfff17 	ldw	r2,-4(fp)
81135cb0:	00ffe284 	movi	r3,-118
81135cb4:	10c00005 	stb	r3,0(r2)
        return (0);
81135cb8:	0005883a 	mov	r2,zero
81135cbc:	00003006 	br	81135d80 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81135cc0:	e0bffd17 	ldw	r2,-12(fp)
81135cc4:	10800003 	ldbu	r2,0(r2)
81135cc8:	10803fcc 	andi	r2,r2,255
81135ccc:	10801920 	cmpeqi	r2,r2,100
81135cd0:	1000051e 	bne	r2,zero,81135ce8 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81135cd4:	e0bfff17 	ldw	r2,-4(fp)
81135cd8:	00ffe244 	movi	r3,-119
81135cdc:	10c00005 	stb	r3,0(r2)
        return (0);
81135ce0:	0005883a 	mov	r2,zero
81135ce4:	00002606 	br	81135d80 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81135ce8:	d0a09103 	ldbu	r2,-32188(gp)
81135cec:	10803fcc 	andi	r2,r2,255
81135cf0:	10000526 	beq	r2,zero,81135d08 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
81135cf4:	e0bfff17 	ldw	r2,-4(fp)
81135cf8:	00c00444 	movi	r3,17
81135cfc:	10c00005 	stb	r3,0(r2)
        return (0);
81135d00:	0005883a 	mov	r2,zero
81135d04:	00001e06 	br	81135d80 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
81135d08:	11369080 	call	81136908 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81135d0c:	e0bffd17 	ldw	r2,-12(fp)
81135d10:	10800c43 	ldbu	r2,49(r2)
81135d14:	10803fcc 	andi	r2,r2,255
81135d18:	10000e26 	beq	r2,zero,81135d54 <OSTmrNameGet+0x100>
81135d1c:	10001316 	blt	r2,zero,81135d6c <OSTmrNameGet+0x118>
81135d20:	10800108 	cmpgei	r2,r2,4
81135d24:	1000111e 	bne	r2,zero,81135d6c <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
81135d28:	e0bffd17 	ldw	r2,-12(fp)
81135d2c:	10800804 	addi	r2,r2,32
81135d30:	100b883a 	mov	r5,r2
81135d34:	e13ffe17 	ldw	r4,-8(fp)
81135d38:	112ea040 	call	8112ea04 <OS_StrCopy>
81135d3c:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
81135d40:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81135d44:	e0bfff17 	ldw	r2,-4(fp)
81135d48:	10000005 	stb	zero,0(r2)
             return (len);
81135d4c:	e0bffc03 	ldbu	r2,-16(fp)
81135d50:	00000b06 	br	81135d80 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
81135d54:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81135d58:	e0bfff17 	ldw	r2,-4(fp)
81135d5c:	00ffe1c4 	movi	r3,-121
81135d60:	10c00005 	stb	r3,0(r2)
             return (0);
81135d64:	0005883a 	mov	r2,zero
81135d68:	00000506 	br	81135d80 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
81135d6c:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81135d70:	e0bfff17 	ldw	r2,-4(fp)
81135d74:	00ffe344 	movi	r3,-115
81135d78:	10c00005 	stb	r3,0(r2)
             return (0);
81135d7c:	0005883a 	mov	r2,zero
    }
}
81135d80:	e037883a 	mov	sp,fp
81135d84:	dfc00117 	ldw	ra,4(sp)
81135d88:	df000017 	ldw	fp,0(sp)
81135d8c:	dec00204 	addi	sp,sp,8
81135d90:	f800283a 	ret

81135d94 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
81135d94:	defffb04 	addi	sp,sp,-20
81135d98:	de00012e 	bgeu	sp,et,81135da0 <OSTmrRemainGet+0xc>
81135d9c:	003b68fa 	trap	3
81135da0:	dfc00415 	stw	ra,16(sp)
81135da4:	df000315 	stw	fp,12(sp)
81135da8:	df000304 	addi	fp,sp,12
81135dac:	e13ffe15 	stw	r4,-8(fp)
81135db0:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81135db4:	e0bfff17 	ldw	r2,-4(fp)
81135db8:	1000021e 	bne	r2,zero,81135dc4 <OSTmrRemainGet+0x30>
        return (0);
81135dbc:	0005883a 	mov	r2,zero
81135dc0:	00005d06 	br	81135f38 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
81135dc4:	e0bffe17 	ldw	r2,-8(fp)
81135dc8:	1000051e 	bne	r2,zero,81135de0 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81135dcc:	e0bfff17 	ldw	r2,-4(fp)
81135dd0:	00ffe284 	movi	r3,-118
81135dd4:	10c00005 	stb	r3,0(r2)
        return (0);
81135dd8:	0005883a 	mov	r2,zero
81135ddc:	00005606 	br	81135f38 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81135de0:	e0bffe17 	ldw	r2,-8(fp)
81135de4:	10800003 	ldbu	r2,0(r2)
81135de8:	10803fcc 	andi	r2,r2,255
81135dec:	10801920 	cmpeqi	r2,r2,100
81135df0:	1000051e 	bne	r2,zero,81135e08 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81135df4:	e0bfff17 	ldw	r2,-4(fp)
81135df8:	00ffe244 	movi	r3,-119
81135dfc:	10c00005 	stb	r3,0(r2)
        return (0);
81135e00:	0005883a 	mov	r2,zero
81135e04:	00004c06 	br	81135f38 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81135e08:	d0a09103 	ldbu	r2,-32188(gp)
81135e0c:	10803fcc 	andi	r2,r2,255
81135e10:	10000526 	beq	r2,zero,81135e28 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81135e14:	e0bfff17 	ldw	r2,-4(fp)
81135e18:	00ffe2c4 	movi	r3,-117
81135e1c:	10c00005 	stb	r3,0(r2)
        return (0);
81135e20:	0005883a 	mov	r2,zero
81135e24:	00004406 	br	81135f38 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
81135e28:	11369080 	call	81136908 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81135e2c:	e0bffe17 	ldw	r2,-8(fp)
81135e30:	10800c43 	ldbu	r2,49(r2)
81135e34:	10803fcc 	andi	r2,r2,255
81135e38:	10c00060 	cmpeqi	r3,r2,1
81135e3c:	1800121e 	bne	r3,zero,81135e88 <OSTmrRemainGet+0xf4>
81135e40:	10c00088 	cmpgei	r3,r2,2
81135e44:	1800021e 	bne	r3,zero,81135e50 <OSTmrRemainGet+0xbc>
81135e48:	10003026 	beq	r2,zero,81135f0c <OSTmrRemainGet+0x178>
81135e4c:	00003506 	br	81135f24 <OSTmrRemainGet+0x190>
81135e50:	10c000a0 	cmpeqi	r3,r2,2
81135e54:	1800281e 	bne	r3,zero,81135ef8 <OSTmrRemainGet+0x164>
81135e58:	108000e0 	cmpeqi	r2,r2,3
81135e5c:	10003126 	beq	r2,zero,81135f24 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
81135e60:	e0bffe17 	ldw	r2,-8(fp)
81135e64:	10c00517 	ldw	r3,20(r2)
81135e68:	d0a09317 	ldw	r2,-32180(gp)
81135e6c:	1885c83a 	sub	r2,r3,r2
81135e70:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
81135e74:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
81135e78:	e0bfff17 	ldw	r2,-4(fp)
81135e7c:	10000005 	stb	zero,0(r2)
             return (remain);
81135e80:	e0bffd17 	ldw	r2,-12(fp)
81135e84:	00002c06 	br	81135f38 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
81135e88:	e0bffe17 	ldw	r2,-8(fp)
81135e8c:	10800c03 	ldbu	r2,48(r2)
81135e90:	10803fcc 	andi	r2,r2,255
81135e94:	108000a0 	cmpeqi	r2,r2,2
81135e98:	10000e26 	beq	r2,zero,81135ed4 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
81135e9c:	e0bffe17 	ldw	r2,-8(fp)
81135ea0:	10800617 	ldw	r2,24(r2)
81135ea4:	1000041e 	bne	r2,zero,81135eb8 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
81135ea8:	e0bffe17 	ldw	r2,-8(fp)
81135eac:	10800717 	ldw	r2,28(r2)
81135eb0:	e0bffd15 	stw	r2,-12(fp)
81135eb4:	00000306 	br	81135ec4 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
81135eb8:	e0bffe17 	ldw	r2,-8(fp)
81135ebc:	10800617 	ldw	r2,24(r2)
81135ec0:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
81135ec4:	113694c0 	call	8113694c <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81135ec8:	e0bfff17 	ldw	r2,-4(fp)
81135ecc:	10000005 	stb	zero,0(r2)
                      break;
81135ed0:	00000706 	br	81135ef0 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
81135ed4:	e0bffe17 	ldw	r2,-8(fp)
81135ed8:	10800617 	ldw	r2,24(r2)
81135edc:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
81135ee0:	113694c0 	call	8113694c <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81135ee4:	e0bfff17 	ldw	r2,-4(fp)
81135ee8:	10000005 	stb	zero,0(r2)
                      break;
81135eec:	0001883a 	nop
             }
             return (remain);
81135ef0:	e0bffd17 	ldw	r2,-12(fp)
81135ef4:	00001006 	br	81135f38 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
81135ef8:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81135efc:	e0bfff17 	ldw	r2,-4(fp)
81135f00:	10000005 	stb	zero,0(r2)
             return (0);
81135f04:	0005883a 	mov	r2,zero
81135f08:	00000b06 	br	81135f38 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
81135f0c:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81135f10:	e0bfff17 	ldw	r2,-4(fp)
81135f14:	00ffe1c4 	movi	r3,-121
81135f18:	10c00005 	stb	r3,0(r2)
             return (0);
81135f1c:	0005883a 	mov	r2,zero
81135f20:	00000506 	br	81135f38 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
81135f24:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81135f28:	e0bfff17 	ldw	r2,-4(fp)
81135f2c:	00ffe344 	movi	r3,-115
81135f30:	10c00005 	stb	r3,0(r2)
             return (0);
81135f34:	0005883a 	mov	r2,zero
    }
}
81135f38:	e037883a 	mov	sp,fp
81135f3c:	dfc00117 	ldw	ra,4(sp)
81135f40:	df000017 	ldw	fp,0(sp)
81135f44:	dec00204 	addi	sp,sp,8
81135f48:	f800283a 	ret

81135f4c <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
81135f4c:	defffb04 	addi	sp,sp,-20
81135f50:	de00012e 	bgeu	sp,et,81135f58 <OSTmrStateGet+0xc>
81135f54:	003b68fa 	trap	3
81135f58:	dfc00415 	stw	ra,16(sp)
81135f5c:	df000315 	stw	fp,12(sp)
81135f60:	df000304 	addi	fp,sp,12
81135f64:	e13ffe15 	stw	r4,-8(fp)
81135f68:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81135f6c:	e0bfff17 	ldw	r2,-4(fp)
81135f70:	1000021e 	bne	r2,zero,81135f7c <OSTmrStateGet+0x30>
        return (0);
81135f74:	0005883a 	mov	r2,zero
81135f78:	00002a06 	br	81136024 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
81135f7c:	e0bffe17 	ldw	r2,-8(fp)
81135f80:	1000051e 	bne	r2,zero,81135f98 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81135f84:	e0bfff17 	ldw	r2,-4(fp)
81135f88:	00ffe284 	movi	r3,-118
81135f8c:	10c00005 	stb	r3,0(r2)
        return (0);
81135f90:	0005883a 	mov	r2,zero
81135f94:	00002306 	br	81136024 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81135f98:	e0bffe17 	ldw	r2,-8(fp)
81135f9c:	10800003 	ldbu	r2,0(r2)
81135fa0:	10803fcc 	andi	r2,r2,255
81135fa4:	10801920 	cmpeqi	r2,r2,100
81135fa8:	1000051e 	bne	r2,zero,81135fc0 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81135fac:	e0bfff17 	ldw	r2,-4(fp)
81135fb0:	00ffe244 	movi	r3,-119
81135fb4:	10c00005 	stb	r3,0(r2)
        return (0);
81135fb8:	0005883a 	mov	r2,zero
81135fbc:	00001906 	br	81136024 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81135fc0:	d0a09103 	ldbu	r2,-32188(gp)
81135fc4:	10803fcc 	andi	r2,r2,255
81135fc8:	10000526 	beq	r2,zero,81135fe0 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81135fcc:	e0bfff17 	ldw	r2,-4(fp)
81135fd0:	00ffe2c4 	movi	r3,-117
81135fd4:	10c00005 	stb	r3,0(r2)
        return (0);
81135fd8:	0005883a 	mov	r2,zero
81135fdc:	00001106 	br	81136024 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
81135fe0:	11369080 	call	81136908 <OSTmr_Lock>
    state = ptmr->OSTmrState;
81135fe4:	e0bffe17 	ldw	r2,-8(fp)
81135fe8:	10800c43 	ldbu	r2,49(r2)
81135fec:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
81135ff0:	e0bffd03 	ldbu	r2,-12(fp)
81135ff4:	1005883a 	mov	r2,r2
81135ff8:	10800128 	cmpgeui	r2,r2,4
81135ffc:	1000031e 	bne	r2,zero,8113600c <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
81136000:	e0bfff17 	ldw	r2,-4(fp)
81136004:	10000005 	stb	zero,0(r2)
             break;
81136008:	00000406 	br	8113601c <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8113600c:	e0bfff17 	ldw	r2,-4(fp)
81136010:	00ffe344 	movi	r3,-115
81136014:	10c00005 	stb	r3,0(r2)
             break;
81136018:	0001883a 	nop
    }
    OSTmr_Unlock();
8113601c:	113694c0 	call	8113694c <OSTmr_Unlock>
    return (state);
81136020:	e0bffd03 	ldbu	r2,-12(fp)
}
81136024:	e037883a 	mov	sp,fp
81136028:	dfc00117 	ldw	ra,4(sp)
8113602c:	df000017 	ldw	fp,0(sp)
81136030:	dec00204 	addi	sp,sp,8
81136034:	f800283a 	ret

81136038 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
81136038:	defffc04 	addi	sp,sp,-16
8113603c:	de00012e 	bgeu	sp,et,81136044 <OSTmrStart+0xc>
81136040:	003b68fa 	trap	3
81136044:	dfc00315 	stw	ra,12(sp)
81136048:	df000215 	stw	fp,8(sp)
8113604c:	df000204 	addi	fp,sp,8
81136050:	e13ffe15 	stw	r4,-8(fp)
81136054:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81136058:	e0bfff17 	ldw	r2,-4(fp)
8113605c:	1000021e 	bne	r2,zero,81136068 <OSTmrStart+0x30>
        return (OS_FALSE);
81136060:	0005883a 	mov	r2,zero
81136064:	00004106 	br	8113616c <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
81136068:	e0bffe17 	ldw	r2,-8(fp)
8113606c:	1000051e 	bne	r2,zero,81136084 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81136070:	e0bfff17 	ldw	r2,-4(fp)
81136074:	00ffe284 	movi	r3,-118
81136078:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113607c:	0005883a 	mov	r2,zero
81136080:	00003a06 	br	8113616c <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81136084:	e0bffe17 	ldw	r2,-8(fp)
81136088:	10800003 	ldbu	r2,0(r2)
8113608c:	10803fcc 	andi	r2,r2,255
81136090:	10801920 	cmpeqi	r2,r2,100
81136094:	1000051e 	bne	r2,zero,811360ac <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81136098:	e0bfff17 	ldw	r2,-4(fp)
8113609c:	00ffe244 	movi	r3,-119
811360a0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811360a4:	0005883a 	mov	r2,zero
811360a8:	00003006 	br	8113616c <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
811360ac:	d0a09103 	ldbu	r2,-32188(gp)
811360b0:	10803fcc 	andi	r2,r2,255
811360b4:	10000526 	beq	r2,zero,811360cc <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
811360b8:	e0bfff17 	ldw	r2,-4(fp)
811360bc:	00ffe2c4 	movi	r3,-117
811360c0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811360c4:	0005883a 	mov	r2,zero
811360c8:	00002806 	br	8113616c <OSTmrStart+0x134>
    }
    OSTmr_Lock();
811360cc:	11369080 	call	81136908 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811360d0:	e0bffe17 	ldw	r2,-8(fp)
811360d4:	10800c43 	ldbu	r2,49(r2)
811360d8:	10803fcc 	andi	r2,r2,255
811360dc:	10c000c8 	cmpgei	r3,r2,3
811360e0:	1800031e 	bne	r3,zero,811360f0 <OSTmrStart+0xb8>
811360e4:	00800e16 	blt	zero,r2,81136120 <OSTmrStart+0xe8>
811360e8:	10001526 	beq	r2,zero,81136140 <OSTmrStart+0x108>
811360ec:	00001a06 	br	81136158 <OSTmrStart+0x120>
811360f0:	108000e0 	cmpeqi	r2,r2,3
811360f4:	10001826 	beq	r2,zero,81136158 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
811360f8:	e13ffe17 	ldw	r4,-8(fp)
811360fc:	113680c0 	call	8113680c <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81136100:	000b883a 	mov	r5,zero
81136104:	e13ffe17 	ldw	r4,-8(fp)
81136108:	11366bc0 	call	811366bc <OSTmr_Link>
             OSTmr_Unlock();
8113610c:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81136110:	e0bfff17 	ldw	r2,-4(fp)
81136114:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81136118:	00800044 	movi	r2,1
8113611c:	00001306 	br	8113616c <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81136120:	000b883a 	mov	r5,zero
81136124:	e13ffe17 	ldw	r4,-8(fp)
81136128:	11366bc0 	call	811366bc <OSTmr_Link>
             OSTmr_Unlock();
8113612c:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81136130:	e0bfff17 	ldw	r2,-4(fp)
81136134:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81136138:	00800044 	movi	r2,1
8113613c:	00000b06 	br	8113616c <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
81136140:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81136144:	e0bfff17 	ldw	r2,-4(fp)
81136148:	00ffe1c4 	movi	r3,-121
8113614c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81136150:	0005883a 	mov	r2,zero
81136154:	00000506 	br	8113616c <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
81136158:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113615c:	e0bfff17 	ldw	r2,-4(fp)
81136160:	00ffe344 	movi	r3,-115
81136164:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81136168:	0005883a 	mov	r2,zero
    }
}
8113616c:	e037883a 	mov	sp,fp
81136170:	dfc00117 	ldw	ra,4(sp)
81136174:	df000017 	ldw	fp,0(sp)
81136178:	dec00204 	addi	sp,sp,8
8113617c:	f800283a 	ret

81136180 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
81136180:	defff904 	addi	sp,sp,-28
81136184:	de00012e 	bgeu	sp,et,8113618c <OSTmrStop+0xc>
81136188:	003b68fa 	trap	3
8113618c:	dfc00615 	stw	ra,24(sp)
81136190:	df000515 	stw	fp,20(sp)
81136194:	df000504 	addi	fp,sp,20
81136198:	e13ffc15 	stw	r4,-16(fp)
8113619c:	2805883a 	mov	r2,r5
811361a0:	e1bffe15 	stw	r6,-8(fp)
811361a4:	e1ffff15 	stw	r7,-4(fp)
811361a8:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
811361ac:	e0bfff17 	ldw	r2,-4(fp)
811361b0:	1000021e 	bne	r2,zero,811361bc <OSTmrStop+0x3c>
        return (OS_FALSE);
811361b4:	0005883a 	mov	r2,zero
811361b8:	00006606 	br	81136354 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
811361bc:	e0bffc17 	ldw	r2,-16(fp)
811361c0:	1000051e 	bne	r2,zero,811361d8 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
811361c4:	e0bfff17 	ldw	r2,-4(fp)
811361c8:	00ffe284 	movi	r3,-118
811361cc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811361d0:	0005883a 	mov	r2,zero
811361d4:	00005f06 	br	81136354 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
811361d8:	e0bffc17 	ldw	r2,-16(fp)
811361dc:	10800003 	ldbu	r2,0(r2)
811361e0:	10803fcc 	andi	r2,r2,255
811361e4:	10801920 	cmpeqi	r2,r2,100
811361e8:	1000051e 	bne	r2,zero,81136200 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811361ec:	e0bfff17 	ldw	r2,-4(fp)
811361f0:	00ffe244 	movi	r3,-119
811361f4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811361f8:	0005883a 	mov	r2,zero
811361fc:	00005506 	br	81136354 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
81136200:	d0a09103 	ldbu	r2,-32188(gp)
81136204:	10803fcc 	andi	r2,r2,255
81136208:	10000526 	beq	r2,zero,81136220 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8113620c:	e0bfff17 	ldw	r2,-4(fp)
81136210:	00ffe2c4 	movi	r3,-117
81136214:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81136218:	0005883a 	mov	r2,zero
8113621c:	00004d06 	br	81136354 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
81136220:	11369080 	call	81136908 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81136224:	e0bffc17 	ldw	r2,-16(fp)
81136228:	10800c43 	ldbu	r2,49(r2)
8113622c:	10803fcc 	andi	r2,r2,255
81136230:	10c000c8 	cmpgei	r3,r2,3
81136234:	1800031e 	bne	r3,zero,81136244 <OSTmrStop+0xc4>
81136238:	00803516 	blt	zero,r2,81136310 <OSTmrStop+0x190>
8113623c:	10003a26 	beq	r2,zero,81136328 <OSTmrStop+0x1a8>
81136240:	00003f06 	br	81136340 <OSTmrStop+0x1c0>
81136244:	108000e0 	cmpeqi	r2,r2,3
81136248:	10003d26 	beq	r2,zero,81136340 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8113624c:	e13ffc17 	ldw	r4,-16(fp)
81136250:	113680c0 	call	8113680c <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
81136254:	e0bfff17 	ldw	r2,-4(fp)
81136258:	10000005 	stb	zero,0(r2)
             switch (opt) {
8113625c:	e0bffd03 	ldbu	r2,-12(fp)
81136260:	10c000e0 	cmpeqi	r3,r2,3
81136264:	1800041e 	bne	r3,zero,81136278 <OSTmrStop+0xf8>
81136268:	10c00120 	cmpeqi	r3,r2,4
8113626c:	1800121e 	bne	r3,zero,811362b8 <OSTmrStop+0x138>
81136270:	10002326 	beq	r2,zero,81136300 <OSTmrStop+0x180>
81136274:	00001e06 	br	811362f0 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81136278:	e0bffc17 	ldw	r2,-16(fp)
8113627c:	10800117 	ldw	r2,4(r2)
81136280:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81136284:	e0bffb17 	ldw	r2,-20(fp)
81136288:	10000726 	beq	r2,zero,811362a8 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8113628c:	e0bffc17 	ldw	r2,-16(fp)
81136290:	10c00217 	ldw	r3,8(r2)
81136294:	e0bffb17 	ldw	r2,-20(fp)
81136298:	180b883a 	mov	r5,r3
8113629c:	e13ffc17 	ldw	r4,-16(fp)
811362a0:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
811362a4:	00001706 	br	81136304 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
811362a8:	e0bfff17 	ldw	r2,-4(fp)
811362ac:	00ffe3c4 	movi	r3,-113
811362b0:	10c00005 	stb	r3,0(r2)
                      }
                      break;
811362b4:	00001306 	br	81136304 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
811362b8:	e0bffc17 	ldw	r2,-16(fp)
811362bc:	10800117 	ldw	r2,4(r2)
811362c0:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
811362c4:	e0bffb17 	ldw	r2,-20(fp)
811362c8:	10000526 	beq	r2,zero,811362e0 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
811362cc:	e0bffb17 	ldw	r2,-20(fp)
811362d0:	e17ffe17 	ldw	r5,-8(fp)
811362d4:	e13ffc17 	ldw	r4,-16(fp)
811362d8:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
811362dc:	00000906 	br	81136304 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
811362e0:	e0bfff17 	ldw	r2,-4(fp)
811362e4:	00ffe3c4 	movi	r3,-113
811362e8:	10c00005 	stb	r3,0(r2)
                      }
                      break;
811362ec:	00000506 	br	81136304 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
811362f0:	e0bfff17 	ldw	r2,-4(fp)
811362f4:	00ffe104 	movi	r3,-124
811362f8:	10c00005 	stb	r3,0(r2)
                     break;
811362fc:	00000106 	br	81136304 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
81136300:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
81136304:	113694c0 	call	8113694c <OSTmr_Unlock>
             return (OS_TRUE);
81136308:	00800044 	movi	r2,1
8113630c:	00001106 	br	81136354 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
81136310:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
81136314:	e0bfff17 	ldw	r2,-4(fp)
81136318:	00ffe384 	movi	r3,-114
8113631c:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
81136320:	00800044 	movi	r2,1
81136324:	00000b06 	br	81136354 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
81136328:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113632c:	e0bfff17 	ldw	r2,-4(fp)
81136330:	00ffe1c4 	movi	r3,-121
81136334:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81136338:	0005883a 	mov	r2,zero
8113633c:	00000506 	br	81136354 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
81136340:	113694c0 	call	8113694c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81136344:	e0bfff17 	ldw	r2,-4(fp)
81136348:	00ffe344 	movi	r3,-115
8113634c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81136350:	0005883a 	mov	r2,zero
    }
}
81136354:	e037883a 	mov	sp,fp
81136358:	dfc00117 	ldw	ra,4(sp)
8113635c:	df000017 	ldw	fp,0(sp)
81136360:	dec00204 	addi	sp,sp,8
81136364:	f800283a 	ret

81136368 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
81136368:	defffd04 	addi	sp,sp,-12
8113636c:	de00012e 	bgeu	sp,et,81136374 <OSTmrSignal+0xc>
81136370:	003b68fa 	trap	3
81136374:	dfc00215 	stw	ra,8(sp)
81136378:	df000115 	stw	fp,4(sp)
8113637c:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
81136380:	d0a08017 	ldw	r2,-32256(gp)
81136384:	1009883a 	mov	r4,r2
81136388:	1133ae80 	call	81133ae8 <OSSemPost>
8113638c:	e0bfff05 	stb	r2,-4(fp)
    return (err);
81136390:	e0bfff03 	ldbu	r2,-4(fp)
}
81136394:	e037883a 	mov	sp,fp
81136398:	dfc00117 	ldw	ra,4(sp)
8113639c:	df000017 	ldw	fp,0(sp)
811363a0:	dec00204 	addi	sp,sp,8
811363a4:	f800283a 	ret

811363a8 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
811363a8:	defffe04 	addi	sp,sp,-8
811363ac:	de00012e 	bgeu	sp,et,811363b4 <OSTmr_Alloc+0xc>
811363b0:	003b68fa 	trap	3
811363b4:	df000115 	stw	fp,4(sp)
811363b8:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
811363bc:	d0a07e17 	ldw	r2,-32264(gp)
811363c0:	1000021e 	bne	r2,zero,811363cc <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
811363c4:	0005883a 	mov	r2,zero
811363c8:	00001006 	br	8113640c <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
811363cc:	d0a07e17 	ldw	r2,-32264(gp)
811363d0:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
811363d4:	e0bfff17 	ldw	r2,-4(fp)
811363d8:	10800317 	ldw	r2,12(r2)
811363dc:	d0a07e15 	stw	r2,-32264(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
811363e0:	e0bfff17 	ldw	r2,-4(fp)
811363e4:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
811363e8:	e0bfff17 	ldw	r2,-4(fp)
811363ec:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
811363f0:	d0a0830b 	ldhu	r2,-32244(gp)
811363f4:	10800044 	addi	r2,r2,1
811363f8:	d0a0830d 	sth	r2,-32244(gp)
    OSTmrFree--;
811363fc:	d0a0870b 	ldhu	r2,-32228(gp)
81136400:	10bfffc4 	addi	r2,r2,-1
81136404:	d0a0870d 	sth	r2,-32228(gp)
    return (ptmr);
81136408:	e0bfff17 	ldw	r2,-4(fp)
}
8113640c:	e037883a 	mov	sp,fp
81136410:	df000017 	ldw	fp,0(sp)
81136414:	dec00104 	addi	sp,sp,4
81136418:	f800283a 	ret

8113641c <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8113641c:	defffe04 	addi	sp,sp,-8
81136420:	de00012e 	bgeu	sp,et,81136428 <OSTmr_Free+0xc>
81136424:	003b68fa 	trap	3
81136428:	df000115 	stw	fp,4(sp)
8113642c:	df000104 	addi	fp,sp,4
81136430:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
81136434:	e0bfff17 	ldw	r2,-4(fp)
81136438:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8113643c:	e0bfff17 	ldw	r2,-4(fp)
81136440:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
81136444:	e0bfff17 	ldw	r2,-4(fp)
81136448:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8113644c:	e0bfff17 	ldw	r2,-4(fp)
81136450:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
81136454:	e0bfff17 	ldw	r2,-4(fp)
81136458:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8113645c:	e0bfff17 	ldw	r2,-4(fp)
81136460:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
81136464:	e0bfff17 	ldw	r2,-4(fp)
81136468:	00c00fc4 	movi	r3,63
8113646c:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
81136470:	e0bfff17 	ldw	r2,-4(fp)
81136474:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
81136478:	e0bfff17 	ldw	r2,-4(fp)
8113647c:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
81136480:	d0e07e17 	ldw	r3,-32264(gp)
81136484:	e0bfff17 	ldw	r2,-4(fp)
81136488:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8113648c:	e0bfff17 	ldw	r2,-4(fp)
81136490:	d0a07e15 	stw	r2,-32264(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
81136494:	d0a0830b 	ldhu	r2,-32244(gp)
81136498:	10bfffc4 	addi	r2,r2,-1
8113649c:	d0a0830d 	sth	r2,-32244(gp)
    OSTmrFree++;
811364a0:	d0a0870b 	ldhu	r2,-32228(gp)
811364a4:	10800044 	addi	r2,r2,1
811364a8:	d0a0870d 	sth	r2,-32228(gp)
}
811364ac:	0001883a 	nop
811364b0:	e037883a 	mov	sp,fp
811364b4:	df000017 	ldw	fp,0(sp)
811364b8:	dec00104 	addi	sp,sp,4
811364bc:	f800283a 	ret

811364c0 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
811364c0:	defffa04 	addi	sp,sp,-24
811364c4:	de00012e 	bgeu	sp,et,811364cc <OSTmr_Init+0xc>
811364c8:	003b68fa 	trap	3
811364cc:	dfc00515 	stw	ra,20(sp)
811364d0:	df000415 	stw	fp,16(sp)
811364d4:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
811364d8:	01406804 	movi	r5,416
811364dc:	012045b4 	movhi	r4,33046
811364e0:	212b0804 	addi	r4,r4,-21472
811364e4:	112e7e40 	call	8112e7e4 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
811364e8:	01400404 	movi	r5,16
811364ec:	012045b4 	movhi	r4,33046
811364f0:	2129a404 	addi	r4,r4,-22896
811364f4:	112e7e40 	call	8112e7e4 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
811364f8:	00a045b4 	movhi	r2,33046
811364fc:	10ab0804 	addi	r2,r2,-21472
81136500:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
81136504:	00a045b4 	movhi	r2,33046
81136508:	10ab1504 	addi	r2,r2,-21420
8113650c:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81136510:	e03ffc0d 	sth	zero,-16(fp)
81136514:	00001606 	br	81136570 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
81136518:	e0bffd17 	ldw	r2,-12(fp)
8113651c:	00c01904 	movi	r3,100
81136520:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
81136524:	e0bffd17 	ldw	r2,-12(fp)
81136528:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
8113652c:	e0bffd17 	ldw	r2,-12(fp)
81136530:	e0fffe17 	ldw	r3,-8(fp)
81136534:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
81136538:	e0bffd17 	ldw	r2,-12(fp)
8113653c:	00c00fc4 	movi	r3,63
81136540:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81136544:	e0bffd17 	ldw	r2,-12(fp)
81136548:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8113654c:	e0bffd17 	ldw	r2,-12(fp)
81136550:	10800d04 	addi	r2,r2,52
81136554:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
81136558:	e0bffe17 	ldw	r2,-8(fp)
8113655c:	10800d04 	addi	r2,r2,52
81136560:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81136564:	e0bffc0b 	ldhu	r2,-16(fp)
81136568:	10800044 	addi	r2,r2,1
8113656c:	e0bffc0d 	sth	r2,-16(fp)
81136570:	e0bffc0b 	ldhu	r2,-16(fp)
81136574:	108001f0 	cmpltui	r2,r2,7
81136578:	103fe71e 	bne	r2,zero,81136518 <__reset+0xfb116518>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8113657c:	e0bffd17 	ldw	r2,-12(fp)
81136580:	00c01904 	movi	r3,100
81136584:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
81136588:	e0bffd17 	ldw	r2,-12(fp)
8113658c:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
81136590:	e0bffd17 	ldw	r2,-12(fp)
81136594:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
81136598:	e0bffd17 	ldw	r2,-12(fp)
8113659c:	00c00fc4 	movi	r3,63
811365a0:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
811365a4:	e0bffd17 	ldw	r2,-12(fp)
811365a8:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
811365ac:	d0209315 	stw	zero,-32180(gp)
    OSTmrUsed           = 0;
811365b0:	d020830d 	sth	zero,-32244(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
811365b4:	00800204 	movi	r2,8
811365b8:	d0a0870d 	sth	r2,-32228(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
811365bc:	00a045b4 	movhi	r2,33046
811365c0:	10ab0804 	addi	r2,r2,-21472
811365c4:	d0a07e15 	stw	r2,-32264(gp)
    OSTmrSem            = OSSemCreate(1);
811365c8:	01000044 	movi	r4,1
811365cc:	11334380 	call	81133438 <OSSemCreate>
811365d0:	d0a09515 	stw	r2,-32172(gp)
    OSTmrSemSignal      = OSSemCreate(0);
811365d4:	0009883a 	mov	r4,zero
811365d8:	11334380 	call	81133438 <OSSemCreate>
811365dc:	d0a08015 	stw	r2,-32256(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
811365e0:	d0a09517 	ldw	r2,-32172(gp)
811365e4:	e0ffff04 	addi	r3,fp,-4
811365e8:	180d883a 	mov	r6,r3
811365ec:	01604534 	movhi	r5,33044
811365f0:	2952c004 	addi	r5,r5,19200
811365f4:	1009883a 	mov	r4,r2
811365f8:	112d0400 	call	8112d040 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
811365fc:	d0a08017 	ldw	r2,-32256(gp)
81136600:	e0ffff04 	addi	r3,fp,-4
81136604:	180d883a 	mov	r6,r3
81136608:	01604534 	movhi	r5,33044
8113660c:	2952c504 	addi	r5,r5,19220
81136610:	1009883a 	mov	r4,r2
81136614:	112d0400 	call	8112d040 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
81136618:	11366340 	call	81136634 <OSTmr_InitTask>
}
8113661c:	0001883a 	nop
81136620:	e037883a 	mov	sp,fp
81136624:	dfc00117 	ldw	ra,4(sp)
81136628:	df000017 	ldw	fp,0(sp)
8113662c:	dec00204 	addi	sp,sp,8
81136630:	f800283a 	ret

81136634 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
81136634:	defff804 	addi	sp,sp,-32
81136638:	de00012e 	bgeu	sp,et,81136640 <OSTmr_InitTask+0xc>
8113663c:	003b68fa 	trap	3
81136640:	dfc00715 	stw	ra,28(sp)
81136644:	df000615 	stw	fp,24(sp)
81136648:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8113664c:	008000c4 	movi	r2,3
81136650:	d8800415 	stw	r2,16(sp)
81136654:	d8000315 	stw	zero,12(sp)
81136658:	00808004 	movi	r2,512
8113665c:	d8800215 	stw	r2,8(sp)
81136660:	00a045b4 	movhi	r2,33046
81136664:	10b2dc04 	addi	r2,r2,-13456
81136668:	d8800115 	stw	r2,4(sp)
8113666c:	00bfff54 	movui	r2,65533
81136670:	d8800015 	stw	r2,0(sp)
81136674:	01c00744 	movi	r7,29
81136678:	01a045b4 	movhi	r6,33046
8113667c:	31b4db04 	addi	r6,r6,-11412
81136680:	000b883a 	mov	r5,zero
81136684:	012044f4 	movhi	r4,33043
81136688:	211a6204 	addi	r4,r4,27016
8113668c:	11343180 	call	81134318 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
81136690:	e1bfff04 	addi	r6,fp,-4
81136694:	01604534 	movhi	r5,33044
81136698:	2952ca04 	addi	r5,r5,19240
8113669c:	01000744 	movi	r4,29
811366a0:	1134b480 	call	81134b48 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
811366a4:	0001883a 	nop
811366a8:	e037883a 	mov	sp,fp
811366ac:	dfc00117 	ldw	ra,4(sp)
811366b0:	df000017 	ldw	fp,0(sp)
811366b4:	dec00204 	addi	sp,sp,8
811366b8:	f800283a 	ret

811366bc <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
811366bc:	defffa04 	addi	sp,sp,-24
811366c0:	de00012e 	bgeu	sp,et,811366c8 <OSTmr_Link+0xc>
811366c4:	003b68fa 	trap	3
811366c8:	df000515 	stw	fp,20(sp)
811366cc:	df000504 	addi	fp,sp,20
811366d0:	e13ffe15 	stw	r4,-8(fp)
811366d4:	2805883a 	mov	r2,r5
811366d8:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
811366dc:	e0bffe17 	ldw	r2,-8(fp)
811366e0:	00c000c4 	movi	r3,3
811366e4:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
811366e8:	e0bfff03 	ldbu	r2,-4(fp)
811366ec:	10800058 	cmpnei	r2,r2,1
811366f0:	1000071e 	bne	r2,zero,81136710 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
811366f4:	e0bffe17 	ldw	r2,-8(fp)
811366f8:	10c00717 	ldw	r3,28(r2)
811366fc:	d0a09317 	ldw	r2,-32180(gp)
81136700:	1887883a 	add	r3,r3,r2
81136704:	e0bffe17 	ldw	r2,-8(fp)
81136708:	10c00515 	stw	r3,20(r2)
8113670c:	00001006 	br	81136750 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
81136710:	e0bffe17 	ldw	r2,-8(fp)
81136714:	10800617 	ldw	r2,24(r2)
81136718:	1000071e 	bne	r2,zero,81136738 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113671c:	e0bffe17 	ldw	r2,-8(fp)
81136720:	10c00717 	ldw	r3,28(r2)
81136724:	d0a09317 	ldw	r2,-32180(gp)
81136728:	1887883a 	add	r3,r3,r2
8113672c:	e0bffe17 	ldw	r2,-8(fp)
81136730:	10c00515 	stw	r3,20(r2)
81136734:	00000606 	br	81136750 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
81136738:	e0bffe17 	ldw	r2,-8(fp)
8113673c:	10c00617 	ldw	r3,24(r2)
81136740:	d0a09317 	ldw	r2,-32180(gp)
81136744:	1887883a 	add	r3,r3,r2
81136748:	e0bffe17 	ldw	r2,-8(fp)
8113674c:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81136750:	e0bffe17 	ldw	r2,-8(fp)
81136754:	10800517 	ldw	r2,20(r2)
81136758:	1080004c 	andi	r2,r2,1
8113675c:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81136760:	e0bffb0b 	ldhu	r2,-20(fp)
81136764:	100690fa 	slli	r3,r2,3
81136768:	00a045b4 	movhi	r2,33046
8113676c:	10a9a404 	addi	r2,r2,-22896
81136770:	1885883a 	add	r2,r3,r2
81136774:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
81136778:	e0bffc17 	ldw	r2,-16(fp)
8113677c:	10800017 	ldw	r2,0(r2)
81136780:	1000091e 	bne	r2,zero,811367a8 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
81136784:	e0bffc17 	ldw	r2,-16(fp)
81136788:	e0fffe17 	ldw	r3,-8(fp)
8113678c:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
81136790:	e0bffe17 	ldw	r2,-8(fp)
81136794:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
81136798:	e0bffc17 	ldw	r2,-16(fp)
8113679c:	00c00044 	movi	r3,1
811367a0:	10c0010d 	sth	r3,4(r2)
811367a4:	00001206 	br	811367f0 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
811367a8:	e0bffc17 	ldw	r2,-16(fp)
811367ac:	10800017 	ldw	r2,0(r2)
811367b0:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
811367b4:	e0bffc17 	ldw	r2,-16(fp)
811367b8:	e0fffe17 	ldw	r3,-8(fp)
811367bc:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
811367c0:	e0bffe17 	ldw	r2,-8(fp)
811367c4:	e0fffd17 	ldw	r3,-12(fp)
811367c8:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
811367cc:	e0bffd17 	ldw	r2,-12(fp)
811367d0:	e0fffe17 	ldw	r3,-8(fp)
811367d4:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
811367d8:	e0bffc17 	ldw	r2,-16(fp)
811367dc:	1080010b 	ldhu	r2,4(r2)
811367e0:	10800044 	addi	r2,r2,1
811367e4:	1007883a 	mov	r3,r2
811367e8:	e0bffc17 	ldw	r2,-16(fp)
811367ec:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
811367f0:	e0bffe17 	ldw	r2,-8(fp)
811367f4:	10000415 	stw	zero,16(r2)
}
811367f8:	0001883a 	nop
811367fc:	e037883a 	mov	sp,fp
81136800:	df000017 	ldw	fp,0(sp)
81136804:	dec00104 	addi	sp,sp,4
81136808:	f800283a 	ret

8113680c <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8113680c:	defffa04 	addi	sp,sp,-24
81136810:	de00012e 	bgeu	sp,et,81136818 <OSTmr_Unlink+0xc>
81136814:	003b68fa 	trap	3
81136818:	df000515 	stw	fp,20(sp)
8113681c:	df000504 	addi	fp,sp,20
81136820:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81136824:	e0bfff17 	ldw	r2,-4(fp)
81136828:	10800517 	ldw	r2,20(r2)
8113682c:	1080004c 	andi	r2,r2,1
81136830:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81136834:	e0bffb0b 	ldhu	r2,-20(fp)
81136838:	100690fa 	slli	r3,r2,3
8113683c:	00a045b4 	movhi	r2,33046
81136840:	10a9a404 	addi	r2,r2,-22896
81136844:	1885883a 	add	r2,r3,r2
81136848:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8113684c:	e0bffc17 	ldw	r2,-16(fp)
81136850:	10c00017 	ldw	r3,0(r2)
81136854:	e0bfff17 	ldw	r2,-4(fp)
81136858:	18800b1e 	bne	r3,r2,81136888 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8113685c:	e0bfff17 	ldw	r2,-4(fp)
81136860:	10800317 	ldw	r2,12(r2)
81136864:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
81136868:	e0bffc17 	ldw	r2,-16(fp)
8113686c:	e0fffd17 	ldw	r3,-12(fp)
81136870:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
81136874:	e0bffd17 	ldw	r2,-12(fp)
81136878:	10001126 	beq	r2,zero,811368c0 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8113687c:	e0bffd17 	ldw	r2,-12(fp)
81136880:	10000415 	stw	zero,16(r2)
81136884:	00000e06 	br	811368c0 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
81136888:	e0bfff17 	ldw	r2,-4(fp)
8113688c:	10800417 	ldw	r2,16(r2)
81136890:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
81136894:	e0bfff17 	ldw	r2,-4(fp)
81136898:	10800317 	ldw	r2,12(r2)
8113689c:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
811368a0:	e0bffd17 	ldw	r2,-12(fp)
811368a4:	e0fffe17 	ldw	r3,-8(fp)
811368a8:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
811368ac:	e0bffe17 	ldw	r2,-8(fp)
811368b0:	10000326 	beq	r2,zero,811368c0 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
811368b4:	e0bffe17 	ldw	r2,-8(fp)
811368b8:	e0fffd17 	ldw	r3,-12(fp)
811368bc:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
811368c0:	e0bfff17 	ldw	r2,-4(fp)
811368c4:	00c00044 	movi	r3,1
811368c8:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
811368cc:	e0bfff17 	ldw	r2,-4(fp)
811368d0:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
811368d4:	e0bfff17 	ldw	r2,-4(fp)
811368d8:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
811368dc:	e0bffc17 	ldw	r2,-16(fp)
811368e0:	1080010b 	ldhu	r2,4(r2)
811368e4:	10bfffc4 	addi	r2,r2,-1
811368e8:	1007883a 	mov	r3,r2
811368ec:	e0bffc17 	ldw	r2,-16(fp)
811368f0:	10c0010d 	sth	r3,4(r2)
}
811368f4:	0001883a 	nop
811368f8:	e037883a 	mov	sp,fp
811368fc:	df000017 	ldw	fp,0(sp)
81136900:	dec00104 	addi	sp,sp,4
81136904:	f800283a 	ret

81136908 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
81136908:	defffd04 	addi	sp,sp,-12
8113690c:	de00012e 	bgeu	sp,et,81136914 <OSTmr_Lock+0xc>
81136910:	003b68fa 	trap	3
81136914:	dfc00215 	stw	ra,8(sp)
81136918:	df000115 	stw	fp,4(sp)
8113691c:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
81136920:	d0a09517 	ldw	r2,-32172(gp)
81136924:	e1bfff04 	addi	r6,fp,-4
81136928:	000b883a 	mov	r5,zero
8113692c:	1009883a 	mov	r4,r2
81136930:	11337600 	call	81133760 <OSSemPend>
    (void)err;
}
81136934:	0001883a 	nop
81136938:	e037883a 	mov	sp,fp
8113693c:	dfc00117 	ldw	ra,4(sp)
81136940:	df000017 	ldw	fp,0(sp)
81136944:	dec00204 	addi	sp,sp,8
81136948:	f800283a 	ret

8113694c <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8113694c:	defffe04 	addi	sp,sp,-8
81136950:	de00012e 	bgeu	sp,et,81136958 <OSTmr_Unlock+0xc>
81136954:	003b68fa 	trap	3
81136958:	dfc00115 	stw	ra,4(sp)
8113695c:	df000015 	stw	fp,0(sp)
81136960:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
81136964:	d0a09517 	ldw	r2,-32172(gp)
81136968:	1009883a 	mov	r4,r2
8113696c:	1133ae80 	call	81133ae8 <OSSemPost>
}
81136970:	0001883a 	nop
81136974:	e037883a 	mov	sp,fp
81136978:	dfc00117 	ldw	ra,4(sp)
8113697c:	df000017 	ldw	fp,0(sp)
81136980:	dec00204 	addi	sp,sp,8
81136984:	f800283a 	ret

81136988 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
81136988:	defff704 	addi	sp,sp,-36
8113698c:	de00012e 	bgeu	sp,et,81136994 <OSTmr_Task+0xc>
81136990:	003b68fa 	trap	3
81136994:	dfc00815 	stw	ra,32(sp)
81136998:	df000715 	stw	fp,28(sp)
8113699c:	df000704 	addi	fp,sp,28
811369a0:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
811369a4:	d0a08017 	ldw	r2,-32256(gp)
811369a8:	e0fffe04 	addi	r3,fp,-8
811369ac:	180d883a 	mov	r6,r3
811369b0:	000b883a 	mov	r5,zero
811369b4:	1009883a 	mov	r4,r2
811369b8:	11337600 	call	81133760 <OSSemPend>
        OSTmr_Lock();
811369bc:	11369080 	call	81136908 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
811369c0:	d0a09317 	ldw	r2,-32180(gp)
811369c4:	10800044 	addi	r2,r2,1
811369c8:	d0a09315 	stw	r2,-32180(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
811369cc:	d0a09317 	ldw	r2,-32180(gp)
811369d0:	1080004c 	andi	r2,r2,1
811369d4:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
811369d8:	e0bffa0b 	ldhu	r2,-24(fp)
811369dc:	100690fa 	slli	r3,r2,3
811369e0:	00a045b4 	movhi	r2,33046
811369e4:	10a9a404 	addi	r2,r2,-22896
811369e8:	1885883a 	add	r2,r3,r2
811369ec:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
811369f0:	e0bffb17 	ldw	r2,-20(fp)
811369f4:	10800017 	ldw	r2,0(r2)
811369f8:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
811369fc:	00002206 	br	81136a88 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81136a00:	e0bff917 	ldw	r2,-28(fp)
81136a04:	10800317 	ldw	r2,12(r2)
81136a08:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
81136a0c:	e0bff917 	ldw	r2,-28(fp)
81136a10:	10c00517 	ldw	r3,20(r2)
81136a14:	d0a09317 	ldw	r2,-32180(gp)
81136a18:	1880191e 	bne	r3,r2,81136a80 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
81136a1c:	e0bff917 	ldw	r2,-28(fp)
81136a20:	10800117 	ldw	r2,4(r2)
81136a24:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
81136a28:	e0bffd17 	ldw	r2,-12(fp)
81136a2c:	10000626 	beq	r2,zero,81136a48 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
81136a30:	e0bff917 	ldw	r2,-28(fp)
81136a34:	10c00217 	ldw	r3,8(r2)
81136a38:	e0bffd17 	ldw	r2,-12(fp)
81136a3c:	180b883a 	mov	r5,r3
81136a40:	e13ff917 	ldw	r4,-28(fp)
81136a44:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
81136a48:	e13ff917 	ldw	r4,-28(fp)
81136a4c:	113680c0 	call	8113680c <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
81136a50:	e0bff917 	ldw	r2,-28(fp)
81136a54:	10800c03 	ldbu	r2,48(r2)
81136a58:	10803fcc 	andi	r2,r2,255
81136a5c:	10800098 	cmpnei	r2,r2,2
81136a60:	1000041e 	bne	r2,zero,81136a74 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
81136a64:	01400044 	movi	r5,1
81136a68:	e13ff917 	ldw	r4,-28(fp)
81136a6c:	11366bc0 	call	811366bc <OSTmr_Link>
81136a70:	00000306 	br	81136a80 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
81136a74:	e0bff917 	ldw	r2,-28(fp)
81136a78:	00c00084 	movi	r3,2
81136a7c:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
81136a80:	e0bffc17 	ldw	r2,-16(fp)
81136a84:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
81136a88:	e0bff917 	ldw	r2,-28(fp)
81136a8c:	103fdc1e 	bne	r2,zero,81136a00 <__reset+0xfb116a00>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
81136a90:	113694c0 	call	8113694c <OSTmr_Unlock>
    }
81136a94:	003fc306 	br	811369a4 <__reset+0xfb1169a4>

81136a98 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
81136a98:	defffd04 	addi	sp,sp,-12
81136a9c:	de00012e 	bgeu	sp,et,81136aa4 <alt_dev_reg+0xc>
81136aa0:	003b68fa 	trap	3
81136aa4:	dfc00215 	stw	ra,8(sp)
81136aa8:	df000115 	stw	fp,4(sp)
81136aac:	df000104 	addi	fp,sp,4
81136ab0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
81136ab4:	d1600d04 	addi	r5,gp,-32716
81136ab8:	e13fff17 	ldw	r4,-4(fp)
81136abc:	113ed380 	call	8113ed38 <alt_dev_llist_insert>
}
81136ac0:	e037883a 	mov	sp,fp
81136ac4:	dfc00117 	ldw	ra,4(sp)
81136ac8:	df000017 	ldw	fp,0(sp)
81136acc:	dec00204 	addi	sp,sp,8
81136ad0:	f800283a 	ret

81136ad4 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
81136ad4:	defffd04 	addi	sp,sp,-12
81136ad8:	de00012e 	bgeu	sp,et,81136ae0 <alt_irq_init+0xc>
81136adc:	003b68fa 	trap	3
81136ae0:	dfc00215 	stw	ra,8(sp)
81136ae4:	df000115 	stw	fp,4(sp)
81136ae8:	df000104 	addi	fp,sp,4
81136aec:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
81136af0:	113f7000 	call	8113f700 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
81136af4:	00800044 	movi	r2,1
81136af8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
81136afc:	0001883a 	nop
81136b00:	e037883a 	mov	sp,fp
81136b04:	dfc00117 	ldw	ra,4(sp)
81136b08:	df000017 	ldw	fp,0(sp)
81136b0c:	dec00204 	addi	sp,sp,8
81136b10:	f800283a 	ret

81136b14 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
81136b14:	defffe04 	addi	sp,sp,-8
81136b18:	de00012e 	bgeu	sp,et,81136b20 <alt_sys_init+0xc>
81136b1c:	003b68fa 	trap	3
81136b20:	dfc00115 	stw	ra,4(sp)
81136b24:	df000015 	stw	fp,0(sp)
81136b28:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
81136b2c:	01c0fa04 	movi	r7,1000
81136b30:	01800304 	movi	r6,12
81136b34:	000b883a 	mov	r5,zero
81136b38:	01200034 	movhi	r4,32768
81136b3c:	21022004 	addi	r4,r4,2176
81136b40:	113be6c0 	call	8113be6c <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
81136b44:	018002c4 	movi	r6,11
81136b48:	000b883a 	mov	r5,zero
81136b4c:	01204534 	movhi	r4,33044
81136b50:	21166604 	addi	r4,r4,22936
81136b54:	113b1580 	call	8113b158 <altera_avalon_jtag_uart_init>
81136b58:	01204534 	movhi	r4,33044
81136b5c:	21165c04 	addi	r4,r4,22896
81136b60:	1136a980 	call	81136a98 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
81136b64:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
81136b68:	018003c4 	movi	r6,15
81136b6c:	000b883a 	mov	r5,zero
81136b70:	01204534 	movhi	r4,33044
81136b74:	211a8104 	addi	r4,r4,27140
81136b78:	113c0180 	call	8113c018 <altera_avalon_uart_init>
81136b7c:	01204534 	movhi	r4,33044
81136b80:	211a7704 	addi	r4,r4,27100
81136b84:	1136a980 	call	81136a98 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
81136b88:	00a04534 	movhi	r2,33044
81136b8c:	109aab04 	addi	r2,r2,27308
81136b90:	10c00717 	ldw	r3,28(r2)
81136b94:	00a04534 	movhi	r2,33044
81136b98:	109aab04 	addi	r2,r2,27308
81136b9c:	10800817 	ldw	r2,32(r2)
81136ba0:	100d883a 	mov	r6,r2
81136ba4:	180b883a 	mov	r5,r3
81136ba8:	01204534 	movhi	r4,33044
81136bac:	211aab04 	addi	r4,r4,27308
81136bb0:	113e8a00 	call	8113e8a0 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
81136bb4:	00a04534 	movhi	r2,33044
81136bb8:	109ac404 	addi	r2,r2,27408
81136bbc:	10c00717 	ldw	r3,28(r2)
81136bc0:	00a04534 	movhi	r2,33044
81136bc4:	109ac404 	addi	r2,r2,27408
81136bc8:	10800817 	ldw	r2,32(r2)
81136bcc:	100d883a 	mov	r6,r2
81136bd0:	180b883a 	mov	r5,r3
81136bd4:	01204534 	movhi	r4,33044
81136bd8:	211ac404 	addi	r4,r4,27408
81136bdc:	113e8a00 	call	8113e8a0 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
81136be0:	01204534 	movhi	r4,33044
81136be4:	211add04 	addi	r4,r4,27508
81136be8:	1136a980 	call	81136a98 <alt_dev_reg>
}
81136bec:	0001883a 	nop
81136bf0:	e037883a 	mov	sp,fp
81136bf4:	dfc00117 	ldw	ra,4(sp)
81136bf8:	df000017 	ldw	fp,0(sp)
81136bfc:	dec00204 	addi	sp,sp,8
81136c00:	f800283a 	ret

81136c04 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
81136c04:	defffa04 	addi	sp,sp,-24
81136c08:	de00012e 	bgeu	sp,et,81136c10 <Write_Sector_Data+0xc>
81136c0c:	003b68fa 	trap	3
81136c10:	dfc00515 	stw	ra,20(sp)
81136c14:	df000415 	stw	fp,16(sp)
81136c18:	df000404 	addi	fp,sp,16
81136c1c:	e13ffe15 	stw	r4,-8(fp)
81136c20:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81136c24:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
81136c28:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
81136c2c:	10001e26 	beq	r2,zero,81136ca8 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
81136c30:	00803fc4 	movi	r2,255
81136c34:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81136c38:	d0a09f17 	ldw	r2,-32132(gp)
81136c3c:	e13ffe17 	ldw	r4,-8(fp)
81136c40:	e0ffff17 	ldw	r3,-4(fp)
81136c44:	20c7883a 	add	r3,r4,r3
81136c48:	1806927a 	slli	r3,r3,9
81136c4c:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
81136c50:	d0a09e17 	ldw	r2,-32136(gp)
81136c54:	00c00604 	movi	r3,24
81136c58:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81136c5c:	d0a09b17 	ldw	r2,-32148(gp)
81136c60:	1080002b 	ldhuio	r2,0(r2)
81136c64:	10bfffcc 	andi	r2,r2,65535
81136c68:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
81136c6c:	e0bffd0b 	ldhu	r2,-12(fp)
81136c70:	10bfffcc 	andi	r2,r2,65535
81136c74:	1080010c 	andi	r2,r2,4
81136c78:	103ff81e 	bne	r2,zero,81136c5c <__reset+0xfb116c5c>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
81136c7c:	e0bffd0b 	ldhu	r2,-12(fp)
81136c80:	10bfffcc 	andi	r2,r2,65535
81136c84:	1080040c 	andi	r2,r2,16
81136c88:	1000071e 	bne	r2,zero,81136ca8 <Write_Sector_Data+0xa4>
        {
            result = true;
81136c8c:	00800044 	movi	r2,1
81136c90:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81136c94:	d020a415 	stw	zero,-32112(gp)
            current_sector_index = sector_index+partition_offset;
81136c98:	e0fffe17 	ldw	r3,-8(fp)
81136c9c:	e0bfff17 	ldw	r2,-4(fp)
81136ca0:	1885883a 	add	r2,r3,r2
81136ca4:	d0a0a515 	stw	r2,-32108(gp)
        }
    }
    return result;
81136ca8:	e0bffc17 	ldw	r2,-16(fp)
}
81136cac:	e037883a 	mov	sp,fp
81136cb0:	dfc00117 	ldw	ra,4(sp)
81136cb4:	df000017 	ldw	fp,0(sp)
81136cb8:	dec00204 	addi	sp,sp,8
81136cbc:	f800283a 	ret

81136cc0 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
81136cc0:	defffd04 	addi	sp,sp,-12
81136cc4:	de00012e 	bgeu	sp,et,81136ccc <Save_Modified_Sector+0xc>
81136cc8:	003b68fa 	trap	3
81136ccc:	dfc00215 	stw	ra,8(sp)
81136cd0:	df000115 	stw	fp,4(sp)
81136cd4:	df000104 	addi	fp,sp,4
    bool result = true;
81136cd8:	00800044 	movi	r2,1
81136cdc:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
81136ce0:	d0a0a417 	ldw	r2,-32112(gp)
81136ce4:	10000526 	beq	r2,zero,81136cfc <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81136ce8:	d0a0a517 	ldw	r2,-32108(gp)
81136cec:	000b883a 	mov	r5,zero
81136cf0:	1009883a 	mov	r4,r2
81136cf4:	1136c040 	call	81136c04 <Write_Sector_Data>
81136cf8:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
81136cfc:	e0bfff17 	ldw	r2,-4(fp)
}
81136d00:	e037883a 	mov	sp,fp
81136d04:	dfc00117 	ldw	ra,4(sp)
81136d08:	df000017 	ldw	fp,0(sp)
81136d0c:	dec00204 	addi	sp,sp,8
81136d10:	f800283a 	ret

81136d14 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
81136d14:	defffa04 	addi	sp,sp,-24
81136d18:	de00012e 	bgeu	sp,et,81136d20 <Read_Sector_Data+0xc>
81136d1c:	003b68fa 	trap	3
81136d20:	dfc00515 	stw	ra,20(sp)
81136d24:	df000415 	stw	fp,16(sp)
81136d28:	df000404 	addi	fp,sp,16
81136d2c:	e13ffe15 	stw	r4,-8(fp)
81136d30:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
81136d34:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
81136d38:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
81136d3c:	10002726 	beq	r2,zero,81136ddc <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
81136d40:	00803fc4 	movi	r2,255
81136d44:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
81136d48:	d0a0a417 	ldw	r2,-32112(gp)
81136d4c:	10000726 	beq	r2,zero,81136d6c <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
81136d50:	d0a0a517 	ldw	r2,-32108(gp)
81136d54:	000b883a 	mov	r5,zero
81136d58:	1009883a 	mov	r4,r2
81136d5c:	1136c040 	call	81136c04 <Write_Sector_Data>
81136d60:	1000021e 	bne	r2,zero,81136d6c <Read_Sector_Data+0x58>
            {
                return false;
81136d64:	0005883a 	mov	r2,zero
81136d68:	00001d06 	br	81136de0 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81136d6c:	d0a09f17 	ldw	r2,-32132(gp)
81136d70:	e13ffe17 	ldw	r4,-8(fp)
81136d74:	e0ffff17 	ldw	r3,-4(fp)
81136d78:	20c7883a 	add	r3,r4,r3
81136d7c:	1806927a 	slli	r3,r3,9
81136d80:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
81136d84:	d0a09e17 	ldw	r2,-32136(gp)
81136d88:	00c00444 	movi	r3,17
81136d8c:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81136d90:	d0a09b17 	ldw	r2,-32148(gp)
81136d94:	1080002b 	ldhuio	r2,0(r2)
81136d98:	10bfffcc 	andi	r2,r2,65535
81136d9c:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
81136da0:	e0bffd0b 	ldhu	r2,-12(fp)
81136da4:	10bfffcc 	andi	r2,r2,65535
81136da8:	1080010c 	andi	r2,r2,4
81136dac:	103ff81e 	bne	r2,zero,81136d90 <__reset+0xfb116d90>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
81136db0:	e0bffd0b 	ldhu	r2,-12(fp)
81136db4:	10bfffcc 	andi	r2,r2,65535
81136db8:	1080040c 	andi	r2,r2,16
81136dbc:	1000071e 	bne	r2,zero,81136ddc <Read_Sector_Data+0xc8>
		{
			result = true;
81136dc0:	00800044 	movi	r2,1
81136dc4:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81136dc8:	d020a415 	stw	zero,-32112(gp)
            current_sector_index = sector_index+partition_offset;
81136dcc:	e0fffe17 	ldw	r3,-8(fp)
81136dd0:	e0bfff17 	ldw	r2,-4(fp)
81136dd4:	1885883a 	add	r2,r3,r2
81136dd8:	d0a0a515 	stw	r2,-32108(gp)
		}
	}
	return result;
81136ddc:	e0bffc17 	ldw	r2,-16(fp)
}
81136de0:	e037883a 	mov	sp,fp
81136de4:	dfc00117 	ldw	ra,4(sp)
81136de8:	df000017 	ldw	fp,0(sp)
81136dec:	dec00204 	addi	sp,sp,8
81136df0:	f800283a 	ret

81136df4 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
81136df4:	defffb04 	addi	sp,sp,-20
81136df8:	de00012e 	bgeu	sp,et,81136e00 <get_cluster_flag+0xc>
81136dfc:	003b68fa 	trap	3
81136e00:	dfc00415 	stw	ra,16(sp)
81136e04:	df000315 	stw	fp,12(sp)
81136e08:	df000304 	addi	fp,sp,12
81136e0c:	e13ffe15 	stw	r4,-8(fp)
81136e10:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
81136e14:	e0bffe17 	ldw	r2,-8(fp)
81136e18:	1004d23a 	srli	r2,r2,8
81136e1c:	d0e0a117 	ldw	r3,-32124(gp)
81136e20:	10c5883a 	add	r2,r2,r3
81136e24:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81136e28:	00a045b4 	movhi	r2,33046
81136e2c:	10bfe004 	addi	r2,r2,-128
81136e30:	10801117 	ldw	r2,68(r2)
81136e34:	e0fffd17 	ldw	r3,-12(fp)
81136e38:	1885883a 	add	r2,r3,r2
81136e3c:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
81136e40:	d0a0a517 	ldw	r2,-32108(gp)
81136e44:	e0fffd17 	ldw	r3,-12(fp)
81136e48:	18800726 	beq	r3,r2,81136e68 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
81136e4c:	e0bffd17 	ldw	r2,-12(fp)
81136e50:	000b883a 	mov	r5,zero
81136e54:	1009883a 	mov	r4,r2
81136e58:	1136d140 	call	81136d14 <Read_Sector_Data>
81136e5c:	1000021e 	bne	r2,zero,81136e68 <get_cluster_flag+0x74>
        {
            return false;
81136e60:	0005883a 	mov	r2,zero
81136e64:	00000d06 	br	81136e9c <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
81136e68:	e0bffe17 	ldw	r2,-8(fp)
81136e6c:	10803fcc 	andi	r2,r2,255
81136e70:	1085883a 	add	r2,r2,r2
81136e74:	1007883a 	mov	r3,r2
81136e78:	d0a0a317 	ldw	r2,-32116(gp)
81136e7c:	10800a17 	ldw	r2,40(r2)
81136e80:	1885883a 	add	r2,r3,r2
81136e84:	1080002b 	ldhuio	r2,0(r2)
81136e88:	10bfffcc 	andi	r2,r2,65535
81136e8c:	1007883a 	mov	r3,r2
81136e90:	e0bfff17 	ldw	r2,-4(fp)
81136e94:	10c0000d 	sth	r3,0(r2)
    return true;
81136e98:	00800044 	movi	r2,1
}
81136e9c:	e037883a 	mov	sp,fp
81136ea0:	dfc00117 	ldw	ra,4(sp)
81136ea4:	df000017 	ldw	fp,0(sp)
81136ea8:	dec00204 	addi	sp,sp,8
81136eac:	f800283a 	ret

81136eb0 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
81136eb0:	defffa04 	addi	sp,sp,-24
81136eb4:	de00012e 	bgeu	sp,et,81136ebc <mark_cluster+0xc>
81136eb8:	003b68fa 	trap	3
81136ebc:	dfc00515 	stw	ra,20(sp)
81136ec0:	df000415 	stw	fp,16(sp)
81136ec4:	df000404 	addi	fp,sp,16
81136ec8:	e13ffd15 	stw	r4,-12(fp)
81136ecc:	2805883a 	mov	r2,r5
81136ed0:	e1bfff15 	stw	r6,-4(fp)
81136ed4:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
81136ed8:	e0bffd17 	ldw	r2,-12(fp)
81136edc:	1004d23a 	srli	r2,r2,8
81136ee0:	d0e0a117 	ldw	r3,-32124(gp)
81136ee4:	10c5883a 	add	r2,r2,r3
81136ee8:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
81136eec:	e0bfff17 	ldw	r2,-4(fp)
81136ef0:	10000726 	beq	r2,zero,81136f10 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81136ef4:	00a045b4 	movhi	r2,33046
81136ef8:	10bfe004 	addi	r2,r2,-128
81136efc:	10801117 	ldw	r2,68(r2)
81136f00:	e0fffc17 	ldw	r3,-16(fp)
81136f04:	1885883a 	add	r2,r3,r2
81136f08:	e0bffc15 	stw	r2,-16(fp)
81136f0c:	00000606 	br	81136f28 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
81136f10:	00a045b4 	movhi	r2,33046
81136f14:	10bfe004 	addi	r2,r2,-128
81136f18:	10801217 	ldw	r2,72(r2)
81136f1c:	e0fffc17 	ldw	r3,-16(fp)
81136f20:	1885883a 	add	r2,r3,r2
81136f24:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
81136f28:	d0a0a517 	ldw	r2,-32108(gp)
81136f2c:	e0fffc17 	ldw	r3,-16(fp)
81136f30:	18800726 	beq	r3,r2,81136f50 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
81136f34:	e0bffc17 	ldw	r2,-16(fp)
81136f38:	000b883a 	mov	r5,zero
81136f3c:	1009883a 	mov	r4,r2
81136f40:	1136d140 	call	81136d14 <Read_Sector_Data>
81136f44:	1000021e 	bne	r2,zero,81136f50 <mark_cluster+0xa0>
        {
            return false;
81136f48:	0005883a 	mov	r2,zero
81136f4c:	00000d06 	br	81136f84 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
81136f50:	e0bffd17 	ldw	r2,-12(fp)
81136f54:	10803fcc 	andi	r2,r2,255
81136f58:	1085883a 	add	r2,r2,r2
81136f5c:	1007883a 	mov	r3,r2
81136f60:	d0a0a317 	ldw	r2,-32116(gp)
81136f64:	10800a17 	ldw	r2,40(r2)
81136f68:	1885883a 	add	r2,r3,r2
81136f6c:	1007883a 	mov	r3,r2
81136f70:	e0bffe0f 	ldh	r2,-8(fp)
81136f74:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
81136f78:	00800044 	movi	r2,1
81136f7c:	d0a0a415 	stw	r2,-32112(gp)
    return true;
81136f80:	00800044 	movi	r2,1
}
81136f84:	e037883a 	mov	sp,fp
81136f88:	dfc00117 	ldw	ra,4(sp)
81136f8c:	df000017 	ldw	fp,0(sp)
81136f90:	dec00204 	addi	sp,sp,8
81136f94:	f800283a 	ret

81136f98 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
81136f98:	defff704 	addi	sp,sp,-36
81136f9c:	de00012e 	bgeu	sp,et,81136fa4 <Check_for_Master_Boot_Record+0xc>
81136fa0:	003b68fa 	trap	3
81136fa4:	dfc00815 	stw	ra,32(sp)
81136fa8:	df000715 	stw	fp,28(sp)
81136fac:	df000704 	addi	fp,sp,28
	bool result = false;
81136fb0:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
81136fb4:	000b883a 	mov	r5,zero
81136fb8:	0009883a 	mov	r4,zero
81136fbc:	1136d140 	call	81136d14 <Read_Sector_Data>
81136fc0:	10005a26 	beq	r2,zero,8113712c <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
81136fc4:	d0a0a317 	ldw	r2,-32116(gp)
81136fc8:	10800a17 	ldw	r2,40(r2)
81136fcc:	10807f84 	addi	r2,r2,510
81136fd0:	1080002b 	ldhuio	r2,0(r2)
81136fd4:	10bfffcc 	andi	r2,r2,65535
81136fd8:	10bfffcc 	andi	r2,r2,65535
81136fdc:	10a0001c 	xori	r2,r2,32768
81136fe0:	10a00004 	addi	r2,r2,-32768
81136fe4:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
81136fe8:	e0bffb17 	ldw	r2,-20(fp)
81136fec:	10ffffcc 	andi	r3,r2,65535
81136ff0:	00aa9554 	movui	r2,43605
81136ff4:	18804d1e 	bne	r3,r2,8113712c <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81136ff8:	e03ffa15 	stw	zero,-24(fp)
81136ffc:	00004806 	br	81137120 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
81137000:	e0bffa17 	ldw	r2,-24(fp)
81137004:	1004913a 	slli	r2,r2,4
81137008:	10806f84 	addi	r2,r2,446
8113700c:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
81137010:	d0a0a317 	ldw	r2,-32116(gp)
81137014:	10c00a17 	ldw	r3,40(r2)
81137018:	e0bffc17 	ldw	r2,-16(fp)
8113701c:	1885883a 	add	r2,r3,r2
81137020:	10800104 	addi	r2,r2,4
81137024:	10800023 	ldbuio	r2,0(r2)
81137028:	10803fcc 	andi	r2,r2,255
8113702c:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
81137030:	e0bffd07 	ldb	r2,-12(fp)
81137034:	10800060 	cmpeqi	r2,r2,1
81137038:	1000091e 	bne	r2,zero,81137060 <Check_for_Master_Boot_Record+0xc8>
8113703c:	e0bffd07 	ldb	r2,-12(fp)
81137040:	10800120 	cmpeqi	r2,r2,4
81137044:	1000061e 	bne	r2,zero,81137060 <Check_for_Master_Boot_Record+0xc8>
81137048:	e0bffd07 	ldb	r2,-12(fp)
8113704c:	108001a0 	cmpeqi	r2,r2,6
81137050:	1000031e 	bne	r2,zero,81137060 <Check_for_Master_Boot_Record+0xc8>
81137054:	e0bffd07 	ldb	r2,-12(fp)
81137058:	10800398 	cmpnei	r2,r2,14
8113705c:	10002d1e 	bne	r2,zero,81137114 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
81137060:	d0a0a317 	ldw	r2,-32116(gp)
81137064:	10c00a17 	ldw	r3,40(r2)
81137068:	e0bffc17 	ldw	r2,-16(fp)
8113706c:	1885883a 	add	r2,r3,r2
81137070:	10800284 	addi	r2,r2,10
81137074:	1080002b 	ldhuio	r2,0(r2)
81137078:	10bfffcc 	andi	r2,r2,65535
8113707c:	1006943a 	slli	r3,r2,16
81137080:	d0a0a317 	ldw	r2,-32116(gp)
81137084:	11000a17 	ldw	r4,40(r2)
81137088:	e0bffc17 	ldw	r2,-16(fp)
8113708c:	2085883a 	add	r2,r4,r2
81137090:	10800204 	addi	r2,r2,8
81137094:	1080002b 	ldhuio	r2,0(r2)
81137098:	10bfffcc 	andi	r2,r2,65535
8113709c:	10bfffcc 	andi	r2,r2,65535
811370a0:	1884b03a 	or	r2,r3,r2
811370a4:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
811370a8:	d0a0a317 	ldw	r2,-32116(gp)
811370ac:	10c00a17 	ldw	r3,40(r2)
811370b0:	e0bffc17 	ldw	r2,-16(fp)
811370b4:	1885883a 	add	r2,r3,r2
811370b8:	10800384 	addi	r2,r2,14
811370bc:	1080002b 	ldhuio	r2,0(r2)
811370c0:	10bfffcc 	andi	r2,r2,65535
811370c4:	1006943a 	slli	r3,r2,16
811370c8:	d0a0a317 	ldw	r2,-32116(gp)
811370cc:	11000a17 	ldw	r4,40(r2)
811370d0:	e0bffc17 	ldw	r2,-16(fp)
811370d4:	2085883a 	add	r2,r4,r2
811370d8:	10800304 	addi	r2,r2,12
811370dc:	1080002b 	ldhuio	r2,0(r2)
811370e0:	10bfffcc 	andi	r2,r2,65535
811370e4:	10bfffcc 	andi	r2,r2,65535
811370e8:	1884b03a 	or	r2,r3,r2
811370ec:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
811370f0:	e0bfff17 	ldw	r2,-4(fp)
811370f4:	0080070e 	bge	zero,r2,81137114 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
811370f8:	00800044 	movi	r2,1
811370fc:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
81137100:	e0bfff17 	ldw	r2,-4(fp)
81137104:	d0a0a215 	stw	r2,-32120(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
81137108:	e0bffe17 	ldw	r2,-8(fp)
8113710c:	d0a0a115 	stw	r2,-32124(gp)
						break;
81137110:	00000606 	br	8113712c <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81137114:	e0bffa17 	ldw	r2,-24(fp)
81137118:	10800044 	addi	r2,r2,1
8113711c:	e0bffa15 	stw	r2,-24(fp)
81137120:	e0bffa17 	ldw	r2,-24(fp)
81137124:	10800110 	cmplti	r2,r2,4
81137128:	103fb51e 	bne	r2,zero,81137000 <__reset+0xfb117000>
				}
			}
		}
	}

	return result;
8113712c:	e0bff917 	ldw	r2,-28(fp)
}
81137130:	e037883a 	mov	sp,fp
81137134:	dfc00117 	ldw	ra,4(sp)
81137138:	df000017 	ldw	fp,0(sp)
8113713c:	dec00204 	addi	sp,sp,8
81137140:	f800283a 	ret

81137144 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
81137144:	defff804 	addi	sp,sp,-32
81137148:	de00012e 	bgeu	sp,et,81137150 <Read_File_Record_At_Offset+0xc>
8113714c:	003b68fa 	trap	3
81137150:	dfc00715 	stw	ra,28(sp)
81137154:	df000615 	stw	fp,24(sp)
81137158:	df000604 	addi	fp,sp,24
8113715c:	e13ffc15 	stw	r4,-16(fp)
81137160:	e17ffd15 	stw	r5,-12(fp)
81137164:	e1bffe15 	stw	r6,-8(fp)
81137168:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8113716c:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81137170:	e0bffc17 	ldw	r2,-16(fp)
81137174:	108007cc 	andi	r2,r2,31
81137178:	10008d1e 	bne	r2,zero,811373b0 <Read_File_Record_At_Offset+0x26c>
8113717c:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
81137180:	10008b26 	beq	r2,zero,811373b0 <Read_File_Record_At_Offset+0x26c>
81137184:	d0a09a17 	ldw	r2,-32152(gp)
81137188:	10008926 	beq	r2,zero,811373b0 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113718c:	e03ffb15 	stw	zero,-20(fp)
81137190:	00001106 	br	811371d8 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
81137194:	e0fffc17 	ldw	r3,-16(fp)
81137198:	e0bffb17 	ldw	r2,-20(fp)
8113719c:	1885883a 	add	r2,r3,r2
811371a0:	1007883a 	mov	r3,r2
811371a4:	d0a0a317 	ldw	r2,-32116(gp)
811371a8:	10800a17 	ldw	r2,40(r2)
811371ac:	1885883a 	add	r2,r3,r2
811371b0:	10800023 	ldbuio	r2,0(r2)
811371b4:	10803fcc 	andi	r2,r2,255
811371b8:	1009883a 	mov	r4,r2
811371bc:	e0fffd17 	ldw	r3,-12(fp)
811371c0:	e0bffb17 	ldw	r2,-20(fp)
811371c4:	1885883a 	add	r2,r3,r2
811371c8:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
811371cc:	e0bffb17 	ldw	r2,-20(fp)
811371d0:	10800044 	addi	r2,r2,1
811371d4:	e0bffb15 	stw	r2,-20(fp)
811371d8:	e0bffb17 	ldw	r2,-20(fp)
811371dc:	10800210 	cmplti	r2,r2,8
811371e0:	103fec1e 	bne	r2,zero,81137194 <__reset+0xfb117194>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
811371e4:	e03ffb15 	stw	zero,-20(fp)
811371e8:	00001306 	br	81137238 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
811371ec:	e0fffc17 	ldw	r3,-16(fp)
811371f0:	e0bffb17 	ldw	r2,-20(fp)
811371f4:	1885883a 	add	r2,r3,r2
811371f8:	1007883a 	mov	r3,r2
811371fc:	d0a0a317 	ldw	r2,-32116(gp)
81137200:	10800a17 	ldw	r2,40(r2)
81137204:	1885883a 	add	r2,r3,r2
81137208:	10800204 	addi	r2,r2,8
8113720c:	10800023 	ldbuio	r2,0(r2)
81137210:	10803fcc 	andi	r2,r2,255
81137214:	1009883a 	mov	r4,r2
81137218:	e0fffd17 	ldw	r3,-12(fp)
8113721c:	e0bffb17 	ldw	r2,-20(fp)
81137220:	1885883a 	add	r2,r3,r2
81137224:	10800204 	addi	r2,r2,8
81137228:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113722c:	e0bffb17 	ldw	r2,-20(fp)
81137230:	10800044 	addi	r2,r2,1
81137234:	e0bffb15 	stw	r2,-20(fp)
81137238:	e0bffb17 	ldw	r2,-20(fp)
8113723c:	108000d0 	cmplti	r2,r2,3
81137240:	103fea1e 	bne	r2,zero,811371ec <__reset+0xfb1171ec>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
81137244:	d0a0a317 	ldw	r2,-32116(gp)
81137248:	10c00a17 	ldw	r3,40(r2)
8113724c:	e0bffc17 	ldw	r2,-16(fp)
81137250:	1885883a 	add	r2,r3,r2
81137254:	108002c4 	addi	r2,r2,11
81137258:	10800023 	ldbuio	r2,0(r2)
8113725c:	10803fcc 	andi	r2,r2,255
81137260:	1007883a 	mov	r3,r2
81137264:	e0bffd17 	ldw	r2,-12(fp)
81137268:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8113726c:	d0a0a317 	ldw	r2,-32116(gp)
81137270:	10c00a17 	ldw	r3,40(r2)
81137274:	e0bffc17 	ldw	r2,-16(fp)
81137278:	1885883a 	add	r2,r3,r2
8113727c:	10800384 	addi	r2,r2,14
81137280:	1080002b 	ldhuio	r2,0(r2)
81137284:	10bfffcc 	andi	r2,r2,65535
81137288:	1007883a 	mov	r3,r2
8113728c:	e0bffd17 	ldw	r2,-12(fp)
81137290:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
81137294:	d0a0a317 	ldw	r2,-32116(gp)
81137298:	10c00a17 	ldw	r3,40(r2)
8113729c:	e0bffc17 	ldw	r2,-16(fp)
811372a0:	1885883a 	add	r2,r3,r2
811372a4:	10800404 	addi	r2,r2,16
811372a8:	1080002b 	ldhuio	r2,0(r2)
811372ac:	10bfffcc 	andi	r2,r2,65535
811372b0:	1007883a 	mov	r3,r2
811372b4:	e0bffd17 	ldw	r2,-12(fp)
811372b8:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
811372bc:	d0a0a317 	ldw	r2,-32116(gp)
811372c0:	10c00a17 	ldw	r3,40(r2)
811372c4:	e0bffc17 	ldw	r2,-16(fp)
811372c8:	1885883a 	add	r2,r3,r2
811372cc:	10800484 	addi	r2,r2,18
811372d0:	1080002b 	ldhuio	r2,0(r2)
811372d4:	10bfffcc 	andi	r2,r2,65535
811372d8:	1007883a 	mov	r3,r2
811372dc:	e0bffd17 	ldw	r2,-12(fp)
811372e0:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
811372e4:	d0a0a317 	ldw	r2,-32116(gp)
811372e8:	10c00a17 	ldw	r3,40(r2)
811372ec:	e0bffc17 	ldw	r2,-16(fp)
811372f0:	1885883a 	add	r2,r3,r2
811372f4:	10800584 	addi	r2,r2,22
811372f8:	1080002b 	ldhuio	r2,0(r2)
811372fc:	10bfffcc 	andi	r2,r2,65535
81137300:	1007883a 	mov	r3,r2
81137304:	e0bffd17 	ldw	r2,-12(fp)
81137308:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
8113730c:	d0a0a317 	ldw	r2,-32116(gp)
81137310:	10c00a17 	ldw	r3,40(r2)
81137314:	e0bffc17 	ldw	r2,-16(fp)
81137318:	1885883a 	add	r2,r3,r2
8113731c:	10800604 	addi	r2,r2,24
81137320:	1080002b 	ldhuio	r2,0(r2)
81137324:	10bfffcc 	andi	r2,r2,65535
81137328:	1007883a 	mov	r3,r2
8113732c:	e0bffd17 	ldw	r2,-12(fp)
81137330:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
81137334:	d0a0a317 	ldw	r2,-32116(gp)
81137338:	10c00a17 	ldw	r3,40(r2)
8113733c:	e0bffc17 	ldw	r2,-16(fp)
81137340:	1885883a 	add	r2,r3,r2
81137344:	10800684 	addi	r2,r2,26
81137348:	1080002b 	ldhuio	r2,0(r2)
8113734c:	10bfffcc 	andi	r2,r2,65535
81137350:	1007883a 	mov	r3,r2
81137354:	e0bffd17 	ldw	r2,-12(fp)
81137358:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8113735c:	d0a0a317 	ldw	r2,-32116(gp)
81137360:	10c00a17 	ldw	r3,40(r2)
81137364:	e0bffc17 	ldw	r2,-16(fp)
81137368:	1885883a 	add	r2,r3,r2
8113736c:	10800704 	addi	r2,r2,28
81137370:	10800037 	ldwio	r2,0(r2)
81137374:	1007883a 	mov	r3,r2
81137378:	e0bffd17 	ldw	r2,-12(fp)
8113737c:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
81137380:	e0bffd17 	ldw	r2,-12(fp)
81137384:	e0fffe17 	ldw	r3,-8(fp)
81137388:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8113738c:	e0bffd17 	ldw	r2,-12(fp)
81137390:	e0ffff17 	ldw	r3,-4(fp)
81137394:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
81137398:	e0bffc17 	ldw	r2,-16(fp)
8113739c:	1007883a 	mov	r3,r2
811373a0:	e0bffd17 	ldw	r2,-12(fp)
811373a4:	10c00c0d 	sth	r3,48(r2)
		result = true;
811373a8:	00800044 	movi	r2,1
811373ac:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
811373b0:	e0bffa17 	ldw	r2,-24(fp)
}
811373b4:	e037883a 	mov	sp,fp
811373b8:	dfc00117 	ldw	ra,4(sp)
811373bc:	df000017 	ldw	fp,0(sp)
811373c0:	dec00204 	addi	sp,sp,8
811373c4:	f800283a 	ret

811373c8 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
811373c8:	defff904 	addi	sp,sp,-28
811373cc:	de00012e 	bgeu	sp,et,811373d4 <Write_File_Record_At_Offset+0xc>
811373d0:	003b68fa 	trap	3
811373d4:	dfc00615 	stw	ra,24(sp)
811373d8:	df000515 	stw	fp,20(sp)
811373dc:	df000504 	addi	fp,sp,20
811373e0:	e13ffe15 	stw	r4,-8(fp)
811373e4:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
811373e8:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811373ec:	e0bffe17 	ldw	r2,-8(fp)
811373f0:	108007cc 	andi	r2,r2,31
811373f4:	1000931e 	bne	r2,zero,81137644 <Write_File_Record_At_Offset+0x27c>
811373f8:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
811373fc:	10009126 	beq	r2,zero,81137644 <Write_File_Record_At_Offset+0x27c>
81137400:	d0a09a17 	ldw	r2,-32152(gp)
81137404:	10008f26 	beq	r2,zero,81137644 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81137408:	e03ffc15 	stw	zero,-16(fp)
8113740c:	00001f06 	br	8113748c <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
81137410:	e0bffc17 	ldw	r2,-16(fp)
81137414:	10800044 	addi	r2,r2,1
81137418:	e0ffff17 	ldw	r3,-4(fp)
8113741c:	1885883a 	add	r2,r3,r2
81137420:	10800003 	ldbu	r2,0(r2)
81137424:	10803fcc 	andi	r2,r2,255
81137428:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
8113742c:	e0bffd0f 	ldh	r2,-12(fp)
81137430:	1004923a 	slli	r2,r2,8
81137434:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
81137438:	e0ffff17 	ldw	r3,-4(fp)
8113743c:	e0bffc17 	ldw	r2,-16(fp)
81137440:	1885883a 	add	r2,r3,r2
81137444:	10800003 	ldbu	r2,0(r2)
81137448:	10c03fcc 	andi	r3,r2,255
8113744c:	e0bffd0b 	ldhu	r2,-12(fp)
81137450:	1884b03a 	or	r2,r3,r2
81137454:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
81137458:	e0fffe17 	ldw	r3,-8(fp)
8113745c:	e0bffc17 	ldw	r2,-16(fp)
81137460:	1885883a 	add	r2,r3,r2
81137464:	1007883a 	mov	r3,r2
81137468:	d0a0a317 	ldw	r2,-32116(gp)
8113746c:	10800a17 	ldw	r2,40(r2)
81137470:	1885883a 	add	r2,r3,r2
81137474:	1007883a 	mov	r3,r2
81137478:	e0bffd0f 	ldh	r2,-12(fp)
8113747c:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81137480:	e0bffc17 	ldw	r2,-16(fp)
81137484:	10800084 	addi	r2,r2,2
81137488:	e0bffc15 	stw	r2,-16(fp)
8113748c:	e0bffc17 	ldw	r2,-16(fp)
81137490:	10800210 	cmplti	r2,r2,8
81137494:	103fde1e 	bne	r2,zero,81137410 <__reset+0xfb117410>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81137498:	e03ffc15 	stw	zero,-16(fp)
8113749c:	00001306 	br	811374ec <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
811374a0:	e0fffe17 	ldw	r3,-8(fp)
811374a4:	e0bffc17 	ldw	r2,-16(fp)
811374a8:	1885883a 	add	r2,r3,r2
811374ac:	1007883a 	mov	r3,r2
811374b0:	d0a0a317 	ldw	r2,-32116(gp)
811374b4:	10800a17 	ldw	r2,40(r2)
811374b8:	1885883a 	add	r2,r3,r2
811374bc:	10800204 	addi	r2,r2,8
811374c0:	1009883a 	mov	r4,r2
811374c4:	e0ffff17 	ldw	r3,-4(fp)
811374c8:	e0bffc17 	ldw	r2,-16(fp)
811374cc:	1885883a 	add	r2,r3,r2
811374d0:	10800204 	addi	r2,r2,8
811374d4:	10800003 	ldbu	r2,0(r2)
811374d8:	10803fcc 	andi	r2,r2,255
811374dc:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
811374e0:	e0bffc17 	ldw	r2,-16(fp)
811374e4:	10800044 	addi	r2,r2,1
811374e8:	e0bffc15 	stw	r2,-16(fp)
811374ec:	e0bffc17 	ldw	r2,-16(fp)
811374f0:	108000d0 	cmplti	r2,r2,3
811374f4:	103fea1e 	bne	r2,zero,811374a0 <__reset+0xfb1174a0>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
811374f8:	d0a0a317 	ldw	r2,-32116(gp)
811374fc:	10c00a17 	ldw	r3,40(r2)
81137500:	e0bffe17 	ldw	r2,-8(fp)
81137504:	1885883a 	add	r2,r3,r2
81137508:	108002c4 	addi	r2,r2,11
8113750c:	1007883a 	mov	r3,r2
81137510:	e0bfff17 	ldw	r2,-4(fp)
81137514:	108002c3 	ldbu	r2,11(r2)
81137518:	10803fcc 	andi	r2,r2,255
8113751c:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
81137520:	d0a0a317 	ldw	r2,-32116(gp)
81137524:	10c00a17 	ldw	r3,40(r2)
81137528:	e0bffe17 	ldw	r2,-8(fp)
8113752c:	1885883a 	add	r2,r3,r2
81137530:	10800384 	addi	r2,r2,14
81137534:	1007883a 	mov	r3,r2
81137538:	e0bfff17 	ldw	r2,-4(fp)
8113753c:	1080030b 	ldhu	r2,12(r2)
81137540:	10bfffcc 	andi	r2,r2,65535
81137544:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
81137548:	d0a0a317 	ldw	r2,-32116(gp)
8113754c:	10c00a17 	ldw	r3,40(r2)
81137550:	e0bffe17 	ldw	r2,-8(fp)
81137554:	1885883a 	add	r2,r3,r2
81137558:	10800404 	addi	r2,r2,16
8113755c:	1007883a 	mov	r3,r2
81137560:	e0bfff17 	ldw	r2,-4(fp)
81137564:	1080038b 	ldhu	r2,14(r2)
81137568:	10bfffcc 	andi	r2,r2,65535
8113756c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81137570:	d0a0a317 	ldw	r2,-32116(gp)
81137574:	10c00a17 	ldw	r3,40(r2)
81137578:	e0bffe17 	ldw	r2,-8(fp)
8113757c:	1885883a 	add	r2,r3,r2
81137580:	10800484 	addi	r2,r2,18
81137584:	1007883a 	mov	r3,r2
81137588:	e0bfff17 	ldw	r2,-4(fp)
8113758c:	1080040b 	ldhu	r2,16(r2)
81137590:	10bfffcc 	andi	r2,r2,65535
81137594:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81137598:	d0a0a317 	ldw	r2,-32116(gp)
8113759c:	10c00a17 	ldw	r3,40(r2)
811375a0:	e0bffe17 	ldw	r2,-8(fp)
811375a4:	1885883a 	add	r2,r3,r2
811375a8:	10800584 	addi	r2,r2,22
811375ac:	1007883a 	mov	r3,r2
811375b0:	e0bfff17 	ldw	r2,-4(fp)
811375b4:	1080048b 	ldhu	r2,18(r2)
811375b8:	10bfffcc 	andi	r2,r2,65535
811375bc:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
811375c0:	d0a0a317 	ldw	r2,-32116(gp)
811375c4:	10c00a17 	ldw	r3,40(r2)
811375c8:	e0bffe17 	ldw	r2,-8(fp)
811375cc:	1885883a 	add	r2,r3,r2
811375d0:	10800604 	addi	r2,r2,24
811375d4:	1007883a 	mov	r3,r2
811375d8:	e0bfff17 	ldw	r2,-4(fp)
811375dc:	1080050b 	ldhu	r2,20(r2)
811375e0:	10bfffcc 	andi	r2,r2,65535
811375e4:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
811375e8:	d0a0a317 	ldw	r2,-32116(gp)
811375ec:	10c00a17 	ldw	r3,40(r2)
811375f0:	e0bffe17 	ldw	r2,-8(fp)
811375f4:	1885883a 	add	r2,r3,r2
811375f8:	10800684 	addi	r2,r2,26
811375fc:	1007883a 	mov	r3,r2
81137600:	e0bfff17 	ldw	r2,-4(fp)
81137604:	1080058b 	ldhu	r2,22(r2)
81137608:	10bfffcc 	andi	r2,r2,65535
8113760c:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
81137610:	d0a0a317 	ldw	r2,-32116(gp)
81137614:	10c00a17 	ldw	r3,40(r2)
81137618:	e0bffe17 	ldw	r2,-8(fp)
8113761c:	1885883a 	add	r2,r3,r2
81137620:	10800704 	addi	r2,r2,28
81137624:	1007883a 	mov	r3,r2
81137628:	e0bfff17 	ldw	r2,-4(fp)
8113762c:	10800617 	ldw	r2,24(r2)
81137630:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81137634:	00800044 	movi	r2,1
81137638:	d0a0a415 	stw	r2,-32112(gp)
        result = true;
8113763c:	00800044 	movi	r2,1
81137640:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81137644:	e0bffb17 	ldw	r2,-20(fp)
}
81137648:	e037883a 	mov	sp,fp
8113764c:	dfc00117 	ldw	ra,4(sp)
81137650:	df000017 	ldw	fp,0(sp)
81137654:	dec00204 	addi	sp,sp,8
81137658:	f800283a 	ret

8113765c <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8113765c:	defff904 	addi	sp,sp,-28
81137660:	de00012e 	bgeu	sp,et,81137668 <Check_for_DOS_FAT+0xc>
81137664:	003b68fa 	trap	3
81137668:	dfc00615 	stw	ra,24(sp)
8113766c:	df000515 	stw	fp,20(sp)
81137670:	df000504 	addi	fp,sp,20
81137674:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81137678:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8113767c:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81137680:	e17fff17 	ldw	r5,-4(fp)
81137684:	0009883a 	mov	r4,zero
81137688:	1136d140 	call	81136d14 <Read_Sector_Data>
8113768c:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81137690:	d0a0a317 	ldw	r2,-32116(gp)
81137694:	10800a17 	ldw	r2,40(r2)
81137698:	10807f84 	addi	r2,r2,510
8113769c:	1080002b 	ldhuio	r2,0(r2)
811376a0:	10bfffcc 	andi	r2,r2,65535
811376a4:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
811376a8:	e0bffe0f 	ldh	r2,-8(fp)
811376ac:	10ffffcc 	andi	r3,r2,65535
811376b0:	00aa9554 	movui	r2,43605
811376b4:	1881841e 	bne	r3,r2,81137cc8 <Check_for_DOS_FAT+0x66c>
811376b8:	e0bffb17 	ldw	r2,-20(fp)
811376bc:	10018226 	beq	r2,zero,81137cc8 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
811376c0:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
811376c4:	d0a0a317 	ldw	r2,-32116(gp)
811376c8:	10800a17 	ldw	r2,40(r2)
811376cc:	10800023 	ldbuio	r2,0(r2)
811376d0:	10803fcc 	andi	r2,r2,255
811376d4:	1007883a 	mov	r3,r2
811376d8:	00a045b4 	movhi	r2,33046
811376dc:	10bfe004 	addi	r2,r2,-128
811376e0:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
811376e4:	d0a0a317 	ldw	r2,-32116(gp)
811376e8:	10800a17 	ldw	r2,40(r2)
811376ec:	10800044 	addi	r2,r2,1
811376f0:	10800023 	ldbuio	r2,0(r2)
811376f4:	10803fcc 	andi	r2,r2,255
811376f8:	1007883a 	mov	r3,r2
811376fc:	00a045b4 	movhi	r2,33046
81137700:	10bfe004 	addi	r2,r2,-128
81137704:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
81137708:	d0a0a317 	ldw	r2,-32116(gp)
8113770c:	10800a17 	ldw	r2,40(r2)
81137710:	10800084 	addi	r2,r2,2
81137714:	10800023 	ldbuio	r2,0(r2)
81137718:	10803fcc 	andi	r2,r2,255
8113771c:	1007883a 	mov	r3,r2
81137720:	00a045b4 	movhi	r2,33046
81137724:	10bfe004 	addi	r2,r2,-128
81137728:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
8113772c:	e03ffc15 	stw	zero,-16(fp)
81137730:	00001106 	br	81137778 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81137734:	d0a0a317 	ldw	r2,-32116(gp)
81137738:	10c00a17 	ldw	r3,40(r2)
8113773c:	e0bffc17 	ldw	r2,-16(fp)
81137740:	1885883a 	add	r2,r3,r2
81137744:	108000c4 	addi	r2,r2,3
81137748:	10800023 	ldbuio	r2,0(r2)
8113774c:	10803fcc 	andi	r2,r2,255
81137750:	1009883a 	mov	r4,r2
81137754:	00a045b4 	movhi	r2,33046
81137758:	10bfe004 	addi	r2,r2,-128
8113775c:	e0fffc17 	ldw	r3,-16(fp)
81137760:	10c5883a 	add	r2,r2,r3
81137764:	108000c4 	addi	r2,r2,3
81137768:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
8113776c:	e0bffc17 	ldw	r2,-16(fp)
81137770:	10800044 	addi	r2,r2,1
81137774:	e0bffc15 	stw	r2,-16(fp)
81137778:	e0bffc17 	ldw	r2,-16(fp)
8113777c:	10800210 	cmplti	r2,r2,8
81137780:	103fec1e 	bne	r2,zero,81137734 <__reset+0xfb117734>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81137784:	d0a0a317 	ldw	r2,-32116(gp)
81137788:	10800a17 	ldw	r2,40(r2)
8113778c:	10800304 	addi	r2,r2,12
81137790:	10800023 	ldbuio	r2,0(r2)
81137794:	10803fcc 	andi	r2,r2,255
81137798:	1004923a 	slli	r2,r2,8
8113779c:	1007883a 	mov	r3,r2
811377a0:	d0a0a317 	ldw	r2,-32116(gp)
811377a4:	10800a17 	ldw	r2,40(r2)
811377a8:	108002c4 	addi	r2,r2,11
811377ac:	10800023 	ldbuio	r2,0(r2)
811377b0:	10803fcc 	andi	r2,r2,255
811377b4:	10803fcc 	andi	r2,r2,255
811377b8:	1080201c 	xori	r2,r2,128
811377bc:	10bfe004 	addi	r2,r2,-128
811377c0:	1884b03a 	or	r2,r3,r2
811377c4:	1007883a 	mov	r3,r2
811377c8:	00a045b4 	movhi	r2,33046
811377cc:	10bfe004 	addi	r2,r2,-128
811377d0:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
811377d4:	d0a0a317 	ldw	r2,-32116(gp)
811377d8:	10800a17 	ldw	r2,40(r2)
811377dc:	10800344 	addi	r2,r2,13
811377e0:	10800023 	ldbuio	r2,0(r2)
811377e4:	10803fcc 	andi	r2,r2,255
811377e8:	1007883a 	mov	r3,r2
811377ec:	00a045b4 	movhi	r2,33046
811377f0:	10bfe004 	addi	r2,r2,-128
811377f4:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
811377f8:	d0a0a317 	ldw	r2,-32116(gp)
811377fc:	10800a17 	ldw	r2,40(r2)
81137800:	10800384 	addi	r2,r2,14
81137804:	1080002b 	ldhuio	r2,0(r2)
81137808:	10bfffcc 	andi	r2,r2,65535
8113780c:	1007883a 	mov	r3,r2
81137810:	00a045b4 	movhi	r2,33046
81137814:	10bfe004 	addi	r2,r2,-128
81137818:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
8113781c:	d0a0a317 	ldw	r2,-32116(gp)
81137820:	10800a17 	ldw	r2,40(r2)
81137824:	10800404 	addi	r2,r2,16
81137828:	10800023 	ldbuio	r2,0(r2)
8113782c:	10803fcc 	andi	r2,r2,255
81137830:	1007883a 	mov	r3,r2
81137834:	00a045b4 	movhi	r2,33046
81137838:	10bfe004 	addi	r2,r2,-128
8113783c:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
81137840:	d0a0a317 	ldw	r2,-32116(gp)
81137844:	10800a17 	ldw	r2,40(r2)
81137848:	10800484 	addi	r2,r2,18
8113784c:	10800023 	ldbuio	r2,0(r2)
81137850:	10803fcc 	andi	r2,r2,255
81137854:	1004923a 	slli	r2,r2,8
81137858:	1007883a 	mov	r3,r2
8113785c:	d0a0a317 	ldw	r2,-32116(gp)
81137860:	10800a17 	ldw	r2,40(r2)
81137864:	10800444 	addi	r2,r2,17
81137868:	10800023 	ldbuio	r2,0(r2)
8113786c:	10803fcc 	andi	r2,r2,255
81137870:	10803fcc 	andi	r2,r2,255
81137874:	1884b03a 	or	r2,r3,r2
81137878:	1007883a 	mov	r3,r2
8113787c:	00a045b4 	movhi	r2,33046
81137880:	10bfe004 	addi	r2,r2,-128
81137884:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
81137888:	d0a0a317 	ldw	r2,-32116(gp)
8113788c:	10800a17 	ldw	r2,40(r2)
81137890:	10800504 	addi	r2,r2,20
81137894:	10800023 	ldbuio	r2,0(r2)
81137898:	10803fcc 	andi	r2,r2,255
8113789c:	1004923a 	slli	r2,r2,8
811378a0:	1007883a 	mov	r3,r2
811378a4:	d0a0a317 	ldw	r2,-32116(gp)
811378a8:	10800a17 	ldw	r2,40(r2)
811378ac:	108004c4 	addi	r2,r2,19
811378b0:	10800023 	ldbuio	r2,0(r2)
811378b4:	10803fcc 	andi	r2,r2,255
811378b8:	10803fcc 	andi	r2,r2,255
811378bc:	1884b03a 	or	r2,r3,r2
811378c0:	1007883a 	mov	r3,r2
811378c4:	00a045b4 	movhi	r2,33046
811378c8:	10bfe004 	addi	r2,r2,-128
811378cc:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
811378d0:	d0a0a317 	ldw	r2,-32116(gp)
811378d4:	10800a17 	ldw	r2,40(r2)
811378d8:	10800544 	addi	r2,r2,21
811378dc:	10800023 	ldbuio	r2,0(r2)
811378e0:	10803fcc 	andi	r2,r2,255
811378e4:	1007883a 	mov	r3,r2
811378e8:	00a045b4 	movhi	r2,33046
811378ec:	10bfe004 	addi	r2,r2,-128
811378f0:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
811378f4:	d0a0a317 	ldw	r2,-32116(gp)
811378f8:	10800a17 	ldw	r2,40(r2)
811378fc:	10800584 	addi	r2,r2,22
81137900:	1080002b 	ldhuio	r2,0(r2)
81137904:	10bfffcc 	andi	r2,r2,65535
81137908:	1007883a 	mov	r3,r2
8113790c:	00a045b4 	movhi	r2,33046
81137910:	10bfe004 	addi	r2,r2,-128
81137914:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
81137918:	d0a0a317 	ldw	r2,-32116(gp)
8113791c:	10800a17 	ldw	r2,40(r2)
81137920:	10800604 	addi	r2,r2,24
81137924:	1080002b 	ldhuio	r2,0(r2)
81137928:	10bfffcc 	andi	r2,r2,65535
8113792c:	1007883a 	mov	r3,r2
81137930:	00a045b4 	movhi	r2,33046
81137934:	10bfe004 	addi	r2,r2,-128
81137938:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
8113793c:	d0a0a317 	ldw	r2,-32116(gp)
81137940:	10800a17 	ldw	r2,40(r2)
81137944:	10800684 	addi	r2,r2,26
81137948:	1080002b 	ldhuio	r2,0(r2)
8113794c:	10bfffcc 	andi	r2,r2,65535
81137950:	1007883a 	mov	r3,r2
81137954:	00a045b4 	movhi	r2,33046
81137958:	10bfe004 	addi	r2,r2,-128
8113795c:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81137960:	d0a0a317 	ldw	r2,-32116(gp)
81137964:	10800a17 	ldw	r2,40(r2)
81137968:	10800704 	addi	r2,r2,28
8113796c:	10800037 	ldwio	r2,0(r2)
81137970:	1007883a 	mov	r3,r2
81137974:	00a045b4 	movhi	r2,33046
81137978:	10bfe004 	addi	r2,r2,-128
8113797c:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
81137980:	d0a0a317 	ldw	r2,-32116(gp)
81137984:	10800a17 	ldw	r2,40(r2)
81137988:	10800804 	addi	r2,r2,32
8113798c:	10800037 	ldwio	r2,0(r2)
81137990:	1007883a 	mov	r3,r2
81137994:	00a045b4 	movhi	r2,33046
81137998:	10bfe004 	addi	r2,r2,-128
8113799c:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
811379a0:	d0a0a317 	ldw	r2,-32116(gp)
811379a4:	10800a17 	ldw	r2,40(r2)
811379a8:	10800904 	addi	r2,r2,36
811379ac:	10800023 	ldbuio	r2,0(r2)
811379b0:	10803fcc 	andi	r2,r2,255
811379b4:	1007883a 	mov	r3,r2
811379b8:	00a045b4 	movhi	r2,33046
811379bc:	10bfe004 	addi	r2,r2,-128
811379c0:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
811379c4:	d0a0a317 	ldw	r2,-32116(gp)
811379c8:	10800a17 	ldw	r2,40(r2)
811379cc:	10800944 	addi	r2,r2,37
811379d0:	10800023 	ldbuio	r2,0(r2)
811379d4:	10803fcc 	andi	r2,r2,255
811379d8:	1007883a 	mov	r3,r2
811379dc:	00a045b4 	movhi	r2,33046
811379e0:	10bfe004 	addi	r2,r2,-128
811379e4:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
811379e8:	d0a0a317 	ldw	r2,-32116(gp)
811379ec:	10800a17 	ldw	r2,40(r2)
811379f0:	10800984 	addi	r2,r2,38
811379f4:	10800023 	ldbuio	r2,0(r2)
811379f8:	10803fcc 	andi	r2,r2,255
811379fc:	1007883a 	mov	r3,r2
81137a00:	00a045b4 	movhi	r2,33046
81137a04:	10bfe004 	addi	r2,r2,-128
81137a08:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81137a0c:	00a045b4 	movhi	r2,33046
81137a10:	10bfe004 	addi	r2,r2,-128
81137a14:	1080040b 	ldhu	r2,16(r2)
81137a18:	10ffffcc 	andi	r3,r2,65535
81137a1c:	00a045b4 	movhi	r2,33046
81137a20:	10bfe004 	addi	r2,r2,-128
81137a24:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
81137a28:	00a045b4 	movhi	r2,33046
81137a2c:	10bfe004 	addi	r2,r2,-128
81137a30:	10c01117 	ldw	r3,68(r2)
81137a34:	00a045b4 	movhi	r2,33046
81137a38:	10bfe004 	addi	r2,r2,-128
81137a3c:	1080068b 	ldhu	r2,26(r2)
81137a40:	10bfffcc 	andi	r2,r2,65535
81137a44:	1887883a 	add	r3,r3,r2
81137a48:	00a045b4 	movhi	r2,33046
81137a4c:	10bfe004 	addi	r2,r2,-128
81137a50:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
81137a54:	00a045b4 	movhi	r2,33046
81137a58:	10bfe004 	addi	r2,r2,-128
81137a5c:	10c01217 	ldw	r3,72(r2)
81137a60:	00a045b4 	movhi	r2,33046
81137a64:	10bfe004 	addi	r2,r2,-128
81137a68:	1080068b 	ldhu	r2,26(r2)
81137a6c:	10bfffcc 	andi	r2,r2,65535
81137a70:	1887883a 	add	r3,r3,r2
81137a74:	00a045b4 	movhi	r2,33046
81137a78:	10bfe004 	addi	r2,r2,-128
81137a7c:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
81137a80:	00a045b4 	movhi	r2,33046
81137a84:	10bfe004 	addi	r2,r2,-128
81137a88:	10c01317 	ldw	r3,76(r2)
81137a8c:	00a045b4 	movhi	r2,33046
81137a90:	10bfe004 	addi	r2,r2,-128
81137a94:	1080050b 	ldhu	r2,20(r2)
81137a98:	10bfffcc 	andi	r2,r2,65535
81137a9c:	1008917a 	slli	r4,r2,5
81137aa0:	00a045b4 	movhi	r2,33046
81137aa4:	10bfe004 	addi	r2,r2,-128
81137aa8:	1080030b 	ldhu	r2,12(r2)
81137aac:	10bfffcc 	andi	r2,r2,65535
81137ab0:	2085283a 	div	r2,r4,r2
81137ab4:	1887883a 	add	r3,r3,r2
81137ab8:	00a045b4 	movhi	r2,33046
81137abc:	10bfe004 	addi	r2,r2,-128
81137ac0:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
81137ac4:	00a045b4 	movhi	r2,33046
81137ac8:	10bfe004 	addi	r2,r2,-128
81137acc:	1080058b 	ldhu	r2,22(r2)
81137ad0:	10bfffcc 	andi	r2,r2,65535
81137ad4:	10000b26 	beq	r2,zero,81137b04 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
81137ad8:	00a045b4 	movhi	r2,33046
81137adc:	10bfe004 	addi	r2,r2,-128
81137ae0:	1080058b 	ldhu	r2,22(r2)
81137ae4:	10ffffcc 	andi	r3,r2,65535
81137ae8:	00a045b4 	movhi	r2,33046
81137aec:	10bfe004 	addi	r2,r2,-128
81137af0:	10800383 	ldbu	r2,14(r2)
81137af4:	10803fcc 	andi	r2,r2,255
81137af8:	1885283a 	div	r2,r3,r2
81137afc:	e0bffd15 	stw	r2,-12(fp)
81137b00:	00000906 	br	81137b28 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
81137b04:	00a045b4 	movhi	r2,33046
81137b08:	10bfe004 	addi	r2,r2,-128
81137b0c:	10c00917 	ldw	r3,36(r2)
81137b10:	00a045b4 	movhi	r2,33046
81137b14:	10bfe004 	addi	r2,r2,-128
81137b18:	10800383 	ldbu	r2,14(r2)
81137b1c:	10803fcc 	andi	r2,r2,255
81137b20:	1885203a 	divu	r2,r3,r2
81137b24:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
81137b28:	e0bffd17 	ldw	r2,-12(fp)
81137b2c:	1083fdc8 	cmpgei	r2,r2,4087
81137b30:	1000051e 	bne	r2,zero,81137b48 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
81137b34:	00a045b4 	movhi	r2,33046
81137b38:	10bfe004 	addi	r2,r2,-128
81137b3c:	00c00304 	movi	r3,12
81137b40:	10c01085 	stb	r3,66(r2)
81137b44:	00000c06 	br	81137b78 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
81137b48:	e0bffd17 	ldw	r2,-12(fp)
81137b4c:	00fffb54 	movui	r3,65517
81137b50:	18800516 	blt	r3,r2,81137b68 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
81137b54:	00a045b4 	movhi	r2,33046
81137b58:	10bfe004 	addi	r2,r2,-128
81137b5c:	00c00404 	movi	r3,16
81137b60:	10c01085 	stb	r3,66(r2)
81137b64:	00000406 	br	81137b78 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
81137b68:	00a045b4 	movhi	r2,33046
81137b6c:	10bfe004 	addi	r2,r2,-128
81137b70:	00c00804 	movi	r3,32
81137b74:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
81137b78:	e03ffc15 	stw	zero,-16(fp)
81137b7c:	00001106 	br	81137bc4 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
81137b80:	d0a0a317 	ldw	r2,-32116(gp)
81137b84:	10c00a17 	ldw	r3,40(r2)
81137b88:	e0bffc17 	ldw	r2,-16(fp)
81137b8c:	1885883a 	add	r2,r3,r2
81137b90:	108009c4 	addi	r2,r2,39
81137b94:	10800023 	ldbuio	r2,0(r2)
81137b98:	10803fcc 	andi	r2,r2,255
81137b9c:	1009883a 	mov	r4,r2
81137ba0:	00a045b4 	movhi	r2,33046
81137ba4:	10bfe004 	addi	r2,r2,-128
81137ba8:	e0fffc17 	ldw	r3,-16(fp)
81137bac:	10c5883a 	add	r2,r2,r3
81137bb0:	10800ac4 	addi	r2,r2,43
81137bb4:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
81137bb8:	e0bffc17 	ldw	r2,-16(fp)
81137bbc:	10800044 	addi	r2,r2,1
81137bc0:	e0bffc15 	stw	r2,-16(fp)
81137bc4:	e0bffc17 	ldw	r2,-16(fp)
81137bc8:	10800110 	cmplti	r2,r2,4
81137bcc:	103fec1e 	bne	r2,zero,81137b80 <__reset+0xfb117b80>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81137bd0:	e03ffc15 	stw	zero,-16(fp)
81137bd4:	00001106 	br	81137c1c <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81137bd8:	d0a0a317 	ldw	r2,-32116(gp)
81137bdc:	10c00a17 	ldw	r3,40(r2)
81137be0:	e0bffc17 	ldw	r2,-16(fp)
81137be4:	1885883a 	add	r2,r3,r2
81137be8:	10800ac4 	addi	r2,r2,43
81137bec:	10800023 	ldbuio	r2,0(r2)
81137bf0:	10803fcc 	andi	r2,r2,255
81137bf4:	1009883a 	mov	r4,r2
81137bf8:	00a045b4 	movhi	r2,33046
81137bfc:	10bfe004 	addi	r2,r2,-128
81137c00:	e0fffc17 	ldw	r3,-16(fp)
81137c04:	10c5883a 	add	r2,r2,r3
81137c08:	10800bc4 	addi	r2,r2,47
81137c0c:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81137c10:	e0bffc17 	ldw	r2,-16(fp)
81137c14:	10800044 	addi	r2,r2,1
81137c18:	e0bffc15 	stw	r2,-16(fp)
81137c1c:	e0bffc17 	ldw	r2,-16(fp)
81137c20:	108002d0 	cmplti	r2,r2,11
81137c24:	103fec1e 	bne	r2,zero,81137bd8 <__reset+0xfb117bd8>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81137c28:	e03ffc15 	stw	zero,-16(fp)
81137c2c:	00001106 	br	81137c74 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
81137c30:	d0a0a317 	ldw	r2,-32116(gp)
81137c34:	10c00a17 	ldw	r3,40(r2)
81137c38:	e0bffc17 	ldw	r2,-16(fp)
81137c3c:	1885883a 	add	r2,r3,r2
81137c40:	10800d84 	addi	r2,r2,54
81137c44:	10800023 	ldbuio	r2,0(r2)
81137c48:	10803fcc 	andi	r2,r2,255
81137c4c:	1009883a 	mov	r4,r2
81137c50:	00a045b4 	movhi	r2,33046
81137c54:	10bfe004 	addi	r2,r2,-128
81137c58:	e0fffc17 	ldw	r3,-16(fp)
81137c5c:	10c5883a 	add	r2,r2,r3
81137c60:	10800e84 	addi	r2,r2,58
81137c64:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81137c68:	e0bffc17 	ldw	r2,-16(fp)
81137c6c:	10800044 	addi	r2,r2,1
81137c70:	e0bffc15 	stw	r2,-16(fp)
81137c74:	e0bffc17 	ldw	r2,-16(fp)
81137c78:	10800210 	cmplti	r2,r2,8
81137c7c:	103fec1e 	bne	r2,zero,81137c30 <__reset+0xfb117c30>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81137c80:	e03ffc15 	stw	zero,-16(fp)
81137c84:	00000a06 	br	81137cb0 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
81137c88:	00a045b4 	movhi	r2,33046
81137c8c:	10bff504 	addi	r2,r2,-44
81137c90:	e0fffc17 	ldw	r3,-16(fp)
81137c94:	180691ba 	slli	r3,r3,6
81137c98:	10c5883a 	add	r2,r2,r3
81137c9c:	10800f04 	addi	r2,r2,60
81137ca0:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81137ca4:	e0bffc17 	ldw	r2,-16(fp)
81137ca8:	10800044 	addi	r2,r2,1
81137cac:	e0bffc15 	stw	r2,-16(fp)
81137cb0:	e0bffc17 	ldw	r2,-16(fp)
81137cb4:	10800510 	cmplti	r2,r2,20
81137cb8:	103ff31e 	bne	r2,zero,81137c88 <__reset+0xfb117c88>
		{
			active_files[counter].in_use = false;
		}
		result = true;
81137cbc:	00800044 	movi	r2,1
81137cc0:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
81137cc4:	00000106 	br	81137ccc <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
81137cc8:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
81137ccc:	e0bffb17 	ldw	r2,-20(fp)
}
81137cd0:	e037883a 	mov	sp,fp
81137cd4:	dfc00117 	ldw	ra,4(sp)
81137cd8:	df000017 	ldw	fp,0(sp)
81137cdc:	dec00204 	addi	sp,sp,8
81137ce0:	f800283a 	ret

81137ce4 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
81137ce4:	defffc04 	addi	sp,sp,-16
81137ce8:	de00012e 	bgeu	sp,et,81137cf0 <Look_for_FAT16+0xc>
81137cec:	003b68fa 	trap	3
81137cf0:	dfc00315 	stw	ra,12(sp)
81137cf4:	df000215 	stw	fp,8(sp)
81137cf8:	df000204 	addi	fp,sp,8
	bool result = false;
81137cfc:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
81137d00:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
81137d04:	10002e26 	beq	r2,zero,81137dc0 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
81137d08:	d0a09d17 	ldw	r2,-32140(gp)
81137d0c:	1080000b 	ldhu	r2,0(r2)
81137d10:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
81137d14:	d020a115 	stw	zero,-32124(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
81137d18:	d020a215 	stw	zero,-32120(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
81137d1c:	e0bfff0f 	ldh	r2,-4(fp)
81137d20:	10002716 	blt	r2,zero,81137dc0 <Look_for_FAT16+0xdc>
81137d24:	e0bfff0b 	ldhu	r2,-4(fp)
81137d28:	10bfffcc 	andi	r2,r2,65535
81137d2c:	1083000c 	andi	r2,r2,3072
81137d30:	10830020 	cmpeqi	r2,r2,3072
81137d34:	1000221e 	bne	r2,zero,81137dc0 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
81137d38:	e0bfff0b 	ldhu	r2,-4(fp)
81137d3c:	10bfffcc 	andi	r2,r2,65535
81137d40:	1083000c 	andi	r2,r2,3072
81137d44:	10810018 	cmpnei	r2,r2,1024
81137d48:	1000031e 	bne	r2,zero,81137d58 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
81137d4c:	0009883a 	mov	r4,zero
81137d50:	113765c0 	call	8113765c <Check_for_DOS_FAT>
81137d54:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
81137d58:	e0bfff0b 	ldhu	r2,-4(fp)
81137d5c:	10bfffcc 	andi	r2,r2,65535
81137d60:	1083000c 	andi	r2,r2,3072
81137d64:	1000061e 	bne	r2,zero,81137d80 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
81137d68:	1136f980 	call	81136f98 <Check_for_Master_Boot_Record>
81137d6c:	10000426 	beq	r2,zero,81137d80 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
81137d70:	d0a0a117 	ldw	r2,-32124(gp)
81137d74:	1009883a 	mov	r4,r2
81137d78:	113765c0 	call	8113765c <Check_for_DOS_FAT>
81137d7c:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
81137d80:	e0bffe17 	ldw	r2,-8(fp)
81137d84:	10800058 	cmpnei	r2,r2,1
81137d88:	10000d1e 	bne	r2,zero,81137dc0 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
81137d8c:	00a045b4 	movhi	r2,33046
81137d90:	10bfe004 	addi	r2,r2,-128
81137d94:	10801083 	ldbu	r2,66(r2)
81137d98:	10803fcc 	andi	r2,r2,255
81137d9c:	10800420 	cmpeqi	r2,r2,16
81137da0:	1000021e 	bne	r2,zero,81137dac <Look_for_FAT16+0xc8>
				{
					result = false;
81137da4:	e03ffe15 	stw	zero,-8(fp)
81137da8:	00000506 	br	81137dc0 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
81137dac:	00a045b4 	movhi	r2,33046
81137db0:	10bfe004 	addi	r2,r2,-128
81137db4:	1080058b 	ldhu	r2,22(r2)
81137db8:	10bfffcc 	andi	r2,r2,65535
81137dbc:	d0a0a215 	stw	r2,-32120(gp)
				}
			}
		}
	}
	return result;
81137dc0:	e0bffe17 	ldw	r2,-8(fp)
}
81137dc4:	e037883a 	mov	sp,fp
81137dc8:	dfc00117 	ldw	ra,4(sp)
81137dcc:	df000017 	ldw	fp,0(sp)
81137dd0:	dec00204 	addi	sp,sp,8
81137dd4:	f800283a 	ret

81137dd8 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
81137dd8:	defffb04 	addi	sp,sp,-20
81137ddc:	de00012e 	bgeu	sp,et,81137de4 <filename_to_upper_case+0xc>
81137de0:	003b68fa 	trap	3
81137de4:	dfc00415 	stw	ra,16(sp)
81137de8:	df000315 	stw	fp,12(sp)
81137dec:	df000304 	addi	fp,sp,12
81137df0:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
81137df4:	e13fff17 	ldw	r4,-4(fp)
81137df8:	11172280 	call	81117228 <strlen>
81137dfc:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
81137e00:	e03ffd15 	stw	zero,-12(fp)
81137e04:	00001e06 	br	81137e80 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
81137e08:	e0bffd17 	ldw	r2,-12(fp)
81137e0c:	e0ffff17 	ldw	r3,-4(fp)
81137e10:	1885883a 	add	r2,r3,r2
81137e14:	10800003 	ldbu	r2,0(r2)
81137e18:	10803fcc 	andi	r2,r2,255
81137e1c:	1080201c 	xori	r2,r2,128
81137e20:	10bfe004 	addi	r2,r2,-128
81137e24:	10801850 	cmplti	r2,r2,97
81137e28:	1000121e 	bne	r2,zero,81137e74 <filename_to_upper_case+0x9c>
81137e2c:	e0bffd17 	ldw	r2,-12(fp)
81137e30:	e0ffff17 	ldw	r3,-4(fp)
81137e34:	1885883a 	add	r2,r3,r2
81137e38:	10800003 	ldbu	r2,0(r2)
81137e3c:	10803fcc 	andi	r2,r2,255
81137e40:	1080201c 	xori	r2,r2,128
81137e44:	10bfe004 	addi	r2,r2,-128
81137e48:	10801ec8 	cmpgei	r2,r2,123
81137e4c:	1000091e 	bne	r2,zero,81137e74 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
81137e50:	e0bffd17 	ldw	r2,-12(fp)
81137e54:	e0ffff17 	ldw	r3,-4(fp)
81137e58:	1885883a 	add	r2,r3,r2
81137e5c:	e0fffd17 	ldw	r3,-12(fp)
81137e60:	e13fff17 	ldw	r4,-4(fp)
81137e64:	20c7883a 	add	r3,r4,r3
81137e68:	18c00003 	ldbu	r3,0(r3)
81137e6c:	18fff804 	addi	r3,r3,-32
81137e70:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
81137e74:	e0bffd17 	ldw	r2,-12(fp)
81137e78:	10800044 	addi	r2,r2,1
81137e7c:	e0bffd15 	stw	r2,-12(fp)
81137e80:	e0fffd17 	ldw	r3,-12(fp)
81137e84:	e0bffe17 	ldw	r2,-8(fp)
81137e88:	18bfdf16 	blt	r3,r2,81137e08 <__reset+0xfb117e08>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
81137e8c:	0001883a 	nop
81137e90:	e037883a 	mov	sp,fp
81137e94:	dfc00117 	ldw	ra,4(sp)
81137e98:	df000017 	ldw	fp,0(sp)
81137e9c:	dec00204 	addi	sp,sp,8
81137ea0:	f800283a 	ret

81137ea4 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
81137ea4:	defff804 	addi	sp,sp,-32
81137ea8:	de00012e 	bgeu	sp,et,81137eb0 <check_file_name_for_FAT16_compliance+0xc>
81137eac:	003b68fa 	trap	3
81137eb0:	dfc00715 	stw	ra,28(sp)
81137eb4:	df000615 	stw	fp,24(sp)
81137eb8:	df000604 	addi	fp,sp,24
81137ebc:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
81137ec0:	e13fff17 	ldw	r4,-4(fp)
81137ec4:	11172280 	call	81117228 <strlen>
81137ec8:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
81137ecc:	00bfffc4 	movi	r2,-1
81137ed0:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
81137ed4:	00bfffc4 	movi	r2,-1
81137ed8:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
81137edc:	00800044 	movi	r2,1
81137ee0:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
81137ee4:	e03ffa15 	stw	zero,-24(fp)
81137ee8:	00006d06 	br	811380a0 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
81137eec:	e0bffa17 	ldw	r2,-24(fp)
81137ef0:	e0ffff17 	ldw	r3,-4(fp)
81137ef4:	1885883a 	add	r2,r3,r2
81137ef8:	10800003 	ldbu	r2,0(r2)
81137efc:	10803fcc 	andi	r2,r2,255
81137f00:	1080201c 	xori	r2,r2,128
81137f04:	10bfe004 	addi	r2,r2,-128
81137f08:	10800820 	cmpeqi	r2,r2,32
81137f0c:	10003e1e 	bne	r2,zero,81138008 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81137f10:	e0bffa17 	ldw	r2,-24(fp)
81137f14:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
81137f18:	e0bffb17 	ldw	r2,-20(fp)
81137f1c:	1880121e 	bne	r3,r2,81137f68 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81137f20:	e0bffa17 	ldw	r2,-24(fp)
81137f24:	e0ffff17 	ldw	r3,-4(fp)
81137f28:	1885883a 	add	r2,r3,r2
81137f2c:	10800003 	ldbu	r2,0(r2)
81137f30:	10803fcc 	andi	r2,r2,255
81137f34:	1080201c 	xori	r2,r2,128
81137f38:	10bfe004 	addi	r2,r2,-128
81137f3c:	10801720 	cmpeqi	r2,r2,92
81137f40:	1000311e 	bne	r2,zero,81138008 <check_file_name_for_FAT16_compliance+0x164>
81137f44:	e0bffa17 	ldw	r2,-24(fp)
81137f48:	e0ffff17 	ldw	r3,-4(fp)
81137f4c:	1885883a 	add	r2,r3,r2
81137f50:	10800003 	ldbu	r2,0(r2)
81137f54:	10803fcc 	andi	r2,r2,255
81137f58:	1080201c 	xori	r2,r2,128
81137f5c:	10bfe004 	addi	r2,r2,-128
81137f60:	10800be0 	cmpeqi	r2,r2,47
81137f64:	1000281e 	bne	r2,zero,81138008 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81137f68:	e0fffa17 	ldw	r3,-24(fp)
81137f6c:	e0bffc17 	ldw	r2,-16(fp)
81137f70:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81137f74:	10800258 	cmpnei	r2,r2,9
81137f78:	1000091e 	bne	r2,zero,81137fa0 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81137f7c:	e0bffa17 	ldw	r2,-24(fp)
81137f80:	e0ffff17 	ldw	r3,-4(fp)
81137f84:	1885883a 	add	r2,r3,r2
81137f88:	10800003 	ldbu	r2,0(r2)
81137f8c:	10803fcc 	andi	r2,r2,255
81137f90:	1080201c 	xori	r2,r2,128
81137f94:	10bfe004 	addi	r2,r2,-128
81137f98:	10800b98 	cmpnei	r2,r2,46
81137f9c:	10001a1e 	bne	r2,zero,81138008 <check_file_name_for_FAT16_compliance+0x164>
81137fa0:	e0fffb17 	ldw	r3,-20(fp)
81137fa4:	e0bffc17 	ldw	r2,-16(fp)
81137fa8:	18801926 	beq	r3,r2,81138010 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81137fac:	e0fffa17 	ldw	r3,-24(fp)
81137fb0:	e0bffc17 	ldw	r2,-16(fp)
81137fb4:	1885c83a 	sub	r2,r3,r2
81137fb8:	10800110 	cmplti	r2,r2,4
81137fbc:	1000141e 	bne	r2,zero,81138010 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81137fc0:	e0bffa17 	ldw	r2,-24(fp)
81137fc4:	e0ffff17 	ldw	r3,-4(fp)
81137fc8:	1885883a 	add	r2,r3,r2
81137fcc:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81137fd0:	10803fcc 	andi	r2,r2,255
81137fd4:	1080201c 	xori	r2,r2,128
81137fd8:	10bfe004 	addi	r2,r2,-128
81137fdc:	10801720 	cmpeqi	r2,r2,92
81137fe0:	10000b1e 	bne	r2,zero,81138010 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81137fe4:	e0bffa17 	ldw	r2,-24(fp)
81137fe8:	e0ffff17 	ldw	r3,-4(fp)
81137fec:	1885883a 	add	r2,r3,r2
81137ff0:	10800003 	ldbu	r2,0(r2)
81137ff4:	10803fcc 	andi	r2,r2,255
81137ff8:	1080201c 	xori	r2,r2,128
81137ffc:	10bfe004 	addi	r2,r2,-128
81138000:	10800be0 	cmpeqi	r2,r2,47
81138004:	1000021e 	bne	r2,zero,81138010 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
81138008:	e03ffd15 	stw	zero,-12(fp)
            break;
8113800c:	00002706 	br	811380ac <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
81138010:	e0bffa17 	ldw	r2,-24(fp)
81138014:	e0ffff17 	ldw	r3,-4(fp)
81138018:	1885883a 	add	r2,r3,r2
8113801c:	10800003 	ldbu	r2,0(r2)
81138020:	10803fcc 	andi	r2,r2,255
81138024:	1080201c 	xori	r2,r2,128
81138028:	10bfe004 	addi	r2,r2,-128
8113802c:	10801720 	cmpeqi	r2,r2,92
81138030:	1000091e 	bne	r2,zero,81138058 <check_file_name_for_FAT16_compliance+0x1b4>
81138034:	e0bffa17 	ldw	r2,-24(fp)
81138038:	e0ffff17 	ldw	r3,-4(fp)
8113803c:	1885883a 	add	r2,r3,r2
81138040:	10800003 	ldbu	r2,0(r2)
81138044:	10803fcc 	andi	r2,r2,255
81138048:	1080201c 	xori	r2,r2,128
8113804c:	10bfe004 	addi	r2,r2,-128
81138050:	10800bd8 	cmpnei	r2,r2,47
81138054:	1000041e 	bne	r2,zero,81138068 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
81138058:	e0bffa17 	ldw	r2,-24(fp)
8113805c:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
81138060:	e0bffa17 	ldw	r2,-24(fp)
81138064:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
81138068:	e0bffa17 	ldw	r2,-24(fp)
8113806c:	e0ffff17 	ldw	r3,-4(fp)
81138070:	1885883a 	add	r2,r3,r2
81138074:	10800003 	ldbu	r2,0(r2)
81138078:	10803fcc 	andi	r2,r2,255
8113807c:	1080201c 	xori	r2,r2,128
81138080:	10bfe004 	addi	r2,r2,-128
81138084:	10800b98 	cmpnei	r2,r2,46
81138088:	1000021e 	bne	r2,zero,81138094 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
8113808c:	e0bffa17 	ldw	r2,-24(fp)
81138090:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
81138094:	e0bffa17 	ldw	r2,-24(fp)
81138098:	10800044 	addi	r2,r2,1
8113809c:	e0bffa15 	stw	r2,-24(fp)
811380a0:	e0fffa17 	ldw	r3,-24(fp)
811380a4:	e0bffe17 	ldw	r2,-8(fp)
811380a8:	18bf9016 	blt	r3,r2,81137eec <__reset+0xfb117eec>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
811380ac:	e0bffe17 	ldw	r2,-8(fp)
811380b0:	10bfffc4 	addi	r2,r2,-1
811380b4:	e0ffff17 	ldw	r3,-4(fp)
811380b8:	1885883a 	add	r2,r3,r2
811380bc:	10800003 	ldbu	r2,0(r2)
811380c0:	10803fcc 	andi	r2,r2,255
811380c4:	1080201c 	xori	r2,r2,128
811380c8:	10bfe004 	addi	r2,r2,-128
811380cc:	10801720 	cmpeqi	r2,r2,92
811380d0:	10000a1e 	bne	r2,zero,811380fc <check_file_name_for_FAT16_compliance+0x258>
811380d4:	e0bffe17 	ldw	r2,-8(fp)
811380d8:	10bfffc4 	addi	r2,r2,-1
811380dc:	e0ffff17 	ldw	r3,-4(fp)
811380e0:	1885883a 	add	r2,r3,r2
811380e4:	10800003 	ldbu	r2,0(r2)
811380e8:	10803fcc 	andi	r2,r2,255
811380ec:	1080201c 	xori	r2,r2,128
811380f0:	10bfe004 	addi	r2,r2,-128
811380f4:	10800bd8 	cmpnei	r2,r2,47
811380f8:	1000011e 	bne	r2,zero,81138100 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
811380fc:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
81138100:	e0bffd17 	ldw	r2,-12(fp)
}
81138104:	e037883a 	mov	sp,fp
81138108:	dfc00117 	ldw	ra,4(sp)
8113810c:	df000017 	ldw	fp,0(sp)
81138110:	dec00204 	addi	sp,sp,8
81138114:	f800283a 	ret

81138118 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
81138118:	defffb04 	addi	sp,sp,-20
8113811c:	de00012e 	bgeu	sp,et,81138124 <get_dir_divider_location+0xc>
81138120:	003b68fa 	trap	3
81138124:	dfc00415 	stw	ra,16(sp)
81138128:	df000315 	stw	fp,12(sp)
8113812c:	df000304 	addi	fp,sp,12
81138130:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
81138134:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
81138138:	e13fff17 	ldw	r4,-4(fp)
8113813c:	11172280 	call	81117228 <strlen>
81138140:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
81138144:	e03ffd15 	stw	zero,-12(fp)
81138148:	00001506 	br	811381a0 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
8113814c:	e0bffd17 	ldw	r2,-12(fp)
81138150:	e0ffff17 	ldw	r3,-4(fp)
81138154:	1885883a 	add	r2,r3,r2
81138158:	10800003 	ldbu	r2,0(r2)
8113815c:	10803fcc 	andi	r2,r2,255
81138160:	1080201c 	xori	r2,r2,128
81138164:	10bfe004 	addi	r2,r2,-128
81138168:	10801720 	cmpeqi	r2,r2,92
8113816c:	10000f1e 	bne	r2,zero,811381ac <get_dir_divider_location+0x94>
81138170:	e0bffd17 	ldw	r2,-12(fp)
81138174:	e0ffff17 	ldw	r3,-4(fp)
81138178:	1885883a 	add	r2,r3,r2
8113817c:	10800003 	ldbu	r2,0(r2)
81138180:	10803fcc 	andi	r2,r2,255
81138184:	1080201c 	xori	r2,r2,128
81138188:	10bfe004 	addi	r2,r2,-128
8113818c:	10800be0 	cmpeqi	r2,r2,47
81138190:	1000061e 	bne	r2,zero,811381ac <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
81138194:	e0bffd17 	ldw	r2,-12(fp)
81138198:	10800044 	addi	r2,r2,1
8113819c:	e0bffd15 	stw	r2,-12(fp)
811381a0:	e0fffd17 	ldw	r3,-12(fp)
811381a4:	e0bffe17 	ldw	r2,-8(fp)
811381a8:	18bfe816 	blt	r3,r2,8113814c <__reset+0xfb11814c>
        {
            break;
        }
    }
    
    if (index == length)
811381ac:	e0fffd17 	ldw	r3,-12(fp)
811381b0:	e0bffe17 	ldw	r2,-8(fp)
811381b4:	1880021e 	bne	r3,r2,811381c0 <get_dir_divider_location+0xa8>
    {
        index = -1;
811381b8:	00bfffc4 	movi	r2,-1
811381bc:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
811381c0:	e0bffd17 	ldw	r2,-12(fp)
}
811381c4:	e037883a 	mov	sp,fp
811381c8:	dfc00117 	ldw	ra,4(sp)
811381cc:	df000017 	ldw	fp,0(sp)
811381d0:	dec00204 	addi	sp,sp,8
811381d4:	f800283a 	ret

811381d8 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
811381d8:	defffa04 	addi	sp,sp,-24
811381dc:	de00012e 	bgeu	sp,et,811381e4 <match_file_record_to_name_ext+0xc>
811381e0:	003b68fa 	trap	3
811381e4:	df000515 	stw	fp,20(sp)
811381e8:	df000504 	addi	fp,sp,20
811381ec:	e13ffd15 	stw	r4,-12(fp)
811381f0:	e17ffe15 	stw	r5,-8(fp)
811381f4:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
811381f8:	00800044 	movi	r2,1
811381fc:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
81138200:	e03ffc15 	stw	zero,-16(fp)
81138204:	00004606 	br	81138320 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
81138208:	e0fffd17 	ldw	r3,-12(fp)
8113820c:	e0bffc17 	ldw	r2,-16(fp)
81138210:	1885883a 	add	r2,r3,r2
81138214:	10800003 	ldbu	r2,0(r2)
81138218:	10803fcc 	andi	r2,r2,255
8113821c:	10801870 	cmpltui	r2,r2,97
81138220:	1000101e 	bne	r2,zero,81138264 <match_file_record_to_name_ext+0x8c>
81138224:	e0fffd17 	ldw	r3,-12(fp)
81138228:	e0bffc17 	ldw	r2,-16(fp)
8113822c:	1885883a 	add	r2,r3,r2
81138230:	10800003 	ldbu	r2,0(r2)
81138234:	10803fcc 	andi	r2,r2,255
81138238:	10801ee8 	cmpgeui	r2,r2,123
8113823c:	1000091e 	bne	r2,zero,81138264 <match_file_record_to_name_ext+0x8c>
81138240:	e0fffd17 	ldw	r3,-12(fp)
81138244:	e0bffc17 	ldw	r2,-16(fp)
81138248:	1885883a 	add	r2,r3,r2
8113824c:	10800003 	ldbu	r2,0(r2)
81138250:	10bff804 	addi	r2,r2,-32
81138254:	10c03fcc 	andi	r3,r2,255
81138258:	18c0201c 	xori	r3,r3,128
8113825c:	18ffe004 	addi	r3,r3,-128
81138260:	00000706 	br	81138280 <match_file_record_to_name_ext+0xa8>
81138264:	e0fffd17 	ldw	r3,-12(fp)
81138268:	e0bffc17 	ldw	r2,-16(fp)
8113826c:	1885883a 	add	r2,r3,r2
81138270:	10800003 	ldbu	r2,0(r2)
81138274:	10c03fcc 	andi	r3,r2,255
81138278:	18c0201c 	xori	r3,r3,128
8113827c:	18ffe004 	addi	r3,r3,-128
81138280:	e0bffc17 	ldw	r2,-16(fp)
81138284:	e13ffe17 	ldw	r4,-8(fp)
81138288:	2085883a 	add	r2,r4,r2
8113828c:	10800003 	ldbu	r2,0(r2)
81138290:	10803fcc 	andi	r2,r2,255
81138294:	1080201c 	xori	r2,r2,128
81138298:	10bfe004 	addi	r2,r2,-128
8113829c:	10801850 	cmplti	r2,r2,97
811382a0:	1000121e 	bne	r2,zero,811382ec <match_file_record_to_name_ext+0x114>
811382a4:	e0bffc17 	ldw	r2,-16(fp)
811382a8:	e13ffe17 	ldw	r4,-8(fp)
811382ac:	2085883a 	add	r2,r4,r2
811382b0:	10800003 	ldbu	r2,0(r2)
811382b4:	10803fcc 	andi	r2,r2,255
811382b8:	1080201c 	xori	r2,r2,128
811382bc:	10bfe004 	addi	r2,r2,-128
811382c0:	10801ec8 	cmpgei	r2,r2,123
811382c4:	1000091e 	bne	r2,zero,811382ec <match_file_record_to_name_ext+0x114>
811382c8:	e0bffc17 	ldw	r2,-16(fp)
811382cc:	e13ffe17 	ldw	r4,-8(fp)
811382d0:	2085883a 	add	r2,r4,r2
811382d4:	10800003 	ldbu	r2,0(r2)
811382d8:	10bff804 	addi	r2,r2,-32
811382dc:	10803fcc 	andi	r2,r2,255
811382e0:	1080201c 	xori	r2,r2,128
811382e4:	10bfe004 	addi	r2,r2,-128
811382e8:	00000706 	br	81138308 <match_file_record_to_name_ext+0x130>
811382ec:	e0bffc17 	ldw	r2,-16(fp)
811382f0:	e13ffe17 	ldw	r4,-8(fp)
811382f4:	2085883a 	add	r2,r4,r2
811382f8:	10800003 	ldbu	r2,0(r2)
811382fc:	10803fcc 	andi	r2,r2,255
81138300:	1080201c 	xori	r2,r2,128
81138304:	10bfe004 	addi	r2,r2,-128
81138308:	18800226 	beq	r3,r2,81138314 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
8113830c:	e03ffb15 	stw	zero,-20(fp)
			break;
81138310:	00000606 	br	8113832c <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
81138314:	e0bffc17 	ldw	r2,-16(fp)
81138318:	10800044 	addi	r2,r2,1
8113831c:	e0bffc15 	stw	r2,-16(fp)
81138320:	e0bffc17 	ldw	r2,-16(fp)
81138324:	10800210 	cmplti	r2,r2,8
81138328:	103fb71e 	bne	r2,zero,81138208 <__reset+0xfb118208>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113832c:	e03ffc15 	stw	zero,-16(fp)
81138330:	00004a06 	br	8113845c <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
81138334:	e0fffd17 	ldw	r3,-12(fp)
81138338:	e0bffc17 	ldw	r2,-16(fp)
8113833c:	1885883a 	add	r2,r3,r2
81138340:	10800204 	addi	r2,r2,8
81138344:	10800003 	ldbu	r2,0(r2)
81138348:	10803fcc 	andi	r2,r2,255
8113834c:	10801870 	cmpltui	r2,r2,97
81138350:	1000121e 	bne	r2,zero,8113839c <match_file_record_to_name_ext+0x1c4>
81138354:	e0fffd17 	ldw	r3,-12(fp)
81138358:	e0bffc17 	ldw	r2,-16(fp)
8113835c:	1885883a 	add	r2,r3,r2
81138360:	10800204 	addi	r2,r2,8
81138364:	10800003 	ldbu	r2,0(r2)
81138368:	10803fcc 	andi	r2,r2,255
8113836c:	10801ee8 	cmpgeui	r2,r2,123
81138370:	10000a1e 	bne	r2,zero,8113839c <match_file_record_to_name_ext+0x1c4>
81138374:	e0fffd17 	ldw	r3,-12(fp)
81138378:	e0bffc17 	ldw	r2,-16(fp)
8113837c:	1885883a 	add	r2,r3,r2
81138380:	10800204 	addi	r2,r2,8
81138384:	10800003 	ldbu	r2,0(r2)
81138388:	10bff804 	addi	r2,r2,-32
8113838c:	10c03fcc 	andi	r3,r2,255
81138390:	18c0201c 	xori	r3,r3,128
81138394:	18ffe004 	addi	r3,r3,-128
81138398:	00000806 	br	811383bc <match_file_record_to_name_ext+0x1e4>
8113839c:	e0fffd17 	ldw	r3,-12(fp)
811383a0:	e0bffc17 	ldw	r2,-16(fp)
811383a4:	1885883a 	add	r2,r3,r2
811383a8:	10800204 	addi	r2,r2,8
811383ac:	10800003 	ldbu	r2,0(r2)
811383b0:	10c03fcc 	andi	r3,r2,255
811383b4:	18c0201c 	xori	r3,r3,128
811383b8:	18ffe004 	addi	r3,r3,-128
811383bc:	e0bffc17 	ldw	r2,-16(fp)
811383c0:	e13fff17 	ldw	r4,-4(fp)
811383c4:	2085883a 	add	r2,r4,r2
811383c8:	10800003 	ldbu	r2,0(r2)
811383cc:	10803fcc 	andi	r2,r2,255
811383d0:	1080201c 	xori	r2,r2,128
811383d4:	10bfe004 	addi	r2,r2,-128
811383d8:	10801850 	cmplti	r2,r2,97
811383dc:	1000121e 	bne	r2,zero,81138428 <match_file_record_to_name_ext+0x250>
811383e0:	e0bffc17 	ldw	r2,-16(fp)
811383e4:	e13fff17 	ldw	r4,-4(fp)
811383e8:	2085883a 	add	r2,r4,r2
811383ec:	10800003 	ldbu	r2,0(r2)
811383f0:	10803fcc 	andi	r2,r2,255
811383f4:	1080201c 	xori	r2,r2,128
811383f8:	10bfe004 	addi	r2,r2,-128
811383fc:	10801ec8 	cmpgei	r2,r2,123
81138400:	1000091e 	bne	r2,zero,81138428 <match_file_record_to_name_ext+0x250>
81138404:	e0bffc17 	ldw	r2,-16(fp)
81138408:	e13fff17 	ldw	r4,-4(fp)
8113840c:	2085883a 	add	r2,r4,r2
81138410:	10800003 	ldbu	r2,0(r2)
81138414:	10bff804 	addi	r2,r2,-32
81138418:	10803fcc 	andi	r2,r2,255
8113841c:	1080201c 	xori	r2,r2,128
81138420:	10bfe004 	addi	r2,r2,-128
81138424:	00000706 	br	81138444 <match_file_record_to_name_ext+0x26c>
81138428:	e0bffc17 	ldw	r2,-16(fp)
8113842c:	e13fff17 	ldw	r4,-4(fp)
81138430:	2085883a 	add	r2,r4,r2
81138434:	10800003 	ldbu	r2,0(r2)
81138438:	10803fcc 	andi	r2,r2,255
8113843c:	1080201c 	xori	r2,r2,128
81138440:	10bfe004 	addi	r2,r2,-128
81138444:	18800226 	beq	r3,r2,81138450 <match_file_record_to_name_ext+0x278>
        {
            match = false;
81138448:	e03ffb15 	stw	zero,-20(fp)
			break;
8113844c:	00000606 	br	81138468 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81138450:	e0bffc17 	ldw	r2,-16(fp)
81138454:	10800044 	addi	r2,r2,1
81138458:	e0bffc15 	stw	r2,-16(fp)
8113845c:	e0bffc17 	ldw	r2,-16(fp)
81138460:	108000d0 	cmplti	r2,r2,3
81138464:	103fb31e 	bne	r2,zero,81138334 <__reset+0xfb118334>
        {
            match = false;
			break;
        }
    }
	return match;
81138468:	e0bffb17 	ldw	r2,-20(fp)
}
8113846c:	e037883a 	mov	sp,fp
81138470:	df000017 	ldw	fp,0(sp)
81138474:	dec00104 	addi	sp,sp,4
81138478:	f800283a 	ret

8113847c <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
8113847c:	deffe704 	addi	sp,sp,-100
81138480:	de00012e 	bgeu	sp,et,81138488 <get_home_directory_cluster_for_file+0xc>
81138484:	003b68fa 	trap	3
81138488:	dfc01815 	stw	ra,96(sp)
8113848c:	df001715 	stw	fp,92(sp)
81138490:	df001704 	addi	fp,sp,92
81138494:	e13ffd15 	stw	r4,-12(fp)
81138498:	e17ffe15 	stw	r5,-8(fp)
8113849c:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
811384a0:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
811384a4:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
811384a8:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
811384ac:	e13ffd17 	ldw	r4,-12(fp)
811384b0:	11381180 	call	81138118 <get_dir_divider_location>
811384b4:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
811384b8:	00012f06 	br	81138978 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
811384bc:	00800804 	movi	r2,32
811384c0:	e0bff905 	stb	r2,-28(fp)
811384c4:	00800804 	movi	r2,32
811384c8:	e0bff945 	stb	r2,-27(fp)
811384cc:	00800804 	movi	r2,32
811384d0:	e0bff985 	stb	r2,-26(fp)
811384d4:	00800804 	movi	r2,32
811384d8:	e0bff9c5 	stb	r2,-25(fp)
811384dc:	00800804 	movi	r2,32
811384e0:	e0bffa05 	stb	r2,-24(fp)
811384e4:	00800804 	movi	r2,32
811384e8:	e0bffa45 	stb	r2,-23(fp)
811384ec:	00800804 	movi	r2,32
811384f0:	e0bffa85 	stb	r2,-22(fp)
811384f4:	00800804 	movi	r2,32
811384f8:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
811384fc:	00800804 	movi	r2,32
81138500:	e0bffb05 	stb	r2,-20(fp)
81138504:	00800804 	movi	r2,32
81138508:	e0bffb45 	stb	r2,-19(fp)
8113850c:	00800804 	movi	r2,32
81138510:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
81138514:	00bfffc4 	movi	r2,-1
81138518:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
8113851c:	e0bfea17 	ldw	r2,-88(fp)
81138520:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81138524:	e03fec15 	stw	zero,-80(fp)
81138528:	00002d06 	br	811385e0 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
8113852c:	e0ffec17 	ldw	r3,-80(fp)
81138530:	e0bfed17 	ldw	r2,-76(fp)
81138534:	1885883a 	add	r2,r3,r2
81138538:	1007883a 	mov	r3,r2
8113853c:	e0bffd17 	ldw	r2,-12(fp)
81138540:	10c5883a 	add	r2,r2,r3
81138544:	10800003 	ldbu	r2,0(r2)
81138548:	10803fcc 	andi	r2,r2,255
8113854c:	1080201c 	xori	r2,r2,128
81138550:	10bfe004 	addi	r2,r2,-128
81138554:	10800b98 	cmpnei	r2,r2,46
81138558:	1000031e 	bne	r2,zero,81138568 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
8113855c:	e0bfec17 	ldw	r2,-80(fp)
81138560:	e0bfee15 	stw	r2,-72(fp)
81138564:	00001b06 	br	811385d4 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81138568:	e0bfee17 	ldw	r2,-72(fp)
8113856c:	10000c0e 	bge	r2,zero,811385a0 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81138570:	e0ffec17 	ldw	r3,-80(fp)
81138574:	e0bfed17 	ldw	r2,-76(fp)
81138578:	1885883a 	add	r2,r3,r2
8113857c:	1007883a 	mov	r3,r2
81138580:	e0bffd17 	ldw	r2,-12(fp)
81138584:	10c5883a 	add	r2,r2,r3
81138588:	10c00003 	ldbu	r3,0(r2)
8113858c:	e13ff904 	addi	r4,fp,-28
81138590:	e0bfec17 	ldw	r2,-80(fp)
81138594:	2085883a 	add	r2,r4,r2
81138598:	10c00005 	stb	r3,0(r2)
8113859c:	00000d06 	br	811385d4 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
811385a0:	e0ffec17 	ldw	r3,-80(fp)
811385a4:	e0bfee17 	ldw	r2,-72(fp)
811385a8:	1885c83a 	sub	r2,r3,r2
811385ac:	e13fec17 	ldw	r4,-80(fp)
811385b0:	e0ffed17 	ldw	r3,-76(fp)
811385b4:	20c7883a 	add	r3,r4,r3
811385b8:	1809883a 	mov	r4,r3
811385bc:	e0fffd17 	ldw	r3,-12(fp)
811385c0:	1907883a 	add	r3,r3,r4
811385c4:	18c00003 	ldbu	r3,0(r3)
811385c8:	e13ffb04 	addi	r4,fp,-20
811385cc:	2085883a 	add	r2,r4,r2
811385d0:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
811385d4:	e0bfec17 	ldw	r2,-80(fp)
811385d8:	10800044 	addi	r2,r2,1
811385dc:	e0bfec15 	stw	r2,-80(fp)
811385e0:	e0ffec17 	ldw	r3,-80(fp)
811385e4:	e0bfeb17 	ldw	r2,-84(fp)
811385e8:	18bfd016 	blt	r3,r2,8113852c <__reset+0xfb11852c>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
811385ec:	e0bfea17 	ldw	r2,-88(fp)
811385f0:	10005c1e 	bne	r2,zero,81138764 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811385f4:	00a045b4 	movhi	r2,33046
811385f8:	10bfe004 	addi	r2,r2,-128
811385fc:	1080050b 	ldhu	r2,20(r2)
81138600:	10bfffcc 	andi	r2,r2,65535
81138604:	1006917a 	slli	r3,r2,5
81138608:	00a045b4 	movhi	r2,33046
8113860c:	10bfe004 	addi	r2,r2,-128
81138610:	1080030b 	ldhu	r2,12(r2)
81138614:	10bfffcc 	andi	r2,r2,65535
81138618:	1885283a 	div	r2,r3,r2
8113861c:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81138620:	e03ff015 	stw	zero,-64(fp)
81138624:	00003b06 	br	81138714 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
81138628:	00a045b4 	movhi	r2,33046
8113862c:	10bfe004 	addi	r2,r2,-128
81138630:	10c01317 	ldw	r3,76(r2)
81138634:	e0bff017 	ldw	r2,-64(fp)
81138638:	1885883a 	add	r2,r3,r2
8113863c:	1007883a 	mov	r3,r2
81138640:	d0a0a117 	ldw	r2,-32124(gp)
81138644:	100b883a 	mov	r5,r2
81138648:	1809883a 	mov	r4,r3
8113864c:	1136d140 	call	81136d14 <Read_Sector_Data>
81138650:	10003426 	beq	r2,zero,81138724 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81138654:	e03ff115 	stw	zero,-60(fp)
81138658:	00002506 	br	811386f0 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113865c:	e0bff117 	ldw	r2,-60(fp)
81138660:	1004917a 	slli	r2,r2,5
81138664:	e0fff017 	ldw	r3,-64(fp)
81138668:	180f883a 	mov	r7,r3
8113866c:	000d883a 	mov	r6,zero
81138670:	e17fff17 	ldw	r5,-4(fp)
81138674:	1009883a 	mov	r4,r2
81138678:	11371440 	call	81137144 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113867c:	e0bfff17 	ldw	r2,-4(fp)
81138680:	10800003 	ldbu	r2,0(r2)
81138684:	10803fcc 	andi	r2,r2,255
81138688:	10803960 	cmpeqi	r2,r2,229
8113868c:	1000151e 	bne	r2,zero,811386e4 <get_home_directory_cluster_for_file+0x268>
81138690:	e0bfff17 	ldw	r2,-4(fp)
81138694:	10800003 	ldbu	r2,0(r2)
81138698:	10803fcc 	andi	r2,r2,255
8113869c:	10001126 	beq	r2,zero,811386e4 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
811386a0:	e0fffb04 	addi	r3,fp,-20
811386a4:	e0bff904 	addi	r2,fp,-28
811386a8:	180d883a 	mov	r6,r3
811386ac:	100b883a 	mov	r5,r2
811386b0:	e13fff17 	ldw	r4,-4(fp)
811386b4:	11381d80 	call	811381d8 <match_file_record_to_name_ext>
811386b8:	e0bff815 	stw	r2,-32(fp)
                            if (match)
811386bc:	e0bff817 	ldw	r2,-32(fp)
811386c0:	10000826 	beq	r2,zero,811386e4 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
811386c4:	e0bfff17 	ldw	r2,-4(fp)
811386c8:	1080058b 	ldhu	r2,22(r2)
811386cc:	10bfffcc 	andi	r2,r2,65535
811386d0:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
811386d4:	e0bfff17 	ldw	r2,-4(fp)
811386d8:	00c00044 	movi	r3,1
811386dc:	10c00a15 	stw	r3,40(r2)
                                break;
811386e0:	00000606 	br	811386fc <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
811386e4:	e0bff117 	ldw	r2,-60(fp)
811386e8:	10800044 	addi	r2,r2,1
811386ec:	e0bff115 	stw	r2,-60(fp)
811386f0:	e0bff117 	ldw	r2,-60(fp)
811386f4:	10800410 	cmplti	r2,r2,16
811386f8:	103fd81e 	bne	r2,zero,8113865c <__reset+0xfb11865c>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
811386fc:	e0ffef17 	ldw	r3,-68(fp)
81138700:	e0bfea17 	ldw	r2,-88(fp)
81138704:	1880091e 	bne	r3,r2,8113872c <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81138708:	e0bff017 	ldw	r2,-64(fp)
8113870c:	10800044 	addi	r2,r2,1
81138710:	e0bff015 	stw	r2,-64(fp)
81138714:	e0fff017 	ldw	r3,-64(fp)
81138718:	e0bff717 	ldw	r2,-36(fp)
8113871c:	18bfc216 	blt	r3,r2,81138628 <__reset+0xfb118628>
81138720:	00000306 	br	81138730 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81138724:	0001883a 	nop
81138728:	00000106 	br	81138730 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
8113872c:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81138730:	e0ffef17 	ldw	r3,-68(fp)
81138734:	e0bfea17 	ldw	r2,-88(fp)
81138738:	18800826 	beq	r3,r2,8113875c <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113873c:	e0bfef17 	ldw	r2,-68(fp)
81138740:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81138744:	e0ffed17 	ldw	r3,-76(fp)
81138748:	e0bfeb17 	ldw	r2,-84(fp)
8113874c:	1885883a 	add	r2,r3,r2
81138750:	10800044 	addi	r2,r2,1
81138754:	e0bfed15 	stw	r2,-76(fp)
81138758:	00007d06 	br	81138950 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113875c:	0005883a 	mov	r2,zero
81138760:	00009106 	br	811389a8 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81138764:	e0bfea17 	ldw	r2,-88(fp)
81138768:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113876c:	e0bff417 	ldw	r2,-48(fp)
81138770:	10ffff84 	addi	r3,r2,-2
81138774:	00a045b4 	movhi	r2,33046
81138778:	10bfe004 	addi	r2,r2,-128
8113877c:	10800383 	ldbu	r2,14(r2)
81138780:	10803fcc 	andi	r2,r2,255
81138784:	1885383a 	mul	r2,r3,r2
81138788:	1007883a 	mov	r3,r2
8113878c:	00a045b4 	movhi	r2,33046
81138790:	10bfe004 	addi	r2,r2,-128
81138794:	10801417 	ldw	r2,80(r2)
81138798:	1885883a 	add	r2,r3,r2
8113879c:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811387a0:	e03ff215 	stw	zero,-56(fp)
811387a4:	00003606 	br	81138880 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811387a8:	e0fff217 	ldw	r3,-56(fp)
811387ac:	e0bff517 	ldw	r2,-44(fp)
811387b0:	1885883a 	add	r2,r3,r2
811387b4:	d0e0a117 	ldw	r3,-32124(gp)
811387b8:	180b883a 	mov	r5,r3
811387bc:	1009883a 	mov	r4,r2
811387c0:	1136d140 	call	81136d14 <Read_Sector_Data>
811387c4:	10003526 	beq	r2,zero,8113889c <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
811387c8:	e03ff315 	stw	zero,-52(fp)
811387cc:	00002306 	br	8113885c <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
811387d0:	e0bff317 	ldw	r2,-52(fp)
811387d4:	1004917a 	slli	r2,r2,5
811387d8:	e0fff417 	ldw	r3,-48(fp)
811387dc:	e13ff217 	ldw	r4,-56(fp)
811387e0:	200f883a 	mov	r7,r4
811387e4:	180d883a 	mov	r6,r3
811387e8:	e17fff17 	ldw	r5,-4(fp)
811387ec:	1009883a 	mov	r4,r2
811387f0:	11371440 	call	81137144 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
811387f4:	e0bfff17 	ldw	r2,-4(fp)
811387f8:	10800003 	ldbu	r2,0(r2)
811387fc:	10803fcc 	andi	r2,r2,255
81138800:	10803960 	cmpeqi	r2,r2,229
81138804:	1000121e 	bne	r2,zero,81138850 <get_home_directory_cluster_for_file+0x3d4>
81138808:	e0bfff17 	ldw	r2,-4(fp)
8113880c:	10800003 	ldbu	r2,0(r2)
81138810:	10803fcc 	andi	r2,r2,255
81138814:	10000e26 	beq	r2,zero,81138850 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
81138818:	e0fffb04 	addi	r3,fp,-20
8113881c:	e0bff904 	addi	r2,fp,-28
81138820:	180d883a 	mov	r6,r3
81138824:	100b883a 	mov	r5,r2
81138828:	e13fff17 	ldw	r4,-4(fp)
8113882c:	11381d80 	call	811381d8 <match_file_record_to_name_ext>
81138830:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81138834:	e0bff617 	ldw	r2,-40(fp)
81138838:	10000526 	beq	r2,zero,81138850 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
8113883c:	e0bfff17 	ldw	r2,-4(fp)
81138840:	1080058b 	ldhu	r2,22(r2)
81138844:	10bfffcc 	andi	r2,r2,65535
81138848:	e0bfef15 	stw	r2,-68(fp)
                                    break;
8113884c:	00000606 	br	81138868 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81138850:	e0bff317 	ldw	r2,-52(fp)
81138854:	10800044 	addi	r2,r2,1
81138858:	e0bff315 	stw	r2,-52(fp)
8113885c:	e0bff317 	ldw	r2,-52(fp)
81138860:	10800410 	cmplti	r2,r2,16
81138864:	103fda1e 	bne	r2,zero,811387d0 <__reset+0xfb1187d0>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
81138868:	e0ffef17 	ldw	r3,-68(fp)
8113886c:	e0bfea17 	ldw	r2,-88(fp)
81138870:	18800c1e 	bne	r3,r2,811388a4 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81138874:	e0bff217 	ldw	r2,-56(fp)
81138878:	10800044 	addi	r2,r2,1
8113887c:	e0bff215 	stw	r2,-56(fp)
81138880:	00a045b4 	movhi	r2,33046
81138884:	10bfe004 	addi	r2,r2,-128
81138888:	10800383 	ldbu	r2,14(r2)
8113888c:	10803fcc 	andi	r2,r2,255
81138890:	e0fff217 	ldw	r3,-56(fp)
81138894:	18bfc416 	blt	r3,r2,811387a8 <__reset+0xfb1187a8>
81138898:	00000306 	br	811388a8 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
8113889c:	0001883a 	nop
811388a0:	00000106 	br	811388a8 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
811388a4:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
811388a8:	e0ffef17 	ldw	r3,-68(fp)
811388ac:	e0bfea17 	ldw	r2,-88(fp)
811388b0:	1880141e 	bne	r3,r2,81138904 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
811388b4:	e0bfef17 	ldw	r2,-68(fp)
811388b8:	e0fffc04 	addi	r3,fp,-16
811388bc:	180b883a 	mov	r5,r3
811388c0:	1009883a 	mov	r4,r2
811388c4:	1136df40 	call	81136df4 <get_cluster_flag>
811388c8:	10000c26 	beq	r2,zero,811388fc <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
811388cc:	e0bffc0b 	ldhu	r2,-16(fp)
811388d0:	10bfffcc 	andi	r2,r2,65535
811388d4:	10fffe0c 	andi	r3,r2,65528
811388d8:	00bffe14 	movui	r2,65528
811388dc:	1880021e 	bne	r3,r2,811388e8 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
811388e0:	0005883a 	mov	r2,zero
811388e4:	00003006 	br	811389a8 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
811388e8:	e0bffc0b 	ldhu	r2,-16(fp)
811388ec:	10bfffcc 	andi	r2,r2,65535
811388f0:	10bffe0c 	andi	r2,r2,65528
811388f4:	e0bfef15 	stw	r2,-68(fp)
811388f8:	00000206 	br	81138904 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
811388fc:	0005883a 	mov	r2,zero
81138900:	00002906 	br	811389a8 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81138904:	e0bff417 	ldw	r2,-48(fp)
81138908:	00fffdd4 	movui	r3,65527
8113890c:	18800316 	blt	r3,r2,8113891c <get_home_directory_cluster_for_file+0x4a0>
81138910:	e0ffef17 	ldw	r3,-68(fp)
81138914:	e0bfea17 	ldw	r2,-88(fp)
81138918:	18bf9426 	beq	r3,r2,8113876c <__reset+0xfb11876c>
            if (new_cluster != home_dir_cluster)
8113891c:	e0ffef17 	ldw	r3,-68(fp)
81138920:	e0bfea17 	ldw	r2,-88(fp)
81138924:	18800826 	beq	r3,r2,81138948 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81138928:	e0bfef17 	ldw	r2,-68(fp)
8113892c:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81138930:	e0ffed17 	ldw	r3,-76(fp)
81138934:	e0bfeb17 	ldw	r2,-84(fp)
81138938:	1885883a 	add	r2,r3,r2
8113893c:	10800044 	addi	r2,r2,1
81138940:	e0bfed15 	stw	r2,-76(fp)
81138944:	00000206 	br	81138950 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81138948:	0005883a 	mov	r2,zero
8113894c:	00001606 	br	811389a8 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81138950:	e0bfed17 	ldw	r2,-76(fp)
81138954:	e0fffd17 	ldw	r3,-12(fp)
81138958:	1885883a 	add	r2,r3,r2
8113895c:	1009883a 	mov	r4,r2
81138960:	11381180 	call	81138118 <get_dir_divider_location>
81138964:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81138968:	e0bfeb17 	ldw	r2,-84(fp)
8113896c:	1000020e 	bge	r2,zero,81138978 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81138970:	00800044 	movi	r2,1
81138974:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81138978:	e0bfeb17 	ldw	r2,-84(fp)
8113897c:	00becf16 	blt	zero,r2,811384bc <__reset+0xfb1184bc>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81138980:	e0bffe17 	ldw	r2,-8(fp)
81138984:	e0ffea17 	ldw	r3,-88(fp)
81138988:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
8113898c:	e0bfea17 	ldw	r2,-88(fp)
81138990:	1000041e 	bne	r2,zero,811389a4 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
81138994:	e0bfff17 	ldw	r2,-4(fp)
81138998:	10000a15 	stw	zero,40(r2)
		result = true;
8113899c:	00800044 	movi	r2,1
811389a0:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
811389a4:	e0bfe917 	ldw	r2,-92(fp)
}
811389a8:	e037883a 	mov	sp,fp
811389ac:	dfc00117 	ldw	ra,4(sp)
811389b0:	df000017 	ldw	fp,0(sp)
811389b4:	dec00204 	addi	sp,sp,8
811389b8:	f800283a 	ret

811389bc <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
811389bc:	deffe804 	addi	sp,sp,-96
811389c0:	de00012e 	bgeu	sp,et,811389c8 <find_file_in_directory+0xc>
811389c4:	003b68fa 	trap	3
811389c8:	dfc01715 	stw	ra,92(sp)
811389cc:	df001615 	stw	fp,88(sp)
811389d0:	df001604 	addi	fp,sp,88
811389d4:	e13ffd15 	stw	r4,-12(fp)
811389d8:	e17ffe15 	stw	r5,-8(fp)
811389dc:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
811389e0:	e13ffe17 	ldw	r4,-8(fp)
811389e4:	11381180 	call	81138118 <get_dir_divider_location>
811389e8:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
811389ec:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
811389f0:	00800804 	movi	r2,32
811389f4:	e0bff905 	stb	r2,-28(fp)
811389f8:	00800804 	movi	r2,32
811389fc:	e0bff945 	stb	r2,-27(fp)
81138a00:	00800804 	movi	r2,32
81138a04:	e0bff985 	stb	r2,-26(fp)
81138a08:	00800804 	movi	r2,32
81138a0c:	e0bff9c5 	stb	r2,-25(fp)
81138a10:	00800804 	movi	r2,32
81138a14:	e0bffa05 	stb	r2,-24(fp)
81138a18:	00800804 	movi	r2,32
81138a1c:	e0bffa45 	stb	r2,-23(fp)
81138a20:	00800804 	movi	r2,32
81138a24:	e0bffa85 	stb	r2,-22(fp)
81138a28:	00800804 	movi	r2,32
81138a2c:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81138a30:	00800804 	movi	r2,32
81138a34:	e0bffb05 	stb	r2,-20(fp)
81138a38:	00800804 	movi	r2,32
81138a3c:	e0bffb45 	stb	r2,-19(fp)
81138a40:	00800804 	movi	r2,32
81138a44:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81138a48:	00bfffc4 	movi	r2,-1
81138a4c:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81138a50:	e0bffd17 	ldw	r2,-12(fp)
81138a54:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81138a58:	e13ffe17 	ldw	r4,-8(fp)
81138a5c:	11172280 	call	81117228 <strlen>
81138a60:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81138a64:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
81138a68:	00000b06 	br	81138a98 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
81138a6c:	e0ffeb17 	ldw	r3,-84(fp)
81138a70:	e0bfea17 	ldw	r2,-88(fp)
81138a74:	1885883a 	add	r2,r3,r2
81138a78:	10800044 	addi	r2,r2,1
81138a7c:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
81138a80:	e0bfeb17 	ldw	r2,-84(fp)
81138a84:	e0fffe17 	ldw	r3,-8(fp)
81138a88:	1885883a 	add	r2,r3,r2
81138a8c:	1009883a 	mov	r4,r2
81138a90:	11381180 	call	81138118 <get_dir_divider_location>
81138a94:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
81138a98:	e0bfea17 	ldw	r2,-88(fp)
81138a9c:	00bff316 	blt	zero,r2,81138a6c <__reset+0xfb118a6c>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81138aa0:	e0bfeb17 	ldw	r2,-84(fp)
81138aa4:	e0bfee15 	stw	r2,-72(fp)
81138aa8:	00002706 	br	81138b48 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
81138aac:	e0bfee17 	ldw	r2,-72(fp)
81138ab0:	e0fffe17 	ldw	r3,-8(fp)
81138ab4:	1885883a 	add	r2,r3,r2
81138ab8:	10800003 	ldbu	r2,0(r2)
81138abc:	10803fcc 	andi	r2,r2,255
81138ac0:	1080201c 	xori	r2,r2,128
81138ac4:	10bfe004 	addi	r2,r2,-128
81138ac8:	10800b98 	cmpnei	r2,r2,46
81138acc:	1000031e 	bne	r2,zero,81138adc <find_file_in_directory+0x120>
        {
            ext_index = index;
81138ad0:	e0bfee17 	ldw	r2,-72(fp)
81138ad4:	e0bfec15 	stw	r2,-80(fp)
81138ad8:	00001806 	br	81138b3c <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
81138adc:	e0bfec17 	ldw	r2,-80(fp)
81138ae0:	10000b0e 	bge	r2,zero,81138b10 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
81138ae4:	e0ffee17 	ldw	r3,-72(fp)
81138ae8:	e0bfeb17 	ldw	r2,-84(fp)
81138aec:	1885c83a 	sub	r2,r3,r2
81138af0:	e0ffee17 	ldw	r3,-72(fp)
81138af4:	e13ffe17 	ldw	r4,-8(fp)
81138af8:	20c7883a 	add	r3,r4,r3
81138afc:	18c00003 	ldbu	r3,0(r3)
81138b00:	e13ff904 	addi	r4,fp,-28
81138b04:	2085883a 	add	r2,r4,r2
81138b08:	10c00005 	stb	r3,0(r2)
81138b0c:	00000b06 	br	81138b3c <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81138b10:	e0ffee17 	ldw	r3,-72(fp)
81138b14:	e0bfec17 	ldw	r2,-80(fp)
81138b18:	1885c83a 	sub	r2,r3,r2
81138b1c:	10bfffc4 	addi	r2,r2,-1
81138b20:	e0ffee17 	ldw	r3,-72(fp)
81138b24:	e13ffe17 	ldw	r4,-8(fp)
81138b28:	20c7883a 	add	r3,r4,r3
81138b2c:	18c00003 	ldbu	r3,0(r3)
81138b30:	e13ffb04 	addi	r4,fp,-20
81138b34:	2085883a 	add	r2,r4,r2
81138b38:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81138b3c:	e0bfee17 	ldw	r2,-72(fp)
81138b40:	10800044 	addi	r2,r2,1
81138b44:	e0bfee15 	stw	r2,-72(fp)
81138b48:	e0ffee17 	ldw	r3,-72(fp)
81138b4c:	e0bff417 	ldw	r2,-48(fp)
81138b50:	18bfd616 	blt	r3,r2,81138aac <__reset+0xfb118aac>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
81138b54:	e0bffd17 	ldw	r2,-12(fp)
81138b58:	1000461e 	bne	r2,zero,81138c74 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81138b5c:	00a045b4 	movhi	r2,33046
81138b60:	10bfe004 	addi	r2,r2,-128
81138b64:	1080050b 	ldhu	r2,20(r2)
81138b68:	10bfffcc 	andi	r2,r2,65535
81138b6c:	1006917a 	slli	r3,r2,5
81138b70:	00a045b4 	movhi	r2,33046
81138b74:	10bfe004 	addi	r2,r2,-128
81138b78:	1080030b 	ldhu	r2,12(r2)
81138b7c:	10bfffcc 	andi	r2,r2,65535
81138b80:	1885283a 	div	r2,r3,r2
81138b84:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81138b88:	e03ff015 	stw	zero,-64(fp)
81138b8c:	00003506 	br	81138c64 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81138b90:	00a045b4 	movhi	r2,33046
81138b94:	10bfe004 	addi	r2,r2,-128
81138b98:	10c01317 	ldw	r3,76(r2)
81138b9c:	e0bff017 	ldw	r2,-64(fp)
81138ba0:	1885883a 	add	r2,r3,r2
81138ba4:	1007883a 	mov	r3,r2
81138ba8:	d0a0a117 	ldw	r2,-32124(gp)
81138bac:	100b883a 	mov	r5,r2
81138bb0:	1809883a 	mov	r4,r3
81138bb4:	1136d140 	call	81136d14 <Read_Sector_Data>
81138bb8:	10009626 	beq	r2,zero,81138e14 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81138bbc:	e03ff115 	stw	zero,-60(fp)
81138bc0:	00002006 	br	81138c44 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81138bc4:	e0bff117 	ldw	r2,-60(fp)
81138bc8:	1004917a 	slli	r2,r2,5
81138bcc:	e0fff017 	ldw	r3,-64(fp)
81138bd0:	180f883a 	mov	r7,r3
81138bd4:	000d883a 	mov	r6,zero
81138bd8:	e17fff17 	ldw	r5,-4(fp)
81138bdc:	1009883a 	mov	r4,r2
81138be0:	11371440 	call	81137144 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81138be4:	e0bfff17 	ldw	r2,-4(fp)
81138be8:	10800003 	ldbu	r2,0(r2)
81138bec:	10803fcc 	andi	r2,r2,255
81138bf0:	10803960 	cmpeqi	r2,r2,229
81138bf4:	1000101e 	bne	r2,zero,81138c38 <find_file_in_directory+0x27c>
81138bf8:	e0bfff17 	ldw	r2,-4(fp)
81138bfc:	10800003 	ldbu	r2,0(r2)
81138c00:	10803fcc 	andi	r2,r2,255
81138c04:	10000c26 	beq	r2,zero,81138c38 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81138c08:	e0fffb04 	addi	r3,fp,-20
81138c0c:	e0bff904 	addi	r2,fp,-28
81138c10:	180d883a 	mov	r6,r3
81138c14:	100b883a 	mov	r5,r2
81138c18:	e13fff17 	ldw	r4,-4(fp)
81138c1c:	11381d80 	call	811381d8 <match_file_record_to_name_ext>
81138c20:	e0bff815 	stw	r2,-32(fp)

                        if (match)
81138c24:	e0bff817 	ldw	r2,-32(fp)
81138c28:	10000326 	beq	r2,zero,81138c38 <find_file_in_directory+0x27c>
                        {
                            result = true;
81138c2c:	00800044 	movi	r2,1
81138c30:	e0bfef15 	stw	r2,-68(fp)
                            break;
81138c34:	00000606 	br	81138c50 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81138c38:	e0bff117 	ldw	r2,-60(fp)
81138c3c:	10800044 	addi	r2,r2,1
81138c40:	e0bff115 	stw	r2,-60(fp)
81138c44:	e0bff117 	ldw	r2,-60(fp)
81138c48:	10800410 	cmplti	r2,r2,16
81138c4c:	103fdd1e 	bne	r2,zero,81138bc4 <__reset+0xfb118bc4>
            }
            else
            {
                break;
            }
            if (result)
81138c50:	e0bfef17 	ldw	r2,-68(fp)
81138c54:	1000711e 	bne	r2,zero,81138e1c <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81138c58:	e0bff017 	ldw	r2,-64(fp)
81138c5c:	10800044 	addi	r2,r2,1
81138c60:	e0bff015 	stw	r2,-64(fp)
81138c64:	e0fff017 	ldw	r3,-64(fp)
81138c68:	e0bff717 	ldw	r2,-36(fp)
81138c6c:	18bfc816 	blt	r3,r2,81138b90 <__reset+0xfb118b90>
81138c70:	00006b06 	br	81138e20 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81138c74:	e0bfed17 	ldw	r2,-76(fp)
81138c78:	10ffff84 	addi	r3,r2,-2
81138c7c:	00a045b4 	movhi	r2,33046
81138c80:	10bfe004 	addi	r2,r2,-128
81138c84:	10800383 	ldbu	r2,14(r2)
81138c88:	10803fcc 	andi	r2,r2,255
81138c8c:	1885383a 	mul	r2,r3,r2
81138c90:	1007883a 	mov	r3,r2
81138c94:	00a045b4 	movhi	r2,33046
81138c98:	10bfe004 	addi	r2,r2,-128
81138c9c:	10801417 	ldw	r2,80(r2)
81138ca0:	1885883a 	add	r2,r3,r2
81138ca4:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81138ca8:	e03ff215 	stw	zero,-56(fp)
81138cac:	00003306 	br	81138d7c <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81138cb0:	e0fff217 	ldw	r3,-56(fp)
81138cb4:	e0bff517 	ldw	r2,-44(fp)
81138cb8:	1885883a 	add	r2,r3,r2
81138cbc:	d0e0a117 	ldw	r3,-32124(gp)
81138cc0:	180b883a 	mov	r5,r3
81138cc4:	1009883a 	mov	r4,r2
81138cc8:	1136d140 	call	81136d14 <Read_Sector_Data>
81138ccc:	10003226 	beq	r2,zero,81138d98 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81138cd0:	e03ff315 	stw	zero,-52(fp)
81138cd4:	00002106 	br	81138d5c <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81138cd8:	e0bff317 	ldw	r2,-52(fp)
81138cdc:	1004917a 	slli	r2,r2,5
81138ce0:	e0ffed17 	ldw	r3,-76(fp)
81138ce4:	e13ff217 	ldw	r4,-56(fp)
81138ce8:	200f883a 	mov	r7,r4
81138cec:	180d883a 	mov	r6,r3
81138cf0:	e17fff17 	ldw	r5,-4(fp)
81138cf4:	1009883a 	mov	r4,r2
81138cf8:	11371440 	call	81137144 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81138cfc:	e0bfff17 	ldw	r2,-4(fp)
81138d00:	10800003 	ldbu	r2,0(r2)
81138d04:	10803fcc 	andi	r2,r2,255
81138d08:	10803960 	cmpeqi	r2,r2,229
81138d0c:	1000101e 	bne	r2,zero,81138d50 <find_file_in_directory+0x394>
81138d10:	e0bfff17 	ldw	r2,-4(fp)
81138d14:	10800003 	ldbu	r2,0(r2)
81138d18:	10803fcc 	andi	r2,r2,255
81138d1c:	10000c26 	beq	r2,zero,81138d50 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81138d20:	e0fffb04 	addi	r3,fp,-20
81138d24:	e0bff904 	addi	r2,fp,-28
81138d28:	180d883a 	mov	r6,r3
81138d2c:	100b883a 	mov	r5,r2
81138d30:	e13fff17 	ldw	r4,-4(fp)
81138d34:	11381d80 	call	811381d8 <match_file_record_to_name_ext>
81138d38:	e0bff615 	stw	r2,-40(fp)

                            if (match)
81138d3c:	e0bff617 	ldw	r2,-40(fp)
81138d40:	10000326 	beq	r2,zero,81138d50 <find_file_in_directory+0x394>
                            {                               
                                result = true;
81138d44:	00800044 	movi	r2,1
81138d48:	e0bfef15 	stw	r2,-68(fp)
                                break;
81138d4c:	00000606 	br	81138d68 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81138d50:	e0bff317 	ldw	r2,-52(fp)
81138d54:	10800044 	addi	r2,r2,1
81138d58:	e0bff315 	stw	r2,-52(fp)
81138d5c:	e0bff317 	ldw	r2,-52(fp)
81138d60:	10800410 	cmplti	r2,r2,16
81138d64:	103fdc1e 	bne	r2,zero,81138cd8 <__reset+0xfb118cd8>
                }
                else
                {
                    break;
                }
                if (result)
81138d68:	e0bfef17 	ldw	r2,-68(fp)
81138d6c:	10000c1e 	bne	r2,zero,81138da0 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81138d70:	e0bff217 	ldw	r2,-56(fp)
81138d74:	10800044 	addi	r2,r2,1
81138d78:	e0bff215 	stw	r2,-56(fp)
81138d7c:	00a045b4 	movhi	r2,33046
81138d80:	10bfe004 	addi	r2,r2,-128
81138d84:	10800383 	ldbu	r2,14(r2)
81138d88:	10803fcc 	andi	r2,r2,255
81138d8c:	e0fff217 	ldw	r3,-56(fp)
81138d90:	18bfc716 	blt	r3,r2,81138cb0 <__reset+0xfb118cb0>
81138d94:	00000306 	br	81138da4 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
81138d98:	0001883a 	nop
81138d9c:	00000106 	br	81138da4 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
81138da0:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
81138da4:	e0bfef17 	ldw	r2,-68(fp)
81138da8:	1000141e 	bne	r2,zero,81138dfc <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
81138dac:	e0bfed17 	ldw	r2,-76(fp)
81138db0:	e0fffc04 	addi	r3,fp,-16
81138db4:	180b883a 	mov	r5,r3
81138db8:	1009883a 	mov	r4,r2
81138dbc:	1136df40 	call	81136df4 <get_cluster_flag>
81138dc0:	10000c26 	beq	r2,zero,81138df4 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81138dc4:	e0bffc0b 	ldhu	r2,-16(fp)
81138dc8:	10bfffcc 	andi	r2,r2,65535
81138dcc:	10fffe0c 	andi	r3,r2,65528
81138dd0:	00bffe14 	movui	r2,65528
81138dd4:	1880021e 	bne	r3,r2,81138de0 <find_file_in_directory+0x424>
					{
						return false;
81138dd8:	0005883a 	mov	r2,zero
81138ddc:	00001106 	br	81138e24 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
81138de0:	e0bffc0b 	ldhu	r2,-16(fp)
81138de4:	10bfffcc 	andi	r2,r2,65535
81138de8:	10bffe0c 	andi	r2,r2,65528
81138dec:	e0bfed15 	stw	r2,-76(fp)
81138df0:	00000206 	br	81138dfc <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
81138df4:	0005883a 	mov	r2,zero
81138df8:	00000a06 	br	81138e24 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
81138dfc:	e0bfed17 	ldw	r2,-76(fp)
81138e00:	00fffdd4 	movui	r3,65527
81138e04:	18800616 	blt	r3,r2,81138e20 <find_file_in_directory+0x464>
81138e08:	e0bfef17 	ldw	r2,-68(fp)
81138e0c:	103f9926 	beq	r2,zero,81138c74 <__reset+0xfb118c74>
81138e10:	00000306 	br	81138e20 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
81138e14:	0001883a 	nop
81138e18:	00000106 	br	81138e20 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
81138e1c:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
81138e20:	e0bfef17 	ldw	r2,-68(fp)
}
81138e24:	e037883a 	mov	sp,fp
81138e28:	dfc00117 	ldw	ra,4(sp)
81138e2c:	df000017 	ldw	fp,0(sp)
81138e30:	dec00204 	addi	sp,sp,8
81138e34:	f800283a 	ret

81138e38 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
81138e38:	defff504 	addi	sp,sp,-44
81138e3c:	de00012e 	bgeu	sp,et,81138e44 <find_first_empty_cluster+0xc>
81138e40:	003b68fa 	trap	3
81138e44:	dfc00a15 	stw	ra,40(sp)
81138e48:	df000915 	stw	fp,36(sp)
81138e4c:	df000904 	addi	fp,sp,36
81138e50:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
81138e54:	00a045b4 	movhi	r2,33046
81138e58:	10bfe004 	addi	r2,r2,-128
81138e5c:	10801117 	ldw	r2,68(r2)
81138e60:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
81138e64:	00800084 	movi	r2,2
81138e68:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
81138e6c:	00bfffc4 	movi	r2,-1
81138e70:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
81138e74:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
81138e78:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
81138e7c:	00a045b4 	movhi	r2,33046
81138e80:	10bfe004 	addi	r2,r2,-128
81138e84:	10801417 	ldw	r2,80(r2)
81138e88:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
81138e8c:	00a045b4 	movhi	r2,33046
81138e90:	10bfe004 	addi	r2,r2,-128
81138e94:	1080058b 	ldhu	r2,22(r2)
81138e98:	10bfffcc 	andi	r2,r2,65535
81138e9c:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
81138ea0:	00a045b4 	movhi	r2,33046
81138ea4:	10bfe004 	addi	r2,r2,-128
81138ea8:	10800917 	ldw	r2,36(r2)
81138eac:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
81138eb0:	e0bffd17 	ldw	r2,-12(fp)
81138eb4:	e0fffe17 	ldw	r3,-8(fp)
81138eb8:	18800b2e 	bgeu	r3,r2,81138ee8 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81138ebc:	e0fffd17 	ldw	r3,-12(fp)
81138ec0:	e0bffc17 	ldw	r2,-16(fp)
81138ec4:	1887c83a 	sub	r3,r3,r2
81138ec8:	00a045b4 	movhi	r2,33046
81138ecc:	10bfe004 	addi	r2,r2,-128
81138ed0:	10800383 	ldbu	r2,14(r2)
81138ed4:	10803fcc 	andi	r2,r2,255
81138ed8:	1885203a 	divu	r2,r3,r2
81138edc:	10800044 	addi	r2,r2,1
81138ee0:	e0bffb15 	stw	r2,-20(fp)
81138ee4:	00002a06 	br	81138f90 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81138ee8:	e0fffe17 	ldw	r3,-8(fp)
81138eec:	e0bffc17 	ldw	r2,-16(fp)
81138ef0:	1887c83a 	sub	r3,r3,r2
81138ef4:	00a045b4 	movhi	r2,33046
81138ef8:	10bfe004 	addi	r2,r2,-128
81138efc:	10800383 	ldbu	r2,14(r2)
81138f00:	10803fcc 	andi	r2,r2,255
81138f04:	1885203a 	divu	r2,r3,r2
81138f08:	10800044 	addi	r2,r2,1
81138f0c:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81138f10:	00001f06 	br	81138f90 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
81138f14:	e0bff717 	ldw	r2,-36(fp)
81138f18:	d0e0a117 	ldw	r3,-32124(gp)
81138f1c:	180b883a 	mov	r5,r3
81138f20:	1009883a 	mov	r4,r2
81138f24:	1136d140 	call	81136d14 <Read_Sector_Data>
81138f28:	10001426 	beq	r2,zero,81138f7c <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
81138f2c:	e0bff817 	ldw	r2,-32(fp)
81138f30:	10803fcc 	andi	r2,r2,255
81138f34:	1085883a 	add	r2,r2,r2
81138f38:	1007883a 	mov	r3,r2
81138f3c:	d0a0a317 	ldw	r2,-32116(gp)
81138f40:	10800a17 	ldw	r2,40(r2)
81138f44:	1885883a 	add	r2,r3,r2
81138f48:	1080002b 	ldhuio	r2,0(r2)
81138f4c:	10bfffcc 	andi	r2,r2,65535
81138f50:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
81138f54:	e0bff90f 	ldh	r2,-28(fp)
81138f58:	10000726 	beq	r2,zero,81138f78 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
81138f5c:	e0bff817 	ldw	r2,-32(fp)
81138f60:	10800044 	addi	r2,r2,1
81138f64:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
81138f68:	e0bff817 	ldw	r2,-32(fp)
81138f6c:	10803fcc 	andi	r2,r2,255
81138f70:	103fee1e 	bne	r2,zero,81138f2c <__reset+0xfb118f2c>
81138f74:	00000106 	br	81138f7c <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
81138f78:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
81138f7c:	e0bff90f 	ldh	r2,-28(fp)
81138f80:	10000926 	beq	r2,zero,81138fa8 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
81138f84:	e0bff717 	ldw	r2,-36(fp)
81138f88:	10800044 	addi	r2,r2,1
81138f8c:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81138f90:	00a045b4 	movhi	r2,33046
81138f94:	10bfe004 	addi	r2,r2,-128
81138f98:	10c01217 	ldw	r3,72(r2)
81138f9c:	e0bff717 	ldw	r2,-36(fp)
81138fa0:	18bfdc1e 	bne	r3,r2,81138f14 <__reset+0xfb118f14>
81138fa4:	00000106 	br	81138fac <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
81138fa8:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
81138fac:	e0bff90f 	ldh	r2,-28(fp)
81138fb0:	1000081e 	bne	r2,zero,81138fd4 <find_first_empty_cluster+0x19c>
81138fb4:	e0bff90f 	ldh	r2,-28(fp)
81138fb8:	e0fffb17 	ldw	r3,-20(fp)
81138fbc:	18800536 	bltu	r3,r2,81138fd4 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
81138fc0:	e0bfff17 	ldw	r2,-4(fp)
81138fc4:	e0fff817 	ldw	r3,-32(fp)
81138fc8:	10c00015 	stw	r3,0(r2)
		result = true;
81138fcc:	00800044 	movi	r2,1
81138fd0:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
81138fd4:	e0bffa17 	ldw	r2,-24(fp)
}
81138fd8:	e037883a 	mov	sp,fp
81138fdc:	dfc00117 	ldw	ra,4(sp)
81138fe0:	df000017 	ldw	fp,0(sp)
81138fe4:	dec00204 	addi	sp,sp,8
81138fe8:	f800283a 	ret

81138fec <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
81138fec:	defff604 	addi	sp,sp,-40
81138ff0:	de00012e 	bgeu	sp,et,81138ff8 <find_first_empty_record_in_a_subdirectory+0xc>
81138ff4:	003b68fa 	trap	3
81138ff8:	dfc00915 	stw	ra,36(sp)
81138ffc:	df000815 	stw	fp,32(sp)
81139000:	df000804 	addi	fp,sp,32
81139004:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
81139008:	00bfffc4 	movi	r2,-1
8113900c:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
81139010:	e0bfff17 	ldw	r2,-4(fp)
81139014:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81139018:	e0bff917 	ldw	r2,-28(fp)
8113901c:	10ffff84 	addi	r3,r2,-2
81139020:	00a045b4 	movhi	r2,33046
81139024:	10bfe004 	addi	r2,r2,-128
81139028:	10800383 	ldbu	r2,14(r2)
8113902c:	10803fcc 	andi	r2,r2,255
81139030:	1885383a 	mul	r2,r3,r2
81139034:	1007883a 	mov	r3,r2
81139038:	00a045b4 	movhi	r2,33046
8113903c:	10bfe004 	addi	r2,r2,-128
81139040:	10801417 	ldw	r2,80(r2)
81139044:	1885883a 	add	r2,r3,r2
81139048:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113904c:	e03ffa15 	stw	zero,-24(fp)
81139050:	00002c06 	br	81139104 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81139054:	e0fffa17 	ldw	r3,-24(fp)
81139058:	e0bffc17 	ldw	r2,-16(fp)
8113905c:	1885883a 	add	r2,r3,r2
81139060:	d0e0a117 	ldw	r3,-32124(gp)
81139064:	180b883a 	mov	r5,r3
81139068:	1009883a 	mov	r4,r2
8113906c:	1136d140 	call	81136d14 <Read_Sector_Data>
81139070:	10002b26 	beq	r2,zero,81139120 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81139074:	e03ffb15 	stw	zero,-20(fp)
81139078:	00001c06 	br	811390ec <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113907c:	e0bffb17 	ldw	r2,-20(fp)
81139080:	1004917a 	slli	r2,r2,5
81139084:	1007883a 	mov	r3,r2
81139088:	d0a0a317 	ldw	r2,-32116(gp)
8113908c:	10800a17 	ldw	r2,40(r2)
81139090:	1885883a 	add	r2,r3,r2
81139094:	10800023 	ldbuio	r2,0(r2)
81139098:	10803fcc 	andi	r2,r2,255
8113909c:	10803fcc 	andi	r2,r2,255
811390a0:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
811390a4:	e0bffd0b 	ldhu	r2,-12(fp)
811390a8:	10803960 	cmpeqi	r2,r2,229
811390ac:	1000021e 	bne	r2,zero,811390b8 <find_first_empty_record_in_a_subdirectory+0xcc>
811390b0:	e0bffd0b 	ldhu	r2,-12(fp)
811390b4:	10000a1e 	bne	r2,zero,811390e0 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
811390b8:	e0bffa17 	ldw	r2,-24(fp)
811390bc:	1006913a 	slli	r3,r2,4
811390c0:	e0bffb17 	ldw	r2,-20(fp)
811390c4:	1885883a 	add	r2,r3,r2
811390c8:	1006943a 	slli	r3,r2,16
811390cc:	e0bff917 	ldw	r2,-28(fp)
811390d0:	1884b03a 	or	r2,r3,r2
811390d4:	e0bff815 	stw	r2,-32(fp)
                        return result;
811390d8:	e0bff817 	ldw	r2,-32(fp)
811390dc:	00005306 	br	8113922c <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811390e0:	e0bffb17 	ldw	r2,-20(fp)
811390e4:	10800044 	addi	r2,r2,1
811390e8:	e0bffb15 	stw	r2,-20(fp)
811390ec:	e0bffb17 	ldw	r2,-20(fp)
811390f0:	10800410 	cmplti	r2,r2,16
811390f4:	103fe11e 	bne	r2,zero,8113907c <__reset+0xfb11907c>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811390f8:	e0bffa17 	ldw	r2,-24(fp)
811390fc:	10800044 	addi	r2,r2,1
81139100:	e0bffa15 	stw	r2,-24(fp)
81139104:	00a045b4 	movhi	r2,33046
81139108:	10bfe004 	addi	r2,r2,-128
8113910c:	10800383 	ldbu	r2,14(r2)
81139110:	10803fcc 	andi	r2,r2,255
81139114:	e0fffa17 	ldw	r3,-24(fp)
81139118:	18bfce16 	blt	r3,r2,81139054 <__reset+0xfb119054>
8113911c:	00000106 	br	81139124 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
81139120:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
81139124:	e0bff817 	ldw	r2,-32(fp)
81139128:	1000390e 	bge	r2,zero,81139210 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
8113912c:	e0bff917 	ldw	r2,-28(fp)
81139130:	e0fffd84 	addi	r3,fp,-10
81139134:	180b883a 	mov	r5,r3
81139138:	1009883a 	mov	r4,r2
8113913c:	1136df40 	call	81136df4 <get_cluster_flag>
81139140:	10003126 	beq	r2,zero,81139208 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81139144:	e0bffd8b 	ldhu	r2,-10(fp)
81139148:	10bfffcc 	andi	r2,r2,65535
8113914c:	10fffe0c 	andi	r3,r2,65528
81139150:	00bffe14 	movui	r2,65528
81139154:	18802e1e 	bne	r3,r2,81139210 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
81139158:	e0bffe04 	addi	r2,fp,-8
8113915c:	1009883a 	mov	r4,r2
81139160:	1138e380 	call	81138e38 <find_first_empty_cluster>
81139164:	10002326 	beq	r2,zero,811391f4 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81139168:	e0bff917 	ldw	r2,-28(fp)
8113916c:	e0fffe17 	ldw	r3,-8(fp)
81139170:	18ffffcc 	andi	r3,r3,65535
81139174:	18e0001c 	xori	r3,r3,32768
81139178:	18e00004 	addi	r3,r3,-32768
8113917c:	01800044 	movi	r6,1
81139180:	180b883a 	mov	r5,r3
81139184:	1009883a 	mov	r4,r2
81139188:	1136eb00 	call	81136eb0 <mark_cluster>
8113918c:	10001926 	beq	r2,zero,811391f4 <find_first_empty_record_in_a_subdirectory+0x208>
81139190:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81139194:	01800044 	movi	r6,1
81139198:	017fffc4 	movi	r5,-1
8113919c:	1009883a 	mov	r4,r2
811391a0:	1136eb00 	call	81136eb0 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811391a4:	10001326 	beq	r2,zero,811391f4 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811391a8:	e0bff917 	ldw	r2,-28(fp)
811391ac:	e0fffe17 	ldw	r3,-8(fp)
811391b0:	18ffffcc 	andi	r3,r3,65535
811391b4:	18e0001c 	xori	r3,r3,32768
811391b8:	18e00004 	addi	r3,r3,-32768
811391bc:	000d883a 	mov	r6,zero
811391c0:	180b883a 	mov	r5,r3
811391c4:	1009883a 	mov	r4,r2
811391c8:	1136eb00 	call	81136eb0 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
811391cc:	10000926 	beq	r2,zero,811391f4 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811391d0:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
811391d4:	000d883a 	mov	r6,zero
811391d8:	017fffc4 	movi	r5,-1
811391dc:	1009883a 	mov	r4,r2
811391e0:	1136eb00 	call	81136eb0 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811391e4:	10000326 	beq	r2,zero,811391f4 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
811391e8:	1136cc00 	call	81136cc0 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
811391ec:	e0bffe17 	ldw	r2,-8(fp)
811391f0:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
811391f4:	e0bffd8b 	ldhu	r2,-10(fp)
811391f8:	10bfffcc 	andi	r2,r2,65535
811391fc:	10bffe0c 	andi	r2,r2,65528
81139200:	e0bff915 	stw	r2,-28(fp)
81139204:	00000206 	br	81139210 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
81139208:	00bfffc4 	movi	r2,-1
8113920c:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
81139210:	e0bff917 	ldw	r2,-28(fp)
81139214:	00fffdd4 	movui	r3,65527
81139218:	18800316 	blt	r3,r2,81139228 <find_first_empty_record_in_a_subdirectory+0x23c>
8113921c:	e0bff817 	ldw	r2,-32(fp)
81139220:	10bfffe0 	cmpeqi	r2,r2,-1
81139224:	103f7c1e 	bne	r2,zero,81139018 <__reset+0xfb119018>
    return result; 
81139228:	e0bff817 	ldw	r2,-32(fp)
}
8113922c:	e037883a 	mov	sp,fp
81139230:	dfc00117 	ldw	ra,4(sp)
81139234:	df000017 	ldw	fp,0(sp)
81139238:	dec00204 	addi	sp,sp,8
8113923c:	f800283a 	ret

81139240 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
81139240:	defff904 	addi	sp,sp,-28
81139244:	de00012e 	bgeu	sp,et,8113924c <find_first_empty_record_in_root_directory+0xc>
81139248:	003b68fa 	trap	3
8113924c:	dfc00615 	stw	ra,24(sp)
81139250:	df000515 	stw	fp,20(sp)
81139254:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81139258:	00a045b4 	movhi	r2,33046
8113925c:	10bfe004 	addi	r2,r2,-128
81139260:	1080050b 	ldhu	r2,20(r2)
81139264:	10bfffcc 	andi	r2,r2,65535
81139268:	1006917a 	slli	r3,r2,5
8113926c:	00a045b4 	movhi	r2,33046
81139270:	10bfe004 	addi	r2,r2,-128
81139274:	1080030b 	ldhu	r2,12(r2)
81139278:	10bfffcc 	andi	r2,r2,65535
8113927c:	1885283a 	div	r2,r3,r2
81139280:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
81139284:	00bfffc4 	movi	r2,-1
81139288:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113928c:	e03ffb15 	stw	zero,-20(fp)
81139290:	00002d06 	br	81139348 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81139294:	00a045b4 	movhi	r2,33046
81139298:	10bfe004 	addi	r2,r2,-128
8113929c:	10c01317 	ldw	r3,76(r2)
811392a0:	e0bffb17 	ldw	r2,-20(fp)
811392a4:	1885883a 	add	r2,r3,r2
811392a8:	1007883a 	mov	r3,r2
811392ac:	d0a0a117 	ldw	r2,-32124(gp)
811392b0:	100b883a 	mov	r5,r2
811392b4:	1809883a 	mov	r4,r3
811392b8:	1136d140 	call	81136d14 <Read_Sector_Data>
811392bc:	10002626 	beq	r2,zero,81139358 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
811392c0:	e03ffc15 	stw	zero,-16(fp)
811392c4:	00001a06 	br	81139330 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
811392c8:	e0bffc17 	ldw	r2,-16(fp)
811392cc:	1004917a 	slli	r2,r2,5
811392d0:	1007883a 	mov	r3,r2
811392d4:	d0a0a317 	ldw	r2,-32116(gp)
811392d8:	10800a17 	ldw	r2,40(r2)
811392dc:	1885883a 	add	r2,r3,r2
811392e0:	10800023 	ldbuio	r2,0(r2)
811392e4:	10803fcc 	andi	r2,r2,255
811392e8:	10803fcc 	andi	r2,r2,255
811392ec:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
811392f0:	e0bfff0b 	ldhu	r2,-4(fp)
811392f4:	10803960 	cmpeqi	r2,r2,229
811392f8:	1000021e 	bne	r2,zero,81139304 <find_first_empty_record_in_root_directory+0xc4>
811392fc:	e0bfff0b 	ldhu	r2,-4(fp)
81139300:	1000081e 	bne	r2,zero,81139324 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
81139304:	e0bffb17 	ldw	r2,-20(fp)
81139308:	1006913a 	slli	r3,r2,4
8113930c:	e0bffc17 	ldw	r2,-16(fp)
81139310:	1885883a 	add	r2,r3,r2
81139314:	1004943a 	slli	r2,r2,16
81139318:	e0bffe15 	stw	r2,-8(fp)
                    return result;
8113931c:	e0bffe17 	ldw	r2,-8(fp)
81139320:	00000f06 	br	81139360 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81139324:	e0bffc17 	ldw	r2,-16(fp)
81139328:	10800044 	addi	r2,r2,1
8113932c:	e0bffc15 	stw	r2,-16(fp)
81139330:	e0bffc17 	ldw	r2,-16(fp)
81139334:	10800410 	cmplti	r2,r2,16
81139338:	103fe31e 	bne	r2,zero,811392c8 <__reset+0xfb1192c8>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113933c:	e0bffb17 	ldw	r2,-20(fp)
81139340:	10800044 	addi	r2,r2,1
81139344:	e0bffb15 	stw	r2,-20(fp)
81139348:	e0fffb17 	ldw	r3,-20(fp)
8113934c:	e0bffd17 	ldw	r2,-12(fp)
81139350:	18bfd016 	blt	r3,r2,81139294 <__reset+0xfb119294>
81139354:	00000106 	br	8113935c <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
81139358:	0001883a 	nop
        }
    }
    return result;
8113935c:	e0bffe17 	ldw	r2,-8(fp)
}
81139360:	e037883a 	mov	sp,fp
81139364:	dfc00117 	ldw	ra,4(sp)
81139368:	df000017 	ldw	fp,0(sp)
8113936c:	dec00204 	addi	sp,sp,8
81139370:	f800283a 	ret

81139374 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
81139374:	defffa04 	addi	sp,sp,-24
81139378:	de00012e 	bgeu	sp,et,81139380 <convert_filename_to_name_extension+0xc>
8113937c:	003b68fa 	trap	3
81139380:	df000515 	stw	fp,20(sp)
81139384:	df000504 	addi	fp,sp,20
81139388:	e13ffd15 	stw	r4,-12(fp)
8113938c:	e17ffe15 	stw	r5,-8(fp)
81139390:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
81139394:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
81139398:	e03ffb15 	stw	zero,-20(fp)
8113939c:	00002506 	br	81139434 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
811393a0:	e0bffc17 	ldw	r2,-16(fp)
811393a4:	e0fffd17 	ldw	r3,-12(fp)
811393a8:	1885883a 	add	r2,r3,r2
811393ac:	10800003 	ldbu	r2,0(r2)
811393b0:	10803fcc 	andi	r2,r2,255
811393b4:	1080201c 	xori	r2,r2,128
811393b8:	10bfe004 	addi	r2,r2,-128
811393bc:	10800ba0 	cmpeqi	r2,r2,46
811393c0:	1000141e 	bne	r2,zero,81139414 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
811393c4:	e0bffb17 	ldw	r2,-20(fp)
811393c8:	e0fffe17 	ldw	r3,-8(fp)
811393cc:	1885883a 	add	r2,r3,r2
811393d0:	e0fffc17 	ldw	r3,-16(fp)
811393d4:	e13ffd17 	ldw	r4,-12(fp)
811393d8:	20c7883a 	add	r3,r4,r3
811393dc:	18c00003 	ldbu	r3,0(r3)
811393e0:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
811393e4:	e0bffc17 	ldw	r2,-16(fp)
811393e8:	e0fffd17 	ldw	r3,-12(fp)
811393ec:	1885883a 	add	r2,r3,r2
811393f0:	10800003 	ldbu	r2,0(r2)
811393f4:	10803fcc 	andi	r2,r2,255
811393f8:	1080201c 	xori	r2,r2,128
811393fc:	10bfe004 	addi	r2,r2,-128
81139400:	10000926 	beq	r2,zero,81139428 <convert_filename_to_name_extension+0xb4>
81139404:	e0bffc17 	ldw	r2,-16(fp)
81139408:	10800044 	addi	r2,r2,1
8113940c:	e0bffc15 	stw	r2,-16(fp)
81139410:	00000506 	br	81139428 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
81139414:	e0bffb17 	ldw	r2,-20(fp)
81139418:	e0fffe17 	ldw	r3,-8(fp)
8113941c:	1885883a 	add	r2,r3,r2
81139420:	00c00804 	movi	r3,32
81139424:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
81139428:	e0bffb17 	ldw	r2,-20(fp)
8113942c:	10800044 	addi	r2,r2,1
81139430:	e0bffb15 	stw	r2,-20(fp)
81139434:	e0bffb17 	ldw	r2,-20(fp)
81139438:	10800210 	cmplti	r2,r2,8
8113943c:	103fd81e 	bne	r2,zero,811393a0 <__reset+0xfb1193a0>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
81139440:	e0bffc17 	ldw	r2,-16(fp)
81139444:	e0fffd17 	ldw	r3,-12(fp)
81139448:	1885883a 	add	r2,r3,r2
8113944c:	10800003 	ldbu	r2,0(r2)
81139450:	10803fcc 	andi	r2,r2,255
81139454:	1080201c 	xori	r2,r2,128
81139458:	10bfe004 	addi	r2,r2,-128
8113945c:	10800b98 	cmpnei	r2,r2,46
81139460:	1000031e 	bne	r2,zero,81139470 <convert_filename_to_name_extension+0xfc>
81139464:	e0bffc17 	ldw	r2,-16(fp)
81139468:	10800044 	addi	r2,r2,1
8113946c:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
81139470:	e03ffb15 	stw	zero,-20(fp)
81139474:	00001c06 	br	811394e8 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
81139478:	e0bffc17 	ldw	r2,-16(fp)
8113947c:	e0fffd17 	ldw	r3,-12(fp)
81139480:	1885883a 	add	r2,r3,r2
81139484:	10800003 	ldbu	r2,0(r2)
81139488:	10803fcc 	andi	r2,r2,255
8113948c:	1080201c 	xori	r2,r2,128
81139490:	10bfe004 	addi	r2,r2,-128
81139494:	10000c26 	beq	r2,zero,811394c8 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
81139498:	e0bffb17 	ldw	r2,-20(fp)
8113949c:	e0ffff17 	ldw	r3,-4(fp)
811394a0:	1885883a 	add	r2,r3,r2
811394a4:	e0fffc17 	ldw	r3,-16(fp)
811394a8:	e13ffd17 	ldw	r4,-12(fp)
811394ac:	20c7883a 	add	r3,r4,r3
811394b0:	18c00003 	ldbu	r3,0(r3)
811394b4:	10c00005 	stb	r3,0(r2)
            local++;
811394b8:	e0bffc17 	ldw	r2,-16(fp)
811394bc:	10800044 	addi	r2,r2,1
811394c0:	e0bffc15 	stw	r2,-16(fp)
811394c4:	00000506 	br	811394dc <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
811394c8:	e0bffb17 	ldw	r2,-20(fp)
811394cc:	e0ffff17 	ldw	r3,-4(fp)
811394d0:	1885883a 	add	r2,r3,r2
811394d4:	00c00804 	movi	r3,32
811394d8:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
811394dc:	e0bffb17 	ldw	r2,-20(fp)
811394e0:	10800044 	addi	r2,r2,1
811394e4:	e0bffb15 	stw	r2,-20(fp)
811394e8:	e0bffb17 	ldw	r2,-20(fp)
811394ec:	108000d0 	cmplti	r2,r2,3
811394f0:	103fe11e 	bne	r2,zero,81139478 <__reset+0xfb119478>
        {
            extension[counter] = ' ';
        }
    }

}
811394f4:	0001883a 	nop
811394f8:	e037883a 	mov	sp,fp
811394fc:	df000017 	ldw	fp,0(sp)
81139500:	dec00104 	addi	sp,sp,4
81139504:	f800283a 	ret

81139508 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
81139508:	defff504 	addi	sp,sp,-44
8113950c:	de00012e 	bgeu	sp,et,81139514 <create_file+0xc>
81139510:	003b68fa 	trap	3
81139514:	dfc00a15 	stw	ra,40(sp)
81139518:	df000915 	stw	fp,36(sp)
8113951c:	df000904 	addi	fp,sp,36
81139520:	e13ffd15 	stw	r4,-12(fp)
81139524:	e17ffe15 	stw	r5,-8(fp)
81139528:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
8113952c:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81139530:	e0bffc04 	addi	r2,fp,-16
81139534:	1009883a 	mov	r4,r2
81139538:	1138e380 	call	81138e38 <find_first_empty_cluster>
8113953c:	1000a026 	beq	r2,zero,811397c0 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81139540:	e0bfff17 	ldw	r2,-4(fp)
81139544:	10800a17 	ldw	r2,40(r2)
81139548:	1000031e 	bne	r2,zero,81139558 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
8113954c:	11392400 	call	81139240 <find_first_empty_record_in_root_directory>
81139550:	e0bff815 	stw	r2,-32(fp)
81139554:	00000606 	br	81139570 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81139558:	e0bfff17 	ldw	r2,-4(fp)
8113955c:	1080058b 	ldhu	r2,22(r2)
81139560:	10bfffcc 	andi	r2,r2,65535
81139564:	1009883a 	mov	r4,r2
81139568:	1138fec0 	call	81138fec <find_first_empty_record_in_a_subdirectory>
8113956c:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81139570:	e0bff817 	ldw	r2,-32(fp)
81139574:	10009216 	blt	r2,zero,811397c0 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81139578:	e13ffd17 	ldw	r4,-12(fp)
8113957c:	11381180 	call	81138118 <get_dir_divider_location>
81139580:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81139584:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81139588:	00000b06 	br	811395b8 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
8113958c:	e0fffa17 	ldw	r3,-24(fp)
81139590:	e0bff917 	ldw	r2,-28(fp)
81139594:	1885883a 	add	r2,r3,r2
81139598:	10800044 	addi	r2,r2,1
8113959c:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
811395a0:	e0bffa17 	ldw	r2,-24(fp)
811395a4:	e0fffd17 	ldw	r3,-12(fp)
811395a8:	1885883a 	add	r2,r3,r2
811395ac:	1009883a 	mov	r4,r2
811395b0:	11381180 	call	81138118 <get_dir_divider_location>
811395b4:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
811395b8:	e0bff917 	ldw	r2,-28(fp)
811395bc:	00bff316 	blt	zero,r2,8113958c <__reset+0xfb11958c>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
811395c0:	e0bffa17 	ldw	r2,-24(fp)
811395c4:	e0fffd17 	ldw	r3,-12(fp)
811395c8:	1887883a 	add	r3,r3,r2
811395cc:	e13ffe17 	ldw	r4,-8(fp)
811395d0:	e0bffe17 	ldw	r2,-8(fp)
811395d4:	10800204 	addi	r2,r2,8
811395d8:	100d883a 	mov	r6,r2
811395dc:	200b883a 	mov	r5,r4
811395e0:	1809883a 	mov	r4,r3
811395e4:	11393740 	call	81139374 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
811395e8:	e0bffe17 	ldw	r2,-8(fp)
811395ec:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
811395f0:	e0bffe17 	ldw	r2,-8(fp)
811395f4:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
811395f8:	e0bffe17 	ldw	r2,-8(fp)
811395fc:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81139600:	e0bffe17 	ldw	r2,-8(fp)
81139604:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
81139608:	e0bffe17 	ldw	r2,-8(fp)
8113960c:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81139610:	e0bffe17 	ldw	r2,-8(fp)
81139614:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
81139618:	e0bffc17 	ldw	r2,-16(fp)
8113961c:	1007883a 	mov	r3,r2
81139620:	e0bffe17 	ldw	r2,-8(fp)
81139624:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
81139628:	e0bffe17 	ldw	r2,-8(fp)
8113962c:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81139630:	e0fffc17 	ldw	r3,-16(fp)
81139634:	e0bffe17 	ldw	r2,-8(fp)
81139638:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
8113963c:	e0bffe17 	ldw	r2,-8(fp)
81139640:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81139644:	e0bffe17 	ldw	r2,-8(fp)
81139648:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
8113964c:	e0bff817 	ldw	r2,-32(fp)
81139650:	10ffffcc 	andi	r3,r2,65535
81139654:	e0bffe17 	ldw	r2,-8(fp)
81139658:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
8113965c:	e0bff817 	ldw	r2,-32(fp)
81139660:	1004d43a 	srli	r2,r2,16
81139664:	1000010e 	bge	r2,zero,8113966c <create_file+0x164>
81139668:	108003c4 	addi	r2,r2,15
8113966c:	1005d13a 	srai	r2,r2,4
81139670:	1007883a 	mov	r3,r2
81139674:	e0bffe17 	ldw	r2,-8(fp)
81139678:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
8113967c:	e0bff817 	ldw	r2,-32(fp)
81139680:	1004d43a 	srli	r2,r2,16
81139684:	1007883a 	mov	r3,r2
81139688:	00a00034 	movhi	r2,32768
8113968c:	108003c4 	addi	r2,r2,15
81139690:	1884703a 	and	r2,r3,r2
81139694:	1000040e 	bge	r2,zero,811396a8 <create_file+0x1a0>
81139698:	10bfffc4 	addi	r2,r2,-1
8113969c:	00fffc04 	movi	r3,-16
811396a0:	10c4b03a 	or	r2,r2,r3
811396a4:	10800044 	addi	r2,r2,1
811396a8:	1004917a 	slli	r2,r2,5
811396ac:	1007883a 	mov	r3,r2
811396b0:	e0bffe17 	ldw	r2,-8(fp)
811396b4:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
811396b8:	e0bfff17 	ldw	r2,-4(fp)
811396bc:	1080058b 	ldhu	r2,22(r2)
811396c0:	10ffffcc 	andi	r3,r2,65535
811396c4:	e0bffe17 	ldw	r2,-8(fp)
811396c8:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
811396cc:	e0bffe17 	ldw	r2,-8(fp)
811396d0:	00c00044 	movi	r3,1
811396d4:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
811396d8:	e0bffe17 	ldw	r2,-8(fp)
811396dc:	00c00044 	movi	r3,1
811396e0:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
811396e4:	e0bffe17 	ldw	r2,-8(fp)
811396e8:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
811396ec:	1000071e 	bne	r2,zero,8113970c <create_file+0x204>
811396f0:	00a045b4 	movhi	r2,33046
811396f4:	10bfe004 	addi	r2,r2,-128
811396f8:	10c01317 	ldw	r3,76(r2)
811396fc:	e0bffe17 	ldw	r2,-8(fp)
81139700:	10800b17 	ldw	r2,44(r2)
81139704:	1885883a 	add	r2,r3,r2
81139708:	00000f06 	br	81139748 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
8113970c:	00a045b4 	movhi	r2,33046
81139710:	10bfe004 	addi	r2,r2,-128
81139714:	10c01417 	ldw	r3,80(r2)
81139718:	e0bffe17 	ldw	r2,-8(fp)
8113971c:	10800a17 	ldw	r2,40(r2)
81139720:	113fff84 	addi	r4,r2,-2
81139724:	00a045b4 	movhi	r2,33046
81139728:	10bfe004 	addi	r2,r2,-128
8113972c:	10800383 	ldbu	r2,14(r2)
81139730:	10803fcc 	andi	r2,r2,255
81139734:	2085383a 	mul	r2,r4,r2
81139738:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
8113973c:	e0bffe17 	ldw	r2,-8(fp)
81139740:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81139744:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81139748:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
8113974c:	e0bffb17 	ldw	r2,-20(fp)
81139750:	d0e0a117 	ldw	r3,-32124(gp)
81139754:	180b883a 	mov	r5,r3
81139758:	1009883a 	mov	r4,r2
8113975c:	1136d140 	call	81136d14 <Read_Sector_Data>
81139760:	10001726 	beq	r2,zero,811397c0 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81139764:	e0bffe17 	ldw	r2,-8(fp)
81139768:	10800c0b 	ldhu	r2,48(r2)
8113976c:	10bfffcc 	andi	r2,r2,65535
81139770:	10a0001c 	xori	r2,r2,32768
81139774:	10a00004 	addi	r2,r2,-32768
81139778:	e17ffe17 	ldw	r5,-8(fp)
8113977c:	1009883a 	mov	r4,r2
81139780:	11373c80 	call	811373c8 <Write_File_Record_At_Offset>
81139784:	10000e26 	beq	r2,zero,811397c0 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81139788:	1136cc00 	call	81136cc0 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
8113978c:	e0bffc17 	ldw	r2,-16(fp)
81139790:	01800044 	movi	r6,1
81139794:	017fffc4 	movi	r5,-1
81139798:	1009883a 	mov	r4,r2
8113979c:	1136eb00 	call	81136eb0 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
811397a0:	e0bffc17 	ldw	r2,-16(fp)
811397a4:	000d883a 	mov	r6,zero
811397a8:	017fffc4 	movi	r5,-1
811397ac:	1009883a 	mov	r4,r2
811397b0:	1136eb00 	call	81136eb0 <mark_cluster>
811397b4:	10000226 	beq	r2,zero,811397c0 <create_file+0x2b8>
                    {
                        result = true;
811397b8:	00800044 	movi	r2,1
811397bc:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
811397c0:	e0bff717 	ldw	r2,-36(fp)
}
811397c4:	e037883a 	mov	sp,fp
811397c8:	dfc00117 	ldw	ra,4(sp)
811397cc:	df000017 	ldw	fp,0(sp)
811397d0:	dec00204 	addi	sp,sp,8
811397d4:	f800283a 	ret

811397d8 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
811397d8:	defffb04 	addi	sp,sp,-20
811397dc:	de00012e 	bgeu	sp,et,811397e4 <copy_file_record_name_to_string+0xc>
811397e0:	003b68fa 	trap	3
811397e4:	df000415 	stw	fp,16(sp)
811397e8:	df000404 	addi	fp,sp,16
811397ec:	e13ffe15 	stw	r4,-8(fp)
811397f0:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
811397f4:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
811397f8:	e03ffc15 	stw	zero,-16(fp)
811397fc:	00001506 	br	81139854 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81139800:	e0fffe17 	ldw	r3,-8(fp)
81139804:	e0bffc17 	ldw	r2,-16(fp)
81139808:	1885883a 	add	r2,r3,r2
8113980c:	10800003 	ldbu	r2,0(r2)
81139810:	10803fcc 	andi	r2,r2,255
81139814:	10800820 	cmpeqi	r2,r2,32
81139818:	10000b1e 	bne	r2,zero,81139848 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
8113981c:	e0bffd17 	ldw	r2,-12(fp)
81139820:	e0ffff17 	ldw	r3,-4(fp)
81139824:	1885883a 	add	r2,r3,r2
81139828:	e13ffe17 	ldw	r4,-8(fp)
8113982c:	e0fffc17 	ldw	r3,-16(fp)
81139830:	20c7883a 	add	r3,r4,r3
81139834:	18c00003 	ldbu	r3,0(r3)
81139838:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
8113983c:	e0bffd17 	ldw	r2,-12(fp)
81139840:	10800044 	addi	r2,r2,1
81139844:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81139848:	e0bffc17 	ldw	r2,-16(fp)
8113984c:	10800044 	addi	r2,r2,1
81139850:	e0bffc15 	stw	r2,-16(fp)
81139854:	e0bffc17 	ldw	r2,-16(fp)
81139858:	10800210 	cmplti	r2,r2,8
8113985c:	103fe81e 	bne	r2,zero,81139800 <__reset+0xfb119800>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81139860:	e0bffe17 	ldw	r2,-8(fp)
81139864:	10800203 	ldbu	r2,8(r2)
81139868:	10803fcc 	andi	r2,r2,255
8113986c:	10800820 	cmpeqi	r2,r2,32
81139870:	1000241e 	bne	r2,zero,81139904 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81139874:	e0bffd17 	ldw	r2,-12(fp)
81139878:	e0ffff17 	ldw	r3,-4(fp)
8113987c:	1885883a 	add	r2,r3,r2
81139880:	00c00b84 	movi	r3,46
81139884:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
81139888:	e0bffd17 	ldw	r2,-12(fp)
8113988c:	10800044 	addi	r2,r2,1
81139890:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
81139894:	e03ffc15 	stw	zero,-16(fp)
81139898:	00001706 	br	811398f8 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
8113989c:	e0fffe17 	ldw	r3,-8(fp)
811398a0:	e0bffc17 	ldw	r2,-16(fp)
811398a4:	1885883a 	add	r2,r3,r2
811398a8:	10800204 	addi	r2,r2,8
811398ac:	10800003 	ldbu	r2,0(r2)
811398b0:	10803fcc 	andi	r2,r2,255
811398b4:	10800820 	cmpeqi	r2,r2,32
811398b8:	10000c1e 	bne	r2,zero,811398ec <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
811398bc:	e0bffd17 	ldw	r2,-12(fp)
811398c0:	e0ffff17 	ldw	r3,-4(fp)
811398c4:	1885883a 	add	r2,r3,r2
811398c8:	e13ffe17 	ldw	r4,-8(fp)
811398cc:	e0fffc17 	ldw	r3,-16(fp)
811398d0:	20c7883a 	add	r3,r4,r3
811398d4:	18c00204 	addi	r3,r3,8
811398d8:	18c00003 	ldbu	r3,0(r3)
811398dc:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
811398e0:	e0bffd17 	ldw	r2,-12(fp)
811398e4:	10800044 	addi	r2,r2,1
811398e8:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
811398ec:	e0bffc17 	ldw	r2,-16(fp)
811398f0:	10800044 	addi	r2,r2,1
811398f4:	e0bffc15 	stw	r2,-16(fp)
811398f8:	e0bffc17 	ldw	r2,-16(fp)
811398fc:	108000d0 	cmplti	r2,r2,3
81139900:	103fe61e 	bne	r2,zero,8113989c <__reset+0xfb11989c>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81139904:	e0bffd17 	ldw	r2,-12(fp)
81139908:	e0ffff17 	ldw	r3,-4(fp)
8113990c:	1885883a 	add	r2,r3,r2
81139910:	10000005 	stb	zero,0(r2)
}
81139914:	0001883a 	nop
81139918:	e037883a 	mov	sp,fp
8113991c:	df000017 	ldw	fp,0(sp)
81139920:	dec00104 	addi	sp,sp,4
81139924:	f800283a 	ret

81139928 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81139928:	defffc04 	addi	sp,sp,-16
8113992c:	de00012e 	bgeu	sp,et,81139934 <alt_up_sd_card_open_dev+0xc>
81139930:	003b68fa 	trap	3
81139934:	dfc00315 	stw	ra,12(sp)
81139938:	df000215 	stw	fp,8(sp)
8113993c:	df000204 	addi	fp,sp,8
81139940:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81139944:	d1600d04 	addi	r5,gp,-32716
81139948:	e13fff17 	ldw	r4,-4(fp)
8113994c:	113ede40 	call	8113ede4 <alt_find_dev>
81139950:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81139954:	e0bffe17 	ldw	r2,-8(fp)
81139958:	10001e26 	beq	r2,zero,811399d4 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
8113995c:	e0bffe17 	ldw	r2,-8(fp)
81139960:	10800a17 	ldw	r2,40(r2)
81139964:	10808d04 	addi	r2,r2,564
81139968:	d0a09b15 	stw	r2,-32148(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
8113996c:	e0bffe17 	ldw	r2,-8(fp)
81139970:	10800a17 	ldw	r2,40(r2)
81139974:	10808904 	addi	r2,r2,548
81139978:	d0a09c15 	stw	r2,-32144(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
8113997c:	e0bffe17 	ldw	r2,-8(fp)
81139980:	10800a17 	ldw	r2,40(r2)
81139984:	10808404 	addi	r2,r2,528
81139988:	d0a09d15 	stw	r2,-32140(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
8113998c:	e0bffe17 	ldw	r2,-8(fp)
81139990:	10800a17 	ldw	r2,40(r2)
81139994:	10808c04 	addi	r2,r2,560
81139998:	d0a09e15 	stw	r2,-32136(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
8113999c:	e0bffe17 	ldw	r2,-8(fp)
811399a0:	10800a17 	ldw	r2,40(r2)
811399a4:	10808b04 	addi	r2,r2,556
811399a8:	d0a09f15 	stw	r2,-32132(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
811399ac:	e0bffe17 	ldw	r2,-8(fp)
811399b0:	10800a17 	ldw	r2,40(r2)
811399b4:	d0a0a015 	stw	r2,-32128(gp)
		device_pointer = dev;
811399b8:	e0bffe17 	ldw	r2,-8(fp)
811399bc:	d0a0a315 	stw	r2,-32116(gp)
		initialized = false;
811399c0:	d0209915 	stw	zero,-32156(gp)
		is_sd_card_formated_as_FAT16 = false;
811399c4:	d0209a15 	stw	zero,-32152(gp)
		search_data.valid = false;
811399c8:	00a045b4 	movhi	r2,33046
811399cc:	10bfdb04 	addi	r2,r2,-148
811399d0:	10000415 	stw	zero,16(r2)
	}
	return dev;
811399d4:	e0bffe17 	ldw	r2,-8(fp)
}
811399d8:	e037883a 	mov	sp,fp
811399dc:	dfc00117 	ldw	ra,4(sp)
811399e0:	df000017 	ldw	fp,0(sp)
811399e4:	dec00204 	addi	sp,sp,8
811399e8:	f800283a 	ret

811399ec <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
811399ec:	defffd04 	addi	sp,sp,-12
811399f0:	de00012e 	bgeu	sp,et,811399f8 <alt_up_sd_card_is_Present+0xc>
811399f4:	003b68fa 	trap	3
811399f8:	df000215 	stw	fp,8(sp)
811399fc:	df000204 	addi	fp,sp,8
    bool result = false;
81139a00:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81139a04:	d0a0a317 	ldw	r2,-32116(gp)
81139a08:	10000826 	beq	r2,zero,81139a2c <alt_up_sd_card_is_Present+0x40>
81139a0c:	d0a09b17 	ldw	r2,-32148(gp)
81139a10:	1080002b 	ldhuio	r2,0(r2)
81139a14:	10bfffcc 	andi	r2,r2,65535
81139a18:	1080008c 	andi	r2,r2,2
81139a1c:	10000326 	beq	r2,zero,81139a2c <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81139a20:	00800044 	movi	r2,1
81139a24:	e0bffe15 	stw	r2,-8(fp)
81139a28:	00001e06 	br	81139aa4 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81139a2c:	d0a09917 	ldw	r2,-32156(gp)
81139a30:	10800058 	cmpnei	r2,r2,1
81139a34:	10001b1e 	bne	r2,zero,81139aa4 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81139a38:	d0209915 	stw	zero,-32156(gp)
		search_data.valid = false;
81139a3c:	00a045b4 	movhi	r2,33046
81139a40:	10bfdb04 	addi	r2,r2,-148
81139a44:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81139a48:	d0209a15 	stw	zero,-32152(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81139a4c:	e03fff15 	stw	zero,-4(fp)
81139a50:	00001106 	br	81139a98 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81139a54:	00a045b4 	movhi	r2,33046
81139a58:	10bff504 	addi	r2,r2,-44
81139a5c:	e0ffff17 	ldw	r3,-4(fp)
81139a60:	180691ba 	slli	r3,r3,6
81139a64:	10c5883a 	add	r2,r2,r3
81139a68:	10800f04 	addi	r2,r2,60
81139a6c:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81139a70:	00a045b4 	movhi	r2,33046
81139a74:	10bff504 	addi	r2,r2,-44
81139a78:	e0ffff17 	ldw	r3,-4(fp)
81139a7c:	180691ba 	slli	r3,r3,6
81139a80:	10c5883a 	add	r2,r2,r3
81139a84:	10800e04 	addi	r2,r2,56
81139a88:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
81139a8c:	e0bfff17 	ldw	r2,-4(fp)
81139a90:	10800044 	addi	r2,r2,1
81139a94:	e0bfff15 	stw	r2,-4(fp)
81139a98:	e0bfff17 	ldw	r2,-4(fp)
81139a9c:	10800510 	cmplti	r2,r2,20
81139aa0:	103fec1e 	bne	r2,zero,81139a54 <__reset+0xfb119a54>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
81139aa4:	e0bffe17 	ldw	r2,-8(fp)
}
81139aa8:	e037883a 	mov	sp,fp
81139aac:	df000017 	ldw	fp,0(sp)
81139ab0:	dec00104 	addi	sp,sp,4
81139ab4:	f800283a 	ret

81139ab8 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81139ab8:	defffd04 	addi	sp,sp,-12
81139abc:	de00012e 	bgeu	sp,et,81139ac4 <alt_up_sd_card_is_FAT16+0xc>
81139ac0:	003b68fa 	trap	3
81139ac4:	dfc00215 	stw	ra,8(sp)
81139ac8:	df000115 	stw	fp,4(sp)
81139acc:	df000104 	addi	fp,sp,4
	bool result = false;
81139ad0:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
81139ad4:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
81139ad8:	10000c26 	beq	r2,zero,81139b0c <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81139adc:	d0a09917 	ldw	r2,-32156(gp)
81139ae0:	1000071e 	bne	r2,zero,81139b00 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
81139ae4:	1137ce40 	call	81137ce4 <Look_for_FAT16>
81139ae8:	d0a09a15 	stw	r2,-32152(gp)
			initialized = is_sd_card_formated_as_FAT16;
81139aec:	d0a09a17 	ldw	r2,-32152(gp)
81139af0:	d0a09915 	stw	r2,-32156(gp)
			search_data.valid = false;
81139af4:	00a045b4 	movhi	r2,33046
81139af8:	10bfdb04 	addi	r2,r2,-148
81139afc:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81139b00:	d0a09a17 	ldw	r2,-32152(gp)
81139b04:	e0bfff15 	stw	r2,-4(fp)
81139b08:	00000206 	br	81139b14 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81139b0c:	d0209915 	stw	zero,-32156(gp)
		is_sd_card_formated_as_FAT16 = false;
81139b10:	d0209a15 	stw	zero,-32152(gp)
	}

	return result;
81139b14:	e0bfff17 	ldw	r2,-4(fp)
}
81139b18:	e037883a 	mov	sp,fp
81139b1c:	dfc00117 	ldw	ra,4(sp)
81139b20:	df000017 	ldw	fp,0(sp)
81139b24:	dec00204 	addi	sp,sp,8
81139b28:	f800283a 	ret

81139b2c <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81139b2c:	deffea04 	addi	sp,sp,-88
81139b30:	de00012e 	bgeu	sp,et,81139b38 <alt_up_sd_card_find_first+0xc>
81139b34:	003b68fa 	trap	3
81139b38:	dfc01515 	stw	ra,84(sp)
81139b3c:	df001415 	stw	fp,80(sp)
81139b40:	df001404 	addi	fp,sp,80
81139b44:	e13ffe15 	stw	r4,-8(fp)
81139b48:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
81139b4c:	00800084 	movi	r2,2
81139b50:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81139b54:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
81139b58:	10002426 	beq	r2,zero,81139bec <alt_up_sd_card_find_first+0xc0>
81139b5c:	d0a09a17 	ldw	r2,-32152(gp)
81139b60:	10002226 	beq	r2,zero,81139bec <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
81139b64:	e0ffee04 	addi	r3,fp,-72
81139b68:	e0bfed04 	addi	r2,fp,-76
81139b6c:	180d883a 	mov	r6,r3
81139b70:	100b883a 	mov	r5,r2
81139b74:	e13ffe17 	ldw	r4,-8(fp)
81139b78:	113847c0 	call	8113847c <get_home_directory_cluster_for_file>
81139b7c:	10001926 	beq	r2,zero,81139be4 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
81139b80:	e0bfed17 	ldw	r2,-76(fp)
81139b84:	1007883a 	mov	r3,r2
81139b88:	00a045b4 	movhi	r2,33046
81139b8c:	10bfdb04 	addi	r2,r2,-148
81139b90:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
81139b94:	e0bfed17 	ldw	r2,-76(fp)
81139b98:	1007883a 	mov	r3,r2
81139b9c:	00a045b4 	movhi	r2,33046
81139ba0:	10bfdb04 	addi	r2,r2,-148
81139ba4:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
81139ba8:	00a045b4 	movhi	r2,33046
81139bac:	10bfdb04 	addi	r2,r2,-148
81139bb0:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
81139bb4:	00a045b4 	movhi	r2,33046
81139bb8:	10bfdb04 	addi	r2,r2,-148
81139bbc:	00ffffc4 	movi	r3,-1
81139bc0:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
81139bc4:	00a045b4 	movhi	r2,33046
81139bc8:	10bfdb04 	addi	r2,r2,-148
81139bcc:	00c00044 	movi	r3,1
81139bd0:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
81139bd4:	e13fff17 	ldw	r4,-4(fp)
81139bd8:	1139c040 	call	81139c04 <alt_up_sd_card_find_next>
81139bdc:	e0bfec0d 	sth	r2,-80(fp)
81139be0:	00000206 	br	81139bec <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
81139be4:	00800044 	movi	r2,1
81139be8:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81139bec:	e0bfec0b 	ldhu	r2,-80(fp)
}
81139bf0:	e037883a 	mov	sp,fp
81139bf4:	dfc00117 	ldw	ra,4(sp)
81139bf8:	df000017 	ldw	fp,0(sp)
81139bfc:	dec00204 	addi	sp,sp,8
81139c00:	f800283a 	ret

81139c04 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
81139c04:	deffe404 	addi	sp,sp,-112
81139c08:	de00012e 	bgeu	sp,et,81139c10 <alt_up_sd_card_find_next+0xc>
81139c0c:	003b68fa 	trap	3
81139c10:	dfc01b15 	stw	ra,108(sp)
81139c14:	df001a15 	stw	fp,104(sp)
81139c18:	df001a04 	addi	fp,sp,104
81139c1c:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
81139c20:	00800084 	movi	r2,2
81139c24:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81139c28:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
81139c2c:	1000df26 	beq	r2,zero,81139fac <alt_up_sd_card_find_next+0x3a8>
81139c30:	d0a09a17 	ldw	r2,-32152(gp)
81139c34:	1000dd26 	beq	r2,zero,81139fac <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81139c38:	00a045b4 	movhi	r2,33046
81139c3c:	10bfdb04 	addi	r2,r2,-148
81139c40:	10800417 	ldw	r2,16(r2)
81139c44:	1000d726 	beq	r2,zero,81139fa4 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81139c48:	00a045b4 	movhi	r2,33046
81139c4c:	10bfdb04 	addi	r2,r2,-148
81139c50:	10800117 	ldw	r2,4(r2)
81139c54:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
81139c58:	e0bfe717 	ldw	r2,-100(fp)
81139c5c:	1000561e 	bne	r2,zero,81139db8 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81139c60:	00a045b4 	movhi	r2,33046
81139c64:	10bfe004 	addi	r2,r2,-128
81139c68:	1080050b 	ldhu	r2,20(r2)
81139c6c:	10bfffcc 	andi	r2,r2,65535
81139c70:	1006917a 	slli	r3,r2,5
81139c74:	00a045b4 	movhi	r2,33046
81139c78:	10bfe004 	addi	r2,r2,-128
81139c7c:	1080030b 	ldhu	r2,12(r2)
81139c80:	10bfffcc 	andi	r2,r2,65535
81139c84:	1885283a 	div	r2,r3,r2
81139c88:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
81139c8c:	00a045b4 	movhi	r2,33046
81139c90:	10bfdb04 	addi	r2,r2,-148
81139c94:	10800217 	ldw	r2,8(r2)
81139c98:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
81139c9c:	00a045b4 	movhi	r2,33046
81139ca0:	10bfdb04 	addi	r2,r2,-148
81139ca4:	1080030b 	ldhu	r2,12(r2)
81139ca8:	10bfffcc 	andi	r2,r2,65535
81139cac:	10a0001c 	xori	r2,r2,32768
81139cb0:	10a00004 	addi	r2,r2,-32768
81139cb4:	10800044 	addi	r2,r2,1
81139cb8:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81139cbc:	00003606 	br	81139d98 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81139cc0:	00a045b4 	movhi	r2,33046
81139cc4:	10bfe004 	addi	r2,r2,-128
81139cc8:	10c01317 	ldw	r3,76(r2)
81139ccc:	e0bfe817 	ldw	r2,-96(fp)
81139cd0:	1885883a 	add	r2,r3,r2
81139cd4:	1007883a 	mov	r3,r2
81139cd8:	d0a0a117 	ldw	r2,-32124(gp)
81139cdc:	100b883a 	mov	r5,r2
81139ce0:	1809883a 	mov	r4,r3
81139ce4:	1136d140 	call	81136d14 <Read_Sector_Data>
81139ce8:	10002f26 	beq	r2,zero,81139da8 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81139cec:	00002306 	br	81139d7c <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81139cf0:	e0bfe917 	ldw	r2,-92(fp)
81139cf4:	1004917a 	slli	r2,r2,5
81139cf8:	e13fe817 	ldw	r4,-96(fp)
81139cfc:	e0ffef04 	addi	r3,fp,-68
81139d00:	200f883a 	mov	r7,r4
81139d04:	000d883a 	mov	r6,zero
81139d08:	180b883a 	mov	r5,r3
81139d0c:	1009883a 	mov	r4,r2
81139d10:	11371440 	call	81137144 <Read_File_Record_At_Offset>
81139d14:	10001626 	beq	r2,zero,81139d70 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81139d18:	e0bfef03 	ldbu	r2,-68(fp)
81139d1c:	10803fcc 	andi	r2,r2,255
81139d20:	10001326 	beq	r2,zero,81139d70 <alt_up_sd_card_find_next+0x16c>
81139d24:	e0bfef03 	ldbu	r2,-68(fp)
81139d28:	10803fcc 	andi	r2,r2,255
81139d2c:	10803960 	cmpeqi	r2,r2,229
81139d30:	10000f1e 	bne	r2,zero,81139d70 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
81139d34:	e0bfe917 	ldw	r2,-92(fp)
81139d38:	1007883a 	mov	r3,r2
81139d3c:	00a045b4 	movhi	r2,33046
81139d40:	10bfdb04 	addi	r2,r2,-148
81139d44:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81139d48:	e0ffe817 	ldw	r3,-96(fp)
81139d4c:	00a045b4 	movhi	r2,33046
81139d50:	10bfdb04 	addi	r2,r2,-148
81139d54:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
81139d58:	e0bfef04 	addi	r2,fp,-68
81139d5c:	e17fff17 	ldw	r5,-4(fp)
81139d60:	1009883a 	mov	r4,r2
81139d64:	11397d80 	call	811397d8 <copy_file_record_name_to_string>
									return 0;
81139d68:	0005883a 	mov	r2,zero
81139d6c:	00009006 	br	81139fb0 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81139d70:	e0bfe917 	ldw	r2,-92(fp)
81139d74:	10800044 	addi	r2,r2,1
81139d78:	e0bfe915 	stw	r2,-92(fp)
81139d7c:	e0bfe917 	ldw	r2,-92(fp)
81139d80:	10800410 	cmplti	r2,r2,16
81139d84:	103fda1e 	bne	r2,zero,81139cf0 <__reset+0xfb119cf0>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
81139d88:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81139d8c:	e0bfe817 	ldw	r2,-96(fp)
81139d90:	10800044 	addi	r2,r2,1
81139d94:	e0bfe815 	stw	r2,-96(fp)
81139d98:	e0ffe817 	ldw	r3,-96(fp)
81139d9c:	e0bfec17 	ldw	r2,-80(fp)
81139da0:	18bfc716 	blt	r3,r2,81139cc0 <__reset+0xfb119cc0>
81139da4:	00000106 	br	81139dac <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
81139da8:	0001883a 	nop
					}
				}
				result = -1;
81139dac:	00bfffc4 	movi	r2,-1
81139db0:	e0bfe60d 	sth	r2,-104(fp)
81139db4:	00007d06 	br	81139fac <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81139db8:	00a045b4 	movhi	r2,33046
81139dbc:	10bfdb04 	addi	r2,r2,-148
81139dc0:	1080030b 	ldhu	r2,12(r2)
81139dc4:	10bfffcc 	andi	r2,r2,65535
81139dc8:	10a0001c 	xori	r2,r2,32768
81139dcc:	10a00004 	addi	r2,r2,-32768
81139dd0:	10800044 	addi	r2,r2,1
81139dd4:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81139dd8:	e0bfe717 	ldw	r2,-100(fp)
81139ddc:	10ffff84 	addi	r3,r2,-2
81139de0:	00a045b4 	movhi	r2,33046
81139de4:	10bfe004 	addi	r2,r2,-128
81139de8:	10800383 	ldbu	r2,14(r2)
81139dec:	10803fcc 	andi	r2,r2,255
81139df0:	1885383a 	mul	r2,r3,r2
81139df4:	1007883a 	mov	r3,r2
81139df8:	00a045b4 	movhi	r2,33046
81139dfc:	10bfe004 	addi	r2,r2,-128
81139e00:	10801417 	ldw	r2,80(r2)
81139e04:	1885883a 	add	r2,r3,r2
81139e08:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81139e0c:	00a045b4 	movhi	r2,33046
81139e10:	10bfdb04 	addi	r2,r2,-148
81139e14:	10800217 	ldw	r2,8(r2)
81139e18:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81139e1c:	00003806 	br	81139f00 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81139e20:	e0ffeb17 	ldw	r3,-84(fp)
81139e24:	e0bfed17 	ldw	r2,-76(fp)
81139e28:	1885883a 	add	r2,r3,r2
81139e2c:	d0e0a117 	ldw	r3,-32124(gp)
81139e30:	180b883a 	mov	r5,r3
81139e34:	1009883a 	mov	r4,r2
81139e38:	1136d140 	call	81136d14 <Read_Sector_Data>
81139e3c:	10003726 	beq	r2,zero,81139f1c <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
81139e40:	00002806 	br	81139ee4 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
81139e44:	e0bfea17 	ldw	r2,-88(fp)
81139e48:	1004917a 	slli	r2,r2,5
81139e4c:	e13fe717 	ldw	r4,-100(fp)
81139e50:	e17feb17 	ldw	r5,-84(fp)
81139e54:	e0ffef04 	addi	r3,fp,-68
81139e58:	280f883a 	mov	r7,r5
81139e5c:	200d883a 	mov	r6,r4
81139e60:	180b883a 	mov	r5,r3
81139e64:	1009883a 	mov	r4,r2
81139e68:	11371440 	call	81137144 <Read_File_Record_At_Offset>
81139e6c:	10001a26 	beq	r2,zero,81139ed8 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81139e70:	e0bfef03 	ldbu	r2,-68(fp)
81139e74:	10803fcc 	andi	r2,r2,255
81139e78:	10001726 	beq	r2,zero,81139ed8 <alt_up_sd_card_find_next+0x2d4>
81139e7c:	e0bfef03 	ldbu	r2,-68(fp)
81139e80:	10803fcc 	andi	r2,r2,255
81139e84:	10803960 	cmpeqi	r2,r2,229
81139e88:	1000131e 	bne	r2,zero,81139ed8 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
81139e8c:	e0ffe717 	ldw	r3,-100(fp)
81139e90:	00a045b4 	movhi	r2,33046
81139e94:	10bfdb04 	addi	r2,r2,-148
81139e98:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
81139e9c:	e0bfea17 	ldw	r2,-88(fp)
81139ea0:	1007883a 	mov	r3,r2
81139ea4:	00a045b4 	movhi	r2,33046
81139ea8:	10bfdb04 	addi	r2,r2,-148
81139eac:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
81139eb0:	e0ffeb17 	ldw	r3,-84(fp)
81139eb4:	00a045b4 	movhi	r2,33046
81139eb8:	10bfdb04 	addi	r2,r2,-148
81139ebc:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
81139ec0:	e0bfef04 	addi	r2,fp,-68
81139ec4:	e17fff17 	ldw	r5,-4(fp)
81139ec8:	1009883a 	mov	r4,r2
81139ecc:	11397d80 	call	811397d8 <copy_file_record_name_to_string>
										return 0;
81139ed0:	0005883a 	mov	r2,zero
81139ed4:	00003606 	br	81139fb0 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81139ed8:	e0bfea17 	ldw	r2,-88(fp)
81139edc:	10800044 	addi	r2,r2,1
81139ee0:	e0bfea15 	stw	r2,-88(fp)
81139ee4:	e0bfea17 	ldw	r2,-88(fp)
81139ee8:	10800410 	cmplti	r2,r2,16
81139eec:	103fd51e 	bne	r2,zero,81139e44 <__reset+0xfb119e44>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
81139ef0:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81139ef4:	e0bfeb17 	ldw	r2,-84(fp)
81139ef8:	10800044 	addi	r2,r2,1
81139efc:	e0bfeb15 	stw	r2,-84(fp)
81139f00:	00a045b4 	movhi	r2,33046
81139f04:	10bfe004 	addi	r2,r2,-128
81139f08:	10800383 	ldbu	r2,14(r2)
81139f0c:	10803fcc 	andi	r2,r2,255
81139f10:	e0ffeb17 	ldw	r3,-84(fp)
81139f14:	18bfc216 	blt	r3,r2,81139e20 <__reset+0xfb119e20>
81139f18:	00000106 	br	81139f20 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
81139f1c:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
81139f20:	00a045b4 	movhi	r2,33046
81139f24:	10bfe004 	addi	r2,r2,-128
81139f28:	10800383 	ldbu	r2,14(r2)
81139f2c:	10803fcc 	andi	r2,r2,255
81139f30:	e0ffeb17 	ldw	r3,-84(fp)
81139f34:	18801716 	blt	r3,r2,81139f94 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
81139f38:	e0bfe717 	ldw	r2,-100(fp)
81139f3c:	e0ffee04 	addi	r3,fp,-72
81139f40:	180b883a 	mov	r5,r3
81139f44:	1009883a 	mov	r4,r2
81139f48:	1136df40 	call	81136df4 <get_cluster_flag>
81139f4c:	10000f26 	beq	r2,zero,81139f8c <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81139f50:	e0bfee0b 	ldhu	r2,-72(fp)
81139f54:	10bfffcc 	andi	r2,r2,65535
81139f58:	10fffe0c 	andi	r3,r2,65528
81139f5c:	00bffe14 	movui	r2,65528
81139f60:	1880051e 	bne	r3,r2,81139f78 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
81139f64:	00bfffc4 	movi	r2,-1
81139f68:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
81139f6c:	00a045b4 	movhi	r2,33046
81139f70:	10bfdb04 	addi	r2,r2,-148
81139f74:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
81139f78:	e0bfee0b 	ldhu	r2,-72(fp)
81139f7c:	10bfffcc 	andi	r2,r2,65535
81139f80:	10bffe0c 	andi	r2,r2,65528
81139f84:	e0bfe715 	stw	r2,-100(fp)
81139f88:	00000206 	br	81139f94 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
81139f8c:	00bfffc4 	movi	r2,-1
81139f90:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
81139f94:	e0bfe717 	ldw	r2,-100(fp)
81139f98:	00fffdd4 	movui	r3,65527
81139f9c:	18bf8e0e 	bge	r3,r2,81139dd8 <__reset+0xfb119dd8>
81139fa0:	00000206 	br	81139fac <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
81139fa4:	008000c4 	movi	r2,3
81139fa8:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
81139fac:	e0bfe60b 	ldhu	r2,-104(fp)
}
81139fb0:	e037883a 	mov	sp,fp
81139fb4:	dfc00117 	ldw	ra,4(sp)
81139fb8:	df000017 	ldw	fp,0(sp)
81139fbc:	dec00204 	addi	sp,sp,8
81139fc0:	f800283a 	ret

81139fc4 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
81139fc4:	deffe904 	addi	sp,sp,-92
81139fc8:	de00012e 	bgeu	sp,et,81139fd0 <alt_up_sd_card_fopen+0xc>
81139fcc:	003b68fa 	trap	3
81139fd0:	dfc01615 	stw	ra,88(sp)
81139fd4:	df001515 	stw	fp,84(sp)
81139fd8:	df001504 	addi	fp,sp,84
81139fdc:	e13ffe15 	stw	r4,-8(fp)
81139fe0:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
81139fe4:	00bfffc4 	movi	r2,-1
81139fe8:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81139fec:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
81139ff0:	1000cf26 	beq	r2,zero,8113a330 <alt_up_sd_card_fopen+0x36c>
81139ff4:	d0a09a17 	ldw	r2,-32152(gp)
81139ff8:	1000cd26 	beq	r2,zero,8113a330 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
81139ffc:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
8113a000:	e13ffe17 	ldw	r4,-8(fp)
8113a004:	1137dd80 	call	81137dd8 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
8113a008:	e13ffe17 	ldw	r4,-8(fp)
8113a00c:	1137ea40 	call	81137ea4 <check_file_name_for_FAT16_compliance>
8113a010:	1000c726 	beq	r2,zero,8113a330 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
8113a014:	e0ffee04 	addi	r3,fp,-72
8113a018:	e0bfed04 	addi	r2,fp,-76
8113a01c:	180d883a 	mov	r6,r3
8113a020:	100b883a 	mov	r5,r2
8113a024:	e13ffe17 	ldw	r4,-8(fp)
8113a028:	113847c0 	call	8113847c <get_home_directory_cluster_for_file>
8113a02c:	1000021e 	bne	r2,zero,8113a038 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
8113a030:	e0bfeb0b 	ldhu	r2,-84(fp)
8113a034:	0000bf06 	br	8113a334 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8113a038:	e03fec15 	stw	zero,-80(fp)
8113a03c:	00000e06 	br	8113a078 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
8113a040:	00a045b4 	movhi	r2,33046
8113a044:	10bff504 	addi	r2,r2,-44
8113a048:	e0ffec17 	ldw	r3,-80(fp)
8113a04c:	180691ba 	slli	r3,r3,6
8113a050:	10c5883a 	add	r2,r2,r3
8113a054:	10800f04 	addi	r2,r2,60
8113a058:	10800017 	ldw	r2,0(r2)
8113a05c:	1000031e 	bne	r2,zero,8113a06c <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
8113a060:	e0bfec17 	ldw	r2,-80(fp)
8113a064:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
8113a068:	00000606 	br	8113a084 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8113a06c:	e0bfec17 	ldw	r2,-80(fp)
8113a070:	10800044 	addi	r2,r2,1
8113a074:	e0bfec15 	stw	r2,-80(fp)
8113a078:	e0bfec17 	ldw	r2,-80(fp)
8113a07c:	10800510 	cmplti	r2,r2,20
8113a080:	103fef1e 	bne	r2,zero,8113a040 <__reset+0xfb11a040>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
8113a084:	e0bfeb0f 	ldh	r2,-84(fp)
8113a088:	1000a916 	blt	r2,zero,8113a330 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
8113a08c:	e0bfed17 	ldw	r2,-76(fp)
8113a090:	1009883a 	mov	r4,r2
8113a094:	e0bfeb0f 	ldh	r2,-84(fp)
8113a098:	100691ba 	slli	r3,r2,6
8113a09c:	00a045b4 	movhi	r2,33046
8113a0a0:	10bff504 	addi	r2,r2,-44
8113a0a4:	1885883a 	add	r2,r3,r2
8113a0a8:	100d883a 	mov	r6,r2
8113a0ac:	e17ffe17 	ldw	r5,-8(fp)
8113a0b0:	11389bc0 	call	811389bc <find_file_in_directory>
8113a0b4:	10007b26 	beq	r2,zero,8113a2a4 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
8113a0b8:	e0bfff17 	ldw	r2,-4(fp)
8113a0bc:	10000226 	beq	r2,zero,8113a0c8 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
8113a0c0:	00bfffc4 	movi	r2,-1
8113a0c4:	00009b06 	br	8113a334 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
8113a0c8:	e13feb0f 	ldh	r4,-84(fp)
8113a0cc:	e0ffeb0f 	ldh	r3,-84(fp)
8113a0d0:	00a045b4 	movhi	r2,33046
8113a0d4:	10bff504 	addi	r2,r2,-44
8113a0d8:	180691ba 	slli	r3,r3,6
8113a0dc:	10c5883a 	add	r2,r2,r3
8113a0e0:	10800584 	addi	r2,r2,22
8113a0e4:	1080000b 	ldhu	r2,0(r2)
8113a0e8:	10ffffcc 	andi	r3,r2,65535
8113a0ec:	00a045b4 	movhi	r2,33046
8113a0f0:	10bff504 	addi	r2,r2,-44
8113a0f4:	200891ba 	slli	r4,r4,6
8113a0f8:	1105883a 	add	r2,r2,r4
8113a0fc:	10800704 	addi	r2,r2,28
8113a100:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
8113a104:	e0ffeb0f 	ldh	r3,-84(fp)
8113a108:	00a045b4 	movhi	r2,33046
8113a10c:	10bff504 	addi	r2,r2,-44
8113a110:	180691ba 	slli	r3,r3,6
8113a114:	10c5883a 	add	r2,r2,r3
8113a118:	10800804 	addi	r2,r2,32
8113a11c:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
8113a120:	e0ffeb0f 	ldh	r3,-84(fp)
8113a124:	00a045b4 	movhi	r2,33046
8113a128:	10bff504 	addi	r2,r2,-44
8113a12c:	180691ba 	slli	r3,r3,6
8113a130:	10c5883a 	add	r2,r2,r3
8113a134:	10800904 	addi	r2,r2,36
8113a138:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
8113a13c:	e0ffeb0f 	ldh	r3,-84(fp)
8113a140:	00a045b4 	movhi	r2,33046
8113a144:	10bff504 	addi	r2,r2,-44
8113a148:	180691ba 	slli	r3,r3,6
8113a14c:	10c5883a 	add	r2,r2,r3
8113a150:	10800f04 	addi	r2,r2,60
8113a154:	00c00044 	movi	r3,1
8113a158:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
8113a15c:	e0ffeb0f 	ldh	r3,-84(fp)
8113a160:	00a045b4 	movhi	r2,33046
8113a164:	10bff504 	addi	r2,r2,-44
8113a168:	180691ba 	slli	r3,r3,6
8113a16c:	10c5883a 	add	r2,r2,r3
8113a170:	10800e04 	addi	r2,r2,56
8113a174:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8113a178:	e03fec15 	stw	zero,-80(fp)
8113a17c:	00004506 	br	8113a294 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
8113a180:	e0ffeb0f 	ldh	r3,-84(fp)
8113a184:	e0bfec17 	ldw	r2,-80(fp)
8113a188:	18803f26 	beq	r3,r2,8113a288 <alt_up_sd_card_fopen+0x2c4>
8113a18c:	00a045b4 	movhi	r2,33046
8113a190:	10bff504 	addi	r2,r2,-44
8113a194:	e0ffec17 	ldw	r3,-80(fp)
8113a198:	180691ba 	slli	r3,r3,6
8113a19c:	10c5883a 	add	r2,r2,r3
8113a1a0:	10800f04 	addi	r2,r2,60
8113a1a4:	10800017 	ldw	r2,0(r2)
8113a1a8:	10800058 	cmpnei	r2,r2,1
8113a1ac:	1000361e 	bne	r2,zero,8113a288 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113a1b0:	e0ffeb0f 	ldh	r3,-84(fp)
8113a1b4:	00a045b4 	movhi	r2,33046
8113a1b8:	10bff504 	addi	r2,r2,-44
8113a1bc:	180691ba 	slli	r3,r3,6
8113a1c0:	10c5883a 	add	r2,r2,r3
8113a1c4:	10800a04 	addi	r2,r2,40
8113a1c8:	10c00017 	ldw	r3,0(r2)
8113a1cc:	00a045b4 	movhi	r2,33046
8113a1d0:	10bff504 	addi	r2,r2,-44
8113a1d4:	e13fec17 	ldw	r4,-80(fp)
8113a1d8:	200891ba 	slli	r4,r4,6
8113a1dc:	1105883a 	add	r2,r2,r4
8113a1e0:	10800a04 	addi	r2,r2,40
8113a1e4:	10800017 	ldw	r2,0(r2)
8113a1e8:	1880271e 	bne	r3,r2,8113a288 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113a1ec:	e0ffeb0f 	ldh	r3,-84(fp)
8113a1f0:	00a045b4 	movhi	r2,33046
8113a1f4:	10bff504 	addi	r2,r2,-44
8113a1f8:	180691ba 	slli	r3,r3,6
8113a1fc:	10c5883a 	add	r2,r2,r3
8113a200:	10800b04 	addi	r2,r2,44
8113a204:	10c00017 	ldw	r3,0(r2)
8113a208:	00a045b4 	movhi	r2,33046
8113a20c:	10bff504 	addi	r2,r2,-44
8113a210:	e13fec17 	ldw	r4,-80(fp)
8113a214:	200891ba 	slli	r4,r4,6
8113a218:	1105883a 	add	r2,r2,r4
8113a21c:	10800b04 	addi	r2,r2,44
8113a220:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113a224:	1880181e 	bne	r3,r2,8113a288 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
8113a228:	e0ffeb0f 	ldh	r3,-84(fp)
8113a22c:	00a045b4 	movhi	r2,33046
8113a230:	10bff504 	addi	r2,r2,-44
8113a234:	180691ba 	slli	r3,r3,6
8113a238:	10c5883a 	add	r2,r2,r3
8113a23c:	10800c04 	addi	r2,r2,48
8113a240:	1100000b 	ldhu	r4,0(r2)
8113a244:	00a045b4 	movhi	r2,33046
8113a248:	10bff504 	addi	r2,r2,-44
8113a24c:	e0ffec17 	ldw	r3,-80(fp)
8113a250:	180691ba 	slli	r3,r3,6
8113a254:	10c5883a 	add	r2,r2,r3
8113a258:	10800c04 	addi	r2,r2,48
8113a25c:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113a260:	20ffffcc 	andi	r3,r4,65535
8113a264:	18e0001c 	xori	r3,r3,32768
8113a268:	18e00004 	addi	r3,r3,-32768
8113a26c:	10bfffcc 	andi	r2,r2,65535
8113a270:	10a0001c 	xori	r2,r2,32768
8113a274:	10a00004 	addi	r2,r2,-32768
8113a278:	1880031e 	bne	r3,r2,8113a288 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
8113a27c:	00bfff84 	movi	r2,-2
8113a280:	e0bfeb0d 	sth	r2,-84(fp)
								break;
8113a284:	00002a06 	br	8113a330 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8113a288:	e0bfec17 	ldw	r2,-80(fp)
8113a28c:	10800044 	addi	r2,r2,1
8113a290:	e0bfec15 	stw	r2,-80(fp)
8113a294:	e0bfec17 	ldw	r2,-80(fp)
8113a298:	10800510 	cmplti	r2,r2,20
8113a29c:	103fb81e 	bne	r2,zero,8113a180 <__reset+0xfb11a180>
8113a2a0:	00002306 	br	8113a330 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
8113a2a4:	e0bfff17 	ldw	r2,-4(fp)
8113a2a8:	10001f26 	beq	r2,zero,8113a328 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
8113a2ac:	e0bfeb0f 	ldh	r2,-84(fp)
8113a2b0:	100691ba 	slli	r3,r2,6
8113a2b4:	00a045b4 	movhi	r2,33046
8113a2b8:	10bff504 	addi	r2,r2,-44
8113a2bc:	1885883a 	add	r2,r3,r2
8113a2c0:	e0ffee04 	addi	r3,fp,-72
8113a2c4:	180d883a 	mov	r6,r3
8113a2c8:	100b883a 	mov	r5,r2
8113a2cc:	e13ffe17 	ldw	r4,-8(fp)
8113a2d0:	11395080 	call	81139508 <create_file>
8113a2d4:	10001126 	beq	r2,zero,8113a31c <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
8113a2d8:	e0ffeb0f 	ldh	r3,-84(fp)
8113a2dc:	00a045b4 	movhi	r2,33046
8113a2e0:	10bff504 	addi	r2,r2,-44
8113a2e4:	180691ba 	slli	r3,r3,6
8113a2e8:	10c5883a 	add	r2,r2,r3
8113a2ec:	10800f04 	addi	r2,r2,60
8113a2f0:	00c00044 	movi	r3,1
8113a2f4:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
8113a2f8:	e0ffeb0f 	ldh	r3,-84(fp)
8113a2fc:	00a045b4 	movhi	r2,33046
8113a300:	10bff504 	addi	r2,r2,-44
8113a304:	180691ba 	slli	r3,r3,6
8113a308:	10c5883a 	add	r2,r2,r3
8113a30c:	10800e04 	addi	r2,r2,56
8113a310:	00c00044 	movi	r3,1
8113a314:	10c00015 	stw	r3,0(r2)
8113a318:	00000506 	br	8113a330 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
8113a31c:	00bfffc4 	movi	r2,-1
8113a320:	e0bfeb0d 	sth	r2,-84(fp)
8113a324:	00000206 	br	8113a330 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
8113a328:	00bfffc4 	movi	r2,-1
8113a32c:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
8113a330:	e0bfeb0b 	ldhu	r2,-84(fp)
}
8113a334:	e037883a 	mov	sp,fp
8113a338:	dfc00117 	ldw	ra,4(sp)
8113a33c:	df000017 	ldw	fp,0(sp)
8113a340:	dec00204 	addi	sp,sp,8
8113a344:	f800283a 	ret

8113a348 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8113a348:	defffd04 	addi	sp,sp,-12
8113a34c:	de00012e 	bgeu	sp,et,8113a354 <alt_up_sd_card_set_attributes+0xc>
8113a350:	003b68fa 	trap	3
8113a354:	df000215 	stw	fp,8(sp)
8113a358:	df000204 	addi	fp,sp,8
8113a35c:	2007883a 	mov	r3,r4
8113a360:	2805883a 	mov	r2,r5
8113a364:	e0fffe0d 	sth	r3,-8(fp)
8113a368:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113a36c:	e0bffe0f 	ldh	r2,-8(fp)
8113a370:	10001416 	blt	r2,zero,8113a3c4 <alt_up_sd_card_set_attributes+0x7c>
8113a374:	e0bffe0f 	ldh	r2,-8(fp)
8113a378:	10800508 	cmpgei	r2,r2,20
8113a37c:	1000111e 	bne	r2,zero,8113a3c4 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8113a380:	e0fffe0f 	ldh	r3,-8(fp)
8113a384:	00a045b4 	movhi	r2,33046
8113a388:	10bff504 	addi	r2,r2,-44
8113a38c:	180691ba 	slli	r3,r3,6
8113a390:	10c5883a 	add	r2,r2,r3
8113a394:	10800f04 	addi	r2,r2,60
8113a398:	10800017 	ldw	r2,0(r2)
8113a39c:	10000926 	beq	r2,zero,8113a3c4 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
8113a3a0:	e0fffe0f 	ldh	r3,-8(fp)
8113a3a4:	e0bfff0b 	ldhu	r2,-4(fp)
8113a3a8:	1009883a 	mov	r4,r2
8113a3ac:	00a045b4 	movhi	r2,33046
8113a3b0:	10bff504 	addi	r2,r2,-44
8113a3b4:	180691ba 	slli	r3,r3,6
8113a3b8:	10c5883a 	add	r2,r2,r3
8113a3bc:	108002c4 	addi	r2,r2,11
8113a3c0:	11000005 	stb	r4,0(r2)
        }
    }
}
8113a3c4:	0001883a 	nop
8113a3c8:	e037883a 	mov	sp,fp
8113a3cc:	df000017 	ldw	fp,0(sp)
8113a3d0:	dec00104 	addi	sp,sp,4
8113a3d4:	f800283a 	ret

8113a3d8 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8113a3d8:	defffd04 	addi	sp,sp,-12
8113a3dc:	de00012e 	bgeu	sp,et,8113a3e4 <alt_up_sd_card_get_attributes+0xc>
8113a3e0:	003b68fa 	trap	3
8113a3e4:	df000215 	stw	fp,8(sp)
8113a3e8:	df000204 	addi	fp,sp,8
8113a3ec:	2005883a 	mov	r2,r4
8113a3f0:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
8113a3f4:	00bfffc4 	movi	r2,-1
8113a3f8:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113a3fc:	e0bfff0f 	ldh	r2,-4(fp)
8113a400:	10001416 	blt	r2,zero,8113a454 <alt_up_sd_card_get_attributes+0x7c>
8113a404:	e0bfff0f 	ldh	r2,-4(fp)
8113a408:	10800508 	cmpgei	r2,r2,20
8113a40c:	1000111e 	bne	r2,zero,8113a454 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8113a410:	e0ffff0f 	ldh	r3,-4(fp)
8113a414:	00a045b4 	movhi	r2,33046
8113a418:	10bff504 	addi	r2,r2,-44
8113a41c:	180691ba 	slli	r3,r3,6
8113a420:	10c5883a 	add	r2,r2,r3
8113a424:	10800f04 	addi	r2,r2,60
8113a428:	10800017 	ldw	r2,0(r2)
8113a42c:	10000926 	beq	r2,zero,8113a454 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
8113a430:	e0ffff0f 	ldh	r3,-4(fp)
8113a434:	00a045b4 	movhi	r2,33046
8113a438:	10bff504 	addi	r2,r2,-44
8113a43c:	180691ba 	slli	r3,r3,6
8113a440:	10c5883a 	add	r2,r2,r3
8113a444:	108002c4 	addi	r2,r2,11
8113a448:	10800003 	ldbu	r2,0(r2)
8113a44c:	10803fcc 	andi	r2,r2,255
8113a450:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
8113a454:	e0bffe0b 	ldhu	r2,-8(fp)
}
8113a458:	e037883a 	mov	sp,fp
8113a45c:	df000017 	ldw	fp,0(sp)
8113a460:	dec00104 	addi	sp,sp,4
8113a464:	f800283a 	ret

8113a468 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
8113a468:	defffa04 	addi	sp,sp,-24
8113a46c:	de00012e 	bgeu	sp,et,8113a474 <alt_up_sd_card_read+0xc>
8113a470:	003b68fa 	trap	3
8113a474:	dfc00515 	stw	ra,20(sp)
8113a478:	df000415 	stw	fp,16(sp)
8113a47c:	df000404 	addi	fp,sp,16
8113a480:	2005883a 	mov	r2,r4
8113a484:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
8113a488:	00bfffc4 	movi	r2,-1
8113a48c:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113a490:	e0bfff0f 	ldh	r2,-4(fp)
8113a494:	1000ce16 	blt	r2,zero,8113a7d0 <alt_up_sd_card_read+0x368>
8113a498:	e0bfff0f 	ldh	r2,-4(fp)
8113a49c:	10800508 	cmpgei	r2,r2,20
8113a4a0:	1000cb1e 	bne	r2,zero,8113a7d0 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
8113a4a4:	e0ffff0f 	ldh	r3,-4(fp)
8113a4a8:	00a045b4 	movhi	r2,33046
8113a4ac:	10bff504 	addi	r2,r2,-44
8113a4b0:	180691ba 	slli	r3,r3,6
8113a4b4:	10c5883a 	add	r2,r2,r3
8113a4b8:	10800f04 	addi	r2,r2,60
8113a4bc:	10800017 	ldw	r2,0(r2)
8113a4c0:	1000c326 	beq	r2,zero,8113a7d0 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
8113a4c4:	e0ffff0f 	ldh	r3,-4(fp)
8113a4c8:	00a045b4 	movhi	r2,33046
8113a4cc:	10bff504 	addi	r2,r2,-44
8113a4d0:	180691ba 	slli	r3,r3,6
8113a4d4:	10c5883a 	add	r2,r2,r3
8113a4d8:	10800904 	addi	r2,r2,36
8113a4dc:	10c00017 	ldw	r3,0(r2)
8113a4e0:	e13fff0f 	ldh	r4,-4(fp)
8113a4e4:	00a045b4 	movhi	r2,33046
8113a4e8:	10bff504 	addi	r2,r2,-44
8113a4ec:	200891ba 	slli	r4,r4,6
8113a4f0:	1105883a 	add	r2,r2,r4
8113a4f4:	10800604 	addi	r2,r2,24
8113a4f8:	10800017 	ldw	r2,0(r2)
8113a4fc:	1880b42e 	bgeu	r3,r2,8113a7d0 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113a500:	00a045b4 	movhi	r2,33046
8113a504:	10bfe004 	addi	r2,r2,-128
8113a508:	10c01417 	ldw	r3,80(r2)
8113a50c:	e13fff0f 	ldh	r4,-4(fp)
8113a510:	00a045b4 	movhi	r2,33046
8113a514:	10bff504 	addi	r2,r2,-44
8113a518:	200891ba 	slli	r4,r4,6
8113a51c:	1105883a 	add	r2,r2,r4
8113a520:	10800704 	addi	r2,r2,28
8113a524:	10800017 	ldw	r2,0(r2)
8113a528:	113fff84 	addi	r4,r2,-2
8113a52c:	00a045b4 	movhi	r2,33046
8113a530:	10bfe004 	addi	r2,r2,-128
8113a534:	10800383 	ldbu	r2,14(r2)
8113a538:	10803fcc 	andi	r2,r2,255
8113a53c:	2085383a 	mul	r2,r4,r2
8113a540:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
8113a544:	e13fff0f 	ldh	r4,-4(fp)
8113a548:	00a045b4 	movhi	r2,33046
8113a54c:	10bff504 	addi	r2,r2,-44
8113a550:	200891ba 	slli	r4,r4,6
8113a554:	1105883a 	add	r2,r2,r4
8113a558:	10800804 	addi	r2,r2,32
8113a55c:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113a560:	1885883a 	add	r2,r3,r2
8113a564:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
8113a568:	e0ffff0f 	ldh	r3,-4(fp)
8113a56c:	00a045b4 	movhi	r2,33046
8113a570:	10bff504 	addi	r2,r2,-44
8113a574:	180691ba 	slli	r3,r3,6
8113a578:	10c5883a 	add	r2,r2,r3
8113a57c:	10800904 	addi	r2,r2,36
8113a580:	10800017 	ldw	r2,0(r2)
8113a584:	10006826 	beq	r2,zero,8113a728 <alt_up_sd_card_read+0x2c0>
8113a588:	e0ffff0f 	ldh	r3,-4(fp)
8113a58c:	00a045b4 	movhi	r2,33046
8113a590:	10bff504 	addi	r2,r2,-44
8113a594:	180691ba 	slli	r3,r3,6
8113a598:	10c5883a 	add	r2,r2,r3
8113a59c:	10800904 	addi	r2,r2,36
8113a5a0:	10800017 	ldw	r2,0(r2)
8113a5a4:	10807fcc 	andi	r2,r2,511
8113a5a8:	10005f1e 	bne	r2,zero,8113a728 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113a5ac:	e0ffff0f 	ldh	r3,-4(fp)
8113a5b0:	00a045b4 	movhi	r2,33046
8113a5b4:	10bff504 	addi	r2,r2,-44
8113a5b8:	180691ba 	slli	r3,r3,6
8113a5bc:	10c5883a 	add	r2,r2,r3
8113a5c0:	10800804 	addi	r2,r2,32
8113a5c4:	10c00017 	ldw	r3,0(r2)
8113a5c8:	00a045b4 	movhi	r2,33046
8113a5cc:	10bfe004 	addi	r2,r2,-128
8113a5d0:	10800383 	ldbu	r2,14(r2)
8113a5d4:	10803fcc 	andi	r2,r2,255
8113a5d8:	10bfffc4 	addi	r2,r2,-1
8113a5dc:	1880401e 	bne	r3,r2,8113a6e0 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
8113a5e0:	e0ffff0f 	ldh	r3,-4(fp)
8113a5e4:	00a045b4 	movhi	r2,33046
8113a5e8:	10bff504 	addi	r2,r2,-44
8113a5ec:	180691ba 	slli	r3,r3,6
8113a5f0:	10c5883a 	add	r2,r2,r3
8113a5f4:	10800704 	addi	r2,r2,28
8113a5f8:	10800017 	ldw	r2,0(r2)
8113a5fc:	e0fffe04 	addi	r3,fp,-8
8113a600:	180b883a 	mov	r5,r3
8113a604:	1009883a 	mov	r4,r2
8113a608:	1136df40 	call	81136df4 <get_cluster_flag>
8113a60c:	10003226 	beq	r2,zero,8113a6d8 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8113a610:	e0bffe0b 	ldhu	r2,-8(fp)
8113a614:	10bfffcc 	andi	r2,r2,65535
8113a618:	10fffe0c 	andi	r3,r2,65528
8113a61c:	00bffe14 	movui	r2,65528
8113a620:	1880021e 	bne	r3,r2,8113a62c <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
8113a624:	00bfffc4 	movi	r2,-1
8113a628:	00006a06 	br	8113a7d4 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
8113a62c:	e13fff0f 	ldh	r4,-4(fp)
8113a630:	e0bffe0b 	ldhu	r2,-8(fp)
8113a634:	10ffffcc 	andi	r3,r2,65535
8113a638:	00a045b4 	movhi	r2,33046
8113a63c:	10bff504 	addi	r2,r2,-44
8113a640:	200891ba 	slli	r4,r4,6
8113a644:	1105883a 	add	r2,r2,r4
8113a648:	10800704 	addi	r2,r2,28
8113a64c:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
8113a650:	e0ffff0f 	ldh	r3,-4(fp)
8113a654:	00a045b4 	movhi	r2,33046
8113a658:	10bff504 	addi	r2,r2,-44
8113a65c:	180691ba 	slli	r3,r3,6
8113a660:	10c5883a 	add	r2,r2,r3
8113a664:	10800804 	addi	r2,r2,32
8113a668:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113a66c:	00a045b4 	movhi	r2,33046
8113a670:	10bfe004 	addi	r2,r2,-128
8113a674:	10c01417 	ldw	r3,80(r2)
8113a678:	e13fff0f 	ldh	r4,-4(fp)
8113a67c:	00a045b4 	movhi	r2,33046
8113a680:	10bff504 	addi	r2,r2,-44
8113a684:	200891ba 	slli	r4,r4,6
8113a688:	1105883a 	add	r2,r2,r4
8113a68c:	10800704 	addi	r2,r2,28
8113a690:	10800017 	ldw	r2,0(r2)
8113a694:	113fff84 	addi	r4,r2,-2
8113a698:	00a045b4 	movhi	r2,33046
8113a69c:	10bfe004 	addi	r2,r2,-128
8113a6a0:	10800383 	ldbu	r2,14(r2)
8113a6a4:	10803fcc 	andi	r2,r2,255
8113a6a8:	2085383a 	mul	r2,r4,r2
8113a6ac:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
8113a6b0:	e13fff0f 	ldh	r4,-4(fp)
8113a6b4:	00a045b4 	movhi	r2,33046
8113a6b8:	10bff504 	addi	r2,r2,-44
8113a6bc:	200891ba 	slli	r4,r4,6
8113a6c0:	1105883a 	add	r2,r2,r4
8113a6c4:	10800804 	addi	r2,r2,32
8113a6c8:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113a6cc:	1885883a 	add	r2,r3,r2
8113a6d0:	e0bffd15 	stw	r2,-12(fp)
8113a6d4:	00001406 	br	8113a728 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
8113a6d8:	00bfff84 	movi	r2,-2
8113a6dc:	00003d06 	br	8113a7d4 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
8113a6e0:	e13fff0f 	ldh	r4,-4(fp)
8113a6e4:	e0ffff0f 	ldh	r3,-4(fp)
8113a6e8:	00a045b4 	movhi	r2,33046
8113a6ec:	10bff504 	addi	r2,r2,-44
8113a6f0:	180691ba 	slli	r3,r3,6
8113a6f4:	10c5883a 	add	r2,r2,r3
8113a6f8:	10800804 	addi	r2,r2,32
8113a6fc:	10800017 	ldw	r2,0(r2)
8113a700:	10c00044 	addi	r3,r2,1
8113a704:	00a045b4 	movhi	r2,33046
8113a708:	10bff504 	addi	r2,r2,-44
8113a70c:	200891ba 	slli	r4,r4,6
8113a710:	1105883a 	add	r2,r2,r4
8113a714:	10800804 	addi	r2,r2,32
8113a718:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
8113a71c:	e0bffd17 	ldw	r2,-12(fp)
8113a720:	10800044 	addi	r2,r2,1
8113a724:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
8113a728:	d0e0a117 	ldw	r3,-32124(gp)
8113a72c:	e0bffd17 	ldw	r2,-12(fp)
8113a730:	1885883a 	add	r2,r3,r2
8113a734:	1007883a 	mov	r3,r2
8113a738:	d0a0a517 	ldw	r2,-32108(gp)
8113a73c:	18800726 	beq	r3,r2,8113a75c <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8113a740:	d0a0a117 	ldw	r2,-32124(gp)
8113a744:	100b883a 	mov	r5,r2
8113a748:	e13ffd17 	ldw	r4,-12(fp)
8113a74c:	1136d140 	call	81136d14 <Read_Sector_Data>
8113a750:	1000021e 	bne	r2,zero,8113a75c <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
8113a754:	00bfff84 	movi	r2,-2
8113a758:	00001e06 	br	8113a7d4 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
8113a75c:	d0e0a017 	ldw	r3,-32128(gp)
8113a760:	e13fff0f 	ldh	r4,-4(fp)
8113a764:	00a045b4 	movhi	r2,33046
8113a768:	10bff504 	addi	r2,r2,-44
8113a76c:	200891ba 	slli	r4,r4,6
8113a770:	1105883a 	add	r2,r2,r4
8113a774:	10800904 	addi	r2,r2,36
8113a778:	10800017 	ldw	r2,0(r2)
8113a77c:	10807fcc 	andi	r2,r2,511
8113a780:	1885883a 	add	r2,r3,r2
8113a784:	10800023 	ldbuio	r2,0(r2)
8113a788:	10803fcc 	andi	r2,r2,255
8113a78c:	10803fcc 	andi	r2,r2,255
8113a790:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8113a794:	e13fff0f 	ldh	r4,-4(fp)
8113a798:	e0ffff0f 	ldh	r3,-4(fp)
8113a79c:	00a045b4 	movhi	r2,33046
8113a7a0:	10bff504 	addi	r2,r2,-44
8113a7a4:	180691ba 	slli	r3,r3,6
8113a7a8:	10c5883a 	add	r2,r2,r3
8113a7ac:	10800904 	addi	r2,r2,36
8113a7b0:	10800017 	ldw	r2,0(r2)
8113a7b4:	10c00044 	addi	r3,r2,1
8113a7b8:	00a045b4 	movhi	r2,33046
8113a7bc:	10bff504 	addi	r2,r2,-44
8113a7c0:	200891ba 	slli	r4,r4,6
8113a7c4:	1105883a 	add	r2,r2,r4
8113a7c8:	10800904 	addi	r2,r2,36
8113a7cc:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
8113a7d0:	e0bffc0b 	ldhu	r2,-16(fp)
}
8113a7d4:	e037883a 	mov	sp,fp
8113a7d8:	dfc00117 	ldw	ra,4(sp)
8113a7dc:	df000017 	ldw	fp,0(sp)
8113a7e0:	dec00204 	addi	sp,sp,8
8113a7e4:	f800283a 	ret

8113a7e8 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
8113a7e8:	defff804 	addi	sp,sp,-32
8113a7ec:	de00012e 	bgeu	sp,et,8113a7f4 <alt_up_sd_card_write+0xc>
8113a7f0:	003b68fa 	trap	3
8113a7f4:	dfc00715 	stw	ra,28(sp)
8113a7f8:	df000615 	stw	fp,24(sp)
8113a7fc:	df000604 	addi	fp,sp,24
8113a800:	2007883a 	mov	r3,r4
8113a804:	2805883a 	mov	r2,r5
8113a808:	e0fffe0d 	sth	r3,-8(fp)
8113a80c:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
8113a810:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113a814:	e0bffe0f 	ldh	r2,-8(fp)
8113a818:	10017716 	blt	r2,zero,8113adf8 <alt_up_sd_card_write+0x610>
8113a81c:	e0bffe0f 	ldh	r2,-8(fp)
8113a820:	10800508 	cmpgei	r2,r2,20
8113a824:	1001741e 	bne	r2,zero,8113adf8 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
8113a828:	e0fffe0f 	ldh	r3,-8(fp)
8113a82c:	00a045b4 	movhi	r2,33046
8113a830:	10bff504 	addi	r2,r2,-44
8113a834:	180691ba 	slli	r3,r3,6
8113a838:	10c5883a 	add	r2,r2,r3
8113a83c:	10800f04 	addi	r2,r2,60
8113a840:	10800017 	ldw	r2,0(r2)
8113a844:	10016c26 	beq	r2,zero,8113adf8 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113a848:	00a045b4 	movhi	r2,33046
8113a84c:	10bfe004 	addi	r2,r2,-128
8113a850:	10c01417 	ldw	r3,80(r2)
8113a854:	e13ffe0f 	ldh	r4,-8(fp)
8113a858:	00a045b4 	movhi	r2,33046
8113a85c:	10bff504 	addi	r2,r2,-44
8113a860:	200891ba 	slli	r4,r4,6
8113a864:	1105883a 	add	r2,r2,r4
8113a868:	10800704 	addi	r2,r2,28
8113a86c:	10800017 	ldw	r2,0(r2)
8113a870:	113fff84 	addi	r4,r2,-2
8113a874:	00a045b4 	movhi	r2,33046
8113a878:	10bfe004 	addi	r2,r2,-128
8113a87c:	10800383 	ldbu	r2,14(r2)
8113a880:	10803fcc 	andi	r2,r2,255
8113a884:	2085383a 	mul	r2,r4,r2
8113a888:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
8113a88c:	e13ffe0f 	ldh	r4,-8(fp)
8113a890:	00a045b4 	movhi	r2,33046
8113a894:	10bff504 	addi	r2,r2,-44
8113a898:	200891ba 	slli	r4,r4,6
8113a89c:	1105883a 	add	r2,r2,r4
8113a8a0:	10800804 	addi	r2,r2,32
8113a8a4:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113a8a8:	1885883a 	add	r2,r3,r2
8113a8ac:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
8113a8b0:	e0fffe0f 	ldh	r3,-8(fp)
8113a8b4:	00a045b4 	movhi	r2,33046
8113a8b8:	10bff504 	addi	r2,r2,-44
8113a8bc:	180691ba 	slli	r3,r3,6
8113a8c0:	10c5883a 	add	r2,r2,r3
8113a8c4:	10800904 	addi	r2,r2,36
8113a8c8:	10c00017 	ldw	r3,0(r2)
8113a8cc:	00a045b4 	movhi	r2,33046
8113a8d0:	10bfe004 	addi	r2,r2,-128
8113a8d4:	1080030b 	ldhu	r2,12(r2)
8113a8d8:	10bfffcc 	andi	r2,r2,65535
8113a8dc:	1889203a 	divu	r4,r3,r2
8113a8e0:	2085383a 	mul	r2,r4,r2
8113a8e4:	1885c83a 	sub	r2,r3,r2
8113a8e8:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
8113a8ec:	e0fffe0f 	ldh	r3,-8(fp)
8113a8f0:	00a045b4 	movhi	r2,33046
8113a8f4:	10bff504 	addi	r2,r2,-44
8113a8f8:	180691ba 	slli	r3,r3,6
8113a8fc:	10c5883a 	add	r2,r2,r3
8113a900:	10800904 	addi	r2,r2,36
8113a904:	10c00017 	ldw	r3,0(r2)
8113a908:	e13ffe0f 	ldh	r4,-8(fp)
8113a90c:	00a045b4 	movhi	r2,33046
8113a910:	10bff504 	addi	r2,r2,-44
8113a914:	200891ba 	slli	r4,r4,6
8113a918:	1105883a 	add	r2,r2,r4
8113a91c:	10800604 	addi	r2,r2,24
8113a920:	10800017 	ldw	r2,0(r2)
8113a924:	1880672e 	bgeu	r3,r2,8113aac4 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8113a928:	e0fffe0f 	ldh	r3,-8(fp)
8113a92c:	00a045b4 	movhi	r2,33046
8113a930:	10bff504 	addi	r2,r2,-44
8113a934:	180691ba 	slli	r3,r3,6
8113a938:	10c5883a 	add	r2,r2,r3
8113a93c:	10800904 	addi	r2,r2,36
8113a940:	10800017 	ldw	r2,0(r2)
8113a944:	1000e126 	beq	r2,zero,8113accc <alt_up_sd_card_write+0x4e4>
8113a948:	e0bffc0f 	ldh	r2,-16(fp)
8113a94c:	1000df1e 	bne	r2,zero,8113accc <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113a950:	e0fffe0f 	ldh	r3,-8(fp)
8113a954:	00a045b4 	movhi	r2,33046
8113a958:	10bff504 	addi	r2,r2,-44
8113a95c:	180691ba 	slli	r3,r3,6
8113a960:	10c5883a 	add	r2,r2,r3
8113a964:	10800804 	addi	r2,r2,32
8113a968:	10c00017 	ldw	r3,0(r2)
8113a96c:	00a045b4 	movhi	r2,33046
8113a970:	10bfe004 	addi	r2,r2,-128
8113a974:	10800383 	ldbu	r2,14(r2)
8113a978:	10803fcc 	andi	r2,r2,255
8113a97c:	10bfffc4 	addi	r2,r2,-1
8113a980:	18803d1e 	bne	r3,r2,8113aa78 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
8113a984:	e0fffe0f 	ldh	r3,-8(fp)
8113a988:	00a045b4 	movhi	r2,33046
8113a98c:	10bff504 	addi	r2,r2,-44
8113a990:	180691ba 	slli	r3,r3,6
8113a994:	10c5883a 	add	r2,r2,r3
8113a998:	10800704 	addi	r2,r2,28
8113a99c:	10800017 	ldw	r2,0(r2)
8113a9a0:	e0fffc84 	addi	r3,fp,-14
8113a9a4:	180b883a 	mov	r5,r3
8113a9a8:	1009883a 	mov	r4,r2
8113a9ac:	1136df40 	call	81136df4 <get_cluster_flag>
8113a9b0:	10002f26 	beq	r2,zero,8113aa70 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
8113a9b4:	e0bffc8b 	ldhu	r2,-14(fp)
8113a9b8:	10bfffcc 	andi	r2,r2,65535
8113a9bc:	10bffe28 	cmpgeui	r2,r2,65528
8113a9c0:	1000c21e 	bne	r2,zero,8113accc <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
8113a9c4:	e13ffe0f 	ldh	r4,-8(fp)
8113a9c8:	e0bffc8b 	ldhu	r2,-14(fp)
8113a9cc:	10ffffcc 	andi	r3,r2,65535
8113a9d0:	00a045b4 	movhi	r2,33046
8113a9d4:	10bff504 	addi	r2,r2,-44
8113a9d8:	200891ba 	slli	r4,r4,6
8113a9dc:	1105883a 	add	r2,r2,r4
8113a9e0:	10800704 	addi	r2,r2,28
8113a9e4:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
8113a9e8:	e0fffe0f 	ldh	r3,-8(fp)
8113a9ec:	00a045b4 	movhi	r2,33046
8113a9f0:	10bff504 	addi	r2,r2,-44
8113a9f4:	180691ba 	slli	r3,r3,6
8113a9f8:	10c5883a 	add	r2,r2,r3
8113a9fc:	10800804 	addi	r2,r2,32
8113aa00:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113aa04:	00a045b4 	movhi	r2,33046
8113aa08:	10bfe004 	addi	r2,r2,-128
8113aa0c:	10c01417 	ldw	r3,80(r2)
8113aa10:	e13ffe0f 	ldh	r4,-8(fp)
8113aa14:	00a045b4 	movhi	r2,33046
8113aa18:	10bff504 	addi	r2,r2,-44
8113aa1c:	200891ba 	slli	r4,r4,6
8113aa20:	1105883a 	add	r2,r2,r4
8113aa24:	10800704 	addi	r2,r2,28
8113aa28:	10800017 	ldw	r2,0(r2)
8113aa2c:	113fff84 	addi	r4,r2,-2
8113aa30:	00a045b4 	movhi	r2,33046
8113aa34:	10bfe004 	addi	r2,r2,-128
8113aa38:	10800383 	ldbu	r2,14(r2)
8113aa3c:	10803fcc 	andi	r2,r2,255
8113aa40:	2085383a 	mul	r2,r4,r2
8113aa44:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
8113aa48:	e13ffe0f 	ldh	r4,-8(fp)
8113aa4c:	00a045b4 	movhi	r2,33046
8113aa50:	10bff504 	addi	r2,r2,-44
8113aa54:	200891ba 	slli	r4,r4,6
8113aa58:	1105883a 	add	r2,r2,r4
8113aa5c:	10800804 	addi	r2,r2,32
8113aa60:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113aa64:	1885883a 	add	r2,r3,r2
8113aa68:	e0bffb15 	stw	r2,-20(fp)
8113aa6c:	00009706 	br	8113accc <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
8113aa70:	0005883a 	mov	r2,zero
8113aa74:	0000e106 	br	8113adfc <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
8113aa78:	e13ffe0f 	ldh	r4,-8(fp)
8113aa7c:	e0fffe0f 	ldh	r3,-8(fp)
8113aa80:	00a045b4 	movhi	r2,33046
8113aa84:	10bff504 	addi	r2,r2,-44
8113aa88:	180691ba 	slli	r3,r3,6
8113aa8c:	10c5883a 	add	r2,r2,r3
8113aa90:	10800804 	addi	r2,r2,32
8113aa94:	10800017 	ldw	r2,0(r2)
8113aa98:	10c00044 	addi	r3,r2,1
8113aa9c:	00a045b4 	movhi	r2,33046
8113aaa0:	10bff504 	addi	r2,r2,-44
8113aaa4:	200891ba 	slli	r4,r4,6
8113aaa8:	1105883a 	add	r2,r2,r4
8113aaac:	10800804 	addi	r2,r2,32
8113aab0:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
8113aab4:	e0bffb17 	ldw	r2,-20(fp)
8113aab8:	10800044 	addi	r2,r2,1
8113aabc:	e0bffb15 	stw	r2,-20(fp)
8113aac0:	00008206 	br	8113accc <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8113aac4:	e0fffe0f 	ldh	r3,-8(fp)
8113aac8:	00a045b4 	movhi	r2,33046
8113aacc:	10bff504 	addi	r2,r2,-44
8113aad0:	180691ba 	slli	r3,r3,6
8113aad4:	10c5883a 	add	r2,r2,r3
8113aad8:	10800904 	addi	r2,r2,36
8113aadc:	10800017 	ldw	r2,0(r2)
8113aae0:	10007a26 	beq	r2,zero,8113accc <alt_up_sd_card_write+0x4e4>
8113aae4:	e0bffc0f 	ldh	r2,-16(fp)
8113aae8:	1000781e 	bne	r2,zero,8113accc <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113aaec:	e0fffe0f 	ldh	r3,-8(fp)
8113aaf0:	00a045b4 	movhi	r2,33046
8113aaf4:	10bff504 	addi	r2,r2,-44
8113aaf8:	180691ba 	slli	r3,r3,6
8113aafc:	10c5883a 	add	r2,r2,r3
8113ab00:	10800804 	addi	r2,r2,32
8113ab04:	10c00017 	ldw	r3,0(r2)
8113ab08:	00a045b4 	movhi	r2,33046
8113ab0c:	10bfe004 	addi	r2,r2,-128
8113ab10:	10800383 	ldbu	r2,14(r2)
8113ab14:	10803fcc 	andi	r2,r2,255
8113ab18:	10bfffc4 	addi	r2,r2,-1
8113ab1c:	18803e1e 	bne	r3,r2,8113ac18 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
8113ab20:	e0bffd04 	addi	r2,fp,-12
8113ab24:	1009883a 	mov	r4,r2
8113ab28:	1138e380 	call	81138e38 <find_first_empty_cluster>
8113ab2c:	10003826 	beq	r2,zero,8113ac10 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
8113ab30:	e0fffe0f 	ldh	r3,-8(fp)
8113ab34:	00a045b4 	movhi	r2,33046
8113ab38:	10bff504 	addi	r2,r2,-44
8113ab3c:	180691ba 	slli	r3,r3,6
8113ab40:	10c5883a 	add	r2,r2,r3
8113ab44:	10800704 	addi	r2,r2,28
8113ab48:	10800017 	ldw	r2,0(r2)
8113ab4c:	e0fffd17 	ldw	r3,-12(fp)
8113ab50:	18ffffcc 	andi	r3,r3,65535
8113ab54:	18e0001c 	xori	r3,r3,32768
8113ab58:	18e00004 	addi	r3,r3,-32768
8113ab5c:	01800044 	movi	r6,1
8113ab60:	180b883a 	mov	r5,r3
8113ab64:	1009883a 	mov	r4,r2
8113ab68:	1136eb00 	call	81136eb0 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
8113ab6c:	e0bffd17 	ldw	r2,-12(fp)
8113ab70:	01800044 	movi	r6,1
8113ab74:	017fffc4 	movi	r5,-1
8113ab78:	1009883a 	mov	r4,r2
8113ab7c:	1136eb00 	call	81136eb0 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
8113ab80:	e0fffe0f 	ldh	r3,-8(fp)
8113ab84:	00a045b4 	movhi	r2,33046
8113ab88:	10bff504 	addi	r2,r2,-44
8113ab8c:	180691ba 	slli	r3,r3,6
8113ab90:	10c5883a 	add	r2,r2,r3
8113ab94:	10800704 	addi	r2,r2,28
8113ab98:	10800017 	ldw	r2,0(r2)
8113ab9c:	e0fffd17 	ldw	r3,-12(fp)
8113aba0:	18ffffcc 	andi	r3,r3,65535
8113aba4:	18e0001c 	xori	r3,r3,32768
8113aba8:	18e00004 	addi	r3,r3,-32768
8113abac:	000d883a 	mov	r6,zero
8113abb0:	180b883a 	mov	r5,r3
8113abb4:	1009883a 	mov	r4,r2
8113abb8:	1136eb00 	call	81136eb0 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
8113abbc:	e0bffd17 	ldw	r2,-12(fp)
8113abc0:	000d883a 	mov	r6,zero
8113abc4:	017fffc4 	movi	r5,-1
8113abc8:	1009883a 	mov	r4,r2
8113abcc:	1136eb00 	call	81136eb0 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
8113abd0:	e13ffe0f 	ldh	r4,-8(fp)
8113abd4:	e0fffd17 	ldw	r3,-12(fp)
8113abd8:	00a045b4 	movhi	r2,33046
8113abdc:	10bff504 	addi	r2,r2,-44
8113abe0:	200891ba 	slli	r4,r4,6
8113abe4:	1105883a 	add	r2,r2,r4
8113abe8:	10800704 	addi	r2,r2,28
8113abec:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
8113abf0:	e0fffe0f 	ldh	r3,-8(fp)
8113abf4:	00a045b4 	movhi	r2,33046
8113abf8:	10bff504 	addi	r2,r2,-44
8113abfc:	180691ba 	slli	r3,r3,6
8113ac00:	10c5883a 	add	r2,r2,r3
8113ac04:	10800804 	addi	r2,r2,32
8113ac08:	10000015 	stw	zero,0(r2)
8113ac0c:	00001506 	br	8113ac64 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
8113ac10:	0005883a 	mov	r2,zero
8113ac14:	00007906 	br	8113adfc <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
8113ac18:	e13ffe0f 	ldh	r4,-8(fp)
8113ac1c:	e0fffe0f 	ldh	r3,-8(fp)
8113ac20:	00a045b4 	movhi	r2,33046
8113ac24:	10bff504 	addi	r2,r2,-44
8113ac28:	180691ba 	slli	r3,r3,6
8113ac2c:	10c5883a 	add	r2,r2,r3
8113ac30:	10800904 	addi	r2,r2,36
8113ac34:	10c00017 	ldw	r3,0(r2)
8113ac38:	00a045b4 	movhi	r2,33046
8113ac3c:	10bfe004 	addi	r2,r2,-128
8113ac40:	1080030b 	ldhu	r2,12(r2)
8113ac44:	10bfffcc 	andi	r2,r2,65535
8113ac48:	1887203a 	divu	r3,r3,r2
8113ac4c:	00a045b4 	movhi	r2,33046
8113ac50:	10bff504 	addi	r2,r2,-44
8113ac54:	200891ba 	slli	r4,r4,6
8113ac58:	1105883a 	add	r2,r2,r4
8113ac5c:	10800804 	addi	r2,r2,32
8113ac60:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113ac64:	00a045b4 	movhi	r2,33046
8113ac68:	10bfe004 	addi	r2,r2,-128
8113ac6c:	10c01417 	ldw	r3,80(r2)
8113ac70:	e13ffe0f 	ldh	r4,-8(fp)
8113ac74:	00a045b4 	movhi	r2,33046
8113ac78:	10bff504 	addi	r2,r2,-44
8113ac7c:	200891ba 	slli	r4,r4,6
8113ac80:	1105883a 	add	r2,r2,r4
8113ac84:	10800704 	addi	r2,r2,28
8113ac88:	10800017 	ldw	r2,0(r2)
8113ac8c:	113fff84 	addi	r4,r2,-2
8113ac90:	00a045b4 	movhi	r2,33046
8113ac94:	10bfe004 	addi	r2,r2,-128
8113ac98:	10800383 	ldbu	r2,14(r2)
8113ac9c:	10803fcc 	andi	r2,r2,255
8113aca0:	2085383a 	mul	r2,r4,r2
8113aca4:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
8113aca8:	e13ffe0f 	ldh	r4,-8(fp)
8113acac:	00a045b4 	movhi	r2,33046
8113acb0:	10bff504 	addi	r2,r2,-44
8113acb4:	200891ba 	slli	r4,r4,6
8113acb8:	1105883a 	add	r2,r2,r4
8113acbc:	10800804 	addi	r2,r2,32
8113acc0:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113acc4:	1885883a 	add	r2,r3,r2
8113acc8:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
8113accc:	d0e0a117 	ldw	r3,-32124(gp)
8113acd0:	e0bffb17 	ldw	r2,-20(fp)
8113acd4:	1885883a 	add	r2,r3,r2
8113acd8:	1007883a 	mov	r3,r2
8113acdc:	d0a0a517 	ldw	r2,-32108(gp)
8113ace0:	18800726 	beq	r3,r2,8113ad00 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8113ace4:	d0a0a117 	ldw	r2,-32124(gp)
8113ace8:	100b883a 	mov	r5,r2
8113acec:	e13ffb17 	ldw	r4,-20(fp)
8113acf0:	1136d140 	call	81136d14 <Read_Sector_Data>
8113acf4:	1000021e 	bne	r2,zero,8113ad00 <alt_up_sd_card_write+0x518>
                {
					return false;
8113acf8:	0005883a 	mov	r2,zero
8113acfc:	00003f06 	br	8113adfc <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
8113ad00:	d0e0a017 	ldw	r3,-32128(gp)
8113ad04:	e0bffc0f 	ldh	r2,-16(fp)
8113ad08:	1885883a 	add	r2,r3,r2
8113ad0c:	e0ffff07 	ldb	r3,-4(fp)
8113ad10:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8113ad14:	e13ffe0f 	ldh	r4,-8(fp)
8113ad18:	e0fffe0f 	ldh	r3,-8(fp)
8113ad1c:	00a045b4 	movhi	r2,33046
8113ad20:	10bff504 	addi	r2,r2,-44
8113ad24:	180691ba 	slli	r3,r3,6
8113ad28:	10c5883a 	add	r2,r2,r3
8113ad2c:	10800904 	addi	r2,r2,36
8113ad30:	10800017 	ldw	r2,0(r2)
8113ad34:	10c00044 	addi	r3,r2,1
8113ad38:	00a045b4 	movhi	r2,33046
8113ad3c:	10bff504 	addi	r2,r2,-44
8113ad40:	200891ba 	slli	r4,r4,6
8113ad44:	1105883a 	add	r2,r2,r4
8113ad48:	10800904 	addi	r2,r2,36
8113ad4c:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
8113ad50:	e0fffe0f 	ldh	r3,-8(fp)
8113ad54:	00a045b4 	movhi	r2,33046
8113ad58:	10bff504 	addi	r2,r2,-44
8113ad5c:	180691ba 	slli	r3,r3,6
8113ad60:	10c5883a 	add	r2,r2,r3
8113ad64:	10800904 	addi	r2,r2,36
8113ad68:	10c00017 	ldw	r3,0(r2)
8113ad6c:	e13ffe0f 	ldh	r4,-8(fp)
8113ad70:	00a045b4 	movhi	r2,33046
8113ad74:	10bff504 	addi	r2,r2,-44
8113ad78:	200891ba 	slli	r4,r4,6
8113ad7c:	1105883a 	add	r2,r2,r4
8113ad80:	10800604 	addi	r2,r2,24
8113ad84:	10800017 	ldw	r2,0(r2)
8113ad88:	18801736 	bltu	r3,r2,8113ade8 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
8113ad8c:	e13ffe0f 	ldh	r4,-8(fp)
8113ad90:	e0fffe0f 	ldh	r3,-8(fp)
8113ad94:	00a045b4 	movhi	r2,33046
8113ad98:	10bff504 	addi	r2,r2,-44
8113ad9c:	180691ba 	slli	r3,r3,6
8113ada0:	10c5883a 	add	r2,r2,r3
8113ada4:	10800604 	addi	r2,r2,24
8113ada8:	10800017 	ldw	r2,0(r2)
8113adac:	10c00044 	addi	r3,r2,1
8113adb0:	00a045b4 	movhi	r2,33046
8113adb4:	10bff504 	addi	r2,r2,-44
8113adb8:	200891ba 	slli	r4,r4,6
8113adbc:	1105883a 	add	r2,r2,r4
8113adc0:	10800604 	addi	r2,r2,24
8113adc4:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
8113adc8:	e0fffe0f 	ldh	r3,-8(fp)
8113adcc:	00a045b4 	movhi	r2,33046
8113add0:	10bff504 	addi	r2,r2,-44
8113add4:	180691ba 	slli	r3,r3,6
8113add8:	10c5883a 	add	r2,r2,r3
8113addc:	10800e04 	addi	r2,r2,56
8113ade0:	00c00044 	movi	r3,1
8113ade4:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
8113ade8:	00800044 	movi	r2,1
8113adec:	d0a0a415 	stw	r2,-32112(gp)
			result = true;
8113adf0:	00800044 	movi	r2,1
8113adf4:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
8113adf8:	e0bffa17 	ldw	r2,-24(fp)
}
8113adfc:	e037883a 	mov	sp,fp
8113ae00:	dfc00117 	ldw	ra,4(sp)
8113ae04:	df000017 	ldw	fp,0(sp)
8113ae08:	dec00204 	addi	sp,sp,8
8113ae0c:	f800283a 	ret

8113ae10 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
8113ae10:	defffb04 	addi	sp,sp,-20
8113ae14:	de00012e 	bgeu	sp,et,8113ae1c <alt_up_sd_card_fclose+0xc>
8113ae18:	003b68fa 	trap	3
8113ae1c:	dfc00415 	stw	ra,16(sp)
8113ae20:	df000315 	stw	fp,12(sp)
8113ae24:	df000304 	addi	fp,sp,12
8113ae28:	2005883a 	mov	r2,r4
8113ae2c:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
8113ae30:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113ae34:	11399ec0 	call	811399ec <alt_up_sd_card_is_Present>
8113ae38:	10006026 	beq	r2,zero,8113afbc <alt_up_sd_card_fclose+0x1ac>
8113ae3c:	d0a09a17 	ldw	r2,-32152(gp)
8113ae40:	10005e26 	beq	r2,zero,8113afbc <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
8113ae44:	e0ffff0f 	ldh	r3,-4(fp)
8113ae48:	00a045b4 	movhi	r2,33046
8113ae4c:	10bff504 	addi	r2,r2,-44
8113ae50:	180691ba 	slli	r3,r3,6
8113ae54:	10c5883a 	add	r2,r2,r3
8113ae58:	10800f04 	addi	r2,r2,60
8113ae5c:	10800017 	ldw	r2,0(r2)
8113ae60:	10005626 	beq	r2,zero,8113afbc <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
8113ae64:	e0ffff0f 	ldh	r3,-4(fp)
8113ae68:	00a045b4 	movhi	r2,33046
8113ae6c:	10bff504 	addi	r2,r2,-44
8113ae70:	180691ba 	slli	r3,r3,6
8113ae74:	10c5883a 	add	r2,r2,r3
8113ae78:	10800e04 	addi	r2,r2,56
8113ae7c:	10800017 	ldw	r2,0(r2)
8113ae80:	10004526 	beq	r2,zero,8113af98 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
8113ae84:	e0ffff0f 	ldh	r3,-4(fp)
8113ae88:	00a045b4 	movhi	r2,33046
8113ae8c:	10bff504 	addi	r2,r2,-44
8113ae90:	180691ba 	slli	r3,r3,6
8113ae94:	10c5883a 	add	r2,r2,r3
8113ae98:	10800b04 	addi	r2,r2,44
8113ae9c:	10800017 	ldw	r2,0(r2)
8113aea0:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
8113aea4:	e0ffff0f 	ldh	r3,-4(fp)
8113aea8:	00a045b4 	movhi	r2,33046
8113aeac:	10bff504 	addi	r2,r2,-44
8113aeb0:	180691ba 	slli	r3,r3,6
8113aeb4:	10c5883a 	add	r2,r2,r3
8113aeb8:	10800a04 	addi	r2,r2,40
8113aebc:	10800017 	ldw	r2,0(r2)
8113aec0:	1000071e 	bne	r2,zero,8113aee0 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
8113aec4:	00a045b4 	movhi	r2,33046
8113aec8:	10bfe004 	addi	r2,r2,-128
8113aecc:	10801317 	ldw	r2,76(r2)
8113aed0:	e0fffe17 	ldw	r3,-8(fp)
8113aed4:	1885883a 	add	r2,r3,r2
8113aed8:	e0bffe15 	stw	r2,-8(fp)
8113aedc:	00001406 	br	8113af30 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
8113aee0:	00a045b4 	movhi	r2,33046
8113aee4:	10bfe004 	addi	r2,r2,-128
8113aee8:	10c01417 	ldw	r3,80(r2)
8113aeec:	e0bffe17 	ldw	r2,-8(fp)
8113aef0:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
8113aef4:	e13fff0f 	ldh	r4,-4(fp)
8113aef8:	00a045b4 	movhi	r2,33046
8113aefc:	10bff504 	addi	r2,r2,-44
8113af00:	200891ba 	slli	r4,r4,6
8113af04:	1105883a 	add	r2,r2,r4
8113af08:	10800a04 	addi	r2,r2,40
8113af0c:	10800017 	ldw	r2,0(r2)
8113af10:	113fff84 	addi	r4,r2,-2
8113af14:	00a045b4 	movhi	r2,33046
8113af18:	10bfe004 	addi	r2,r2,-128
8113af1c:	10800383 	ldbu	r2,14(r2)
8113af20:	10803fcc 	andi	r2,r2,255
8113af24:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
8113af28:	1885883a 	add	r2,r3,r2
8113af2c:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
8113af30:	e0bffe17 	ldw	r2,-8(fp)
8113af34:	d0e0a117 	ldw	r3,-32124(gp)
8113af38:	180b883a 	mov	r5,r3
8113af3c:	1009883a 	mov	r4,r2
8113af40:	1136d140 	call	81136d14 <Read_Sector_Data>
8113af44:	10001426 	beq	r2,zero,8113af98 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
8113af48:	e0ffff0f 	ldh	r3,-4(fp)
8113af4c:	00a045b4 	movhi	r2,33046
8113af50:	10bff504 	addi	r2,r2,-44
8113af54:	180691ba 	slli	r3,r3,6
8113af58:	10c5883a 	add	r2,r2,r3
8113af5c:	10800c04 	addi	r2,r2,48
8113af60:	1080000b 	ldhu	r2,0(r2)
8113af64:	113fffcc 	andi	r4,r2,65535
8113af68:	2120001c 	xori	r4,r4,32768
8113af6c:	21200004 	addi	r4,r4,-32768
8113af70:	e0bfff0f 	ldh	r2,-4(fp)
8113af74:	100691ba 	slli	r3,r2,6
8113af78:	00a045b4 	movhi	r2,33046
8113af7c:	10bff504 	addi	r2,r2,-44
8113af80:	1885883a 	add	r2,r3,r2
8113af84:	100b883a 	mov	r5,r2
8113af88:	11373c80 	call	811373c8 <Write_File_Record_At_Offset>
8113af8c:	10000226 	beq	r2,zero,8113af98 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
8113af90:	1136cc00 	call	81136cc0 <Save_Modified_Sector>
8113af94:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
8113af98:	e0ffff0f 	ldh	r3,-4(fp)
8113af9c:	00a045b4 	movhi	r2,33046
8113afa0:	10bff504 	addi	r2,r2,-44
8113afa4:	180691ba 	slli	r3,r3,6
8113afa8:	10c5883a 	add	r2,r2,r3
8113afac:	10800f04 	addi	r2,r2,60
8113afb0:	10000015 	stw	zero,0(r2)
			result = true;
8113afb4:	00800044 	movi	r2,1
8113afb8:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
8113afbc:	e0bffd17 	ldw	r2,-12(fp)
}
8113afc0:	e037883a 	mov	sp,fp
8113afc4:	dfc00117 	ldw	ra,4(sp)
8113afc8:	df000017 	ldw	fp,0(sp)
8113afcc:	dec00204 	addi	sp,sp,8
8113afd0:	f800283a 	ret

8113afd4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
8113afd4:	defffa04 	addi	sp,sp,-24
8113afd8:	de00012e 	bgeu	sp,et,8113afe0 <altera_avalon_jtag_uart_read_fd+0xc>
8113afdc:	003b68fa 	trap	3
8113afe0:	dfc00515 	stw	ra,20(sp)
8113afe4:	df000415 	stw	fp,16(sp)
8113afe8:	df000404 	addi	fp,sp,16
8113afec:	e13ffd15 	stw	r4,-12(fp)
8113aff0:	e17ffe15 	stw	r5,-8(fp)
8113aff4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113aff8:	e0bffd17 	ldw	r2,-12(fp)
8113affc:	10800017 	ldw	r2,0(r2)
8113b000:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
8113b004:	e0bffc17 	ldw	r2,-16(fp)
8113b008:	10c00a04 	addi	r3,r2,40
8113b00c:	e0bffd17 	ldw	r2,-12(fp)
8113b010:	10800217 	ldw	r2,8(r2)
8113b014:	100f883a 	mov	r7,r2
8113b018:	e1bfff17 	ldw	r6,-4(fp)
8113b01c:	e17ffe17 	ldw	r5,-8(fp)
8113b020:	1809883a 	mov	r4,r3
8113b024:	113b8580 	call	8113b858 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
8113b028:	e037883a 	mov	sp,fp
8113b02c:	dfc00117 	ldw	ra,4(sp)
8113b030:	df000017 	ldw	fp,0(sp)
8113b034:	dec00204 	addi	sp,sp,8
8113b038:	f800283a 	ret

8113b03c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8113b03c:	defffa04 	addi	sp,sp,-24
8113b040:	de00012e 	bgeu	sp,et,8113b048 <altera_avalon_jtag_uart_write_fd+0xc>
8113b044:	003b68fa 	trap	3
8113b048:	dfc00515 	stw	ra,20(sp)
8113b04c:	df000415 	stw	fp,16(sp)
8113b050:	df000404 	addi	fp,sp,16
8113b054:	e13ffd15 	stw	r4,-12(fp)
8113b058:	e17ffe15 	stw	r5,-8(fp)
8113b05c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113b060:	e0bffd17 	ldw	r2,-12(fp)
8113b064:	10800017 	ldw	r2,0(r2)
8113b068:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
8113b06c:	e0bffc17 	ldw	r2,-16(fp)
8113b070:	10c00a04 	addi	r3,r2,40
8113b074:	e0bffd17 	ldw	r2,-12(fp)
8113b078:	10800217 	ldw	r2,8(r2)
8113b07c:	100f883a 	mov	r7,r2
8113b080:	e1bfff17 	ldw	r6,-4(fp)
8113b084:	e17ffe17 	ldw	r5,-8(fp)
8113b088:	1809883a 	mov	r4,r3
8113b08c:	113bb1c0 	call	8113bb1c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
8113b090:	e037883a 	mov	sp,fp
8113b094:	dfc00117 	ldw	ra,4(sp)
8113b098:	df000017 	ldw	fp,0(sp)
8113b09c:	dec00204 	addi	sp,sp,8
8113b0a0:	f800283a 	ret

8113b0a4 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
8113b0a4:	defffc04 	addi	sp,sp,-16
8113b0a8:	de00012e 	bgeu	sp,et,8113b0b0 <altera_avalon_jtag_uart_close_fd+0xc>
8113b0ac:	003b68fa 	trap	3
8113b0b0:	dfc00315 	stw	ra,12(sp)
8113b0b4:	df000215 	stw	fp,8(sp)
8113b0b8:	df000204 	addi	fp,sp,8
8113b0bc:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113b0c0:	e0bfff17 	ldw	r2,-4(fp)
8113b0c4:	10800017 	ldw	r2,0(r2)
8113b0c8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
8113b0cc:	e0bffe17 	ldw	r2,-8(fp)
8113b0d0:	10c00a04 	addi	r3,r2,40
8113b0d4:	e0bfff17 	ldw	r2,-4(fp)
8113b0d8:	10800217 	ldw	r2,8(r2)
8113b0dc:	100b883a 	mov	r5,r2
8113b0e0:	1809883a 	mov	r4,r3
8113b0e4:	113b6f00 	call	8113b6f0 <altera_avalon_jtag_uart_close>
}
8113b0e8:	e037883a 	mov	sp,fp
8113b0ec:	dfc00117 	ldw	ra,4(sp)
8113b0f0:	df000017 	ldw	fp,0(sp)
8113b0f4:	dec00204 	addi	sp,sp,8
8113b0f8:	f800283a 	ret

8113b0fc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
8113b0fc:	defffa04 	addi	sp,sp,-24
8113b100:	de00012e 	bgeu	sp,et,8113b108 <altera_avalon_jtag_uart_ioctl_fd+0xc>
8113b104:	003b68fa 	trap	3
8113b108:	dfc00515 	stw	ra,20(sp)
8113b10c:	df000415 	stw	fp,16(sp)
8113b110:	df000404 	addi	fp,sp,16
8113b114:	e13ffd15 	stw	r4,-12(fp)
8113b118:	e17ffe15 	stw	r5,-8(fp)
8113b11c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
8113b120:	e0bffd17 	ldw	r2,-12(fp)
8113b124:	10800017 	ldw	r2,0(r2)
8113b128:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
8113b12c:	e0bffc17 	ldw	r2,-16(fp)
8113b130:	10800a04 	addi	r2,r2,40
8113b134:	e1bfff17 	ldw	r6,-4(fp)
8113b138:	e17ffe17 	ldw	r5,-8(fp)
8113b13c:	1009883a 	mov	r4,r2
8113b140:	113b7600 	call	8113b760 <altera_avalon_jtag_uart_ioctl>
}
8113b144:	e037883a 	mov	sp,fp
8113b148:	dfc00117 	ldw	ra,4(sp)
8113b14c:	df000017 	ldw	fp,0(sp)
8113b150:	dec00204 	addi	sp,sp,8
8113b154:	f800283a 	ret

8113b158 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
8113b158:	deffef04 	addi	sp,sp,-68
8113b15c:	de00012e 	bgeu	sp,et,8113b164 <altera_avalon_jtag_uart_init+0xc>
8113b160:	003b68fa 	trap	3
8113b164:	dfc01015 	stw	ra,64(sp)
8113b168:	df000f15 	stw	fp,60(sp)
8113b16c:	dc400e15 	stw	r17,56(sp)
8113b170:	dc000d15 	stw	r16,52(sp)
8113b174:	df000f04 	addi	fp,sp,60
8113b178:	e13ff715 	stw	r4,-36(fp)
8113b17c:	e17ff815 	stw	r5,-32(fp)
8113b180:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
8113b184:	e0bff717 	ldw	r2,-36(fp)
8113b188:	10800c04 	addi	r2,r2,48
8113b18c:	e0bff215 	stw	r2,-56(fp)
8113b190:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
8113b194:	e0bff60b 	ldhu	r2,-40(fp)
8113b198:	e0fff684 	addi	r3,fp,-38
8113b19c:	180b883a 	mov	r5,r3
8113b1a0:	1009883a 	mov	r4,r2
8113b1a4:	112f4dc0 	call	8112f4dc <OSFlagCreate>
8113b1a8:	1007883a 	mov	r3,r2
8113b1ac:	e0bff217 	ldw	r2,-56(fp)
8113b1b0:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
8113b1b4:	e0bff717 	ldw	r2,-36(fp)
8113b1b8:	10800a04 	addi	r2,r2,40
8113b1bc:	e0bff315 	stw	r2,-52(fp)
8113b1c0:	00800044 	movi	r2,1
8113b1c4:	e0bff58d 	sth	r2,-42(fp)
8113b1c8:	e0bff58b 	ldhu	r2,-42(fp)
8113b1cc:	1009883a 	mov	r4,r2
8113b1d0:	11334380 	call	81133438 <OSSemCreate>
8113b1d4:	1007883a 	mov	r3,r2
8113b1d8:	e0bff317 	ldw	r2,-52(fp)
8113b1dc:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
8113b1e0:	e0bff717 	ldw	r2,-36(fp)
8113b1e4:	10800b04 	addi	r2,r2,44
8113b1e8:	e0bff415 	stw	r2,-48(fp)
8113b1ec:	00800044 	movi	r2,1
8113b1f0:	e0bff50d 	sth	r2,-44(fp)
8113b1f4:	e0bff50b 	ldhu	r2,-44(fp)
8113b1f8:	1009883a 	mov	r4,r2
8113b1fc:	11334380 	call	81133438 <OSSemCreate>
8113b200:	1007883a 	mov	r3,r2
8113b204:	e0bff417 	ldw	r2,-48(fp)
8113b208:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8113b20c:	e0bff717 	ldw	r2,-36(fp)
8113b210:	00c00044 	movi	r3,1
8113b214:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
8113b218:	e0bff717 	ldw	r2,-36(fp)
8113b21c:	10800017 	ldw	r2,0(r2)
8113b220:	10800104 	addi	r2,r2,4
8113b224:	1007883a 	mov	r3,r2
8113b228:	e0bff717 	ldw	r2,-36(fp)
8113b22c:	10800817 	ldw	r2,32(r2)
8113b230:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
8113b234:	e0bff817 	ldw	r2,-32(fp)
8113b238:	e0fff917 	ldw	r3,-28(fp)
8113b23c:	d8000015 	stw	zero,0(sp)
8113b240:	e1fff717 	ldw	r7,-36(fp)
8113b244:	01a04534 	movhi	r6,33044
8113b248:	31acca04 	addi	r6,r6,-19672
8113b24c:	180b883a 	mov	r5,r3
8113b250:	1009883a 	mov	r4,r2
8113b254:	113f0700 	call	8113f070 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
8113b258:	e0bff717 	ldw	r2,-36(fp)
8113b25c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
8113b260:	e0bff717 	ldw	r2,-36(fp)
8113b264:	10800204 	addi	r2,r2,8
8113b268:	d0e07817 	ldw	r3,-32288(gp)
8113b26c:	e1fff717 	ldw	r7,-36(fp)
8113b270:	01a04534 	movhi	r6,33044
8113b274:	31ad7904 	addi	r6,r6,-18972
8113b278:	180b883a 	mov	r5,r3
8113b27c:	1009883a 	mov	r4,r2
8113b280:	113ebc00 	call	8113ebc0 <alt_alarm_start>
8113b284:	1000040e 	bge	r2,zero,8113b298 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
8113b288:	e0fff717 	ldw	r3,-36(fp)
8113b28c:	00a00034 	movhi	r2,32768
8113b290:	10bfffc4 	addi	r2,r2,-1
8113b294:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
8113b298:	d0a07183 	ldbu	r2,-32314(gp)
8113b29c:	10803fcc 	andi	r2,r2,255
8113b2a0:	10800058 	cmpnei	r2,r2,1
8113b2a4:	10000f1e 	bne	r2,zero,8113b2e4 <altera_avalon_jtag_uart_init+0x18c>
8113b2a8:	d0e07817 	ldw	r3,-32288(gp)
8113b2ac:	00b33374 	movhi	r2,52429
8113b2b0:	10b33344 	addi	r2,r2,-13107
8113b2b4:	1888383a 	mulxuu	r4,r3,r2
8113b2b8:	1885383a 	mul	r2,r3,r2
8113b2bc:	1021883a 	mov	r16,r2
8113b2c0:	2023883a 	mov	r17,r4
8113b2c4:	8804d0fa 	srli	r2,r17,3
8113b2c8:	e1fff717 	ldw	r7,-36(fp)
8113b2cc:	01a044f4 	movhi	r6,33043
8113b2d0:	31af0304 	addi	r6,r6,-17396
8113b2d4:	100b883a 	mov	r5,r2
8113b2d8:	012045b4 	movhi	r4,33046
8113b2dc:	21299e04 	addi	r4,r4,-22920
8113b2e0:	113ebc00 	call	8113ebc0 <alt_alarm_start>
8113b2e4:	d0a07203 	ldbu	r2,-32312(gp)
8113b2e8:	10803fcc 	andi	r2,r2,255
8113b2ec:	10800058 	cmpnei	r2,r2,1
8113b2f0:	1000051e 	bne	r2,zero,8113b308 <altera_avalon_jtag_uart_init+0x1b0>
8113b2f4:	e0bff717 	ldw	r2,-36(fp)
8113b2f8:	10800017 	ldw	r2,0(r2)
8113b2fc:	100b883a 	mov	r5,r2
8113b300:	e13ff717 	ldw	r4,-36(fp)
8113b304:	112bda40 	call	8112bda4 <alt_log_jtag_uart_startup_info>
}
8113b308:	0001883a 	nop
8113b30c:	e6fffe04 	addi	sp,fp,-8
8113b310:	dfc00317 	ldw	ra,12(sp)
8113b314:	df000217 	ldw	fp,8(sp)
8113b318:	dc400117 	ldw	r17,4(sp)
8113b31c:	dc000017 	ldw	r16,0(sp)
8113b320:	dec00404 	addi	sp,sp,16
8113b324:	f800283a 	ret

8113b328 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
8113b328:	defff204 	addi	sp,sp,-56
8113b32c:	de00012e 	bgeu	sp,et,8113b334 <altera_avalon_jtag_uart_irq+0xc>
8113b330:	003b68fa 	trap	3
8113b334:	dfc00d15 	stw	ra,52(sp)
8113b338:	df000c15 	stw	fp,48(sp)
8113b33c:	df000c04 	addi	fp,sp,48
8113b340:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
8113b344:	e0bfff17 	ldw	r2,-4(fp)
8113b348:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
8113b34c:	e0bff617 	ldw	r2,-40(fp)
8113b350:	10800017 	ldw	r2,0(r2)
8113b354:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
8113b358:	e0bff717 	ldw	r2,-36(fp)
8113b35c:	e17ff617 	ldw	r5,-40(fp)
8113b360:	1009883a 	mov	r4,r2
8113b364:	112bdf80 	call	8112bdf8 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113b368:	e0bff717 	ldw	r2,-36(fp)
8113b36c:	10800104 	addi	r2,r2,4
8113b370:	10800037 	ldwio	r2,0(r2)
8113b374:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
8113b378:	e0bff817 	ldw	r2,-32(fp)
8113b37c:	1080c00c 	andi	r2,r2,768
8113b380:	10009126 	beq	r2,zero,8113b5c8 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
8113b384:	e0bff817 	ldw	r2,-32(fp)
8113b388:	1080400c 	andi	r2,r2,256
8113b38c:	10004726 	beq	r2,zero,8113b4ac <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
8113b390:	00800074 	movhi	r2,1
8113b394:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113b398:	e0bff617 	ldw	r2,-40(fp)
8113b39c:	10800d17 	ldw	r2,52(r2)
8113b3a0:	10800044 	addi	r2,r2,1
8113b3a4:	1081ffcc 	andi	r2,r2,2047
8113b3a8:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
8113b3ac:	e0bff617 	ldw	r2,-40(fp)
8113b3b0:	10c00e17 	ldw	r3,56(r2)
8113b3b4:	e0bff917 	ldw	r2,-28(fp)
8113b3b8:	18802726 	beq	r3,r2,8113b458 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
8113b3bc:	e0bff717 	ldw	r2,-36(fp)
8113b3c0:	10800037 	ldwio	r2,0(r2)
8113b3c4:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
8113b3c8:	e0bff417 	ldw	r2,-48(fp)
8113b3cc:	10a0000c 	andi	r2,r2,32768
8113b3d0:	10002326 	beq	r2,zero,8113b460 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
8113b3d4:	e0bff617 	ldw	r2,-40(fp)
8113b3d8:	10800d17 	ldw	r2,52(r2)
8113b3dc:	e0fff417 	ldw	r3,-48(fp)
8113b3e0:	1809883a 	mov	r4,r3
8113b3e4:	e0fff617 	ldw	r3,-40(fp)
8113b3e8:	1885883a 	add	r2,r3,r2
8113b3ec:	10801104 	addi	r2,r2,68
8113b3f0:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113b3f4:	e0bff617 	ldw	r2,-40(fp)
8113b3f8:	10800d17 	ldw	r2,52(r2)
8113b3fc:	10800044 	addi	r2,r2,1
8113b400:	10c1ffcc 	andi	r3,r2,2047
8113b404:	e0bff617 	ldw	r2,-40(fp)
8113b408:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
8113b40c:	e0bff617 	ldw	r2,-40(fp)
8113b410:	10800c17 	ldw	r2,48(r2)
8113b414:	e0bffb15 	stw	r2,-20(fp)
8113b418:	00800044 	movi	r2,1
8113b41c:	e0bffc0d 	sth	r2,-16(fp)
8113b420:	00800044 	movi	r2,1
8113b424:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113b428:	d0a08103 	ldbu	r2,-32252(gp)
8113b42c:	10803fcc 	andi	r2,r2,255
8113b430:	103fd926 	beq	r2,zero,8113b398 <__reset+0xfb11b398>
  {
    OSFlagPost (group, flags, opt, &err);
8113b434:	e0bffc0b 	ldhu	r2,-16(fp)
8113b438:	e0fffc83 	ldbu	r3,-14(fp)
8113b43c:	e13ffdc4 	addi	r4,fp,-9
8113b440:	200f883a 	mov	r7,r4
8113b444:	180d883a 	mov	r6,r3
8113b448:	100b883a 	mov	r5,r2
8113b44c:	e13ffb17 	ldw	r4,-20(fp)
8113b450:	11300e80 	call	811300e8 <OSFlagPost>
      }
8113b454:	003fd006 	br	8113b398 <__reset+0xfb11b398>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
8113b458:	0001883a 	nop
8113b45c:	00000106 	br	8113b464 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
8113b460:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
8113b464:	e0bff417 	ldw	r2,-48(fp)
8113b468:	10bfffec 	andhi	r2,r2,65535
8113b46c:	10000f26 	beq	r2,zero,8113b4ac <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8113b470:	e0bff617 	ldw	r2,-40(fp)
8113b474:	10c00817 	ldw	r3,32(r2)
8113b478:	00bfff84 	movi	r2,-2
8113b47c:	1886703a 	and	r3,r3,r2
8113b480:	e0bff617 	ldw	r2,-40(fp)
8113b484:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
8113b488:	e0bff717 	ldw	r2,-36(fp)
8113b48c:	10800104 	addi	r2,r2,4
8113b490:	1007883a 	mov	r3,r2
8113b494:	e0bff617 	ldw	r2,-40(fp)
8113b498:	10800817 	ldw	r2,32(r2)
8113b49c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113b4a0:	e0bff717 	ldw	r2,-36(fp)
8113b4a4:	10800104 	addi	r2,r2,4
8113b4a8:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
8113b4ac:	e0bff817 	ldw	r2,-32(fp)
8113b4b0:	1080800c 	andi	r2,r2,512
8113b4b4:	103fac26 	beq	r2,zero,8113b368 <__reset+0xfb11b368>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
8113b4b8:	e0bff817 	ldw	r2,-32(fp)
8113b4bc:	1004d43a 	srli	r2,r2,16
8113b4c0:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
8113b4c4:	00002606 	br	8113b560 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
8113b4c8:	e0bff717 	ldw	r2,-36(fp)
8113b4cc:	e0fff617 	ldw	r3,-40(fp)
8113b4d0:	18c01017 	ldw	r3,64(r3)
8113b4d4:	e13ff617 	ldw	r4,-40(fp)
8113b4d8:	20c7883a 	add	r3,r4,r3
8113b4dc:	18c21104 	addi	r3,r3,2116
8113b4e0:	18c00003 	ldbu	r3,0(r3)
8113b4e4:	18c03fcc 	andi	r3,r3,255
8113b4e8:	18c0201c 	xori	r3,r3,128
8113b4ec:	18ffe004 	addi	r3,r3,-128
8113b4f0:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113b4f4:	e0bff617 	ldw	r2,-40(fp)
8113b4f8:	10801017 	ldw	r2,64(r2)
8113b4fc:	10800044 	addi	r2,r2,1
8113b500:	10c1ffcc 	andi	r3,r2,2047
8113b504:	e0bff617 	ldw	r2,-40(fp)
8113b508:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
8113b50c:	e0bff617 	ldw	r2,-40(fp)
8113b510:	10800c17 	ldw	r2,48(r2)
8113b514:	e0bffa15 	stw	r2,-24(fp)
8113b518:	00800084 	movi	r2,2
8113b51c:	e0bffd0d 	sth	r2,-12(fp)
8113b520:	00800044 	movi	r2,1
8113b524:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113b528:	d0a08103 	ldbu	r2,-32252(gp)
8113b52c:	10803fcc 	andi	r2,r2,255
8113b530:	10000826 	beq	r2,zero,8113b554 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
8113b534:	e0bffd0b 	ldhu	r2,-12(fp)
8113b538:	e0fffd83 	ldbu	r3,-10(fp)
8113b53c:	e13ffe04 	addi	r4,fp,-8
8113b540:	200f883a 	mov	r7,r4
8113b544:	180d883a 	mov	r6,r3
8113b548:	100b883a 	mov	r5,r2
8113b54c:	e13ffa17 	ldw	r4,-24(fp)
8113b550:	11300e80 	call	811300e8 <OSFlagPost>

        space--;
8113b554:	e0bff517 	ldw	r2,-44(fp)
8113b558:	10bfffc4 	addi	r2,r2,-1
8113b55c:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
8113b560:	e0bff517 	ldw	r2,-44(fp)
8113b564:	10000526 	beq	r2,zero,8113b57c <altera_avalon_jtag_uart_irq+0x254>
8113b568:	e0bff617 	ldw	r2,-40(fp)
8113b56c:	10c01017 	ldw	r3,64(r2)
8113b570:	e0bff617 	ldw	r2,-40(fp)
8113b574:	10800f17 	ldw	r2,60(r2)
8113b578:	18bfd31e 	bne	r3,r2,8113b4c8 <__reset+0xfb11b4c8>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
8113b57c:	e0bff517 	ldw	r2,-44(fp)
8113b580:	103f7926 	beq	r2,zero,8113b368 <__reset+0xfb11b368>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
8113b584:	e0bff617 	ldw	r2,-40(fp)
8113b588:	10c00817 	ldw	r3,32(r2)
8113b58c:	00bfff44 	movi	r2,-3
8113b590:	1886703a 	and	r3,r3,r2
8113b594:	e0bff617 	ldw	r2,-40(fp)
8113b598:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8113b59c:	e0bff617 	ldw	r2,-40(fp)
8113b5a0:	10800017 	ldw	r2,0(r2)
8113b5a4:	10800104 	addi	r2,r2,4
8113b5a8:	1007883a 	mov	r3,r2
8113b5ac:	e0bff617 	ldw	r2,-40(fp)
8113b5b0:	10800817 	ldw	r2,32(r2)
8113b5b4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113b5b8:	e0bff717 	ldw	r2,-36(fp)
8113b5bc:	10800104 	addi	r2,r2,4
8113b5c0:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
8113b5c4:	003f6806 	br	8113b368 <__reset+0xfb11b368>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
8113b5c8:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
8113b5cc:	0001883a 	nop
8113b5d0:	e037883a 	mov	sp,fp
8113b5d4:	dfc00117 	ldw	ra,4(sp)
8113b5d8:	df000017 	ldw	fp,0(sp)
8113b5dc:	dec00204 	addi	sp,sp,8
8113b5e0:	f800283a 	ret

8113b5e4 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
8113b5e4:	defff904 	addi	sp,sp,-28
8113b5e8:	de00012e 	bgeu	sp,et,8113b5f0 <altera_avalon_jtag_uart_timeout+0xc>
8113b5ec:	003b68fa 	trap	3
8113b5f0:	dfc00615 	stw	ra,24(sp)
8113b5f4:	df000515 	stw	fp,20(sp)
8113b5f8:	df000504 	addi	fp,sp,20
8113b5fc:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
8113b600:	e0bfff17 	ldw	r2,-4(fp)
8113b604:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
8113b608:	e0bffb17 	ldw	r2,-20(fp)
8113b60c:	10800017 	ldw	r2,0(r2)
8113b610:	10800104 	addi	r2,r2,4
8113b614:	10800037 	ldwio	r2,0(r2)
8113b618:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
8113b61c:	e0bffc17 	ldw	r2,-16(fp)
8113b620:	1081000c 	andi	r2,r2,1024
8113b624:	10000b26 	beq	r2,zero,8113b654 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
8113b628:	e0bffb17 	ldw	r2,-20(fp)
8113b62c:	10800017 	ldw	r2,0(r2)
8113b630:	10800104 	addi	r2,r2,4
8113b634:	1007883a 	mov	r3,r2
8113b638:	e0bffb17 	ldw	r2,-20(fp)
8113b63c:	10800817 	ldw	r2,32(r2)
8113b640:	10810014 	ori	r2,r2,1024
8113b644:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
8113b648:	e0bffb17 	ldw	r2,-20(fp)
8113b64c:	10000915 	stw	zero,36(r2)
8113b650:	00002106 	br	8113b6d8 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
8113b654:	e0bffb17 	ldw	r2,-20(fp)
8113b658:	10c00917 	ldw	r3,36(r2)
8113b65c:	00a00034 	movhi	r2,32768
8113b660:	10bfff04 	addi	r2,r2,-4
8113b664:	10c01c36 	bltu	r2,r3,8113b6d8 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
8113b668:	e0bffb17 	ldw	r2,-20(fp)
8113b66c:	10800917 	ldw	r2,36(r2)
8113b670:	10c00044 	addi	r3,r2,1
8113b674:	e0bffb17 	ldw	r2,-20(fp)
8113b678:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
8113b67c:	e0bffb17 	ldw	r2,-20(fp)
8113b680:	10c00917 	ldw	r3,36(r2)
8113b684:	e0bffb17 	ldw	r2,-20(fp)
8113b688:	10800117 	ldw	r2,4(r2)
8113b68c:	18801236 	bltu	r3,r2,8113b6d8 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
8113b690:	e0bffb17 	ldw	r2,-20(fp)
8113b694:	10800c17 	ldw	r2,48(r2)
8113b698:	e0bffd15 	stw	r2,-12(fp)
8113b69c:	00800104 	movi	r2,4
8113b6a0:	e0bffe0d 	sth	r2,-8(fp)
8113b6a4:	00800044 	movi	r2,1
8113b6a8:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113b6ac:	d0a08103 	ldbu	r2,-32252(gp)
8113b6b0:	10803fcc 	andi	r2,r2,255
8113b6b4:	10000826 	beq	r2,zero,8113b6d8 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
8113b6b8:	e0bffe0b 	ldhu	r2,-8(fp)
8113b6bc:	e0fffe83 	ldbu	r3,-6(fp)
8113b6c0:	e13ffec4 	addi	r4,fp,-5
8113b6c4:	200f883a 	mov	r7,r4
8113b6c8:	180d883a 	mov	r6,r3
8113b6cc:	100b883a 	mov	r5,r2
8113b6d0:	e13ffd17 	ldw	r4,-12(fp)
8113b6d4:	11300e80 	call	811300e8 <OSFlagPost>
8113b6d8:	d0a07817 	ldw	r2,-32288(gp)
    }
  }

  return alt_ticks_per_second();
}
8113b6dc:	e037883a 	mov	sp,fp
8113b6e0:	dfc00117 	ldw	ra,4(sp)
8113b6e4:	df000017 	ldw	fp,0(sp)
8113b6e8:	dec00204 	addi	sp,sp,8
8113b6ec:	f800283a 	ret

8113b6f0 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
8113b6f0:	defffd04 	addi	sp,sp,-12
8113b6f4:	de00012e 	bgeu	sp,et,8113b6fc <altera_avalon_jtag_uart_close+0xc>
8113b6f8:	003b68fa 	trap	3
8113b6fc:	df000215 	stw	fp,8(sp)
8113b700:	df000204 	addi	fp,sp,8
8113b704:	e13ffe15 	stw	r4,-8(fp)
8113b708:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
8113b70c:	00000506 	br	8113b724 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
8113b710:	e0bfff17 	ldw	r2,-4(fp)
8113b714:	1090000c 	andi	r2,r2,16384
8113b718:	10000226 	beq	r2,zero,8113b724 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
8113b71c:	00bffd44 	movi	r2,-11
8113b720:	00000b06 	br	8113b750 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
8113b724:	e0bffe17 	ldw	r2,-8(fp)
8113b728:	10c01017 	ldw	r3,64(r2)
8113b72c:	e0bffe17 	ldw	r2,-8(fp)
8113b730:	10800f17 	ldw	r2,60(r2)
8113b734:	18800526 	beq	r3,r2,8113b74c <altera_avalon_jtag_uart_close+0x5c>
8113b738:	e0bffe17 	ldw	r2,-8(fp)
8113b73c:	10c00917 	ldw	r3,36(r2)
8113b740:	e0bffe17 	ldw	r2,-8(fp)
8113b744:	10800117 	ldw	r2,4(r2)
8113b748:	18bff136 	bltu	r3,r2,8113b710 <__reset+0xfb11b710>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
8113b74c:	0005883a 	mov	r2,zero
}
8113b750:	e037883a 	mov	sp,fp
8113b754:	df000017 	ldw	fp,0(sp)
8113b758:	dec00104 	addi	sp,sp,4
8113b75c:	f800283a 	ret

8113b760 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
8113b760:	defffa04 	addi	sp,sp,-24
8113b764:	de00012e 	bgeu	sp,et,8113b76c <altera_avalon_jtag_uart_ioctl+0xc>
8113b768:	003b68fa 	trap	3
8113b76c:	df000515 	stw	fp,20(sp)
8113b770:	df000504 	addi	fp,sp,20
8113b774:	e13ffd15 	stw	r4,-12(fp)
8113b778:	e17ffe15 	stw	r5,-8(fp)
8113b77c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
8113b780:	00bff9c4 	movi	r2,-25
8113b784:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
8113b788:	e0bffe17 	ldw	r2,-8(fp)
8113b78c:	10da8060 	cmpeqi	r3,r2,27137
8113b790:	1800031e 	bne	r3,zero,8113b7a0 <altera_avalon_jtag_uart_ioctl+0x40>
8113b794:	109a80a0 	cmpeqi	r2,r2,27138
8113b798:	1000181e 	bne	r2,zero,8113b7fc <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
8113b79c:	00002906 	br	8113b844 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
8113b7a0:	e0bffd17 	ldw	r2,-12(fp)
8113b7a4:	10c00117 	ldw	r3,4(r2)
8113b7a8:	00a00034 	movhi	r2,32768
8113b7ac:	10bfffc4 	addi	r2,r2,-1
8113b7b0:	18802126 	beq	r3,r2,8113b838 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
8113b7b4:	e0bfff17 	ldw	r2,-4(fp)
8113b7b8:	10800017 	ldw	r2,0(r2)
8113b7bc:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
8113b7c0:	e0bffc17 	ldw	r2,-16(fp)
8113b7c4:	10800090 	cmplti	r2,r2,2
8113b7c8:	1000061e 	bne	r2,zero,8113b7e4 <altera_avalon_jtag_uart_ioctl+0x84>
8113b7cc:	e0fffc17 	ldw	r3,-16(fp)
8113b7d0:	00a00034 	movhi	r2,32768
8113b7d4:	10bfffc4 	addi	r2,r2,-1
8113b7d8:	18800226 	beq	r3,r2,8113b7e4 <altera_avalon_jtag_uart_ioctl+0x84>
8113b7dc:	e0bffc17 	ldw	r2,-16(fp)
8113b7e0:	00000206 	br	8113b7ec <altera_avalon_jtag_uart_ioctl+0x8c>
8113b7e4:	00a00034 	movhi	r2,32768
8113b7e8:	10bfff84 	addi	r2,r2,-2
8113b7ec:	e0fffd17 	ldw	r3,-12(fp)
8113b7f0:	18800115 	stw	r2,4(r3)
      rc = 0;
8113b7f4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
8113b7f8:	00000f06 	br	8113b838 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
8113b7fc:	e0bffd17 	ldw	r2,-12(fp)
8113b800:	10c00117 	ldw	r3,4(r2)
8113b804:	00a00034 	movhi	r2,32768
8113b808:	10bfffc4 	addi	r2,r2,-1
8113b80c:	18800c26 	beq	r3,r2,8113b840 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
8113b810:	e0bffd17 	ldw	r2,-12(fp)
8113b814:	10c00917 	ldw	r3,36(r2)
8113b818:	e0bffd17 	ldw	r2,-12(fp)
8113b81c:	10800117 	ldw	r2,4(r2)
8113b820:	1885803a 	cmpltu	r2,r3,r2
8113b824:	10c03fcc 	andi	r3,r2,255
8113b828:	e0bfff17 	ldw	r2,-4(fp)
8113b82c:	10c00015 	stw	r3,0(r2)
      rc = 0;
8113b830:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
8113b834:	00000206 	br	8113b840 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
8113b838:	0001883a 	nop
8113b83c:	00000106 	br	8113b844 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
8113b840:	0001883a 	nop

  default:
    break;
  }

  return rc;
8113b844:	e0bffb17 	ldw	r2,-20(fp)
}
8113b848:	e037883a 	mov	sp,fp
8113b84c:	df000017 	ldw	fp,0(sp)
8113b850:	dec00104 	addi	sp,sp,4
8113b854:	f800283a 	ret

8113b858 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
8113b858:	deffed04 	addi	sp,sp,-76
8113b85c:	de00012e 	bgeu	sp,et,8113b864 <altera_avalon_jtag_uart_read+0xc>
8113b860:	003b68fa 	trap	3
8113b864:	dfc01215 	stw	ra,72(sp)
8113b868:	df001115 	stw	fp,68(sp)
8113b86c:	df001104 	addi	fp,sp,68
8113b870:	e13ffc15 	stw	r4,-16(fp)
8113b874:	e17ffd15 	stw	r5,-12(fp)
8113b878:	e1bffe15 	stw	r6,-8(fp)
8113b87c:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
8113b880:	e0bffd17 	ldw	r2,-12(fp)
8113b884:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
8113b888:	e0bffc17 	ldw	r2,-16(fp)
8113b88c:	10800a17 	ldw	r2,40(r2)
8113b890:	e0bff815 	stw	r2,-32(fp)
8113b894:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8113b898:	e0bff90b 	ldhu	r2,-28(fp)
8113b89c:	e0fffb04 	addi	r3,fp,-20
8113b8a0:	180d883a 	mov	r6,r3
8113b8a4:	100b883a 	mov	r5,r2
8113b8a8:	e13ff817 	ldw	r4,-32(fp)
8113b8ac:	11337600 	call	81133760 <OSSemPend>

  while (space > 0)
8113b8b0:	00006106 	br	8113ba38 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
8113b8b4:	e0bffc17 	ldw	r2,-16(fp)
8113b8b8:	10800d17 	ldw	r2,52(r2)
8113b8bc:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
8113b8c0:	e0bffc17 	ldw	r2,-16(fp)
8113b8c4:	10800e17 	ldw	r2,56(r2)
8113b8c8:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
8113b8cc:	e0fff317 	ldw	r3,-52(fp)
8113b8d0:	e0bff417 	ldw	r2,-48(fp)
8113b8d4:	18800536 	bltu	r3,r2,8113b8ec <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
8113b8d8:	e0fff317 	ldw	r3,-52(fp)
8113b8dc:	e0bff417 	ldw	r2,-48(fp)
8113b8e0:	1885c83a 	sub	r2,r3,r2
8113b8e4:	e0bff115 	stw	r2,-60(fp)
8113b8e8:	00000406 	br	8113b8fc <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
8113b8ec:	00c20004 	movi	r3,2048
8113b8f0:	e0bff417 	ldw	r2,-48(fp)
8113b8f4:	1885c83a 	sub	r2,r3,r2
8113b8f8:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8113b8fc:	e0bff117 	ldw	r2,-60(fp)
8113b900:	10001e26 	beq	r2,zero,8113b97c <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
8113b904:	e0fffe17 	ldw	r3,-8(fp)
8113b908:	e0bff117 	ldw	r2,-60(fp)
8113b90c:	1880022e 	bgeu	r3,r2,8113b918 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
8113b910:	e0bffe17 	ldw	r2,-8(fp)
8113b914:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
8113b918:	e0bffc17 	ldw	r2,-16(fp)
8113b91c:	10c01104 	addi	r3,r2,68
8113b920:	e0bff417 	ldw	r2,-48(fp)
8113b924:	1885883a 	add	r2,r3,r2
8113b928:	e1bff117 	ldw	r6,-60(fp)
8113b92c:	100b883a 	mov	r5,r2
8113b930:	e13ff017 	ldw	r4,-64(fp)
8113b934:	11167340 	call	81116734 <memcpy>
      ptr   += n;
8113b938:	e0fff017 	ldw	r3,-64(fp)
8113b93c:	e0bff117 	ldw	r2,-60(fp)
8113b940:	1885883a 	add	r2,r3,r2
8113b944:	e0bff015 	stw	r2,-64(fp)
      space -= n;
8113b948:	e0fffe17 	ldw	r3,-8(fp)
8113b94c:	e0bff117 	ldw	r2,-60(fp)
8113b950:	1885c83a 	sub	r2,r3,r2
8113b954:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113b958:	e0fff417 	ldw	r3,-48(fp)
8113b95c:	e0bff117 	ldw	r2,-60(fp)
8113b960:	1885883a 	add	r2,r3,r2
8113b964:	10c1ffcc 	andi	r3,r2,2047
8113b968:	e0bffc17 	ldw	r2,-16(fp)
8113b96c:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
8113b970:	e0bffe17 	ldw	r2,-8(fp)
8113b974:	00bfcf16 	blt	zero,r2,8113b8b4 <__reset+0xfb11b8b4>
8113b978:	00000106 	br	8113b980 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
8113b97c:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
8113b980:	e0fff017 	ldw	r3,-64(fp)
8113b984:	e0bffd17 	ldw	r2,-12(fp)
8113b988:	18802e1e 	bne	r3,r2,8113ba44 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
8113b98c:	e0bfff17 	ldw	r2,-4(fp)
8113b990:	1090000c 	andi	r2,r2,16384
8113b994:	10002d1e 	bne	r2,zero,8113ba4c <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
8113b998:	d0a08103 	ldbu	r2,-32252(gp)
8113b99c:	10803fcc 	andi	r2,r2,255
8113b9a0:	10800058 	cmpnei	r2,r2,1
8113b9a4:	1000161e 	bne	r2,zero,8113ba00 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
8113b9a8:	e0bffc17 	ldw	r2,-16(fp)
8113b9ac:	10800c17 	ldw	r2,48(r2)
8113b9b0:	e0bff215 	stw	r2,-56(fp)
8113b9b4:	00800144 	movi	r2,5
8113b9b8:	e0bff98d 	sth	r2,-26(fp)
8113b9bc:	00bfe0c4 	movi	r2,-125
8113b9c0:	e0bffa05 	stb	r2,-24(fp)
8113b9c4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8113b9c8:	d0a08103 	ldbu	r2,-32252(gp)
8113b9cc:	10803fcc 	andi	r2,r2,255
8113b9d0:	10001526 	beq	r2,zero,8113ba28 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8113b9d4:	e0fff98b 	ldhu	r3,-26(fp)
8113b9d8:	e13ffa03 	ldbu	r4,-24(fp)
8113b9dc:	e17ffa8b 	ldhu	r5,-22(fp)
8113b9e0:	e0bffb44 	addi	r2,fp,-19
8113b9e4:	d8800015 	stw	r2,0(sp)
8113b9e8:	280f883a 	mov	r7,r5
8113b9ec:	200d883a 	mov	r6,r4
8113b9f0:	180b883a 	mov	r5,r3
8113b9f4:	e13ff217 	ldw	r4,-56(fp)
8113b9f8:	112fac00 	call	8112fac0 <OSFlagPend>
8113b9fc:	00000a06 	br	8113ba28 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
8113ba00:	0001883a 	nop
8113ba04:	e0bffc17 	ldw	r2,-16(fp)
8113ba08:	10c00d17 	ldw	r3,52(r2)
8113ba0c:	e0bff317 	ldw	r2,-52(fp)
8113ba10:	1880051e 	bne	r3,r2,8113ba28 <altera_avalon_jtag_uart_read+0x1d0>
8113ba14:	e0bffc17 	ldw	r2,-16(fp)
8113ba18:	10c00917 	ldw	r3,36(r2)
8113ba1c:	e0bffc17 	ldw	r2,-16(fp)
8113ba20:	10800117 	ldw	r2,4(r2)
8113ba24:	18bff736 	bltu	r3,r2,8113ba04 <__reset+0xfb11ba04>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
8113ba28:	e0bffc17 	ldw	r2,-16(fp)
8113ba2c:	10c00d17 	ldw	r3,52(r2)
8113ba30:	e0bff317 	ldw	r2,-52(fp)
8113ba34:	18800726 	beq	r3,r2,8113ba54 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
8113ba38:	e0bffe17 	ldw	r2,-8(fp)
8113ba3c:	00bf9d16 	blt	zero,r2,8113b8b4 <__reset+0xfb11b8b4>
8113ba40:	00000506 	br	8113ba58 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
8113ba44:	0001883a 	nop
8113ba48:	00000306 	br	8113ba58 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
8113ba4c:	0001883a 	nop
8113ba50:	00000106 	br	8113ba58 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
8113ba54:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
8113ba58:	e0bffc17 	ldw	r2,-16(fp)
8113ba5c:	10800a17 	ldw	r2,40(r2)
8113ba60:	1009883a 	mov	r4,r2
8113ba64:	1133ae80 	call	81133ae8 <OSSemPost>

  if (ptr != buffer)
8113ba68:	e0fff017 	ldw	r3,-64(fp)
8113ba6c:	e0bffd17 	ldw	r2,-12(fp)
8113ba70:	18801826 	beq	r3,r2,8113bad4 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ba74:	0005303a 	rdctl	r2,status
8113ba78:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ba7c:	e0fff717 	ldw	r3,-36(fp)
8113ba80:	00bfff84 	movi	r2,-2
8113ba84:	1884703a 	and	r2,r3,r2
8113ba88:	1001703a 	wrctl	status,r2
  
  return context;
8113ba8c:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
8113ba90:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8113ba94:	e0bffc17 	ldw	r2,-16(fp)
8113ba98:	10800817 	ldw	r2,32(r2)
8113ba9c:	10c00054 	ori	r3,r2,1
8113baa0:	e0bffc17 	ldw	r2,-16(fp)
8113baa4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8113baa8:	e0bffc17 	ldw	r2,-16(fp)
8113baac:	10800017 	ldw	r2,0(r2)
8113bab0:	10800104 	addi	r2,r2,4
8113bab4:	1007883a 	mov	r3,r2
8113bab8:	e0bffc17 	ldw	r2,-16(fp)
8113babc:	10800817 	ldw	r2,32(r2)
8113bac0:	18800035 	stwio	r2,0(r3)
8113bac4:	e0bff617 	ldw	r2,-40(fp)
8113bac8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bacc:	e0bff517 	ldw	r2,-44(fp)
8113bad0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
8113bad4:	e0fff017 	ldw	r3,-64(fp)
8113bad8:	e0bffd17 	ldw	r2,-12(fp)
8113badc:	18800426 	beq	r3,r2,8113baf0 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
8113bae0:	e0fff017 	ldw	r3,-64(fp)
8113bae4:	e0bffd17 	ldw	r2,-12(fp)
8113bae8:	1885c83a 	sub	r2,r3,r2
8113baec:	00000606 	br	8113bb08 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
8113baf0:	e0bfff17 	ldw	r2,-4(fp)
8113baf4:	1090000c 	andi	r2,r2,16384
8113baf8:	10000226 	beq	r2,zero,8113bb04 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
8113bafc:	00bffd44 	movi	r2,-11
8113bb00:	00000106 	br	8113bb08 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
8113bb04:	00bffec4 	movi	r2,-5
}
8113bb08:	e037883a 	mov	sp,fp
8113bb0c:	dfc00117 	ldw	ra,4(sp)
8113bb10:	df000017 	ldw	fp,0(sp)
8113bb14:	dec00204 	addi	sp,sp,8
8113bb18:	f800283a 	ret

8113bb1c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
8113bb1c:	deffed04 	addi	sp,sp,-76
8113bb20:	de00012e 	bgeu	sp,et,8113bb28 <altera_avalon_jtag_uart_write+0xc>
8113bb24:	003b68fa 	trap	3
8113bb28:	dfc01215 	stw	ra,72(sp)
8113bb2c:	df001115 	stw	fp,68(sp)
8113bb30:	df001104 	addi	fp,sp,68
8113bb34:	e13ffc15 	stw	r4,-16(fp)
8113bb38:	e17ffd15 	stw	r5,-12(fp)
8113bb3c:	e1bffe15 	stw	r6,-8(fp)
8113bb40:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
8113bb44:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
8113bb48:	e0bffd17 	ldw	r2,-12(fp)
8113bb4c:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
8113bb50:	e0bffc17 	ldw	r2,-16(fp)
8113bb54:	10800b17 	ldw	r2,44(r2)
8113bb58:	e0bff815 	stw	r2,-32(fp)
8113bb5c:	e03ff90d 	sth	zero,-28(fp)
8113bb60:	e0bff90b 	ldhu	r2,-28(fp)
8113bb64:	e0fffb44 	addi	r3,fp,-19
8113bb68:	180d883a 	mov	r6,r3
8113bb6c:	100b883a 	mov	r5,r2
8113bb70:	e13ff817 	ldw	r4,-32(fp)
8113bb74:	11337600 	call	81133760 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
8113bb78:	00003706 	br	8113bc58 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
8113bb7c:	e0bffc17 	ldw	r2,-16(fp)
8113bb80:	10800f17 	ldw	r2,60(r2)
8113bb84:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
8113bb88:	e0bffc17 	ldw	r2,-16(fp)
8113bb8c:	10801017 	ldw	r2,64(r2)
8113bb90:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
8113bb94:	e0fff417 	ldw	r3,-48(fp)
8113bb98:	e0bff017 	ldw	r2,-64(fp)
8113bb9c:	1880062e 	bgeu	r3,r2,8113bbb8 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
8113bba0:	e0fff017 	ldw	r3,-64(fp)
8113bba4:	e0bff417 	ldw	r2,-48(fp)
8113bba8:	1885c83a 	sub	r2,r3,r2
8113bbac:	10bfffc4 	addi	r2,r2,-1
8113bbb0:	e0bff115 	stw	r2,-60(fp)
8113bbb4:	00000b06 	br	8113bbe4 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
8113bbb8:	e0bff017 	ldw	r2,-64(fp)
8113bbbc:	10000526 	beq	r2,zero,8113bbd4 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
8113bbc0:	00c20004 	movi	r3,2048
8113bbc4:	e0bff417 	ldw	r2,-48(fp)
8113bbc8:	1885c83a 	sub	r2,r3,r2
8113bbcc:	e0bff115 	stw	r2,-60(fp)
8113bbd0:	00000406 	br	8113bbe4 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
8113bbd4:	00c1ffc4 	movi	r3,2047
8113bbd8:	e0bff417 	ldw	r2,-48(fp)
8113bbdc:	1885c83a 	sub	r2,r3,r2
8113bbe0:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8113bbe4:	e0bff117 	ldw	r2,-60(fp)
8113bbe8:	10001e26 	beq	r2,zero,8113bc64 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
8113bbec:	e0fffe17 	ldw	r3,-8(fp)
8113bbf0:	e0bff117 	ldw	r2,-60(fp)
8113bbf4:	1880022e 	bgeu	r3,r2,8113bc00 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
8113bbf8:	e0bffe17 	ldw	r2,-8(fp)
8113bbfc:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
8113bc00:	e0bffc17 	ldw	r2,-16(fp)
8113bc04:	10c21104 	addi	r3,r2,2116
8113bc08:	e0bff417 	ldw	r2,-48(fp)
8113bc0c:	1885883a 	add	r2,r3,r2
8113bc10:	e1bff117 	ldw	r6,-60(fp)
8113bc14:	e17ffd17 	ldw	r5,-12(fp)
8113bc18:	1009883a 	mov	r4,r2
8113bc1c:	11167340 	call	81116734 <memcpy>
      ptr   += n;
8113bc20:	e0fffd17 	ldw	r3,-12(fp)
8113bc24:	e0bff117 	ldw	r2,-60(fp)
8113bc28:	1885883a 	add	r2,r3,r2
8113bc2c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
8113bc30:	e0fffe17 	ldw	r3,-8(fp)
8113bc34:	e0bff117 	ldw	r2,-60(fp)
8113bc38:	1885c83a 	sub	r2,r3,r2
8113bc3c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113bc40:	e0fff417 	ldw	r3,-48(fp)
8113bc44:	e0bff117 	ldw	r2,-60(fp)
8113bc48:	1885883a 	add	r2,r3,r2
8113bc4c:	10c1ffcc 	andi	r3,r2,2047
8113bc50:	e0bffc17 	ldw	r2,-16(fp)
8113bc54:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
8113bc58:	e0bffe17 	ldw	r2,-8(fp)
8113bc5c:	00bfc716 	blt	zero,r2,8113bb7c <__reset+0xfb11bb7c>
8113bc60:	00000106 	br	8113bc68 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
8113bc64:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bc68:	0005303a 	rdctl	r2,status
8113bc6c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bc70:	e0fff717 	ldw	r3,-36(fp)
8113bc74:	00bfff84 	movi	r2,-2
8113bc78:	1884703a 	and	r2,r3,r2
8113bc7c:	1001703a 	wrctl	status,r2
  
  return context;
8113bc80:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
8113bc84:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
8113bc88:	e0bffc17 	ldw	r2,-16(fp)
8113bc8c:	10800817 	ldw	r2,32(r2)
8113bc90:	10c00094 	ori	r3,r2,2
8113bc94:	e0bffc17 	ldw	r2,-16(fp)
8113bc98:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8113bc9c:	e0bffc17 	ldw	r2,-16(fp)
8113bca0:	10800017 	ldw	r2,0(r2)
8113bca4:	10800104 	addi	r2,r2,4
8113bca8:	1007883a 	mov	r3,r2
8113bcac:	e0bffc17 	ldw	r2,-16(fp)
8113bcb0:	10800817 	ldw	r2,32(r2)
8113bcb4:	18800035 	stwio	r2,0(r3)
8113bcb8:	e0bff617 	ldw	r2,-40(fp)
8113bcbc:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bcc0:	e0bff317 	ldw	r2,-52(fp)
8113bcc4:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
8113bcc8:	e0bffe17 	ldw	r2,-8(fp)
8113bccc:	00802a0e 	bge	zero,r2,8113bd78 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
8113bcd0:	e0bfff17 	ldw	r2,-4(fp)
8113bcd4:	1090000c 	andi	r2,r2,16384
8113bcd8:	10002a1e 	bne	r2,zero,8113bd84 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
8113bcdc:	d0a08103 	ldbu	r2,-32252(gp)
8113bce0:	10803fcc 	andi	r2,r2,255
8113bce4:	10800058 	cmpnei	r2,r2,1
8113bce8:	1000161e 	bne	r2,zero,8113bd44 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
8113bcec:	e0bffc17 	ldw	r2,-16(fp)
8113bcf0:	10800c17 	ldw	r2,48(r2)
8113bcf4:	e0bff515 	stw	r2,-44(fp)
8113bcf8:	00800184 	movi	r2,6
8113bcfc:	e0bff98d 	sth	r2,-26(fp)
8113bd00:	00bfe0c4 	movi	r2,-125
8113bd04:	e0bffa05 	stb	r2,-24(fp)
8113bd08:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8113bd0c:	d0a08103 	ldbu	r2,-32252(gp)
8113bd10:	10803fcc 	andi	r2,r2,255
8113bd14:	10001526 	beq	r2,zero,8113bd6c <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8113bd18:	e0fff98b 	ldhu	r3,-26(fp)
8113bd1c:	e13ffa03 	ldbu	r4,-24(fp)
8113bd20:	e17ffa8b 	ldhu	r5,-22(fp)
8113bd24:	e0bffb04 	addi	r2,fp,-20
8113bd28:	d8800015 	stw	r2,0(sp)
8113bd2c:	280f883a 	mov	r7,r5
8113bd30:	200d883a 	mov	r6,r4
8113bd34:	180b883a 	mov	r5,r3
8113bd38:	e13ff517 	ldw	r4,-44(fp)
8113bd3c:	112fac00 	call	8112fac0 <OSFlagPend>
8113bd40:	00000a06 	br	8113bd6c <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
8113bd44:	0001883a 	nop
8113bd48:	e0bffc17 	ldw	r2,-16(fp)
8113bd4c:	10c01017 	ldw	r3,64(r2)
8113bd50:	e0bff017 	ldw	r2,-64(fp)
8113bd54:	1880051e 	bne	r3,r2,8113bd6c <altera_avalon_jtag_uart_write+0x250>
8113bd58:	e0bffc17 	ldw	r2,-16(fp)
8113bd5c:	10c00917 	ldw	r3,36(r2)
8113bd60:	e0bffc17 	ldw	r2,-16(fp)
8113bd64:	10800117 	ldw	r2,4(r2)
8113bd68:	18bff736 	bltu	r3,r2,8113bd48 <__reset+0xfb11bd48>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
8113bd6c:	e0bffc17 	ldw	r2,-16(fp)
8113bd70:	10800917 	ldw	r2,36(r2)
8113bd74:	1000051e 	bne	r2,zero,8113bd8c <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
8113bd78:	e0bffe17 	ldw	r2,-8(fp)
8113bd7c:	00bfb616 	blt	zero,r2,8113bc58 <__reset+0xfb11bc58>
8113bd80:	00000306 	br	8113bd90 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
8113bd84:	0001883a 	nop
8113bd88:	00000106 	br	8113bd90 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
8113bd8c:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
8113bd90:	e0bffc17 	ldw	r2,-16(fp)
8113bd94:	10800b17 	ldw	r2,44(r2)
8113bd98:	1009883a 	mov	r4,r2
8113bd9c:	1133ae80 	call	81133ae8 <OSSemPost>

  if (ptr != start)
8113bda0:	e0fffd17 	ldw	r3,-12(fp)
8113bda4:	e0bff217 	ldw	r2,-56(fp)
8113bda8:	18800426 	beq	r3,r2,8113bdbc <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
8113bdac:	e0fffd17 	ldw	r3,-12(fp)
8113bdb0:	e0bff217 	ldw	r2,-56(fp)
8113bdb4:	1885c83a 	sub	r2,r3,r2
8113bdb8:	00000606 	br	8113bdd4 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
8113bdbc:	e0bfff17 	ldw	r2,-4(fp)
8113bdc0:	1090000c 	andi	r2,r2,16384
8113bdc4:	10000226 	beq	r2,zero,8113bdd0 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
8113bdc8:	00bffd44 	movi	r2,-11
8113bdcc:	00000106 	br	8113bdd4 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
8113bdd0:	00bffec4 	movi	r2,-5
}
8113bdd4:	e037883a 	mov	sp,fp
8113bdd8:	dfc00117 	ldw	ra,4(sp)
8113bddc:	df000017 	ldw	fp,0(sp)
8113bde0:	dec00204 	addi	sp,sp,8
8113bde4:	f800283a 	ret

8113bde8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
8113bde8:	defffa04 	addi	sp,sp,-24
8113bdec:	de00012e 	bgeu	sp,et,8113bdf4 <alt_avalon_timer_sc_irq+0xc>
8113bdf0:	003b68fa 	trap	3
8113bdf4:	dfc00515 	stw	ra,20(sp)
8113bdf8:	df000415 	stw	fp,16(sp)
8113bdfc:	df000404 	addi	fp,sp,16
8113be00:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
8113be04:	0007883a 	mov	r3,zero
8113be08:	e0bfff17 	ldw	r2,-4(fp)
8113be0c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
8113be10:	e0bfff17 	ldw	r2,-4(fp)
8113be14:	10800104 	addi	r2,r2,4
8113be18:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
8113be1c:	112bf9c0 	call	8112bf9c <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113be20:	0005303a 	rdctl	r2,status
8113be24:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113be28:	e0fffd17 	ldw	r3,-12(fp)
8113be2c:	00bfff84 	movi	r2,-2
8113be30:	1884703a 	and	r2,r3,r2
8113be34:	1001703a 	wrctl	status,r2
  
  return context;
8113be38:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
8113be3c:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
8113be40:	112c84c0 	call	8112c84c <alt_tick>
8113be44:	e0bffc17 	ldw	r2,-16(fp)
8113be48:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113be4c:	e0bffe17 	ldw	r2,-8(fp)
8113be50:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
8113be54:	0001883a 	nop
8113be58:	e037883a 	mov	sp,fp
8113be5c:	dfc00117 	ldw	ra,4(sp)
8113be60:	df000017 	ldw	fp,0(sp)
8113be64:	dec00204 	addi	sp,sp,8
8113be68:	f800283a 	ret

8113be6c <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
8113be6c:	defff804 	addi	sp,sp,-32
8113be70:	de00012e 	bgeu	sp,et,8113be78 <alt_avalon_timer_sc_init+0xc>
8113be74:	003b68fa 	trap	3
8113be78:	dfc00715 	stw	ra,28(sp)
8113be7c:	df000615 	stw	fp,24(sp)
8113be80:	df000604 	addi	fp,sp,24
8113be84:	e13ffc15 	stw	r4,-16(fp)
8113be88:	e17ffd15 	stw	r5,-12(fp)
8113be8c:	e1bffe15 	stw	r6,-8(fp)
8113be90:	e1ffff15 	stw	r7,-4(fp)
8113be94:	e0bfff17 	ldw	r2,-4(fp)
8113be98:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
8113be9c:	d0a07817 	ldw	r2,-32288(gp)
8113bea0:	1000021e 	bne	r2,zero,8113beac <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
8113bea4:	e0bffb17 	ldw	r2,-20(fp)
8113bea8:	d0a07815 	stw	r2,-32288(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
8113beac:	e0bffc17 	ldw	r2,-16(fp)
8113beb0:	10800104 	addi	r2,r2,4
8113beb4:	00c001c4 	movi	r3,7
8113beb8:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
8113bebc:	d8000015 	stw	zero,0(sp)
8113bec0:	e1fffc17 	ldw	r7,-16(fp)
8113bec4:	01a04534 	movhi	r6,33044
8113bec8:	31af7a04 	addi	r6,r6,-16920
8113becc:	e17ffe17 	ldw	r5,-8(fp)
8113bed0:	e13ffd17 	ldw	r4,-12(fp)
8113bed4:	113f0700 	call	8113f070 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
8113bed8:	0001883a 	nop
8113bedc:	e037883a 	mov	sp,fp
8113bee0:	dfc00117 	ldw	ra,4(sp)
8113bee4:	df000017 	ldw	fp,0(sp)
8113bee8:	dec00204 	addi	sp,sp,8
8113beec:	f800283a 	ret

8113bef0 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
8113bef0:	defffa04 	addi	sp,sp,-24
8113bef4:	de00012e 	bgeu	sp,et,8113befc <altera_avalon_uart_read_fd+0xc>
8113bef8:	003b68fa 	trap	3
8113befc:	dfc00515 	stw	ra,20(sp)
8113bf00:	df000415 	stw	fp,16(sp)
8113bf04:	df000404 	addi	fp,sp,16
8113bf08:	e13ffd15 	stw	r4,-12(fp)
8113bf0c:	e17ffe15 	stw	r5,-8(fp)
8113bf10:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8113bf14:	e0bffd17 	ldw	r2,-12(fp)
8113bf18:	10800017 	ldw	r2,0(r2)
8113bf1c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
8113bf20:	e0bffc17 	ldw	r2,-16(fp)
8113bf24:	10c00a04 	addi	r3,r2,40
8113bf28:	e0bffd17 	ldw	r2,-12(fp)
8113bf2c:	10800217 	ldw	r2,8(r2)
8113bf30:	100f883a 	mov	r7,r2
8113bf34:	e1bfff17 	ldw	r6,-4(fp)
8113bf38:	e17ffe17 	ldw	r5,-8(fp)
8113bf3c:	1809883a 	mov	r4,r3
8113bf40:	113c5b00 	call	8113c5b0 <altera_avalon_uart_read>
      fd->fd_flags);
}
8113bf44:	e037883a 	mov	sp,fp
8113bf48:	dfc00117 	ldw	ra,4(sp)
8113bf4c:	df000017 	ldw	fp,0(sp)
8113bf50:	dec00204 	addi	sp,sp,8
8113bf54:	f800283a 	ret

8113bf58 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8113bf58:	defffa04 	addi	sp,sp,-24
8113bf5c:	de00012e 	bgeu	sp,et,8113bf64 <altera_avalon_uart_write_fd+0xc>
8113bf60:	003b68fa 	trap	3
8113bf64:	dfc00515 	stw	ra,20(sp)
8113bf68:	df000415 	stw	fp,16(sp)
8113bf6c:	df000404 	addi	fp,sp,16
8113bf70:	e13ffd15 	stw	r4,-12(fp)
8113bf74:	e17ffe15 	stw	r5,-8(fp)
8113bf78:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8113bf7c:	e0bffd17 	ldw	r2,-12(fp)
8113bf80:	10800017 	ldw	r2,0(r2)
8113bf84:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
8113bf88:	e0bffc17 	ldw	r2,-16(fp)
8113bf8c:	10c00a04 	addi	r3,r2,40
8113bf90:	e0bffd17 	ldw	r2,-12(fp)
8113bf94:	10800217 	ldw	r2,8(r2)
8113bf98:	100f883a 	mov	r7,r2
8113bf9c:	e1bfff17 	ldw	r6,-4(fp)
8113bfa0:	e17ffe17 	ldw	r5,-8(fp)
8113bfa4:	1809883a 	mov	r4,r3
8113bfa8:	113c8640 	call	8113c864 <altera_avalon_uart_write>
      fd->fd_flags);
}
8113bfac:	e037883a 	mov	sp,fp
8113bfb0:	dfc00117 	ldw	ra,4(sp)
8113bfb4:	df000017 	ldw	fp,0(sp)
8113bfb8:	dec00204 	addi	sp,sp,8
8113bfbc:	f800283a 	ret

8113bfc0 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
8113bfc0:	defffc04 	addi	sp,sp,-16
8113bfc4:	de00012e 	bgeu	sp,et,8113bfcc <altera_avalon_uart_close_fd+0xc>
8113bfc8:	003b68fa 	trap	3
8113bfcc:	dfc00315 	stw	ra,12(sp)
8113bfd0:	df000215 	stw	fp,8(sp)
8113bfd4:	df000204 	addi	fp,sp,8
8113bfd8:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8113bfdc:	e0bfff17 	ldw	r2,-4(fp)
8113bfe0:	10800017 	ldw	r2,0(r2)
8113bfe4:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
8113bfe8:	e0bffe17 	ldw	r2,-8(fp)
8113bfec:	10c00a04 	addi	r3,r2,40
8113bff0:	e0bfff17 	ldw	r2,-4(fp)
8113bff4:	10800217 	ldw	r2,8(r2)
8113bff8:	100b883a 	mov	r5,r2
8113bffc:	1809883a 	mov	r4,r3
8113c000:	113c5100 	call	8113c510 <altera_avalon_uart_close>
}
8113c004:	e037883a 	mov	sp,fp
8113c008:	dfc00117 	ldw	ra,4(sp)
8113c00c:	df000017 	ldw	fp,0(sp)
8113c010:	dec00204 	addi	sp,sp,8
8113c014:	f800283a 	ret

8113c018 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
8113c018:	defff304 	addi	sp,sp,-52
8113c01c:	de00012e 	bgeu	sp,et,8113c024 <altera_avalon_uart_init+0xc>
8113c020:	003b68fa 	trap	3
8113c024:	dfc00c15 	stw	ra,48(sp)
8113c028:	df000b15 	stw	fp,44(sp)
8113c02c:	df000b04 	addi	fp,sp,44
8113c030:	e13ffd15 	stw	r4,-12(fp)
8113c034:	e17ffe15 	stw	r5,-8(fp)
8113c038:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
8113c03c:	e0bffd17 	ldw	r2,-12(fp)
8113c040:	10800017 	ldw	r2,0(r2)
8113c044:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
8113c048:	e0bffd17 	ldw	r2,-12(fp)
8113c04c:	10800704 	addi	r2,r2,28
8113c050:	e0bffa15 	stw	r2,-24(fp)
8113c054:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
8113c058:	e0bffb0b 	ldhu	r2,-20(fp)
8113c05c:	e0fffc84 	addi	r3,fp,-14
8113c060:	180b883a 	mov	r5,r3
8113c064:	1009883a 	mov	r4,r2
8113c068:	112f4dc0 	call	8112f4dc <OSFlagCreate>
8113c06c:	1007883a 	mov	r3,r2
8113c070:	e0bffa17 	ldw	r2,-24(fp)
8113c074:	10c00015 	stw	r3,0(r2)
  return err;
8113c078:	e0bffc83 	ldbu	r2,-14(fp)
8113c07c:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
8113c080:	1000241e 	bne	r2,zero,8113c114 <altera_avalon_uart_init+0xfc>
8113c084:	e0bffd17 	ldw	r2,-12(fp)
8113c088:	10800804 	addi	r2,r2,32
8113c08c:	e0bff715 	stw	r2,-36(fp)
8113c090:	00800044 	movi	r2,1
8113c094:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8113c098:	e0bffb8b 	ldhu	r2,-18(fp)
8113c09c:	1009883a 	mov	r4,r2
8113c0a0:	11334380 	call	81133438 <OSSemCreate>
8113c0a4:	1007883a 	mov	r3,r2
8113c0a8:	e0bff717 	ldw	r2,-36(fp)
8113c0ac:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8113c0b0:	e0bff717 	ldw	r2,-36(fp)
8113c0b4:	10800017 	ldw	r2,0(r2)
8113c0b8:	10000226 	beq	r2,zero,8113c0c4 <altera_avalon_uart_init+0xac>
8113c0bc:	0005883a 	mov	r2,zero
8113c0c0:	00000106 	br	8113c0c8 <altera_avalon_uart_init+0xb0>
8113c0c4:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
8113c0c8:	1000121e 	bne	r2,zero,8113c114 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
8113c0cc:	e0bffd17 	ldw	r2,-12(fp)
8113c0d0:	10800904 	addi	r2,r2,36
8113c0d4:	e0bff815 	stw	r2,-32(fp)
8113c0d8:	00800044 	movi	r2,1
8113c0dc:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8113c0e0:	e0bffc0b 	ldhu	r2,-16(fp)
8113c0e4:	1009883a 	mov	r4,r2
8113c0e8:	11334380 	call	81133438 <OSSemCreate>
8113c0ec:	1007883a 	mov	r3,r2
8113c0f0:	e0bff817 	ldw	r2,-32(fp)
8113c0f4:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8113c0f8:	e0bff817 	ldw	r2,-32(fp)
8113c0fc:	10800017 	ldw	r2,0(r2)
8113c100:	10000226 	beq	r2,zero,8113c10c <altera_avalon_uart_init+0xf4>
8113c104:	0005883a 	mov	r2,zero
8113c108:	00000106 	br	8113c110 <altera_avalon_uart_init+0xf8>
8113c10c:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
8113c110:	10000226 	beq	r2,zero,8113c11c <altera_avalon_uart_init+0x104>
8113c114:	00800044 	movi	r2,1
8113c118:	00000106 	br	8113c120 <altera_avalon_uart_init+0x108>
8113c11c:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
8113c120:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
8113c124:	e0bff917 	ldw	r2,-28(fp)
8113c128:	10000f1e 	bne	r2,zero,8113c168 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
8113c12c:	e0bffd17 	ldw	r2,-12(fp)
8113c130:	00c32004 	movi	r3,3200
8113c134:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
8113c138:	e0bff617 	ldw	r2,-40(fp)
8113c13c:	10800304 	addi	r2,r2,12
8113c140:	e0fffd17 	ldw	r3,-12(fp)
8113c144:	18c00117 	ldw	r3,4(r3)
8113c148:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
8113c14c:	d8000015 	stw	zero,0(sp)
8113c150:	e1fffd17 	ldw	r7,-12(fp)
8113c154:	01a04534 	movhi	r6,33044
8113c158:	31b06004 	addi	r6,r6,-16000
8113c15c:	e17fff17 	ldw	r5,-4(fp)
8113c160:	e13ffe17 	ldw	r4,-8(fp)
8113c164:	113f0700 	call	8113f070 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
8113c168:	0001883a 	nop
8113c16c:	e037883a 	mov	sp,fp
8113c170:	dfc00117 	ldw	ra,4(sp)
8113c174:	df000017 	ldw	fp,0(sp)
8113c178:	dec00204 	addi	sp,sp,8
8113c17c:	f800283a 	ret

8113c180 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
8113c180:	defffa04 	addi	sp,sp,-24
8113c184:	de00012e 	bgeu	sp,et,8113c18c <altera_avalon_uart_irq+0xc>
8113c188:	003b68fa 	trap	3
8113c18c:	dfc00515 	stw	ra,20(sp)
8113c190:	df000415 	stw	fp,16(sp)
8113c194:	df000404 	addi	fp,sp,16
8113c198:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
8113c19c:	e0bfff17 	ldw	r2,-4(fp)
8113c1a0:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
8113c1a4:	e0bffc17 	ldw	r2,-16(fp)
8113c1a8:	10800017 	ldw	r2,0(r2)
8113c1ac:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
8113c1b0:	e0bffd17 	ldw	r2,-12(fp)
8113c1b4:	10800204 	addi	r2,r2,8
8113c1b8:	10800037 	ldwio	r2,0(r2)
8113c1bc:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
8113c1c0:	e0bffd17 	ldw	r2,-12(fp)
8113c1c4:	10800204 	addi	r2,r2,8
8113c1c8:	0007883a 	mov	r3,zero
8113c1cc:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
8113c1d0:	e0bffd17 	ldw	r2,-12(fp)
8113c1d4:	10800204 	addi	r2,r2,8
8113c1d8:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
8113c1dc:	e0bffe17 	ldw	r2,-8(fp)
8113c1e0:	1080200c 	andi	r2,r2,128
8113c1e4:	10000326 	beq	r2,zero,8113c1f4 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
8113c1e8:	e17ffe17 	ldw	r5,-8(fp)
8113c1ec:	e13ffc17 	ldw	r4,-16(fp)
8113c1f0:	113c2240 	call	8113c224 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
8113c1f4:	e0bffe17 	ldw	r2,-8(fp)
8113c1f8:	1081100c 	andi	r2,r2,1088
8113c1fc:	10000326 	beq	r2,zero,8113c20c <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
8113c200:	e17ffe17 	ldw	r5,-8(fp)
8113c204:	e13ffc17 	ldw	r4,-16(fp)
8113c208:	113c3640 	call	8113c364 <altera_avalon_uart_txirq>
  }
  

}
8113c20c:	0001883a 	nop
8113c210:	e037883a 	mov	sp,fp
8113c214:	dfc00117 	ldw	ra,4(sp)
8113c218:	df000017 	ldw	fp,0(sp)
8113c21c:	dec00204 	addi	sp,sp,8
8113c220:	f800283a 	ret

8113c224 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
8113c224:	defff904 	addi	sp,sp,-28
8113c228:	de00012e 	bgeu	sp,et,8113c230 <altera_avalon_uart_rxirq+0xc>
8113c22c:	003b68fa 	trap	3
8113c230:	dfc00615 	stw	ra,24(sp)
8113c234:	df000515 	stw	fp,20(sp)
8113c238:	df000504 	addi	fp,sp,20
8113c23c:	e13ffe15 	stw	r4,-8(fp)
8113c240:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
8113c244:	e0bfff17 	ldw	r2,-4(fp)
8113c248:	108000cc 	andi	r2,r2,3
8113c24c:	10003f1e 	bne	r2,zero,8113c34c <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
8113c250:	e0bffe17 	ldw	r2,-8(fp)
8113c254:	10c00317 	ldw	r3,12(r2)
8113c258:	e0bffe17 	ldw	r2,-8(fp)
8113c25c:	10800217 	ldw	r2,8(r2)
8113c260:	1880121e 	bne	r3,r2,8113c2ac <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
8113c264:	e0bffe17 	ldw	r2,-8(fp)
8113c268:	10800717 	ldw	r2,28(r2)
8113c26c:	e0bffc15 	stw	r2,-16(fp)
8113c270:	00800044 	movi	r2,1
8113c274:	e0bffd0d 	sth	r2,-12(fp)
8113c278:	00800044 	movi	r2,1
8113c27c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113c280:	d0a08103 	ldbu	r2,-32252(gp)
8113c284:	10803fcc 	andi	r2,r2,255
8113c288:	10000826 	beq	r2,zero,8113c2ac <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
8113c28c:	e0bffd0b 	ldhu	r2,-12(fp)
8113c290:	e0fffd83 	ldbu	r3,-10(fp)
8113c294:	e13ffdc4 	addi	r4,fp,-9
8113c298:	200f883a 	mov	r7,r4
8113c29c:	180d883a 	mov	r6,r3
8113c2a0:	100b883a 	mov	r5,r2
8113c2a4:	e13ffc17 	ldw	r4,-16(fp)
8113c2a8:	11300e80 	call	811300e8 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8113c2ac:	e0bffe17 	ldw	r2,-8(fp)
8113c2b0:	10800317 	ldw	r2,12(r2)
8113c2b4:	10800044 	addi	r2,r2,1
8113c2b8:	10800fcc 	andi	r2,r2,63
8113c2bc:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
8113c2c0:	e0bffe17 	ldw	r2,-8(fp)
8113c2c4:	10800317 	ldw	r2,12(r2)
8113c2c8:	e0fffe17 	ldw	r3,-8(fp)
8113c2cc:	18c00017 	ldw	r3,0(r3)
8113c2d0:	18c00037 	ldwio	r3,0(r3)
8113c2d4:	1809883a 	mov	r4,r3
8113c2d8:	e0fffe17 	ldw	r3,-8(fp)
8113c2dc:	1885883a 	add	r2,r3,r2
8113c2e0:	10800a04 	addi	r2,r2,40
8113c2e4:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
8113c2e8:	e0bffe17 	ldw	r2,-8(fp)
8113c2ec:	e0fffb17 	ldw	r3,-20(fp)
8113c2f0:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8113c2f4:	e0bffe17 	ldw	r2,-8(fp)
8113c2f8:	10800317 	ldw	r2,12(r2)
8113c2fc:	10800044 	addi	r2,r2,1
8113c300:	10800fcc 	andi	r2,r2,63
8113c304:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
8113c308:	e0bffe17 	ldw	r2,-8(fp)
8113c30c:	10c00217 	ldw	r3,8(r2)
8113c310:	e0bffb17 	ldw	r2,-20(fp)
8113c314:	18800e1e 	bne	r3,r2,8113c350 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8113c318:	e0bffe17 	ldw	r2,-8(fp)
8113c31c:	10c00117 	ldw	r3,4(r2)
8113c320:	00bfdfc4 	movi	r2,-129
8113c324:	1886703a 	and	r3,r3,r2
8113c328:	e0bffe17 	ldw	r2,-8(fp)
8113c32c:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
8113c330:	e0bffe17 	ldw	r2,-8(fp)
8113c334:	10800017 	ldw	r2,0(r2)
8113c338:	10800304 	addi	r2,r2,12
8113c33c:	e0fffe17 	ldw	r3,-8(fp)
8113c340:	18c00117 	ldw	r3,4(r3)
8113c344:	10c00035 	stwio	r3,0(r2)
8113c348:	00000106 	br	8113c350 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
8113c34c:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
8113c350:	e037883a 	mov	sp,fp
8113c354:	dfc00117 	ldw	ra,4(sp)
8113c358:	df000017 	ldw	fp,0(sp)
8113c35c:	dec00204 	addi	sp,sp,8
8113c360:	f800283a 	ret

8113c364 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
8113c364:	defffa04 	addi	sp,sp,-24
8113c368:	de00012e 	bgeu	sp,et,8113c370 <altera_avalon_uart_txirq+0xc>
8113c36c:	003b68fa 	trap	3
8113c370:	dfc00515 	stw	ra,20(sp)
8113c374:	df000415 	stw	fp,16(sp)
8113c378:	df000404 	addi	fp,sp,16
8113c37c:	e13ffe15 	stw	r4,-8(fp)
8113c380:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
8113c384:	e0bffe17 	ldw	r2,-8(fp)
8113c388:	10c00417 	ldw	r3,16(r2)
8113c38c:	e0bffe17 	ldw	r2,-8(fp)
8113c390:	10800517 	ldw	r2,20(r2)
8113c394:	18804726 	beq	r3,r2,8113c4b4 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
8113c398:	e0bffe17 	ldw	r2,-8(fp)
8113c39c:	10800617 	ldw	r2,24(r2)
8113c3a0:	1080008c 	andi	r2,r2,2
8113c3a4:	10000326 	beq	r2,zero,8113c3b4 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
8113c3a8:	e0bfff17 	ldw	r2,-4(fp)
8113c3ac:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
8113c3b0:	10003226 	beq	r2,zero,8113c47c <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
8113c3b4:	e0bffe17 	ldw	r2,-8(fp)
8113c3b8:	10c00417 	ldw	r3,16(r2)
8113c3bc:	e0bffe17 	ldw	r2,-8(fp)
8113c3c0:	10800517 	ldw	r2,20(r2)
8113c3c4:	10800044 	addi	r2,r2,1
8113c3c8:	10800fcc 	andi	r2,r2,63
8113c3cc:	1880121e 	bne	r3,r2,8113c418 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
8113c3d0:	e0bffe17 	ldw	r2,-8(fp)
8113c3d4:	10800717 	ldw	r2,28(r2)
8113c3d8:	e0bffc15 	stw	r2,-16(fp)
8113c3dc:	00800084 	movi	r2,2
8113c3e0:	e0bffd0d 	sth	r2,-12(fp)
8113c3e4:	00800044 	movi	r2,1
8113c3e8:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113c3ec:	d0a08103 	ldbu	r2,-32252(gp)
8113c3f0:	10803fcc 	andi	r2,r2,255
8113c3f4:	10000826 	beq	r2,zero,8113c418 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
8113c3f8:	e0bffd0b 	ldhu	r2,-12(fp)
8113c3fc:	e0fffd83 	ldbu	r3,-10(fp)
8113c400:	e13ffdc4 	addi	r4,fp,-9
8113c404:	200f883a 	mov	r7,r4
8113c408:	180d883a 	mov	r6,r3
8113c40c:	100b883a 	mov	r5,r2
8113c410:	e13ffc17 	ldw	r4,-16(fp)
8113c414:	11300e80 	call	811300e8 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
8113c418:	e0bffe17 	ldw	r2,-8(fp)
8113c41c:	10800017 	ldw	r2,0(r2)
8113c420:	10800104 	addi	r2,r2,4
8113c424:	e0fffe17 	ldw	r3,-8(fp)
8113c428:	18c00417 	ldw	r3,16(r3)
8113c42c:	e13ffe17 	ldw	r4,-8(fp)
8113c430:	20c7883a 	add	r3,r4,r3
8113c434:	18c01a04 	addi	r3,r3,104
8113c438:	18c00003 	ldbu	r3,0(r3)
8113c43c:	18c03fcc 	andi	r3,r3,255
8113c440:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
8113c444:	e0bffe17 	ldw	r2,-8(fp)
8113c448:	10800417 	ldw	r2,16(r2)
8113c44c:	10800044 	addi	r2,r2,1
8113c450:	e0fffe17 	ldw	r3,-8(fp)
8113c454:	18800415 	stw	r2,16(r3)
8113c458:	10c00fcc 	andi	r3,r2,63
8113c45c:	e0bffe17 	ldw	r2,-8(fp)
8113c460:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
8113c464:	e0bffe17 	ldw	r2,-8(fp)
8113c468:	10800117 	ldw	r2,4(r2)
8113c46c:	10c01014 	ori	r3,r2,64
8113c470:	e0bffe17 	ldw	r2,-8(fp)
8113c474:	10c00115 	stw	r3,4(r2)
8113c478:	00000e06 	br	8113c4b4 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
8113c47c:	e0bffe17 	ldw	r2,-8(fp)
8113c480:	10800017 	ldw	r2,0(r2)
8113c484:	10800204 	addi	r2,r2,8
8113c488:	10800037 	ldwio	r2,0(r2)
8113c48c:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
8113c490:	e0bfff17 	ldw	r2,-4(fp)
8113c494:	1082000c 	andi	r2,r2,2048
8113c498:	1000061e 	bne	r2,zero,8113c4b4 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
8113c49c:	e0bffe17 	ldw	r2,-8(fp)
8113c4a0:	10c00117 	ldw	r3,4(r2)
8113c4a4:	00bfefc4 	movi	r2,-65
8113c4a8:	1886703a 	and	r3,r3,r2
8113c4ac:	e0bffe17 	ldw	r2,-8(fp)
8113c4b0:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
8113c4b4:	e0bffe17 	ldw	r2,-8(fp)
8113c4b8:	10c00417 	ldw	r3,16(r2)
8113c4bc:	e0bffe17 	ldw	r2,-8(fp)
8113c4c0:	10800517 	ldw	r2,20(r2)
8113c4c4:	1880061e 	bne	r3,r2,8113c4e0 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
8113c4c8:	e0bffe17 	ldw	r2,-8(fp)
8113c4cc:	10c00117 	ldw	r3,4(r2)
8113c4d0:	00beefc4 	movi	r2,-1089
8113c4d4:	1886703a 	and	r3,r3,r2
8113c4d8:	e0bffe17 	ldw	r2,-8(fp)
8113c4dc:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8113c4e0:	e0bffe17 	ldw	r2,-8(fp)
8113c4e4:	10800017 	ldw	r2,0(r2)
8113c4e8:	10800304 	addi	r2,r2,12
8113c4ec:	e0fffe17 	ldw	r3,-8(fp)
8113c4f0:	18c00117 	ldw	r3,4(r3)
8113c4f4:	10c00035 	stwio	r3,0(r2)
}
8113c4f8:	0001883a 	nop
8113c4fc:	e037883a 	mov	sp,fp
8113c500:	dfc00117 	ldw	ra,4(sp)
8113c504:	df000017 	ldw	fp,0(sp)
8113c508:	dec00204 	addi	sp,sp,8
8113c50c:	f800283a 	ret

8113c510 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
8113c510:	defffd04 	addi	sp,sp,-12
8113c514:	de00012e 	bgeu	sp,et,8113c51c <altera_avalon_uart_close+0xc>
8113c518:	003b68fa 	trap	3
8113c51c:	df000215 	stw	fp,8(sp)
8113c520:	df000204 	addi	fp,sp,8
8113c524:	e13ffe15 	stw	r4,-8(fp)
8113c528:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
8113c52c:	00000506 	br	8113c544 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
8113c530:	e0bfff17 	ldw	r2,-4(fp)
8113c534:	1090000c 	andi	r2,r2,16384
8113c538:	10000226 	beq	r2,zero,8113c544 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
8113c53c:	00bffd44 	movi	r2,-11
8113c540:	00000606 	br	8113c55c <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
8113c544:	e0bffe17 	ldw	r2,-8(fp)
8113c548:	10c00417 	ldw	r3,16(r2)
8113c54c:	e0bffe17 	ldw	r2,-8(fp)
8113c550:	10800517 	ldw	r2,20(r2)
8113c554:	18bff61e 	bne	r3,r2,8113c530 <__reset+0xfb11c530>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
8113c558:	0005883a 	mov	r2,zero
}
8113c55c:	e037883a 	mov	sp,fp
8113c560:	df000017 	ldw	fp,0(sp)
8113c564:	dec00104 	addi	sp,sp,4
8113c568:	f800283a 	ret

8113c56c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113c56c:	defffe04 	addi	sp,sp,-8
8113c570:	de00012e 	bgeu	sp,et,8113c578 <alt_get_errno+0xc>
8113c574:	003b68fa 	trap	3
8113c578:	dfc00115 	stw	ra,4(sp)
8113c57c:	df000015 	stw	fp,0(sp)
8113c580:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113c584:	d0a01017 	ldw	r2,-32704(gp)
8113c588:	10000326 	beq	r2,zero,8113c598 <alt_get_errno+0x2c>
8113c58c:	d0a01017 	ldw	r2,-32704(gp)
8113c590:	103ee83a 	callr	r2
8113c594:	00000106 	br	8113c59c <alt_get_errno+0x30>
8113c598:	d0a06804 	addi	r2,gp,-32352
}
8113c59c:	e037883a 	mov	sp,fp
8113c5a0:	dfc00117 	ldw	ra,4(sp)
8113c5a4:	df000017 	ldw	fp,0(sp)
8113c5a8:	dec00204 	addi	sp,sp,8
8113c5ac:	f800283a 	ret

8113c5b0 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
8113c5b0:	deffec04 	addi	sp,sp,-80
8113c5b4:	de00012e 	bgeu	sp,et,8113c5bc <altera_avalon_uart_read+0xc>
8113c5b8:	003b68fa 	trap	3
8113c5bc:	dfc01315 	stw	ra,76(sp)
8113c5c0:	df001215 	stw	fp,72(sp)
8113c5c4:	df001204 	addi	fp,sp,72
8113c5c8:	e13ffc15 	stw	r4,-16(fp)
8113c5cc:	e17ffd15 	stw	r5,-12(fp)
8113c5d0:	e1bffe15 	stw	r6,-8(fp)
8113c5d4:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
8113c5d8:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
8113c5dc:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
8113c5e0:	e0bfff17 	ldw	r2,-4(fp)
8113c5e4:	1090000c 	andi	r2,r2,16384
8113c5e8:	1005003a 	cmpeq	r2,r2,zero
8113c5ec:	10803fcc 	andi	r2,r2,255
8113c5f0:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
8113c5f4:	e0bffc17 	ldw	r2,-16(fp)
8113c5f8:	10800817 	ldw	r2,32(r2)
8113c5fc:	e0bff815 	stw	r2,-32(fp)
8113c600:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8113c604:	e0bff90b 	ldhu	r2,-28(fp)
8113c608:	e0fffb44 	addi	r3,fp,-19
8113c60c:	180d883a 	mov	r6,r3
8113c610:	100b883a 	mov	r5,r2
8113c614:	e13ff817 	ldw	r4,-32(fp)
8113c618:	11337600 	call	81133760 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
8113c61c:	00001306 	br	8113c66c <altera_avalon_uart_read+0xbc>
    {
      count++;
8113c620:	e0bff017 	ldw	r2,-64(fp)
8113c624:	10800044 	addi	r2,r2,1
8113c628:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
8113c62c:	e0bffd17 	ldw	r2,-12(fp)
8113c630:	10c00044 	addi	r3,r2,1
8113c634:	e0fffd15 	stw	r3,-12(fp)
8113c638:	e0fffc17 	ldw	r3,-16(fp)
8113c63c:	18c00217 	ldw	r3,8(r3)
8113c640:	e13ffc17 	ldw	r4,-16(fp)
8113c644:	20c7883a 	add	r3,r4,r3
8113c648:	18c00a04 	addi	r3,r3,40
8113c64c:	18c00003 	ldbu	r3,0(r3)
8113c650:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
8113c654:	e0bffc17 	ldw	r2,-16(fp)
8113c658:	10800217 	ldw	r2,8(r2)
8113c65c:	10800044 	addi	r2,r2,1
8113c660:	10c00fcc 	andi	r3,r2,63
8113c664:	e0bffc17 	ldw	r2,-16(fp)
8113c668:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
8113c66c:	e0fff017 	ldw	r3,-64(fp)
8113c670:	e0bffe17 	ldw	r2,-8(fp)
8113c674:	1880050e 	bge	r3,r2,8113c68c <altera_avalon_uart_read+0xdc>
8113c678:	e0bffc17 	ldw	r2,-16(fp)
8113c67c:	10c00217 	ldw	r3,8(r2)
8113c680:	e0bffc17 	ldw	r2,-16(fp)
8113c684:	10800317 	ldw	r2,12(r2)
8113c688:	18bfe51e 	bne	r3,r2,8113c620 <__reset+0xfb11c620>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
8113c68c:	e0bff017 	ldw	r2,-64(fp)
8113c690:	10003a1e 	bne	r2,zero,8113c77c <altera_avalon_uart_read+0x1cc>
8113c694:	e0bffc17 	ldw	r2,-16(fp)
8113c698:	10c00217 	ldw	r3,8(r2)
8113c69c:	e0bffc17 	ldw	r2,-16(fp)
8113c6a0:	10800317 	ldw	r2,12(r2)
8113c6a4:	1880351e 	bne	r3,r2,8113c77c <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
8113c6a8:	e0bff117 	ldw	r2,-60(fp)
8113c6ac:	1000071e 	bne	r2,zero,8113c6cc <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
8113c6b0:	113c56c0 	call	8113c56c <alt_get_errno>
8113c6b4:	1007883a 	mov	r3,r2
8113c6b8:	008002c4 	movi	r2,11
8113c6bc:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
8113c6c0:	00800044 	movi	r2,1
8113c6c4:	e0bfef05 	stb	r2,-68(fp)
        break;
8113c6c8:	00003006 	br	8113c78c <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c6cc:	0005303a 	rdctl	r2,status
8113c6d0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c6d4:	e0fff517 	ldw	r3,-44(fp)
8113c6d8:	00bfff84 	movi	r2,-2
8113c6dc:	1884703a 	and	r2,r3,r2
8113c6e0:	1001703a 	wrctl	status,r2
  
  return context;
8113c6e4:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
8113c6e8:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8113c6ec:	e0bffc17 	ldw	r2,-16(fp)
8113c6f0:	10800117 	ldw	r2,4(r2)
8113c6f4:	10c02014 	ori	r3,r2,128
8113c6f8:	e0bffc17 	ldw	r2,-16(fp)
8113c6fc:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8113c700:	e0bffc17 	ldw	r2,-16(fp)
8113c704:	10800017 	ldw	r2,0(r2)
8113c708:	10800304 	addi	r2,r2,12
8113c70c:	e0fffc17 	ldw	r3,-16(fp)
8113c710:	18c00117 	ldw	r3,4(r3)
8113c714:	10c00035 	stwio	r3,0(r2)
8113c718:	e0bff417 	ldw	r2,-48(fp)
8113c71c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c720:	e0bff617 	ldw	r2,-40(fp)
8113c724:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
8113c728:	e0bffc17 	ldw	r2,-16(fp)
8113c72c:	10800717 	ldw	r2,28(r2)
8113c730:	e0bff215 	stw	r2,-56(fp)
8113c734:	00800044 	movi	r2,1
8113c738:	e0bff98d 	sth	r2,-26(fp)
8113c73c:	00bfe0c4 	movi	r2,-125
8113c740:	e0bffa05 	stb	r2,-24(fp)
8113c744:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8113c748:	d0a08103 	ldbu	r2,-32252(gp)
8113c74c:	10803fcc 	andi	r2,r2,255
8113c750:	10000a26 	beq	r2,zero,8113c77c <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8113c754:	e0fff98b 	ldhu	r3,-26(fp)
8113c758:	e13ffa03 	ldbu	r4,-24(fp)
8113c75c:	e17ffa8b 	ldhu	r5,-22(fp)
8113c760:	e0bffb04 	addi	r2,fp,-20
8113c764:	d8800015 	stw	r2,0(sp)
8113c768:	280f883a 	mov	r7,r5
8113c76c:	200d883a 	mov	r6,r4
8113c770:	180b883a 	mov	r5,r3
8113c774:	e13ff217 	ldw	r4,-56(fp)
8113c778:	112fac00 	call	8112fac0 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
8113c77c:	e0bff017 	ldw	r2,-64(fp)
8113c780:	1000021e 	bne	r2,zero,8113c78c <altera_avalon_uart_read+0x1dc>
8113c784:	e0bffe17 	ldw	r2,-8(fp)
8113c788:	103fb81e 	bne	r2,zero,8113c66c <__reset+0xfb11c66c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
8113c78c:	e0bffc17 	ldw	r2,-16(fp)
8113c790:	10800817 	ldw	r2,32(r2)
8113c794:	1009883a 	mov	r4,r2
8113c798:	1133ae80 	call	81133ae8 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c79c:	0005303a 	rdctl	r2,status
8113c7a0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c7a4:	e0fff717 	ldw	r3,-36(fp)
8113c7a8:	00bfff84 	movi	r2,-2
8113c7ac:	1884703a 	and	r2,r3,r2
8113c7b0:	1001703a 	wrctl	status,r2
  
  return context;
8113c7b4:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
8113c7b8:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8113c7bc:	e0bffc17 	ldw	r2,-16(fp)
8113c7c0:	10800117 	ldw	r2,4(r2)
8113c7c4:	10c02014 	ori	r3,r2,128
8113c7c8:	e0bffc17 	ldw	r2,-16(fp)
8113c7cc:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8113c7d0:	e0bffc17 	ldw	r2,-16(fp)
8113c7d4:	10800017 	ldw	r2,0(r2)
8113c7d8:	10800304 	addi	r2,r2,12
8113c7dc:	e0fffc17 	ldw	r3,-16(fp)
8113c7e0:	18c00117 	ldw	r3,4(r3)
8113c7e4:	10c00035 	stwio	r3,0(r2)
8113c7e8:	e0bff417 	ldw	r2,-48(fp)
8113c7ec:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c7f0:	e0bff317 	ldw	r2,-52(fp)
8113c7f4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
8113c7f8:	e0bfef03 	ldbu	r2,-68(fp)
8113c7fc:	10000226 	beq	r2,zero,8113c808 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
8113c800:	00bffd44 	movi	r2,-11
8113c804:	00000106 	br	8113c80c <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
8113c808:	e0bff017 	ldw	r2,-64(fp)
  }
}
8113c80c:	e037883a 	mov	sp,fp
8113c810:	dfc00117 	ldw	ra,4(sp)
8113c814:	df000017 	ldw	fp,0(sp)
8113c818:	dec00204 	addi	sp,sp,8
8113c81c:	f800283a 	ret

8113c820 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113c820:	defffe04 	addi	sp,sp,-8
8113c824:	de00012e 	bgeu	sp,et,8113c82c <alt_get_errno+0xc>
8113c828:	003b68fa 	trap	3
8113c82c:	dfc00115 	stw	ra,4(sp)
8113c830:	df000015 	stw	fp,0(sp)
8113c834:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113c838:	d0a01017 	ldw	r2,-32704(gp)
8113c83c:	10000326 	beq	r2,zero,8113c84c <alt_get_errno+0x2c>
8113c840:	d0a01017 	ldw	r2,-32704(gp)
8113c844:	103ee83a 	callr	r2
8113c848:	00000106 	br	8113c850 <alt_get_errno+0x30>
8113c84c:	d0a06804 	addi	r2,gp,-32352
}
8113c850:	e037883a 	mov	sp,fp
8113c854:	dfc00117 	ldw	ra,4(sp)
8113c858:	df000017 	ldw	fp,0(sp)
8113c85c:	dec00204 	addi	sp,sp,8
8113c860:	f800283a 	ret

8113c864 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
8113c864:	deffec04 	addi	sp,sp,-80
8113c868:	de00012e 	bgeu	sp,et,8113c870 <altera_avalon_uart_write+0xc>
8113c86c:	003b68fa 	trap	3
8113c870:	dfc01315 	stw	ra,76(sp)
8113c874:	df001215 	stw	fp,72(sp)
8113c878:	df001204 	addi	fp,sp,72
8113c87c:	e13ffc15 	stw	r4,-16(fp)
8113c880:	e17ffd15 	stw	r5,-12(fp)
8113c884:	e1bffe15 	stw	r6,-8(fp)
8113c888:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
8113c88c:	e0bffe17 	ldw	r2,-8(fp)
8113c890:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
8113c894:	e0bfff17 	ldw	r2,-4(fp)
8113c898:	1090000c 	andi	r2,r2,16384
8113c89c:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
8113c8a0:	e0bffc17 	ldw	r2,-16(fp)
8113c8a4:	10800917 	ldw	r2,36(r2)
8113c8a8:	e0bff815 	stw	r2,-32(fp)
8113c8ac:	e03ff90d 	sth	zero,-28(fp)
8113c8b0:	e0bff90b 	ldhu	r2,-28(fp)
8113c8b4:	e0fffb44 	addi	r3,fp,-19
8113c8b8:	180d883a 	mov	r6,r3
8113c8bc:	100b883a 	mov	r5,r2
8113c8c0:	e13ff817 	ldw	r4,-32(fp)
8113c8c4:	11337600 	call	81133760 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
8113c8c8:	00005106 	br	8113ca10 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8113c8cc:	e0bffc17 	ldw	r2,-16(fp)
8113c8d0:	10800517 	ldw	r2,20(r2)
8113c8d4:	10800044 	addi	r2,r2,1
8113c8d8:	10800fcc 	andi	r2,r2,63
8113c8dc:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
8113c8e0:	e0bffc17 	ldw	r2,-16(fp)
8113c8e4:	10c00417 	ldw	r3,16(r2)
8113c8e8:	e0bff217 	ldw	r2,-56(fp)
8113c8ec:	1880371e 	bne	r3,r2,8113c9cc <altera_avalon_uart_write+0x168>
    {
      if (no_block)
8113c8f0:	e0bff017 	ldw	r2,-64(fp)
8113c8f4:	10000526 	beq	r2,zero,8113c90c <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
8113c8f8:	113c8200 	call	8113c820 <alt_get_errno>
8113c8fc:	1007883a 	mov	r3,r2
8113c900:	008002c4 	movi	r2,11
8113c904:	18800015 	stw	r2,0(r3)
        break;
8113c908:	00004306 	br	8113ca18 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c90c:	0005303a 	rdctl	r2,status
8113c910:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c914:	e0fff517 	ldw	r3,-44(fp)
8113c918:	00bfff84 	movi	r2,-2
8113c91c:	1884703a 	and	r2,r3,r2
8113c920:	1001703a 	wrctl	status,r2
  
  return context;
8113c924:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
8113c928:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
8113c92c:	e0bffc17 	ldw	r2,-16(fp)
8113c930:	10800117 	ldw	r2,4(r2)
8113c934:	10c11014 	ori	r3,r2,1088
8113c938:	e0bffc17 	ldw	r2,-16(fp)
8113c93c:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8113c940:	e0bffc17 	ldw	r2,-16(fp)
8113c944:	10800017 	ldw	r2,0(r2)
8113c948:	10800304 	addi	r2,r2,12
8113c94c:	e0fffc17 	ldw	r3,-16(fp)
8113c950:	18c00117 	ldw	r3,4(r3)
8113c954:	10c00035 	stwio	r3,0(r2)
8113c958:	e0bff417 	ldw	r2,-48(fp)
8113c95c:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c960:	e0bff117 	ldw	r2,-60(fp)
8113c964:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
8113c968:	e0bffc17 	ldw	r2,-16(fp)
8113c96c:	10800717 	ldw	r2,28(r2)
8113c970:	e0bff315 	stw	r2,-52(fp)
8113c974:	00800084 	movi	r2,2
8113c978:	e0bff98d 	sth	r2,-26(fp)
8113c97c:	00bfe0c4 	movi	r2,-125
8113c980:	e0bffa05 	stb	r2,-24(fp)
8113c984:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8113c988:	d0a08103 	ldbu	r2,-32252(gp)
8113c98c:	10803fcc 	andi	r2,r2,255
8113c990:	10000a26 	beq	r2,zero,8113c9bc <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8113c994:	e0fff98b 	ldhu	r3,-26(fp)
8113c998:	e13ffa03 	ldbu	r4,-24(fp)
8113c99c:	e17ffa8b 	ldhu	r5,-22(fp)
8113c9a0:	e0bffb04 	addi	r2,fp,-20
8113c9a4:	d8800015 	stw	r2,0(sp)
8113c9a8:	280f883a 	mov	r7,r5
8113c9ac:	200d883a 	mov	r6,r4
8113c9b0:	180b883a 	mov	r5,r3
8113c9b4:	e13ff317 	ldw	r4,-52(fp)
8113c9b8:	112fac00 	call	8112fac0 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
8113c9bc:	e0bffc17 	ldw	r2,-16(fp)
8113c9c0:	10c00417 	ldw	r3,16(r2)
8113c9c4:	e0bff217 	ldw	r2,-56(fp)
8113c9c8:	18bfe726 	beq	r3,r2,8113c968 <__reset+0xfb11c968>
      }
    }

    count--;
8113c9cc:	e0bfef17 	ldw	r2,-68(fp)
8113c9d0:	10bfffc4 	addi	r2,r2,-1
8113c9d4:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
8113c9d8:	e0bffc17 	ldw	r2,-16(fp)
8113c9dc:	10c00517 	ldw	r3,20(r2)
8113c9e0:	e0bffd17 	ldw	r2,-12(fp)
8113c9e4:	11000044 	addi	r4,r2,1
8113c9e8:	e13ffd15 	stw	r4,-12(fp)
8113c9ec:	10800003 	ldbu	r2,0(r2)
8113c9f0:	1009883a 	mov	r4,r2
8113c9f4:	e0bffc17 	ldw	r2,-16(fp)
8113c9f8:	10c5883a 	add	r2,r2,r3
8113c9fc:	10801a04 	addi	r2,r2,104
8113ca00:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
8113ca04:	e0bffc17 	ldw	r2,-16(fp)
8113ca08:	e0fff217 	ldw	r3,-56(fp)
8113ca0c:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
8113ca10:	e0bfef17 	ldw	r2,-68(fp)
8113ca14:	103fad1e 	bne	r2,zero,8113c8cc <__reset+0xfb11c8cc>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
8113ca18:	e0bffc17 	ldw	r2,-16(fp)
8113ca1c:	10800917 	ldw	r2,36(r2)
8113ca20:	1009883a 	mov	r4,r2
8113ca24:	1133ae80 	call	81133ae8 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ca28:	0005303a 	rdctl	r2,status
8113ca2c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ca30:	e0fff717 	ldw	r3,-36(fp)
8113ca34:	00bfff84 	movi	r2,-2
8113ca38:	1884703a 	and	r2,r3,r2
8113ca3c:	1001703a 	wrctl	status,r2
  
  return context;
8113ca40:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
8113ca44:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
8113ca48:	e0bffc17 	ldw	r2,-16(fp)
8113ca4c:	10800117 	ldw	r2,4(r2)
8113ca50:	10c11014 	ori	r3,r2,1088
8113ca54:	e0bffc17 	ldw	r2,-16(fp)
8113ca58:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8113ca5c:	e0bffc17 	ldw	r2,-16(fp)
8113ca60:	10800017 	ldw	r2,0(r2)
8113ca64:	10800304 	addi	r2,r2,12
8113ca68:	e0fffc17 	ldw	r3,-16(fp)
8113ca6c:	18c00117 	ldw	r3,4(r3)
8113ca70:	10c00035 	stwio	r3,0(r2)
8113ca74:	e0bff417 	ldw	r2,-48(fp)
8113ca78:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ca7c:	e0bff617 	ldw	r2,-40(fp)
8113ca80:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
8113ca84:	e0fffe17 	ldw	r3,-8(fp)
8113ca88:	e0bfef17 	ldw	r2,-68(fp)
8113ca8c:	1885c83a 	sub	r2,r3,r2
}
8113ca90:	e037883a 	mov	sp,fp
8113ca94:	dfc00117 	ldw	ra,4(sp)
8113ca98:	df000017 	ldw	fp,0(sp)
8113ca9c:	dec00204 	addi	sp,sp,8
8113caa0:	f800283a 	ret

8113caa4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113caa4:	defffe04 	addi	sp,sp,-8
8113caa8:	de00012e 	bgeu	sp,et,8113cab0 <alt_get_errno+0xc>
8113caac:	003b68fa 	trap	3
8113cab0:	dfc00115 	stw	ra,4(sp)
8113cab4:	df000015 	stw	fp,0(sp)
8113cab8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113cabc:	d0a01017 	ldw	r2,-32704(gp)
8113cac0:	10000326 	beq	r2,zero,8113cad0 <alt_get_errno+0x2c>
8113cac4:	d0a01017 	ldw	r2,-32704(gp)
8113cac8:	103ee83a 	callr	r2
8113cacc:	00000106 	br	8113cad4 <alt_get_errno+0x30>
8113cad0:	d0a06804 	addi	r2,gp,-32352
}
8113cad4:	e037883a 	mov	sp,fp
8113cad8:	dfc00117 	ldw	ra,4(sp)
8113cadc:	df000017 	ldw	fp,0(sp)
8113cae0:	dec00204 	addi	sp,sp,8
8113cae4:	f800283a 	ret

8113cae8 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
8113cae8:	defffc04 	addi	sp,sp,-16
8113caec:	de00012e 	bgeu	sp,et,8113caf4 <alt_msgdma_write_standard_descriptor+0xc>
8113caf0:	003b68fa 	trap	3
8113caf4:	df000315 	stw	fp,12(sp)
8113caf8:	df000304 	addi	fp,sp,12
8113cafc:	e13ffd15 	stw	r4,-12(fp)
8113cb00:	e17ffe15 	stw	r5,-8(fp)
8113cb04:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
8113cb08:	e0bffd17 	ldw	r2,-12(fp)
8113cb0c:	10800037 	ldwio	r2,0(r2)
8113cb10:	1080010c 	andi	r2,r2,4
8113cb14:	10000226 	beq	r2,zero,8113cb20 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
8113cb18:	00bff904 	movi	r2,-28
8113cb1c:	00001506 	br	8113cb74 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
8113cb20:	e0bfff17 	ldw	r2,-4(fp)
8113cb24:	10800017 	ldw	r2,0(r2)
8113cb28:	1007883a 	mov	r3,r2
8113cb2c:	e0bffe17 	ldw	r2,-8(fp)
8113cb30:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
8113cb34:	e0bffe17 	ldw	r2,-8(fp)
8113cb38:	10800104 	addi	r2,r2,4
8113cb3c:	e0ffff17 	ldw	r3,-4(fp)
8113cb40:	18c00117 	ldw	r3,4(r3)
8113cb44:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
8113cb48:	e0bffe17 	ldw	r2,-8(fp)
8113cb4c:	10800204 	addi	r2,r2,8
8113cb50:	e0ffff17 	ldw	r3,-4(fp)
8113cb54:	18c00217 	ldw	r3,8(r3)
8113cb58:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
8113cb5c:	e0bffe17 	ldw	r2,-8(fp)
8113cb60:	10800304 	addi	r2,r2,12
8113cb64:	e0ffff17 	ldw	r3,-4(fp)
8113cb68:	18c00317 	ldw	r3,12(r3)
8113cb6c:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
8113cb70:	0005883a 	mov	r2,zero
}
8113cb74:	e037883a 	mov	sp,fp
8113cb78:	df000017 	ldw	fp,0(sp)
8113cb7c:	dec00104 	addi	sp,sp,4
8113cb80:	f800283a 	ret

8113cb84 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
8113cb84:	defffc04 	addi	sp,sp,-16
8113cb88:	de00012e 	bgeu	sp,et,8113cb90 <alt_msgdma_write_extended_descriptor+0xc>
8113cb8c:	003b68fa 	trap	3
8113cb90:	df000315 	stw	fp,12(sp)
8113cb94:	df000304 	addi	fp,sp,12
8113cb98:	e13ffd15 	stw	r4,-12(fp)
8113cb9c:	e17ffe15 	stw	r5,-8(fp)
8113cba0:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
8113cba4:	e0bffd17 	ldw	r2,-12(fp)
8113cba8:	10800037 	ldwio	r2,0(r2)
8113cbac:	1080010c 	andi	r2,r2,4
8113cbb0:	10000226 	beq	r2,zero,8113cbbc <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
8113cbb4:	00bff904 	movi	r2,-28
8113cbb8:	00003b06 	br	8113cca8 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
8113cbbc:	e0bfff17 	ldw	r2,-4(fp)
8113cbc0:	10800017 	ldw	r2,0(r2)
8113cbc4:	1007883a 	mov	r3,r2
8113cbc8:	e0bffe17 	ldw	r2,-8(fp)
8113cbcc:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
8113cbd0:	e0bffe17 	ldw	r2,-8(fp)
8113cbd4:	10800104 	addi	r2,r2,4
8113cbd8:	e0ffff17 	ldw	r3,-4(fp)
8113cbdc:	18c00117 	ldw	r3,4(r3)
8113cbe0:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
8113cbe4:	e0bffe17 	ldw	r2,-8(fp)
8113cbe8:	10800204 	addi	r2,r2,8
8113cbec:	e0ffff17 	ldw	r3,-4(fp)
8113cbf0:	18c00217 	ldw	r3,8(r3)
8113cbf4:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
8113cbf8:	e0bffe17 	ldw	r2,-8(fp)
8113cbfc:	10800304 	addi	r2,r2,12
8113cc00:	e0ffff17 	ldw	r3,-4(fp)
8113cc04:	18c0030b 	ldhu	r3,12(r3)
8113cc08:	18ffffcc 	andi	r3,r3,65535
8113cc0c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
8113cc10:	e0bffe17 	ldw	r2,-8(fp)
8113cc14:	10800384 	addi	r2,r2,14
8113cc18:	e0ffff17 	ldw	r3,-4(fp)
8113cc1c:	18c00383 	ldbu	r3,14(r3)
8113cc20:	18c03fcc 	andi	r3,r3,255
8113cc24:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
8113cc28:	e0bffe17 	ldw	r2,-8(fp)
8113cc2c:	108003c4 	addi	r2,r2,15
8113cc30:	e0ffff17 	ldw	r3,-4(fp)
8113cc34:	18c003c3 	ldbu	r3,15(r3)
8113cc38:	18c03fcc 	andi	r3,r3,255
8113cc3c:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
8113cc40:	e0bffe17 	ldw	r2,-8(fp)
8113cc44:	10800404 	addi	r2,r2,16
8113cc48:	e0ffff17 	ldw	r3,-4(fp)
8113cc4c:	18c0040b 	ldhu	r3,16(r3)
8113cc50:	18ffffcc 	andi	r3,r3,65535
8113cc54:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
8113cc58:	e0bffe17 	ldw	r2,-8(fp)
8113cc5c:	10800484 	addi	r2,r2,18
8113cc60:	e0ffff17 	ldw	r3,-4(fp)
8113cc64:	18c0048b 	ldhu	r3,18(r3)
8113cc68:	18ffffcc 	andi	r3,r3,65535
8113cc6c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
8113cc70:	e0bffe17 	ldw	r2,-8(fp)
8113cc74:	10800504 	addi	r2,r2,20
8113cc78:	0007883a 	mov	r3,zero
8113cc7c:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
8113cc80:	e0bffe17 	ldw	r2,-8(fp)
8113cc84:	10800604 	addi	r2,r2,24
8113cc88:	0007883a 	mov	r3,zero
8113cc8c:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
8113cc90:	e0bffe17 	ldw	r2,-8(fp)
8113cc94:	10800704 	addi	r2,r2,28
8113cc98:	e0ffff17 	ldw	r3,-4(fp)
8113cc9c:	18c00717 	ldw	r3,28(r3)
8113cca0:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
8113cca4:	0005883a 	mov	r2,zero
}
8113cca8:	e037883a 	mov	sp,fp
8113ccac:	df000017 	ldw	fp,0(sp)
8113ccb0:	dec00104 	addi	sp,sp,4
8113ccb4:	f800283a 	ret

8113ccb8 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
8113ccb8:	defff804 	addi	sp,sp,-32
8113ccbc:	de00012e 	bgeu	sp,et,8113ccc4 <alt_msgdma_irq+0xc>
8113ccc0:	003b68fa 	trap	3
8113ccc4:	dfc00715 	stw	ra,28(sp)
8113ccc8:	df000615 	stw	fp,24(sp)
8113cccc:	df000604 	addi	fp,sp,24
8113ccd0:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
8113ccd4:	e0bfff17 	ldw	r2,-4(fp)
8113ccd8:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
8113ccdc:	e0bffa17 	ldw	r2,-24(fp)
8113cce0:	10801783 	ldbu	r2,94(r2)
8113cce4:	10803fcc 	andi	r2,r2,255
8113cce8:	10001126 	beq	r2,zero,8113cd30 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
8113ccec:	e0bffa17 	ldw	r2,-24(fp)
8113ccf0:	10800617 	ldw	r2,24(r2)
8113ccf4:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
8113ccf8:	1007883a 	mov	r3,r2
8113ccfc:	00bffdc4 	movi	r2,-9
8113cd00:	1884703a 	and	r2,r3,r2
8113cd04:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
8113cd08:	e0bffa17 	ldw	r2,-24(fp)
8113cd0c:	10800617 	ldw	r2,24(r2)
8113cd10:	e0fffb17 	ldw	r3,-20(fp)
8113cd14:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
8113cd18:	e0bffa17 	ldw	r2,-24(fp)
8113cd1c:	10800617 	ldw	r2,24(r2)
8113cd20:	10800404 	addi	r2,r2,16
8113cd24:	00c00044 	movi	r3,1
8113cd28:	10c00035 	stwio	r3,0(r2)
8113cd2c:	00001106 	br	8113cd74 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8113cd30:	e0bffa17 	ldw	r2,-24(fp)
8113cd34:	10800317 	ldw	r2,12(r2)
8113cd38:	10800104 	addi	r2,r2,4
8113cd3c:	10800037 	ldwio	r2,0(r2)
8113cd40:	1007883a 	mov	r3,r2
8113cd44:	00bffbc4 	movi	r2,-17
8113cd48:	1884703a 	and	r2,r3,r2
8113cd4c:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8113cd50:	e0bffa17 	ldw	r2,-24(fp)
8113cd54:	10800317 	ldw	r2,12(r2)
8113cd58:	10800104 	addi	r2,r2,4
8113cd5c:	e0fffb17 	ldw	r3,-20(fp)
8113cd60:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8113cd64:	e0bffa17 	ldw	r2,-24(fp)
8113cd68:	10800317 	ldw	r2,12(r2)
8113cd6c:	00c08004 	movi	r3,512
8113cd70:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
8113cd74:	e0bffa17 	ldw	r2,-24(fp)
8113cd78:	10800b17 	ldw	r2,44(r2)
8113cd7c:	10001226 	beq	r2,zero,8113cdc8 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cd80:	0005303a 	rdctl	r2,status
8113cd84:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cd88:	e0fffd17 	ldw	r3,-12(fp)
8113cd8c:	00bfff84 	movi	r2,-2
8113cd90:	1884703a 	and	r2,r3,r2
8113cd94:	1001703a 	wrctl	status,r2
  
  return context;
8113cd98:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
8113cd9c:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
8113cda0:	e0bffa17 	ldw	r2,-24(fp)
8113cda4:	10800b17 	ldw	r2,44(r2)
8113cda8:	e0fffa17 	ldw	r3,-24(fp)
8113cdac:	18c00c17 	ldw	r3,48(r3)
8113cdb0:	1809883a 	mov	r4,r3
8113cdb4:	103ee83a 	callr	r2
8113cdb8:	e0bffc17 	ldw	r2,-16(fp)
8113cdbc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cdc0:	e0bffe17 	ldw	r2,-8(fp)
8113cdc4:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
8113cdc8:	e0bffa17 	ldw	r2,-24(fp)
8113cdcc:	10801783 	ldbu	r2,94(r2)
8113cdd0:	10803fcc 	andi	r2,r2,255
8113cdd4:	10000a26 	beq	r2,zero,8113ce00 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
8113cdd8:	e0bffa17 	ldw	r2,-24(fp)
8113cddc:	10800617 	ldw	r2,24(r2)
8113cde0:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8113cde4:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
8113cde8:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
8113cdec:	e0bffa17 	ldw	r2,-24(fp)
8113cdf0:	10800617 	ldw	r2,24(r2)
8113cdf4:	e0fffb17 	ldw	r3,-20(fp)
8113cdf8:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
8113cdfc:	00000c06 	br	8113ce30 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8113ce00:	e0bffa17 	ldw	r2,-24(fp)
8113ce04:	10800317 	ldw	r2,12(r2)
8113ce08:	10800104 	addi	r2,r2,4
8113ce0c:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
8113ce10:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8113ce14:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8113ce18:	e0bffa17 	ldw	r2,-24(fp)
8113ce1c:	10800317 	ldw	r2,12(r2)
8113ce20:	10800104 	addi	r2,r2,4
8113ce24:	e0fffb17 	ldw	r3,-20(fp)
8113ce28:	10c00035 	stwio	r3,0(r2)
    }

    return;
8113ce2c:	0001883a 	nop
}
8113ce30:	e037883a 	mov	sp,fp
8113ce34:	dfc00117 	ldw	ra,4(sp)
8113ce38:	df000017 	ldw	fp,0(sp)
8113ce3c:	dec00204 	addi	sp,sp,8
8113ce40:	f800283a 	ret

8113ce44 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113ce44:	defffb04 	addi	sp,sp,-20
8113ce48:	de00012e 	bgeu	sp,et,8113ce50 <alt_msgdma_construct_standard_descriptor+0xc>
8113ce4c:	003b68fa 	trap	3
8113ce50:	df000415 	stw	fp,16(sp)
8113ce54:	df000404 	addi	fp,sp,16
8113ce58:	e13ffc15 	stw	r4,-16(fp)
8113ce5c:	e17ffd15 	stw	r5,-12(fp)
8113ce60:	e1bffe15 	stw	r6,-8(fp)
8113ce64:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8113ce68:	e0bffc17 	ldw	r2,-16(fp)
8113ce6c:	10c01217 	ldw	r3,72(r2)
8113ce70:	e0800117 	ldw	r2,4(fp)
8113ce74:	18800436 	bltu	r3,r2,8113ce88 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
8113ce78:	e0bffc17 	ldw	r2,-16(fp)
8113ce7c:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8113ce80:	10803fcc 	andi	r2,r2,255
8113ce84:	10000226 	beq	r2,zero,8113ce90 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8113ce88:	00bffa84 	movi	r2,-22
8113ce8c:	00000e06 	br	8113cec8 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
8113ce90:	e0bffd17 	ldw	r2,-12(fp)
8113ce94:	e0fffe17 	ldw	r3,-8(fp)
8113ce98:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8113ce9c:	e0bffd17 	ldw	r2,-12(fp)
8113cea0:	e0ffff17 	ldw	r3,-4(fp)
8113cea4:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8113cea8:	e0bffd17 	ldw	r2,-12(fp)
8113ceac:	e0c00117 	ldw	r3,4(fp)
8113ceb0:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8113ceb4:	e0800217 	ldw	r2,8(fp)
8113ceb8:	10e00034 	orhi	r3,r2,32768
8113cebc:	e0bffd17 	ldw	r2,-12(fp)
8113cec0:	10c00315 	stw	r3,12(r2)
    
    return 0;
8113cec4:	0005883a 	mov	r2,zero
}
8113cec8:	e037883a 	mov	sp,fp
8113cecc:	df000017 	ldw	fp,0(sp)
8113ced0:	dec00104 	addi	sp,sp,4
8113ced4:	f800283a 	ret

8113ced8 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8113ced8:	defff604 	addi	sp,sp,-40
8113cedc:	de00012e 	bgeu	sp,et,8113cee4 <alt_msgdma_construct_extended_descriptor+0xc>
8113cee0:	003b68fa 	trap	3
8113cee4:	df000915 	stw	fp,36(sp)
8113cee8:	df000904 	addi	fp,sp,36
8113ceec:	e13ff715 	stw	r4,-36(fp)
8113cef0:	e17ff815 	stw	r5,-32(fp)
8113cef4:	e1bff915 	stw	r6,-28(fp)
8113cef8:	e1fffa15 	stw	r7,-24(fp)
8113cefc:	e1800317 	ldw	r6,12(fp)
8113cf00:	e1400417 	ldw	r5,16(fp)
8113cf04:	e1000517 	ldw	r4,20(fp)
8113cf08:	e0c00617 	ldw	r3,24(fp)
8113cf0c:	e0800717 	ldw	r2,28(fp)
8113cf10:	e1bffb0d 	sth	r6,-20(fp)
8113cf14:	e17ffc05 	stb	r5,-16(fp)
8113cf18:	e13ffd05 	stb	r4,-12(fp)
8113cf1c:	e0fffe0d 	sth	r3,-8(fp)
8113cf20:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
8113cf24:	e0bff717 	ldw	r2,-36(fp)
8113cf28:	10c01217 	ldw	r3,72(r2)
8113cf2c:	e0800117 	ldw	r2,4(fp)
8113cf30:	18801936 	bltu	r3,r2,8113cf98 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8113cf34:	e13ff717 	ldw	r4,-36(fp)
8113cf38:	20801317 	ldw	r2,76(r4)
8113cf3c:	20c01417 	ldw	r3,80(r4)
8113cf40:	e13ffe0b 	ldhu	r4,-8(fp)
8113cf44:	213fffcc 	andi	r4,r4,65535
8113cf48:	2015883a 	mov	r10,r4
8113cf4c:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
8113cf50:	1ac01136 	bltu	r3,r11,8113cf98 <alt_msgdma_construct_extended_descriptor+0xc0>
8113cf54:	58c0011e 	bne	r11,r3,8113cf5c <alt_msgdma_construct_extended_descriptor+0x84>
8113cf58:	12800f36 	bltu	r2,r10,8113cf98 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8113cf5c:	e13ff717 	ldw	r4,-36(fp)
8113cf60:	20801317 	ldw	r2,76(r4)
8113cf64:	20c01417 	ldw	r3,80(r4)
8113cf68:	e13fff0b 	ldhu	r4,-4(fp)
8113cf6c:	213fffcc 	andi	r4,r4,65535
8113cf70:	2011883a 	mov	r8,r4
8113cf74:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
8113cf78:	1a400736 	bltu	r3,r9,8113cf98 <alt_msgdma_construct_extended_descriptor+0xc0>
8113cf7c:	48c0011e 	bne	r9,r3,8113cf84 <alt_msgdma_construct_extended_descriptor+0xac>
8113cf80:	12000536 	bltu	r2,r8,8113cf98 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8113cf84:	e0bff717 	ldw	r2,-36(fp)
8113cf88:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8113cf8c:	10803fcc 	andi	r2,r2,255
8113cf90:	10800060 	cmpeqi	r2,r2,1
8113cf94:	1000021e 	bne	r2,zero,8113cfa0 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8113cf98:	00bffa84 	movi	r2,-22
8113cf9c:	00002106 	br	8113d024 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
8113cfa0:	e0bff817 	ldw	r2,-32(fp)
8113cfa4:	e0fff917 	ldw	r3,-28(fp)
8113cfa8:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
8113cfac:	e0bff817 	ldw	r2,-32(fp)
8113cfb0:	e0fffa17 	ldw	r3,-24(fp)
8113cfb4:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8113cfb8:	e0bff817 	ldw	r2,-32(fp)
8113cfbc:	e0c00117 	ldw	r3,4(fp)
8113cfc0:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8113cfc4:	e0bff817 	ldw	r2,-32(fp)
8113cfc8:	e0fffb0b 	ldhu	r3,-20(fp)
8113cfcc:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
8113cfd0:	e0bff817 	ldw	r2,-32(fp)
8113cfd4:	e0fffc03 	ldbu	r3,-16(fp)
8113cfd8:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
8113cfdc:	e0bff817 	ldw	r2,-32(fp)
8113cfe0:	e0fffd03 	ldbu	r3,-12(fp)
8113cfe4:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
8113cfe8:	e0bff817 	ldw	r2,-32(fp)
8113cfec:	e0fffe0b 	ldhu	r3,-8(fp)
8113cff0:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
8113cff4:	e0bff817 	ldw	r2,-32(fp)
8113cff8:	e0ffff0b 	ldhu	r3,-4(fp)
8113cffc:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
8113d000:	e0bff817 	ldw	r2,-32(fp)
8113d004:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
8113d008:	e0bff817 	ldw	r2,-32(fp)
8113d00c:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8113d010:	e0800217 	ldw	r2,8(fp)
8113d014:	10e00034 	orhi	r3,r2,32768
8113d018:	e0bff817 	ldw	r2,-32(fp)
8113d01c:	10c00715 	stw	r3,28(r2)

  return 0 ;
8113d020:	0005883a 	mov	r2,zero

}
8113d024:	e037883a 	mov	sp,fp
8113d028:	df000017 	ldw	fp,0(sp)
8113d02c:	dec00104 	addi	sp,sp,4
8113d030:	f800283a 	ret

8113d034 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8113d034:	deffee04 	addi	sp,sp,-72
8113d038:	de00012e 	bgeu	sp,et,8113d040 <alt_msgdma_descriptor_async_transfer+0xc>
8113d03c:	003b68fa 	trap	3
8113d040:	dfc01115 	stw	ra,68(sp)
8113d044:	df001015 	stw	fp,64(sp)
8113d048:	df001004 	addi	fp,sp,64
8113d04c:	e13ffd15 	stw	r4,-12(fp)
8113d050:	e17ffe15 	stw	r5,-8(fp)
8113d054:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
8113d058:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
8113d05c:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
8113d060:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113d064:	e0bffd17 	ldw	r2,-12(fp)
8113d068:	10800317 	ldw	r2,12(r2)
8113d06c:	10800204 	addi	r2,r2,8
8113d070:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8113d074:	10bfffcc 	andi	r2,r2,65535
8113d078:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113d07c:	e0bffd17 	ldw	r2,-12(fp)
8113d080:	10800317 	ldw	r2,12(r2)
8113d084:	10800204 	addi	r2,r2,8
8113d088:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8113d08c:	1004d43a 	srli	r2,r2,16
8113d090:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8113d094:	e0bffd17 	ldw	r2,-12(fp)
8113d098:	10800917 	ldw	r2,36(r2)
8113d09c:	e0fff417 	ldw	r3,-48(fp)
8113d0a0:	1880042e 	bgeu	r3,r2,8113d0b4 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8113d0a4:	e0bffd17 	ldw	r2,-12(fp)
8113d0a8:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8113d0ac:	e0fff317 	ldw	r3,-52(fp)
8113d0b0:	18800236 	bltu	r3,r2,8113d0bc <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
8113d0b4:	00bff904 	movi	r2,-28
8113d0b8:	0000a906 	br	8113d360 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
8113d0bc:	e0bffd17 	ldw	r2,-12(fp)
8113d0c0:	10801817 	ldw	r2,96(r2)
8113d0c4:	e0bff615 	stw	r2,-40(fp)
8113d0c8:	e03ffc0d 	sth	zero,-16(fp)
8113d0cc:	e0bffc0b 	ldhu	r2,-16(fp)
8113d0d0:	e0fffc84 	addi	r3,fp,-14
8113d0d4:	180d883a 	mov	r6,r3
8113d0d8:	100b883a 	mov	r5,r2
8113d0dc:	e13ff617 	ldw	r4,-40(fp)
8113d0e0:	11337600 	call	81133760 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8113d0e4:	00800804 	movi	r2,32
8113d0e8:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d0ec:	0005303a 	rdctl	r2,status
8113d0f0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d0f4:	e0fff717 	ldw	r3,-36(fp)
8113d0f8:	00bfff84 	movi	r2,-2
8113d0fc:	1884703a 	and	r2,r3,r2
8113d100:	1001703a 	wrctl	status,r2
  
  return context;
8113d104:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8113d108:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8113d10c:	e0bffd17 	ldw	r2,-12(fp)
8113d110:	10800317 	ldw	r2,12(r2)
8113d114:	10800104 	addi	r2,r2,4
8113d118:	e0fff117 	ldw	r3,-60(fp)
8113d11c:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
8113d120:	e0bffd17 	ldw	r2,-12(fp)
8113d124:	10800317 	ldw	r2,12(r2)
8113d128:	e0fffd17 	ldw	r3,-12(fp)
8113d12c:	18c00317 	ldw	r3,12(r3)
8113d130:	18c00037 	ldwio	r3,0(r3)
8113d134:	10c00035 	stwio	r3,0(r2)
8113d138:	e0bff217 	ldw	r2,-56(fp)
8113d13c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d140:	e0bffb17 	ldw	r2,-20(fp)
8113d144:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8113d148:	e0bffe17 	ldw	r2,-8(fp)
8113d14c:	10001e26 	beq	r2,zero,8113d1c8 <alt_msgdma_descriptor_async_transfer+0x194>
8113d150:	e0bfff17 	ldw	r2,-4(fp)
8113d154:	10001c1e 	bne	r2,zero,8113d1c8 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8113d158:	00001106 	br	8113d1a0 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8113d15c:	01000044 	movi	r4,1
8113d160:	112aee80 	call	8112aee8 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113d164:	e0bff00b 	ldhu	r2,-64(fp)
8113d168:	1084e230 	cmpltui	r2,r2,5000
8113d16c:	1000091e 	bne	r2,zero,8113d194 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
8113d170:	01204534 	movhi	r4,33044
8113d174:	2112f204 	addi	r4,r4,19400
8113d178:	113f4880 	call	8113f488 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8113d17c:	e0bffd17 	ldw	r2,-12(fp)
8113d180:	10801817 	ldw	r2,96(r2)
8113d184:	1009883a 	mov	r4,r2
8113d188:	1133ae80 	call	81133ae8 <OSSemPost>
				
                return -ETIME;
8113d18c:	00bff084 	movi	r2,-62
8113d190:	00007306 	br	8113d360 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
8113d194:	e0bff00b 	ldhu	r2,-64(fp)
8113d198:	10800044 	addi	r2,r2,1
8113d19c:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8113d1a0:	e0bffd17 	ldw	r2,-12(fp)
8113d1a4:	10c00317 	ldw	r3,12(r2)
8113d1a8:	e0bffd17 	ldw	r2,-12(fp)
8113d1ac:	10800417 	ldw	r2,16(r2)
8113d1b0:	e1bffe17 	ldw	r6,-8(fp)
8113d1b4:	100b883a 	mov	r5,r2
8113d1b8:	1809883a 	mov	r4,r3
8113d1bc:	113cae80 	call	8113cae8 <alt_msgdma_write_standard_descriptor>
8113d1c0:	103fe61e 	bne	r2,zero,8113d15c <__reset+0xfb11d15c>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8113d1c4:	00002706 	br	8113d264 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8113d1c8:	e0bffe17 	ldw	r2,-8(fp)
8113d1cc:	10001f1e 	bne	r2,zero,8113d24c <alt_msgdma_descriptor_async_transfer+0x218>
8113d1d0:	e0bfff17 	ldw	r2,-4(fp)
8113d1d4:	10001d26 	beq	r2,zero,8113d24c <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
8113d1d8:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8113d1dc:	00001106 	br	8113d224 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8113d1e0:	01000044 	movi	r4,1
8113d1e4:	112aee80 	call	8112aee8 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113d1e8:	e0bff00b 	ldhu	r2,-64(fp)
8113d1ec:	1084e230 	cmpltui	r2,r2,5000
8113d1f0:	1000091e 	bne	r2,zero,8113d218 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
8113d1f4:	01204534 	movhi	r4,33044
8113d1f8:	21130804 	addi	r4,r4,19488
8113d1fc:	113f4880 	call	8113f488 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8113d200:	e0bffd17 	ldw	r2,-12(fp)
8113d204:	10801817 	ldw	r2,96(r2)
8113d208:	1009883a 	mov	r4,r2
8113d20c:	1133ae80 	call	81133ae8 <OSSemPost>
				
                return -ETIME;
8113d210:	00bff084 	movi	r2,-62
8113d214:	00005206 	br	8113d360 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
8113d218:	e0bff00b 	ldhu	r2,-64(fp)
8113d21c:	10800044 	addi	r2,r2,1
8113d220:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8113d224:	e0bffd17 	ldw	r2,-12(fp)
8113d228:	10c00317 	ldw	r3,12(r2)
8113d22c:	e0bffd17 	ldw	r2,-12(fp)
8113d230:	10800417 	ldw	r2,16(r2)
8113d234:	e1bfff17 	ldw	r6,-4(fp)
8113d238:	100b883a 	mov	r5,r2
8113d23c:	1809883a 	mov	r4,r3
8113d240:	113cb840 	call	8113cb84 <alt_msgdma_write_extended_descriptor>
8113d244:	103fe61e 	bne	r2,zero,8113d1e0 <__reset+0xfb11d1e0>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8113d248:	00000606 	br	8113d264 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8113d24c:	e0bffd17 	ldw	r2,-12(fp)
8113d250:	10801817 	ldw	r2,96(r2)
8113d254:	1009883a 	mov	r4,r2
8113d258:	1133ae80 	call	81133ae8 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
8113d25c:	00bfffc4 	movi	r2,-1
8113d260:	00003f06 	br	8113d360 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
8113d264:	e0bffd17 	ldw	r2,-12(fp)
8113d268:	10800b17 	ldw	r2,44(r2)
8113d26c:	10001c26 	beq	r2,zero,8113d2e0 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
8113d270:	e0bffd17 	ldw	r2,-12(fp)
8113d274:	10c00d17 	ldw	r3,52(r2)
8113d278:	e0bff117 	ldw	r2,-60(fp)
8113d27c:	1884b03a 	or	r2,r3,r2
8113d280:	10800514 	ori	r2,r2,20
8113d284:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8113d288:	e0fff117 	ldw	r3,-60(fp)
8113d28c:	00bff7c4 	movi	r2,-33
8113d290:	1884703a 	and	r2,r3,r2
8113d294:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d298:	0005303a 	rdctl	r2,status
8113d29c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d2a0:	e0fff917 	ldw	r3,-28(fp)
8113d2a4:	00bfff84 	movi	r2,-2
8113d2a8:	1884703a 	and	r2,r3,r2
8113d2ac:	1001703a 	wrctl	status,r2
  
  return context;
8113d2b0:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
8113d2b4:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8113d2b8:	e0bffd17 	ldw	r2,-12(fp)
8113d2bc:	10800317 	ldw	r2,12(r2)
8113d2c0:	10800104 	addi	r2,r2,4
8113d2c4:	e0fff117 	ldw	r3,-60(fp)
8113d2c8:	10c00035 	stwio	r3,0(r2)
8113d2cc:	e0bff217 	ldw	r2,-56(fp)
8113d2d0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d2d4:	e0bff517 	ldw	r2,-44(fp)
8113d2d8:	1001703a 	wrctl	status,r2
8113d2dc:	00001b06 	br	8113d34c <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
8113d2e0:	e0bffd17 	ldw	r2,-12(fp)
8113d2e4:	10c00d17 	ldw	r3,52(r2)
8113d2e8:	e0bff117 	ldw	r2,-60(fp)
8113d2ec:	1884b03a 	or	r2,r3,r2
8113d2f0:	10800114 	ori	r2,r2,4
8113d2f4:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
8113d2f8:	e0fff117 	ldw	r3,-60(fp)
8113d2fc:	00bff3c4 	movi	r2,-49
8113d300:	1884703a 	and	r2,r3,r2
8113d304:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d308:	0005303a 	rdctl	r2,status
8113d30c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d310:	e0fffa17 	ldw	r3,-24(fp)
8113d314:	00bfff84 	movi	r2,-2
8113d318:	1884703a 	and	r2,r3,r2
8113d31c:	1001703a 	wrctl	status,r2
  
  return context;
8113d320:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
8113d324:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8113d328:	e0bffd17 	ldw	r2,-12(fp)
8113d32c:	10800317 	ldw	r2,12(r2)
8113d330:	10800104 	addi	r2,r2,4
8113d334:	e0fff117 	ldw	r3,-60(fp)
8113d338:	10c00035 	stwio	r3,0(r2)
8113d33c:	e0bff217 	ldw	r2,-56(fp)
8113d340:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d344:	e0bff817 	ldw	r2,-32(fp)
8113d348:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
8113d34c:	e0bffd17 	ldw	r2,-12(fp)
8113d350:	10801817 	ldw	r2,96(r2)
8113d354:	1009883a 	mov	r4,r2
8113d358:	1133ae80 	call	81133ae8 <OSSemPost>
    
    return 0;
8113d35c:	0005883a 	mov	r2,zero
}
8113d360:	e037883a 	mov	sp,fp
8113d364:	dfc00117 	ldw	ra,4(sp)
8113d368:	df000017 	ldw	fp,0(sp)
8113d36c:	dec00204 	addi	sp,sp,8
8113d370:	f800283a 	ret

8113d374 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8113d374:	deffee04 	addi	sp,sp,-72
8113d378:	de00012e 	bgeu	sp,et,8113d380 <alt_msgdma_descriptor_sync_transfer+0xc>
8113d37c:	003b68fa 	trap	3
8113d380:	dfc01115 	stw	ra,68(sp)
8113d384:	df001015 	stw	fp,64(sp)
8113d388:	df001004 	addi	fp,sp,64
8113d38c:	e13ffd15 	stw	r4,-12(fp)
8113d390:	e17ffe15 	stw	r5,-8(fp)
8113d394:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
8113d398:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
8113d39c:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
8113d3a0:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
8113d3a4:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113d3a8:	e0bffd17 	ldw	r2,-12(fp)
8113d3ac:	10800317 	ldw	r2,12(r2)
8113d3b0:	10800204 	addi	r2,r2,8
8113d3b4:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8113d3b8:	10bfffcc 	andi	r2,r2,65535
8113d3bc:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113d3c0:	e0bffd17 	ldw	r2,-12(fp)
8113d3c4:	10800317 	ldw	r2,12(r2)
8113d3c8:	10800204 	addi	r2,r2,8
8113d3cc:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8113d3d0:	1004d43a 	srli	r2,r2,16
8113d3d4:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
8113d3d8:	00807804 	movi	r2,480
8113d3dc:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8113d3e0:	00001906 	br	8113d448 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
8113d3e4:	01000044 	movi	r4,1
8113d3e8:	112aee80 	call	8112aee8 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113d3ec:	e0bff10b 	ldhu	r2,-60(fp)
8113d3f0:	1084e230 	cmpltui	r2,r2,5000
8113d3f4:	1000051e 	bne	r2,zero,8113d40c <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
8113d3f8:	01204534 	movhi	r4,33044
8113d3fc:	21131e04 	addi	r4,r4,19576
8113d400:	113f4880 	call	8113f488 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
8113d404:	00bff084 	movi	r2,-62
8113d408:	0000d706 	br	8113d768 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
8113d40c:	e0bff10b 	ldhu	r2,-60(fp)
8113d410:	10800044 	addi	r2,r2,1
8113d414:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113d418:	e0bffd17 	ldw	r2,-12(fp)
8113d41c:	10800317 	ldw	r2,12(r2)
8113d420:	10800204 	addi	r2,r2,8
8113d424:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
8113d428:	10bfffcc 	andi	r2,r2,65535
8113d42c:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113d430:	e0bffd17 	ldw	r2,-12(fp)
8113d434:	10800317 	ldw	r2,12(r2)
8113d438:	10800204 	addi	r2,r2,8
8113d43c:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
8113d440:	1004d43a 	srli	r2,r2,16
8113d444:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8113d448:	e0bffd17 	ldw	r2,-12(fp)
8113d44c:	10800917 	ldw	r2,36(r2)
8113d450:	e0fff317 	ldw	r3,-52(fp)
8113d454:	18bfe32e 	bgeu	r3,r2,8113d3e4 <__reset+0xfb11d3e4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8113d458:	e0bffd17 	ldw	r2,-12(fp)
8113d45c:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8113d460:	e0fff217 	ldw	r3,-56(fp)
8113d464:	18bfdf2e 	bgeu	r3,r2,8113d3e4 <__reset+0xfb11d3e4>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
8113d468:	e0bffd17 	ldw	r2,-12(fp)
8113d46c:	10801817 	ldw	r2,96(r2)
8113d470:	e0bff815 	stw	r2,-32(fp)
8113d474:	e03ffc0d 	sth	zero,-16(fp)
8113d478:	e0bffc0b 	ldhu	r2,-16(fp)
8113d47c:	e0fffc84 	addi	r3,fp,-14
8113d480:	180d883a 	mov	r6,r3
8113d484:	100b883a 	mov	r5,r2
8113d488:	e13ff817 	ldw	r4,-32(fp)
8113d48c:	11337600 	call	81133760 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d490:	0005303a 	rdctl	r2,status
8113d494:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d498:	e0fffb17 	ldw	r3,-20(fp)
8113d49c:	00bfff84 	movi	r2,-2
8113d4a0:	1884703a 	and	r2,r3,r2
8113d4a4:	1001703a 	wrctl	status,r2
  
  return context;
8113d4a8:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
8113d4ac:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8113d4b0:	e0bffd17 	ldw	r2,-12(fp)
8113d4b4:	10800317 	ldw	r2,12(r2)
8113d4b8:	10800104 	addi	r2,r2,4
8113d4bc:	00c00804 	movi	r3,32
8113d4c0:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
8113d4c4:	e0bffd17 	ldw	r2,-12(fp)
8113d4c8:	10800317 	ldw	r2,12(r2)
8113d4cc:	e0fffd17 	ldw	r3,-12(fp)
8113d4d0:	18c00317 	ldw	r3,12(r3)
8113d4d4:	18c00037 	ldwio	r3,0(r3)
8113d4d8:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
8113d4dc:	e0bffe17 	ldw	r2,-8(fp)
8113d4e0:	10001f26 	beq	r2,zero,8113d560 <alt_msgdma_descriptor_sync_transfer+0x1ec>
8113d4e4:	e0bfff17 	ldw	r2,-4(fp)
8113d4e8:	10001d1e 	bne	r2,zero,8113d560 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
8113d4ec:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8113d4f0:	00001106 	br	8113d538 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
8113d4f4:	01000044 	movi	r4,1
8113d4f8:	112aee80 	call	8112aee8 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113d4fc:	e0bff10b 	ldhu	r2,-60(fp)
8113d500:	1084e230 	cmpltui	r2,r2,5000
8113d504:	1000091e 	bne	r2,zero,8113d52c <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
8113d508:	01204534 	movhi	r4,33044
8113d50c:	21133204 	addi	r4,r4,19656
8113d510:	113f4880 	call	8113f488 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8113d514:	e0bffd17 	ldw	r2,-12(fp)
8113d518:	10801817 	ldw	r2,96(r2)
8113d51c:	1009883a 	mov	r4,r2
8113d520:	1133ae80 	call	81133ae8 <OSSemPost>
				
                return -ETIME;
8113d524:	00bff084 	movi	r2,-62
8113d528:	00008f06 	br	8113d768 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
8113d52c:	e0bff10b 	ldhu	r2,-60(fp)
8113d530:	10800044 	addi	r2,r2,1
8113d534:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8113d538:	e0bffd17 	ldw	r2,-12(fp)
8113d53c:	10c00317 	ldw	r3,12(r2)
8113d540:	e0bffd17 	ldw	r2,-12(fp)
8113d544:	10800417 	ldw	r2,16(r2)
8113d548:	e1bffe17 	ldw	r6,-8(fp)
8113d54c:	100b883a 	mov	r5,r2
8113d550:	1809883a 	mov	r4,r3
8113d554:	113cae80 	call	8113cae8 <alt_msgdma_write_standard_descriptor>
8113d558:	103fe61e 	bne	r2,zero,8113d4f4 <__reset+0xfb11d4f4>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
8113d55c:	00002706 	br	8113d5fc <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8113d560:	e0bffe17 	ldw	r2,-8(fp)
8113d564:	10001f1e 	bne	r2,zero,8113d5e4 <alt_msgdma_descriptor_sync_transfer+0x270>
8113d568:	e0bfff17 	ldw	r2,-4(fp)
8113d56c:	10001d26 	beq	r2,zero,8113d5e4 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
8113d570:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8113d574:	00001106 	br	8113d5bc <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8113d578:	01000044 	movi	r4,1
8113d57c:	112aee80 	call	8112aee8 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113d580:	e0bff10b 	ldhu	r2,-60(fp)
8113d584:	1084e230 	cmpltui	r2,r2,5000
8113d588:	1000091e 	bne	r2,zero,8113d5b0 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
8113d58c:	01204534 	movhi	r4,33044
8113d590:	21134304 	addi	r4,r4,19724
8113d594:	113f4880 	call	8113f488 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8113d598:	e0bffd17 	ldw	r2,-12(fp)
8113d59c:	10801817 	ldw	r2,96(r2)
8113d5a0:	1009883a 	mov	r4,r2
8113d5a4:	1133ae80 	call	81133ae8 <OSSemPost>
				
                return -ETIME;
8113d5a8:	00bff084 	movi	r2,-62
8113d5ac:	00006e06 	br	8113d768 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
8113d5b0:	e0bff10b 	ldhu	r2,-60(fp)
8113d5b4:	10800044 	addi	r2,r2,1
8113d5b8:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8113d5bc:	e0bffd17 	ldw	r2,-12(fp)
8113d5c0:	10c00317 	ldw	r3,12(r2)
8113d5c4:	e0bffd17 	ldw	r2,-12(fp)
8113d5c8:	10800417 	ldw	r2,16(r2)
8113d5cc:	e1bfff17 	ldw	r6,-4(fp)
8113d5d0:	100b883a 	mov	r5,r2
8113d5d4:	1809883a 	mov	r4,r3
8113d5d8:	113cb840 	call	8113cb84 <alt_msgdma_write_extended_descriptor>
8113d5dc:	103fe61e 	bne	r2,zero,8113d578 <__reset+0xfb11d578>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8113d5e0:	00000606 	br	8113d5fc <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8113d5e4:	e0bffd17 	ldw	r2,-12(fp)
8113d5e8:	10801817 	ldw	r2,96(r2)
8113d5ec:	1009883a 	mov	r4,r2
8113d5f0:	1133ae80 	call	81133ae8 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
8113d5f4:	00bfffc4 	movi	r2,-1
8113d5f8:	00005b06 	br	8113d768 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8113d5fc:	e0bffd17 	ldw	r2,-12(fp)
8113d600:	10800317 	ldw	r2,12(r2)
8113d604:	10800104 	addi	r2,r2,4
8113d608:	e0fffd17 	ldw	r3,-12(fp)
8113d60c:	19000d17 	ldw	r4,52(r3)
8113d610:	00fff2c4 	movi	r3,-53
8113d614:	20c6703a 	and	r3,r4,r3
8113d618:	18c00114 	ori	r3,r3,4
8113d61c:	10c00035 	stwio	r3,0(r2)
8113d620:	e0bff517 	ldw	r2,-44(fp)
8113d624:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d628:	e0bff717 	ldw	r2,-36(fp)
8113d62c:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
8113d630:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8113d634:	e0bffd17 	ldw	r2,-12(fp)
8113d638:	10800317 	ldw	r2,12(r2)
8113d63c:	10800037 	ldwio	r2,0(r2)
8113d640:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
8113d644:	00001506 	br	8113d69c <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
8113d648:	01000044 	movi	r4,1
8113d64c:	112aee80 	call	8112aee8 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113d650:	e0bff10b 	ldhu	r2,-60(fp)
8113d654:	1084e230 	cmpltui	r2,r2,5000
8113d658:	1000091e 	bne	r2,zero,8113d680 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
8113d65c:	01204534 	movhi	r4,33044
8113d660:	21135404 	addi	r4,r4,19792
8113d664:	113f4880 	call	8113f488 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
8113d668:	e0bffd17 	ldw	r2,-12(fp)
8113d66c:	10801817 	ldw	r2,96(r2)
8113d670:	1009883a 	mov	r4,r2
8113d674:	1133ae80 	call	81133ae8 <OSSemPost>
			
            return -ETIME;
8113d678:	00bff084 	movi	r2,-62
8113d67c:	00003a06 	br	8113d768 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
8113d680:	e0bff10b 	ldhu	r2,-60(fp)
8113d684:	10800044 	addi	r2,r2,1
8113d688:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8113d68c:	e0bffd17 	ldw	r2,-12(fp)
8113d690:	10800317 	ldw	r2,12(r2)
8113d694:	10800037 	ldwio	r2,0(r2)
8113d698:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
8113d69c:	e0fff017 	ldw	r3,-64(fp)
8113d6a0:	e0bff617 	ldw	r2,-40(fp)
8113d6a4:	1884703a 	and	r2,r3,r2
8113d6a8:	1000031e 	bne	r2,zero,8113d6b8 <alt_msgdma_descriptor_sync_transfer+0x344>
8113d6ac:	e0bff017 	ldw	r2,-64(fp)
8113d6b0:	1080004c 	andi	r2,r2,1
8113d6b4:	103fe41e 	bne	r2,zero,8113d648 <__reset+0xfb11d648>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
8113d6b8:	e0fff017 	ldw	r3,-64(fp)
8113d6bc:	e0bff617 	ldw	r2,-40(fp)
8113d6c0:	1884703a 	and	r2,r3,r2
8113d6c4:	10000626 	beq	r2,zero,8113d6e0 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8113d6c8:	e0bffd17 	ldw	r2,-12(fp)
8113d6cc:	10801817 	ldw	r2,96(r2)
8113d6d0:	1009883a 	mov	r4,r2
8113d6d4:	1133ae80 	call	81133ae8 <OSSemPost>
		
        return error;
8113d6d8:	e0bff617 	ldw	r2,-40(fp)
8113d6dc:	00002206 	br	8113d768 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
8113d6e0:	e0bffd17 	ldw	r2,-12(fp)
8113d6e4:	10800317 	ldw	r2,12(r2)
8113d6e8:	10800104 	addi	r2,r2,4
8113d6ec:	10800037 	ldwio	r2,0(r2)
8113d6f0:	10800814 	ori	r2,r2,32
8113d6f4:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d6f8:	0005303a 	rdctl	r2,status
8113d6fc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d700:	e0fffa17 	ldw	r3,-24(fp)
8113d704:	00bfff84 	movi	r2,-2
8113d708:	1884703a 	and	r2,r3,r2
8113d70c:	1001703a 	wrctl	status,r2
  
  return context;
8113d710:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
8113d714:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8113d718:	e0bffd17 	ldw	r2,-12(fp)
8113d71c:	10800317 	ldw	r2,12(r2)
8113d720:	10800104 	addi	r2,r2,4
8113d724:	e0fff417 	ldw	r3,-48(fp)
8113d728:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
8113d72c:	e0bffd17 	ldw	r2,-12(fp)
8113d730:	10800317 	ldw	r2,12(r2)
8113d734:	e0fffd17 	ldw	r3,-12(fp)
8113d738:	18c00317 	ldw	r3,12(r3)
8113d73c:	18c00037 	ldwio	r3,0(r3)
8113d740:	10c00035 	stwio	r3,0(r2)
8113d744:	e0bff517 	ldw	r2,-44(fp)
8113d748:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d74c:	e0bff917 	ldw	r2,-28(fp)
8113d750:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
8113d754:	e0bffd17 	ldw	r2,-12(fp)
8113d758:	10801817 	ldw	r2,96(r2)
8113d75c:	1009883a 	mov	r4,r2
8113d760:	1133ae80 	call	81133ae8 <OSSemPost>
    
    return 0;
8113d764:	0005883a 	mov	r2,zero

}
8113d768:	e037883a 	mov	sp,fp
8113d76c:	dfc00117 	ldw	ra,4(sp)
8113d770:	df000017 	ldw	fp,0(sp)
8113d774:	dec00204 	addi	sp,sp,8
8113d778:	f800283a 	ret

8113d77c <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
8113d77c:	defff804 	addi	sp,sp,-32
8113d780:	de00012e 	bgeu	sp,et,8113d788 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
8113d784:	003b68fa 	trap	3
8113d788:	dfc00715 	stw	ra,28(sp)
8113d78c:	df000615 	stw	fp,24(sp)
8113d790:	df000604 	addi	fp,sp,24
8113d794:	e13ffc15 	stw	r4,-16(fp)
8113d798:	e17ffd15 	stw	r5,-12(fp)
8113d79c:	e1bffe15 	stw	r6,-8(fp)
8113d7a0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
8113d7a4:	e0800217 	ldw	r2,8(fp)
8113d7a8:	d8800115 	stw	r2,4(sp)
8113d7ac:	e0bfff17 	ldw	r2,-4(fp)
8113d7b0:	d8800015 	stw	r2,0(sp)
8113d7b4:	e1fffe17 	ldw	r7,-8(fp)
8113d7b8:	000d883a 	mov	r6,zero
8113d7bc:	e17ffd17 	ldw	r5,-12(fp)
8113d7c0:	e13ffc17 	ldw	r4,-16(fp)
8113d7c4:	113ce440 	call	8113ce44 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8113d7c8:	e037883a 	mov	sp,fp
8113d7cc:	dfc00117 	ldw	ra,4(sp)
8113d7d0:	df000017 	ldw	fp,0(sp)
8113d7d4:	dec00204 	addi	sp,sp,8
8113d7d8:	f800283a 	ret

8113d7dc <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
8113d7dc:	defff804 	addi	sp,sp,-32
8113d7e0:	de00012e 	bgeu	sp,et,8113d7e8 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
8113d7e4:	003b68fa 	trap	3
8113d7e8:	dfc00715 	stw	ra,28(sp)
8113d7ec:	df000615 	stw	fp,24(sp)
8113d7f0:	df000604 	addi	fp,sp,24
8113d7f4:	e13ffc15 	stw	r4,-16(fp)
8113d7f8:	e17ffd15 	stw	r5,-12(fp)
8113d7fc:	e1bffe15 	stw	r6,-8(fp)
8113d800:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8113d804:	e0800217 	ldw	r2,8(fp)
8113d808:	d8800115 	stw	r2,4(sp)
8113d80c:	e0bfff17 	ldw	r2,-4(fp)
8113d810:	d8800015 	stw	r2,0(sp)
8113d814:	000f883a 	mov	r7,zero
8113d818:	e1bffe17 	ldw	r6,-8(fp)
8113d81c:	e17ffd17 	ldw	r5,-12(fp)
8113d820:	e13ffc17 	ldw	r4,-16(fp)
8113d824:	113ce440 	call	8113ce44 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
8113d828:	e037883a 	mov	sp,fp
8113d82c:	dfc00117 	ldw	ra,4(sp)
8113d830:	df000017 	ldw	fp,0(sp)
8113d834:	dec00204 	addi	sp,sp,8
8113d838:	f800283a 	ret

8113d83c <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113d83c:	defff804 	addi	sp,sp,-32
8113d840:	de00012e 	bgeu	sp,et,8113d848 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
8113d844:	003b68fa 	trap	3
8113d848:	dfc00715 	stw	ra,28(sp)
8113d84c:	df000615 	stw	fp,24(sp)
8113d850:	df000604 	addi	fp,sp,24
8113d854:	e13ffc15 	stw	r4,-16(fp)
8113d858:	e17ffd15 	stw	r5,-12(fp)
8113d85c:	e1bffe15 	stw	r6,-8(fp)
8113d860:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8113d864:	e0800317 	ldw	r2,12(fp)
8113d868:	d8800115 	stw	r2,4(sp)
8113d86c:	e0800217 	ldw	r2,8(fp)
8113d870:	d8800015 	stw	r2,0(sp)
8113d874:	e1ffff17 	ldw	r7,-4(fp)
8113d878:	e1bffe17 	ldw	r6,-8(fp)
8113d87c:	e17ffd17 	ldw	r5,-12(fp)
8113d880:	e13ffc17 	ldw	r4,-16(fp)
8113d884:	113ce440 	call	8113ce44 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8113d888:	e037883a 	mov	sp,fp
8113d88c:	dfc00117 	ldw	ra,4(sp)
8113d890:	df000017 	ldw	fp,0(sp)
8113d894:	dec00204 	addi	sp,sp,8
8113d898:	f800283a 	ret

8113d89c <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
8113d89c:	defff004 	addi	sp,sp,-64
8113d8a0:	de00012e 	bgeu	sp,et,8113d8a8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
8113d8a4:	003b68fa 	trap	3
8113d8a8:	dfc00f15 	stw	ra,60(sp)
8113d8ac:	df000e15 	stw	fp,56(sp)
8113d8b0:	df000e04 	addi	fp,sp,56
8113d8b4:	e13ff915 	stw	r4,-28(fp)
8113d8b8:	e17ffa15 	stw	r5,-24(fp)
8113d8bc:	e1bffb15 	stw	r6,-20(fp)
8113d8c0:	e1fffc15 	stw	r7,-16(fp)
8113d8c4:	e1000317 	ldw	r4,12(fp)
8113d8c8:	e0c00417 	ldw	r3,16(fp)
8113d8cc:	e0800517 	ldw	r2,20(fp)
8113d8d0:	e13ffd0d 	sth	r4,-12(fp)
8113d8d4:	e0fffe05 	stb	r3,-8(fp)
8113d8d8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8113d8dc:	e0bffd0b 	ldhu	r2,-12(fp)
8113d8e0:	e0fffe03 	ldbu	r3,-8(fp)
8113d8e4:	e13fff0b 	ldhu	r4,-4(fp)
8113d8e8:	d9000615 	stw	r4,24(sp)
8113d8ec:	d8000515 	stw	zero,20(sp)
8113d8f0:	d8c00415 	stw	r3,16(sp)
8113d8f4:	d8000315 	stw	zero,12(sp)
8113d8f8:	d8800215 	stw	r2,8(sp)
8113d8fc:	e0800217 	ldw	r2,8(fp)
8113d900:	d8800115 	stw	r2,4(sp)
8113d904:	e0bffc17 	ldw	r2,-16(fp)
8113d908:	d8800015 	stw	r2,0(sp)
8113d90c:	e1fffb17 	ldw	r7,-20(fp)
8113d910:	000d883a 	mov	r6,zero
8113d914:	e17ffa17 	ldw	r5,-24(fp)
8113d918:	e13ff917 	ldw	r4,-28(fp)
8113d91c:	113ced80 	call	8113ced8 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
8113d920:	e037883a 	mov	sp,fp
8113d924:	dfc00117 	ldw	ra,4(sp)
8113d928:	df000017 	ldw	fp,0(sp)
8113d92c:	dec00204 	addi	sp,sp,8
8113d930:	f800283a 	ret

8113d934 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8113d934:	defff004 	addi	sp,sp,-64
8113d938:	de00012e 	bgeu	sp,et,8113d940 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
8113d93c:	003b68fa 	trap	3
8113d940:	dfc00f15 	stw	ra,60(sp)
8113d944:	df000e15 	stw	fp,56(sp)
8113d948:	df000e04 	addi	fp,sp,56
8113d94c:	e13ff915 	stw	r4,-28(fp)
8113d950:	e17ffa15 	stw	r5,-24(fp)
8113d954:	e1bffb15 	stw	r6,-20(fp)
8113d958:	e1fffc15 	stw	r7,-16(fp)
8113d95c:	e1000317 	ldw	r4,12(fp)
8113d960:	e0c00417 	ldw	r3,16(fp)
8113d964:	e0800517 	ldw	r2,20(fp)
8113d968:	e13ffd0d 	sth	r4,-12(fp)
8113d96c:	e0fffe05 	stb	r3,-8(fp)
8113d970:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
8113d974:	e0bffd0b 	ldhu	r2,-12(fp)
8113d978:	e0fffe03 	ldbu	r3,-8(fp)
8113d97c:	e13fff0b 	ldhu	r4,-4(fp)
8113d980:	d8000615 	stw	zero,24(sp)
8113d984:	d9000515 	stw	r4,20(sp)
8113d988:	d8000415 	stw	zero,16(sp)
8113d98c:	d8c00315 	stw	r3,12(sp)
8113d990:	d8800215 	stw	r2,8(sp)
8113d994:	e0800217 	ldw	r2,8(fp)
8113d998:	d8800115 	stw	r2,4(sp)
8113d99c:	e0bffc17 	ldw	r2,-16(fp)
8113d9a0:	d8800015 	stw	r2,0(sp)
8113d9a4:	000f883a 	mov	r7,zero
8113d9a8:	e1bffb17 	ldw	r6,-20(fp)
8113d9ac:	e17ffa17 	ldw	r5,-24(fp)
8113d9b0:	e13ff917 	ldw	r4,-28(fp)
8113d9b4:	113ced80 	call	8113ced8 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
8113d9b8:	e037883a 	mov	sp,fp
8113d9bc:	dfc00117 	ldw	ra,4(sp)
8113d9c0:	df000017 	ldw	fp,0(sp)
8113d9c4:	dec00204 	addi	sp,sp,8
8113d9c8:	f800283a 	ret

8113d9cc <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
8113d9cc:	deffee04 	addi	sp,sp,-72
8113d9d0:	de00012e 	bgeu	sp,et,8113d9d8 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
8113d9d4:	003b68fa 	trap	3
8113d9d8:	dfc01115 	stw	ra,68(sp)
8113d9dc:	df001015 	stw	fp,64(sp)
8113d9e0:	df001004 	addi	fp,sp,64
8113d9e4:	e13ff715 	stw	r4,-36(fp)
8113d9e8:	e17ff815 	stw	r5,-32(fp)
8113d9ec:	e1bff915 	stw	r6,-28(fp)
8113d9f0:	e1fffa15 	stw	r7,-24(fp)
8113d9f4:	e1800417 	ldw	r6,16(fp)
8113d9f8:	e1400517 	ldw	r5,20(fp)
8113d9fc:	e1000617 	ldw	r4,24(fp)
8113da00:	e0c00717 	ldw	r3,28(fp)
8113da04:	e0800817 	ldw	r2,32(fp)
8113da08:	e1bffb0d 	sth	r6,-20(fp)
8113da0c:	e17ffc05 	stb	r5,-16(fp)
8113da10:	e13ffd05 	stb	r4,-12(fp)
8113da14:	e0fffe0d 	sth	r3,-8(fp)
8113da18:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8113da1c:	e0bffb0b 	ldhu	r2,-20(fp)
8113da20:	e0fffc03 	ldbu	r3,-16(fp)
8113da24:	e13ffd03 	ldbu	r4,-12(fp)
8113da28:	e17ffe0b 	ldhu	r5,-8(fp)
8113da2c:	e1bfff0b 	ldhu	r6,-4(fp)
8113da30:	d9800615 	stw	r6,24(sp)
8113da34:	d9400515 	stw	r5,20(sp)
8113da38:	d9000415 	stw	r4,16(sp)
8113da3c:	d8c00315 	stw	r3,12(sp)
8113da40:	d8800215 	stw	r2,8(sp)
8113da44:	e0800317 	ldw	r2,12(fp)
8113da48:	d8800115 	stw	r2,4(sp)
8113da4c:	e0800217 	ldw	r2,8(fp)
8113da50:	d8800015 	stw	r2,0(sp)
8113da54:	e1fffa17 	ldw	r7,-24(fp)
8113da58:	e1bff917 	ldw	r6,-28(fp)
8113da5c:	e17ff817 	ldw	r5,-32(fp)
8113da60:	e13ff717 	ldw	r4,-36(fp)
8113da64:	113ced80 	call	8113ced8 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
8113da68:	e037883a 	mov	sp,fp
8113da6c:	dfc00117 	ldw	ra,4(sp)
8113da70:	df000017 	ldw	fp,0(sp)
8113da74:	dec00204 	addi	sp,sp,8
8113da78:	f800283a 	ret

8113da7c <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113da7c:	defffb04 	addi	sp,sp,-20
8113da80:	de00012e 	bgeu	sp,et,8113da88 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
8113da84:	003b68fa 	trap	3
8113da88:	df000415 	stw	fp,16(sp)
8113da8c:	df000404 	addi	fp,sp,16
8113da90:	e13ffc15 	stw	r4,-16(fp)
8113da94:	e17ffd15 	stw	r5,-12(fp)
8113da98:	e1bffe15 	stw	r6,-8(fp)
8113da9c:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8113daa0:	e0bffc17 	ldw	r2,-16(fp)
8113daa4:	10c01217 	ldw	r3,72(r2)
8113daa8:	e0800117 	ldw	r2,4(fp)
8113daac:	18800436 	bltu	r3,r2,8113dac0 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
8113dab0:	e0bffc17 	ldw	r2,-16(fp)
8113dab4:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8113dab8:	10803fcc 	andi	r2,r2,255
8113dabc:	10000226 	beq	r2,zero,8113dac8 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8113dac0:	00bffa84 	movi	r2,-22
8113dac4:	00001406 	br	8113db18 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
8113dac8:	e0bffd17 	ldw	r2,-12(fp)
8113dacc:	e0fffe17 	ldw	r3,-8(fp)
8113dad0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8113dad4:	e0bffd17 	ldw	r2,-12(fp)
8113dad8:	e0ffff17 	ldw	r3,-4(fp)
8113dadc:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8113dae0:	e0bffd17 	ldw	r2,-12(fp)
8113dae4:	e0c00117 	ldw	r3,4(fp)
8113dae8:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
8113daec:	e0fffd17 	ldw	r3,-12(fp)
8113daf0:	e0bffd17 	ldw	r2,-12(fp)
8113daf4:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8113daf8:	e0c00217 	ldw	r3,8(fp)
8113dafc:	00900034 	movhi	r2,16384
8113db00:	10bfffc4 	addi	r2,r2,-1
8113db04:	1884703a 	and	r2,r3,r2
8113db08:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
8113db0c:	e0bffd17 	ldw	r2,-12(fp)
8113db10:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
8113db14:	0005883a 	mov	r2,zero
}
8113db18:	e037883a 	mov	sp,fp
8113db1c:	df000017 	ldw	fp,0(sp)
8113db20:	dec00104 	addi	sp,sp,4
8113db24:	f800283a 	ret

8113db28 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8113db28:	defff404 	addi	sp,sp,-48
8113db2c:	de00012e 	bgeu	sp,et,8113db34 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
8113db30:	003b68fa 	trap	3
8113db34:	df000b15 	stw	fp,44(sp)
8113db38:	df000b04 	addi	fp,sp,44
8113db3c:	e13ff715 	stw	r4,-36(fp)
8113db40:	e17ff815 	stw	r5,-32(fp)
8113db44:	e1bff915 	stw	r6,-28(fp)
8113db48:	e1fffa15 	stw	r7,-24(fp)
8113db4c:	e1800517 	ldw	r6,20(fp)
8113db50:	e1400617 	ldw	r5,24(fp)
8113db54:	e1000717 	ldw	r4,28(fp)
8113db58:	e0c00817 	ldw	r3,32(fp)
8113db5c:	e0800917 	ldw	r2,36(fp)
8113db60:	e1bffb0d 	sth	r6,-20(fp)
8113db64:	e17ffc05 	stb	r5,-16(fp)
8113db68:	e13ffd05 	stb	r4,-12(fp)
8113db6c:	e0fffe0d 	sth	r3,-8(fp)
8113db70:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8113db74:	e0bff717 	ldw	r2,-36(fp)
8113db78:	10c01217 	ldw	r3,72(r2)
8113db7c:	e0800317 	ldw	r2,12(fp)
8113db80:	18801936 	bltu	r3,r2,8113dbe8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8113db84:	e13ff717 	ldw	r4,-36(fp)
8113db88:	20801317 	ldw	r2,76(r4)
8113db8c:	20c01417 	ldw	r3,80(r4)
8113db90:	e13ffe0b 	ldhu	r4,-8(fp)
8113db94:	213fffcc 	andi	r4,r4,65535
8113db98:	2015883a 	mov	r10,r4
8113db9c:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8113dba0:	1ac01136 	bltu	r3,r11,8113dbe8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8113dba4:	58c0011e 	bne	r11,r3,8113dbac <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
8113dba8:	12800f36 	bltu	r2,r10,8113dbe8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8113dbac:	e13ff717 	ldw	r4,-36(fp)
8113dbb0:	20801317 	ldw	r2,76(r4)
8113dbb4:	20c01417 	ldw	r3,80(r4)
8113dbb8:	e13fff0b 	ldhu	r4,-4(fp)
8113dbbc:	213fffcc 	andi	r4,r4,65535
8113dbc0:	2011883a 	mov	r8,r4
8113dbc4:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
8113dbc8:	1a400736 	bltu	r3,r9,8113dbe8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8113dbcc:	48c0011e 	bne	r9,r3,8113dbd4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
8113dbd0:	12000536 	bltu	r2,r8,8113dbe8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8113dbd4:	e0bff717 	ldw	r2,-36(fp)
8113dbd8:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8113dbdc:	10803fcc 	andi	r2,r2,255
8113dbe0:	10800060 	cmpeqi	r2,r2,1
8113dbe4:	1000021e 	bne	r2,zero,8113dbf0 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8113dbe8:	00bffa84 	movi	r2,-22
8113dbec:	00003106 	br	8113dcb4 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
8113dbf0:	e0bff817 	ldw	r2,-32(fp)
8113dbf4:	e0fff917 	ldw	r3,-28(fp)
8113dbf8:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
8113dbfc:	e0bff817 	ldw	r2,-32(fp)
8113dc00:	e0fffa17 	ldw	r3,-24(fp)
8113dc04:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
8113dc08:	e0bff817 	ldw	r2,-32(fp)
8113dc0c:	e0c00117 	ldw	r3,4(fp)
8113dc10:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
8113dc14:	e0bff817 	ldw	r2,-32(fp)
8113dc18:	e0c00217 	ldw	r3,8(fp)
8113dc1c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8113dc20:	e0bff817 	ldw	r2,-32(fp)
8113dc24:	e0c00317 	ldw	r3,12(fp)
8113dc28:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8113dc2c:	e0bff817 	ldw	r2,-32(fp)
8113dc30:	e0fffb0b 	ldhu	r3,-20(fp)
8113dc34:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
8113dc38:	e0bff817 	ldw	r2,-32(fp)
8113dc3c:	e0fffc03 	ldbu	r3,-16(fp)
8113dc40:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
8113dc44:	e0bff817 	ldw	r2,-32(fp)
8113dc48:	e0fffd03 	ldbu	r3,-12(fp)
8113dc4c:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
8113dc50:	e0bff817 	ldw	r2,-32(fp)
8113dc54:	e0fffe0b 	ldhu	r3,-8(fp)
8113dc58:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
8113dc5c:	e0bff817 	ldw	r2,-32(fp)
8113dc60:	e0ffff0b 	ldhu	r3,-4(fp)
8113dc64:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
8113dc68:	e0bff817 	ldw	r2,-32(fp)
8113dc6c:	1019883a 	mov	r12,r2
8113dc70:	001b883a 	mov	r13,zero
8113dc74:	e33ff515 	stw	r12,-44(fp)
8113dc78:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
8113dc7c:	e0fff517 	ldw	r3,-44(fp)
8113dc80:	e0bff817 	ldw	r2,-32(fp)
8113dc84:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
8113dc88:	e0fff617 	ldw	r3,-40(fp)
8113dc8c:	e0bff817 	ldw	r2,-32(fp)
8113dc90:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8113dc94:	e0c00417 	ldw	r3,16(fp)
8113dc98:	00900034 	movhi	r2,16384
8113dc9c:	10bfffc4 	addi	r2,r2,-1
8113dca0:	1884703a 	and	r2,r3,r2
8113dca4:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
8113dca8:	e0bff817 	ldw	r2,-32(fp)
8113dcac:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
8113dcb0:	0005883a 	mov	r2,zero
}
8113dcb4:	e037883a 	mov	sp,fp
8113dcb8:	df000017 	ldw	fp,0(sp)
8113dcbc:	dec00104 	addi	sp,sp,4
8113dcc0:	f800283a 	ret

8113dcc4 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
8113dcc4:	defff804 	addi	sp,sp,-32
8113dcc8:	de00012e 	bgeu	sp,et,8113dcd0 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
8113dccc:	003b68fa 	trap	3
8113dcd0:	dfc00715 	stw	ra,28(sp)
8113dcd4:	df000615 	stw	fp,24(sp)
8113dcd8:	df000604 	addi	fp,sp,24
8113dcdc:	e13ffc15 	stw	r4,-16(fp)
8113dce0:	e17ffd15 	stw	r5,-12(fp)
8113dce4:	e1bffe15 	stw	r6,-8(fp)
8113dce8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8113dcec:	e0800317 	ldw	r2,12(fp)
8113dcf0:	d8800115 	stw	r2,4(sp)
8113dcf4:	e0800217 	ldw	r2,8(fp)
8113dcf8:	d8800015 	stw	r2,0(sp)
8113dcfc:	e1ffff17 	ldw	r7,-4(fp)
8113dd00:	e1bffe17 	ldw	r6,-8(fp)
8113dd04:	e17ffd17 	ldw	r5,-12(fp)
8113dd08:	e13ffc17 	ldw	r4,-16(fp)
8113dd0c:	113da7c0 	call	8113da7c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
8113dd10:	e037883a 	mov	sp,fp
8113dd14:	dfc00117 	ldw	ra,4(sp)
8113dd18:	df000017 	ldw	fp,0(sp)
8113dd1c:	dec00204 	addi	sp,sp,8
8113dd20:	f800283a 	ret

8113dd24 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113dd24:	defff804 	addi	sp,sp,-32
8113dd28:	de00012e 	bgeu	sp,et,8113dd30 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
8113dd2c:	003b68fa 	trap	3
8113dd30:	dfc00715 	stw	ra,28(sp)
8113dd34:	df000615 	stw	fp,24(sp)
8113dd38:	df000604 	addi	fp,sp,24
8113dd3c:	e13ffc15 	stw	r4,-16(fp)
8113dd40:	e17ffd15 	stw	r5,-12(fp)
8113dd44:	e1bffe15 	stw	r6,-8(fp)
8113dd48:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8113dd4c:	e0800217 	ldw	r2,8(fp)
8113dd50:	d8800115 	stw	r2,4(sp)
8113dd54:	e0bfff17 	ldw	r2,-4(fp)
8113dd58:	d8800015 	stw	r2,0(sp)
8113dd5c:	e1fffe17 	ldw	r7,-8(fp)
8113dd60:	000d883a 	mov	r6,zero
8113dd64:	e17ffd17 	ldw	r5,-12(fp)
8113dd68:	e13ffc17 	ldw	r4,-16(fp)
8113dd6c:	113da7c0 	call	8113da7c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
8113dd70:	e037883a 	mov	sp,fp
8113dd74:	dfc00117 	ldw	ra,4(sp)
8113dd78:	df000017 	ldw	fp,0(sp)
8113dd7c:	dec00204 	addi	sp,sp,8
8113dd80:	f800283a 	ret

8113dd84 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113dd84:	defff804 	addi	sp,sp,-32
8113dd88:	de00012e 	bgeu	sp,et,8113dd90 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
8113dd8c:	003b68fa 	trap	3
8113dd90:	dfc00715 	stw	ra,28(sp)
8113dd94:	df000615 	stw	fp,24(sp)
8113dd98:	df000604 	addi	fp,sp,24
8113dd9c:	e13ffc15 	stw	r4,-16(fp)
8113dda0:	e17ffd15 	stw	r5,-12(fp)
8113dda4:	e1bffe15 	stw	r6,-8(fp)
8113dda8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8113ddac:	e0800217 	ldw	r2,8(fp)
8113ddb0:	d8800115 	stw	r2,4(sp)
8113ddb4:	e0bfff17 	ldw	r2,-4(fp)
8113ddb8:	d8800015 	stw	r2,0(sp)
8113ddbc:	000f883a 	mov	r7,zero
8113ddc0:	e1bffe17 	ldw	r6,-8(fp)
8113ddc4:	e17ffd17 	ldw	r5,-12(fp)
8113ddc8:	e13ffc17 	ldw	r4,-16(fp)
8113ddcc:	113da7c0 	call	8113da7c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
8113ddd0:	e037883a 	mov	sp,fp
8113ddd4:	dfc00117 	ldw	ra,4(sp)
8113ddd8:	df000017 	ldw	fp,0(sp)
8113dddc:	dec00204 	addi	sp,sp,8
8113dde0:	f800283a 	ret

8113dde4 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
8113dde4:	deffee04 	addi	sp,sp,-72
8113dde8:	de00012e 	bgeu	sp,et,8113ddf0 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
8113ddec:	003b68fa 	trap	3
8113ddf0:	dfc01115 	stw	ra,68(sp)
8113ddf4:	df001015 	stw	fp,64(sp)
8113ddf8:	df001004 	addi	fp,sp,64
8113ddfc:	e13ff915 	stw	r4,-28(fp)
8113de00:	e17ffa15 	stw	r5,-24(fp)
8113de04:	e1bffb15 	stw	r6,-20(fp)
8113de08:	e1fffc15 	stw	r7,-16(fp)
8113de0c:	e1000417 	ldw	r4,16(fp)
8113de10:	e0c00517 	ldw	r3,20(fp)
8113de14:	e0800617 	ldw	r2,24(fp)
8113de18:	e13ffd0d 	sth	r4,-12(fp)
8113de1c:	e0fffe05 	stb	r3,-8(fp)
8113de20:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
8113de24:	e0bffd0b 	ldhu	r2,-12(fp)
8113de28:	e0fffe03 	ldbu	r3,-8(fp)
8113de2c:	e13fff0b 	ldhu	r4,-4(fp)
8113de30:	d9000815 	stw	r4,32(sp)
8113de34:	d8000715 	stw	zero,28(sp)
8113de38:	d8c00615 	stw	r3,24(sp)
8113de3c:	d8000515 	stw	zero,20(sp)
8113de40:	d8800415 	stw	r2,16(sp)
8113de44:	e0800317 	ldw	r2,12(fp)
8113de48:	d8800315 	stw	r2,12(sp)
8113de4c:	e0800217 	ldw	r2,8(fp)
8113de50:	d8800215 	stw	r2,8(sp)
8113de54:	e0bffc17 	ldw	r2,-16(fp)
8113de58:	d8800115 	stw	r2,4(sp)
8113de5c:	e0bffb17 	ldw	r2,-20(fp)
8113de60:	d8800015 	stw	r2,0(sp)
8113de64:	000f883a 	mov	r7,zero
8113de68:	000d883a 	mov	r6,zero
8113de6c:	e17ffa17 	ldw	r5,-24(fp)
8113de70:	e13ff917 	ldw	r4,-28(fp)
8113de74:	113db280 	call	8113db28 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
8113de78:	e037883a 	mov	sp,fp
8113de7c:	dfc00117 	ldw	ra,4(sp)
8113de80:	df000017 	ldw	fp,0(sp)
8113de84:	dec00204 	addi	sp,sp,8
8113de88:	f800283a 	ret

8113de8c <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8113de8c:	deffee04 	addi	sp,sp,-72
8113de90:	de00012e 	bgeu	sp,et,8113de98 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
8113de94:	003b68fa 	trap	3
8113de98:	dfc01115 	stw	ra,68(sp)
8113de9c:	df001015 	stw	fp,64(sp)
8113dea0:	df001004 	addi	fp,sp,64
8113dea4:	e13ff915 	stw	r4,-28(fp)
8113dea8:	e17ffa15 	stw	r5,-24(fp)
8113deac:	e1bffb15 	stw	r6,-20(fp)
8113deb0:	e1fffc15 	stw	r7,-16(fp)
8113deb4:	e1000417 	ldw	r4,16(fp)
8113deb8:	e0c00517 	ldw	r3,20(fp)
8113debc:	e0800617 	ldw	r2,24(fp)
8113dec0:	e13ffd0d 	sth	r4,-12(fp)
8113dec4:	e0fffe05 	stb	r3,-8(fp)
8113dec8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8113decc:	e0bffd0b 	ldhu	r2,-12(fp)
8113ded0:	e0fffe03 	ldbu	r3,-8(fp)
8113ded4:	e13fff0b 	ldhu	r4,-4(fp)
8113ded8:	d8000815 	stw	zero,32(sp)
8113dedc:	d9000715 	stw	r4,28(sp)
8113dee0:	d8000615 	stw	zero,24(sp)
8113dee4:	d8c00515 	stw	r3,20(sp)
8113dee8:	d8800415 	stw	r2,16(sp)
8113deec:	e0800317 	ldw	r2,12(fp)
8113def0:	d8800315 	stw	r2,12(sp)
8113def4:	e0800217 	ldw	r2,8(fp)
8113def8:	d8800215 	stw	r2,8(sp)
8113defc:	d8000115 	stw	zero,4(sp)
8113df00:	d8000015 	stw	zero,0(sp)
8113df04:	e1fffc17 	ldw	r7,-16(fp)
8113df08:	e1bffb17 	ldw	r6,-20(fp)
8113df0c:	e17ffa17 	ldw	r5,-24(fp)
8113df10:	e13ff917 	ldw	r4,-28(fp)
8113df14:	113db280 	call	8113db28 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
8113df18:	e037883a 	mov	sp,fp
8113df1c:	dfc00117 	ldw	ra,4(sp)
8113df20:	df000017 	ldw	fp,0(sp)
8113df24:	dec00204 	addi	sp,sp,8
8113df28:	f800283a 	ret

8113df2c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8113df2c:	deffec04 	addi	sp,sp,-80
8113df30:	de00012e 	bgeu	sp,et,8113df38 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
8113df34:	003b68fa 	trap	3
8113df38:	dfc01315 	stw	ra,76(sp)
8113df3c:	df001215 	stw	fp,72(sp)
8113df40:	df001204 	addi	fp,sp,72
8113df44:	e13ff715 	stw	r4,-36(fp)
8113df48:	e17ff815 	stw	r5,-32(fp)
8113df4c:	e1bff915 	stw	r6,-28(fp)
8113df50:	e1fffa15 	stw	r7,-24(fp)
8113df54:	e1800617 	ldw	r6,24(fp)
8113df58:	e1400717 	ldw	r5,28(fp)
8113df5c:	e1000817 	ldw	r4,32(fp)
8113df60:	e0c00917 	ldw	r3,36(fp)
8113df64:	e0800a17 	ldw	r2,40(fp)
8113df68:	e1bffb0d 	sth	r6,-20(fp)
8113df6c:	e17ffc05 	stb	r5,-16(fp)
8113df70:	e13ffd05 	stb	r4,-12(fp)
8113df74:	e0fffe0d 	sth	r3,-8(fp)
8113df78:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8113df7c:	e0bffb0b 	ldhu	r2,-20(fp)
8113df80:	e0fffc03 	ldbu	r3,-16(fp)
8113df84:	e13ffd03 	ldbu	r4,-12(fp)
8113df88:	e17ffe0b 	ldhu	r5,-8(fp)
8113df8c:	e1bfff0b 	ldhu	r6,-4(fp)
8113df90:	d9800815 	stw	r6,32(sp)
8113df94:	d9400715 	stw	r5,28(sp)
8113df98:	d9000615 	stw	r4,24(sp)
8113df9c:	d8c00515 	stw	r3,20(sp)
8113dfa0:	d8800415 	stw	r2,16(sp)
8113dfa4:	e0800517 	ldw	r2,20(fp)
8113dfa8:	d8800315 	stw	r2,12(sp)
8113dfac:	e0800417 	ldw	r2,16(fp)
8113dfb0:	d8800215 	stw	r2,8(sp)
8113dfb4:	e0800317 	ldw	r2,12(fp)
8113dfb8:	d8800115 	stw	r2,4(sp)
8113dfbc:	e0800217 	ldw	r2,8(fp)
8113dfc0:	d8800015 	stw	r2,0(sp)
8113dfc4:	e1fffa17 	ldw	r7,-24(fp)
8113dfc8:	e1bff917 	ldw	r6,-28(fp)
8113dfcc:	e17ff817 	ldw	r5,-32(fp)
8113dfd0:	e13ff717 	ldw	r4,-36(fp)
8113dfd4:	113db280 	call	8113db28 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
8113dfd8:	e037883a 	mov	sp,fp
8113dfdc:	dfc00117 	ldw	ra,4(sp)
8113dfe0:	df000017 	ldw	fp,0(sp)
8113dfe4:	dec00204 	addi	sp,sp,8
8113dfe8:	f800283a 	ret

8113dfec <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
8113dfec:	defffc04 	addi	sp,sp,-16
8113dff0:	de00012e 	bgeu	sp,et,8113dff8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
8113dff4:	003b68fa 	trap	3
8113dff8:	df000315 	stw	fp,12(sp)
8113dffc:	df000304 	addi	fp,sp,12
8113e000:	e13ffe15 	stw	r4,-8(fp)
8113e004:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
8113e008:	e0bfff17 	ldw	r2,-4(fp)
8113e00c:	1000021e 	bne	r2,zero,8113e018 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8113e010:	00bffa84 	movi	r2,-22
8113e014:	00002f06 	br	8113e0d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
8113e018:	e0bfff17 	ldw	r2,-4(fp)
8113e01c:	10c00317 	ldw	r3,12(r2)
8113e020:	e0bfff17 	ldw	r2,-4(fp)
8113e024:	18800226 	beq	r3,r2,8113e030 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8113e028:	00bffa84 	movi	r2,-22
8113e02c:	00002906 	br	8113e0d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
8113e030:	e0bffe17 	ldw	r2,-8(fp)
8113e034:	10800017 	ldw	r2,0(r2)
8113e038:	1000051e 	bne	r2,zero,8113e050 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
8113e03c:	e0bffe17 	ldw	r2,-8(fp)
8113e040:	e0ffff17 	ldw	r3,-4(fp)
8113e044:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
8113e048:	0005883a 	mov	r2,zero
8113e04c:	00002106 	br	8113e0d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
8113e050:	e0bffe17 	ldw	r2,-8(fp)
8113e054:	10c00017 	ldw	r3,0(r2)
8113e058:	e0bfff17 	ldw	r2,-4(fp)
8113e05c:	1880021e 	bne	r3,r2,8113e068 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8113e060:	00bffa84 	movi	r2,-22
8113e064:	00001b06 	br	8113e0d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8113e068:	e0bffe17 	ldw	r2,-8(fp)
8113e06c:	10800017 	ldw	r2,0(r2)
8113e070:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8113e074:	00000906 	br	8113e09c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
8113e078:	e0bffd17 	ldw	r2,-12(fp)
8113e07c:	10c00317 	ldw	r3,12(r2)
8113e080:	e0bfff17 	ldw	r2,-4(fp)
8113e084:	1880021e 	bne	r3,r2,8113e090 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8113e088:	00bffa84 	movi	r2,-22
8113e08c:	00001106 	br	8113e0d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8113e090:	e0bffd17 	ldw	r2,-12(fp)
8113e094:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
8113e098:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8113e09c:	e0bffd17 	ldw	r2,-12(fp)
8113e0a0:	10800317 	ldw	r2,12(r2)
8113e0a4:	e0fffe17 	ldw	r3,-8(fp)
8113e0a8:	18c00017 	ldw	r3,0(r3)
8113e0ac:	10fff21e 	bne	r2,r3,8113e078 <__reset+0xfb11e078>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8113e0b0:	e0ffff17 	ldw	r3,-4(fp)
8113e0b4:	e0bffd17 	ldw	r2,-12(fp)
8113e0b8:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
8113e0bc:	e0bffe17 	ldw	r2,-8(fp)
8113e0c0:	10800017 	ldw	r2,0(r2)
8113e0c4:	1007883a 	mov	r3,r2
8113e0c8:	e0bfff17 	ldw	r2,-4(fp)
8113e0cc:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
8113e0d0:	0005883a 	mov	r2,zero
}
8113e0d4:	e037883a 	mov	sp,fp
8113e0d8:	df000017 	ldw	fp,0(sp)
8113e0dc:	dec00104 	addi	sp,sp,4
8113e0e0:	f800283a 	ret

8113e0e4 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
8113e0e4:	defff804 	addi	sp,sp,-32
8113e0e8:	de00012e 	bgeu	sp,et,8113e0f0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
8113e0ec:	003b68fa 	trap	3
8113e0f0:	df000715 	stw	fp,28(sp)
8113e0f4:	df000704 	addi	fp,sp,28
8113e0f8:	e13ffe15 	stw	r4,-8(fp)
8113e0fc:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
8113e100:	e13fff17 	ldw	r4,-4(fp)
8113e104:	2000021e 	bne	r4,zero,8113e110 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8113e108:	00bffa84 	movi	r2,-22
8113e10c:	00005906 	br	8113e274 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
8113e110:	e13fff17 	ldw	r4,-4(fp)
8113e114:	2015883a 	mov	r10,r4
8113e118:	0017883a 	mov	r11,zero
8113e11c:	e2bffc15 	stw	r10,-16(fp)
8113e120:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8113e124:	e13fff17 	ldw	r4,-4(fp)
8113e128:	21400317 	ldw	r5,12(r4)
8113e12c:	e13ffc17 	ldw	r4,-16(fp)
8113e130:	29000626 	beq	r5,r4,8113e14c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
8113e134:	e13fff17 	ldw	r4,-4(fp)
8113e138:	21400b17 	ldw	r5,44(r4)
8113e13c:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8113e140:	29000226 	beq	r5,r4,8113e14c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8113e144:	00bffa84 	movi	r2,-22
8113e148:	00004a06 	br	8113e274 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
8113e14c:	e13ffe17 	ldw	r4,-8(fp)
8113e150:	21000017 	ldw	r4,0(r4)
8113e154:	2000051e 	bne	r4,zero,8113e16c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
8113e158:	e0bffe17 	ldw	r2,-8(fp)
8113e15c:	e0ffff17 	ldw	r3,-4(fp)
8113e160:	10c00015 	stw	r3,0(r2)
		return 0;
8113e164:	0005883a 	mov	r2,zero
8113e168:	00004206 	br	8113e274 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
8113e16c:	e13ffe17 	ldw	r4,-8(fp)
8113e170:	21400017 	ldw	r5,0(r4)
8113e174:	e13fff17 	ldw	r4,-4(fp)
8113e178:	2900021e 	bne	r5,r4,8113e184 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8113e17c:	00bffa84 	movi	r2,-22
8113e180:	00003c06 	br	8113e274 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8113e184:	e13ffe17 	ldw	r4,-8(fp)
8113e188:	21000017 	ldw	r4,0(r4)
8113e18c:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
8113e190:	e13ffe17 	ldw	r4,-8(fp)
8113e194:	21000017 	ldw	r4,0(r4)
8113e198:	2011883a 	mov	r8,r4
8113e19c:	0013883a 	mov	r9,zero
8113e1a0:	e23ffa15 	stw	r8,-24(fp)
8113e1a4:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113e1a8:	00001806 	br	8113e20c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
8113e1ac:	e13fff17 	ldw	r4,-4(fp)
8113e1b0:	200d883a 	mov	r6,r4
8113e1b4:	000f883a 	mov	r7,zero
8113e1b8:	e1bffc15 	stw	r6,-16(fp)
8113e1bc:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8113e1c0:	e13ff917 	ldw	r4,-28(fp)
8113e1c4:	21400317 	ldw	r5,12(r4)
8113e1c8:	e13ffc17 	ldw	r4,-16(fp)
8113e1cc:	2900061e 	bne	r5,r4,8113e1e8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
8113e1d0:	e13ff917 	ldw	r4,-28(fp)
8113e1d4:	21400b17 	ldw	r5,44(r4)
8113e1d8:	e13ffd17 	ldw	r4,-12(fp)
8113e1dc:	2900021e 	bne	r5,r4,8113e1e8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8113e1e0:	00bffa84 	movi	r2,-22
8113e1e4:	00002306 	br	8113e274 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8113e1e8:	e13ff917 	ldw	r4,-28(fp)
8113e1ec:	21000317 	ldw	r4,12(r4)
8113e1f0:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8113e1f4:	e13ff917 	ldw	r4,-28(fp)
8113e1f8:	21000b17 	ldw	r4,44(r4)
8113e1fc:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8113e200:	e13ffc17 	ldw	r4,-16(fp)
8113e204:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8113e208:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113e20c:	e13ff917 	ldw	r4,-28(fp)
8113e210:	21400317 	ldw	r5,12(r4)
8113e214:	e13ffa17 	ldw	r4,-24(fp)
8113e218:	29000426 	beq	r5,r4,8113e22c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8113e21c:	e13ff917 	ldw	r4,-28(fp)
8113e220:	21400b17 	ldw	r5,44(r4)
8113e224:	e13ffb17 	ldw	r4,-20(fp)
8113e228:	293fe01e 	bne	r5,r4,8113e1ac <__reset+0xfb11e1ac>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
8113e22c:	e13fff17 	ldw	r4,-4(fp)
8113e230:	2005883a 	mov	r2,r4
8113e234:	0007883a 	mov	r3,zero
8113e238:	e0bffc15 	stw	r2,-16(fp)
8113e23c:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
8113e240:	e0fffc17 	ldw	r3,-16(fp)
8113e244:	e0bff917 	ldw	r2,-28(fp)
8113e248:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
8113e24c:	e0fffd17 	ldw	r3,-12(fp)
8113e250:	e0bff917 	ldw	r2,-28(fp)
8113e254:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
8113e258:	e0fffa17 	ldw	r3,-24(fp)
8113e25c:	e0bfff17 	ldw	r2,-4(fp)
8113e260:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
8113e264:	e0fffb17 	ldw	r3,-20(fp)
8113e268:	e0bfff17 	ldw	r2,-4(fp)
8113e26c:	10c00b15 	stw	r3,44(r2)
	return 0;
8113e270:	0005883a 	mov	r2,zero
}
8113e274:	e037883a 	mov	sp,fp
8113e278:	df000017 	ldw	fp,0(sp)
8113e27c:	dec00104 	addi	sp,sp,4
8113e280:	f800283a 	ret

8113e284 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
8113e284:	defffc04 	addi	sp,sp,-16
8113e288:	de00012e 	bgeu	sp,et,8113e290 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
8113e28c:	003b68fa 	trap	3
8113e290:	df000315 	stw	fp,12(sp)
8113e294:	df000304 	addi	fp,sp,12
8113e298:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8113e29c:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8113e2a0:	e0bfff17 	ldw	r2,-4(fp)
8113e2a4:	1000021e 	bne	r2,zero,8113e2b0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8113e2a8:	00bffa84 	movi	r2,-22
8113e2ac:	00001906 	br	8113e314 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8113e2b0:	e0bfff17 	ldw	r2,-4(fp)
8113e2b4:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8113e2b8:	00000a06 	br	8113e2e4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
8113e2bc:	e0bffd17 	ldw	r2,-12(fp)
8113e2c0:	10800717 	ldw	r2,28(r2)
8113e2c4:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113e2c8:	e0bffe17 	ldw	r2,-8(fp)
8113e2cc:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8113e2d0:	e0bffd17 	ldw	r2,-12(fp)
8113e2d4:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8113e2d8:	e0bffd17 	ldw	r2,-12(fp)
8113e2dc:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
8113e2e0:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8113e2e4:	e0bffd17 	ldw	r2,-12(fp)
8113e2e8:	10c00317 	ldw	r3,12(r2)
8113e2ec:	e0bfff17 	ldw	r2,-4(fp)
8113e2f0:	18bff21e 	bne	r3,r2,8113e2bc <__reset+0xfb11e2bc>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
8113e2f4:	e0bffd17 	ldw	r2,-12(fp)
8113e2f8:	10800717 	ldw	r2,28(r2)
8113e2fc:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113e300:	e0bffe17 	ldw	r2,-8(fp)
8113e304:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8113e308:	e0bffd17 	ldw	r2,-12(fp)
8113e30c:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
8113e310:	0005883a 	mov	r2,zero
}
8113e314:	e037883a 	mov	sp,fp
8113e318:	df000017 	ldw	fp,0(sp)
8113e31c:	dec00104 	addi	sp,sp,4
8113e320:	f800283a 	ret

8113e324 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
8113e324:	defff804 	addi	sp,sp,-32
8113e328:	de00012e 	bgeu	sp,et,8113e330 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
8113e32c:	003b68fa 	trap	3
8113e330:	df000715 	stw	fp,28(sp)
8113e334:	df000704 	addi	fp,sp,28
8113e338:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8113e33c:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
8113e340:	e13fff17 	ldw	r4,-4(fp)
8113e344:	2000021e 	bne	r4,zero,8113e350 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8113e348:	00bffa84 	movi	r2,-22
8113e34c:	00002806 	br	8113e3f0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8113e350:	e13fff17 	ldw	r4,-4(fp)
8113e354:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
8113e358:	e13fff17 	ldw	r4,-4(fp)
8113e35c:	2005883a 	mov	r2,r4
8113e360:	0007883a 	mov	r3,zero
8113e364:	e0bffb15 	stw	r2,-20(fp)
8113e368:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113e36c:	00001006 	br	8113e3b0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
8113e370:	e0bff917 	ldw	r2,-28(fp)
8113e374:	10800f17 	ldw	r2,60(r2)
8113e378:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113e37c:	e0bffa17 	ldw	r2,-24(fp)
8113e380:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8113e384:	e0bff917 	ldw	r2,-28(fp)
8113e388:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8113e38c:	e0bff917 	ldw	r2,-28(fp)
8113e390:	10800317 	ldw	r2,12(r2)
8113e394:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8113e398:	e0bff917 	ldw	r2,-28(fp)
8113e39c:	10800b17 	ldw	r2,44(r2)
8113e3a0:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8113e3a4:	e0bffd17 	ldw	r2,-12(fp)
8113e3a8:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8113e3ac:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113e3b0:	e0bff917 	ldw	r2,-28(fp)
8113e3b4:	10c00317 	ldw	r3,12(r2)
8113e3b8:	e0bffb17 	ldw	r2,-20(fp)
8113e3bc:	18800426 	beq	r3,r2,8113e3d0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8113e3c0:	e0bff917 	ldw	r2,-28(fp)
8113e3c4:	10c00b17 	ldw	r3,44(r2)
8113e3c8:	e0bffc17 	ldw	r2,-16(fp)
8113e3cc:	18bfe81e 	bne	r3,r2,8113e370 <__reset+0xfb11e370>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8113e3d0:	e0bff917 	ldw	r2,-28(fp)
8113e3d4:	10800f17 	ldw	r2,60(r2)
8113e3d8:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113e3dc:	e0bffa17 	ldw	r2,-24(fp)
8113e3e0:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8113e3e4:	e0bff917 	ldw	r2,-28(fp)
8113e3e8:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
8113e3ec:	0005883a 	mov	r2,zero
}
8113e3f0:	e037883a 	mov	sp,fp
8113e3f4:	df000017 	ldw	fp,0(sp)
8113e3f8:	dec00104 	addi	sp,sp,4
8113e3fc:	f800283a 	ret

8113e400 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8113e400:	deffeb04 	addi	sp,sp,-84
8113e404:	de00012e 	bgeu	sp,et,8113e40c <alt_msgdma_start_prefetcher_with_list_addr+0xc>
8113e408:	003b68fa 	trap	3
8113e40c:	dfc01415 	stw	ra,80(sp)
8113e410:	df001315 	stw	fp,76(sp)
8113e414:	df001304 	addi	fp,sp,76
8113e418:	e13ffb15 	stw	r4,-20(fp)
8113e41c:	e17ffc15 	stw	r5,-16(fp)
8113e420:	e1bffd15 	stw	r6,-12(fp)
8113e424:	3807883a 	mov	r3,r7
8113e428:	e0800217 	ldw	r2,8(fp)
8113e42c:	e0fffe05 	stb	r3,-8(fp)
8113e430:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
8113e434:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
8113e438:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
8113e43c:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8113e440:	e0bffc17 	ldw	r2,-16(fp)
8113e444:	e0bff815 	stw	r2,-32(fp)
8113e448:	e0bffd17 	ldw	r2,-12(fp)
8113e44c:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8113e450:	e0bffb17 	ldw	r2,-20(fp)
8113e454:	10801817 	ldw	r2,96(r2)
8113e458:	e0bff615 	stw	r2,-40(fp)
8113e45c:	e03ff70d 	sth	zero,-36(fp)
8113e460:	e0bff70b 	ldhu	r2,-36(fp)
8113e464:	e0fffa04 	addi	r3,fp,-24
8113e468:	180d883a 	mov	r6,r3
8113e46c:	100b883a 	mov	r5,r2
8113e470:	e13ff617 	ldw	r4,-40(fp)
8113e474:	11337600 	call	81133760 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
8113e478:	e0bffb17 	ldw	r2,-20(fp)
8113e47c:	10800617 	ldw	r2,24(r2)
8113e480:	10800037 	ldwio	r2,0(r2)
8113e484:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
8113e488:	e0bfed17 	ldw	r2,-76(fp)
8113e48c:	1080004c 	andi	r2,r2,1
8113e490:	10000626 	beq	r2,zero,8113e4ac <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
8113e494:	e0bffb17 	ldw	r2,-20(fp)
8113e498:	10801817 	ldw	r2,96(r2)
8113e49c:	1009883a 	mov	r4,r2
8113e4a0:	1133ae80 	call	81133ae8 <OSSemPost>
		return -EBUSY;
8113e4a4:	00bffc04 	movi	r2,-16
8113e4a8:	00009606 	br	8113e704 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8113e4ac:	00800804 	movi	r2,32
8113e4b0:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e4b4:	0005303a 	rdctl	r2,status
8113e4b8:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e4bc:	e0fff217 	ldw	r3,-56(fp)
8113e4c0:	00bfff84 	movi	r2,-2
8113e4c4:	1884703a 	and	r2,r3,r2
8113e4c8:	1001703a 	wrctl	status,r2
  
  return context;
8113e4cc:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8113e4d0:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8113e4d4:	e0bffb17 	ldw	r2,-20(fp)
8113e4d8:	10800317 	ldw	r2,12(r2)
8113e4dc:	10800104 	addi	r2,r2,4
8113e4e0:	e0ffee17 	ldw	r3,-72(fp)
8113e4e4:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
8113e4e8:	e0bffb17 	ldw	r2,-20(fp)
8113e4ec:	10800317 	ldw	r2,12(r2)
8113e4f0:	e0fffb17 	ldw	r3,-20(fp)
8113e4f4:	18c00317 	ldw	r3,12(r3)
8113e4f8:	18c00037 	ldwio	r3,0(r3)
8113e4fc:	10c00035 	stwio	r3,0(r2)
8113e500:	e0bfef17 	ldw	r2,-68(fp)
8113e504:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e508:	e0bff017 	ldw	r2,-64(fp)
8113e50c:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
8113e510:	e0bffb17 	ldw	r2,-20(fp)
8113e514:	10800b17 	ldw	r2,44(r2)
8113e518:	10002326 	beq	r2,zero,8113e5a8 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
8113e51c:	e0bffb17 	ldw	r2,-20(fp)
8113e520:	10c00d17 	ldw	r3,52(r2)
8113e524:	e0bfee17 	ldw	r2,-72(fp)
8113e528:	1884b03a 	or	r2,r3,r2
8113e52c:	10800514 	ori	r2,r2,20
8113e530:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8113e534:	e0ffee17 	ldw	r3,-72(fp)
8113e538:	00bff7c4 	movi	r2,-33
8113e53c:	1884703a 	and	r2,r3,r2
8113e540:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8113e544:	e0bfed17 	ldw	r2,-76(fp)
8113e548:	10800214 	ori	r2,r2,8
8113e54c:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e550:	0005303a 	rdctl	r2,status
8113e554:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e558:	e0fff417 	ldw	r3,-48(fp)
8113e55c:	00bfff84 	movi	r2,-2
8113e560:	1884703a 	and	r2,r3,r2
8113e564:	1001703a 	wrctl	status,r2
  
  return context;
8113e568:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
8113e56c:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8113e570:	e0bffb17 	ldw	r2,-20(fp)
8113e574:	10800317 	ldw	r2,12(r2)
8113e578:	10800104 	addi	r2,r2,4
8113e57c:	e0ffee17 	ldw	r3,-72(fp)
8113e580:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8113e584:	e0bffb17 	ldw	r2,-20(fp)
8113e588:	10800617 	ldw	r2,24(r2)
8113e58c:	e0ffed17 	ldw	r3,-76(fp)
8113e590:	10c00035 	stwio	r3,0(r2)
8113e594:	e0bfef17 	ldw	r2,-68(fp)
8113e598:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e59c:	e0bff117 	ldw	r2,-60(fp)
8113e5a0:	1001703a 	wrctl	status,r2
8113e5a4:	00002306 	br	8113e634 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
8113e5a8:	e0bffb17 	ldw	r2,-20(fp)
8113e5ac:	10c00d17 	ldw	r3,52(r2)
8113e5b0:	e0bfee17 	ldw	r2,-72(fp)
8113e5b4:	1884b03a 	or	r2,r3,r2
8113e5b8:	10800114 	ori	r2,r2,4
8113e5bc:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
8113e5c0:	e0ffee17 	ldw	r3,-72(fp)
8113e5c4:	00bff3c4 	movi	r2,-49
8113e5c8:	1884703a 	and	r2,r3,r2
8113e5cc:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
8113e5d0:	e0ffed17 	ldw	r3,-76(fp)
8113e5d4:	00bffdc4 	movi	r2,-9
8113e5d8:	1884703a 	and	r2,r3,r2
8113e5dc:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e5e0:	0005303a 	rdctl	r2,status
8113e5e4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e5e8:	e0fff517 	ldw	r3,-44(fp)
8113e5ec:	00bfff84 	movi	r2,-2
8113e5f0:	1884703a 	and	r2,r3,r2
8113e5f4:	1001703a 	wrctl	status,r2
  
  return context;
8113e5f8:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
8113e5fc:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8113e600:	e0bffb17 	ldw	r2,-20(fp)
8113e604:	10800317 	ldw	r2,12(r2)
8113e608:	10800104 	addi	r2,r2,4
8113e60c:	e0ffee17 	ldw	r3,-72(fp)
8113e610:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8113e614:	e0bffb17 	ldw	r2,-20(fp)
8113e618:	10800617 	ldw	r2,24(r2)
8113e61c:	e0ffed17 	ldw	r3,-76(fp)
8113e620:	10c00035 	stwio	r3,0(r2)
8113e624:	e0bfef17 	ldw	r2,-68(fp)
8113e628:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e62c:	e0bff317 	ldw	r2,-52(fp)
8113e630:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
8113e634:	e0bffb17 	ldw	r2,-20(fp)
8113e638:	10800617 	ldw	r2,24(r2)
8113e63c:	10800104 	addi	r2,r2,4
8113e640:	e0fff817 	ldw	r3,-32(fp)
8113e644:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
8113e648:	e0bffb17 	ldw	r2,-20(fp)
8113e64c:	10800617 	ldw	r2,24(r2)
8113e650:	10800204 	addi	r2,r2,8
8113e654:	e0fff917 	ldw	r3,-28(fp)
8113e658:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
8113e65c:	e0bffe03 	ldbu	r2,-8(fp)
8113e660:	10000426 	beq	r2,zero,8113e674 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
8113e664:	e0bfed17 	ldw	r2,-76(fp)
8113e668:	10800414 	ori	r2,r2,16
8113e66c:	e0bfed15 	stw	r2,-76(fp)
8113e670:	00000406 	br	8113e684 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
8113e674:	e0ffed17 	ldw	r3,-76(fp)
8113e678:	00bffbc4 	movi	r2,-17
8113e67c:	1884703a 	and	r2,r3,r2
8113e680:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
8113e684:	e0bfff03 	ldbu	r2,-4(fp)
8113e688:	10000e26 	beq	r2,zero,8113e6c4 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
8113e68c:	e0bfed17 	ldw	r2,-76(fp)
8113e690:	10800094 	ori	r2,r2,2
8113e694:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8113e698:	e0bffb17 	ldw	r2,-20(fp)
8113e69c:	10800617 	ldw	r2,24(r2)
8113e6a0:	10800304 	addi	r2,r2,12
8113e6a4:	10800037 	ldwio	r2,0(r2)
8113e6a8:	10000a1e 	bne	r2,zero,8113e6d4 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8113e6ac:	e0bffb17 	ldw	r2,-20(fp)
8113e6b0:	10800617 	ldw	r2,24(r2)
8113e6b4:	10800304 	addi	r2,r2,12
8113e6b8:	00c03fc4 	movi	r3,255
8113e6bc:	10c00035 	stwio	r3,0(r2)
8113e6c0:	00000406 	br	8113e6d4 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
8113e6c4:	e0ffed17 	ldw	r3,-76(fp)
8113e6c8:	00bfff44 	movi	r2,-3
8113e6cc:	1884703a 	and	r2,r3,r2
8113e6d0:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
8113e6d4:	e0bfed17 	ldw	r2,-76(fp)
8113e6d8:	10800054 	ori	r2,r2,1
8113e6dc:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8113e6e0:	e0bffb17 	ldw	r2,-20(fp)
8113e6e4:	10800617 	ldw	r2,24(r2)
8113e6e8:	e0ffed17 	ldw	r3,-76(fp)
8113e6ec:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
8113e6f0:	e0bffb17 	ldw	r2,-20(fp)
8113e6f4:	10801817 	ldw	r2,96(r2)
8113e6f8:	1009883a 	mov	r4,r2
8113e6fc:	1133ae80 	call	81133ae8 <OSSemPost>
	 
	 return 0;
8113e700:	0005883a 	mov	r2,zero
}
8113e704:	e037883a 	mov	sp,fp
8113e708:	dfc00117 	ldw	ra,4(sp)
8113e70c:	df000017 	ldw	fp,0(sp)
8113e710:	dec00204 	addi	sp,sp,8
8113e714:	f800283a 	ret

8113e718 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
8113e718:	defff704 	addi	sp,sp,-36
8113e71c:	de00012e 	bgeu	sp,et,8113e724 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
8113e720:	003b68fa 	trap	3
8113e724:	dfc00815 	stw	ra,32(sp)
8113e728:	df000715 	stw	fp,28(sp)
8113e72c:	dc400615 	stw	r17,24(sp)
8113e730:	dc000515 	stw	r16,20(sp)
8113e734:	df000704 	addi	fp,sp,28
8113e738:	e13ffa15 	stw	r4,-24(fp)
8113e73c:	e17ffb15 	stw	r5,-20(fp)
8113e740:	3007883a 	mov	r3,r6
8113e744:	3805883a 	mov	r2,r7
8113e748:	e0fffc05 	stb	r3,-16(fp)
8113e74c:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
8113e750:	e13ffb17 	ldw	r4,-20(fp)
8113e754:	113e2840 	call	8113e284 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
8113e758:	10000226 	beq	r2,zero,8113e764 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
8113e75c:	00bffa84 	movi	r2,-22
8113e760:	00000b06 	br	8113e790 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
8113e764:	e0bffb17 	ldw	r2,-20(fp)
8113e768:	1021883a 	mov	r16,r2
8113e76c:	0023883a 	mov	r17,zero
8113e770:	e0fffc03 	ldbu	r3,-16(fp)
8113e774:	e0bffd03 	ldbu	r2,-12(fp)
8113e778:	d8800015 	stw	r2,0(sp)
8113e77c:	180f883a 	mov	r7,r3
8113e780:	800b883a 	mov	r5,r16
8113e784:	880d883a 	mov	r6,r17
8113e788:	e13ffa17 	ldw	r4,-24(fp)
8113e78c:	113e4000 	call	8113e400 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8113e790:	e6fffe04 	addi	sp,fp,-8
8113e794:	dfc00317 	ldw	ra,12(sp)
8113e798:	df000217 	ldw	fp,8(sp)
8113e79c:	dc400117 	ldw	r17,4(sp)
8113e7a0:	dc000017 	ldw	r16,0(sp)
8113e7a4:	dec00404 	addi	sp,sp,16
8113e7a8:	f800283a 	ret

8113e7ac <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8113e7ac:	defff704 	addi	sp,sp,-36
8113e7b0:	de00012e 	bgeu	sp,et,8113e7b8 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
8113e7b4:	003b68fa 	trap	3
8113e7b8:	dfc00815 	stw	ra,32(sp)
8113e7bc:	df000715 	stw	fp,28(sp)
8113e7c0:	dc400615 	stw	r17,24(sp)
8113e7c4:	dc000515 	stw	r16,20(sp)
8113e7c8:	df000704 	addi	fp,sp,28
8113e7cc:	e13ffa15 	stw	r4,-24(fp)
8113e7d0:	e17ffb15 	stw	r5,-20(fp)
8113e7d4:	3007883a 	mov	r3,r6
8113e7d8:	3805883a 	mov	r2,r7
8113e7dc:	e0fffc05 	stb	r3,-16(fp)
8113e7e0:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
8113e7e4:	e13ffb17 	ldw	r4,-20(fp)
8113e7e8:	113e3240 	call	8113e324 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
8113e7ec:	10000226 	beq	r2,zero,8113e7f8 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
8113e7f0:	00bffa84 	movi	r2,-22
8113e7f4:	00000b06 	br	8113e824 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
8113e7f8:	e0bffb17 	ldw	r2,-20(fp)
8113e7fc:	1021883a 	mov	r16,r2
8113e800:	0023883a 	mov	r17,zero
8113e804:	e0fffc03 	ldbu	r3,-16(fp)
8113e808:	e0bffd03 	ldbu	r2,-12(fp)
8113e80c:	d8800015 	stw	r2,0(sp)
8113e810:	180f883a 	mov	r7,r3
8113e814:	800b883a 	mov	r5,r16
8113e818:	880d883a 	mov	r6,r17
8113e81c:	e13ffa17 	ldw	r4,-24(fp)
8113e820:	113e4000 	call	8113e400 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8113e824:	e6fffe04 	addi	sp,fp,-8
8113e828:	dfc00317 	ldw	ra,12(sp)
8113e82c:	df000217 	ldw	fp,8(sp)
8113e830:	dc400117 	ldw	r17,4(sp)
8113e834:	dc000017 	ldw	r16,0(sp)
8113e838:	dec00404 	addi	sp,sp,16
8113e83c:	f800283a 	ret

8113e840 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
8113e840:	defffc04 	addi	sp,sp,-16
8113e844:	de00012e 	bgeu	sp,et,8113e84c <alt_msgdma_open+0xc>
8113e848:	003b68fa 	trap	3
8113e84c:	dfc00315 	stw	ra,12(sp)
8113e850:	df000215 	stw	fp,8(sp)
8113e854:	df000204 	addi	fp,sp,8
8113e858:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
8113e85c:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
8113e860:	d1603504 	addi	r5,gp,-32556
8113e864:	e13fff17 	ldw	r4,-4(fp)
8113e868:	113ede40 	call	8113ede4 <alt_find_dev>
8113e86c:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
8113e870:	e0bffe17 	ldw	r2,-8(fp)
8113e874:	1000041e 	bne	r2,zero,8113e888 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
8113e878:	113caa40 	call	8113caa4 <alt_get_errno>
8113e87c:	1007883a 	mov	r3,r2
8113e880:	008004c4 	movi	r2,19
8113e884:	18800015 	stw	r2,0(r3)
    }

    return dev;
8113e888:	e0bffe17 	ldw	r2,-8(fp)
}
8113e88c:	e037883a 	mov	sp,fp
8113e890:	dfc00117 	ldw	ra,4(sp)
8113e894:	df000017 	ldw	fp,0(sp)
8113e898:	dec00204 	addi	sp,sp,8
8113e89c:	f800283a 	ret

8113e8a0 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
8113e8a0:	defff604 	addi	sp,sp,-40
8113e8a4:	de00012e 	bgeu	sp,et,8113e8ac <alt_msgdma_init+0xc>
8113e8a8:	003b68fa 	trap	3
8113e8ac:	dfc00915 	stw	ra,36(sp)
8113e8b0:	df000815 	stw	fp,32(sp)
8113e8b4:	df000804 	addi	fp,sp,32
8113e8b8:	e13ffd15 	stw	r4,-12(fp)
8113e8bc:	e17ffe15 	stw	r5,-8(fp)
8113e8c0:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
8113e8c4:	e0bffd17 	ldw	r2,-12(fp)
8113e8c8:	10801783 	ldbu	r2,94(r2)
8113e8cc:	10803fcc 	andi	r2,r2,255
8113e8d0:	10000b26 	beq	r2,zero,8113e900 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
8113e8d4:	e0bffd17 	ldw	r2,-12(fp)
8113e8d8:	10800617 	ldw	r2,24(r2)
8113e8dc:	00c00104 	movi	r3,4
8113e8e0:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
8113e8e4:	0001883a 	nop
8113e8e8:	e0bffd17 	ldw	r2,-12(fp)
8113e8ec:	10800617 	ldw	r2,24(r2)
8113e8f0:	10800037 	ldwio	r2,0(r2)
8113e8f4:	1080010c 	andi	r2,r2,4
8113e8f8:	1005d0ba 	srai	r2,r2,2
8113e8fc:	103ffa1e 	bne	r2,zero,8113e8e8 <__reset+0xfb11e8e8>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
8113e900:	e0bffd17 	ldw	r2,-12(fp)
8113e904:	10800317 	ldw	r2,12(r2)
8113e908:	10800104 	addi	r2,r2,4
8113e90c:	00c00084 	movi	r3,2
8113e910:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8113e914:	0001883a 	nop
8113e918:	e0bffd17 	ldw	r2,-12(fp)
8113e91c:	10800317 	ldw	r2,12(r2)
8113e920:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
8113e924:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8113e928:	103ffb1e 	bne	r2,zero,8113e918 <__reset+0xfb11e918>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8113e92c:	e0bffd17 	ldw	r2,-12(fp)
8113e930:	10800317 	ldw	r2,12(r2)
8113e934:	10800104 	addi	r2,r2,4
8113e938:	10800037 	ldwio	r2,0(r2)
8113e93c:	1007883a 	mov	r3,r2
8113e940:	00bffbc4 	movi	r2,-17
8113e944:	1884703a 	and	r2,r3,r2
8113e948:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8113e94c:	e0bff917 	ldw	r2,-28(fp)
8113e950:	10800814 	ori	r2,r2,32
8113e954:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8113e958:	e0bffd17 	ldw	r2,-12(fp)
8113e95c:	10800317 	ldw	r2,12(r2)
8113e960:	10800104 	addi	r2,r2,4
8113e964:	e0fff917 	ldw	r3,-28(fp)
8113e968:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
8113e96c:	e0bffd17 	ldw	r2,-12(fp)
8113e970:	10800317 	ldw	r2,12(r2)
8113e974:	e0fffd17 	ldw	r3,-12(fp)
8113e978:	18c00317 	ldw	r3,12(r3)
8113e97c:	18c00037 	ldwio	r3,0(r3)
8113e980:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
8113e984:	e0bffd17 	ldw	r2,-12(fp)
8113e988:	10801783 	ldbu	r2,94(r2)
8113e98c:	10803fcc 	andi	r2,r2,255
8113e990:	10000826 	beq	r2,zero,8113e9b4 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
8113e994:	e0bffd17 	ldw	r2,-12(fp)
8113e998:	10800617 	ldw	r2,24(r2)
8113e99c:	10800404 	addi	r2,r2,16
8113e9a0:	e0fffd17 	ldw	r3,-12(fp)
8113e9a4:	18c00617 	ldw	r3,24(r3)
8113e9a8:	18c00404 	addi	r3,r3,16
8113e9ac:	18c00037 	ldwio	r3,0(r3)
8113e9b0:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
8113e9b4:	d1603504 	addi	r5,gp,-32556
8113e9b8:	e13ffd17 	ldw	r4,-12(fp)
8113e9bc:	113ed380 	call	8113ed38 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
8113e9c0:	e0bffd17 	ldw	r2,-12(fp)
8113e9c4:	10801804 	addi	r2,r2,96
8113e9c8:	e0bffb15 	stw	r2,-20(fp)
8113e9cc:	00800044 	movi	r2,1
8113e9d0:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8113e9d4:	e0bffc0b 	ldhu	r2,-16(fp)
8113e9d8:	1009883a 	mov	r4,r2
8113e9dc:	11334380 	call	81133438 <OSSemCreate>
8113e9e0:	1007883a 	mov	r3,r2
8113e9e4:	e0bffb17 	ldw	r2,-20(fp)
8113e9e8:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8113e9ec:	e0bffb17 	ldw	r2,-20(fp)
8113e9f0:	10800017 	ldw	r2,0(r2)
8113e9f4:	10000226 	beq	r2,zero,8113ea00 <alt_msgdma_init+0x160>
8113e9f8:	0005883a 	mov	r2,zero
8113e9fc:	00000106 	br	8113ea04 <alt_msgdma_init+0x164>
8113ea00:	00bfffc4 	movi	r2,-1
8113ea04:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
8113ea08:	e0bffa17 	ldw	r2,-24(fp)
8113ea0c:	1000081e 	bne	r2,zero,8113ea30 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
8113ea10:	d8000015 	stw	zero,0(sp)
8113ea14:	e1fffd17 	ldw	r7,-12(fp)
8113ea18:	01a04534 	movhi	r6,33044
8113ea1c:	31b32e04 	addi	r6,r6,-13128
8113ea20:	e17fff17 	ldw	r5,-4(fp)
8113ea24:	e13ffe17 	ldw	r4,-8(fp)
8113ea28:	113f0700 	call	8113f070 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
8113ea2c:	00000406 	br	8113ea40 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
8113ea30:	01204534 	movhi	r4,33044
8113ea34:	21136604 	addi	r4,r4,19864
8113ea38:	113f4880 	call	8113f488 <alt_printf>
    }
    
    return;
8113ea3c:	0001883a 	nop

}
8113ea40:	e037883a 	mov	sp,fp
8113ea44:	dfc00117 	ldw	ra,4(sp)
8113ea48:	df000017 	ldw	fp,0(sp)
8113ea4c:	dec00204 	addi	sp,sp,8
8113ea50:	f800283a 	ret

8113ea54 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
8113ea54:	defffb04 	addi	sp,sp,-20
8113ea58:	de00012e 	bgeu	sp,et,8113ea60 <alt_msgdma_register_callback+0xc>
8113ea5c:	003b68fa 	trap	3
8113ea60:	df000415 	stw	fp,16(sp)
8113ea64:	df000404 	addi	fp,sp,16
8113ea68:	e13ffc15 	stw	r4,-16(fp)
8113ea6c:	e17ffd15 	stw	r5,-12(fp)
8113ea70:	e1bffe15 	stw	r6,-8(fp)
8113ea74:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
8113ea78:	e0bffc17 	ldw	r2,-16(fp)
8113ea7c:	e0fffd17 	ldw	r3,-12(fp)
8113ea80:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
8113ea84:	e0bffc17 	ldw	r2,-16(fp)
8113ea88:	e0ffff17 	ldw	r3,-4(fp)
8113ea8c:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
8113ea90:	e0bffc17 	ldw	r2,-16(fp)
8113ea94:	e0fffe17 	ldw	r3,-8(fp)
8113ea98:	10c00d15 	stw	r3,52(r2)

    return ;
8113ea9c:	0001883a 	nop
}
8113eaa0:	e037883a 	mov	sp,fp
8113eaa4:	df000017 	ldw	fp,0(sp)
8113eaa8:	dec00104 	addi	sp,sp,4
8113eaac:	f800283a 	ret

8113eab0 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8113eab0:	defffc04 	addi	sp,sp,-16
8113eab4:	de00012e 	bgeu	sp,et,8113eabc <alt_msgdma_standard_descriptor_async_transfer+0xc>
8113eab8:	003b68fa 	trap	3
8113eabc:	dfc00315 	stw	ra,12(sp)
8113eac0:	df000215 	stw	fp,8(sp)
8113eac4:	df000204 	addi	fp,sp,8
8113eac8:	e13ffe15 	stw	r4,-8(fp)
8113eacc:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
8113ead0:	000d883a 	mov	r6,zero
8113ead4:	e17fff17 	ldw	r5,-4(fp)
8113ead8:	e13ffe17 	ldw	r4,-8(fp)
8113eadc:	113d0340 	call	8113d034 <alt_msgdma_descriptor_async_transfer>

}
8113eae0:	e037883a 	mov	sp,fp
8113eae4:	dfc00117 	ldw	ra,4(sp)
8113eae8:	df000017 	ldw	fp,0(sp)
8113eaec:	dec00204 	addi	sp,sp,8
8113eaf0:	f800283a 	ret

8113eaf4 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8113eaf4:	defffc04 	addi	sp,sp,-16
8113eaf8:	de00012e 	bgeu	sp,et,8113eb00 <alt_msgdma_extended_descriptor_async_transfer+0xc>
8113eafc:	003b68fa 	trap	3
8113eb00:	dfc00315 	stw	ra,12(sp)
8113eb04:	df000215 	stw	fp,8(sp)
8113eb08:	df000204 	addi	fp,sp,8
8113eb0c:	e13ffe15 	stw	r4,-8(fp)
8113eb10:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
8113eb14:	e1bfff17 	ldw	r6,-4(fp)
8113eb18:	000b883a 	mov	r5,zero
8113eb1c:	e13ffe17 	ldw	r4,-8(fp)
8113eb20:	113d0340 	call	8113d034 <alt_msgdma_descriptor_async_transfer>
}
8113eb24:	e037883a 	mov	sp,fp
8113eb28:	dfc00117 	ldw	ra,4(sp)
8113eb2c:	df000017 	ldw	fp,0(sp)
8113eb30:	dec00204 	addi	sp,sp,8
8113eb34:	f800283a 	ret

8113eb38 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8113eb38:	defffc04 	addi	sp,sp,-16
8113eb3c:	de00012e 	bgeu	sp,et,8113eb44 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
8113eb40:	003b68fa 	trap	3
8113eb44:	dfc00315 	stw	ra,12(sp)
8113eb48:	df000215 	stw	fp,8(sp)
8113eb4c:	df000204 	addi	fp,sp,8
8113eb50:	e13ffe15 	stw	r4,-8(fp)
8113eb54:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
8113eb58:	000d883a 	mov	r6,zero
8113eb5c:	e17fff17 	ldw	r5,-4(fp)
8113eb60:	e13ffe17 	ldw	r4,-8(fp)
8113eb64:	113d3740 	call	8113d374 <alt_msgdma_descriptor_sync_transfer>
}
8113eb68:	e037883a 	mov	sp,fp
8113eb6c:	dfc00117 	ldw	ra,4(sp)
8113eb70:	df000017 	ldw	fp,0(sp)
8113eb74:	dec00204 	addi	sp,sp,8
8113eb78:	f800283a 	ret

8113eb7c <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8113eb7c:	defffc04 	addi	sp,sp,-16
8113eb80:	de00012e 	bgeu	sp,et,8113eb88 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
8113eb84:	003b68fa 	trap	3
8113eb88:	dfc00315 	stw	ra,12(sp)
8113eb8c:	df000215 	stw	fp,8(sp)
8113eb90:	df000204 	addi	fp,sp,8
8113eb94:	e13ffe15 	stw	r4,-8(fp)
8113eb98:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
8113eb9c:	e1bfff17 	ldw	r6,-4(fp)
8113eba0:	000b883a 	mov	r5,zero
8113eba4:	e13ffe17 	ldw	r4,-8(fp)
8113eba8:	113d3740 	call	8113d374 <alt_msgdma_descriptor_sync_transfer>
}
8113ebac:	e037883a 	mov	sp,fp
8113ebb0:	dfc00117 	ldw	ra,4(sp)
8113ebb4:	df000017 	ldw	fp,0(sp)
8113ebb8:	dec00204 	addi	sp,sp,8
8113ebbc:	f800283a 	ret

8113ebc0 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
8113ebc0:	defff504 	addi	sp,sp,-44
8113ebc4:	de00012e 	bgeu	sp,et,8113ebcc <alt_alarm_start+0xc>
8113ebc8:	003b68fa 	trap	3
8113ebcc:	df000a15 	stw	fp,40(sp)
8113ebd0:	df000a04 	addi	fp,sp,40
8113ebd4:	e13ffc15 	stw	r4,-16(fp)
8113ebd8:	e17ffd15 	stw	r5,-12(fp)
8113ebdc:	e1bffe15 	stw	r6,-8(fp)
8113ebe0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
8113ebe4:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8113ebe8:	d0a07817 	ldw	r2,-32288(gp)
  
  if (alt_ticks_per_second ())
8113ebec:	10003c26 	beq	r2,zero,8113ece0 <alt_alarm_start+0x120>
  {
    if (alarm)
8113ebf0:	e0bffc17 	ldw	r2,-16(fp)
8113ebf4:	10003826 	beq	r2,zero,8113ecd8 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
8113ebf8:	e0bffc17 	ldw	r2,-16(fp)
8113ebfc:	e0fffe17 	ldw	r3,-8(fp)
8113ec00:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8113ec04:	e0bffc17 	ldw	r2,-16(fp)
8113ec08:	e0ffff17 	ldw	r3,-4(fp)
8113ec0c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ec10:	0005303a 	rdctl	r2,status
8113ec14:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ec18:	e0fff917 	ldw	r3,-28(fp)
8113ec1c:	00bfff84 	movi	r2,-2
8113ec20:	1884703a 	and	r2,r3,r2
8113ec24:	1001703a 	wrctl	status,r2
  
  return context;
8113ec28:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
8113ec2c:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8113ec30:	d0a07917 	ldw	r2,-32284(gp)
      
      current_nticks = alt_nticks();
8113ec34:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
8113ec38:	e0fffd17 	ldw	r3,-12(fp)
8113ec3c:	e0bff617 	ldw	r2,-40(fp)
8113ec40:	1885883a 	add	r2,r3,r2
8113ec44:	10c00044 	addi	r3,r2,1
8113ec48:	e0bffc17 	ldw	r2,-16(fp)
8113ec4c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
8113ec50:	e0bffc17 	ldw	r2,-16(fp)
8113ec54:	10c00217 	ldw	r3,8(r2)
8113ec58:	e0bff617 	ldw	r2,-40(fp)
8113ec5c:	1880042e 	bgeu	r3,r2,8113ec70 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
8113ec60:	e0bffc17 	ldw	r2,-16(fp)
8113ec64:	00c00044 	movi	r3,1
8113ec68:	10c00405 	stb	r3,16(r2)
8113ec6c:	00000206 	br	8113ec78 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
8113ec70:	e0bffc17 	ldw	r2,-16(fp)
8113ec74:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
8113ec78:	e0bffc17 	ldw	r2,-16(fp)
8113ec7c:	d0e01404 	addi	r3,gp,-32688
8113ec80:	e0fffa15 	stw	r3,-24(fp)
8113ec84:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8113ec88:	e0bffb17 	ldw	r2,-20(fp)
8113ec8c:	e0fffa17 	ldw	r3,-24(fp)
8113ec90:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8113ec94:	e0bffa17 	ldw	r2,-24(fp)
8113ec98:	10c00017 	ldw	r3,0(r2)
8113ec9c:	e0bffb17 	ldw	r2,-20(fp)
8113eca0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8113eca4:	e0bffa17 	ldw	r2,-24(fp)
8113eca8:	10800017 	ldw	r2,0(r2)
8113ecac:	e0fffb17 	ldw	r3,-20(fp)
8113ecb0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8113ecb4:	e0bffa17 	ldw	r2,-24(fp)
8113ecb8:	e0fffb17 	ldw	r3,-20(fp)
8113ecbc:	10c00015 	stw	r3,0(r2)
8113ecc0:	e0bff817 	ldw	r2,-32(fp)
8113ecc4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ecc8:	e0bff717 	ldw	r2,-36(fp)
8113eccc:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
8113ecd0:	0005883a 	mov	r2,zero
8113ecd4:	00000306 	br	8113ece4 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
8113ecd8:	00bffa84 	movi	r2,-22
8113ecdc:	00000106 	br	8113ece4 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
8113ece0:	00bfde84 	movi	r2,-134
  }
}
8113ece4:	e037883a 	mov	sp,fp
8113ece8:	df000017 	ldw	fp,0(sp)
8113ecec:	dec00104 	addi	sp,sp,4
8113ecf0:	f800283a 	ret

8113ecf4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113ecf4:	defffe04 	addi	sp,sp,-8
8113ecf8:	de00012e 	bgeu	sp,et,8113ed00 <alt_get_errno+0xc>
8113ecfc:	003b68fa 	trap	3
8113ed00:	dfc00115 	stw	ra,4(sp)
8113ed04:	df000015 	stw	fp,0(sp)
8113ed08:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113ed0c:	d0a01017 	ldw	r2,-32704(gp)
8113ed10:	10000326 	beq	r2,zero,8113ed20 <alt_get_errno+0x2c>
8113ed14:	d0a01017 	ldw	r2,-32704(gp)
8113ed18:	103ee83a 	callr	r2
8113ed1c:	00000106 	br	8113ed24 <alt_get_errno+0x30>
8113ed20:	d0a06804 	addi	r2,gp,-32352
}
8113ed24:	e037883a 	mov	sp,fp
8113ed28:	dfc00117 	ldw	ra,4(sp)
8113ed2c:	df000017 	ldw	fp,0(sp)
8113ed30:	dec00204 	addi	sp,sp,8
8113ed34:	f800283a 	ret

8113ed38 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
8113ed38:	defffa04 	addi	sp,sp,-24
8113ed3c:	de00012e 	bgeu	sp,et,8113ed44 <alt_dev_llist_insert+0xc>
8113ed40:	003b68fa 	trap	3
8113ed44:	dfc00515 	stw	ra,20(sp)
8113ed48:	df000415 	stw	fp,16(sp)
8113ed4c:	df000404 	addi	fp,sp,16
8113ed50:	e13ffe15 	stw	r4,-8(fp)
8113ed54:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
8113ed58:	e0bffe17 	ldw	r2,-8(fp)
8113ed5c:	10000326 	beq	r2,zero,8113ed6c <alt_dev_llist_insert+0x34>
8113ed60:	e0bffe17 	ldw	r2,-8(fp)
8113ed64:	10800217 	ldw	r2,8(r2)
8113ed68:	1000061e 	bne	r2,zero,8113ed84 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
8113ed6c:	113ecf40 	call	8113ecf4 <alt_get_errno>
8113ed70:	1007883a 	mov	r3,r2
8113ed74:	00800584 	movi	r2,22
8113ed78:	18800015 	stw	r2,0(r3)
    return -EINVAL;
8113ed7c:	00bffa84 	movi	r2,-22
8113ed80:	00001306 	br	8113edd0 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
8113ed84:	e0bffe17 	ldw	r2,-8(fp)
8113ed88:	e0ffff17 	ldw	r3,-4(fp)
8113ed8c:	e0fffc15 	stw	r3,-16(fp)
8113ed90:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8113ed94:	e0bffd17 	ldw	r2,-12(fp)
8113ed98:	e0fffc17 	ldw	r3,-16(fp)
8113ed9c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8113eda0:	e0bffc17 	ldw	r2,-16(fp)
8113eda4:	10c00017 	ldw	r3,0(r2)
8113eda8:	e0bffd17 	ldw	r2,-12(fp)
8113edac:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8113edb0:	e0bffc17 	ldw	r2,-16(fp)
8113edb4:	10800017 	ldw	r2,0(r2)
8113edb8:	e0fffd17 	ldw	r3,-12(fp)
8113edbc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8113edc0:	e0bffc17 	ldw	r2,-16(fp)
8113edc4:	e0fffd17 	ldw	r3,-12(fp)
8113edc8:	10c00015 	stw	r3,0(r2)

  return 0;  
8113edcc:	0005883a 	mov	r2,zero
}
8113edd0:	e037883a 	mov	sp,fp
8113edd4:	dfc00117 	ldw	ra,4(sp)
8113edd8:	df000017 	ldw	fp,0(sp)
8113eddc:	dec00204 	addi	sp,sp,8
8113ede0:	f800283a 	ret

8113ede4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8113ede4:	defffa04 	addi	sp,sp,-24
8113ede8:	de00012e 	bgeu	sp,et,8113edf0 <alt_find_dev+0xc>
8113edec:	003b68fa 	trap	3
8113edf0:	dfc00515 	stw	ra,20(sp)
8113edf4:	df000415 	stw	fp,16(sp)
8113edf8:	df000404 	addi	fp,sp,16
8113edfc:	e13ffe15 	stw	r4,-8(fp)
8113ee00:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8113ee04:	e0bfff17 	ldw	r2,-4(fp)
8113ee08:	10800017 	ldw	r2,0(r2)
8113ee0c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
8113ee10:	e13ffe17 	ldw	r4,-8(fp)
8113ee14:	11172280 	call	81117228 <strlen>
8113ee18:	10800044 	addi	r2,r2,1
8113ee1c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8113ee20:	00000d06 	br	8113ee58 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8113ee24:	e0bffc17 	ldw	r2,-16(fp)
8113ee28:	10800217 	ldw	r2,8(r2)
8113ee2c:	e0fffd17 	ldw	r3,-12(fp)
8113ee30:	180d883a 	mov	r6,r3
8113ee34:	e17ffe17 	ldw	r5,-8(fp)
8113ee38:	1009883a 	mov	r4,r2
8113ee3c:	113fbf80 	call	8113fbf8 <memcmp>
8113ee40:	1000021e 	bne	r2,zero,8113ee4c <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8113ee44:	e0bffc17 	ldw	r2,-16(fp)
8113ee48:	00000706 	br	8113ee68 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
8113ee4c:	e0bffc17 	ldw	r2,-16(fp)
8113ee50:	10800017 	ldw	r2,0(r2)
8113ee54:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8113ee58:	e0fffc17 	ldw	r3,-16(fp)
8113ee5c:	e0bfff17 	ldw	r2,-4(fp)
8113ee60:	18bff01e 	bne	r3,r2,8113ee24 <__reset+0xfb11ee24>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
8113ee64:	0005883a 	mov	r2,zero
}
8113ee68:	e037883a 	mov	sp,fp
8113ee6c:	dfc00117 	ldw	ra,4(sp)
8113ee70:	df000017 	ldw	fp,0(sp)
8113ee74:	dec00204 	addi	sp,sp,8
8113ee78:	f800283a 	ret

8113ee7c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
8113ee7c:	defffb04 	addi	sp,sp,-20
8113ee80:	de00012e 	bgeu	sp,et,8113ee88 <alt_find_file+0xc>
8113ee84:	003b68fa 	trap	3
8113ee88:	dfc00415 	stw	ra,16(sp)
8113ee8c:	df000315 	stw	fp,12(sp)
8113ee90:	df000304 	addi	fp,sp,12
8113ee94:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
8113ee98:	d0a00b17 	ldw	r2,-32724(gp)
8113ee9c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8113eea0:	00003106 	br	8113ef68 <alt_find_file+0xec>
  {
    len = strlen(next->name);
8113eea4:	e0bffd17 	ldw	r2,-12(fp)
8113eea8:	10800217 	ldw	r2,8(r2)
8113eeac:	1009883a 	mov	r4,r2
8113eeb0:	11172280 	call	81117228 <strlen>
8113eeb4:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
8113eeb8:	e0bffd17 	ldw	r2,-12(fp)
8113eebc:	10c00217 	ldw	r3,8(r2)
8113eec0:	e0bffe17 	ldw	r2,-8(fp)
8113eec4:	10bfffc4 	addi	r2,r2,-1
8113eec8:	1885883a 	add	r2,r3,r2
8113eecc:	10800003 	ldbu	r2,0(r2)
8113eed0:	10803fcc 	andi	r2,r2,255
8113eed4:	1080201c 	xori	r2,r2,128
8113eed8:	10bfe004 	addi	r2,r2,-128
8113eedc:	10800bd8 	cmpnei	r2,r2,47
8113eee0:	1000031e 	bne	r2,zero,8113eef0 <alt_find_file+0x74>
    {
      len -= 1;
8113eee4:	e0bffe17 	ldw	r2,-8(fp)
8113eee8:	10bfffc4 	addi	r2,r2,-1
8113eeec:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8113eef0:	e0bffe17 	ldw	r2,-8(fp)
8113eef4:	e0ffff17 	ldw	r3,-4(fp)
8113eef8:	1885883a 	add	r2,r3,r2
8113eefc:	10800003 	ldbu	r2,0(r2)
8113ef00:	10803fcc 	andi	r2,r2,255
8113ef04:	1080201c 	xori	r2,r2,128
8113ef08:	10bfe004 	addi	r2,r2,-128
8113ef0c:	10800be0 	cmpeqi	r2,r2,47
8113ef10:	1000081e 	bne	r2,zero,8113ef34 <alt_find_file+0xb8>
8113ef14:	e0bffe17 	ldw	r2,-8(fp)
8113ef18:	e0ffff17 	ldw	r3,-4(fp)
8113ef1c:	1885883a 	add	r2,r3,r2
8113ef20:	10800003 	ldbu	r2,0(r2)
8113ef24:	10803fcc 	andi	r2,r2,255
8113ef28:	1080201c 	xori	r2,r2,128
8113ef2c:	10bfe004 	addi	r2,r2,-128
8113ef30:	10000a1e 	bne	r2,zero,8113ef5c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8113ef34:	e0bffd17 	ldw	r2,-12(fp)
8113ef38:	10800217 	ldw	r2,8(r2)
8113ef3c:	e0fffe17 	ldw	r3,-8(fp)
8113ef40:	180d883a 	mov	r6,r3
8113ef44:	e17fff17 	ldw	r5,-4(fp)
8113ef48:	1009883a 	mov	r4,r2
8113ef4c:	113fbf80 	call	8113fbf8 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8113ef50:	1000021e 	bne	r2,zero,8113ef5c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8113ef54:	e0bffd17 	ldw	r2,-12(fp)
8113ef58:	00000706 	br	8113ef78 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
8113ef5c:	e0bffd17 	ldw	r2,-12(fp)
8113ef60:	10800017 	ldw	r2,0(r2)
8113ef64:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8113ef68:	e0fffd17 	ldw	r3,-12(fp)
8113ef6c:	d0a00b04 	addi	r2,gp,-32724
8113ef70:	18bfcc1e 	bne	r3,r2,8113eea4 <__reset+0xfb11eea4>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8113ef74:	0005883a 	mov	r2,zero
}
8113ef78:	e037883a 	mov	sp,fp
8113ef7c:	dfc00117 	ldw	ra,4(sp)
8113ef80:	df000017 	ldw	fp,0(sp)
8113ef84:	dec00204 	addi	sp,sp,8
8113ef88:	f800283a 	ret

8113ef8c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
8113ef8c:	defff904 	addi	sp,sp,-28
8113ef90:	de00012e 	bgeu	sp,et,8113ef98 <alt_get_fd+0xc>
8113ef94:	003b68fa 	trap	3
8113ef98:	dfc00615 	stw	ra,24(sp)
8113ef9c:	df000515 	stw	fp,20(sp)
8113efa0:	df000504 	addi	fp,sp,20
8113efa4:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
8113efa8:	00bffa04 	movi	r2,-24
8113efac:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
8113efb0:	d0a06f17 	ldw	r2,-32324(gp)
8113efb4:	e0bffd15 	stw	r2,-12(fp)
8113efb8:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8113efbc:	e0bffe0b 	ldhu	r2,-8(fp)
8113efc0:	e0fffe84 	addi	r3,fp,-6
8113efc4:	180d883a 	mov	r6,r3
8113efc8:	100b883a 	mov	r5,r2
8113efcc:	e13ffd17 	ldw	r4,-12(fp)
8113efd0:	11337600 	call	81133760 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8113efd4:	e03ffb15 	stw	zero,-20(fp)
8113efd8:	00001906 	br	8113f040 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
8113efdc:	00a04534 	movhi	r2,33044
8113efe0:	1095d504 	addi	r2,r2,22356
8113efe4:	e0fffb17 	ldw	r3,-20(fp)
8113efe8:	18c00324 	muli	r3,r3,12
8113efec:	10c5883a 	add	r2,r2,r3
8113eff0:	10800017 	ldw	r2,0(r2)
8113eff4:	10000f1e 	bne	r2,zero,8113f034 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
8113eff8:	00a04534 	movhi	r2,33044
8113effc:	1095d504 	addi	r2,r2,22356
8113f000:	e0fffb17 	ldw	r3,-20(fp)
8113f004:	18c00324 	muli	r3,r3,12
8113f008:	10c5883a 	add	r2,r2,r3
8113f00c:	e0ffff17 	ldw	r3,-4(fp)
8113f010:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8113f014:	d0e00f17 	ldw	r3,-32708(gp)
8113f018:	e0bffb17 	ldw	r2,-20(fp)
8113f01c:	1880020e 	bge	r3,r2,8113f028 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
8113f020:	e0bffb17 	ldw	r2,-20(fp)
8113f024:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
8113f028:	e0bffb17 	ldw	r2,-20(fp)
8113f02c:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
8113f030:	00000606 	br	8113f04c <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8113f034:	e0bffb17 	ldw	r2,-20(fp)
8113f038:	10800044 	addi	r2,r2,1
8113f03c:	e0bffb15 	stw	r2,-20(fp)
8113f040:	e0bffb17 	ldw	r2,-20(fp)
8113f044:	10800810 	cmplti	r2,r2,32
8113f048:	103fe41e 	bne	r2,zero,8113efdc <__reset+0xfb11efdc>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
8113f04c:	d0a06f17 	ldw	r2,-32324(gp)
8113f050:	1009883a 	mov	r4,r2
8113f054:	1133ae80 	call	81133ae8 <OSSemPost>

  return rc;
8113f058:	e0bffc17 	ldw	r2,-16(fp)
}
8113f05c:	e037883a 	mov	sp,fp
8113f060:	dfc00117 	ldw	ra,4(sp)
8113f064:	df000017 	ldw	fp,0(sp)
8113f068:	dec00204 	addi	sp,sp,8
8113f06c:	f800283a 	ret

8113f070 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8113f070:	defff904 	addi	sp,sp,-28
8113f074:	de00012e 	bgeu	sp,et,8113f07c <alt_ic_isr_register+0xc>
8113f078:	003b68fa 	trap	3
8113f07c:	dfc00615 	stw	ra,24(sp)
8113f080:	df000515 	stw	fp,20(sp)
8113f084:	df000504 	addi	fp,sp,20
8113f088:	e13ffc15 	stw	r4,-16(fp)
8113f08c:	e17ffd15 	stw	r5,-12(fp)
8113f090:	e1bffe15 	stw	r6,-8(fp)
8113f094:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
8113f098:	e0800217 	ldw	r2,8(fp)
8113f09c:	d8800015 	stw	r2,0(sp)
8113f0a0:	e1ffff17 	ldw	r7,-4(fp)
8113f0a4:	e1bffe17 	ldw	r6,-8(fp)
8113f0a8:	e17ffd17 	ldw	r5,-12(fp)
8113f0ac:	e13ffc17 	ldw	r4,-16(fp)
8113f0b0:	113f2400 	call	8113f240 <alt_iic_isr_register>
}  
8113f0b4:	e037883a 	mov	sp,fp
8113f0b8:	dfc00117 	ldw	ra,4(sp)
8113f0bc:	df000017 	ldw	fp,0(sp)
8113f0c0:	dec00204 	addi	sp,sp,8
8113f0c4:	f800283a 	ret

8113f0c8 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
8113f0c8:	defff904 	addi	sp,sp,-28
8113f0cc:	de00012e 	bgeu	sp,et,8113f0d4 <alt_ic_irq_enable+0xc>
8113f0d0:	003b68fa 	trap	3
8113f0d4:	df000615 	stw	fp,24(sp)
8113f0d8:	df000604 	addi	fp,sp,24
8113f0dc:	e13ffe15 	stw	r4,-8(fp)
8113f0e0:	e17fff15 	stw	r5,-4(fp)
8113f0e4:	e0bfff17 	ldw	r2,-4(fp)
8113f0e8:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f0ec:	0005303a 	rdctl	r2,status
8113f0f0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f0f4:	e0fffb17 	ldw	r3,-20(fp)
8113f0f8:	00bfff84 	movi	r2,-2
8113f0fc:	1884703a 	and	r2,r3,r2
8113f100:	1001703a 	wrctl	status,r2
  
  return context;
8113f104:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8113f108:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
8113f10c:	00c00044 	movi	r3,1
8113f110:	e0bffa17 	ldw	r2,-24(fp)
8113f114:	1884983a 	sll	r2,r3,r2
8113f118:	1007883a 	mov	r3,r2
8113f11c:	d0a07017 	ldw	r2,-32320(gp)
8113f120:	1884b03a 	or	r2,r3,r2
8113f124:	d0a07015 	stw	r2,-32320(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8113f128:	d0a07017 	ldw	r2,-32320(gp)
8113f12c:	100170fa 	wrctl	ienable,r2
8113f130:	e0bffc17 	ldw	r2,-16(fp)
8113f134:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f138:	e0bffd17 	ldw	r2,-12(fp)
8113f13c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113f140:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8113f144:	0001883a 	nop
}
8113f148:	e037883a 	mov	sp,fp
8113f14c:	df000017 	ldw	fp,0(sp)
8113f150:	dec00104 	addi	sp,sp,4
8113f154:	f800283a 	ret

8113f158 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
8113f158:	defff904 	addi	sp,sp,-28
8113f15c:	de00012e 	bgeu	sp,et,8113f164 <alt_ic_irq_disable+0xc>
8113f160:	003b68fa 	trap	3
8113f164:	df000615 	stw	fp,24(sp)
8113f168:	df000604 	addi	fp,sp,24
8113f16c:	e13ffe15 	stw	r4,-8(fp)
8113f170:	e17fff15 	stw	r5,-4(fp)
8113f174:	e0bfff17 	ldw	r2,-4(fp)
8113f178:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f17c:	0005303a 	rdctl	r2,status
8113f180:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f184:	e0fffb17 	ldw	r3,-20(fp)
8113f188:	00bfff84 	movi	r2,-2
8113f18c:	1884703a 	and	r2,r3,r2
8113f190:	1001703a 	wrctl	status,r2
  
  return context;
8113f194:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8113f198:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
8113f19c:	00c00044 	movi	r3,1
8113f1a0:	e0bffa17 	ldw	r2,-24(fp)
8113f1a4:	1884983a 	sll	r2,r3,r2
8113f1a8:	0084303a 	nor	r2,zero,r2
8113f1ac:	1007883a 	mov	r3,r2
8113f1b0:	d0a07017 	ldw	r2,-32320(gp)
8113f1b4:	1884703a 	and	r2,r3,r2
8113f1b8:	d0a07015 	stw	r2,-32320(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8113f1bc:	d0a07017 	ldw	r2,-32320(gp)
8113f1c0:	100170fa 	wrctl	ienable,r2
8113f1c4:	e0bffc17 	ldw	r2,-16(fp)
8113f1c8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f1cc:	e0bffd17 	ldw	r2,-12(fp)
8113f1d0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113f1d4:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
8113f1d8:	0001883a 	nop
}
8113f1dc:	e037883a 	mov	sp,fp
8113f1e0:	df000017 	ldw	fp,0(sp)
8113f1e4:	dec00104 	addi	sp,sp,4
8113f1e8:	f800283a 	ret

8113f1ec <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
8113f1ec:	defffc04 	addi	sp,sp,-16
8113f1f0:	de00012e 	bgeu	sp,et,8113f1f8 <alt_ic_irq_enabled+0xc>
8113f1f4:	003b68fa 	trap	3
8113f1f8:	df000315 	stw	fp,12(sp)
8113f1fc:	df000304 	addi	fp,sp,12
8113f200:	e13ffe15 	stw	r4,-8(fp)
8113f204:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
8113f208:	000530fa 	rdctl	r2,ienable
8113f20c:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8113f210:	00c00044 	movi	r3,1
8113f214:	e0bfff17 	ldw	r2,-4(fp)
8113f218:	1884983a 	sll	r2,r3,r2
8113f21c:	1007883a 	mov	r3,r2
8113f220:	e0bffd17 	ldw	r2,-12(fp)
8113f224:	1884703a 	and	r2,r3,r2
8113f228:	1004c03a 	cmpne	r2,r2,zero
8113f22c:	10803fcc 	andi	r2,r2,255
}
8113f230:	e037883a 	mov	sp,fp
8113f234:	df000017 	ldw	fp,0(sp)
8113f238:	dec00104 	addi	sp,sp,4
8113f23c:	f800283a 	ret

8113f240 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8113f240:	defff504 	addi	sp,sp,-44
8113f244:	de00012e 	bgeu	sp,et,8113f24c <alt_iic_isr_register+0xc>
8113f248:	003b68fa 	trap	3
8113f24c:	dfc00a15 	stw	ra,40(sp)
8113f250:	df000915 	stw	fp,36(sp)
8113f254:	df000904 	addi	fp,sp,36
8113f258:	e13ffc15 	stw	r4,-16(fp)
8113f25c:	e17ffd15 	stw	r5,-12(fp)
8113f260:	e1bffe15 	stw	r6,-8(fp)
8113f264:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
8113f268:	00bffa84 	movi	r2,-22
8113f26c:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
8113f270:	e0bffd17 	ldw	r2,-12(fp)
8113f274:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8113f278:	e0bff817 	ldw	r2,-32(fp)
8113f27c:	10800808 	cmpgei	r2,r2,32
8113f280:	1000271e 	bne	r2,zero,8113f320 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f284:	0005303a 	rdctl	r2,status
8113f288:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f28c:	e0fffb17 	ldw	r3,-20(fp)
8113f290:	00bfff84 	movi	r2,-2
8113f294:	1884703a 	and	r2,r3,r2
8113f298:	1001703a 	wrctl	status,r2
  
  return context;
8113f29c:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8113f2a0:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8113f2a4:	00a045b4 	movhi	r2,33046
8113f2a8:	10813504 	addi	r2,r2,1236
8113f2ac:	e0fff817 	ldw	r3,-32(fp)
8113f2b0:	180690fa 	slli	r3,r3,3
8113f2b4:	10c5883a 	add	r2,r2,r3
8113f2b8:	e0fffe17 	ldw	r3,-8(fp)
8113f2bc:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8113f2c0:	00a045b4 	movhi	r2,33046
8113f2c4:	10813504 	addi	r2,r2,1236
8113f2c8:	e0fff817 	ldw	r3,-32(fp)
8113f2cc:	180690fa 	slli	r3,r3,3
8113f2d0:	10c5883a 	add	r2,r2,r3
8113f2d4:	10800104 	addi	r2,r2,4
8113f2d8:	e0ffff17 	ldw	r3,-4(fp)
8113f2dc:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
8113f2e0:	e0bffe17 	ldw	r2,-8(fp)
8113f2e4:	10000526 	beq	r2,zero,8113f2fc <alt_iic_isr_register+0xbc>
8113f2e8:	e0bff817 	ldw	r2,-32(fp)
8113f2ec:	100b883a 	mov	r5,r2
8113f2f0:	e13ffc17 	ldw	r4,-16(fp)
8113f2f4:	113f0c80 	call	8113f0c8 <alt_ic_irq_enable>
8113f2f8:	00000406 	br	8113f30c <alt_iic_isr_register+0xcc>
8113f2fc:	e0bff817 	ldw	r2,-32(fp)
8113f300:	100b883a 	mov	r5,r2
8113f304:	e13ffc17 	ldw	r4,-16(fp)
8113f308:	113f1580 	call	8113f158 <alt_ic_irq_disable>
8113f30c:	e0bff715 	stw	r2,-36(fp)
8113f310:	e0bffa17 	ldw	r2,-24(fp)
8113f314:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f318:	e0bff917 	ldw	r2,-28(fp)
8113f31c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8113f320:	e0bff717 	ldw	r2,-36(fp)
}
8113f324:	e037883a 	mov	sp,fp
8113f328:	dfc00117 	ldw	ra,4(sp)
8113f32c:	df000017 	ldw	fp,0(sp)
8113f330:	dec00204 	addi	sp,sp,8
8113f334:	f800283a 	ret

8113f338 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
8113f338:	defff904 	addi	sp,sp,-28
8113f33c:	de00012e 	bgeu	sp,et,8113f344 <alt_open_fd+0xc>
8113f340:	003b68fa 	trap	3
8113f344:	dfc00615 	stw	ra,24(sp)
8113f348:	df000515 	stw	fp,20(sp)
8113f34c:	df000504 	addi	fp,sp,20
8113f350:	e13ffc15 	stw	r4,-16(fp)
8113f354:	e17ffd15 	stw	r5,-12(fp)
8113f358:	e1bffe15 	stw	r6,-8(fp)
8113f35c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8113f360:	e1bfff17 	ldw	r6,-4(fp)
8113f364:	e17ffe17 	ldw	r5,-8(fp)
8113f368:	e13ffd17 	ldw	r4,-12(fp)
8113f36c:	112c39c0 	call	8112c39c <open>
8113f370:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8113f374:	e0bffb17 	ldw	r2,-20(fp)
8113f378:	10001c16 	blt	r2,zero,8113f3ec <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
8113f37c:	00a04534 	movhi	r2,33044
8113f380:	1095d504 	addi	r2,r2,22356
8113f384:	e0fffb17 	ldw	r3,-20(fp)
8113f388:	18c00324 	muli	r3,r3,12
8113f38c:	10c5883a 	add	r2,r2,r3
8113f390:	10c00017 	ldw	r3,0(r2)
8113f394:	e0bffc17 	ldw	r2,-16(fp)
8113f398:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
8113f39c:	00a04534 	movhi	r2,33044
8113f3a0:	1095d504 	addi	r2,r2,22356
8113f3a4:	e0fffb17 	ldw	r3,-20(fp)
8113f3a8:	18c00324 	muli	r3,r3,12
8113f3ac:	10c5883a 	add	r2,r2,r3
8113f3b0:	10800104 	addi	r2,r2,4
8113f3b4:	10c00017 	ldw	r3,0(r2)
8113f3b8:	e0bffc17 	ldw	r2,-16(fp)
8113f3bc:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8113f3c0:	00a04534 	movhi	r2,33044
8113f3c4:	1095d504 	addi	r2,r2,22356
8113f3c8:	e0fffb17 	ldw	r3,-20(fp)
8113f3cc:	18c00324 	muli	r3,r3,12
8113f3d0:	10c5883a 	add	r2,r2,r3
8113f3d4:	10800204 	addi	r2,r2,8
8113f3d8:	10c00017 	ldw	r3,0(r2)
8113f3dc:	e0bffc17 	ldw	r2,-16(fp)
8113f3e0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8113f3e4:	e13ffb17 	ldw	r4,-20(fp)
8113f3e8:	112c6400 	call	8112c640 <alt_release_fd>
  }
} 
8113f3ec:	0001883a 	nop
8113f3f0:	e037883a 	mov	sp,fp
8113f3f4:	dfc00117 	ldw	ra,4(sp)
8113f3f8:	df000017 	ldw	fp,0(sp)
8113f3fc:	dec00204 	addi	sp,sp,8
8113f400:	f800283a 	ret

8113f404 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8113f404:	defffb04 	addi	sp,sp,-20
8113f408:	de00012e 	bgeu	sp,et,8113f410 <alt_io_redirect+0xc>
8113f40c:	003b68fa 	trap	3
8113f410:	dfc00415 	stw	ra,16(sp)
8113f414:	df000315 	stw	fp,12(sp)
8113f418:	df000304 	addi	fp,sp,12
8113f41c:	e13ffd15 	stw	r4,-12(fp)
8113f420:	e17ffe15 	stw	r5,-8(fp)
8113f424:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
8113f428:	01c07fc4 	movi	r7,511
8113f42c:	01800044 	movi	r6,1
8113f430:	e17ffd17 	ldw	r5,-12(fp)
8113f434:	01204534 	movhi	r4,33044
8113f438:	2115d804 	addi	r4,r4,22368
8113f43c:	113f3380 	call	8113f338 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8113f440:	01c07fc4 	movi	r7,511
8113f444:	000d883a 	mov	r6,zero
8113f448:	e17ffe17 	ldw	r5,-8(fp)
8113f44c:	01204534 	movhi	r4,33044
8113f450:	2115d504 	addi	r4,r4,22356
8113f454:	113f3380 	call	8113f338 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
8113f458:	01c07fc4 	movi	r7,511
8113f45c:	01800044 	movi	r6,1
8113f460:	e17fff17 	ldw	r5,-4(fp)
8113f464:	01204534 	movhi	r4,33044
8113f468:	2115db04 	addi	r4,r4,22380
8113f46c:	113f3380 	call	8113f338 <alt_open_fd>
}  
8113f470:	0001883a 	nop
8113f474:	e037883a 	mov	sp,fp
8113f478:	dfc00117 	ldw	ra,4(sp)
8113f47c:	df000017 	ldw	fp,0(sp)
8113f480:	dec00204 	addi	sp,sp,8
8113f484:	f800283a 	ret

8113f488 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
8113f488:	defff204 	addi	sp,sp,-56
8113f48c:	de00012e 	bgeu	sp,et,8113f494 <alt_printf+0xc>
8113f490:	003b68fa 	trap	3
8113f494:	dfc00a15 	stw	ra,40(sp)
8113f498:	df000915 	stw	fp,36(sp)
8113f49c:	df000904 	addi	fp,sp,36
8113f4a0:	e13fff15 	stw	r4,-4(fp)
8113f4a4:	e1400215 	stw	r5,8(fp)
8113f4a8:	e1800315 	stw	r6,12(fp)
8113f4ac:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
8113f4b0:	e0800204 	addi	r2,fp,8
8113f4b4:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
8113f4b8:	e0bfff17 	ldw	r2,-4(fp)
8113f4bc:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8113f4c0:	00006f06 	br	8113f680 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
8113f4c4:	e0bff807 	ldb	r2,-32(fp)
8113f4c8:	10800960 	cmpeqi	r2,r2,37
8113f4cc:	1000041e 	bne	r2,zero,8113f4e0 <alt_printf+0x58>
        {
            alt_putchar(c);
8113f4d0:	e0bff807 	ldb	r2,-32(fp)
8113f4d4:	1009883a 	mov	r4,r2
8113f4d8:	113f6bc0 	call	8113f6bc <alt_putchar>
8113f4dc:	00006806 	br	8113f680 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
8113f4e0:	e0bff717 	ldw	r2,-36(fp)
8113f4e4:	10c00044 	addi	r3,r2,1
8113f4e8:	e0fff715 	stw	r3,-36(fp)
8113f4ec:	10800003 	ldbu	r2,0(r2)
8113f4f0:	e0bff805 	stb	r2,-32(fp)
8113f4f4:	e0bff807 	ldb	r2,-32(fp)
8113f4f8:	10006926 	beq	r2,zero,8113f6a0 <alt_printf+0x218>
            {
                if (c == '%')
8113f4fc:	e0bff807 	ldb	r2,-32(fp)
8113f500:	10800958 	cmpnei	r2,r2,37
8113f504:	1000041e 	bne	r2,zero,8113f518 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8113f508:	e0bff807 	ldb	r2,-32(fp)
8113f50c:	1009883a 	mov	r4,r2
8113f510:	113f6bc0 	call	8113f6bc <alt_putchar>
8113f514:	00005a06 	br	8113f680 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8113f518:	e0bff807 	ldb	r2,-32(fp)
8113f51c:	108018d8 	cmpnei	r2,r2,99
8113f520:	1000081e 	bne	r2,zero,8113f544 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
8113f524:	e0bffe17 	ldw	r2,-8(fp)
8113f528:	10c00104 	addi	r3,r2,4
8113f52c:	e0fffe15 	stw	r3,-8(fp)
8113f530:	10800017 	ldw	r2,0(r2)
8113f534:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8113f538:	e13ffd17 	ldw	r4,-12(fp)
8113f53c:	113f6bc0 	call	8113f6bc <alt_putchar>
8113f540:	00004f06 	br	8113f680 <alt_printf+0x1f8>
                }
                else if (c == 'x')
8113f544:	e0bff807 	ldb	r2,-32(fp)
8113f548:	10801e18 	cmpnei	r2,r2,120
8113f54c:	1000341e 	bne	r2,zero,8113f620 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8113f550:	e0bffe17 	ldw	r2,-8(fp)
8113f554:	10c00104 	addi	r3,r2,4
8113f558:	e0fffe15 	stw	r3,-8(fp)
8113f55c:	10800017 	ldw	r2,0(r2)
8113f560:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
8113f564:	e0bffb17 	ldw	r2,-20(fp)
8113f568:	1000031e 	bne	r2,zero,8113f578 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
8113f56c:	01000c04 	movi	r4,48
8113f570:	113f6bc0 	call	8113f6bc <alt_putchar>
                        continue;
8113f574:	00004206 	br	8113f680 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
8113f578:	00800704 	movi	r2,28
8113f57c:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8113f580:	00000306 	br	8113f590 <alt_printf+0x108>
                        digit_shift -= 4;
8113f584:	e0bff917 	ldw	r2,-28(fp)
8113f588:	10bfff04 	addi	r2,r2,-4
8113f58c:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8113f590:	00c003c4 	movi	r3,15
8113f594:	e0bff917 	ldw	r2,-28(fp)
8113f598:	1884983a 	sll	r2,r3,r2
8113f59c:	1007883a 	mov	r3,r2
8113f5a0:	e0bffb17 	ldw	r2,-20(fp)
8113f5a4:	1884703a 	and	r2,r3,r2
8113f5a8:	103ff626 	beq	r2,zero,8113f584 <__reset+0xfb11f584>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8113f5ac:	00001906 	br	8113f614 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
8113f5b0:	00c003c4 	movi	r3,15
8113f5b4:	e0bff917 	ldw	r2,-28(fp)
8113f5b8:	1884983a 	sll	r2,r3,r2
8113f5bc:	1007883a 	mov	r3,r2
8113f5c0:	e0bffb17 	ldw	r2,-20(fp)
8113f5c4:	1886703a 	and	r3,r3,r2
8113f5c8:	e0bff917 	ldw	r2,-28(fp)
8113f5cc:	1884d83a 	srl	r2,r3,r2
8113f5d0:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
8113f5d4:	e0bffc17 	ldw	r2,-16(fp)
8113f5d8:	108002a8 	cmpgeui	r2,r2,10
8113f5dc:	1000041e 	bne	r2,zero,8113f5f0 <alt_printf+0x168>
                            c = '0' + digit;
8113f5e0:	e0bffc17 	ldw	r2,-16(fp)
8113f5e4:	10800c04 	addi	r2,r2,48
8113f5e8:	e0bff805 	stb	r2,-32(fp)
8113f5ec:	00000306 	br	8113f5fc <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
8113f5f0:	e0bffc17 	ldw	r2,-16(fp)
8113f5f4:	108015c4 	addi	r2,r2,87
8113f5f8:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
8113f5fc:	e0bff807 	ldb	r2,-32(fp)
8113f600:	1009883a 	mov	r4,r2
8113f604:	113f6bc0 	call	8113f6bc <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8113f608:	e0bff917 	ldw	r2,-28(fp)
8113f60c:	10bfff04 	addi	r2,r2,-4
8113f610:	e0bff915 	stw	r2,-28(fp)
8113f614:	e0bff917 	ldw	r2,-28(fp)
8113f618:	103fe50e 	bge	r2,zero,8113f5b0 <__reset+0xfb11f5b0>
8113f61c:	00001806 	br	8113f680 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8113f620:	e0bff807 	ldb	r2,-32(fp)
8113f624:	10801cd8 	cmpnei	r2,r2,115
8113f628:	1000151e 	bne	r2,zero,8113f680 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
8113f62c:	e0bffe17 	ldw	r2,-8(fp)
8113f630:	10c00104 	addi	r3,r2,4
8113f634:	e0fffe15 	stw	r3,-8(fp)
8113f638:	10800017 	ldw	r2,0(r2)
8113f63c:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8113f640:	00000906 	br	8113f668 <alt_printf+0x1e0>
                      alt_putchar(*s++);
8113f644:	e0bffa17 	ldw	r2,-24(fp)
8113f648:	10c00044 	addi	r3,r2,1
8113f64c:	e0fffa15 	stw	r3,-24(fp)
8113f650:	10800003 	ldbu	r2,0(r2)
8113f654:	10803fcc 	andi	r2,r2,255
8113f658:	1080201c 	xori	r2,r2,128
8113f65c:	10bfe004 	addi	r2,r2,-128
8113f660:	1009883a 	mov	r4,r2
8113f664:	113f6bc0 	call	8113f6bc <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
8113f668:	e0bffa17 	ldw	r2,-24(fp)
8113f66c:	10800003 	ldbu	r2,0(r2)
8113f670:	10803fcc 	andi	r2,r2,255
8113f674:	1080201c 	xori	r2,r2,128
8113f678:	10bfe004 	addi	r2,r2,-128
8113f67c:	103ff11e 	bne	r2,zero,8113f644 <__reset+0xfb11f644>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8113f680:	e0bff717 	ldw	r2,-36(fp)
8113f684:	10c00044 	addi	r3,r2,1
8113f688:	e0fff715 	stw	r3,-36(fp)
8113f68c:	10800003 	ldbu	r2,0(r2)
8113f690:	e0bff805 	stb	r2,-32(fp)
8113f694:	e0bff807 	ldb	r2,-32(fp)
8113f698:	103f8a1e 	bne	r2,zero,8113f4c4 <__reset+0xfb11f4c4>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8113f69c:	00000106 	br	8113f6a4 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
8113f6a0:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8113f6a4:	0001883a 	nop
8113f6a8:	e037883a 	mov	sp,fp
8113f6ac:	dfc00117 	ldw	ra,4(sp)
8113f6b0:	df000017 	ldw	fp,0(sp)
8113f6b4:	dec00504 	addi	sp,sp,20
8113f6b8:	f800283a 	ret

8113f6bc <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
8113f6bc:	defffd04 	addi	sp,sp,-12
8113f6c0:	de00012e 	bgeu	sp,et,8113f6c8 <alt_putchar+0xc>
8113f6c4:	003b68fa 	trap	3
8113f6c8:	dfc00215 	stw	ra,8(sp)
8113f6cc:	df000115 	stw	fp,4(sp)
8113f6d0:	df000104 	addi	fp,sp,4
8113f6d4:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8113f6d8:	d0a00517 	ldw	r2,-32748(gp)
8113f6dc:	10800217 	ldw	r2,8(r2)
8113f6e0:	100b883a 	mov	r5,r2
8113f6e4:	e13fff17 	ldw	r4,-4(fp)
8113f6e8:	1116b380 	call	81116b38 <putc>
#endif
#endif
}
8113f6ec:	e037883a 	mov	sp,fp
8113f6f0:	dfc00117 	ldw	ra,4(sp)
8113f6f4:	df000017 	ldw	fp,0(sp)
8113f6f8:	dec00204 	addi	sp,sp,8
8113f6fc:	f800283a 	ret

8113f700 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8113f700:	deffff04 	addi	sp,sp,-4
8113f704:	de00012e 	bgeu	sp,et,8113f70c <altera_nios2_gen2_irq_init+0xc>
8113f708:	003b68fa 	trap	3
8113f70c:	df000015 	stw	fp,0(sp)
8113f710:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
8113f714:	000170fa 	wrctl	ienable,zero
}
8113f718:	0001883a 	nop
8113f71c:	e037883a 	mov	sp,fp
8113f720:	df000017 	ldw	fp,0(sp)
8113f724:	dec00104 	addi	sp,sp,4
8113f728:	f800283a 	ret

8113f72c <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
8113f72c:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8113f730:	de002436 	bltu	sp,et,8113f7c4 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
8113f734:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8113f738:	d1209217 	ldw	r4,-32184(gp)

      stw ra,  0(sp)
8113f73c:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8113f740:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
8113f744:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8113f748:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
8113f74c:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8113f750:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
8113f754:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8113f758:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
8113f75c:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
8113f760:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
8113f764:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
8113f768:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8113f76c:	113f9c80 	call	8113f9c8 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
8113f770:	d1208c17 	ldw	r4,-32208(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
8113f774:	d1608387 	ldb	r5,-32242(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
8113f778:	d1209215 	stw	r4,-32184(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
8113f77c:	d16083c5 	stb	r5,-32241(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
8113f780:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
8113f784:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
8113f788:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
8113f78c:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
8113f790:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
8113f794:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
8113f798:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
8113f79c:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
8113f7a0:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
8113f7a4:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
8113f7a8:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
8113f7ac:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
8113f7b0:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
8113f7b4:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
8113f7b8:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
8113f7bc:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
8113f7c0:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
8113f7c4:	003da0fa 	break	3

8113f7c8 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8113f7c8:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
8113f7cc:	047fff84 	movi	r17,-2
      and   r18, r18, r17
8113f7d0:	9464703a 	and	r18,r18,r17
      wrctl status, r18
8113f7d4:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8113f7d8:	113f9c80 	call	8113f9c8 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
8113f7dc:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
8113f7e0:	d4a08105 	stb	r18,-32252(gp)

      /*
       * start execution of the new task.
       */

      br 9b
8113f7e4:	003fe206 	br	8113f770 <__reset+0xfb11f770>

8113f7e8 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8113f7e8:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
8113f7ec:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
8113f7f0:	10800054 	ori	r2,r2,1
      wrctl status, r2
8113f7f4:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8113f7f8:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
8113f7fc:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8113f800:	dec00204 	addi	sp,sp,8

      callr r2
8113f804:	103ee83a 	callr	r2

      nop
8113f808:	0001883a 	nop

8113f80c <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
8113f80c:	defff704 	addi	sp,sp,-36
8113f810:	de00012e 	bgeu	sp,et,8113f818 <OSTaskStkInit+0xc>
8113f814:	003b68fa 	trap	3
8113f818:	dfc00815 	stw	ra,32(sp)
8113f81c:	df000715 	stw	fp,28(sp)
8113f820:	df000704 	addi	fp,sp,28
8113f824:	e13ffc15 	stw	r4,-16(fp)
8113f828:	e17ffd15 	stw	r5,-12(fp)
8113f82c:	e1bffe15 	stw	r6,-8(fp)
8113f830:	3805883a 	mov	r2,r7
8113f834:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8113f838:	e0fffe17 	ldw	r3,-8(fp)
8113f83c:	00bfff04 	movi	r2,-4
8113f840:	1884703a 	and	r2,r3,r2
8113f844:	10bef704 	addi	r2,r2,-1060
8113f848:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
8113f84c:	01810904 	movi	r6,1060
8113f850:	000b883a 	mov	r5,zero
8113f854:	e13ff917 	ldw	r4,-28(fp)
8113f858:	11168840 	call	81116884 <memset>
8113f85c:	e0bff917 	ldw	r2,-28(fp)
8113f860:	10c0bb04 	addi	r3,r2,748
8113f864:	e0bff917 	ldw	r2,-28(fp)
8113f868:	10c00115 	stw	r3,4(r2)
8113f86c:	e0bff917 	ldw	r2,-28(fp)
8113f870:	10c0d504 	addi	r3,r2,852
8113f874:	e0bff917 	ldw	r2,-28(fp)
8113f878:	10c00215 	stw	r3,8(r2)
8113f87c:	e0bff917 	ldw	r2,-28(fp)
8113f880:	10c0ef04 	addi	r3,r2,956
8113f884:	e0bff917 	ldw	r2,-28(fp)
8113f888:	10c00315 	stw	r3,12(r2)
8113f88c:	e0fff917 	ldw	r3,-28(fp)
8113f890:	00a04534 	movhi	r2,33044
8113f894:	10936e04 	addi	r2,r2,19896
8113f898:	18800d15 	stw	r2,52(r3)
8113f89c:	e0bff917 	ldw	r2,-28(fp)
8113f8a0:	00c00044 	movi	r3,1
8113f8a4:	10c02915 	stw	r3,164(r2)
8113f8a8:	10002a15 	stw	zero,168(r2)
8113f8ac:	e0bff917 	ldw	r2,-28(fp)
8113f8b0:	00ccc384 	movi	r3,13070
8113f8b4:	10c02b0d 	sth	r3,172(r2)
8113f8b8:	e0bff917 	ldw	r2,-28(fp)
8113f8bc:	00eaf344 	movi	r3,-21555
8113f8c0:	10c02b8d 	sth	r3,174(r2)
8113f8c4:	e0bff917 	ldw	r2,-28(fp)
8113f8c8:	00c48d04 	movi	r3,4660
8113f8cc:	10c02c0d 	sth	r3,176(r2)
8113f8d0:	e0bff917 	ldw	r2,-28(fp)
8113f8d4:	00f99b44 	movi	r3,-6547
8113f8d8:	10c02c8d 	sth	r3,178(r2)
8113f8dc:	e0bff917 	ldw	r2,-28(fp)
8113f8e0:	00f7bb04 	movi	r3,-8468
8113f8e4:	10c02d0d 	sth	r3,180(r2)
8113f8e8:	e0bff917 	ldw	r2,-28(fp)
8113f8ec:	00c00144 	movi	r3,5
8113f8f0:	10c02d8d 	sth	r3,182(r2)
8113f8f4:	e0bff917 	ldw	r2,-28(fp)
8113f8f8:	00c002c4 	movi	r3,11
8113f8fc:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8113f900:	e0bff917 	ldw	r2,-28(fp)
8113f904:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8113f908:	e0bffa17 	ldw	r2,-24(fp)
8113f90c:	10bff304 	addi	r2,r2,-52
8113f910:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
8113f914:	e0bffb17 	ldw	r2,-20(fp)
8113f918:	10800c04 	addi	r2,r2,48
8113f91c:	e0fffc17 	ldw	r3,-16(fp)
8113f920:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
8113f924:	e0bffb17 	ldw	r2,-20(fp)
8113f928:	10800b04 	addi	r2,r2,44
8113f92c:	e0fffd17 	ldw	r3,-12(fp)
8113f930:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
8113f934:	e0bffb17 	ldw	r2,-20(fp)
8113f938:	10800a04 	addi	r2,r2,40
8113f93c:	e0fff917 	ldw	r3,-28(fp)
8113f940:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8113f944:	00a04534 	movhi	r2,33044
8113f948:	10bdfa04 	addi	r2,r2,-2072
8113f94c:	10c00104 	addi	r3,r2,4
8113f950:	e0bffb17 	ldw	r2,-20(fp)
8113f954:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8113f958:	e0bffb17 	ldw	r2,-20(fp)
}
8113f95c:	e037883a 	mov	sp,fp
8113f960:	dfc00117 	ldw	ra,4(sp)
8113f964:	df000017 	ldw	fp,0(sp)
8113f968:	dec00204 	addi	sp,sp,8
8113f96c:	f800283a 	ret

8113f970 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8113f970:	defffe04 	addi	sp,sp,-8
8113f974:	de00012e 	bgeu	sp,et,8113f97c <OSTaskCreateHook+0xc>
8113f978:	003b68fa 	trap	3
8113f97c:	df000115 	stw	fp,4(sp)
8113f980:	df000104 	addi	fp,sp,4
8113f984:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
8113f988:	0001883a 	nop
8113f98c:	e037883a 	mov	sp,fp
8113f990:	df000017 	ldw	fp,0(sp)
8113f994:	dec00104 	addi	sp,sp,4
8113f998:	f800283a 	ret

8113f99c <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
8113f99c:	defffe04 	addi	sp,sp,-8
8113f9a0:	de00012e 	bgeu	sp,et,8113f9a8 <OSTaskDelHook+0xc>
8113f9a4:	003b68fa 	trap	3
8113f9a8:	df000115 	stw	fp,4(sp)
8113f9ac:	df000104 	addi	fp,sp,4
8113f9b0:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8113f9b4:	0001883a 	nop
8113f9b8:	e037883a 	mov	sp,fp
8113f9bc:	df000017 	ldw	fp,0(sp)
8113f9c0:	dec00104 	addi	sp,sp,4
8113f9c4:	f800283a 	ret

8113f9c8 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
8113f9c8:	deffff04 	addi	sp,sp,-4
8113f9cc:	de00012e 	bgeu	sp,et,8113f9d4 <OSTaskSwHook+0xc>
8113f9d0:	003b68fa 	trap	3
8113f9d4:	df000015 	stw	fp,0(sp)
8113f9d8:	d839883a 	mov	fp,sp
}
8113f9dc:	0001883a 	nop
8113f9e0:	e037883a 	mov	sp,fp
8113f9e4:	df000017 	ldw	fp,0(sp)
8113f9e8:	dec00104 	addi	sp,sp,4
8113f9ec:	f800283a 	ret

8113f9f0 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8113f9f0:	deffff04 	addi	sp,sp,-4
8113f9f4:	de00012e 	bgeu	sp,et,8113f9fc <OSTaskStatHook+0xc>
8113f9f8:	003b68fa 	trap	3
8113f9fc:	df000015 	stw	fp,0(sp)
8113fa00:	d839883a 	mov	fp,sp
}
8113fa04:	0001883a 	nop
8113fa08:	e037883a 	mov	sp,fp
8113fa0c:	df000017 	ldw	fp,0(sp)
8113fa10:	dec00104 	addi	sp,sp,4
8113fa14:	f800283a 	ret

8113fa18 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
8113fa18:	defffe04 	addi	sp,sp,-8
8113fa1c:	de00012e 	bgeu	sp,et,8113fa24 <OSTimeTickHook+0xc>
8113fa20:	003b68fa 	trap	3
8113fa24:	dfc00115 	stw	ra,4(sp)
8113fa28:	df000015 	stw	fp,0(sp)
8113fa2c:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8113fa30:	d0a0a60b 	ldhu	r2,-32104(gp)
8113fa34:	10800044 	addi	r2,r2,1
8113fa38:	d0a0a60d 	sth	r2,-32104(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
8113fa3c:	d0a0a60b 	ldhu	r2,-32104(gp)
8113fa40:	10bfffcc 	andi	r2,r2,65535
8113fa44:	10807d30 	cmpltui	r2,r2,500
8113fa48:	1000021e 	bne	r2,zero,8113fa54 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
8113fa4c:	d020a60d 	sth	zero,-32104(gp)
        OSTmrSignal();
8113fa50:	11363680 	call	81136368 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8113fa54:	0001883a 	nop
8113fa58:	e037883a 	mov	sp,fp
8113fa5c:	dfc00117 	ldw	ra,4(sp)
8113fa60:	df000017 	ldw	fp,0(sp)
8113fa64:	dec00204 	addi	sp,sp,8
8113fa68:	f800283a 	ret

8113fa6c <OSInitHookBegin>:

void OSInitHookBegin(void)
{
8113fa6c:	deffff04 	addi	sp,sp,-4
8113fa70:	de00012e 	bgeu	sp,et,8113fa78 <OSInitHookBegin+0xc>
8113fa74:	003b68fa 	trap	3
8113fa78:	df000015 	stw	fp,0(sp)
8113fa7c:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8113fa80:	d020a60d 	sth	zero,-32104(gp)
#endif
}
8113fa84:	0001883a 	nop
8113fa88:	e037883a 	mov	sp,fp
8113fa8c:	df000017 	ldw	fp,0(sp)
8113fa90:	dec00104 	addi	sp,sp,4
8113fa94:	f800283a 	ret

8113fa98 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
8113fa98:	deffff04 	addi	sp,sp,-4
8113fa9c:	de00012e 	bgeu	sp,et,8113faa4 <OSInitHookEnd+0xc>
8113faa0:	003b68fa 	trap	3
8113faa4:	df000015 	stw	fp,0(sp)
8113faa8:	d839883a 	mov	fp,sp
}
8113faac:	0001883a 	nop
8113fab0:	e037883a 	mov	sp,fp
8113fab4:	df000017 	ldw	fp,0(sp)
8113fab8:	dec00104 	addi	sp,sp,4
8113fabc:	f800283a 	ret

8113fac0 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8113fac0:	deffff04 	addi	sp,sp,-4
8113fac4:	de00012e 	bgeu	sp,et,8113facc <OSTaskIdleHook+0xc>
8113fac8:	003b68fa 	trap	3
8113facc:	df000015 	stw	fp,0(sp)
8113fad0:	d839883a 	mov	fp,sp
}
8113fad4:	0001883a 	nop
8113fad8:	e037883a 	mov	sp,fp
8113fadc:	df000017 	ldw	fp,0(sp)
8113fae0:	dec00104 	addi	sp,sp,4
8113fae4:	f800283a 	ret

8113fae8 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
8113fae8:	defffe04 	addi	sp,sp,-8
8113faec:	de00012e 	bgeu	sp,et,8113faf4 <OSTCBInitHook+0xc>
8113faf0:	003b68fa 	trap	3
8113faf4:	df000115 	stw	fp,4(sp)
8113faf8:	df000104 	addi	fp,sp,4
8113fafc:	e13fff15 	stw	r4,-4(fp)
}
8113fb00:	0001883a 	nop
8113fb04:	e037883a 	mov	sp,fp
8113fb08:	df000017 	ldw	fp,0(sp)
8113fb0c:	dec00104 	addi	sp,sp,4
8113fb10:	f800283a 	ret

8113fb14 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8113fb14:	defffe04 	addi	sp,sp,-8
8113fb18:	de00012e 	bgeu	sp,et,8113fb20 <alt_exception_cause_generated_bad_addr+0xc>
8113fb1c:	003b68fa 	trap	3
8113fb20:	df000115 	stw	fp,4(sp)
8113fb24:	df000104 	addi	fp,sp,4
8113fb28:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
8113fb2c:	e0bfff17 	ldw	r2,-4(fp)
8113fb30:	10bffe84 	addi	r2,r2,-6
8113fb34:	10c00428 	cmpgeui	r3,r2,16
8113fb38:	18001a1e 	bne	r3,zero,8113fba4 <alt_exception_cause_generated_bad_addr+0x90>
8113fb3c:	100690ba 	slli	r3,r2,2
8113fb40:	00a04534 	movhi	r2,33044
8113fb44:	10bed504 	addi	r2,r2,-1196
8113fb48:	1885883a 	add	r2,r3,r2
8113fb4c:	10800017 	ldw	r2,0(r2)
8113fb50:	1000683a 	jmp	r2
8113fb54:	8113fb94 	ori	r4,r16,20462
8113fb58:	8113fb94 	ori	r4,r16,20462
8113fb5c:	8113fba4 	muli	r4,r16,20462
8113fb60:	8113fba4 	muli	r4,r16,20462
8113fb64:	8113fba4 	muli	r4,r16,20462
8113fb68:	8113fb94 	ori	r4,r16,20462
8113fb6c:	8113fb9c 	xori	r4,r16,20462
8113fb70:	8113fba4 	muli	r4,r16,20462
8113fb74:	8113fb94 	ori	r4,r16,20462
8113fb78:	8113fb94 	ori	r4,r16,20462
8113fb7c:	8113fba4 	muli	r4,r16,20462
8113fb80:	8113fb94 	ori	r4,r16,20462
8113fb84:	8113fb9c 	xori	r4,r16,20462
8113fb88:	8113fba4 	muli	r4,r16,20462
8113fb8c:	8113fba4 	muli	r4,r16,20462
8113fb90:	8113fb94 	ori	r4,r16,20462
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8113fb94:	00800044 	movi	r2,1
8113fb98:	00000306 	br	8113fba8 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
8113fb9c:	0005883a 	mov	r2,zero
8113fba0:	00000106 	br	8113fba8 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8113fba4:	0005883a 	mov	r2,zero
  }
}
8113fba8:	e037883a 	mov	sp,fp
8113fbac:	df000017 	ldw	fp,0(sp)
8113fbb0:	dec00104 	addi	sp,sp,4
8113fbb4:	f800283a 	ret

8113fbb8 <exit>:
8113fbb8:	defffe04 	addi	sp,sp,-8
8113fbbc:	000b883a 	mov	r5,zero
8113fbc0:	de00012e 	bgeu	sp,et,8113fbc8 <exit+0x10>
8113fbc4:	003b68fa 	trap	3
8113fbc8:	dc000015 	stw	r16,0(sp)
8113fbcc:	dfc00115 	stw	ra,4(sp)
8113fbd0:	2021883a 	mov	r16,r4
8113fbd4:	113fd600 	call	8113fd60 <__call_exitprocs>
8113fbd8:	00a04534 	movhi	r2,33044
8113fbdc:	109aec04 	addi	r2,r2,27568
8113fbe0:	11000017 	ldw	r4,0(r2)
8113fbe4:	20800f17 	ldw	r2,60(r4)
8113fbe8:	10000126 	beq	r2,zero,8113fbf0 <exit+0x38>
8113fbec:	103ee83a 	callr	r2
8113fbf0:	8009883a 	mov	r4,r16
8113fbf4:	113fee80 	call	8113fee8 <_exit>

8113fbf8 <memcmp>:
8113fbf8:	01c000c4 	movi	r7,3
8113fbfc:	3980192e 	bgeu	r7,r6,8113fc64 <memcmp+0x6c>
8113fc00:	2144b03a 	or	r2,r4,r5
8113fc04:	11c4703a 	and	r2,r2,r7
8113fc08:	10000f26 	beq	r2,zero,8113fc48 <memcmp+0x50>
8113fc0c:	20800003 	ldbu	r2,0(r4)
8113fc10:	28c00003 	ldbu	r3,0(r5)
8113fc14:	10c0151e 	bne	r2,r3,8113fc6c <memcmp+0x74>
8113fc18:	31bfff84 	addi	r6,r6,-2
8113fc1c:	01ffffc4 	movi	r7,-1
8113fc20:	00000406 	br	8113fc34 <memcmp+0x3c>
8113fc24:	20800003 	ldbu	r2,0(r4)
8113fc28:	28c00003 	ldbu	r3,0(r5)
8113fc2c:	31bfffc4 	addi	r6,r6,-1
8113fc30:	10c00e1e 	bne	r2,r3,8113fc6c <memcmp+0x74>
8113fc34:	21000044 	addi	r4,r4,1
8113fc38:	29400044 	addi	r5,r5,1
8113fc3c:	31fff91e 	bne	r6,r7,8113fc24 <__reset+0xfb11fc24>
8113fc40:	0005883a 	mov	r2,zero
8113fc44:	f800283a 	ret
8113fc48:	20c00017 	ldw	r3,0(r4)
8113fc4c:	28800017 	ldw	r2,0(r5)
8113fc50:	18bfee1e 	bne	r3,r2,8113fc0c <__reset+0xfb11fc0c>
8113fc54:	31bfff04 	addi	r6,r6,-4
8113fc58:	21000104 	addi	r4,r4,4
8113fc5c:	29400104 	addi	r5,r5,4
8113fc60:	39bff936 	bltu	r7,r6,8113fc48 <__reset+0xfb11fc48>
8113fc64:	303fe91e 	bne	r6,zero,8113fc0c <__reset+0xfb11fc0c>
8113fc68:	003ff506 	br	8113fc40 <__reset+0xfb11fc40>
8113fc6c:	10c5c83a 	sub	r2,r2,r3
8113fc70:	f800283a 	ret

8113fc74 <strncpy>:
8113fc74:	2906b03a 	or	r3,r5,r4
8113fc78:	18c000cc 	andi	r3,r3,3
8113fc7c:	2005883a 	mov	r2,r4
8113fc80:	18002c1e 	bne	r3,zero,8113fd34 <strncpy+0xc0>
8113fc84:	010000c4 	movi	r4,3
8113fc88:	21802a2e 	bgeu	r4,r6,8113fd34 <strncpy+0xc0>
8113fc8c:	033fbff4 	movhi	r12,65279
8113fc90:	02e02074 	movhi	r11,32897
8113fc94:	633fbfc4 	addi	r12,r12,-257
8113fc98:	5ae02004 	addi	r11,r11,-32640
8113fc9c:	100f883a 	mov	r7,r2
8113fca0:	2a000017 	ldw	r8,0(r5)
8113fca4:	3815883a 	mov	r10,r7
8113fca8:	4313883a 	add	r9,r8,r12
8113fcac:	0206303a 	nor	r3,zero,r8
8113fcb0:	48c6703a 	and	r3,r9,r3
8113fcb4:	1ac6703a 	and	r3,r3,r11
8113fcb8:	1800261e 	bne	r3,zero,8113fd54 <strncpy+0xe0>
8113fcbc:	39c00104 	addi	r7,r7,4
8113fcc0:	52000015 	stw	r8,0(r10)
8113fcc4:	31bfff04 	addi	r6,r6,-4
8113fcc8:	3811883a 	mov	r8,r7
8113fccc:	29400104 	addi	r5,r5,4
8113fcd0:	21bff336 	bltu	r4,r6,8113fca0 <__reset+0xfb11fca0>
8113fcd4:	30001e26 	beq	r6,zero,8113fd50 <strncpy+0xdc>
8113fcd8:	29c00003 	ldbu	r7,0(r5)
8113fcdc:	31bfffc4 	addi	r6,r6,-1
8113fce0:	40c00044 	addi	r3,r8,1
8113fce4:	41c00005 	stb	r7,0(r8)
8113fce8:	39c03fcc 	andi	r7,r7,255
8113fcec:	39c0201c 	xori	r7,r7,128
8113fcf0:	39ffe004 	addi	r7,r7,-128
8113fcf4:	29400044 	addi	r5,r5,1
8113fcf8:	38001026 	beq	r7,zero,8113fd3c <strncpy+0xc8>
8113fcfc:	1811883a 	mov	r8,r3
8113fd00:	00000906 	br	8113fd28 <strncpy+0xb4>
8113fd04:	29c00003 	ldbu	r7,0(r5)
8113fd08:	31bfffc4 	addi	r6,r6,-1
8113fd0c:	29400044 	addi	r5,r5,1
8113fd10:	41c00005 	stb	r7,0(r8)
8113fd14:	39c03fcc 	andi	r7,r7,255
8113fd18:	39c0201c 	xori	r7,r7,128
8113fd1c:	39ffe004 	addi	r7,r7,-128
8113fd20:	1811883a 	mov	r8,r3
8113fd24:	38000526 	beq	r7,zero,8113fd3c <strncpy+0xc8>
8113fd28:	18c00044 	addi	r3,r3,1
8113fd2c:	303ff51e 	bne	r6,zero,8113fd04 <__reset+0xfb11fd04>
8113fd30:	f800283a 	ret
8113fd34:	1011883a 	mov	r8,r2
8113fd38:	003fe606 	br	8113fcd4 <__reset+0xfb11fcd4>
8113fd3c:	30000726 	beq	r6,zero,8113fd5c <strncpy+0xe8>
8113fd40:	198d883a 	add	r6,r3,r6
8113fd44:	18000005 	stb	zero,0(r3)
8113fd48:	18c00044 	addi	r3,r3,1
8113fd4c:	19bffd1e 	bne	r3,r6,8113fd44 <__reset+0xfb11fd44>
8113fd50:	f800283a 	ret
8113fd54:	3811883a 	mov	r8,r7
8113fd58:	003fdf06 	br	8113fcd8 <__reset+0xfb11fcd8>
8113fd5c:	f800283a 	ret

8113fd60 <__call_exitprocs>:
8113fd60:	defff504 	addi	sp,sp,-44
8113fd64:	de00012e 	bgeu	sp,et,8113fd6c <__call_exitprocs+0xc>
8113fd68:	003b68fa 	trap	3
8113fd6c:	df000915 	stw	fp,36(sp)
8113fd70:	dd400615 	stw	r21,24(sp)
8113fd74:	dc800315 	stw	r18,12(sp)
8113fd78:	dfc00a15 	stw	ra,40(sp)
8113fd7c:	ddc00815 	stw	r23,32(sp)
8113fd80:	dd800715 	stw	r22,28(sp)
8113fd84:	dd000515 	stw	r20,20(sp)
8113fd88:	dcc00415 	stw	r19,16(sp)
8113fd8c:	dc400215 	stw	r17,8(sp)
8113fd90:	dc000115 	stw	r16,4(sp)
8113fd94:	d9000015 	stw	r4,0(sp)
8113fd98:	2839883a 	mov	fp,r5
8113fd9c:	04800044 	movi	r18,1
8113fda0:	057fffc4 	movi	r21,-1
8113fda4:	00a04534 	movhi	r2,33044
8113fda8:	109aec04 	addi	r2,r2,27568
8113fdac:	12000017 	ldw	r8,0(r2)
8113fdb0:	45005217 	ldw	r20,328(r8)
8113fdb4:	44c05204 	addi	r19,r8,328
8113fdb8:	a0001c26 	beq	r20,zero,8113fe2c <__call_exitprocs+0xcc>
8113fdbc:	a0800117 	ldw	r2,4(r20)
8113fdc0:	15ffffc4 	addi	r23,r2,-1
8113fdc4:	b8000d16 	blt	r23,zero,8113fdfc <__call_exitprocs+0x9c>
8113fdc8:	14000044 	addi	r16,r2,1
8113fdcc:	8421883a 	add	r16,r16,r16
8113fdd0:	8421883a 	add	r16,r16,r16
8113fdd4:	84402004 	addi	r17,r16,128
8113fdd8:	a463883a 	add	r17,r20,r17
8113fddc:	a421883a 	add	r16,r20,r16
8113fde0:	e0001e26 	beq	fp,zero,8113fe5c <__call_exitprocs+0xfc>
8113fde4:	80804017 	ldw	r2,256(r16)
8113fde8:	e0801c26 	beq	fp,r2,8113fe5c <__call_exitprocs+0xfc>
8113fdec:	bdffffc4 	addi	r23,r23,-1
8113fdf0:	843fff04 	addi	r16,r16,-4
8113fdf4:	8c7fff04 	addi	r17,r17,-4
8113fdf8:	bd7ff91e 	bne	r23,r21,8113fde0 <__reset+0xfb11fde0>
8113fdfc:	00800034 	movhi	r2,0
8113fe00:	10800004 	addi	r2,r2,0
8113fe04:	10000926 	beq	r2,zero,8113fe2c <__call_exitprocs+0xcc>
8113fe08:	a0800117 	ldw	r2,4(r20)
8113fe0c:	1000301e 	bne	r2,zero,8113fed0 <__call_exitprocs+0x170>
8113fe10:	a0800017 	ldw	r2,0(r20)
8113fe14:	10003226 	beq	r2,zero,8113fee0 <__call_exitprocs+0x180>
8113fe18:	a009883a 	mov	r4,r20
8113fe1c:	98800015 	stw	r2,0(r19)
8113fe20:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8113fe24:	9d000017 	ldw	r20,0(r19)
8113fe28:	a03fe41e 	bne	r20,zero,8113fdbc <__reset+0xfb11fdbc>
8113fe2c:	dfc00a17 	ldw	ra,40(sp)
8113fe30:	df000917 	ldw	fp,36(sp)
8113fe34:	ddc00817 	ldw	r23,32(sp)
8113fe38:	dd800717 	ldw	r22,28(sp)
8113fe3c:	dd400617 	ldw	r21,24(sp)
8113fe40:	dd000517 	ldw	r20,20(sp)
8113fe44:	dcc00417 	ldw	r19,16(sp)
8113fe48:	dc800317 	ldw	r18,12(sp)
8113fe4c:	dc400217 	ldw	r17,8(sp)
8113fe50:	dc000117 	ldw	r16,4(sp)
8113fe54:	dec00b04 	addi	sp,sp,44
8113fe58:	f800283a 	ret
8113fe5c:	a0800117 	ldw	r2,4(r20)
8113fe60:	80c00017 	ldw	r3,0(r16)
8113fe64:	10bfffc4 	addi	r2,r2,-1
8113fe68:	15c01426 	beq	r2,r23,8113febc <__call_exitprocs+0x15c>
8113fe6c:	80000015 	stw	zero,0(r16)
8113fe70:	183fde26 	beq	r3,zero,8113fdec <__reset+0xfb11fdec>
8113fe74:	95c8983a 	sll	r4,r18,r23
8113fe78:	a0806217 	ldw	r2,392(r20)
8113fe7c:	a5800117 	ldw	r22,4(r20)
8113fe80:	2084703a 	and	r2,r4,r2
8113fe84:	10000b26 	beq	r2,zero,8113feb4 <__call_exitprocs+0x154>
8113fe88:	a0806317 	ldw	r2,396(r20)
8113fe8c:	2088703a 	and	r4,r4,r2
8113fe90:	20000c1e 	bne	r4,zero,8113fec4 <__call_exitprocs+0x164>
8113fe94:	89400017 	ldw	r5,0(r17)
8113fe98:	d9000017 	ldw	r4,0(sp)
8113fe9c:	183ee83a 	callr	r3
8113fea0:	a0800117 	ldw	r2,4(r20)
8113fea4:	15bfbf1e 	bne	r2,r22,8113fda4 <__reset+0xfb11fda4>
8113fea8:	98800017 	ldw	r2,0(r19)
8113feac:	153fcf26 	beq	r2,r20,8113fdec <__reset+0xfb11fdec>
8113feb0:	003fbc06 	br	8113fda4 <__reset+0xfb11fda4>
8113feb4:	183ee83a 	callr	r3
8113feb8:	003ff906 	br	8113fea0 <__reset+0xfb11fea0>
8113febc:	a5c00115 	stw	r23,4(r20)
8113fec0:	003feb06 	br	8113fe70 <__reset+0xfb11fe70>
8113fec4:	89000017 	ldw	r4,0(r17)
8113fec8:	183ee83a 	callr	r3
8113fecc:	003ff406 	br	8113fea0 <__reset+0xfb11fea0>
8113fed0:	a0800017 	ldw	r2,0(r20)
8113fed4:	a027883a 	mov	r19,r20
8113fed8:	1029883a 	mov	r20,r2
8113fedc:	003fb606 	br	8113fdb8 <__reset+0xfb11fdb8>
8113fee0:	0005883a 	mov	r2,zero
8113fee4:	003ffb06 	br	8113fed4 <__reset+0xfb11fed4>

8113fee8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8113fee8:	defffc04 	addi	sp,sp,-16
8113feec:	de00012e 	bgeu	sp,et,8113fef4 <_exit+0xc>
8113fef0:	003b68fa 	trap	3
8113fef4:	dfc00315 	stw	ra,12(sp)
8113fef8:	df000215 	stw	fp,8(sp)
8113fefc:	df000204 	addi	fp,sp,8
8113ff00:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8113ff04:	d0a01217 	ldw	r2,-32696(gp)
8113ff08:	10800058 	cmpnei	r2,r2,1
8113ff0c:	1000031e 	bne	r2,zero,8113ff1c <_exit+0x34>
8113ff10:	01204534 	movhi	r4,33044
8113ff14:	21136f04 	addi	r4,r4,19900
8113ff18:	112bbac0 	call	8112bbac <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
8113ff1c:	d0a01217 	ldw	r2,-32696(gp)
8113ff20:	10800058 	cmpnei	r2,r2,1
8113ff24:	1000041e 	bne	r2,zero,8113ff38 <_exit+0x50>
8113ff28:	e17fff17 	ldw	r5,-4(fp)
8113ff2c:	01204534 	movhi	r4,33044
8113ff30:	21137a04 	addi	r4,r4,19944
8113ff34:	112bbac0 	call	8112bbac <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
8113ff38:	d0a01217 	ldw	r2,-32696(gp)
8113ff3c:	10800058 	cmpnei	r2,r2,1
8113ff40:	1000031e 	bne	r2,zero,8113ff50 <_exit+0x68>
8113ff44:	01204534 	movhi	r4,33044
8113ff48:	21138504 	addi	r4,r4,19988
8113ff4c:	112bbac0 	call	8112bbac <alt_log_printf_proc>
  ALT_OS_STOP();
8113ff50:	d0208105 	stb	zero,-32252(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8113ff54:	d0a01217 	ldw	r2,-32696(gp)
8113ff58:	10800058 	cmpnei	r2,r2,1
8113ff5c:	1000031e 	bne	r2,zero,8113ff6c <_exit+0x84>
8113ff60:	01204534 	movhi	r4,33044
8113ff64:	21138f04 	addi	r4,r4,20028
8113ff68:	112bbac0 	call	8112bbac <alt_log_printf_proc>
8113ff6c:	e0bfff17 	ldw	r2,-4(fp)
8113ff70:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8113ff74:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
8113ff78:	10000226 	beq	r2,zero,8113ff84 <_exit+0x9c>
    ALT_SIM_FAIL();
8113ff7c:	002af070 	cmpltui	zero,zero,43969
8113ff80:	00000106 	br	8113ff88 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8113ff84:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
8113ff88:	d0a01217 	ldw	r2,-32696(gp)
8113ff8c:	10800058 	cmpnei	r2,r2,1
8113ff90:	1000031e 	bne	r2,zero,8113ffa0 <_exit+0xb8>
8113ff94:	01204534 	movhi	r4,33044
8113ff98:	21139904 	addi	r4,r4,20068
8113ff9c:	112bbac0 	call	8112bbac <alt_log_printf_proc>
  while (1);
8113ffa0:	003fff06 	br	8113ffa0 <__reset+0xfb11ffa0>
