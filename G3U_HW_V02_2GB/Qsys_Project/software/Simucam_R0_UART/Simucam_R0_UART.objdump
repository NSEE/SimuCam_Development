
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x00041b4c memsz 0x00055910 flags rwx
    LOAD off    0x00043000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00043000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0003c380  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000383c  8113c5dc  8113c5dc  0003d5dc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001d54  8113fe18  8113fe18  00040e18  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00013dc4  81141b6c  81141b6c  00042b6c  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  81155930  81155930  00043000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00043000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00043000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001c38  00000000  00000000  00043028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0005bcb4  00000000  00000000  00044c60  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00014afc  00000000  00000000  000a0914  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001d8c8  00000000  00000000  000b5410  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00007c3c  00000000  00000000  000d2cd8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000a81e  00000000  00000000  000da914  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026d67  00000000  00000000  000e5132  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0010be9c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002388  00000000  00000000  0010bee0  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00118299  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0011829f  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  001182ab  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  001182ac  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  001182ad  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  001182b1  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  001182b5  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  001182b9  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  001182c4  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  001182ce  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  001182d8  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  001182e9  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00278448  00000000  00000000  00118328  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8113c5dc l    d  .rodata	00000000 .rodata
8113fe18 l    d  .rwdata	00000000 .rwdata
81141b6c l    d  .bss	00000000 .bss
81155930 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100294 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm.c
00000000 l    df *ABS*	00000000 data_packet.c
00000000 l    df *ABS*	00000000 fee_buffers.c
81141b88 l     O .bss	00000004 viCh1HoldContext
81141b8c l     O .bss	00000004 viCh2HoldContext
81141b90 l     O .bss	00000004 viCh3HoldContext
81141b94 l     O .bss	00000004 viCh4HoldContext
81141b98 l     O .bss	00000004 viCh5HoldContext
81141b9c l     O .bss	00000004 viCh6HoldContext
81141ba0 l     O .bss	00000004 viCh7HoldContext
81141ba4 l     O .bss	00000004 viCh8HoldContext
811050d8 l     F .text	00000054 vFeebWriteReg
8110512c l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
00000000 l    df *ABS*	00000000 spw_controller.c
811056dc l     F .text	00000050 uliSpwcReadReg
81105688 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
81141a98 l     O .rwdata	00000001 ucIoValue
811058dc l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
811061cc l     F .text	0000013c msgdma_write_extended_descriptor
81106308 l     F .text	00000164 msgdma_construct_extended_descriptor
8110646c l     F .text	00000318 msgdma_descriptor_async_transfer
81106784 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
81107300 l     F .text	00000054 vRstcWriteReg
81107354 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
81141bac l     O .bss	00000004 viHoldContext
81108688 l     F .text	00000058 uliSyncReadReg
8110862c l     F .text	0000005c bSyncWriteReg
00000000 l    df *ABS*	00000000 fee_task.c
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
81141bb2 l     O .bss	00000004 xRAckLocal.4480
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
81141bb6 l     O .bss	00000004 xSAckLocal.4465
00000000 l    df *ABS*	00000000 parser_comm_task.c
81141d04 l     O .bss	0000004c PreParsedLocal.4550
00000000 l    df *ABS*	00000000 receiver_uart_task.c
81141d50 l     O .bss	0000004c xPreParsedReader.4544
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8113e25c l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
8113f4f5 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
8113fe18 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
81113b18 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
8113f6c2 l     O .rodata	00000010 zeroes.4389
8113f6d2 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
8113f6e2 l     O .rodata	00000010 zeroes.4404
81118790 l     F .text	000000c4 __sbprintf
8113f6f2 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
8113f70a l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
8111a318 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8111be68 l     F .text	00000008 __fp_unlock
8111be7c l     F .text	000001a4 __sinit.part.1
8111c020 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
81140664 l     O .rwdata	00000020 lc_ctype_charset
81140644 l     O .rwdata	00000020 lc_message_charset
81140684 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
8113f748 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
8111ee90 l     F .text	0000006c sulp
8113f890 l     O .rodata	00000014 fpi.2737
8113f8a4 l     O .rodata	00000028 tinytens
8113f87c l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8113f8dc l     O .rodata	00000010 blanks.4332
8113f8cc l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
81122500 l     F .text	00000104 __sprint_r.part.0
8113f8fc l     O .rodata	00000010 blanks.4348
8113f8ec l     O .rodata	00000010 zeroes.4349
81123a9c l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
81123f50 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
81127e4c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81127f90 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
81127fc4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
81128248 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
81128338 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
8112851c l     F .text	00000044 alt_get_errno
81128560 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
81128788 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
81141adc l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81128d28 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
81141ae8 l     O .rwdata	00000004 lockid
81141c4c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
81141aec l     O .rwdata	00000004 lockid
81141c54 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
8112a82c l     F .text	00000050 OS_InitMisc
8112a87c l     F .text	00000074 OS_InitRdyList
8112aa00 l     F .text	000000ec OS_InitTCBList
8112a744 l     F .text	000000e8 OS_InitEventList
8112a8f0 l     F .text	00000088 OS_InitTaskIdle
8112a978 l     F .text	00000088 OS_InitTaskStat
8112ac90 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
8112caa8 l     F .text	000000fc OS_FlagTaskRdy
8112c858 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8112e394 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
81132dc4 l     F .text	00000044 OSTmr_Lock
81132864 l     F .text	00000074 OSTmr_Alloc
81132e08 l     F .text	0000003c OSTmr_Unlock
81132cc8 l     F .text	000000fc OSTmr_Unlink
811328d8 l     F .text	000000a4 OSTmr_Free
81132b78 l     F .text	00000150 OSTmr_Link
81132af0 l     F .text	00000088 OSTmr_InitTask
81132e44 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
81132f54 l     F .text	0000003c alt_dev_reg
81140864 l     O .rwdata	0000106c jtag_uart_0
811418d0 l     O .rwdata	000000d0 rs232_uart
811419a0 l     O .rwdata	00000064 dma_DDR_M1
81141a04 l     O .rwdata	00000064 dma_DDR_M2
81141a68 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81137764 l     F .text	000002ac altera_avalon_jtag_uart_irq
81137a10 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81138214 l     F .text	00000080 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
811385a8 l     F .text	000000a4 altera_avalon_uart_irq
8113864c l     F .text	00000140 altera_avalon_uart_rxirq
8113878c l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81138994 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81138c48 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
81138ecc l     F .text	00000044 alt_get_errno
81138f10 l     F .text	0000009c alt_msgdma_write_standard_descriptor
81138fac l     F .text	00000134 alt_msgdma_write_extended_descriptor
811390e0 l     F .text	0000018c alt_msgdma_irq
8113926c l     F .text	00000094 alt_msgdma_construct_standard_descriptor
81139300 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
8113945c l     F .text	00000340 alt_msgdma_descriptor_async_transfer
8113979c l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81139ea4 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81139f50 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8113b11c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
8113b830 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81141cfc l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81141d00 g     O .bss	00000004 alt_instruction_exception_handler
8110f06c g     F .text	0000004c vFailDeleteInitialization
81141cd0 g     O .bss	00000004 aux_status_register
811422c4 g     O .bss	00002000 vInAckHandlerTask_stk
8113aed8 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
8110788c g     F .text	0000004c vSyncInitIrq
8110b23c g     F .text	000002c0 vCheckRetransmission128
8111e514 g     F .text	0000007c _mprec_log10
81107a08 g     F .text	00000040 bSyncSetMbt
81105ac0 g     F .text	00000108 I2C_Read
81141b3a g     O .rwdata	00000002 OSTaskNameSize
811442c4 g     O .bss	00000130 xBuffer64
8111e608 g     F .text	0000008c __any_on
8111cfdc g     F .text	0000005c _isatty_r
8113f754 g     O .rodata	00000028 __mprec_tinytens
81128458 g     F .text	000000c4 alt_main
81113a3c g     F .text	000000c8 _puts_r
81104964 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
81141c5c g     O .bss	00000004 OSTmrFreeList
81155830 g     O .bss	00000100 alt_irq
8111d14c g     F .text	00000068 _lseek_r
81110920 g     F .text	00000030 vChangeDefaultAutoResetSync
8112d308 g     F .text	000000d4 OS_MemInit
8110dcac g     F .text	0000098c vLoadDefaultETHConf
81108b84 g     F .text	00000144 bCheckInAck64
81131da4 g     F .text	00000068 OSTimeSet
8111c220 g     F .text	000000ac __sflags
81126fac g     F .text	00000088 .hidden __eqdf2
81102a38 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
81110798 g     F .text	00000034 vLoadDefaultSyncSource
81133454 g     F .text	000001ac Check_for_Master_Boot_Record
81150c6c g     O .bss	00000010 OSTmrWheelTbl
81139c64 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
8112940c g     F .text	00000618 OSEventPendMulti
81155930 g       *ABS*	00000000 __alt_heap_start
8113be68 g     F .text	0000002c OSTaskCreateHook
811372cc g     F .text	000001c4 alt_up_sd_card_fclose
81141bc0 g     O .bss	00000004 xSemCountBuffer64
811139f8 g     F .text	00000044 printf
81141ba9 g     O .bss	00000001 SspdConfigControl
81107e24 g     F .text	00000054 bSyncCtrReset
81141b12 g     O .rwdata	00000002 OSMboxEn
81110f94 g     F .text	000000a4 aatoh
81129a88 g     F .text	00000054 OSIntEnter
81124d1c g     F .text	000000a4 _wcrtomb_r
81104870 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8110efd4 g     F .text	0000004c vFailReceiverCreate
811044d4 g     F .text	00000040 vFeebCh2HandleIrq
81113fa4 g     F .text	00000064 __sseek
8111c1d0 g     F .text	00000010 __sinit
81106c40 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
81124bbc g     F .text	00000148 __swbuf_r
8110c2f4 g     F .text	000002f0 bResourcesInitRTOS
8110534c g     F .text	000000f4 bSpwcGetLinkError
81141b22 g     O .rwdata	00000002 OSQEn
8111d068 g     F .text	00000084 _setlocale_r
81141a9c g     O .rwdata	00000004 LedsPainelControl
81141dc4 g     O .bss	00000100 cDebugBuffer
8111c028 g     F .text	00000070 __sfmoreglue
811224e8 g     F .text	00000018 ungetc
811290c8 g     F .text	000000d4 __malloc_unlock
81102d28 g     F .text	00000210 DMA_MULTIPLE_TRANSFER
8113bee8 g     F .text	00000028 OSTaskStatHook
81110808 g     F .text	00000030 vChangeDefaultSyncSource
81141c60 g     O .bss	00000001 OSLockNesting
81141c64 g     O .bss	00000004 OSTmrSemSignal
8110fd80 g     F .text	000000d8 vNFeeStructureInit
81141bc4 g     O .bss	00000004 xSemCommInit
811028bc g     F .text	00000080 uliXorshift32
8111eefc g     F .text	00001600 _strtod_r
81141bc8 g     O .bss	00000004 xSemCountSenderACK
811110d0 g     F .text	00000448 .hidden __divsf3
81141cf4 g     O .bss	00000004 current_sector_modified
81141b60 g     O .rwdata	00000002 OSDataSize
81141c68 g     O .bss	00000001 OSRunning
81105510 g     F .text	00000178 bSpwcInitCh
811443f4 g     O .bss	00002000 senderTask_stk
81141bcc g     O .bss	00000004 fp
81108a44 g     F .text	00000140 bCheckInAck128
8111d4dc g     F .text	0000015c memmove
811463f4 g     O .bss	0000045c xSimMebStruct
8113bf64 g     F .text	0000002c OSInitHookBegin
811082c0 g     F .text	00000074 bSyncCtrCh8OutEnable
81141b58 g     O .rwdata	00000002 OSTmrSize
8111c1b8 g     F .text	00000018 _cleanup
81110bcc g     F .text	00000040 siCloseFile
8111d638 g     F .text	000000b0 _Balloc
811108ac g     F .text	00000038 vLoadDefaultAutoResetSync
81135ea8 g     F .text	000000cc alt_up_sd_card_is_Present
81139ba4 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
81141b74 g     O .bss	00000004 pxDmaM1Dev
81102ad0 g     F .text	000000a4 DMA_DISPATCHER_STOP
8113317c g     F .text	00000054 Save_Modified_Sector
81104ac4 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
81141c6c g     O .bss	00000004 OSIdleCtr
8110572c g     F .text	0000003c bEnableIsoDrivers
81127034 g     F .text	000000dc .hidden __gtdf2
8113bbf8 g     F .text	0000002c altera_nios2_gen2_irq_init
8113bce0 g       .text	00000000 OSStartTsk
81107b7c g     F .text	00000070 bSyncSetNCycles
8112b000 g     F .text	000002dc OS_TCBInit
81110380 g     F .text	00000068 vInitSimucamBasicHW
81146850 g     O .bss	00002000 vTimeoutCheckerTask_stk
811081d8 g     F .text	00000074 bSyncCtrCh6OutEnable
81105e3c g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81141cec g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
81141c70 g     O .bss	00000002 OSTmrUsed
81141bd0 g     O .bss	00000004 xSemCountBuffer128
81103200 g     F .text	000000f8 TEMP_Read
81104554 g     F .text	00000040 vFeebCh4HandleIrq
81141b5e g     O .rwdata	00000002 OSTmrWheelTblSize
81110250 g     F .text	0000002c cFeeSpwChannelDisable
81141afe g     O .rwdata	00000002 OSEventSize
81141c72 g     O .bss	00000001 OSPrioHighRdy
81112b94 g     F .text	00000064 _fstat_r
8113be94 g     F .text	0000002c OSTaskDelHook
81141c14 g     O .bss	00000004 errno
811085b4 g     F .text	0000003c uliSyncGetCtr
8111a088 g     F .text	0000001c __svfscanf
81113f18 g     F .text	00000008 __seofread
8113bcc0 g       .text	00000000 OSStartHighRdy
811307d4 g     F .text	000001ec OSTaskCreateExt
8110f390 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
8112102c g     F .text	00001244 ___svfiprintf_internal_r
8110ab18 g     F .text	00000388 bPreParserV2
8112c388 g     F .text	00000068 OSFlagPendGetFlagsRdy
81141b3e g     O .rwdata	00000002 OSTaskStatStkSize
8112b4d4 g     F .text	00000310 OSFlagAccept
8112eab0 g     F .text	000000c0 OSQFlush
8112e52c g     F .text	00000148 OSQAccept
81141c3c g     O .bss	00000004 alt_argv
81149a94 g       *ABS*	00000000 _gp
8110ec9c g     F .text	0000004c vFailSendPreAckReceiverSemaphore
81128bec g     F .text	0000013c usleep
81136480 g     F .text	00000384 alt_up_sd_card_fopen
81110a38 g     F .text	00000030 bSDcardIsPresent
8110aea0 g     F .text	0000017c vSenderComTask
81135fe8 g     F .text	000000d8 alt_up_sd_card_find_first
81130620 g     F .text	000001b4 OSTaskCreate
8110f530 g     F .text	00000068 vFailSendNack
81141ce0 g     O .bss	00000004 command_argument_register
81130128 g     F .text	000004f8 OSTaskChangePrio
8110fc40 g     F .text	00000088 vCouldNotSendTMPusCommand
81141c58 g     O .bss	00000004 alt_heapsem
811060d4 g     F .text	00000080 bSetBoardLeds
8112b2dc g     F .text	000001f8 OSDebugInit
811309c0 g     F .text	0000034c OSTaskDel
8112d3dc g     F .text	000001ac OSMutexAccept
81110838 g     F .text	00000040 vSetTimeCode
8113a74c g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
81141bd4 g     O .bss	00000004 xSemCountPreParsed
811406e4 g     O .rwdata	00000180 alt_fd_list
81104a14 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
81150c7c g     O .bss	00000370 OSFlagTbl
8110ee04 g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
811106f0 g     F .text	0000003c vLoadDefaultRTValue
8112a50c g     F .text	000000c0 OS_EventTaskRemove
811356fc g     F .text	00000134 find_first_empty_record_in_root_directory
8113b2dc g     F .text	00000098 alt_find_dev
811136e0 g     F .text	00000150 memcpy
81124888 g     F .text	00000264 __hexnan
81148850 g     O .bss	00000160 xBuffer32
81141b28 g     O .rwdata	00000002 OSRdyTblSize
81150fec g     O .bss	000001a0 OSTmrTbl
8111be70 g     F .text	0000000c _cleanup_r
81127b88 g     F .text	000000e4 .hidden __floatsidf
8110d8d4 g     F .text	000001a8 vSendPusTM64
81107978 g     F .text	0000004c ucSyncStatusErrorCode
8111034c g     F .text	00000034 cFeeRMAPLogDisable
8110940c g     F .text	00000a80 vParserCommTask
8113b8fc g     F .text	00000084 alt_io_redirect
811102e0 g     F .text	00000034 cFeeRMAPEchoingDisable
81127110 g     F .text	000000f4 .hidden __ltdf2
81104cf4 g     F .text	000000d4 bFeebSetIrqControl
8110faa0 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
81141bd8 g     O .bss	00000004 xMutexReceivedACK
81103b7c g     F .text	000000b0 bSdmaInitM2Dma
8113c5dc g       *ABS*	00000000 __DTOR_END__
8113abd4 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
8113af1c g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
81107ecc g     F .text	00000054 bSyncCtrErrInj
8113ae7c g     F .text	0000005c alt_msgdma_register_callback
8110e638 g     F .text	00000330 vShowEthConfig
811103e8 g     F .text	00000030 bLogWriteSDCard
8110f120 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
81109fa4 g     F .text	000000a0 bTrySendSemaphoreCommInit
81113b04 g     F .text	00000014 puts
8113c00c g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110784c g     F .text	00000040 vSyncHandleIrq
8112919c g     F .text	00000128 OSEventNameGet
811046d8 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
81141b0c g     O .rwdata	00000002 OSFlagMax
8111d268 g     F .text	000000e0 mbrtowc
811352f4 g     F .text	000001b4 find_first_empty_cluster
81108164 g     F .text	00000074 bSyncCtrCh5OutEnable
81141bb0 g     O .bss	00000001 vucN
8111ec68 g     F .text	00000074 __fpclassifyd
811078d8 g     F .text	00000054 bSyncStatusExtnIrq
8111a0a4 g     F .text	00000054 _vfscanf_r
8112da5c g     F .text	000005a4 OSMutexPend
8111e468 g     F .text	000000ac __ratio
81135de4 g     F .text	000000c4 alt_up_sd_card_open_dev
8110fcc8 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
81129adc g     F .text	00000100 OSIntExit
81107a48 g     F .text	00000040 bSyncSetBt
81123a80 g     F .text	0000001c __vfiprintf_internal
81141b46 g     O .rwdata	00000002 OSTCBSize
81104694 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
81141c73 g     O .bss	00000001 OSPrioCur
81137c84 g     F .text	000002c4 altera_avalon_jtag_uart_read
8113a414 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
811139c0 g     F .text	00000038 _printf_r
81125b50 g     F .text	00000064 .hidden __udivsi3
8112828c g     F .text	000000ac isatty
81141ba8 g     O .bss	00000001 LedsBoardControl
81141bdc g     O .bss	00000004 xSemCountReceivedACK
81141b2c g     O .rwdata	00000002 OSStkWidth
8111d038 g     F .text	00000030 iswspace
8113f7a4 g     O .rodata	000000c8 __mprec_tens
81141b20 g     O .rwdata	00000002 OSPtrSize
8111d0ec g     F .text	0000000c __locale_charset
8110807c g     F .text	00000074 bSyncCtrCh3OutEnable
81125d40 g     F .text	000000c8 .hidden __lesf2
81141b00 g     O .rwdata	00000002 OSEventTblSize
81124f1c g     F .text	0000007c .hidden __fixunsdfsi
8113bc24 g       .text	00000000 OSCtxSw
81105bc8 g     F .text	00000160 I2C_MultipleRead
81141c20 g     O .bss	00000004 __malloc_top_pad
81141c74 g     O .bss	00000004 OSTCBList
81132824 g     F .text	00000040 OSTmrSignal
81141c30 g     O .bss	00000004 alt_fd_list_lock
81120b58 g     F .text	0000001c strtoul
81141ab4 g     O .rwdata	00000004 __mb_cur_max
8111d11c g     F .text	0000000c _localeconv_r
81120b74 g     F .text	000002e0 _strtoull_r
81107290 g     F .text	00000070 vRstcHoldDeviceReset
8111da5c g     F .text	00000044 __i2b
8111c980 g     F .text	000004c4 __sfvwrite_r
811345d4 g     F .text	000000c0 get_dir_divider_location
8115118c g     O .bss	00000c30 OSMemTbl
81141c78 g     O .bss	00000001 OSTickStepState
811489b0 g     O .bss	00002000 vReceiverUartTask_stk
81113d10 g     F .text	0000005c _sbrk_r
81141be0 g     O .bss	00000004 xSemTimeoutChecker
81134294 g     F .text	000000cc filename_to_upper_case
81141b24 g     O .rwdata	00000002 OSQMax
81136804 g     F .text	00000090 alt_up_sd_card_set_attributes
8112d758 g     F .text	00000304 OSMutexDel
81151dbc g     O .bss	00000800 OSTaskStatStk
81110a68 g     F .text	00000030 bSDcardFAT16Check
8112cf24 g     F .text	000000f8 OSMemNameGet
8110eaf0 g     F .text	00000060 vFailCreateMutexSResources
81133600 g     F .text	00000284 Read_File_Record_At_Offset
81141b04 g     O .rwdata	00000002 OSFlagEn
8111e694 g     F .text	00000068 _read_r
81141b4a g     O .rwdata	00000002 OSTimeTickHookEn
8112ef78 g     F .text	00000170 OSQPost
8112cba4 g     F .text	000000ac OS_FlagUnlink
81102420 g     F .text	0000049c bDdr2MemoryRandomReadTest
81141ad0 g     O .rwdata	00000004 alt_max_fd
8110f84c g     F .text	0000004c vFailTimeoutCheckerTaskCreate
8112ab48 g     F .text	00000070 OS_MemCopy
8112abb8 g     F .text	000000d8 OS_Sched
81134e78 g     F .text	0000047c find_file_in_directory
81123c2c g     F .text	000000f8 _fclose_r
8112ce2c g     F .text	000000f8 OSMemGet
81131004 g     F .text	000001bc OSTaskNameSet
8111be38 g     F .text	00000030 fflush
81141c1c g     O .bss	00000004 __malloc_max_sbrked_mem
81141c7c g     O .bss	00000004 OSCtxSwCtr
8113bf10 g     F .text	00000054 OSTimeTickHook
8114a9b0 g     O .bss	00002000 vOutAckHandlerTask_stk
811280c0 g     F .text	00000188 alt_irq_register
81141b0e g     O .rwdata	00000002 OSFlagNameSize
81112260 g     F .text	00000118 .hidden __extendsfdf2
8112a5cc g     F .text	00000108 OS_EventTaskRemoveMulti
81135f74 g     F .text	00000074 alt_up_sd_card_is_FAT16
81105958 g     F .text	00000088 I2C_TestAdress
81125e08 g     F .text	000008b4 .hidden __adddf3
81125c0c g     F .text	00000078 .hidden __nesf2
8112a3b4 g     F .text	00000158 OS_EventTaskWaitMulti
8111e200 g     F .text	00000114 __b2d
8113a14c g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
81141b26 g     O .rwdata	00000002 OSQSize
81125518 g     F .text	00000540 .hidden __umoddi3
8112837c g     F .text	000000dc lseek
8112fa68 g     F .text	00000214 OSSemPend
81105440 g     F .text	000000d0 bSpwcGetLinkStatus
81104fa4 g     F .text	00000088 bFeebGetWindowing
81141aa4 g     O .rwdata	00000004 _global_impure_ptr
81107800 g     F .text	0000004c bSSDisplayUpdate
81134938 g     F .text	00000540 get_home_directory_cluster_for_file
8111e6fc g     F .text	0000056c _realloc_r
81141b10 g     O .rwdata	00000002 OSLowestPrio
81155930 g       *ABS*	00000000 __bss_end
8113b738 g     F .text	000000f8 alt_iic_isr_register
8113bfe0 g     F .text	0000002c OSTCBInitHook
81141b56 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81128adc g     F .text	00000110 alt_tick
8110ed9c g     F .text	00000068 vFailGetMutexSenderTask
811071b0 g     F .text	0000006c vRstcSimucamReset
8113f90c g     O .rodata	00000100 __hexdig
8113acc8 g     F .text	000001b4 alt_msgdma_init
81124f98 g     F .text	00000580 .hidden __udivdi3
8110a800 g     F .text	0000017c setPreAckSenderFreePos
81123ea4 g     F .text	00000024 _fputwc_r
81141af8 g     O .rwdata	00000002 OSEventEn
8113f77c g     O .rodata	00000028 __mprec_bigtens
8111d838 g     F .text	0000010c __s2b
81141b52 g     O .rwdata	00000002 OSTmrCfgNameSize
81107b08 g     F .text	00000074 bSyncSetPolarity
8110b4fc g     F .text	0000028c vCheckRetransmission64
81127c6c g     F .text	000000b0 .hidden __floatunsidf
8110f328 g     F .text	00000068 vFailFoundBufferRetransmission
8111df38 g     F .text	00000060 __mcmp
81141cf8 g     O .bss	00000004 current_sector_index
81138440 g     F .text	00000168 altera_avalon_uart_init
8113afa4 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
8110405c g     F .text	00000438 bSdmaDmaM2Transfer
81110878 g     F .text	00000034 vResetTimeCode
81110224 g     F .text	0000002c cFeeSpwChannelEnable
8111c1f0 g     F .text	00000018 __fp_lock_all
8113b6e4 g     F .text	00000054 alt_ic_irq_enabled
811059e0 g     F .text	000000e0 I2C_Write
81141c80 g     O .bss	00000002 OSTmrFree
8112c9c0 g     F .text	000000e8 OS_FlagInit
81128a38 g     F .text	000000a4 alt_alarm_stop
81114378 g     F .text	0000001c strtol
81131fd0 g     F .text	00000140 OSTmrDel
8113336c g     F .text	000000e8 mark_cluster
81141b34 g     O .rwdata	00000002 OSTaskIdleStkSize
81141c34 g     O .bss	00000004 alt_irq_active
8112f688 g     F .text	000000b8 OSSemAccept
8111272c g     F .text	0000044c _fseeko_r
811140f4 g     F .text	00000044 strnlen
8112d138 g     F .text	000000e0 OSMemPut
8112cc50 g     F .text	000001dc OSMemCreate
81141c84 g     O .bss	00000004 OSIdleCtrMax
8110da7c g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
811406bc g     O .rwdata	00000028 alt_dev_null
81139d5c g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
81107ac8 g     F .text	00000040 bSyncSetOst
81141b48 g     O .rwdata	00000002 OSTicksPerSec
81135830 g     F .text	00000194 convert_filename_to_name_extension
8110b01c g     F .text	00000030 vSimMebTask
81105d28 g     F .text	00000094 i2c_start
8113bc24 g       .text	00000000 OSIntCtxSw
811080f0 g     F .text	00000074 bSyncCtrCh4OutEnable
8113ab40 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
81127f68 g     F .text	00000028 alt_dcache_flush_all
8111d944 g     F .text	00000068 __hi0bits
8111072c g     F .text	0000003c vChangeRTValue
81141ccc g     O .bss	00000004 is_sd_card_formated_as_FAT16
8110b0b8 g     F .text	00000184 vCheck
8110fd30 g     F .text	00000050 vNFeeNotInUse
81127b08 g     F .text	00000080 .hidden __fixdfsi
8114c9b0 g     O .bss	00002000 vInitialTask_stk
81141be4 g     O .bss	00000002 usiIdCMD
81107dd0 g     F .text	00000054 bSyncCtrStart
811354a8 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
8110a294 g     F .text	00000434 bPreParser
811204fc g     F .text	00000018 strtod
81141c88 g     O .bss	00000004 OSTCBFreeList
8112fc7c g     F .text	00000174 OSSemPendAbort
8110ef3c g     F .text	0000004c vFailGetMacRTC
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8110f7b4 g     F .text	0000004c vFailCreateTimerRetransmisison
8110f2c0 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
8110caec g     F .text	000002c0 bSendUART128v2
811104b0 g     F .text	0000019c vSimucamStructureInit
81141ac8 g     O .rwdata	00000008 alt_dev_list
81128d6c g     F .text	00000100 write
8113c180 g     F .text	000000a8 _putc_r
81141cf0 g     O .bss	00000004 device_pointer
81141b4c g     O .rwdata	00000002 OSVersionNbr
81125c84 g     F .text	000000bc .hidden __gtsf2
81109e8c g     F .text	00000118 getPreParsedPacket
81128008 g     F .text	000000b8 fstat
81110984 g     F .text	00000040 vChangeIdNFEEMaster
811126e0 g     F .text	0000002c fprintf
81110314 g     F .text	00000038 cFeeRMAPLogEnable
81102c18 g     F .text	00000110 DMA_SINGLE_TRANSFER
81104a6c g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
8110f900 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
81110c74 g     F .text	00000058 _reg_write
811109c4 g     F .text	00000034 vChangeDefaultIdNFEEMaster
81127110 g     F .text	000000f4 .hidden __ledf2
8110fbd8 g     F .text	00000068 vCouldNotSendLog
81132250 g     F .text	000001b8 OSTmrRemainGet
81141af4 g     O .rwdata	00000004 OSEndiannessTest
811073a4 g     F .text	00000058 v_spi_start
8111dca0 g     F .text	00000148 __pow5mult
8112261c g     F .text	00001464 ___vfiprintf_internal_r
81141c2c g     O .bss	00000004 __nlocale_changed
81125bb4 g     F .text	00000058 .hidden __umodsi3
81107f20 g     F .text	00000074 bSyncCtrSyncOutEnable
81110a98 g     F .text	000000f8 bInitializeSDCard
8110f6d0 g     F .text	0000004c vFailParserCommTaskCreate
81113db0 g     F .text	00000038 _scanf_r
8110f768 g     F .text	0000004c vFailOutAckHandlerTaskCreate
81141b06 g     O .rwdata	00000002 OSFlagGrpSize
8114e9b0 g     O .bss	00000038 xInUseRetrans
8113a1ac g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
81132408 g     F .text	000000ec OSTmrStateGet
81155930 g       *ABS*	00000000 end
811045d4 g     F .text	00000040 vFeebCh6HandleIrq
8110f460 g     F .text	00000068 vNoContentInPreParsedBuffer
81112b78 g     F .text	0000001c fseeko
81112590 g     F .text	0000000c _atoi_r
81138c8c g     F .text	00000240 altera_avalon_uart_write
81112710 g     F .text	0000001c fseek
8110ca5c g     F .text	00000090 vCCDChangeValues
81137614 g     F .text	00000150 altera_avalon_jtag_uart_init
8112ae48 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
8110eb9c g     F .text	0000004c vFailTestCriticasParts
8113c5dc g       *ABS*	00000000 __CTOR_LIST__
811fa000 g       *ABS*	00000000 __alt_stack_pointer
81101fb0 g     F .text	00000470 bDdr2MemoryRandomWriteTest
81138294 g     F .text	00000084 alt_avalon_timer_sc_init
81104efc g     F .text	000000a8 bFeebSetWindowing
81138380 g     F .text	00000068 altera_avalon_uart_write_fd
81112520 g     F .text	00000064 .hidden __clzsi2
811383e8 g     F .text	00000058 altera_avalon_uart_close_fd
81137f48 g     F .text	000002cc altera_avalon_jtag_uart_write
8113297c g     F .text	00000174 OSTmr_Init
8114e9e8 g     O .bss	00000118 xBuffer128
8111c1e0 g     F .text	00000004 __sfp_lock_acquire
811032f8 g     F .text	00000048 sense_log_temp
8111d3f8 g     F .text	000000e4 memchr
8112aaec g     F .text	0000005c OS_MemClr
81116574 g     F .text	00002200 ___vfprintf_internal_r
8113bd04 g     F .text	00000164 OSTaskStkInit
81113de8 g     F .text	00000060 _sprintf_r
81141be6 g     O .bss	00000001 SemCount32
8111c668 g     F .text	00000318 _free_r
8113b980 g     F .text	00000234 alt_printf
8110d884 g     F .text	00000050 vTimeoutCheck
81110d24 g     F .text	000001fc _print_codec_status
8111d0f8 g     F .text	00000010 __locale_mb_cur_max
8112a0fc g     F .text	000001a0 OS_EventTaskRdy
81102b74 g     F .text	000000a4 DMA_DISPATCHER_RESET
8113c418 g     F .text	00000188 __call_exitprocs
81141c8c g     O .bss	00000001 OSCPUUsage
81141c28 g     O .bss	00000004 __mlocale_changed
81107e78 g     F .text	00000054 bSyncCtrOneShot
81141aac g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	0000003c _start
811085f0 g     F .text	0000003c uliSyncReadStatus
81141c44 g     O .bss	00000004 _alt_tick_rate
8112eb70 g     F .text	00000294 OSQPend
8112061c g     F .text	000002e8 _strtoll_r
811318f4 g     F .text	0000010c OSTimeDly
8111dde8 g     F .text	00000150 __lshift
81109114 g     F .text	000002f8 vOutAckHandlerTask
81139c04 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
81141c48 g     O .bss	00000004 _alt_nticks
811287cc g     F .text	00000104 read
81132fd0 g     F .text	000000f0 alt_sys_init
8111191c g     F .text	0000012c .hidden __floatsisf
81120e54 g     F .text	000001d8 __ssprint_r
81113958 g     F .text	00000068 _open_r
81110c4c g     F .text	00000028 bTestSimucamCriticalHW
8110502c g     F .text	000000ac bFeebGetBuffersStatus
8110e968 g     F .text	000000a4 ucCrc8
811007ac g     F .text	00000cb4 bDdr2EepromDump
8113c2f8 g     F .text	00000120 __register_exitproc
81141c8d g     O .bss	00000001 OSTaskCtr
8110d834 g     F .text	00000050 siPosStr
81124aec g     F .text	000000d0 strncmp
81131a00 g     F .text	00000164 OSTimeDlyHMSM
8111daa0 g     F .text	00000200 __multiply
81137b1c g     F .text	00000070 altera_avalon_jtag_uart_close
81107574 g     F .text	00000058 v_spi_end
81110c0c g     F .text	00000040 cGetNextChar
81141d9c g     O .bss	00000028 __malloc_current_mallinfo
81141afa g     O .rwdata	00000002 OSEventMax
81125c0c g     F .text	00000078 .hidden __eqsf2
8111e314 g     F .text	00000154 __d2b
8112fdf0 g     F .text	00000118 OSSemPost
81104760 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
81110768 g     F .text	00000030 vChangeDefaultRTValue
81104654 g     F .text	00000040 vFeebCh8HandleIrq
81141cc8 g     O .bss	00000004 initialized
8110d6e4 g     F .text	00000100 vSendLog
81129c70 g     F .text	000000e4 OSSchedUnlock
811075cc g     F .text	00000164 RTCC_SPI_R_MAC
81137490 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
81120904 g     F .text	00000254 _strtoul_r
8113b484 g     F .text	000000e4 alt_get_fd
81141c90 g     O .bss	00000004 OSMemFreeList
81129dcc g     F .text	000000b8 OSStatInit
8110293c g     F .text	00000064 DMA_OPEN_DEVICE
811552c8 g     O .bss	00000014 search_data
8110517c g     F .text	00000100 bSpwcSetLink
81127d1c g     F .text	00000130 alt_busy_sleep
8112c78c g     F .text	000000cc OSFlagQuery
81107f94 g     F .text	00000074 bSyncCtrCh1OutEnable
81141b30 g     O .rwdata	00000002 OSTaskCreateExtEn
81110f20 g     F .text	00000074 _split_codec_status
8111a2bc g     F .text	0000005c _close_r
8110f4c8 g     F .text	00000068 vCouldNotSendEthConfUART
81108e0c g     F .text	00000308 vInitialTask
8113a0ec g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
8113c104 g     F .text	0000007c memcmp
8112a0d4 g     F .text	00000028 OS_Dummy
81137560 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
81155930 g       *ABS*	00000000 __alt_stack_base
811375b8 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
811047a4 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
81112bf8 g     F .text	000000d4 _fwrite_r
8113a20c g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
811048b4 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
8111a160 g     F .text	0000015c __swsetup_r
811525bc g     O .bss	000001e0 OSQTbl
8110ba14 g     F .text	000008e0 vTimeoutCheckerTask
81150c50 g     O .bss	0000001c xConfEth
811266bc g     F .text	000008f0 .hidden __divdf3
811107cc g     F .text	0000003c vChangeSyncSource
8111c098 g     F .text	00000120 __sfp
811552dc g     O .bss	00000054 boot_sector_data
81102a84 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8111e590 g     F .text	00000078 __copybits
8114023c g     O .rwdata	00000408 __malloc_av_
8111c1ec g     F .text	00000004 __sinit_lock_release
81141b6c g     O .bss	00000004 uliInitialState
81105dbc g     F .text	00000080 i2c_stop
81111038 g     F .text	00000064 Verif_Error
8111109c g     F .text	00000034 toInt
8110ece8 g     F .text	0000004c vFailSendPreAckSenderSemaphore
81141c94 g     O .bss	00000004 OSTCBHighRdy
81111b40 g     F .text	00000720 .hidden __muldf3
81113ebc g     F .text	0000005c __sread
8111c500 g     F .text	0000003c fread
81141c98 g     O .bss	00000004 OSQFreeList
8113b374 g     F .text	00000110 alt_find_file
8113b160 g     F .text	000000ac alt_dev_llist_insert
81128fa0 g     F .text	00000128 __malloc_lock
811126b0 g     F .text	00000030 _fprintf_r
8112893c g     F .text	000000fc sbrk
811101a0 g     F .text	0000002c vFeeSpwRMAPLoadDefault
8110f258 g     F .text	00000068 vFailGetCountSemaphorexBuffer64
81114394 g     F .text	000021e0 ___svfprintf_internal_r
8110dc24 g     F .text	00000088 vTMPusTestConnection
811292c4 g     F .text	00000148 OSEventNameSet
8111bdd4 g     F .text	00000064 _fflush_r
81123b60 g     F .text	000000cc _calloc_r
81141c9c g     O .bss	00000001 OSRdyGrp
811079c4 g     F .text	00000044 ucSyncStatusCycleNumber
811324f4 g     F .text	00000148 OSTmrStart
81104594 g     F .text	00000040 vFeebCh5HandleIrq
81112698 g     F .text	00000018 fopen
811029a0 g     F .text	0000004c DMA_CONFIG
81141b6c g       *ABS*	00000000 __bss_start
81113830 g     F .text	00000128 memset
8110a6c8 g     F .text	00000138 setPreParsedFreePos
8113ac68 g     F .text	00000060 alt_msgdma_open
8110c878 g     F .text	0000017c main
8110ee6c g     F .text	00000068 vFailGetMutexReceiverTask
81110684 g     F .text	0000003c vChangeEPValue
81141c40 g     O .bss	00000004 alt_envp
81141c18 g     O .bss	00000004 __malloc_max_total_mem
8113a50c g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8110ea0c g     F .text	00000074 ucCrc8wInit
8110f800 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
811374f8 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f38 g     F .text	000002c8 POWER_Read
81105f74 g     F .text	00000160 i2c_read
81124d04 g     F .text	00000018 __swbuf
8113fa3c g     O .rodata	00000100 OSUnMapTbl
81125d40 g     F .text	000000c8 .hidden __ltsf2
81136894 g     F .text	00000090 alt_up_sd_card_get_attributes
8111c2cc g     F .text	00000234 _fread_r
8110ed34 g     F .text	00000068 vFailGetCountSemaphoreSenderTask
81105768 g     F .text	0000003c bDisableIsoDrivers
81141b2a g     O .rwdata	00000002 OSSemEn
811330c0 g     F .text	000000bc Write_Sector_Data
81136ca4 g     F .text	00000628 alt_up_sd_card_write
8112c3f0 g     F .text	0000039c OSFlagPost
81114008 g     F .text	00000008 __sclose
8110fb08 g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
81123d24 g     F .text	00000014 fclose
8112a29c g     F .text	00000118 OS_EventTaskWait
8110f9d0 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
81114138 g     F .text	00000240 _strtol_r
81112378 g     F .text	000001a8 .hidden __truncdfsf2
8112af2c g     F .text	000000d4 OS_TaskStatStkChk
81130d0c g     F .text	00000158 OSTaskDelReq
8111a520 g     F .text	00001690 _dtoa_r
8113a828 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
81112ecc g     F .text	00000814 _malloc_r
81124e88 g     F .text	00000030 __ascii_wctomb
8112d588 g     F .text	000001d0 OSMutexCreate
8110f968 g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
81108cc8 g     F .text	00000144 bCheckInAck32
81141ad4 g     O .rwdata	00000004 alt_errno
8113a354 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
81129d54 g     F .text	00000078 OSStart
8110527c g     F .text	000000d0 bSpwcGetLink
81106cc8 g     F .text	000004e8 POWER_SPI_RW
81122270 g     F .text	000000dc __submore
81128f38 g     F .text	00000068 __env_unlock
8111ce44 g     F .text	000000cc _fwalk
811311c0 g     F .text	000001dc OSTaskResume
8112d218 g     F .text	000000f0 OSMemQuery
81141b3c g     O .rwdata	00000002 OSTaskStatEn
81155930 g       *ABS*	00000000 __alt_stack_limit
81141b84 g     O .bss	00000004 ECommSpwCh
811108e4 g     F .text	0000003c vChangeAutoResetSync
8111d394 g     F .text	00000064 _mbtowc_r
81108710 g     F .text	00000334 vInAckHandlerTaskV2
81141b16 g     O .rwdata	00000002 OSMemMax
8112f0e8 g     F .text	00000178 OSQPostFront
8113c228 g     F .text	000000d0 putc
81125a58 g     F .text	00000084 .hidden __divsi3
81141c9d g     O .bss	00000006 OSRdyTbl
81141af0 g     O .rwdata	00000002 OSDebugEn
8111c53c g     F .text	0000012c _malloc_trim_r
8113c5dc g       *ABS*	00000000 __CTOR_END__
81141c0c g     O .bss	00000008 xSdHandle
81111518 g     F .text	00000404 .hidden __mulsf3
81141b08 g     O .rwdata	00000002 OSFlagNodeSize
81141b70 g     O .bss	00000004 pnt_memory
811109f8 g     F .text	00000040 vSyncReset
81107a88 g     F .text	00000040 bSyncSetPer
81100298 g     F .text	00000514 bDdr2EepromTest
81141cd4 g     O .bss	00000004 status_register
81141b50 g     O .rwdata	00000002 OSTmrCfgMax
8110841c g     F .text	00000074 bSyncIrqFlagClrError
8110f598 g     F .text	00000068 vFailSetPreAckSenderBuffer
8111edb4 g     F .text	000000dc strcmp
81141cdc g     O .bss	00000004 command_register
8112e674 g     F .text	000001b4 OSQCreate
81130e64 g     F .text	000001a0 OSTaskNameGet
8114eb00 g     O .bss	00000010 xReceivedACK
8112f260 g     F .text	00000214 OSQPostOpt
81129e84 g     F .text	00000228 OSTimeTick
81141b38 g     O .rwdata	00000002 OSTaskMax
8113c5dc g       *ABS*	00000000 __DTOR_LIST__
8112f740 g     F .text	000000e0 OSSemCreate
81141b5c g     O .rwdata	00000002 OSTmrWheelSize
81110ccc g     F .text	00000058 _reg_read
8112e220 g     F .text	00000174 OSMutexQuery
81126fac g     F .text	00000088 .hidden __nedf2
81141b32 g     O .rwdata	00000002 OSTaskDelEn
8111064c g     F .text	00000038 vLoadDefaultEPValue
8110824c g     F .text	00000074 bSyncCtrCh7OutEnable
8112ff08 g     F .text	00000118 OSSemQuery
8112e828 g     F .text	00000288 OSQDel
8112ee04 g     F .text	00000174 OSQPendAbort
81141be8 g     O .bss	00000004 xMutexPreParsed
81132f90 g     F .text	00000040 alt_irq_init
811288d0 g     F .text	0000006c alt_release_fd
811332b0 g     F .text	000000bc get_cluster_flag
81108490 g     F .text	00000074 bSyncIrqFlagClrBlank
8113af60 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
81113e48 g     F .text	00000074 sprintf
8113f2f4 g     O .rodata	00000100 .hidden __clz_tab
81133884 g     F .text	00000294 Write_File_Record_At_Offset
81101520 g     F .text	00000580 bDdr2MemoryWriteTest
8110eed4 g     F .text	00000068 vFailGetMutexTxUARTSenderTask
81141c24 g     O .bss	00000004 _PathLocale
8110855c g     F .text	00000058 bSyncIrqFlagBlank
81106b80 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
8113263c g     F .text	000001e8 OSTmrStop
8110d7e4 g     F .text	00000050 usiGetIdCMD
81120514 g     F .text	00000108 strtof
8113c0b0 g     F .text	00000014 atexit
81104514 g     F .text	00000040 vFeebCh3HandleIrq
81125c84 g     F .text	000000bc .hidden __gesf2
81114010 g     F .text	0000004c strcspn
8111a0f8 g     F .text	00000068 _write_r
8110721c g     F .text	00000074 vRstcReleaseDeviceReset
8110f71c g     F .text	0000004c vFailInAckHandlerTaskCreate
81129bdc g     F .text	00000094 OSSchedLock
8111d128 g     F .text	00000018 setlocale
8113a2b4 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
8115279c g     O .bss	00000800 OSTmrTaskStk
81113d6c g     F .text	00000044 scanf
8112b7e4 g     F .text	00000110 OSFlagCreate
81133b18 g     F .text	00000688 Check_for_DOS_FAT
811359c4 g     F .text	000002d0 create_file
8111edac g     F .text	00000008 nanf
81141aa8 g     O .rwdata	00000004 _impure_ptr
81141cd8 g     O .bss	00000004 CSD_register_w0
81141c38 g     O .bss	00000004 alt_argc
8110f1f0 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
8111bbb0 g     F .text	00000224 __sflush_r
8111d1b4 g     F .text	000000b4 _mbrtowc_r
8113b274 g     F .text	00000068 _do_dtors
8111d114 g     F .text	00000008 __locale_cjk_lang
81103340 g     F .text	0000078c sense_log
81141b7c g     O .bss	00000004 ESdmaBufferSide
81141b02 g     O .rwdata	00000002 OSEventMultiEn
8111270c g     F .text	00000004 _fseek_r
8114eb10 g     O .bss	00002000 vParserCommTask_stk
8110ea80 g     F .text	00000070 printErrorTask
811106c0 g     F .text	00000030 vChangeDefaultEPValue
8110b788 g     F .text	0000028c vCheckRetransmission32
81131e0c g     F .text	000001c4 OSTmrCreate
81113b34 g     F .text	000001dc __srefill_r
811057a4 g     F .text	0000003c bEnableLvdsBoard
81141bec g     O .bss	00000004 xMutexBuffer32
8112b8f4 g     F .text	00000250 OSFlagDel
81141ca4 g     O .bss	00000004 OSEventFreeList
8110581c g     F .text	000000c0 bSetPreEmphasys
81100020 g       .exceptions	00000000 alt_irq_entry
8111d348 g     F .text	0000004c __ascii_mbtowc
81107d58 g     F .text	00000078 bSyncCtrExtnIrq
8111e19c g     F .text	00000064 __ulp
8112bdc8 g     F .text	000005c0 OSFlagPend
81141b4e g     O .rwdata	00000002 OSTmrEn
8111c208 g     F .text	00000018 __fp_unlock_all
8110d074 g     F .text	000002c8 bSendUART32v2
8110a97c g     F .text	0000019c setPreAckReceiverFreePos
81107d18 g     F .text	00000040 bSyncErrInj
81141ac0 g     O .rwdata	00000008 alt_fs_list
81134360 g     F .text	00000274 check_file_name_for_FAT16_compliance
81132110 g     F .text	00000140 OSTmrNameGet
81141ec4 g     O .bss	00000400 xSZData
8112ad0c g     F .text	0000007c OS_StrCopy
81141ce4 g     O .bss	00000004 buffer_memory
8110f3f8 g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
81110418 g     F .text	00000098 vLogWriteNUC
81141b18 g     O .rwdata	00000002 OSMemNameSize
81103acc g     F .text	000000b0 bSdmaInitM1Dma
811083a8 g     F .text	00000074 bSyncIrqEnableBlank
8113bf90 g     F .text	00000028 OSInitHookEnd
8110fe58 g     F .text	00000348 vUpdateMemMapFEE
8110f668 g     F .text	00000068 vFailSetPreAckReceiverBuffer
81104b1c g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
81141b44 g     O .rwdata	00000002 OSTCBPrioTblMax
8111d140 g     F .text	0000000c localeconv
81141bf0 g     O .bss	00000004 xTimerRetransmission
8110a044 g     F .text	00000250 vReceiverUartTask
81141b40 g     O .rwdata	00000002 OSTaskStatStkChkEn
81141bf4 g     O .bss	00000004 xMutexBuffer128
81104494 g     F .text	00000040 vFeebCh1HandleIrq
81104614 g     F .text	00000040 vFeebCh7HandleIrq
8113b568 g     F .text	00000058 alt_ic_isr_register
81141b14 g     O .rwdata	00000002 OSMemEn
81141a94 g     O .rwdata	00000004 alt_stack_limit_value
81112ccc g     F .text	0000003c fwrite
81141ce8 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
81141b1e g     O .rwdata	00000002 OSMutexEn
81141b6c g       *ABS*	00000000 _edata
81138318 g     F .text	00000068 altera_avalon_uart_read_fd
81110950 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81155930 g       *ABS*	00000000 _end
81155330 g     O .bss	00000500 active_files
81141ca8 g     O .bss	00000001 OSIntNesting
8110ef88 g     F .text	0000004c vFailInitialization
81101460 g     F .text	000000c0 bDdr2SwitchMemory
8111027c g     F .text	0000002c cFeeRMAPDump
81141bf8 g     O .bss	00000004 xSemCountBuffer32
81123d38 g     F .text	0000016c __fputwc
811101cc g     F .text	0000002c vFeeSpwRMAPChangeConfig
8111a018 g     F .text	00000070 vfscanf
81135c94 g     F .text	00000150 copy_file_record_name_to_string
81137b8c g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
81131b64 g     F .text	000001dc OSTimeDlyResume
811341a0 g     F .text	000000f4 Look_for_FAT16
8112bc74 g     F .text	00000154 OSFlagNameSet
81141bfc g     O .bss	00000004 xMutexBuffer64
8113139c g     F .text	000001c8 OSTaskStkChk
8113b650 g     F .text	00000094 alt_ic_irq_disable
81103c2c g     F .text	00000430 bSdmaDmaM1Transfer
81141b1a g     O .rwdata	00000002 OSMemSize
8110f0b8 g     F .text	00000068 vFailSetCountSemaphorexBuffer32
81113f20 g     F .text	00000084 __swrite
81141ab0 g     O .rwdata	00000004 __malloc_trim_threshold
8111d108 g     F .text	0000000c __locale_msgcharset
81141cac g     O .bss	00000004 OSTCBCur
8110fa38 g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
81106c84 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
8113c0c4 g     F .text	00000040 exit
8112e000 g     F .text	00000220 OSMutexPost
81108504 g     F .text	00000058 bSyncIrqFlagError
811360c0 g     F .text	000003c0 alt_up_sd_card_find_next
81141b1c g     O .rwdata	00000002 OSMemTblSize
8111cf10 g     F .text	000000cc _fwalk_reent
8113a6ac g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
81111a48 g     F .text	000000f8 .hidden __floatunsisf
8111df98 g     F .text	00000204 __mdiff
81104b74 g     F .text	00000180 vFeebInitIrq
8110f020 g     F .text	0000004c vFailSenderCreate
81125adc g     F .text	00000074 .hidden __modsi3
81107c64 g     F .text	0000003c uliSyncGetPer
81141c00 g     O .bss	00000004 xMutexSenderACK
8110f898 g     F .text	00000068 vFailGetBlockingSemTimeoutTask
81141aa0 g     O .rwdata	00000004 __ctype_ptr__
8110f600 g     F .text	00000068 vFailSetPreParsedBuffer
811331d0 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8111c1e4 g     F .text	00000004 __sfp_lock_release
81104dc8 g     F .text	000000ac bFeebGetIrqControl
8110fb70 g     F .text	00000068 vCouldNotSendTurnOff
81129a24 g     F .text	00000064 OSInit
81106154 g     F .text	00000078 bSetPainelLeds
81139df4 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
81141cb0 g     O .bss	00000004 OSTmrTime
81101aa0 g     F .text	00000510 bDdr2MemoryReadTest
81131750 g     F .text	0000012c OSTaskQuery
81108334 g     F .text	00000074 bSyncIrqEnableError
8112f5d8 g     F .text	000000b0 OS_QInit
8111ecdc g     F .text	000000d0 __sccl
81112584 g     F .text	0000000c atoi
811086e0 g     F .text	00000030 vFeeTask
8112ad88 g     F .text	0000005c OS_StrLen
8110490c g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8112d01c g     F .text	0000011c OSMemNameSet
8113f3f4 g     O .rodata	00000101 _ctype_
81107c28 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8110f188 g     F .text	00000068 vFailSetCountSemaphorexBuffer128
81141b36 g     O .rwdata	00000002 OSTaskProfileEn
81139cc4 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
81141c04 g     O .bss	00000004 xTxUARTMutex
81141cb4 g     O .bss	00000004 OSTime
81141ab8 g     O .rwdata	00000004 __mbtowc
81138938 g     F .text	0000005c altera_avalon_uart_close
81141cb8 g     O .bss	00000004 OSTmrSem
81152f9c g     O .bss	00000800 OSTaskIdleStk
8111259c g     F .text	000000fc _fopen_r
81141bbc g     O .bss	00000004 pdata
8113c5a0 g     F .text	0000003c _exit
8113afe8 g     F .text	00000134 alt_alarm_start
8112bb44 g     F .text	00000130 OSFlagNameGet
81131d40 g     F .text	00000064 OSTimeGet
81141b80 g     O .bss	00000004 ESdmaChBufferId
81136924 g     F .text	00000380 alt_up_sd_card_read
81112d08 g     F .text	000001c4 __smakebuf_r
81141c08 g     O .bss	00000001 SemCount64
8110cdac g     F .text	000002c8 bSendUART64v2
811049bc g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
81141b64 g     O .rwdata	00000008 alt_msgdma_list
8111405c g     F .text	00000098 strlen
811074c0 g     F .text	000000b4 uc_spi_get_byte
8113bec0 g     F .text	00000028 OSTaskSwHook
8112862c g     F .text	0000015c open
8115379c g     O .bss	00000c30 OSEventTbl
811101f8 g     F .text	0000002c vFeeSpwRMAPChangeDefault
81127034 g     F .text	000000dc .hidden __gedf2
81150b10 g     O .bss	00000010 xSenderACK
8113bbb4 g     F .text	00000044 alt_putchar
811543cc g     O .bss	00000e58 OSTCBTbl
81124050 g     F .text	00000838 __gethex
81130020 g     F .text	00000108 OSSemSet
8110b04c g     F .text	0000006c vTimeoutCheckerTaskv2
811102a8 g     F .text	00000038 cFeeRMAPEchoingEnable
81141abc g     O .rwdata	00000004 __wctomb
8110c5e4 g     F .text	00000294 vVariablesInitialization
81122604 g     F .text	00000018 __sprint_r
81104e74 g     F .text	00000088 bFeebGetIrqFlags
81141b78 g     O .bss	00000004 pxDmaM2Dev
8110eb50 g     F .text	0000004c vFailCreateSemaphoreResources
81141ad8 g     O .rwdata	00000004 alt_priority_mask
811057e0 g     F .text	0000003c bDisableLvdsBoard
8112f820 g     F .text	00000248 OSSemDel
81141cbc g     O .bss	00000004 OSFlagFreeList
811073fc g     F .text	000000c4 v_spi_send_byte
81107730 g     F .text	000000d0 bSSDisplayConfig
8113b5c0 g     F .text	00000090 alt_ic_irq_enable
81141afc g     O .rwdata	00000002 OSEventNameSize
81118774 g     F .text	0000001c __vfprintf_internal
81141cc0 g     O .bss	00000001 OSStatRdy
81108008 g     F .text	00000074 bSyncCtrCh2OutEnable
81155224 g     O .bss	000000a4 OSTCBPrioTbl
811389d8 g     F .text	00000270 altera_avalon_uart_read
81124eb8 g     F .text	00000064 _wctomb_r
81128e6c g     F .text	000000cc __env_lock
81141b42 g     O .rwdata	00000002 OSTaskSwHookEn
8110471c g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
81127204 g     F .text	00000904 .hidden __subdf3
81150b20 g     O .bss	00000130 xPreParsed
81107ca0 g     F .text	0000003c uliSyncGetOst
81141c09 g     O .bss	00000001 SemCount128
811047e8 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
8110d33c g     F .text	00000290 vSendEthConf
8111d9ac g     F .text	000000b0 __lo0bits
81118854 g     F .text	000017c4 __svfscanf_r
81141ae0 g     O .rwdata	00000008 alt_alarm_list
8112234c g     F .text	0000019c _ungetc_r
81141b0a g     O .rwdata	00000002 OSFlagWidth
8113b20c g     F .text	00000068 _do_ctors
811029ec g     F .text	0000004c DMA_BUSY
81124dc0 g     F .text	000000c8 wcrtomb
8110c9f4 g     F .text	00000068 vCCDLoadDefaultValues
81127e90 g     F .text	000000d8 close
81107cdc g     F .text	0000003c uliSyncGetGeneral
81141c50 g     O .bss	00000004 alt_envsem
81141cc4 g     O .bss	00000004 OSIdleCtrRun
8112a0ac g     F .text	00000028 OSVersion
81141b54 g     O .rwdata	00000002 OSTmrCfgWheelSize
8113187c g     F .text	00000078 OS_TaskStkClr
81110b90 g     F .text	0000003c siOpenFile
81141b2e g     O .rwdata	00000002 OSTaskCreateEn
8110d5cc g     F .text	00000118 vSendTurnOff
8110ec50 g     F .text	0000004c vFailSendPreParsedSemaphore
81134694 g     F .text	000002a4 match_file_record_to_name_ext
8112a6d4 g     F .text	00000070 OS_EventWaitListInit
81123ec8 g     F .text	00000088 fputwc
8110ebe8 g     F .text	00000068 vFailSendxSemCommInit
8113bfb8 g     F .text	00000028 OSTaskIdleHook
8111c1e8 g     F .text	00000004 __sinit_lock_acquire
8111d710 g     F .text	00000128 __multadd
8110482c g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110792c g     F .text	0000004c ucSyncStatusState
81131564 g     F .text	000001ec OSTaskSuspend
8111d6e8 g     F .text	00000028 _Bfree
81107bec g     F .text	0000003c uliSyncGetMbt
8112ade4 g     F .text	00000064 OS_TaskIdle
81141b5a g     O .rwdata	00000002 OSTmrTblSize
8112f474 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	1129a880 	call	81129a88 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a04574 	movhi	r2,33045
81100150:	10960c04 	addi	r2,r2,22576
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a04574 	movhi	r2,33045
81100168:	10960c04 	addi	r2,r2,22576
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	1129adc0 	call	81129adc <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a09b17 	ldw	r2,-32148(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a09b17 	ldw	r2,-32148(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
8110025c:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100260:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
81100264:	06a04534 	movhi	gp,33044
    ori gp, gp, %lo(_gp)
81100268:	d6a6a514 	ori	gp,gp,39572
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
8110026c:	00a04534 	movhi	r2,33044
    ori r2, r2, %lo(__bss_start)
81100270:	1086db14 	ori	r2,r2,7020

    movhi r3, %hi(__bss_end)
81100274:	00e04574 	movhi	r3,33045
    ori r3, r3, %lo(__bss_end)
81100278:	18d64c14 	ori	r3,r3,22832

    beq r2, r3, 1f
8110027c:	10c00326 	beq	r2,r3,8110028c <_start+0x30>

0:
    stw zero, (r2)
81100280:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
81100284:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
81100288:	10fffd36 	bltu	r2,r3,81100280 <__reset+0xfb0e0280>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
8110028c:	d6200017 	ldw	et,-32768(gp)

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
81100290:	11284580 	call	81128458 <alt_main>

81100294 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100294:	003fff06 	br	81100294 <__reset+0xfb0e0294>

81100298 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mémoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100298:	defff604 	addi	sp,sp,-40
8110029c:	de00012e 	bgeu	sp,et,811002a4 <bDdr2EepromTest+0xc>
811002a0:	003b68fa 	trap	3
811002a4:	dfc00915 	stw	ra,36(sp)
811002a8:	df000815 	stw	fp,32(sp)
811002ac:	df000804 	addi	fp,sp,32
811002b0:	2005883a 	mov	r2,r4
811002b4:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
811002b8:	00e04534 	movhi	r3,33044
811002bc:	18c77104 	addi	r3,r3,7620
811002c0:	00a04534 	movhi	r2,33044
811002c4:	10b17704 	addi	r2,r2,-14884
811002c8:	1009883a 	mov	r4,r2
811002cc:	00800884 	movi	r2,34
811002d0:	100d883a 	mov	r6,r2
811002d4:	200b883a 	mov	r5,r4
811002d8:	1809883a 	mov	r4,r3
811002dc:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
811002e0:	d0a04e17 	ldw	r2,-32456(gp)
811002e4:	01604534 	movhi	r5,33044
811002e8:	29477104 	addi	r5,r5,7620
811002ec:	1009883a 	mov	r4,r2
811002f0:	11126e00 	call	811126e0 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
811002f4:	00bfe804 	movi	r2,-96
811002f8:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
811002fc:	00800044 	movi	r2,1
81100300:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100304:	e0bfff03 	ldbu	r2,-4(fp)
81100308:	10c00060 	cmpeqi	r3,r2,1
8110030c:	1800031e 	bne	r3,zero,8110031c <bDdr2EepromTest+0x84>
81100310:	108000a0 	cmpeqi	r2,r2,2
81100314:	1000081e 	bne	r2,zero,81100338 <bDdr2EepromTest+0xa0>
81100318:	00000e06 	br	81100354 <bDdr2EepromTest+0xbc>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
8110031c:	00a00034 	movhi	r2,32768
81100320:	10827c04 	addi	r2,r2,2544
81100324:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100328:	00a00034 	movhi	r2,32768
8110032c:	10828004 	addi	r2,r2,2560
81100330:	e0bffb15 	stw	r2,-20(fp)
		break;
81100334:	00001906 	br	8110039c <bDdr2EepromTest+0x104>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
81100338:	00a00034 	movhi	r2,32768
8110033c:	10825804 	addi	r2,r2,2400
81100340:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
81100344:	00a00034 	movhi	r2,32768
81100348:	10825c04 	addi	r2,r2,2416
8110034c:	e0bffb15 	stw	r2,-20(fp)
		break;
81100350:	00001206 	br	8110039c <bDdr2EepromTest+0x104>
	default:
		bSuccess = FALSE;
81100354:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81100358:	00e04534 	movhi	r3,33044
8110035c:	18c77104 	addi	r3,r3,7620
81100360:	00a04534 	movhi	r2,33044
81100364:	10b18004 	addi	r2,r2,-14848
81100368:	1009883a 	mov	r4,r2
8110036c:	00800bc4 	movi	r2,47
81100370:	100d883a 	mov	r6,r2
81100374:	200b883a 	mov	r5,r4
81100378:	1809883a 	mov	r4,r3
8110037c:	11136e00 	call	811136e0 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81100380:	d0a04e17 	ldw	r2,-32456(gp)
81100384:	01604534 	movhi	r5,33044
81100388:	29477104 	addi	r5,r5,7620
8110038c:	1009883a 	mov	r4,r2
81100390:	11126e00 	call	811126e0 <fprintf>
		;
#endif
		return bSuccess;
81100394:	e0bff917 	ldw	r2,-28(fp)
81100398:	0000ff06 	br	81100798 <bDdr2EepromTest+0x500>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
8110039c:	00e04534 	movhi	r3,33044
811003a0:	18c77104 	addi	r3,r3,7620
811003a4:	00a04534 	movhi	r2,33044
811003a8:	10b18c04 	addi	r2,r2,-14800
811003ac:	1009883a 	mov	r4,r2
811003b0:	008005c4 	movi	r2,23
811003b4:	100d883a 	mov	r6,r2
811003b8:	200b883a 	mov	r5,r4
811003bc:	1809883a 	mov	r4,r3
811003c0:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
811003c4:	d0a04e17 	ldw	r2,-32456(gp)
811003c8:	01604534 	movhi	r5,33044
811003cc:	29477104 	addi	r5,r5,7620
811003d0:	1009883a 	mov	r4,r2
811003d4:	11126e00 	call	811126e0 <fprintf>
#endif
	usleep(20 * 1000);
811003d8:	01138804 	movi	r4,20000
811003dc:	1128bec0 	call	81128bec <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
811003e0:	e03ffc15 	stw	zero,-16(fp)
811003e4:	00003306 	br	811004b4 <bDdr2EepromTest+0x21c>
		ucControlAddr = iI;
811003e8:	e0bffc17 	ldw	r2,-16(fp)
811003ec:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
811003f0:	e0bffd03 	ldbu	r2,-12(fp)
811003f4:	10c03fcc 	andi	r3,r2,255
811003f8:	18c0201c 	xori	r3,r3,128
811003fc:	18ffe004 	addi	r3,r3,-128
81100400:	e13ffd43 	ldbu	r4,-11(fp)
81100404:	e0bffe04 	addi	r2,fp,-8
81100408:	d8800015 	stw	r2,0(sp)
8110040c:	200f883a 	mov	r7,r4
81100410:	180d883a 	mov	r6,r3
81100414:	e17ffb17 	ldw	r5,-20(fp)
81100418:	e13ffa17 	ldw	r4,-24(fp)
8110041c:	1105ac00 	call	81105ac0 <I2C_Read>
81100420:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100424:	e0bff917 	ldw	r2,-28(fp)
81100428:	10001026 	beq	r2,zero,8110046c <bDdr2EepromTest+0x1d4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
8110042c:	e0bffd43 	ldbu	r2,-11(fp)
81100430:	e0fffe03 	ldbu	r3,-8(fp)
81100434:	18c03fcc 	andi	r3,r3,255
81100438:	180f883a 	mov	r7,r3
8110043c:	100d883a 	mov	r6,r2
81100440:	01604534 	movhi	r5,33044
81100444:	29719204 	addi	r5,r5,-14776
81100448:	01204534 	movhi	r4,33044
8110044c:	21077104 	addi	r4,r4,7620
81100450:	1113e480 	call	81113e48 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
81100454:	d0a04e17 	ldw	r2,-32456(gp)
81100458:	01604534 	movhi	r5,33044
8110045c:	29477104 	addi	r5,r5,7620
81100460:	1009883a 	mov	r4,r2
81100464:	11126e00 	call	811126e0 <fprintf>
81100468:	00000f06 	br	811004a8 <bDdr2EepromTest+0x210>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
8110046c:	00e04534 	movhi	r3,33044
81100470:	18c77104 	addi	r3,r3,7620
81100474:	00a04534 	movhi	r2,33044
81100478:	10b19704 	addi	r2,r2,-14756
8110047c:	1009883a 	mov	r4,r2
81100480:	008005c4 	movi	r2,23
81100484:	100d883a 	mov	r6,r2
81100488:	200b883a 	mov	r5,r4
8110048c:	1809883a 	mov	r4,r3
81100490:	11136e00 	call	811136e0 <memcpy>
			debug(fp, cDebugBuffer);
81100494:	d0a04e17 	ldw	r2,-32456(gp)
81100498:	01604534 	movhi	r5,33044
8110049c:	29477104 	addi	r5,r5,7620
811004a0:	1009883a 	mov	r4,r2
811004a4:	11126e00 	call	811126e0 <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
811004a8:	e0bffc17 	ldw	r2,-16(fp)
811004ac:	10800044 	addi	r2,r2,1
811004b0:	e0bffc15 	stw	r2,-16(fp)
811004b4:	e0bffc17 	ldw	r2,-16(fp)
811004b8:	10804008 	cmpgei	r2,r2,256
811004bc:	1000021e 	bne	r2,zero,811004c8 <bDdr2EepromTest+0x230>
811004c0:	e0bff917 	ldw	r2,-28(fp)
811004c4:	103fc81e 	bne	r2,zero,811003e8 <__reset+0xfb0e03e8>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
811004c8:	e0bff917 	ldw	r2,-28(fp)
811004cc:	10001026 	beq	r2,zero,81100510 <bDdr2EepromTest+0x278>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
811004d0:	00e04534 	movhi	r3,33044
811004d4:	18c77104 	addi	r3,r3,7620
811004d8:	00a04534 	movhi	r2,33044
811004dc:	10b19d04 	addi	r2,r2,-14732
811004e0:	1009883a 	mov	r4,r2
811004e4:	00800884 	movi	r2,34
811004e8:	100d883a 	mov	r6,r2
811004ec:	200b883a 	mov	r5,r4
811004f0:	1809883a 	mov	r4,r3
811004f4:	11136e00 	call	811136e0 <memcpy>
		debug(fp, cDebugBuffer);
811004f8:	d0a04e17 	ldw	r2,-32456(gp)
811004fc:	01604534 	movhi	r5,33044
81100500:	29477104 	addi	r5,r5,7620
81100504:	1009883a 	mov	r4,r2
81100508:	11126e00 	call	811126e0 <fprintf>
8110050c:	00000f06 	br	8110054c <bDdr2EepromTest+0x2b4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
81100510:	00e04534 	movhi	r3,33044
81100514:	18c77104 	addi	r3,r3,7620
81100518:	00a04534 	movhi	r2,33044
8110051c:	10b1a604 	addi	r2,r2,-14696
81100520:	1009883a 	mov	r4,r2
81100524:	008007c4 	movi	r2,31
81100528:	100d883a 	mov	r6,r2
8110052c:	200b883a 	mov	r5,r4
81100530:	1809883a 	mov	r4,r3
81100534:	11136e00 	call	811136e0 <memcpy>
		debug(fp, cDebugBuffer);
81100538:	d0a04e17 	ldw	r2,-32456(gp)
8110053c:	01604534 	movhi	r5,33044
81100540:	29477104 	addi	r5,r5,7620
81100544:	1009883a 	mov	r4,r2
81100548:	11126e00 	call	811126e0 <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
8110054c:	00e04534 	movhi	r3,33044
81100550:	18c77104 	addi	r3,r3,7620
81100554:	00a04534 	movhi	r2,33044
81100558:	10b1ae04 	addi	r2,r2,-14664
8110055c:	1009883a 	mov	r4,r2
81100560:	00800604 	movi	r2,24
81100564:	100d883a 	mov	r6,r2
81100568:	200b883a 	mov	r5,r4
8110056c:	1809883a 	mov	r4,r3
81100570:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
81100574:	d0a04e17 	ldw	r2,-32456(gp)
81100578:	01604534 	movhi	r5,33044
8110057c:	29477104 	addi	r5,r5,7620
81100580:	1009883a 	mov	r4,r2
81100584:	11126e00 	call	811126e0 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
81100588:	00800484 	movi	r2,18
8110058c:	e0bffd85 	stb	r2,-10(fp)
81100590:	00bfe004 	movi	r2,-128
81100594:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100598:	01138804 	movi	r4,20000
8110059c:	1128bec0 	call	81128bec <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
811005a0:	e0bffd03 	ldbu	r2,-12(fp)
811005a4:	10c03fcc 	andi	r3,r2,255
811005a8:	18c0201c 	xori	r3,r3,128
811005ac:	18ffe004 	addi	r3,r3,-128
811005b0:	e13ffdc3 	ldbu	r4,-9(fp)
811005b4:	e0bffd83 	ldbu	r2,-10(fp)
811005b8:	d8800015 	stw	r2,0(sp)
811005bc:	200f883a 	mov	r7,r4
811005c0:	180d883a 	mov	r6,r3
811005c4:	e17ffb17 	ldw	r5,-20(fp)
811005c8:	e13ffa17 	ldw	r4,-24(fp)
811005cc:	11059e00 	call	811059e0 <I2C_Write>
811005d0:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
811005d4:	e0bff917 	ldw	r2,-28(fp)
811005d8:	1000101e 	bne	r2,zero,8110061c <bDdr2EepromTest+0x384>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
811005dc:	00e04534 	movhi	r3,33044
811005e0:	18c77104 	addi	r3,r3,7620
811005e4:	00a04534 	movhi	r2,33044
811005e8:	10b1b404 	addi	r2,r2,-14640
811005ec:	1009883a 	mov	r4,r2
811005f0:	00800604 	movi	r2,24
811005f4:	100d883a 	mov	r6,r2
811005f8:	200b883a 	mov	r5,r4
811005fc:	1809883a 	mov	r4,r3
81100600:	11136e00 	call	811136e0 <memcpy>
		debug(fp, cDebugBuffer);
81100604:	d0a04e17 	ldw	r2,-32456(gp)
81100608:	01604534 	movhi	r5,33044
8110060c:	29477104 	addi	r5,r5,7620
81100610:	1009883a 	mov	r4,r2
81100614:	11126e00 	call	811126e0 <fprintf>
81100618:	00003306 	br	811006e8 <bDdr2EepromTest+0x450>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110061c:	e0bffd03 	ldbu	r2,-12(fp)
81100620:	10c03fcc 	andi	r3,r2,255
81100624:	18c0201c 	xori	r3,r3,128
81100628:	18ffe004 	addi	r3,r3,-128
8110062c:	e13ffdc3 	ldbu	r4,-9(fp)
81100630:	e0bffe44 	addi	r2,fp,-7
81100634:	d8800015 	stw	r2,0(sp)
81100638:	200f883a 	mov	r7,r4
8110063c:	180d883a 	mov	r6,r3
81100640:	e17ffb17 	ldw	r5,-20(fp)
81100644:	e13ffa17 	ldw	r4,-24(fp)
81100648:	1105ac00 	call	81105ac0 <I2C_Read>
8110064c:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
81100650:	e0bff917 	ldw	r2,-28(fp)
81100654:	1000101e 	bne	r2,zero,81100698 <bDdr2EepromTest+0x400>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
81100658:	00e04534 	movhi	r3,33044
8110065c:	18c77104 	addi	r3,r3,7620
81100660:	00a04534 	movhi	r2,33044
81100664:	10b1ba04 	addi	r2,r2,-14616
81100668:	1009883a 	mov	r4,r2
8110066c:	00800884 	movi	r2,34
81100670:	100d883a 	mov	r6,r2
81100674:	200b883a 	mov	r5,r4
81100678:	1809883a 	mov	r4,r3
8110067c:	11136e00 	call	811136e0 <memcpy>
			debug(fp, cDebugBuffer);
81100680:	d0a04e17 	ldw	r2,-32456(gp)
81100684:	01604534 	movhi	r5,33044
81100688:	29477104 	addi	r5,r5,7620
8110068c:	1009883a 	mov	r4,r2
81100690:	11126e00 	call	811126e0 <fprintf>
81100694:	00001406 	br	811006e8 <bDdr2EepromTest+0x450>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100698:	e0bffe43 	ldbu	r2,-7(fp)
8110069c:	10c03fcc 	andi	r3,r2,255
811006a0:	e0bffd83 	ldbu	r2,-10(fp)
811006a4:	18801026 	beq	r3,r2,811006e8 <bDdr2EepromTest+0x450>
				bSuccess = FALSE;
811006a8:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811006ac:	e0bffe43 	ldbu	r2,-7(fp)
811006b0:	10803fcc 	andi	r2,r2,255
811006b4:	e0fffd83 	ldbu	r3,-10(fp)
811006b8:	180f883a 	mov	r7,r3
811006bc:	100d883a 	mov	r6,r2
811006c0:	01604534 	movhi	r5,33044
811006c4:	2971c304 	addi	r5,r5,-14580
811006c8:	01204534 	movhi	r4,33044
811006cc:	21077104 	addi	r4,r4,7620
811006d0:	1113e480 	call	81113e48 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
811006d4:	d0a04e17 	ldw	r2,-32456(gp)
811006d8:	01604534 	movhi	r5,33044
811006dc:	29477104 	addi	r5,r5,7620
811006e0:	1009883a 	mov	r4,r2
811006e4:	11126e00 	call	811126e0 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
811006e8:	e0bff917 	ldw	r2,-28(fp)
811006ec:	10001026 	beq	r2,zero,81100730 <bDdr2EepromTest+0x498>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
811006f0:	00e04534 	movhi	r3,33044
811006f4:	18c77104 	addi	r3,r3,7620
811006f8:	00a04534 	movhi	r2,33044
811006fc:	10b1d204 	addi	r2,r2,-14520
81100700:	1009883a 	mov	r4,r2
81100704:	008008c4 	movi	r2,35
81100708:	100d883a 	mov	r6,r2
8110070c:	200b883a 	mov	r5,r4
81100710:	1809883a 	mov	r4,r3
81100714:	11136e00 	call	811136e0 <memcpy>
		debug(fp, cDebugBuffer);
81100718:	d0a04e17 	ldw	r2,-32456(gp)
8110071c:	01604534 	movhi	r5,33044
81100720:	29477104 	addi	r5,r5,7620
81100724:	1009883a 	mov	r4,r2
81100728:	11126e00 	call	811126e0 <fprintf>
8110072c:	00000f06 	br	8110076c <bDdr2EepromTest+0x4d4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
81100730:	00e04534 	movhi	r3,33044
81100734:	18c77104 	addi	r3,r3,7620
81100738:	00a04534 	movhi	r2,33044
8110073c:	10b1db04 	addi	r2,r2,-14484
81100740:	1009883a 	mov	r4,r2
81100744:	00800804 	movi	r2,32
81100748:	100d883a 	mov	r6,r2
8110074c:	200b883a 	mov	r5,r4
81100750:	1809883a 	mov	r4,r3
81100754:	11136e00 	call	811136e0 <memcpy>
		debug(fp, cDebugBuffer);
81100758:	d0a04e17 	ldw	r2,-32456(gp)
8110075c:	01604534 	movhi	r5,33044
81100760:	29477104 	addi	r5,r5,7620
81100764:	1009883a 	mov	r4,r2
81100768:	11126e00 	call	811126e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
8110076c:	00a04534 	movhi	r2,33044
81100770:	10877104 	addi	r2,r2,7620
81100774:	00c00284 	movi	r3,10
81100778:	10c00005 	stb	r3,0(r2)
8110077c:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81100780:	d0a04e17 	ldw	r2,-32456(gp)
81100784:	01604534 	movhi	r5,33044
81100788:	29477104 	addi	r5,r5,7620
8110078c:	1009883a 	mov	r4,r2
81100790:	11126e00 	call	811126e0 <fprintf>
#endif

	return bSuccess;
81100794:	e0bff917 	ldw	r2,-28(fp)
}
81100798:	e037883a 	mov	sp,fp
8110079c:	dfc00117 	ldw	ra,4(sp)
811007a0:	df000017 	ldw	fp,0(sp)
811007a4:	dec00204 	addi	sp,sp,8
811007a8:	f800283a 	ret

811007ac <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mémoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
811007ac:	deffb704 	addi	sp,sp,-292
811007b0:	de00012e 	bgeu	sp,et,811007b8 <bDdr2EepromDump+0xc>
811007b4:	003b68fa 	trap	3
811007b8:	dfc04815 	stw	ra,288(sp)
811007bc:	df004715 	stw	fp,284(sp)
811007c0:	df004704 	addi	fp,sp,284
811007c4:	2005883a 	mov	r2,r4
811007c8:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
811007cc:	00e04534 	movhi	r3,33044
811007d0:	18c77104 	addi	r3,r3,7620
811007d4:	00a04534 	movhi	r2,33044
811007d8:	10b1e304 	addi	r2,r2,-14452
811007dc:	1009883a 	mov	r4,r2
811007e0:	00800884 	movi	r2,34
811007e4:	100d883a 	mov	r6,r2
811007e8:	200b883a 	mov	r5,r4
811007ec:	1809883a 	mov	r4,r3
811007f0:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
811007f4:	d0a04e17 	ldw	r2,-32456(gp)
811007f8:	01604534 	movhi	r5,33044
811007fc:	29477104 	addi	r5,r5,7620
81100800:	1009883a 	mov	r4,r2
81100804:	11126e00 	call	811126e0 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100808:	00bfe804 	movi	r2,-96
8110080c:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
81100810:	00800044 	movi	r2,1
81100814:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100818:	e0bfff03 	ldbu	r2,-4(fp)
8110081c:	10c00060 	cmpeqi	r3,r2,1
81100820:	1800031e 	bne	r3,zero,81100830 <bDdr2EepromDump+0x84>
81100824:	108000a0 	cmpeqi	r2,r2,2
81100828:	1000081e 	bne	r2,zero,8110084c <bDdr2EepromDump+0xa0>
8110082c:	00000e06 	br	81100868 <bDdr2EepromDump+0xbc>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100830:	00a00034 	movhi	r2,32768
81100834:	10827c04 	addi	r2,r2,2544
81100838:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
8110083c:	00a00034 	movhi	r2,32768
81100840:	10828004 	addi	r2,r2,2560
81100844:	e0bfbb15 	stw	r2,-276(fp)
		break;
81100848:	00001906 	br	811008b0 <bDdr2EepromDump+0x104>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
8110084c:	00a00034 	movhi	r2,32768
81100850:	10825804 	addi	r2,r2,2400
81100854:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
81100858:	00a00034 	movhi	r2,32768
8110085c:	10825c04 	addi	r2,r2,2416
81100860:	e0bfbb15 	stw	r2,-276(fp)
		break;
81100864:	00001206 	br	811008b0 <bDdr2EepromDump+0x104>
	default:
		bSuccess = FALSE;
81100868:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
8110086c:	00e04534 	movhi	r3,33044
81100870:	18c77104 	addi	r3,r3,7620
81100874:	00a04534 	movhi	r2,33044
81100878:	10b1ec04 	addi	r2,r2,-14416
8110087c:	1009883a 	mov	r4,r2
81100880:	00800bc4 	movi	r2,47
81100884:	100d883a 	mov	r6,r2
81100888:	200b883a 	mov	r5,r4
8110088c:	1809883a 	mov	r4,r3
81100890:	11136e00 	call	811136e0 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
81100894:	d0a04e17 	ldw	r2,-32456(gp)
81100898:	01604534 	movhi	r5,33044
8110089c:	29477104 	addi	r5,r5,7620
811008a0:	1009883a 	mov	r4,r2
811008a4:	11126e00 	call	811126e0 <fprintf>
		;
#endif
		return bSuccess;
811008a8:	e0bfbe17 	ldw	r2,-264(fp)
811008ac:	0002e706 	br	8110144c <bDdr2EepromDump+0xca0>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
811008b0:	e0bfbd03 	ldbu	r2,-268(fp)
811008b4:	10c03fcc 	andi	r3,r2,255
811008b8:	18c0201c 	xori	r3,r3,128
811008bc:	18ffe004 	addi	r3,r3,-128
811008c0:	e13fbf04 	addi	r4,fp,-260
811008c4:	00804004 	movi	r2,256
811008c8:	d8800015 	stw	r2,0(sp)
811008cc:	200f883a 	mov	r7,r4
811008d0:	180d883a 	mov	r6,r3
811008d4:	e17fbb17 	ldw	r5,-276(fp)
811008d8:	e13fba17 	ldw	r4,-280(fp)
811008dc:	1105bc80 	call	81105bc8 <I2C_MultipleRead>
811008e0:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
811008e4:	e0bfbe17 	ldw	r2,-264(fp)
811008e8:	1002be26 	beq	r2,zero,811013e4 <bDdr2EepromDump+0xc38>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
811008ec:	e03fbc15 	stw	zero,-272(fp)
811008f0:	0002b606 	br	811013cc <bDdr2EepromDump+0xc20>
			if (iI == 0) {
811008f4:	e0bfbc17 	ldw	r2,-272(fp)
811008f8:	1000121e 	bne	r2,zero,81100944 <bDdr2EepromDump+0x198>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
811008fc:	e0ffbf04 	addi	r3,fp,-260
81100900:	e0bfbc17 	ldw	r2,-272(fp)
81100904:	1885883a 	add	r2,r3,r2
81100908:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110090c:	10803fcc 	andi	r2,r2,255
81100910:	100f883a 	mov	r7,r2
81100914:	e1bfbc17 	ldw	r6,-272(fp)
81100918:	01604534 	movhi	r5,33044
8110091c:	2971f804 	addi	r5,r5,-14368
81100920:	01204534 	movhi	r4,33044
81100924:	21077104 	addi	r4,r4,7620
81100928:	1113e480 	call	81113e48 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
8110092c:	d0a04e17 	ldw	r2,-32456(gp)
81100930:	01604534 	movhi	r5,33044
81100934:	29477104 	addi	r5,r5,7620
81100938:	1009883a 	mov	r4,r2
8110093c:	11126e00 	call	811126e0 <fprintf>
81100940:	00029f06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 1) {
81100944:	e0bfbc17 	ldw	r2,-272(fp)
81100948:	10800058 	cmpnei	r2,r2,1
8110094c:	1000101e 	bne	r2,zero,81100990 <bDdr2EepromDump+0x1e4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100950:	00e04534 	movhi	r3,33044
81100954:	18c77104 	addi	r3,r3,7620
81100958:	00a04534 	movhi	r2,33044
8110095c:	10b20404 	addi	r2,r2,-14320
81100960:	1009883a 	mov	r4,r2
81100964:	00800c04 	movi	r2,48
81100968:	100d883a 	mov	r6,r2
8110096c:	200b883a 	mov	r5,r4
81100970:	1809883a 	mov	r4,r3
81100974:	11136e00 	call	811136e0 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
81100978:	d0a04e17 	ldw	r2,-32456(gp)
8110097c:	01604534 	movhi	r5,33044
81100980:	29477104 	addi	r5,r5,7620
81100984:	1009883a 	mov	r4,r2
81100988:	11126e00 	call	811126e0 <fprintf>
8110098c:	00028c06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 2) {
81100990:	e0bfbc17 	ldw	r2,-272(fp)
81100994:	10800098 	cmpnei	r2,r2,2
81100998:	1000101e 	bne	r2,zero,811009dc <bDdr2EepromDump+0x230>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
8110099c:	00e04534 	movhi	r3,33044
811009a0:	18c77104 	addi	r3,r3,7620
811009a4:	00a04534 	movhi	r2,33044
811009a8:	10b21004 	addi	r2,r2,-14272
811009ac:	1009883a 	mov	r4,r2
811009b0:	008007c4 	movi	r2,31
811009b4:	100d883a 	mov	r6,r2
811009b8:	200b883a 	mov	r5,r4
811009bc:	1809883a 	mov	r4,r3
811009c0:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
811009c4:	d0a04e17 	ldw	r2,-32456(gp)
811009c8:	01604534 	movhi	r5,33044
811009cc:	29477104 	addi	r5,r5,7620
811009d0:	1009883a 	mov	r4,r2
811009d4:	11126e00 	call	811126e0 <fprintf>
811009d8:	00027906 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 3) {
811009dc:	e0bfbc17 	ldw	r2,-272(fp)
811009e0:	108000d8 	cmpnei	r2,r2,3
811009e4:	1000101e 	bne	r2,zero,81100a28 <bDdr2EepromDump+0x27c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009e8:	00e04534 	movhi	r3,33044
811009ec:	18c77104 	addi	r3,r3,7620
811009f0:	00a04534 	movhi	r2,33044
811009f4:	10b21804 	addi	r2,r2,-14240
811009f8:	1009883a 	mov	r4,r2
811009fc:	008009c4 	movi	r2,39
81100a00:	100d883a 	mov	r6,r2
81100a04:	200b883a 	mov	r5,r4
81100a08:	1809883a 	mov	r4,r3
81100a0c:	11136e00 	call	811136e0 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a10:	d0a04e17 	ldw	r2,-32456(gp)
81100a14:	01604534 	movhi	r5,33044
81100a18:	29477104 	addi	r5,r5,7620
81100a1c:	1009883a 	mov	r4,r2
81100a20:	11126e00 	call	811126e0 <fprintf>
81100a24:	00026606 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 4) {
81100a28:	e0bfbc17 	ldw	r2,-272(fp)
81100a2c:	10800118 	cmpnei	r2,r2,4
81100a30:	1000101e 	bne	r2,zero,81100a74 <bDdr2EepromDump+0x2c8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a34:	00e04534 	movhi	r3,33044
81100a38:	18c77104 	addi	r3,r3,7620
81100a3c:	00a04534 	movhi	r2,33044
81100a40:	10b22204 	addi	r2,r2,-14200
81100a44:	1009883a 	mov	r4,r2
81100a48:	00800a84 	movi	r2,42
81100a4c:	100d883a 	mov	r6,r2
81100a50:	200b883a 	mov	r5,r4
81100a54:	1809883a 	mov	r4,r3
81100a58:	11136e00 	call	811136e0 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a5c:	d0a04e17 	ldw	r2,-32456(gp)
81100a60:	01604534 	movhi	r5,33044
81100a64:	29477104 	addi	r5,r5,7620
81100a68:	1009883a 	mov	r4,r2
81100a6c:	11126e00 	call	811126e0 <fprintf>
81100a70:	00025306 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 5) {
81100a74:	e0bfbc17 	ldw	r2,-272(fp)
81100a78:	10800158 	cmpnei	r2,r2,5
81100a7c:	1000101e 	bne	r2,zero,81100ac0 <bDdr2EepromDump+0x314>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a80:	00e04534 	movhi	r3,33044
81100a84:	18c77104 	addi	r3,r3,7620
81100a88:	00a04534 	movhi	r2,33044
81100a8c:	10b22d04 	addi	r2,r2,-14156
81100a90:	1009883a 	mov	r4,r2
81100a94:	00800c04 	movi	r2,48
81100a98:	100d883a 	mov	r6,r2
81100a9c:	200b883a 	mov	r5,r4
81100aa0:	1809883a 	mov	r4,r3
81100aa4:	11136e00 	call	811136e0 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100aa8:	d0a04e17 	ldw	r2,-32456(gp)
81100aac:	01604534 	movhi	r5,33044
81100ab0:	29477104 	addi	r5,r5,7620
81100ab4:	1009883a 	mov	r4,r2
81100ab8:	11126e00 	call	811126e0 <fprintf>
81100abc:	00024006 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 6) {
81100ac0:	e0bfbc17 	ldw	r2,-272(fp)
81100ac4:	10800198 	cmpnei	r2,r2,6
81100ac8:	1000101e 	bne	r2,zero,81100b0c <bDdr2EepromDump+0x360>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100acc:	00e04534 	movhi	r3,33044
81100ad0:	18c77104 	addi	r3,r3,7620
81100ad4:	00a04534 	movhi	r2,33044
81100ad8:	10b23904 	addi	r2,r2,-14108
81100adc:	1009883a 	mov	r4,r2
81100ae0:	00800544 	movi	r2,21
81100ae4:	100d883a 	mov	r6,r2
81100ae8:	200b883a 	mov	r5,r4
81100aec:	1809883a 	mov	r4,r3
81100af0:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
81100af4:	d0a04e17 	ldw	r2,-32456(gp)
81100af8:	01604534 	movhi	r5,33044
81100afc:	29477104 	addi	r5,r5,7620
81100b00:	1009883a 	mov	r4,r2
81100b04:	11126e00 	call	811126e0 <fprintf>
81100b08:	00022d06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 7) {
81100b0c:	e0bfbc17 	ldw	r2,-272(fp)
81100b10:	108001d8 	cmpnei	r2,r2,7
81100b14:	1000101e 	bne	r2,zero,81100b58 <bDdr2EepromDump+0x3ac>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b18:	00e04534 	movhi	r3,33044
81100b1c:	18c77104 	addi	r3,r3,7620
81100b20:	00a04534 	movhi	r2,33044
81100b24:	10b23f04 	addi	r2,r2,-14084
81100b28:	1009883a 	mov	r4,r2
81100b2c:	00800804 	movi	r2,32
81100b30:	100d883a 	mov	r6,r2
81100b34:	200b883a 	mov	r5,r4
81100b38:	1809883a 	mov	r4,r3
81100b3c:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
81100b40:	d0a04e17 	ldw	r2,-32456(gp)
81100b44:	01604534 	movhi	r5,33044
81100b48:	29477104 	addi	r5,r5,7620
81100b4c:	1009883a 	mov	r4,r2
81100b50:	11126e00 	call	811126e0 <fprintf>
81100b54:	00021a06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 16) {
81100b58:	e0bfbc17 	ldw	r2,-272(fp)
81100b5c:	10800418 	cmpnei	r2,r2,16
81100b60:	1000101e 	bne	r2,zero,81100ba4 <bDdr2EepromDump+0x3f8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100b64:	00e04534 	movhi	r3,33044
81100b68:	18c77104 	addi	r3,r3,7620
81100b6c:	00a04534 	movhi	r2,33044
81100b70:	10b24704 	addi	r2,r2,-14052
81100b74:	1009883a 	mov	r4,r2
81100b78:	00800d04 	movi	r2,52
81100b7c:	100d883a 	mov	r6,r2
81100b80:	200b883a 	mov	r5,r4
81100b84:	1809883a 	mov	r4,r3
81100b88:	11136e00 	call	811136e0 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100b8c:	d0a04e17 	ldw	r2,-32456(gp)
81100b90:	01604534 	movhi	r5,33044
81100b94:	29477104 	addi	r5,r5,7620
81100b98:	1009883a 	mov	r4,r2
81100b9c:	11126e00 	call	811126e0 <fprintf>
81100ba0:	00020706 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 13) {
81100ba4:	e0bfbc17 	ldw	r2,-272(fp)
81100ba8:	10800358 	cmpnei	r2,r2,13
81100bac:	1000101e 	bne	r2,zero,81100bf0 <bDdr2EepromDump+0x444>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100bb0:	00e04534 	movhi	r3,33044
81100bb4:	18c77104 	addi	r3,r3,7620
81100bb8:	00a04534 	movhi	r2,33044
81100bbc:	10b25404 	addi	r2,r2,-14000
81100bc0:	1009883a 	mov	r4,r2
81100bc4:	008005c4 	movi	r2,23
81100bc8:	100d883a 	mov	r6,r2
81100bcc:	200b883a 	mov	r5,r4
81100bd0:	1809883a 	mov	r4,r3
81100bd4:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
81100bd8:	d0a04e17 	ldw	r2,-32456(gp)
81100bdc:	01604534 	movhi	r5,33044
81100be0:	29477104 	addi	r5,r5,7620
81100be4:	1009883a 	mov	r4,r2
81100be8:	11126e00 	call	811126e0 <fprintf>
81100bec:	0001f406 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 14) {
81100bf0:	e0bfbc17 	ldw	r2,-272(fp)
81100bf4:	10800398 	cmpnei	r2,r2,14
81100bf8:	1000101e 	bne	r2,zero,81100c3c <bDdr2EepromDump+0x490>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100bfc:	00e04534 	movhi	r3,33044
81100c00:	18c77104 	addi	r3,r3,7620
81100c04:	00a04534 	movhi	r2,33044
81100c08:	10b25a04 	addi	r2,r2,-13976
81100c0c:	1009883a 	mov	r4,r2
81100c10:	008004c4 	movi	r2,19
81100c14:	100d883a 	mov	r6,r2
81100c18:	200b883a 	mov	r5,r4
81100c1c:	1809883a 	mov	r4,r3
81100c20:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
81100c24:	d0a04e17 	ldw	r2,-32456(gp)
81100c28:	01604534 	movhi	r5,33044
81100c2c:	29477104 	addi	r5,r5,7620
81100c30:	1009883a 	mov	r4,r2
81100c34:	11126e00 	call	811126e0 <fprintf>
81100c38:	0001e106 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 17) {
81100c3c:	e0bfbc17 	ldw	r2,-272(fp)
81100c40:	10800458 	cmpnei	r2,r2,17
81100c44:	1000101e 	bne	r2,zero,81100c88 <bDdr2EepromDump+0x4dc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100c48:	00e04534 	movhi	r3,33044
81100c4c:	18c77104 	addi	r3,r3,7620
81100c50:	00a04534 	movhi	r2,33044
81100c54:	10b25f04 	addi	r2,r2,-13956
81100c58:	1009883a 	mov	r4,r2
81100c5c:	00800684 	movi	r2,26
81100c60:	100d883a 	mov	r6,r2
81100c64:	200b883a 	mov	r5,r4
81100c68:	1809883a 	mov	r4,r3
81100c6c:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
81100c70:	d0a04e17 	ldw	r2,-32456(gp)
81100c74:	01604534 	movhi	r5,33044
81100c78:	29477104 	addi	r5,r5,7620
81100c7c:	1009883a 	mov	r4,r2
81100c80:	11126e00 	call	811126e0 <fprintf>
81100c84:	0001ce06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 18) {
81100c88:	e0bfbc17 	ldw	r2,-272(fp)
81100c8c:	10800498 	cmpnei	r2,r2,18
81100c90:	1000101e 	bne	r2,zero,81100cd4 <bDdr2EepromDump+0x528>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100c94:	00e04534 	movhi	r3,33044
81100c98:	18c77104 	addi	r3,r3,7620
81100c9c:	00a04534 	movhi	r2,33044
81100ca0:	10b26604 	addi	r2,r2,-13928
81100ca4:	1009883a 	mov	r4,r2
81100ca8:	00800d44 	movi	r2,53
81100cac:	100d883a 	mov	r6,r2
81100cb0:	200b883a 	mov	r5,r4
81100cb4:	1809883a 	mov	r4,r3
81100cb8:	11136e00 	call	811136e0 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100cbc:	d0a04e17 	ldw	r2,-32456(gp)
81100cc0:	01604534 	movhi	r5,33044
81100cc4:	29477104 	addi	r5,r5,7620
81100cc8:	1009883a 	mov	r4,r2
81100ccc:	11126e00 	call	811126e0 <fprintf>
81100cd0:	0001bb06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 20) {
81100cd4:	e0bfbc17 	ldw	r2,-272(fp)
81100cd8:	10800518 	cmpnei	r2,r2,20
81100cdc:	1000101e 	bne	r2,zero,81100d20 <bDdr2EepromDump+0x574>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ce0:	00e04534 	movhi	r3,33044
81100ce4:	18c77104 	addi	r3,r3,7620
81100ce8:	00a04534 	movhi	r2,33044
81100cec:	10b27404 	addi	r2,r2,-13872
81100cf0:	1009883a 	mov	r4,r2
81100cf4:	00801204 	movi	r2,72
81100cf8:	100d883a 	mov	r6,r2
81100cfc:	200b883a 	mov	r5,r4
81100d00:	1809883a 	mov	r4,r3
81100d04:	11136e00 	call	811136e0 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d08:	d0a04e17 	ldw	r2,-32456(gp)
81100d0c:	01604534 	movhi	r5,33044
81100d10:	29477104 	addi	r5,r5,7620
81100d14:	1009883a 	mov	r4,r2
81100d18:	11126e00 	call	811126e0 <fprintf>
81100d1c:	0001a806 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 22) {
81100d20:	e0bfbc17 	ldw	r2,-272(fp)
81100d24:	10800598 	cmpnei	r2,r2,22
81100d28:	1000101e 	bne	r2,zero,81100d6c <bDdr2EepromDump+0x5c0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d2c:	00e04534 	movhi	r3,33044
81100d30:	18c77104 	addi	r3,r3,7620
81100d34:	00a04534 	movhi	r2,33044
81100d38:	10b28604 	addi	r2,r2,-13800
81100d3c:	1009883a 	mov	r4,r2
81100d40:	00800784 	movi	r2,30
81100d44:	100d883a 	mov	r6,r2
81100d48:	200b883a 	mov	r5,r4
81100d4c:	1809883a 	mov	r4,r3
81100d50:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
81100d54:	d0a04e17 	ldw	r2,-32456(gp)
81100d58:	01604534 	movhi	r5,33044
81100d5c:	29477104 	addi	r5,r5,7620
81100d60:	1009883a 	mov	r4,r2
81100d64:	11126e00 	call	811126e0 <fprintf>
81100d68:	00019506 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 27) {
81100d6c:	e0bfbc17 	ldw	r2,-272(fp)
81100d70:	108006d8 	cmpnei	r2,r2,27
81100d74:	1000101e 	bne	r2,zero,81100db8 <bDdr2EepromDump+0x60c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d78:	00e04534 	movhi	r3,33044
81100d7c:	18c77104 	addi	r3,r3,7620
81100d80:	00a04534 	movhi	r2,33044
81100d84:	10b28e04 	addi	r2,r2,-13768
81100d88:	1009883a 	mov	r4,r2
81100d8c:	00800a04 	movi	r2,40
81100d90:	100d883a 	mov	r6,r2
81100d94:	200b883a 	mov	r5,r4
81100d98:	1809883a 	mov	r4,r3
81100d9c:	11136e00 	call	811136e0 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100da0:	d0a04e17 	ldw	r2,-32456(gp)
81100da4:	01604534 	movhi	r5,33044
81100da8:	29477104 	addi	r5,r5,7620
81100dac:	1009883a 	mov	r4,r2
81100db0:	11126e00 	call	811126e0 <fprintf>
81100db4:	00018206 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 28) {
81100db8:	e0bfbc17 	ldw	r2,-272(fp)
81100dbc:	10800718 	cmpnei	r2,r2,28
81100dc0:	1000101e 	bne	r2,zero,81100e04 <bDdr2EepromDump+0x658>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100dc4:	00e04534 	movhi	r3,33044
81100dc8:	18c77104 	addi	r3,r3,7620
81100dcc:	00a04534 	movhi	r2,33044
81100dd0:	10b29804 	addi	r2,r2,-13728
81100dd4:	1009883a 	mov	r4,r2
81100dd8:	00800cc4 	movi	r2,51
81100ddc:	100d883a 	mov	r6,r2
81100de0:	200b883a 	mov	r5,r4
81100de4:	1809883a 	mov	r4,r3
81100de8:	11136e00 	call	811136e0 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100dec:	d0a04e17 	ldw	r2,-32456(gp)
81100df0:	01604534 	movhi	r5,33044
81100df4:	29477104 	addi	r5,r5,7620
81100df8:	1009883a 	mov	r4,r2
81100dfc:	11126e00 	call	811126e0 <fprintf>
81100e00:	00016f06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 29) {
81100e04:	e0bfbc17 	ldw	r2,-272(fp)
81100e08:	10800758 	cmpnei	r2,r2,29
81100e0c:	1000101e 	bne	r2,zero,81100e50 <bDdr2EepromDump+0x6a4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e10:	00e04534 	movhi	r3,33044
81100e14:	18c77104 	addi	r3,r3,7620
81100e18:	00a04534 	movhi	r2,33044
81100e1c:	10b2a504 	addi	r2,r2,-13676
81100e20:	1009883a 	mov	r4,r2
81100e24:	008009c4 	movi	r2,39
81100e28:	100d883a 	mov	r6,r2
81100e2c:	200b883a 	mov	r5,r4
81100e30:	1809883a 	mov	r4,r3
81100e34:	11136e00 	call	811136e0 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e38:	d0a04e17 	ldw	r2,-32456(gp)
81100e3c:	01604534 	movhi	r5,33044
81100e40:	29477104 	addi	r5,r5,7620
81100e44:	1009883a 	mov	r4,r2
81100e48:	11126e00 	call	811126e0 <fprintf>
81100e4c:	00015c06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 30) {
81100e50:	e0bfbc17 	ldw	r2,-272(fp)
81100e54:	10800798 	cmpnei	r2,r2,30
81100e58:	1000101e 	bne	r2,zero,81100e9c <bDdr2EepromDump+0x6f0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e5c:	00e04534 	movhi	r3,33044
81100e60:	18c77104 	addi	r3,r3,7620
81100e64:	00a04534 	movhi	r2,33044
81100e68:	10b2af04 	addi	r2,r2,-13636
81100e6c:	1009883a 	mov	r4,r2
81100e70:	00800b04 	movi	r2,44
81100e74:	100d883a 	mov	r6,r2
81100e78:	200b883a 	mov	r5,r4
81100e7c:	1809883a 	mov	r4,r3
81100e80:	11136e00 	call	811136e0 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100e84:	d0a04e17 	ldw	r2,-32456(gp)
81100e88:	01604534 	movhi	r5,33044
81100e8c:	29477104 	addi	r5,r5,7620
81100e90:	1009883a 	mov	r4,r2
81100e94:	11126e00 	call	811126e0 <fprintf>
81100e98:	00014906 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 31) {
81100e9c:	e0bfbc17 	ldw	r2,-272(fp)
81100ea0:	108007d8 	cmpnei	r2,r2,31
81100ea4:	1000101e 	bne	r2,zero,81100ee8 <bDdr2EepromDump+0x73c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ea8:	00e04534 	movhi	r3,33044
81100eac:	18c77104 	addi	r3,r3,7620
81100eb0:	00a04534 	movhi	r2,33044
81100eb4:	10b2ba04 	addi	r2,r2,-13592
81100eb8:	1009883a 	mov	r4,r2
81100ebc:	008010c4 	movi	r2,67
81100ec0:	100d883a 	mov	r6,r2
81100ec4:	200b883a 	mov	r5,r4
81100ec8:	1809883a 	mov	r4,r3
81100ecc:	11136e00 	call	811136e0 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100ed0:	d0a04e17 	ldw	r2,-32456(gp)
81100ed4:	01604534 	movhi	r5,33044
81100ed8:	29477104 	addi	r5,r5,7620
81100edc:	1009883a 	mov	r4,r2
81100ee0:	11126e00 	call	811126e0 <fprintf>
81100ee4:	00013606 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 36) {
81100ee8:	e0bfbc17 	ldw	r2,-272(fp)
81100eec:	10800918 	cmpnei	r2,r2,36
81100ef0:	1000101e 	bne	r2,zero,81100f34 <bDdr2EepromDump+0x788>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ef4:	00e04534 	movhi	r3,33044
81100ef8:	18c77104 	addi	r3,r3,7620
81100efc:	00a04534 	movhi	r2,33044
81100f00:	10b2cb04 	addi	r2,r2,-13524
81100f04:	1009883a 	mov	r4,r2
81100f08:	00800a84 	movi	r2,42
81100f0c:	100d883a 	mov	r6,r2
81100f10:	200b883a 	mov	r5,r4
81100f14:	1809883a 	mov	r4,r3
81100f18:	11136e00 	call	811136e0 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f1c:	d0a04e17 	ldw	r2,-32456(gp)
81100f20:	01604534 	movhi	r5,33044
81100f24:	29477104 	addi	r5,r5,7620
81100f28:	1009883a 	mov	r4,r2
81100f2c:	11126e00 	call	811126e0 <fprintf>
81100f30:	00012306 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 37) {
81100f34:	e0bfbc17 	ldw	r2,-272(fp)
81100f38:	10800958 	cmpnei	r2,r2,37
81100f3c:	1000101e 	bne	r2,zero,81100f80 <bDdr2EepromDump+0x7d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f40:	00e04534 	movhi	r3,33044
81100f44:	18c77104 	addi	r3,r3,7620
81100f48:	00a04534 	movhi	r2,33044
81100f4c:	10b2d604 	addi	r2,r2,-13480
81100f50:	1009883a 	mov	r4,r2
81100f54:	00800cc4 	movi	r2,51
81100f58:	100d883a 	mov	r6,r2
81100f5c:	200b883a 	mov	r5,r4
81100f60:	1809883a 	mov	r4,r3
81100f64:	11136e00 	call	811136e0 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f68:	d0a04e17 	ldw	r2,-32456(gp)
81100f6c:	01604534 	movhi	r5,33044
81100f70:	29477104 	addi	r5,r5,7620
81100f74:	1009883a 	mov	r4,r2
81100f78:	11126e00 	call	811126e0 <fprintf>
81100f7c:	00011006 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 38) {
81100f80:	e0bfbc17 	ldw	r2,-272(fp)
81100f84:	10800998 	cmpnei	r2,r2,38
81100f88:	1000101e 	bne	r2,zero,81100fcc <bDdr2EepromDump+0x820>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f8c:	00e04534 	movhi	r3,33044
81100f90:	18c77104 	addi	r3,r3,7620
81100f94:	00a04534 	movhi	r2,33044
81100f98:	10b2e304 	addi	r2,r2,-13428
81100f9c:	1009883a 	mov	r4,r2
81100fa0:	00800dc4 	movi	r2,55
81100fa4:	100d883a 	mov	r6,r2
81100fa8:	200b883a 	mov	r5,r4
81100fac:	1809883a 	mov	r4,r3
81100fb0:	11136e00 	call	811136e0 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fb4:	d0a04e17 	ldw	r2,-32456(gp)
81100fb8:	01604534 	movhi	r5,33044
81100fbc:	29477104 	addi	r5,r5,7620
81100fc0:	1009883a 	mov	r4,r2
81100fc4:	11126e00 	call	811126e0 <fprintf>
81100fc8:	0000fd06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 41) {
81100fcc:	e0bfbc17 	ldw	r2,-272(fp)
81100fd0:	10800a58 	cmpnei	r2,r2,41
81100fd4:	1000101e 	bne	r2,zero,81101018 <bDdr2EepromDump+0x86c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fd8:	00e04534 	movhi	r3,33044
81100fdc:	18c77104 	addi	r3,r3,7620
81100fe0:	00a04534 	movhi	r2,33044
81100fe4:	10b2f104 	addi	r2,r2,-13372
81100fe8:	1009883a 	mov	r4,r2
81100fec:	00800c84 	movi	r2,50
81100ff0:	100d883a 	mov	r6,r2
81100ff4:	200b883a 	mov	r5,r4
81100ff8:	1809883a 	mov	r4,r3
81100ffc:	11136e00 	call	811136e0 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101000:	d0a04e17 	ldw	r2,-32456(gp)
81101004:	01604534 	movhi	r5,33044
81101008:	29477104 	addi	r5,r5,7620
8110100c:	1009883a 	mov	r4,r2
81101010:	11126e00 	call	811126e0 <fprintf>
81101014:	0000ea06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 42) {
81101018:	e0bfbc17 	ldw	r2,-272(fp)
8110101c:	10800a98 	cmpnei	r2,r2,42
81101020:	1000101e 	bne	r2,zero,81101064 <bDdr2EepromDump+0x8b8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101024:	00e04534 	movhi	r3,33044
81101028:	18c77104 	addi	r3,r3,7620
8110102c:	00a04534 	movhi	r2,33044
81101030:	10b2fe04 	addi	r2,r2,-13320
81101034:	1009883a 	mov	r4,r2
81101038:	00800cc4 	movi	r2,51
8110103c:	100d883a 	mov	r6,r2
81101040:	200b883a 	mov	r5,r4
81101044:	1809883a 	mov	r4,r3
81101048:	11136e00 	call	811136e0 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
8110104c:	d0a04e17 	ldw	r2,-32456(gp)
81101050:	01604534 	movhi	r5,33044
81101054:	29477104 	addi	r5,r5,7620
81101058:	1009883a 	mov	r4,r2
8110105c:	11126e00 	call	811126e0 <fprintf>
81101060:	0000d706 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 62) {
81101064:	e0bfbc17 	ldw	r2,-272(fp)
81101068:	10800f98 	cmpnei	r2,r2,62
8110106c:	1000101e 	bne	r2,zero,811010b0 <bDdr2EepromDump+0x904>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
81101070:	00e04534 	movhi	r3,33044
81101074:	18c77104 	addi	r3,r3,7620
81101078:	00a04534 	movhi	r2,33044
8110107c:	10b30b04 	addi	r2,r2,-13268
81101080:	1009883a 	mov	r4,r2
81101084:	00800404 	movi	r2,16
81101088:	100d883a 	mov	r6,r2
8110108c:	200b883a 	mov	r5,r4
81101090:	1809883a 	mov	r4,r3
81101094:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
81101098:	d0a04e17 	ldw	r2,-32456(gp)
8110109c:	01604534 	movhi	r5,33044
811010a0:	29477104 	addi	r5,r5,7620
811010a4:	1009883a 	mov	r4,r2
811010a8:	11126e00 	call	811126e0 <fprintf>
811010ac:	0000c406 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 63) {
811010b0:	e0bfbc17 	ldw	r2,-272(fp)
811010b4:	10800fd8 	cmpnei	r2,r2,63
811010b8:	10001f1e 	bne	r2,zero,81101138 <bDdr2EepromDump+0x98c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
811010bc:	00a04534 	movhi	r2,33044
811010c0:	10877104 	addi	r2,r2,7620
811010c4:	00c00a04 	movi	r3,40
811010c8:	10c00005 	stb	r3,0(r2)
811010cc:	00c010c4 	movi	r3,67
811010d0:	10c00045 	stb	r3,1(r2)
811010d4:	00c01a04 	movi	r3,104
811010d8:	10c00085 	stb	r3,2(r2)
811010dc:	00c01944 	movi	r3,101
811010e0:	10c000c5 	stb	r3,3(r2)
811010e4:	00c018c4 	movi	r3,99
811010e8:	10c00105 	stb	r3,4(r2)
811010ec:	00c01ac4 	movi	r3,107
811010f0:	10c00145 	stb	r3,5(r2)
811010f4:	00c01cc4 	movi	r3,115
811010f8:	10c00185 	stb	r3,6(r2)
811010fc:	00c01d44 	movi	r3,117
81101100:	10c001c5 	stb	r3,7(r2)
81101104:	00c01b44 	movi	r3,109
81101108:	10c00205 	stb	r3,8(r2)
8110110c:	00c00a44 	movi	r3,41
81101110:	10c00245 	stb	r3,9(r2)
81101114:	00c00284 	movi	r3,10
81101118:	10c00285 	stb	r3,10(r2)
8110111c:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101120:	d0a04e17 	ldw	r2,-32456(gp)
81101124:	01604534 	movhi	r5,33044
81101128:	29477104 	addi	r5,r5,7620
8110112c:	1009883a 	mov	r4,r2
81101130:	11126e00 	call	811126e0 <fprintf>
81101134:	0000a206 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 64) {
81101138:	e0bfbc17 	ldw	r2,-272(fp)
8110113c:	10801018 	cmpnei	r2,r2,64
81101140:	1000101e 	bne	r2,zero,81101184 <bDdr2EepromDump+0x9d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
81101144:	00e04534 	movhi	r3,33044
81101148:	18c77104 	addi	r3,r3,7620
8110114c:	00a04534 	movhi	r2,33044
81101150:	10b30f04 	addi	r2,r2,-13252
81101154:	1009883a 	mov	r4,r2
81101158:	00800804 	movi	r2,32
8110115c:	100d883a 	mov	r6,r2
81101160:	200b883a 	mov	r5,r4
81101164:	1809883a 	mov	r4,r3
81101168:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
8110116c:	d0a04e17 	ldw	r2,-32456(gp)
81101170:	01604534 	movhi	r5,33044
81101174:	29477104 	addi	r5,r5,7620
81101178:	1009883a 	mov	r4,r2
8110117c:	11126e00 	call	811126e0 <fprintf>
81101180:	00008f06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 72) {
81101184:	e0bfbc17 	ldw	r2,-272(fp)
81101188:	10801218 	cmpnei	r2,r2,72
8110118c:	1000101e 	bne	r2,zero,811011d0 <bDdr2EepromDump+0xa24>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101190:	00e04534 	movhi	r3,33044
81101194:	18c77104 	addi	r3,r3,7620
81101198:	00a04534 	movhi	r2,33044
8110119c:	10b31704 	addi	r2,r2,-13220
811011a0:	1009883a 	mov	r4,r2
811011a4:	00800dc4 	movi	r2,55
811011a8:	100d883a 	mov	r6,r2
811011ac:	200b883a 	mov	r5,r4
811011b0:	1809883a 	mov	r4,r3
811011b4:	11136e00 	call	811136e0 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
811011b8:	d0a04e17 	ldw	r2,-32456(gp)
811011bc:	01604534 	movhi	r5,33044
811011c0:	29477104 	addi	r5,r5,7620
811011c4:	1009883a 	mov	r4,r2
811011c8:	11126e00 	call	811126e0 <fprintf>
811011cc:	00007c06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 73) {
811011d0:	e0bfbc17 	ldw	r2,-272(fp)
811011d4:	10801258 	cmpnei	r2,r2,73
811011d8:	1000101e 	bne	r2,zero,8110121c <bDdr2EepromDump+0xa70>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
811011dc:	00e04534 	movhi	r3,33044
811011e0:	18c77104 	addi	r3,r3,7620
811011e4:	00a04534 	movhi	r2,33044
811011e8:	10b32504 	addi	r2,r2,-13164
811011ec:	1009883a 	mov	r4,r2
811011f0:	00800784 	movi	r2,30
811011f4:	100d883a 	mov	r6,r2
811011f8:	200b883a 	mov	r5,r4
811011fc:	1809883a 	mov	r4,r3
81101200:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
81101204:	d0a04e17 	ldw	r2,-32456(gp)
81101208:	01604534 	movhi	r5,33044
8110120c:	29477104 	addi	r5,r5,7620
81101210:	1009883a 	mov	r4,r2
81101214:	11126e00 	call	811126e0 <fprintf>
81101218:	00006906 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 91) {
8110121c:	e0bfbc17 	ldw	r2,-272(fp)
81101220:	108016d8 	cmpnei	r2,r2,91
81101224:	1000101e 	bne	r2,zero,81101268 <bDdr2EepromDump+0xabc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101228:	00e04534 	movhi	r3,33044
8110122c:	18c77104 	addi	r3,r3,7620
81101230:	00a04534 	movhi	r2,33044
81101234:	10b32d04 	addi	r2,r2,-13132
81101238:	1009883a 	mov	r4,r2
8110123c:	00800804 	movi	r2,32
81101240:	100d883a 	mov	r6,r2
81101244:	200b883a 	mov	r5,r4
81101248:	1809883a 	mov	r4,r3
8110124c:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
81101250:	d0a04e17 	ldw	r2,-32456(gp)
81101254:	01604534 	movhi	r5,33044
81101258:	29477104 	addi	r5,r5,7620
8110125c:	1009883a 	mov	r4,r2
81101260:	11126e00 	call	811126e0 <fprintf>
81101264:	00005606 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 93) {
81101268:	e0bfbc17 	ldw	r2,-272(fp)
8110126c:	10801758 	cmpnei	r2,r2,93
81101270:	1000101e 	bne	r2,zero,811012b4 <bDdr2EepromDump+0xb08>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101274:	00e04534 	movhi	r3,33044
81101278:	18c77104 	addi	r3,r3,7620
8110127c:	00a04534 	movhi	r2,33044
81101280:	10b33504 	addi	r2,r2,-13100
81101284:	1009883a 	mov	r4,r2
81101288:	008009c4 	movi	r2,39
8110128c:	100d883a 	mov	r6,r2
81101290:	200b883a 	mov	r5,r4
81101294:	1809883a 	mov	r4,r3
81101298:	11136e00 	call	811136e0 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
8110129c:	d0a04e17 	ldw	r2,-32456(gp)
811012a0:	01604534 	movhi	r5,33044
811012a4:	29477104 	addi	r5,r5,7620
811012a8:	1009883a 	mov	r4,r2
811012ac:	11126e00 	call	811126e0 <fprintf>
811012b0:	00004306 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 94) {
811012b4:	e0bfbc17 	ldw	r2,-272(fp)
811012b8:	10801798 	cmpnei	r2,r2,94
811012bc:	1000101e 	bne	r2,zero,81101300 <bDdr2EepromDump+0xb54>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
811012c0:	00e04534 	movhi	r3,33044
811012c4:	18c77104 	addi	r3,r3,7620
811012c8:	00a04534 	movhi	r2,33044
811012cc:	10b33f04 	addi	r2,r2,-13060
811012d0:	1009883a 	mov	r4,r2
811012d4:	008006c4 	movi	r2,27
811012d8:	100d883a 	mov	r6,r2
811012dc:	200b883a 	mov	r5,r4
811012e0:	1809883a 	mov	r4,r3
811012e4:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
811012e8:	d0a04e17 	ldw	r2,-32456(gp)
811012ec:	01604534 	movhi	r5,33044
811012f0:	29477104 	addi	r5,r5,7620
811012f4:	1009883a 	mov	r4,r2
811012f8:	11126e00 	call	811126e0 <fprintf>
811012fc:	00003006 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 95) {
81101300:	e0bfbc17 	ldw	r2,-272(fp)
81101304:	108017d8 	cmpnei	r2,r2,95
81101308:	1000101e 	bne	r2,zero,8110134c <bDdr2EepromDump+0xba0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110130c:	00e04534 	movhi	r3,33044
81101310:	18c77104 	addi	r3,r3,7620
81101314:	00a04534 	movhi	r2,33044
81101318:	10b34604 	addi	r2,r2,-13032
8110131c:	1009883a 	mov	r4,r2
81101320:	00800a04 	movi	r2,40
81101324:	100d883a 	mov	r6,r2
81101328:	200b883a 	mov	r5,r4
8110132c:	1809883a 	mov	r4,r3
81101330:	11136e00 	call	811136e0 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
81101334:	d0a04e17 	ldw	r2,-32456(gp)
81101338:	01604534 	movhi	r5,33044
8110133c:	29477104 	addi	r5,r5,7620
81101340:	1009883a 	mov	r4,r2
81101344:	11126e00 	call	811126e0 <fprintf>
81101348:	00001d06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else if (iI == 99) {
8110134c:	e0bfbc17 	ldw	r2,-272(fp)
81101350:	108018d8 	cmpnei	r2,r2,99
81101354:	1000101e 	bne	r2,zero,81101398 <bDdr2EepromDump+0xbec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
81101358:	00e04534 	movhi	r3,33044
8110135c:	18c77104 	addi	r3,r3,7620
81101360:	00a04534 	movhi	r2,33044
81101364:	10b35004 	addi	r2,r2,-12992
81101368:	1009883a 	mov	r4,r2
8110136c:	00800984 	movi	r2,38
81101370:	100d883a 	mov	r6,r2
81101374:	200b883a 	mov	r5,r4
81101378:	1809883a 	mov	r4,r3
8110137c:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
81101380:	d0a04e17 	ldw	r2,-32456(gp)
81101384:	01604534 	movhi	r5,33044
81101388:	29477104 	addi	r5,r5,7620
8110138c:	1009883a 	mov	r4,r2
81101390:	11126e00 	call	811126e0 <fprintf>
81101394:	00000a06 	br	811013c0 <bDdr2EepromDump+0xc14>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101398:	00a04534 	movhi	r2,33044
8110139c:	10877104 	addi	r2,r2,7620
811013a0:	00c00284 	movi	r3,10
811013a4:	10c00005 	stb	r3,0(r2)
811013a8:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
811013ac:	d0a04e17 	ldw	r2,-32456(gp)
811013b0:	01604534 	movhi	r5,33044
811013b4:	29477104 	addi	r5,r5,7620
811013b8:	1009883a 	mov	r4,r2
811013bc:	11126e00 	call	811126e0 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
811013c0:	e0bfbc17 	ldw	r2,-272(fp)
811013c4:	10800044 	addi	r2,r2,1
811013c8:	e0bfbc15 	stw	r2,-272(fp)
811013cc:	e0bfbc17 	ldw	r2,-272(fp)
811013d0:	10804008 	cmpgei	r2,r2,256
811013d4:	1000121e 	bne	r2,zero,81101420 <bDdr2EepromDump+0xc74>
811013d8:	e0bfbe17 	ldw	r2,-264(fp)
811013dc:	103d451e 	bne	r2,zero,811008f4 <__reset+0xfb0e08f4>
811013e0:	00000f06 	br	81101420 <bDdr2EepromDump+0xc74>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
811013e4:	00e04534 	movhi	r3,33044
811013e8:	18c77104 	addi	r3,r3,7620
811013ec:	00a04534 	movhi	r2,33044
811013f0:	10b35a04 	addi	r2,r2,-12952
811013f4:	1009883a 	mov	r4,r2
811013f8:	008005c4 	movi	r2,23
811013fc:	100d883a 	mov	r6,r2
81101400:	200b883a 	mov	r5,r4
81101404:	1809883a 	mov	r4,r3
81101408:	11136e00 	call	811136e0 <memcpy>
		debug(fp, cDebugBuffer);
8110140c:	d0a04e17 	ldw	r2,-32456(gp)
81101410:	01604534 	movhi	r5,33044
81101414:	29477104 	addi	r5,r5,7620
81101418:	1009883a 	mov	r4,r2
8110141c:	11126e00 	call	811126e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101420:	00a04534 	movhi	r2,33044
81101424:	10877104 	addi	r2,r2,7620
81101428:	00c00284 	movi	r3,10
8110142c:	10c00005 	stb	r3,0(r2)
81101430:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101434:	d0a04e17 	ldw	r2,-32456(gp)
81101438:	01604534 	movhi	r5,33044
8110143c:	29477104 	addi	r5,r5,7620
81101440:	1009883a 	mov	r4,r2
81101444:	11126e00 	call	811126e0 <fprintf>
#endif

	return bSuccess;
81101448:	e0bfbe17 	ldw	r2,-264(fp)
}
8110144c:	e037883a 	mov	sp,fp
81101450:	dfc00117 	ldw	ra,4(sp)
81101454:	df000017 	ldw	fp,0(sp)
81101458:	dec00204 	addi	sp,sp,8
8110145c:	f800283a 	ret

81101460 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
81101460:	defffb04 	addi	sp,sp,-20
81101464:	de00012e 	bgeu	sp,et,8110146c <bDdr2SwitchMemory+0xc>
81101468:	003b68fa 	trap	3
8110146c:	dfc00415 	stw	ra,16(sp)
81101470:	df000315 	stw	fp,12(sp)
81101474:	df000304 	addi	fp,sp,12
81101478:	2005883a 	mov	r2,r4
8110147c:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
81101480:	00a04834 	movhi	r2,33056
81101484:	108c2204 	addi	r2,r2,12424
81101488:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
8110148c:	00800044 	movi	r2,1
81101490:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
81101494:	e0bfff03 	ldbu	r2,-4(fp)
81101498:	10c00060 	cmpeqi	r3,r2,1
8110149c:	1800031e 	bne	r3,zero,811014ac <bDdr2SwitchMemory+0x4c>
811014a0:	108000a0 	cmpeqi	r2,r2,2
811014a4:	1000041e 	bne	r2,zero,811014b8 <bDdr2SwitchMemory+0x58>
811014a8:	00000706 	br	811014c8 <bDdr2SwitchMemory+0x68>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
811014ac:	e0bffe17 	ldw	r2,-8(fp)
811014b0:	10000015 	stw	zero,0(r2)
		break;
811014b4:	00001406 	br	81101508 <bDdr2SwitchMemory+0xa8>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
811014b8:	e0bffe17 	ldw	r2,-8(fp)
811014bc:	00e00034 	movhi	r3,32768
811014c0:	10c00015 	stw	r3,0(r2)
		break;
811014c4:	00001006 	br	81101508 <bDdr2SwitchMemory+0xa8>
	default:
		bSuccess = FALSE;
811014c8:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811014cc:	00e04534 	movhi	r3,33044
811014d0:	18c77104 	addi	r3,r3,7620
811014d4:	00a04534 	movhi	r2,33044
811014d8:	10b36004 	addi	r2,r2,-12928
811014dc:	1009883a 	mov	r4,r2
811014e0:	00800f04 	movi	r2,60
811014e4:	100d883a 	mov	r6,r2
811014e8:	200b883a 	mov	r5,r4
811014ec:	1809883a 	mov	r4,r3
811014f0:	11136e00 	call	811136e0 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
811014f4:	d0a04e17 	ldw	r2,-32456(gp)
811014f8:	01604534 	movhi	r5,33044
811014fc:	29477104 	addi	r5,r5,7620
81101500:	1009883a 	mov	r4,r2
81101504:	11126e00 	call	811126e0 <fprintf>
		;
#endif
	}

	return bSuccess;
81101508:	e0bffd17 	ldw	r2,-12(fp)
}
8110150c:	e037883a 	mov	sp,fp
81101510:	dfc00117 	ldw	ra,4(sp)
81101514:	df000017 	ldw	fp,0(sp)
81101518:	dec00204 	addi	sp,sp,8
8110151c:	f800283a 	ret

81101520 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mémoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101520:	deffe204 	addi	sp,sp,-120
81101524:	de00012e 	bgeu	sp,et,8110152c <bDdr2MemoryWriteTest+0xc>
81101528:	003b68fa 	trap	3
8110152c:	dfc01d15 	stw	ra,116(sp)
81101530:	df001c15 	stw	fp,112(sp)
81101534:	dc401b15 	stw	r17,108(sp)
81101538:	dc001a15 	stw	r16,104(sp)
8110153c:	df001c04 	addi	fp,sp,112
81101540:	2005883a 	mov	r2,r4
81101544:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
81101548:	00e04534 	movhi	r3,33044
8110154c:	18c77104 	addi	r3,r3,7620
81101550:	00a04534 	movhi	r2,33044
81101554:	10b36f04 	addi	r2,r2,-12868
81101558:	1009883a 	mov	r4,r2
8110155c:	00800a04 	movi	r2,40
81101560:	100d883a 	mov	r6,r2
81101564:	200b883a 	mov	r5,r4
81101568:	1809883a 	mov	r4,r3
8110156c:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
81101570:	d0a04e17 	ldw	r2,-32456(gp)
81101574:	01604534 	movhi	r5,33044
81101578:	29477104 	addi	r5,r5,7620
8110157c:	1009883a 	mov	r4,r2
81101580:	11126e00 	call	811126e0 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101584:	00800044 	movi	r2,1
81101588:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
8110158c:	e0bffd03 	ldbu	r2,-12(fp)
81101590:	10c00060 	cmpeqi	r3,r2,1
81101594:	1800031e 	bne	r3,zero,811015a4 <bDdr2MemoryWriteTest+0x84>
81101598:	108000a0 	cmpeqi	r2,r2,2
8110159c:	1000081e 	bne	r2,zero,811015c0 <bDdr2MemoryWriteTest+0xa0>
811015a0:	00000e06 	br	811015dc <bDdr2MemoryWriteTest+0xbc>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
811015a4:	e0bffd03 	ldbu	r2,-12(fp)
811015a8:	1009883a 	mov	r4,r2
811015ac:	11014600 	call	81101460 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811015b0:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811015b4:	00a00034 	movhi	r2,32768
811015b8:	e0bfe615 	stw	r2,-104(fp)
		break;
811015bc:	00001906 	br	81101624 <bDdr2MemoryWriteTest+0x104>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811015c0:	e0bffd03 	ldbu	r2,-12(fp)
811015c4:	1009883a 	mov	r4,r2
811015c8:	11014600 	call	81101460 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811015cc:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811015d0:	00a00034 	movhi	r2,32768
811015d4:	e0bfe615 	stw	r2,-104(fp)
		break;
811015d8:	00001206 	br	81101624 <bDdr2MemoryWriteTest+0x104>
	default:
		bSuccess = FALSE;
811015dc:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811015e0:	00e04534 	movhi	r3,33044
811015e4:	18c77104 	addi	r3,r3,7620
811015e8:	00a04534 	movhi	r2,33044
811015ec:	10b18004 	addi	r2,r2,-14848
811015f0:	1009883a 	mov	r4,r2
811015f4:	00800bc4 	movi	r2,47
811015f8:	100d883a 	mov	r6,r2
811015fc:	200b883a 	mov	r5,r4
81101600:	1809883a 	mov	r4,r3
81101604:	11136e00 	call	811136e0 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101608:	d0a04e17 	ldw	r2,-32456(gp)
8110160c:	01604534 	movhi	r5,33044
81101610:	29477104 	addi	r5,r5,7620
81101614:	1009883a 	mov	r4,r2
81101618:	11126e00 	call	811126e0 <fprintf>
		;
#endif
		return bSuccess;
8110161c:	e0bfed17 	ldw	r2,-76(fp)
81101620:	00011806 	br	81101a84 <bDdr2MemoryWriteTest+0x564>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101624:	e0bfe617 	ldw	r2,-104(fp)
81101628:	1004d53a 	srli	r2,r2,20
8110162c:	100d883a 	mov	r6,r2
81101630:	01604534 	movhi	r5,33044
81101634:	29737904 	addi	r5,r5,-12828
81101638:	01204534 	movhi	r4,33044
8110163c:	21077104 	addi	r4,r4,7620
81101640:	1113e480 	call	81113e48 <sprintf>
	debug(fp, cDebugBuffer);
81101644:	d0a04e17 	ldw	r2,-32456(gp)
81101648:	01604534 	movhi	r5,33044
8110164c:	29477104 	addi	r5,r5,7620
81101650:	1009883a 	mov	r4,r2
81101654:	11126e00 	call	811126e0 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
81101658:	00800104 	movi	r2,4
8110165c:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
81101660:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101664:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
81101668:	e03fe715 	stw	zero,-100(fp)
8110166c:	00001506 	br	811016c4 <bDdr2MemoryWriteTest+0x1a4>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101670:	e0ffe617 	ldw	r3,-104(fp)
81101674:	00b33374 	movhi	r2,52429
81101678:	10b33344 	addi	r2,r2,-13107
8110167c:	1888383a 	mulxuu	r4,r3,r2
81101680:	1885383a 	mul	r2,r3,r2
81101684:	1021883a 	mov	r16,r2
81101688:	2023883a 	mov	r17,r4
8110168c:	8804d0fa 	srli	r2,r17,3
81101690:	e0ffe717 	ldw	r3,-100(fp)
81101694:	18c00044 	addi	r3,r3,1
81101698:	10c7383a 	mul	r3,r2,r3
8110169c:	e0bfe717 	ldw	r2,-100(fp)
811016a0:	1085883a 	add	r2,r2,r2
811016a4:	1085883a 	add	r2,r2,r2
811016a8:	e13fe504 	addi	r4,fp,-108
811016ac:	2085883a 	add	r2,r4,r2
811016b0:	10800e04 	addi	r2,r2,56
811016b4:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
811016b8:	e0bfe717 	ldw	r2,-100(fp)
811016bc:	10800044 	addi	r2,r2,1
811016c0:	e0bfe715 	stw	r2,-100(fp)
811016c4:	e0bfe717 	ldw	r2,-100(fp)
811016c8:	10800290 	cmplti	r2,r2,10
811016cc:	103fe81e 	bne	r2,zero,81101670 <__reset+0xfb0e1670>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
811016d0:	d0a06d17 	ldw	r2,-32332(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
811016d4:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
811016d8:	00804004 	movi	r2,256
811016dc:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
811016e0:	e03fe715 	stw	zero,-100(fp)
811016e4:	00001e06 	br	81101760 <bDdr2MemoryWriteTest+0x240>
		if (iI == 0) {
811016e8:	e0bfe717 	ldw	r2,-100(fp)
811016ec:	1000091e 	bne	r2,zero,81101714 <bDdr2MemoryWriteTest+0x1f4>
			xSZData[iI] = uliInitValue;
811016f0:	00a04534 	movhi	r2,33044
811016f4:	1087b104 	addi	r2,r2,7876
811016f8:	e0ffe717 	ldw	r3,-100(fp)
811016fc:	18c7883a 	add	r3,r3,r3
81101700:	18c7883a 	add	r3,r3,r3
81101704:	10c5883a 	add	r2,r2,r3
81101708:	e0fff017 	ldw	r3,-64(fp)
8110170c:	10c00015 	stw	r3,0(r2)
81101710:	00001006 	br	81101754 <bDdr2MemoryWriteTest+0x234>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101714:	e0bfe717 	ldw	r2,-100(fp)
81101718:	10ffffc4 	addi	r3,r2,-1
8110171c:	00a04534 	movhi	r2,33044
81101720:	1087b104 	addi	r2,r2,7876
81101724:	18c7883a 	add	r3,r3,r3
81101728:	18c7883a 	add	r3,r3,r3
8110172c:	10c5883a 	add	r2,r2,r3
81101730:	10800017 	ldw	r2,0(r2)
81101734:	11000364 	muli	r4,r2,13
81101738:	00a04534 	movhi	r2,33044
8110173c:	1087b104 	addi	r2,r2,7876
81101740:	e0ffe717 	ldw	r3,-100(fp)
81101744:	18c7883a 	add	r3,r3,r3
81101748:	18c7883a 	add	r3,r3,r3
8110174c:	10c5883a 	add	r2,r2,r3
81101750:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
81101754:	e0bfe717 	ldw	r2,-100(fp)
81101758:	10800044 	addi	r2,r2,1
8110175c:	e0bfe715 	stw	r2,-100(fp)
81101760:	e0ffe717 	ldw	r3,-100(fp)
81101764:	e0bfea17 	ldw	r2,-88(fp)
81101768:	18bfdf16 	blt	r3,r2,811016e8 <__reset+0xfb0e16e8>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
8110176c:	e0bfea17 	ldw	r2,-88(fp)
81101770:	10ffffc4 	addi	r3,r2,-1
81101774:	00a04534 	movhi	r2,33044
81101778:	1087b104 	addi	r2,r2,7876
8110177c:	18c7883a 	add	r3,r3,r3
81101780:	18c7883a 	add	r3,r3,r3
81101784:	10c7883a 	add	r3,r2,r3
81101788:	00aaaaf4 	movhi	r2,43691
8110178c:	10aaaa84 	addi	r2,r2,-21846
81101790:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
81101794:	e0bfea17 	ldw	r2,-88(fp)
81101798:	10ffff84 	addi	r3,r2,-2
8110179c:	00a04534 	movhi	r2,33044
811017a0:	1087b104 	addi	r2,r2,7876
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c7883a 	add	r3,r2,r3
811017b0:	00955574 	movhi	r2,21845
811017b4:	10955544 	addi	r2,r2,21845
811017b8:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
811017bc:	e0bfea17 	ldw	r2,-88(fp)
811017c0:	10ffff44 	addi	r3,r2,-3
811017c4:	00a04534 	movhi	r2,33044
811017c8:	1087b104 	addi	r2,r2,7876
811017cc:	18c7883a 	add	r3,r3,r3
811017d0:	18c7883a 	add	r3,r3,r3
811017d4:	10c5883a 	add	r2,r2,r3
811017d8:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
811017dc:	e0bfea17 	ldw	r2,-88(fp)
811017e0:	10ffff04 	addi	r3,r2,-4
811017e4:	00a04534 	movhi	r2,33044
811017e8:	1087b104 	addi	r2,r2,7876
811017ec:	18c7883a 	add	r3,r3,r3
811017f0:	18c7883a 	add	r3,r3,r3
811017f4:	10c5883a 	add	r2,r2,r3
811017f8:	00ffffc4 	movi	r3,-1
811017fc:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101800:	00e04534 	movhi	r3,33044
81101804:	18c77104 	addi	r3,r3,7620
81101808:	00a04534 	movhi	r2,33044
8110180c:	10b37f04 	addi	r2,r2,-12804
81101810:	1009883a 	mov	r4,r2
81101814:	00800444 	movi	r2,17
81101818:	100d883a 	mov	r6,r2
8110181c:	200b883a 	mov	r5,r4
81101820:	1809883a 	mov	r4,r3
81101824:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
81101828:	d0a04e17 	ldw	r2,-32456(gp)
8110182c:	01604534 	movhi	r5,33044
81101830:	29477104 	addi	r5,r5,7620
81101834:	1009883a 	mov	r4,r2
81101838:	11126e00 	call	811126e0 <fprintf>
8110183c:	d0a06d17 	ldw	r2,-32332(gp)
#endif
	iTimeStart = alt_nticks();
81101840:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
81101844:	e0bfe517 	ldw	r2,-108(fp)
81101848:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
8110184c:	00810004 	movi	r2,1024
81101850:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101854:	e0ffe817 	ldw	r3,-96(fp)
81101858:	e0bfee17 	ldw	r2,-72(fp)
8110185c:	1885283a 	div	r2,r3,r2
81101860:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
81101864:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
81101868:	00003a06 	br	81101954 <bDdr2MemoryWriteTest+0x434>
		iNRemainedLen = uliByteLen - iNPos;
8110186c:	e0bfeb17 	ldw	r2,-84(fp)
81101870:	e0ffe617 	ldw	r3,-104(fp)
81101874:	1885c83a 	sub	r2,r3,r2
81101878:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
8110187c:	e0bfe817 	ldw	r2,-96(fp)
81101880:	e0fff217 	ldw	r3,-56(fp)
81101884:	1880060e 	bge	r3,r2,811018a0 <bDdr2MemoryWriteTest+0x380>
			iNAccessLen = iNRemainedLen;
81101888:	e0bff217 	ldw	r2,-56(fp)
8110188c:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101890:	e0ffe817 	ldw	r3,-96(fp)
81101894:	e0bfee17 	ldw	r2,-72(fp)
81101898:	1885283a 	div	r2,r3,r2
8110189c:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
811018a0:	e0bfe817 	ldw	r2,-96(fp)
811018a4:	100d883a 	mov	r6,r2
811018a8:	01604534 	movhi	r5,33044
811018ac:	2947b104 	addi	r5,r5,7876
811018b0:	e13fe917 	ldw	r4,-92(fp)
811018b4:	11136e00 	call	811136e0 <memcpy>
		pxDes += iNItemNum;
811018b8:	e0bfea17 	ldw	r2,-88(fp)
811018bc:	1085883a 	add	r2,r2,r2
811018c0:	1085883a 	add	r2,r2,r2
811018c4:	1007883a 	mov	r3,r2
811018c8:	e0bfe917 	ldw	r2,-92(fp)
811018cc:	10c5883a 	add	r2,r2,r3
811018d0:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
811018d4:	e0ffeb17 	ldw	r3,-84(fp)
811018d8:	e0bfe817 	ldw	r2,-96(fp)
811018dc:	1885883a 	add	r2,r3,r2
811018e0:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
811018e4:	e0bfec17 	ldw	r2,-80(fp)
811018e8:	10800288 	cmpgei	r2,r2,10
811018ec:	1000191e 	bne	r2,zero,81101954 <bDdr2MemoryWriteTest+0x434>
811018f0:	e0bfec17 	ldw	r2,-80(fp)
811018f4:	1085883a 	add	r2,r2,r2
811018f8:	1085883a 	add	r2,r2,r2
811018fc:	e0ffe504 	addi	r3,fp,-108
81101900:	1885883a 	add	r2,r3,r2
81101904:	10800e04 	addi	r2,r2,56
81101908:	10800017 	ldw	r2,0(r2)
8110190c:	e0ffeb17 	ldw	r3,-84(fp)
81101910:	18801036 	bltu	r3,r2,81101954 <bDdr2MemoryWriteTest+0x434>
			iNProgressIndex++;
81101914:	e0bfec17 	ldw	r2,-80(fp)
81101918:	10800044 	addi	r2,r2,1
8110191c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101920:	e0bfec17 	ldw	r2,-80(fp)
81101924:	108002a4 	muli	r2,r2,10
81101928:	100d883a 	mov	r6,r2
8110192c:	01604534 	movhi	r5,33044
81101930:	29738404 	addi	r5,r5,-12784
81101934:	01204534 	movhi	r4,33044
81101938:	21077104 	addi	r4,r4,7620
8110193c:	1113e480 	call	81113e48 <sprintf>
			debug(fp, cDebugBuffer);
81101940:	d0a04e17 	ldw	r2,-32456(gp)
81101944:	01604534 	movhi	r5,33044
81101948:	29477104 	addi	r5,r5,7620
8110194c:	1009883a 	mov	r4,r2
81101950:	11126e00 	call	811126e0 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
81101954:	e0ffeb17 	ldw	r3,-84(fp)
81101958:	e0bfe617 	ldw	r2,-104(fp)
8110195c:	18bfc336 	bltu	r3,r2,8110186c <__reset+0xfb0e186c>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
81101960:	1127f680 	call	81127f68 <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101964:	00a04534 	movhi	r2,33044
81101968:	10877104 	addi	r2,r2,7620
8110196c:	00c00284 	movi	r3,10
81101970:	10c00005 	stb	r3,0(r2)
81101974:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101978:	d0a04e17 	ldw	r2,-32456(gp)
8110197c:	01604534 	movhi	r5,33044
81101980:	29477104 	addi	r5,r5,7620
81101984:	1009883a 	mov	r4,r2
81101988:	11126e00 	call	811126e0 <fprintf>
8110198c:	d0e06d17 	ldw	r3,-32332(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101990:	e0bff117 	ldw	r2,-60(fp)
81101994:	1885c83a 	sub	r2,r3,r2
81101998:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
8110199c:	e0bfed17 	ldw	r2,-76(fp)
811019a0:	10001e26 	beq	r2,zero,81101a1c <bDdr2MemoryWriteTest+0x4fc>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
811019a4:	e13fef17 	ldw	r4,-68(fp)
811019a8:	111191c0 	call	8111191c <__floatsisf>
811019ac:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811019b0:	d0a06c17 	ldw	r2,-32336(gp)
811019b4:	1009883a 	mov	r4,r2
811019b8:	1111a480 	call	81111a48 <__floatunsisf>
811019bc:	1007883a 	mov	r3,r2
811019c0:	180b883a 	mov	r5,r3
811019c4:	8009883a 	mov	r4,r16
811019c8:	11110d00 	call	811110d0 <__divsf3>
811019cc:	1007883a 	mov	r3,r2
811019d0:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811019d4:	1009883a 	mov	r4,r2
811019d8:	11122600 	call	81112260 <__extendsfdf2>
811019dc:	1009883a 	mov	r4,r2
811019e0:	180b883a 	mov	r5,r3
811019e4:	d9400015 	stw	r5,0(sp)
811019e8:	200f883a 	mov	r7,r4
811019ec:	e1bfe617 	ldw	r6,-104(fp)
811019f0:	01604534 	movhi	r5,33044
811019f4:	29738604 	addi	r5,r5,-12776
811019f8:	01204534 	movhi	r4,33044
811019fc:	21077104 	addi	r4,r4,7620
81101a00:	1113e480 	call	81113e48 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a04:	d0a04e17 	ldw	r2,-32456(gp)
81101a08:	01604534 	movhi	r5,33044
81101a0c:	29477104 	addi	r5,r5,7620
81101a10:	1009883a 	mov	r4,r2
81101a14:	11126e00 	call	811126e0 <fprintf>
81101a18:	00000f06 	br	81101a58 <bDdr2MemoryWriteTest+0x538>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a1c:	00e04534 	movhi	r3,33044
81101a20:	18c77104 	addi	r3,r3,7620
81101a24:	00a04534 	movhi	r2,33044
81101a28:	10b39204 	addi	r2,r2,-12728
81101a2c:	1009883a 	mov	r4,r2
81101a30:	00800584 	movi	r2,22
81101a34:	100d883a 	mov	r6,r2
81101a38:	200b883a 	mov	r5,r4
81101a3c:	1809883a 	mov	r4,r3
81101a40:	11136e00 	call	811136e0 <memcpy>
		debug(fp, cDebugBuffer);
81101a44:	d0a04e17 	ldw	r2,-32456(gp)
81101a48:	01604534 	movhi	r5,33044
81101a4c:	29477104 	addi	r5,r5,7620
81101a50:	1009883a 	mov	r4,r2
81101a54:	11126e00 	call	811126e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101a58:	00a04534 	movhi	r2,33044
81101a5c:	10877104 	addi	r2,r2,7620
81101a60:	00c00284 	movi	r3,10
81101a64:	10c00005 	stb	r3,0(r2)
81101a68:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101a6c:	d0a04e17 	ldw	r2,-32456(gp)
81101a70:	01604534 	movhi	r5,33044
81101a74:	29477104 	addi	r5,r5,7620
81101a78:	1009883a 	mov	r4,r2
81101a7c:	11126e00 	call	811126e0 <fprintf>
#endif

	return bSuccess;
81101a80:	e0bfed17 	ldw	r2,-76(fp)
}
81101a84:	e6fffe04 	addi	sp,fp,-8
81101a88:	dfc00317 	ldw	ra,12(sp)
81101a8c:	df000217 	ldw	fp,8(sp)
81101a90:	dc400117 	ldw	r17,4(sp)
81101a94:	dc000017 	ldw	r16,0(sp)
81101a98:	dec00404 	addi	sp,sp,16
81101a9c:	f800283a 	ret

81101aa0 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mémoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101aa0:	deffe204 	addi	sp,sp,-120
81101aa4:	de00012e 	bgeu	sp,et,81101aac <bDdr2MemoryReadTest+0xc>
81101aa8:	003b68fa 	trap	3
81101aac:	dfc01d15 	stw	ra,116(sp)
81101ab0:	df001c15 	stw	fp,112(sp)
81101ab4:	dc401b15 	stw	r17,108(sp)
81101ab8:	dc001a15 	stw	r16,104(sp)
81101abc:	df001c04 	addi	fp,sp,112
81101ac0:	2005883a 	mov	r2,r4
81101ac4:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101ac8:	00e04534 	movhi	r3,33044
81101acc:	18c77104 	addi	r3,r3,7620
81101ad0:	00a04534 	movhi	r2,33044
81101ad4:	10b39804 	addi	r2,r2,-12704
81101ad8:	1009883a 	mov	r4,r2
81101adc:	008009c4 	movi	r2,39
81101ae0:	100d883a 	mov	r6,r2
81101ae4:	200b883a 	mov	r5,r4
81101ae8:	1809883a 	mov	r4,r3
81101aec:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
81101af0:	d0a04e17 	ldw	r2,-32456(gp)
81101af4:	01604534 	movhi	r5,33044
81101af8:	29477104 	addi	r5,r5,7620
81101afc:	1009883a 	mov	r4,r2
81101b00:	11126e00 	call	811126e0 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b04:	00800044 	movi	r2,1
81101b08:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b0c:	e0bffd03 	ldbu	r2,-12(fp)
81101b10:	10c00060 	cmpeqi	r3,r2,1
81101b14:	1800031e 	bne	r3,zero,81101b24 <bDdr2MemoryReadTest+0x84>
81101b18:	108000a0 	cmpeqi	r2,r2,2
81101b1c:	1000081e 	bne	r2,zero,81101b40 <bDdr2MemoryReadTest+0xa0>
81101b20:	00000e06 	br	81101b5c <bDdr2MemoryReadTest+0xbc>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b24:	e0bffd03 	ldbu	r2,-12(fp)
81101b28:	1009883a 	mov	r4,r2
81101b2c:	11014600 	call	81101460 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b30:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b34:	00a00034 	movhi	r2,32768
81101b38:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b3c:	00001906 	br	81101ba4 <bDdr2MemoryReadTest+0x104>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b40:	e0bffd03 	ldbu	r2,-12(fp)
81101b44:	1009883a 	mov	r4,r2
81101b48:	11014600 	call	81101460 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b4c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101b50:	00a00034 	movhi	r2,32768
81101b54:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b58:	00001206 	br	81101ba4 <bDdr2MemoryReadTest+0x104>
	default:
		bSuccess = FALSE;
81101b5c:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101b60:	00e04534 	movhi	r3,33044
81101b64:	18c77104 	addi	r3,r3,7620
81101b68:	00a04534 	movhi	r2,33044
81101b6c:	10b18004 	addi	r2,r2,-14848
81101b70:	1009883a 	mov	r4,r2
81101b74:	00800bc4 	movi	r2,47
81101b78:	100d883a 	mov	r6,r2
81101b7c:	200b883a 	mov	r5,r4
81101b80:	1809883a 	mov	r4,r3
81101b84:	11136e00 	call	811136e0 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101b88:	d0a04e17 	ldw	r2,-32456(gp)
81101b8c:	01604534 	movhi	r5,33044
81101b90:	29477104 	addi	r5,r5,7620
81101b94:	1009883a 	mov	r4,r2
81101b98:	11126e00 	call	811126e0 <fprintf>
		;
#endif
		return bSuccess;
81101b9c:	e0bfe517 	ldw	r2,-108(fp)
81101ba0:	0000fc06 	br	81101f94 <bDdr2MemoryReadTest+0x4f4>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101ba4:	e0bfe717 	ldw	r2,-100(fp)
81101ba8:	1004d53a 	srli	r2,r2,20
81101bac:	100d883a 	mov	r6,r2
81101bb0:	01604534 	movhi	r5,33044
81101bb4:	2973a204 	addi	r5,r5,-12664
81101bb8:	01204534 	movhi	r4,33044
81101bbc:	21077104 	addi	r4,r4,7620
81101bc0:	1113e480 	call	81113e48 <sprintf>
	debug(fp, cDebugBuffer);
81101bc4:	d0a04e17 	ldw	r2,-32456(gp)
81101bc8:	01604534 	movhi	r5,33044
81101bcc:	29477104 	addi	r5,r5,7620
81101bd0:	1009883a 	mov	r4,r2
81101bd4:	11126e00 	call	811126e0 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101bd8:	00804004 	movi	r2,256
81101bdc:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101be0:	00800104 	movi	r2,4
81101be4:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101be8:	e0ffec17 	ldw	r3,-80(fp)
81101bec:	e0bfef17 	ldw	r2,-68(fp)
81101bf0:	1885383a 	mul	r2,r3,r2
81101bf4:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101bf8:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101bfc:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c00:	e03fe815 	stw	zero,-96(fp)
81101c04:	00001506 	br	81101c5c <bDdr2MemoryReadTest+0x1bc>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c08:	e0ffe717 	ldw	r3,-100(fp)
81101c0c:	00b33374 	movhi	r2,52429
81101c10:	10b33344 	addi	r2,r2,-13107
81101c14:	1888383a 	mulxuu	r4,r3,r2
81101c18:	1885383a 	mul	r2,r3,r2
81101c1c:	1021883a 	mov	r16,r2
81101c20:	2023883a 	mov	r17,r4
81101c24:	8804d0fa 	srli	r2,r17,3
81101c28:	e0ffe817 	ldw	r3,-96(fp)
81101c2c:	18c00044 	addi	r3,r3,1
81101c30:	10c7383a 	mul	r3,r2,r3
81101c34:	e0bfe817 	ldw	r2,-96(fp)
81101c38:	1085883a 	add	r2,r2,r2
81101c3c:	1085883a 	add	r2,r2,r2
81101c40:	e13fe504 	addi	r4,fp,-108
81101c44:	2085883a 	add	r2,r4,r2
81101c48:	10800e04 	addi	r2,r2,56
81101c4c:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101c50:	e0bfe817 	ldw	r2,-96(fp)
81101c54:	10800044 	addi	r2,r2,1
81101c58:	e0bfe815 	stw	r2,-96(fp)
81101c5c:	e0bfe817 	ldw	r2,-96(fp)
81101c60:	10800290 	cmplti	r2,r2,10
81101c64:	103fe81e 	bne	r2,zero,81101c08 <__reset+0xfb0e1c08>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101c68:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101c6c:	00e04534 	movhi	r3,33044
81101c70:	18c77104 	addi	r3,r3,7620
81101c74:	00a04534 	movhi	r2,33044
81101c78:	10b3a804 	addi	r2,r2,-12640
81101c7c:	1009883a 	mov	r4,r2
81101c80:	008006c4 	movi	r2,27
81101c84:	100d883a 	mov	r6,r2
81101c88:	200b883a 	mov	r5,r4
81101c8c:	1809883a 	mov	r4,r3
81101c90:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
81101c94:	d0a04e17 	ldw	r2,-32456(gp)
81101c98:	01604534 	movhi	r5,33044
81101c9c:	29477104 	addi	r5,r5,7620
81101ca0:	1009883a 	mov	r4,r2
81101ca4:	11126e00 	call	811126e0 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101ca8:	d0a06d17 	ldw	r2,-32332(gp)
#endif
	iTimeStart = alt_nticks();
81101cac:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101cb0:	e0bfe617 	ldw	r2,-104(fp)
81101cb4:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101cb8:	00810004 	movi	r2,1024
81101cbc:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101cc0:	e0ffe917 	ldw	r3,-92(fp)
81101cc4:	e0bfef17 	ldw	r2,-68(fp)
81101cc8:	1885283a 	div	r2,r3,r2
81101ccc:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101cd0:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101cd4:	00006206 	br	81101e60 <bDdr2MemoryReadTest+0x3c0>
		iNRemainedLen = uliByteLen - iNPos;
81101cd8:	e0bfed17 	ldw	r2,-76(fp)
81101cdc:	e0ffe717 	ldw	r3,-100(fp)
81101ce0:	1885c83a 	sub	r2,r3,r2
81101ce4:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101ce8:	e0bfe917 	ldw	r2,-92(fp)
81101cec:	e0fff217 	ldw	r3,-56(fp)
81101cf0:	1880060e 	bge	r3,r2,81101d0c <bDdr2MemoryReadTest+0x26c>
			iNAccessLen = iNRemainedLen;
81101cf4:	e0bff217 	ldw	r2,-56(fp)
81101cf8:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101cfc:	e0ffe917 	ldw	r3,-92(fp)
81101d00:	e0bfef17 	ldw	r2,-68(fp)
81101d04:	1885283a 	div	r2,r3,r2
81101d08:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d0c:	00a04534 	movhi	r2,33044
81101d10:	1087b104 	addi	r2,r2,7876
81101d14:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d18:	e03fe815 	stw	zero,-96(fp)
81101d1c:	00002b06 	br	81101dcc <bDdr2MemoryReadTest+0x32c>
			if (*pxSrc++ != *pxDes++) {
81101d20:	e0bfeb17 	ldw	r2,-84(fp)
81101d24:	10c00104 	addi	r3,r2,4
81101d28:	e0ffeb15 	stw	r3,-84(fp)
81101d2c:	10c00017 	ldw	r3,0(r2)
81101d30:	e0bfea17 	ldw	r2,-88(fp)
81101d34:	11000104 	addi	r4,r2,4
81101d38:	e13fea15 	stw	r4,-88(fp)
81101d3c:	10800017 	ldw	r2,0(r2)
81101d40:	18801f26 	beq	r3,r2,81101dc0 <bDdr2MemoryReadTest+0x320>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101d44:	e0bfeb17 	ldw	r2,-84(fp)
81101d48:	10bfff04 	addi	r2,r2,-4
81101d4c:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101d50:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101d54:	00a04534 	movhi	r2,33044
81101d58:	1087b104 	addi	r2,r2,7876
81101d5c:	e0ffe817 	ldw	r3,-96(fp)
81101d60:	18c7883a 	add	r3,r3,r3
81101d64:	18c7883a 	add	r3,r3,r3
81101d68:	10c5883a 	add	r2,r2,r3
81101d6c:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101d70:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101d74:	e0ffed17 	ldw	r3,-76(fp)
81101d78:	e0bfef17 	ldw	r2,-68(fp)
81101d7c:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101d80:	e0bfe817 	ldw	r2,-96(fp)
81101d84:	1885883a 	add	r2,r3,r2
81101d88:	d8800015 	stw	r2,0(sp)
81101d8c:	280f883a 	mov	r7,r5
81101d90:	200d883a 	mov	r6,r4
81101d94:	01604534 	movhi	r5,33044
81101d98:	2973af04 	addi	r5,r5,-12612
81101d9c:	01204534 	movhi	r4,33044
81101da0:	21077104 	addi	r4,r4,7620
81101da4:	1113e480 	call	81113e48 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101da8:	d0a04e17 	ldw	r2,-32456(gp)
81101dac:	01604534 	movhi	r5,33044
81101db0:	29477104 	addi	r5,r5,7620
81101db4:	1009883a 	mov	r4,r2
81101db8:	11126e00 	call	811126e0 <fprintf>
#endif
				bSuccess = FALSE;
81101dbc:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101dc0:	e0bfe817 	ldw	r2,-96(fp)
81101dc4:	10800044 	addi	r2,r2,1
81101dc8:	e0bfe815 	stw	r2,-96(fp)
81101dcc:	e0ffe817 	ldw	r3,-96(fp)
81101dd0:	e0bfec17 	ldw	r2,-80(fp)
81101dd4:	1880020e 	bge	r3,r2,81101de0 <bDdr2MemoryReadTest+0x340>
81101dd8:	e0bfe517 	ldw	r2,-108(fp)
81101ddc:	103fd01e 	bne	r2,zero,81101d20 <__reset+0xfb0e1d20>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101de0:	e0ffed17 	ldw	r3,-76(fp)
81101de4:	e0bfe917 	ldw	r2,-92(fp)
81101de8:	1885883a 	add	r2,r3,r2
81101dec:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101df0:	e0bfee17 	ldw	r2,-72(fp)
81101df4:	10800288 	cmpgei	r2,r2,10
81101df8:	1000191e 	bne	r2,zero,81101e60 <bDdr2MemoryReadTest+0x3c0>
81101dfc:	e0bfee17 	ldw	r2,-72(fp)
81101e00:	1085883a 	add	r2,r2,r2
81101e04:	1085883a 	add	r2,r2,r2
81101e08:	e0ffe504 	addi	r3,fp,-108
81101e0c:	1885883a 	add	r2,r3,r2
81101e10:	10800e04 	addi	r2,r2,56
81101e14:	10800017 	ldw	r2,0(r2)
81101e18:	e0ffed17 	ldw	r3,-76(fp)
81101e1c:	18801036 	bltu	r3,r2,81101e60 <bDdr2MemoryReadTest+0x3c0>
			iNProgressIndex++;
81101e20:	e0bfee17 	ldw	r2,-72(fp)
81101e24:	10800044 	addi	r2,r2,1
81101e28:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e2c:	e0bfee17 	ldw	r2,-72(fp)
81101e30:	108002a4 	muli	r2,r2,10
81101e34:	100d883a 	mov	r6,r2
81101e38:	01604534 	movhi	r5,33044
81101e3c:	29738404 	addi	r5,r5,-12784
81101e40:	01204534 	movhi	r4,33044
81101e44:	21077104 	addi	r4,r4,7620
81101e48:	1113e480 	call	81113e48 <sprintf>
			debug(fp, cDebugBuffer);
81101e4c:	d0a04e17 	ldw	r2,-32456(gp)
81101e50:	01604534 	movhi	r5,33044
81101e54:	29477104 	addi	r5,r5,7620
81101e58:	1009883a 	mov	r4,r2
81101e5c:	11126e00 	call	811126e0 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101e60:	e0bfe517 	ldw	r2,-108(fp)
81101e64:	10000326 	beq	r2,zero,81101e74 <bDdr2MemoryReadTest+0x3d4>
81101e68:	e0ffed17 	ldw	r3,-76(fp)
81101e6c:	e0bfe717 	ldw	r2,-100(fp)
81101e70:	18bf9936 	bltu	r3,r2,81101cd8 <__reset+0xfb0e1cd8>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101e74:	00a04534 	movhi	r2,33044
81101e78:	10877104 	addi	r2,r2,7620
81101e7c:	00c00284 	movi	r3,10
81101e80:	10c00005 	stb	r3,0(r2)
81101e84:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101e88:	d0a04e17 	ldw	r2,-32456(gp)
81101e8c:	01604534 	movhi	r5,33044
81101e90:	29477104 	addi	r5,r5,7620
81101e94:	1009883a 	mov	r4,r2
81101e98:	11126e00 	call	811126e0 <fprintf>
81101e9c:	d0e06d17 	ldw	r3,-32332(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101ea0:	e0bff117 	ldw	r2,-60(fp)
81101ea4:	1885c83a 	sub	r2,r3,r2
81101ea8:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101eac:	e0bfe517 	ldw	r2,-108(fp)
81101eb0:	10001e26 	beq	r2,zero,81101f2c <bDdr2MemoryReadTest+0x48c>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101eb4:	e13ff017 	ldw	r4,-64(fp)
81101eb8:	111191c0 	call	8111191c <__floatsisf>
81101ebc:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101ec0:	d0a06c17 	ldw	r2,-32336(gp)
81101ec4:	1009883a 	mov	r4,r2
81101ec8:	1111a480 	call	81111a48 <__floatunsisf>
81101ecc:	1007883a 	mov	r3,r2
81101ed0:	180b883a 	mov	r5,r3
81101ed4:	8009883a 	mov	r4,r16
81101ed8:	11110d00 	call	811110d0 <__divsf3>
81101edc:	1007883a 	mov	r3,r2
81101ee0:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101ee4:	1009883a 	mov	r4,r2
81101ee8:	11122600 	call	81112260 <__extendsfdf2>
81101eec:	1009883a 	mov	r4,r2
81101ef0:	180b883a 	mov	r5,r3
81101ef4:	d9400015 	stw	r5,0(sp)
81101ef8:	200f883a 	mov	r7,r4
81101efc:	e1bfe717 	ldw	r6,-100(fp)
81101f00:	01604534 	movhi	r5,33044
81101f04:	2973bd04 	addi	r5,r5,-12556
81101f08:	01204534 	movhi	r4,33044
81101f0c:	21077104 	addi	r4,r4,7620
81101f10:	1113e480 	call	81113e48 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f14:	d0a04e17 	ldw	r2,-32456(gp)
81101f18:	01604534 	movhi	r5,33044
81101f1c:	29477104 	addi	r5,r5,7620
81101f20:	1009883a 	mov	r4,r2
81101f24:	11126e00 	call	811126e0 <fprintf>
81101f28:	00000f06 	br	81101f68 <bDdr2MemoryReadTest+0x4c8>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f2c:	00e04534 	movhi	r3,33044
81101f30:	18c77104 	addi	r3,r3,7620
81101f34:	00a04534 	movhi	r2,33044
81101f38:	10b3c904 	addi	r2,r2,-12508
81101f3c:	1009883a 	mov	r4,r2
81101f40:	00800544 	movi	r2,21
81101f44:	100d883a 	mov	r6,r2
81101f48:	200b883a 	mov	r5,r4
81101f4c:	1809883a 	mov	r4,r3
81101f50:	11136e00 	call	811136e0 <memcpy>
		debug(fp, cDebugBuffer);
81101f54:	d0a04e17 	ldw	r2,-32456(gp)
81101f58:	01604534 	movhi	r5,33044
81101f5c:	29477104 	addi	r5,r5,7620
81101f60:	1009883a 	mov	r4,r2
81101f64:	11126e00 	call	811126e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101f68:	00a04534 	movhi	r2,33044
81101f6c:	10877104 	addi	r2,r2,7620
81101f70:	00c00284 	movi	r3,10
81101f74:	10c00005 	stb	r3,0(r2)
81101f78:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101f7c:	d0a04e17 	ldw	r2,-32456(gp)
81101f80:	01604534 	movhi	r5,33044
81101f84:	29477104 	addi	r5,r5,7620
81101f88:	1009883a 	mov	r4,r2
81101f8c:	11126e00 	call	811126e0 <fprintf>
#endif

	return bSuccess;
81101f90:	e0bfe517 	ldw	r2,-108(fp)
}
81101f94:	e6fffe04 	addi	sp,fp,-8
81101f98:	dfc00317 	ldw	ra,12(sp)
81101f9c:	df000217 	ldw	fp,8(sp)
81101fa0:	dc400117 	ldw	r17,4(sp)
81101fa4:	dc000017 	ldw	r16,0(sp)
81101fa8:	dec00404 	addi	sp,sp,16
81101fac:	f800283a 	ret

81101fb0 <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a duração da função será medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81101fb0:	deffec04 	addi	sp,sp,-80
81101fb4:	de00012e 	bgeu	sp,et,81101fbc <bDdr2MemoryRandomWriteTest+0xc>
81101fb8:	003b68fa 	trap	3
81101fbc:	dfc01315 	stw	ra,76(sp)
81101fc0:	df001215 	stw	fp,72(sp)
81101fc4:	dcc01115 	stw	r19,68(sp)
81101fc8:	dc801015 	stw	r18,64(sp)
81101fcc:	dc400f15 	stw	r17,60(sp)
81101fd0:	dc000e15 	stw	r16,56(sp)
81101fd4:	df001204 	addi	fp,sp,72
81101fd8:	2005883a 	mov	r2,r4
81101fdc:	e17ffa15 	stw	r5,-24(fp)
81101fe0:	e1bffb15 	stw	r6,-20(fp)
81101fe4:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81101fe8:	00e04534 	movhi	r3,33044
81101fec:	18c77104 	addi	r3,r3,7620
81101ff0:	00a04534 	movhi	r2,33044
81101ff4:	10b3cf04 	addi	r2,r2,-12484
81101ff8:	1009883a 	mov	r4,r2
81101ffc:	00800bc4 	movi	r2,47
81102000:	100d883a 	mov	r6,r2
81102004:	200b883a 	mov	r5,r4
81102008:	1809883a 	mov	r4,r3
8110200c:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
81102010:	d0a04e17 	ldw	r2,-32456(gp)
81102014:	01604534 	movhi	r5,33044
81102018:	29477104 	addi	r5,r5,7620
8110201c:	1009883a 	mov	r4,r2
81102020:	11126e00 	call	811126e0 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102024:	00800044 	movi	r2,1
81102028:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
8110202c:	e0bff903 	ldbu	r2,-28(fp)
81102030:	10c00060 	cmpeqi	r3,r2,1
81102034:	1800031e 	bne	r3,zero,81102044 <bDdr2MemoryRandomWriteTest+0x94>
81102038:	108000a0 	cmpeqi	r2,r2,2
8110203c:	1000081e 	bne	r2,zero,81102060 <bDdr2MemoryRandomWriteTest+0xb0>
81102040:	00000e06 	br	8110207c <bDdr2MemoryRandomWriteTest+0xcc>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102044:	e0bff903 	ldbu	r2,-28(fp)
81102048:	1009883a 	mov	r4,r2
8110204c:	11014600 	call	81101460 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102050:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102054:	00a00034 	movhi	r2,32768
81102058:	e0bff015 	stw	r2,-64(fp)
		break;
8110205c:	00001906 	br	811020c4 <bDdr2MemoryRandomWriteTest+0x114>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102060:	e0bff903 	ldbu	r2,-28(fp)
81102064:	1009883a 	mov	r4,r2
81102068:	11014600 	call	81101460 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110206c:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102070:	00a00034 	movhi	r2,32768
81102074:	e0bff015 	stw	r2,-64(fp)
		break;
81102078:	00001206 	br	811020c4 <bDdr2MemoryRandomWriteTest+0x114>
	default:
		bSuccess = FALSE;
8110207c:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102080:	00e04534 	movhi	r3,33044
81102084:	18c77104 	addi	r3,r3,7620
81102088:	00a04534 	movhi	r2,33044
8110208c:	10b18004 	addi	r2,r2,-14848
81102090:	1009883a 	mov	r4,r2
81102094:	00800bc4 	movi	r2,47
81102098:	100d883a 	mov	r6,r2
8110209c:	200b883a 	mov	r5,r4
811020a0:	1809883a 	mov	r4,r3
811020a4:	11136e00 	call	811136e0 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811020a8:	d0a04e17 	ldw	r2,-32456(gp)
811020ac:	01604534 	movhi	r5,33044
811020b0:	29477104 	addi	r5,r5,7620
811020b4:	1009883a 	mov	r4,r2
811020b8:	11126e00 	call	811126e0 <fprintf>
		;
#endif
		return bSuccess;
811020bc:	e0bff417 	ldw	r2,-48(fp)
811020c0:	0000ce06 	br	811023fc <bDdr2MemoryRandomWriteTest+0x44c>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
811020c4:	e0bff017 	ldw	r2,-64(fp)
811020c8:	1004d53a 	srli	r2,r2,20
811020cc:	100d883a 	mov	r6,r2
811020d0:	01604534 	movhi	r5,33044
811020d4:	29737904 	addi	r5,r5,-12828
811020d8:	01204534 	movhi	r4,33044
811020dc:	21077104 	addi	r4,r4,7620
811020e0:	1113e480 	call	81113e48 <sprintf>
	debug(fp, cDebugBuffer);
811020e4:	d0a04e17 	ldw	r2,-32456(gp)
811020e8:	01604534 	movhi	r5,33044
811020ec:	29477104 	addi	r5,r5,7620
811020f0:	1009883a 	mov	r4,r2
811020f4:	11126e00 	call	811126e0 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
811020f8:	d0a06d17 	ldw	r2,-32332(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
811020fc:	d0a03615 	stw	r2,-32552(gp)
	uliCurrentState = uliInitialState;
81102100:	d0a03617 	ldw	r2,-32552(gp)
81102104:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102108:	e0ffef17 	ldw	r3,-68(fp)
8110210c:	e0bff017 	ldw	r2,-64(fp)
81102110:	1885883a 	add	r2,r3,r2
81102114:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102118:	e0fff017 	ldw	r3,-64(fp)
8110211c:	00b33374 	movhi	r2,52429
81102120:	10b33344 	addi	r2,r2,-13107
81102124:	1888383a 	mulxuu	r4,r3,r2
81102128:	1885383a 	mul	r2,r3,r2
8110212c:	1025883a 	mov	r18,r2
81102130:	2027883a 	mov	r19,r4
81102134:	9806d13a 	srli	r3,r19,4
81102138:	e0bfef17 	ldw	r2,-68(fp)
8110213c:	1885883a 	add	r2,r3,r2
81102140:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
81102144:	00800144 	movi	r2,5
81102148:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
8110214c:	00e04534 	movhi	r3,33044
81102150:	18c77104 	addi	r3,r3,7620
81102154:	00a04534 	movhi	r2,33044
81102158:	10b3db04 	addi	r2,r2,-12436
8110215c:	1009883a 	mov	r4,r2
81102160:	00800584 	movi	r2,22
81102164:	100d883a 	mov	r6,r2
81102168:	200b883a 	mov	r5,r4
8110216c:	1809883a 	mov	r4,r3
81102170:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
81102174:	d0a04e17 	ldw	r2,-32456(gp)
81102178:	01604534 	movhi	r5,33044
8110217c:	29477104 	addi	r5,r5,7620
81102180:	1009883a 	mov	r4,r2
81102184:	11126e00 	call	811126e0 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102188:	e0bffa17 	ldw	r2,-24(fp)
8110218c:	10800058 	cmpnei	r2,r2,1
81102190:	10000a1e 	bne	r2,zero,811021bc <bDdr2MemoryRandomWriteTest+0x20c>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102194:	01604534 	movhi	r5,33044
81102198:	2973e104 	addi	r5,r5,-12412
8110219c:	01204534 	movhi	r4,33044
811021a0:	21077104 	addi	r4,r4,7620
811021a4:	1113e480 	call	81113e48 <sprintf>
		debug(fp, cDebugBuffer);
811021a8:	d0a04e17 	ldw	r2,-32456(gp)
811021ac:	01604534 	movhi	r5,33044
811021b0:	29477104 	addi	r5,r5,7620
811021b4:	1009883a 	mov	r4,r2
811021b8:	11126e00 	call	811126e0 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
811021bc:	e03ff615 	stw	zero,-40(fp)
811021c0:	d0a06d17 	ldw	r2,-32332(gp)

	TimeStart = alt_nticks();
811021c4:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
811021c8:	e0bfef17 	ldw	r2,-68(fp)
811021cc:	e0bff115 	stw	r2,-60(fp)
811021d0:	00002c06 	br	81102284 <bDdr2MemoryRandomWriteTest+0x2d4>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
811021d4:	e0bff804 	addi	r2,fp,-32
811021d8:	1009883a 	mov	r4,r2
811021dc:	11028bc0 	call	811028bc <uliXorshift32>
811021e0:	1007883a 	mov	r3,r2
811021e4:	e0bff117 	ldw	r2,-60(fp)
811021e8:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
811021ec:	e0bffa17 	ldw	r2,-24(fp)
811021f0:	10800060 	cmpeqi	r2,r2,1
811021f4:	1009883a 	mov	r4,r2
811021f8:	e0bff117 	ldw	r2,-60(fp)
811021fc:	e0fff217 	ldw	r3,-56(fp)
81102200:	1885803a 	cmpltu	r2,r3,r2
81102204:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102208:	10803fcc 	andi	r2,r2,255
8110220c:	10001a26 	beq	r2,zero,81102278 <bDdr2MemoryRandomWriteTest+0x2c8>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102210:	e0bff303 	ldbu	r2,-52(fp)
81102214:	100d883a 	mov	r6,r2
81102218:	01604534 	movhi	r5,33044
8110221c:	2973e304 	addi	r5,r5,-12404
81102220:	01204534 	movhi	r4,33044
81102224:	21077104 	addi	r4,r4,7620
81102228:	1113e480 	call	81113e48 <sprintf>
			debug(fp, cDebugBuffer);
8110222c:	d0a04e17 	ldw	r2,-32456(gp)
81102230:	01604534 	movhi	r5,33044
81102234:	29477104 	addi	r5,r5,7620
81102238:	1009883a 	mov	r4,r2
8110223c:	11126e00 	call	811126e0 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102240:	e0fff017 	ldw	r3,-64(fp)
81102244:	00b33374 	movhi	r2,52429
81102248:	10b33344 	addi	r2,r2,-13107
8110224c:	1888383a 	mulxuu	r4,r3,r2
81102250:	1885383a 	mul	r2,r3,r2
81102254:	1021883a 	mov	r16,r2
81102258:	2023883a 	mov	r17,r4
8110225c:	8804d13a 	srli	r2,r17,4
81102260:	e0fff217 	ldw	r3,-56(fp)
81102264:	1885883a 	add	r2,r3,r2
81102268:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
8110226c:	e0bff303 	ldbu	r2,-52(fp)
81102270:	10800144 	addi	r2,r2,5
81102274:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
81102278:	e0bff117 	ldw	r2,-60(fp)
8110227c:	10800104 	addi	r2,r2,4
81102280:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
81102284:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102288:	e0bff517 	ldw	r2,-44(fp)
8110228c:	18bfd136 	bltu	r3,r2,811021d4 <__reset+0xfb0e21d4>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
81102290:	1127f680 	call	81127f68 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
81102294:	e0bffa17 	ldw	r2,-24(fp)
81102298:	10800058 	cmpnei	r2,r2,1
8110229c:	10000a1e 	bne	r2,zero,811022c8 <bDdr2MemoryRandomWriteTest+0x318>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022a0:	01604534 	movhi	r5,33044
811022a4:	2973e604 	addi	r5,r5,-12392
811022a8:	01204534 	movhi	r4,33044
811022ac:	21077104 	addi	r4,r4,7620
811022b0:	1113e480 	call	81113e48 <sprintf>
		debug(fp, cDebugBuffer);
811022b4:	d0a04e17 	ldw	r2,-32456(gp)
811022b8:	01604534 	movhi	r5,33044
811022bc:	29477104 	addi	r5,r5,7620
811022c0:	1009883a 	mov	r4,r2
811022c4:	11126e00 	call	811126e0 <fprintf>
#endif
	}

	if (bSuccess) {
811022c8:	e0bff417 	ldw	r2,-48(fp)
811022cc:	10003126 	beq	r2,zero,81102394 <bDdr2MemoryRandomWriteTest+0x3e4>
		if (bTime == TRUE) {
811022d0:	e0bffb17 	ldw	r2,-20(fp)
811022d4:	10800058 	cmpnei	r2,r2,1
811022d8:	1000221e 	bne	r2,zero,81102364 <bDdr2MemoryRandomWriteTest+0x3b4>
811022dc:	d0e06d17 	ldw	r3,-32332(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811022e0:	e0bff717 	ldw	r2,-36(fp)
811022e4:	1885c83a 	sub	r2,r3,r2
811022e8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811022ec:	e13ff617 	ldw	r4,-40(fp)
811022f0:	111191c0 	call	8111191c <__floatsisf>
811022f4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811022f8:	d0a06c17 	ldw	r2,-32336(gp)
811022fc:	1009883a 	mov	r4,r2
81102300:	1111a480 	call	81111a48 <__floatunsisf>
81102304:	1007883a 	mov	r3,r2
81102308:	180b883a 	mov	r5,r3
8110230c:	8009883a 	mov	r4,r16
81102310:	11110d00 	call	811110d0 <__divsf3>
81102314:	1007883a 	mov	r3,r2
81102318:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110231c:	1009883a 	mov	r4,r2
81102320:	11122600 	call	81112260 <__extendsfdf2>
81102324:	1009883a 	mov	r4,r2
81102328:	180b883a 	mov	r5,r3
8110232c:	d9400015 	stw	r5,0(sp)
81102330:	200f883a 	mov	r7,r4
81102334:	e1bff017 	ldw	r6,-64(fp)
81102338:	01604534 	movhi	r5,33044
8110233c:	2973e904 	addi	r5,r5,-12380
81102340:	01204534 	movhi	r4,33044
81102344:	21077104 	addi	r4,r4,7620
81102348:	1113e480 	call	81113e48 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110234c:	d0a04e17 	ldw	r2,-32456(gp)
81102350:	01604534 	movhi	r5,33044
81102354:	29477104 	addi	r5,r5,7620
81102358:	1009883a 	mov	r4,r2
8110235c:	11126e00 	call	811126e0 <fprintf>
81102360:	00001b06 	br	811023d0 <bDdr2MemoryRandomWriteTest+0x420>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
81102364:	e1bff017 	ldw	r6,-64(fp)
81102368:	01604534 	movhi	r5,33044
8110236c:	2973f504 	addi	r5,r5,-12332
81102370:	01204534 	movhi	r4,33044
81102374:	21077104 	addi	r4,r4,7620
81102378:	1113e480 	call	81113e48 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110237c:	d0a04e17 	ldw	r2,-32456(gp)
81102380:	01604534 	movhi	r5,33044
81102384:	29477104 	addi	r5,r5,7620
81102388:	1009883a 	mov	r4,r2
8110238c:	11126e00 	call	811126e0 <fprintf>
81102390:	00000f06 	br	811023d0 <bDdr2MemoryRandomWriteTest+0x420>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81102394:	00e04534 	movhi	r3,33044
81102398:	18c77104 	addi	r3,r3,7620
8110239c:	00a04534 	movhi	r2,33044
811023a0:	10b39204 	addi	r2,r2,-12728
811023a4:	1009883a 	mov	r4,r2
811023a8:	00800584 	movi	r2,22
811023ac:	100d883a 	mov	r6,r2
811023b0:	200b883a 	mov	r5,r4
811023b4:	1809883a 	mov	r4,r3
811023b8:	11136e00 	call	811136e0 <memcpy>
		debug(fp, cDebugBuffer);
811023bc:	d0a04e17 	ldw	r2,-32456(gp)
811023c0:	01604534 	movhi	r5,33044
811023c4:	29477104 	addi	r5,r5,7620
811023c8:	1009883a 	mov	r4,r2
811023cc:	11126e00 	call	811126e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811023d0:	00a04534 	movhi	r2,33044
811023d4:	10877104 	addi	r2,r2,7620
811023d8:	00c00284 	movi	r3,10
811023dc:	10c00005 	stb	r3,0(r2)
811023e0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811023e4:	d0a04e17 	ldw	r2,-32456(gp)
811023e8:	01604534 	movhi	r5,33044
811023ec:	29477104 	addi	r5,r5,7620
811023f0:	1009883a 	mov	r4,r2
811023f4:	11126e00 	call	811126e0 <fprintf>
#endif

	return bSuccess;
811023f8:	e0bff417 	ldw	r2,-48(fp)
}
811023fc:	e6fffc04 	addi	sp,fp,-16
81102400:	dfc00517 	ldw	ra,20(sp)
81102404:	df000417 	ldw	fp,16(sp)
81102408:	dcc00317 	ldw	r19,12(sp)
8110240c:	dc800217 	ldw	r18,8(sp)
81102410:	dc400117 	ldw	r17,4(sp)
81102414:	dc000017 	ldw	r16,0(sp)
81102418:	dec00604 	addi	sp,sp,24
8110241c:	f800283a 	ret

81102420 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a duração da função será medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102420:	deffec04 	addi	sp,sp,-80
81102424:	de00012e 	bgeu	sp,et,8110242c <bDdr2MemoryRandomReadTest+0xc>
81102428:	003b68fa 	trap	3
8110242c:	dfc01315 	stw	ra,76(sp)
81102430:	df001215 	stw	fp,72(sp)
81102434:	dcc01115 	stw	r19,68(sp)
81102438:	dc801015 	stw	r18,64(sp)
8110243c:	dc400f15 	stw	r17,60(sp)
81102440:	dc000e15 	stw	r16,56(sp)
81102444:	df001204 	addi	fp,sp,72
81102448:	2005883a 	mov	r2,r4
8110244c:	e17ffa15 	stw	r5,-24(fp)
81102450:	e1bffb15 	stw	r6,-20(fp)
81102454:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
81102458:	00e04534 	movhi	r3,33044
8110245c:	18c77104 	addi	r3,r3,7620
81102460:	00a04534 	movhi	r2,33044
81102464:	10b3ff04 	addi	r2,r2,-12292
81102468:	1009883a 	mov	r4,r2
8110246c:	00800b84 	movi	r2,46
81102470:	100d883a 	mov	r6,r2
81102474:	200b883a 	mov	r5,r4
81102478:	1809883a 	mov	r4,r3
8110247c:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
81102480:	d0a04e17 	ldw	r2,-32456(gp)
81102484:	01604534 	movhi	r5,33044
81102488:	29477104 	addi	r5,r5,7620
8110248c:	1009883a 	mov	r4,r2
81102490:	11126e00 	call	811126e0 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102494:	00800044 	movi	r2,1
81102498:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
8110249c:	e0bff903 	ldbu	r2,-28(fp)
811024a0:	10c00060 	cmpeqi	r3,r2,1
811024a4:	1800031e 	bne	r3,zero,811024b4 <bDdr2MemoryRandomReadTest+0x94>
811024a8:	108000a0 	cmpeqi	r2,r2,2
811024ac:	1000081e 	bne	r2,zero,811024d0 <bDdr2MemoryRandomReadTest+0xb0>
811024b0:	00000e06 	br	811024ec <bDdr2MemoryRandomReadTest+0xcc>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
811024b4:	e0bff903 	ldbu	r2,-28(fp)
811024b8:	1009883a 	mov	r4,r2
811024bc:	11014600 	call	81101460 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811024c0:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811024c4:	00a00034 	movhi	r2,32768
811024c8:	e0bff115 	stw	r2,-60(fp)
		break;
811024cc:	00001906 	br	81102534 <bDdr2MemoryRandomReadTest+0x114>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811024d0:	e0bff903 	ldbu	r2,-28(fp)
811024d4:	1009883a 	mov	r4,r2
811024d8:	11014600 	call	81101460 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811024dc:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811024e0:	00a00034 	movhi	r2,32768
811024e4:	e0bff115 	stw	r2,-60(fp)
		break;
811024e8:	00001206 	br	81102534 <bDdr2MemoryRandomReadTest+0x114>
	default:
		bSuccess = FALSE;
811024ec:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811024f0:	00e04534 	movhi	r3,33044
811024f4:	18c77104 	addi	r3,r3,7620
811024f8:	00a04534 	movhi	r2,33044
811024fc:	10b18004 	addi	r2,r2,-14848
81102500:	1009883a 	mov	r4,r2
81102504:	00800bc4 	movi	r2,47
81102508:	100d883a 	mov	r6,r2
8110250c:	200b883a 	mov	r5,r4
81102510:	1809883a 	mov	r4,r3
81102514:	11136e00 	call	811136e0 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102518:	d0a04e17 	ldw	r2,-32456(gp)
8110251c:	01604534 	movhi	r5,33044
81102520:	29477104 	addi	r5,r5,7620
81102524:	1009883a 	mov	r4,r2
81102528:	11126e00 	call	811126e0 <fprintf>
		;
#endif
		return bSuccess;
8110252c:	e0bfef17 	ldw	r2,-68(fp)
81102530:	0000d906 	br	81102898 <bDdr2MemoryRandomReadTest+0x478>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102534:	e0bff117 	ldw	r2,-60(fp)
81102538:	1004d53a 	srli	r2,r2,20
8110253c:	100d883a 	mov	r6,r2
81102540:	01604534 	movhi	r5,33044
81102544:	29737904 	addi	r5,r5,-12828
81102548:	01204534 	movhi	r4,33044
8110254c:	21077104 	addi	r4,r4,7620
81102550:	1113e480 	call	81113e48 <sprintf>
	debug(fp, cDebugBuffer);
81102554:	d0a04e17 	ldw	r2,-32456(gp)
81102558:	01604534 	movhi	r5,33044
8110255c:	29477104 	addi	r5,r5,7620
81102560:	1009883a 	mov	r4,r2
81102564:	11126e00 	call	811126e0 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
81102568:	d0a03617 	ldw	r2,-32552(gp)
8110256c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102570:	e0fff017 	ldw	r3,-64(fp)
81102574:	e0bff117 	ldw	r2,-60(fp)
81102578:	1885883a 	add	r2,r3,r2
8110257c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102580:	e0fff117 	ldw	r3,-60(fp)
81102584:	00b33374 	movhi	r2,52429
81102588:	10b33344 	addi	r2,r2,-13107
8110258c:	1888383a 	mulxuu	r4,r3,r2
81102590:	1885383a 	mul	r2,r3,r2
81102594:	1025883a 	mov	r18,r2
81102598:	2027883a 	mov	r19,r4
8110259c:	9806d13a 	srli	r3,r19,4
811025a0:	e0bff017 	ldw	r2,-64(fp)
811025a4:	1885883a 	add	r2,r3,r2
811025a8:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
811025ac:	00800144 	movi	r2,5
811025b0:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
811025b4:	00e04534 	movhi	r3,33044
811025b8:	18c77104 	addi	r3,r3,7620
811025bc:	00a04534 	movhi	r2,33044
811025c0:	10b40b04 	addi	r2,r2,-12244
811025c4:	1009883a 	mov	r4,r2
811025c8:	00800604 	movi	r2,24
811025cc:	100d883a 	mov	r6,r2
811025d0:	200b883a 	mov	r5,r4
811025d4:	1809883a 	mov	r4,r3
811025d8:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
811025dc:	d0a04e17 	ldw	r2,-32456(gp)
811025e0:	01604534 	movhi	r5,33044
811025e4:	29477104 	addi	r5,r5,7620
811025e8:	1009883a 	mov	r4,r2
811025ec:	11126e00 	call	811126e0 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811025f0:	e0bffa17 	ldw	r2,-24(fp)
811025f4:	10800058 	cmpnei	r2,r2,1
811025f8:	10000a1e 	bne	r2,zero,81102624 <bDdr2MemoryRandomReadTest+0x204>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811025fc:	01604534 	movhi	r5,33044
81102600:	2973e104 	addi	r5,r5,-12412
81102604:	01204534 	movhi	r4,33044
81102608:	21077104 	addi	r4,r4,7620
8110260c:	1113e480 	call	81113e48 <sprintf>
		debug(fp, cDebugBuffer);
81102610:	d0a04e17 	ldw	r2,-32456(gp)
81102614:	01604534 	movhi	r5,33044
81102618:	29477104 	addi	r5,r5,7620
8110261c:	1009883a 	mov	r4,r2
81102620:	11126e00 	call	811126e0 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102624:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102628:	d0a06d17 	ldw	r2,-32332(gp)

	TimeStart = alt_nticks();
8110262c:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102630:	e0bff017 	ldw	r2,-64(fp)
81102634:	e0bff215 	stw	r2,-56(fp)
81102638:	00003a06 	br	81102724 <bDdr2MemoryRandomReadTest+0x304>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
8110263c:	e0bff804 	addi	r2,fp,-32
81102640:	1009883a 	mov	r4,r2
81102644:	11028bc0 	call	811028bc <uliXorshift32>
81102648:	1007883a 	mov	r3,r2
8110264c:	e0bff217 	ldw	r2,-56(fp)
81102650:	10800017 	ldw	r2,0(r2)
81102654:	18801026 	beq	r3,r2,81102698 <bDdr2MemoryRandomReadTest+0x278>
			bSuccess = FALSE;
81102658:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
8110265c:	e0bffa17 	ldw	r2,-24(fp)
81102660:	10800058 	cmpnei	r2,r2,1
81102664:	10000c1e 	bne	r2,zero,81102698 <bDdr2MemoryRandomReadTest+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
81102668:	e0bff217 	ldw	r2,-56(fp)
8110266c:	100d883a 	mov	r6,r2
81102670:	01604534 	movhi	r5,33044
81102674:	29741104 	addi	r5,r5,-12220
81102678:	01204534 	movhi	r4,33044
8110267c:	21077104 	addi	r4,r4,7620
81102680:	1113e480 	call	81113e48 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
81102684:	d0a04e17 	ldw	r2,-32456(gp)
81102688:	01604534 	movhi	r5,33044
8110268c:	29477104 	addi	r5,r5,7620
81102690:	1009883a 	mov	r4,r2
81102694:	11126e00 	call	811126e0 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
81102698:	e0bffa17 	ldw	r2,-24(fp)
8110269c:	10800058 	cmpnei	r2,r2,1
811026a0:	10001d1e 	bne	r2,zero,81102718 <bDdr2MemoryRandomReadTest+0x2f8>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026a4:	e0bff217 	ldw	r2,-56(fp)
811026a8:	e0fff317 	ldw	r3,-52(fp)
811026ac:	18801a2e 	bgeu	r3,r2,81102718 <bDdr2MemoryRandomReadTest+0x2f8>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
811026b0:	e0bff403 	ldbu	r2,-48(fp)
811026b4:	100d883a 	mov	r6,r2
811026b8:	01604534 	movhi	r5,33044
811026bc:	2973e304 	addi	r5,r5,-12404
811026c0:	01204534 	movhi	r4,33044
811026c4:	21077104 	addi	r4,r4,7620
811026c8:	1113e480 	call	81113e48 <sprintf>
			debug(fp, cDebugBuffer);
811026cc:	d0a04e17 	ldw	r2,-32456(gp)
811026d0:	01604534 	movhi	r5,33044
811026d4:	29477104 	addi	r5,r5,7620
811026d8:	1009883a 	mov	r4,r2
811026dc:	11126e00 	call	811126e0 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
811026e0:	e0fff117 	ldw	r3,-60(fp)
811026e4:	00b33374 	movhi	r2,52429
811026e8:	10b33344 	addi	r2,r2,-13107
811026ec:	1888383a 	mulxuu	r4,r3,r2
811026f0:	1885383a 	mul	r2,r3,r2
811026f4:	1021883a 	mov	r16,r2
811026f8:	2023883a 	mov	r17,r4
811026fc:	8804d13a 	srli	r2,r17,4
81102700:	e0fff317 	ldw	r3,-52(fp)
81102704:	1885883a 	add	r2,r3,r2
81102708:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
8110270c:	e0bff403 	ldbu	r2,-48(fp)
81102710:	10800144 	addi	r2,r2,5
81102714:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
81102718:	e0bff217 	ldw	r2,-56(fp)
8110271c:	10800104 	addi	r2,r2,4
81102720:	e0bff215 	stw	r2,-56(fp)
81102724:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
81102728:	e0bff517 	ldw	r2,-44(fp)
8110272c:	18bfc336 	bltu	r3,r2,8110263c <__reset+0xfb0e263c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102730:	e0bffa17 	ldw	r2,-24(fp)
81102734:	10800058 	cmpnei	r2,r2,1
81102738:	10000a1e 	bne	r2,zero,81102764 <bDdr2MemoryRandomReadTest+0x344>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
8110273c:	01604534 	movhi	r5,33044
81102740:	2973e604 	addi	r5,r5,-12392
81102744:	01204534 	movhi	r4,33044
81102748:	21077104 	addi	r4,r4,7620
8110274c:	1113e480 	call	81113e48 <sprintf>
		debug(fp, cDebugBuffer);
81102750:	d0a04e17 	ldw	r2,-32456(gp)
81102754:	01604534 	movhi	r5,33044
81102758:	29477104 	addi	r5,r5,7620
8110275c:	1009883a 	mov	r4,r2
81102760:	11126e00 	call	811126e0 <fprintf>
#endif
	}

	if (bSuccess) {
81102764:	e0bfef17 	ldw	r2,-68(fp)
81102768:	10003126 	beq	r2,zero,81102830 <bDdr2MemoryRandomReadTest+0x410>
		if (bTime == TRUE) {
8110276c:	e0bffb17 	ldw	r2,-20(fp)
81102770:	10800058 	cmpnei	r2,r2,1
81102774:	1000221e 	bne	r2,zero,81102800 <bDdr2MemoryRandomReadTest+0x3e0>
81102778:	d0e06d17 	ldw	r3,-32332(gp)
			TimeElapsed = alt_nticks() - TimeStart;
8110277c:	e0bff717 	ldw	r2,-36(fp)
81102780:	1885c83a 	sub	r2,r3,r2
81102784:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102788:	e13ff617 	ldw	r4,-40(fp)
8110278c:	111191c0 	call	8111191c <__floatsisf>
81102790:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102794:	d0a06c17 	ldw	r2,-32336(gp)
81102798:	1009883a 	mov	r4,r2
8110279c:	1111a480 	call	81111a48 <__floatunsisf>
811027a0:	1007883a 	mov	r3,r2
811027a4:	180b883a 	mov	r5,r3
811027a8:	8009883a 	mov	r4,r16
811027ac:	11110d00 	call	811110d0 <__divsf3>
811027b0:	1007883a 	mov	r3,r2
811027b4:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
811027b8:	1009883a 	mov	r4,r2
811027bc:	11122600 	call	81112260 <__extendsfdf2>
811027c0:	1009883a 	mov	r4,r2
811027c4:	180b883a 	mov	r5,r3
811027c8:	d9400015 	stw	r5,0(sp)
811027cc:	200f883a 	mov	r7,r4
811027d0:	e1bff117 	ldw	r6,-60(fp)
811027d4:	01604534 	movhi	r5,33044
811027d8:	29741904 	addi	r5,r5,-12188
811027dc:	01204534 	movhi	r4,33044
811027e0:	21077104 	addi	r4,r4,7620
811027e4:	1113e480 	call	81113e48 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811027e8:	d0a04e17 	ldw	r2,-32456(gp)
811027ec:	01604534 	movhi	r5,33044
811027f0:	29477104 	addi	r5,r5,7620
811027f4:	1009883a 	mov	r4,r2
811027f8:	11126e00 	call	811126e0 <fprintf>
811027fc:	00001b06 	br	8110286c <bDdr2MemoryRandomReadTest+0x44c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102800:	e1bff117 	ldw	r6,-60(fp)
81102804:	01604534 	movhi	r5,33044
81102808:	29742504 	addi	r5,r5,-12140
8110280c:	01204534 	movhi	r4,33044
81102810:	21077104 	addi	r4,r4,7620
81102814:	1113e480 	call	81113e48 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
81102818:	d0a04e17 	ldw	r2,-32456(gp)
8110281c:	01604534 	movhi	r5,33044
81102820:	29477104 	addi	r5,r5,7620
81102824:	1009883a 	mov	r4,r2
81102828:	11126e00 	call	811126e0 <fprintf>
8110282c:	00000f06 	br	8110286c <bDdr2MemoryRandomReadTest+0x44c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102830:	00e04534 	movhi	r3,33044
81102834:	18c77104 	addi	r3,r3,7620
81102838:	00a04534 	movhi	r2,33044
8110283c:	10b3c904 	addi	r2,r2,-12508
81102840:	1009883a 	mov	r4,r2
81102844:	00800544 	movi	r2,21
81102848:	100d883a 	mov	r6,r2
8110284c:	200b883a 	mov	r5,r4
81102850:	1809883a 	mov	r4,r3
81102854:	11136e00 	call	811136e0 <memcpy>
		debug(fp, cDebugBuffer);
81102858:	d0a04e17 	ldw	r2,-32456(gp)
8110285c:	01604534 	movhi	r5,33044
81102860:	29477104 	addi	r5,r5,7620
81102864:	1009883a 	mov	r4,r2
81102868:	11126e00 	call	811126e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
8110286c:	00a04534 	movhi	r2,33044
81102870:	10877104 	addi	r2,r2,7620
81102874:	00c00284 	movi	r3,10
81102878:	10c00005 	stb	r3,0(r2)
8110287c:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81102880:	d0a04e17 	ldw	r2,-32456(gp)
81102884:	01604534 	movhi	r5,33044
81102888:	29477104 	addi	r5,r5,7620
8110288c:	1009883a 	mov	r4,r2
81102890:	11126e00 	call	811126e0 <fprintf>
#endif

	return bSuccess;
81102894:	e0bfef17 	ldw	r2,-68(fp)
}
81102898:	e6fffc04 	addi	sp,fp,-16
8110289c:	dfc00517 	ldw	ra,20(sp)
811028a0:	df000417 	ldw	fp,16(sp)
811028a4:	dcc00317 	ldw	r19,12(sp)
811028a8:	dc800217 	ldw	r18,8(sp)
811028ac:	dc400117 	ldw	r17,4(sp)
811028b0:	dc000017 	ldw	r16,0(sp)
811028b4:	dec00604 	addi	sp,sp,24
811028b8:	f800283a 	ret

811028bc <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Número aleatório resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
811028bc:	defffd04 	addi	sp,sp,-12
811028c0:	de00012e 	bgeu	sp,et,811028c8 <uliXorshift32+0xc>
811028c4:	003b68fa 	trap	3
811028c8:	df000215 	stw	fp,8(sp)
811028cc:	df000204 	addi	fp,sp,8
811028d0:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
811028d4:	e0bfff17 	ldw	r2,-4(fp)
811028d8:	10800017 	ldw	r2,0(r2)
811028dc:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
811028e0:	e0bffe17 	ldw	r2,-8(fp)
811028e4:	1004937a 	slli	r2,r2,13
811028e8:	e0fffe17 	ldw	r3,-8(fp)
811028ec:	1884f03a 	xor	r2,r3,r2
811028f0:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
811028f4:	e0bffe17 	ldw	r2,-8(fp)
811028f8:	1004d47a 	srli	r2,r2,17
811028fc:	e0fffe17 	ldw	r3,-8(fp)
81102900:	1884f03a 	xor	r2,r3,r2
81102904:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
81102908:	e0bffe17 	ldw	r2,-8(fp)
8110290c:	1004917a 	slli	r2,r2,5
81102910:	e0fffe17 	ldw	r3,-8(fp)
81102914:	1884f03a 	xor	r2,r3,r2
81102918:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
8110291c:	e0bfff17 	ldw	r2,-4(fp)
81102920:	e0fffe17 	ldw	r3,-8(fp)
81102924:	10c00015 	stw	r3,0(r2)

	return uliX;
81102928:	e0bffe17 	ldw	r2,-8(fp)
}
8110292c:	e037883a 	mov	sp,fp
81102930:	df000017 	ldw	fp,0(sp)
81102934:	dec00104 	addi	sp,sp,4
81102938:	f800283a 	ret

8110293c <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
8110293c:	defffb04 	addi	sp,sp,-20
81102940:	de00012e 	bgeu	sp,et,81102948 <DMA_OPEN_DEVICE+0xc>
81102944:	003b68fa 	trap	3
81102948:	dfc00415 	stw	ra,16(sp)
8110294c:	df000315 	stw	fp,12(sp)
81102950:	df000304 	addi	fp,sp,12
81102954:	e13ffe15 	stw	r4,-8(fp)
81102958:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
8110295c:	00800044 	movi	r2,1
81102960:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
81102964:	e13fff17 	ldw	r4,-4(fp)
81102968:	113ac680 	call	8113ac68 <alt_msgdma_open>
8110296c:	1007883a 	mov	r3,r2
81102970:	e0bffe17 	ldw	r2,-8(fp)
81102974:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
81102978:	e0bffe17 	ldw	r2,-8(fp)
8110297c:	10800017 	ldw	r2,0(r2)
81102980:	1000011e 	bne	r2,zero,81102988 <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
81102984:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
81102988:	e0bffd17 	ldw	r2,-12(fp)
}
8110298c:	e037883a 	mov	sp,fp
81102990:	dfc00117 	ldw	ra,4(sp)
81102994:	df000017 	ldw	fp,0(sp)
81102998:	dec00204 	addi	sp,sp,8
8110299c:	f800283a 	ret

811029a0 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configurações do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029a0:	defffc04 	addi	sp,sp,-16
811029a4:	de00012e 	bgeu	sp,et,811029ac <DMA_CONFIG+0xc>
811029a8:	003b68fa 	trap	3
811029ac:	df000315 	stw	fp,12(sp)
811029b0:	df000304 	addi	fp,sp,12
811029b4:	e13ffe15 	stw	r4,-8(fp)
811029b8:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029bc:	00800044 	movi	r2,1
811029c0:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10800317 	ldw	r2,12(r2)
811029cc:	10800104 	addi	r2,r2,4
811029d0:	e0ffff17 	ldw	r3,-4(fp)
811029d4:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
811029d8:	e0bffd17 	ldw	r2,-12(fp)
}
811029dc:	e037883a 	mov	sp,fp
811029e0:	df000017 	ldw	fp,0(sp)
811029e4:	dec00104 	addi	sp,sp,4
811029e8:	f800283a 	ret

811029ec <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
811029ec:	defffd04 	addi	sp,sp,-12
811029f0:	de00012e 	bgeu	sp,et,811029f8 <DMA_BUSY+0xc>
811029f4:	003b68fa 	trap	3
811029f8:	df000215 	stw	fp,8(sp)
811029fc:	df000204 	addi	fp,sp,8
81102a00:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a04:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a08:	e0bfff17 	ldw	r2,-4(fp)
81102a0c:	10800317 	ldw	r2,12(r2)
81102a10:	10800037 	ldwio	r2,0(r2)
81102a14:	1080004c 	andi	r2,r2,1
81102a18:	10000226 	beq	r2,zero,81102a24 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a1c:	00800044 	movi	r2,1
81102a20:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a24:	e0bffe17 	ldw	r2,-8(fp)
}
81102a28:	e037883a 	mov	sp,fp
81102a2c:	df000017 	ldw	fp,0(sp)
81102a30:	dec00104 	addi	sp,sp,4
81102a34:	f800283a 	ret

81102a38 <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a38:	defffd04 	addi	sp,sp,-12
81102a3c:	de00012e 	bgeu	sp,et,81102a44 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a40:	003b68fa 	trap	3
81102a44:	df000215 	stw	fp,8(sp)
81102a48:	df000204 	addi	fp,sp,8
81102a4c:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102a50:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102a54:	e0bfff17 	ldw	r2,-4(fp)
81102a58:	10800317 	ldw	r2,12(r2)
81102a5c:	10800037 	ldwio	r2,0(r2)
81102a60:	1080010c 	andi	r2,r2,4
81102a64:	10000226 	beq	r2,zero,81102a70 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102a68:	00800044 	movi	r2,1
81102a6c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102a70:	e0bffe17 	ldw	r2,-8(fp)
}
81102a74:	e037883a 	mov	sp,fp
81102a78:	df000017 	ldw	fp,0(sp)
81102a7c:	dec00104 	addi	sp,sp,4
81102a80:	f800283a 	ret

81102a84 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102a84:	defffd04 	addi	sp,sp,-12
81102a88:	de00012e 	bgeu	sp,et,81102a90 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102a8c:	003b68fa 	trap	3
81102a90:	df000215 	stw	fp,8(sp)
81102a94:	df000204 	addi	fp,sp,8
81102a98:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102a9c:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102aa0:	e0bfff17 	ldw	r2,-4(fp)
81102aa4:	10800317 	ldw	r2,12(r2)
81102aa8:	10800037 	ldwio	r2,0(r2)
81102aac:	1080008c 	andi	r2,r2,2
81102ab0:	10000226 	beq	r2,zero,81102abc <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102ab4:	00800044 	movi	r2,1
81102ab8:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102abc:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac0:	e037883a 	mov	sp,fp
81102ac4:	df000017 	ldw	fp,0(sp)
81102ac8:	dec00104 	addi	sp,sp,4
81102acc:	f800283a 	ret

81102ad0 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a função irá verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102ad0:	defffa04 	addi	sp,sp,-24
81102ad4:	de00012e 	bgeu	sp,et,81102adc <DMA_DISPATCHER_STOP+0xc>
81102ad8:	003b68fa 	trap	3
81102adc:	dfc00515 	stw	ra,20(sp)
81102ae0:	df000415 	stw	fp,16(sp)
81102ae4:	df000404 	addi	fp,sp,16
81102ae8:	e13ffd15 	stw	r4,-12(fp)
81102aec:	e17ffe15 	stw	r5,-8(fp)
81102af0:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102af4:	00800044 	movi	r2,1
81102af8:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102afc:	e0bffd17 	ldw	r2,-12(fp)
81102b00:	10800317 	ldw	r2,12(r2)
81102b04:	10800104 	addi	r2,r2,4
81102b08:	00c00044 	movi	r3,1
81102b0c:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b10:	e0bffe17 	ldw	r2,-8(fp)
81102b14:	10800058 	cmpnei	r2,r2,1
81102b18:	10000e1e 	bne	r2,zero,81102b54 <DMA_DISPATCHER_STOP+0x84>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b1c:	00000706 	br	81102b3c <DMA_DISPATCHER_STOP+0x6c>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b20:	e0bfff17 	ldw	r2,-4(fp)
81102b24:	1000031e 	bne	r2,zero,81102b34 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b28:	01000044 	movi	r4,1
81102b2c:	1128bec0 	call	81128bec <usleep>
81102b30:	00000206 	br	81102b3c <DMA_DISPATCHER_STOP+0x6c>
      } else {
        usleep(WaitPeriodUs);
81102b34:	e13fff17 	ldw	r4,-4(fp)
81102b38:	1128bec0 	call	81128bec <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b3c:	e0bffd17 	ldw	r2,-12(fp)
81102b40:	10800317 	ldw	r2,12(r2)
81102b44:	10800037 	ldwio	r2,0(r2)
81102b48:	1080080c 	andi	r2,r2,32
81102b4c:	103ff41e 	bne	r2,zero,81102b20 <__reset+0xfb0e2b20>
81102b50:	00000206 	br	81102b5c <DMA_DISPATCHER_STOP+0x8c>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102b54:	e0bffc17 	ldw	r2,-16(fp)
81102b58:	00000106 	br	81102b60 <DMA_DISPATCHER_STOP+0x90>
  }
  
  return bSuccess;
81102b5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102b60:	e037883a 	mov	sp,fp
81102b64:	dfc00117 	ldw	ra,4(sp)
81102b68:	df000017 	ldw	fp,0(sp)
81102b6c:	dec00204 	addi	sp,sp,8
81102b70:	f800283a 	ret

81102b74 <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a função irá verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b74:	defffa04 	addi	sp,sp,-24
81102b78:	de00012e 	bgeu	sp,et,81102b80 <DMA_DISPATCHER_RESET+0xc>
81102b7c:	003b68fa 	trap	3
81102b80:	dfc00515 	stw	ra,20(sp)
81102b84:	df000415 	stw	fp,16(sp)
81102b88:	df000404 	addi	fp,sp,16
81102b8c:	e13ffd15 	stw	r4,-12(fp)
81102b90:	e17ffe15 	stw	r5,-8(fp)
81102b94:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b98:	00800044 	movi	r2,1
81102b9c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102ba0:	e0bffd17 	ldw	r2,-12(fp)
81102ba4:	10800317 	ldw	r2,12(r2)
81102ba8:	10800104 	addi	r2,r2,4
81102bac:	00c00084 	movi	r3,2
81102bb0:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102bb4:	e0bffe17 	ldw	r2,-8(fp)
81102bb8:	10800058 	cmpnei	r2,r2,1
81102bbc:	10000e1e 	bne	r2,zero,81102bf8 <DMA_DISPATCHER_RESET+0x84>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102bc0:	00000706 	br	81102be0 <DMA_DISPATCHER_RESET+0x6c>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102bc4:	e0bfff17 	ldw	r2,-4(fp)
81102bc8:	1000031e 	bne	r2,zero,81102bd8 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102bcc:	01000044 	movi	r4,1
81102bd0:	1128bec0 	call	81128bec <usleep>
81102bd4:	00000206 	br	81102be0 <DMA_DISPATCHER_RESET+0x6c>
      } else {
        usleep(WaitPeriodUs);
81102bd8:	e13fff17 	ldw	r4,-4(fp)
81102bdc:	1128bec0 	call	81128bec <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102be0:	e0bffd17 	ldw	r2,-12(fp)
81102be4:	10800317 	ldw	r2,12(r2)
81102be8:	10800037 	ldwio	r2,0(r2)
81102bec:	1080100c 	andi	r2,r2,64
81102bf0:	103ff41e 	bne	r2,zero,81102bc4 <__reset+0xfb0e2bc4>
81102bf4:	00000206 	br	81102c00 <DMA_DISPATCHER_RESET+0x8c>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bf8:	e0bffc17 	ldw	r2,-16(fp)
81102bfc:	00000106 	br	81102c04 <DMA_DISPATCHER_RESET+0x90>
  }
  
  return bSuccess;
81102c00:	e0bffc17 	ldw	r2,-16(fp)
}
81102c04:	e037883a 	mov	sp,fp
81102c08:	dfc00117 	ldw	ra,4(sp)
81102c0c:	df000017 	ldw	fp,0(sp)
81102c10:	dec00204 	addi	sp,sp,8
81102c14:	f800283a 	ret

81102c18 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a função irá verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c18:	defff604 	addi	sp,sp,-40
81102c1c:	de00012e 	bgeu	sp,et,81102c24 <DMA_SINGLE_TRANSFER+0xc>
81102c20:	003b68fa 	trap	3
81102c24:	dfc00915 	stw	ra,36(sp)
81102c28:	df000815 	stw	fp,32(sp)
81102c2c:	dc000715 	stw	r16,28(sp)
81102c30:	df000804 	addi	fp,sp,32
81102c34:	e13ffb15 	stw	r4,-20(fp)
81102c38:	e17ffc15 	stw	r5,-16(fp)
81102c3c:	e1bffd15 	stw	r6,-12(fp)
81102c40:	e1fffe15 	stw	r7,-8(fp)
81102c44:	defff804 	addi	sp,sp,-32
81102c48:	d8800204 	addi	r2,sp,8
81102c4c:	108003c4 	addi	r2,r2,15
81102c50:	1004d13a 	srli	r2,r2,4
81102c54:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102c58:	00800044 	movi	r2,1
81102c5c:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102c60:	e0fffc17 	ldw	r3,-16(fp)
81102c64:	e13ffd17 	ldw	r4,-12(fp)
81102c68:	e0800217 	ldw	r2,8(fp)
81102c6c:	d8800115 	stw	r2,4(sp)
81102c70:	e0bffe17 	ldw	r2,-8(fp)
81102c74:	d8800015 	stw	r2,0(sp)
81102c78:	200f883a 	mov	r7,r4
81102c7c:	180d883a 	mov	r6,r3
81102c80:	800b883a 	mov	r5,r16
81102c84:	e13ffb17 	ldw	r4,-20(fp)
81102c88:	1139c640 	call	81139c64 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102c8c:	10000326 	beq	r2,zero,81102c9c <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102c90:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102c94:	e0bffa17 	ldw	r2,-24(fp)
81102c98:	00001d06 	br	81102d10 <DMA_SINGLE_TRANSFER+0xf8>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102c9c:	800b883a 	mov	r5,r16
81102ca0:	e13ffb17 	ldw	r4,-20(fp)
81102ca4:	113aed80 	call	8113aed8 <alt_msgdma_standard_descriptor_async_transfer>
81102ca8:	10000326 	beq	r2,zero,81102cb8 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102cac:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102cb0:	e0bffa17 	ldw	r2,-24(fp)
81102cb4:	00001606 	br	81102d10 <DMA_SINGLE_TRANSFER+0xf8>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102cb8:	e0bffa17 	ldw	r2,-24(fp)
81102cbc:	10800060 	cmpeqi	r2,r2,1
81102cc0:	1007883a 	mov	r3,r2
81102cc4:	e0800317 	ldw	r2,12(fp)
81102cc8:	10800060 	cmpeqi	r2,r2,1
81102ccc:	1884703a 	and	r2,r3,r2
81102cd0:	10803fcc 	andi	r2,r2,255
81102cd4:	10000d26 	beq	r2,zero,81102d0c <DMA_SINGLE_TRANSFER+0xf4>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102cd8:	00000706 	br	81102cf8 <DMA_SINGLE_TRANSFER+0xe0>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102cdc:	e0800417 	ldw	r2,16(fp)
81102ce0:	1000031e 	bne	r2,zero,81102cf0 <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102ce4:	0100fa04 	movi	r4,1000
81102ce8:	1128bec0 	call	81128bec <usleep>
81102cec:	00000206 	br	81102cf8 <DMA_SINGLE_TRANSFER+0xe0>
      } else {
        usleep(WaitPeriodUs);
81102cf0:	e1000417 	ldw	r4,16(fp)
81102cf4:	1128bec0 	call	81128bec <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102cf8:	e0bffb17 	ldw	r2,-20(fp)
81102cfc:	10800317 	ldw	r2,12(r2)
81102d00:	10800037 	ldwio	r2,0(r2)
81102d04:	1080004c 	andi	r2,r2,1
81102d08:	103ff41e 	bne	r2,zero,81102cdc <__reset+0xfb0e2cdc>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d10:	e6ffff04 	addi	sp,fp,-4
81102d14:	dfc00217 	ldw	ra,8(sp)
81102d18:	df000117 	ldw	fp,4(sp)
81102d1c:	dc000017 	ldw	r16,0(sp)
81102d20:	dec00304 	addi	sp,sp,12
81102d24:	f800283a 	ret

81102d28 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a função irá verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d28:	defff504 	addi	sp,sp,-44
81102d2c:	de00012e 	bgeu	sp,et,81102d34 <DMA_MULTIPLE_TRANSFER+0xc>
81102d30:	003b68fa 	trap	3
81102d34:	dfc00a15 	stw	ra,40(sp)
81102d38:	df000915 	stw	fp,36(sp)
81102d3c:	dc000815 	stw	r16,32(sp)
81102d40:	df000904 	addi	fp,sp,36
81102d44:	e13ffb15 	stw	r4,-20(fp)
81102d48:	e17ffc15 	stw	r5,-16(fp)
81102d4c:	e1bffd15 	stw	r6,-12(fp)
81102d50:	3805883a 	mov	r2,r7
81102d54:	e0bffe05 	stb	r2,-8(fp)
81102d58:	defff804 	addi	sp,sp,-32
81102d5c:	d8800204 	addi	r2,sp,8
81102d60:	108003c4 	addi	r2,r2,15
81102d64:	1004d13a 	srli	r2,r2,4
81102d68:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102d6c:	00800044 	movi	r2,1
81102d70:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102d74:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102d78:	00002506 	br	81102e10 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102d7c:	e0bffa03 	ldbu	r2,-24(fp)
81102d80:	1085883a 	add	r2,r2,r2
81102d84:	1085883a 	add	r2,r2,r2
81102d88:	1007883a 	mov	r3,r2
81102d8c:	e0bffc17 	ldw	r2,-16(fp)
81102d90:	10c5883a 	add	r2,r2,r3
81102d94:	10800017 	ldw	r2,0(r2)
81102d98:	1009883a 	mov	r4,r2
81102d9c:	e0bffa03 	ldbu	r2,-24(fp)
81102da0:	1085883a 	add	r2,r2,r2
81102da4:	1085883a 	add	r2,r2,r2
81102da8:	1007883a 	mov	r3,r2
81102dac:	e0bffd17 	ldw	r2,-12(fp)
81102db0:	10c5883a 	add	r2,r2,r3
81102db4:	10800017 	ldw	r2,0(r2)
81102db8:	1007883a 	mov	r3,r2
81102dbc:	e0800317 	ldw	r2,12(fp)
81102dc0:	10804034 	orhi	r2,r2,256
81102dc4:	d8800115 	stw	r2,4(sp)
81102dc8:	e0800217 	ldw	r2,8(fp)
81102dcc:	d8800015 	stw	r2,0(sp)
81102dd0:	180f883a 	mov	r7,r3
81102dd4:	200d883a 	mov	r6,r4
81102dd8:	800b883a 	mov	r5,r16
81102ddc:	e13ffb17 	ldw	r4,-20(fp)
81102de0:	1139c640 	call	81139c64 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102de4:	10000226 	beq	r2,zero,81102df0 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102de8:	e03ff915 	stw	zero,-28(fp)
81102dec:	00000506 	br	81102e04 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102df0:	800b883a 	mov	r5,r16
81102df4:	e13ffb17 	ldw	r4,-20(fp)
81102df8:	113aed80 	call	8113aed8 <alt_msgdma_standard_descriptor_async_transfer>
81102dfc:	10000126 	beq	r2,zero,81102e04 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e00:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e04:	e0bffa03 	ldbu	r2,-24(fp)
81102e08:	10800044 	addi	r2,r2,1
81102e0c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e10:	e0bff917 	ldw	r2,-28(fp)
81102e14:	10800060 	cmpeqi	r2,r2,1
81102e18:	1009883a 	mov	r4,r2
81102e1c:	e0fffa03 	ldbu	r3,-24(fp)
81102e20:	e0bffe03 	ldbu	r2,-8(fp)
81102e24:	10bfffc4 	addi	r2,r2,-1
81102e28:	1884803a 	cmplt	r2,r3,r2
81102e2c:	2084703a 	and	r2,r4,r2
81102e30:	10803fcc 	andi	r2,r2,255
81102e34:	103fd11e 	bne	r2,zero,81102d7c <__reset+0xfb0e2d7c>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e38:	e0bff917 	ldw	r2,-28(fp)
81102e3c:	10800058 	cmpnei	r2,r2,1
81102e40:	1000211e 	bne	r2,zero,81102ec8 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102e44:	e0bffa03 	ldbu	r2,-24(fp)
81102e48:	1085883a 	add	r2,r2,r2
81102e4c:	1085883a 	add	r2,r2,r2
81102e50:	1007883a 	mov	r3,r2
81102e54:	e0bffc17 	ldw	r2,-16(fp)
81102e58:	10c5883a 	add	r2,r2,r3
81102e5c:	10800017 	ldw	r2,0(r2)
81102e60:	1009883a 	mov	r4,r2
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	1085883a 	add	r2,r2,r2
81102e6c:	1085883a 	add	r2,r2,r2
81102e70:	1007883a 	mov	r3,r2
81102e74:	e0bffd17 	ldw	r2,-12(fp)
81102e78:	10c5883a 	add	r2,r2,r3
81102e7c:	10800017 	ldw	r2,0(r2)
81102e80:	1007883a 	mov	r3,r2
81102e84:	e0800317 	ldw	r2,12(fp)
81102e88:	d8800115 	stw	r2,4(sp)
81102e8c:	e0800217 	ldw	r2,8(fp)
81102e90:	d8800015 	stw	r2,0(sp)
81102e94:	180f883a 	mov	r7,r3
81102e98:	200d883a 	mov	r6,r4
81102e9c:	800b883a 	mov	r5,r16
81102ea0:	e13ffb17 	ldw	r4,-20(fp)
81102ea4:	1139c640 	call	81139c64 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ea8:	10000226 	beq	r2,zero,81102eb4 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102eac:	e03ff915 	stw	zero,-28(fp)
81102eb0:	00000506 	br	81102ec8 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102eb4:	800b883a 	mov	r5,r16
81102eb8:	e13ffb17 	ldw	r4,-20(fp)
81102ebc:	113aed80 	call	8113aed8 <alt_msgdma_standard_descriptor_async_transfer>
81102ec0:	10000126 	beq	r2,zero,81102ec8 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102ec4:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102ec8:	e0bff917 	ldw	r2,-28(fp)
81102ecc:	10800060 	cmpeqi	r2,r2,1
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0800417 	ldw	r2,16(fp)
81102ed8:	10800060 	cmpeqi	r2,r2,1
81102edc:	1884703a 	and	r2,r3,r2
81102ee0:	10803fcc 	andi	r2,r2,255
81102ee4:	10000d26 	beq	r2,zero,81102f1c <DMA_MULTIPLE_TRANSFER+0x1f4>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102ee8:	00000706 	br	81102f08 <DMA_MULTIPLE_TRANSFER+0x1e0>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102eec:	e0800517 	ldw	r2,20(fp)
81102ef0:	1000031e 	bne	r2,zero,81102f00 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102ef4:	0100fa04 	movi	r4,1000
81102ef8:	1128bec0 	call	81128bec <usleep>
81102efc:	00000206 	br	81102f08 <DMA_MULTIPLE_TRANSFER+0x1e0>
      } else {
    	usleep(WaitPeriodUs);
81102f00:	e1000517 	ldw	r4,20(fp)
81102f04:	1128bec0 	call	81128bec <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f08:	e0bffb17 	ldw	r2,-20(fp)
81102f0c:	10800317 	ldw	r2,12(r2)
81102f10:	10800037 	ldwio	r2,0(r2)
81102f14:	1080004c 	andi	r2,r2,1
81102f18:	103ff41e 	bne	r2,zero,81102eec <__reset+0xfb0e2eec>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f1c:	e0bff917 	ldw	r2,-28(fp)
}
81102f20:	e6ffff04 	addi	sp,fp,-4
81102f24:	dfc00217 	ldw	ra,8(sp)
81102f28:	df000117 	ldw	fp,4(sp)
81102f2c:	dc000017 	ldw	r16,0(sp)
81102f30:	dec00304 	addi	sp,sp,12
81102f34:	f800283a 	ret

81102f38 <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f38:	deffef04 	addi	sp,sp,-68
81102f3c:	de00012e 	bgeu	sp,et,81102f44 <POWER_Read+0xc>
81102f40:	003b68fa 	trap	3
81102f44:	dfc01015 	stw	ra,64(sp)
81102f48:	df000f15 	stw	fp,60(sp)
81102f4c:	df000f04 	addi	fp,sp,60
81102f50:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102f54:	00800044 	movi	r2,1
81102f58:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102f5c:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102f60:	00800204 	movi	r2,8
81102f64:	e0bffc15 	stw	r2,-16(fp)
81102f68:	00800104 	movi	r2,4
81102f6c:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102f70:	00800044 	movi	r2,1
81102f74:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102f78:	00800044 	movi	r2,1
81102f7c:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102f80:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102f84:	e03ff515 	stw	zero,-44(fp)
81102f88:	00009206 	br	811031d4 <POWER_Read+0x29c>
		NextChannel = 0;
81102f8c:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102f90:	e0bff517 	ldw	r2,-44(fp)
81102f94:	10c03fcc 	andi	r3,r2,255
81102f98:	e13ffa03 	ldbu	r4,-24(fp)
81102f9c:	e0bfff17 	ldw	r2,-4(fp)
81102fa0:	d8800115 	stw	r2,4(sp)
81102fa4:	e0bff917 	ldw	r2,-28(fp)
81102fa8:	d8800015 	stw	r2,0(sp)
81102fac:	e1fff817 	ldw	r7,-32(fp)
81102fb0:	e1bff717 	ldw	r6,-36(fp)
81102fb4:	200b883a 	mov	r5,r4
81102fb8:	1809883a 	mov	r4,r3
81102fbc:	1106cc80 	call	81106cc8 <POWER_SPI_RW>
81102fc0:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81102fc4:	e03ff415 	stw	zero,-48(fp)
81102fc8:	00007406 	br	8110319c <POWER_Read+0x264>
			NextChannel = i + 1;
81102fcc:	e0bff417 	ldw	r2,-48(fp)
81102fd0:	10800044 	addi	r2,r2,1
81102fd4:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
81102fd8:	e0bff517 	ldw	r2,-44(fp)
81102fdc:	10c03fcc 	andi	r3,r2,255
81102fe0:	e13ffa03 	ldbu	r4,-24(fp)
81102fe4:	e0bffe04 	addi	r2,fp,-8
81102fe8:	d8800115 	stw	r2,4(sp)
81102fec:	e0bff917 	ldw	r2,-28(fp)
81102ff0:	d8800015 	stw	r2,0(sp)
81102ff4:	e1fff817 	ldw	r7,-32(fp)
81102ff8:	e1bff717 	ldw	r6,-36(fp)
81102ffc:	200b883a 	mov	r5,r4
81103000:	1809883a 	mov	r4,r3
81103004:	1106cc80 	call	81106cc8 <POWER_SPI_RW>
81103008:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
8110300c:	e0bff317 	ldw	r2,-52(fp)
81103010:	10005026 	beq	r2,zero,81103154 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103014:	e0bffe17 	ldw	r2,-8(fp)
81103018:	1004d7ba 	srli	r2,r2,30
8110301c:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103020:	e0bffe17 	ldw	r2,-8(fp)
81103024:	1004d07a 	srli	r2,r2,1
81103028:	108001cc 	andi	r2,r2,7
8110302c:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103030:	e0bffe17 	ldw	r2,-8(fp)
81103034:	1004d13a 	srli	r2,r2,4
81103038:	1080004c 	andi	r2,r2,1
8110303c:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
81103040:	e0bffe17 	ldw	r2,-8(fp)
81103044:	1004d17a 	srli	r2,r2,5
81103048:	1080004c 	andi	r2,r2,1
8110304c:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
81103050:	e0bffe17 	ldw	r2,-8(fp)
81103054:	1080004c 	andi	r2,r2,1
81103058:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
8110305c:	e0bffa43 	ldbu	r2,-23(fp)
81103060:	10000d26 	beq	r2,zero,81103098 <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
81103064:	e1bff417 	ldw	r6,-48(fp)
81103068:	01604534 	movhi	r5,33044
8110306c:	29742f04 	addi	r5,r5,-12100
81103070:	01204534 	movhi	r4,33044
81103074:	21077104 	addi	r4,r4,7620
81103078:	1113e480 	call	81113e48 <sprintf>
					debug(fp, cDebugBuffer);
8110307c:	d0a04e17 	ldw	r2,-32456(gp)
81103080:	01604534 	movhi	r5,33044
81103084:	29477104 	addi	r5,r5,7620
81103088:	1009883a 	mov	r4,r2
8110308c:	11126e00 	call	811126e0 <fprintf>
#endif
					bSuccess = FALSE;
81103090:	e03ff315 	stw	zero,-52(fp)
81103094:	00002206 	br	81103120 <POWER_Read+0x1e8>
				} else if (Channel != i) {
81103098:	e0fffa83 	ldbu	r3,-22(fp)
8110309c:	e0bff417 	ldw	r2,-48(fp)
811030a0:	18801026 	beq	r3,r2,811030e4 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
811030a4:	e0bffa83 	ldbu	r2,-22(fp)
811030a8:	d8800015 	stw	r2,0(sp)
811030ac:	e1fff417 	ldw	r7,-48(fp)
811030b0:	e1bff417 	ldw	r6,-48(fp)
811030b4:	01604534 	movhi	r5,33044
811030b8:	29743504 	addi	r5,r5,-12076
811030bc:	01204534 	movhi	r4,33044
811030c0:	21077104 	addi	r4,r4,7620
811030c4:	1113e480 	call	81113e48 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
811030c8:	d0a04e17 	ldw	r2,-32456(gp)
811030cc:	01604534 	movhi	r5,33044
811030d0:	29477104 	addi	r5,r5,7620
811030d4:	1009883a 	mov	r4,r2
811030d8:	11126e00 	call	811126e0 <fprintf>
#endif
					bSuccess = FALSE;
811030dc:	e03ff315 	stw	zero,-52(fp)
811030e0:	00000f06 	br	81103120 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
811030e4:	e0fffac3 	ldbu	r3,-21(fp)
811030e8:	e0bff817 	ldw	r2,-32(fp)
811030ec:	18800c26 	beq	r3,r2,81103120 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
811030f0:	e1bff417 	ldw	r6,-48(fp)
811030f4:	01604534 	movhi	r5,33044
811030f8:	29744104 	addi	r5,r5,-12028
811030fc:	01204534 	movhi	r4,33044
81103100:	21077104 	addi	r4,r4,7620
81103104:	1113e480 	call	81113e48 <sprintf>
					debug(fp, cDebugBuffer);
81103108:	d0a04e17 	ldw	r2,-32456(gp)
8110310c:	01604534 	movhi	r5,33044
81103110:	29477104 	addi	r5,r5,7620
81103114:	1009883a 	mov	r4,r2
81103118:	11126e00 	call	811126e0 <fprintf>
#endif
					bSuccess = FALSE;
8110311c:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103120:	e0bff317 	ldw	r2,-52(fp)
81103124:	10001a26 	beq	r2,zero,81103190 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
81103128:	e0bff617 	ldw	r2,-40(fp)
8110312c:	10c00044 	addi	r3,r2,1
81103130:	e0fff615 	stw	r3,-40(fp)
81103134:	1085883a 	add	r2,r2,r2
81103138:	1085883a 	add	r2,r2,r2
8110313c:	1007883a 	mov	r3,r2
81103140:	e0bfff17 	ldw	r2,-4(fp)
81103144:	10c5883a 	add	r2,r2,r3
81103148:	e0fffe17 	ldw	r3,-8(fp)
8110314c:	10c00015 	stw	r3,0(r2)
81103150:	00000f06 	br	81103190 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
81103154:	00e04534 	movhi	r3,33044
81103158:	18c77104 	addi	r3,r3,7620
8110315c:	00a04534 	movhi	r2,33044
81103160:	10b44704 	addi	r2,r2,-12004
81103164:	1009883a 	mov	r4,r2
81103168:	00800444 	movi	r2,17
8110316c:	100d883a 	mov	r6,r2
81103170:	200b883a 	mov	r5,r4
81103174:	1809883a 	mov	r4,r3
81103178:	11136e00 	call	811136e0 <memcpy>
				debug(fp, cDebugBuffer);
8110317c:	d0a04e17 	ldw	r2,-32456(gp)
81103180:	01604534 	movhi	r5,33044
81103184:	29477104 	addi	r5,r5,7620
81103188:	1009883a 	mov	r4,r2
8110318c:	11126e00 	call	811126e0 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103190:	e0bff417 	ldw	r2,-48(fp)
81103194:	10800044 	addi	r2,r2,1
81103198:	e0bff415 	stw	r2,-48(fp)
8110319c:	e0bff517 	ldw	r2,-44(fp)
811031a0:	1085883a 	add	r2,r2,r2
811031a4:	1085883a 	add	r2,r2,r2
811031a8:	e0fff304 	addi	r3,fp,-52
811031ac:	1885883a 	add	r2,r3,r2
811031b0:	10800904 	addi	r2,r2,36
811031b4:	10800017 	ldw	r2,0(r2)
811031b8:	e0fff417 	ldw	r3,-48(fp)
811031bc:	1880020e 	bge	r3,r2,811031c8 <POWER_Read+0x290>
811031c0:	e0bff317 	ldw	r2,-52(fp)
811031c4:	103f811e 	bne	r2,zero,81102fcc <__reset+0xfb0e2fcc>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
811031c8:	e0bff517 	ldw	r2,-44(fp)
811031cc:	10800044 	addi	r2,r2,1
811031d0:	e0bff515 	stw	r2,-44(fp)
811031d4:	e0bff517 	ldw	r2,-44(fp)
811031d8:	10800088 	cmpgei	r2,r2,2
811031dc:	1000021e 	bne	r2,zero,811031e8 <POWER_Read+0x2b0>
811031e0:	e0bff317 	ldw	r2,-52(fp)
811031e4:	103f691e 	bne	r2,zero,81102f8c <__reset+0xfb0e2f8c>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
811031e8:	e0bff317 	ldw	r2,-52(fp)
}
811031ec:	e037883a 	mov	sp,fp
811031f0:	dfc00117 	ldw	ra,4(sp)
811031f4:	df000017 	ldw	fp,0(sp)
811031f8:	dec00204 	addi	sp,sp,8
811031fc:	f800283a 	ret

81103200 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103200:	defff904 	addi	sp,sp,-28
81103204:	de00012e 	bgeu	sp,et,8110320c <TEMP_Read+0xc>
81103208:	003b68fa 	trap	3
8110320c:	dfc00615 	stw	ra,24(sp)
81103210:	df000515 	stw	fp,20(sp)
81103214:	df000504 	addi	fp,sp,20
81103218:	e13ffe15 	stw	r4,-8(fp)
8110321c:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103220:	00800c04 	movi	r2,48
81103224:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
81103228:	e0bffd83 	ldbu	r2,-10(fp)
8110322c:	10c03fcc 	andi	r3,r2,255
81103230:	18c0201c 	xori	r3,r3,128
81103234:	18ffe004 	addi	r3,r3,-128
81103238:	e0bffdc4 	addi	r2,fp,-9
8110323c:	d8800015 	stw	r2,0(sp)
81103240:	000f883a 	mov	r7,zero
81103244:	180d883a 	mov	r6,r3
81103248:	01600034 	movhi	r5,32768
8110324c:	29426004 	addi	r5,r5,2432
81103250:	01200034 	movhi	r4,32768
81103254:	21026404 	addi	r4,r4,2448
81103258:	1105ac00 	call	81105ac0 <I2C_Read>
8110325c:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
81103260:	e0bffc17 	ldw	r2,-16(fp)
81103264:	10000226 	beq	r2,zero,81103270 <TEMP_Read+0x70>
		BoardTemp = Data;
81103268:	e0bffdc3 	ldbu	r2,-9(fp)
8110326c:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
81103270:	e0bffc17 	ldw	r2,-16(fp)
81103274:	10001226 	beq	r2,zero,811032c0 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
81103278:	e0bffd83 	ldbu	r2,-10(fp)
8110327c:	10c03fcc 	andi	r3,r2,255
81103280:	18c0201c 	xori	r3,r3,128
81103284:	18ffe004 	addi	r3,r3,-128
81103288:	e0bffdc4 	addi	r2,fp,-9
8110328c:	d8800015 	stw	r2,0(sp)
81103290:	01c00044 	movi	r7,1
81103294:	180d883a 	mov	r6,r3
81103298:	01600034 	movhi	r5,32768
8110329c:	29426004 	addi	r5,r5,2432
811032a0:	01200034 	movhi	r4,32768
811032a4:	21026404 	addi	r4,r4,2448
811032a8:	1105ac00 	call	81105ac0 <I2C_Read>
811032ac:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
811032b0:	e0bffc17 	ldw	r2,-16(fp)
811032b4:	10000226 	beq	r2,zero,811032c0 <TEMP_Read+0xc0>
			FpgaTemp = Data;
811032b8:	e0bffdc3 	ldbu	r2,-9(fp)
811032bc:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
811032c0:	e0bffc17 	ldw	r2,-16(fp)
811032c4:	10000626 	beq	r2,zero,811032e0 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
811032c8:	e0bffe17 	ldw	r2,-8(fp)
811032cc:	e0fffd03 	ldbu	r3,-12(fp)
811032d0:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
811032d4:	e0bfff17 	ldw	r2,-4(fp)
811032d8:	e0fffd43 	ldbu	r3,-11(fp)
811032dc:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
811032e0:	e0bffc17 	ldw	r2,-16(fp)
}
811032e4:	e037883a 	mov	sp,fp
811032e8:	dfc00117 	ldw	ra,4(sp)
811032ec:	df000017 	ldw	fp,0(sp)
811032f0:	dec00204 	addi	sp,sp,8
811032f4:	f800283a 	ret

811032f8 <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
811032f8:	defffb04 	addi	sp,sp,-20
811032fc:	de00012e 	bgeu	sp,et,81103304 <sense_log_temp+0xc>
81103300:	003b68fa 	trap	3
81103304:	dfc00415 	stw	ra,16(sp)
81103308:	df000315 	stw	fp,12(sp)
8110330c:	df000304 	addi	fp,sp,12
81103310:	e13ffe15 	stw	r4,-8(fp)
81103314:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
81103318:	e17fff17 	ldw	r5,-4(fp)
8110331c:	e13ffe17 	ldw	r4,-8(fp)
81103320:	11032000 	call	81103200 <TEMP_Read>
81103324:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
81103328:	e0bffd17 	ldw	r2,-12(fp)
}
8110332c:	e037883a 	mov	sp,fp
81103330:	dfc00117 	ldw	ra,4(sp)
81103334:	df000017 	ldw	fp,0(sp)
81103338:	dec00204 	addi	sp,sp,8
8110333c:	f800283a 	ret

81103340 <sense_log>:

void sense_log(void) {
81103340:	deff0404 	addi	sp,sp,-1008
81103344:	de00012e 	bgeu	sp,et,8110334c <sense_log+0xc>
81103348:	003b68fa 	trap	3
8110334c:	dfc0fb15 	stw	ra,1004(sp)
81103350:	df00fa15 	stw	fp,1000(sp)
81103354:	dd40f915 	stw	r21,996(sp)
81103358:	dd00f815 	stw	r20,992(sp)
8110335c:	dcc0f715 	stw	r19,988(sp)
81103360:	dc80f615 	stw	r18,984(sp)
81103364:	dc40f515 	stw	r17,980(sp)
81103368:	dc00f415 	stw	r16,976(sp)
8110336c:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
81103370:	00902834 	movhi	r2,16544
81103374:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
81103378:	008ed174 	movhi	r2,15173
8110337c:	10a6e984 	addi	r2,r2,-25690
81103380:	e0bf2215 	stw	r2,-888(fp)
81103384:	008ea0f4 	movhi	r2,14979
81103388:	10849bc4 	addi	r2,r2,4719
8110338c:	e0bf2315 	stw	r2,-884(fp)
81103390:	008ed174 	movhi	r2,15173
81103394:	10a6e984 	addi	r2,r2,-25690
81103398:	e0bf2415 	stw	r2,-880(fp)
8110339c:	008ed174 	movhi	r2,15173
811033a0:	10a6e984 	addi	r2,r2,-25690
811033a4:	e0bf2515 	stw	r2,-876(fp)
811033a8:	008ed174 	movhi	r2,15173
811033ac:	10a6e984 	addi	r2,r2,-25690
811033b0:	e0bf2615 	stw	r2,-872(fp)
811033b4:	008ed174 	movhi	r2,15173
811033b8:	10a6e984 	addi	r2,r2,-25690
811033bc:	e0bf2715 	stw	r2,-868(fp)
811033c0:	008ed174 	movhi	r2,15173
811033c4:	10a6e984 	addi	r2,r2,-25690
811033c8:	e0bf2815 	stw	r2,-864(fp)
811033cc:	008ed174 	movhi	r2,15173
811033d0:	10a6e984 	addi	r2,r2,-25690
811033d4:	e0bf2915 	stw	r2,-860(fp)
811033d8:	008ed174 	movhi	r2,15173
811033dc:	10a6e984 	addi	r2,r2,-25690
811033e0:	e0bf2a15 	stw	r2,-856(fp)
811033e4:	008ed174 	movhi	r2,15173
811033e8:	10a6e984 	addi	r2,r2,-25690
811033ec:	e0bf2b15 	stw	r2,-852(fp)
811033f0:	008ed174 	movhi	r2,15173
811033f4:	10a6e984 	addi	r2,r2,-25690
811033f8:	e0bf2c15 	stw	r2,-848(fp)
811033fc:	008ed174 	movhi	r2,15173
81103400:	10a6e984 	addi	r2,r2,-25690
81103404:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
81103408:	008fd9b4 	movhi	r2,16230
8110340c:	10999984 	addi	r2,r2,26214
81103410:	e0bf2e15 	stw	r2,-840(fp)
81103414:	008fd9b4 	movhi	r2,16230
81103418:	10999984 	addi	r2,r2,26214
8110341c:	e0bf2f15 	stw	r2,-836(fp)
81103420:	00901034 	movhi	r2,16448
81103424:	e0bf3015 	stw	r2,-832(fp)
81103428:	008fd9b4 	movhi	r2,16230
8110342c:	10999984 	addi	r2,r2,26214
81103430:	e0bf3115 	stw	r2,-828(fp)
81103434:	008ff9b4 	movhi	r2,16358
81103438:	10999984 	addi	r2,r2,26214
8110343c:	e0bf3215 	stw	r2,-824(fp)
81103440:	00900834 	movhi	r2,16416
81103444:	e0bf3315 	stw	r2,-820(fp)
81103448:	008ff9b4 	movhi	r2,16358
8110344c:	10999984 	addi	r2,r2,26214
81103450:	e0bf3415 	stw	r2,-816(fp)
81103454:	00900834 	movhi	r2,16416
81103458:	e0bf3515 	stw	r2,-812(fp)
8110345c:	008fe374 	movhi	r2,16269
81103460:	10b33344 	addi	r2,r2,-13107
81103464:	e0bf3615 	stw	r2,-808(fp)
81103468:	008fecf4 	movhi	r2,16307
8110346c:	108cccc4 	addi	r2,r2,13107
81103470:	e0bf3715 	stw	r2,-804(fp)
81103474:	009014f4 	movhi	r2,16467
81103478:	108cccc4 	addi	r2,r2,13107
8110347c:	e0bf3815 	stw	r2,-800(fp)
81103480:	00900834 	movhi	r2,16416
81103484:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
81103488:	00a04534 	movhi	r2,33044
8110348c:	10b47e04 	addi	r2,r2,-11784
81103490:	e0ff3a04 	addi	r3,fp,-792
81103494:	1009883a 	mov	r4,r2
81103498:	0080c004 	movi	r2,768
8110349c:	100d883a 	mov	r6,r2
811034a0:	200b883a 	mov	r5,r4
811034a4:	1809883a 	mov	r4,r3
811034a8:	11136e00 	call	811136e0 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
811034ac:	e0bf1604 	addi	r2,fp,-936
811034b0:	1009883a 	mov	r4,r2
811034b4:	1102f380 	call	81102f38 <POWER_Read>
811034b8:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
811034bc:	e0bf0f17 	ldw	r2,-964(fp)
811034c0:	10016026 	beq	r2,zero,81103a44 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
811034c4:	e03f0c15 	stw	zero,-976(fp)
811034c8:	00014c06 	br	811039fc <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
811034cc:	e0bf0c17 	ldw	r2,-976(fp)
811034d0:	1085883a 	add	r2,r2,r2
811034d4:	1085883a 	add	r2,r2,r2
811034d8:	e0ff0c04 	addi	r3,fp,-976
811034dc:	1885883a 	add	r2,r3,r2
811034e0:	10800a04 	addi	r2,r2,40
811034e4:	10800017 	ldw	r2,0(r2)
811034e8:	1004d77a 	srli	r2,r2,29
811034ec:	1080004c 	andi	r2,r2,1
811034f0:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
811034f4:	e0bf0c17 	ldw	r2,-976(fp)
811034f8:	1085883a 	add	r2,r2,r2
811034fc:	1085883a 	add	r2,r2,r2
81103500:	e0ff0c04 	addi	r3,fp,-976
81103504:	1885883a 	add	r2,r3,r2
81103508:	10800a04 	addi	r2,r2,40
8110350c:	10800017 	ldw	r2,0(r2)
81103510:	1004d73a 	srli	r2,r2,28
81103514:	1080004c 	andi	r2,r2,1
81103518:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
8110351c:	e0bf0c17 	ldw	r2,-976(fp)
81103520:	1085883a 	add	r2,r2,r2
81103524:	1085883a 	add	r2,r2,r2
81103528:	e0ff0c04 	addi	r3,fp,-976
8110352c:	1885883a 	add	r2,r3,r2
81103530:	10800a04 	addi	r2,r2,40
81103534:	10800017 	ldw	r2,0(r2)
81103538:	1006d1ba 	srli	r3,r2,6
8110353c:	00801034 	movhi	r2,64
81103540:	10bfffc4 	addi	r2,r2,-1
81103544:	1884703a 	and	r2,r3,r2
81103548:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
8110354c:	e0bf1117 	ldw	r2,-956(fp)
81103550:	1000091e 	bne	r2,zero,81103578 <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
81103554:	e13f1217 	ldw	r4,-952(fp)
81103558:	1111a480 	call	81111a48 <__floatunsisf>
8110355c:	1007883a 	mov	r3,r2
81103560:	0152a034 	movhi	r5,19072
81103564:	1809883a 	mov	r4,r3
81103568:	11110d00 	call	811110d0 <__divsf3>
8110356c:	1007883a 	mov	r3,r2
81103570:	e0ff0d15 	stw	r3,-972(fp)
81103574:	00000106 	br	8110357c <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
81103578:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
8110357c:	e0bf1017 	ldw	r2,-960(fp)
81103580:	10002626 	beq	r2,zero,8110361c <sense_log+0x2dc>
81103584:	e0bf1117 	ldw	r2,-956(fp)
81103588:	10002426 	beq	r2,zero,8110361c <sense_log+0x2dc>
				fVol = fRef * 0.5;
8110358c:	014fc034 	movhi	r5,16128
81103590:	e13f0e17 	ldw	r4,-968(fp)
81103594:	11115180 	call	81111518 <__mulsf3>
81103598:	1007883a 	mov	r3,r2
8110359c:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811035a0:	e0ff3a04 	addi	r3,fp,-792
811035a4:	e0bf0c17 	ldw	r2,-976(fp)
811035a8:	100491ba 	slli	r2,r2,6
811035ac:	18a1883a 	add	r16,r3,r2
811035b0:	e0bf0c17 	ldw	r2,-976(fp)
811035b4:	1085883a 	add	r2,r2,r2
811035b8:	1085883a 	add	r2,r2,r2
811035bc:	e0ff0c04 	addi	r3,fp,-976
811035c0:	1885883a 	add	r2,r3,r2
811035c4:	10800a04 	addi	r2,r2,40
811035c8:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
811035cc:	1023883a 	mov	r17,r2
811035d0:	e13f1317 	ldw	r4,-948(fp)
811035d4:	11122600 	call	81112260 <__extendsfdf2>
811035d8:	1009883a 	mov	r4,r2
811035dc:	180b883a 	mov	r5,r3
811035e0:	d9000015 	stw	r4,0(sp)
811035e4:	d9400115 	stw	r5,4(sp)
811035e8:	880f883a 	mov	r7,r17
811035ec:	800d883a 	mov	r6,r16
811035f0:	01604534 	movhi	r5,33044
811035f4:	29744c04 	addi	r5,r5,-11984
811035f8:	01204534 	movhi	r4,33044
811035fc:	21077104 	addi	r4,r4,7620
81103600:	1113e480 	call	81113e48 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103604:	d0a04e17 	ldw	r2,-32456(gp)
81103608:	01604534 	movhi	r5,33044
8110360c:	29477104 	addi	r5,r5,7620
81103610:	1009883a 	mov	r4,r2
81103614:	11126e00 	call	811126e0 <fprintf>
81103618:	0000f506 	br	811039f0 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
8110361c:	e0bf1017 	ldw	r2,-960(fp)
81103620:	10006426 	beq	r2,zero,811037b4 <sense_log+0x474>
81103624:	e0bf1117 	ldw	r2,-956(fp)
81103628:	1000621e 	bne	r2,zero,811037b4 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
8110362c:	e13f0e17 	ldw	r4,-968(fp)
81103630:	11122600 	call	81112260 <__extendsfdf2>
81103634:	1011883a 	mov	r8,r2
81103638:	1813883a 	mov	r9,r3
8110363c:	000d883a 	mov	r6,zero
81103640:	01cff834 	movhi	r7,16352
81103644:	4009883a 	mov	r4,r8
81103648:	480b883a 	mov	r5,r9
8110364c:	1111b400 	call	81111b40 <__muldf3>
81103650:	1009883a 	mov	r4,r2
81103654:	180b883a 	mov	r5,r3
81103658:	2021883a 	mov	r16,r4
8110365c:	2823883a 	mov	r17,r5
81103660:	e13f0d17 	ldw	r4,-972(fp)
81103664:	11122600 	call	81112260 <__extendsfdf2>
81103668:	1009883a 	mov	r4,r2
8110366c:	180b883a 	mov	r5,r3
81103670:	200d883a 	mov	r6,r4
81103674:	280f883a 	mov	r7,r5
81103678:	8009883a 	mov	r4,r16
8110367c:	880b883a 	mov	r5,r17
81103680:	1111b400 	call	81111b40 <__muldf3>
81103684:	1009883a 	mov	r4,r2
81103688:	180b883a 	mov	r5,r3
8110368c:	2005883a 	mov	r2,r4
81103690:	2807883a 	mov	r3,r5
81103694:	1009883a 	mov	r4,r2
81103698:	180b883a 	mov	r5,r3
8110369c:	11123780 	call	81112378 <__truncdfsf2>
811036a0:	1007883a 	mov	r3,r2
811036a4:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811036a8:	e0bf0c17 	ldw	r2,-976(fp)
811036ac:	1085883a 	add	r2,r2,r2
811036b0:	1085883a 	add	r2,r2,r2
811036b4:	e0ff0c04 	addi	r3,fp,-976
811036b8:	1885883a 	add	r2,r3,r2
811036bc:	10801604 	addi	r2,r2,88
811036c0:	10c00017 	ldw	r3,0(r2)
811036c4:	180b883a 	mov	r5,r3
811036c8:	e13f0d17 	ldw	r4,-972(fp)
811036cc:	11110d00 	call	811110d0 <__divsf3>
811036d0:	1007883a 	mov	r3,r2
811036d4:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811036d8:	e0bf0c17 	ldw	r2,-976(fp)
811036dc:	1085883a 	add	r2,r2,r2
811036e0:	1085883a 	add	r2,r2,r2
811036e4:	e0ff0c04 	addi	r3,fp,-976
811036e8:	1885883a 	add	r2,r3,r2
811036ec:	10802204 	addi	r2,r2,136
811036f0:	10c00017 	ldw	r3,0(r2)
811036f4:	e17f1417 	ldw	r5,-944(fp)
811036f8:	1809883a 	mov	r4,r3
811036fc:	11115180 	call	81111518 <__mulsf3>
81103700:	1007883a 	mov	r3,r2
81103704:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103708:	e0ff3a04 	addi	r3,fp,-792
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	100491ba 	slli	r2,r2,6
81103714:	18a9883a 	add	r20,r3,r2
81103718:	e0bf0c17 	ldw	r2,-976(fp)
8110371c:	1085883a 	add	r2,r2,r2
81103720:	1085883a 	add	r2,r2,r2
81103724:	e0ff0c04 	addi	r3,fp,-976
81103728:	1885883a 	add	r2,r3,r2
8110372c:	10800a04 	addi	r2,r2,40
81103730:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103734:	102b883a 	mov	r21,r2
81103738:	e13f0d17 	ldw	r4,-972(fp)
8110373c:	11122600 	call	81112260 <__extendsfdf2>
81103740:	1021883a 	mov	r16,r2
81103744:	1823883a 	mov	r17,r3
81103748:	e13f1417 	ldw	r4,-944(fp)
8110374c:	11122600 	call	81112260 <__extendsfdf2>
81103750:	1025883a 	mov	r18,r2
81103754:	1827883a 	mov	r19,r3
81103758:	e13f1517 	ldw	r4,-940(fp)
8110375c:	11122600 	call	81112260 <__extendsfdf2>
81103760:	1009883a 	mov	r4,r2
81103764:	180b883a 	mov	r5,r3
81103768:	d9000415 	stw	r4,16(sp)
8110376c:	d9400515 	stw	r5,20(sp)
81103770:	dc800215 	stw	r18,8(sp)
81103774:	dcc00315 	stw	r19,12(sp)
81103778:	dc000015 	stw	r16,0(sp)
8110377c:	dc400115 	stw	r17,4(sp)
81103780:	a80f883a 	mov	r7,r21
81103784:	a00d883a 	mov	r6,r20
81103788:	01604534 	movhi	r5,33044
8110378c:	29745504 	addi	r5,r5,-11948
81103790:	01204534 	movhi	r4,33044
81103794:	21077104 	addi	r4,r4,7620
81103798:	1113e480 	call	81113e48 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
8110379c:	d0a04e17 	ldw	r2,-32456(gp)
811037a0:	01604534 	movhi	r5,33044
811037a4:	29477104 	addi	r5,r5,7620
811037a8:	1009883a 	mov	r4,r2
811037ac:	11126e00 	call	811126e0 <fprintf>
811037b0:	00008f06 	br	811039f0 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
811037b4:	e0bf1017 	ldw	r2,-960(fp)
811037b8:	1000641e 	bne	r2,zero,8110394c <sense_log+0x60c>
811037bc:	e0bf1117 	ldw	r2,-956(fp)
811037c0:	10006226 	beq	r2,zero,8110394c <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
811037c4:	e13f0e17 	ldw	r4,-968(fp)
811037c8:	11122600 	call	81112260 <__extendsfdf2>
811037cc:	1011883a 	mov	r8,r2
811037d0:	1813883a 	mov	r9,r3
811037d4:	000d883a 	mov	r6,zero
811037d8:	01cff834 	movhi	r7,16352
811037dc:	4009883a 	mov	r4,r8
811037e0:	480b883a 	mov	r5,r9
811037e4:	1111b400 	call	81111b40 <__muldf3>
811037e8:	1009883a 	mov	r4,r2
811037ec:	180b883a 	mov	r5,r3
811037f0:	2021883a 	mov	r16,r4
811037f4:	2823883a 	mov	r17,r5
811037f8:	e13f0d17 	ldw	r4,-972(fp)
811037fc:	11122600 	call	81112260 <__extendsfdf2>
81103800:	1009883a 	mov	r4,r2
81103804:	180b883a 	mov	r5,r3
81103808:	200d883a 	mov	r6,r4
8110380c:	280f883a 	mov	r7,r5
81103810:	8009883a 	mov	r4,r16
81103814:	880b883a 	mov	r5,r17
81103818:	1111b400 	call	81111b40 <__muldf3>
8110381c:	1009883a 	mov	r4,r2
81103820:	180b883a 	mov	r5,r3
81103824:	2005883a 	mov	r2,r4
81103828:	2807883a 	mov	r3,r5
8110382c:	1009883a 	mov	r4,r2
81103830:	180b883a 	mov	r5,r3
81103834:	11123780 	call	81112378 <__truncdfsf2>
81103838:	1007883a 	mov	r3,r2
8110383c:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
81103840:	e0bf0c17 	ldw	r2,-976(fp)
81103844:	1085883a 	add	r2,r2,r2
81103848:	1085883a 	add	r2,r2,r2
8110384c:	e0ff0c04 	addi	r3,fp,-976
81103850:	1885883a 	add	r2,r3,r2
81103854:	10801604 	addi	r2,r2,88
81103858:	10c00017 	ldw	r3,0(r2)
8110385c:	180b883a 	mov	r5,r3
81103860:	e13f0d17 	ldw	r4,-972(fp)
81103864:	11110d00 	call	811110d0 <__divsf3>
81103868:	1007883a 	mov	r3,r2
8110386c:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
81103870:	e0bf0c17 	ldw	r2,-976(fp)
81103874:	1085883a 	add	r2,r2,r2
81103878:	1085883a 	add	r2,r2,r2
8110387c:	e0ff0c04 	addi	r3,fp,-976
81103880:	1885883a 	add	r2,r3,r2
81103884:	10802204 	addi	r2,r2,136
81103888:	10c00017 	ldw	r3,0(r2)
8110388c:	e17f1417 	ldw	r5,-944(fp)
81103890:	1809883a 	mov	r4,r3
81103894:	11115180 	call	81111518 <__mulsf3>
81103898:	1007883a 	mov	r3,r2
8110389c:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
811038a0:	e0ff3a04 	addi	r3,fp,-792
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	100491ba 	slli	r2,r2,6
811038ac:	18a9883a 	add	r20,r3,r2
811038b0:	e0bf0c17 	ldw	r2,-976(fp)
811038b4:	1085883a 	add	r2,r2,r2
811038b8:	1085883a 	add	r2,r2,r2
811038bc:	e0ff0c04 	addi	r3,fp,-976
811038c0:	1885883a 	add	r2,r3,r2
811038c4:	10800a04 	addi	r2,r2,40
811038c8:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811038cc:	102b883a 	mov	r21,r2
811038d0:	e13f0d17 	ldw	r4,-972(fp)
811038d4:	11122600 	call	81112260 <__extendsfdf2>
811038d8:	1021883a 	mov	r16,r2
811038dc:	1823883a 	mov	r17,r3
811038e0:	e13f1417 	ldw	r4,-944(fp)
811038e4:	11122600 	call	81112260 <__extendsfdf2>
811038e8:	1025883a 	mov	r18,r2
811038ec:	1827883a 	mov	r19,r3
811038f0:	e13f1517 	ldw	r4,-940(fp)
811038f4:	11122600 	call	81112260 <__extendsfdf2>
811038f8:	1009883a 	mov	r4,r2
811038fc:	180b883a 	mov	r5,r3
81103900:	d9000415 	stw	r4,16(sp)
81103904:	d9400515 	stw	r5,20(sp)
81103908:	dc800215 	stw	r18,8(sp)
8110390c:	dcc00315 	stw	r19,12(sp)
81103910:	dc000015 	stw	r16,0(sp)
81103914:	dc400115 	stw	r17,4(sp)
81103918:	a80f883a 	mov	r7,r21
8110391c:	a00d883a 	mov	r6,r20
81103920:	01604534 	movhi	r5,33044
81103924:	29746504 	addi	r5,r5,-11884
81103928:	01204534 	movhi	r4,33044
8110392c:	21077104 	addi	r4,r4,7620
81103930:	1113e480 	call	81113e48 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103934:	d0a04e17 	ldw	r2,-32456(gp)
81103938:	01604534 	movhi	r5,33044
8110393c:	29477104 	addi	r5,r5,7620
81103940:	1009883a 	mov	r4,r2
81103944:	11126e00 	call	811126e0 <fprintf>
81103948:	00002906 	br	811039f0 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
8110394c:	e0bf1017 	ldw	r2,-960(fp)
81103950:	1000271e 	bne	r2,zero,811039f0 <sense_log+0x6b0>
81103954:	e0bf1117 	ldw	r2,-956(fp)
81103958:	1000251e 	bne	r2,zero,811039f0 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
8110395c:	e0bf0e17 	ldw	r2,-968(fp)
81103960:	10a0003c 	xorhi	r2,r2,32768
81103964:	014fc034 	movhi	r5,16128
81103968:	1009883a 	mov	r4,r2
8110396c:	11115180 	call	81111518 <__mulsf3>
81103970:	1007883a 	mov	r3,r2
81103974:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103978:	e0ff3a04 	addi	r3,fp,-792
8110397c:	e0bf0c17 	ldw	r2,-976(fp)
81103980:	100491ba 	slli	r2,r2,6
81103984:	18a1883a 	add	r16,r3,r2
81103988:	e0bf0c17 	ldw	r2,-976(fp)
8110398c:	1085883a 	add	r2,r2,r2
81103990:	1085883a 	add	r2,r2,r2
81103994:	e0ff0c04 	addi	r3,fp,-976
81103998:	1885883a 	add	r2,r3,r2
8110399c:	10800a04 	addi	r2,r2,40
811039a0:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
811039a4:	1023883a 	mov	r17,r2
811039a8:	e13f1317 	ldw	r4,-948(fp)
811039ac:	11122600 	call	81112260 <__extendsfdf2>
811039b0:	1009883a 	mov	r4,r2
811039b4:	180b883a 	mov	r5,r3
811039b8:	d9000015 	stw	r4,0(sp)
811039bc:	d9400115 	stw	r5,4(sp)
811039c0:	880f883a 	mov	r7,r17
811039c4:	800d883a 	mov	r6,r16
811039c8:	01604534 	movhi	r5,33044
811039cc:	29747504 	addi	r5,r5,-11820
811039d0:	01204534 	movhi	r4,33044
811039d4:	21077104 	addi	r4,r4,7620
811039d8:	1113e480 	call	81113e48 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
811039dc:	d0a04e17 	ldw	r2,-32456(gp)
811039e0:	01604534 	movhi	r5,33044
811039e4:	29477104 	addi	r5,r5,7620
811039e8:	1009883a 	mov	r4,r2
811039ec:	11126e00 	call	811126e0 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
811039f0:	e0bf0c17 	ldw	r2,-976(fp)
811039f4:	10800044 	addi	r2,r2,1
811039f8:	e0bf0c15 	stw	r2,-976(fp)
811039fc:	e0bf0c17 	ldw	r2,-976(fp)
81103a00:	10800308 	cmpgei	r2,r2,12
81103a04:	1000021e 	bne	r2,zero,81103a10 <sense_log+0x6d0>
81103a08:	e0bf0f17 	ldw	r2,-964(fp)
81103a0c:	103eaf1e 	bne	r2,zero,811034cc <__reset+0xfb0e34cc>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a10:	00a04534 	movhi	r2,33044
81103a14:	10877104 	addi	r2,r2,7620
81103a18:	00c00344 	movi	r3,13
81103a1c:	10c00005 	stb	r3,0(r2)
81103a20:	00c00284 	movi	r3,10
81103a24:	10c00045 	stb	r3,1(r2)
81103a28:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a2c:	d0a04e17 	ldw	r2,-32456(gp)
81103a30:	01604534 	movhi	r5,33044
81103a34:	29477104 	addi	r5,r5,7620
81103a38:	1009883a 	mov	r4,r2
81103a3c:	11126e00 	call	811126e0 <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103a40:	00001606 	br	81103a9c <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103a44:	00a04534 	movhi	r2,33044
81103a48:	10877104 	addi	r2,r2,7620
81103a4c:	00c01144 	movi	r3,69
81103a50:	10c00005 	stb	r3,0(r2)
81103a54:	00c01c84 	movi	r3,114
81103a58:	10c00045 	stb	r3,1(r2)
81103a5c:	00c01c84 	movi	r3,114
81103a60:	10c00085 	stb	r3,2(r2)
81103a64:	00c01bc4 	movi	r3,111
81103a68:	10c000c5 	stb	r3,3(r2)
81103a6c:	00c01c84 	movi	r3,114
81103a70:	10c00105 	stb	r3,4(r2)
81103a74:	00c00344 	movi	r3,13
81103a78:	10c00145 	stb	r3,5(r2)
81103a7c:	00c00284 	movi	r3,10
81103a80:	10c00185 	stb	r3,6(r2)
81103a84:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103a88:	d0a04e17 	ldw	r2,-32456(gp)
81103a8c:	01604534 	movhi	r5,33044
81103a90:	29477104 	addi	r5,r5,7620
81103a94:	1009883a 	mov	r4,r2
81103a98:	11126e00 	call	811126e0 <fprintf>
#endif
	}
}
81103a9c:	0001883a 	nop
81103aa0:	e6fffa04 	addi	sp,fp,-24
81103aa4:	dfc00717 	ldw	ra,28(sp)
81103aa8:	df000617 	ldw	fp,24(sp)
81103aac:	dd400517 	ldw	r21,20(sp)
81103ab0:	dd000417 	ldw	r20,16(sp)
81103ab4:	dcc00317 	ldw	r19,12(sp)
81103ab8:	dc800217 	ldw	r18,8(sp)
81103abc:	dc400117 	ldw	r17,4(sp)
81103ac0:	dc000017 	ldw	r16,0(sp)
81103ac4:	dec00804 	addi	sp,sp,32
81103ac8:	f800283a 	ret

81103acc <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103acc:	defffc04 	addi	sp,sp,-16
81103ad0:	de00012e 	bgeu	sp,et,81103ad8 <bSdmaInitM1Dma+0xc>
81103ad4:	003b68fa 	trap	3
81103ad8:	dfc00315 	stw	ra,12(sp)
81103adc:	df000215 	stw	fp,8(sp)
81103ae0:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103ae4:	00800044 	movi	r2,1
81103ae8:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103aec:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103af0:	01204534 	movhi	r4,33044
81103af4:	21353e04 	addi	r4,r4,-11016
81103af8:	113ac680 	call	8113ac68 <alt_msgdma_open>
81103afc:	d0a03815 	stw	r2,-32544(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b00:	d0a03817 	ldw	r2,-32544(gp)
81103b04:	1000021e 	bne	r2,zero,81103b10 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b08:	e03ffe15 	stw	zero,-8(fp)
81103b0c:	00001506 	br	81103b64 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b10:	d0a03817 	ldw	r2,-32544(gp)
81103b14:	10800317 	ldw	r2,12(r2)
81103b18:	10800104 	addi	r2,r2,4
81103b1c:	00c00084 	movi	r3,2
81103b20:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b24:	00000a06 	br	81103b50 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b28:	01000044 	movi	r4,1
81103b2c:	1128bec0 	call	81128bec <usleep>
			usiCounter++;
81103b30:	e0bfff0b 	ldhu	r2,-4(fp)
81103b34:	10800044 	addi	r2,r2,1
81103b38:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103b3c:	e0bfff0b 	ldhu	r2,-4(fp)
81103b40:	1084e230 	cmpltui	r2,r2,5000
81103b44:	1000021e 	bne	r2,zero,81103b50 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103b48:	e03ffe15 	stw	zero,-8(fp)
				break;
81103b4c:	00000506 	br	81103b64 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b50:	d0a03817 	ldw	r2,-32544(gp)
81103b54:	10800317 	ldw	r2,12(r2)
81103b58:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103b5c:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b60:	103ff11e 	bne	r2,zero,81103b28 <__reset+0xfb0e3b28>
				break;
			}
		}
	}

	return bStatus;
81103b64:	e0bffe17 	ldw	r2,-8(fp)
}
81103b68:	e037883a 	mov	sp,fp
81103b6c:	dfc00117 	ldw	ra,4(sp)
81103b70:	df000017 	ldw	fp,0(sp)
81103b74:	dec00204 	addi	sp,sp,8
81103b78:	f800283a 	ret

81103b7c <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103b7c:	defffc04 	addi	sp,sp,-16
81103b80:	de00012e 	bgeu	sp,et,81103b88 <bSdmaInitM2Dma+0xc>
81103b84:	003b68fa 	trap	3
81103b88:	dfc00315 	stw	ra,12(sp)
81103b8c:	df000215 	stw	fp,8(sp)
81103b90:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b94:	00800044 	movi	r2,1
81103b98:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b9c:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103ba0:	01204534 	movhi	r4,33044
81103ba4:	21354304 	addi	r4,r4,-10996
81103ba8:	113ac680 	call	8113ac68 <alt_msgdma_open>
81103bac:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103bb0:	d0a03917 	ldw	r2,-32540(gp)
81103bb4:	1000021e 	bne	r2,zero,81103bc0 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103bb8:	e03ffe15 	stw	zero,-8(fp)
81103bbc:	00001506 	br	81103c14 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103bc0:	d0a03917 	ldw	r2,-32540(gp)
81103bc4:	10800317 	ldw	r2,12(r2)
81103bc8:	10800104 	addi	r2,r2,4
81103bcc:	00c00084 	movi	r3,2
81103bd0:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103bd4:	00000a06 	br	81103c00 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103bd8:	01000044 	movi	r4,1
81103bdc:	1128bec0 	call	81128bec <usleep>
			usiCounter++;
81103be0:	e0bfff0b 	ldhu	r2,-4(fp)
81103be4:	10800044 	addi	r2,r2,1
81103be8:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103bec:	e0bfff0b 	ldhu	r2,-4(fp)
81103bf0:	1084e230 	cmpltui	r2,r2,5000
81103bf4:	1000021e 	bne	r2,zero,81103c00 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103bf8:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bfc:	00000506 	br	81103c14 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c00:	d0a03917 	ldw	r2,-32540(gp)
81103c04:	10800317 	ldw	r2,12(r2)
81103c08:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c0c:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c10:	103ff11e 	bne	r2,zero,81103bd8 <__reset+0xfb0e3bd8>
				break;
			}
		}
	}

	return bStatus;
81103c14:	e0bffe17 	ldw	r2,-8(fp)
}
81103c18:	e037883a 	mov	sp,fp
81103c1c:	dfc00117 	ldw	ra,4(sp)
81103c20:	df000017 	ldw	fp,0(sp)
81103c24:	dec00204 	addi	sp,sp,8
81103c28:	f800283a 	ret

81103c2c <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c2c:	deffe904 	addi	sp,sp,-92
81103c30:	de00012e 	bgeu	sp,et,81103c38 <bSdmaDmaM1Transfer+0xc>
81103c34:	003b68fa 	trap	3
81103c38:	dfc01615 	stw	ra,88(sp)
81103c3c:	df001515 	stw	fp,84(sp)
81103c40:	dc001415 	stw	r16,80(sp)
81103c44:	df001504 	addi	fp,sp,84
81103c48:	e13ffb15 	stw	r4,-20(fp)
81103c4c:	2809883a 	mov	r4,r5
81103c50:	3007883a 	mov	r3,r6
81103c54:	3805883a 	mov	r2,r7
81103c58:	e13ffc0d 	sth	r4,-16(fp)
81103c5c:	e0fffd05 	stb	r3,-12(fp)
81103c60:	e0bffe05 	stb	r2,-8(fp)
81103c64:	defff004 	addi	sp,sp,-64
81103c68:	d8800904 	addi	r2,sp,36
81103c6c:	108007c4 	addi	r2,r2,31
81103c70:	1004d17a 	srli	r2,r2,5
81103c74:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103c78:	00800044 	movi	r2,1
81103c7c:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81103c80:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103c84:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81103c88:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81103c8c:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103c90:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103c94:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81103c98:	e0bffe03 	ldbu	r2,-8(fp)
81103c9c:	10c00268 	cmpgeui	r3,r2,9
81103ca0:	1800a51e 	bne	r3,zero,81103f38 <bSdmaDmaM1Transfer+0x30c>
81103ca4:	100690ba 	slli	r3,r2,2
81103ca8:	00a04434 	movhi	r2,33040
81103cac:	108f2f04 	addi	r2,r2,15548
81103cb0:	1885883a 	add	r2,r3,r2
81103cb4:	10800017 	ldw	r2,0(r2)
81103cb8:	1000683a 	jmp	r2
81103cbc:	81103f38 	rdprs	r4,r16,16636
81103cc0:	81103ce0 	cmpeqi	r4,r16,16627
81103cc4:	81103d24 	muli	r4,r16,16628
81103cc8:	81103d70 	cmpltui	r4,r16,16629
81103ccc:	81103dbc 	xorhi	r4,r16,16630
81103cd0:	81103e08 	cmpgei	r4,r16,16632
81103cd4:	81103e54 	ori	r4,r16,16633
81103cd8:	81103ea0 	cmpeqi	r4,r16,16634
81103cdc:	81103eec 	andhi	r4,r16,16635
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103ce0:	e0bffd03 	ldbu	r2,-12(fp)
81103ce4:	10000326 	beq	r2,zero,81103cf4 <bSdmaDmaM1Transfer+0xc8>
81103ce8:	10800060 	cmpeqi	r2,r2,1
81103cec:	1000051e 	bne	r2,zero,81103d04 <bSdmaDmaM1Transfer+0xd8>
81103cf0:	00000906 	br	81103d18 <bSdmaDmaM1Transfer+0xec>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103cf4:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103cf8:	00800044 	movi	r2,1
81103cfc:	e0bff715 	stw	r2,-36(fp)
			break;
81103d00:	00000706 	br	81103d20 <bSdmaDmaM1Transfer+0xf4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d04:	00800074 	movhi	r2,1
81103d08:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d0c:	00800044 	movi	r2,1
81103d10:	e0bff715 	stw	r2,-36(fp)
			break;
81103d14:	00000206 	br	81103d20 <bSdmaDmaM1Transfer+0xf4>
		default:
			bStatus = FALSE;
81103d18:	e03ff415 	stw	zero,-48(fp)
			break;
81103d1c:	0001883a 	nop
		}
		break;
81103d20:	00008706 	br	81103f40 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d24:	e0bffd03 	ldbu	r2,-12(fp)
81103d28:	10000326 	beq	r2,zero,81103d38 <bSdmaDmaM1Transfer+0x10c>
81103d2c:	10800060 	cmpeqi	r2,r2,1
81103d30:	1000061e 	bne	r2,zero,81103d4c <bSdmaDmaM1Transfer+0x120>
81103d34:	00000b06 	br	81103d64 <bSdmaDmaM1Transfer+0x138>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103d38:	00880004 	movi	r2,8192
81103d3c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103d40:	00800044 	movi	r2,1
81103d44:	e0bff715 	stw	r2,-36(fp)
			break;
81103d48:	00000806 	br	81103d6c <bSdmaDmaM1Transfer+0x140>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103d4c:	00800074 	movhi	r2,1
81103d50:	10880004 	addi	r2,r2,8192
81103d54:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103d58:	00800044 	movi	r2,1
81103d5c:	e0bff715 	stw	r2,-36(fp)
			break;
81103d60:	00000206 	br	81103d6c <bSdmaDmaM1Transfer+0x140>
		default:
			bStatus = FALSE;
81103d64:	e03ff415 	stw	zero,-48(fp)
			break;
81103d68:	0001883a 	nop
		}
		break;
81103d6c:	00007406 	br	81103f40 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103d70:	e0bffd03 	ldbu	r2,-12(fp)
81103d74:	10000326 	beq	r2,zero,81103d84 <bSdmaDmaM1Transfer+0x158>
81103d78:	10800060 	cmpeqi	r2,r2,1
81103d7c:	1000061e 	bne	r2,zero,81103d98 <bSdmaDmaM1Transfer+0x16c>
81103d80:	00000b06 	br	81103db0 <bSdmaDmaM1Transfer+0x184>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103d84:	00900004 	movi	r2,16384
81103d88:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103d8c:	00800044 	movi	r2,1
81103d90:	e0bff715 	stw	r2,-36(fp)
			break;
81103d94:	00000806 	br	81103db8 <bSdmaDmaM1Transfer+0x18c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103d98:	00800074 	movhi	r2,1
81103d9c:	10900004 	addi	r2,r2,16384
81103da0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103da4:	00800044 	movi	r2,1
81103da8:	e0bff715 	stw	r2,-36(fp)
			break;
81103dac:	00000206 	br	81103db8 <bSdmaDmaM1Transfer+0x18c>
		default:
			bStatus = FALSE;
81103db0:	e03ff415 	stw	zero,-48(fp)
			break;
81103db4:	0001883a 	nop
		}
		break;
81103db8:	00006106 	br	81103f40 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103dbc:	e0bffd03 	ldbu	r2,-12(fp)
81103dc0:	10000326 	beq	r2,zero,81103dd0 <bSdmaDmaM1Transfer+0x1a4>
81103dc4:	10800060 	cmpeqi	r2,r2,1
81103dc8:	1000061e 	bne	r2,zero,81103de4 <bSdmaDmaM1Transfer+0x1b8>
81103dcc:	00000b06 	br	81103dfc <bSdmaDmaM1Transfer+0x1d0>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103dd0:	00980004 	movi	r2,24576
81103dd4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103dd8:	00800044 	movi	r2,1
81103ddc:	e0bff715 	stw	r2,-36(fp)
			break;
81103de0:	00000806 	br	81103e04 <bSdmaDmaM1Transfer+0x1d8>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103de4:	00800074 	movhi	r2,1
81103de8:	10980004 	addi	r2,r2,24576
81103dec:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103df0:	00800044 	movi	r2,1
81103df4:	e0bff715 	stw	r2,-36(fp)
			break;
81103df8:	00000206 	br	81103e04 <bSdmaDmaM1Transfer+0x1d8>
		default:
			bStatus = FALSE;
81103dfc:	e03ff415 	stw	zero,-48(fp)
			break;
81103e00:	0001883a 	nop
		}
		break;
81103e04:	00004e06 	br	81103f40 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e08:	e0bffd03 	ldbu	r2,-12(fp)
81103e0c:	10000326 	beq	r2,zero,81103e1c <bSdmaDmaM1Transfer+0x1f0>
81103e10:	10800060 	cmpeqi	r2,r2,1
81103e14:	1000061e 	bne	r2,zero,81103e30 <bSdmaDmaM1Transfer+0x204>
81103e18:	00000b06 	br	81103e48 <bSdmaDmaM1Transfer+0x21c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103e1c:	00a00014 	movui	r2,32768
81103e20:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103e24:	00800044 	movi	r2,1
81103e28:	e0bff715 	stw	r2,-36(fp)
			break;
81103e2c:	00000806 	br	81103e50 <bSdmaDmaM1Transfer+0x224>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103e30:	008000b4 	movhi	r2,2
81103e34:	10a00004 	addi	r2,r2,-32768
81103e38:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103e3c:	00800044 	movi	r2,1
81103e40:	e0bff715 	stw	r2,-36(fp)
			break;
81103e44:	00000206 	br	81103e50 <bSdmaDmaM1Transfer+0x224>
		default:
			bStatus = FALSE;
81103e48:	e03ff415 	stw	zero,-48(fp)
			break;
81103e4c:	0001883a 	nop
		}
		break;
81103e50:	00003b06 	br	81103f40 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103e54:	e0bffd03 	ldbu	r2,-12(fp)
81103e58:	10000326 	beq	r2,zero,81103e68 <bSdmaDmaM1Transfer+0x23c>
81103e5c:	10800060 	cmpeqi	r2,r2,1
81103e60:	1000061e 	bne	r2,zero,81103e7c <bSdmaDmaM1Transfer+0x250>
81103e64:	00000b06 	br	81103e94 <bSdmaDmaM1Transfer+0x268>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103e68:	00a80014 	movui	r2,40960
81103e6c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103e70:	00800044 	movi	r2,1
81103e74:	e0bff715 	stw	r2,-36(fp)
			break;
81103e78:	00000806 	br	81103e9c <bSdmaDmaM1Transfer+0x270>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103e7c:	008000b4 	movhi	r2,2
81103e80:	10a80004 	addi	r2,r2,-24576
81103e84:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103e88:	00800044 	movi	r2,1
81103e8c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e90:	00000206 	br	81103e9c <bSdmaDmaM1Transfer+0x270>
		default:
			bStatus = FALSE;
81103e94:	e03ff415 	stw	zero,-48(fp)
			break;
81103e98:	0001883a 	nop
		}
		break;
81103e9c:	00002806 	br	81103f40 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103ea0:	e0bffd03 	ldbu	r2,-12(fp)
81103ea4:	10000326 	beq	r2,zero,81103eb4 <bSdmaDmaM1Transfer+0x288>
81103ea8:	10800060 	cmpeqi	r2,r2,1
81103eac:	1000061e 	bne	r2,zero,81103ec8 <bSdmaDmaM1Transfer+0x29c>
81103eb0:	00000b06 	br	81103ee0 <bSdmaDmaM1Transfer+0x2b4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103eb4:	00b00014 	movui	r2,49152
81103eb8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103ebc:	00800044 	movi	r2,1
81103ec0:	e0bff715 	stw	r2,-36(fp)
			break;
81103ec4:	00000806 	br	81103ee8 <bSdmaDmaM1Transfer+0x2bc>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103ec8:	008000b4 	movhi	r2,2
81103ecc:	10b00004 	addi	r2,r2,-16384
81103ed0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103ed4:	00800044 	movi	r2,1
81103ed8:	e0bff715 	stw	r2,-36(fp)
			break;
81103edc:	00000206 	br	81103ee8 <bSdmaDmaM1Transfer+0x2bc>
		default:
			bStatus = FALSE;
81103ee0:	e03ff415 	stw	zero,-48(fp)
			break;
81103ee4:	0001883a 	nop
		}
		break;
81103ee8:	00001506 	br	81103f40 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103eec:	e0bffd03 	ldbu	r2,-12(fp)
81103ef0:	10000326 	beq	r2,zero,81103f00 <bSdmaDmaM1Transfer+0x2d4>
81103ef4:	10800060 	cmpeqi	r2,r2,1
81103ef8:	1000061e 	bne	r2,zero,81103f14 <bSdmaDmaM1Transfer+0x2e8>
81103efc:	00000b06 	br	81103f2c <bSdmaDmaM1Transfer+0x300>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103f00:	00b80014 	movui	r2,57344
81103f04:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103f08:	00800044 	movi	r2,1
81103f0c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f10:	00000806 	br	81103f34 <bSdmaDmaM1Transfer+0x308>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103f14:	008000b4 	movhi	r2,2
81103f18:	10b80004 	addi	r2,r2,-8192
81103f1c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103f20:	00800044 	movi	r2,1
81103f24:	e0bff715 	stw	r2,-36(fp)
			break;
81103f28:	00000206 	br	81103f34 <bSdmaDmaM1Transfer+0x308>
		default:
			bStatus = FALSE;
81103f2c:	e03ff415 	stw	zero,-48(fp)
			break;
81103f30:	0001883a 	nop
		}
		break;
81103f34:	00000206 	br	81103f40 <bSdmaDmaM1Transfer+0x314>
	default:
		bStatus = FALSE;
81103f38:	e03ff415 	stw	zero,-48(fp)
		break;
81103f3c:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103f40:	e0bffb17 	ldw	r2,-20(fp)
81103f44:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103f48:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
81103f4c:	e0bff417 	ldw	r2,-48(fp)
81103f50:	10003b26 	beq	r2,zero,81104040 <bSdmaDmaM1Transfer+0x414>
		if (pxDmaM1Dev == NULL) {
81103f54:	d0a03817 	ldw	r2,-32544(gp)
81103f58:	1000021e 	bne	r2,zero,81103f64 <bSdmaDmaM1Transfer+0x338>
			bStatus = FALSE;
81103f5c:	e03ff415 	stw	zero,-48(fp)
81103f60:	00003706 	br	81104040 <bSdmaDmaM1Transfer+0x414>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81103f64:	e03ff50d 	sth	zero,-44(fp)
81103f68:	00003206 	br	81104034 <bSdmaDmaM1Transfer+0x408>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81103f6c:	01000044 	movi	r4,1
81103f70:	1127d1c0 	call	81127d1c <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103f74:	d0a03817 	ldw	r2,-32544(gp)
81103f78:	10800317 	ldw	r2,12(r2)
81103f7c:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81103f80:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81103f84:	103ff91e 	bne	r2,zero,81103f6c <__reset+0xfb0e3f6c>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81103f88:	d2203817 	ldw	r8,-32544(gp)
81103f8c:	e17ff817 	ldw	r5,-32(fp)
81103f90:	e1bff617 	ldw	r6,-40(fp)
81103f94:	e0bff917 	ldw	r2,-28(fp)
81103f98:	e0fff717 	ldw	r3,-36(fp)
81103f9c:	01000044 	movi	r4,1
81103fa0:	d9000815 	stw	r4,32(sp)
81103fa4:	01000044 	movi	r4,1
81103fa8:	d9000715 	stw	r4,28(sp)
81103fac:	01000044 	movi	r4,1
81103fb0:	d9000615 	stw	r4,24(sp)
81103fb4:	01000044 	movi	r4,1
81103fb8:	d9000515 	stw	r4,20(sp)
81103fbc:	01000044 	movi	r4,1
81103fc0:	d9000415 	stw	r4,16(sp)
81103fc4:	d8c00315 	stw	r3,12(sp)
81103fc8:	d8800215 	stw	r2,8(sp)
81103fcc:	e0bffa17 	ldw	r2,-24(fp)
81103fd0:	d8800115 	stw	r2,4(sp)
81103fd4:	00802204 	movi	r2,136
81103fd8:	d8800015 	stw	r2,0(sp)
81103fdc:	300f883a 	mov	r7,r6
81103fe0:	280d883a 	mov	r6,r5
81103fe4:	800b883a 	mov	r5,r16
81103fe8:	4009883a 	mov	r4,r8
81103fec:	1106b800 	call	81106b80 <iMsgdmaConstructExtendedMmToMmDescriptor>
81103ff0:	10000226 	beq	r2,zero,81103ffc <bSdmaDmaM1Transfer+0x3d0>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81103ff4:	e03ff415 	stw	zero,-48(fp)
					break;
81103ff8:	00001106 	br	81104040 <bSdmaDmaM1Transfer+0x414>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
81103ffc:	d0a03817 	ldw	r2,-32544(gp)
81104000:	800b883a 	mov	r5,r16
81104004:	1009883a 	mov	r4,r2
81104008:	1106c840 	call	81106c84 <iMsgdmaExtendedDescriptorSyncTransfer>
8110400c:	10000226 	beq	r2,zero,81104018 <bSdmaDmaM1Transfer+0x3ec>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104010:	e03ff415 	stw	zero,-48(fp)
						break;
81104014:	00000a06 	br	81104040 <bSdmaDmaM1Transfer+0x414>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
81104018:	e0bff817 	ldw	r2,-32(fp)
8110401c:	10802204 	addi	r2,r2,136
81104020:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104024:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104028:	e0bff50b 	ldhu	r2,-44(fp)
8110402c:	10800044 	addi	r2,r2,1
81104030:	e0bff50d 	sth	r2,-44(fp)
81104034:	e0fff50b 	ldhu	r3,-44(fp)
81104038:	e0bffc0b 	ldhu	r2,-16(fp)
8110403c:	18bfcd36 	bltu	r3,r2,81103f74 <__reset+0xfb0e3f74>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104040:	e0bff417 	ldw	r2,-48(fp)
}
81104044:	e6ffff04 	addi	sp,fp,-4
81104048:	dfc00217 	ldw	ra,8(sp)
8110404c:	df000117 	ldw	fp,4(sp)
81104050:	dc000017 	ldw	r16,0(sp)
81104054:	dec00304 	addi	sp,sp,12
81104058:	f800283a 	ret

8110405c <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
8110405c:	deffe904 	addi	sp,sp,-92
81104060:	de00012e 	bgeu	sp,et,81104068 <bSdmaDmaM2Transfer+0xc>
81104064:	003b68fa 	trap	3
81104068:	dfc01615 	stw	ra,88(sp)
8110406c:	df001515 	stw	fp,84(sp)
81104070:	dc001415 	stw	r16,80(sp)
81104074:	df001504 	addi	fp,sp,84
81104078:	e13ffb15 	stw	r4,-20(fp)
8110407c:	2809883a 	mov	r4,r5
81104080:	3007883a 	mov	r3,r6
81104084:	3805883a 	mov	r2,r7
81104088:	e13ffc0d 	sth	r4,-16(fp)
8110408c:	e0fffd05 	stb	r3,-12(fp)
81104090:	e0bffe05 	stb	r2,-8(fp)
81104094:	defff004 	addi	sp,sp,-64
81104098:	d8800904 	addi	r2,sp,36
8110409c:	108007c4 	addi	r2,r2,31
811040a0:	1004d17a 	srli	r2,r2,5
811040a4:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
811040a8:	00800044 	movi	r2,1
811040ac:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
811040b0:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
811040b4:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
811040b8:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
811040bc:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
811040c0:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
811040c4:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
811040c8:	e0bffe03 	ldbu	r2,-8(fp)
811040cc:	10c00268 	cmpgeui	r3,r2,9
811040d0:	1800a51e 	bne	r3,zero,81104368 <bSdmaDmaM2Transfer+0x30c>
811040d4:	100690ba 	slli	r3,r2,2
811040d8:	00a04434 	movhi	r2,33040
811040dc:	10903b04 	addi	r2,r2,16620
811040e0:	1885883a 	add	r2,r3,r2
811040e4:	10800017 	ldw	r2,0(r2)
811040e8:	1000683a 	jmp	r2
811040ec:	81104368 	cmpgeui	r4,r16,16653
811040f0:	81104110 	cmplti	r4,r16,16644
811040f4:	81104154 	ori	r4,r16,16645
811040f8:	811041a0 	cmpeqi	r4,r16,16646
811040fc:	811041ec 	andhi	r4,r16,16647
81104100:	81104238 	rdprs	r4,r16,16648
81104104:	81104284 	addi	r4,r16,16650
81104108:	811042d0 	cmplti	r4,r16,16651
8110410c:	8110431c 	xori	r4,r16,16652
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81104110:	e0bffd03 	ldbu	r2,-12(fp)
81104114:	10000326 	beq	r2,zero,81104124 <bSdmaDmaM2Transfer+0xc8>
81104118:	10800060 	cmpeqi	r2,r2,1
8110411c:	1000051e 	bne	r2,zero,81104134 <bSdmaDmaM2Transfer+0xd8>
81104120:	00000906 	br	81104148 <bSdmaDmaM2Transfer+0xec>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81104124:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81104128:	00800044 	movi	r2,1
8110412c:	e0bff715 	stw	r2,-36(fp)
			break;
81104130:	00000706 	br	81104150 <bSdmaDmaM2Transfer+0xf4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81104134:	00800074 	movhi	r2,1
81104138:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
8110413c:	00800044 	movi	r2,1
81104140:	e0bff715 	stw	r2,-36(fp)
			break;
81104144:	00000206 	br	81104150 <bSdmaDmaM2Transfer+0xf4>
		default:
			bStatus = FALSE;
81104148:	e03ff415 	stw	zero,-48(fp)
			break;
8110414c:	0001883a 	nop
		}
		break;
81104150:	00008706 	br	81104370 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81104154:	e0bffd03 	ldbu	r2,-12(fp)
81104158:	10000326 	beq	r2,zero,81104168 <bSdmaDmaM2Transfer+0x10c>
8110415c:	10800060 	cmpeqi	r2,r2,1
81104160:	1000061e 	bne	r2,zero,8110417c <bSdmaDmaM2Transfer+0x120>
81104164:	00000b06 	br	81104194 <bSdmaDmaM2Transfer+0x138>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81104168:	00880004 	movi	r2,8192
8110416c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81104170:	00800044 	movi	r2,1
81104174:	e0bff715 	stw	r2,-36(fp)
			break;
81104178:	00000806 	br	8110419c <bSdmaDmaM2Transfer+0x140>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
8110417c:	00800074 	movhi	r2,1
81104180:	10880004 	addi	r2,r2,8192
81104184:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81104188:	00800044 	movi	r2,1
8110418c:	e0bff715 	stw	r2,-36(fp)
			break;
81104190:	00000206 	br	8110419c <bSdmaDmaM2Transfer+0x140>
		default:
			bStatus = FALSE;
81104194:	e03ff415 	stw	zero,-48(fp)
			break;
81104198:	0001883a 	nop
		}
		break;
8110419c:	00007406 	br	81104370 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811041a0:	e0bffd03 	ldbu	r2,-12(fp)
811041a4:	10000326 	beq	r2,zero,811041b4 <bSdmaDmaM2Transfer+0x158>
811041a8:	10800060 	cmpeqi	r2,r2,1
811041ac:	1000061e 	bne	r2,zero,811041c8 <bSdmaDmaM2Transfer+0x16c>
811041b0:	00000b06 	br	811041e0 <bSdmaDmaM2Transfer+0x184>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
811041b4:	00900004 	movi	r2,16384
811041b8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
811041bc:	00800044 	movi	r2,1
811041c0:	e0bff715 	stw	r2,-36(fp)
			break;
811041c4:	00000806 	br	811041e8 <bSdmaDmaM2Transfer+0x18c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
811041c8:	00800074 	movhi	r2,1
811041cc:	10900004 	addi	r2,r2,16384
811041d0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
811041d4:	00800044 	movi	r2,1
811041d8:	e0bff715 	stw	r2,-36(fp)
			break;
811041dc:	00000206 	br	811041e8 <bSdmaDmaM2Transfer+0x18c>
		default:
			bStatus = FALSE;
811041e0:	e03ff415 	stw	zero,-48(fp)
			break;
811041e4:	0001883a 	nop
		}
		break;
811041e8:	00006106 	br	81104370 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
811041ec:	e0bffd03 	ldbu	r2,-12(fp)
811041f0:	10000326 	beq	r2,zero,81104200 <bSdmaDmaM2Transfer+0x1a4>
811041f4:	10800060 	cmpeqi	r2,r2,1
811041f8:	1000061e 	bne	r2,zero,81104214 <bSdmaDmaM2Transfer+0x1b8>
811041fc:	00000b06 	br	8110422c <bSdmaDmaM2Transfer+0x1d0>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81104200:	00980004 	movi	r2,24576
81104204:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104208:	00800044 	movi	r2,1
8110420c:	e0bff715 	stw	r2,-36(fp)
			break;
81104210:	00000806 	br	81104234 <bSdmaDmaM2Transfer+0x1d8>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104214:	00800074 	movhi	r2,1
81104218:	10980004 	addi	r2,r2,24576
8110421c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81104220:	00800044 	movi	r2,1
81104224:	e0bff715 	stw	r2,-36(fp)
			break;
81104228:	00000206 	br	81104234 <bSdmaDmaM2Transfer+0x1d8>
		default:
			bStatus = FALSE;
8110422c:	e03ff415 	stw	zero,-48(fp)
			break;
81104230:	0001883a 	nop
		}
		break;
81104234:	00004e06 	br	81104370 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104238:	e0bffd03 	ldbu	r2,-12(fp)
8110423c:	10000326 	beq	r2,zero,8110424c <bSdmaDmaM2Transfer+0x1f0>
81104240:	10800060 	cmpeqi	r2,r2,1
81104244:	1000061e 	bne	r2,zero,81104260 <bSdmaDmaM2Transfer+0x204>
81104248:	00000b06 	br	81104278 <bSdmaDmaM2Transfer+0x21c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
8110424c:	00a00014 	movui	r2,32768
81104250:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81104254:	00800044 	movi	r2,1
81104258:	e0bff715 	stw	r2,-36(fp)
			break;
8110425c:	00000806 	br	81104280 <bSdmaDmaM2Transfer+0x224>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104260:	008000b4 	movhi	r2,2
81104264:	10a00004 	addi	r2,r2,-32768
81104268:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
8110426c:	00800044 	movi	r2,1
81104270:	e0bff715 	stw	r2,-36(fp)
			break;
81104274:	00000206 	br	81104280 <bSdmaDmaM2Transfer+0x224>
		default:
			bStatus = FALSE;
81104278:	e03ff415 	stw	zero,-48(fp)
			break;
8110427c:	0001883a 	nop
		}
		break;
81104280:	00003b06 	br	81104370 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81104284:	e0bffd03 	ldbu	r2,-12(fp)
81104288:	10000326 	beq	r2,zero,81104298 <bSdmaDmaM2Transfer+0x23c>
8110428c:	10800060 	cmpeqi	r2,r2,1
81104290:	1000061e 	bne	r2,zero,811042ac <bSdmaDmaM2Transfer+0x250>
81104294:	00000b06 	br	811042c4 <bSdmaDmaM2Transfer+0x268>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81104298:	00a80014 	movui	r2,40960
8110429c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
811042a0:	00800044 	movi	r2,1
811042a4:	e0bff715 	stw	r2,-36(fp)
			break;
811042a8:	00000806 	br	811042cc <bSdmaDmaM2Transfer+0x270>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
811042ac:	008000b4 	movhi	r2,2
811042b0:	10a80004 	addi	r2,r2,-24576
811042b4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
811042b8:	00800044 	movi	r2,1
811042bc:	e0bff715 	stw	r2,-36(fp)
			break;
811042c0:	00000206 	br	811042cc <bSdmaDmaM2Transfer+0x270>
		default:
			bStatus = FALSE;
811042c4:	e03ff415 	stw	zero,-48(fp)
			break;
811042c8:	0001883a 	nop
		}
		break;
811042cc:	00002806 	br	81104370 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
811042d0:	e0bffd03 	ldbu	r2,-12(fp)
811042d4:	10000326 	beq	r2,zero,811042e4 <bSdmaDmaM2Transfer+0x288>
811042d8:	10800060 	cmpeqi	r2,r2,1
811042dc:	1000061e 	bne	r2,zero,811042f8 <bSdmaDmaM2Transfer+0x29c>
811042e0:	00000b06 	br	81104310 <bSdmaDmaM2Transfer+0x2b4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
811042e4:	00b00014 	movui	r2,49152
811042e8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
811042ec:	00800044 	movi	r2,1
811042f0:	e0bff715 	stw	r2,-36(fp)
			break;
811042f4:	00000806 	br	81104318 <bSdmaDmaM2Transfer+0x2bc>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
811042f8:	008000b4 	movhi	r2,2
811042fc:	10b00004 	addi	r2,r2,-16384
81104300:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104304:	00800044 	movi	r2,1
81104308:	e0bff715 	stw	r2,-36(fp)
			break;
8110430c:	00000206 	br	81104318 <bSdmaDmaM2Transfer+0x2bc>
		default:
			bStatus = FALSE;
81104310:	e03ff415 	stw	zero,-48(fp)
			break;
81104314:	0001883a 	nop
		}
		break;
81104318:	00001506 	br	81104370 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110431c:	e0bffd03 	ldbu	r2,-12(fp)
81104320:	10000326 	beq	r2,zero,81104330 <bSdmaDmaM2Transfer+0x2d4>
81104324:	10800060 	cmpeqi	r2,r2,1
81104328:	1000061e 	bne	r2,zero,81104344 <bSdmaDmaM2Transfer+0x2e8>
8110432c:	00000b06 	br	8110435c <bSdmaDmaM2Transfer+0x300>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81104330:	00b80014 	movui	r2,57344
81104334:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104338:	00800044 	movi	r2,1
8110433c:	e0bff715 	stw	r2,-36(fp)
			break;
81104340:	00000806 	br	81104364 <bSdmaDmaM2Transfer+0x308>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104344:	008000b4 	movhi	r2,2
81104348:	10b80004 	addi	r2,r2,-8192
8110434c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81104350:	00800044 	movi	r2,1
81104354:	e0bff715 	stw	r2,-36(fp)
			break;
81104358:	00000206 	br	81104364 <bSdmaDmaM2Transfer+0x308>
		default:
			bStatus = FALSE;
8110435c:	e03ff415 	stw	zero,-48(fp)
			break;
81104360:	0001883a 	nop
		}
		break;
81104364:	00000206 	br	81104370 <bSdmaDmaM2Transfer+0x314>
	default:
		bStatus = FALSE;
81104368:	e03ff415 	stw	zero,-48(fp)
		break;
8110436c:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
81104370:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
81104374:	00a00034 	movhi	r2,32768
81104378:	1885883a 	add	r2,r3,r2
8110437c:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104380:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
81104384:	e0bff417 	ldw	r2,-48(fp)
81104388:	10003b26 	beq	r2,zero,81104478 <bSdmaDmaM2Transfer+0x41c>
		if (pxDmaM2Dev == NULL) {
8110438c:	d0a03917 	ldw	r2,-32540(gp)
81104390:	1000021e 	bne	r2,zero,8110439c <bSdmaDmaM2Transfer+0x340>
			bStatus = FALSE;
81104394:	e03ff415 	stw	zero,-48(fp)
81104398:	00003706 	br	81104478 <bSdmaDmaM2Transfer+0x41c>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
8110439c:	e03ff50d 	sth	zero,-44(fp)
811043a0:	00003206 	br	8110446c <bSdmaDmaM2Transfer+0x410>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
811043a4:	01000044 	movi	r4,1
811043a8:	1127d1c0 	call	81127d1c <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
811043ac:	d0a03917 	ldw	r2,-32540(gp)
811043b0:	10800317 	ldw	r2,12(r2)
811043b4:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811043b8:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
811043bc:	103ff91e 	bne	r2,zero,811043a4 <__reset+0xfb0e43a4>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811043c0:	d2203917 	ldw	r8,-32540(gp)
811043c4:	e17ff817 	ldw	r5,-32(fp)
811043c8:	e1bff617 	ldw	r6,-40(fp)
811043cc:	e0bff917 	ldw	r2,-28(fp)
811043d0:	e0fff717 	ldw	r3,-36(fp)
811043d4:	01000044 	movi	r4,1
811043d8:	d9000815 	stw	r4,32(sp)
811043dc:	01000044 	movi	r4,1
811043e0:	d9000715 	stw	r4,28(sp)
811043e4:	01000044 	movi	r4,1
811043e8:	d9000615 	stw	r4,24(sp)
811043ec:	01000044 	movi	r4,1
811043f0:	d9000515 	stw	r4,20(sp)
811043f4:	01000044 	movi	r4,1
811043f8:	d9000415 	stw	r4,16(sp)
811043fc:	d8c00315 	stw	r3,12(sp)
81104400:	d8800215 	stw	r2,8(sp)
81104404:	e0bffa17 	ldw	r2,-24(fp)
81104408:	d8800115 	stw	r2,4(sp)
8110440c:	00802204 	movi	r2,136
81104410:	d8800015 	stw	r2,0(sp)
81104414:	300f883a 	mov	r7,r6
81104418:	280d883a 	mov	r6,r5
8110441c:	800b883a 	mov	r5,r16
81104420:	4009883a 	mov	r4,r8
81104424:	1106b800 	call	81106b80 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104428:	10000226 	beq	r2,zero,81104434 <bSdmaDmaM2Transfer+0x3d8>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
8110442c:	e03ff415 	stw	zero,-48(fp)
					break;
81104430:	00001106 	br	81104478 <bSdmaDmaM2Transfer+0x41c>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81104434:	d0a03917 	ldw	r2,-32540(gp)
81104438:	800b883a 	mov	r5,r16
8110443c:	1009883a 	mov	r4,r2
81104440:	1106c840 	call	81106c84 <iMsgdmaExtendedDescriptorSyncTransfer>
81104444:	10000226 	beq	r2,zero,81104450 <bSdmaDmaM2Transfer+0x3f4>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104448:	e03ff415 	stw	zero,-48(fp)
						break;
8110444c:	00000a06 	br	81104478 <bSdmaDmaM2Transfer+0x41c>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
81104450:	e0bff817 	ldw	r2,-32(fp)
81104454:	10802204 	addi	r2,r2,136
81104458:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
8110445c:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104460:	e0bff50b 	ldhu	r2,-44(fp)
81104464:	10800044 	addi	r2,r2,1
81104468:	e0bff50d 	sth	r2,-44(fp)
8110446c:	e0fff50b 	ldhu	r3,-44(fp)
81104470:	e0bffc0b 	ldhu	r2,-16(fp)
81104474:	18bfcd36 	bltu	r3,r2,811043ac <__reset+0xfb0e43ac>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104478:	e0bff417 	ldw	r2,-48(fp)
}
8110447c:	e6ffff04 	addi	sp,fp,-4
81104480:	dfc00217 	ldw	ra,8(sp)
81104484:	df000117 	ldw	fp,4(sp)
81104488:	dc000017 	ldw	r16,0(sp)
8110448c:	dec00304 	addi	sp,sp,12
81104490:	f800283a 	ret

81104494 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81104494:	defffc04 	addi	sp,sp,-16
81104498:	de00012e 	bgeu	sp,et,811044a0 <vFeebCh1HandleIrq+0xc>
8110449c:	003b68fa 	trap	3
811044a0:	dfc00315 	stw	ra,12(sp)
811044a4:	df000215 	stw	fp,8(sp)
811044a8:	df000204 	addi	fp,sp,8
811044ac:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811044b0:	e0bfff17 	ldw	r2,-4(fp)
811044b4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh1IrqFlagClrBufferEmpty();
811044b8:	11046940 	call	81104694 <vFeebCh1IrqFlagClrBufferEmpty>
}
811044bc:	0001883a 	nop
811044c0:	e037883a 	mov	sp,fp
811044c4:	dfc00117 	ldw	ra,4(sp)
811044c8:	df000017 	ldw	fp,0(sp)
811044cc:	dec00204 	addi	sp,sp,8
811044d0:	f800283a 	ret

811044d4 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
811044d4:	defffc04 	addi	sp,sp,-16
811044d8:	de00012e 	bgeu	sp,et,811044e0 <vFeebCh2HandleIrq+0xc>
811044dc:	003b68fa 	trap	3
811044e0:	dfc00315 	stw	ra,12(sp)
811044e4:	df000215 	stw	fp,8(sp)
811044e8:	df000204 	addi	fp,sp,8
811044ec:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811044f0:	e0bfff17 	ldw	r2,-4(fp)
811044f4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh2IrqFlagClrBufferEmpty();
811044f8:	11046d80 	call	811046d8 <vFeebCh2IrqFlagClrBufferEmpty>
}
811044fc:	0001883a 	nop
81104500:	e037883a 	mov	sp,fp
81104504:	dfc00117 	ldw	ra,4(sp)
81104508:	df000017 	ldw	fp,0(sp)
8110450c:	dec00204 	addi	sp,sp,8
81104510:	f800283a 	ret

81104514 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81104514:	defffc04 	addi	sp,sp,-16
81104518:	de00012e 	bgeu	sp,et,81104520 <vFeebCh3HandleIrq+0xc>
8110451c:	003b68fa 	trap	3
81104520:	dfc00315 	stw	ra,12(sp)
81104524:	df000215 	stw	fp,8(sp)
81104528:	df000204 	addi	fp,sp,8
8110452c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104530:	e0bfff17 	ldw	r2,-4(fp)
81104534:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh3IrqFlagClrBufferEmpty();
81104538:	110471c0 	call	8110471c <vFeebCh3IrqFlagClrBufferEmpty>
}
8110453c:	0001883a 	nop
81104540:	e037883a 	mov	sp,fp
81104544:	dfc00117 	ldw	ra,4(sp)
81104548:	df000017 	ldw	fp,0(sp)
8110454c:	dec00204 	addi	sp,sp,8
81104550:	f800283a 	ret

81104554 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81104554:	defffc04 	addi	sp,sp,-16
81104558:	de00012e 	bgeu	sp,et,81104560 <vFeebCh4HandleIrq+0xc>
8110455c:	003b68fa 	trap	3
81104560:	dfc00315 	stw	ra,12(sp)
81104564:	df000215 	stw	fp,8(sp)
81104568:	df000204 	addi	fp,sp,8
8110456c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104570:	e0bfff17 	ldw	r2,-4(fp)
81104574:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh4IrqFlagClrBufferEmpty();
81104578:	11047600 	call	81104760 <vFeebCh4IrqFlagClrBufferEmpty>
}
8110457c:	0001883a 	nop
81104580:	e037883a 	mov	sp,fp
81104584:	dfc00117 	ldw	ra,4(sp)
81104588:	df000017 	ldw	fp,0(sp)
8110458c:	dec00204 	addi	sp,sp,8
81104590:	f800283a 	ret

81104594 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81104594:	defffc04 	addi	sp,sp,-16
81104598:	de00012e 	bgeu	sp,et,811045a0 <vFeebCh5HandleIrq+0xc>
8110459c:	003b68fa 	trap	3
811045a0:	dfc00315 	stw	ra,12(sp)
811045a4:	df000215 	stw	fp,8(sp)
811045a8:	df000204 	addi	fp,sp,8
811045ac:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811045b0:	e0bfff17 	ldw	r2,-4(fp)
811045b4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh5IrqFlagClrBufferEmpty();
811045b8:	11047a40 	call	811047a4 <vFeebCh5IrqFlagClrBufferEmpty>
}
811045bc:	0001883a 	nop
811045c0:	e037883a 	mov	sp,fp
811045c4:	dfc00117 	ldw	ra,4(sp)
811045c8:	df000017 	ldw	fp,0(sp)
811045cc:	dec00204 	addi	sp,sp,8
811045d0:	f800283a 	ret

811045d4 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
811045d4:	defffc04 	addi	sp,sp,-16
811045d8:	de00012e 	bgeu	sp,et,811045e0 <vFeebCh6HandleIrq+0xc>
811045dc:	003b68fa 	trap	3
811045e0:	dfc00315 	stw	ra,12(sp)
811045e4:	df000215 	stw	fp,8(sp)
811045e8:	df000204 	addi	fp,sp,8
811045ec:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811045f0:	e0bfff17 	ldw	r2,-4(fp)
811045f4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vFeebCh6IrqFlagClrBufferEmpty();
811045f8:	11047e80 	call	811047e8 <vFeebCh6IrqFlagClrBufferEmpty>
}
811045fc:	0001883a 	nop
81104600:	e037883a 	mov	sp,fp
81104604:	dfc00117 	ldw	ra,4(sp)
81104608:	df000017 	ldw	fp,0(sp)
8110460c:	dec00204 	addi	sp,sp,8
81104610:	f800283a 	ret

81104614 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
81104614:	defffc04 	addi	sp,sp,-16
81104618:	de00012e 	bgeu	sp,et,81104620 <vFeebCh7HandleIrq+0xc>
8110461c:	003b68fa 	trap	3
81104620:	dfc00315 	stw	ra,12(sp)
81104624:	df000215 	stw	fp,8(sp)
81104628:	df000204 	addi	fp,sp,8
8110462c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104630:	e0bfff17 	ldw	r2,-4(fp)
81104634:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh7IrqFlagClrBufferEmpty();
81104638:	110482c0 	call	8110482c <vFeebCh7IrqFlagClrBufferEmpty>
}
8110463c:	0001883a 	nop
81104640:	e037883a 	mov	sp,fp
81104644:	dfc00117 	ldw	ra,4(sp)
81104648:	df000017 	ldw	fp,0(sp)
8110464c:	dec00204 	addi	sp,sp,8
81104650:	f800283a 	ret

81104654 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81104654:	defffc04 	addi	sp,sp,-16
81104658:	de00012e 	bgeu	sp,et,81104660 <vFeebCh8HandleIrq+0xc>
8110465c:	003b68fa 	trap	3
81104660:	dfc00315 	stw	ra,12(sp)
81104664:	df000215 	stw	fp,8(sp)
81104668:	df000204 	addi	fp,sp,8
8110466c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104670:	e0bfff17 	ldw	r2,-4(fp)
81104674:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh8IrqFlagClrBufferEmpty();
81104678:	11048700 	call	81104870 <vFeebCh8IrqFlagClrBufferEmpty>
}
8110467c:	0001883a 	nop
81104680:	e037883a 	mov	sp,fp
81104684:	dfc00117 	ldw	ra,4(sp)
81104688:	df000017 	ldw	fp,0(sp)
8110468c:	dec00204 	addi	sp,sp,8
81104690:	f800283a 	ret

81104694 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81104694:	defffe04 	addi	sp,sp,-8
81104698:	de00012e 	bgeu	sp,et,811046a0 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
8110469c:	003b68fa 	trap	3
811046a0:	dfc00115 	stw	ra,4(sp)
811046a4:	df000015 	stw	fp,0(sp)
811046a8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811046ac:	01800044 	movi	r6,1
811046b0:	01400144 	movi	r5,5
811046b4:	01204834 	movhi	r4,33056
811046b8:	210b0004 	addi	r4,r4,11264
811046bc:	11050d80 	call	811050d8 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
811046c0:	0001883a 	nop
811046c4:	e037883a 	mov	sp,fp
811046c8:	dfc00117 	ldw	ra,4(sp)
811046cc:	df000017 	ldw	fp,0(sp)
811046d0:	dec00204 	addi	sp,sp,8
811046d4:	f800283a 	ret

811046d8 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
811046d8:	defffe04 	addi	sp,sp,-8
811046dc:	de00012e 	bgeu	sp,et,811046e4 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
811046e0:	003b68fa 	trap	3
811046e4:	dfc00115 	stw	ra,4(sp)
811046e8:	df000015 	stw	fp,0(sp)
811046ec:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811046f0:	01800044 	movi	r6,1
811046f4:	01400144 	movi	r5,5
811046f8:	01204834 	movhi	r4,33056
811046fc:	210a0004 	addi	r4,r4,10240
81104700:	11050d80 	call	811050d8 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104704:	0001883a 	nop
81104708:	e037883a 	mov	sp,fp
8110470c:	dfc00117 	ldw	ra,4(sp)
81104710:	df000017 	ldw	fp,0(sp)
81104714:	dec00204 	addi	sp,sp,8
81104718:	f800283a 	ret

8110471c <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
8110471c:	defffe04 	addi	sp,sp,-8
81104720:	de00012e 	bgeu	sp,et,81104728 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
81104724:	003b68fa 	trap	3
81104728:	dfc00115 	stw	ra,4(sp)
8110472c:	df000015 	stw	fp,0(sp)
81104730:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81104734:	01800044 	movi	r6,1
81104738:	01400144 	movi	r5,5
8110473c:	01204834 	movhi	r4,33056
81104740:	21090004 	addi	r4,r4,9216
81104744:	11050d80 	call	811050d8 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104748:	0001883a 	nop
8110474c:	e037883a 	mov	sp,fp
81104750:	dfc00117 	ldw	ra,4(sp)
81104754:	df000017 	ldw	fp,0(sp)
81104758:	dec00204 	addi	sp,sp,8
8110475c:	f800283a 	ret

81104760 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
81104760:	defffe04 	addi	sp,sp,-8
81104764:	de00012e 	bgeu	sp,et,8110476c <vFeebCh4IrqFlagClrBufferEmpty+0xc>
81104768:	003b68fa 	trap	3
8110476c:	dfc00115 	stw	ra,4(sp)
81104770:	df000015 	stw	fp,0(sp)
81104774:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81104778:	01800044 	movi	r6,1
8110477c:	01400144 	movi	r5,5
81104780:	01204834 	movhi	r4,33056
81104784:	21080004 	addi	r4,r4,8192
81104788:	11050d80 	call	811050d8 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
8110478c:	0001883a 	nop
81104790:	e037883a 	mov	sp,fp
81104794:	dfc00117 	ldw	ra,4(sp)
81104798:	df000017 	ldw	fp,0(sp)
8110479c:	dec00204 	addi	sp,sp,8
811047a0:	f800283a 	ret

811047a4 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
811047a4:	defffe04 	addi	sp,sp,-8
811047a8:	de00012e 	bgeu	sp,et,811047b0 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
811047ac:	003b68fa 	trap	3
811047b0:	dfc00115 	stw	ra,4(sp)
811047b4:	df000015 	stw	fp,0(sp)
811047b8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811047bc:	01800044 	movi	r6,1
811047c0:	01400144 	movi	r5,5
811047c4:	01204834 	movhi	r4,33056
811047c8:	21070004 	addi	r4,r4,7168
811047cc:	11050d80 	call	811050d8 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
811047d0:	0001883a 	nop
811047d4:	e037883a 	mov	sp,fp
811047d8:	dfc00117 	ldw	ra,4(sp)
811047dc:	df000017 	ldw	fp,0(sp)
811047e0:	dec00204 	addi	sp,sp,8
811047e4:	f800283a 	ret

811047e8 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
811047e8:	defffe04 	addi	sp,sp,-8
811047ec:	de00012e 	bgeu	sp,et,811047f4 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
811047f0:	003b68fa 	trap	3
811047f4:	dfc00115 	stw	ra,4(sp)
811047f8:	df000015 	stw	fp,0(sp)
811047fc:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81104800:	01800044 	movi	r6,1
81104804:	01400144 	movi	r5,5
81104808:	01204834 	movhi	r4,33056
8110480c:	21060004 	addi	r4,r4,6144
81104810:	11050d80 	call	811050d8 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104814:	0001883a 	nop
81104818:	e037883a 	mov	sp,fp
8110481c:	dfc00117 	ldw	ra,4(sp)
81104820:	df000017 	ldw	fp,0(sp)
81104824:	dec00204 	addi	sp,sp,8
81104828:	f800283a 	ret

8110482c <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
8110482c:	defffe04 	addi	sp,sp,-8
81104830:	de00012e 	bgeu	sp,et,81104838 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
81104834:	003b68fa 	trap	3
81104838:	dfc00115 	stw	ra,4(sp)
8110483c:	df000015 	stw	fp,0(sp)
81104840:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81104844:	01800044 	movi	r6,1
81104848:	01400144 	movi	r5,5
8110484c:	01204834 	movhi	r4,33056
81104850:	21050004 	addi	r4,r4,5120
81104854:	11050d80 	call	811050d8 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104858:	0001883a 	nop
8110485c:	e037883a 	mov	sp,fp
81104860:	dfc00117 	ldw	ra,4(sp)
81104864:	df000017 	ldw	fp,0(sp)
81104868:	dec00204 	addi	sp,sp,8
8110486c:	f800283a 	ret

81104870 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
81104870:	defffe04 	addi	sp,sp,-8
81104874:	de00012e 	bgeu	sp,et,8110487c <vFeebCh8IrqFlagClrBufferEmpty+0xc>
81104878:	003b68fa 	trap	3
8110487c:	dfc00115 	stw	ra,4(sp)
81104880:	df000015 	stw	fp,0(sp)
81104884:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81104888:	01800044 	movi	r6,1
8110488c:	01400144 	movi	r5,5
81104890:	01204834 	movhi	r4,33056
81104894:	21040004 	addi	r4,r4,4096
81104898:	11050d80 	call	811050d8 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
8110489c:	0001883a 	nop
811048a0:	e037883a 	mov	sp,fp
811048a4:	dfc00117 	ldw	ra,4(sp)
811048a8:	df000017 	ldw	fp,0(sp)
811048ac:	dec00204 	addi	sp,sp,8
811048b0:	f800283a 	ret

811048b4 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
811048b4:	defffd04 	addi	sp,sp,-12
811048b8:	de00012e 	bgeu	sp,et,811048c0 <bFeebCh1IrqFlagBufferEmpty+0xc>
811048bc:	003b68fa 	trap	3
811048c0:	dfc00215 	stw	ra,8(sp)
811048c4:	df000115 	stw	fp,4(sp)
811048c8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811048cc:	01400144 	movi	r5,5
811048d0:	01204834 	movhi	r4,33056
811048d4:	210b0004 	addi	r4,r4,11264
811048d8:	110512c0 	call	8110512c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
811048dc:	1080004c 	andi	r2,r2,1
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811048e0:	10000326 	beq	r2,zero,811048f0 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
811048e4:	00800044 	movi	r2,1
811048e8:	e0bfff15 	stw	r2,-4(fp)
811048ec:	00000106 	br	811048f4 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811048f0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811048f4:	e0bfff17 	ldw	r2,-4(fp)
}
811048f8:	e037883a 	mov	sp,fp
811048fc:	dfc00117 	ldw	ra,4(sp)
81104900:	df000017 	ldw	fp,0(sp)
81104904:	dec00204 	addi	sp,sp,8
81104908:	f800283a 	ret

8110490c <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
8110490c:	defffd04 	addi	sp,sp,-12
81104910:	de00012e 	bgeu	sp,et,81104918 <bFeebCh2IrqFlagBufferEmpty+0xc>
81104914:	003b68fa 	trap	3
81104918:	dfc00215 	stw	ra,8(sp)
8110491c:	df000115 	stw	fp,4(sp)
81104920:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81104924:	01400144 	movi	r5,5
81104928:	01204834 	movhi	r4,33056
8110492c:	210a0004 	addi	r4,r4,10240
81104930:	110512c0 	call	8110512c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104934:	1080004c 	andi	r2,r2,1
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81104938:	10000326 	beq	r2,zero,81104948 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
8110493c:	00800044 	movi	r2,1
81104940:	e0bfff15 	stw	r2,-4(fp)
81104944:	00000106 	br	8110494c <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104948:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110494c:	e0bfff17 	ldw	r2,-4(fp)
}
81104950:	e037883a 	mov	sp,fp
81104954:	dfc00117 	ldw	ra,4(sp)
81104958:	df000017 	ldw	fp,0(sp)
8110495c:	dec00204 	addi	sp,sp,8
81104960:	f800283a 	ret

81104964 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81104964:	defffd04 	addi	sp,sp,-12
81104968:	de00012e 	bgeu	sp,et,81104970 <bFeebCh3IrqFlagBufferEmpty+0xc>
8110496c:	003b68fa 	trap	3
81104970:	dfc00215 	stw	ra,8(sp)
81104974:	df000115 	stw	fp,4(sp)
81104978:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110497c:	01400144 	movi	r5,5
81104980:	01204834 	movhi	r4,33056
81104984:	21090004 	addi	r4,r4,9216
81104988:	110512c0 	call	8110512c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
8110498c:	1080004c 	andi	r2,r2,1
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81104990:	10000326 	beq	r2,zero,811049a0 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104994:	00800044 	movi	r2,1
81104998:	e0bfff15 	stw	r2,-4(fp)
8110499c:	00000106 	br	811049a4 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811049a0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811049a4:	e0bfff17 	ldw	r2,-4(fp)
}
811049a8:	e037883a 	mov	sp,fp
811049ac:	dfc00117 	ldw	ra,4(sp)
811049b0:	df000017 	ldw	fp,0(sp)
811049b4:	dec00204 	addi	sp,sp,8
811049b8:	f800283a 	ret

811049bc <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
811049bc:	defffd04 	addi	sp,sp,-12
811049c0:	de00012e 	bgeu	sp,et,811049c8 <bFeebCh4IrqFlagBufferEmpty+0xc>
811049c4:	003b68fa 	trap	3
811049c8:	dfc00215 	stw	ra,8(sp)
811049cc:	df000115 	stw	fp,4(sp)
811049d0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811049d4:	01400144 	movi	r5,5
811049d8:	01204834 	movhi	r4,33056
811049dc:	21080004 	addi	r4,r4,8192
811049e0:	110512c0 	call	8110512c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
811049e4:	1080004c 	andi	r2,r2,1
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811049e8:	10000326 	beq	r2,zero,811049f8 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
811049ec:	00800044 	movi	r2,1
811049f0:	e0bfff15 	stw	r2,-4(fp)
811049f4:	00000106 	br	811049fc <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811049f8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811049fc:	e0bfff17 	ldw	r2,-4(fp)
}
81104a00:	e037883a 	mov	sp,fp
81104a04:	dfc00117 	ldw	ra,4(sp)
81104a08:	df000017 	ldw	fp,0(sp)
81104a0c:	dec00204 	addi	sp,sp,8
81104a10:	f800283a 	ret

81104a14 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
81104a14:	defffd04 	addi	sp,sp,-12
81104a18:	de00012e 	bgeu	sp,et,81104a20 <bFeebCh5IrqFlagBufferEmpty+0xc>
81104a1c:	003b68fa 	trap	3
81104a20:	dfc00215 	stw	ra,8(sp)
81104a24:	df000115 	stw	fp,4(sp)
81104a28:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81104a2c:	01400144 	movi	r5,5
81104a30:	01204834 	movhi	r4,33056
81104a34:	21070004 	addi	r4,r4,7168
81104a38:	110512c0 	call	8110512c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104a3c:	1080004c 	andi	r2,r2,1
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81104a40:	10000326 	beq	r2,zero,81104a50 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104a44:	00800044 	movi	r2,1
81104a48:	e0bfff15 	stw	r2,-4(fp)
81104a4c:	00000106 	br	81104a54 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104a50:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104a54:	e0bfff17 	ldw	r2,-4(fp)
}
81104a58:	e037883a 	mov	sp,fp
81104a5c:	dfc00117 	ldw	ra,4(sp)
81104a60:	df000017 	ldw	fp,0(sp)
81104a64:	dec00204 	addi	sp,sp,8
81104a68:	f800283a 	ret

81104a6c <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81104a6c:	defffd04 	addi	sp,sp,-12
81104a70:	de00012e 	bgeu	sp,et,81104a78 <bFeebCh6IrqFlagBufferEmpty+0xc>
81104a74:	003b68fa 	trap	3
81104a78:	dfc00215 	stw	ra,8(sp)
81104a7c:	df000115 	stw	fp,4(sp)
81104a80:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81104a84:	01400144 	movi	r5,5
81104a88:	01204834 	movhi	r4,33056
81104a8c:	21060004 	addi	r4,r4,6144
81104a90:	110512c0 	call	8110512c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104a94:	1080004c 	andi	r2,r2,1
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81104a98:	10000326 	beq	r2,zero,81104aa8 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104a9c:	00800044 	movi	r2,1
81104aa0:	e0bfff15 	stw	r2,-4(fp)
81104aa4:	00000106 	br	81104aac <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104aa8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104aac:	e0bfff17 	ldw	r2,-4(fp)
}
81104ab0:	e037883a 	mov	sp,fp
81104ab4:	dfc00117 	ldw	ra,4(sp)
81104ab8:	df000017 	ldw	fp,0(sp)
81104abc:	dec00204 	addi	sp,sp,8
81104ac0:	f800283a 	ret

81104ac4 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81104ac4:	defffd04 	addi	sp,sp,-12
81104ac8:	de00012e 	bgeu	sp,et,81104ad0 <bFeebCh7IrqFlagBufferEmpty+0xc>
81104acc:	003b68fa 	trap	3
81104ad0:	dfc00215 	stw	ra,8(sp)
81104ad4:	df000115 	stw	fp,4(sp)
81104ad8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81104adc:	01400144 	movi	r5,5
81104ae0:	01204834 	movhi	r4,33056
81104ae4:	21050004 	addi	r4,r4,5120
81104ae8:	110512c0 	call	8110512c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104aec:	1080004c 	andi	r2,r2,1
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81104af0:	10000326 	beq	r2,zero,81104b00 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104af4:	00800044 	movi	r2,1
81104af8:	e0bfff15 	stw	r2,-4(fp)
81104afc:	00000106 	br	81104b04 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104b00:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104b04:	e0bfff17 	ldw	r2,-4(fp)
}
81104b08:	e037883a 	mov	sp,fp
81104b0c:	dfc00117 	ldw	ra,4(sp)
81104b10:	df000017 	ldw	fp,0(sp)
81104b14:	dec00204 	addi	sp,sp,8
81104b18:	f800283a 	ret

81104b1c <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81104b1c:	defffd04 	addi	sp,sp,-12
81104b20:	de00012e 	bgeu	sp,et,81104b28 <bFeebCh8IrqFlagBufferEmpty+0xc>
81104b24:	003b68fa 	trap	3
81104b28:	dfc00215 	stw	ra,8(sp)
81104b2c:	df000115 	stw	fp,4(sp)
81104b30:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81104b34:	01400144 	movi	r5,5
81104b38:	01204834 	movhi	r4,33056
81104b3c:	21040004 	addi	r4,r4,4096
81104b40:	110512c0 	call	8110512c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104b44:	1080004c 	andi	r2,r2,1
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81104b48:	10000326 	beq	r2,zero,81104b58 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104b4c:	00800044 	movi	r2,1
81104b50:	e0bfff15 	stw	r2,-4(fp)
81104b54:	00000106 	br	81104b5c <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104b58:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104b5c:	e0bfff17 	ldw	r2,-4(fp)
}
81104b60:	e037883a 	mov	sp,fp
81104b64:	dfc00117 	ldw	ra,4(sp)
81104b68:	df000017 	ldw	fp,0(sp)
81104b6c:	dec00204 	addi	sp,sp,8
81104b70:	f800283a 	ret

81104b74 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81104b74:	defffc04 	addi	sp,sp,-16
81104b78:	de00012e 	bgeu	sp,et,81104b80 <vFeebInitIrq+0xc>
81104b7c:	003b68fa 	trap	3
81104b80:	dfc00315 	stw	ra,12(sp)
81104b84:	df000215 	stw	fp,8(sp)
81104b88:	df000204 	addi	fp,sp,8
81104b8c:	2005883a 	mov	r2,r4
81104b90:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81104b94:	e0bfff03 	ldbu	r2,-4(fp)
81104b98:	10c00268 	cmpgeui	r3,r2,9
81104b9c:	18004f1e 	bne	r3,zero,81104cdc <vFeebInitIrq+0x168>
81104ba0:	100690ba 	slli	r3,r2,2
81104ba4:	00a04434 	movhi	r2,33040
81104ba8:	1092ee04 	addi	r2,r2,19384
81104bac:	1885883a 	add	r2,r3,r2
81104bb0:	10800017 	ldw	r2,0(r2)
81104bb4:	1000683a 	jmp	r2
81104bb8:	81104cdc 	xori	r4,r16,16691
81104bbc:	81104bdc 	xori	r4,r16,16687
81104bc0:	81104bfc 	xorhi	r4,r16,16687
81104bc4:	81104c1c 	xori	r4,r16,16688
81104bc8:	81104c3c 	xorhi	r4,r16,16688
81104bcc:	81104c5c 	xori	r4,r16,16689
81104bd0:	81104c7c 	xorhi	r4,r16,16689
81104bd4:	81104c9c 	xori	r4,r16,16690
81104bd8:	81104cbc 	xorhi	r4,r16,16690
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81104bdc:	d0a03d04 	addi	r2,gp,-32524
81104be0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_A_IRQ, pvHoldContext,
81104be4:	01a04434 	movhi	r6,33040
81104be8:	31912504 	addi	r6,r6,17556
81104bec:	e17ffe17 	ldw	r5,-8(fp)
81104bf0:	01000084 	movi	r4,2
81104bf4:	11280c00 	call	811280c0 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81104bf8:	00003806 	br	81104cdc <vFeebInitIrq+0x168>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81104bfc:	d0a03e04 	addi	r2,gp,-32520
81104c00:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_B_IRQ, pvHoldContext,
81104c04:	01a04434 	movhi	r6,33040
81104c08:	31913504 	addi	r6,r6,17620
81104c0c:	e17ffe17 	ldw	r5,-8(fp)
81104c10:	010000c4 	movi	r4,3
81104c14:	11280c00 	call	811280c0 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
81104c18:	00003006 	br	81104cdc <vFeebInitIrq+0x168>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81104c1c:	d0a03f04 	addi	r2,gp,-32516
81104c20:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_C_IRQ, pvHoldContext,
81104c24:	01a04434 	movhi	r6,33040
81104c28:	31914504 	addi	r6,r6,17684
81104c2c:	e17ffe17 	ldw	r5,-8(fp)
81104c30:	01000104 	movi	r4,4
81104c34:	11280c00 	call	811280c0 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81104c38:	00002806 	br	81104cdc <vFeebInitIrq+0x168>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81104c3c:	d0a04004 	addi	r2,gp,-32512
81104c40:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_D_IRQ, pvHoldContext,
81104c44:	01a04434 	movhi	r6,33040
81104c48:	31915504 	addi	r6,r6,17748
81104c4c:	e17ffe17 	ldw	r5,-8(fp)
81104c50:	01000204 	movi	r4,8
81104c54:	11280c00 	call	811280c0 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
81104c58:	00002006 	br	81104cdc <vFeebInitIrq+0x168>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81104c5c:	d0a04104 	addi	r2,gp,-32508
81104c60:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_E_IRQ, pvHoldContext,
81104c64:	01a04434 	movhi	r6,33040
81104c68:	31916504 	addi	r6,r6,17812
81104c6c:	e17ffe17 	ldw	r5,-8(fp)
81104c70:	010001c4 	movi	r4,7
81104c74:	11280c00 	call	811280c0 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81104c78:	00001806 	br	81104cdc <vFeebInitIrq+0x168>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81104c7c:	d0a04204 	addi	r2,gp,-32504
81104c80:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_F_IRQ, pvHoldContext,
81104c84:	01a04434 	movhi	r6,33040
81104c88:	31917504 	addi	r6,r6,17876
81104c8c:	e17ffe17 	ldw	r5,-8(fp)
81104c90:	01000184 	movi	r4,6
81104c94:	11280c00 	call	811280c0 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81104c98:	00001006 	br	81104cdc <vFeebInitIrq+0x168>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81104c9c:	d0a04304 	addi	r2,gp,-32500
81104ca0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_G_IRQ, pvHoldContext,
81104ca4:	01a04434 	movhi	r6,33040
81104ca8:	31918504 	addi	r6,r6,17940
81104cac:	e17ffe17 	ldw	r5,-8(fp)
81104cb0:	01000144 	movi	r4,5
81104cb4:	11280c00 	call	811280c0 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81104cb8:	00000806 	br	81104cdc <vFeebInitIrq+0x168>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81104cbc:	d0a04404 	addi	r2,gp,-32496
81104cc0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_H_IRQ, pvHoldContext,
81104cc4:	01a04434 	movhi	r6,33040
81104cc8:	31919504 	addi	r6,r6,18004
81104ccc:	e17ffe17 	ldw	r5,-8(fp)
81104cd0:	01000244 	movi	r4,9
81104cd4:	11280c00 	call	811280c0 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
81104cd8:	0001883a 	nop
	}
}
81104cdc:	0001883a 	nop
81104ce0:	e037883a 	mov	sp,fp
81104ce4:	dfc00117 	ldw	ra,4(sp)
81104ce8:	df000017 	ldw	fp,0(sp)
81104cec:	dec00204 	addi	sp,sp,8
81104cf0:	f800283a 	ret

81104cf4 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
81104cf4:	defffb04 	addi	sp,sp,-20
81104cf8:	de00012e 	bgeu	sp,et,81104d00 <bFeebSetIrqControl+0xc>
81104cfc:	003b68fa 	trap	3
81104d00:	dfc00415 	stw	ra,16(sp)
81104d04:	df000315 	stw	fp,12(sp)
81104d08:	df000304 	addi	fp,sp,12
81104d0c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d10:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104d14:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104d18:	e0bfff17 	ldw	r2,-4(fp)
81104d1c:	10002426 	beq	r2,zero,81104db0 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104d20:	e0bfff17 	ldw	r2,-4(fp)
81104d24:	10800017 	ldw	r2,0(r2)
81104d28:	01400104 	movi	r5,4
81104d2c:	1009883a 	mov	r4,r2
81104d30:	110512c0 	call	8110512c <uliFeebReadReg>
81104d34:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CTRL_REG_OFFSET);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81104d38:	e0bfff17 	ldw	r2,-4(fp)
81104d3c:	10800217 	ldw	r2,8(r2)
81104d40:	10000426 	beq	r2,zero,81104d54 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_L_BUFFER_EMPTY_EN_MSK;
81104d44:	e0bffe17 	ldw	r2,-8(fp)
81104d48:	10804014 	ori	r2,r2,256
81104d4c:	e0bffe15 	stw	r2,-8(fp)
81104d50:	00000406 	br	81104d64 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_L_BUFFER_EMPTY_EN_MSK);
81104d54:	e0fffe17 	ldw	r3,-8(fp)
81104d58:	00bfbfc4 	movi	r2,-257
81104d5c:	1884703a 	and	r2,r3,r2
81104d60:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81104d64:	e0bfff17 	ldw	r2,-4(fp)
81104d68:	10800317 	ldw	r2,12(r2)
81104d6c:	10000426 	beq	r2,zero,81104d80 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_R_BUFFER_EMPTY_EN_MSK;
81104d70:	e0bffe17 	ldw	r2,-8(fp)
81104d74:	10800054 	ori	r2,r2,1
81104d78:	e0bffe15 	stw	r2,-8(fp)
81104d7c:	00000406 	br	81104d90 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_R_BUFFER_EMPTY_EN_MSK);
81104d80:	e0fffe17 	ldw	r3,-8(fp)
81104d84:	00bfff84 	movi	r2,-2
81104d88:	1884703a 	and	r2,r3,r2
81104d8c:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CTRL_REG_OFFSET,
81104d90:	e0bfff17 	ldw	r2,-4(fp)
81104d94:	10800017 	ldw	r2,0(r2)
81104d98:	e1bffe17 	ldw	r6,-8(fp)
81104d9c:	01400104 	movi	r5,4
81104da0:	1009883a 	mov	r4,r2
81104da4:	11050d80 	call	811050d8 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81104da8:	00800044 	movi	r2,1
81104dac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104db0:	e0bffd17 	ldw	r2,-12(fp)
}
81104db4:	e037883a 	mov	sp,fp
81104db8:	dfc00117 	ldw	ra,4(sp)
81104dbc:	df000017 	ldw	fp,0(sp)
81104dc0:	dec00204 	addi	sp,sp,8
81104dc4:	f800283a 	ret

81104dc8 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81104dc8:	defffb04 	addi	sp,sp,-20
81104dcc:	de00012e 	bgeu	sp,et,81104dd4 <bFeebGetIrqControl+0xc>
81104dd0:	003b68fa 	trap	3
81104dd4:	dfc00415 	stw	ra,16(sp)
81104dd8:	df000315 	stw	fp,12(sp)
81104ddc:	df000304 	addi	fp,sp,12
81104de0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104de4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104de8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104dec:	e0bfff17 	ldw	r2,-4(fp)
81104df0:	10001a26 	beq	r2,zero,81104e5c <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104df4:	e0bfff17 	ldw	r2,-4(fp)
81104df8:	10800017 	ldw	r2,0(r2)
81104dfc:	01400104 	movi	r5,4
81104e00:	1009883a 	mov	r4,r2
81104e04:	110512c0 	call	8110512c <uliFeebReadReg>
81104e08:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CTRL_REG_OFFSET);

		if (uliReg & COMM_IRQ_L_BUFFER_EMPTY_EN_MSK) {
81104e0c:	e0bffe17 	ldw	r2,-8(fp)
81104e10:	1080400c 	andi	r2,r2,256
81104e14:	10000426 	beq	r2,zero,81104e28 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81104e18:	e0bfff17 	ldw	r2,-4(fp)
81104e1c:	00c00044 	movi	r3,1
81104e20:	10c00215 	stw	r3,8(r2)
81104e24:	00000206 	br	81104e30 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81104e28:	e0bfff17 	ldw	r2,-4(fp)
81104e2c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_R_BUFFER_EMPTY_EN_MSK) {
81104e30:	e0bffe17 	ldw	r2,-8(fp)
81104e34:	1080004c 	andi	r2,r2,1
81104e38:	10000426 	beq	r2,zero,81104e4c <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81104e3c:	e0bfff17 	ldw	r2,-4(fp)
81104e40:	00c00044 	movi	r3,1
81104e44:	10c00315 	stw	r3,12(r2)
81104e48:	00000206 	br	81104e54 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81104e4c:	e0bfff17 	ldw	r2,-4(fp)
81104e50:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
81104e54:	00800044 	movi	r2,1
81104e58:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104e5c:	e0bffd17 	ldw	r2,-12(fp)
}
81104e60:	e037883a 	mov	sp,fp
81104e64:	dfc00117 	ldw	ra,4(sp)
81104e68:	df000017 	ldw	fp,0(sp)
81104e6c:	dec00204 	addi	sp,sp,8
81104e70:	f800283a 	ret

81104e74 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81104e74:	defffb04 	addi	sp,sp,-20
81104e78:	de00012e 	bgeu	sp,et,81104e80 <bFeebGetIrqFlags+0xc>
81104e7c:	003b68fa 	trap	3
81104e80:	dfc00415 	stw	ra,16(sp)
81104e84:	df000315 	stw	fp,12(sp)
81104e88:	df000304 	addi	fp,sp,12
81104e8c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104e90:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104e94:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104e98:	e0bfff17 	ldw	r2,-4(fp)
81104e9c:	10001126 	beq	r2,zero,81104ee4 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104ea0:	e0bfff17 	ldw	r2,-4(fp)
81104ea4:	10800017 	ldw	r2,0(r2)
81104ea8:	01400144 	movi	r5,5
81104eac:	1009883a 	mov	r4,r2
81104eb0:	110512c0 	call	8110512c <uliFeebReadReg>
81104eb4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAG_REG_OFFSET);

		if (uliReg & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104eb8:	e0bffe17 	ldw	r2,-8(fp)
81104ebc:	1080004c 	andi	r2,r2,1
81104ec0:	10000426 	beq	r2,zero,81104ed4 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81104ec4:	e0bfff17 	ldw	r2,-4(fp)
81104ec8:	00c00044 	movi	r3,1
81104ecc:	10c00415 	stw	r3,16(r2)
81104ed0:	00000206 	br	81104edc <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81104ed4:	e0bfff17 	ldw	r2,-4(fp)
81104ed8:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
81104edc:	00800044 	movi	r2,1
81104ee0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ee4:	e0bffd17 	ldw	r2,-12(fp)
}
81104ee8:	e037883a 	mov	sp,fp
81104eec:	dfc00117 	ldw	ra,4(sp)
81104ef0:	df000017 	ldw	fp,0(sp)
81104ef4:	dec00204 	addi	sp,sp,8
81104ef8:	f800283a 	ret

81104efc <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81104efc:	defffb04 	addi	sp,sp,-20
81104f00:	de00012e 	bgeu	sp,et,81104f08 <bFeebSetWindowing+0xc>
81104f04:	003b68fa 	trap	3
81104f08:	dfc00415 	stw	ra,16(sp)
81104f0c:	df000315 	stw	fp,12(sp)
81104f10:	df000304 	addi	fp,sp,12
81104f14:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104f18:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104f1c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104f20:	e0bfff17 	ldw	r2,-4(fp)
81104f24:	10001926 	beq	r2,zero,81104f8c <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104f28:	e0bfff17 	ldw	r2,-4(fp)
81104f2c:	10800017 	ldw	r2,0(r2)
81104f30:	000b883a 	mov	r5,zero
81104f34:	1009883a 	mov	r4,r2
81104f38:	110512c0 	call	8110512c <uliFeebReadReg>
81104f3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81104f40:	e0bfff17 	ldw	r2,-4(fp)
81104f44:	10800117 	ldw	r2,4(r2)
81104f48:	10000426 	beq	r2,zero,81104f5c <bFeebSetWindowing+0x60>
			uliReg |= COMM_CTRL_MASKING_EN_MSK;
81104f4c:	e0bffe17 	ldw	r2,-8(fp)
81104f50:	10804014 	ori	r2,r2,256
81104f54:	e0bffe15 	stw	r2,-8(fp)
81104f58:	00000406 	br	81104f6c <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_CTRL_MASKING_EN_MSK);
81104f5c:	e0fffe17 	ldw	r3,-8(fp)
81104f60:	00bfbfc4 	movi	r2,-257
81104f64:	1884703a 	and	r2,r3,r2
81104f68:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_WINDOW_CTRL_REG_OFFSET,
81104f6c:	e0bfff17 	ldw	r2,-4(fp)
81104f70:	10800017 	ldw	r2,0(r2)
81104f74:	e1bffe17 	ldw	r6,-8(fp)
81104f78:	000b883a 	mov	r5,zero
81104f7c:	1009883a 	mov	r4,r2
81104f80:	11050d80 	call	811050d8 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81104f84:	00800044 	movi	r2,1
81104f88:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104f8c:	e0bffd17 	ldw	r2,-12(fp)
}
81104f90:	e037883a 	mov	sp,fp
81104f94:	dfc00117 	ldw	ra,4(sp)
81104f98:	df000017 	ldw	fp,0(sp)
81104f9c:	dec00204 	addi	sp,sp,8
81104fa0:	f800283a 	ret

81104fa4 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81104fa4:	defffb04 	addi	sp,sp,-20
81104fa8:	de00012e 	bgeu	sp,et,81104fb0 <bFeebGetWindowing+0xc>
81104fac:	003b68fa 	trap	3
81104fb0:	dfc00415 	stw	ra,16(sp)
81104fb4:	df000315 	stw	fp,12(sp)
81104fb8:	df000304 	addi	fp,sp,12
81104fbc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104fc0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104fc4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104fc8:	e0bfff17 	ldw	r2,-4(fp)
81104fcc:	10001126 	beq	r2,zero,81105014 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104fd0:	e0bfff17 	ldw	r2,-4(fp)
81104fd4:	10800017 	ldw	r2,0(r2)
81104fd8:	000b883a 	mov	r5,zero
81104fdc:	1009883a 	mov	r4,r2
81104fe0:	110512c0 	call	8110512c <uliFeebReadReg>
81104fe4:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (uliReg & COMM_CTRL_MASKING_EN_MSK) {
81104fe8:	e0bffe17 	ldw	r2,-8(fp)
81104fec:	1080400c 	andi	r2,r2,256
81104ff0:	10000426 	beq	r2,zero,81105004 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81104ff4:	e0bfff17 	ldw	r2,-4(fp)
81104ff8:	00c00044 	movi	r3,1
81104ffc:	10c00115 	stw	r3,4(r2)
81105000:	00000206 	br	8110500c <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81105004:	e0bfff17 	ldw	r2,-4(fp)
81105008:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
8110500c:	00800044 	movi	r2,1
81105010:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105014:	e0bffd17 	ldw	r2,-12(fp)
}
81105018:	e037883a 	mov	sp,fp
8110501c:	dfc00117 	ldw	ra,4(sp)
81105020:	df000017 	ldw	fp,0(sp)
81105024:	dec00204 	addi	sp,sp,8
81105028:	f800283a 	ret

8110502c <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
8110502c:	defffb04 	addi	sp,sp,-20
81105030:	de00012e 	bgeu	sp,et,81105038 <bFeebGetBuffersStatus+0xc>
81105034:	003b68fa 	trap	3
81105038:	dfc00415 	stw	ra,16(sp)
8110503c:	df000315 	stw	fp,12(sp)
81105040:	df000304 	addi	fp,sp,12
81105044:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105048:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110504c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105050:	e0bfff17 	ldw	r2,-4(fp)
81105054:	10001a26 	beq	r2,zero,811050c0 <bFeebGetBuffersStatus+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105058:	e0bfff17 	ldw	r2,-4(fp)
8110505c:	10800017 	ldw	r2,0(r2)
81105060:	01400184 	movi	r5,6
81105064:	1009883a 	mov	r4,r2
81105068:	110512c0 	call	8110512c <uliFeebReadReg>
8110506c:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_BUFFER_REG_OFFSET);

		if (uliReg & COMM_BUFF_STAT_L_BUFF_EPY_MSK) {
81105070:	e0bffe17 	ldw	r2,-8(fp)
81105074:	1080400c 	andi	r2,r2,256
81105078:	10000426 	beq	r2,zero,8110508c <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
8110507c:	e0bfff17 	ldw	r2,-4(fp)
81105080:	00c00044 	movi	r3,1
81105084:	10c00515 	stw	r3,20(r2)
81105088:	00000206 	br	81105094 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
8110508c:	e0bfff17 	ldw	r2,-4(fp)
81105090:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_BUFF_STAT_R_BUFF_EPY_MSK) {
81105094:	e0bffe17 	ldw	r2,-8(fp)
81105098:	1080004c 	andi	r2,r2,1
8110509c:	10000426 	beq	r2,zero,811050b0 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
811050a0:	e0bfff17 	ldw	r2,-4(fp)
811050a4:	00c00044 	movi	r3,1
811050a8:	10c00615 	stw	r3,24(r2)
811050ac:	00000206 	br	811050b8 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
811050b0:	e0bfff17 	ldw	r2,-4(fp)
811050b4:	10000615 	stw	zero,24(r2)
		}

		bStatus = TRUE;
811050b8:	00800044 	movi	r2,1
811050bc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811050c0:	e0bffd17 	ldw	r2,-12(fp)
}
811050c4:	e037883a 	mov	sp,fp
811050c8:	dfc00117 	ldw	ra,4(sp)
811050cc:	df000017 	ldw	fp,0(sp)
811050d0:	dec00204 	addi	sp,sp,8
811050d4:	f800283a 	ret

811050d8 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811050d8:	defffc04 	addi	sp,sp,-16
811050dc:	de00012e 	bgeu	sp,et,811050e4 <vFeebWriteReg+0xc>
811050e0:	003b68fa 	trap	3
811050e4:	df000315 	stw	fp,12(sp)
811050e8:	df000304 	addi	fp,sp,12
811050ec:	e13ffd15 	stw	r4,-12(fp)
811050f0:	e17ffe15 	stw	r5,-8(fp)
811050f4:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811050f8:	e0bffe17 	ldw	r2,-8(fp)
811050fc:	1085883a 	add	r2,r2,r2
81105100:	1085883a 	add	r2,r2,r2
81105104:	1007883a 	mov	r3,r2
81105108:	e0bffd17 	ldw	r2,-12(fp)
8110510c:	10c5883a 	add	r2,r2,r3
81105110:	e0ffff17 	ldw	r3,-4(fp)
81105114:	10c00015 	stw	r3,0(r2)
}
81105118:	0001883a 	nop
8110511c:	e037883a 	mov	sp,fp
81105120:	df000017 	ldw	fp,0(sp)
81105124:	dec00104 	addi	sp,sp,4
81105128:	f800283a 	ret

8110512c <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110512c:	defffc04 	addi	sp,sp,-16
81105130:	de00012e 	bgeu	sp,et,81105138 <uliFeebReadReg+0xc>
81105134:	003b68fa 	trap	3
81105138:	df000315 	stw	fp,12(sp)
8110513c:	df000304 	addi	fp,sp,12
81105140:	e13ffe15 	stw	r4,-8(fp)
81105144:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105148:	e0bfff17 	ldw	r2,-4(fp)
8110514c:	1085883a 	add	r2,r2,r2
81105150:	1085883a 	add	r2,r2,r2
81105154:	1007883a 	mov	r3,r2
81105158:	e0bffe17 	ldw	r2,-8(fp)
8110515c:	10c5883a 	add	r2,r2,r3
81105160:	10800017 	ldw	r2,0(r2)
81105164:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105168:	e0bffd17 	ldw	r2,-12(fp)
}
8110516c:	e037883a 	mov	sp,fp
81105170:	df000017 	ldw	fp,0(sp)
81105174:	dec00104 	addi	sp,sp,4
81105178:	f800283a 	ret

8110517c <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
8110517c:	defffb04 	addi	sp,sp,-20
81105180:	de00012e 	bgeu	sp,et,81105188 <bSpwcSetLink+0xc>
81105184:	003b68fa 	trap	3
81105188:	dfc00415 	stw	ra,16(sp)
8110518c:	df000315 	stw	fp,12(sp)
81105190:	df000304 	addi	fp,sp,12
81105194:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105198:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110519c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811051a0:	e0bfff17 	ldw	r2,-4(fp)
811051a4:	10002f26 	beq	r2,zero,81105264 <bSpwcSetLink+0xe8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811051a8:	e0bfff17 	ldw	r2,-4(fp)
811051ac:	10800017 	ldw	r2,0(r2)
811051b0:	000b883a 	mov	r5,zero
811051b4:	1009883a 	mov	r4,r2
811051b8:	11056dc0 	call	811056dc <uliSpwcReadReg>
811051bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
811051c0:	e0bfff17 	ldw	r2,-4(fp)
811051c4:	10800117 	ldw	r2,4(r2)
811051c8:	10000426 	beq	r2,zero,811051dc <bSpwcSetLink+0x60>
			uliReg |= COMM_CTRL_LINK_AUTOSTART_MSK;
811051cc:	e0bffe17 	ldw	r2,-8(fp)
811051d0:	10800114 	ori	r2,r2,4
811051d4:	e0bffe15 	stw	r2,-8(fp)
811051d8:	00000406 	br	811051ec <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_CTRL_LINK_AUTOSTART_MSK);
811051dc:	e0fffe17 	ldw	r3,-8(fp)
811051e0:	00bffec4 	movi	r2,-5
811051e4:	1884703a 	and	r2,r3,r2
811051e8:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bStart) {
811051ec:	e0bfff17 	ldw	r2,-4(fp)
811051f0:	10800217 	ldw	r2,8(r2)
811051f4:	10000426 	beq	r2,zero,81105208 <bSpwcSetLink+0x8c>
			uliReg |= COMM_CTRL_LINK_START_MSK;
811051f8:	e0bffe17 	ldw	r2,-8(fp)
811051fc:	10800094 	ori	r2,r2,2
81105200:	e0bffe15 	stw	r2,-8(fp)
81105204:	00000406 	br	81105218 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_CTRL_LINK_START_MSK);
81105208:	e0fffe17 	ldw	r3,-8(fp)
8110520c:	00bfff44 	movi	r2,-3
81105210:	1884703a 	and	r2,r3,r2
81105214:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
81105218:	e0bfff17 	ldw	r2,-4(fp)
8110521c:	10800317 	ldw	r2,12(r2)
81105220:	10000426 	beq	r2,zero,81105234 <bSpwcSetLink+0xb8>
			uliReg |= COMM_CTRL_LINK_DISCONNECT_MSK;
81105224:	e0bffe17 	ldw	r2,-8(fp)
81105228:	10800054 	ori	r2,r2,1
8110522c:	e0bffe15 	stw	r2,-8(fp)
81105230:	00000406 	br	81105244 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_CTRL_LINK_DISCONNECT_MSK);
81105234:	e0fffe17 	ldw	r3,-8(fp)
81105238:	00bfff84 	movi	r2,-2
8110523c:	1884703a 	and	r2,r3,r2
81105240:	e0bffe15 	stw	r2,-8(fp)
		}

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_WINDOW_CTRL_REG_OFFSET,
81105244:	e0bfff17 	ldw	r2,-4(fp)
81105248:	10800017 	ldw	r2,0(r2)
8110524c:	e1bffe17 	ldw	r6,-8(fp)
81105250:	000b883a 	mov	r5,zero
81105254:	1009883a 	mov	r4,r2
81105258:	11056880 	call	81105688 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
8110525c:	00800044 	movi	r2,1
81105260:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105264:	e0bffd17 	ldw	r2,-12(fp)
}
81105268:	e037883a 	mov	sp,fp
8110526c:	dfc00117 	ldw	ra,4(sp)
81105270:	df000017 	ldw	fp,0(sp)
81105274:	dec00204 	addi	sp,sp,8
81105278:	f800283a 	ret

8110527c <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
8110527c:	defffb04 	addi	sp,sp,-20
81105280:	de00012e 	bgeu	sp,et,81105288 <bSpwcGetLink+0xc>
81105284:	003b68fa 	trap	3
81105288:	dfc00415 	stw	ra,16(sp)
8110528c:	df000315 	stw	fp,12(sp)
81105290:	df000304 	addi	fp,sp,12
81105294:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105298:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110529c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811052a0:	e0bfff17 	ldw	r2,-4(fp)
811052a4:	10002326 	beq	r2,zero,81105334 <bSpwcGetLink+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811052a8:	e0bfff17 	ldw	r2,-4(fp)
811052ac:	10800017 	ldw	r2,0(r2)
811052b0:	000b883a 	mov	r5,zero
811052b4:	1009883a 	mov	r4,r2
811052b8:	11056dc0 	call	811056dc <uliSpwcReadReg>
811052bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (uliReg & COMM_CTRL_LINK_AUTOSTART_MSK) {
811052c0:	e0bffe17 	ldw	r2,-8(fp)
811052c4:	1080010c 	andi	r2,r2,4
811052c8:	10000426 	beq	r2,zero,811052dc <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
811052cc:	e0bfff17 	ldw	r2,-4(fp)
811052d0:	00c00044 	movi	r3,1
811052d4:	10c00115 	stw	r3,4(r2)
811052d8:	00000206 	br	811052e4 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
811052dc:	e0bfff17 	ldw	r2,-4(fp)
811052e0:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_CTRL_LINK_START_MSK) {
811052e4:	e0bffe17 	ldw	r2,-8(fp)
811052e8:	1080008c 	andi	r2,r2,2
811052ec:	10000426 	beq	r2,zero,81105300 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bStart = TRUE;
811052f0:	e0bfff17 	ldw	r2,-4(fp)
811052f4:	00c00044 	movi	r3,1
811052f8:	10c00215 	stw	r3,8(r2)
811052fc:	00000206 	br	81105308 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bStart = FALSE;
81105300:	e0bfff17 	ldw	r2,-4(fp)
81105304:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_CTRL_LINK_DISCONNECT_MSK) {
81105308:	e0bffe17 	ldw	r2,-8(fp)
8110530c:	1080004c 	andi	r2,r2,1
81105310:	10000426 	beq	r2,zero,81105324 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
81105314:	e0bfff17 	ldw	r2,-4(fp)
81105318:	00c00044 	movi	r3,1
8110531c:	10c00315 	stw	r3,12(r2)
81105320:	00000206 	br	8110532c <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
81105324:	e0bfff17 	ldw	r2,-4(fp)
81105328:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
8110532c:	00800044 	movi	r2,1
81105330:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105334:	e0bffd17 	ldw	r2,-12(fp)
}
81105338:	e037883a 	mov	sp,fp
8110533c:	dfc00117 	ldw	ra,4(sp)
81105340:	df000017 	ldw	fp,0(sp)
81105344:	dec00204 	addi	sp,sp,8
81105348:	f800283a 	ret

8110534c <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110534c:	defffb04 	addi	sp,sp,-20
81105350:	de00012e 	bgeu	sp,et,81105358 <bSpwcGetLinkError+0xc>
81105354:	003b68fa 	trap	3
81105358:	dfc00415 	stw	ra,16(sp)
8110535c:	df000315 	stw	fp,12(sp)
81105360:	df000304 	addi	fp,sp,12
81105364:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105368:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110536c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81105370:	e0bfff17 	ldw	r2,-4(fp)
81105374:	10002c26 	beq	r2,zero,81105428 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81105378:	e0bfff17 	ldw	r2,-4(fp)
8110537c:	10800017 	ldw	r2,0(r2)
81105380:	01400044 	movi	r5,1
81105384:	1009883a 	mov	r4,r2
81105388:	11056dc0 	call	811056dc <uliSpwcReadReg>
8110538c:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_STAT_REG_OFFSET);

		if (uliReg & COMM_STAT_LINK_DISC_ERR_MSK) {
81105390:	e0bffe17 	ldw	r2,-8(fp)
81105394:	1082000c 	andi	r2,r2,2048
81105398:	10000426 	beq	r2,zero,811053ac <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110539c:	e0bfff17 	ldw	r2,-4(fp)
811053a0:	00c00044 	movi	r3,1
811053a4:	10c00415 	stw	r3,16(r2)
811053a8:	00000206 	br	811053b4 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
811053ac:	e0bfff17 	ldw	r2,-4(fp)
811053b0:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_STAT_LINK_PAR_ERR_MSK) {
811053b4:	e0bffe17 	ldw	r2,-8(fp)
811053b8:	1081000c 	andi	r2,r2,1024
811053bc:	10000426 	beq	r2,zero,811053d0 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
811053c0:	e0bfff17 	ldw	r2,-4(fp)
811053c4:	00c00044 	movi	r3,1
811053c8:	10c00515 	stw	r3,20(r2)
811053cc:	00000206 	br	811053d8 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
811053d0:	e0bfff17 	ldw	r2,-4(fp)
811053d4:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_STAT_LINK_ESC_ERR_MSK) {
811053d8:	e0bffe17 	ldw	r2,-8(fp)
811053dc:	1080800c 	andi	r2,r2,512
811053e0:	10000426 	beq	r2,zero,811053f4 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
811053e4:	e0bfff17 	ldw	r2,-4(fp)
811053e8:	00c00044 	movi	r3,1
811053ec:	10c00615 	stw	r3,24(r2)
811053f0:	00000206 	br	811053fc <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
811053f4:	e0bfff17 	ldw	r2,-4(fp)
811053f8:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_STAT_LINK_CRED_ERR_MSK) {
811053fc:	e0bffe17 	ldw	r2,-8(fp)
81105400:	1080400c 	andi	r2,r2,256
81105404:	10000426 	beq	r2,zero,81105418 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
81105408:	e0bfff17 	ldw	r2,-4(fp)
8110540c:	00c00044 	movi	r3,1
81105410:	10c00715 	stw	r3,28(r2)
81105414:	00000206 	br	81105420 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
81105418:	e0bfff17 	ldw	r2,-4(fp)
8110541c:	10000715 	stw	zero,28(r2)
		}

		bStatus = TRUE;
81105420:	00800044 	movi	r2,1
81105424:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105428:	e0bffd17 	ldw	r2,-12(fp)
}
8110542c:	e037883a 	mov	sp,fp
81105430:	dfc00117 	ldw	ra,4(sp)
81105434:	df000017 	ldw	fp,0(sp)
81105438:	dec00204 	addi	sp,sp,8
8110543c:	f800283a 	ret

81105440 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
81105440:	defffb04 	addi	sp,sp,-20
81105444:	de00012e 	bgeu	sp,et,8110544c <bSpwcGetLinkStatus+0xc>
81105448:	003b68fa 	trap	3
8110544c:	dfc00415 	stw	ra,16(sp)
81105450:	df000315 	stw	fp,12(sp)
81105454:	df000304 	addi	fp,sp,12
81105458:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110545c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105460:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81105464:	e0bfff17 	ldw	r2,-4(fp)
81105468:	10002326 	beq	r2,zero,811054f8 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110546c:	e0bfff17 	ldw	r2,-4(fp)
81105470:	10800017 	ldw	r2,0(r2)
81105474:	01400044 	movi	r5,1
81105478:	1009883a 	mov	r4,r2
8110547c:	11056dc0 	call	811056dc <uliSpwcReadReg>
81105480:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_STAT_REG_OFFSET);

		if (uliReg & COMM_STAT_LINK_STARTED_MSK) {
81105484:	e0bffe17 	ldw	r2,-8(fp)
81105488:	1080010c 	andi	r2,r2,4
8110548c:	10000426 	beq	r2,zero,811054a0 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
81105490:	e0bfff17 	ldw	r2,-4(fp)
81105494:	00c00044 	movi	r3,1
81105498:	10c00815 	stw	r3,32(r2)
8110549c:	00000206 	br	811054a8 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
811054a0:	e0bfff17 	ldw	r2,-4(fp)
811054a4:	10000815 	stw	zero,32(r2)
		}
		if (uliReg & COMM_STAT_LINK_CONNECTING_MSK) {
811054a8:	e0bffe17 	ldw	r2,-8(fp)
811054ac:	1080008c 	andi	r2,r2,2
811054b0:	10000426 	beq	r2,zero,811054c4 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
811054b4:	e0bfff17 	ldw	r2,-4(fp)
811054b8:	00c00044 	movi	r3,1
811054bc:	10c00915 	stw	r3,36(r2)
811054c0:	00000206 	br	811054cc <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
811054c4:	e0bfff17 	ldw	r2,-4(fp)
811054c8:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_STAT_LINK_RUNNING_MSK) {
811054cc:	e0bffe17 	ldw	r2,-8(fp)
811054d0:	1080004c 	andi	r2,r2,1
811054d4:	10000426 	beq	r2,zero,811054e8 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
811054d8:	e0bfff17 	ldw	r2,-4(fp)
811054dc:	00c00044 	movi	r3,1
811054e0:	10c00a15 	stw	r3,40(r2)
811054e4:	00000206 	br	811054f0 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
811054e8:	e0bfff17 	ldw	r2,-4(fp)
811054ec:	10000a15 	stw	zero,40(r2)
		}

		bStatus = TRUE;
811054f0:	00800044 	movi	r2,1
811054f4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811054f8:	e0bffd17 	ldw	r2,-12(fp)
}
811054fc:	e037883a 	mov	sp,fp
81105500:	dfc00117 	ldw	ra,4(sp)
81105504:	df000017 	ldw	fp,0(sp)
81105508:	dec00204 	addi	sp,sp,8
8110550c:	f800283a 	ret

81105510 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
81105510:	defffb04 	addi	sp,sp,-20
81105514:	de00012e 	bgeu	sp,et,8110551c <bSpwcInitCh+0xc>
81105518:	003b68fa 	trap	3
8110551c:	dfc00415 	stw	ra,16(sp)
81105520:	df000315 	stw	fp,12(sp)
81105524:	df000304 	addi	fp,sp,12
81105528:	e13ffe15 	stw	r4,-8(fp)
8110552c:	2805883a 	mov	r2,r5
81105530:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105534:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
81105538:	e0bffe17 	ldw	r2,-8(fp)
8110553c:	10004c26 	beq	r2,zero,81105670 <bSpwcInitCh+0x160>
		bStatus = TRUE;
81105540:	00800044 	movi	r2,1
81105544:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81105548:	e0bfff03 	ldbu	r2,-4(fp)
8110554c:	10c00268 	cmpgeui	r3,r2,9
81105550:	1800371e 	bne	r3,zero,81105630 <bSpwcInitCh+0x120>
81105554:	100690ba 	slli	r3,r2,2
81105558:	00a04434 	movhi	r2,33040
8110555c:	10955b04 	addi	r2,r2,21868
81105560:	1885883a 	add	r2,r3,r2
81105564:	10800017 	ldw	r2,0(r2)
81105568:	1000683a 	jmp	r2
8110556c:	81105630 	cmpltui	r4,r16,16728
81105570:	81105590 	cmplti	r4,r16,16726
81105574:	811055a4 	muli	r4,r16,16726
81105578:	811055b8 	rdprs	r4,r16,16726
8110557c:	811055cc 	andi	r4,r16,16727
81105580:	811055e0 	cmpeqi	r4,r16,16727
81105584:	811055f4 	orhi	r4,r16,16727
81105588:	81105608 	cmpgei	r4,r16,16728
8110558c:	8110561c 	xori	r4,r16,16728
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81105590:	e0fffe17 	ldw	r3,-8(fp)
81105594:	00a04834 	movhi	r2,33056
81105598:	108b0004 	addi	r2,r2,11264
8110559c:	18800015 	stw	r2,0(r3)
			break;
811055a0:	00002506 	br	81105638 <bSpwcInitCh+0x128>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811055a4:	e0fffe17 	ldw	r3,-8(fp)
811055a8:	00a04834 	movhi	r2,33056
811055ac:	108a0004 	addi	r2,r2,10240
811055b0:	18800015 	stw	r2,0(r3)
			break;
811055b4:	00002006 	br	81105638 <bSpwcInitCh+0x128>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811055b8:	e0fffe17 	ldw	r3,-8(fp)
811055bc:	00a04834 	movhi	r2,33056
811055c0:	10890004 	addi	r2,r2,9216
811055c4:	18800015 	stw	r2,0(r3)
			break;
811055c8:	00001b06 	br	81105638 <bSpwcInitCh+0x128>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811055cc:	e0fffe17 	ldw	r3,-8(fp)
811055d0:	00a04834 	movhi	r2,33056
811055d4:	10880004 	addi	r2,r2,8192
811055d8:	18800015 	stw	r2,0(r3)
			break;
811055dc:	00001606 	br	81105638 <bSpwcInitCh+0x128>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811055e0:	e0fffe17 	ldw	r3,-8(fp)
811055e4:	00a04834 	movhi	r2,33056
811055e8:	10870004 	addi	r2,r2,7168
811055ec:	18800015 	stw	r2,0(r3)
			break;
811055f0:	00001106 	br	81105638 <bSpwcInitCh+0x128>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811055f4:	e0fffe17 	ldw	r3,-8(fp)
811055f8:	00a04834 	movhi	r2,33056
811055fc:	10860004 	addi	r2,r2,6144
81105600:	18800015 	stw	r2,0(r3)
			break;
81105604:	00000c06 	br	81105638 <bSpwcInitCh+0x128>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81105608:	e0fffe17 	ldw	r3,-8(fp)
8110560c:	00a04834 	movhi	r2,33056
81105610:	10850004 	addi	r2,r2,5120
81105614:	18800015 	stw	r2,0(r3)
			break;
81105618:	00000706 	br	81105638 <bSpwcInitCh+0x128>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110561c:	e0fffe17 	ldw	r3,-8(fp)
81105620:	00a04834 	movhi	r2,33056
81105624:	10840004 	addi	r2,r2,4096
81105628:	18800015 	stw	r2,0(r3)
			break;
8110562c:	00000206 	br	81105638 <bSpwcInitCh+0x128>
		default:
			bStatus = FALSE;
81105630:	e03ffd15 	stw	zero,-12(fp)
			break;
81105634:	0001883a 	nop
		}

		if (bStatus) {
81105638:	e0bffd17 	ldw	r2,-12(fp)
8110563c:	10000c26 	beq	r2,zero,81105670 <bSpwcInitCh+0x160>
//			if (!bFeebGetWindowing(pxSpwcCh)) {
//				bStatus = FALSE;
//			}
			if (!bSpwcGetLink(pxSpwcCh)) {
81105640:	e13ffe17 	ldw	r4,-8(fp)
81105644:	110527c0 	call	8110527c <bSpwcGetLink>
81105648:	1000011e 	bne	r2,zero,81105650 <bSpwcInitCh+0x140>
				bStatus = FALSE;
8110564c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
81105650:	e13ffe17 	ldw	r4,-8(fp)
81105654:	110534c0 	call	8110534c <bSpwcGetLinkError>
81105658:	1000011e 	bne	r2,zero,81105660 <bSpwcInitCh+0x150>
				bStatus = FALSE;
8110565c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
81105660:	e13ffe17 	ldw	r4,-8(fp)
81105664:	11054400 	call	81105440 <bSpwcGetLinkStatus>
81105668:	1000011e 	bne	r2,zero,81105670 <bSpwcInitCh+0x160>
				bStatus = FALSE;
8110566c:	e03ffd15 	stw	zero,-12(fp)
//			if (!bFeebGetBuffersStatus(pxSpwcCh)) {
//				bStatus = FALSE;
//			}
		}
	}
	return bStatus;
81105670:	e0bffd17 	ldw	r2,-12(fp)
}
81105674:	e037883a 	mov	sp,fp
81105678:	dfc00117 	ldw	ra,4(sp)
8110567c:	df000017 	ldw	fp,0(sp)
81105680:	dec00204 	addi	sp,sp,8
81105684:	f800283a 	ret

81105688 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81105688:	defffc04 	addi	sp,sp,-16
8110568c:	de00012e 	bgeu	sp,et,81105694 <vSpwcWriteReg+0xc>
81105690:	003b68fa 	trap	3
81105694:	df000315 	stw	fp,12(sp)
81105698:	df000304 	addi	fp,sp,12
8110569c:	e13ffd15 	stw	r4,-12(fp)
811056a0:	e17ffe15 	stw	r5,-8(fp)
811056a4:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811056a8:	e0bffe17 	ldw	r2,-8(fp)
811056ac:	1085883a 	add	r2,r2,r2
811056b0:	1085883a 	add	r2,r2,r2
811056b4:	1007883a 	mov	r3,r2
811056b8:	e0bffd17 	ldw	r2,-12(fp)
811056bc:	10c5883a 	add	r2,r2,r3
811056c0:	e0ffff17 	ldw	r3,-4(fp)
811056c4:	10c00015 	stw	r3,0(r2)
}
811056c8:	0001883a 	nop
811056cc:	e037883a 	mov	sp,fp
811056d0:	df000017 	ldw	fp,0(sp)
811056d4:	dec00104 	addi	sp,sp,4
811056d8:	f800283a 	ret

811056dc <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811056dc:	defffc04 	addi	sp,sp,-16
811056e0:	de00012e 	bgeu	sp,et,811056e8 <uliSpwcReadReg+0xc>
811056e4:	003b68fa 	trap	3
811056e8:	df000315 	stw	fp,12(sp)
811056ec:	df000304 	addi	fp,sp,12
811056f0:	e13ffe15 	stw	r4,-8(fp)
811056f4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811056f8:	e0bfff17 	ldw	r2,-4(fp)
811056fc:	1085883a 	add	r2,r2,r2
81105700:	1085883a 	add	r2,r2,r2
81105704:	1007883a 	mov	r3,r2
81105708:	e0bffe17 	ldw	r2,-8(fp)
8110570c:	10c5883a 	add	r2,r2,r3
81105710:	10800017 	ldw	r2,0(r2)
81105714:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105718:	e0bffd17 	ldw	r2,-12(fp)
}
8110571c:	e037883a 	mov	sp,fp
81105720:	df000017 	ldw	fp,0(sp)
81105724:	dec00104 	addi	sp,sp,4
81105728:	f800283a 	ret

8110572c <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110572c:	defffe04 	addi	sp,sp,-8
81105730:	de00012e 	bgeu	sp,et,81105738 <bEnableIsoDrivers+0xc>
81105734:	003b68fa 	trap	3
81105738:	dfc00115 	stw	ra,4(sp)
8110573c:	df000015 	stw	fp,0(sp)
81105740:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
81105744:	01400204 	movi	r5,8
81105748:	01000044 	movi	r4,1
8110574c:	11058dc0 	call	811058dc <bCtrlIoLvdsDrive>
  return  TRUE;
81105750:	00800044 	movi	r2,1
}
81105754:	e037883a 	mov	sp,fp
81105758:	dfc00117 	ldw	ra,4(sp)
8110575c:	df000017 	ldw	fp,0(sp)
81105760:	dec00204 	addi	sp,sp,8
81105764:	f800283a 	ret

81105768 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
81105768:	defffe04 	addi	sp,sp,-8
8110576c:	de00012e 	bgeu	sp,et,81105774 <bDisableIsoDrivers+0xc>
81105770:	003b68fa 	trap	3
81105774:	dfc00115 	stw	ra,4(sp)
81105778:	df000015 	stw	fp,0(sp)
8110577c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
81105780:	01400204 	movi	r5,8
81105784:	0009883a 	mov	r4,zero
81105788:	11058dc0 	call	811058dc <bCtrlIoLvdsDrive>
  return  TRUE;
8110578c:	00800044 	movi	r2,1
}
81105790:	e037883a 	mov	sp,fp
81105794:	dfc00117 	ldw	ra,4(sp)
81105798:	df000017 	ldw	fp,0(sp)
8110579c:	dec00204 	addi	sp,sp,8
811057a0:	f800283a 	ret

811057a4 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
811057a4:	defffe04 	addi	sp,sp,-8
811057a8:	de00012e 	bgeu	sp,et,811057b0 <bEnableLvdsBoard+0xc>
811057ac:	003b68fa 	trap	3
811057b0:	dfc00115 	stw	ra,4(sp)
811057b4:	df000015 	stw	fp,0(sp)
811057b8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
811057bc:	01400104 	movi	r5,4
811057c0:	01000044 	movi	r4,1
811057c4:	11058dc0 	call	811058dc <bCtrlIoLvdsDrive>
  return  TRUE;
811057c8:	00800044 	movi	r2,1
}
811057cc:	e037883a 	mov	sp,fp
811057d0:	dfc00117 	ldw	ra,4(sp)
811057d4:	df000017 	ldw	fp,0(sp)
811057d8:	dec00204 	addi	sp,sp,8
811057dc:	f800283a 	ret

811057e0 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
811057e0:	defffe04 	addi	sp,sp,-8
811057e4:	de00012e 	bgeu	sp,et,811057ec <bDisableLvdsBoard+0xc>
811057e8:	003b68fa 	trap	3
811057ec:	dfc00115 	stw	ra,4(sp)
811057f0:	df000015 	stw	fp,0(sp)
811057f4:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
811057f8:	01400104 	movi	r5,4
811057fc:	0009883a 	mov	r4,zero
81105800:	11058dc0 	call	811058dc <bCtrlIoLvdsDrive>
  return  TRUE;
81105804:	00800044 	movi	r2,1
}
81105808:	e037883a 	mov	sp,fp
8110580c:	dfc00117 	ldw	ra,4(sp)
81105810:	df000017 	ldw	fp,0(sp)
81105814:	dec00204 	addi	sp,sp,8
81105818:	f800283a 	ret

8110581c <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110581c:	defffd04 	addi	sp,sp,-12
81105820:	de00012e 	bgeu	sp,et,81105828 <bSetPreEmphasys+0xc>
81105824:	003b68fa 	trap	3
81105828:	dfc00215 	stw	ra,8(sp)
8110582c:	df000115 	stw	fp,4(sp)
81105830:	df000104 	addi	fp,sp,4
81105834:	2005883a 	mov	r2,r4
81105838:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110583c:	e0bfff03 	ldbu	r2,-4(fp)
81105840:	10c00060 	cmpeqi	r3,r2,1
81105844:	18000d1e 	bne	r3,zero,8110587c <bSetPreEmphasys+0x60>
81105848:	10c00088 	cmpgei	r3,r2,2
8110584c:	1800021e 	bne	r3,zero,81105858 <bSetPreEmphasys+0x3c>
81105850:	10000626 	beq	r2,zero,8110586c <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
81105854:	00001b06 	br	811058c4 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
81105858:	10c000a0 	cmpeqi	r3,r2,2
8110585c:	18000e1e 	bne	r3,zero,81105898 <bSetPreEmphasys+0x7c>
81105860:	108000e0 	cmpeqi	r2,r2,3
81105864:	1000131e 	bne	r2,zero,811058b4 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
81105868:	00001606 	br	811058c4 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110586c:	014000c4 	movi	r5,3
81105870:	0009883a 	mov	r4,zero
81105874:	11058dc0 	call	811058dc <bCtrlIoLvdsDrive>
      break;
81105878:	00001206 	br	811058c4 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110587c:	01400084 	movi	r5,2
81105880:	0009883a 	mov	r4,zero
81105884:	11058dc0 	call	811058dc <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
81105888:	01400044 	movi	r5,1
8110588c:	01000044 	movi	r4,1
81105890:	11058dc0 	call	811058dc <bCtrlIoLvdsDrive>
      break;
81105894:	00000b06 	br	811058c4 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
81105898:	01400044 	movi	r5,1
8110589c:	0009883a 	mov	r4,zero
811058a0:	11058dc0 	call	811058dc <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
811058a4:	01400084 	movi	r5,2
811058a8:	01000044 	movi	r4,1
811058ac:	11058dc0 	call	811058dc <bCtrlIoLvdsDrive>
      break;
811058b0:	00000406 	br	811058c4 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
811058b4:	014000c4 	movi	r5,3
811058b8:	01000044 	movi	r4,1
811058bc:	11058dc0 	call	811058dc <bCtrlIoLvdsDrive>
      break;
811058c0:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
811058c4:	00800044 	movi	r2,1
}
811058c8:	e037883a 	mov	sp,fp
811058cc:	dfc00117 	ldw	ra,4(sp)
811058d0:	df000017 	ldw	fp,0(sp)
811058d4:	dec00204 	addi	sp,sp,8
811058d8:	f800283a 	ret

811058dc <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/o´s a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
811058dc:	defffd04 	addi	sp,sp,-12
811058e0:	de00012e 	bgeu	sp,et,811058e8 <bCtrlIoLvdsDrive+0xc>
811058e4:	003b68fa 	trap	3
811058e8:	df000215 	stw	fp,8(sp)
811058ec:	df000204 	addi	fp,sp,8
811058f0:	e13ffe15 	stw	r4,-8(fp)
811058f4:	2805883a 	mov	r2,r5
811058f8:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
811058fc:	e0bffe17 	ldw	r2,-8(fp)
81105900:	1000071e 	bne	r2,zero,81105920 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
81105904:	e0bfff03 	ldbu	r2,-4(fp)
81105908:	0084303a 	nor	r2,zero,r2
8110590c:	1007883a 	mov	r3,r2
81105910:	d0a00103 	ldbu	r2,-32764(gp)
81105914:	1884703a 	and	r2,r3,r2
81105918:	d0a00105 	stb	r2,-32764(gp)
8110591c:	00000406 	br	81105930 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
81105920:	d0e00103 	ldbu	r3,-32764(gp)
81105924:	e0bfff03 	ldbu	r2,-4(fp)
81105928:	1884b03a 	or	r2,r3,r2
8110592c:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
81105930:	d0a00103 	ldbu	r2,-32764(gp)
81105934:	10c03fcc 	andi	r3,r2,255
81105938:	00a00034 	movhi	r2,32768
8110593c:	10822804 	addi	r2,r2,2208
81105940:	10c00035 	stwio	r3,0(r2)
  return TRUE;
81105944:	00800044 	movi	r2,1
}
81105948:	e037883a 	mov	sp,fp
8110594c:	df000017 	ldw	fp,0(sp)
81105950:	dec00104 	addi	sp,sp,4
81105954:	f800283a 	ret

81105958 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
81105958:	defffa04 	addi	sp,sp,-24
8110595c:	de00012e 	bgeu	sp,et,81105964 <I2C_TestAdress+0xc>
81105960:	003b68fa 	trap	3
81105964:	dfc00515 	stw	ra,20(sp)
81105968:	df000415 	stw	fp,16(sp)
8110596c:	df000404 	addi	fp,sp,16
81105970:	e13ffd15 	stw	r4,-12(fp)
81105974:	e17ffe15 	stw	r5,-8(fp)
81105978:	3005883a 	mov	r2,r6
8110597c:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81105980:	00800044 	movi	r2,1
81105984:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81105988:	e17ffe17 	ldw	r5,-8(fp)
8110598c:	e13ffd17 	ldw	r4,-12(fp)
81105990:	1105d280 	call	81105d28 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105994:	e0bfff03 	ldbu	r2,-4(fp)
81105998:	10803fcc 	andi	r2,r2,255
8110599c:	100d883a 	mov	r6,r2
811059a0:	e17ffe17 	ldw	r5,-8(fp)
811059a4:	e13ffd17 	ldw	r4,-12(fp)
811059a8:	1105e3c0 	call	81105e3c <i2c_write>
811059ac:	1000011e 	bne	r2,zero,811059b4 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
811059b0:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
811059b4:	e17ffe17 	ldw	r5,-8(fp)
811059b8:	e13ffd17 	ldw	r4,-12(fp)
811059bc:	1105dbc0 	call	81105dbc <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
811059c0:	0106d604 	movi	r4,7000
811059c4:	1128bec0 	call	81128bec <usleep>
    
    return bSuccess;
811059c8:	e0bffc17 	ldw	r2,-16(fp)

}
811059cc:	e037883a 	mov	sp,fp
811059d0:	dfc00117 	ldw	ra,4(sp)
811059d4:	df000017 	ldw	fp,0(sp)
811059d8:	dec00204 	addi	sp,sp,8
811059dc:	f800283a 	ret

811059e0 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
811059e0:	defff804 	addi	sp,sp,-32
811059e4:	de00012e 	bgeu	sp,et,811059ec <I2C_Write+0xc>
811059e8:	003b68fa 	trap	3
811059ec:	dfc00715 	stw	ra,28(sp)
811059f0:	df000615 	stw	fp,24(sp)
811059f4:	df000604 	addi	fp,sp,24
811059f8:	e13ffb15 	stw	r4,-20(fp)
811059fc:	e17ffc15 	stw	r5,-16(fp)
81105a00:	3009883a 	mov	r4,r6
81105a04:	3807883a 	mov	r3,r7
81105a08:	e0800217 	ldw	r2,8(fp)
81105a0c:	e13ffd05 	stb	r4,-12(fp)
81105a10:	e0fffe05 	stb	r3,-8(fp)
81105a14:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81105a18:	00800044 	movi	r2,1
81105a1c:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81105a20:	e17ffc17 	ldw	r5,-16(fp)
81105a24:	e13ffb17 	ldw	r4,-20(fp)
81105a28:	1105d280 	call	81105d28 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105a2c:	e0bffd03 	ldbu	r2,-12(fp)
81105a30:	10803fcc 	andi	r2,r2,255
81105a34:	100d883a 	mov	r6,r2
81105a38:	e17ffc17 	ldw	r5,-16(fp)
81105a3c:	e13ffb17 	ldw	r4,-20(fp)
81105a40:	1105e3c0 	call	81105e3c <i2c_write>
81105a44:	1000011e 	bne	r2,zero,81105a4c <I2C_Write+0x6c>
        bSuccess = FALSE;
81105a48:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81105a4c:	e0bffa17 	ldw	r2,-24(fp)
81105a50:	10000726 	beq	r2,zero,81105a70 <I2C_Write+0x90>
81105a54:	e0bffe03 	ldbu	r2,-8(fp)
81105a58:	100d883a 	mov	r6,r2
81105a5c:	e17ffc17 	ldw	r5,-16(fp)
81105a60:	e13ffb17 	ldw	r4,-20(fp)
81105a64:	1105e3c0 	call	81105e3c <i2c_write>
81105a68:	1000011e 	bne	r2,zero,81105a70 <I2C_Write+0x90>
        bSuccess = FALSE;
81105a6c:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
81105a70:	e0bffa17 	ldw	r2,-24(fp)
81105a74:	10000726 	beq	r2,zero,81105a94 <I2C_Write+0xb4>
81105a78:	e0bfff03 	ldbu	r2,-4(fp)
81105a7c:	100d883a 	mov	r6,r2
81105a80:	e17ffc17 	ldw	r5,-16(fp)
81105a84:	e13ffb17 	ldw	r4,-20(fp)
81105a88:	1105e3c0 	call	81105e3c <i2c_write>
81105a8c:	1000011e 	bne	r2,zero,81105a94 <I2C_Write+0xb4>
        bSuccess = FALSE;
81105a90:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81105a94:	e17ffc17 	ldw	r5,-16(fp)
81105a98:	e13ffb17 	ldw	r4,-20(fp)
81105a9c:	1105dbc0 	call	81105dbc <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81105aa0:	0106d604 	movi	r4,7000
81105aa4:	1128bec0 	call	81128bec <usleep>
    
    return bSuccess;
81105aa8:	e0bffa17 	ldw	r2,-24(fp)

}
81105aac:	e037883a 	mov	sp,fp
81105ab0:	dfc00117 	ldw	ra,4(sp)
81105ab4:	df000017 	ldw	fp,0(sp)
81105ab8:	dec00204 	addi	sp,sp,8
81105abc:	f800283a 	ret

81105ac0 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
81105ac0:	defff904 	addi	sp,sp,-28
81105ac4:	de00012e 	bgeu	sp,et,81105acc <I2C_Read+0xc>
81105ac8:	003b68fa 	trap	3
81105acc:	dfc00615 	stw	ra,24(sp)
81105ad0:	df000515 	stw	fp,20(sp)
81105ad4:	df000504 	addi	fp,sp,20
81105ad8:	e13ffc15 	stw	r4,-16(fp)
81105adc:	e17ffd15 	stw	r5,-12(fp)
81105ae0:	3007883a 	mov	r3,r6
81105ae4:	3805883a 	mov	r2,r7
81105ae8:	e0fffe05 	stb	r3,-8(fp)
81105aec:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81105af0:	00800044 	movi	r2,1
81105af4:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81105af8:	e17ffd17 	ldw	r5,-12(fp)
81105afc:	e13ffc17 	ldw	r4,-16(fp)
81105b00:	1105d280 	call	81105d28 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105b04:	e0bffe03 	ldbu	r2,-8(fp)
81105b08:	10803fcc 	andi	r2,r2,255
81105b0c:	100d883a 	mov	r6,r2
81105b10:	e17ffd17 	ldw	r5,-12(fp)
81105b14:	e13ffc17 	ldw	r4,-16(fp)
81105b18:	1105e3c0 	call	81105e3c <i2c_write>
81105b1c:	1000011e 	bne	r2,zero,81105b24 <I2C_Read+0x64>
        bSuccess = FALSE;
81105b20:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81105b24:	e0bffb17 	ldw	r2,-20(fp)
81105b28:	10000726 	beq	r2,zero,81105b48 <I2C_Read+0x88>
81105b2c:	e0bfff03 	ldbu	r2,-4(fp)
81105b30:	100d883a 	mov	r6,r2
81105b34:	e17ffd17 	ldw	r5,-12(fp)
81105b38:	e13ffc17 	ldw	r4,-16(fp)
81105b3c:	1105e3c0 	call	81105e3c <i2c_write>
81105b40:	1000011e 	bne	r2,zero,81105b48 <I2C_Read+0x88>
        bSuccess = FALSE;
81105b44:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
81105b48:	e17ffd17 	ldw	r5,-12(fp)
81105b4c:	e13ffc17 	ldw	r4,-16(fp)
81105b50:	1105d280 	call	81105d28 <i2c_start>
    DeviceAddr |= 1; // Read
81105b54:	e0bffe03 	ldbu	r2,-8(fp)
81105b58:	10800054 	ori	r2,r2,1
81105b5c:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81105b60:	e0bffb17 	ldw	r2,-20(fp)
81105b64:	10000826 	beq	r2,zero,81105b88 <I2C_Read+0xc8>
81105b68:	e0bffe03 	ldbu	r2,-8(fp)
81105b6c:	10803fcc 	andi	r2,r2,255
81105b70:	100d883a 	mov	r6,r2
81105b74:	e17ffd17 	ldw	r5,-12(fp)
81105b78:	e13ffc17 	ldw	r4,-16(fp)
81105b7c:	1105e3c0 	call	81105e3c <i2c_write>
81105b80:	1000011e 	bne	r2,zero,81105b88 <I2C_Read+0xc8>
        bSuccess = FALSE;
81105b84:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81105b88:	e0bffb17 	ldw	r2,-20(fp)
81105b8c:	10000526 	beq	r2,zero,81105ba4 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
81105b90:	000f883a 	mov	r7,zero
81105b94:	e1800217 	ldw	r6,8(fp)
81105b98:	e17ffd17 	ldw	r5,-12(fp)
81105b9c:	e13ffc17 	ldw	r4,-16(fp)
81105ba0:	1105f740 	call	81105f74 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
81105ba4:	e17ffd17 	ldw	r5,-12(fp)
81105ba8:	e13ffc17 	ldw	r4,-16(fp)
81105bac:	1105dbc0 	call	81105dbc <i2c_stop>
    
    return bSuccess;
81105bb0:	e0bffb17 	ldw	r2,-20(fp)
}
81105bb4:	e037883a 	mov	sp,fp
81105bb8:	dfc00117 	ldw	ra,4(sp)
81105bbc:	df000017 	ldw	fp,0(sp)
81105bc0:	dec00204 	addi	sp,sp,8
81105bc4:	f800283a 	ret

81105bc8 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
81105bc8:	defff604 	addi	sp,sp,-40
81105bcc:	de00012e 	bgeu	sp,et,81105bd4 <I2C_MultipleRead+0xc>
81105bd0:	003b68fa 	trap	3
81105bd4:	dfc00915 	stw	ra,36(sp)
81105bd8:	df000815 	stw	fp,32(sp)
81105bdc:	df000804 	addi	fp,sp,32
81105be0:	e13ffb15 	stw	r4,-20(fp)
81105be4:	e17ffc15 	stw	r5,-16(fp)
81105be8:	3007883a 	mov	r3,r6
81105bec:	e1fffe15 	stw	r7,-8(fp)
81105bf0:	e0800217 	ldw	r2,8(fp)
81105bf4:	e0fffd05 	stb	r3,-12(fp)
81105bf8:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
81105bfc:	00800044 	movi	r2,1
81105c00:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
81105c04:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81105c08:	e17ffc17 	ldw	r5,-16(fp)
81105c0c:	e13ffb17 	ldw	r4,-20(fp)
81105c10:	1105d280 	call	81105d28 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105c14:	e0bffd03 	ldbu	r2,-12(fp)
81105c18:	10803fcc 	andi	r2,r2,255
81105c1c:	100d883a 	mov	r6,r2
81105c20:	e17ffc17 	ldw	r5,-16(fp)
81105c24:	e13ffb17 	ldw	r4,-20(fp)
81105c28:	1105e3c0 	call	81105e3c <i2c_write>
81105c2c:	1000011e 	bne	r2,zero,81105c34 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
81105c30:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81105c34:	e0bff917 	ldw	r2,-28(fp)
81105c38:	10000726 	beq	r2,zero,81105c58 <I2C_MultipleRead+0x90>
81105c3c:	e0bffa03 	ldbu	r2,-24(fp)
81105c40:	100d883a 	mov	r6,r2
81105c44:	e17ffc17 	ldw	r5,-16(fp)
81105c48:	e13ffb17 	ldw	r4,-20(fp)
81105c4c:	1105e3c0 	call	81105e3c <i2c_write>
81105c50:	1000011e 	bne	r2,zero,81105c58 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
81105c54:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
81105c58:	e0bff917 	ldw	r2,-28(fp)
81105c5c:	10000326 	beq	r2,zero,81105c6c <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
81105c60:	e17ffc17 	ldw	r5,-16(fp)
81105c64:	e13ffb17 	ldw	r4,-20(fp)
81105c68:	1105d280 	call	81105d28 <i2c_start>
    DeviceAddr |= 1; // Read
81105c6c:	e0bffd03 	ldbu	r2,-12(fp)
81105c70:	10800054 	ori	r2,r2,1
81105c74:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81105c78:	e0bff917 	ldw	r2,-28(fp)
81105c7c:	10000826 	beq	r2,zero,81105ca0 <I2C_MultipleRead+0xd8>
81105c80:	e0bffd03 	ldbu	r2,-12(fp)
81105c84:	10803fcc 	andi	r2,r2,255
81105c88:	100d883a 	mov	r6,r2
81105c8c:	e17ffc17 	ldw	r5,-16(fp)
81105c90:	e13ffb17 	ldw	r4,-20(fp)
81105c94:	1105e3c0 	call	81105e3c <i2c_write>
81105c98:	1000011e 	bne	r2,zero,81105ca0 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
81105c9c:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81105ca0:	e0bff917 	ldw	r2,-28(fp)
81105ca4:	10001726 	beq	r2,zero,81105d04 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
81105ca8:	e03ff815 	stw	zero,-32(fp)
81105cac:	00001006 	br	81105cf0 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
81105cb0:	e0bff817 	ldw	r2,-32(fp)
81105cb4:	e0fffe17 	ldw	r3,-8(fp)
81105cb8:	1889883a 	add	r4,r3,r2
81105cbc:	e0bfff0b 	ldhu	r2,-4(fp)
81105cc0:	10ffffc4 	addi	r3,r2,-1
81105cc4:	e0bff817 	ldw	r2,-32(fp)
81105cc8:	1884c03a 	cmpne	r2,r3,r2
81105ccc:	10803fcc 	andi	r2,r2,255
81105cd0:	100f883a 	mov	r7,r2
81105cd4:	200d883a 	mov	r6,r4
81105cd8:	e17ffc17 	ldw	r5,-16(fp)
81105cdc:	e13ffb17 	ldw	r4,-20(fp)
81105ce0:	1105f740 	call	81105f74 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
81105ce4:	e0bff817 	ldw	r2,-32(fp)
81105ce8:	10800044 	addi	r2,r2,1
81105cec:	e0bff815 	stw	r2,-32(fp)
81105cf0:	e0bfff0b 	ldhu	r2,-4(fp)
81105cf4:	e0fff817 	ldw	r3,-32(fp)
81105cf8:	1880020e 	bge	r3,r2,81105d04 <I2C_MultipleRead+0x13c>
81105cfc:	e0bff917 	ldw	r2,-28(fp)
81105d00:	103feb1e 	bne	r2,zero,81105cb0 <__reset+0xfb0e5cb0>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
81105d04:	e17ffc17 	ldw	r5,-16(fp)
81105d08:	e13ffb17 	ldw	r4,-20(fp)
81105d0c:	1105dbc0 	call	81105dbc <i2c_stop>
    
    return bSuccess;    
81105d10:	e0bff917 	ldw	r2,-28(fp)
    
}
81105d14:	e037883a 	mov	sp,fp
81105d18:	dfc00117 	ldw	ra,4(sp)
81105d1c:	df000017 	ldw	fp,0(sp)
81105d20:	dec00204 	addi	sp,sp,8
81105d24:	f800283a 	ret

81105d28 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
81105d28:	defffc04 	addi	sp,sp,-16
81105d2c:	de00012e 	bgeu	sp,et,81105d34 <i2c_start+0xc>
81105d30:	003b68fa 	trap	3
81105d34:	dfc00315 	stw	ra,12(sp)
81105d38:	df000215 	stw	fp,8(sp)
81105d3c:	df000204 	addi	fp,sp,8
81105d40:	e13ffe15 	stw	r4,-8(fp)
81105d44:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
81105d48:	e0bfff17 	ldw	r2,-4(fp)
81105d4c:	10800104 	addi	r2,r2,4
81105d50:	1007883a 	mov	r3,r2
81105d54:	00800044 	movi	r2,1
81105d58:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
81105d5c:	e0bfff17 	ldw	r2,-4(fp)
81105d60:	00c00044 	movi	r3,1
81105d64:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
81105d68:	e0bffe17 	ldw	r2,-8(fp)
81105d6c:	00c00044 	movi	r3,1
81105d70:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81105d74:	01000044 	movi	r4,1
81105d78:	1128bec0 	call	81128bec <usleep>
     
    SDA_LOW(data_base); // data low
81105d7c:	e0bfff17 	ldw	r2,-4(fp)
81105d80:	0007883a 	mov	r3,zero
81105d84:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
81105d88:	01000044 	movi	r4,1
81105d8c:	1128bec0 	call	81128bec <usleep>
    SCL_LOW(clk_base); // clock low
81105d90:	e0bffe17 	ldw	r2,-8(fp)
81105d94:	0007883a 	mov	r3,zero
81105d98:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81105d9c:	01000044 	movi	r4,1
81105da0:	1128bec0 	call	81128bec <usleep>
}
81105da4:	0001883a 	nop
81105da8:	e037883a 	mov	sp,fp
81105dac:	dfc00117 	ldw	ra,4(sp)
81105db0:	df000017 	ldw	fp,0(sp)
81105db4:	dec00204 	addi	sp,sp,8
81105db8:	f800283a 	ret

81105dbc <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
81105dbc:	defffc04 	addi	sp,sp,-16
81105dc0:	de00012e 	bgeu	sp,et,81105dc8 <i2c_stop+0xc>
81105dc4:	003b68fa 	trap	3
81105dc8:	dfc00315 	stw	ra,12(sp)
81105dcc:	df000215 	stw	fp,8(sp)
81105dd0:	df000204 	addi	fp,sp,8
81105dd4:	e13ffe15 	stw	r4,-8(fp)
81105dd8:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
81105ddc:	e0bfff17 	ldw	r2,-4(fp)
81105de0:	10800104 	addi	r2,r2,4
81105de4:	1007883a 	mov	r3,r2
81105de8:	00800044 	movi	r2,1
81105dec:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
81105df0:	e0bfff17 	ldw	r2,-4(fp)
81105df4:	0007883a 	mov	r3,zero
81105df8:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
81105dfc:	e0bffe17 	ldw	r2,-8(fp)
81105e00:	00c00044 	movi	r3,1
81105e04:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
81105e08:	01000044 	movi	r4,1
81105e0c:	1128bec0 	call	81128bec <usleep>
    SDA_HIGH(data_base); // data high
81105e10:	e0bfff17 	ldw	r2,-4(fp)
81105e14:	00c00044 	movi	r3,1
81105e18:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
81105e1c:	01000044 	movi	r4,1
81105e20:	1128bec0 	call	81128bec <usleep>
    

    
}
81105e24:	0001883a 	nop
81105e28:	e037883a 	mov	sp,fp
81105e2c:	dfc00117 	ldw	ra,4(sp)
81105e30:	df000017 	ldw	fp,0(sp)
81105e34:	dec00204 	addi	sp,sp,8
81105e38:	f800283a 	ret

81105e3c <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
81105e3c:	defff804 	addi	sp,sp,-32
81105e40:	de00012e 	bgeu	sp,et,81105e48 <i2c_write+0xc>
81105e44:	003b68fa 	trap	3
81105e48:	dfc00715 	stw	ra,28(sp)
81105e4c:	df000615 	stw	fp,24(sp)
81105e50:	df000604 	addi	fp,sp,24
81105e54:	e13ffd15 	stw	r4,-12(fp)
81105e58:	e17ffe15 	stw	r5,-8(fp)
81105e5c:	3005883a 	mov	r2,r6
81105e60:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
81105e64:	00bfe004 	movi	r2,-128
81105e68:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
81105e6c:	e0bffe17 	ldw	r2,-8(fp)
81105e70:	10800104 	addi	r2,r2,4
81105e74:	1007883a 	mov	r3,r2
81105e78:	00800044 	movi	r2,1
81105e7c:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
81105e80:	e03ffb15 	stw	zero,-20(fp)
81105e84:	00001f06 	br	81105f04 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
81105e88:	e0bffd17 	ldw	r2,-12(fp)
81105e8c:	0007883a 	mov	r3,zero
81105e90:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
81105e94:	e0ffff03 	ldbu	r3,-4(fp)
81105e98:	e0bffa03 	ldbu	r2,-24(fp)
81105e9c:	1884703a 	and	r2,r3,r2
81105ea0:	10803fcc 	andi	r2,r2,255
81105ea4:	10000426 	beq	r2,zero,81105eb8 <i2c_write+0x7c>
            SDA_HIGH(data_base);
81105ea8:	e0bffe17 	ldw	r2,-8(fp)
81105eac:	00c00044 	movi	r3,1
81105eb0:	10c00035 	stwio	r3,0(r2)
81105eb4:	00000306 	br	81105ec4 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
81105eb8:	e0bffe17 	ldw	r2,-8(fp)
81105ebc:	0007883a 	mov	r3,zero
81105ec0:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
81105ec4:	e0bffa03 	ldbu	r2,-24(fp)
81105ec8:	1004d07a 	srli	r2,r2,1
81105ecc:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
81105ed0:	e0bffd17 	ldw	r2,-12(fp)
81105ed4:	00c00044 	movi	r3,1
81105ed8:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81105edc:	01000044 	movi	r4,1
81105ee0:	1128bec0 	call	81128bec <usleep>
        SCL_LOW(clk_base);
81105ee4:	e0bffd17 	ldw	r2,-12(fp)
81105ee8:	0007883a 	mov	r3,zero
81105eec:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81105ef0:	01000044 	movi	r4,1
81105ef4:	1128bec0 	call	81128bec <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
81105ef8:	e0bffb17 	ldw	r2,-20(fp)
81105efc:	10800044 	addi	r2,r2,1
81105f00:	e0bffb15 	stw	r2,-20(fp)
81105f04:	e0bffb17 	ldw	r2,-20(fp)
81105f08:	10800210 	cmplti	r2,r2,8
81105f0c:	103fde1e 	bne	r2,zero,81105e88 <__reset+0xfb0e5e88>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
81105f10:	e0bffe17 	ldw	r2,-8(fp)
81105f14:	10800104 	addi	r2,r2,4
81105f18:	0007883a 	mov	r3,zero
81105f1c:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
81105f20:	e0bffd17 	ldw	r2,-12(fp)
81105f24:	00c00044 	movi	r3,1
81105f28:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
81105f2c:	01000044 	movi	r4,1
81105f30:	1128bec0 	call	81128bec <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
81105f34:	e0bffe17 	ldw	r2,-8(fp)
81105f38:	10800037 	ldwio	r2,0(r2)
81105f3c:	1005003a 	cmpeq	r2,r2,zero
81105f40:	10803fcc 	andi	r2,r2,255
81105f44:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
81105f48:	e0bffd17 	ldw	r2,-12(fp)
81105f4c:	0007883a 	mov	r3,zero
81105f50:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81105f54:	01000044 	movi	r4,1
81105f58:	1128bec0 	call	81128bec <usleep>
    return bAck;
81105f5c:	e0bffc17 	ldw	r2,-16(fp)
}    
81105f60:	e037883a 	mov	sp,fp
81105f64:	dfc00117 	ldw	ra,4(sp)
81105f68:	df000017 	ldw	fp,0(sp)
81105f6c:	dec00204 	addi	sp,sp,8
81105f70:	f800283a 	ret

81105f74 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
81105f74:	defff804 	addi	sp,sp,-32
81105f78:	de00012e 	bgeu	sp,et,81105f80 <i2c_read+0xc>
81105f7c:	003b68fa 	trap	3
81105f80:	dfc00715 	stw	ra,28(sp)
81105f84:	df000615 	stw	fp,24(sp)
81105f88:	df000604 	addi	fp,sp,24
81105f8c:	e13ffc15 	stw	r4,-16(fp)
81105f90:	e17ffd15 	stw	r5,-12(fp)
81105f94:	e1bffe15 	stw	r6,-8(fp)
81105f98:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
81105f9c:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
81105fa0:	e0bffd17 	ldw	r2,-12(fp)
81105fa4:	10800104 	addi	r2,r2,4
81105fa8:	0007883a 	mov	r3,zero
81105fac:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
81105fb0:	e0bffc17 	ldw	r2,-16(fp)
81105fb4:	0007883a 	mov	r3,zero
81105fb8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81105fbc:	01000044 	movi	r4,1
81105fc0:	1128bec0 	call	81128bec <usleep>

    for(i=0;i<8;i++){
81105fc4:	e03ffb15 	stw	zero,-20(fp)
81105fc8:	00001606 	br	81106024 <i2c_read+0xb0>
        Data <<= 1;
81105fcc:	e0bffa03 	ldbu	r2,-24(fp)
81105fd0:	1085883a 	add	r2,r2,r2
81105fd4:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
81105fd8:	e0bffc17 	ldw	r2,-16(fp)
81105fdc:	00c00044 	movi	r3,1
81105fe0:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81105fe4:	01000044 	movi	r4,1
81105fe8:	1128bec0 	call	81128bec <usleep>
        if (SDA_READ(data_base))  // read data   
81105fec:	e0bffd17 	ldw	r2,-12(fp)
81105ff0:	10800037 	ldwio	r2,0(r2)
81105ff4:	10000326 	beq	r2,zero,81106004 <i2c_read+0x90>
            Data |= 0x01;
81105ff8:	e0bffa03 	ldbu	r2,-24(fp)
81105ffc:	10800054 	ori	r2,r2,1
81106000:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
81106004:	e0bffc17 	ldw	r2,-16(fp)
81106008:	0007883a 	mov	r3,zero
8110600c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81106010:	01000044 	movi	r4,1
81106014:	1128bec0 	call	81128bec <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
81106018:	e0bffb17 	ldw	r2,-20(fp)
8110601c:	10800044 	addi	r2,r2,1
81106020:	e0bffb15 	stw	r2,-20(fp)
81106024:	e0bffb17 	ldw	r2,-20(fp)
81106028:	10800210 	cmplti	r2,r2,8
8110602c:	103fe71e 	bne	r2,zero,81105fcc <__reset+0xfb0e5fcc>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
81106030:	e0bffc17 	ldw	r2,-16(fp)
81106034:	0007883a 	mov	r3,zero
81106038:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110603c:	e0bffd17 	ldw	r2,-12(fp)
81106040:	10800104 	addi	r2,r2,4
81106044:	1007883a 	mov	r3,r2
81106048:	00800044 	movi	r2,1
8110604c:	18800035 	stwio	r2,0(r3)
    if (bAck)
81106050:	e0bfff17 	ldw	r2,-4(fp)
81106054:	10000426 	beq	r2,zero,81106068 <i2c_read+0xf4>
        SDA_LOW(data_base);
81106058:	e0bffd17 	ldw	r2,-12(fp)
8110605c:	0007883a 	mov	r3,zero
81106060:	10c00035 	stwio	r3,0(r2)
81106064:	00000306 	br	81106074 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
81106068:	e0bffd17 	ldw	r2,-12(fp)
8110606c:	00c00044 	movi	r3,1
81106070:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
81106074:	e0bffc17 	ldw	r2,-16(fp)
81106078:	00c00044 	movi	r3,1
8110607c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
81106080:	01000044 	movi	r4,1
81106084:	1128bec0 	call	81128bec <usleep>
    SCL_LOW(clk_base); // clock low
81106088:	e0bffc17 	ldw	r2,-16(fp)
8110608c:	0007883a 	mov	r3,zero
81106090:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81106094:	01000044 	movi	r4,1
81106098:	1128bec0 	call	81128bec <usleep>
    SDA_LOW(data_base);  // data low
8110609c:	e0bffd17 	ldw	r2,-12(fp)
811060a0:	0007883a 	mov	r3,zero
811060a4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
811060a8:	01000044 	movi	r4,1
811060ac:	1128bec0 	call	81128bec <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
811060b0:	e0bffe17 	ldw	r2,-8(fp)
811060b4:	e0fffa03 	ldbu	r3,-24(fp)
811060b8:	10c00005 	stb	r3,0(r2)
}
811060bc:	0001883a 	nop
811060c0:	e037883a 	mov	sp,fp
811060c4:	dfc00117 	ldw	ra,4(sp)
811060c8:	df000017 	ldw	fp,0(sp)
811060cc:	dec00204 	addi	sp,sp,8
811060d0:	f800283a 	ret

811060d4 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
811060d4:	defffd04 	addi	sp,sp,-12
811060d8:	de00012e 	bgeu	sp,et,811060e0 <bSetBoardLeds+0xc>
811060dc:	003b68fa 	trap	3
811060e0:	df000215 	stw	fp,8(sp)
811060e4:	df000204 	addi	fp,sp,8
811060e8:	e13ffe15 	stw	r4,-8(fp)
811060ec:	2805883a 	mov	r2,r5
811060f0:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
811060f4:	e0bffe17 	ldw	r2,-8(fp)
811060f8:	10800058 	cmpnei	r2,r2,1
811060fc:	1000071e 	bne	r2,zero,8110611c <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
81106100:	e0bfff03 	ldbu	r2,-4(fp)
81106104:	0084303a 	nor	r2,zero,r2
81106108:	1007883a 	mov	r3,r2
8110610c:	d0a04503 	ldbu	r2,-32492(gp)
81106110:	1884703a 	and	r2,r3,r2
81106114:	d0a04505 	stb	r2,-32492(gp)
81106118:	00000406 	br	8110612c <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110611c:	d0e04503 	ldbu	r3,-32492(gp)
81106120:	e0bfff03 	ldbu	r2,-4(fp)
81106124:	1884b03a 	or	r2,r3,r2
81106128:	d0a04505 	stb	r2,-32492(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110612c:	d0a04503 	ldbu	r2,-32492(gp)
81106130:	10c03fcc 	andi	r3,r2,255
81106134:	00a00034 	movhi	r2,32768
81106138:	10827404 	addi	r2,r2,2512
8110613c:	10c00035 	stwio	r3,0(r2)

  return TRUE;
81106140:	00800044 	movi	r2,1
}
81106144:	e037883a 	mov	sp,fp
81106148:	df000017 	ldw	fp,0(sp)
8110614c:	dec00104 	addi	sp,sp,4
81106150:	f800283a 	ret

81106154 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
81106154:	defffd04 	addi	sp,sp,-12
81106158:	de00012e 	bgeu	sp,et,81106160 <bSetPainelLeds+0xc>
8110615c:	003b68fa 	trap	3
81106160:	df000215 	stw	fp,8(sp)
81106164:	df000204 	addi	fp,sp,8
81106168:	e13ffe15 	stw	r4,-8(fp)
8110616c:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
81106170:	e0bffe17 	ldw	r2,-8(fp)
81106174:	10800058 	cmpnei	r2,r2,1
81106178:	1000051e 	bne	r2,zero,81106190 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110617c:	d0e00217 	ldw	r3,-32760(gp)
81106180:	e0bfff17 	ldw	r2,-4(fp)
81106184:	1884b03a 	or	r2,r3,r2
81106188:	d0a00215 	stw	r2,-32760(gp)
8110618c:	00000506 	br	811061a4 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
81106190:	e0bfff17 	ldw	r2,-4(fp)
81106194:	0086303a 	nor	r3,zero,r2
81106198:	d0a00217 	ldw	r2,-32760(gp)
8110619c:	1884703a 	and	r2,r3,r2
811061a0:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
811061a4:	d0a00217 	ldw	r2,-32760(gp)
811061a8:	1007883a 	mov	r3,r2
811061ac:	00a00034 	movhi	r2,32768
811061b0:	10824004 	addi	r2,r2,2304
811061b4:	10c00035 	stwio	r3,0(r2)

  return TRUE;
811061b8:	00800044 	movi	r2,1
}
811061bc:	e037883a 	mov	sp,fp
811061c0:	df000017 	ldw	fp,0(sp)
811061c4:	dec00104 	addi	sp,sp,4
811061c8:	f800283a 	ret

811061cc <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
811061cc:	defffc04 	addi	sp,sp,-16
811061d0:	de00012e 	bgeu	sp,et,811061d8 <msgdma_write_extended_descriptor+0xc>
811061d4:	003b68fa 	trap	3
811061d8:	df000315 	stw	fp,12(sp)
811061dc:	df000304 	addi	fp,sp,12
811061e0:	e13ffd15 	stw	r4,-12(fp)
811061e4:	e17ffe15 	stw	r5,-8(fp)
811061e8:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
811061ec:	e0bffd17 	ldw	r2,-12(fp)
811061f0:	10800037 	ldwio	r2,0(r2)
811061f4:	1080010c 	andi	r2,r2,4
811061f8:	10000226 	beq	r2,zero,81106204 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
811061fc:	00bff904 	movi	r2,-28
81106200:	00003d06 	br	811062f8 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
81106204:	e0bfff17 	ldw	r2,-4(fp)
81106208:	10800017 	ldw	r2,0(r2)
8110620c:	1007883a 	mov	r3,r2
81106210:	e0bffe17 	ldw	r2,-8(fp)
81106214:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
81106218:	e0bffe17 	ldw	r2,-8(fp)
8110621c:	10800104 	addi	r2,r2,4
81106220:	e0ffff17 	ldw	r3,-4(fp)
81106224:	18c00117 	ldw	r3,4(r3)
81106228:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110622c:	e0bffe17 	ldw	r2,-8(fp)
81106230:	10800204 	addi	r2,r2,8
81106234:	e0ffff17 	ldw	r3,-4(fp)
81106238:	18c00217 	ldw	r3,8(r3)
8110623c:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
81106240:	e0bffe17 	ldw	r2,-8(fp)
81106244:	10800304 	addi	r2,r2,12
81106248:	e0ffff17 	ldw	r3,-4(fp)
8110624c:	18c0030b 	ldhu	r3,12(r3)
81106250:	18ffffcc 	andi	r3,r3,65535
81106254:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
81106258:	e0bffe17 	ldw	r2,-8(fp)
8110625c:	10800384 	addi	r2,r2,14
81106260:	e0ffff17 	ldw	r3,-4(fp)
81106264:	18c00383 	ldbu	r3,14(r3)
81106268:	18c03fcc 	andi	r3,r3,255
8110626c:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
81106270:	e0bffe17 	ldw	r2,-8(fp)
81106274:	108003c4 	addi	r2,r2,15
81106278:	e0ffff17 	ldw	r3,-4(fp)
8110627c:	18c003c3 	ldbu	r3,15(r3)
81106280:	18c03fcc 	andi	r3,r3,255
81106284:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
81106288:	e0bffe17 	ldw	r2,-8(fp)
8110628c:	10800404 	addi	r2,r2,16
81106290:	e0ffff17 	ldw	r3,-4(fp)
81106294:	18c0040b 	ldhu	r3,16(r3)
81106298:	18ffffcc 	andi	r3,r3,65535
8110629c:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
811062a0:	e0bffe17 	ldw	r2,-8(fp)
811062a4:	10800484 	addi	r2,r2,18
811062a8:	e0ffff17 	ldw	r3,-4(fp)
811062ac:	18c0048b 	ldhu	r3,18(r3)
811062b0:	18ffffcc 	andi	r3,r3,65535
811062b4:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
811062b8:	e0bffe17 	ldw	r2,-8(fp)
811062bc:	10800504 	addi	r2,r2,20
811062c0:	e0ffff17 	ldw	r3,-4(fp)
811062c4:	18c00517 	ldw	r3,20(r3)
811062c8:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
811062cc:	e0bffe17 	ldw	r2,-8(fp)
811062d0:	10800604 	addi	r2,r2,24
811062d4:	e0ffff17 	ldw	r3,-4(fp)
811062d8:	18c00617 	ldw	r3,24(r3)
811062dc:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
811062e0:	e0bffe17 	ldw	r2,-8(fp)
811062e4:	10800704 	addi	r2,r2,28
811062e8:	e0ffff17 	ldw	r3,-4(fp)
811062ec:	18c00717 	ldw	r3,28(r3)
811062f0:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
811062f4:	0005883a 	mov	r2,zero
}
811062f8:	e037883a 	mov	sp,fp
811062fc:	df000017 	ldw	fp,0(sp)
81106300:	dec00104 	addi	sp,sp,4
81106304:	f800283a 	ret

81106308 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
81106308:	defff604 	addi	sp,sp,-40
8110630c:	de00012e 	bgeu	sp,et,81106314 <msgdma_construct_extended_descriptor+0xc>
81106310:	003b68fa 	trap	3
81106314:	df000915 	stw	fp,36(sp)
81106318:	df000904 	addi	fp,sp,36
8110631c:	e13ff715 	stw	r4,-36(fp)
81106320:	e17ff815 	stw	r5,-32(fp)
81106324:	e1bff915 	stw	r6,-28(fp)
81106328:	e1fffa15 	stw	r7,-24(fp)
8110632c:	e1800517 	ldw	r6,20(fp)
81106330:	e1400617 	ldw	r5,24(fp)
81106334:	e1000717 	ldw	r4,28(fp)
81106338:	e0c00817 	ldw	r3,32(fp)
8110633c:	e0800917 	ldw	r2,36(fp)
81106340:	e1bffb0d 	sth	r6,-20(fp)
81106344:	e17ffc05 	stb	r5,-16(fp)
81106348:	e13ffd05 	stb	r4,-12(fp)
8110634c:	e0fffe0d 	sth	r3,-8(fp)
81106350:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
81106354:	e0bff717 	ldw	r2,-36(fp)
81106358:	10c01217 	ldw	r3,72(r2)
8110635c:	e0800117 	ldw	r2,4(fp)
81106360:	18801936 	bltu	r3,r2,811063c8 <msgdma_construct_extended_descriptor+0xc0>
81106364:	e13ff717 	ldw	r4,-36(fp)
81106368:	20801317 	ldw	r2,76(r4)
8110636c:	20c01417 	ldw	r3,80(r4)
81106370:	e13ffe0b 	ldhu	r4,-8(fp)
81106374:	213fffcc 	andi	r4,r4,65535
81106378:	2015883a 	mov	r10,r4
8110637c:	0017883a 	mov	r11,zero
81106380:	1ac01136 	bltu	r3,r11,811063c8 <msgdma_construct_extended_descriptor+0xc0>
81106384:	58c0011e 	bne	r11,r3,8110638c <msgdma_construct_extended_descriptor+0x84>
81106388:	12800f36 	bltu	r2,r10,811063c8 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110638c:	e13ff717 	ldw	r4,-36(fp)
81106390:	20801317 	ldw	r2,76(r4)
81106394:	20c01417 	ldw	r3,80(r4)
81106398:	e13fff0b 	ldhu	r4,-4(fp)
8110639c:	213fffcc 	andi	r4,r4,65535
811063a0:	2011883a 	mov	r8,r4
811063a4:	0013883a 	mov	r9,zero
811063a8:	1a400736 	bltu	r3,r9,811063c8 <msgdma_construct_extended_descriptor+0xc0>
811063ac:	48c0011e 	bne	r9,r3,811063b4 <msgdma_construct_extended_descriptor+0xac>
811063b0:	12000536 	bltu	r2,r8,811063c8 <msgdma_construct_extended_descriptor+0xc0>
811063b4:	e0bff717 	ldw	r2,-36(fp)
811063b8:	10801703 	ldbu	r2,92(r2)
811063bc:	10803fcc 	andi	r2,r2,255
811063c0:	10800060 	cmpeqi	r2,r2,1
811063c4:	1000021e 	bne	r2,zero,811063d0 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
811063c8:	00bffa84 	movi	r2,-22
811063cc:	00002306 	br	8110645c <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
811063d0:	e0bff817 	ldw	r2,-32(fp)
811063d4:	e0fff917 	ldw	r3,-28(fp)
811063d8:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
811063dc:	e0bff817 	ldw	r2,-32(fp)
811063e0:	e0fffa17 	ldw	r3,-24(fp)
811063e4:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
811063e8:	e0bff817 	ldw	r2,-32(fp)
811063ec:	e0c00117 	ldw	r3,4(fp)
811063f0:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
811063f4:	e0bff817 	ldw	r2,-32(fp)
811063f8:	e0fffb0b 	ldhu	r3,-20(fp)
811063fc:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
81106400:	e0bff817 	ldw	r2,-32(fp)
81106404:	e0fffc03 	ldbu	r3,-16(fp)
81106408:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110640c:	e0bff817 	ldw	r2,-32(fp)
81106410:	e0fffd03 	ldbu	r3,-12(fp)
81106414:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
81106418:	e0bff817 	ldw	r2,-32(fp)
8110641c:	e0fffe0b 	ldhu	r3,-8(fp)
81106420:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
81106424:	e0bff817 	ldw	r2,-32(fp)
81106428:	e0ffff0b 	ldhu	r3,-4(fp)
8110642c:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
81106430:	e0bff817 	ldw	r2,-32(fp)
81106434:	e0c00317 	ldw	r3,12(fp)
81106438:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110643c:	e0bff817 	ldw	r2,-32(fp)
81106440:	e0c00417 	ldw	r3,16(fp)
81106444:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81106448:	e0800217 	ldw	r2,8(fp)
8110644c:	10e00034 	orhi	r3,r2,32768
81106450:	e0bff817 	ldw	r2,-32(fp)
81106454:	10c00715 	stw	r3,28(r2)

	return 0;
81106458:	0005883a 	mov	r2,zero

}
8110645c:	e037883a 	mov	sp,fp
81106460:	df000017 	ldw	fp,0(sp)
81106464:	dec00104 	addi	sp,sp,4
81106468:	f800283a 	ret

8110646c <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110646c:	deffee04 	addi	sp,sp,-72
81106470:	de00012e 	bgeu	sp,et,81106478 <msgdma_descriptor_async_transfer+0xc>
81106474:	003b68fa 	trap	3
81106478:	dfc01115 	stw	ra,68(sp)
8110647c:	df001015 	stw	fp,64(sp)
81106480:	df001004 	addi	fp,sp,64
81106484:	e13ffd15 	stw	r4,-12(fp)
81106488:	e17ffe15 	stw	r5,-8(fp)
8110648c:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
81106490:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
81106494:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
81106498:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110649c:	e0bffd17 	ldw	r2,-12(fp)
811064a0:	10800317 	ldw	r2,12(r2)
811064a4:	10800204 	addi	r2,r2,8
811064a8:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
811064ac:	10bfffcc 	andi	r2,r2,65535
811064b0:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
811064b4:	e0bffd17 	ldw	r2,-12(fp)
811064b8:	10800317 	ldw	r2,12(r2)
811064bc:	10800204 	addi	r2,r2,8
811064c0:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
811064c4:	1004d43a 	srli	r2,r2,16
811064c8:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
811064cc:	e0bffd17 	ldw	r2,-12(fp)
811064d0:	10800917 	ldw	r2,36(r2)
811064d4:	e0fff417 	ldw	r3,-48(fp)
811064d8:	1880042e 	bgeu	r3,r2,811064ec <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
811064dc:	e0bffd17 	ldw	r2,-12(fp)
811064e0:	10800917 	ldw	r2,36(r2)
811064e4:	e0fff317 	ldw	r3,-52(fp)
811064e8:	18800236 	bltu	r3,r2,811064f4 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
811064ec:	00bff904 	movi	r2,-28
811064f0:	00009f06 	br	81106770 <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
811064f4:	e0bffd17 	ldw	r2,-12(fp)
811064f8:	10801817 	ldw	r2,96(r2)
811064fc:	e0bff615 	stw	r2,-40(fp)
81106500:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81106504:	e0bffc0b 	ldhu	r2,-16(fp)
81106508:	e0fffc84 	addi	r3,fp,-14
8110650c:	180d883a 	mov	r6,r3
81106510:	100b883a 	mov	r5,r2
81106514:	e13ff617 	ldw	r4,-40(fp)
81106518:	112fa680 	call	8112fa68 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110651c:	00800804 	movi	r2,32
81106520:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106524:	0005303a 	rdctl	r2,status
81106528:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110652c:	e0fff717 	ldw	r3,-36(fp)
81106530:	00bfff84 	movi	r2,-2
81106534:	1884703a 	and	r2,r3,r2
81106538:	1001703a 	wrctl	status,r2
  
  return context;
8110653c:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81106540:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81106544:	e0bffd17 	ldw	r2,-12(fp)
81106548:	10800317 	ldw	r2,12(r2)
8110654c:	10800104 	addi	r2,r2,4
81106550:	e0fff117 	ldw	r3,-60(fp)
81106554:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81106558:	e0bffd17 	ldw	r2,-12(fp)
8110655c:	10800317 	ldw	r2,12(r2)
81106560:	e0fffd17 	ldw	r3,-12(fp)
81106564:	18c00317 	ldw	r3,12(r3)
81106568:	18c00037 	ldwio	r3,0(r3)
8110656c:	10c00035 	stwio	r3,0(r2)
81106570:	e0bff217 	ldw	r2,-56(fp)
81106574:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81106578:	e0bffb17 	ldw	r2,-20(fp)
8110657c:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
81106580:	e0bffe17 	ldw	r2,-8(fp)
81106584:	10001026 	beq	r2,zero,811065c8 <msgdma_descriptor_async_transfer+0x15c>
81106588:	e0bfff17 	ldw	r2,-4(fp)
8110658c:	10000e1e 	bne	r2,zero,811065c8 <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
81106590:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
81106594:	d0a04e17 	ldw	r2,-32456(gp)
81106598:	100f883a 	mov	r7,r2
8110659c:	01800784 	movi	r6,30
811065a0:	01400044 	movi	r5,1
811065a4:	01204534 	movhi	r4,33044
811065a8:	21354804 	addi	r4,r4,-10976
811065ac:	1112ccc0 	call	81112ccc <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
811065b0:	e0bffd17 	ldw	r2,-12(fp)
811065b4:	10801817 	ldw	r2,96(r2)
811065b8:	1009883a 	mov	r4,r2
811065bc:	112fdf00 	call	8112fdf0 <OSSemPost>

		return -ETIME;
811065c0:	00bff084 	movi	r2,-62
811065c4:	00006a06 	br	81106770 <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
811065c8:	e0bffe17 	ldw	r2,-8(fp)
811065cc:	1000231e 	bne	r2,zero,8110665c <msgdma_descriptor_async_transfer+0x1f0>
811065d0:	e0bfff17 	ldw	r2,-4(fp)
811065d4:	10002126 	beq	r2,zero,8110665c <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
811065d8:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
811065dc:	00001506 	br	81106634 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
811065e0:	01000044 	movi	r4,1
811065e4:	1127d1c0 	call	81127d1c <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
811065e8:	e0bff00b 	ldhu	r2,-64(fp)
811065ec:	1084e230 	cmpltui	r2,r2,5000
811065f0:	10000d1e 	bne	r2,zero,81106628 <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
811065f4:	d0a04e17 	ldw	r2,-32456(gp)
811065f8:	100f883a 	mov	r7,r2
811065fc:	01801544 	movi	r6,85
81106600:	01400044 	movi	r5,1
81106604:	01204534 	movhi	r4,33044
81106608:	21355004 	addi	r4,r4,-10944
8110660c:	1112ccc0 	call	81112ccc <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
81106610:	e0bffd17 	ldw	r2,-12(fp)
81106614:	10801817 	ldw	r2,96(r2)
81106618:	1009883a 	mov	r4,r2
8110661c:	112fdf00 	call	8112fdf0 <OSSemPost>

				return -ETIME;
81106620:	00bff084 	movi	r2,-62
81106624:	00005206 	br	81106770 <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
81106628:	e0bff00b 	ldhu	r2,-64(fp)
8110662c:	10800044 	addi	r2,r2,1
81106630:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
81106634:	e0bffd17 	ldw	r2,-12(fp)
81106638:	10c00317 	ldw	r3,12(r2)
8110663c:	e0bffd17 	ldw	r2,-12(fp)
81106640:	10800417 	ldw	r2,16(r2)
81106644:	e1bfff17 	ldw	r6,-4(fp)
81106648:	100b883a 	mov	r5,r2
8110664c:	1809883a 	mov	r4,r3
81106650:	11061cc0 	call	811061cc <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
81106654:	103fe21e 	bne	r2,zero,811065e0 <__reset+0xfb0e65e0>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
81106658:	00000606 	br	81106674 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110665c:	e0bffd17 	ldw	r2,-12(fp)
81106660:	10801817 	ldw	r2,96(r2)
81106664:	1009883a 	mov	r4,r2
81106668:	112fdf00 	call	8112fdf0 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110666c:	00bfffc4 	movi	r2,-1
81106670:	00003f06 	br	81106770 <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
81106674:	e0bffd17 	ldw	r2,-12(fp)
81106678:	10800b17 	ldw	r2,44(r2)
8110667c:	10001c26 	beq	r2,zero,811066f0 <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
81106680:	e0bffd17 	ldw	r2,-12(fp)
81106684:	10c00d17 	ldw	r3,52(r2)
81106688:	e0bff117 	ldw	r2,-60(fp)
8110668c:	1884b03a 	or	r2,r3,r2
81106690:	10800514 	ori	r2,r2,20
81106694:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81106698:	e0fff117 	ldw	r3,-60(fp)
8110669c:	00bff7c4 	movi	r2,-33
811066a0:	1884703a 	and	r2,r3,r2
811066a4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811066a8:	0005303a 	rdctl	r2,status
811066ac:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811066b0:	e0fff917 	ldw	r3,-28(fp)
811066b4:	00bfff84 	movi	r2,-2
811066b8:	1884703a 	and	r2,r3,r2
811066bc:	1001703a 	wrctl	status,r2
  
  return context;
811066c0:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
811066c4:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811066c8:	e0bffd17 	ldw	r2,-12(fp)
811066cc:	10800317 	ldw	r2,12(r2)
811066d0:	10800104 	addi	r2,r2,4
811066d4:	e0fff117 	ldw	r3,-60(fp)
811066d8:	10c00035 	stwio	r3,0(r2)
811066dc:	e0bff217 	ldw	r2,-56(fp)
811066e0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811066e4:	e0bff517 	ldw	r2,-44(fp)
811066e8:	1001703a 	wrctl	status,r2
811066ec:	00001b06 	br	8110675c <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
811066f0:	e0bffd17 	ldw	r2,-12(fp)
811066f4:	10c00d17 	ldw	r3,52(r2)
811066f8:	e0bff117 	ldw	r2,-60(fp)
811066fc:	1884b03a 	or	r2,r3,r2
81106700:	10800114 	ori	r2,r2,4
81106704:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
81106708:	e0fff117 	ldw	r3,-60(fp)
8110670c:	00bff3c4 	movi	r2,-49
81106710:	1884703a 	and	r2,r3,r2
81106714:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106718:	0005303a 	rdctl	r2,status
8110671c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81106720:	e0fffa17 	ldw	r3,-24(fp)
81106724:	00bfff84 	movi	r2,-2
81106728:	1884703a 	and	r2,r3,r2
8110672c:	1001703a 	wrctl	status,r2
  
  return context;
81106730:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
81106734:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81106738:	e0bffd17 	ldw	r2,-12(fp)
8110673c:	10800317 	ldw	r2,12(r2)
81106740:	10800104 	addi	r2,r2,4
81106744:	e0fff117 	ldw	r3,-60(fp)
81106748:	10c00035 	stwio	r3,0(r2)
8110674c:	e0bff217 	ldw	r2,-56(fp)
81106750:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81106754:	e0bff817 	ldw	r2,-32(fp)
81106758:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110675c:	e0bffd17 	ldw	r2,-12(fp)
81106760:	10801817 	ldw	r2,96(r2)
81106764:	1009883a 	mov	r4,r2
81106768:	112fdf00 	call	8112fdf0 <OSSemPost>

	return 0;
8110676c:	0005883a 	mov	r2,zero
}
81106770:	e037883a 	mov	sp,fp
81106774:	dfc00117 	ldw	ra,4(sp)
81106778:	df000017 	ldw	fp,0(sp)
8110677c:	dec00204 	addi	sp,sp,8
81106780:	f800283a 	ret

81106784 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
81106784:	deffee04 	addi	sp,sp,-72
81106788:	de00012e 	bgeu	sp,et,81106790 <msgdma_descriptor_sync_transfer+0xc>
8110678c:	003b68fa 	trap	3
81106790:	dfc01115 	stw	ra,68(sp)
81106794:	df001015 	stw	fp,64(sp)
81106798:	df001004 	addi	fp,sp,64
8110679c:	e13ffd15 	stw	r4,-12(fp)
811067a0:	e17ffe15 	stw	r5,-8(fp)
811067a4:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
811067a8:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
811067ac:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
811067b0:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
811067b4:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
811067b8:	e0bffd17 	ldw	r2,-12(fp)
811067bc:	10800317 	ldw	r2,12(r2)
811067c0:	10800204 	addi	r2,r2,8
811067c4:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
811067c8:	10bfffcc 	andi	r2,r2,65535
811067cc:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
811067d0:	e0bffd17 	ldw	r2,-12(fp)
811067d4:	10800317 	ldw	r2,12(r2)
811067d8:	10800204 	addi	r2,r2,8
811067dc:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
811067e0:	1004d43a 	srli	r2,r2,16
811067e4:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
811067e8:	00807804 	movi	r2,480
811067ec:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
811067f0:	00001d06 	br	81106868 <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
811067f4:	01000044 	movi	r4,1
811067f8:	1127d1c0 	call	81127d1c <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
811067fc:	e0bff10b 	ldhu	r2,-60(fp)
81106800:	1084e230 	cmpltui	r2,r2,5000
81106804:	1000091e 	bne	r2,zero,8110682c <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
81106808:	d0a04e17 	ldw	r2,-32456(gp)
8110680c:	100f883a 	mov	r7,r2
81106810:	01801304 	movi	r6,76
81106814:	01400044 	movi	r5,1
81106818:	01204534 	movhi	r4,33044
8110681c:	21356604 	addi	r4,r4,-10856
81106820:	1112ccc0 	call	81112ccc <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
81106824:	00bff084 	movi	r2,-62
81106828:	0000d006 	br	81106b6c <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110682c:	e0bff10b 	ldhu	r2,-60(fp)
81106830:	10800044 	addi	r2,r2,1
81106834:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81106838:	e0bffd17 	ldw	r2,-12(fp)
8110683c:	10800317 	ldw	r2,12(r2)
81106840:	10800204 	addi	r2,r2,8
81106844:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
81106848:	10bfffcc 	andi	r2,r2,65535
8110684c:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81106850:	e0bffd17 	ldw	r2,-12(fp)
81106854:	10800317 	ldw	r2,12(r2)
81106858:	10800204 	addi	r2,r2,8
8110685c:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
81106860:	1004d43a 	srli	r2,r2,16
81106864:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
81106868:	e0bffd17 	ldw	r2,-12(fp)
8110686c:	10800917 	ldw	r2,36(r2)
81106870:	e0fff317 	ldw	r3,-52(fp)
81106874:	18bfdf2e 	bgeu	r3,r2,811067f4 <__reset+0xfb0e67f4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
81106878:	e0bffd17 	ldw	r2,-12(fp)
8110687c:	10800917 	ldw	r2,36(r2)
81106880:	e0fff217 	ldw	r3,-56(fp)
81106884:	18bfdb2e 	bgeu	r3,r2,811067f4 <__reset+0xfb0e67f4>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
81106888:	e0bffd17 	ldw	r2,-12(fp)
8110688c:	10801817 	ldw	r2,96(r2)
81106890:	e0bff815 	stw	r2,-32(fp)
81106894:	e03ffc0d 	sth	zero,-16(fp)
81106898:	e0bffc0b 	ldhu	r2,-16(fp)
8110689c:	e0fffc84 	addi	r3,fp,-14
811068a0:	180d883a 	mov	r6,r3
811068a4:	100b883a 	mov	r5,r2
811068a8:	e13ff817 	ldw	r4,-32(fp)
811068ac:	112fa680 	call	8112fa68 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811068b0:	0005303a 	rdctl	r2,status
811068b4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811068b8:	e0fffb17 	ldw	r3,-20(fp)
811068bc:	00bfff84 	movi	r2,-2
811068c0:	1884703a 	and	r2,r3,r2
811068c4:	1001703a 	wrctl	status,r2
  
  return context;
811068c8:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
811068cc:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811068d0:	e0bffd17 	ldw	r2,-12(fp)
811068d4:	10800317 	ldw	r2,12(r2)
811068d8:	10800104 	addi	r2,r2,4
811068dc:	00c00804 	movi	r3,32
811068e0:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
811068e4:	e0bffd17 	ldw	r2,-12(fp)
811068e8:	10800317 	ldw	r2,12(r2)
811068ec:	e0fffd17 	ldw	r3,-12(fp)
811068f0:	18c00317 	ldw	r3,12(r3)
811068f4:	18c00037 	ldwio	r3,0(r3)
811068f8:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
811068fc:	e0bffe17 	ldw	r2,-8(fp)
81106900:	10001026 	beq	r2,zero,81106944 <msgdma_descriptor_sync_transfer+0x1c0>
81106904:	e0bfff17 	ldw	r2,-4(fp)
81106908:	10000e1e 	bne	r2,zero,81106944 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
8110690c:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
81106910:	d0a04e17 	ldw	r2,-32456(gp)
81106914:	100f883a 	mov	r7,r2
81106918:	01800784 	movi	r6,30
8110691c:	01400044 	movi	r5,1
81106920:	01204534 	movhi	r4,33044
81106924:	21354804 	addi	r4,r4,-10976
81106928:	1112ccc0 	call	81112ccc <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110692c:	e0bffd17 	ldw	r2,-12(fp)
81106930:	10801817 	ldw	r2,96(r2)
81106934:	1009883a 	mov	r4,r2
81106938:	112fdf00 	call	8112fdf0 <OSSemPost>

		return -ETIME;
8110693c:	00bff084 	movi	r2,-62
81106940:	00008a06 	br	81106b6c <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
81106944:	e0bffe17 	ldw	r2,-8(fp)
81106948:	1000231e 	bne	r2,zero,811069d8 <msgdma_descriptor_sync_transfer+0x254>
8110694c:	e0bfff17 	ldw	r2,-4(fp)
81106950:	10002126 	beq	r2,zero,811069d8 <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
81106954:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
81106958:	00001506 	br	811069b0 <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110695c:	01000044 	movi	r4,1
81106960:	1127d1c0 	call	81127d1c <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81106964:	e0bff10b 	ldhu	r2,-60(fp)
81106968:	1084e230 	cmpltui	r2,r2,5000
8110696c:	10000d1e 	bne	r2,zero,811069a4 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
81106970:	d0a04e17 	ldw	r2,-32456(gp)
81106974:	100f883a 	mov	r7,r2
81106978:	01801004 	movi	r6,64
8110697c:	01400044 	movi	r5,1
81106980:	01204534 	movhi	r4,33044
81106984:	21357a04 	addi	r4,r4,-10776
81106988:	1112ccc0 	call	81112ccc <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110698c:	e0bffd17 	ldw	r2,-12(fp)
81106990:	10801817 	ldw	r2,96(r2)
81106994:	1009883a 	mov	r4,r2
81106998:	112fdf00 	call	8112fdf0 <OSSemPost>

				return -ETIME;
8110699c:	00bff084 	movi	r2,-62
811069a0:	00007206 	br	81106b6c <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
811069a4:	e0bff10b 	ldhu	r2,-60(fp)
811069a8:	10800044 	addi	r2,r2,1
811069ac:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
811069b0:	e0bffd17 	ldw	r2,-12(fp)
811069b4:	10c00317 	ldw	r3,12(r2)
811069b8:	e0bffd17 	ldw	r2,-12(fp)
811069bc:	10800417 	ldw	r2,16(r2)
811069c0:	e1bfff17 	ldw	r6,-4(fp)
811069c4:	100b883a 	mov	r5,r2
811069c8:	1809883a 	mov	r4,r3
811069cc:	11061cc0 	call	811061cc <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
811069d0:	103fe21e 	bne	r2,zero,8110695c <__reset+0xfb0e695c>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
811069d4:	00000606 	br	811069f0 <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
811069d8:	e0bffd17 	ldw	r2,-12(fp)
811069dc:	10801817 	ldw	r2,96(r2)
811069e0:	1009883a 	mov	r4,r2
811069e4:	112fdf00 	call	8112fdf0 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
811069e8:	00bfffc4 	movi	r2,-1
811069ec:	00005f06 	br	81106b6c <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811069f0:	e0bffd17 	ldw	r2,-12(fp)
811069f4:	10800317 	ldw	r2,12(r2)
811069f8:	10800104 	addi	r2,r2,4
811069fc:	e0fffd17 	ldw	r3,-12(fp)
81106a00:	19000d17 	ldw	r4,52(r3)
81106a04:	00fff2c4 	movi	r3,-53
81106a08:	20c6703a 	and	r3,r4,r3
81106a0c:	18c00114 	ori	r3,r3,4
81106a10:	10c00035 	stwio	r3,0(r2)
81106a14:	e0bff517 	ldw	r2,-44(fp)
81106a18:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81106a1c:	e0bff717 	ldw	r2,-36(fp)
81106a20:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
81106a24:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81106a28:	e0bffd17 	ldw	r2,-12(fp)
81106a2c:	10800317 	ldw	r2,12(r2)
81106a30:	10800037 	ldwio	r2,0(r2)
81106a34:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
81106a38:	00001906 	br	81106aa0 <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
81106a3c:	01000044 	movi	r4,1
81106a40:	1127d1c0 	call	81127d1c <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81106a44:	e0bff10b 	ldhu	r2,-60(fp)
81106a48:	1084e230 	cmpltui	r2,r2,5000
81106a4c:	10000d1e 	bne	r2,zero,81106a84 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
81106a50:	d0a04e17 	ldw	r2,-32456(gp)
81106a54:	100f883a 	mov	r7,r2
81106a58:	01801184 	movi	r6,70
81106a5c:	01400044 	movi	r5,1
81106a60:	01204534 	movhi	r4,33044
81106a64:	21358b04 	addi	r4,r4,-10708
81106a68:	1112ccc0 	call	81112ccc <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
81106a6c:	e0bffd17 	ldw	r2,-12(fp)
81106a70:	10801817 	ldw	r2,96(r2)
81106a74:	1009883a 	mov	r4,r2
81106a78:	112fdf00 	call	8112fdf0 <OSSemPost>

			return -ETIME;
81106a7c:	00bff084 	movi	r2,-62
81106a80:	00003a06 	br	81106b6c <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
81106a84:	e0bff10b 	ldhu	r2,-60(fp)
81106a88:	10800044 	addi	r2,r2,1
81106a8c:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81106a90:	e0bffd17 	ldw	r2,-12(fp)
81106a94:	10800317 	ldw	r2,12(r2)
81106a98:	10800037 	ldwio	r2,0(r2)
81106a9c:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
81106aa0:	e0fff017 	ldw	r3,-64(fp)
81106aa4:	e0bff617 	ldw	r2,-40(fp)
81106aa8:	1884703a 	and	r2,r3,r2
81106aac:	1000031e 	bne	r2,zero,81106abc <msgdma_descriptor_sync_transfer+0x338>
81106ab0:	e0bff017 	ldw	r2,-64(fp)
81106ab4:	1080004c 	andi	r2,r2,1
81106ab8:	103fe01e 	bne	r2,zero,81106a3c <__reset+0xfb0e6a3c>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
81106abc:	e0fff017 	ldw	r3,-64(fp)
81106ac0:	e0bff617 	ldw	r2,-40(fp)
81106ac4:	1884703a 	and	r2,r3,r2
81106ac8:	10000626 	beq	r2,zero,81106ae4 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81106acc:	e0bffd17 	ldw	r2,-12(fp)
81106ad0:	10801817 	ldw	r2,96(r2)
81106ad4:	1009883a 	mov	r4,r2
81106ad8:	112fdf00 	call	8112fdf0 <OSSemPost>

		return error;
81106adc:	e0bff617 	ldw	r2,-40(fp)
81106ae0:	00002206 	br	81106b6c <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
81106ae4:	e0bffd17 	ldw	r2,-12(fp)
81106ae8:	10800317 	ldw	r2,12(r2)
81106aec:	10800104 	addi	r2,r2,4
81106af0:	10800037 	ldwio	r2,0(r2)
81106af4:	10800814 	ori	r2,r2,32
81106af8:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106afc:	0005303a 	rdctl	r2,status
81106b00:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81106b04:	e0fffa17 	ldw	r3,-24(fp)
81106b08:	00bfff84 	movi	r2,-2
81106b0c:	1884703a 	and	r2,r3,r2
81106b10:	1001703a 	wrctl	status,r2
  
  return context;
81106b14:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81106b18:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81106b1c:	e0bffd17 	ldw	r2,-12(fp)
81106b20:	10800317 	ldw	r2,12(r2)
81106b24:	10800104 	addi	r2,r2,4
81106b28:	e0fff417 	ldw	r3,-48(fp)
81106b2c:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81106b30:	e0bffd17 	ldw	r2,-12(fp)
81106b34:	10800317 	ldw	r2,12(r2)
81106b38:	e0fffd17 	ldw	r3,-12(fp)
81106b3c:	18c00317 	ldw	r3,12(r3)
81106b40:	18c00037 	ldwio	r3,0(r3)
81106b44:	10c00035 	stwio	r3,0(r2)
81106b48:	e0bff517 	ldw	r2,-44(fp)
81106b4c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81106b50:	e0bff917 	ldw	r2,-28(fp)
81106b54:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
81106b58:	e0bffd17 	ldw	r2,-12(fp)
81106b5c:	10801817 	ldw	r2,96(r2)
81106b60:	1009883a 	mov	r4,r2
81106b64:	112fdf00 	call	8112fdf0 <OSSemPost>

	return 0;
81106b68:	0005883a 	mov	r2,zero

}
81106b6c:	e037883a 	mov	sp,fp
81106b70:	dfc00117 	ldw	ra,4(sp)
81106b74:	df000017 	ldw	fp,0(sp)
81106b78:	dec00204 	addi	sp,sp,8
81106b7c:	f800283a 	ret

81106b80 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
81106b80:	deffec04 	addi	sp,sp,-80
81106b84:	de00012e 	bgeu	sp,et,81106b8c <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
81106b88:	003b68fa 	trap	3
81106b8c:	dfc01315 	stw	ra,76(sp)
81106b90:	df001215 	stw	fp,72(sp)
81106b94:	df001204 	addi	fp,sp,72
81106b98:	e13ff715 	stw	r4,-36(fp)
81106b9c:	e17ff815 	stw	r5,-32(fp)
81106ba0:	e1bff915 	stw	r6,-28(fp)
81106ba4:	e1fffa15 	stw	r7,-24(fp)
81106ba8:	e1800617 	ldw	r6,24(fp)
81106bac:	e1400717 	ldw	r5,28(fp)
81106bb0:	e1000817 	ldw	r4,32(fp)
81106bb4:	e0c00917 	ldw	r3,36(fp)
81106bb8:	e0800a17 	ldw	r2,40(fp)
81106bbc:	e1bffb0d 	sth	r6,-20(fp)
81106bc0:	e17ffc05 	stb	r5,-16(fp)
81106bc4:	e13ffd05 	stb	r4,-12(fp)
81106bc8:	e0fffe0d 	sth	r3,-8(fp)
81106bcc:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
81106bd0:	e0bffb0b 	ldhu	r2,-20(fp)
81106bd4:	e0fffc03 	ldbu	r3,-16(fp)
81106bd8:	e13ffd03 	ldbu	r4,-12(fp)
81106bdc:	e17ffe0b 	ldhu	r5,-8(fp)
81106be0:	e1bfff0b 	ldhu	r6,-4(fp)
81106be4:	d9800815 	stw	r6,32(sp)
81106be8:	d9400715 	stw	r5,28(sp)
81106bec:	d9000615 	stw	r4,24(sp)
81106bf0:	d8c00515 	stw	r3,20(sp)
81106bf4:	d8800415 	stw	r2,16(sp)
81106bf8:	e0800517 	ldw	r2,20(fp)
81106bfc:	d8800315 	stw	r2,12(sp)
81106c00:	e0800417 	ldw	r2,16(fp)
81106c04:	d8800215 	stw	r2,8(sp)
81106c08:	e0800317 	ldw	r2,12(fp)
81106c0c:	d8800115 	stw	r2,4(sp)
81106c10:	e0800217 	ldw	r2,8(fp)
81106c14:	d8800015 	stw	r2,0(sp)
81106c18:	e1fffa17 	ldw	r7,-24(fp)
81106c1c:	e1bff917 	ldw	r6,-28(fp)
81106c20:	e17ff817 	ldw	r5,-32(fp)
81106c24:	e13ff717 	ldw	r4,-36(fp)
81106c28:	11063080 	call	81106308 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
81106c2c:	e037883a 	mov	sp,fp
81106c30:	dfc00117 	ldw	ra,4(sp)
81106c34:	df000017 	ldw	fp,0(sp)
81106c38:	dec00204 	addi	sp,sp,8
81106c3c:	f800283a 	ret

81106c40 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
81106c40:	defffc04 	addi	sp,sp,-16
81106c44:	de00012e 	bgeu	sp,et,81106c4c <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
81106c48:	003b68fa 	trap	3
81106c4c:	dfc00315 	stw	ra,12(sp)
81106c50:	df000215 	stw	fp,8(sp)
81106c54:	df000204 	addi	fp,sp,8
81106c58:	e13ffe15 	stw	r4,-8(fp)
81106c5c:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
81106c60:	e1bfff17 	ldw	r6,-4(fp)
81106c64:	000b883a 	mov	r5,zero
81106c68:	e13ffe17 	ldw	r4,-8(fp)
81106c6c:	110646c0 	call	8110646c <msgdma_descriptor_async_transfer>
}
81106c70:	e037883a 	mov	sp,fp
81106c74:	dfc00117 	ldw	ra,4(sp)
81106c78:	df000017 	ldw	fp,0(sp)
81106c7c:	dec00204 	addi	sp,sp,8
81106c80:	f800283a 	ret

81106c84 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
81106c84:	defffc04 	addi	sp,sp,-16
81106c88:	de00012e 	bgeu	sp,et,81106c90 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
81106c8c:	003b68fa 	trap	3
81106c90:	dfc00315 	stw	ra,12(sp)
81106c94:	df000215 	stw	fp,8(sp)
81106c98:	df000204 	addi	fp,sp,8
81106c9c:	e13ffe15 	stw	r4,-8(fp)
81106ca0:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
81106ca4:	e1bfff17 	ldw	r6,-4(fp)
81106ca8:	000b883a 	mov	r5,zero
81106cac:	e13ffe17 	ldw	r4,-8(fp)
81106cb0:	11067840 	call	81106784 <msgdma_descriptor_sync_transfer>
}
81106cb4:	e037883a 	mov	sp,fp
81106cb8:	dfc00117 	ldw	ra,4(sp)
81106cbc:	df000017 	ldw	fp,0(sp)
81106cc0:	dec00204 	addi	sp,sp,8
81106cc4:	f800283a 	ret

81106cc8 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
81106cc8:	defff204 	addi	sp,sp,-56
81106ccc:	de00012e 	bgeu	sp,et,81106cd4 <POWER_SPI_RW+0xc>
81106cd0:	003b68fa 	trap	3
81106cd4:	dfc00d15 	stw	ra,52(sp)
81106cd8:	df000c15 	stw	fp,48(sp)
81106cdc:	df000c04 	addi	fp,sp,48
81106ce0:	2007883a 	mov	r3,r4
81106ce4:	2805883a 	mov	r2,r5
81106ce8:	e1bffe15 	stw	r6,-8(fp)
81106cec:	e1ffff15 	stw	r7,-4(fp)
81106cf0:	e0fffc05 	stb	r3,-16(fp)
81106cf4:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
81106cf8:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
81106cfc:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
81106d00:	008003f4 	movhi	r2,15
81106d04:	10909004 	addi	r2,r2,16960
81106d08:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
81106d0c:	00bfe004 	movi	r2,-128
81106d10:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
81106d14:	e0bffe17 	ldw	r2,-8(fp)
81106d18:	10000226 	beq	r2,zero,81106d24 <POWER_SPI_RW+0x5c>
81106d1c:	00800804 	movi	r2,32
81106d20:	00000106 	br	81106d28 <POWER_SPI_RW+0x60>
81106d24:	0005883a 	mov	r2,zero
81106d28:	e0fff403 	ldbu	r3,-48(fp)
81106d2c:	10c4b03a 	or	r2,r2,r3
81106d30:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
81106d34:	e0800217 	ldw	r2,8(fp)
81106d38:	10000226 	beq	r2,zero,81106d44 <POWER_SPI_RW+0x7c>
81106d3c:	00800404 	movi	r2,16
81106d40:	00000106 	br	81106d48 <POWER_SPI_RW+0x80>
81106d44:	0005883a 	mov	r2,zero
81106d48:	e0fff403 	ldbu	r3,-48(fp)
81106d4c:	10c4b03a 	or	r2,r2,r3
81106d50:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
81106d54:	e0bfff17 	ldw	r2,-4(fp)
81106d58:	10000226 	beq	r2,zero,81106d64 <POWER_SPI_RW+0x9c>
81106d5c:	00800204 	movi	r2,8
81106d60:	00000106 	br	81106d68 <POWER_SPI_RW+0xa0>
81106d64:	0005883a 	mov	r2,zero
81106d68:	e0fff403 	ldbu	r3,-48(fp)
81106d6c:	10c4b03a 	or	r2,r2,r3
81106d70:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
81106d74:	e0bffd03 	ldbu	r2,-12(fp)
81106d78:	108001cc 	andi	r2,r2,7
81106d7c:	1007883a 	mov	r3,r2
81106d80:	e0bff403 	ldbu	r2,-48(fp)
81106d84:	1884b03a 	or	r2,r3,r2
81106d88:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
81106d8c:	0007883a 	mov	r3,zero
81106d90:	00a00034 	movhi	r2,32768
81106d94:	10824404 	addi	r2,r2,2320
81106d98:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
81106d9c:	0007883a 	mov	r3,zero
81106da0:	00a00034 	movhi	r2,32768
81106da4:	10824c04 	addi	r2,r2,2352
81106da8:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
81106dac:	e0bffc03 	ldbu	r2,-16(fp)
81106db0:	1000021e 	bne	r2,zero,81106dbc <POWER_SPI_RW+0xf4>
81106db4:	00c00084 	movi	r3,2
81106db8:	00000106 	br	81106dc0 <POWER_SPI_RW+0xf8>
81106dbc:	00c00044 	movi	r3,1
81106dc0:	00a00034 	movhi	r2,32768
81106dc4:	10824804 	addi	r2,r2,2336
81106dc8:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
81106dcc:	010003c4 	movi	r4,15
81106dd0:	1128bec0 	call	81128bec <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
81106dd4:	00000306 	br	81106de4 <POWER_SPI_RW+0x11c>
		nWait++;
81106dd8:	e0bff817 	ldw	r2,-32(fp)
81106ddc:	10800044 	addi	r2,r2,1
81106de0:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
81106de4:	00a00034 	movhi	r2,32768
81106de8:	10825404 	addi	r2,r2,2384
81106dec:	10800037 	ldwio	r2,0(r2)
81106df0:	1080004c 	andi	r2,r2,1
81106df4:	10000326 	beq	r2,zero,81106e04 <POWER_SPI_RW+0x13c>
81106df8:	e0fff817 	ldw	r3,-32(fp)
81106dfc:	e0bffa17 	ldw	r2,-24(fp)
81106e00:	18bff516 	blt	r3,r2,81106dd8 <__reset+0xfb0e6dd8>
		nWait++;
	}

	if (SPI_SDO) {
81106e04:	00a00034 	movhi	r2,32768
81106e08:	10825404 	addi	r2,r2,2384
81106e0c:	10800037 	ldwio	r2,0(r2)
81106e10:	1080004c 	andi	r2,r2,1
81106e14:	10000626 	beq	r2,zero,81106e30 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
81106e18:	00c000c4 	movi	r3,3
81106e1c:	00a00034 	movhi	r2,32768
81106e20:	10824804 	addi	r2,r2,2336
81106e24:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
81106e28:	0005883a 	mov	r2,zero
81106e2c:	0000db06 	br	8110719c <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
81106e30:	e03ff715 	stw	zero,-36(fp)
81106e34:	00002406 	br	81106ec8 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
81106e38:	e0bff403 	ldbu	r2,-48(fp)
81106e3c:	10803fcc 	andi	r2,r2,255
81106e40:	1004d1fa 	srli	r2,r2,7
81106e44:	10c03fcc 	andi	r3,r2,255
81106e48:	00a00034 	movhi	r2,32768
81106e4c:	10825004 	addi	r2,r2,2368
81106e50:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
81106e54:	e0bff403 	ldbu	r2,-48(fp)
81106e58:	1085883a 	add	r2,r2,r2
81106e5c:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
81106e60:	e0bff517 	ldw	r2,-44(fp)
81106e64:	1085883a 	add	r2,r2,r2
81106e68:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
81106e6c:	00a00034 	movhi	r2,32768
81106e70:	10825404 	addi	r2,r2,2384
81106e74:	10800037 	ldwio	r2,0(r2)
81106e78:	1080004c 	andi	r2,r2,1
81106e7c:	1007883a 	mov	r3,r2
81106e80:	e0bff517 	ldw	r2,-44(fp)
81106e84:	10c4b03a 	or	r2,r2,r3
81106e88:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81106e8c:	00c00044 	movi	r3,1
81106e90:	00a00034 	movhi	r2,32768
81106e94:	10824c04 	addi	r2,r2,2352
81106e98:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106e9c:	010003c4 	movi	r4,15
81106ea0:	1128bec0 	call	81128bec <usleep>
		SPI_SCK(0); //sck=0; // clock low
81106ea4:	0007883a 	mov	r3,zero
81106ea8:	00a00034 	movhi	r2,32768
81106eac:	10824c04 	addi	r2,r2,2352
81106eb0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106eb4:	010003c4 	movi	r4,15
81106eb8:	1128bec0 	call	81128bec <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
81106ebc:	e0bff717 	ldw	r2,-36(fp)
81106ec0:	10800044 	addi	r2,r2,1
81106ec4:	e0bff715 	stw	r2,-36(fp)
81106ec8:	e0bff717 	ldw	r2,-36(fp)
81106ecc:	10800090 	cmplti	r2,r2,2
81106ed0:	103fd91e 	bne	r2,zero,81106e38 <__reset+0xfb0e6e38>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
81106ed4:	e03ff715 	stw	zero,-36(fp)
81106ed8:	00002406 	br	81106f6c <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
81106edc:	e0bff403 	ldbu	r2,-48(fp)
81106ee0:	10803fcc 	andi	r2,r2,255
81106ee4:	1004d1fa 	srli	r2,r2,7
81106ee8:	10c03fcc 	andi	r3,r2,255
81106eec:	00a00034 	movhi	r2,32768
81106ef0:	10825004 	addi	r2,r2,2368
81106ef4:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
81106ef8:	e0bff403 	ldbu	r2,-48(fp)
81106efc:	1085883a 	add	r2,r2,r2
81106f00:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
81106f04:	e0bff517 	ldw	r2,-44(fp)
81106f08:	1085883a 	add	r2,r2,r2
81106f0c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
81106f10:	00a00034 	movhi	r2,32768
81106f14:	10825404 	addi	r2,r2,2384
81106f18:	10800037 	ldwio	r2,0(r2)
81106f1c:	1080004c 	andi	r2,r2,1
81106f20:	1007883a 	mov	r3,r2
81106f24:	e0bff517 	ldw	r2,-44(fp)
81106f28:	10c4b03a 	or	r2,r2,r3
81106f2c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81106f30:	00c00044 	movi	r3,1
81106f34:	00a00034 	movhi	r2,32768
81106f38:	10824c04 	addi	r2,r2,2352
81106f3c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106f40:	010003c4 	movi	r4,15
81106f44:	1128bec0 	call	81128bec <usleep>
		SPI_SCK(0); //sck=0; // clock low
81106f48:	0007883a 	mov	r3,zero
81106f4c:	00a00034 	movhi	r2,32768
81106f50:	10824c04 	addi	r2,r2,2352
81106f54:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106f58:	010003c4 	movi	r4,15
81106f5c:	1128bec0 	call	81128bec <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
81106f60:	e0bff717 	ldw	r2,-36(fp)
81106f64:	10800044 	addi	r2,r2,1
81106f68:	e0bff715 	stw	r2,-36(fp)
81106f6c:	e0bff717 	ldw	r2,-36(fp)
81106f70:	10800210 	cmplti	r2,r2,8
81106f74:	103fd91e 	bne	r2,zero,81106edc <__reset+0xfb0e6edc>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
81106f78:	e03ff715 	stw	zero,-36(fp)
81106f7c:	00001a06 	br	81106fe8 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
81106f80:	e0bff517 	ldw	r2,-44(fp)
81106f84:	1085883a 	add	r2,r2,r2
81106f88:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
81106f8c:	00a00034 	movhi	r2,32768
81106f90:	10825404 	addi	r2,r2,2384
81106f94:	10800037 	ldwio	r2,0(r2)
81106f98:	1080004c 	andi	r2,r2,1
81106f9c:	1007883a 	mov	r3,r2
81106fa0:	e0bff517 	ldw	r2,-44(fp)
81106fa4:	10c4b03a 	or	r2,r2,r3
81106fa8:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81106fac:	00c00044 	movi	r3,1
81106fb0:	00a00034 	movhi	r2,32768
81106fb4:	10824c04 	addi	r2,r2,2352
81106fb8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106fbc:	010003c4 	movi	r4,15
81106fc0:	1128bec0 	call	81128bec <usleep>
		SPI_SCK(0); //sck=0; // clock low
81106fc4:	0007883a 	mov	r3,zero
81106fc8:	00a00034 	movhi	r2,32768
81106fcc:	10824c04 	addi	r2,r2,2352
81106fd0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106fd4:	010003c4 	movi	r4,15
81106fd8:	1128bec0 	call	81128bec <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
81106fdc:	e0bff717 	ldw	r2,-36(fp)
81106fe0:	10800044 	addi	r2,r2,1
81106fe4:	e0bff715 	stw	r2,-36(fp)
81106fe8:	e0bff717 	ldw	r2,-36(fp)
81106fec:	10800210 	cmplti	r2,r2,8
81106ff0:	103fe31e 	bne	r2,zero,81106f80 <__reset+0xfb0e6f80>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
81106ff4:	e03ff715 	stw	zero,-36(fp)
81106ff8:	00001a06 	br	81107064 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
81106ffc:	e0bff517 	ldw	r2,-44(fp)
81107000:	1085883a 	add	r2,r2,r2
81107004:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
81107008:	00a00034 	movhi	r2,32768
8110700c:	10825404 	addi	r2,r2,2384
81107010:	10800037 	ldwio	r2,0(r2)
81107014:	1080004c 	andi	r2,r2,1
81107018:	1007883a 	mov	r3,r2
8110701c:	e0bff517 	ldw	r2,-44(fp)
81107020:	10c4b03a 	or	r2,r2,r3
81107024:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81107028:	00c00044 	movi	r3,1
8110702c:	00a00034 	movhi	r2,32768
81107030:	10824c04 	addi	r2,r2,2352
81107034:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81107038:	010003c4 	movi	r4,15
8110703c:	1128bec0 	call	81128bec <usleep>
		SPI_SCK(0); //sck=0; // clock low
81107040:	0007883a 	mov	r3,zero
81107044:	00a00034 	movhi	r2,32768
81107048:	10824c04 	addi	r2,r2,2352
8110704c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81107050:	010003c4 	movi	r4,15
81107054:	1128bec0 	call	81128bec <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
81107058:	e0bff717 	ldw	r2,-36(fp)
8110705c:	10800044 	addi	r2,r2,1
81107060:	e0bff715 	stw	r2,-36(fp)
81107064:	e0bff717 	ldw	r2,-36(fp)
81107068:	10800210 	cmplti	r2,r2,8
8110706c:	103fe31e 	bne	r2,zero,81106ffc <__reset+0xfb0e6ffc>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
81107070:	e03ff715 	stw	zero,-36(fp)
81107074:	00001a06 	br	811070e0 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
81107078:	e0bff517 	ldw	r2,-44(fp)
8110707c:	1085883a 	add	r2,r2,r2
81107080:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
81107084:	00a00034 	movhi	r2,32768
81107088:	10825404 	addi	r2,r2,2384
8110708c:	10800037 	ldwio	r2,0(r2)
81107090:	1080004c 	andi	r2,r2,1
81107094:	1007883a 	mov	r3,r2
81107098:	e0bff517 	ldw	r2,-44(fp)
8110709c:	10c4b03a 	or	r2,r2,r3
811070a0:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
811070a4:	00c00044 	movi	r3,1
811070a8:	00a00034 	movhi	r2,32768
811070ac:	10824c04 	addi	r2,r2,2352
811070b0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
811070b4:	010003c4 	movi	r4,15
811070b8:	1128bec0 	call	81128bec <usleep>
		SPI_SCK(0); //sck=0; // clock low
811070bc:	0007883a 	mov	r3,zero
811070c0:	00a00034 	movhi	r2,32768
811070c4:	10824c04 	addi	r2,r2,2352
811070c8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
811070cc:	010003c4 	movi	r4,15
811070d0:	1128bec0 	call	81128bec <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
811070d4:	e0bff717 	ldw	r2,-36(fp)
811070d8:	10800044 	addi	r2,r2,1
811070dc:	e0bff715 	stw	r2,-36(fp)
811070e0:	e0bff717 	ldw	r2,-36(fp)
811070e4:	10800190 	cmplti	r2,r2,6
811070e8:	103fe31e 	bne	r2,zero,81107078 <__reset+0xfb0e7078>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
811070ec:	00c00044 	movi	r3,1
811070f0:	00a00034 	movhi	r2,32768
811070f4:	10824c04 	addi	r2,r2,2352
811070f8:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
811070fc:	010003c4 	movi	r4,15
81107100:	1128bec0 	call	81128bec <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
81107104:	00c000c4 	movi	r3,3
81107108:	00a00034 	movhi	r2,32768
8110710c:	10824804 	addi	r2,r2,2336
81107110:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
81107114:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
81107118:	00800044 	movi	r2,1
8110711c:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
81107120:	e03ff715 	stw	zero,-36(fp)
81107124:	00000d06 	br	8110715c <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
81107128:	e0fff517 	ldw	r3,-44(fp)
8110712c:	e0bff617 	ldw	r2,-40(fp)
81107130:	1884703a 	and	r2,r3,r2
81107134:	1000031e 	bne	r2,zero,81107144 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
81107138:	e0bff917 	ldw	r2,-28(fp)
8110713c:	10800044 	addi	r2,r2,1
81107140:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
81107144:	e0bff617 	ldw	r2,-40(fp)
81107148:	1085883a 	add	r2,r2,r2
8110714c:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
81107150:	e0bff717 	ldw	r2,-36(fp)
81107154:	10800044 	addi	r2,r2,1
81107158:	e0bff715 	stw	r2,-36(fp)
8110715c:	e0bff717 	ldw	r2,-36(fp)
81107160:	10800810 	cmplti	r2,r2,32
81107164:	103ff01e 	bne	r2,zero,81107128 <__reset+0xfb0e7128>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
81107168:	e0bff917 	ldw	r2,-28(fp)
8110716c:	1080004c 	andi	r2,r2,1
81107170:	1005003a 	cmpeq	r2,r2,zero
81107174:	10803fcc 	andi	r2,r2,255
81107178:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110717c:	e0bffb17 	ldw	r2,-20(fp)
81107180:	1000021e 	bne	r2,zero,8110718c <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
81107184:	0005883a 	mov	r2,zero
81107188:	00000406 	br	8110719c <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110718c:	e0800317 	ldw	r2,12(fp)
81107190:	e0fff517 	ldw	r3,-44(fp)
81107194:	10c00015 	stw	r3,0(r2)

	return bSuccess;
81107198:	e0bffb17 	ldw	r2,-20(fp)
}
8110719c:	e037883a 	mov	sp,fp
811071a0:	dfc00117 	ldw	ra,4(sp)
811071a4:	df000017 	ldw	fp,0(sp)
811071a8:	dec00204 	addi	sp,sp,8
811071ac:	f800283a 	ret

811071b0 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
811071b0:	defffc04 	addi	sp,sp,-16
811071b4:	de00012e 	bgeu	sp,et,811071bc <vRstcSimucamReset+0xc>
811071b8:	003b68fa 	trap	3
811071bc:	dfc00315 	stw	ra,12(sp)
811071c0:	df000215 	stw	fp,8(sp)
811071c4:	df000204 	addi	fp,sp,8
811071c8:	2005883a 	mov	r2,r4
811071cc:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
811071d0:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
811071d4:	e0bfff0b 	ldhu	r2,-4(fp)
811071d8:	e0fffe17 	ldw	r3,-8(fp)
811071dc:	1884b03a 	or	r2,r3,r2
811071e0:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
811071e4:	e0bffe17 	ldw	r2,-8(fp)
811071e8:	10800074 	orhi	r2,r2,1
811071ec:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
811071f0:	e1bffe17 	ldw	r6,-8(fp)
811071f4:	000b883a 	mov	r5,zero
811071f8:	01200034 	movhi	r4,32768
811071fc:	21020004 	addi	r4,r4,2048
81107200:	11073000 	call	81107300 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
81107204:	0001883a 	nop
81107208:	e037883a 	mov	sp,fp
8110720c:	dfc00117 	ldw	ra,4(sp)
81107210:	df000017 	ldw	fp,0(sp)
81107214:	dec00204 	addi	sp,sp,8
81107218:	f800283a 	ret

8110721c <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110721c:	defffc04 	addi	sp,sp,-16
81107220:	de00012e 	bgeu	sp,et,81107228 <vRstcReleaseDeviceReset+0xc>
81107224:	003b68fa 	trap	3
81107228:	dfc00315 	stw	ra,12(sp)
8110722c:	df000215 	stw	fp,8(sp)
81107230:	df000204 	addi	fp,sp,8
81107234:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
81107238:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110723c:	01400044 	movi	r5,1
81107240:	01200034 	movhi	r4,32768
81107244:	21020004 	addi	r4,r4,2048
81107248:	11073540 	call	81107354 <uliRstReadReg>
8110724c:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
81107250:	e0bfff17 	ldw	r2,-4(fp)
81107254:	0084303a 	nor	r2,zero,r2
81107258:	e0fffe17 	ldw	r3,-8(fp)
8110725c:	1884703a 	and	r2,r3,r2
81107260:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
81107264:	e1bffe17 	ldw	r6,-8(fp)
81107268:	01400044 	movi	r5,1
8110726c:	01200034 	movhi	r4,32768
81107270:	21020004 	addi	r4,r4,2048
81107274:	11073000 	call	81107300 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
81107278:	0001883a 	nop
8110727c:	e037883a 	mov	sp,fp
81107280:	dfc00117 	ldw	ra,4(sp)
81107284:	df000017 	ldw	fp,0(sp)
81107288:	dec00204 	addi	sp,sp,8
8110728c:	f800283a 	ret

81107290 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
81107290:	defffc04 	addi	sp,sp,-16
81107294:	de00012e 	bgeu	sp,et,8110729c <vRstcHoldDeviceReset+0xc>
81107298:	003b68fa 	trap	3
8110729c:	dfc00315 	stw	ra,12(sp)
811072a0:	df000215 	stw	fp,8(sp)
811072a4:	df000204 	addi	fp,sp,8
811072a8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
811072ac:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
811072b0:	01400044 	movi	r5,1
811072b4:	01200034 	movhi	r4,32768
811072b8:	21020004 	addi	r4,r4,2048
811072bc:	11073540 	call	81107354 <uliRstReadReg>
811072c0:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
811072c4:	e0fffe17 	ldw	r3,-8(fp)
811072c8:	e0bfff17 	ldw	r2,-4(fp)
811072cc:	1884b03a 	or	r2,r3,r2
811072d0:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
811072d4:	e1bffe17 	ldw	r6,-8(fp)
811072d8:	01400044 	movi	r5,1
811072dc:	01200034 	movhi	r4,32768
811072e0:	21020004 	addi	r4,r4,2048
811072e4:	11073000 	call	81107300 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
811072e8:	0001883a 	nop
811072ec:	e037883a 	mov	sp,fp
811072f0:	dfc00117 	ldw	ra,4(sp)
811072f4:	df000017 	ldw	fp,0(sp)
811072f8:	dec00204 	addi	sp,sp,8
811072fc:	f800283a 	ret

81107300 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81107300:	defffc04 	addi	sp,sp,-16
81107304:	de00012e 	bgeu	sp,et,8110730c <vRstcWriteReg+0xc>
81107308:	003b68fa 	trap	3
8110730c:	df000315 	stw	fp,12(sp)
81107310:	df000304 	addi	fp,sp,12
81107314:	e13ffd15 	stw	r4,-12(fp)
81107318:	e17ffe15 	stw	r5,-8(fp)
8110731c:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81107320:	e0bffe17 	ldw	r2,-8(fp)
81107324:	1085883a 	add	r2,r2,r2
81107328:	1085883a 	add	r2,r2,r2
8110732c:	1007883a 	mov	r3,r2
81107330:	e0bffd17 	ldw	r2,-12(fp)
81107334:	10c5883a 	add	r2,r2,r3
81107338:	e0ffff17 	ldw	r3,-4(fp)
8110733c:	10c00015 	stw	r3,0(r2)
}
81107340:	0001883a 	nop
81107344:	e037883a 	mov	sp,fp
81107348:	df000017 	ldw	fp,0(sp)
8110734c:	dec00104 	addi	sp,sp,4
81107350:	f800283a 	ret

81107354 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81107354:	defffc04 	addi	sp,sp,-16
81107358:	de00012e 	bgeu	sp,et,81107360 <uliRstReadReg+0xc>
8110735c:	003b68fa 	trap	3
81107360:	df000315 	stw	fp,12(sp)
81107364:	df000304 	addi	fp,sp,12
81107368:	e13ffe15 	stw	r4,-8(fp)
8110736c:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81107370:	e0bfff17 	ldw	r2,-4(fp)
81107374:	1085883a 	add	r2,r2,r2
81107378:	1085883a 	add	r2,r2,r2
8110737c:	1007883a 	mov	r3,r2
81107380:	e0bffe17 	ldw	r2,-8(fp)
81107384:	10c5883a 	add	r2,r2,r3
81107388:	10800017 	ldw	r2,0(r2)
8110738c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81107390:	e0bffd17 	ldw	r2,-12(fp)
}
81107394:	e037883a 	mov	sp,fp
81107398:	df000017 	ldw	fp,0(sp)
8110739c:	dec00104 	addi	sp,sp,4
811073a0:	f800283a 	ret

811073a4 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
811073a4:	defffe04 	addi	sp,sp,-8
811073a8:	de00012e 	bgeu	sp,et,811073b0 <v_spi_start+0xc>
811073ac:	003b68fa 	trap	3
811073b0:	dfc00115 	stw	ra,4(sp)
811073b4:	df000015 	stw	fp,0(sp)
811073b8:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
811073bc:	0007883a 	mov	r3,zero
811073c0:	00a00034 	movhi	r2,32768
811073c4:	10823004 	addi	r2,r2,2240
811073c8:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
811073cc:	0007883a 	mov	r3,zero
811073d0:	00a00034 	movhi	r2,32768
811073d4:	10822c04 	addi	r2,r2,2224
811073d8:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
811073dc:	01002584 	movi	r4,150
811073e0:	1128bec0 	call	81128bec <usleep>
}
811073e4:	0001883a 	nop
811073e8:	e037883a 	mov	sp,fp
811073ec:	dfc00117 	ldw	ra,4(sp)
811073f0:	df000017 	ldw	fp,0(sp)
811073f4:	dec00204 	addi	sp,sp,8
811073f8:	f800283a 	ret

811073fc <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
811073fc:	defffc04 	addi	sp,sp,-16
81107400:	de00012e 	bgeu	sp,et,81107408 <v_spi_send_byte+0xc>
81107404:	003b68fa 	trap	3
81107408:	dfc00315 	stw	ra,12(sp)
8110740c:	df000215 	stw	fp,8(sp)
81107410:	df000204 	addi	fp,sp,8
81107414:	2005883a 	mov	r2,r4
81107418:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110741c:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
81107420:	00bfe004 	movi	r2,-128
81107424:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
81107428:	e03ffe05 	stb	zero,-8(fp)
8110742c:	00001b06 	br	8110749c <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
81107430:	e0ffff03 	ldbu	r3,-4(fp)
81107434:	e0bffe43 	ldbu	r2,-7(fp)
81107438:	1884703a 	and	r2,r3,r2
8110743c:	10803fcc 	andi	r2,r2,255
81107440:	1004c03a 	cmpne	r2,r2,zero
81107444:	10c03fcc 	andi	r3,r2,255
81107448:	00a00034 	movhi	r2,32768
8110744c:	10823404 	addi	r2,r2,2256
81107450:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
81107454:	e0bffe43 	ldbu	r2,-7(fp)
81107458:	1004d07a 	srli	r2,r2,1
8110745c:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
81107460:	00c00044 	movi	r3,1
81107464:	00a00034 	movhi	r2,32768
81107468:	10823004 	addi	r2,r2,2240
8110746c:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
81107470:	01002584 	movi	r4,150
81107474:	1128bec0 	call	81128bec <usleep>
        SPI_SCK(0);//sck=0; // clock low
81107478:	0007883a 	mov	r3,zero
8110747c:	00a00034 	movhi	r2,32768
81107480:	10823004 	addi	r2,r2,2240
81107484:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
81107488:	01002584 	movi	r4,150
8110748c:	1128bec0 	call	81128bec <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
81107490:	e0bffe03 	ldbu	r2,-8(fp)
81107494:	10800044 	addi	r2,r2,1
81107498:	e0bffe05 	stb	r2,-8(fp)
8110749c:	e0bffe03 	ldbu	r2,-8(fp)
811074a0:	10800230 	cmpltui	r2,r2,8
811074a4:	103fe21e 	bne	r2,zero,81107430 <__reset+0xfb0e7430>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
811074a8:	0001883a 	nop
811074ac:	e037883a 	mov	sp,fp
811074b0:	dfc00117 	ldw	ra,4(sp)
811074b4:	df000017 	ldw	fp,0(sp)
811074b8:	dec00204 	addi	sp,sp,8
811074bc:	f800283a 	ret

811074c0 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
811074c0:	defffd04 	addi	sp,sp,-12
811074c4:	de00012e 	bgeu	sp,et,811074cc <uc_spi_get_byte+0xc>
811074c8:	003b68fa 	trap	3
811074cc:	dfc00215 	stw	ra,8(sp)
811074d0:	df000115 	stw	fp,4(sp)
811074d4:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
811074d8:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
811074dc:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
811074e0:	e03fff05 	stb	zero,-4(fp)
811074e4:	00001a06 	br	81107550 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
811074e8:	e0bfff43 	ldbu	r2,-3(fp)
811074ec:	1085883a 	add	r2,r2,r2
811074f0:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
811074f4:	00a00034 	movhi	r2,32768
811074f8:	10823804 	addi	r2,r2,2272
811074fc:	10800037 	ldwio	r2,0(r2)
81107500:	1080004c 	andi	r2,r2,1
81107504:	1007883a 	mov	r3,r2
81107508:	e0bfff43 	ldbu	r2,-3(fp)
8110750c:	1884b03a 	or	r2,r3,r2
81107510:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
81107514:	00c00044 	movi	r3,1
81107518:	00a00034 	movhi	r2,32768
8110751c:	10823004 	addi	r2,r2,2240
81107520:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
81107524:	01002584 	movi	r4,150
81107528:	1128bec0 	call	81128bec <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110752c:	0007883a 	mov	r3,zero
81107530:	00a00034 	movhi	r2,32768
81107534:	10823004 	addi	r2,r2,2240
81107538:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110753c:	01002584 	movi	r4,150
81107540:	1128bec0 	call	81128bec <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
81107544:	e0bfff03 	ldbu	r2,-4(fp)
81107548:	10800044 	addi	r2,r2,1
8110754c:	e0bfff05 	stb	r2,-4(fp)
81107550:	e0bfff03 	ldbu	r2,-4(fp)
81107554:	10800230 	cmpltui	r2,r2,8
81107558:	103fe31e 	bne	r2,zero,811074e8 <__reset+0xfb0e74e8>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110755c:	e0bfff43 	ldbu	r2,-3(fp)
}
81107560:	e037883a 	mov	sp,fp
81107564:	dfc00117 	ldw	ra,4(sp)
81107568:	df000017 	ldw	fp,0(sp)
8110756c:	dec00204 	addi	sp,sp,8
81107570:	f800283a 	ret

81107574 <v_spi_end>:

void v_spi_end(void){
81107574:	defffe04 	addi	sp,sp,-8
81107578:	de00012e 	bgeu	sp,et,81107580 <v_spi_end+0xc>
8110757c:	003b68fa 	trap	3
81107580:	dfc00115 	stw	ra,4(sp)
81107584:	df000015 	stw	fp,0(sp)
81107588:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110758c:	0007883a 	mov	r3,zero
81107590:	00a00034 	movhi	r2,32768
81107594:	10823004 	addi	r2,r2,2240
81107598:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110759c:	01002584 	movi	r4,150
811075a0:	1128bec0 	call	81128bec <usleep>
    SPI_CS_N(1);
811075a4:	00c00044 	movi	r3,1
811075a8:	00a00034 	movhi	r2,32768
811075ac:	10822c04 	addi	r2,r2,2224
811075b0:	10c00035 	stwio	r3,0(r2)
}
811075b4:	0001883a 	nop
811075b8:	e037883a 	mov	sp,fp
811075bc:	dfc00117 	ldw	ra,4(sp)
811075c0:	df000017 	ldw	fp,0(sp)
811075c4:	dec00204 	addi	sp,sp,8
811075c8:	f800283a 	ret

811075cc <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
811075cc:	defff604 	addi	sp,sp,-40
811075d0:	de00012e 	bgeu	sp,et,811075d8 <RTCC_SPI_R_MAC+0xc>
811075d4:	003b68fa 	trap	3
811075d8:	dfc00915 	stw	ra,36(sp)
811075dc:	df000815 	stw	fp,32(sp)
811075e0:	df000804 	addi	fp,sp,32
811075e4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811075e8:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
811075ec:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
811075f0:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
811075f4:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
811075f8:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
811075fc:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
81107600:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
81107604:	00800084 	movi	r2,2
81107608:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110760c:	00800cc4 	movi	r2,51
81107610:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
81107614:	11073a40 	call	811073a4 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
81107618:	e0bffec3 	ldbu	r2,-5(fp)
8110761c:	1009883a 	mov	r4,r2
81107620:	11073fc0 	call	811073fc <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
81107624:	e0bffe83 	ldbu	r2,-6(fp)
81107628:	1009883a 	mov	r4,r2
8110762c:	11073fc0 	call	811073fc <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
81107630:	11074c00 	call	811074c0 <uc_spi_get_byte>
81107634:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
81107638:	11074c00 	call	811074c0 <uc_spi_get_byte>
8110763c:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
81107640:	11074c00 	call	811074c0 <uc_spi_get_byte>
81107644:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
81107648:	11074c00 	call	811074c0 <uc_spi_get_byte>
8110764c:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
81107650:	11074c00 	call	811074c0 <uc_spi_get_byte>
81107654:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
81107658:	11074c00 	call	811074c0 <uc_spi_get_byte>
8110765c:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
81107660:	11075740 	call	81107574 <v_spi_end>

    bSuccess = TRUE;
81107664:	00800044 	movi	r2,1
81107668:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110766c:	e0bfff17 	ldw	r2,-4(fp)
81107670:	e0fffd03 	ldbu	r3,-12(fp)
81107674:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
81107678:	e0bfff17 	ldw	r2,-4(fp)
8110767c:	10800044 	addi	r2,r2,1
81107680:	e0fffd43 	ldbu	r3,-11(fp)
81107684:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
81107688:	e0bfff17 	ldw	r2,-4(fp)
8110768c:	10800084 	addi	r2,r2,2
81107690:	e0fffd83 	ldbu	r3,-10(fp)
81107694:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
81107698:	e0bfff17 	ldw	r2,-4(fp)
8110769c:	108000c4 	addi	r2,r2,3
811076a0:	e0fffdc3 	ldbu	r3,-9(fp)
811076a4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
811076a8:	e0bfff17 	ldw	r2,-4(fp)
811076ac:	10800104 	addi	r2,r2,4
811076b0:	e0fffe03 	ldbu	r3,-8(fp)
811076b4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
811076b8:	e0bfff17 	ldw	r2,-4(fp)
811076bc:	10800144 	addi	r2,r2,5
811076c0:	e0fffe43 	ldbu	r3,-7(fp)
811076c4:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
811076c8:	e1bffd03 	ldbu	r6,-12(fp)
811076cc:	e1fffd43 	ldbu	r7,-11(fp)
811076d0:	e0bffd83 	ldbu	r2,-10(fp)
811076d4:	e0fffdc3 	ldbu	r3,-9(fp)
811076d8:	e13ffe03 	ldbu	r4,-8(fp)
811076dc:	e17ffe43 	ldbu	r5,-7(fp)
811076e0:	d9400315 	stw	r5,12(sp)
811076e4:	d9000215 	stw	r4,8(sp)
811076e8:	d8c00115 	stw	r3,4(sp)
811076ec:	d8800015 	stw	r2,0(sp)
811076f0:	01604534 	movhi	r5,33044
811076f4:	29759d04 	addi	r5,r5,-10636
811076f8:	01204534 	movhi	r4,33044
811076fc:	21077104 	addi	r4,r4,7620
81107700:	1113e480 	call	81113e48 <sprintf>
	debug(fp, cDebugBuffer);
81107704:	d0a04e17 	ldw	r2,-32456(gp)
81107708:	01604534 	movhi	r5,33044
8110770c:	29477104 	addi	r5,r5,7620
81107710:	1009883a 	mov	r4,r2
81107714:	11126e00 	call	811126e0 <fprintf>
#endif

    return bSuccess;
81107718:	e0bffc17 	ldw	r2,-16(fp)
}
8110771c:	e037883a 	mov	sp,fp
81107720:	dfc00117 	ldw	ra,4(sp)
81107724:	df000017 	ldw	fp,0(sp)
81107728:	dec00204 	addi	sp,sp,8
8110772c:	f800283a 	ret

81107730 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configuração não especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
81107730:	defffd04 	addi	sp,sp,-12
81107734:	de00012e 	bgeu	sp,et,8110773c <bSSDisplayConfig+0xc>
81107738:	003b68fa 	trap	3
8110773c:	df000215 	stw	fp,8(sp)
81107740:	df000204 	addi	fp,sp,8
81107744:	2005883a 	mov	r2,r4
81107748:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110774c:	e0bfff03 	ldbu	r2,-4(fp)
81107750:	10c00168 	cmpgeui	r3,r2,5
81107754:	18001c1e 	bne	r3,zero,811077c8 <bSSDisplayConfig+0x98>
81107758:	100690ba 	slli	r3,r2,2
8110775c:	00a04434 	movhi	r2,33040
81107760:	109ddc04 	addi	r2,r2,30576
81107764:	1885883a 	add	r2,r3,r2
81107768:	10800017 	ldw	r2,0(r2)
8110776c:	1000683a 	jmp	r2
81107770:	81107784 	addi	r4,r16,16862
81107774:	81107790 	cmplti	r4,r16,16862
81107778:	8110779c 	xori	r4,r16,16862
8110777c:	811077b0 	cmpltui	r4,r16,16862
81107780:	811077c0 	call	8811077c <__reset+0x20f077c>
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
81107784:	00800cc4 	movi	r2,51
81107788:	d0a04545 	stb	r2,-32491(gp)
	    break;
8110778c:	00001006 	br	811077d0 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
81107790:	00801544 	movi	r2,85
81107794:	d0a04545 	stb	r2,-32491(gp)
	    break;
81107798:	00000d06 	br	811077d0 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110779c:	d0e04543 	ldbu	r3,-32491(gp)
811077a0:	00bff744 	movi	r2,-35
811077a4:	1884703a 	and	r2,r3,r2
811077a8:	d0a04545 	stb	r2,-32491(gp)
	    break;
811077ac:	00000806 	br	811077d0 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
811077b0:	d0a04543 	ldbu	r2,-32491(gp)
811077b4:	10800894 	ori	r2,r2,34
811077b8:	d0a04545 	stb	r2,-32491(gp)
	    break;
811077bc:	00000406 	br	811077d0 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
811077c0:	d0204545 	stb	zero,-32491(gp)
	    break;
811077c4:	00000206 	br	811077d0 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
811077c8:	0005883a 	mov	r2,zero
811077cc:	00000806 	br	811077f0 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
811077d0:	00a00034 	movhi	r2,32768
811077d4:	10828404 	addi	r2,r2,2576
811077d8:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
811077dc:	d0a04543 	ldbu	r2,-32491(gp)
811077e0:	10c03fcc 	andi	r3,r2,255
811077e4:	e0bffe17 	ldw	r2,-8(fp)
811077e8:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
811077ec:	00800044 	movi	r2,1
}
811077f0:	e037883a 	mov	sp,fp
811077f4:	df000017 	ldw	fp,0(sp)
811077f8:	dec00104 	addi	sp,sp,4
811077fc:	f800283a 	ret

81107800 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
81107800:	defffd04 	addi	sp,sp,-12
81107804:	de00012e 	bgeu	sp,et,8110780c <bSSDisplayUpdate+0xc>
81107808:	003b68fa 	trap	3
8110780c:	df000215 	stw	fp,8(sp)
81107810:	df000204 	addi	fp,sp,8
81107814:	2005883a 	mov	r2,r4
81107818:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110781c:	00a00034 	movhi	r2,32768
81107820:	10828404 	addi	r2,r2,2576
81107824:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
81107828:	e0bffe17 	ldw	r2,-8(fp)
8110782c:	10800104 	addi	r2,r2,4
81107830:	e0ffff03 	ldbu	r3,-4(fp)
81107834:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
81107838:	00800044 	movi	r2,1
}
8110783c:	e037883a 	mov	sp,fp
81107840:	df000017 	ldw	fp,0(sp)
81107844:	dec00104 	addi	sp,sp,4
81107848:	f800283a 	ret

8110784c <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110784c:	defffd04 	addi	sp,sp,-12
81107850:	de00012e 	bgeu	sp,et,81107858 <vSyncHandleIrq+0xc>
81107854:	003b68fa 	trap	3
81107858:	df000215 	stw	fp,8(sp)
8110785c:	df000204 	addi	fp,sp,8
81107860:	e13fff15 	stw	r4,-4(fp)
	// Cast pvContext to viHoldContext's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81107864:	e0bfff17 	ldw	r2,-4(fp)
81107868:	e0bffe15 	stw	r2,-8(fp)
	// Use pvContext value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vucN += 1;
8110786c:	d0a04703 	ldbu	r2,-32484(gp)
81107870:	10800044 	addi	r2,r2,1
81107874:	d0a04705 	stb	r2,-32484(gp)
}
81107878:	0001883a 	nop
8110787c:	e037883a 	mov	sp,fp
81107880:	df000017 	ldw	fp,0(sp)
81107884:	dec00104 	addi	sp,sp,4
81107888:	f800283a 	ret

8110788c <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110788c:	defffd04 	addi	sp,sp,-12
81107890:	de00012e 	bgeu	sp,et,81107898 <vSyncInitIrq+0xc>
81107894:	003b68fa 	trap	3
81107898:	dfc00215 	stw	ra,8(sp)
8110789c:	df000115 	stw	fp,4(sp)
811078a0:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
811078a4:	d0a04604 	addi	r2,gp,-32488
811078a8:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
811078ac:	01a04434 	movhi	r6,33040
811078b0:	319e1304 	addi	r6,r6,30796
811078b4:	e17fff17 	ldw	r5,-4(fp)
811078b8:	01000284 	movi	r4,10
811078bc:	11280c00 	call	811280c0 <alt_irq_register>
}
811078c0:	0001883a 	nop
811078c4:	e037883a 	mov	sp,fp
811078c8:	dfc00117 	ldw	ra,4(sp)
811078cc:	df000017 	ldw	fp,0(sp)
811078d0:	dec00204 	addi	sp,sp,8
811078d4:	f800283a 	ret

811078d8 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
811078d8:	defffc04 	addi	sp,sp,-16
811078dc:	de00012e 	bgeu	sp,et,811078e4 <bSyncStatusExtnIrq+0xc>
811078e0:	003b68fa 	trap	3
811078e4:	dfc00315 	stw	ra,12(sp)
811078e8:	df000215 	stw	fp,8(sp)
811078ec:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
811078f0:	0009883a 	mov	r4,zero
811078f4:	11086880 	call	81108688 <uliSyncReadReg>
811078f8:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
811078fc:	e0bfff17 	ldw	r2,-4(fp)
81107900:	1000030e 	bge	r2,zero,81107910 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
81107904:	00800044 	movi	r2,1
81107908:	e0bffe15 	stw	r2,-8(fp)
8110790c:	00000106 	br	81107914 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
81107910:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
81107914:	e0bffe17 	ldw	r2,-8(fp)
}
81107918:	e037883a 	mov	sp,fp
8110791c:	dfc00117 	ldw	ra,4(sp)
81107920:	df000017 	ldw	fp,0(sp)
81107924:	dec00204 	addi	sp,sp,8
81107928:	f800283a 	ret

8110792c <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110792c:	defffc04 	addi	sp,sp,-16
81107930:	de00012e 	bgeu	sp,et,81107938 <ucSyncStatusState+0xc>
81107934:	003b68fa 	trap	3
81107938:	dfc00315 	stw	ra,12(sp)
8110793c:	df000215 	stw	fp,8(sp)
81107940:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
81107944:	0009883a 	mov	r4,zero
81107948:	11086880 	call	81108688 <uliSyncReadReg>
8110794c:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
81107950:	e0bffe17 	ldw	r2,-8(fp)
81107954:	10803fec 	andhi	r2,r2,255
81107958:	1004d43a 	srli	r2,r2,16
8110795c:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
81107960:	e0bfff03 	ldbu	r2,-4(fp)
}
81107964:	e037883a 	mov	sp,fp
81107968:	dfc00117 	ldw	ra,4(sp)
8110796c:	df000017 	ldw	fp,0(sp)
81107970:	dec00204 	addi	sp,sp,8
81107974:	f800283a 	ret

81107978 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
81107978:	defffc04 	addi	sp,sp,-16
8110797c:	de00012e 	bgeu	sp,et,81107984 <ucSyncStatusErrorCode+0xc>
81107980:	003b68fa 	trap	3
81107984:	dfc00315 	stw	ra,12(sp)
81107988:	df000215 	stw	fp,8(sp)
8110798c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
81107990:	0009883a 	mov	r4,zero
81107994:	11086880 	call	81108688 <uliSyncReadReg>
81107998:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110799c:	e0bffe17 	ldw	r2,-8(fp)
811079a0:	10bfc00c 	andi	r2,r2,65280
811079a4:	1004d23a 	srli	r2,r2,8
811079a8:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
811079ac:	e0bfff03 	ldbu	r2,-4(fp)
}
811079b0:	e037883a 	mov	sp,fp
811079b4:	dfc00117 	ldw	ra,4(sp)
811079b8:	df000017 	ldw	fp,0(sp)
811079bc:	dec00204 	addi	sp,sp,8
811079c0:	f800283a 	ret

811079c4 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
811079c4:	defffc04 	addi	sp,sp,-16
811079c8:	de00012e 	bgeu	sp,et,811079d0 <ucSyncStatusCycleNumber+0xc>
811079cc:	003b68fa 	trap	3
811079d0:	dfc00315 	stw	ra,12(sp)
811079d4:	df000215 	stw	fp,8(sp)
811079d8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
811079dc:	0009883a 	mov	r4,zero
811079e0:	11086880 	call	81108688 <uliSyncReadReg>
811079e4:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
811079e8:	e0bffe17 	ldw	r2,-8(fp)
811079ec:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
811079f0:	e0bfff03 	ldbu	r2,-4(fp)
}
811079f4:	e037883a 	mov	sp,fp
811079f8:	dfc00117 	ldw	ra,4(sp)
811079fc:	df000017 	ldw	fp,0(sp)
81107a00:	dec00204 	addi	sp,sp,8
81107a04:	f800283a 	ret

81107a08 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
81107a08:	defffd04 	addi	sp,sp,-12
81107a0c:	de00012e 	bgeu	sp,et,81107a14 <bSyncSetMbt+0xc>
81107a10:	003b68fa 	trap	3
81107a14:	dfc00215 	stw	ra,8(sp)
81107a18:	df000115 	stw	fp,4(sp)
81107a1c:	df000104 	addi	fp,sp,4
81107a20:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
81107a24:	e17fff17 	ldw	r5,-4(fp)
81107a28:	01000104 	movi	r4,4
81107a2c:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107a30:	00800044 	movi	r2,1
}
81107a34:	e037883a 	mov	sp,fp
81107a38:	dfc00117 	ldw	ra,4(sp)
81107a3c:	df000017 	ldw	fp,0(sp)
81107a40:	dec00204 	addi	sp,sp,8
81107a44:	f800283a 	ret

81107a48 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
81107a48:	defffd04 	addi	sp,sp,-12
81107a4c:	de00012e 	bgeu	sp,et,81107a54 <bSyncSetBt+0xc>
81107a50:	003b68fa 	trap	3
81107a54:	dfc00215 	stw	ra,8(sp)
81107a58:	df000115 	stw	fp,4(sp)
81107a5c:	df000104 	addi	fp,sp,4
81107a60:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
81107a64:	e17fff17 	ldw	r5,-4(fp)
81107a68:	01000144 	movi	r4,5
81107a6c:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107a70:	00800044 	movi	r2,1
}
81107a74:	e037883a 	mov	sp,fp
81107a78:	dfc00117 	ldw	ra,4(sp)
81107a7c:	df000017 	ldw	fp,0(sp)
81107a80:	dec00204 	addi	sp,sp,8
81107a84:	f800283a 	ret

81107a88 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
81107a88:	defffd04 	addi	sp,sp,-12
81107a8c:	de00012e 	bgeu	sp,et,81107a94 <bSyncSetPer+0xc>
81107a90:	003b68fa 	trap	3
81107a94:	dfc00215 	stw	ra,8(sp)
81107a98:	df000115 	stw	fp,4(sp)
81107a9c:	df000104 	addi	fp,sp,4
81107aa0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
81107aa4:	e17fff17 	ldw	r5,-4(fp)
81107aa8:	01000184 	movi	r4,6
81107aac:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107ab0:	00800044 	movi	r2,1
}
81107ab4:	e037883a 	mov	sp,fp
81107ab8:	dfc00117 	ldw	ra,4(sp)
81107abc:	df000017 	ldw	fp,0(sp)
81107ac0:	dec00204 	addi	sp,sp,8
81107ac4:	f800283a 	ret

81107ac8 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
81107ac8:	defffd04 	addi	sp,sp,-12
81107acc:	de00012e 	bgeu	sp,et,81107ad4 <bSyncSetOst+0xc>
81107ad0:	003b68fa 	trap	3
81107ad4:	dfc00215 	stw	ra,8(sp)
81107ad8:	df000115 	stw	fp,4(sp)
81107adc:	df000104 	addi	fp,sp,4
81107ae0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
81107ae4:	e17fff17 	ldw	r5,-4(fp)
81107ae8:	010001c4 	movi	r4,7
81107aec:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107af0:	00800044 	movi	r2,1
}
81107af4:	e037883a 	mov	sp,fp
81107af8:	dfc00117 	ldw	ra,4(sp)
81107afc:	df000017 	ldw	fp,0(sp)
81107b00:	dec00204 	addi	sp,sp,8
81107b04:	f800283a 	ret

81107b08 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
81107b08:	defffc04 	addi	sp,sp,-16
81107b0c:	de00012e 	bgeu	sp,et,81107b14 <bSyncSetPolarity+0xc>
81107b10:	003b68fa 	trap	3
81107b14:	dfc00315 	stw	ra,12(sp)
81107b18:	df000215 	stw	fp,8(sp)
81107b1c:	df000204 	addi	fp,sp,8
81107b20:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
81107b24:	01000204 	movi	r4,8
81107b28:	11086880 	call	81108688 <uliSyncReadReg>
81107b2c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81107b30:	e0bfff17 	ldw	r2,-4(fp)
81107b34:	1000051e 	bne	r2,zero,81107b4c <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
81107b38:	e0fffe17 	ldw	r3,-8(fp)
81107b3c:	00bfbfc4 	movi	r2,-257
81107b40:	1884703a 	and	r2,r3,r2
81107b44:	e0bffe15 	stw	r2,-8(fp)
81107b48:	00000306 	br	81107b58 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
81107b4c:	e0bffe17 	ldw	r2,-8(fp)
81107b50:	10804014 	ori	r2,r2,256
81107b54:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
81107b58:	e17ffe17 	ldw	r5,-8(fp)
81107b5c:	01000204 	movi	r4,8
81107b60:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107b64:	00800044 	movi	r2,1
}
81107b68:	e037883a 	mov	sp,fp
81107b6c:	dfc00117 	ldw	ra,4(sp)
81107b70:	df000017 	ldw	fp,0(sp)
81107b74:	dec00204 	addi	sp,sp,8
81107b78:	f800283a 	ret

81107b7c <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
81107b7c:	defffc04 	addi	sp,sp,-16
81107b80:	de00012e 	bgeu	sp,et,81107b88 <bSyncSetNCycles+0xc>
81107b84:	003b68fa 	trap	3
81107b88:	dfc00315 	stw	ra,12(sp)
81107b8c:	df000215 	stw	fp,8(sp)
81107b90:	df000204 	addi	fp,sp,8
81107b94:	2005883a 	mov	r2,r4
81107b98:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
81107b9c:	01000204 	movi	r4,8
81107ba0:	11086880 	call	81108688 <uliSyncReadReg>
81107ba4:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
81107ba8:	e0fffe17 	ldw	r3,-8(fp)
81107bac:	00bfc004 	movi	r2,-256
81107bb0:	1884703a 	and	r2,r3,r2
81107bb4:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
81107bb8:	e0bfff03 	ldbu	r2,-4(fp)
81107bbc:	e0fffe17 	ldw	r3,-8(fp)
81107bc0:	1884b03a 	or	r2,r3,r2
81107bc4:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
81107bc8:	e17ffe17 	ldw	r5,-8(fp)
81107bcc:	01000204 	movi	r4,8
81107bd0:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107bd4:	00800044 	movi	r2,1
}
81107bd8:	e037883a 	mov	sp,fp
81107bdc:	dfc00117 	ldw	ra,4(sp)
81107be0:	df000017 	ldw	fp,0(sp)
81107be4:	dec00204 	addi	sp,sp,8
81107be8:	f800283a 	ret

81107bec <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
81107bec:	defffd04 	addi	sp,sp,-12
81107bf0:	de00012e 	bgeu	sp,et,81107bf8 <uliSyncGetMbt+0xc>
81107bf4:	003b68fa 	trap	3
81107bf8:	dfc00215 	stw	ra,8(sp)
81107bfc:	df000115 	stw	fp,4(sp)
81107c00:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
81107c04:	01000104 	movi	r4,4
81107c08:	11086880 	call	81108688 <uliSyncReadReg>
81107c0c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107c10:	e0bfff17 	ldw	r2,-4(fp)
}
81107c14:	e037883a 	mov	sp,fp
81107c18:	dfc00117 	ldw	ra,4(sp)
81107c1c:	df000017 	ldw	fp,0(sp)
81107c20:	dec00204 	addi	sp,sp,8
81107c24:	f800283a 	ret

81107c28 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
81107c28:	defffd04 	addi	sp,sp,-12
81107c2c:	de00012e 	bgeu	sp,et,81107c34 <uliSyncGetBt+0xc>
81107c30:	003b68fa 	trap	3
81107c34:	dfc00215 	stw	ra,8(sp)
81107c38:	df000115 	stw	fp,4(sp)
81107c3c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
81107c40:	01000144 	movi	r4,5
81107c44:	11086880 	call	81108688 <uliSyncReadReg>
81107c48:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107c4c:	e0bfff17 	ldw	r2,-4(fp)
}
81107c50:	e037883a 	mov	sp,fp
81107c54:	dfc00117 	ldw	ra,4(sp)
81107c58:	df000017 	ldw	fp,0(sp)
81107c5c:	dec00204 	addi	sp,sp,8
81107c60:	f800283a 	ret

81107c64 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
81107c64:	defffd04 	addi	sp,sp,-12
81107c68:	de00012e 	bgeu	sp,et,81107c70 <uliSyncGetPer+0xc>
81107c6c:	003b68fa 	trap	3
81107c70:	dfc00215 	stw	ra,8(sp)
81107c74:	df000115 	stw	fp,4(sp)
81107c78:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
81107c7c:	01000184 	movi	r4,6
81107c80:	11086880 	call	81108688 <uliSyncReadReg>
81107c84:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107c88:	e0bfff17 	ldw	r2,-4(fp)
}
81107c8c:	e037883a 	mov	sp,fp
81107c90:	dfc00117 	ldw	ra,4(sp)
81107c94:	df000017 	ldw	fp,0(sp)
81107c98:	dec00204 	addi	sp,sp,8
81107c9c:	f800283a 	ret

81107ca0 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
81107ca0:	defffd04 	addi	sp,sp,-12
81107ca4:	de00012e 	bgeu	sp,et,81107cac <uliSyncGetOst+0xc>
81107ca8:	003b68fa 	trap	3
81107cac:	dfc00215 	stw	ra,8(sp)
81107cb0:	df000115 	stw	fp,4(sp)
81107cb4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
81107cb8:	010001c4 	movi	r4,7
81107cbc:	11086880 	call	81108688 <uliSyncReadReg>
81107cc0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107cc4:	e0bfff17 	ldw	r2,-4(fp)
}
81107cc8:	e037883a 	mov	sp,fp
81107ccc:	dfc00117 	ldw	ra,4(sp)
81107cd0:	df000017 	ldw	fp,0(sp)
81107cd4:	dec00204 	addi	sp,sp,8
81107cd8:	f800283a 	ret

81107cdc <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
81107cdc:	defffd04 	addi	sp,sp,-12
81107ce0:	de00012e 	bgeu	sp,et,81107ce8 <uliSyncGetGeneral+0xc>
81107ce4:	003b68fa 	trap	3
81107ce8:	dfc00215 	stw	ra,8(sp)
81107cec:	df000115 	stw	fp,4(sp)
81107cf0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
81107cf4:	01000204 	movi	r4,8
81107cf8:	11086880 	call	81108688 <uliSyncReadReg>
81107cfc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107d00:	e0bfff17 	ldw	r2,-4(fp)
}
81107d04:	e037883a 	mov	sp,fp
81107d08:	dfc00117 	ldw	ra,4(sp)
81107d0c:	df000017 	ldw	fp,0(sp)
81107d10:	dec00204 	addi	sp,sp,8
81107d14:	f800283a 	ret

81107d18 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
81107d18:	defffd04 	addi	sp,sp,-12
81107d1c:	de00012e 	bgeu	sp,et,81107d24 <bSyncErrInj+0xc>
81107d20:	003b68fa 	trap	3
81107d24:	dfc00215 	stw	ra,8(sp)
81107d28:	df000115 	stw	fp,4(sp)
81107d2c:	df000104 	addi	fp,sp,4
81107d30:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
81107d34:	e17fff17 	ldw	r5,-4(fp)
81107d38:	01000244 	movi	r4,9
81107d3c:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107d40:	00800044 	movi	r2,1
}
81107d44:	e037883a 	mov	sp,fp
81107d48:	dfc00117 	ldw	ra,4(sp)
81107d4c:	df000017 	ldw	fp,0(sp)
81107d50:	dec00204 	addi	sp,sp,8
81107d54:	f800283a 	ret

81107d58 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
81107d58:	defffc04 	addi	sp,sp,-16
81107d5c:	de00012e 	bgeu	sp,et,81107d64 <bSyncCtrExtnIrq+0xc>
81107d60:	003b68fa 	trap	3
81107d64:	dfc00315 	stw	ra,12(sp)
81107d68:	df000215 	stw	fp,8(sp)
81107d6c:	df000204 	addi	fp,sp,8
81107d70:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107d74:	01000284 	movi	r4,10
81107d78:	11086880 	call	81108688 <uliSyncReadReg>
81107d7c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81107d80:	e0bfff17 	ldw	r2,-4(fp)
81107d84:	1000061e 	bne	r2,zero,81107da0 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
81107d88:	e0fffe17 	ldw	r3,-8(fp)
81107d8c:	00a00034 	movhi	r2,32768
81107d90:	10bfffc4 	addi	r2,r2,-1
81107d94:	1884703a 	and	r2,r3,r2
81107d98:	e0bffe15 	stw	r2,-8(fp)
81107d9c:	00000306 	br	81107dac <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
81107da0:	e0bffe17 	ldw	r2,-8(fp)
81107da4:	10a00034 	orhi	r2,r2,32768
81107da8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107dac:	e17ffe17 	ldw	r5,-8(fp)
81107db0:	01000284 	movi	r4,10
81107db4:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107db8:	00800044 	movi	r2,1
}
81107dbc:	e037883a 	mov	sp,fp
81107dc0:	dfc00117 	ldw	ra,4(sp)
81107dc4:	df000017 	ldw	fp,0(sp)
81107dc8:	dec00204 	addi	sp,sp,8
81107dcc:	f800283a 	ret

81107dd0 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
81107dd0:	defffd04 	addi	sp,sp,-12
81107dd4:	de00012e 	bgeu	sp,et,81107ddc <bSyncCtrStart+0xc>
81107dd8:	003b68fa 	trap	3
81107ddc:	dfc00215 	stw	ra,8(sp)
81107de0:	df000115 	stw	fp,4(sp)
81107de4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107de8:	01000284 	movi	r4,10
81107dec:	11086880 	call	81108688 <uliSyncReadReg>
81107df0:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
81107df4:	e0bfff17 	ldw	r2,-4(fp)
81107df8:	10800234 	orhi	r2,r2,8
81107dfc:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107e00:	e17fff17 	ldw	r5,-4(fp)
81107e04:	01000284 	movi	r4,10
81107e08:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107e0c:	00800044 	movi	r2,1
}
81107e10:	e037883a 	mov	sp,fp
81107e14:	dfc00117 	ldw	ra,4(sp)
81107e18:	df000017 	ldw	fp,0(sp)
81107e1c:	dec00204 	addi	sp,sp,8
81107e20:	f800283a 	ret

81107e24 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
81107e24:	defffd04 	addi	sp,sp,-12
81107e28:	de00012e 	bgeu	sp,et,81107e30 <bSyncCtrReset+0xc>
81107e2c:	003b68fa 	trap	3
81107e30:	dfc00215 	stw	ra,8(sp)
81107e34:	df000115 	stw	fp,4(sp)
81107e38:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107e3c:	01000284 	movi	r4,10
81107e40:	11086880 	call	81108688 <uliSyncReadReg>
81107e44:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
81107e48:	e0bfff17 	ldw	r2,-4(fp)
81107e4c:	10800134 	orhi	r2,r2,4
81107e50:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107e54:	e17fff17 	ldw	r5,-4(fp)
81107e58:	01000284 	movi	r4,10
81107e5c:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107e60:	00800044 	movi	r2,1
}
81107e64:	e037883a 	mov	sp,fp
81107e68:	dfc00117 	ldw	ra,4(sp)
81107e6c:	df000017 	ldw	fp,0(sp)
81107e70:	dec00204 	addi	sp,sp,8
81107e74:	f800283a 	ret

81107e78 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
81107e78:	defffd04 	addi	sp,sp,-12
81107e7c:	de00012e 	bgeu	sp,et,81107e84 <bSyncCtrOneShot+0xc>
81107e80:	003b68fa 	trap	3
81107e84:	dfc00215 	stw	ra,8(sp)
81107e88:	df000115 	stw	fp,4(sp)
81107e8c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107e90:	01000284 	movi	r4,10
81107e94:	11086880 	call	81108688 <uliSyncReadReg>
81107e98:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
81107e9c:	e0bfff17 	ldw	r2,-4(fp)
81107ea0:	108000b4 	orhi	r2,r2,2
81107ea4:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107ea8:	e17fff17 	ldw	r5,-4(fp)
81107eac:	01000284 	movi	r4,10
81107eb0:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107eb4:	00800044 	movi	r2,1
}
81107eb8:	e037883a 	mov	sp,fp
81107ebc:	dfc00117 	ldw	ra,4(sp)
81107ec0:	df000017 	ldw	fp,0(sp)
81107ec4:	dec00204 	addi	sp,sp,8
81107ec8:	f800283a 	ret

81107ecc <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
81107ecc:	defffd04 	addi	sp,sp,-12
81107ed0:	de00012e 	bgeu	sp,et,81107ed8 <bSyncCtrErrInj+0xc>
81107ed4:	003b68fa 	trap	3
81107ed8:	dfc00215 	stw	ra,8(sp)
81107edc:	df000115 	stw	fp,4(sp)
81107ee0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107ee4:	01000284 	movi	r4,10
81107ee8:	11086880 	call	81108688 <uliSyncReadReg>
81107eec:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
81107ef0:	e0bfff17 	ldw	r2,-4(fp)
81107ef4:	10800074 	orhi	r2,r2,1
81107ef8:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107efc:	e17fff17 	ldw	r5,-4(fp)
81107f00:	01000284 	movi	r4,10
81107f04:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107f08:	00800044 	movi	r2,1
}
81107f0c:	e037883a 	mov	sp,fp
81107f10:	dfc00117 	ldw	ra,4(sp)
81107f14:	df000017 	ldw	fp,0(sp)
81107f18:	dec00204 	addi	sp,sp,8
81107f1c:	f800283a 	ret

81107f20 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
81107f20:	defffc04 	addi	sp,sp,-16
81107f24:	de00012e 	bgeu	sp,et,81107f2c <bSyncCtrSyncOutEnable+0xc>
81107f28:	003b68fa 	trap	3
81107f2c:	dfc00315 	stw	ra,12(sp)
81107f30:	df000215 	stw	fp,8(sp)
81107f34:	df000204 	addi	fp,sp,8
81107f38:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107f3c:	01000284 	movi	r4,10
81107f40:	11086880 	call	81108688 <uliSyncReadReg>
81107f44:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81107f48:	e0bfff17 	ldw	r2,-4(fp)
81107f4c:	1000051e 	bne	r2,zero,81107f64 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
81107f50:	e0fffe17 	ldw	r3,-8(fp)
81107f54:	00bfbfc4 	movi	r2,-257
81107f58:	1884703a 	and	r2,r3,r2
81107f5c:	e0bffe15 	stw	r2,-8(fp)
81107f60:	00000306 	br	81107f70 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
81107f64:	e0bffe17 	ldw	r2,-8(fp)
81107f68:	10804014 	ori	r2,r2,256
81107f6c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107f70:	e17ffe17 	ldw	r5,-8(fp)
81107f74:	01000284 	movi	r4,10
81107f78:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107f7c:	00800044 	movi	r2,1
}
81107f80:	e037883a 	mov	sp,fp
81107f84:	dfc00117 	ldw	ra,4(sp)
81107f88:	df000017 	ldw	fp,0(sp)
81107f8c:	dec00204 	addi	sp,sp,8
81107f90:	f800283a 	ret

81107f94 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
81107f94:	defffc04 	addi	sp,sp,-16
81107f98:	de00012e 	bgeu	sp,et,81107fa0 <bSyncCtrCh1OutEnable+0xc>
81107f9c:	003b68fa 	trap	3
81107fa0:	dfc00315 	stw	ra,12(sp)
81107fa4:	df000215 	stw	fp,8(sp)
81107fa8:	df000204 	addi	fp,sp,8
81107fac:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107fb0:	01000284 	movi	r4,10
81107fb4:	11086880 	call	81108688 <uliSyncReadReg>
81107fb8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81107fbc:	e0bfff17 	ldw	r2,-4(fp)
81107fc0:	1000051e 	bne	r2,zero,81107fd8 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
81107fc4:	e0fffe17 	ldw	r3,-8(fp)
81107fc8:	00bfff84 	movi	r2,-2
81107fcc:	1884703a 	and	r2,r3,r2
81107fd0:	e0bffe15 	stw	r2,-8(fp)
81107fd4:	00000306 	br	81107fe4 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
81107fd8:	e0bffe17 	ldw	r2,-8(fp)
81107fdc:	10800054 	ori	r2,r2,1
81107fe0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107fe4:	e17ffe17 	ldw	r5,-8(fp)
81107fe8:	01000284 	movi	r4,10
81107fec:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81107ff0:	00800044 	movi	r2,1
}
81107ff4:	e037883a 	mov	sp,fp
81107ff8:	dfc00117 	ldw	ra,4(sp)
81107ffc:	df000017 	ldw	fp,0(sp)
81108000:	dec00204 	addi	sp,sp,8
81108004:	f800283a 	ret

81108008 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
81108008:	defffc04 	addi	sp,sp,-16
8110800c:	de00012e 	bgeu	sp,et,81108014 <bSyncCtrCh2OutEnable+0xc>
81108010:	003b68fa 	trap	3
81108014:	dfc00315 	stw	ra,12(sp)
81108018:	df000215 	stw	fp,8(sp)
8110801c:	df000204 	addi	fp,sp,8
81108020:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108024:	01000284 	movi	r4,10
81108028:	11086880 	call	81108688 <uliSyncReadReg>
8110802c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108030:	e0bfff17 	ldw	r2,-4(fp)
81108034:	1000051e 	bne	r2,zero,8110804c <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
81108038:	e0fffe17 	ldw	r3,-8(fp)
8110803c:	00bfff44 	movi	r2,-3
81108040:	1884703a 	and	r2,r3,r2
81108044:	e0bffe15 	stw	r2,-8(fp)
81108048:	00000306 	br	81108058 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110804c:	e0bffe17 	ldw	r2,-8(fp)
81108050:	10800094 	ori	r2,r2,2
81108054:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108058:	e17ffe17 	ldw	r5,-8(fp)
8110805c:	01000284 	movi	r4,10
81108060:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81108064:	00800044 	movi	r2,1
}
81108068:	e037883a 	mov	sp,fp
8110806c:	dfc00117 	ldw	ra,4(sp)
81108070:	df000017 	ldw	fp,0(sp)
81108074:	dec00204 	addi	sp,sp,8
81108078:	f800283a 	ret

8110807c <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110807c:	defffc04 	addi	sp,sp,-16
81108080:	de00012e 	bgeu	sp,et,81108088 <bSyncCtrCh3OutEnable+0xc>
81108084:	003b68fa 	trap	3
81108088:	dfc00315 	stw	ra,12(sp)
8110808c:	df000215 	stw	fp,8(sp)
81108090:	df000204 	addi	fp,sp,8
81108094:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108098:	01000284 	movi	r4,10
8110809c:	11086880 	call	81108688 <uliSyncReadReg>
811080a0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811080a4:	e0bfff17 	ldw	r2,-4(fp)
811080a8:	1000051e 	bne	r2,zero,811080c0 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
811080ac:	e0fffe17 	ldw	r3,-8(fp)
811080b0:	00bffec4 	movi	r2,-5
811080b4:	1884703a 	and	r2,r3,r2
811080b8:	e0bffe15 	stw	r2,-8(fp)
811080bc:	00000306 	br	811080cc <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
811080c0:	e0bffe17 	ldw	r2,-8(fp)
811080c4:	10800114 	ori	r2,r2,4
811080c8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
811080cc:	e17ffe17 	ldw	r5,-8(fp)
811080d0:	01000284 	movi	r4,10
811080d4:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
811080d8:	00800044 	movi	r2,1
}
811080dc:	e037883a 	mov	sp,fp
811080e0:	dfc00117 	ldw	ra,4(sp)
811080e4:	df000017 	ldw	fp,0(sp)
811080e8:	dec00204 	addi	sp,sp,8
811080ec:	f800283a 	ret

811080f0 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
811080f0:	defffc04 	addi	sp,sp,-16
811080f4:	de00012e 	bgeu	sp,et,811080fc <bSyncCtrCh4OutEnable+0xc>
811080f8:	003b68fa 	trap	3
811080fc:	dfc00315 	stw	ra,12(sp)
81108100:	df000215 	stw	fp,8(sp)
81108104:	df000204 	addi	fp,sp,8
81108108:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110810c:	01000284 	movi	r4,10
81108110:	11086880 	call	81108688 <uliSyncReadReg>
81108114:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108118:	e0bfff17 	ldw	r2,-4(fp)
8110811c:	1000051e 	bne	r2,zero,81108134 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
81108120:	e0fffe17 	ldw	r3,-8(fp)
81108124:	00bffdc4 	movi	r2,-9
81108128:	1884703a 	and	r2,r3,r2
8110812c:	e0bffe15 	stw	r2,-8(fp)
81108130:	00000306 	br	81108140 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
81108134:	e0bffe17 	ldw	r2,-8(fp)
81108138:	10800214 	ori	r2,r2,8
8110813c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108140:	e17ffe17 	ldw	r5,-8(fp)
81108144:	01000284 	movi	r4,10
81108148:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
8110814c:	00800044 	movi	r2,1
}
81108150:	e037883a 	mov	sp,fp
81108154:	dfc00117 	ldw	ra,4(sp)
81108158:	df000017 	ldw	fp,0(sp)
8110815c:	dec00204 	addi	sp,sp,8
81108160:	f800283a 	ret

81108164 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
81108164:	defffc04 	addi	sp,sp,-16
81108168:	de00012e 	bgeu	sp,et,81108170 <bSyncCtrCh5OutEnable+0xc>
8110816c:	003b68fa 	trap	3
81108170:	dfc00315 	stw	ra,12(sp)
81108174:	df000215 	stw	fp,8(sp)
81108178:	df000204 	addi	fp,sp,8
8110817c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108180:	01000284 	movi	r4,10
81108184:	11086880 	call	81108688 <uliSyncReadReg>
81108188:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110818c:	e0bfff17 	ldw	r2,-4(fp)
81108190:	1000051e 	bne	r2,zero,811081a8 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
81108194:	e0fffe17 	ldw	r3,-8(fp)
81108198:	00bffbc4 	movi	r2,-17
8110819c:	1884703a 	and	r2,r3,r2
811081a0:	e0bffe15 	stw	r2,-8(fp)
811081a4:	00000306 	br	811081b4 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
811081a8:	e0bffe17 	ldw	r2,-8(fp)
811081ac:	10800414 	ori	r2,r2,16
811081b0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
811081b4:	e17ffe17 	ldw	r5,-8(fp)
811081b8:	01000284 	movi	r4,10
811081bc:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
811081c0:	00800044 	movi	r2,1
}
811081c4:	e037883a 	mov	sp,fp
811081c8:	dfc00117 	ldw	ra,4(sp)
811081cc:	df000017 	ldw	fp,0(sp)
811081d0:	dec00204 	addi	sp,sp,8
811081d4:	f800283a 	ret

811081d8 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
811081d8:	defffc04 	addi	sp,sp,-16
811081dc:	de00012e 	bgeu	sp,et,811081e4 <bSyncCtrCh6OutEnable+0xc>
811081e0:	003b68fa 	trap	3
811081e4:	dfc00315 	stw	ra,12(sp)
811081e8:	df000215 	stw	fp,8(sp)
811081ec:	df000204 	addi	fp,sp,8
811081f0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
811081f4:	01000284 	movi	r4,10
811081f8:	11086880 	call	81108688 <uliSyncReadReg>
811081fc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108200:	e0bfff17 	ldw	r2,-4(fp)
81108204:	1000051e 	bne	r2,zero,8110821c <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
81108208:	e0fffe17 	ldw	r3,-8(fp)
8110820c:	00bff7c4 	movi	r2,-33
81108210:	1884703a 	and	r2,r3,r2
81108214:	e0bffe15 	stw	r2,-8(fp)
81108218:	00000306 	br	81108228 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110821c:	e0bffe17 	ldw	r2,-8(fp)
81108220:	10800814 	ori	r2,r2,32
81108224:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108228:	e17ffe17 	ldw	r5,-8(fp)
8110822c:	01000284 	movi	r4,10
81108230:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81108234:	00800044 	movi	r2,1
}
81108238:	e037883a 	mov	sp,fp
8110823c:	dfc00117 	ldw	ra,4(sp)
81108240:	df000017 	ldw	fp,0(sp)
81108244:	dec00204 	addi	sp,sp,8
81108248:	f800283a 	ret

8110824c <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110824c:	defffc04 	addi	sp,sp,-16
81108250:	de00012e 	bgeu	sp,et,81108258 <bSyncCtrCh7OutEnable+0xc>
81108254:	003b68fa 	trap	3
81108258:	dfc00315 	stw	ra,12(sp)
8110825c:	df000215 	stw	fp,8(sp)
81108260:	df000204 	addi	fp,sp,8
81108264:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108268:	01000284 	movi	r4,10
8110826c:	11086880 	call	81108688 <uliSyncReadReg>
81108270:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108274:	e0bfff17 	ldw	r2,-4(fp)
81108278:	1000051e 	bne	r2,zero,81108290 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110827c:	e0fffe17 	ldw	r3,-8(fp)
81108280:	00bfefc4 	movi	r2,-65
81108284:	1884703a 	and	r2,r3,r2
81108288:	e0bffe15 	stw	r2,-8(fp)
8110828c:	00000306 	br	8110829c <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
81108290:	e0bffe17 	ldw	r2,-8(fp)
81108294:	10801014 	ori	r2,r2,64
81108298:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110829c:	e17ffe17 	ldw	r5,-8(fp)
811082a0:	01000284 	movi	r4,10
811082a4:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
811082a8:	00800044 	movi	r2,1
}
811082ac:	e037883a 	mov	sp,fp
811082b0:	dfc00117 	ldw	ra,4(sp)
811082b4:	df000017 	ldw	fp,0(sp)
811082b8:	dec00204 	addi	sp,sp,8
811082bc:	f800283a 	ret

811082c0 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
811082c0:	defffc04 	addi	sp,sp,-16
811082c4:	de00012e 	bgeu	sp,et,811082cc <bSyncCtrCh8OutEnable+0xc>
811082c8:	003b68fa 	trap	3
811082cc:	dfc00315 	stw	ra,12(sp)
811082d0:	df000215 	stw	fp,8(sp)
811082d4:	df000204 	addi	fp,sp,8
811082d8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
811082dc:	01000284 	movi	r4,10
811082e0:	11086880 	call	81108688 <uliSyncReadReg>
811082e4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811082e8:	e0bfff17 	ldw	r2,-4(fp)
811082ec:	1000051e 	bne	r2,zero,81108304 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
811082f0:	e0fffe17 	ldw	r3,-8(fp)
811082f4:	00bfdfc4 	movi	r2,-129
811082f8:	1884703a 	and	r2,r3,r2
811082fc:	e0bffe15 	stw	r2,-8(fp)
81108300:	00000306 	br	81108310 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
81108304:	e0bffe17 	ldw	r2,-8(fp)
81108308:	10802014 	ori	r2,r2,128
8110830c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108310:	e17ffe17 	ldw	r5,-8(fp)
81108314:	01000284 	movi	r4,10
81108318:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
8110831c:	00800044 	movi	r2,1
}
81108320:	e037883a 	mov	sp,fp
81108324:	dfc00117 	ldw	ra,4(sp)
81108328:	df000017 	ldw	fp,0(sp)
8110832c:	dec00204 	addi	sp,sp,8
81108330:	f800283a 	ret

81108334 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
81108334:	defffc04 	addi	sp,sp,-16
81108338:	de00012e 	bgeu	sp,et,81108340 <bSyncIrqEnableError+0xc>
8110833c:	003b68fa 	trap	3
81108340:	dfc00315 	stw	ra,12(sp)
81108344:	df000215 	stw	fp,8(sp)
81108348:	df000204 	addi	fp,sp,8
8110834c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
81108350:	01000044 	movi	r4,1
81108354:	11086880 	call	81108688 <uliSyncReadReg>
81108358:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110835c:	e0bfff17 	ldw	r2,-4(fp)
81108360:	1000051e 	bne	r2,zero,81108378 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
81108364:	e0fffe17 	ldw	r3,-8(fp)
81108368:	00bfff44 	movi	r2,-3
8110836c:	1884703a 	and	r2,r3,r2
81108370:	e0bffe15 	stw	r2,-8(fp)
81108374:	00000306 	br	81108384 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
81108378:	e0bffe17 	ldw	r2,-8(fp)
8110837c:	10800094 	ori	r2,r2,2
81108380:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
81108384:	e17ffe17 	ldw	r5,-8(fp)
81108388:	01000044 	movi	r4,1
8110838c:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81108390:	00800044 	movi	r2,1
}
81108394:	e037883a 	mov	sp,fp
81108398:	dfc00117 	ldw	ra,4(sp)
8110839c:	df000017 	ldw	fp,0(sp)
811083a0:	dec00204 	addi	sp,sp,8
811083a4:	f800283a 	ret

811083a8 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
811083a8:	defffc04 	addi	sp,sp,-16
811083ac:	de00012e 	bgeu	sp,et,811083b4 <bSyncIrqEnableBlank+0xc>
811083b0:	003b68fa 	trap	3
811083b4:	dfc00315 	stw	ra,12(sp)
811083b8:	df000215 	stw	fp,8(sp)
811083bc:	df000204 	addi	fp,sp,8
811083c0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
811083c4:	01000044 	movi	r4,1
811083c8:	11086880 	call	81108688 <uliSyncReadReg>
811083cc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811083d0:	e0bfff17 	ldw	r2,-4(fp)
811083d4:	1000051e 	bne	r2,zero,811083ec <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
811083d8:	e0fffe17 	ldw	r3,-8(fp)
811083dc:	00bfff84 	movi	r2,-2
811083e0:	1884703a 	and	r2,r3,r2
811083e4:	e0bffe15 	stw	r2,-8(fp)
811083e8:	00000306 	br	811083f8 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
811083ec:	e0bffe17 	ldw	r2,-8(fp)
811083f0:	10800054 	ori	r2,r2,1
811083f4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
811083f8:	e17ffe17 	ldw	r5,-8(fp)
811083fc:	01000044 	movi	r4,1
81108400:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81108404:	00800044 	movi	r2,1
}
81108408:	e037883a 	mov	sp,fp
8110840c:	dfc00117 	ldw	ra,4(sp)
81108410:	df000017 	ldw	fp,0(sp)
81108414:	dec00204 	addi	sp,sp,8
81108418:	f800283a 	ret

8110841c <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110841c:	defffc04 	addi	sp,sp,-16
81108420:	de00012e 	bgeu	sp,et,81108428 <bSyncIrqFlagClrError+0xc>
81108424:	003b68fa 	trap	3
81108428:	dfc00315 	stw	ra,12(sp)
8110842c:	df000215 	stw	fp,8(sp)
81108430:	df000204 	addi	fp,sp,8
81108434:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
81108438:	01000084 	movi	r4,2
8110843c:	11086880 	call	81108688 <uliSyncReadReg>
81108440:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108444:	e0bfff17 	ldw	r2,-4(fp)
81108448:	1000051e 	bne	r2,zero,81108460 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110844c:	e0fffe17 	ldw	r3,-8(fp)
81108450:	00bfff44 	movi	r2,-3
81108454:	1884703a 	and	r2,r3,r2
81108458:	e0bffe15 	stw	r2,-8(fp)
8110845c:	00000306 	br	8110846c <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
81108460:	e0bffe17 	ldw	r2,-8(fp)
81108464:	10800094 	ori	r2,r2,2
81108468:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110846c:	e17ffe17 	ldw	r5,-8(fp)
81108470:	01000084 	movi	r4,2
81108474:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
81108478:	00800044 	movi	r2,1
}
8110847c:	e037883a 	mov	sp,fp
81108480:	dfc00117 	ldw	ra,4(sp)
81108484:	df000017 	ldw	fp,0(sp)
81108488:	dec00204 	addi	sp,sp,8
8110848c:	f800283a 	ret

81108490 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
81108490:	defffc04 	addi	sp,sp,-16
81108494:	de00012e 	bgeu	sp,et,8110849c <bSyncIrqFlagClrBlank+0xc>
81108498:	003b68fa 	trap	3
8110849c:	dfc00315 	stw	ra,12(sp)
811084a0:	df000215 	stw	fp,8(sp)
811084a4:	df000204 	addi	fp,sp,8
811084a8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
811084ac:	01000084 	movi	r4,2
811084b0:	11086880 	call	81108688 <uliSyncReadReg>
811084b4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811084b8:	e0bfff17 	ldw	r2,-4(fp)
811084bc:	1000051e 	bne	r2,zero,811084d4 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
811084c0:	e0fffe17 	ldw	r3,-8(fp)
811084c4:	00bfff84 	movi	r2,-2
811084c8:	1884703a 	and	r2,r3,r2
811084cc:	e0bffe15 	stw	r2,-8(fp)
811084d0:	00000306 	br	811084e0 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
811084d4:	e0bffe17 	ldw	r2,-8(fp)
811084d8:	10800054 	ori	r2,r2,1
811084dc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
811084e0:	e17ffe17 	ldw	r5,-8(fp)
811084e4:	01000084 	movi	r4,2
811084e8:	110862c0 	call	8110862c <bSyncWriteReg>
	return TRUE;
811084ec:	00800044 	movi	r2,1
}
811084f0:	e037883a 	mov	sp,fp
811084f4:	dfc00117 	ldw	ra,4(sp)
811084f8:	df000017 	ldw	fp,0(sp)
811084fc:	dec00204 	addi	sp,sp,8
81108500:	f800283a 	ret

81108504 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
81108504:	defffc04 	addi	sp,sp,-16
81108508:	de00012e 	bgeu	sp,et,81108510 <bSyncIrqFlagError+0xc>
8110850c:	003b68fa 	trap	3
81108510:	dfc00315 	stw	ra,12(sp)
81108514:	df000215 	stw	fp,8(sp)
81108518:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110851c:	010000c4 	movi	r4,3
81108520:	11086880 	call	81108688 <uliSyncReadReg>
81108524:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
81108528:	e0bfff17 	ldw	r2,-4(fp)
8110852c:	1080008c 	andi	r2,r2,2
81108530:	10000326 	beq	r2,zero,81108540 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
81108534:	00800044 	movi	r2,1
81108538:	e0bffe15 	stw	r2,-8(fp)
8110853c:	00000106 	br	81108544 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
81108540:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
81108544:	e0bffe17 	ldw	r2,-8(fp)
}
81108548:	e037883a 	mov	sp,fp
8110854c:	dfc00117 	ldw	ra,4(sp)
81108550:	df000017 	ldw	fp,0(sp)
81108554:	dec00204 	addi	sp,sp,8
81108558:	f800283a 	ret

8110855c <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110855c:	defffc04 	addi	sp,sp,-16
81108560:	de00012e 	bgeu	sp,et,81108568 <bSyncIrqFlagBlank+0xc>
81108564:	003b68fa 	trap	3
81108568:	dfc00315 	stw	ra,12(sp)
8110856c:	df000215 	stw	fp,8(sp)
81108570:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
81108574:	010000c4 	movi	r4,3
81108578:	11086880 	call	81108688 <uliSyncReadReg>
8110857c:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
81108580:	e0bfff17 	ldw	r2,-4(fp)
81108584:	1080004c 	andi	r2,r2,1
81108588:	10000326 	beq	r2,zero,81108598 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110858c:	00800044 	movi	r2,1
81108590:	e0bffe15 	stw	r2,-8(fp)
81108594:	00000106 	br	8110859c <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
81108598:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110859c:	e0bffe17 	ldw	r2,-8(fp)
}
811085a0:	e037883a 	mov	sp,fp
811085a4:	dfc00117 	ldw	ra,4(sp)
811085a8:	df000017 	ldw	fp,0(sp)
811085ac:	dec00204 	addi	sp,sp,8
811085b0:	f800283a 	ret

811085b4 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
811085b4:	defffd04 	addi	sp,sp,-12
811085b8:	de00012e 	bgeu	sp,et,811085c0 <uliSyncGetCtr+0xc>
811085bc:	003b68fa 	trap	3
811085c0:	dfc00215 	stw	ra,8(sp)
811085c4:	df000115 	stw	fp,4(sp)
811085c8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
811085cc:	01000284 	movi	r4,10
811085d0:	11086880 	call	81108688 <uliSyncReadReg>
811085d4:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
811085d8:	e0bfff17 	ldw	r2,-4(fp)
}
811085dc:	e037883a 	mov	sp,fp
811085e0:	dfc00117 	ldw	ra,4(sp)
811085e4:	df000017 	ldw	fp,0(sp)
811085e8:	dec00204 	addi	sp,sp,8
811085ec:	f800283a 	ret

811085f0 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
811085f0:	defffd04 	addi	sp,sp,-12
811085f4:	de00012e 	bgeu	sp,et,811085fc <uliSyncReadStatus+0xc>
811085f8:	003b68fa 	trap	3
811085fc:	dfc00215 	stw	ra,8(sp)
81108600:	df000115 	stw	fp,4(sp)
81108604:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
81108608:	0009883a 	mov	r4,zero
8110860c:	11086880 	call	81108688 <uliSyncReadReg>
81108610:	e0bfff15 	stw	r2,-4(fp)
	return aux;
81108614:	e0bfff17 	ldw	r2,-4(fp)
}
81108618:	e037883a 	mov	sp,fp
8110861c:	dfc00117 	ldw	ra,4(sp)
81108620:	df000017 	ldw	fp,0(sp)
81108624:	dec00204 	addi	sp,sp,8
81108628:	f800283a 	ret

8110862c <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
static bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110862c:	defffc04 	addi	sp,sp,-16
81108630:	de00012e 	bgeu	sp,et,81108638 <bSyncWriteReg+0xc>
81108634:	003b68fa 	trap	3
81108638:	df000315 	stw	fp,12(sp)
8110863c:	df000304 	addi	fp,sp,12
81108640:	e13ffe15 	stw	r4,-8(fp)
81108644:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
81108648:	00a00034 	movhi	r2,32768
8110864c:	10810004 	addi	r2,r2,1024
81108650:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
81108654:	e0bffe17 	ldw	r2,-8(fp)
81108658:	1085883a 	add	r2,r2,r2
8110865c:	1085883a 	add	r2,r2,r2
81108660:	1007883a 	mov	r3,r2
81108664:	e0bffd17 	ldw	r2,-12(fp)
81108668:	10c5883a 	add	r2,r2,r3
8110866c:	e0ffff17 	ldw	r3,-4(fp)
81108670:	10c00015 	stw	r3,0(r2)
	return TRUE;
81108674:	00800044 	movi	r2,1
}
81108678:	e037883a 	mov	sp,fp
8110867c:	df000017 	ldw	fp,0(sp)
81108680:	dec00104 	addi	sp,sp,4
81108684:	f800283a 	ret

81108688 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
static alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
81108688:	defffc04 	addi	sp,sp,-16
8110868c:	de00012e 	bgeu	sp,et,81108694 <uliSyncReadReg+0xc>
81108690:	003b68fa 	trap	3
81108694:	df000315 	stw	fp,12(sp)
81108698:	df000304 	addi	fp,sp,12
8110869c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
811086a0:	00a00034 	movhi	r2,32768
811086a4:	10810004 	addi	r2,r2,1024
811086a8:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
811086ac:	e0bfff17 	ldw	r2,-4(fp)
811086b0:	1085883a 	add	r2,r2,r2
811086b4:	1085883a 	add	r2,r2,r2
811086b8:	1007883a 	mov	r3,r2
811086bc:	e0bffd17 	ldw	r2,-12(fp)
811086c0:	10c5883a 	add	r2,r2,r3
811086c4:	10800017 	ldw	r2,0(r2)
811086c8:	e0bffe15 	stw	r2,-8(fp)
	return value;
811086cc:	e0bffe17 	ldw	r2,-8(fp)
}
811086d0:	e037883a 	mov	sp,fp
811086d4:	df000017 	ldw	fp,0(sp)
811086d8:	dec00104 	addi	sp,sp,4
811086dc:	f800283a 	ret

811086e0 <vFeeTask>:

#include "fee_task.h"



void vFeeTask(void *task_data) {
811086e0:	defffd04 	addi	sp,sp,-12
811086e4:	de00012e 	bgeu	sp,et,811086ec <vFeeTask+0xc>
811086e8:	003b68fa 	trap	3
811086ec:	df000215 	stw	fp,8(sp)
811086f0:	df000204 	addi	fp,sp,8
811086f4:	e13fff15 	stw	r4,-4(fp)
	tFEEStates eFeeState;
	bool bSuccess = FALSE;
811086f8:	e03ffe15 	stw	zero,-8(fp)

		// Check sync ?
			// mudar de estado se isso estiver agendado


}
811086fc:	0001883a 	nop
81108700:	e037883a 	mov	sp,fp
81108704:	df000017 	ldw	fp,0(sp)
81108708:	dec00104 	addi	sp,sp,4
8110870c:	f800283a 	ret

81108710 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
81108710:	defff604 	addi	sp,sp,-40
81108714:	de00012e 	bgeu	sp,et,8110871c <vInAckHandlerTaskV2+0xc>
81108718:	003b68fa 	trap	3
8110871c:	dfc00915 	stw	ra,36(sp)
81108720:	df000815 	stw	fp,32(sp)
81108724:	df000804 	addi	fp,sp,32
81108728:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8110872c:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
81108730:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
81108734:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
81108738:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
8110873c:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
81108740:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
81108744:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
81108748:	d0a04e17 	ldw	r2,-32456(gp)
8110874c:	100f883a 	mov	r7,r2
81108750:	018007c4 	movi	r6,31
81108754:	01400044 	movi	r5,1
81108758:	01204534 	movhi	r4,33044
8110875c:	2135ac04 	addi	r4,r4,-10576
81108760:	1112ccc0 	call	81112ccc <fwrite>
    #endif    

	eReceiverAckState = sRAConfiguring;
81108764:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
81108768:	e0bff917 	ldw	r2,-28(fp)
8110876c:	10c00060 	cmpeqi	r3,r2,1
81108770:	1800071e 	bne	r3,zero,81108790 <vInAckHandlerTaskV2+0x80>
81108774:	0080032e 	bgeu	zero,r2,81108784 <vInAckHandlerTaskV2+0x74>
81108778:	108000a0 	cmpeqi	r2,r2,2
8110877c:	1000471e 	bne	r2,zero,8110889c <vInAckHandlerTaskV2+0x18c>
81108780:	0000a506 	br	81108a18 <vInAckHandlerTaskV2+0x308>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
81108784:	00800044 	movi	r2,1
81108788:	e0bff915 	stw	r2,-28(fp)
				break;
8110878c:	0000ac06 	br	81108a40 <vInAckHandlerTaskV2+0x330>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
81108790:	00800044 	movi	r2,1
81108794:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
81108798:	d0a05217 	ldw	r2,-32440(gp)
8110879c:	e0fffe04 	addi	r3,fp,-8
811087a0:	180d883a 	mov	r6,r3
811087a4:	000b883a 	mov	r5,zero
811087a8:	1009883a 	mov	r4,r2
811087ac:	112fa680 	call	8112fa68 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
811087b0:	e0bffe03 	ldbu	r2,-8(fp)
811087b4:	10803fcc 	andi	r2,r2,255
811087b8:	1000361e 	bne	r2,zero,81108894 <vInAckHandlerTaskV2+0x184>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
811087bc:	d0a05117 	ldw	r2,-32444(gp)
811087c0:	e0fffe04 	addi	r3,fp,-8
811087c4:	180d883a 	mov	r6,r3
811087c8:	000b883a 	mov	r5,zero
811087cc:	1009883a 	mov	r4,r2
811087d0:	112da5c0 	call	8112da5c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
811087d4:	e0bffe03 	ldbu	r2,-8(fp)
811087d8:	10803fcc 	andi	r2,r2,255
811087dc:	10002b1e 	bne	r2,zero,8110888c <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
811087e0:	e03ffa45 	stb	zero,-23(fp)
811087e4:	00002206 	br	81108870 <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
811087e8:	e0fffa43 	ldbu	r3,-23(fp)
811087ec:	00a04574 	movhi	r2,33045
811087f0:	10bac004 	addi	r2,r2,-5376
811087f4:	18c7883a 	add	r3,r3,r3
811087f8:	18c7883a 	add	r3,r3,r3
811087fc:	10c5883a 	add	r2,r2,r3
81108800:	10800003 	ldbu	r2,0(r2)
81108804:	10803fcc 	andi	r2,r2,255
81108808:	1080201c 	xori	r2,r2,128
8110880c:	10bfe004 	addi	r2,r2,-128
81108810:	10001426 	beq	r2,zero,81108864 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
81108814:	e0fffa43 	ldbu	r3,-23(fp)
81108818:	00a04574 	movhi	r2,33045
8110881c:	10bac004 	addi	r2,r2,-5376
81108820:	18c7883a 	add	r3,r3,r3
81108824:	18c7883a 	add	r3,r3,r3
81108828:	10c5883a 	add	r2,r2,r3
8110882c:	10c0000b 	ldhu	r3,0(r2)
81108830:	d0e0478d 	sth	r3,-32482(gp)
81108834:	1080008b 	ldhu	r2,2(r2)
81108838:	d0a0480d 	sth	r2,-32480(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110883c:	e0fffa43 	ldbu	r3,-23(fp)
81108840:	00a04574 	movhi	r2,33045
81108844:	10bac004 	addi	r2,r2,-5376
81108848:	18c7883a 	add	r3,r3,r3
8110884c:	18c7883a 	add	r3,r3,r3
81108850:	10c5883a 	add	r2,r2,r3
81108854:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
81108858:	00800084 	movi	r2,2
8110885c:	e0bff915 	stw	r2,-28(fp)
                                break;                                
81108860:	00000606 	br	8110887c <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81108864:	e0bffa43 	ldbu	r2,-23(fp)
81108868:	10800044 	addi	r2,r2,1
8110886c:	e0bffa45 	stb	r2,-23(fp)
81108870:	e0bffa43 	ldbu	r2,-23(fp)
81108874:	10800130 	cmpltui	r2,r2,4
81108878:	103fdb1e 	bne	r2,zero,811087e8 <__reset+0xfb0e87e8>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
8110887c:	d0a05117 	ldw	r2,-32444(gp)
81108880:	1009883a 	mov	r4,r2
81108884:	112e0000 	call	8112e000 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81108888:	00006d06 	br	81108a40 <vInAckHandlerTaskV2+0x330>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexReceiverTask();
8110888c:	110ee6c0 	call	8110ee6c <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81108890:	00006b06 	br	81108a40 <vInAckHandlerTaskV2+0x330>
                        vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
81108894:	110ee040 	call	8110ee04 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
81108898:	00006906 	br	81108a40 <vInAckHandlerTaskV2+0x330>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
8110889c:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
811088a0:	d0a05483 	ldbu	r2,-32430(gp)
811088a4:	10803fcc 	andi	r2,r2,255
811088a8:	10800218 	cmpnei	r2,r2,8
811088ac:	1000021e 	bne	r2,zero,811088b8 <vInAckHandlerTaskV2+0x1a8>
811088b0:	00c00104 	movi	r3,4
811088b4:	00000106 	br	811088bc <vInAckHandlerTaskV2+0x1ac>
811088b8:	0007883a 	mov	r3,zero
811088bc:	d0a05d03 	ldbu	r2,-32396(gp)
811088c0:	10803fcc 	andi	r2,r2,255
811088c4:	10800118 	cmpnei	r2,r2,4
811088c8:	1000021e 	bne	r2,zero,811088d4 <vInAckHandlerTaskV2+0x1c4>
811088cc:	00800084 	movi	r2,2
811088d0:	00000106 	br	811088d8 <vInAckHandlerTaskV2+0x1c8>
811088d4:	0005883a 	mov	r2,zero
811088d8:	1884b03a 	or	r2,r3,r2
811088dc:	1007883a 	mov	r3,r2
811088e0:	d0a05d43 	ldbu	r2,-32395(gp)
811088e4:	10803fcc 	andi	r2,r2,255
811088e8:	108000a0 	cmpeqi	r2,r2,2
811088ec:	1884b03a 	or	r2,r3,r2
811088f0:	1007883a 	mov	r3,r2
811088f4:	e0bffa83 	ldbu	r2,-22(fp)
811088f8:	1884b03a 	or	r2,r3,r2
811088fc:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81108900:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
81108904:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
81108908:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
8110890c:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81108910:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
81108914:	e0bffa03 	ldbu	r2,-24(fp)
81108918:	10800044 	addi	r2,r2,1
8110891c:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 == (0b00000001 & ucHashVerification ) )
81108920:	e0bffa83 	ldbu	r2,-22(fp)
81108924:	1080004c 	andi	r2,r2,1
81108928:	10803fcc 	andi	r2,r2,255
8110892c:	10000626 	beq	r2,zero,81108948 <vInAckHandlerTaskV2+0x238>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
81108930:	e0bffd04 	addi	r2,fp,-12
81108934:	100b883a 	mov	r5,r2
81108938:	d1204784 	addi	r4,gp,-32482
8110893c:	1108a440 	call	81108a44 <bCheckInAck128>
81108940:	e0bff815 	stw	r2,-32(fp)
81108944:	00000206 	br	81108950 <vInAckHandlerTaskV2+0x240>
                    else
                        bFinished128 = TRUE;
81108948:	00800044 	movi	r2,1
8110894c:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( 0b00000010 == (0b00000010 & ucHashVerification ) )
81108950:	e0bffa83 	ldbu	r2,-22(fp)
81108954:	1080008c 	andi	r2,r2,2
81108958:	10803fcc 	andi	r2,r2,255
8110895c:	10000626 	beq	r2,zero,81108978 <vInAckHandlerTaskV2+0x268>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
81108960:	e0bffc04 	addi	r2,fp,-16
81108964:	100b883a 	mov	r5,r2
81108968:	d1204784 	addi	r4,gp,-32482
8110896c:	1108b840 	call	81108b84 <bCheckInAck64>
81108970:	e0bff815 	stw	r2,-32(fp)
81108974:	00000206 	br	81108980 <vInAckHandlerTaskV2+0x270>
                    else
                        bFinished64 = TRUE;
81108978:	00800044 	movi	r2,1
8110897c:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( 0b00000100 == (0b00000100 & ucHashVerification ) )
81108980:	e0bffa83 	ldbu	r2,-22(fp)
81108984:	1080010c 	andi	r2,r2,4
81108988:	10803fcc 	andi	r2,r2,255
8110898c:	10000626 	beq	r2,zero,811089a8 <vInAckHandlerTaskV2+0x298>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
81108990:	e0bffb04 	addi	r2,fp,-20
81108994:	100b883a 	mov	r5,r2
81108998:	d1204784 	addi	r4,gp,-32482
8110899c:	1108cc80 	call	81108cc8 <bCheckInAck32>
811089a0:	e0bff815 	stw	r2,-32(fp)
811089a4:	00000206 	br	811089b0 <vInAckHandlerTaskV2+0x2a0>
                    else
                        bFinished32 = TRUE;
811089a8:	00800044 	movi	r2,1
811089ac:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
811089b0:	e0bffa03 	ldbu	r2,-24(fp)
811089b4:	10c00044 	addi	r3,r2,1
811089b8:	e0fffa05 	stb	r3,-24(fp)
811089bc:	10803fcc 	andi	r2,r2,255
811089c0:	10801928 	cmpgeui	r2,r2,100
811089c4:	10000e1e 	bne	r2,zero,81108a00 <vInAckHandlerTaskV2+0x2f0>
811089c8:	e0bff817 	ldw	r2,-32(fp)
811089cc:	10000c1e 	bne	r2,zero,81108a00 <vInAckHandlerTaskV2+0x2f0>
811089d0:	e0bffb17 	ldw	r2,-20(fp)
811089d4:	1005003a 	cmpeq	r2,r2,zero
811089d8:	1007883a 	mov	r3,r2
811089dc:	e0bffc17 	ldw	r2,-16(fp)
811089e0:	1005003a 	cmpeq	r2,r2,zero
811089e4:	1884b03a 	or	r2,r3,r2
811089e8:	10c03fcc 	andi	r3,r2,255
811089ec:	e0bffd17 	ldw	r2,-12(fp)
811089f0:	1005003a 	cmpeq	r2,r2,zero
811089f4:	10803fcc 	andi	r2,r2,255
811089f8:	1884b03a 	or	r2,r3,r2
811089fc:	103fc51e 	bne	r2,zero,81108914 <__reset+0xfb0e8914>
                
                if (bFound == FALSE) {
81108a00:	e0bff817 	ldw	r2,-32(fp)
81108a04:	1000011e 	bne	r2,zero,81108a0c <vInAckHandlerTaskV2+0x2fc>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
81108a08:	110f3280 	call	8110f328 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
81108a0c:	00800044 	movi	r2,1
81108a10:	e0bff915 	stw	r2,-28(fp)
				break;
81108a14:	00000a06 	br	81108a40 <vInAckHandlerTaskV2+0x330>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81108a18:	d0a04e17 	ldw	r2,-32456(gp)
81108a1c:	100f883a 	mov	r7,r2
81108a20:	01801144 	movi	r6,69
81108a24:	01400044 	movi	r5,1
81108a28:	01204534 	movhi	r4,33044
81108a2c:	2135b404 	addi	r4,r4,-10544
81108a30:	1112ccc0 	call	81112ccc <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
81108a34:	00800044 	movi	r2,1
81108a38:	e0bff915 	stw	r2,-28(fp)
				break;
81108a3c:	0001883a 	nop
		}
	}
81108a40:	003f4906 	br	81108768 <__reset+0xfb0e8768>

81108a44 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
81108a44:	defffa04 	addi	sp,sp,-24
81108a48:	de00012e 	bgeu	sp,et,81108a50 <bCheckInAck128+0xc>
81108a4c:	003b68fa 	trap	3
81108a50:	dfc00515 	stw	ra,20(sp)
81108a54:	df000415 	stw	fp,16(sp)
81108a58:	df000404 	addi	fp,sp,16
81108a5c:	e13ffe15 	stw	r4,-8(fp)
81108a60:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81108a64:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81108a68:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81108a6c:	e03ffc15 	stw	zero,-16(fp)
    OSSemPend(xMutexBuffer128, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81108a70:	d0a05817 	ldw	r2,-32416(gp)
81108a74:	e0fffd44 	addi	r3,fp,-11
81108a78:	180d883a 	mov	r6,r3
81108a7c:	01400044 	movi	r5,1
81108a80:	1009883a 	mov	r4,r2
81108a84:	112fa680 	call	8112fa68 <OSSemPend>
    if ( error_code != OS_NO_ERR )
81108a88:	e0bffd43 	ldbu	r2,-11(fp)
81108a8c:	10803fcc 	andi	r2,r2,255
81108a90:	10000226 	beq	r2,zero,81108a9c <bCheckInAck128+0x58>
        return bFound;
81108a94:	e0bffc17 	ldw	r2,-16(fp)
81108a98:	00003506 	br	81108b70 <bCheckInAck128+0x12c>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81108a9c:	e03ffd05 	stb	zero,-12(fp)
81108aa0:	00002706 	br	81108b40 <bCheckInAck128+0xfc>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
81108aa4:	e0fffd03 	ldbu	r3,-12(fp)
81108aa8:	00a04574 	movhi	r2,33045
81108aac:	10ba7a04 	addi	r2,r2,-5656
81108ab0:	18c02324 	muli	r3,r3,140
81108ab4:	10c5883a 	add	r2,r2,r3
81108ab8:	10802104 	addi	r2,r2,132
81108abc:	10c0000b 	ldhu	r3,0(r2)
81108ac0:	e0bffe17 	ldw	r2,-8(fp)
81108ac4:	1080008b 	ldhu	r2,2(r2)
81108ac8:	18ffffcc 	andi	r3,r3,65535
81108acc:	10bfffcc 	andi	r2,r2,65535
81108ad0:	1880181e 	bne	r3,r2,81108b34 <bCheckInAck128+0xf0>
            bFound = TRUE;
81108ad4:	00800044 	movi	r2,1
81108ad8:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
81108adc:	e0fffd03 	ldbu	r3,-12(fp)
81108ae0:	00a04574 	movhi	r2,33045
81108ae4:	10ba6c04 	addi	r2,r2,-5712
81108ae8:	18c7883a 	add	r3,r3,r3
81108aec:	18c7883a 	add	r3,r3,r3
81108af0:	10c5883a 	add	r2,r2,r3
81108af4:	10000015 	stw	zero,0(r2)
            SemCount128++;
81108af8:	d0a05d43 	ldbu	r2,-32395(gp)
81108afc:	10800044 	addi	r2,r2,1
81108b00:	d0a05d45 	stb	r2,-32395(gp)
            error_code = OSSemPost(xSemCountBuffer128);
81108b04:	d0a04f17 	ldw	r2,-32452(gp)
81108b08:	1009883a 	mov	r4,r2
81108b0c:	112fdf00 	call	8112fdf0 <OSSemPost>
81108b10:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81108b14:	e0bffd43 	ldbu	r2,-11(fp)
81108b18:	10803fcc 	andi	r2,r2,255
81108b1c:	10000c26 	beq	r2,zero,81108b50 <bCheckInAck128+0x10c>
                SemCount128--;
81108b20:	d0a05d43 	ldbu	r2,-32395(gp)
81108b24:	10bfffc4 	addi	r2,r2,-1
81108b28:	d0a05d45 	stb	r2,-32395(gp)
                vFailSetCountSemaphorexBuffer128();
81108b2c:	110f1880 	call	8110f188 <vFailSetCountSemaphorexBuffer128>
            }
            break;
81108b30:	00000706 	br	81108b50 <bCheckInAck128+0x10c>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81108b34:	e0bffd03 	ldbu	r2,-12(fp)
81108b38:	10800044 	addi	r2,r2,1
81108b3c:	e0bffd05 	stb	r2,-12(fp)
81108b40:	e0bffd03 	ldbu	r2,-12(fp)
81108b44:	108000b0 	cmpltui	r2,r2,2
81108b48:	103fd61e 	bne	r2,zero,81108aa4 <__reset+0xfb0e8aa4>
81108b4c:	00000106 	br	81108b54 <bCheckInAck128+0x110>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
81108b50:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81108b54:	d0a05817 	ldw	r2,-32416(gp)
81108b58:	1009883a 	mov	r4,r2
81108b5c:	112e0000 	call	8112e000 <OSMutexPost>
    (*bFinished) = TRUE;
81108b60:	e0bfff17 	ldw	r2,-4(fp)
81108b64:	00c00044 	movi	r3,1
81108b68:	10c00015 	stw	r3,0(r2)

    return bFound;
81108b6c:	e0bffc17 	ldw	r2,-16(fp)
}
81108b70:	e037883a 	mov	sp,fp
81108b74:	dfc00117 	ldw	ra,4(sp)
81108b78:	df000017 	ldw	fp,0(sp)
81108b7c:	dec00204 	addi	sp,sp,8
81108b80:	f800283a 	ret

81108b84 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
81108b84:	defffa04 	addi	sp,sp,-24
81108b88:	de00012e 	bgeu	sp,et,81108b90 <bCheckInAck64+0xc>
81108b8c:	003b68fa 	trap	3
81108b90:	dfc00515 	stw	ra,20(sp)
81108b94:	df000415 	stw	fp,16(sp)
81108b98:	df000404 	addi	fp,sp,16
81108b9c:	e13ffe15 	stw	r4,-8(fp)
81108ba0:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81108ba4:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81108ba8:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81108bac:	e03ffc15 	stw	zero,-16(fp)
    OSSemPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81108bb0:	d0a05a17 	ldw	r2,-32408(gp)
81108bb4:	e0fffd44 	addi	r3,fp,-11
81108bb8:	180d883a 	mov	r6,r3
81108bbc:	01400044 	movi	r5,1
81108bc0:	1009883a 	mov	r4,r2
81108bc4:	112fa680 	call	8112fa68 <OSSemPend>
    if ( error_code != OS_NO_ERR )
81108bc8:	e0bffd43 	ldbu	r2,-11(fp)
81108bcc:	10803fcc 	andi	r2,r2,255
81108bd0:	10000226 	beq	r2,zero,81108bdc <bCheckInAck64+0x58>
        return bFound;
81108bd4:	e0bffc17 	ldw	r2,-16(fp)
81108bd8:	00003606 	br	81108cb4 <bCheckInAck64+0x130>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81108bdc:	e03ffd05 	stb	zero,-12(fp)
81108be0:	00002806 	br	81108c84 <bCheckInAck64+0x100>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
81108be4:	e0fffd03 	ldbu	r3,-12(fp)
81108be8:	00a04534 	movhi	r2,33044
81108bec:	1090b104 	addi	r2,r2,17092
81108bf0:	18c01324 	muli	r3,r3,76
81108bf4:	10c5883a 	add	r2,r2,r3
81108bf8:	10801104 	addi	r2,r2,68
81108bfc:	10c0000b 	ldhu	r3,0(r2)
81108c00:	e0bffe17 	ldw	r2,-8(fp)
81108c04:	1080008b 	ldhu	r2,2(r2)
81108c08:	18ffffcc 	andi	r3,r3,65535
81108c0c:	10bfffcc 	andi	r2,r2,65535
81108c10:	1880191e 	bne	r3,r2,81108c78 <bCheckInAck64+0xf4>
            bFound = TRUE;
81108c14:	00800044 	movi	r2,1
81108c18:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
81108c1c:	e0fffd03 	ldbu	r3,-12(fp)
81108c20:	00a04574 	movhi	r2,33045
81108c24:	10ba6c04 	addi	r2,r2,-5712
81108c28:	18c00084 	addi	r3,r3,2
81108c2c:	18c7883a 	add	r3,r3,r3
81108c30:	18c7883a 	add	r3,r3,r3
81108c34:	10c5883a 	add	r2,r2,r3
81108c38:	10000015 	stw	zero,0(r2)
            SemCount64++;
81108c3c:	d0a05d03 	ldbu	r2,-32396(gp)
81108c40:	10800044 	addi	r2,r2,1
81108c44:	d0a05d05 	stb	r2,-32396(gp)
            error_code = OSSemPost(xSemCountBuffer64);
81108c48:	d0a04b17 	ldw	r2,-32468(gp)
81108c4c:	1009883a 	mov	r4,r2
81108c50:	112fdf00 	call	8112fdf0 <OSSemPost>
81108c54:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81108c58:	e0bffd43 	ldbu	r2,-11(fp)
81108c5c:	10803fcc 	andi	r2,r2,255
81108c60:	10000c26 	beq	r2,zero,81108c94 <bCheckInAck64+0x110>
                SemCount64--;
81108c64:	d0a05d03 	ldbu	r2,-32396(gp)
81108c68:	10bfffc4 	addi	r2,r2,-1
81108c6c:	d0a05d05 	stb	r2,-32396(gp)
                vFailSetCountSemaphorexBuffer64();
81108c70:	110f1200 	call	8110f120 <vFailSetCountSemaphorexBuffer64>
            }
            break;
81108c74:	00000706 	br	81108c94 <bCheckInAck64+0x110>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81108c78:	e0bffd03 	ldbu	r2,-12(fp)
81108c7c:	10800044 	addi	r2,r2,1
81108c80:	e0bffd05 	stb	r2,-12(fp)
81108c84:	e0bffd03 	ldbu	r2,-12(fp)
81108c88:	10800130 	cmpltui	r2,r2,4
81108c8c:	103fd51e 	bne	r2,zero,81108be4 <__reset+0xfb0e8be4>
81108c90:	00000106 	br	81108c98 <bCheckInAck64+0x114>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
81108c94:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
81108c98:	d0a05a17 	ldw	r2,-32408(gp)
81108c9c:	1009883a 	mov	r4,r2
81108ca0:	112e0000 	call	8112e000 <OSMutexPost>
    (*bFinished) = TRUE;
81108ca4:	e0bfff17 	ldw	r2,-4(fp)
81108ca8:	00c00044 	movi	r3,1
81108cac:	10c00015 	stw	r3,0(r2)

    return bFound;
81108cb0:	e0bffc17 	ldw	r2,-16(fp)
}
81108cb4:	e037883a 	mov	sp,fp
81108cb8:	dfc00117 	ldw	ra,4(sp)
81108cbc:	df000017 	ldw	fp,0(sp)
81108cc0:	dec00204 	addi	sp,sp,8
81108cc4:	f800283a 	ret

81108cc8 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
81108cc8:	defffa04 	addi	sp,sp,-24
81108ccc:	de00012e 	bgeu	sp,et,81108cd4 <bCheckInAck32+0xc>
81108cd0:	003b68fa 	trap	3
81108cd4:	dfc00515 	stw	ra,20(sp)
81108cd8:	df000415 	stw	fp,16(sp)
81108cdc:	df000404 	addi	fp,sp,16
81108ce0:	e13ffe15 	stw	r4,-8(fp)
81108ce4:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81108ce8:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81108cec:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81108cf0:	e03ffc15 	stw	zero,-16(fp)
    OSSemPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81108cf4:	d0a05617 	ldw	r2,-32424(gp)
81108cf8:	e0fffd44 	addi	r3,fp,-11
81108cfc:	180d883a 	mov	r6,r3
81108d00:	01400044 	movi	r5,1
81108d04:	1009883a 	mov	r4,r2
81108d08:	112fa680 	call	8112fa68 <OSSemPend>
    if ( error_code != OS_NO_ERR )
81108d0c:	e0bffd43 	ldbu	r2,-11(fp)
81108d10:	10803fcc 	andi	r2,r2,255
81108d14:	10000226 	beq	r2,zero,81108d20 <bCheckInAck32+0x58>
        return bFound;
81108d18:	e0bffc17 	ldw	r2,-16(fp)
81108d1c:	00003606 	br	81108df8 <bCheckInAck32+0x130>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81108d20:	e03ffd05 	stb	zero,-12(fp)
81108d24:	00002806 	br	81108dc8 <bCheckInAck32+0x100>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
81108d28:	e0fffd03 	ldbu	r3,-12(fp)
81108d2c:	00a04574 	movhi	r2,33045
81108d30:	10a21404 	addi	r2,r2,-30640
81108d34:	18c00b24 	muli	r3,r3,44
81108d38:	10c5883a 	add	r2,r2,r3
81108d3c:	10800904 	addi	r2,r2,36
81108d40:	10c0000b 	ldhu	r3,0(r2)
81108d44:	e0bffe17 	ldw	r2,-8(fp)
81108d48:	1080008b 	ldhu	r2,2(r2)
81108d4c:	18ffffcc 	andi	r3,r3,65535
81108d50:	10bfffcc 	andi	r2,r2,65535
81108d54:	1880191e 	bne	r3,r2,81108dbc <bCheckInAck32+0xf4>
            bFound = TRUE;
81108d58:	00800044 	movi	r2,1
81108d5c:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
81108d60:	e0fffd03 	ldbu	r3,-12(fp)
81108d64:	00a04574 	movhi	r2,33045
81108d68:	10ba6c04 	addi	r2,r2,-5712
81108d6c:	18c00184 	addi	r3,r3,6
81108d70:	18c7883a 	add	r3,r3,r3
81108d74:	18c7883a 	add	r3,r3,r3
81108d78:	10c5883a 	add	r2,r2,r3
81108d7c:	10000015 	stw	zero,0(r2)
            SemCount32++;
81108d80:	d0a05483 	ldbu	r2,-32430(gp)
81108d84:	10800044 	addi	r2,r2,1
81108d88:	d0a05485 	stb	r2,-32430(gp)
            error_code = OSSemPost(xSemCountBuffer32);
81108d8c:	d0a05917 	ldw	r2,-32412(gp)
81108d90:	1009883a 	mov	r4,r2
81108d94:	112fdf00 	call	8112fdf0 <OSSemPost>
81108d98:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81108d9c:	e0bffd43 	ldbu	r2,-11(fp)
81108da0:	10803fcc 	andi	r2,r2,255
81108da4:	10000c26 	beq	r2,zero,81108dd8 <bCheckInAck32+0x110>
                SemCount32--;
81108da8:	d0a05483 	ldbu	r2,-32430(gp)
81108dac:	10bfffc4 	addi	r2,r2,-1
81108db0:	d0a05485 	stb	r2,-32430(gp)
                vFailSetCountSemaphorexBuffer32();
81108db4:	110f0b80 	call	8110f0b8 <vFailSetCountSemaphorexBuffer32>
            }
            break;
81108db8:	00000706 	br	81108dd8 <bCheckInAck32+0x110>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81108dbc:	e0bffd03 	ldbu	r2,-12(fp)
81108dc0:	10800044 	addi	r2,r2,1
81108dc4:	e0bffd05 	stb	r2,-12(fp)
81108dc8:	e0bffd03 	ldbu	r2,-12(fp)
81108dcc:	10800230 	cmpltui	r2,r2,8
81108dd0:	103fd51e 	bne	r2,zero,81108d28 <__reset+0xfb0e8d28>
81108dd4:	00000106 	br	81108ddc <bCheckInAck32+0x114>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
81108dd8:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xBuffer128*/
81108ddc:	d0a05617 	ldw	r2,-32424(gp)
81108de0:	1009883a 	mov	r4,r2
81108de4:	112e0000 	call	8112e000 <OSMutexPost>
    (*bFinished) = TRUE;
81108de8:	e0bfff17 	ldw	r2,-4(fp)
81108dec:	00c00044 	movi	r3,1
81108df0:	10c00015 	stw	r3,0(r2)

    return bFound;
81108df4:	e0bffc17 	ldw	r2,-16(fp)
81108df8:	e037883a 	mov	sp,fp
81108dfc:	dfc00117 	ldw	ra,4(sp)
81108e00:	df000017 	ldw	fp,0(sp)
81108e04:	dec00204 	addi	sp,sp,8
81108e08:	f800283a 	ret

81108e0c <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
81108e0c:	defff704 	addi	sp,sp,-36
81108e10:	de00012e 	bgeu	sp,et,81108e18 <vInitialTask+0xc>
81108e14:	003b68fa 	trap	3
81108e18:	dfc00815 	stw	ra,32(sp)
81108e1c:	df000715 	stw	fp,28(sp)
81108e20:	df000704 	addi	fp,sp,28
81108e24:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
81108e28:	e03ffe05 	stb	zero,-8(fp)
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
81108e2c:	d8000415 	stw	zero,16(sp)
81108e30:	d8000315 	stw	zero,12(sp)
81108e34:	00820004 	movi	r2,2048
81108e38:	d8800215 	stw	r2,8(sp)
81108e3c:	00a04534 	movhi	r2,33044
81108e40:	109a1404 	addi	r2,r2,26704
81108e44:	d8800115 	stw	r2,4(sp)
81108e48:	00800704 	movi	r2,28
81108e4c:	d8800015 	stw	r2,0(sp)
81108e50:	01c00704 	movi	r7,28
81108e54:	01a04574 	movhi	r6,33045
81108e58:	31a21304 	addi	r6,r6,-30644
81108e5c:	000b883a 	mov	r5,zero
81108e60:	01204474 	movhi	r4,33041
81108e64:	212c1304 	addi	r4,r4,-20404
81108e68:	11307d40 	call	811307d4 <OSTaskCreateExt>
81108e6c:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81108e70:	e0bffe03 	ldbu	r2,-8(fp)
81108e74:	10803fcc 	andi	r2,r2,255
81108e78:	10000526 	beq	r2,zero,81108e90 <vInitialTask+0x84>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81108e7c:	e0bffe03 	ldbu	r2,-8(fp)
81108e80:	10803fcc 	andi	r2,r2,255
81108e84:	1009883a 	mov	r4,r2
81108e88:	110ea800 	call	8110ea80 <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
81108e8c:	110f84c0 	call	8110f84c <vFailTimeoutCheckerTaskCreate>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
81108e90:	d8000415 	stw	zero,16(sp)
81108e94:	d8000315 	stw	zero,12(sp)
81108e98:	00820004 	movi	r2,2048
81108e9c:	d8800215 	stw	r2,8(sp)
81108ea0:	00a04574 	movhi	r2,33045
81108ea4:	10aa6c04 	addi	r2,r2,-22096
81108ea8:	d8800115 	stw	r2,4(sp)
81108eac:	00800644 	movi	r2,25
81108eb0:	d8800015 	stw	r2,0(sp)
81108eb4:	01c00644 	movi	r7,25
81108eb8:	01a04574 	movhi	r6,33045
81108ebc:	31b26b04 	addi	r6,r6,-13908
81108ec0:	000b883a 	mov	r5,zero
81108ec4:	01204474 	movhi	r4,33041
81108ec8:	21244504 	addi	r4,r4,-28396
81108ecc:	11307d40 	call	811307d4 <OSTaskCreateExt>
81108ed0:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81108ed4:	e0bffe03 	ldbu	r2,-8(fp)
81108ed8:	10803fcc 	andi	r2,r2,255
81108edc:	10000526 	beq	r2,zero,81108ef4 <vInitialTask+0xe8>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81108ee0:	e0bffe03 	ldbu	r2,-8(fp)
81108ee4:	10803fcc 	andi	r2,r2,255
81108ee8:	1009883a 	mov	r4,r2
81108eec:	110ea800 	call	8110ea80 <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
81108ef0:	110f7680 	call	8110f768 <vFailOutAckHandlerTaskCreate>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
81108ef4:	d8000415 	stw	zero,16(sp)
81108ef8:	d8000315 	stw	zero,12(sp)
81108efc:	00820004 	movi	r2,2048
81108f00:	d8800215 	stw	r2,8(sp)
81108f04:	00a04534 	movhi	r2,33044
81108f08:	1088b104 	addi	r2,r2,8900
81108f0c:	d8800115 	stw	r2,4(sp)
81108f10:	008005c4 	movi	r2,23
81108f14:	d8800015 	stw	r2,0(sp)
81108f18:	01c005c4 	movi	r7,23
81108f1c:	01a04534 	movhi	r6,33044
81108f20:	3190b004 	addi	r6,r6,17088
81108f24:	000b883a 	mov	r5,zero
81108f28:	01204474 	movhi	r4,33041
81108f2c:	2121c404 	addi	r4,r4,-30960
81108f30:	11307d40 	call	811307d4 <OSTaskCreateExt>
81108f34:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81108f38:	e0bffe03 	ldbu	r2,-8(fp)
81108f3c:	10803fcc 	andi	r2,r2,255
81108f40:	10000526 	beq	r2,zero,81108f58 <vInitialTask+0x14c>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81108f44:	e0bffe03 	ldbu	r2,-8(fp)
81108f48:	10803fcc 	andi	r2,r2,255
81108f4c:	1009883a 	mov	r4,r2
81108f50:	110ea800 	call	8110ea80 <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
81108f54:	110f71c0 	call	8110f71c <vFailInAckHandlerTaskCreate>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
81108f58:	d8000415 	stw	zero,16(sp)
81108f5c:	d8000315 	stw	zero,12(sp)
81108f60:	00820004 	movi	r2,2048
81108f64:	d8800215 	stw	r2,8(sp)
81108f68:	00a04574 	movhi	r2,33045
81108f6c:	10bac404 	addi	r2,r2,-5360
81108f70:	d8800115 	stw	r2,4(sp)
81108f74:	00800684 	movi	r2,26
81108f78:	d8800015 	stw	r2,0(sp)
81108f7c:	01c00684 	movi	r7,26
81108f80:	01a04574 	movhi	r6,33045
81108f84:	3182c304 	addi	r6,r6,2828
81108f88:	000b883a 	mov	r5,zero
81108f8c:	01204474 	movhi	r4,33041
81108f90:	21250304 	addi	r4,r4,-27636
81108f94:	11307d40 	call	811307d4 <OSTaskCreateExt>
81108f98:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81108f9c:	e0bffe03 	ldbu	r2,-8(fp)
81108fa0:	10803fcc 	andi	r2,r2,255
81108fa4:	10000526 	beq	r2,zero,81108fbc <vInitialTask+0x1b0>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81108fa8:	e0bffe03 	ldbu	r2,-8(fp)
81108fac:	10803fcc 	andi	r2,r2,255
81108fb0:	1009883a 	mov	r4,r2
81108fb4:	110ea800 	call	8110ea80 <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
81108fb8:	110f6d00 	call	8110f6d0 <vFailParserCommTaskCreate>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
81108fbc:	d8000415 	stw	zero,16(sp)
81108fc0:	d8000315 	stw	zero,12(sp)
81108fc4:	00820004 	movi	r2,2048
81108fc8:	d8800215 	stw	r2,8(sp)
81108fcc:	00a04574 	movhi	r2,33045
81108fd0:	10a26c04 	addi	r2,r2,-30288
81108fd4:	d8800115 	stw	r2,4(sp)
81108fd8:	00800784 	movi	r2,30
81108fdc:	d8800015 	stw	r2,0(sp)
81108fe0:	01c00784 	movi	r7,30
81108fe4:	01a04574 	movhi	r6,33045
81108fe8:	31aa6b04 	addi	r6,r6,-22100
81108fec:	000b883a 	mov	r5,zero
81108ff0:	01204474 	movhi	r4,33041
81108ff4:	21281104 	addi	r4,r4,-24508
81108ff8:	11307d40 	call	811307d4 <OSTaskCreateExt>
81108ffc:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109000:	e0bffe03 	ldbu	r2,-8(fp)
81109004:	10803fcc 	andi	r2,r2,255
81109008:	10000526 	beq	r2,zero,81109020 <vInitialTask+0x214>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110900c:	e0bffe03 	ldbu	r2,-8(fp)
81109010:	10803fcc 	andi	r2,r2,255
81109014:	1009883a 	mov	r4,r2
81109018:	110ea800 	call	8110ea80 <printErrorTask>
		#endif
		vFailReceiverCreate();
8110901c:	110efd40 	call	8110efd4 <vFailReceiverCreate>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
81109020:	d8000415 	stw	zero,16(sp)
81109024:	d8000315 	stw	zero,12(sp)
81109028:	00820004 	movi	r2,2048
8110902c:	d8800215 	stw	r2,8(sp)
81109030:	00a04534 	movhi	r2,33044
81109034:	1090fd04 	addi	r2,r2,17396
81109038:	d8800115 	stw	r2,4(sp)
8110903c:	00800604 	movi	r2,24
81109040:	d8800015 	stw	r2,0(sp)
81109044:	01c00604 	movi	r7,24
81109048:	01a04534 	movhi	r6,33044
8110904c:	3198fc04 	addi	r6,r6,25584
81109050:	000b883a 	mov	r5,zero
81109054:	01204474 	movhi	r4,33041
81109058:	212ba804 	addi	r4,r4,-20832
8110905c:	11307d40 	call	811307d4 <OSTaskCreateExt>
81109060:	e0bffe05 	stb	r2,-8(fp)
									SENDER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81109064:	e0bffe03 	ldbu	r2,-8(fp)
81109068:	10803fcc 	andi	r2,r2,255
8110906c:	10000526 	beq	r2,zero,81109084 <vInitialTask+0x278>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81109070:	e0bffe03 	ldbu	r2,-8(fp)
81109074:	10803fcc 	andi	r2,r2,255
81109078:	1009883a 	mov	r4,r2
8110907c:	110ea800 	call	8110ea80 <printErrorTask>
		#endif
		vFailSenderCreate();
81109080:	110f0200 	call	8110f020 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
81109084:	d0a05717 	ldw	r2,-32420(gp)
81109088:	e17ffe04 	addi	r5,fp,-8
8110908c:	1009883a 	mov	r4,r2
81109090:	11324f40 	call	811324f4 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
81109094:	e0bffe03 	ldbu	r2,-8(fp)
81109098:	10803fcc 	andi	r2,r2,255
8110909c:	10000126 	beq	r2,zero,811090a4 <vInitialTask+0x298>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
811090a0:	110fb080 	call	8110fb08 <vFailStartTimerRetransmission>
	}



	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
811090a4:	01003fc4 	movi	r4,255
811090a8:	11309c00 	call	811309c0 <OSTaskDel>
811090ac:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
811090b0:	e0bffe03 	ldbu	r2,-8(fp)
811090b4:	10803fcc 	andi	r2,r2,255
811090b8:	10001026 	beq	r2,zero,811090fc <vInitialTask+0x2f0>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
811090bc:	e0bffe03 	ldbu	r2,-8(fp)
811090c0:	10803fcc 	andi	r2,r2,255
811090c4:	1009883a 	mov	r4,r2
811090c8:	110ea800 	call	8110ea80 <printErrorTask>
		#endif
		vFailDeleteInitialization();
811090cc:	110f06c0 	call	8110f06c <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
811090d0:	014009c4 	movi	r5,39
811090d4:	01000044 	movi	r4,1
811090d8:	11301280 	call	81130128 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
811090dc:	01003fc4 	movi	r4,255
811090e0:	11309c00 	call	811309c0 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
811090e4:	000f883a 	mov	r7,zero
811090e8:	01800284 	movi	r6,10
811090ec:	000b883a 	mov	r5,zero
811090f0:	0009883a 	mov	r4,zero
811090f4:	1131a000 	call	81131a00 <OSTimeDlyHMSM>
		}
811090f8:	003ff806 	br	811090dc <__reset+0xfb0e90dc>
	}

}
811090fc:	0001883a 	nop
81109100:	e037883a 	mov	sp,fp
81109104:	dfc00117 	ldw	ra,4(sp)
81109108:	df000017 	ldw	fp,0(sp)
8110910c:	dec00204 	addi	sp,sp,8
81109110:	f800283a 	ret

81109114 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
81109114:	defff704 	addi	sp,sp,-36
81109118:	de00012e 	bgeu	sp,et,81109120 <vOutAckHandlerTask+0xc>
8110911c:	003b68fa 	trap	3
81109120:	dfc00815 	stw	ra,32(sp)
81109124:	df000715 	stw	fp,28(sp)
81109128:	df000704 	addi	fp,sp,28
8110912c:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
81109130:	e03ffac5 	stb	zero,-21(fp)
81109134:	e03ffb05 	stb	zero,-20(fp)
81109138:	e03ffb45 	stb	zero,-19(fp)
8110913c:	e03ffb85 	stb	zero,-18(fp)
81109140:	e03ffbc5 	stb	zero,-17(fp)
81109144:	e03ffc05 	stb	zero,-16(fp)
81109148:	e03ffc45 	stb	zero,-15(fp)
8110914c:	e03ffc85 	stb	zero,-14(fp)
81109150:	e03ffcc5 	stb	zero,-13(fp)
81109154:	e03ffd05 	stb	zero,-12(fp)
81109158:	e03ffd45 	stb	zero,-11(fp)
8110915c:	e03ffd85 	stb	zero,-10(fp)
81109160:	e03ffdc5 	stb	zero,-9(fp)
81109164:	e03ffe05 	stb	zero,-8(fp)
81109168:	e03ffe45 	stb	zero,-7(fp)
8110916c:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
81109170:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
81109174:	d0a04e17 	ldw	r2,-32456(gp)
81109178:	100f883a 	mov	r7,r2
8110917c:	01800804 	movi	r6,32
81109180:	01400044 	movi	r5,1
81109184:	01204534 	movhi	r4,33044
81109188:	2135c604 	addi	r4,r4,-10472
8110918c:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
81109190:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
81109194:	e0bff917 	ldw	r2,-28(fp)
81109198:	10c00060 	cmpeqi	r3,r2,1
8110919c:	1800071e 	bne	r3,zero,811091bc <vOutAckHandlerTask+0xa8>
811091a0:	0080032e 	bgeu	zero,r2,811091b0 <vOutAckHandlerTask+0x9c>
811091a4:	108000a0 	cmpeqi	r2,r2,2
811091a8:	1000471e 	bne	r2,zero,811092c8 <vOutAckHandlerTask+0x1b4>
811091ac:	00008c06 	br	811093e0 <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
811091b0:	00800044 	movi	r2,1
811091b4:	e0bff915 	stw	r2,-28(fp)
				break;
811091b8:	00009306 	br	81109408 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
811091bc:	00800044 	movi	r2,1
811091c0:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
811091c4:	d0a04d17 	ldw	r2,-32460(gp)
811091c8:	e0fffa84 	addi	r3,fp,-22
811091cc:	180d883a 	mov	r6,r3
811091d0:	000b883a 	mov	r5,zero
811091d4:	1009883a 	mov	r4,r2
811091d8:	112fa680 	call	8112fa68 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
811091dc:	e0bffa83 	ldbu	r2,-22(fp)
811091e0:	10803fcc 	andi	r2,r2,255
811091e4:	1000361e 	bne	r2,zero,811092c0 <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
811091e8:	d0a05b17 	ldw	r2,-32404(gp)
811091ec:	e0fffa84 	addi	r3,fp,-22
811091f0:	180d883a 	mov	r6,r3
811091f4:	000b883a 	mov	r5,zero
811091f8:	1009883a 	mov	r4,r2
811091fc:	112da5c0 	call	8112da5c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81109200:	e0bffa83 	ldbu	r2,-22(fp)
81109204:	10803fcc 	andi	r2,r2,255
81109208:	10002b1e 	bne	r2,zero,811092b8 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110920c:	e03ffa05 	stb	zero,-24(fp)
81109210:	00002206 	br	8110929c <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
81109214:	e0fffa03 	ldbu	r3,-24(fp)
81109218:	00a04574 	movhi	r2,33045
8110921c:	1082c404 	addi	r2,r2,2832
81109220:	18c7883a 	add	r3,r3,r3
81109224:	18c7883a 	add	r3,r3,r3
81109228:	10c5883a 	add	r2,r2,r3
8110922c:	10800003 	ldbu	r2,0(r2)
81109230:	10803fcc 	andi	r2,r2,255
81109234:	1080201c 	xori	r2,r2,128
81109238:	10bfe004 	addi	r2,r2,-128
8110923c:	10001426 	beq	r2,zero,81109290 <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
81109240:	e0fffa03 	ldbu	r3,-24(fp)
81109244:	00a04574 	movhi	r2,33045
81109248:	1082c404 	addi	r2,r2,2832
8110924c:	18c7883a 	add	r3,r3,r3
81109250:	18c7883a 	add	r3,r3,r3
81109254:	10c5883a 	add	r2,r2,r3
81109258:	10c0000b 	ldhu	r3,0(r2)
8110925c:	d0e0488d 	sth	r3,-32478(gp)
81109260:	1080008b 	ldhu	r2,2(r2)
81109264:	d0a0490d 	sth	r2,-32476(gp)
                                eSenderAckState = sSASending;
81109268:	00800084 	movi	r2,2
8110926c:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81109270:	e0fffa03 	ldbu	r3,-24(fp)
81109274:	00a04574 	movhi	r2,33045
81109278:	1082c404 	addi	r2,r2,2832
8110927c:	18c7883a 	add	r3,r3,r3
81109280:	18c7883a 	add	r3,r3,r3
81109284:	10c5883a 	add	r2,r2,r3
81109288:	10000005 	stb	zero,0(r2)
                                break;
8110928c:	00000606 	br	811092a8 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81109290:	e0bffa03 	ldbu	r2,-24(fp)
81109294:	10800044 	addi	r2,r2,1
81109298:	e0bffa05 	stb	r2,-24(fp)
8110929c:	e0bffa03 	ldbu	r2,-24(fp)
811092a0:	10800130 	cmpltui	r2,r2,4
811092a4:	103fdb1e 	bne	r2,zero,81109214 <__reset+0xfb0e9214>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
811092a8:	d0a05b17 	ldw	r2,-32404(gp)
811092ac:	1009883a 	mov	r4,r2
811092b0:	112e0000 	call	8112e000 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
811092b4:	00005406 	br	81109408 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
811092b8:	110ed9c0 	call	8110ed9c <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
811092bc:	00005206 	br	81109408 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
811092c0:	110ed340 	call	8110ed34 <vFailGetCountSemaphoreSenderTask>
                }

                break;
811092c4:	00005006 	br	81109408 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
811092c8:	d0a04883 	ldbu	r2,-32478(gp)
811092cc:	10803fcc 	andi	r2,r2,255
811092d0:	1080201c 	xori	r2,r2,128
811092d4:	10bfe004 	addi	r2,r2,-128
811092d8:	108008e0 	cmpeqi	r2,r2,35
811092dc:	1000201e 	bne	r2,zero,81109360 <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
811092e0:	d0a048c3 	ldbu	r2,-32477(gp)
811092e4:	10c03fcc 	andi	r3,r2,255
811092e8:	18c0201c 	xori	r3,r3,128
811092ec:	18ffe004 	addi	r3,r3,-128
811092f0:	d0a0490b 	ldhu	r2,-32476(gp)
811092f4:	113fffcc 	andi	r4,r2,65535
811092f8:	e0bffac4 	addi	r2,fp,-21
811092fc:	200f883a 	mov	r7,r4
81109300:	180d883a 	mov	r6,r3
81109304:	01604534 	movhi	r5,33044
81109308:	2975cf04 	addi	r5,r5,-10436
8110930c:	1009883a 	mov	r4,r2
81109310:	1113e480 	call	81113e48 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
81109314:	e0bffac4 	addi	r2,fp,-21
81109318:	1009883a 	mov	r4,r2
8110931c:	111405c0 	call	8111405c <strlen>
81109320:	1007883a 	mov	r3,r2
81109324:	e0bffac4 	addi	r2,fp,-21
81109328:	180b883a 	mov	r5,r3
8110932c:	1009883a 	mov	r4,r2
81109330:	110ea0c0 	call	8110ea0c <ucCrc8wInit>
81109334:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
81109338:	e13ffa43 	ldbu	r4,-23(fp)
8110933c:	e0fffac4 	addi	r3,fp,-21
81109340:	e0bffac4 	addi	r2,fp,-21
81109344:	200f883a 	mov	r7,r4
81109348:	180d883a 	mov	r6,r3
8110934c:	01604534 	movhi	r5,33044
81109350:	2975d104 	addi	r5,r5,-10428
81109354:	1009883a 	mov	r4,r2
81109358:	1113e480 	call	81113e48 <sprintf>
8110935c:	00000c06 	br	81109390 <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
81109360:	e0bffac4 	addi	r2,fp,-21
81109364:	00c008c4 	movi	r3,35
81109368:	10c00005 	stb	r3,0(r2)
8110936c:	00c01f04 	movi	r3,124
81109370:	10c00045 	stb	r3,1(r2)
81109374:	00c00d44 	movi	r3,53
81109378:	10c00085 	stb	r3,2(r2)
8110937c:	00c00d04 	movi	r3,52
81109380:	10c000c5 	stb	r3,3(r2)
81109384:	00c00ec4 	movi	r3,59
81109388:	10c00105 	stb	r3,4(r2)
8110938c:	10000145 	stb	zero,5(r2)
                }

                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
81109390:	d0a05c17 	ldw	r2,-32400(gp)
81109394:	e0fffa84 	addi	r3,fp,-22
81109398:	180d883a 	mov	r6,r3
8110939c:	01401904 	movi	r5,100
811093a0:	1009883a 	mov	r4,r2
811093a4:	112da5c0 	call	8112da5c <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
811093a8:	e0bffa83 	ldbu	r2,-22(fp)
811093ac:	10803fcc 	andi	r2,r2,255
811093b0:	1000071e 	bne	r2,zero,811093d0 <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
811093b4:	e0bffac4 	addi	r2,fp,-21
811093b8:	1009883a 	mov	r4,r2
811093bc:	1113b040 	call	81113b04 <puts>
                    OSMutexPost(xTxUARTMutex);
811093c0:	d0a05c17 	ldw	r2,-32400(gp)
811093c4:	1009883a 	mov	r4,r2
811093c8:	112e0000 	call	8112e000 <OSMutexPost>
811093cc:	00000106 	br	811093d4 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
811093d0:	110eed40 	call	8110eed4 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
811093d4:	00800044 	movi	r2,1
811093d8:	e0bff915 	stw	r2,-28(fp)
                
				break;
811093dc:	00000a06 	br	81109408 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
811093e0:	d0a04e17 	ldw	r2,-32456(gp)
811093e4:	100f883a 	mov	r7,r2
811093e8:	01801104 	movi	r6,68
811093ec:	01400044 	movi	r5,1
811093f0:	01204534 	movhi	r4,33044
811093f4:	2135d404 	addi	r4,r4,-10416
811093f8:	1112ccc0 	call	81112ccc <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
811093fc:	00800044 	movi	r2,1
81109400:	e0bff915 	stw	r2,-28(fp)
				break;
81109404:	0001883a 	nop
		}
	}
81109408:	003f6206 	br	81109194 <__reset+0xfb0e9194>

8110940c <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
8110940c:	deffc104 	addi	sp,sp,-252
81109410:	de00012e 	bgeu	sp,et,81109418 <vParserCommTask+0xc>
81109414:	003b68fa 	trap	3
81109418:	dfc03e15 	stw	ra,248(sp)
8110941c:	df003d15 	stw	fp,244(sp)
81109420:	df003d04 	addi	fp,sp,244
81109424:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiTypeL;
	unsigned short int usiSubTypeL;
	unsigned short int usiPUSidL;
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
81109428:	e03fc915 	stw	zero,-220(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
8110942c:	d0a04e17 	ldw	r2,-32456(gp)
81109430:	100f883a 	mov	r7,r2
81109434:	01800704 	movi	r6,28
81109438:	01400044 	movi	r5,1
8110943c:	01204534 	movhi	r4,33044
81109440:	2135e604 	addi	r4,r4,-10344
81109444:	1112ccc0 	call	81112ccc <fwrite>
    #endif

	eParserMode = sConfiguring;
81109448:	e03fc815 	stw	zero,-224(fp)

	for(;;){

		switch (eParserMode) {
8110944c:	e0bfc817 	ldw	r2,-224(fp)
81109450:	108001a8 	cmpgeui	r2,r2,6
81109454:	1002881e 	bne	r2,zero,81109e78 <vParserCommTask+0xa6c>
81109458:	e0bfc817 	ldw	r2,-224(fp)
8110945c:	100690ba 	slli	r3,r2,2
81109460:	00a04474 	movhi	r2,33041
81109464:	10a51d04 	addi	r2,r2,-27532
81109468:	1885883a 	add	r2,r3,r2
8110946c:	10800017 	ldw	r2,0(r2)
81109470:	1000683a 	jmp	r2
81109474:	8110948c 	andi	r4,r16,16978
81109478:	81109498 	cmpnei	r4,r16,16978
8110947c:	81109564 	muli	r4,r16,16981
81109480:	811095f8 	rdprs	r4,r16,16983
81109484:	81109750 	cmplti	r4,r16,16989
81109488:	81109798 	cmpnei	r4,r16,16990
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingConn;
8110948c:	00800044 	movi	r2,1
81109490:	e0bfc815 	stw	r2,-224(fp)
				break;
81109494:	00027c06 	br	81109e88 <vParserCommTask+0xa7c>
			case sWaitingConn:

				bSuccess = FALSE;
81109498:	e03fc915 	stw	zero,-220(fp)
				eParserMode = sWaitingConn;
8110949c:	00800044 	movi	r2,1
811094a0:	e0bfc815 	stw	r2,-224(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
811094a4:	d0a05017 	ldw	r2,-32448(gp)
811094a8:	e0ffca84 	addi	r3,fp,-214
811094ac:	180d883a 	mov	r6,r3
811094b0:	000b883a 	mov	r5,zero
811094b4:	1009883a 	mov	r4,r2
811094b8:	112fa680 	call	8112fa68 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
811094bc:	e0bfca83 	ldbu	r2,-214(fp)
811094c0:	10803fcc 	andi	r2,r2,255
811094c4:	1000251e 	bne	r2,zero,8110955c <vParserCommTask+0x150>
					/* There's command waiting to be threat */

					/* Should post the semaphore to the Sender Task stop to send the Initialization message (Request Status) */
					error_code = OSSemPost(xSemCommInit);
811094c8:	d0a04c17 	ldw	r2,-32464(gp)
811094cc:	1009883a 	mov	r4,r2
811094d0:	112fdf00 	call	8112fdf0 <OSSemPost>
811094d4:	e0bfca85 	stb	r2,-214(fp)
                    if ( error_code == OS_ERR_NONE ) {
811094d8:	e0bfca83 	ldbu	r2,-214(fp)
811094dc:	10803fcc 	andi	r2,r2,255
811094e0:	1000171e 	bne	r2,zero,81109540 <vParserCommTask+0x134>

                    	bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
811094e4:	01204534 	movhi	r4,33044
811094e8:	21074104 	addi	r4,r4,7428
811094ec:	1109e8c0 	call	81109e8c <getPreParsedPacket>
811094f0:	e0bfc915 	stw	r2,-220(fp)
                    	if (bSuccess == TRUE) {
811094f4:	e0bfc917 	ldw	r2,-220(fp)
811094f8:	10800058 	cmpnei	r2,r2,1
811094fc:	10000e1e 	bne	r2,zero,81109538 <vParserCommTask+0x12c>
                    		/* PreParsed Content copied to the local variable */
                            if ( PreParsedLocal.cType == START_REPLY_CHAR )
81109500:	00a04534 	movhi	r2,33044
81109504:	10874104 	addi	r2,r2,7428
81109508:	10800103 	ldbu	r2,4(r2)
8110950c:	10803fcc 	andi	r2,r2,255
81109510:	1080201c 	xori	r2,r2,128
81109514:	10bfe004 	addi	r2,r2,-128
81109518:	10800858 	cmpnei	r2,r2,33
8110951c:	1000031e 	bne	r2,zero,8110952c <vParserCommTask+0x120>
                            	eParserMode = sReplyParsing;
81109520:	00800104 	movi	r2,4
81109524:	e0bfc815 	stw	r2,-224(fp)
                    }
				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}

				break;
81109528:	00025606 	br	81109e84 <vParserCommTask+0xa78>
                    	if (bSuccess == TRUE) {
                    		/* PreParsed Content copied to the local variable */
                            if ( PreParsedLocal.cType == START_REPLY_CHAR )
                            	eParserMode = sReplyParsing;
                            else
                            	eParserMode = sRequestParsing;
8110952c:	008000c4 	movi	r2,3
81109530:	e0bfc815 	stw	r2,-224(fp)
                    }
				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}

				break;
81109534:	00025306 	br	81109e84 <vParserCommTask+0xa78>
                            	eParserMode = sReplyParsing;
                            else
                            	eParserMode = sRequestParsing;
                    	} else {
							/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
							vNoContentInPreParsedBuffer();
81109538:	110f4600 	call	8110f460 <vNoContentInPreParsedBuffer>
                    }
				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}

				break;
8110953c:	00025106 	br	81109e84 <vParserCommTask+0xa78>
							vNoContentInPreParsedBuffer();
						}
                    } else {
						/*  Could not post the semaphore that indicates that NUC is connected and send a message.
							this a very IMPORTANT signalization!*/
                    	bSuccess = bTrySendSemaphoreCommInit();
81109540:	1109fa40 	call	81109fa4 <bTrySendSemaphoreCommInit>
81109544:	e0bfc915 	stw	r2,-220(fp)
						if (bSuccess == TRUE) {
81109548:	e0bfc917 	ldw	r2,-220(fp)
8110954c:	10800058 	cmpnei	r2,r2,1
81109550:	10024c1e 	bne	r2,zero,81109e84 <vParserCommTask+0xa78>
							vFailSendxSemCommInit();
81109554:	110ebe80 	call	8110ebe8 <vFailSendxSemCommInit>
                    }
				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}

				break;
81109558:	00024a06 	br	81109e84 <vParserCommTask+0xa78>
						if (bSuccess == TRUE) {
							vFailSendxSemCommInit();
						}
                    }
				} else {
					vFailGetCountSemaphorePreParsedBuffer();
8110955c:	110f3900 	call	8110f390 <vFailGetCountSemaphorePreParsedBuffer>
				}

				break;
81109560:	00024806 	br	81109e84 <vParserCommTask+0xa78>
			case sWaitingMessage:

				bSuccess = FALSE;
81109564:	e03fc915 	stw	zero,-220(fp)
				eParserMode = sWaitingMessage;
81109568:	00800084 	movi	r2,2
8110956c:	e0bfc815 	stw	r2,-224(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
81109570:	d0a05017 	ldw	r2,-32448(gp)
81109574:	e0ffca84 	addi	r3,fp,-214
81109578:	180d883a 	mov	r6,r3
8110957c:	000b883a 	mov	r5,zero
81109580:	1009883a 	mov	r4,r2
81109584:	112fa680 	call	8112fa68 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
81109588:	e0bfca83 	ldbu	r2,-214(fp)
8110958c:	10803fcc 	andi	r2,r2,255
81109590:	1000171e 	bne	r2,zero,811095f0 <vParserCommTask+0x1e4>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81109594:	01204534 	movhi	r4,33044
81109598:	21074104 	addi	r4,r4,7428
8110959c:	1109e8c0 	call	81109e8c <getPreParsedPacket>
811095a0:	e0bfc915 	stw	r2,-220(fp)
					if (bSuccess == TRUE) {
811095a4:	e0bfc917 	ldw	r2,-220(fp)
811095a8:	10800058 	cmpnei	r2,r2,1
811095ac:	10000e1e 	bne	r2,zero,811095e8 <vParserCommTask+0x1dc>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
811095b0:	00a04534 	movhi	r2,33044
811095b4:	10874104 	addi	r2,r2,7428
811095b8:	10800103 	ldbu	r2,4(r2)
811095bc:	10803fcc 	andi	r2,r2,255
811095c0:	1080201c 	xori	r2,r2,128
811095c4:	10bfe004 	addi	r2,r2,-128
811095c8:	10800858 	cmpnei	r2,r2,33
811095cc:	1000031e 	bne	r2,zero,811095dc <vParserCommTask+0x1d0>
							eParserMode = sReplyParsing;
811095d0:	00800104 	movi	r2,4
811095d4:	e0bfc815 	stw	r2,-224(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811095d8:	00022b06 	br	81109e88 <vParserCommTask+0xa7c>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
811095dc:	008000c4 	movi	r2,3
811095e0:	e0bfc815 	stw	r2,-224(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811095e4:	00022806 	br	81109e88 <vParserCommTask+0xa7c>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
811095e8:	110f4600 	call	8110f460 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811095ec:	00022606 	br	81109e88 <vParserCommTask+0xa7c>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
811095f0:	110f3900 	call	8110f390 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
811095f4:	00022406 	br	81109e88 <vParserCommTask+0xa7c>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
811095f8:	00a04534 	movhi	r2,33044
811095fc:	10874104 	addi	r2,r2,7428
81109600:	10800143 	ldbu	r2,5(r2)
81109604:	10803fcc 	andi	r2,r2,255
81109608:	1080201c 	xori	r2,r2,128
8110960c:	10bfe004 	addi	r2,r2,-128
81109610:	10c01120 	cmpeqi	r3,r2,68
81109614:	1800081e 	bne	r3,zero,81109638 <vParserCommTask+0x22c>
81109618:	10c01420 	cmpeqi	r3,r2,80
8110961c:	18000a1e 	bne	r3,zero,81109648 <vParserCommTask+0x23c>
81109620:	108010e0 	cmpeqi	r2,r2,67
81109624:	10004626 	beq	r2,zero,81109740 <vParserCommTask+0x334>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
81109628:	110d33c0 	call	8110d33c <vSendEthConf>
						eParserMode = sWaitingMessage;
8110962c:	00800084 	movi	r2,2
81109630:	e0bfc815 	stw	r2,-224(fp)
						break;
81109634:	00004506 	br	8110974c <vParserCommTask+0x340>
                    case POWER_OFF_CMD: /*Shut down command from SGSE*/
						vSendTurnOff();
81109638:	110d5cc0 	call	8110d5cc <vSendTurnOff>
						eParserMode = sWaitingMessage;
8110963c:	00800084 	movi	r2,2
81109640:	e0bfc815 	stw	r2,-224(fp)
                        break;						
81109644:	00004106 	br	8110974c <vParserCommTask+0x340>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							debug(fp,"PUS Received:\n");
81109648:	d0a04e17 	ldw	r2,-32456(gp)
8110964c:	100f883a 	mov	r7,r2
81109650:	01800384 	movi	r6,14
81109654:	01400044 	movi	r5,1
81109658:	01204534 	movhi	r4,33044
8110965c:	2135ee04 	addi	r4,r4,-10312
81109660:	1112ccc0 	call	81112ccc <fwrite>
							memset(cPUSDebug,0,128);
81109664:	e0bfdf04 	addi	r2,fp,-132
81109668:	01802004 	movi	r6,128
8110966c:	000b883a 	mov	r5,zero
81109670:	1009883a 	mov	r4,r2
81109674:	11138300 	call	81113830 <memset>
							sprintf(cPUSDebug, "TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
81109678:	00a04534 	movhi	r2,33044
8110967c:	10874104 	addi	r2,r2,7428
81109680:	1080028b 	ldhu	r2,10(r2)
81109684:	117fffcc 	andi	r5,r2,65535
81109688:	00a04534 	movhi	r2,33044
8110968c:	10874104 	addi	r2,r2,7428
81109690:	1080030b 	ldhu	r2,12(r2)
81109694:	11bfffcc 	andi	r6,r2,65535
81109698:	00a04534 	movhi	r2,33044
8110969c:	10874104 	addi	r2,r2,7428
811096a0:	1080038b 	ldhu	r2,14(r2)
811096a4:	10ffffcc 	andi	r3,r2,65535
811096a8:	00a04534 	movhi	r2,33044
811096ac:	10874104 	addi	r2,r2,7428
811096b0:	1080040b 	ldhu	r2,16(r2)
811096b4:	113fffcc 	andi	r4,r2,65535
811096b8:	00a04534 	movhi	r2,33044
811096bc:	10874104 	addi	r2,r2,7428
811096c0:	1080048b 	ldhu	r2,18(r2)
811096c4:	10bfffcc 	andi	r2,r2,65535
811096c8:	e23fdf04 	addi	r8,fp,-132
811096cc:	d8800215 	stw	r2,8(sp)
811096d0:	d9000115 	stw	r4,4(sp)
811096d4:	d8c00015 	stw	r3,0(sp)
811096d8:	300f883a 	mov	r7,r6
811096dc:	280d883a 	mov	r6,r5
811096e0:	01604534 	movhi	r5,33044
811096e4:	2975f204 	addi	r5,r5,-10296
811096e8:	4009883a 	mov	r4,r8
811096ec:	1113e480 	call	81113e48 <sprintf>
							debug(fp, cPUSDebug );
811096f0:	d0a04e17 	ldw	r2,-32456(gp)
811096f4:	e0ffdf04 	addi	r3,fp,-132
811096f8:	180b883a 	mov	r5,r3
811096fc:	1009883a 	mov	r4,r2
81109700:	11126e00 	call	811126e0 <fprintf>
						#endif
	
						usiTypeL = PreParsedLocal.usiValues[3];
81109704:	00a04534 	movhi	r2,33044
81109708:	10874104 	addi	r2,r2,7428
8110970c:	1080038b 	ldhu	r2,14(r2)
81109710:	e0bfc60d 	sth	r2,-232(fp)
						usiSubTypeL = PreParsedLocal.usiValues[4];
81109714:	00a04534 	movhi	r2,33044
81109718:	10874104 	addi	r2,r2,7428
8110971c:	1080040b 	ldhu	r2,16(r2)
81109720:	e0bfc68d 	sth	r2,-230(fp)
						usiPUSidL = PreParsedLocal.usiValues[5];
81109724:	00a04534 	movhi	r2,33044
81109728:	10874104 	addi	r2,r2,7428
8110972c:	1080048b 	ldhu	r2,18(r2)
81109730:	e0bfc70d 	sth	r2,-228(fp)

						eParserMode = sPusHandling;
81109734:	00800144 	movi	r2,5
81109738:	e0bfc815 	stw	r2,-224(fp)
                        break;						
8110973c:	00000306 	br	8110974c <vParserCommTask+0x340>
					default:
						eParserMode = sWaitingMessage;
81109740:	00800084 	movi	r2,2
81109744:	e0bfc815 	stw	r2,-224(fp)
						break;
81109748:	0001883a 	nop
				}
				break;
8110974c:	0001ce06 	br	81109e88 <vParserCommTask+0xa7c>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
81109750:	00800084 	movi	r2,2
81109754:	e0bfc815 	stw	r2,-224(fp)
                switch ( usiTypeL )
81109758:	e0bfc60b 	ldhu	r2,-232(fp)
8110975c:	10c01220 	cmpeqi	r3,r2,72
81109760:	1800091e 	bne	r3,zero,81109788 <vParserCommTask+0x37c>
81109764:	10c014e0 	cmpeqi	r3,r2,83
81109768:	1800091e 	bne	r3,zero,81109790 <vParserCommTask+0x384>
8110976c:	10801120 	cmpeqi	r2,r2,68
81109770:	10000226 	beq	r2,zero,8110977c <vParserCommTask+0x370>
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
                    case POWER_OFF_CMD: /*Shut down command from SGSE*/
						vSendTurnOff();
81109774:	110d5cc0 	call	8110d5cc <vSendTurnOff>
						
						
                        break;
81109778:	00000606 	br	81109794 <vParserCommTask+0x388>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
8110977c:	00800084 	movi	r2,2
81109780:	e0bfc815 	stw	r2,-224(fp)
                        break;
81109784:	00000306 	br	81109794 <vParserCommTask+0x388>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
81109788:	0001883a 	nop
8110978c:	0001be06 	br	81109e88 <vParserCommTask+0xa7c>
                switch ( usiTypeL )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
81109790:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81109794:	0001bc06 	br	81109e88 <vParserCommTask+0xa7c>
			case sPusHandling:
				eParserMode = sWaitingMessage;
81109798:	00800084 	movi	r2,2
8110979c:	e0bfc815 	stw	r2,-224(fp)
				
                switch ( usiTypeL )
811097a0:	e0bfc60b 	ldhu	r2,-232(fp)
811097a4:	10c03ea0 	cmpeqi	r3,r2,250
811097a8:	1800311e 	bne	r3,zero,81109870 <vParserCommTask+0x464>
811097ac:	10c03ec8 	cmpgei	r3,r2,251
811097b0:	1800031e 	bne	r3,zero,811097c0 <vParserCommTask+0x3b4>
811097b4:	10800460 	cmpeqi	r2,r2,17
811097b8:	1000061e 	bne	r2,zero,811097d4 <vParserCommTask+0x3c8>
811097bc:	0001aa06 	br	81109e68 <vParserCommTask+0xa5c>
811097c0:	10c03ee0 	cmpeqi	r3,r2,251
811097c4:	1800621e 	bne	r3,zero,81109950 <vParserCommTask+0x544>
811097c8:	10803f20 	cmpeqi	r2,r2,252
811097cc:	1000ba1e 	bne	r2,zero,81109ab8 <vParserCommTask+0x6ac>
811097d0:	0001a506 	br	81109e68 <vParserCommTask+0xa5c>
                {
                    case 17: /* srv-Type = 17 */
						switch ( usiSubTypeL )
811097d4:	e0bfc68b 	ldhu	r2,-230(fp)
811097d8:	10800060 	cmpeqi	r2,r2,1
811097dc:	10000b26 	beq	r2,zero,8110980c <vParserCommTask+0x400>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_TEST_CONNECTION\n");
811097e0:	d0a04e17 	ldw	r2,-32456(gp)
811097e4:	100f883a 	mov	r7,r2
811097e8:	01800604 	movi	r6,24
811097ec:	01400044 	movi	r5,1
811097f0:	01204534 	movhi	r4,33044
811097f4:	21360504 	addi	r4,r4,-10220
811097f8:	1112ccc0 	call	81112ccc <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( usiPUSidL );
811097fc:	e0bfc70b 	ldhu	r2,-228(fp)
81109800:	1009883a 	mov	r4,r2
81109804:	110dc240 	call	8110dc24 <vTMPusTestConnection>

								break;
81109808:	00001806 	br	8110986c <vParserCommTask+0x460>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110980c:	e0bfdf04 	addi	r2,fp,-132
81109810:	01802004 	movi	r6,128
81109814:	000b883a 	mov	r5,zero
81109818:	1009883a 	mov	r4,r2
8110981c:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", usiTypeL, usiSubTypeL, usiPUSidL );
81109820:	e13fc60b 	ldhu	r4,-232(fp)
81109824:	e17fc68b 	ldhu	r5,-230(fp)
81109828:	e0bfc70b 	ldhu	r2,-228(fp)
8110982c:	e0ffdf04 	addi	r3,fp,-132
81109830:	d8800015 	stw	r2,0(sp)
81109834:	280f883a 	mov	r7,r5
81109838:	200d883a 	mov	r6,r4
8110983c:	01604534 	movhi	r5,33044
81109840:	29760c04 	addi	r5,r5,-10192
81109844:	1809883a 	mov	r4,r3
81109848:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
8110984c:	d0a04e17 	ldw	r2,-32456(gp)
81109850:	e0ffdf04 	addi	r3,fp,-132
81109854:	180b883a 	mov	r5,r3
81109858:	1009883a 	mov	r4,r2
8110985c:	11126e00 	call	811126e0 <fprintf>
								#endif
								eParserMode = sWaitingMessage;
81109860:	00800084 	movi	r2,2
81109864:	e0bfc815 	stw	r2,-224(fp)
								break;
81109868:	0001883a 	nop
						}
                        break;
8110986c:	00018106 	br	81109e74 <vParserCommTask+0xa68>
                    case 250: /* srv-Type = 250 */
						switch ( usiSubTypeL )
81109870:	e0bfc68b 	ldhu	r2,-230(fp)
81109874:	10c00f20 	cmpeqi	r3,r2,60
81109878:	18000c1e 	bne	r3,zero,811098ac <vParserCommTask+0x4a0>
8110987c:	10c00f60 	cmpeqi	r3,r2,61
81109880:	1800121e 	bne	r3,zero,811098cc <vParserCommTask+0x4c0>
81109884:	10800ee0 	cmpeqi	r2,r2,59
81109888:	10001826 	beq	r2,zero,811098ec <vParserCommTask+0x4e0>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_RESET\n");
8110988c:	d0a04e17 	ldw	r2,-32456(gp)
81109890:	100f883a 	mov	r7,r2
81109894:	01800384 	movi	r6,14
81109898:	01400044 	movi	r5,1
8110989c:	01204534 	movhi	r4,33044
811098a0:	21361c04 	addi	r4,r4,-10128
811098a4:	1112ccc0 	call	81112ccc <fwrite>
								#endif

								
								break;
811098a8:	00002806 	br	8110994c <vParserCommTask+0x540>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_CONFIG\n");
811098ac:	d0a04e17 	ldw	r2,-32456(gp)
811098b0:	100f883a 	mov	r7,r2
811098b4:	018003c4 	movi	r6,15
811098b8:	01400044 	movi	r5,1
811098bc:	01204534 	movhi	r4,33044
811098c0:	21362004 	addi	r4,r4,-10112
811098c4:	1112ccc0 	call	81112ccc <fwrite>
								#endif


								break;
811098c8:	00002006 	br	8110994c <vParserCommTask+0x540>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_RUN\n");
811098cc:	d0a04e17 	ldw	r2,-32456(gp)
811098d0:	100f883a 	mov	r7,r2
811098d4:	01800304 	movi	r6,12
811098d8:	01400044 	movi	r5,1
811098dc:	01204534 	movhi	r4,33044
811098e0:	21362404 	addi	r4,r4,-10096
811098e4:	1112ccc0 	call	81112ccc <fwrite>
								#endif


								break;
811098e8:	00001806 	br	8110994c <vParserCommTask+0x540>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811098ec:	e0bfdf04 	addi	r2,fp,-132
811098f0:	01802004 	movi	r6,128
811098f4:	000b883a 	mov	r5,zero
811098f8:	1009883a 	mov	r4,r2
811098fc:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", usiTypeL, usiSubTypeL, usiPUSidL );
81109900:	e13fc60b 	ldhu	r4,-232(fp)
81109904:	e17fc68b 	ldhu	r5,-230(fp)
81109908:	e0bfc70b 	ldhu	r2,-228(fp)
8110990c:	e0ffdf04 	addi	r3,fp,-132
81109910:	d8800015 	stw	r2,0(sp)
81109914:	280f883a 	mov	r7,r5
81109918:	200d883a 	mov	r6,r4
8110991c:	01604534 	movhi	r5,33044
81109920:	29760c04 	addi	r5,r5,-10192
81109924:	1809883a 	mov	r4,r3
81109928:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
8110992c:	d0a04e17 	ldw	r2,-32456(gp)
81109930:	e0ffdf04 	addi	r3,fp,-132
81109934:	180b883a 	mov	r5,r3
81109938:	1009883a 	mov	r4,r2
8110993c:	11126e00 	call	811126e0 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81109940:	00800084 	movi	r2,2
81109944:	e0bfc815 	stw	r2,-224(fp)
								break;
81109948:	0001883a 	nop
						}
                        break;
8110994c:	00014906 	br	81109e74 <vParserCommTask+0xa68>
                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81109950:	00a04534 	movhi	r2,33044
81109954:	10874104 	addi	r2,r2,7428
81109958:	1080050b 	ldhu	r2,20(r2)
8110995c:	e0bfca0d 	sth	r2,-216(fp)

						switch ( usiSubTypeL )
81109960:	e0bfc68b 	ldhu	r2,-230(fp)
81109964:	10c000a0 	cmpeqi	r3,r2,2
81109968:	1800161e 	bne	r3,zero,811099c4 <vParserCommTask+0x5b8>
8110996c:	10c000e0 	cmpeqi	r3,r2,3
81109970:	1800261e 	bne	r3,zero,81109a0c <vParserCommTask+0x600>
81109974:	10800060 	cmpeqi	r2,r2,1
81109978:	10003626 	beq	r2,zero,81109a54 <vParserCommTask+0x648>
						{
							case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110997c:	e0bfdf04 	addi	r2,fp,-132
81109980:	01802004 	movi	r6,128
81109984:	000b883a 	mov	r5,zero
81109988:	1009883a 	mov	r4,r2
8110998c:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "TC_SCAM_FEE_CONFIG_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
81109990:	e0ffca0b 	ldhu	r3,-216(fp)
81109994:	e0bfdf04 	addi	r2,fp,-132
81109998:	180d883a 	mov	r6,r3
8110999c:	01604534 	movhi	r5,33044
811099a0:	29762804 	addi	r5,r5,-10080
811099a4:	1009883a 	mov	r4,r2
811099a8:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
811099ac:	d0a04e17 	ldw	r2,-32456(gp)
811099b0:	e0ffdf04 	addi	r3,fp,-132
811099b4:	180b883a 	mov	r5,r3
811099b8:	1009883a 	mov	r4,r2
811099bc:	11126e00 	call	811126e0 <fprintf>
								#endif							


								break;
811099c0:	00003c06 	br	81109ab4 <vParserCommTask+0x6a8>
							case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811099c4:	e0bfdf04 	addi	r2,fp,-132
811099c8:	01802004 	movi	r6,128
811099cc:	000b883a 	mov	r5,zero
811099d0:	1009883a 	mov	r4,r2
811099d4:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "TC_SCAM_FEE_STANDBY_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
811099d8:	e0ffca0b 	ldhu	r3,-216(fp)
811099dc:	e0bfdf04 	addi	r2,fp,-132
811099e0:	180d883a 	mov	r6,r3
811099e4:	01604534 	movhi	r5,33044
811099e8:	29763404 	addi	r5,r5,-10032
811099ec:	1009883a 	mov	r4,r2
811099f0:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
811099f4:	d0a04e17 	ldw	r2,-32456(gp)
811099f8:	e0ffdf04 	addi	r3,fp,-132
811099fc:	180b883a 	mov	r5,r3
81109a00:	1009883a 	mov	r4,r2
81109a04:	11126e00 	call	811126e0 <fprintf>
								#endif


								break;
81109a08:	00002a06 	br	81109ab4 <vParserCommTask+0x6a8>
							case 3: /* TC_SCAM_FEE_CALIBRATION_ENTER */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81109a0c:	e0bfdf04 	addi	r2,fp,-132
81109a10:	01802004 	movi	r6,128
81109a14:	000b883a 	mov	r5,zero
81109a18:	1009883a 	mov	r4,r2
81109a1c:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "TC_SCAM_FEE_CALIBRATION_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
81109a20:	e0ffca0b 	ldhu	r3,-216(fp)
81109a24:	e0bfdf04 	addi	r2,fp,-132
81109a28:	180d883a 	mov	r6,r3
81109a2c:	01604534 	movhi	r5,33044
81109a30:	29764004 	addi	r5,r5,-9984
81109a34:	1009883a 	mov	r4,r2
81109a38:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109a3c:	d0a04e17 	ldw	r2,-32456(gp)
81109a40:	e0ffdf04 	addi	r3,fp,-132
81109a44:	180b883a 	mov	r5,r3
81109a48:	1009883a 	mov	r4,r2
81109a4c:	11126e00 	call	811126e0 <fprintf>
								#endif


								break;
81109a50:	00001806 	br	81109ab4 <vParserCommTask+0x6a8>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81109a54:	e0bfdf04 	addi	r2,fp,-132
81109a58:	01802004 	movi	r6,128
81109a5c:	000b883a 	mov	r5,zero
81109a60:	1009883a 	mov	r4,r2
81109a64:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", usiTypeL, usiSubTypeL, usiPUSidL );
81109a68:	e13fc60b 	ldhu	r4,-232(fp)
81109a6c:	e17fc68b 	ldhu	r5,-230(fp)
81109a70:	e0bfc70b 	ldhu	r2,-228(fp)
81109a74:	e0ffdf04 	addi	r3,fp,-132
81109a78:	d8800015 	stw	r2,0(sp)
81109a7c:	280f883a 	mov	r7,r5
81109a80:	200d883a 	mov	r6,r4
81109a84:	01604534 	movhi	r5,33044
81109a88:	29760c04 	addi	r5,r5,-10192
81109a8c:	1809883a 	mov	r4,r3
81109a90:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109a94:	d0a04e17 	ldw	r2,-32456(gp)
81109a98:	e0ffdf04 	addi	r3,fp,-132
81109a9c:	180b883a 	mov	r5,r3
81109aa0:	1009883a 	mov	r4,r2
81109aa4:	11126e00 	call	811126e0 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81109aa8:	00800084 	movi	r2,2
81109aac:	e0bfc815 	stw	r2,-224(fp)
								break;
81109ab0:	0001883a 	nop
						}
                        break;
81109ab4:	0000ef06 	br	81109e74 <vParserCommTask+0xa68>
					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81109ab8:	00a04534 	movhi	r2,33044
81109abc:	10874104 	addi	r2,r2,7428
81109ac0:	1080050b 	ldhu	r2,20(r2)
81109ac4:	e0bfca0d 	sth	r2,-216(fp)

						switch ( usiSubTypeL )
81109ac8:	e0bfc68b 	ldhu	r2,-230(fp)
81109acc:	10c000e0 	cmpeqi	r3,r2,3
81109ad0:	18000a1e 	bne	r3,zero,81109afc <vParserCommTask+0x6f0>
81109ad4:	10c00108 	cmpgei	r3,r2,4
81109ad8:	1800031e 	bne	r3,zero,81109ae8 <vParserCommTask+0x6dc>
81109adc:	108000a0 	cmpeqi	r2,r2,2
81109ae0:	10003c1e 	bne	r2,zero,81109bd4 <vParserCommTask+0x7c8>
81109ae4:	0000c706 	br	81109e04 <vParserCommTask+0x9f8>
81109ae8:	10c00120 	cmpeqi	r3,r2,4
81109aec:	1800151e 	bne	r3,zero,81109b44 <vParserCommTask+0x738>
81109af0:	10800160 	cmpeqi	r2,r2,5
81109af4:	1000251e 	bne	r2,zero,81109b8c <vParserCommTask+0x780>
81109af8:	0000c206 	br	81109e04 <vParserCommTask+0x9f8>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81109afc:	e0bfdf04 	addi	r2,fp,-132
81109b00:	01802004 	movi	r6,128
81109b04:	000b883a 	mov	r5,zero
81109b08:	1009883a 	mov	r4,r2
81109b0c:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_ENABLE-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81109b10:	e0ffca0b 	ldhu	r3,-216(fp)
81109b14:	e0bfdf04 	addi	r2,fp,-132
81109b18:	180d883a 	mov	r6,r3
81109b1c:	01604534 	movhi	r5,33044
81109b20:	29764d04 	addi	r5,r5,-9932
81109b24:	1009883a 	mov	r4,r2
81109b28:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109b2c:	d0a04e17 	ldw	r2,-32456(gp)
81109b30:	e0ffdf04 	addi	r3,fp,-132
81109b34:	180b883a 	mov	r5,r3
81109b38:	1009883a 	mov	r4,r2
81109b3c:	11126e00 	call	811126e0 <fprintf>
								#endif


								break;
81109b40:	0000c806 	br	81109e64 <vParserCommTask+0xa58>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81109b44:	e0bfdf04 	addi	r2,fp,-132
81109b48:	01802004 	movi	r6,128
81109b4c:	000b883a 	mov	r5,zero
81109b50:	1009883a 	mov	r4,r2
81109b54:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_DISABLE-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81109b58:	e0ffca0b 	ldhu	r3,-216(fp)
81109b5c:	e0bfdf04 	addi	r2,fp,-132
81109b60:	180d883a 	mov	r6,r3
81109b64:	01604534 	movhi	r5,33044
81109b68:	29765a04 	addi	r5,r5,-9880
81109b6c:	1009883a 	mov	r4,r2
81109b70:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109b74:	d0a04e17 	ldw	r2,-32456(gp)
81109b78:	e0ffdf04 	addi	r3,fp,-132
81109b7c:	180b883a 	mov	r5,r3
81109b80:	1009883a 	mov	r4,r2
81109b84:	11126e00 	call	811126e0 <fprintf>
								#endif


								break;
81109b88:	0000b606 	br	81109e64 <vParserCommTask+0xa58>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81109b8c:	e0bfdf04 	addi	r2,fp,-132
81109b90:	01802004 	movi	r6,128
81109b94:	000b883a 	mov	r5,zero
81109b98:	1009883a 	mov	r4,r2
81109b9c:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_RESET-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81109ba0:	e0ffca0b 	ldhu	r3,-216(fp)
81109ba4:	e0bfdf04 	addi	r2,fp,-132
81109ba8:	180d883a 	mov	r6,r3
81109bac:	01604534 	movhi	r5,33044
81109bb0:	29766704 	addi	r5,r5,-9828
81109bb4:	1009883a 	mov	r4,r2
81109bb8:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109bbc:	d0a04e17 	ldw	r2,-32456(gp)
81109bc0:	e0ffdf04 	addi	r3,fp,-132
81109bc4:	180b883a 	mov	r5,r3
81109bc8:	1009883a 	mov	r4,r2
81109bcc:	11126e00 	call	811126e0 <fprintf>
								#endif


								break;
81109bd0:	0000a406 	br	81109e64 <vParserCommTask+0xa58>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81109bd4:	e0bfdf04 	addi	r2,fp,-132
81109bd8:	01802004 	movi	r6,128
81109bdc:	000b883a 	mov	r5,zero
81109be0:	1009883a 	mov	r4,r2
81109be4:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_RMAP_CONFIG_UPDATE->\n");
81109be8:	e0bfdf04 	addi	r2,fp,-132
81109bec:	00d4d7f4 	movhi	r3,21343
81109bf0:	18d0d504 	addi	r3,r3,17236
81109bf4:	10c00015 	stw	r3,0(r2)
81109bf8:	00d7d374 	movhi	r3,24397
81109bfc:	18d050c4 	addi	r3,r3,16707
81109c00:	10c00115 	stw	r3,4(r2)
81109c04:	00d7d5f4 	movhi	r3,24407
81109c08:	18d414c4 	addi	r3,r3,20563
81109c0c:	10c00215 	stw	r3,8(r2)
81109c10:	00d41074 	movhi	r3,20545
81109c14:	18d35484 	addi	r3,r3,19794
81109c18:	10c00315 	stw	r3,12(r2)
81109c1c:	00d393f4 	movhi	r3,20047
81109c20:	18d0d7c4 	addi	r3,r3,17247
81109c24:	10c00415 	stw	r3,16(r2)
81109c28:	00d7d1f4 	movhi	r3,24391
81109c2c:	18d25184 	addi	r3,r3,18758
81109c30:	10c00515 	stw	r3,20(r2)
81109c34:	00d05134 	movhi	r3,16708
81109c38:	18d41544 	addi	r3,r3,20565
81109c3c:	10c00615 	stw	r3,24(r2)
81109c40:	00cf8b74 	movhi	r3,15917
81109c44:	18d15504 	addi	r3,r3,17748
81109c48:	10c00715 	stw	r3,28(r2)
81109c4c:	00c00284 	movi	r3,10
81109c50:	10c0080d 	sth	r3,32(r2)
									debug(fp, cPUSDebug );
81109c54:	d0a04e17 	ldw	r2,-32456(gp)
81109c58:	e0ffdf04 	addi	r3,fp,-132
81109c5c:	180b883a 	mov	r5,r3
81109c60:	1009883a 	mov	r4,r2
81109c64:	11126e00 	call	811126e0 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81109c68:	e0ffca0b 	ldhu	r3,-216(fp)
81109c6c:	e0bfdf04 	addi	r2,fp,-132
81109c70:	180d883a 	mov	r6,r3
81109c74:	01604534 	movhi	r5,33044
81109c78:	29767304 	addi	r5,r5,-9780
81109c7c:	1009883a 	mov	r4,r2
81109c80:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109c84:	d0a04e17 	ldw	r2,-32456(gp)
81109c88:	e0ffdf04 	addi	r3,fp,-132
81109c8c:	180b883a 	mov	r5,r3
81109c90:	1009883a 	mov	r4,r2
81109c94:	11126e00 	call	811126e0 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81109c98:	00a04534 	movhi	r2,33044
81109c9c:	10874104 	addi	r2,r2,7428
81109ca0:	1080058b 	ldhu	r2,22(r2)
81109ca4:	10ffffcc 	andi	r3,r2,65535
81109ca8:	e0bfdf04 	addi	r2,fp,-132
81109cac:	180d883a 	mov	r6,r3
81109cb0:	01604534 	movhi	r5,33044
81109cb4:	29767a04 	addi	r5,r5,-9752
81109cb8:	1009883a 	mov	r4,r2
81109cbc:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109cc0:	d0a04e17 	ldw	r2,-32456(gp)
81109cc4:	e0ffdf04 	addi	r3,fp,-132
81109cc8:	180b883a 	mov	r5,r3
81109ccc:	1009883a 	mov	r4,r2
81109cd0:	11126e00 	call	811126e0 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81109cd4:	00a04534 	movhi	r2,33044
81109cd8:	10874104 	addi	r2,r2,7428
81109cdc:	1080060b 	ldhu	r2,24(r2)
81109ce0:	10ffffcc 	andi	r3,r2,65535
81109ce4:	e0bfdf04 	addi	r2,fp,-132
81109ce8:	180d883a 	mov	r6,r3
81109cec:	01604534 	movhi	r5,33044
81109cf0:	29767e04 	addi	r5,r5,-9736
81109cf4:	1009883a 	mov	r4,r2
81109cf8:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109cfc:	d0a04e17 	ldw	r2,-32456(gp)
81109d00:	e0ffdf04 	addi	r3,fp,-132
81109d04:	180b883a 	mov	r5,r3
81109d08:	1009883a 	mov	r4,r2
81109d0c:	11126e00 	call	811126e0 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
81109d10:	00a04534 	movhi	r2,33044
81109d14:	10874104 	addi	r2,r2,7428
81109d18:	1080068b 	ldhu	r2,26(r2)
81109d1c:	10ffffcc 	andi	r3,r2,65535
81109d20:	e0bfdf04 	addi	r2,fp,-132
81109d24:	180d883a 	mov	r6,r3
81109d28:	01604534 	movhi	r5,33044
81109d2c:	29768304 	addi	r5,r5,-9716
81109d30:	1009883a 	mov	r4,r2
81109d34:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109d38:	d0a04e17 	ldw	r2,-32456(gp)
81109d3c:	e0ffdf04 	addi	r3,fp,-132
81109d40:	180b883a 	mov	r5,r3
81109d44:	1009883a 	mov	r4,r2
81109d48:	11126e00 	call	811126e0 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81109d4c:	00a04534 	movhi	r2,33044
81109d50:	10874104 	addi	r2,r2,7428
81109d54:	1080070b 	ldhu	r2,28(r2)
81109d58:	10ffffcc 	andi	r3,r2,65535
81109d5c:	e0bfdf04 	addi	r2,fp,-132
81109d60:	180d883a 	mov	r6,r3
81109d64:	01604534 	movhi	r5,33044
81109d68:	29768a04 	addi	r5,r5,-9688
81109d6c:	1009883a 	mov	r4,r2
81109d70:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109d74:	d0a04e17 	ldw	r2,-32456(gp)
81109d78:	e0ffdf04 	addi	r3,fp,-132
81109d7c:	180b883a 	mov	r5,r3
81109d80:	1009883a 	mov	r4,r2
81109d84:	11126e00 	call	811126e0 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81109d88:	00a04534 	movhi	r2,33044
81109d8c:	10874104 	addi	r2,r2,7428
81109d90:	1080078b 	ldhu	r2,30(r2)
81109d94:	10ffffcc 	andi	r3,r2,65535
81109d98:	e0bfdf04 	addi	r2,fp,-132
81109d9c:	180d883a 	mov	r6,r3
81109da0:	01604534 	movhi	r5,33044
81109da4:	29769104 	addi	r5,r5,-9660
81109da8:	1009883a 	mov	r4,r2
81109dac:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109db0:	d0a04e17 	ldw	r2,-32456(gp)
81109db4:	e0ffdf04 	addi	r3,fp,-132
81109db8:	180b883a 	mov	r5,r3
81109dbc:	1009883a 	mov	r4,r2
81109dc0:	11126e00 	call	811126e0 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81109dc4:	00a04534 	movhi	r2,33044
81109dc8:	10874104 	addi	r2,r2,7428
81109dcc:	1080080b 	ldhu	r2,32(r2)
81109dd0:	10ffffcc 	andi	r3,r2,65535
81109dd4:	e0bfdf04 	addi	r2,fp,-132
81109dd8:	180d883a 	mov	r6,r3
81109ddc:	01604534 	movhi	r5,33044
81109de0:	29769704 	addi	r5,r5,-9636
81109de4:	1009883a 	mov	r4,r2
81109de8:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109dec:	d0a04e17 	ldw	r2,-32456(gp)
81109df0:	e0ffdf04 	addi	r3,fp,-132
81109df4:	180b883a 	mov	r5,r3
81109df8:	1009883a 	mov	r4,r2
81109dfc:	11126e00 	call	811126e0 <fprintf>
								#endif



								break;
81109e00:	00001806 	br	81109e64 <vParserCommTask+0xa58>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81109e04:	e0bfdf04 	addi	r2,fp,-132
81109e08:	01802004 	movi	r6,128
81109e0c:	000b883a 	mov	r5,zero
81109e10:	1009883a 	mov	r4,r2
81109e14:	11138300 	call	81113830 <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", usiTypeL, usiSubTypeL, usiPUSidL );
81109e18:	e13fc60b 	ldhu	r4,-232(fp)
81109e1c:	e17fc68b 	ldhu	r5,-230(fp)
81109e20:	e0bfc70b 	ldhu	r2,-228(fp)
81109e24:	e0ffdf04 	addi	r3,fp,-132
81109e28:	d8800015 	stw	r2,0(sp)
81109e2c:	280f883a 	mov	r7,r5
81109e30:	200d883a 	mov	r6,r4
81109e34:	01604534 	movhi	r5,33044
81109e38:	29760c04 	addi	r5,r5,-10192
81109e3c:	1809883a 	mov	r4,r3
81109e40:	1113e480 	call	81113e48 <sprintf>
									debug(fp, cPUSDebug );
81109e44:	d0a04e17 	ldw	r2,-32456(gp)
81109e48:	e0ffdf04 	addi	r3,fp,-132
81109e4c:	180b883a 	mov	r5,r3
81109e50:	1009883a 	mov	r4,r2
81109e54:	11126e00 	call	811126e0 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81109e58:	00800084 	movi	r2,2
81109e5c:	e0bfc815 	stw	r2,-224(fp)
								break;
81109e60:	0001883a 	nop
						}
                        break;
81109e64:	00000306 	br	81109e74 <vParserCommTask+0xa68>
                    default:
						eParserMode = sWaitingMessage;
81109e68:	00800084 	movi	r2,2
81109e6c:	e0bfc815 	stw	r2,-224(fp)
                        break;
81109e70:	0001883a 	nop
                }
				break;				
81109e74:	00000406 	br	81109e88 <vParserCommTask+0xa7c>
			default:
				eParserMode = sWaitingMessage;
81109e78:	00800084 	movi	r2,2
81109e7c:	e0bfc815 	stw	r2,-224(fp)
				break;
81109e80:	00000106 	br	81109e88 <vParserCommTask+0xa7c>
                    }
				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}

				break;
81109e84:	0001883a 	nop
				break;				
			default:
				eParserMode = sWaitingMessage;
				break;
		}
	}
81109e88:	003d7006 	br	8110944c <__reset+0xfb0e944c>

81109e8c <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81109e8c:	defffb04 	addi	sp,sp,-20
81109e90:	de00012e 	bgeu	sp,et,81109e98 <getPreParsedPacket+0xc>
81109e94:	003b68fa 	trap	3
81109e98:	dfc00415 	stw	ra,16(sp)
81109e9c:	df000315 	stw	fp,12(sp)
81109ea0:	df000304 	addi	fp,sp,12
81109ea4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81109ea8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81109eac:	d0a05517 	ldw	r2,-32428(gp)
81109eb0:	e0fffe44 	addi	r3,fp,-7
81109eb4:	180d883a 	mov	r6,r3
81109eb8:	000b883a 	mov	r5,zero
81109ebc:	1009883a 	mov	r4,r2
81109ec0:	112da5c0 	call	8112da5c <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81109ec4:	e0bffe43 	ldbu	r2,-7(fp)
81109ec8:	10803fcc 	andi	r2,r2,255
81109ecc:	10002e1e 	bne	r2,zero,81109f88 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for(unsigned char i = 0; i < N_PREPARSED_ENTRIES; i++)
81109ed0:	e03ffe05 	stb	zero,-8(fp)
81109ed4:	00002506 	br	81109f6c <getPreParsedPacket+0xe0>
		{
            if ( xPreParsed[i].cType != 0 ) {
81109ed8:	e0fffe03 	ldbu	r3,-8(fp)
81109edc:	00a04574 	movhi	r2,33045
81109ee0:	1082c804 	addi	r2,r2,2848
81109ee4:	18c01324 	muli	r3,r3,76
81109ee8:	10c5883a 	add	r2,r2,r3
81109eec:	10800104 	addi	r2,r2,4
81109ef0:	10800003 	ldbu	r2,0(r2)
81109ef4:	10803fcc 	andi	r2,r2,255
81109ef8:	1080201c 	xori	r2,r2,128
81109efc:	10bfe004 	addi	r2,r2,-128
81109f00:	10001726 	beq	r2,zero,81109f60 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81109f04:	e0fffe03 	ldbu	r3,-8(fp)
81109f08:	e13fff17 	ldw	r4,-4(fp)
81109f0c:	00a04574 	movhi	r2,33045
81109f10:	1082c804 	addi	r2,r2,2848
81109f14:	18c01324 	muli	r3,r3,76
81109f18:	10c5883a 	add	r2,r2,r3
81109f1c:	2007883a 	mov	r3,r4
81109f20:	1009883a 	mov	r4,r2
81109f24:	00801304 	movi	r2,76
81109f28:	100d883a 	mov	r6,r2
81109f2c:	200b883a 	mov	r5,r4
81109f30:	1809883a 	mov	r4,r3
81109f34:	11136e00 	call	811136e0 <memcpy>
                bSuccess = TRUE;
81109f38:	00800044 	movi	r2,1
81109f3c:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
81109f40:	e0fffe03 	ldbu	r3,-8(fp)
81109f44:	00a04574 	movhi	r2,33045
81109f48:	1082c804 	addi	r2,r2,2848
81109f4c:	18c01324 	muli	r3,r3,76
81109f50:	10c5883a 	add	r2,r2,r3
81109f54:	10800104 	addi	r2,r2,4
81109f58:	10000005 	stb	zero,0(r2)
                break;
81109f5c:	00000606 	br	81109f78 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for(unsigned char i = 0; i < N_PREPARSED_ENTRIES; i++)
81109f60:	e0bffe03 	ldbu	r2,-8(fp)
81109f64:	10800044 	addi	r2,r2,1
81109f68:	e0bffe05 	stb	r2,-8(fp)
81109f6c:	e0bffe03 	ldbu	r2,-8(fp)
81109f70:	10800130 	cmpltui	r2,r2,4
81109f74:	103fd81e 	bne	r2,zero,81109ed8 <__reset+0xfb0e9ed8>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81109f78:	d0a05517 	ldw	r2,-32428(gp)
81109f7c:	1009883a 	mov	r4,r2
81109f80:	112e0000 	call	8112e000 <OSMutexPost>
81109f84:	00000106 	br	81109f8c <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81109f88:	110f3f80 	call	8110f3f8 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81109f8c:	e0bffd17 	ldw	r2,-12(fp)
}
81109f90:	e037883a 	mov	sp,fp
81109f94:	dfc00117 	ldw	ra,4(sp)
81109f98:	df000017 	ldw	fp,0(sp)
81109f9c:	dec00204 	addi	sp,sp,8
81109fa0:	f800283a 	ret

81109fa4 <bTrySendSemaphoreCommInit>:

bool bTrySendSemaphoreCommInit( void ) {
81109fa4:	defffc04 	addi	sp,sp,-16
81109fa8:	de00012e 	bgeu	sp,et,81109fb0 <bTrySendSemaphoreCommInit+0xc>
81109fac:	003b68fa 	trap	3
81109fb0:	dfc00315 	stw	ra,12(sp)
81109fb4:	df000215 	stw	fp,8(sp)
81109fb8:	df000204 	addi	fp,sp,8
	bool bSuccess = FALSE;
81109fbc:	e03ffe15 	stw	zero,-8(fp)
	unsigned char ucCountRetries = 0;
81109fc0:	e03fff05 	stb	zero,-4(fp)
	INT8U error_code;

	#ifdef DEBUG_ON
		debug(fp,"Can't post semaphore to SenderTask. Trying more 10 times.\n");
81109fc4:	d0a04e17 	ldw	r2,-32456(gp)
81109fc8:	100f883a 	mov	r7,r2
81109fcc:	01800e84 	movi	r6,58
81109fd0:	01400044 	movi	r5,1
81109fd4:	01204534 	movhi	r4,33044
81109fd8:	21369d04 	addi	r4,r4,-9612
81109fdc:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	ucCountRetries = 0;
81109fe0:	e03fff05 	stb	zero,-4(fp)
	do
	{
		ucCountRetries++;
81109fe4:	e0bfff03 	ldbu	r2,-4(fp)
81109fe8:	10800044 	addi	r2,r2,1
81109fec:	e0bfff05 	stb	r2,-4(fp)
		OSTimeDly(50); /* 50 ticks -> 50 ms -> context switch */
81109ff0:	01000c84 	movi	r4,50
81109ff4:	11318f40 	call	811318f4 <OSTimeDly>
		error_code = OSSemPost(xSemCommInit);
81109ff8:	d0a04c17 	ldw	r2,-32464(gp)
81109ffc:	1009883a 	mov	r4,r2
8110a000:	112fdf00 	call	8112fdf0 <OSSemPost>
8110a004:	e0bfff45 	stb	r2,-3(fp)
	} while ((error_code != OS_ERR_NONE) && (ucCountRetries < 11));
8110a008:	e0bfff43 	ldbu	r2,-3(fp)
8110a00c:	10000326 	beq	r2,zero,8110a01c <bTrySendSemaphoreCommInit+0x78>
8110a010:	e0bfff03 	ldbu	r2,-4(fp)
8110a014:	108002f0 	cmpltui	r2,r2,11
8110a018:	103ff21e 	bne	r2,zero,81109fe4 <__reset+0xfb0e9fe4>

	if ( error_code == OS_ERR_NONE ) {
8110a01c:	e0bfff43 	ldbu	r2,-3(fp)
8110a020:	1000021e 	bne	r2,zero,8110a02c <bTrySendSemaphoreCommInit+0x88>
		bSuccess = TRUE;
8110a024:	00800044 	movi	r2,1
8110a028:	e0bffe15 	stw	r2,-8(fp)
	}

	return bSuccess;
8110a02c:	e0bffe17 	ldw	r2,-8(fp)
}
8110a030:	e037883a 	mov	sp,fp
8110a034:	dfc00117 	ldw	ra,4(sp)
8110a038:	df000017 	ldw	fp,0(sp)
8110a03c:	dec00204 	addi	sp,sp,8
8110a040:	f800283a 	ret

8110a044 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
8110a044:	deffab04 	addi	sp,sp,-340
8110a048:	de00012e 	bgeu	sp,et,8110a050 <vReceiverUartTask+0xc>
8110a04c:	003b68fa 	trap	3
8110a050:	dfc05415 	stw	ra,336(sp)
8110a054:	df005315 	stw	fp,332(sp)
8110a058:	df005304 	addi	fp,sp,332
8110a05c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110a060:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
8110a064:	d0a04e17 	ldw	r2,-32456(gp)
8110a068:	100f883a 	mov	r7,r2
8110a06c:	01800784 	movi	r6,30
8110a070:	01400044 	movi	r5,1
8110a074:	01204534 	movhi	r4,33044
8110a078:	2136ac04 	addi	r4,r4,-9552
8110a07c:	1112ccc0 	call	81112ccc <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
8110a080:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
8110a084:	e0bfad17 	ldw	r2,-332(fp)
8110a088:	10c00060 	cmpeqi	r3,r2,1
8110a08c:	1800091e 	bne	r3,zero,8110a0b4 <vReceiverUartTask+0x70>
8110a090:	0080052e 	bgeu	zero,r2,8110a0a8 <vReceiverUartTask+0x64>
8110a094:	10c000a0 	cmpeqi	r3,r2,2
8110a098:	18005d1e 	bne	r3,zero,8110a210 <vReceiverUartTask+0x1cc>
8110a09c:	108000e0 	cmpeqi	r2,r2,3
8110a0a0:	10006e1e 	bne	r2,zero,8110a25c <vReceiverUartTask+0x218>
8110a0a4:	00007706 	br	8110a284 <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
8110a0a8:	00800044 	movi	r2,1
8110a0ac:	e0bfad15 	stw	r2,-332(fp)
                break;
8110a0b0:	00007706 	br	8110a290 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
8110a0b4:	e0bfaf04 	addi	r2,fp,-324
8110a0b8:	01802004 	movi	r6,128
8110a0bc:	000b883a 	mov	r5,zero
8110a0c0:	1009883a 	mov	r4,r2
8110a0c4:	11138300 	call	81113830 <memset>
                scanf("%s", cReceive);
8110a0c8:	e0bfcf04 	addi	r2,fp,-196
8110a0cc:	100b883a 	mov	r5,r2
8110a0d0:	01204534 	movhi	r4,33044
8110a0d4:	2136b404 	addi	r4,r4,-9520
8110a0d8:	1113d6c0 	call	81113d6c <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
8110a0dc:	e0ffcf04 	addi	r3,fp,-196
8110a0e0:	e0bfaf04 	addi	r2,fp,-324
8110a0e4:	01801fc4 	movi	r6,127
8110a0e8:	180b883a 	mov	r5,r3
8110a0ec:	1009883a 	mov	r4,r2
8110a0f0:	11136e00 	call	811136e0 <memcpy>
                bSuccess = bPreParser( cReceiveBuffer , &xPreParsedReader );
8110a0f4:	e0bfaf04 	addi	r2,fp,-324
8110a0f8:	01604534 	movhi	r5,33044
8110a0fc:	29475404 	addi	r5,r5,7504
8110a100:	1009883a 	mov	r4,r2
8110a104:	110a2940 	call	8110a294 <bPreParser>
8110a108:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
8110a10c:	e0bfae17 	ldw	r2,-328(fp)
8110a110:	10800058 	cmpnei	r2,r2,1
8110a114:	1000281e 	bne	r2,zero,8110a1b8 <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
8110a118:	00a04534 	movhi	r2,33044
8110a11c:	10875404 	addi	r2,r2,7504
8110a120:	10800103 	ldbu	r2,4(r2)
8110a124:	10803fcc 	andi	r2,r2,255
8110a128:	1080201c 	xori	r2,r2,128
8110a12c:	10bfe004 	addi	r2,r2,-128
8110a130:	10800fe0 	cmpeqi	r2,r2,63
8110a134:	1000081e 	bne	r2,zero,8110a158 <vReceiverUartTask+0x114>
8110a138:	00a04534 	movhi	r2,33044
8110a13c:	10875404 	addi	r2,r2,7504
8110a140:	10800103 	ldbu	r2,4(r2)
8110a144:	10803fcc 	andi	r2,r2,255
8110a148:	1080201c 	xori	r2,r2,128
8110a14c:	10bfe004 	addi	r2,r2,-128
8110a150:	10800858 	cmpnei	r2,r2,33
8110a154:	1000031e 	bne	r2,zero,8110a164 <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
8110a158:	00800084 	movi	r2,2
8110a15c:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110a160:	00004b06 	br	8110a290 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
8110a164:	00a04534 	movhi	r2,33044
8110a168:	10875404 	addi	r2,r2,7504
8110a16c:	10800103 	ldbu	r2,4(r2)
8110a170:	10803fcc 	andi	r2,r2,255
8110a174:	1080201c 	xori	r2,r2,128
8110a178:	10bfe004 	addi	r2,r2,-128
8110a17c:	108008d8 	cmpnei	r2,r2,35
8110a180:	10000a1e 	bne	r2,zero,8110a1ac <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
8110a184:	00800044 	movi	r2,1
8110a188:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
8110a18c:	d0a04e17 	ldw	r2,-32456(gp)
8110a190:	100f883a 	mov	r7,r2
8110a194:	018006c4 	movi	r6,27
8110a198:	01400044 	movi	r5,1
8110a19c:	01204534 	movhi	r4,33044
8110a1a0:	2136b504 	addi	r4,r4,-9516
8110a1a4:	1112ccc0 	call	81112ccc <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110a1a8:	00003906 	br	8110a290 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
8110a1ac:	008000c4 	movi	r2,3
8110a1b0:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110a1b4:	00003606 	br	8110a290 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
8110a1b8:	00a04534 	movhi	r2,33044
8110a1bc:	10875404 	addi	r2,r2,7504
8110a1c0:	00c008c4 	movi	r3,35
8110a1c4:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
8110a1c8:	00a04534 	movhi	r2,33044
8110a1cc:	10875404 	addi	r2,r2,7504
8110a1d0:	00c00b84 	movi	r3,46
8110a1d4:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
8110a1d8:	00a04534 	movhi	r2,33044
8110a1dc:	10875404 	addi	r2,r2,7504
8110a1e0:	00c00044 	movi	r3,1
8110a1e4:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
8110a1e8:	01204534 	movhi	r4,33044
8110a1ec:	21075404 	addi	r4,r4,7504
8110a1f0:	110a8000 	call	8110a800 <setPreAckSenderFreePos>
8110a1f4:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
8110a1f8:	e0bfae17 	ldw	r2,-328(fp)
8110a1fc:	1000011e 	bne	r2,zero,8110a204 <vReceiverUartTask+0x1c0>
                        vFailSendNack();
8110a200:	110f5300 	call	8110f530 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
8110a204:	00800044 	movi	r2,1
8110a208:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
8110a20c:	00002006 	br	8110a290 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
8110a210:	01204534 	movhi	r4,33044
8110a214:	21075404 	addi	r4,r4,7504
8110a218:	110a8000 	call	8110a800 <setPreAckSenderFreePos>
8110a21c:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
8110a220:	e0bfae17 	ldw	r2,-328(fp)
8110a224:	10800058 	cmpnei	r2,r2,1
8110a228:	1000081e 	bne	r2,zero,8110a24c <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
8110a22c:	01204534 	movhi	r4,33044
8110a230:	21075404 	addi	r4,r4,7504
8110a234:	110a6c80 	call	8110a6c8 <setPreParsedFreePos>
8110a238:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
8110a23c:	e0bfae17 	ldw	r2,-328(fp)
8110a240:	1000031e 	bne	r2,zero,8110a250 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
8110a244:	110f6000 	call	8110f600 <vFailSetPreParsedBuffer>
8110a248:	00000106 	br	8110a250 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
8110a24c:	110f5980 	call	8110f598 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
8110a250:	00800044 	movi	r2,1
8110a254:	e0bfad15 	stw	r2,-332(fp)
                break;
8110a258:	00000d06 	br	8110a290 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
8110a25c:	01204534 	movhi	r4,33044
8110a260:	21075404 	addi	r4,r4,7504
8110a264:	110a97c0 	call	8110a97c <setPreAckReceiverFreePos>
8110a268:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
8110a26c:	e0bfae17 	ldw	r2,-328(fp)
8110a270:	1000011e 	bne	r2,zero,8110a278 <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
8110a274:	110f6680 	call	8110f668 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
8110a278:	00800044 	movi	r2,1
8110a27c:	e0bfad15 	stw	r2,-332(fp)
                break;
8110a280:	00000306 	br	8110a290 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
8110a284:	00800044 	movi	r2,1
8110a288:	e0bfad15 	stw	r2,-332(fp)
                break;
8110a28c:	0001883a 	nop
        }

    }
8110a290:	003f7c06 	br	8110a084 <__reset+0xfb0ea084>

8110a294 <bPreParser>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParser( char *buffer, tPreParsed *xPerParcedBuffer )
{
8110a294:	defff204 	addi	sp,sp,-56
8110a298:	de00012e 	bgeu	sp,et,8110a2a0 <bPreParser+0xc>
8110a29c:	003b68fa 	trap	3
8110a2a0:	dfc00d15 	stw	ra,52(sp)
8110a2a4:	df000c15 	stw	fp,48(sp)
8110a2a8:	dc000b15 	stw	r16,44(sp)
8110a2ac:	df000c04 	addi	fp,sp,48
8110a2b0:	e13ffd15 	stw	r4,-12(fp)
8110a2b4:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
8110a2b8:	e03ff415 	stw	zero,-48(fp)
    short int siStrLen, siTeminador, siIniReq, siIniResp, siIniACK, siIniNACK, siCRC;
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */

    siStrLen = strlen(buffer);
8110a2bc:	e13ffd17 	ldw	r4,-12(fp)
8110a2c0:	111405c0 	call	8111405c <strlen>
8110a2c4:	e0bff70d 	sth	r2,-36(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
8110a2c8:	01400ec4 	movi	r5,59
8110a2cc:	e13ffd17 	ldw	r4,-12(fp)
8110a2d0:	110d8340 	call	8110d834 <siPosStr>
8110a2d4:	e0bff78d 	sth	r2,-34(fp)
    siIniACK = siPosStr(buffer, ACK_CHAR);
8110a2d8:	01401004 	movi	r5,64
8110a2dc:	e13ffd17 	ldw	r4,-12(fp)
8110a2e0:	110d8340 	call	8110d834 <siPosStr>
8110a2e4:	e0bff80d 	sth	r2,-32(fp)
    siIniNACK = siPosStr(buffer, NACK_CHAR);
8110a2e8:	014008c4 	movi	r5,35
8110a2ec:	e13ffd17 	ldw	r4,-12(fp)
8110a2f0:	110d8340 	call	8110d834 <siPosStr>
8110a2f4:	e0bff88d 	sth	r2,-30(fp)
    siIniACK = min_sim(siIniACK, siIniNACK);
8110a2f8:	e17ff80b 	ldhu	r5,-32(fp)
8110a2fc:	e0bff88b 	ldhu	r2,-30(fp)
8110a300:	10ffffcc 	andi	r3,r2,65535
8110a304:	18e0001c 	xori	r3,r3,32768
8110a308:	18e00004 	addi	r3,r3,-32768
8110a30c:	293fffcc 	andi	r4,r5,65535
8110a310:	2120001c 	xori	r4,r4,32768
8110a314:	21200004 	addi	r4,r4,-32768
8110a318:	20c0010e 	bge	r4,r3,8110a320 <bPreParser+0x8c>
8110a31c:	2805883a 	mov	r2,r5
8110a320:	e0bff80d 	sth	r2,-32(fp)
    siIniReq = siPosStr(buffer, START_REQUEST_CHAR);
8110a324:	01400fc4 	movi	r5,63
8110a328:	e13ffd17 	ldw	r4,-12(fp)
8110a32c:	110d8340 	call	8110d834 <siPosStr>
8110a330:	e0bff90d 	sth	r2,-28(fp)
    siIniResp = siPosStr(buffer, START_REPLY_CHAR);
8110a334:	01400844 	movi	r5,33
8110a338:	e13ffd17 	ldw	r4,-12(fp)
8110a33c:	110d8340 	call	8110d834 <siPosStr>
8110a340:	e0bff98d 	sth	r2,-26(fp)
    siIniReq = min_sim(siIniReq, siIniResp);
8110a344:	e17ff90b 	ldhu	r5,-28(fp)
8110a348:	e0bff98b 	ldhu	r2,-26(fp)
8110a34c:	10ffffcc 	andi	r3,r2,65535
8110a350:	18e0001c 	xori	r3,r3,32768
8110a354:	18e00004 	addi	r3,r3,-32768
8110a358:	293fffcc 	andi	r4,r5,65535
8110a35c:	2120001c 	xori	r4,r4,32768
8110a360:	21200004 	addi	r4,r4,-32768
8110a364:	20c0010e 	bge	r4,r3,8110a36c <bPreParser+0xd8>
8110a368:	2805883a 	mov	r2,r5
8110a36c:	e0bff90d 	sth	r2,-28(fp)
    siIniReq = min_sim(siIniReq, siIniACK);
8110a370:	e17ff90b 	ldhu	r5,-28(fp)
8110a374:	e0bff80b 	ldhu	r2,-32(fp)
8110a378:	10ffffcc 	andi	r3,r2,65535
8110a37c:	18e0001c 	xori	r3,r3,32768
8110a380:	18e00004 	addi	r3,r3,-32768
8110a384:	293fffcc 	andi	r4,r5,65535
8110a388:	2120001c 	xori	r4,r4,32768
8110a38c:	21200004 	addi	r4,r4,-32768
8110a390:	20c0010e 	bge	r4,r3,8110a398 <bPreParser+0x104>
8110a394:	2805883a 	mov	r2,r5
8110a398:	e0bff90d 	sth	r2,-28(fp)
    siCRC = siPosStr(buffer, SEPARATOR_CRC);
8110a39c:	01401f04 	movi	r5,124
8110a3a0:	e13ffd17 	ldw	r4,-12(fp)
8110a3a4:	110d8340 	call	8110d834 <siPosStr>
8110a3a8:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there is [!|?] , |, ; in the packet*/
    if ( (siTeminador == (siStrLen-1)) && (siCRC < siTeminador) && (siIniReq < siCRC) ) {
8110a3ac:	e0fff78f 	ldh	r3,-34(fp)
8110a3b0:	e0bff70f 	ldh	r2,-36(fp)
8110a3b4:	10bfffc4 	addi	r2,r2,-1
8110a3b8:	1880b51e 	bne	r3,r2,8110a690 <bPreParser+0x3fc>
8110a3bc:	e0fffa0f 	ldh	r3,-24(fp)
8110a3c0:	e0bff78f 	ldh	r2,-34(fp)
8110a3c4:	1880b20e 	bge	r3,r2,8110a690 <bPreParser+0x3fc>
8110a3c8:	e0fff90f 	ldh	r3,-28(fp)
8110a3cc:	e0bffa0f 	ldh	r2,-24(fp)
8110a3d0:	1880af0e 	bge	r3,r2,8110a690 <bPreParser+0x3fc>

#ifdef DEBUG_ON
	fprintf(fp," Debug -  siIni = %hhu, siCRC = %hhu\n", siIniReq, siCRC );
8110a3d4:	d0a04e17 	ldw	r2,-32456(gp)
8110a3d8:	e0fff90f 	ldh	r3,-28(fp)
8110a3dc:	e13ffa0f 	ldh	r4,-24(fp)
8110a3e0:	200f883a 	mov	r7,r4
8110a3e4:	180d883a 	mov	r6,r3
8110a3e8:	01604534 	movhi	r5,33044
8110a3ec:	2976bc04 	addi	r5,r5,-9488
8110a3f0:	1009883a 	mov	r4,r2
8110a3f4:	11126e00 	call	811126e0 <fprintf>
#endif

        xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit(&buffer[siIniReq] , (siCRC - siIniReq) );
8110a3f8:	e0bff90f 	ldh	r2,-28(fp)
8110a3fc:	e0fffd17 	ldw	r3,-12(fp)
8110a400:	1889883a 	add	r4,r3,r2
8110a404:	e0fffa0f 	ldh	r3,-24(fp)
8110a408:	e0bff90f 	ldh	r2,-28(fp)
8110a40c:	1885c83a 	sub	r2,r3,r2
8110a410:	100b883a 	mov	r5,r2
8110a414:	110ea0c0 	call	8110ea0c <ucCrc8wInit>
8110a418:	1007883a 	mov	r3,r2
8110a41c:	e0bffe17 	ldw	r2,-8(fp)
8110a420:	10c01205 	stb	r3,72(r2)
        xPerParcedBuffer->cType = buffer[siIniReq];
8110a424:	e0bff90f 	ldh	r2,-28(fp)
8110a428:	e0fffd17 	ldw	r3,-12(fp)
8110a42c:	1885883a 	add	r2,r3,r2
8110a430:	10c00003 	ldbu	r3,0(r2)
8110a434:	e0bffe17 	ldw	r2,-8(fp)
8110a438:	10c00105 	stb	r3,4(r2)

        if (xPerParcedBuffer->cType == NACK_CHAR ) {
8110a43c:	e0bffe17 	ldw	r2,-8(fp)
8110a440:	10800103 	ldbu	r2,4(r2)
8110a444:	10803fcc 	andi	r2,r2,255
8110a448:	1080201c 	xori	r2,r2,128
8110a44c:	10bfe004 	addi	r2,r2,-128
8110a450:	108008d8 	cmpnei	r2,r2,35
8110a454:	1000091e 	bne	r2,zero,8110a47c <bPreParser+0x1e8>
            xPerParcedBuffer->ucMessageCRC8 = 54; /*CRC8("#")=54*/
8110a458:	e0bffe17 	ldw	r2,-8(fp)
8110a45c:	00c00d84 	movi	r3,54
8110a460:	10c01245 	stb	r3,73(r2)
            xPerParcedBuffer->ucCalculatedCRC8 = 54; /*Even if calculated crc is wrong we should re-send the commands*/
8110a464:	e0bffe17 	ldw	r2,-8(fp)
8110a468:	00c00d84 	movi	r3,54
8110a46c:	10c01205 	stb	r3,72(r2)
            bSuccess = TRUE;
8110a470:	00800044 	movi	r2,1
8110a474:	e0bff415 	stw	r2,-48(fp)
#endif

        xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit(&buffer[siIniReq] , (siCRC - siIniReq) );
        xPerParcedBuffer->cType = buffer[siIniReq];

        if (xPerParcedBuffer->cType == NACK_CHAR ) {
8110a478:	00008606 	br	8110a694 <bPreParser+0x400>
            xPerParcedBuffer->ucMessageCRC8 = 54; /*CRC8("#")=54*/
            xPerParcedBuffer->ucCalculatedCRC8 = 54; /*Even if calculated crc is wrong we should re-send the commands*/
            bSuccess = TRUE;
        } else {
            xPerParcedBuffer->cCommand = buffer[siIniReq+1];
8110a47c:	e0bff90f 	ldh	r2,-28(fp)
8110a480:	10800044 	addi	r2,r2,1
8110a484:	e0fffd17 	ldw	r3,-12(fp)
8110a488:	1885883a 	add	r2,r3,r2
8110a48c:	10c00003 	ldbu	r3,0(r2)
8110a490:	e0bffe17 	ldw	r2,-8(fp)
8110a494:	10c00145 	stb	r3,5(r2)
            xPerParcedBuffer->ucNofBytes = 0;
8110a498:	e0bffe17 	ldw	r2,-8(fp)
8110a49c:	10000185 	stb	zero,6(r2)
            memset( xPerParcedBuffer->usiValues , 0 , SIZE_UCVALUES);
8110a4a0:	e0bffe17 	ldw	r2,-8(fp)
8110a4a4:	10800204 	addi	r2,r2,8
8110a4a8:	01800804 	movi	r6,32
8110a4ac:	000b883a 	mov	r5,zero
8110a4b0:	1009883a 	mov	r4,r2
8110a4b4:	11138300 	call	81113830 <memset>

            i = siIniReq + 3; /* "?C:i..." */
8110a4b8:	e0bff90b 	ldhu	r2,-28(fp)
8110a4bc:	108000c4 	addi	r2,r2,3
8110a4c0:	e0bff505 	stb	r2,-44(fp)
            do {
                p_inteiro = inteiro;
8110a4c4:	e0bffac4 	addi	r2,fp,-21
8110a4c8:	e0bff615 	stw	r2,-40(fp)
                memset( &(inteiro) , 0 , sizeof( inteiro ) );
8110a4cc:	e0bffac4 	addi	r2,fp,-21
8110a4d0:	01800184 	movi	r6,6
8110a4d4:	000b883a 	mov	r5,zero
8110a4d8:	1009883a 	mov	r4,r2
8110a4dc:	11138300 	call	81113830 <memset>
                do {
                    c = buffer[i];
8110a4e0:	e0bff503 	ldbu	r2,-44(fp)
8110a4e4:	e0fffd17 	ldw	r3,-12(fp)
8110a4e8:	1885883a 	add	r2,r3,r2
8110a4ec:	10800003 	ldbu	r2,0(r2)
8110a4f0:	e0bffa85 	stb	r2,-22(fp)
                    if ( isdigit( c ) ) {
8110a4f4:	d0e00317 	ldw	r3,-32756(gp)
8110a4f8:	e0bffa87 	ldb	r2,-22(fp)
8110a4fc:	10800044 	addi	r2,r2,1
8110a500:	1885883a 	add	r2,r3,r2
8110a504:	10800003 	ldbu	r2,0(r2)
8110a508:	10803fcc 	andi	r2,r2,255
8110a50c:	1080010c 	andi	r2,r2,4
8110a510:	10000626 	beq	r2,zero,8110a52c <bPreParser+0x298>
                        (*p_inteiro) = c;
8110a514:	e0bff617 	ldw	r2,-40(fp)
8110a518:	e0fffa83 	ldbu	r3,-22(fp)
8110a51c:	10c00005 	stb	r3,0(r2)
                        p_inteiro++;
8110a520:	e0bff617 	ldw	r2,-40(fp)
8110a524:	10800044 	addi	r2,r2,1
8110a528:	e0bff615 	stw	r2,-40(fp)
                    }
                    i++;
8110a52c:	e0bff503 	ldbu	r2,-44(fp)
8110a530:	10800044 	addi	r2,r2,1
8110a534:	e0bff505 	stb	r2,-44(fp)
                } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
8110a538:	e0bff70f 	ldh	r2,-36(fp)
8110a53c:	e0fff503 	ldbu	r3,-44(fp)
8110a540:	1880090e 	bge	r3,r2,8110a568 <bPreParser+0x2d4>
8110a544:	e0bffa87 	ldb	r2,-22(fp)
8110a548:	10800ea0 	cmpeqi	r2,r2,58
8110a54c:	1000061e 	bne	r2,zero,8110a568 <bPreParser+0x2d4>
8110a550:	e0bffa87 	ldb	r2,-22(fp)
8110a554:	10800ee0 	cmpeqi	r2,r2,59
8110a558:	1000031e 	bne	r2,zero,8110a568 <bPreParser+0x2d4>
8110a55c:	e0bffa87 	ldb	r2,-22(fp)
8110a560:	10801f18 	cmpnei	r2,r2,124
8110a564:	103fde1e 	bne	r2,zero,8110a4e0 <__reset+0xfb0ea4e0>
                (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110a568:	e0bff617 	ldw	r2,-40(fp)
8110a56c:	00c00284 	movi	r3,10
8110a570:	10c00005 	stb	r3,0(r2)

                if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
8110a574:	e0bffa87 	ldb	r2,-22(fp)
8110a578:	10800ea0 	cmpeqi	r2,r2,58
8110a57c:	1000031e 	bne	r2,zero,8110a58c <bPreParser+0x2f8>
8110a580:	e0bffa87 	ldb	r2,-22(fp)
8110a584:	10801f18 	cmpnei	r2,r2,124
8110a588:	10001a1e 	bne	r2,zero,8110a5f4 <bPreParser+0x360>
                    xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
8110a58c:	e0bffe17 	ldw	r2,-8(fp)
8110a590:	10800183 	ldbu	r2,6(r2)
8110a594:	10803fcc 	andi	r2,r2,255
8110a598:	10800828 	cmpgeui	r2,r2,32
8110a59c:	1000041e 	bne	r2,zero,8110a5b0 <bPreParser+0x31c>
8110a5a0:	e0bffe17 	ldw	r2,-8(fp)
8110a5a4:	10800183 	ldbu	r2,6(r2)
8110a5a8:	14003fcc 	andi	r16,r2,255
8110a5ac:	00000106 	br	8110a5b4 <bPreParser+0x320>
8110a5b0:	04000804 	movi	r16,32
8110a5b4:	e0bffac4 	addi	r2,fp,-21
8110a5b8:	1009883a 	mov	r4,r2
8110a5bc:	11125840 	call	81112584 <atoi>
8110a5c0:	1009883a 	mov	r4,r2
8110a5c4:	e0fffe17 	ldw	r3,-8(fp)
8110a5c8:	80800104 	addi	r2,r16,4
8110a5cc:	1085883a 	add	r2,r2,r2
8110a5d0:	1885883a 	add	r2,r3,r2
8110a5d4:	1100000d 	sth	r4,0(r2)
                    xPerParcedBuffer->ucNofBytes++;
8110a5d8:	e0bffe17 	ldw	r2,-8(fp)
8110a5dc:	10800183 	ldbu	r2,6(r2)
8110a5e0:	10800044 	addi	r2,r2,1
8110a5e4:	1007883a 	mov	r3,r2
8110a5e8:	e0bffe17 	ldw	r2,-8(fp)
8110a5ec:	10c00185 	stb	r3,6(r2)
8110a5f0:	00000906 	br	8110a618 <bPreParser+0x384>
                }
                else if ( c == FINAL_CHAR )
8110a5f4:	e0bffa87 	ldb	r2,-22(fp)
8110a5f8:	10800ed8 	cmpnei	r2,r2,59
8110a5fc:	1000061e 	bne	r2,zero,8110a618 <bPreParser+0x384>
                {
                    xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
8110a600:	e0bffac4 	addi	r2,fp,-21
8110a604:	1009883a 	mov	r4,r2
8110a608:	11125840 	call	81112584 <atoi>
8110a60c:	1007883a 	mov	r3,r2
8110a610:	e0bffe17 	ldw	r2,-8(fp)
8110a614:	10c01245 	stb	r3,73(r2)
                }

            } while ( (c != FINAL_CHAR) && (siStrLen>i) );
8110a618:	e0bffa87 	ldb	r2,-22(fp)
8110a61c:	10800ee0 	cmpeqi	r2,r2,59
8110a620:	1000031e 	bne	r2,zero,8110a630 <bPreParser+0x39c>
8110a624:	e0bff70f 	ldh	r2,-36(fp)
8110a628:	e0fff503 	ldbu	r3,-44(fp)
8110a62c:	18bfa516 	blt	r3,r2,8110a4c4 <__reset+0xfb0ea4c4>

            if ( c == FINAL_CHAR )
8110a630:	e0bffa87 	ldb	r2,-22(fp)
8110a634:	10800ed8 	cmpnei	r2,r2,59
8110a638:	1000131e 	bne	r2,zero,8110a688 <bPreParser+0x3f4>
                if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
8110a63c:	e0bffe17 	ldw	r2,-8(fp)
8110a640:	10c01243 	ldbu	r3,73(r2)
8110a644:	e0bffe17 	ldw	r2,-8(fp)
8110a648:	10801203 	ldbu	r2,72(r2)
8110a64c:	18c03fcc 	andi	r3,r3,255
8110a650:	10803fcc 	andi	r2,r2,255
8110a654:	1880031e 	bne	r3,r2,8110a664 <bPreParser+0x3d0>
                    bSuccess = TRUE;
8110a658:	00800044 	movi	r2,1
8110a65c:	e0bff415 	stw	r2,-48(fp)
#endif

        xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit(&buffer[siIniReq] , (siCRC - siIniReq) );
        xPerParcedBuffer->cType = buffer[siIniReq];

        if (xPerParcedBuffer->cType == NACK_CHAR ) {
8110a660:	00000c06 	br	8110a694 <bPreParser+0x400>
                if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
                    bSuccess = TRUE;
                } else {
                    /* Wrong CRC */
                    #ifdef DEBUG_ON
                        debug(fp,"Wrong CRC. Pre Parsed.\n");
8110a664:	d0a04e17 	ldw	r2,-32456(gp)
8110a668:	100f883a 	mov	r7,r2
8110a66c:	018005c4 	movi	r6,23
8110a670:	01400044 	movi	r5,1
8110a674:	01204534 	movhi	r4,33044
8110a678:	2136c604 	addi	r4,r4,-9448
8110a67c:	1112ccc0 	call	81112ccc <fwrite>
                    #endif
                    bSuccess = FALSE;
8110a680:	e03ff415 	stw	zero,-48(fp)
#endif

        xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit(&buffer[siIniReq] , (siCRC - siIniReq) );
        xPerParcedBuffer->cType = buffer[siIniReq];

        if (xPerParcedBuffer->cType == NACK_CHAR ) {
8110a684:	00000306 	br	8110a694 <bPreParser+0x400>
                    #endif
                    bSuccess = FALSE;
                }

            else
                bSuccess = FALSE; /*Index overflow in the buffer*/
8110a688:	e03ff415 	stw	zero,-48(fp)
#endif

        xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit(&buffer[siIniReq] , (siCRC - siIniReq) );
        xPerParcedBuffer->cType = buffer[siIniReq];

        if (xPerParcedBuffer->cType == NACK_CHAR ) {
8110a68c:	00000106 	br	8110a694 <bPreParser+0x400>
            else
                bSuccess = FALSE; /*Index overflow in the buffer*/
            }
    } else {
        /*Malformed Packet*/
        bSuccess = FALSE;
8110a690:	e03ff415 	stw	zero,-48(fp)
    }
    memset(buffer,0,strlen(buffer));
8110a694:	e13ffd17 	ldw	r4,-12(fp)
8110a698:	111405c0 	call	8111405c <strlen>
8110a69c:	100d883a 	mov	r6,r2
8110a6a0:	000b883a 	mov	r5,zero
8110a6a4:	e13ffd17 	ldw	r4,-12(fp)
8110a6a8:	11138300 	call	81113830 <memset>

    return bSuccess;
8110a6ac:	e0bff417 	ldw	r2,-48(fp)
}
8110a6b0:	e6ffff04 	addi	sp,fp,-4
8110a6b4:	dfc00217 	ldw	ra,8(sp)
8110a6b8:	df000117 	ldw	fp,4(sp)
8110a6bc:	dc000017 	ldw	r16,0(sp)
8110a6c0:	dec00304 	addi	sp,sp,12
8110a6c4:	f800283a 	ret

8110a6c8 <setPreParsedFreePos>:

/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
8110a6c8:	defffb04 	addi	sp,sp,-20
8110a6cc:	de00012e 	bgeu	sp,et,8110a6d4 <setPreParsedFreePos+0xc>
8110a6d0:	003b68fa 	trap	3
8110a6d4:	dfc00415 	stw	ra,16(sp)
8110a6d8:	df000315 	stw	fp,12(sp)
8110a6dc:	df000304 	addi	fp,sp,12
8110a6e0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110a6e4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8110a6e8:	e03ffe05 	stb	zero,-8(fp)

    OSMutexPend(xMutexPreParsed, 30, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 30 ticks = 30 ms */
8110a6ec:	d0a05517 	ldw	r2,-32428(gp)
8110a6f0:	e0fffe44 	addi	r3,fp,-7
8110a6f4:	180d883a 	mov	r6,r3
8110a6f8:	01400784 	movi	r5,30
8110a6fc:	1009883a 	mov	r4,r2
8110a700:	112da5c0 	call	8112da5c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110a704:	e0bffe43 	ldbu	r2,-7(fp)
8110a708:	10803fcc 	andi	r2,r2,255
8110a70c:	1000361e 	bne	r2,zero,8110a7e8 <setPreParsedFreePos+0x120>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
8110a710:	e03ffe05 	stb	zero,-8(fp)
8110a714:	00002e06 	br	8110a7d0 <setPreParsedFreePos+0x108>
        {
            if ( xPreParsed[i].cType == 0 ) {
8110a718:	e0fffe03 	ldbu	r3,-8(fp)
8110a71c:	00a04574 	movhi	r2,33045
8110a720:	1082c804 	addi	r2,r2,2848
8110a724:	18c01324 	muli	r3,r3,76
8110a728:	10c5883a 	add	r2,r2,r3
8110a72c:	10800104 	addi	r2,r2,4
8110a730:	10800003 	ldbu	r2,0(r2)
8110a734:	10803fcc 	andi	r2,r2,255
8110a738:	1080201c 	xori	r2,r2,128
8110a73c:	10bfe004 	addi	r2,r2,-128
8110a740:	1000201e 	bne	r2,zero,8110a7c4 <setPreParsedFreePos+0xfc>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
8110a744:	e0fffe03 	ldbu	r3,-8(fp)
8110a748:	00a04574 	movhi	r2,33045
8110a74c:	1082c804 	addi	r2,r2,2848
8110a750:	18c01324 	muli	r3,r3,76
8110a754:	10c7883a 	add	r3,r2,r3
8110a758:	e0bfff17 	ldw	r2,-4(fp)
8110a75c:	1009883a 	mov	r4,r2
8110a760:	00801304 	movi	r2,76
8110a764:	100d883a 	mov	r6,r2
8110a768:	200b883a 	mov	r5,r4
8110a76c:	1809883a 	mov	r4,r3
8110a770:	11136e00 	call	811136e0 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
8110a774:	d0a05017 	ldw	r2,-32448(gp)
8110a778:	1009883a 	mov	r4,r2
8110a77c:	112fdf00 	call	8112fdf0 <OSSemPost>
8110a780:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
8110a784:	e0bffe43 	ldbu	r2,-7(fp)
8110a788:	10803fcc 	andi	r2,r2,255
8110a78c:	1000031e 	bne	r2,zero,8110a79c <setPreParsedFreePos+0xd4>
                    bSuccess = TRUE;
8110a790:	00800044 	movi	r2,1
8110a794:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
8110a798:	00001006 	br	8110a7dc <setPreParsedFreePos+0x114>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
8110a79c:	110ec500 	call	8110ec50 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
8110a7a0:	e0fffe03 	ldbu	r3,-8(fp)
8110a7a4:	00a04574 	movhi	r2,33045
8110a7a8:	1082c804 	addi	r2,r2,2848
8110a7ac:	18c01324 	muli	r3,r3,76
8110a7b0:	10c5883a 	add	r2,r2,r3
8110a7b4:	10800104 	addi	r2,r2,4
8110a7b8:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
8110a7bc:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
8110a7c0:	00000606 	br	8110a7dc <setPreParsedFreePos+0x114>

    OSMutexPend(xMutexPreParsed, 30, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 30 ticks = 30 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
8110a7c4:	e0bffe03 	ldbu	r2,-8(fp)
8110a7c8:	10800044 	addi	r2,r2,1
8110a7cc:	e0bffe05 	stb	r2,-8(fp)
8110a7d0:	e0bffe03 	ldbu	r2,-8(fp)
8110a7d4:	10800130 	cmpltui	r2,r2,4
8110a7d8:	103fcf1e 	bne	r2,zero,8110a718 <__reset+0xfb0ea718>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
8110a7dc:	d0a05517 	ldw	r2,-32428(gp)
8110a7e0:	1009883a 	mov	r4,r2
8110a7e4:	112e0000 	call	8112e000 <OSMutexPost>
    }
    return bSuccess;
8110a7e8:	e0bffd17 	ldw	r2,-12(fp)
}
8110a7ec:	e037883a 	mov	sp,fp
8110a7f0:	dfc00117 	ldw	ra,4(sp)
8110a7f4:	df000017 	ldw	fp,0(sp)
8110a7f8:	dec00204 	addi	sp,sp,8
8110a7fc:	f800283a 	ret

8110a800 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
8110a800:	defffb04 	addi	sp,sp,-20
8110a804:	de00012e 	bgeu	sp,et,8110a80c <setPreAckSenderFreePos+0xc>
8110a808:	003b68fa 	trap	3
8110a80c:	dfc00415 	stw	ra,16(sp)
8110a810:	df000315 	stw	fp,12(sp)
8110a814:	df000304 	addi	fp,sp,12
8110a818:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110a81c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8110a820:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
8110a824:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 50, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 50 ticks = 50 ms */
8110a828:	d0a05b17 	ldw	r2,-32404(gp)
8110a82c:	e0fffe44 	addi	r3,fp,-7
8110a830:	180d883a 	mov	r6,r3
8110a834:	01400c84 	movi	r5,50
8110a838:	1009883a 	mov	r4,r2
8110a83c:	112da5c0 	call	8112da5c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110a840:	e0bffe43 	ldbu	r2,-7(fp)
8110a844:	10803fcc 	andi	r2,r2,255
8110a848:	1000461e 	bne	r2,zero,8110a964 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
8110a84c:	e03ffe05 	stb	zero,-8(fp)
8110a850:	00003e06 	br	8110a94c <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
8110a854:	e0fffe03 	ldbu	r3,-8(fp)
8110a858:	00a04574 	movhi	r2,33045
8110a85c:	1082c404 	addi	r2,r2,2832
8110a860:	18c7883a 	add	r3,r3,r3
8110a864:	18c7883a 	add	r3,r3,r3
8110a868:	10c5883a 	add	r2,r2,r3
8110a86c:	10800003 	ldbu	r2,0(r2)
8110a870:	10803fcc 	andi	r2,r2,255
8110a874:	1080201c 	xori	r2,r2,128
8110a878:	10bfe004 	addi	r2,r2,-128
8110a87c:	1000301e 	bne	r2,zero,8110a940 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
8110a880:	e0fffe03 	ldbu	r3,-8(fp)
8110a884:	e0bfff17 	ldw	r2,-4(fp)
8110a888:	11000103 	ldbu	r4,4(r2)
8110a88c:	00a04574 	movhi	r2,33045
8110a890:	1082c404 	addi	r2,r2,2832
8110a894:	18c7883a 	add	r3,r3,r3
8110a898:	18c7883a 	add	r3,r3,r3
8110a89c:	10c5883a 	add	r2,r2,r3
8110a8a0:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
8110a8a4:	e0fffe03 	ldbu	r3,-8(fp)
8110a8a8:	e0bfff17 	ldw	r2,-4(fp)
8110a8ac:	11000143 	ldbu	r4,5(r2)
8110a8b0:	00a04574 	movhi	r2,33045
8110a8b4:	1082c404 	addi	r2,r2,2832
8110a8b8:	18c7883a 	add	r3,r3,r3
8110a8bc:	18c7883a 	add	r3,r3,r3
8110a8c0:	10c5883a 	add	r2,r2,r3
8110a8c4:	10800044 	addi	r2,r2,1
8110a8c8:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
8110a8cc:	e0fffe03 	ldbu	r3,-8(fp)
8110a8d0:	e0bfff17 	ldw	r2,-4(fp)
8110a8d4:	1100020b 	ldhu	r4,8(r2)
8110a8d8:	00a04574 	movhi	r2,33045
8110a8dc:	1082c404 	addi	r2,r2,2832
8110a8e0:	18c7883a 	add	r3,r3,r3
8110a8e4:	18c7883a 	add	r3,r3,r3
8110a8e8:	10c5883a 	add	r2,r2,r3
8110a8ec:	10800084 	addi	r2,r2,2
8110a8f0:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
8110a8f4:	d0a04d17 	ldw	r2,-32460(gp)
8110a8f8:	1009883a 	mov	r4,r2
8110a8fc:	112fdf00 	call	8112fdf0 <OSSemPost>
8110a900:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
8110a904:	e0bffe43 	ldbu	r2,-7(fp)
8110a908:	10803fcc 	andi	r2,r2,255
8110a90c:	10000926 	beq	r2,zero,8110a934 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
8110a910:	110ece80 	call	8110ece8 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
8110a914:	e0fffe03 	ldbu	r3,-8(fp)
8110a918:	00a04574 	movhi	r2,33045
8110a91c:	1082c404 	addi	r2,r2,2832
8110a920:	18c7883a 	add	r3,r3,r3
8110a924:	18c7883a 	add	r3,r3,r3
8110a928:	10c5883a 	add	r2,r2,r3
8110a92c:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
8110a930:	00000906 	br	8110a958 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
8110a934:	00800044 	movi	r2,1
8110a938:	e0bffd15 	stw	r2,-12(fp)
                break;
8110a93c:	00000606 	br	8110a958 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 50, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 50 ticks = 50 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
8110a940:	e0bffe03 	ldbu	r2,-8(fp)
8110a944:	10800044 	addi	r2,r2,1
8110a948:	e0bffe05 	stb	r2,-8(fp)
8110a94c:	e0bffe03 	ldbu	r2,-8(fp)
8110a950:	10800130 	cmpltui	r2,r2,4
8110a954:	103fbf1e 	bne	r2,zero,8110a854 <__reset+0xfb0ea854>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
8110a958:	d0a05b17 	ldw	r2,-32404(gp)
8110a95c:	1009883a 	mov	r4,r2
8110a960:	112e0000 	call	8112e000 <OSMutexPost>
    }

    return bSuccess;
8110a964:	e0bffd17 	ldw	r2,-12(fp)
}
8110a968:	e037883a 	mov	sp,fp
8110a96c:	dfc00117 	ldw	ra,4(sp)
8110a970:	df000017 	ldw	fp,0(sp)
8110a974:	dec00204 	addi	sp,sp,8
8110a978:	f800283a 	ret

8110a97c <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
8110a97c:	defffb04 	addi	sp,sp,-20
8110a980:	de00012e 	bgeu	sp,et,8110a988 <setPreAckReceiverFreePos+0xc>
8110a984:	003b68fa 	trap	3
8110a988:	dfc00415 	stw	ra,16(sp)
8110a98c:	df000315 	stw	fp,12(sp)
8110a990:	df000304 	addi	fp,sp,12
8110a994:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110a998:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8110a99c:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
8110a9a0:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 50, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 50 ticks = 50 ms */
8110a9a4:	d0a05117 	ldw	r2,-32444(gp)
8110a9a8:	e0fffe44 	addi	r3,fp,-7
8110a9ac:	180d883a 	mov	r6,r3
8110a9b0:	01400c84 	movi	r5,50
8110a9b4:	1009883a 	mov	r4,r2
8110a9b8:	112da5c0 	call	8112da5c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110a9bc:	e0bffe43 	ldbu	r2,-7(fp)
8110a9c0:	10803fcc 	andi	r2,r2,255
8110a9c4:	1000471e 	bne	r2,zero,8110aae4 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8110a9c8:	e03ffe05 	stb	zero,-8(fp)
8110a9cc:	00003e06 	br	8110aac8 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
8110a9d0:	e0fffe03 	ldbu	r3,-8(fp)
8110a9d4:	00a04574 	movhi	r2,33045
8110a9d8:	10bac004 	addi	r2,r2,-5376
8110a9dc:	18c7883a 	add	r3,r3,r3
8110a9e0:	18c7883a 	add	r3,r3,r3
8110a9e4:	10c5883a 	add	r2,r2,r3
8110a9e8:	10800003 	ldbu	r2,0(r2)
8110a9ec:	10803fcc 	andi	r2,r2,255
8110a9f0:	1080201c 	xori	r2,r2,128
8110a9f4:	10bfe004 	addi	r2,r2,-128
8110a9f8:	1000301e 	bne	r2,zero,8110aabc <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
8110a9fc:	e0fffe03 	ldbu	r3,-8(fp)
8110aa00:	e0bfff17 	ldw	r2,-4(fp)
8110aa04:	11000103 	ldbu	r4,4(r2)
8110aa08:	00a04574 	movhi	r2,33045
8110aa0c:	10bac004 	addi	r2,r2,-5376
8110aa10:	18c7883a 	add	r3,r3,r3
8110aa14:	18c7883a 	add	r3,r3,r3
8110aa18:	10c5883a 	add	r2,r2,r3
8110aa1c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
8110aa20:	e0fffe03 	ldbu	r3,-8(fp)
8110aa24:	e0bfff17 	ldw	r2,-4(fp)
8110aa28:	11000143 	ldbu	r4,5(r2)
8110aa2c:	00a04574 	movhi	r2,33045
8110aa30:	10bac004 	addi	r2,r2,-5376
8110aa34:	18c7883a 	add	r3,r3,r3
8110aa38:	18c7883a 	add	r3,r3,r3
8110aa3c:	10c5883a 	add	r2,r2,r3
8110aa40:	10800044 	addi	r2,r2,1
8110aa44:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
8110aa48:	e0fffe03 	ldbu	r3,-8(fp)
8110aa4c:	e0bfff17 	ldw	r2,-4(fp)
8110aa50:	1100020b 	ldhu	r4,8(r2)
8110aa54:	00a04574 	movhi	r2,33045
8110aa58:	10bac004 	addi	r2,r2,-5376
8110aa5c:	18c7883a 	add	r3,r3,r3
8110aa60:	18c7883a 	add	r3,r3,r3
8110aa64:	10c5883a 	add	r2,r2,r3
8110aa68:	10800084 	addi	r2,r2,2
8110aa6c:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
8110aa70:	d0a05217 	ldw	r2,-32440(gp)
8110aa74:	1009883a 	mov	r4,r2
8110aa78:	112fdf00 	call	8112fdf0 <OSSemPost>
8110aa7c:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
8110aa80:	e0bffe43 	ldbu	r2,-7(fp)
8110aa84:	10803fcc 	andi	r2,r2,255
8110aa88:	1000031e 	bne	r2,zero,8110aa98 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
8110aa8c:	00800044 	movi	r2,1
8110aa90:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
8110aa94:	00000f06 	br	8110aad4 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
8110aa98:	110ec9c0 	call	8110ec9c <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
8110aa9c:	e0fffe03 	ldbu	r3,-8(fp)
8110aaa0:	00a04574 	movhi	r2,33045
8110aaa4:	10bac004 	addi	r2,r2,-5376
8110aaa8:	18c7883a 	add	r3,r3,r3
8110aaac:	18c7883a 	add	r3,r3,r3
8110aab0:	10c5883a 	add	r2,r2,r3
8110aab4:	10000005 	stb	zero,0(r2)
                }
                break;
8110aab8:	00000606 	br	8110aad4 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 50, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 50 ticks = 50 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8110aabc:	e0bffe03 	ldbu	r2,-8(fp)
8110aac0:	10800044 	addi	r2,r2,1
8110aac4:	e0bffe05 	stb	r2,-8(fp)
8110aac8:	e0bffe03 	ldbu	r2,-8(fp)
8110aacc:	10800130 	cmpltui	r2,r2,4
8110aad0:	103fbf1e 	bne	r2,zero,8110a9d0 <__reset+0xfb0ea9d0>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
8110aad4:	d0a05117 	ldw	r2,-32444(gp)
8110aad8:	1009883a 	mov	r4,r2
8110aadc:	112e0000 	call	8112e000 <OSMutexPost>
8110aae0:	00000706 	br	8110ab00 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
8110aae4:	d0a04e17 	ldw	r2,-32456(gp)
8110aae8:	100f883a 	mov	r7,r2
8110aaec:	01801404 	movi	r6,80
8110aaf0:	01400044 	movi	r5,1
8110aaf4:	01204534 	movhi	r4,33044
8110aaf8:	2136cc04 	addi	r4,r4,-9424
8110aafc:	1112ccc0 	call	81112ccc <fwrite>
        #endif
    }

    return bSuccess;
8110ab00:	e0bffd17 	ldw	r2,-12(fp)
}
8110ab04:	e037883a 	mov	sp,fp
8110ab08:	dfc00117 	ldw	ra,4(sp)
8110ab0c:	df000017 	ldw	fp,0(sp)
8110ab10:	dec00204 	addi	sp,sp,8
8110ab14:	f800283a 	ret

8110ab18 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
8110ab18:	defff404 	addi	sp,sp,-48
8110ab1c:	de00012e 	bgeu	sp,et,8110ab24 <bPreParserV2+0xc>
8110ab20:	003b68fa 	trap	3
8110ab24:	dfc00b15 	stw	ra,44(sp)
8110ab28:	df000a15 	stw	fp,40(sp)
8110ab2c:	dc000915 	stw	r16,36(sp)
8110ab30:	df000a04 	addi	fp,sp,40
8110ab34:	e13ffd15 	stw	r4,-12(fp)
8110ab38:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
8110ab3c:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
8110ab40:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
8110ab44:	01402004 	movi	r5,128
8110ab48:	e13ffd17 	ldw	r4,-12(fp)
8110ab4c:	11140f40 	call	811140f4 <strnlen>
8110ab50:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
8110ab54:	01400ec4 	movi	r5,59
8110ab58:	e13ffd17 	ldw	r4,-12(fp)
8110ab5c:	110d8340 	call	8110d834 <siPosStr>
8110ab60:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
8110ab64:	e0fff98f 	ldh	r3,-26(fp)
8110ab68:	e0bff90f 	ldh	r2,-28(fp)
8110ab6c:	10bfffc4 	addi	r2,r2,-1
8110ab70:	18800226 	beq	r3,r2,8110ab7c <bPreParserV2+0x64>
        return bSuccess;
8110ab74:	e0bff617 	ldw	r2,-40(fp)
8110ab78:	0000c306 	br	8110ae88 <bPreParserV2+0x370>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
8110ab7c:	01401f04 	movi	r5,124
8110ab80:	e13ffd17 	ldw	r4,-12(fp)
8110ab84:	110d8340 	call	8110d834 <siPosStr>
8110ab88:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
8110ab8c:	e0bffa0f 	ldh	r2,-24(fp)
8110ab90:	e0fff98f 	ldh	r3,-26(fp)
8110ab94:	1880020e 	bge	r3,r2,8110aba0 <bPreParserV2+0x88>
        return bSuccess;
8110ab98:	e0bff617 	ldw	r2,-40(fp)
8110ab9c:	0000ba06 	br	8110ae88 <bPreParserV2+0x370>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
8110aba0:	01604534 	movhi	r5,33044
8110aba4:	2976e104 	addi	r5,r5,-9340
8110aba8:	e13ffd17 	ldw	r4,-12(fp)
8110abac:	11140100 	call	81114010 <strcspn>
8110abb0:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
8110abb4:	e0bffa8f 	ldh	r2,-22(fp)
8110abb8:	e0fffa0f 	ldh	r3,-24(fp)
8110abbc:	1880020e 	bge	r3,r2,8110abc8 <bPreParserV2+0xb0>
        return bSuccess;
8110abc0:	e0bff617 	ldw	r2,-40(fp)
8110abc4:	0000b006 	br	8110ae88 <bPreParserV2+0x370>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
8110abc8:	e0bffa8f 	ldh	r2,-22(fp)
8110abcc:	e0fffd17 	ldw	r3,-12(fp)
8110abd0:	1885883a 	add	r2,r3,r2
8110abd4:	10c00003 	ldbu	r3,0(r2)
8110abd8:	e0bffe17 	ldw	r2,-8(fp)
8110abdc:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
8110abe0:	e0bffe17 	ldw	r2,-8(fp)
8110abe4:	10800103 	ldbu	r2,4(r2)
8110abe8:	10803fcc 	andi	r2,r2,255
8110abec:	1080201c 	xori	r2,r2,128
8110abf0:	10bfe004 	addi	r2,r2,-128
8110abf4:	108008d8 	cmpnei	r2,r2,35
8110abf8:	1000041e 	bne	r2,zero,8110ac0c <bPreParserV2+0xf4>
        bSuccess = TRUE;
8110abfc:	00800044 	movi	r2,1
8110ac00:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
8110ac04:	e0bff617 	ldw	r2,-40(fp)
8110ac08:	00009f06 	br	8110ae88 <bPreParserV2+0x370>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/

	#ifdef DEBUG_ON
		fprintf(fp," Debug -  siIni = %hhu, siCRC = %hhu\n", siIni, siCRC );
8110ac0c:	d0a04e17 	ldw	r2,-32456(gp)
8110ac10:	e0fffa8f 	ldh	r3,-22(fp)
8110ac14:	e13ffa0f 	ldh	r4,-24(fp)
8110ac18:	200f883a 	mov	r7,r4
8110ac1c:	180d883a 	mov	r6,r3
8110ac20:	01604534 	movhi	r5,33044
8110ac24:	2976bc04 	addi	r5,r5,-9488
8110ac28:	1009883a 	mov	r4,r2
8110ac2c:	11126e00 	call	811126e0 <fprintf>
	#endif

    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
8110ac30:	e0bffa8f 	ldh	r2,-22(fp)
8110ac34:	e0fffd17 	ldw	r3,-12(fp)
8110ac38:	1889883a 	add	r4,r3,r2
8110ac3c:	e0fffa0f 	ldh	r3,-24(fp)
8110ac40:	e0bffa8f 	ldh	r2,-22(fp)
8110ac44:	1885c83a 	sub	r2,r3,r2
8110ac48:	100b883a 	mov	r5,r2
8110ac4c:	110ea0c0 	call	8110ea0c <ucCrc8wInit>
8110ac50:	1007883a 	mov	r3,r2
8110ac54:	e0bffe17 	ldw	r2,-8(fp)
8110ac58:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
8110ac5c:	e0bffa8f 	ldh	r2,-22(fp)
8110ac60:	10800044 	addi	r2,r2,1
8110ac64:	e0fffd17 	ldw	r3,-12(fp)
8110ac68:	1885883a 	add	r2,r3,r2
8110ac6c:	10c00003 	ldbu	r3,0(r2)
8110ac70:	e0bffe17 	ldw	r2,-8(fp)
8110ac74:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
8110ac78:	e0bffe17 	ldw	r2,-8(fp)
8110ac7c:	10000185 	stb	zero,6(r2)
    memset( xPerParcedBuffer->usiValues , 0 , SIZE_UCVALUES*sizeof(xPerParcedBuffer->usiValues) );    
8110ac80:	e0bffe17 	ldw	r2,-8(fp)
8110ac84:	10800204 	addi	r2,r2,8
8110ac88:	01820004 	movi	r6,2048
8110ac8c:	000b883a 	mov	r5,zero
8110ac90:	1009883a 	mov	r4,r2
8110ac94:	11138300 	call	81113830 <memset>

    i = siIni + 3; /* "?C:i..." */
8110ac98:	e0bffa8b 	ldhu	r2,-22(fp)
8110ac9c:	108000c4 	addi	r2,r2,3
8110aca0:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
8110aca4:	e0bffb44 	addi	r2,fp,-19
8110aca8:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
8110acac:	e0bffb44 	addi	r2,fp,-19
8110acb0:	01800184 	movi	r6,6
8110acb4:	000b883a 	mov	r5,zero
8110acb8:	1009883a 	mov	r4,r2
8110acbc:	11138300 	call	81113830 <memset>
        do {
            c = buffer[i];
8110acc0:	e0bff703 	ldbu	r2,-36(fp)
8110acc4:	e0fffd17 	ldw	r3,-12(fp)
8110acc8:	1885883a 	add	r2,r3,r2
8110accc:	10800003 	ldbu	r2,0(r2)
8110acd0:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
8110acd4:	d0e00317 	ldw	r3,-32756(gp)
8110acd8:	e0bffb07 	ldb	r2,-20(fp)
8110acdc:	10800044 	addi	r2,r2,1
8110ace0:	1885883a 	add	r2,r3,r2
8110ace4:	10800003 	ldbu	r2,0(r2)
8110ace8:	10803fcc 	andi	r2,r2,255
8110acec:	1080010c 	andi	r2,r2,4
8110acf0:	10000626 	beq	r2,zero,8110ad0c <bPreParserV2+0x1f4>
                (*p_inteiro) = c;
8110acf4:	e0bff817 	ldw	r2,-32(fp)
8110acf8:	e0fffb03 	ldbu	r3,-20(fp)
8110acfc:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
8110ad00:	e0bff817 	ldw	r2,-32(fp)
8110ad04:	10800044 	addi	r2,r2,1
8110ad08:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
8110ad0c:	e0bff703 	ldbu	r2,-36(fp)
8110ad10:	10800044 	addi	r2,r2,1
8110ad14:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
8110ad18:	e0bff90f 	ldh	r2,-28(fp)
8110ad1c:	e0fff703 	ldbu	r3,-36(fp)
8110ad20:	1880090e 	bge	r3,r2,8110ad48 <bPreParserV2+0x230>
8110ad24:	e0bffb07 	ldb	r2,-20(fp)
8110ad28:	10800ea0 	cmpeqi	r2,r2,58
8110ad2c:	1000061e 	bne	r2,zero,8110ad48 <bPreParserV2+0x230>
8110ad30:	e0bffb07 	ldb	r2,-20(fp)
8110ad34:	10800ee0 	cmpeqi	r2,r2,59
8110ad38:	1000031e 	bne	r2,zero,8110ad48 <bPreParserV2+0x230>
8110ad3c:	e0bffb07 	ldb	r2,-20(fp)
8110ad40:	10801f18 	cmpnei	r2,r2,124
8110ad44:	103fde1e 	bne	r2,zero,8110acc0 <__reset+0xfb0eacc0>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110ad48:	e0bff817 	ldw	r2,-32(fp)
8110ad4c:	00c00284 	movi	r3,10
8110ad50:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
8110ad54:	e0bffb07 	ldb	r2,-20(fp)
8110ad58:	10800ea0 	cmpeqi	r2,r2,58
8110ad5c:	1000031e 	bne	r2,zero,8110ad6c <bPreParserV2+0x254>
8110ad60:	e0bffb07 	ldb	r2,-20(fp)
8110ad64:	10801f18 	cmpnei	r2,r2,124
8110ad68:	10001a1e 	bne	r2,zero,8110add4 <bPreParserV2+0x2bc>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
8110ad6c:	e0bffe17 	ldw	r2,-8(fp)
8110ad70:	10800183 	ldbu	r2,6(r2)
8110ad74:	10803fcc 	andi	r2,r2,255
8110ad78:	10800828 	cmpgeui	r2,r2,32
8110ad7c:	1000041e 	bne	r2,zero,8110ad90 <bPreParserV2+0x278>
8110ad80:	e0bffe17 	ldw	r2,-8(fp)
8110ad84:	10800183 	ldbu	r2,6(r2)
8110ad88:	14003fcc 	andi	r16,r2,255
8110ad8c:	00000106 	br	8110ad94 <bPreParserV2+0x27c>
8110ad90:	04000804 	movi	r16,32
8110ad94:	e0bffb44 	addi	r2,fp,-19
8110ad98:	1009883a 	mov	r4,r2
8110ad9c:	11125840 	call	81112584 <atoi>
8110ada0:	1009883a 	mov	r4,r2
8110ada4:	e0fffe17 	ldw	r3,-8(fp)
8110ada8:	80800104 	addi	r2,r16,4
8110adac:	1085883a 	add	r2,r2,r2
8110adb0:	1885883a 	add	r2,r3,r2
8110adb4:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
8110adb8:	e0bffe17 	ldw	r2,-8(fp)
8110adbc:	10800183 	ldbu	r2,6(r2)
8110adc0:	10800044 	addi	r2,r2,1
8110adc4:	1007883a 	mov	r3,r2
8110adc8:	e0bffe17 	ldw	r2,-8(fp)
8110adcc:	10c00185 	stb	r3,6(r2)
8110add0:	00000906 	br	8110adf8 <bPreParserV2+0x2e0>
        }
        else if ( c == FINAL_CHAR )
8110add4:	e0bffb07 	ldb	r2,-20(fp)
8110add8:	10800ed8 	cmpnei	r2,r2,59
8110addc:	1000061e 	bne	r2,zero,8110adf8 <bPreParserV2+0x2e0>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
8110ade0:	e0bffb44 	addi	r2,fp,-19
8110ade4:	1009883a 	mov	r4,r2
8110ade8:	11125840 	call	81112584 <atoi>
8110adec:	1007883a 	mov	r3,r2
8110adf0:	e0bffe17 	ldw	r2,-8(fp)
8110adf4:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
8110adf8:	e0bffb07 	ldb	r2,-20(fp)
8110adfc:	10800ee0 	cmpeqi	r2,r2,59
8110ae00:	1000031e 	bne	r2,zero,8110ae10 <bPreParserV2+0x2f8>
8110ae04:	e0bff90f 	ldh	r2,-28(fp)
8110ae08:	e0fff703 	ldbu	r3,-36(fp)
8110ae0c:	18bfa516 	blt	r3,r2,8110aca4 <__reset+0xfb0eaca4>


    if ( c == FINAL_CHAR )
8110ae10:	e0bffb07 	ldb	r2,-20(fp)
8110ae14:	10800ed8 	cmpnei	r2,r2,59
8110ae18:	1000191e 	bne	r2,zero,8110ae80 <bPreParserV2+0x368>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
8110ae1c:	e0bffe17 	ldw	r2,-8(fp)
8110ae20:	10c01243 	ldbu	r3,73(r2)
8110ae24:	e0bffe17 	ldw	r2,-8(fp)
8110ae28:	10801203 	ldbu	r2,72(r2)
8110ae2c:	18c03fcc 	andi	r3,r3,255
8110ae30:	10803fcc 	andi	r2,r2,255
8110ae34:	1880031e 	bne	r3,r2,8110ae44 <bPreParserV2+0x32c>
            bSuccess = TRUE;
8110ae38:	00800044 	movi	r2,1
8110ae3c:	e0bff615 	stw	r2,-40(fp)
8110ae40:	00001006 	br	8110ae84 <bPreParserV2+0x36c>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
8110ae44:	d0e04e17 	ldw	r3,-32456(gp)
8110ae48:	e0bffe17 	ldw	r2,-8(fp)
8110ae4c:	10801203 	ldbu	r2,72(r2)
8110ae50:	11003fcc 	andi	r4,r2,255
8110ae54:	e0bffe17 	ldw	r2,-8(fp)
8110ae58:	10801243 	ldbu	r2,73(r2)
8110ae5c:	10803fcc 	andi	r2,r2,255
8110ae60:	100f883a 	mov	r7,r2
8110ae64:	200d883a 	mov	r6,r4
8110ae68:	01604534 	movhi	r5,33044
8110ae6c:	2976e304 	addi	r5,r5,-9332
8110ae70:	1809883a 	mov	r4,r3
8110ae74:	11126e00 	call	811126e0 <fprintf>
            #endif
            bSuccess = FALSE;
8110ae78:	e03ff615 	stw	zero,-40(fp)
8110ae7c:	00000106 	br	8110ae84 <bPreParserV2+0x36c>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
8110ae80:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
8110ae84:	e0bff617 	ldw	r2,-40(fp)
}
8110ae88:	e6ffff04 	addi	sp,fp,-4
8110ae8c:	dfc00217 	ldw	ra,8(sp)
8110ae90:	df000117 	ldw	fp,4(sp)
8110ae94:	dc000017 	ldw	r16,0(sp)
8110ae98:	dec00304 	addi	sp,sp,12
8110ae9c:	f800283a 	ret

8110aea0 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
8110aea0:	defff804 	addi	sp,sp,-32
8110aea4:	de00012e 	bgeu	sp,et,8110aeac <vSenderComTask+0xc>
8110aea8:	003b68fa 	trap	3
8110aeac:	dfc00715 	stw	ra,28(sp)
8110aeb0:	df000615 	stw	fp,24(sp)
8110aeb4:	df000604 	addi	fp,sp,24
8110aeb8:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    OS_STK_DATA data;
    bool bSuccess;
    int desligarEm = 0;
8110aebc:	e03ffb15 	stw	zero,-20(fp)

    eSenderMode = sConfiguringSender;
8110aec0:	e03ffa15 	stw	zero,-24(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
8110aec4:	d0a04e17 	ldw	r2,-32456(gp)
8110aec8:	100f883a 	mov	r7,r2
8110aecc:	01800704 	movi	r6,28
8110aed0:	01400044 	movi	r5,1
8110aed4:	01204534 	movhi	r4,33044
8110aed8:	2136ef04 	addi	r4,r4,-9284
8110aedc:	1112ccc0 	call	81112ccc <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
8110aee0:	e0bffa17 	ldw	r2,-24(fp)
8110aee4:	10c00060 	cmpeqi	r3,r2,1
8110aee8:	1800091e 	bne	r3,zero,8110af10 <vSenderComTask+0x70>
8110aeec:	0080052e 	bgeu	zero,r2,8110af04 <vSenderComTask+0x64>
8110aef0:	10c000a0 	cmpeqi	r3,r2,2
8110aef4:	1800471e 	bne	r3,zero,8110b014 <vSenderComTask+0x174>
8110aef8:	10800160 	cmpeqi	r2,r2,5
8110aefc:	10002c1e 	bne	r2,zero,8110afb0 <vSenderComTask+0x110>
8110af00:	00003a06 	br	8110afec <vSenderComTask+0x14c>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
8110af04:	00800044 	movi	r2,1
8110af08:	e0bffa15 	stw	r2,-24(fp)
                break;
8110af0c:	00004206 	br	8110b018 <vSenderComTask+0x178>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
8110af10:	d0a04e17 	ldw	r2,-32456(gp)
8110af14:	100f883a 	mov	r7,r2
8110af18:	01800784 	movi	r6,30
8110af1c:	01400044 	movi	r5,1
8110af20:	01204534 	movhi	r4,33044
8110af24:	2136f704 	addi	r4,r4,-9252
8110af28:	1112ccc0 	call	81112ccc <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
8110af2c:	01400044 	movi	r5,1
8110af30:	01204534 	movhi	r4,33044
8110af34:	2136ff04 	addi	r4,r4,-9220
8110af38:	110d0740 	call	8110d074 <bSendUART32v2>
8110af3c:	e0bffc15 	stw	r2,-16(fp)
                if ( bSuccess == TRUE ) {
8110af40:	e0bffc17 	ldw	r2,-16(fp)
8110af44:	10800058 	cmpnei	r2,r2,1
8110af48:	10000a1e 	bne	r2,zero,8110af74 <vSenderComTask+0xd4>
                    eSenderMode = sDummySender;
8110af4c:	00800144 	movi	r2,5
8110af50:	e0bffa15 	stw	r2,-24(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
8110af54:	d0a04e17 	ldw	r2,-32456(gp)
8110af58:	100f883a 	mov	r7,r2
8110af5c:	01800d44 	movi	r6,53
8110af60:	01400044 	movi	r5,1
8110af64:	01204534 	movhi	r4,33044
8110af68:	21370204 	addi	r4,r4,-9208
8110af6c:	1112ccc0 	call	81112ccc <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
8110af70:	00002906 	br	8110b018 <vSenderComTask+0x178>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
8110af74:	d0a04e17 	ldw	r2,-32456(gp)
8110af78:	100f883a 	mov	r7,r2
8110af7c:	01800784 	movi	r6,30
8110af80:	01400044 	movi	r5,1
8110af84:	01204534 	movhi	r4,33044
8110af88:	21371004 	addi	r4,r4,-9152
8110af8c:	1112ccc0 	call	81112ccc <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
8110af90:	00800044 	movi	r2,1
8110af94:	e0bffa15 	stw	r2,-24(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
8110af98:	000f883a 	mov	r7,zero
8110af9c:	01800144 	movi	r6,5
8110afa0:	000b883a 	mov	r5,zero
8110afa4:	0009883a 	mov	r4,zero
8110afa8:	1131a000 	call	81131a00 <OSTimeDlyHMSM>
                }
                break;
8110afac:	00001a06 	br	8110b018 <vSenderComTask+0x178>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
8110afb0:	00800144 	movi	r2,5
8110afb4:	e0bffa15 	stw	r2,-24(fp)

                #endif
                */

                #ifdef DEBUG_ON
                    debug(fp,"sDummySender\n");
8110afb8:	d0a04e17 	ldw	r2,-32456(gp)
8110afbc:	100f883a 	mov	r7,r2
8110afc0:	01800344 	movi	r6,13
8110afc4:	01400044 	movi	r5,1
8110afc8:	01204534 	movhi	r4,33044
8110afcc:	21371804 	addi	r4,r4,-9120
8110afd0:	1112ccc0 	call	81112ccc <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 3 second*/
8110afd4:	000f883a 	mov	r7,zero
8110afd8:	01800144 	movi	r6,5
8110afdc:	000b883a 	mov	r5,zero
8110afe0:	0009883a 	mov	r4,zero
8110afe4:	1131a000 	call	81131a00 <OSTimeDlyHMSM>

                break;
8110afe8:	00000b06 	br	8110b018 <vSenderComTask+0x178>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
8110afec:	d0a04e17 	ldw	r2,-32456(gp)
8110aff0:	100f883a 	mov	r7,r2
8110aff4:	018003c4 	movi	r6,15
8110aff8:	01400044 	movi	r5,1
8110affc:	01204534 	movhi	r4,33044
8110b000:	21371c04 	addi	r4,r4,-9104
8110b004:	1112ccc0 	call	81112ccc <fwrite>
                #endif
                eSenderMode = sDummySender;
8110b008:	00800144 	movi	r2,5
8110b00c:	e0bffa15 	stw	r2,-24(fp)
                break;
8110b010:	00000106 	br	8110b018 <vSenderComTask+0x178>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
8110b014:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
8110b018:	003fb106 	br	8110aee0 <__reset+0xfb0eaee0>

8110b01c <vSimMebTask>:


#include "sim_meb_task.h"


void vSimMebTask(void *task_data) {
8110b01c:	defffd04 	addi	sp,sp,-12
8110b020:	de00012e 	bgeu	sp,et,8110b028 <vSimMebTask+0xc>
8110b024:	003b68fa 	trap	3
8110b028:	df000215 	stw	fp,8(sp)
8110b02c:	df000204 	addi	fp,sp,8
8110b030:	e13fff15 	stw	r4,-4(fp)
	tFEEStates eFeeState;
	bool bSuccess = FALSE;
8110b034:	e03ffe15 	stw	zero,-8(fp)


	//SIMUCAM MAIN TASK


}
8110b038:	0001883a 	nop
8110b03c:	e037883a 	mov	sp,fp
8110b040:	df000017 	ldw	fp,0(sp)
8110b044:	dec00104 	addi	sp,sp,4
8110b048:	f800283a 	ret

8110b04c <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
8110b04c:	defffc04 	addi	sp,sp,-16
8110b050:	de00012e 	bgeu	sp,et,8110b058 <vTimeoutCheckerTaskv2+0xc>
8110b054:	003b68fa 	trap	3
8110b058:	dfc00315 	stw	ra,12(sp)
8110b05c:	df000215 	stw	fp,8(sp)
8110b060:	df000204 	addi	fp,sp,8
8110b064:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
8110b068:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
8110b06c:	d0a04e17 	ldw	r2,-32456(gp)
8110b070:	100f883a 	mov	r7,r2
8110b074:	01800844 	movi	r6,33
8110b078:	01400044 	movi	r5,1
8110b07c:	01204534 	movhi	r4,33044
8110b080:	21372004 	addi	r4,r4,-9088
8110b084:	1112ccc0 	call	81112ccc <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
8110b088:	d0a05317 	ldw	r2,-32436(gp)
8110b08c:	e1bffe04 	addi	r6,fp,-8
8110b090:	000b883a 	mov	r5,zero
8110b094:	1009883a 	mov	r4,r2
8110b098:	112fa680 	call	8112fa68 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
8110b09c:	e0bffe03 	ldbu	r2,-8(fp)
8110b0a0:	10803fcc 	andi	r2,r2,255
8110b0a4:	1000021e 	bne	r2,zero,8110b0b0 <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
8110b0a8:	110b0b80 	call	8110b0b8 <vCheck>
8110b0ac:	003ff606 	br	8110b088 <__reset+0xfb0eb088>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
8110b0b0:	110f8980 	call	8110f898 <vFailGetBlockingSemTimeoutTask>
        }
    }
8110b0b4:	003ff406 	br	8110b088 <__reset+0xfb0eb088>

8110b0b8 <vCheck>:
}


void vCheck( void ) {
8110b0b8:	defffd04 	addi	sp,sp,-12
8110b0bc:	de00012e 	bgeu	sp,et,8110b0c4 <vCheck+0xc>
8110b0c0:	003b68fa 	trap	3
8110b0c4:	dfc00215 	stw	ra,8(sp)
8110b0c8:	df000115 	stw	fp,4(sp)
8110b0cc:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
8110b0d0:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
8110b0d4:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
8110b0d8:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8110b0dc:	d0a05483 	ldbu	r2,-32430(gp)
8110b0e0:	10803fcc 	andi	r2,r2,255
8110b0e4:	10800218 	cmpnei	r2,r2,8
8110b0e8:	1000021e 	bne	r2,zero,8110b0f4 <vCheck+0x3c>
8110b0ec:	00c00104 	movi	r3,4
8110b0f0:	00000106 	br	8110b0f8 <vCheck+0x40>
8110b0f4:	0007883a 	mov	r3,zero
8110b0f8:	d0a05d03 	ldbu	r2,-32396(gp)
8110b0fc:	10803fcc 	andi	r2,r2,255
8110b100:	10800118 	cmpnei	r2,r2,4
8110b104:	1000021e 	bne	r2,zero,8110b110 <vCheck+0x58>
8110b108:	00800084 	movi	r2,2
8110b10c:	00000106 	br	8110b114 <vCheck+0x5c>
8110b110:	0005883a 	mov	r2,zero
8110b114:	1884b03a 	or	r2,r3,r2
8110b118:	1007883a 	mov	r3,r2
8110b11c:	d0a05d43 	ldbu	r2,-32395(gp)
8110b120:	10803fcc 	andi	r2,r2,255
8110b124:	108000a0 	cmpeqi	r2,r2,2
8110b128:	1884b03a 	or	r2,r3,r2
8110b12c:	1007883a 	mov	r3,r2
8110b130:	e0bfff03 	ldbu	r2,-4(fp)
8110b134:	1884b03a 	or	r2,r3,r2
8110b138:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
8110b13c:	e0bfff03 	ldbu	r2,-4(fp)
8110b140:	108001d8 	cmpnei	r2,r2,7
8110b144:	10003726 	beq	r2,zero,8110b224 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
8110b148:	d0a05c17 	ldw	r2,-32400(gp)
8110b14c:	e0ffff44 	addi	r3,fp,-3
8110b150:	180d883a 	mov	r6,r3
8110b154:	000b883a 	mov	r5,zero
8110b158:	1009883a 	mov	r4,r2
8110b15c:	112da5c0 	call	8112da5c <OSMutexPend>

    if ( ucErrorCode != OS_NO_ERR ) {
8110b160:	e0bfff43 	ldbu	r2,-3(fp)
8110b164:	10803fcc 	andi	r2,r2,255
8110b168:	10000826 	beq	r2,zero,8110b18c <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
8110b16c:	d0a04e17 	ldw	r2,-32456(gp)
8110b170:	100f883a 	mov	r7,r2
8110b174:	01800f04 	movi	r6,60
8110b178:	01400044 	movi	r5,1
8110b17c:	01204534 	movhi	r4,33044
8110b180:	21372904 	addi	r4,r4,-9052
8110b184:	1112ccc0 	call	81112ccc <fwrite>
		#endif
        return;
8110b188:	00002706 	br	8110b228 <vCheck+0x170>


    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */

    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 == (0b00000001 & ucHashVerification ) )
8110b18c:	e0bfff03 	ldbu	r2,-4(fp)
8110b190:	1080004c 	andi	r2,r2,1
8110b194:	10803fcc 	andi	r2,r2,255
8110b198:	10000226 	beq	r2,zero,8110b1a4 <vCheck+0xec>
        vCheckRetransmission128();
8110b19c:	110b23c0 	call	8110b23c <vCheckRetransmission128>
8110b1a0:	00000506 	br	8110b1b8 <vCheck+0x100>
    else
        memset( xInUseRetrans.b128 , FALSE , sizeof(bool)*N_128); /* For consistency with SemCount128 */
8110b1a4:	01800204 	movi	r6,8
8110b1a8:	000b883a 	mov	r5,zero
8110b1ac:	01204574 	movhi	r4,33045
8110b1b0:	213a6c04 	addi	r4,r4,-5712
8110b1b4:	11138300 	call	81113830 <memset>

        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 == (0b00000010 & ucHashVerification ) )
8110b1b8:	e0bfff03 	ldbu	r2,-4(fp)
8110b1bc:	1080008c 	andi	r2,r2,2
8110b1c0:	10803fcc 	andi	r2,r2,255
8110b1c4:	10000226 	beq	r2,zero,8110b1d0 <vCheck+0x118>
        vCheckRetransmission64();
8110b1c8:	110b4fc0 	call	8110b4fc <vCheckRetransmission64>
8110b1cc:	00000506 	br	8110b1e4 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(bool)*N_64); /* For consistency with SemCount64 */
8110b1d0:	01800404 	movi	r6,16
8110b1d4:	000b883a 	mov	r5,zero
8110b1d8:	01204574 	movhi	r4,33045
8110b1dc:	213a6e04 	addi	r4,r4,-5704
8110b1e0:	11138300 	call	81113830 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 == (0b00000100 & ucHashVerification ) )
8110b1e4:	e0bfff03 	ldbu	r2,-4(fp)
8110b1e8:	1080010c 	andi	r2,r2,4
8110b1ec:	10803fcc 	andi	r2,r2,255
8110b1f0:	10000226 	beq	r2,zero,8110b1fc <vCheck+0x144>
        vCheckRetransmission32();
8110b1f4:	110b7880 	call	8110b788 <vCheckRetransmission32>
8110b1f8:	00000506 	br	8110b210 <vCheck+0x158>
    else
        memset( xInUseRetrans.b32 , FALSE , sizeof(bool)*N_32); /* For consistency with SemCount32 */
8110b1fc:	01800804 	movi	r6,32
8110b200:	000b883a 	mov	r5,zero
8110b204:	01204574 	movhi	r4,33045
8110b208:	213a7204 	addi	r4,r4,-5688
8110b20c:	11138300 	call	81113830 <memset>


    OSMutexPost(xTxUARTMutex);
8110b210:	d0a05c17 	ldw	r2,-32400(gp)
8110b214:	1009883a 	mov	r4,r2
8110b218:	112e0000 	call	8112e000 <OSMutexPost>
    return;
8110b21c:	0001883a 	nop
8110b220:	00000106 	br	8110b228 <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
8110b224:	0001883a 	nop
        memset( xInUseRetrans.b32 , FALSE , sizeof(bool)*N_32); /* For consistency with SemCount32 */


    OSMutexPost(xTxUARTMutex);
    return;
}
8110b228:	e037883a 	mov	sp,fp
8110b22c:	dfc00117 	ldw	ra,4(sp)
8110b230:	df000017 	ldw	fp,0(sp)
8110b234:	dec00204 	addi	sp,sp,8
8110b238:	f800283a 	ret

8110b23c <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
8110b23c:	defffd04 	addi	sp,sp,-12
8110b240:	de00012e 	bgeu	sp,et,8110b248 <vCheckRetransmission128+0xc>
8110b244:	003b68fa 	trap	3
8110b248:	dfc00215 	stw	ra,8(sp)
8110b24c:	df000115 	stw	fp,4(sp)
8110b250:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8110b254:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
8110b258:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
8110b25c:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8110b260:	d0a05817 	ldw	r2,-32416(gp)
8110b264:	e0ffff84 	addi	r3,fp,-2
8110b268:	180b883a 	mov	r5,r3
8110b26c:	1009883a 	mov	r4,r2
8110b270:	112d3dc0 	call	8112d3dc <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8110b274:	e0bfff83 	ldbu	r2,-2(fp)
8110b278:	10803fcc 	andi	r2,r2,255
8110b27c:	1000991e 	bne	r2,zero,8110b4e4 <vCheckRetransmission128+0x2a8>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110b280:	e03fff05 	stb	zero,-4(fp)
8110b284:	00008f06 	br	8110b4c4 <vCheckRetransmission128+0x288>
	{
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
8110b288:	e0ffff03 	ldbu	r3,-4(fp)
8110b28c:	00a04574 	movhi	r2,33045
8110b290:	10ba6c04 	addi	r2,r2,-5712
8110b294:	18c7883a 	add	r3,r3,r3
8110b298:	18c7883a 	add	r3,r3,r3
8110b29c:	10c5883a 	add	r2,r2,r3
8110b2a0:	10800017 	ldw	r2,0(r2)
8110b2a4:	10800058 	cmpnei	r2,r2,1
8110b2a8:	1000831e 	bne	r2,zero,8110b4b8 <vCheckRetransmission128+0x27c>

            if ( xBuffer128[ucIL].bSent == TRUE )
8110b2ac:	e0ffff03 	ldbu	r3,-4(fp)
8110b2b0:	00a04574 	movhi	r2,33045
8110b2b4:	10ba7a04 	addi	r2,r2,-5656
8110b2b8:	18c02324 	muli	r3,r3,140
8110b2bc:	10c5883a 	add	r2,r2,r3
8110b2c0:	10802004 	addi	r2,r2,128
8110b2c4:	10800017 	ldw	r2,0(r2)
8110b2c8:	10800058 	cmpnei	r2,r2,1
8110b2cc:	1000211e 	bne	r2,zero,8110b354 <vCheckRetransmission128+0x118>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
8110b2d0:	e0ffff03 	ldbu	r3,-4(fp)
8110b2d4:	00a04574 	movhi	r2,33045
8110b2d8:	10ba7a04 	addi	r2,r2,-5656
8110b2dc:	19002324 	muli	r4,r3,140
8110b2e0:	1105883a 	add	r2,r2,r4
8110b2e4:	10802184 	addi	r2,r2,134
8110b2e8:	1080000b 	ldhu	r2,0(r2)
8110b2ec:	10800044 	addi	r2,r2,1
8110b2f0:	100b883a 	mov	r5,r2
8110b2f4:	00a04574 	movhi	r2,33045
8110b2f8:	10ba7a04 	addi	r2,r2,-5656
8110b2fc:	19002324 	muli	r4,r3,140
8110b300:	1105883a 	add	r2,r2,r4
8110b304:	10802184 	addi	r2,r2,134
8110b308:	1140000d 	sth	r5,0(r2)
8110b30c:	00a04574 	movhi	r2,33045
8110b310:	10ba7a04 	addi	r2,r2,-5656
8110b314:	18c02324 	muli	r3,r3,140
8110b318:	10c5883a 	add	r2,r2,r3
8110b31c:	10802184 	addi	r2,r2,134
8110b320:	1080000b 	ldhu	r2,0(r2)
8110b324:	10bfffcc 	andi	r2,r2,65535
8110b328:	10a0001c 	xori	r2,r2,32768
8110b32c:	10a00004 	addi	r2,r2,-32768
8110b330:	10800190 	cmplti	r2,r2,6
8110b334:	1000071e 	bne	r2,zero,8110b354 <vCheckRetransmission128+0x118>
                    xBuffer128[ucIL].bSent = FALSE;
8110b338:	e0ffff03 	ldbu	r3,-4(fp)
8110b33c:	00a04574 	movhi	r2,33045
8110b340:	10ba7a04 	addi	r2,r2,-5656
8110b344:	18c02324 	muli	r3,r3,140
8110b348:	10c5883a 	add	r2,r2,r3
8110b34c:	10802004 	addi	r2,r2,128
8110b350:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
8110b354:	e0ffff03 	ldbu	r3,-4(fp)
8110b358:	00a04574 	movhi	r2,33045
8110b35c:	10ba7a04 	addi	r2,r2,-5656
8110b360:	18c02324 	muli	r3,r3,140
8110b364:	10c5883a 	add	r2,r2,r3
8110b368:	10802004 	addi	r2,r2,128
8110b36c:	10800017 	ldw	r2,0(r2)
8110b370:	1000511e 	bne	r2,zero,8110b4b8 <vCheckRetransmission128+0x27c>
                puts(xBuffer128[ucIL].buffer);
8110b374:	e0bfff03 	ldbu	r2,-4(fp)
8110b378:	10c02324 	muli	r3,r2,140
8110b37c:	00a04574 	movhi	r2,33045
8110b380:	10ba7a04 	addi	r2,r2,-5656
8110b384:	1885883a 	add	r2,r3,r2
8110b388:	1009883a 	mov	r4,r2
8110b38c:	1113b040 	call	81113b04 <puts>
                xBuffer128[ucIL].bSent = TRUE;
8110b390:	e0ffff03 	ldbu	r3,-4(fp)
8110b394:	00a04574 	movhi	r2,33045
8110b398:	10ba7a04 	addi	r2,r2,-5656
8110b39c:	18c02324 	muli	r3,r3,140
8110b3a0:	10c5883a 	add	r2,r2,r3
8110b3a4:	10802004 	addi	r2,r2,128
8110b3a8:	00c00044 	movi	r3,1
8110b3ac:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
8110b3b0:	e0ffff03 	ldbu	r3,-4(fp)
8110b3b4:	00a04574 	movhi	r2,33045
8110b3b8:	10ba7a04 	addi	r2,r2,-5656
8110b3bc:	18c02324 	muli	r3,r3,140
8110b3c0:	10c5883a 	add	r2,r2,r3
8110b3c4:	10802184 	addi	r2,r2,134
8110b3c8:	1000000d 	sth	zero,0(r2)

                ucMax = ( xBuffer128[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
8110b3cc:	e0ffff03 	ldbu	r3,-4(fp)
8110b3d0:	00a04574 	movhi	r2,33045
8110b3d4:	10ba7a04 	addi	r2,r2,-5656
8110b3d8:	18c02324 	muli	r3,r3,140
8110b3dc:	10c5883a 	add	r2,r2,r3
8110b3e0:	10802104 	addi	r2,r2,132
8110b3e4:	1080000b 	ldhu	r2,0(r2)
8110b3e8:	10bfffcc 	andi	r2,r2,65535
8110b3ec:	10800058 	cmpnei	r2,r2,1
8110b3f0:	1000021e 	bne	r2,zero,8110b3fc <vCheckRetransmission128+0x1c0>
8110b3f4:	00bffe84 	movi	r2,-6
8110b3f8:	00000106 	br	8110b400 <vCheckRetransmission128+0x1c4>
8110b3fc:	00800084 	movi	r2,2
8110b400:	e0bfff45 	stb	r2,-3(fp)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > ucMax ) {
8110b404:	e0ffff03 	ldbu	r3,-4(fp)
8110b408:	00a04574 	movhi	r2,33045
8110b40c:	10ba7a04 	addi	r2,r2,-5656
8110b410:	19002324 	muli	r4,r3,140
8110b414:	1105883a 	add	r2,r2,r4
8110b418:	10802204 	addi	r2,r2,136
8110b41c:	10800003 	ldbu	r2,0(r2)
8110b420:	10800044 	addi	r2,r2,1
8110b424:	100b883a 	mov	r5,r2
8110b428:	00a04574 	movhi	r2,33045
8110b42c:	10ba7a04 	addi	r2,r2,-5656
8110b430:	19002324 	muli	r4,r3,140
8110b434:	1105883a 	add	r2,r2,r4
8110b438:	10802204 	addi	r2,r2,136
8110b43c:	11400005 	stb	r5,0(r2)
8110b440:	00a04574 	movhi	r2,33045
8110b444:	10ba7a04 	addi	r2,r2,-5656
8110b448:	18c02324 	muli	r3,r3,140
8110b44c:	10c5883a 	add	r2,r2,r3
8110b450:	10802204 	addi	r2,r2,136
8110b454:	10800003 	ldbu	r2,0(r2)
8110b458:	10803fcc 	andi	r2,r2,255
8110b45c:	e0ffff43 	ldbu	r3,-3(fp)
8110b460:	1880152e 	bgeu	r3,r2,8110b4b8 <vCheckRetransmission128+0x27c>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
8110b464:	e0ffff03 	ldbu	r3,-4(fp)
8110b468:	00a04574 	movhi	r2,33045
8110b46c:	10ba6c04 	addi	r2,r2,-5712
8110b470:	18c7883a 	add	r3,r3,r3
8110b474:	18c7883a 	add	r3,r3,r3
8110b478:	10c5883a 	add	r2,r2,r3
8110b47c:	10000015 	stw	zero,0(r2)
                    SemCount128++;
8110b480:	d0a05d43 	ldbu	r2,-32395(gp)
8110b484:	10800044 	addi	r2,r2,1
8110b488:	d0a05d45 	stb	r2,-32395(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
8110b48c:	d0a04f17 	ldw	r2,-32452(gp)
8110b490:	1009883a 	mov	r4,r2
8110b494:	112fdf00 	call	8112fdf0 <OSSemPost>
8110b498:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8110b49c:	e0bfff83 	ldbu	r2,-2(fp)
8110b4a0:	10803fcc 	andi	r2,r2,255
8110b4a4:	10000426 	beq	r2,zero,8110b4b8 <vCheckRetransmission128+0x27c>
                        SemCount128--;
8110b4a8:	d0a05d43 	ldbu	r2,-32395(gp)
8110b4ac:	10bfffc4 	addi	r2,r2,-1
8110b4b0:	d0a05d45 	stb	r2,-32395(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8110b4b4:	110f1880 	call	8110f188 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110b4b8:	e0bfff03 	ldbu	r2,-4(fp)
8110b4bc:	10800044 	addi	r2,r2,1
8110b4c0:	e0bfff05 	stb	r2,-4(fp)
8110b4c4:	e0bfff03 	ldbu	r2,-4(fp)
8110b4c8:	108000b0 	cmpltui	r2,r2,2
8110b4cc:	103f6e1e 	bne	r2,zero,8110b288 <__reset+0xfb0eb288>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
8110b4d0:	d0a05817 	ldw	r2,-32416(gp)
8110b4d4:	1009883a 	mov	r4,r2
8110b4d8:	112e0000 	call	8112e000 <OSMutexPost>

    return;
8110b4dc:	0001883a 	nop
8110b4e0:	00000106 	br	8110b4e8 <vCheckRetransmission128+0x2ac>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8110b4e4:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
8110b4e8:	e037883a 	mov	sp,fp
8110b4ec:	dfc00117 	ldw	ra,4(sp)
8110b4f0:	df000017 	ldw	fp,0(sp)
8110b4f4:	dec00204 	addi	sp,sp,8
8110b4f8:	f800283a 	ret

8110b4fc <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
8110b4fc:	defffd04 	addi	sp,sp,-12
8110b500:	de00012e 	bgeu	sp,et,8110b508 <vCheckRetransmission64+0xc>
8110b504:	003b68fa 	trap	3
8110b508:	dfc00215 	stw	ra,8(sp)
8110b50c:	df000115 	stw	fp,4(sp)
8110b510:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8110b514:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
8110b518:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8110b51c:	d0a05a17 	ldw	r2,-32408(gp)
8110b520:	e0ffff44 	addi	r3,fp,-3
8110b524:	180b883a 	mov	r5,r3
8110b528:	1009883a 	mov	r4,r2
8110b52c:	112d3dc0 	call	8112d3dc <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8110b530:	e0bfff43 	ldbu	r2,-3(fp)
8110b534:	10803fcc 	andi	r2,r2,255
8110b538:	10008d1e 	bne	r2,zero,8110b770 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++)
8110b53c:	e03fff05 	stb	zero,-4(fp)
8110b540:	00008306 	br	8110b750 <vCheckRetransmission64+0x254>
	{
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
8110b544:	e0ffff03 	ldbu	r3,-4(fp)
8110b548:	00a04574 	movhi	r2,33045
8110b54c:	10ba6c04 	addi	r2,r2,-5712
8110b550:	18c00084 	addi	r3,r3,2
8110b554:	18c7883a 	add	r3,r3,r3
8110b558:	18c7883a 	add	r3,r3,r3
8110b55c:	10c5883a 	add	r2,r2,r3
8110b560:	10800017 	ldw	r2,0(r2)
8110b564:	10800058 	cmpnei	r2,r2,1
8110b568:	1000761e 	bne	r2,zero,8110b744 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
8110b56c:	e0ffff03 	ldbu	r3,-4(fp)
8110b570:	00a04534 	movhi	r2,33044
8110b574:	1090b104 	addi	r2,r2,17092
8110b578:	18c01324 	muli	r3,r3,76
8110b57c:	10c5883a 	add	r2,r2,r3
8110b580:	10801004 	addi	r2,r2,64
8110b584:	10800017 	ldw	r2,0(r2)
8110b588:	10800058 	cmpnei	r2,r2,1
8110b58c:	1000211e 	bne	r2,zero,8110b614 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
8110b590:	e0ffff03 	ldbu	r3,-4(fp)
8110b594:	00a04534 	movhi	r2,33044
8110b598:	1090b104 	addi	r2,r2,17092
8110b59c:	19001324 	muli	r4,r3,76
8110b5a0:	1105883a 	add	r2,r2,r4
8110b5a4:	10801184 	addi	r2,r2,70
8110b5a8:	1080000b 	ldhu	r2,0(r2)
8110b5ac:	10800044 	addi	r2,r2,1
8110b5b0:	100b883a 	mov	r5,r2
8110b5b4:	00a04534 	movhi	r2,33044
8110b5b8:	1090b104 	addi	r2,r2,17092
8110b5bc:	19001324 	muli	r4,r3,76
8110b5c0:	1105883a 	add	r2,r2,r4
8110b5c4:	10801184 	addi	r2,r2,70
8110b5c8:	1140000d 	sth	r5,0(r2)
8110b5cc:	00a04534 	movhi	r2,33044
8110b5d0:	1090b104 	addi	r2,r2,17092
8110b5d4:	18c01324 	muli	r3,r3,76
8110b5d8:	10c5883a 	add	r2,r2,r3
8110b5dc:	10801184 	addi	r2,r2,70
8110b5e0:	1080000b 	ldhu	r2,0(r2)
8110b5e4:	10bfffcc 	andi	r2,r2,65535
8110b5e8:	10a0001c 	xori	r2,r2,32768
8110b5ec:	10a00004 	addi	r2,r2,-32768
8110b5f0:	10800190 	cmplti	r2,r2,6
8110b5f4:	1000071e 	bne	r2,zero,8110b614 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
8110b5f8:	e0ffff03 	ldbu	r3,-4(fp)
8110b5fc:	00a04534 	movhi	r2,33044
8110b600:	1090b104 	addi	r2,r2,17092
8110b604:	18c01324 	muli	r3,r3,76
8110b608:	10c5883a 	add	r2,r2,r3
8110b60c:	10801004 	addi	r2,r2,64
8110b610:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
8110b614:	e0ffff03 	ldbu	r3,-4(fp)
8110b618:	00a04534 	movhi	r2,33044
8110b61c:	1090b104 	addi	r2,r2,17092
8110b620:	18c01324 	muli	r3,r3,76
8110b624:	10c5883a 	add	r2,r2,r3
8110b628:	10801004 	addi	r2,r2,64
8110b62c:	10800017 	ldw	r2,0(r2)
8110b630:	1000441e 	bne	r2,zero,8110b744 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
8110b634:	e0bfff03 	ldbu	r2,-4(fp)
8110b638:	10c01324 	muli	r3,r2,76
8110b63c:	00a04534 	movhi	r2,33044
8110b640:	1090b104 	addi	r2,r2,17092
8110b644:	1885883a 	add	r2,r3,r2
8110b648:	1009883a 	mov	r4,r2
8110b64c:	1113b040 	call	81113b04 <puts>
                xBuffer64[ucIL].bSent = TRUE;
8110b650:	e0ffff03 	ldbu	r3,-4(fp)
8110b654:	00a04534 	movhi	r2,33044
8110b658:	1090b104 	addi	r2,r2,17092
8110b65c:	18c01324 	muli	r3,r3,76
8110b660:	10c5883a 	add	r2,r2,r3
8110b664:	10801004 	addi	r2,r2,64
8110b668:	00c00044 	movi	r3,1
8110b66c:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
8110b670:	e0ffff03 	ldbu	r3,-4(fp)
8110b674:	00a04534 	movhi	r2,33044
8110b678:	1090b104 	addi	r2,r2,17092
8110b67c:	18c01324 	muli	r3,r3,76
8110b680:	10c5883a 	add	r2,r2,r3
8110b684:	10801184 	addi	r2,r2,70
8110b688:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8110b68c:	e0ffff03 	ldbu	r3,-4(fp)
8110b690:	00a04534 	movhi	r2,33044
8110b694:	1090b104 	addi	r2,r2,17092
8110b698:	19001324 	muli	r4,r3,76
8110b69c:	1105883a 	add	r2,r2,r4
8110b6a0:	10801204 	addi	r2,r2,72
8110b6a4:	10800003 	ldbu	r2,0(r2)
8110b6a8:	10800044 	addi	r2,r2,1
8110b6ac:	100b883a 	mov	r5,r2
8110b6b0:	00a04534 	movhi	r2,33044
8110b6b4:	1090b104 	addi	r2,r2,17092
8110b6b8:	19001324 	muli	r4,r3,76
8110b6bc:	1105883a 	add	r2,r2,r4
8110b6c0:	10801204 	addi	r2,r2,72
8110b6c4:	11400005 	stb	r5,0(r2)
8110b6c8:	00a04534 	movhi	r2,33044
8110b6cc:	1090b104 	addi	r2,r2,17092
8110b6d0:	18c01324 	muli	r3,r3,76
8110b6d4:	10c5883a 	add	r2,r2,r3
8110b6d8:	10801204 	addi	r2,r2,72
8110b6dc:	10800003 	ldbu	r2,0(r2)
8110b6e0:	10803fcc 	andi	r2,r2,255
8110b6e4:	108000f0 	cmpltui	r2,r2,3
8110b6e8:	1000161e 	bne	r2,zero,8110b744 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
8110b6ec:	e0ffff03 	ldbu	r3,-4(fp)
8110b6f0:	00a04574 	movhi	r2,33045
8110b6f4:	10ba6c04 	addi	r2,r2,-5712
8110b6f8:	18c00084 	addi	r3,r3,2
8110b6fc:	18c7883a 	add	r3,r3,r3
8110b700:	18c7883a 	add	r3,r3,r3
8110b704:	10c5883a 	add	r2,r2,r3
8110b708:	10000015 	stw	zero,0(r2)
                    SemCount64++;
8110b70c:	d0a05d03 	ldbu	r2,-32396(gp)
8110b710:	10800044 	addi	r2,r2,1
8110b714:	d0a05d05 	stb	r2,-32396(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
8110b718:	d0a04b17 	ldw	r2,-32468(gp)
8110b71c:	1009883a 	mov	r4,r2
8110b720:	112fdf00 	call	8112fdf0 <OSSemPost>
8110b724:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8110b728:	e0bfff43 	ldbu	r2,-3(fp)
8110b72c:	10803fcc 	andi	r2,r2,255
8110b730:	10000426 	beq	r2,zero,8110b744 <vCheckRetransmission64+0x248>
                        SemCount64--;
8110b734:	d0a05d03 	ldbu	r2,-32396(gp)
8110b738:	10bfffc4 	addi	r2,r2,-1
8110b73c:	d0a05d05 	stb	r2,-32396(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8110b740:	110f1200 	call	8110f120 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++)
8110b744:	e0bfff03 	ldbu	r2,-4(fp)
8110b748:	10800044 	addi	r2,r2,1
8110b74c:	e0bfff05 	stb	r2,-4(fp)
8110b750:	e0bfff03 	ldbu	r2,-4(fp)
8110b754:	10800130 	cmpltui	r2,r2,4
8110b758:	103f7a1e 	bne	r2,zero,8110b544 <__reset+0xfb0eb544>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
8110b75c:	d0a05a17 	ldw	r2,-32408(gp)
8110b760:	1009883a 	mov	r4,r2
8110b764:	112e0000 	call	8112e000 <OSMutexPost>

    return;
8110b768:	0001883a 	nop
8110b76c:	00000106 	br	8110b774 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8110b770:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
8110b774:	e037883a 	mov	sp,fp
8110b778:	dfc00117 	ldw	ra,4(sp)
8110b77c:	df000017 	ldw	fp,0(sp)
8110b780:	dec00204 	addi	sp,sp,8
8110b784:	f800283a 	ret

8110b788 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
8110b788:	defffd04 	addi	sp,sp,-12
8110b78c:	de00012e 	bgeu	sp,et,8110b794 <vCheckRetransmission32+0xc>
8110b790:	003b68fa 	trap	3
8110b794:	dfc00215 	stw	ra,8(sp)
8110b798:	df000115 	stw	fp,4(sp)
8110b79c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8110b7a0:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
8110b7a4:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8110b7a8:	d0a05617 	ldw	r2,-32424(gp)
8110b7ac:	e0ffff44 	addi	r3,fp,-3
8110b7b0:	180b883a 	mov	r5,r3
8110b7b4:	1009883a 	mov	r4,r2
8110b7b8:	112d3dc0 	call	8112d3dc <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8110b7bc:	e0bfff43 	ldbu	r2,-3(fp)
8110b7c0:	10803fcc 	andi	r2,r2,255
8110b7c4:	10008d1e 	bne	r2,zero,8110b9fc <vCheckRetransmission32+0x274>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++)
8110b7c8:	e03fff05 	stb	zero,-4(fp)
8110b7cc:	00008306 	br	8110b9dc <vCheckRetransmission32+0x254>
	{
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
8110b7d0:	e0ffff03 	ldbu	r3,-4(fp)
8110b7d4:	00a04574 	movhi	r2,33045
8110b7d8:	10ba6c04 	addi	r2,r2,-5712
8110b7dc:	18c00184 	addi	r3,r3,6
8110b7e0:	18c7883a 	add	r3,r3,r3
8110b7e4:	18c7883a 	add	r3,r3,r3
8110b7e8:	10c5883a 	add	r2,r2,r3
8110b7ec:	10800017 	ldw	r2,0(r2)
8110b7f0:	10800058 	cmpnei	r2,r2,1
8110b7f4:	1000761e 	bne	r2,zero,8110b9d0 <vCheckRetransmission32+0x248>

            if ( xBuffer32[ucIL].bSent == TRUE )
8110b7f8:	e0ffff03 	ldbu	r3,-4(fp)
8110b7fc:	00a04574 	movhi	r2,33045
8110b800:	10a21404 	addi	r2,r2,-30640
8110b804:	18c00b24 	muli	r3,r3,44
8110b808:	10c5883a 	add	r2,r2,r3
8110b80c:	10800804 	addi	r2,r2,32
8110b810:	10800017 	ldw	r2,0(r2)
8110b814:	10800058 	cmpnei	r2,r2,1
8110b818:	1000211e 	bne	r2,zero,8110b8a0 <vCheckRetransmission32+0x118>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
8110b81c:	e0ffff03 	ldbu	r3,-4(fp)
8110b820:	00a04574 	movhi	r2,33045
8110b824:	10a21404 	addi	r2,r2,-30640
8110b828:	19000b24 	muli	r4,r3,44
8110b82c:	1105883a 	add	r2,r2,r4
8110b830:	10800984 	addi	r2,r2,38
8110b834:	1080000b 	ldhu	r2,0(r2)
8110b838:	10800044 	addi	r2,r2,1
8110b83c:	100b883a 	mov	r5,r2
8110b840:	00a04574 	movhi	r2,33045
8110b844:	10a21404 	addi	r2,r2,-30640
8110b848:	19000b24 	muli	r4,r3,44
8110b84c:	1105883a 	add	r2,r2,r4
8110b850:	10800984 	addi	r2,r2,38
8110b854:	1140000d 	sth	r5,0(r2)
8110b858:	00a04574 	movhi	r2,33045
8110b85c:	10a21404 	addi	r2,r2,-30640
8110b860:	18c00b24 	muli	r3,r3,44
8110b864:	10c5883a 	add	r2,r2,r3
8110b868:	10800984 	addi	r2,r2,38
8110b86c:	1080000b 	ldhu	r2,0(r2)
8110b870:	10bfffcc 	andi	r2,r2,65535
8110b874:	10a0001c 	xori	r2,r2,32768
8110b878:	10a00004 	addi	r2,r2,-32768
8110b87c:	10800190 	cmplti	r2,r2,6
8110b880:	1000071e 	bne	r2,zero,8110b8a0 <vCheckRetransmission32+0x118>
                    xBuffer32[ucIL].bSent = FALSE;
8110b884:	e0ffff03 	ldbu	r3,-4(fp)
8110b888:	00a04574 	movhi	r2,33045
8110b88c:	10a21404 	addi	r2,r2,-30640
8110b890:	18c00b24 	muli	r3,r3,44
8110b894:	10c5883a 	add	r2,r2,r3
8110b898:	10800804 	addi	r2,r2,32
8110b89c:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
8110b8a0:	e0ffff03 	ldbu	r3,-4(fp)
8110b8a4:	00a04574 	movhi	r2,33045
8110b8a8:	10a21404 	addi	r2,r2,-30640
8110b8ac:	18c00b24 	muli	r3,r3,44
8110b8b0:	10c5883a 	add	r2,r2,r3
8110b8b4:	10800804 	addi	r2,r2,32
8110b8b8:	10800017 	ldw	r2,0(r2)
8110b8bc:	1000441e 	bne	r2,zero,8110b9d0 <vCheckRetransmission32+0x248>
                puts(xBuffer32[ucIL].buffer);
8110b8c0:	e0bfff03 	ldbu	r2,-4(fp)
8110b8c4:	10c00b24 	muli	r3,r2,44
8110b8c8:	00a04574 	movhi	r2,33045
8110b8cc:	10a21404 	addi	r2,r2,-30640
8110b8d0:	1885883a 	add	r2,r3,r2
8110b8d4:	1009883a 	mov	r4,r2
8110b8d8:	1113b040 	call	81113b04 <puts>
                xBuffer32[ucIL].bSent = TRUE;
8110b8dc:	e0ffff03 	ldbu	r3,-4(fp)
8110b8e0:	00a04574 	movhi	r2,33045
8110b8e4:	10a21404 	addi	r2,r2,-30640
8110b8e8:	18c00b24 	muli	r3,r3,44
8110b8ec:	10c5883a 	add	r2,r2,r3
8110b8f0:	10800804 	addi	r2,r2,32
8110b8f4:	00c00044 	movi	r3,1
8110b8f8:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
8110b8fc:	e0ffff03 	ldbu	r3,-4(fp)
8110b900:	00a04574 	movhi	r2,33045
8110b904:	10a21404 	addi	r2,r2,-30640
8110b908:	18c00b24 	muli	r3,r3,44
8110b90c:	10c5883a 	add	r2,r2,r3
8110b910:	10800984 	addi	r2,r2,38
8110b914:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer32[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8110b918:	e0ffff03 	ldbu	r3,-4(fp)
8110b91c:	00a04574 	movhi	r2,33045
8110b920:	10a21404 	addi	r2,r2,-30640
8110b924:	19000b24 	muli	r4,r3,44
8110b928:	1105883a 	add	r2,r2,r4
8110b92c:	10800a04 	addi	r2,r2,40
8110b930:	10800003 	ldbu	r2,0(r2)
8110b934:	10800044 	addi	r2,r2,1
8110b938:	100b883a 	mov	r5,r2
8110b93c:	00a04574 	movhi	r2,33045
8110b940:	10a21404 	addi	r2,r2,-30640
8110b944:	19000b24 	muli	r4,r3,44
8110b948:	1105883a 	add	r2,r2,r4
8110b94c:	10800a04 	addi	r2,r2,40
8110b950:	11400005 	stb	r5,0(r2)
8110b954:	00a04574 	movhi	r2,33045
8110b958:	10a21404 	addi	r2,r2,-30640
8110b95c:	18c00b24 	muli	r3,r3,44
8110b960:	10c5883a 	add	r2,r2,r3
8110b964:	10800a04 	addi	r2,r2,40
8110b968:	10800003 	ldbu	r2,0(r2)
8110b96c:	10803fcc 	andi	r2,r2,255
8110b970:	108000f0 	cmpltui	r2,r2,3
8110b974:	1000161e 	bne	r2,zero,8110b9d0 <vCheckRetransmission32+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
8110b978:	e0ffff03 	ldbu	r3,-4(fp)
8110b97c:	00a04574 	movhi	r2,33045
8110b980:	10ba6c04 	addi	r2,r2,-5712
8110b984:	18c00184 	addi	r3,r3,6
8110b988:	18c7883a 	add	r3,r3,r3
8110b98c:	18c7883a 	add	r3,r3,r3
8110b990:	10c5883a 	add	r2,r2,r3
8110b994:	10000015 	stw	zero,0(r2)
                    SemCount32++;
8110b998:	d0a05483 	ldbu	r2,-32430(gp)
8110b99c:	10800044 	addi	r2,r2,1
8110b9a0:	d0a05485 	stb	r2,-32430(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
8110b9a4:	d0a05917 	ldw	r2,-32412(gp)
8110b9a8:	1009883a 	mov	r4,r2
8110b9ac:	112fdf00 	call	8112fdf0 <OSSemPost>
8110b9b0:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8110b9b4:	e0bfff43 	ldbu	r2,-3(fp)
8110b9b8:	10803fcc 	andi	r2,r2,255
8110b9bc:	10000426 	beq	r2,zero,8110b9d0 <vCheckRetransmission32+0x248>
                        SemCount32--;
8110b9c0:	d0a05483 	ldbu	r2,-32430(gp)
8110b9c4:	10bfffc4 	addi	r2,r2,-1
8110b9c8:	d0a05485 	stb	r2,-32430(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8110b9cc:	110f0b80 	call	8110f0b8 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++)
8110b9d0:	e0bfff03 	ldbu	r2,-4(fp)
8110b9d4:	10800044 	addi	r2,r2,1
8110b9d8:	e0bfff05 	stb	r2,-4(fp)
8110b9dc:	e0bfff03 	ldbu	r2,-4(fp)
8110b9e0:	10800230 	cmpltui	r2,r2,8
8110b9e4:	103f7a1e 	bne	r2,zero,8110b7d0 <__reset+0xfb0eb7d0>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
8110b9e8:	d0a05617 	ldw	r2,-32424(gp)
8110b9ec:	1009883a 	mov	r4,r2
8110b9f0:	112e0000 	call	8112e000 <OSMutexPost>

    return;
8110b9f4:	0001883a 	nop
8110b9f8:	00000106 	br	8110ba00 <vCheckRetransmission32+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8110b9fc:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
8110ba00:	e037883a 	mov	sp,fp
8110ba04:	dfc00117 	ldw	ra,4(sp)
8110ba08:	df000017 	ldw	fp,0(sp)
8110ba0c:	dec00204 	addi	sp,sp,8
8110ba10:	f800283a 	ret

8110ba14 <vTimeoutCheckerTask>:




/* Could impact in the overall performance of the system due to need many shared resources (many mutexes) */
void vTimeoutCheckerTask(void *task_data) {
8110ba14:	defff504 	addi	sp,sp,-44
8110ba18:	de00012e 	bgeu	sp,et,8110ba20 <vTimeoutCheckerTask+0xc>
8110ba1c:	003b68fa 	trap	3
8110ba20:	dfc00a15 	stw	ra,40(sp)
8110ba24:	df000915 	stw	fp,36(sp)
8110ba28:	df000904 	addi	fp,sp,36
8110ba2c:	e13fff15 	stw	r4,-4(fp)
    bool bFinished32 = FALSE;
8110ba30:	e03ff715 	stw	zero,-36(fp)
    bool bFinished64 = FALSE;
8110ba34:	e03ff815 	stw	zero,-32(fp)
    bool bFinished128 = FALSE;
8110ba38:	e03ff915 	stw	zero,-28(fp)
	INT8U error_code;
    unsigned char ucCountRetries = 0;
8110ba3c:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0, k =0;
8110ba40:	e03ffa45 	stb	zero,-23(fp)
8110ba44:	e03ffa85 	stb	zero,-22(fp)
	unsigned char ucRetransB32[N_32];
	unsigned char ucRetransB64[N_64];
	unsigned char ucRetransB128[N_128];

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
8110ba48:	d0a04e17 	ldw	r2,-32456(gp)
8110ba4c:	100f883a 	mov	r7,r2
8110ba50:	01800844 	movi	r6,33
8110ba54:	01400044 	movi	r5,1
8110ba58:	01204534 	movhi	r4,33044
8110ba5c:	21372004 	addi	r4,r4,-9088
8110ba60:	1112ccc0 	call	81112ccc <fwrite>
    #endif

    for (;;) {
        /* This semaphore is used to sync the Timer used for check timeout and this task that is for actualy implement the logic of the timeout for the communication*/
        OSSemPend(xSemTimeoutChecker, 0, &error_code);
8110ba64:	d0a05317 	ldw	r2,-32436(gp)
8110ba68:	e0fffac4 	addi	r3,fp,-21
8110ba6c:	180d883a 	mov	r6,r3
8110ba70:	000b883a 	mov	r5,zero
8110ba74:	1009883a 	mov	r4,r2
8110ba78:	112fa680 	call	8112fa68 <OSSemPend>
        if ( error_code == OS_NO_ERR ) {
8110ba7c:	e0bffac3 	ldbu	r2,-21(fp)
8110ba80:	10803fcc 	andi	r2,r2,255
8110ba84:	1002191e 	bne	r2,zero,8110c2ec <vTimeoutCheckerTask+0x8d8>
            /*  Time to check all the (re)transmission buffers in order to retransmit if any message got timeout*/

            /*  Writing 0xFF in the buffer to check after if there is any scheduled retransmission
                If there is some, the valur will be between 0 and <max buffer size>*/
            memset(ucRetransB32, 255, N_32);
8110ba88:	e0bffb04 	addi	r2,fp,-20
8110ba8c:	01800204 	movi	r6,8
8110ba90:	01403fc4 	movi	r5,255
8110ba94:	1009883a 	mov	r4,r2
8110ba98:	11138300 	call	81113830 <memset>
            memset(ucRetransB64, 255, N_64);
8110ba9c:	e0bffd04 	addi	r2,fp,-12
8110baa0:	01800104 	movi	r6,4
8110baa4:	01403fc4 	movi	r5,255
8110baa8:	1009883a 	mov	r4,r2
8110baac:	11138300 	call	81113830 <memset>
            memset(ucRetransB128, 255, N_128);
8110bab0:	e0bffe04 	addi	r2,fp,-8
8110bab4:	01800084 	movi	r6,2
8110bab8:	01403fc4 	movi	r5,255
8110babc:	1009883a 	mov	r4,r2
8110bac0:	11138300 	call	81113830 <memset>

            bFinished32=FALSE;
8110bac4:	e03ff715 	stw	zero,-36(fp)
            bFinished64=FALSE;
8110bac8:	e03ff815 	stw	zero,-32(fp)
            bFinished128=FALSE;
8110bacc:	e03ff915 	stw	zero,-28(fp)
            ucCountRetries = 0;
8110bad0:	e03ffa05 	stb	zero,-24(fp)

            /* The mutex will not be blocking, so it will try for five times search in the three (re)transmission buffer */
            while ( ( ucCountRetries < 6 ) && ( (bFinished32==FALSE) || (bFinished64==FALSE) || (bFinished128==FALSE) ) ) {
8110bad4:	00011a06 	br	8110bf40 <vTimeoutCheckerTask+0x52c>

                if ( bFinished32 == FALSE ) {
8110bad8:	e0bff717 	ldw	r2,-36(fp)
8110badc:	10005b1e 	bne	r2,zero,8110bc4c <vTimeoutCheckerTask+0x238>
                    /* Check all positions of the (re)transmission buffer*/
                    OSMutexPend(xMutexBuffer32, 2, &error_code); /* Try to get the mutex (wait 2 ticks) */
8110bae0:	d0a05617 	ldw	r2,-32424(gp)
8110bae4:	e0fffac4 	addi	r3,fp,-21
8110bae8:	180d883a 	mov	r6,r3
8110baec:	01400084 	movi	r5,2
8110baf0:	1009883a 	mov	r4,r2
8110baf4:	112da5c0 	call	8112da5c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110baf8:	e0bffac3 	ldbu	r2,-21(fp)
8110bafc:	10803fcc 	andi	r2,r2,255
8110bb00:	1000521e 	bne	r2,zero,8110bc4c <vTimeoutCheckerTask+0x238>
                        /*Search for the id*/
                        k = 0;
8110bb04:	e03ffa85 	stb	zero,-22(fp)
                        for(i = 0; i < N_32; i++)
8110bb08:	e03ffa45 	stb	zero,-23(fp)
8110bb0c:	00004706 	br	8110bc2c <vTimeoutCheckerTask+0x218>
                        {
                            if ( xBuffer32[i].usiId != 0 ) {
8110bb10:	e0fffa43 	ldbu	r3,-23(fp)
8110bb14:	00a04574 	movhi	r2,33045
8110bb18:	10a21404 	addi	r2,r2,-30640
8110bb1c:	18c00b24 	muli	r3,r3,44
8110bb20:	10c5883a 	add	r2,r2,r3
8110bb24:	10800904 	addi	r2,r2,36
8110bb28:	1080000b 	ldhu	r2,0(r2)
8110bb2c:	10bfffcc 	andi	r2,r2,65535
8110bb30:	10003b26 	beq	r2,zero,8110bc20 <vTimeoutCheckerTask+0x20c>
                                /* If isn't Zero, so there a message in this position of the (re)transmission buffer */

                                if ( xBuffer32[i].ucNofRetries < 1 ) {
8110bb34:	e0fffa43 	ldbu	r3,-23(fp)
8110bb38:	00a04574 	movhi	r2,33045
8110bb3c:	10a21404 	addi	r2,r2,-30640
8110bb40:	18c00b24 	muli	r3,r3,44
8110bb44:	10c5883a 	add	r2,r2,r3
8110bb48:	10800a04 	addi	r2,r2,40
8110bb4c:	10800003 	ldbu	r2,0(r2)
8110bb50:	10803fcc 	andi	r2,r2,255
8110bb54:	1000101e 	bne	r2,zero,8110bb98 <vTimeoutCheckerTask+0x184>
                                    /* Reach the max number of retransmission. Clear the position. */
                                    xBuffer32[i].usiId = 0;
8110bb58:	e0fffa43 	ldbu	r3,-23(fp)
8110bb5c:	00a04574 	movhi	r2,33045
8110bb60:	10a21404 	addi	r2,r2,-30640
8110bb64:	18c00b24 	muli	r3,r3,44
8110bb68:	10c5883a 	add	r2,r2,r3
8110bb6c:	10800904 	addi	r2,r2,36
8110bb70:	1000000d 	sth	zero,0(r2)
                                    error_code = OSSemPost(xSemCountBuffer32);
8110bb74:	d0a05917 	ldw	r2,-32412(gp)
8110bb78:	1009883a 	mov	r4,r2
8110bb7c:	112fdf00 	call	8112fdf0 <OSSemPost>
8110bb80:	e0bffac5 	stb	r2,-21(fp)
                                    if ( error_code != OS_ERR_NONE ) {
8110bb84:	e0bffac3 	ldbu	r2,-21(fp)
8110bb88:	10803fcc 	andi	r2,r2,255
8110bb8c:	10002426 	beq	r2,zero,8110bc20 <vTimeoutCheckerTask+0x20c>
                                        vFailSetCountSemaphorexBuffer32();
8110bb90:	110f0b80 	call	8110f0b8 <vFailSetCountSemaphorexBuffer32>
8110bb94:	00002206 	br	8110bc20 <vTimeoutCheckerTask+0x20c>
                                    }
                                } else {
                                    /* Check if there's timeout to retransmit */
                                    xBuffer32[i].usiTimeOut--;
8110bb98:	e0fffa43 	ldbu	r3,-23(fp)
8110bb9c:	00a04574 	movhi	r2,33045
8110bba0:	10a21404 	addi	r2,r2,-30640
8110bba4:	19000b24 	muli	r4,r3,44
8110bba8:	1105883a 	add	r2,r2,r4
8110bbac:	10800984 	addi	r2,r2,38
8110bbb0:	1080000b 	ldhu	r2,0(r2)
8110bbb4:	10bfffc4 	addi	r2,r2,-1
8110bbb8:	1009883a 	mov	r4,r2
8110bbbc:	00a04574 	movhi	r2,33045
8110bbc0:	10a21404 	addi	r2,r2,-30640
8110bbc4:	18c00b24 	muli	r3,r3,44
8110bbc8:	10c5883a 	add	r2,r2,r3
8110bbcc:	10800984 	addi	r2,r2,38
8110bbd0:	1100000d 	sth	r4,0(r2)
                                    if ( xBuffer32[i].usiTimeOut < 1 ) {
8110bbd4:	e0fffa43 	ldbu	r3,-23(fp)
8110bbd8:	00a04574 	movhi	r2,33045
8110bbdc:	10a21404 	addi	r2,r2,-30640
8110bbe0:	18c00b24 	muli	r3,r3,44
8110bbe4:	10c5883a 	add	r2,r2,r3
8110bbe8:	10800984 	addi	r2,r2,38
8110bbec:	1080000b 	ldhu	r2,0(r2)
8110bbf0:	10bfffcc 	andi	r2,r2,65535
8110bbf4:	10a0001c 	xori	r2,r2,32768
8110bbf8:	10a00004 	addi	r2,r2,-32768
8110bbfc:	00800816 	blt	zero,r2,8110bc20 <vTimeoutCheckerTask+0x20c>
                                        /* Schedule to retransmit */
                                        ucRetransB32[k] = i;
8110bc00:	e0bffa83 	ldbu	r2,-22(fp)
8110bc04:	e0fffb04 	addi	r3,fp,-20
8110bc08:	1885883a 	add	r2,r3,r2
8110bc0c:	e0fffa43 	ldbu	r3,-23(fp)
8110bc10:	10c00005 	stb	r3,0(r2)
                                        k++;
8110bc14:	e0bffa83 	ldbu	r2,-22(fp)
8110bc18:	10800044 	addi	r2,r2,1
8110bc1c:	e0bffa85 	stb	r2,-22(fp)
                    /* Check all positions of the (re)transmission buffer*/
                    OSMutexPend(xMutexBuffer32, 2, &error_code); /* Try to get the mutex (wait 2 ticks) */
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the id*/
                        k = 0;
                        for(i = 0; i < N_32; i++)
8110bc20:	e0bffa43 	ldbu	r2,-23(fp)
8110bc24:	10800044 	addi	r2,r2,1
8110bc28:	e0bffa45 	stb	r2,-23(fp)
8110bc2c:	e0bffa43 	ldbu	r2,-23(fp)
8110bc30:	10800230 	cmpltui	r2,r2,8
8110bc34:	103fb61e 	bne	r2,zero,8110bb10 <__reset+0xfb0ebb10>
                                        k++;
                                    }
                                }
                            }
                        }
                        OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xBuffer32*/
8110bc38:	d0a05617 	ldw	r2,-32424(gp)
8110bc3c:	1009883a 	mov	r4,r2
8110bc40:	112e0000 	call	8112e000 <OSMutexPost>
                        bFinished32 = TRUE;
8110bc44:	00800044 	movi	r2,1
8110bc48:	e0bff715 	stw	r2,-36(fp)
                    }
                }

                if ( bFinished64 == FALSE ) {
8110bc4c:	e0bff817 	ldw	r2,-32(fp)
8110bc50:	10005b1e 	bne	r2,zero,8110bdc0 <vTimeoutCheckerTask+0x3ac>
                    /* Check all positions of the (re)transmission buffer*/
                    OSMutexPend(xMutexBuffer64, 2, &error_code); /* Try to get the mutex (wait 2 ticks) */
8110bc54:	d0a05a17 	ldw	r2,-32408(gp)
8110bc58:	e0fffac4 	addi	r3,fp,-21
8110bc5c:	180d883a 	mov	r6,r3
8110bc60:	01400084 	movi	r5,2
8110bc64:	1009883a 	mov	r4,r2
8110bc68:	112da5c0 	call	8112da5c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110bc6c:	e0bffac3 	ldbu	r2,-21(fp)
8110bc70:	10803fcc 	andi	r2,r2,255
8110bc74:	1000521e 	bne	r2,zero,8110bdc0 <vTimeoutCheckerTask+0x3ac>
                        /*Search for the id*/
                        k = 0;
8110bc78:	e03ffa85 	stb	zero,-22(fp)
                        for(i = 0; i < N_64; i++)
8110bc7c:	e03ffa45 	stb	zero,-23(fp)
8110bc80:	00004706 	br	8110bda0 <vTimeoutCheckerTask+0x38c>
                        {
                            if ( xBuffer64[i].usiId != 0 ) {
8110bc84:	e0fffa43 	ldbu	r3,-23(fp)
8110bc88:	00a04534 	movhi	r2,33044
8110bc8c:	1090b104 	addi	r2,r2,17092
8110bc90:	18c01324 	muli	r3,r3,76
8110bc94:	10c5883a 	add	r2,r2,r3
8110bc98:	10801104 	addi	r2,r2,68
8110bc9c:	1080000b 	ldhu	r2,0(r2)
8110bca0:	10bfffcc 	andi	r2,r2,65535
8110bca4:	10003b26 	beq	r2,zero,8110bd94 <vTimeoutCheckerTask+0x380>
                                /* If isn't Zero, so there a message in this position of the (re)transmission buffer */

                                if ( xBuffer64[i].ucNofRetries < 1 ) {
8110bca8:	e0fffa43 	ldbu	r3,-23(fp)
8110bcac:	00a04534 	movhi	r2,33044
8110bcb0:	1090b104 	addi	r2,r2,17092
8110bcb4:	18c01324 	muli	r3,r3,76
8110bcb8:	10c5883a 	add	r2,r2,r3
8110bcbc:	10801204 	addi	r2,r2,72
8110bcc0:	10800003 	ldbu	r2,0(r2)
8110bcc4:	10803fcc 	andi	r2,r2,255
8110bcc8:	1000101e 	bne	r2,zero,8110bd0c <vTimeoutCheckerTask+0x2f8>
                                    /* Reach the max number of retransmission. Clear the position. */
                                    xBuffer64[i].usiId = 0;
8110bccc:	e0fffa43 	ldbu	r3,-23(fp)
8110bcd0:	00a04534 	movhi	r2,33044
8110bcd4:	1090b104 	addi	r2,r2,17092
8110bcd8:	18c01324 	muli	r3,r3,76
8110bcdc:	10c5883a 	add	r2,r2,r3
8110bce0:	10801104 	addi	r2,r2,68
8110bce4:	1000000d 	sth	zero,0(r2)
                                    error_code = OSSemPost(xSemCountBuffer64);
8110bce8:	d0a04b17 	ldw	r2,-32468(gp)
8110bcec:	1009883a 	mov	r4,r2
8110bcf0:	112fdf00 	call	8112fdf0 <OSSemPost>
8110bcf4:	e0bffac5 	stb	r2,-21(fp)
                                    if ( error_code != OS_ERR_NONE ) {
8110bcf8:	e0bffac3 	ldbu	r2,-21(fp)
8110bcfc:	10803fcc 	andi	r2,r2,255
8110bd00:	10002426 	beq	r2,zero,8110bd94 <vTimeoutCheckerTask+0x380>
                                        vFailSetCountSemaphorexBuffer64();
8110bd04:	110f1200 	call	8110f120 <vFailSetCountSemaphorexBuffer64>
8110bd08:	00002206 	br	8110bd94 <vTimeoutCheckerTask+0x380>
                                    }
                                } else {
                                    /* Check if there's timeout to retransmit */
                                    xBuffer64[i].usiTimeOut--;
8110bd0c:	e0fffa43 	ldbu	r3,-23(fp)
8110bd10:	00a04534 	movhi	r2,33044
8110bd14:	1090b104 	addi	r2,r2,17092
8110bd18:	19001324 	muli	r4,r3,76
8110bd1c:	1105883a 	add	r2,r2,r4
8110bd20:	10801184 	addi	r2,r2,70
8110bd24:	1080000b 	ldhu	r2,0(r2)
8110bd28:	10bfffc4 	addi	r2,r2,-1
8110bd2c:	1009883a 	mov	r4,r2
8110bd30:	00a04534 	movhi	r2,33044
8110bd34:	1090b104 	addi	r2,r2,17092
8110bd38:	18c01324 	muli	r3,r3,76
8110bd3c:	10c5883a 	add	r2,r2,r3
8110bd40:	10801184 	addi	r2,r2,70
8110bd44:	1100000d 	sth	r4,0(r2)
                                    if ( xBuffer64[i].usiTimeOut < 1 ) {
8110bd48:	e0fffa43 	ldbu	r3,-23(fp)
8110bd4c:	00a04534 	movhi	r2,33044
8110bd50:	1090b104 	addi	r2,r2,17092
8110bd54:	18c01324 	muli	r3,r3,76
8110bd58:	10c5883a 	add	r2,r2,r3
8110bd5c:	10801184 	addi	r2,r2,70
8110bd60:	1080000b 	ldhu	r2,0(r2)
8110bd64:	10bfffcc 	andi	r2,r2,65535
8110bd68:	10a0001c 	xori	r2,r2,32768
8110bd6c:	10a00004 	addi	r2,r2,-32768
8110bd70:	00800816 	blt	zero,r2,8110bd94 <vTimeoutCheckerTask+0x380>
                                        /* Schedule to retransmit */
                                        ucRetransB64[k] = i;
8110bd74:	e0bffa83 	ldbu	r2,-22(fp)
8110bd78:	e0fffd04 	addi	r3,fp,-12
8110bd7c:	1885883a 	add	r2,r3,r2
8110bd80:	e0fffa43 	ldbu	r3,-23(fp)
8110bd84:	10c00005 	stb	r3,0(r2)
                                        k++;
8110bd88:	e0bffa83 	ldbu	r2,-22(fp)
8110bd8c:	10800044 	addi	r2,r2,1
8110bd90:	e0bffa85 	stb	r2,-22(fp)
                    /* Check all positions of the (re)transmission buffer*/
                    OSMutexPend(xMutexBuffer64, 2, &error_code); /* Try to get the mutex (wait 2 ticks) */
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the id*/
                        k = 0;
                        for(i = 0; i < N_64; i++)
8110bd94:	e0bffa43 	ldbu	r2,-23(fp)
8110bd98:	10800044 	addi	r2,r2,1
8110bd9c:	e0bffa45 	stb	r2,-23(fp)
8110bda0:	e0bffa43 	ldbu	r2,-23(fp)
8110bda4:	10800130 	cmpltui	r2,r2,4
8110bda8:	103fb61e 	bne	r2,zero,8110bc84 <__reset+0xfb0ebc84>
                                        k++;
                                    }
                                }
                            }
                        }
                        OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer32*/
8110bdac:	d0a05a17 	ldw	r2,-32408(gp)
8110bdb0:	1009883a 	mov	r4,r2
8110bdb4:	112e0000 	call	8112e000 <OSMutexPost>
                        bFinished64 = TRUE;
8110bdb8:	00800044 	movi	r2,1
8110bdbc:	e0bff815 	stw	r2,-32(fp)
                    }
                }

                if ( bFinished128 == FALSE ) {
8110bdc0:	e0bff917 	ldw	r2,-28(fp)
8110bdc4:	10005b1e 	bne	r2,zero,8110bf34 <vTimeoutCheckerTask+0x520>
                    /* Check all positions of the (re)transmission buffer*/
                    OSMutexPend(xMutexBuffer128, 2, &error_code); /* Try to get the mutex (wait 2 ticks) */
8110bdc8:	d0a05817 	ldw	r2,-32416(gp)
8110bdcc:	e0fffac4 	addi	r3,fp,-21
8110bdd0:	180d883a 	mov	r6,r3
8110bdd4:	01400084 	movi	r5,2
8110bdd8:	1009883a 	mov	r4,r2
8110bddc:	112da5c0 	call	8112da5c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110bde0:	e0bffac3 	ldbu	r2,-21(fp)
8110bde4:	10803fcc 	andi	r2,r2,255
8110bde8:	1000521e 	bne	r2,zero,8110bf34 <vTimeoutCheckerTask+0x520>
                        /*Search for the id*/
                        k = 0;
8110bdec:	e03ffa85 	stb	zero,-22(fp)
                        for(i = 0; i < N_128; i++)
8110bdf0:	e03ffa45 	stb	zero,-23(fp)
8110bdf4:	00004706 	br	8110bf14 <vTimeoutCheckerTask+0x500>
                        {
                            if ( xBuffer128[i].usiId != 0 ) {
8110bdf8:	e0fffa43 	ldbu	r3,-23(fp)
8110bdfc:	00a04574 	movhi	r2,33045
8110be00:	10ba7a04 	addi	r2,r2,-5656
8110be04:	18c02324 	muli	r3,r3,140
8110be08:	10c5883a 	add	r2,r2,r3
8110be0c:	10802104 	addi	r2,r2,132
8110be10:	1080000b 	ldhu	r2,0(r2)
8110be14:	10bfffcc 	andi	r2,r2,65535
8110be18:	10003b26 	beq	r2,zero,8110bf08 <vTimeoutCheckerTask+0x4f4>
                                /* If isn't Zero, so there a message in this position of the (re)transmission buffer */

                                if ( xBuffer128[i].ucNofRetries < 1 ) {
8110be1c:	e0fffa43 	ldbu	r3,-23(fp)
8110be20:	00a04574 	movhi	r2,33045
8110be24:	10ba7a04 	addi	r2,r2,-5656
8110be28:	18c02324 	muli	r3,r3,140
8110be2c:	10c5883a 	add	r2,r2,r3
8110be30:	10802204 	addi	r2,r2,136
8110be34:	10800003 	ldbu	r2,0(r2)
8110be38:	10803fcc 	andi	r2,r2,255
8110be3c:	1000101e 	bne	r2,zero,8110be80 <vTimeoutCheckerTask+0x46c>
                                    /* Reach the max number of retransmission. Clear the position. */
                                    xBuffer128[i].usiId = 0;
8110be40:	e0fffa43 	ldbu	r3,-23(fp)
8110be44:	00a04574 	movhi	r2,33045
8110be48:	10ba7a04 	addi	r2,r2,-5656
8110be4c:	18c02324 	muli	r3,r3,140
8110be50:	10c5883a 	add	r2,r2,r3
8110be54:	10802104 	addi	r2,r2,132
8110be58:	1000000d 	sth	zero,0(r2)
                                    error_code = OSSemPost(xSemCountBuffer128);
8110be5c:	d0a04f17 	ldw	r2,-32452(gp)
8110be60:	1009883a 	mov	r4,r2
8110be64:	112fdf00 	call	8112fdf0 <OSSemPost>
8110be68:	e0bffac5 	stb	r2,-21(fp)
                                    if ( error_code != OS_ERR_NONE ) {
8110be6c:	e0bffac3 	ldbu	r2,-21(fp)
8110be70:	10803fcc 	andi	r2,r2,255
8110be74:	10002426 	beq	r2,zero,8110bf08 <vTimeoutCheckerTask+0x4f4>
                                        vFailSetCountSemaphorexBuffer128();
8110be78:	110f1880 	call	8110f188 <vFailSetCountSemaphorexBuffer128>
8110be7c:	00002206 	br	8110bf08 <vTimeoutCheckerTask+0x4f4>
                                    }
                                } else {
                                    /* Check if there's timeout to retransmit */
                                    xBuffer128[i].usiTimeOut--;
8110be80:	e0fffa43 	ldbu	r3,-23(fp)
8110be84:	00a04574 	movhi	r2,33045
8110be88:	10ba7a04 	addi	r2,r2,-5656
8110be8c:	19002324 	muli	r4,r3,140
8110be90:	1105883a 	add	r2,r2,r4
8110be94:	10802184 	addi	r2,r2,134
8110be98:	1080000b 	ldhu	r2,0(r2)
8110be9c:	10bfffc4 	addi	r2,r2,-1
8110bea0:	1009883a 	mov	r4,r2
8110bea4:	00a04574 	movhi	r2,33045
8110bea8:	10ba7a04 	addi	r2,r2,-5656
8110beac:	18c02324 	muli	r3,r3,140
8110beb0:	10c5883a 	add	r2,r2,r3
8110beb4:	10802184 	addi	r2,r2,134
8110beb8:	1100000d 	sth	r4,0(r2)
                                    if ( xBuffer128[i].usiTimeOut < 1 ) {
8110bebc:	e0fffa43 	ldbu	r3,-23(fp)
8110bec0:	00a04574 	movhi	r2,33045
8110bec4:	10ba7a04 	addi	r2,r2,-5656
8110bec8:	18c02324 	muli	r3,r3,140
8110becc:	10c5883a 	add	r2,r2,r3
8110bed0:	10802184 	addi	r2,r2,134
8110bed4:	1080000b 	ldhu	r2,0(r2)
8110bed8:	10bfffcc 	andi	r2,r2,65535
8110bedc:	10a0001c 	xori	r2,r2,32768
8110bee0:	10a00004 	addi	r2,r2,-32768
8110bee4:	00800816 	blt	zero,r2,8110bf08 <vTimeoutCheckerTask+0x4f4>
                                        /* Schedule to retransmit */
                                        ucRetransB128[k] = i;
8110bee8:	e0bffa83 	ldbu	r2,-22(fp)
8110beec:	e0fffe04 	addi	r3,fp,-8
8110bef0:	1885883a 	add	r2,r3,r2
8110bef4:	e0fffa43 	ldbu	r3,-23(fp)
8110bef8:	10c00005 	stb	r3,0(r2)
                                        k++;
8110befc:	e0bffa83 	ldbu	r2,-22(fp)
8110bf00:	10800044 	addi	r2,r2,1
8110bf04:	e0bffa85 	stb	r2,-22(fp)
                    /* Check all positions of the (re)transmission buffer*/
                    OSMutexPend(xMutexBuffer128, 2, &error_code); /* Try to get the mutex (wait 2 ticks) */
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the id*/
                        k = 0;
                        for(i = 0; i < N_128; i++)
8110bf08:	e0bffa43 	ldbu	r2,-23(fp)
8110bf0c:	10800044 	addi	r2,r2,1
8110bf10:	e0bffa45 	stb	r2,-23(fp)
8110bf14:	e0bffa43 	ldbu	r2,-23(fp)
8110bf18:	108000b0 	cmpltui	r2,r2,2
8110bf1c:	103fb61e 	bne	r2,zero,8110bdf8 <__reset+0xfb0ebdf8>
                                        k++;
                                    }
                                }
                            }
                        }
                        OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer32*/
8110bf20:	d0a05817 	ldw	r2,-32416(gp)
8110bf24:	1009883a 	mov	r4,r2
8110bf28:	112e0000 	call	8112e000 <OSMutexPost>
                        bFinished128 = TRUE;
8110bf2c:	00800044 	movi	r2,1
8110bf30:	e0bff915 	stw	r2,-28(fp)
                    }
                }
                ucCountRetries++;
8110bf34:	e0bffa03 	ldbu	r2,-24(fp)
8110bf38:	10800044 	addi	r2,r2,1
8110bf3c:	e0bffa05 	stb	r2,-24(fp)
            bFinished64=FALSE;
            bFinished128=FALSE;
            ucCountRetries = 0;

            /* The mutex will not be blocking, so it will try for five times search in the three (re)transmission buffer */
            while ( ( ucCountRetries < 6 ) && ( (bFinished32==FALSE) || (bFinished64==FALSE) || (bFinished128==FALSE) ) ) {
8110bf40:	e0bffa03 	ldbu	r2,-24(fp)
8110bf44:	108001a8 	cmpgeui	r2,r2,6
8110bf48:	1000061e 	bne	r2,zero,8110bf64 <vTimeoutCheckerTask+0x550>
8110bf4c:	e0bff717 	ldw	r2,-36(fp)
8110bf50:	103ee126 	beq	r2,zero,8110bad8 <__reset+0xfb0ebad8>
8110bf54:	e0bff817 	ldw	r2,-32(fp)
8110bf58:	103edf26 	beq	r2,zero,8110bad8 <__reset+0xfb0ebad8>
8110bf5c:	e0bff917 	ldw	r2,-28(fp)
8110bf60:	103edd26 	beq	r2,zero,8110bad8 <__reset+0xfb0ebad8>
                }
                ucCountRetries++;
            }

            /*  Check if could not check some of the (re)transmission buffer*/
            if ( (bFinished32==FALSE) || (bFinished64==FALSE) || (bFinished128==FALSE) ) {
8110bf64:	e0bff717 	ldw	r2,-36(fp)
8110bf68:	10000426 	beq	r2,zero,8110bf7c <vTimeoutCheckerTask+0x568>
8110bf6c:	e0bff817 	ldw	r2,-32(fp)
8110bf70:	10000226 	beq	r2,zero,8110bf7c <vTimeoutCheckerTask+0x568>
8110bf74:	e0bff917 	ldw	r2,-28(fp)
8110bf78:	1000011e 	bne	r2,zero,8110bf80 <vTimeoutCheckerTask+0x56c>
                /*  Could not check all (re)transmission buffer, only show message for now. There's no hard impact to thesystem
                    but we need to know that is occourring*/
                vCouldNotCheckBufferTimeOutFunction();
8110bf7c:	110f8000 	call	8110f800 <vCouldNotCheckBufferTimeOutFunction>
            /*  Retransmit could slow down the system in the worst case, because need to get more than one mutex at same time
                this also could impact in various task that need the mutex also, as this operation may be rare
                before try to get all mutexes, will check if there is anything in the scheduler buffers (ucRetransB32,ucRetransB64,ucRetransB128). */
                
            /*  Most part of the time this will be false, and many processing and kernell resources will be saved with this verification*/
            if ( (ucRetransB32[0] != 255) || (ucRetransB64[0] != 255) || (ucRetransB128[0] != 255) ) {
8110bf80:	e0bffb03 	ldbu	r2,-20(fp)
8110bf84:	10803fcc 	andi	r2,r2,255
8110bf88:	10803fd8 	cmpnei	r2,r2,255
8110bf8c:	1000081e 	bne	r2,zero,8110bfb0 <vTimeoutCheckerTask+0x59c>
8110bf90:	e0bffd03 	ldbu	r2,-12(fp)
8110bf94:	10803fcc 	andi	r2,r2,255
8110bf98:	10803fd8 	cmpnei	r2,r2,255
8110bf9c:	1000041e 	bne	r2,zero,8110bfb0 <vTimeoutCheckerTask+0x59c>
8110bfa0:	e0bffe03 	ldbu	r2,-8(fp)
8110bfa4:	10803fcc 	andi	r2,r2,255
8110bfa8:	10803fe0 	cmpeqi	r2,r2,255
8110bfac:	103ead1e 	bne	r2,zero,8110ba64 <__reset+0xfb0eba64>
                /*  This operation will try to use the UART TX buffer, so after get the mutex it will remain for almost 3 or 4 ticks in the worst case.
                    In order to avoid that all the system lost the access to the communication for more time, and to minimize the priority inversion
                    if we can't get the mutex for the buffer32, buffer 64 or buffer128, we continue and in the next cycle of checkout it will try to re-send finaly. */                

                /*  Sleep for 50 ticks (50 milli) in the worst case*/
                OSMutexPend(xTxUARTMutex, 50, &error_code); /* Wait 50 ticks = 50 ms */
8110bfb0:	d0a05c17 	ldw	r2,-32400(gp)
8110bfb4:	e0fffac4 	addi	r3,fp,-21
8110bfb8:	180d883a 	mov	r6,r3
8110bfbc:	01400c84 	movi	r5,50
8110bfc0:	1009883a 	mov	r4,r2
8110bfc4:	112da5c0 	call	8112da5c <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
8110bfc8:	e0bffac3 	ldbu	r2,-21(fp)
8110bfcc:	10803fcc 	andi	r2,r2,255
8110bfd0:	1000c41e 	bne	r2,zero,8110c2e4 <vTimeoutCheckerTask+0x8d0>


                    if ( ucRetransB32[0] != 255 ) {
8110bfd4:	e0bffb03 	ldbu	r2,-20(fp)
8110bfd8:	10803fcc 	andi	r2,r2,255
8110bfdc:	10803fe0 	cmpeqi	r2,r2,255
8110bfe0:	10003c1e 	bne	r2,zero,8110c0d4 <vTimeoutCheckerTask+0x6c0>
                        OSMutexPend(xMutexBuffer32, 1, &error_code); /* Try to get the mutex (wait 1 ticks) */
8110bfe4:	d0a05617 	ldw	r2,-32424(gp)
8110bfe8:	e0fffac4 	addi	r3,fp,-21
8110bfec:	180d883a 	mov	r6,r3
8110bff0:	01400044 	movi	r5,1
8110bff4:	1009883a 	mov	r4,r2
8110bff8:	112da5c0 	call	8112da5c <OSMutexPend>
                        if ( error_code == OS_ERR_NONE ) {
8110bffc:	e0bffac3 	ldbu	r2,-21(fp)
8110c000:	10803fcc 	andi	r2,r2,255
8110c004:	1000321e 	bne	r2,zero,8110c0d0 <vTimeoutCheckerTask+0x6bc>
                            k = 0;
8110c008:	e03ffa85 	stb	zero,-22(fp)
                            do
                            {
                                i = ucRetransB32[k];
8110c00c:	e0bffa83 	ldbu	r2,-22(fp)
8110c010:	e0fffb04 	addi	r3,fp,-20
8110c014:	1885883a 	add	r2,r3,r2
8110c018:	10800003 	ldbu	r2,0(r2)
8110c01c:	e0bffa45 	stb	r2,-23(fp)
                                xBuffer32[i].ucNofRetries--;
8110c020:	e0fffa43 	ldbu	r3,-23(fp)
8110c024:	00a04574 	movhi	r2,33045
8110c028:	10a21404 	addi	r2,r2,-30640
8110c02c:	19000b24 	muli	r4,r3,44
8110c030:	1105883a 	add	r2,r2,r4
8110c034:	10800a04 	addi	r2,r2,40
8110c038:	10800003 	ldbu	r2,0(r2)
8110c03c:	10bfffc4 	addi	r2,r2,-1
8110c040:	1009883a 	mov	r4,r2
8110c044:	00a04574 	movhi	r2,33045
8110c048:	10a21404 	addi	r2,r2,-30640
8110c04c:	18c00b24 	muli	r3,r3,44
8110c050:	10c5883a 	add	r2,r2,r3
8110c054:	10800a04 	addi	r2,r2,40
8110c058:	11000005 	stb	r4,0(r2)
                                xBuffer32[i].usiTimeOut = TIMEOUT_COUNT;
8110c05c:	e0fffa43 	ldbu	r3,-23(fp)
8110c060:	00a04574 	movhi	r2,33045
8110c064:	10a21404 	addi	r2,r2,-30640
8110c068:	18c00b24 	muli	r3,r3,44
8110c06c:	10c5883a 	add	r2,r2,r3
8110c070:	10800984 	addi	r2,r2,38
8110c074:	00c00144 	movi	r3,5
8110c078:	10c0000d 	sth	r3,0(r2)
                                puts(xBuffer32[i].buffer);                                
8110c07c:	e0bffa43 	ldbu	r2,-23(fp)
8110c080:	10c00b24 	muli	r3,r2,44
8110c084:	00a04574 	movhi	r2,33045
8110c088:	10a21404 	addi	r2,r2,-30640
8110c08c:	1885883a 	add	r2,r3,r2
8110c090:	1009883a 	mov	r4,r2
8110c094:	1113b040 	call	81113b04 <puts>
                                k++;
8110c098:	e0bffa83 	ldbu	r2,-22(fp)
8110c09c:	10800044 	addi	r2,r2,1
8110c0a0:	e0bffa85 	stb	r2,-22(fp)
                            } while ( ucRetransB32[k] != 255 );                       
8110c0a4:	e0bffa83 	ldbu	r2,-22(fp)
8110c0a8:	e0fffb04 	addi	r3,fp,-20
8110c0ac:	1885883a 	add	r2,r3,r2
8110c0b0:	10800003 	ldbu	r2,0(r2)
8110c0b4:	10803fcc 	andi	r2,r2,255
8110c0b8:	10803fd8 	cmpnei	r2,r2,255
8110c0bc:	103fd31e 	bne	r2,zero,8110c00c <__reset+0xfb0ec00c>

                            OSMutexPost(xMutexBuffer32);
8110c0c0:	d0a05617 	ldw	r2,-32424(gp)
8110c0c4:	1009883a 	mov	r4,r2
8110c0c8:	112e0000 	call	8112e000 <OSMutexPost>
8110c0cc:	00000106 	br	8110c0d4 <vTimeoutCheckerTask+0x6c0>
                        } else {
                            /*  Could not get the mutex for the buffer32. There is no big impact to the system. So next cycle it may be transmited.
                                This is not a reason to exit the execution of all Simucam.*/
                            vCouldNotRetransmitB32TimeoutTask();
8110c0d0:	110f9d00 	call	8110f9d0 <vCouldNotRetransmitB32TimeoutTask>
                        }
                    }

                    if ( ucRetransB64[0] != 255 ) {
8110c0d4:	e0bffd03 	ldbu	r2,-12(fp)
8110c0d8:	10803fcc 	andi	r2,r2,255
8110c0dc:	10803fe0 	cmpeqi	r2,r2,255
8110c0e0:	10003c1e 	bne	r2,zero,8110c1d4 <vTimeoutCheckerTask+0x7c0>
                        OSMutexPend(xMutexBuffer64, 1, &error_code); /* Try to get the mutex (wait 1 ticks) */
8110c0e4:	d0a05a17 	ldw	r2,-32408(gp)
8110c0e8:	e0fffac4 	addi	r3,fp,-21
8110c0ec:	180d883a 	mov	r6,r3
8110c0f0:	01400044 	movi	r5,1
8110c0f4:	1009883a 	mov	r4,r2
8110c0f8:	112da5c0 	call	8112da5c <OSMutexPend>
                        if ( error_code == OS_ERR_NONE ) {
8110c0fc:	e0bffac3 	ldbu	r2,-21(fp)
8110c100:	10803fcc 	andi	r2,r2,255
8110c104:	1000321e 	bne	r2,zero,8110c1d0 <vTimeoutCheckerTask+0x7bc>
                            k = 0;
8110c108:	e03ffa85 	stb	zero,-22(fp)
                            do
                            {
                                i = ucRetransB64[k];
8110c10c:	e0bffa83 	ldbu	r2,-22(fp)
8110c110:	e0fffd04 	addi	r3,fp,-12
8110c114:	1885883a 	add	r2,r3,r2
8110c118:	10800003 	ldbu	r2,0(r2)
8110c11c:	e0bffa45 	stb	r2,-23(fp)
                                xBuffer64[i].ucNofRetries--;
8110c120:	e0fffa43 	ldbu	r3,-23(fp)
8110c124:	00a04534 	movhi	r2,33044
8110c128:	1090b104 	addi	r2,r2,17092
8110c12c:	19001324 	muli	r4,r3,76
8110c130:	1105883a 	add	r2,r2,r4
8110c134:	10801204 	addi	r2,r2,72
8110c138:	10800003 	ldbu	r2,0(r2)
8110c13c:	10bfffc4 	addi	r2,r2,-1
8110c140:	1009883a 	mov	r4,r2
8110c144:	00a04534 	movhi	r2,33044
8110c148:	1090b104 	addi	r2,r2,17092
8110c14c:	18c01324 	muli	r3,r3,76
8110c150:	10c5883a 	add	r2,r2,r3
8110c154:	10801204 	addi	r2,r2,72
8110c158:	11000005 	stb	r4,0(r2)
                                xBuffer64[i].usiTimeOut = TIMEOUT_COUNT;
8110c15c:	e0fffa43 	ldbu	r3,-23(fp)
8110c160:	00a04534 	movhi	r2,33044
8110c164:	1090b104 	addi	r2,r2,17092
8110c168:	18c01324 	muli	r3,r3,76
8110c16c:	10c5883a 	add	r2,r2,r3
8110c170:	10801184 	addi	r2,r2,70
8110c174:	00c00144 	movi	r3,5
8110c178:	10c0000d 	sth	r3,0(r2)
                                puts(xBuffer64[i].buffer);                                
8110c17c:	e0bffa43 	ldbu	r2,-23(fp)
8110c180:	10c01324 	muli	r3,r2,76
8110c184:	00a04534 	movhi	r2,33044
8110c188:	1090b104 	addi	r2,r2,17092
8110c18c:	1885883a 	add	r2,r3,r2
8110c190:	1009883a 	mov	r4,r2
8110c194:	1113b040 	call	81113b04 <puts>
                                k++;
8110c198:	e0bffa83 	ldbu	r2,-22(fp)
8110c19c:	10800044 	addi	r2,r2,1
8110c1a0:	e0bffa85 	stb	r2,-22(fp)
                            } while ( ucRetransB64[k] != 255 );
8110c1a4:	e0bffa83 	ldbu	r2,-22(fp)
8110c1a8:	e0fffd04 	addi	r3,fp,-12
8110c1ac:	1885883a 	add	r2,r3,r2
8110c1b0:	10800003 	ldbu	r2,0(r2)
8110c1b4:	10803fcc 	andi	r2,r2,255
8110c1b8:	10803fd8 	cmpnei	r2,r2,255
8110c1bc:	103fd31e 	bne	r2,zero,8110c10c <__reset+0xfb0ec10c>

                            OSMutexPost(xMutexBuffer64);
8110c1c0:	d0a05a17 	ldw	r2,-32408(gp)
8110c1c4:	1009883a 	mov	r4,r2
8110c1c8:	112e0000 	call	8112e000 <OSMutexPost>
8110c1cc:	00000106 	br	8110c1d4 <vTimeoutCheckerTask+0x7c0>
                        } else {
                            /*  Could not get the mutex for the buffer32. There is no big impact to the system. So next cycle it may be transmited.
                                This is not a reason to exit the execution of all Simucam.*/
                            vCouldNotRetransmitB64TimeoutTask();
8110c1d0:	110fa380 	call	8110fa38 <vCouldNotRetransmitB64TimeoutTask>
                        }    
                    }

                    if ( ucRetransB128[0] != 255 ) {
8110c1d4:	e0bffe03 	ldbu	r2,-8(fp)
8110c1d8:	10803fcc 	andi	r2,r2,255
8110c1dc:	10803fe0 	cmpeqi	r2,r2,255
8110c1e0:	10003c1e 	bne	r2,zero,8110c2d4 <vTimeoutCheckerTask+0x8c0>
                        OSMutexPend(xMutexBuffer128, 1, &error_code); /* Try to get the mutex (wait 1 ticks) */
8110c1e4:	d0a05817 	ldw	r2,-32416(gp)
8110c1e8:	e0fffac4 	addi	r3,fp,-21
8110c1ec:	180d883a 	mov	r6,r3
8110c1f0:	01400044 	movi	r5,1
8110c1f4:	1009883a 	mov	r4,r2
8110c1f8:	112da5c0 	call	8112da5c <OSMutexPend>
                        if ( error_code == OS_ERR_NONE ) {
8110c1fc:	e0bffac3 	ldbu	r2,-21(fp)
8110c200:	10803fcc 	andi	r2,r2,255
8110c204:	1000321e 	bne	r2,zero,8110c2d0 <vTimeoutCheckerTask+0x8bc>
                            k = 0;
8110c208:	e03ffa85 	stb	zero,-22(fp)
                            do
                            {
                                i = ucRetransB128[k];
8110c20c:	e0bffa83 	ldbu	r2,-22(fp)
8110c210:	e0fffe04 	addi	r3,fp,-8
8110c214:	1885883a 	add	r2,r3,r2
8110c218:	10800003 	ldbu	r2,0(r2)
8110c21c:	e0bffa45 	stb	r2,-23(fp)
                                xBuffer128[i].ucNofRetries--;
8110c220:	e0fffa43 	ldbu	r3,-23(fp)
8110c224:	00a04574 	movhi	r2,33045
8110c228:	10ba7a04 	addi	r2,r2,-5656
8110c22c:	19002324 	muli	r4,r3,140
8110c230:	1105883a 	add	r2,r2,r4
8110c234:	10802204 	addi	r2,r2,136
8110c238:	10800003 	ldbu	r2,0(r2)
8110c23c:	10bfffc4 	addi	r2,r2,-1
8110c240:	1009883a 	mov	r4,r2
8110c244:	00a04574 	movhi	r2,33045
8110c248:	10ba7a04 	addi	r2,r2,-5656
8110c24c:	18c02324 	muli	r3,r3,140
8110c250:	10c5883a 	add	r2,r2,r3
8110c254:	10802204 	addi	r2,r2,136
8110c258:	11000005 	stb	r4,0(r2)
                                xBuffer128[i].usiTimeOut = TIMEOUT_COUNT;
8110c25c:	e0fffa43 	ldbu	r3,-23(fp)
8110c260:	00a04574 	movhi	r2,33045
8110c264:	10ba7a04 	addi	r2,r2,-5656
8110c268:	18c02324 	muli	r3,r3,140
8110c26c:	10c5883a 	add	r2,r2,r3
8110c270:	10802184 	addi	r2,r2,134
8110c274:	00c00144 	movi	r3,5
8110c278:	10c0000d 	sth	r3,0(r2)
                                puts(xBuffer128[i].buffer);                                
8110c27c:	e0bffa43 	ldbu	r2,-23(fp)
8110c280:	10c02324 	muli	r3,r2,140
8110c284:	00a04574 	movhi	r2,33045
8110c288:	10ba7a04 	addi	r2,r2,-5656
8110c28c:	1885883a 	add	r2,r3,r2
8110c290:	1009883a 	mov	r4,r2
8110c294:	1113b040 	call	81113b04 <puts>
                                k++;
8110c298:	e0bffa83 	ldbu	r2,-22(fp)
8110c29c:	10800044 	addi	r2,r2,1
8110c2a0:	e0bffa85 	stb	r2,-22(fp)
                            } while ( ucRetransB128[k] != 255 );
8110c2a4:	e0bffa83 	ldbu	r2,-22(fp)
8110c2a8:	e0fffe04 	addi	r3,fp,-8
8110c2ac:	1885883a 	add	r2,r3,r2
8110c2b0:	10800003 	ldbu	r2,0(r2)
8110c2b4:	10803fcc 	andi	r2,r2,255
8110c2b8:	10803fd8 	cmpnei	r2,r2,255
8110c2bc:	103fd31e 	bne	r2,zero,8110c20c <__reset+0xfb0ec20c>

                            OSMutexPost(xMutexBuffer128);
8110c2c0:	d0a05817 	ldw	r2,-32416(gp)
8110c2c4:	1009883a 	mov	r4,r2
8110c2c8:	112e0000 	call	8112e000 <OSMutexPost>
8110c2cc:	00000106 	br	8110c2d4 <vTimeoutCheckerTask+0x8c0>
                        } else {
                            /*  Could not get the mutex for the buffer32. There is no big impact to the system. So next cycle it may be transmited.
                                This is not a reason to exit the execution of all Simucam.*/
                            vCouldNotRetransmitB128TimeoutTask();
8110c2d0:	110faa00 	call	8110faa0 <vCouldNotRetransmitB128TimeoutTask>
                        }
                    }                    
                    OSMutexPost(xTxUARTMutex);
8110c2d4:	d0a05c17 	ldw	r2,-32400(gp)
8110c2d8:	1009883a 	mov	r4,r2
8110c2dc:	112e0000 	call	8112e000 <OSMutexPost>
8110c2e0:	003de006 	br	8110ba64 <__reset+0xfb0eba64>
                } else {
                    /*  Couldn't get access to the UART tx buffer, there is no big impact to the system. So next cycle it may be transmited.
                        This is not a reason to exit the execution of all Simucam.*/
                    vFailCouldNotRetransmitTimeoutTask();
8110c2e4:	110f9680 	call	8110f968 <vFailCouldNotRetransmitTimeoutTask>
8110c2e8:	003dde06 	br	8110ba64 <__reset+0xfb0eba64>
                }
            }

        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
8110c2ec:	110f8980 	call	8110f898 <vFailGetBlockingSemTimeoutTask>
        }
    }
8110c2f0:	003ddc06 	br	8110ba64 <__reset+0xfb0eba64>

8110c2f4 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMebStruct;

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void )
{
8110c2f4:	defff904 	addi	sp,sp,-28
8110c2f8:	de00012e 	bgeu	sp,et,8110c300 <bResourcesInitRTOS+0xc>
8110c2fc:	003b68fa 	trap	3
8110c300:	dfc00615 	stw	ra,24(sp)
8110c304:	df000515 	stw	fp,20(sp)
8110c308:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
8110c30c:	00800044 	movi	r2,1
8110c310:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
8110c314:	0009883a 	mov	r4,zero
8110c318:	112f7400 	call	8112f740 <OSSemCreate>
8110c31c:	d0a04c15 	stw	r2,-32464(gp)
	if (!xSemCommInit) {
8110c320:	d0a04c17 	ldw	r2,-32464(gp)
8110c324:	1000021e 	bne	r2,zero,8110c330 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
8110c328:	110eb500 	call	8110eb50 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110c32c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
8110c330:	e0bfff04 	addi	r2,fp,-4
8110c334:	100b883a 	mov	r5,r2
8110c338:	010000c4 	movi	r4,3
8110c33c:	112d5880 	call	8112d588 <OSMutexCreate>
8110c340:	d0a05c15 	stw	r2,-32400(gp)
	if ( err != OS_ERR_NONE ) {
8110c344:	e0bfff03 	ldbu	r2,-4(fp)
8110c348:	10803fcc 	andi	r2,r2,255
8110c34c:	10000526 	beq	r2,zero,8110c364 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
8110c350:	e0bfff03 	ldbu	r2,-4(fp)
8110c354:	10803fcc 	andi	r2,r2,255
8110c358:	1009883a 	mov	r4,r2
8110c35c:	110eaf00 	call	8110eaf0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110c360:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
8110c364:	e0bfff04 	addi	r2,fp,-4
8110c368:	100b883a 	mov	r5,r2
8110c36c:	01000184 	movi	r4,6
8110c370:	112d5880 	call	8112d588 <OSMutexCreate>
8110c374:	d0a05815 	stw	r2,-32416(gp)
	if ( err != OS_ERR_NONE ) {
8110c378:	e0bfff03 	ldbu	r2,-4(fp)
8110c37c:	10803fcc 	andi	r2,r2,255
8110c380:	10000526 	beq	r2,zero,8110c398 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
8110c384:	e0bfff03 	ldbu	r2,-4(fp)
8110c388:	10803fcc 	andi	r2,r2,255
8110c38c:	1009883a 	mov	r4,r2
8110c390:	110eaf00 	call	8110eaf0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110c394:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
8110c398:	e0bfff04 	addi	r2,fp,-4
8110c39c:	100b883a 	mov	r5,r2
8110c3a0:	010001c4 	movi	r4,7
8110c3a4:	112d5880 	call	8112d588 <OSMutexCreate>
8110c3a8:	d0a05a15 	stw	r2,-32408(gp)
	if ( err != OS_ERR_NONE ) {
8110c3ac:	e0bfff03 	ldbu	r2,-4(fp)
8110c3b0:	10803fcc 	andi	r2,r2,255
8110c3b4:	10000526 	beq	r2,zero,8110c3cc <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
8110c3b8:	e0bfff03 	ldbu	r2,-4(fp)
8110c3bc:	10803fcc 	andi	r2,r2,255
8110c3c0:	1009883a 	mov	r4,r2
8110c3c4:	110eaf00 	call	8110eaf0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110c3c8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
8110c3cc:	e0bfff04 	addi	r2,fp,-4
8110c3d0:	100b883a 	mov	r5,r2
8110c3d4:	01000204 	movi	r4,8
8110c3d8:	112d5880 	call	8112d588 <OSMutexCreate>
8110c3dc:	d0a05615 	stw	r2,-32424(gp)
	if ( err != OS_ERR_NONE ) {
8110c3e0:	e0bfff03 	ldbu	r2,-4(fp)
8110c3e4:	10803fcc 	andi	r2,r2,255
8110c3e8:	10000526 	beq	r2,zero,8110c400 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
8110c3ec:	e0bfff03 	ldbu	r2,-4(fp)
8110c3f0:	10803fcc 	andi	r2,r2,255
8110c3f4:	1009883a 	mov	r4,r2
8110c3f8:	110eaf00 	call	8110eaf0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110c3fc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
8110c400:	00800084 	movi	r2,2
8110c404:	d0a05d45 	stb	r2,-32395(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
8110c408:	01000084 	movi	r4,2
8110c40c:	112f7400 	call	8112f740 <OSSemCreate>
8110c410:	d0a04f15 	stw	r2,-32452(gp)
	if (!xSemCountBuffer128) {
8110c414:	d0a04f17 	ldw	r2,-32452(gp)
8110c418:	1000031e 	bne	r2,zero,8110c428 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
8110c41c:	d0205d45 	stb	zero,-32395(gp)
		vFailCreateSemaphoreResources();
8110c420:	110eb500 	call	8110eb50 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110c424:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
8110c428:	00800104 	movi	r2,4
8110c42c:	d0a05d05 	stb	r2,-32396(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
8110c430:	01000104 	movi	r4,4
8110c434:	112f7400 	call	8112f740 <OSSemCreate>
8110c438:	d0a04b15 	stw	r2,-32468(gp)
	if (!xSemCountBuffer64) {
8110c43c:	d0a04b17 	ldw	r2,-32468(gp)
8110c440:	1000031e 	bne	r2,zero,8110c450 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
8110c444:	d0205d05 	stb	zero,-32396(gp)
		vFailCreateSemaphoreResources();
8110c448:	110eb500 	call	8110eb50 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110c44c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
8110c450:	00800204 	movi	r2,8
8110c454:	d0a05485 	stb	r2,-32430(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
8110c458:	01000204 	movi	r4,8
8110c45c:	112f7400 	call	8112f740 <OSSemCreate>
8110c460:	d0a05915 	stw	r2,-32412(gp)
	if (!xSemCountBuffer32) {
8110c464:	d0a05917 	ldw	r2,-32412(gp)
8110c468:	1000031e 	bne	r2,zero,8110c478 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
8110c46c:	d0205485 	stb	zero,-32430(gp)
		vFailCreateSemaphoreResources();
8110c470:	110eb500 	call	8110eb50 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110c474:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
8110c478:	e0bfff04 	addi	r2,fp,-4
8110c47c:	100b883a 	mov	r5,r2
8110c480:	01000144 	movi	r4,5
8110c484:	112d5880 	call	8112d588 <OSMutexCreate>
8110c488:	d0a05115 	stw	r2,-32444(gp)
	if ( err != OS_ERR_NONE ) {
8110c48c:	e0bfff03 	ldbu	r2,-4(fp)
8110c490:	10803fcc 	andi	r2,r2,255
8110c494:	10000526 	beq	r2,zero,8110c4ac <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
8110c498:	e0bfff03 	ldbu	r2,-4(fp)
8110c49c:	10803fcc 	andi	r2,r2,255
8110c4a0:	1009883a 	mov	r4,r2
8110c4a4:	110eaf00 	call	8110eaf0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110c4a8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
8110c4ac:	e0bfff04 	addi	r2,fp,-4
8110c4b0:	100b883a 	mov	r5,r2
8110c4b4:	01000244 	movi	r4,9
8110c4b8:	112d5880 	call	8112d588 <OSMutexCreate>
8110c4bc:	d0a05515 	stw	r2,-32428(gp)
	if ( err != OS_ERR_NONE ) {
8110c4c0:	e0bfff03 	ldbu	r2,-4(fp)
8110c4c4:	10803fcc 	andi	r2,r2,255
8110c4c8:	10000526 	beq	r2,zero,8110c4e0 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
8110c4cc:	e0bfff03 	ldbu	r2,-4(fp)
8110c4d0:	10803fcc 	andi	r2,r2,255
8110c4d4:	1009883a 	mov	r4,r2
8110c4d8:	110eaf00 	call	8110eaf0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110c4dc:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
8110c4e0:	0009883a 	mov	r4,zero
8110c4e4:	112f7400 	call	8112f740 <OSSemCreate>
8110c4e8:	d0a05215 	stw	r2,-32440(gp)
	if (!xSemCountReceivedACK) {
8110c4ec:	d0a05217 	ldw	r2,-32440(gp)
8110c4f0:	1000021e 	bne	r2,zero,8110c4fc <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
8110c4f4:	110eb500 	call	8110eb50 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110c4f8:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
8110c4fc:	0009883a 	mov	r4,zero
8110c500:	112f7400 	call	8112f740 <OSSemCreate>
8110c504:	d0a05015 	stw	r2,-32448(gp)
	if (!xSemCountPreParsed) {
8110c508:	d0a05017 	ldw	r2,-32448(gp)
8110c50c:	1000021e 	bne	r2,zero,8110c518 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
8110c510:	110eb500 	call	8110eb50 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110c514:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
8110c518:	0009883a 	mov	r4,zero
8110c51c:	112f7400 	call	8112f740 <OSSemCreate>
8110c520:	d0a04d15 	stw	r2,-32460(gp)
	if (!xSemCountSenderACK) {
8110c524:	d0a04d17 	ldw	r2,-32460(gp)
8110c528:	1000021e 	bne	r2,zero,8110c534 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
8110c52c:	110eb500 	call	8110eb50 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110c530:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
8110c534:	e0bfff04 	addi	r2,fp,-4
8110c538:	100b883a 	mov	r5,r2
8110c53c:	01000104 	movi	r4,4
8110c540:	112d5880 	call	8112d588 <OSMutexCreate>
8110c544:	d0a05b15 	stw	r2,-32404(gp)
	if ( err != OS_ERR_NONE ) {
8110c548:	e0bfff03 	ldbu	r2,-4(fp)
8110c54c:	10803fcc 	andi	r2,r2,255
8110c550:	10000526 	beq	r2,zero,8110c568 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
8110c554:	e0bfff03 	ldbu	r2,-4(fp)
8110c558:	10803fcc 	andi	r2,r2,255
8110c55c:	1009883a 	mov	r4,r2
8110c560:	110eaf00 	call	8110eaf0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110c564:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
8110c568:	0009883a 	mov	r4,zero
8110c56c:	112f7400 	call	8112f740 <OSSemCreate>
8110c570:	d0a05315 	stw	r2,-32436(gp)
	if (!xSemTimeoutChecker) {
8110c574:	d0a05317 	ldw	r2,-32436(gp)
8110c578:	1000021e 	bne	r2,zero,8110c584 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
8110c57c:	110eb500 	call	8110eb50 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110c580:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
8110c584:	e0bfff04 	addi	r2,fp,-4
8110c588:	d8800215 	stw	r2,8(sp)
8110c58c:	00a04534 	movhi	r2,33044
8110c590:	10b73904 	addi	r2,r2,-8988
8110c594:	d8800115 	stw	r2,4(sp)
8110c598:	d8000015 	stw	zero,0(sp)
8110c59c:	01e04474 	movhi	r7,33041
8110c5a0:	39f62104 	addi	r7,r7,-10108
8110c5a4:	01800084 	movi	r6,2
8110c5a8:	01400144 	movi	r5,5
8110c5ac:	01003204 	movi	r4,200
8110c5b0:	1131e0c0 	call	81131e0c <OSTmrCreate>
8110c5b4:	d0a05715 	stw	r2,-32420(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
8110c5b8:	e0bfff03 	ldbu	r2,-4(fp)
8110c5bc:	10803fcc 	andi	r2,r2,255
8110c5c0:	10000226 	beq	r2,zero,8110c5cc <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
8110c5c4:	110f7b40 	call	8110f7b4 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
8110c5c8:	e03ffe15 	stw	zero,-8(fp)
	}

	return bSuccess;
8110c5cc:	e0bffe17 	ldw	r2,-8(fp)
}
8110c5d0:	e037883a 	mov	sp,fp
8110c5d4:	dfc00117 	ldw	ra,4(sp)
8110c5d8:	df000017 	ldw	fp,0(sp)
8110c5dc:	dec00204 	addi	sp,sp,8
8110c5e0:	f800283a 	ret

8110c5e4 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
8110c5e4:	defffd04 	addi	sp,sp,-12
8110c5e8:	de00012e 	bgeu	sp,et,8110c5f0 <vVariablesInitialization+0xc>
8110c5ec:	003b68fa 	trap	3
8110c5f0:	dfc00215 	stw	ra,8(sp)
8110c5f4:	df000115 	stw	fp,4(sp)
8110c5f8:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
8110c5fc:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
8110c600:	00800084 	movi	r2,2
8110c604:	d0a0540d 	sth	r2,-32432(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(bool)*N_128);
8110c608:	01800204 	movi	r6,8
8110c60c:	000b883a 	mov	r5,zero
8110c610:	01204574 	movhi	r4,33045
8110c614:	213a6c04 	addi	r4,r4,-5712
8110c618:	11138300 	call	81113830 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(bool)*N_64);
8110c61c:	01800404 	movi	r6,16
8110c620:	000b883a 	mov	r5,zero
8110c624:	01204574 	movhi	r4,33045
8110c628:	213a6e04 	addi	r4,r4,-5704
8110c62c:	11138300 	call	81113830 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(bool)*N_32);
8110c630:	01800804 	movi	r6,32
8110c634:	000b883a 	mov	r5,zero
8110c638:	01204574 	movhi	r4,33045
8110c63c:	213a7204 	addi	r4,r4,-5688
8110c640:	11138300 	call	81113830 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110c644:	e03fff05 	stb	zero,-4(fp)
8110c648:	00002806 	br	8110c6ec <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
8110c64c:	e0bfff03 	ldbu	r2,-4(fp)
8110c650:	10c02324 	muli	r3,r2,140
8110c654:	00a04574 	movhi	r2,33045
8110c658:	10ba7a04 	addi	r2,r2,-5656
8110c65c:	1885883a 	add	r2,r3,r2
8110c660:	01802004 	movi	r6,128
8110c664:	000b883a 	mov	r5,zero
8110c668:	1009883a 	mov	r4,r2
8110c66c:	11138300 	call	81113830 <memset>
		xBuffer128[ucIL].bSent = FALSE;
8110c670:	e0ffff03 	ldbu	r3,-4(fp)
8110c674:	00a04574 	movhi	r2,33045
8110c678:	10ba7a04 	addi	r2,r2,-5656
8110c67c:	18c02324 	muli	r3,r3,140
8110c680:	10c5883a 	add	r2,r2,r3
8110c684:	10802004 	addi	r2,r2,128
8110c688:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
8110c68c:	e0ffff03 	ldbu	r3,-4(fp)
8110c690:	00a04574 	movhi	r2,33045
8110c694:	10ba7a04 	addi	r2,r2,-5656
8110c698:	18c02324 	muli	r3,r3,140
8110c69c:	10c5883a 	add	r2,r2,r3
8110c6a0:	10802104 	addi	r2,r2,132
8110c6a4:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
8110c6a8:	e0ffff03 	ldbu	r3,-4(fp)
8110c6ac:	00a04574 	movhi	r2,33045
8110c6b0:	10ba7a04 	addi	r2,r2,-5656
8110c6b4:	18c02324 	muli	r3,r3,140
8110c6b8:	10c5883a 	add	r2,r2,r3
8110c6bc:	10802184 	addi	r2,r2,134
8110c6c0:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
8110c6c4:	e0ffff03 	ldbu	r3,-4(fp)
8110c6c8:	00a04574 	movhi	r2,33045
8110c6cc:	10ba7a04 	addi	r2,r2,-5656
8110c6d0:	18c02324 	muli	r3,r3,140
8110c6d4:	10c5883a 	add	r2,r2,r3
8110c6d8:	10802204 	addi	r2,r2,136
8110c6dc:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(bool)*N_128);
	memset( xInUseRetrans.b64 , FALSE , sizeof(bool)*N_64);
	memset( xInUseRetrans.b32 , FALSE , sizeof(bool)*N_32);
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110c6e0:	e0bfff03 	ldbu	r2,-4(fp)
8110c6e4:	10800044 	addi	r2,r2,1
8110c6e8:	e0bfff05 	stb	r2,-4(fp)
8110c6ec:	e0bfff03 	ldbu	r2,-4(fp)
8110c6f0:	108000b0 	cmpltui	r2,r2,2
8110c6f4:	103fd51e 	bne	r2,zero,8110c64c <__reset+0xfb0ec64c>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
8110c6f8:	e03fff05 	stb	zero,-4(fp)
8110c6fc:	00002806 	br	8110c7a0 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
8110c700:	e0bfff03 	ldbu	r2,-4(fp)
8110c704:	10c01324 	muli	r3,r2,76
8110c708:	00a04534 	movhi	r2,33044
8110c70c:	1090b104 	addi	r2,r2,17092
8110c710:	1885883a 	add	r2,r3,r2
8110c714:	01801004 	movi	r6,64
8110c718:	000b883a 	mov	r5,zero
8110c71c:	1009883a 	mov	r4,r2
8110c720:	11138300 	call	81113830 <memset>
		xBuffer64[ucIL].bSent = FALSE;
8110c724:	e0ffff03 	ldbu	r3,-4(fp)
8110c728:	00a04534 	movhi	r2,33044
8110c72c:	1090b104 	addi	r2,r2,17092
8110c730:	18c01324 	muli	r3,r3,76
8110c734:	10c5883a 	add	r2,r2,r3
8110c738:	10801004 	addi	r2,r2,64
8110c73c:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
8110c740:	e0ffff03 	ldbu	r3,-4(fp)
8110c744:	00a04534 	movhi	r2,33044
8110c748:	1090b104 	addi	r2,r2,17092
8110c74c:	18c01324 	muli	r3,r3,76
8110c750:	10c5883a 	add	r2,r2,r3
8110c754:	10801104 	addi	r2,r2,68
8110c758:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
8110c75c:	e0ffff03 	ldbu	r3,-4(fp)
8110c760:	00a04534 	movhi	r2,33044
8110c764:	1090b104 	addi	r2,r2,17092
8110c768:	18c01324 	muli	r3,r3,76
8110c76c:	10c5883a 	add	r2,r2,r3
8110c770:	10801184 	addi	r2,r2,70
8110c774:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
8110c778:	e0ffff03 	ldbu	r3,-4(fp)
8110c77c:	00a04534 	movhi	r2,33044
8110c780:	1090b104 	addi	r2,r2,17092
8110c784:	18c01324 	muli	r3,r3,76
8110c788:	10c5883a 	add	r2,r2,r3
8110c78c:	10801204 	addi	r2,r2,72
8110c790:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
8110c794:	e0bfff03 	ldbu	r2,-4(fp)
8110c798:	10800044 	addi	r2,r2,1
8110c79c:	e0bfff05 	stb	r2,-4(fp)
8110c7a0:	e0bfff03 	ldbu	r2,-4(fp)
8110c7a4:	10800130 	cmpltui	r2,r2,4
8110c7a8:	103fd51e 	bne	r2,zero,8110c700 <__reset+0xfb0ec700>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
8110c7ac:	e03fff05 	stb	zero,-4(fp)
8110c7b0:	00002806 	br	8110c854 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
8110c7b4:	e0bfff03 	ldbu	r2,-4(fp)
8110c7b8:	10c00b24 	muli	r3,r2,44
8110c7bc:	00a04574 	movhi	r2,33045
8110c7c0:	10a21404 	addi	r2,r2,-30640
8110c7c4:	1885883a 	add	r2,r3,r2
8110c7c8:	01800804 	movi	r6,32
8110c7cc:	000b883a 	mov	r5,zero
8110c7d0:	1009883a 	mov	r4,r2
8110c7d4:	11138300 	call	81113830 <memset>
		xBuffer32[ucIL].bSent = FALSE;
8110c7d8:	e0ffff03 	ldbu	r3,-4(fp)
8110c7dc:	00a04574 	movhi	r2,33045
8110c7e0:	10a21404 	addi	r2,r2,-30640
8110c7e4:	18c00b24 	muli	r3,r3,44
8110c7e8:	10c5883a 	add	r2,r2,r3
8110c7ec:	10800804 	addi	r2,r2,32
8110c7f0:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
8110c7f4:	e0ffff03 	ldbu	r3,-4(fp)
8110c7f8:	00a04574 	movhi	r2,33045
8110c7fc:	10a21404 	addi	r2,r2,-30640
8110c800:	18c00b24 	muli	r3,r3,44
8110c804:	10c5883a 	add	r2,r2,r3
8110c808:	10800904 	addi	r2,r2,36
8110c80c:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
8110c810:	e0ffff03 	ldbu	r3,-4(fp)
8110c814:	00a04574 	movhi	r2,33045
8110c818:	10a21404 	addi	r2,r2,-30640
8110c81c:	18c00b24 	muli	r3,r3,44
8110c820:	10c5883a 	add	r2,r2,r3
8110c824:	10800984 	addi	r2,r2,38
8110c828:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
8110c82c:	e0ffff03 	ldbu	r3,-4(fp)
8110c830:	00a04574 	movhi	r2,33045
8110c834:	10a21404 	addi	r2,r2,-30640
8110c838:	18c00b24 	muli	r3,r3,44
8110c83c:	10c5883a 	add	r2,r2,r3
8110c840:	10800a04 	addi	r2,r2,40
8110c844:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
8110c848:	e0bfff03 	ldbu	r2,-4(fp)
8110c84c:	10800044 	addi	r2,r2,1
8110c850:	e0bfff05 	stb	r2,-4(fp)
8110c854:	e0bfff03 	ldbu	r2,-4(fp)
8110c858:	10800230 	cmpltui	r2,r2,8
8110c85c:	103fd51e 	bne	r2,zero,8110c7b4 <__reset+0xfb0ec7b4>
*/




}
8110c860:	0001883a 	nop
8110c864:	e037883a 	mov	sp,fp
8110c868:	dfc00117 	ldw	ra,4(sp)
8110c86c:	df000017 	ldw	fp,0(sp)
8110c870:	dec00204 	addi	sp,sp,8
8110c874:	f800283a 	ret

8110c878 <main>:



/* Entry point */
int main(void)
{
8110c878:	defff704 	addi	sp,sp,-36
8110c87c:	de00012e 	bgeu	sp,et,8110c884 <main+0xc>
8110c880:	003b68fa 	trap	3
8110c884:	dfc00815 	stw	ra,32(sp)
8110c888:	df000715 	stw	fp,28(sp)
8110c88c:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
8110c890:	e03ffe15 	stw	zero,-8(fp)
	
	//OSInit(); /* todo: Talvez remover */

	/* Clear the RTOS timer */
	OSTimeSet(0);
8110c894:	0009883a 	mov	r4,zero
8110c898:	1131da40 	call	81131da4 <OSTimeSet>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
8110c89c:	01604534 	movhi	r5,33044
8110c8a0:	29773d04 	addi	r5,r5,-8972
8110c8a4:	01204534 	movhi	r4,33044
8110c8a8:	21373e04 	addi	r4,r4,-8968
8110c8ac:	11126980 	call	81112698 <fopen>
8110c8b0:	d0a04e15 	stw	r2,-32456(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
8110c8b4:	d0a04e17 	ldw	r2,-32456(gp)
8110c8b8:	100f883a 	mov	r7,r2
8110c8bc:	01800484 	movi	r6,18
8110c8c0:	01400044 	movi	r5,1
8110c8c4:	01204534 	movhi	r4,33044
8110c8c8:	21374304 	addi	r4,r4,-8948
8110c8cc:	1112ccc0 	call	81112ccc <fwrite>
	#endif


	/* Initialization of basic HW */
	vInitSimucamBasicHW();
8110c8d0:	11103800 	call	81110380 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
8110c8d4:	1110c4c0 	call	81110c4c <bTestSimucamCriticalHW>
8110c8d8:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110c8dc:	e0bffe17 	ldw	r2,-8(fp)
8110c8e0:	1000031e 	bne	r2,zero,8110c8f0 <main+0x78>
		vFailTestCriticasParts();
8110c8e4:	110eb9c0 	call	8110eb9c <vFailTestCriticasParts>
		return -1;
8110c8e8:	00bfffc4 	movi	r2,-1
8110c8ec:	00003c06 	br	8110c9e0 <main+0x168>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
8110c8f0:	1110a980 	call	81110a98 <bInitializeSDCard>
8110c8f4:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110c8f8:	e0bffe17 	ldw	r2,-8(fp)
8110c8fc:	1000031e 	bne	r2,zero,8110c90c <main+0x94>
		vFailTestCriticasParts();
8110c900:	110eb9c0 	call	8110eb9c <vFailTestCriticasParts>
		return -1;
8110c904:	00bfffc4 	movi	r2,-1
8110c908:	00003506 	br	8110c9e0 <main+0x168>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
8110c90c:	110dcac0 	call	8110dcac <vLoadDefaultETHConf>
8110c910:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110c914:	e0bffe17 	ldw	r2,-8(fp)
8110c918:	1000091e 	bne	r2,zero,8110c940 <main+0xc8>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. (exit) \n");
8110c91c:	d0a04e17 	ldw	r2,-32456(gp)
8110c920:	100f883a 	mov	r7,r2
8110c924:	01801644 	movi	r6,89
8110c928:	01400044 	movi	r5,1
8110c92c:	01204534 	movhi	r4,33044
8110c930:	21374804 	addi	r4,r4,-8928
8110c934:	1112ccc0 	call	81112ccc <fwrite>
		#endif
		return -1;
8110c938:	00bfffc4 	movi	r2,-1
8110c93c:	00002806 	br	8110c9e0 <main+0x168>
	}

	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
8110c940:	110e6380 	call	8110e638 <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
8110c944:	110c2f40 	call	8110c2f4 <bResourcesInitRTOS>
8110c948:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110c94c:	e0bffe17 	ldw	r2,-8(fp)
8110c950:	1000091e 	bne	r2,zero,8110c978 <main+0x100>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
8110c954:	d0a04e17 	ldw	r2,-32456(gp)
8110c958:	100f883a 	mov	r7,r2
8110c95c:	01800ac4 	movi	r6,43
8110c960:	01400044 	movi	r5,1
8110c964:	01204534 	movhi	r4,33044
8110c968:	21375f04 	addi	r4,r4,-8836
8110c96c:	1112ccc0 	call	81112ccc <fwrite>
		return -1;
8110c970:	00bfffc4 	movi	r2,-1
8110c974:	00001a06 	br	8110c9e0 <main+0x168>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMebStruct );
8110c978:	01204534 	movhi	r4,33044
8110c97c:	2118fd04 	addi	r4,r4,25588
8110c980:	11104b00 	call	811104b0 <vSimucamStructureInit>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
8110c984:	d8000415 	stw	zero,16(sp)
8110c988:	d8000315 	stw	zero,12(sp)
8110c98c:	00820004 	movi	r2,2048
8110c990:	d8800215 	stw	r2,8(sp)
8110c994:	00a04574 	movhi	r2,33045
8110c998:	10b26c04 	addi	r2,r2,-13904
8110c99c:	d8800115 	stw	r2,4(sp)
8110c9a0:	00800044 	movi	r2,1
8110c9a4:	d8800015 	stw	r2,0(sp)
8110c9a8:	01c00044 	movi	r7,1
8110c9ac:	01a04574 	movhi	r6,33045
8110c9b0:	31ba6b04 	addi	r6,r6,-5716
8110c9b4:	000b883a 	mov	r5,zero
8110c9b8:	01204474 	movhi	r4,33041
8110c9bc:	21238304 	addi	r4,r4,-29172
8110c9c0:	11307d40 	call	811307d4 <OSTaskCreateExt>
8110c9c4:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
8110c9c8:	e0bfff03 	ldbu	r2,-4(fp)
8110c9cc:	1000021e 	bne	r2,zero,8110c9d8 <main+0x160>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
8110c9d0:	1129d540 	call	81129d54 <OSStart>
8110c9d4:	00000106 	br	8110c9dc <main+0x164>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
8110c9d8:	110ef880 	call	8110ef88 <vFailInitialization>
	}
  
	return 0;
8110c9dc:	0005883a 	mov	r2,zero
}
8110c9e0:	e037883a 	mov	sp,fp
8110c9e4:	dfc00117 	ldw	ra,4(sp)
8110c9e8:	df000017 	ldw	fp,0(sp)
8110c9ec:	dec00204 	addi	sp,sp,8
8110c9f0:	f800283a 	ret

8110c9f4 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
8110c9f4:	defffe04 	addi	sp,sp,-8
8110c9f8:	de00012e 	bgeu	sp,et,8110ca00 <vCCDLoadDefaultValues+0xc>
8110c9fc:	003b68fa 	trap	3
8110ca00:	df000115 	stw	fp,4(sp)
8110ca04:	df000104 	addi	fp,sp,4
8110ca08:	e13fff15 	stw	r4,-4(fp)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadCcdDefsSDCard();

	ccdDef->usiHeight = 4510;
8110ca0c:	e0bfff17 	ldw	r2,-4(fp)
8110ca10:	00c46784 	movi	r3,4510
8110ca14:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = 30;
8110ca18:	e0bfff17 	ldw	r2,-4(fp)
8110ca1c:	00c00784 	movi	r3,30
8110ca20:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = 2255;
8110ca24:	e0bfff17 	ldw	r2,-4(fp)
8110ca28:	00c233c4 	movi	r3,2255
8110ca2c:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = 15;
8110ca30:	e0bfff17 	ldw	r2,-4(fp)
8110ca34:	00c003c4 	movi	r3,15
8110ca38:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = 25;
8110ca3c:	e0bfff17 	ldw	r2,-4(fp)
8110ca40:	00c00644 	movi	r3,25
8110ca44:	10c0000d 	sth	r3,0(r2)
}
8110ca48:	0001883a 	nop
8110ca4c:	e037883a 	mov	sp,fp
8110ca50:	df000017 	ldw	fp,0(sp)
8110ca54:	dec00104 	addi	sp,sp,4
8110ca58:	f800283a 	ret

8110ca5c <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
8110ca5c:	defff904 	addi	sp,sp,-28
8110ca60:	de00012e 	bgeu	sp,et,8110ca68 <vCCDChangeValues+0xc>
8110ca64:	003b68fa 	trap	3
8110ca68:	df000615 	stw	fp,24(sp)
8110ca6c:	df000604 	addi	fp,sp,24
8110ca70:	e13ffa15 	stw	r4,-24(fp)
8110ca74:	2811883a 	mov	r8,r5
8110ca78:	300b883a 	mov	r5,r6
8110ca7c:	3809883a 	mov	r4,r7
8110ca80:	e0c00117 	ldw	r3,4(fp)
8110ca84:	e0800217 	ldw	r2,8(fp)
8110ca88:	e23ffb0d 	sth	r8,-20(fp)
8110ca8c:	e17ffc0d 	sth	r5,-16(fp)
8110ca90:	e13ffd0d 	sth	r4,-12(fp)
8110ca94:	e0fffe0d 	sth	r3,-8(fp)
8110ca98:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
8110ca9c:	e0bffa17 	ldw	r2,-24(fp)
8110caa0:	e0fffb0b 	ldhu	r3,-20(fp)
8110caa4:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
8110caa8:	e0bffa17 	ldw	r2,-24(fp)
8110caac:	e0fffc0b 	ldhu	r3,-16(fp)
8110cab0:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
8110cab4:	e0bffa17 	ldw	r2,-24(fp)
8110cab8:	e0fffd0b 	ldhu	r3,-12(fp)
8110cabc:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
8110cac0:	e0bffa17 	ldw	r2,-24(fp)
8110cac4:	e0fffe0b 	ldhu	r3,-8(fp)
8110cac8:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
8110cacc:	e0bffa17 	ldw	r2,-24(fp)
8110cad0:	e0ffff0b 	ldhu	r3,-4(fp)
8110cad4:	10c0000d 	sth	r3,0(r2)
}
8110cad8:	0001883a 	nop
8110cadc:	e037883a 	mov	sp,fp
8110cae0:	df000017 	ldw	fp,0(sp)
8110cae4:	dec00104 	addi	sp,sp,4
8110cae8:	f800283a 	ret

8110caec <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
8110caec:	defff904 	addi	sp,sp,-28
8110caf0:	de00012e 	bgeu	sp,et,8110caf8 <bSendUART128v2+0xc>
8110caf4:	003b68fa 	trap	3
8110caf8:	dfc00615 	stw	ra,24(sp)
8110cafc:	df000515 	stw	fp,20(sp)
8110cb00:	df000504 	addi	fp,sp,20
8110cb04:	e13ffe15 	stw	r4,-8(fp)
8110cb08:	2805883a 	mov	r2,r5
8110cb0c:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
8110cb10:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8110cb14:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8110cb18:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8110cb1c:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8110cb20:	d0a04f17 	ldw	r2,-32452(gp)
8110cb24:	e0fffd04 	addi	r3,fp,-12
8110cb28:	180d883a 	mov	r6,r3
8110cb2c:	01400a04 	movi	r5,40
8110cb30:	1009883a 	mov	r4,r2
8110cb34:	112fa680 	call	8112fa68 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8110cb38:	e0bffd03 	ldbu	r2,-12(fp)
8110cb3c:	10803fcc 	andi	r2,r2,255
8110cb40:	10000326 	beq	r2,zero,8110cb50 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8110cb44:	110f1f00 	call	8110f1f0 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
8110cb48:	e0bffc17 	ldw	r2,-16(fp)
8110cb4c:	00009206 	br	8110cd98 <bSendUART128v2+0x2ac>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8110cb50:	d0a05817 	ldw	r2,-32416(gp)
8110cb54:	e0fffd04 	addi	r3,fp,-12
8110cb58:	180d883a 	mov	r6,r3
8110cb5c:	01400104 	movi	r5,4
8110cb60:	1009883a 	mov	r4,r2
8110cb64:	112da5c0 	call	8112da5c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110cb68:	e0bffd03 	ldbu	r2,-12(fp)
8110cb6c:	10803fcc 	andi	r2,r2,255
8110cb70:	10001126 	beq	r2,zero,8110cbb8 <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
8110cb74:	d0a04e17 	ldw	r2,-32456(gp)
8110cb78:	100f883a 	mov	r7,r2
8110cb7c:	01801484 	movi	r6,82
8110cb80:	01400044 	movi	r5,1
8110cb84:	01204534 	movhi	r4,33044
8110cb88:	21376a04 	addi	r4,r4,-8792
8110cb8c:	1112ccc0 	call	81112ccc <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
8110cb90:	d0a04f17 	ldw	r2,-32452(gp)
8110cb94:	1009883a 	mov	r4,r2
8110cb98:	112fdf00 	call	8112fdf0 <OSSemPost>
8110cb9c:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8110cba0:	e0bffd03 	ldbu	r2,-12(fp)
8110cba4:	10803fcc 	andi	r2,r2,255
8110cba8:	10000126 	beq	r2,zero,8110cbb0 <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8110cbac:	110f1880 	call	8110f188 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
8110cbb0:	e0bffc17 	ldw	r2,-16(fp)
8110cbb4:	00007806 	br	8110cd98 <bSendUART128v2+0x2ac>
	

	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	bSuccessL = TRUE;
8110cbb8:	00800044 	movi	r2,1
8110cbbc:	e0bffc15 	stw	r2,-16(fp)
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110cbc0:	e03ffb05 	stb	zero,-20(fp)
8110cbc4:	00004306 	br	8110ccd4 <bSendUART128v2+0x1e8>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
8110cbc8:	e0fffb03 	ldbu	r3,-20(fp)
8110cbcc:	00a04574 	movhi	r2,33045
8110cbd0:	10ba6c04 	addi	r2,r2,-5712
8110cbd4:	18c7883a 	add	r3,r3,r3
8110cbd8:	18c7883a 	add	r3,r3,r3
8110cbdc:	10c5883a 	add	r2,r2,r3
8110cbe0:	10800017 	ldw	r2,0(r2)
8110cbe4:	1000381e 	bne	r2,zero,8110ccc8 <bSendUART128v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
8110cbe8:	e0bffb03 	ldbu	r2,-20(fp)
8110cbec:	10c02324 	muli	r3,r2,140
8110cbf0:	00a04574 	movhi	r2,33045
8110cbf4:	10ba7a04 	addi	r2,r2,-5656
8110cbf8:	1885883a 	add	r2,r3,r2
8110cbfc:	01802004 	movi	r6,128
8110cc00:	000b883a 	mov	r5,zero
8110cc04:	1009883a 	mov	r4,r2
8110cc08:	11138300 	call	81113830 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
8110cc0c:	e0bffb03 	ldbu	r2,-20(fp)
8110cc10:	10c02324 	muli	r3,r2,140
8110cc14:	00a04574 	movhi	r2,33045
8110cc18:	10ba7a04 	addi	r2,r2,-5656
8110cc1c:	1885883a 	add	r2,r3,r2
8110cc20:	01801fc4 	movi	r6,127
8110cc24:	e17ffe17 	ldw	r5,-8(fp)
8110cc28:	1009883a 	mov	r4,r2
8110cc2c:	11136e00 	call	811136e0 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
8110cc30:	e13ffb03 	ldbu	r4,-20(fp)
8110cc34:	e0ffff0b 	ldhu	r3,-4(fp)
8110cc38:	00a04574 	movhi	r2,33045
8110cc3c:	10ba7a04 	addi	r2,r2,-5656
8110cc40:	21002324 	muli	r4,r4,140
8110cc44:	1105883a 	add	r2,r2,r4
8110cc48:	10802104 	addi	r2,r2,132
8110cc4c:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
8110cc50:	e0fffb03 	ldbu	r3,-20(fp)
8110cc54:	00a04574 	movhi	r2,33045
8110cc58:	10ba7a04 	addi	r2,r2,-5656
8110cc5c:	18c02324 	muli	r3,r3,140
8110cc60:	10c5883a 	add	r2,r2,r3
8110cc64:	10802204 	addi	r2,r2,136
8110cc68:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
8110cc6c:	e0fffb03 	ldbu	r3,-20(fp)
8110cc70:	00a04574 	movhi	r2,33045
8110cc74:	10ba7a04 	addi	r2,r2,-5656
8110cc78:	18c02324 	muli	r3,r3,140
8110cc7c:	10c5883a 	add	r2,r2,r3
8110cc80:	10802184 	addi	r2,r2,134
8110cc84:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
8110cc88:	e0fffb03 	ldbu	r3,-20(fp)
8110cc8c:	00a04574 	movhi	r2,33045
8110cc90:	10ba7a04 	addi	r2,r2,-5656
8110cc94:	18c02324 	muli	r3,r3,140
8110cc98:	10c5883a 	add	r2,r2,r3
8110cc9c:	10802004 	addi	r2,r2,128
8110cca0:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
8110cca4:	e0fffb03 	ldbu	r3,-20(fp)
8110cca8:	00a04574 	movhi	r2,33045
8110ccac:	10ba6c04 	addi	r2,r2,-5712
8110ccb0:	18c7883a 	add	r3,r3,r3
8110ccb4:	18c7883a 	add	r3,r3,r3
8110ccb8:	10c5883a 	add	r2,r2,r3
8110ccbc:	00c00044 	movi	r3,1
8110ccc0:	10c00015 	stw	r3,0(r2)
			break;
8110ccc4:	00000606 	br	8110cce0 <bSendUART128v2+0x1f4>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	bSuccessL = TRUE;
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110ccc8:	e0bffb03 	ldbu	r2,-20(fp)
8110cccc:	10800044 	addi	r2,r2,1
8110ccd0:	e0bffb05 	stb	r2,-20(fp)
8110ccd4:	e0bffb03 	ldbu	r2,-20(fp)
8110ccd8:	108000b0 	cmpltui	r2,r2,2
8110ccdc:	103fba1e 	bne	r2,zero,8110cbc8 <__reset+0xfb0ecbc8>
			xBuffer128[ucIL].bSent = FALSE;
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}
	SemCount128--; /* Sure that you get the semaphore */
8110cce0:	d0a05d43 	ldbu	r2,-32395(gp)
8110cce4:	10bfffc4 	addi	r2,r2,-1
8110cce8:	d0a05d45 	stb	r2,-32395(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8110ccec:	d0a05c17 	ldw	r2,-32400(gp)
8110ccf0:	e0fffd04 	addi	r3,fp,-12
8110ccf4:	180d883a 	mov	r6,r3
8110ccf8:	01400084 	movi	r5,2
8110ccfc:	1009883a 	mov	r4,r2
8110cd00:	112da5c0 	call	8112da5c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110cd04:	e0bffd03 	ldbu	r2,-12(fp)
8110cd08:	10803fcc 	andi	r2,r2,255
8110cd0c:	10000c26 	beq	r2,zero,8110cd40 <bSendUART128v2+0x254>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
8110cd10:	d0a04e17 	ldw	r2,-32456(gp)
8110cd14:	100f883a 	mov	r7,r2
8110cd18:	01801c04 	movi	r6,112
8110cd1c:	01400044 	movi	r5,1
8110cd20:	01204534 	movhi	r4,33044
8110cd24:	21377f04 	addi	r4,r4,-8708
8110cd28:	1112ccc0 	call	81112ccc <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8110cd2c:	d0a05817 	ldw	r2,-32416(gp)
8110cd30:	1009883a 	mov	r4,r2
8110cd34:	112e0000 	call	8112e000 <OSMutexPost>
		return bSuccessL;
8110cd38:	e0bffc17 	ldw	r2,-16(fp)
8110cd3c:	00001606 	br	8110cd98 <bSendUART128v2+0x2ac>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
8110cd40:	e0bffb03 	ldbu	r2,-20(fp)
8110cd44:	10c02324 	muli	r3,r2,140
8110cd48:	00a04574 	movhi	r2,33045
8110cd4c:	10ba7a04 	addi	r2,r2,-5656
8110cd50:	1885883a 	add	r2,r3,r2
8110cd54:	1009883a 	mov	r4,r2
8110cd58:	1113b040 	call	81113b04 <puts>
	xBuffer128[ucIL].bSent = TRUE;
8110cd5c:	e0fffb03 	ldbu	r3,-20(fp)
8110cd60:	00a04574 	movhi	r2,33045
8110cd64:	10ba7a04 	addi	r2,r2,-5656
8110cd68:	18c02324 	muli	r3,r3,140
8110cd6c:	10c5883a 	add	r2,r2,r3
8110cd70:	10802004 	addi	r2,r2,128
8110cd74:	00c00044 	movi	r3,1
8110cd78:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
8110cd7c:	d0a05c17 	ldw	r2,-32400(gp)
8110cd80:	1009883a 	mov	r4,r2
8110cd84:	112e0000 	call	8112e000 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
8110cd88:	d0a05817 	ldw	r2,-32416(gp)
8110cd8c:	1009883a 	mov	r4,r2
8110cd90:	112e0000 	call	8112e000 <OSMutexPost>

	return bSuccessL;
8110cd94:	e0bffc17 	ldw	r2,-16(fp)
}
8110cd98:	e037883a 	mov	sp,fp
8110cd9c:	dfc00117 	ldw	ra,4(sp)
8110cda0:	df000017 	ldw	fp,0(sp)
8110cda4:	dec00204 	addi	sp,sp,8
8110cda8:	f800283a 	ret

8110cdac <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
8110cdac:	defff904 	addi	sp,sp,-28
8110cdb0:	de00012e 	bgeu	sp,et,8110cdb8 <bSendUART64v2+0xc>
8110cdb4:	003b68fa 	trap	3
8110cdb8:	dfc00615 	stw	ra,24(sp)
8110cdbc:	df000515 	stw	fp,20(sp)
8110cdc0:	df000504 	addi	fp,sp,20
8110cdc4:	e13ffe15 	stw	r4,-8(fp)
8110cdc8:	2805883a 	mov	r2,r5
8110cdcc:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
8110cdd0:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8110cdd4:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8110cdd8:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8110cddc:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8110cde0:	d0a04b17 	ldw	r2,-32468(gp)
8110cde4:	e0fffd04 	addi	r3,fp,-12
8110cde8:	180d883a 	mov	r6,r3
8110cdec:	01400a04 	movi	r5,40
8110cdf0:	1009883a 	mov	r4,r2
8110cdf4:	112fa680 	call	8112fa68 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8110cdf8:	e0bffd03 	ldbu	r2,-12(fp)
8110cdfc:	10803fcc 	andi	r2,r2,255
8110ce00:	10000326 	beq	r2,zero,8110ce10 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8110ce04:	110f2580 	call	8110f258 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
8110ce08:	e0bffc17 	ldw	r2,-16(fp)
8110ce0c:	00009406 	br	8110d060 <bSendUART64v2+0x2b4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8110ce10:	d0a05a17 	ldw	r2,-32408(gp)
8110ce14:	e0fffd04 	addi	r3,fp,-12
8110ce18:	180d883a 	mov	r6,r3
8110ce1c:	01400104 	movi	r5,4
8110ce20:	1009883a 	mov	r4,r2
8110ce24:	112da5c0 	call	8112da5c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110ce28:	e0bffd03 	ldbu	r2,-12(fp)
8110ce2c:	10803fcc 	andi	r2,r2,255
8110ce30:	10001126 	beq	r2,zero,8110ce78 <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
8110ce34:	d0a04e17 	ldw	r2,-32456(gp)
8110ce38:	100f883a 	mov	r7,r2
8110ce3c:	018013c4 	movi	r6,79
8110ce40:	01400044 	movi	r5,1
8110ce44:	01204534 	movhi	r4,33044
8110ce48:	21379c04 	addi	r4,r4,-8592
8110ce4c:	1112ccc0 	call	81112ccc <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
8110ce50:	d0a04b17 	ldw	r2,-32468(gp)
8110ce54:	1009883a 	mov	r4,r2
8110ce58:	112fdf00 	call	8112fdf0 <OSSemPost>
8110ce5c:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8110ce60:	e0bffd03 	ldbu	r2,-12(fp)
8110ce64:	10803fcc 	andi	r2,r2,255
8110ce68:	10000126 	beq	r2,zero,8110ce70 <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8110ce6c:	110f1200 	call	8110f120 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
8110ce70:	e0bffc17 	ldw	r2,-16(fp)
8110ce74:	00007a06 	br	8110d060 <bSendUART64v2+0x2b4>
	}
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */

	bSuccessL = TRUE;
8110ce78:	00800044 	movi	r2,1
8110ce7c:	e0bffc15 	stw	r2,-16(fp)
	for( ucIL = 0; ucIL < N_64; ucIL++)
8110ce80:	e03ffb05 	stb	zero,-20(fp)
8110ce84:	00004506 	br	8110cf9c <bSendUART64v2+0x1f0>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
8110ce88:	e0fffb03 	ldbu	r3,-20(fp)
8110ce8c:	00a04574 	movhi	r2,33045
8110ce90:	10ba6c04 	addi	r2,r2,-5712
8110ce94:	18c00084 	addi	r3,r3,2
8110ce98:	18c7883a 	add	r3,r3,r3
8110ce9c:	18c7883a 	add	r3,r3,r3
8110cea0:	10c5883a 	add	r2,r2,r3
8110cea4:	10800017 	ldw	r2,0(r2)
8110cea8:	1000391e 	bne	r2,zero,8110cf90 <bSendUART64v2+0x1e4>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
8110ceac:	e0bffb03 	ldbu	r2,-20(fp)
8110ceb0:	10c01324 	muli	r3,r2,76
8110ceb4:	00a04534 	movhi	r2,33044
8110ceb8:	1090b104 	addi	r2,r2,17092
8110cebc:	1885883a 	add	r2,r3,r2
8110cec0:	01801004 	movi	r6,64
8110cec4:	000b883a 	mov	r5,zero
8110cec8:	1009883a 	mov	r4,r2
8110cecc:	11138300 	call	81113830 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
8110ced0:	e0bffb03 	ldbu	r2,-20(fp)
8110ced4:	10c01324 	muli	r3,r2,76
8110ced8:	00a04534 	movhi	r2,33044
8110cedc:	1090b104 	addi	r2,r2,17092
8110cee0:	1885883a 	add	r2,r3,r2
8110cee4:	01800fc4 	movi	r6,63
8110cee8:	e17ffe17 	ldw	r5,-8(fp)
8110ceec:	1009883a 	mov	r4,r2
8110cef0:	11136e00 	call	811136e0 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
8110cef4:	e13ffb03 	ldbu	r4,-20(fp)
8110cef8:	e0ffff0b 	ldhu	r3,-4(fp)
8110cefc:	00a04534 	movhi	r2,33044
8110cf00:	1090b104 	addi	r2,r2,17092
8110cf04:	21001324 	muli	r4,r4,76
8110cf08:	1105883a 	add	r2,r2,r4
8110cf0c:	10801104 	addi	r2,r2,68
8110cf10:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
8110cf14:	e0fffb03 	ldbu	r3,-20(fp)
8110cf18:	00a04534 	movhi	r2,33044
8110cf1c:	1090b104 	addi	r2,r2,17092
8110cf20:	18c01324 	muli	r3,r3,76
8110cf24:	10c5883a 	add	r2,r2,r3
8110cf28:	10801204 	addi	r2,r2,72
8110cf2c:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
8110cf30:	e0fffb03 	ldbu	r3,-20(fp)
8110cf34:	00a04534 	movhi	r2,33044
8110cf38:	1090b104 	addi	r2,r2,17092
8110cf3c:	18c01324 	muli	r3,r3,76
8110cf40:	10c5883a 	add	r2,r2,r3
8110cf44:	10801184 	addi	r2,r2,70
8110cf48:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
8110cf4c:	e0fffb03 	ldbu	r3,-20(fp)
8110cf50:	00a04534 	movhi	r2,33044
8110cf54:	1090b104 	addi	r2,r2,17092
8110cf58:	18c01324 	muli	r3,r3,76
8110cf5c:	10c5883a 	add	r2,r2,r3
8110cf60:	10801004 	addi	r2,r2,64
8110cf64:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
8110cf68:	e0fffb03 	ldbu	r3,-20(fp)
8110cf6c:	00a04574 	movhi	r2,33045
8110cf70:	10ba6c04 	addi	r2,r2,-5712
8110cf74:	18c00084 	addi	r3,r3,2
8110cf78:	18c7883a 	add	r3,r3,r3
8110cf7c:	18c7883a 	add	r3,r3,r3
8110cf80:	10c5883a 	add	r2,r2,r3
8110cf84:	00c00044 	movi	r3,1
8110cf88:	10c00015 	stw	r3,0(r2)
			break;
8110cf8c:	00000606 	br	8110cfa8 <bSendUART64v2+0x1fc>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */

	bSuccessL = TRUE;
	for( ucIL = 0; ucIL < N_64; ucIL++)
8110cf90:	e0bffb03 	ldbu	r2,-20(fp)
8110cf94:	10800044 	addi	r2,r2,1
8110cf98:	e0bffb05 	stb	r2,-20(fp)
8110cf9c:	e0bffb03 	ldbu	r2,-20(fp)
8110cfa0:	10800130 	cmpltui	r2,r2,4
8110cfa4:	103fb81e 	bne	r2,zero,8110ce88 <__reset+0xfb0ece88>
			xBuffer64[ucIL].bSent = FALSE;
			xInUseRetrans.b64[ucIL] = TRUE;
			break;
		}
	}
	SemCount64--; /* Sure that you get the semaphore */
8110cfa8:	d0a05d03 	ldbu	r2,-32396(gp)
8110cfac:	10bfffc4 	addi	r2,r2,-1
8110cfb0:	d0a05d05 	stb	r2,-32396(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8110cfb4:	d0a05c17 	ldw	r2,-32400(gp)
8110cfb8:	e0fffd04 	addi	r3,fp,-12
8110cfbc:	180d883a 	mov	r6,r3
8110cfc0:	01400084 	movi	r5,2
8110cfc4:	1009883a 	mov	r4,r2
8110cfc8:	112da5c0 	call	8112da5c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110cfcc:	e0bffd03 	ldbu	r2,-12(fp)
8110cfd0:	10803fcc 	andi	r2,r2,255
8110cfd4:	10000c26 	beq	r2,zero,8110d008 <bSendUART64v2+0x25c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
8110cfd8:	d0a04e17 	ldw	r2,-32456(gp)
8110cfdc:	100f883a 	mov	r7,r2
8110cfe0:	01801bc4 	movi	r6,111
8110cfe4:	01400044 	movi	r5,1
8110cfe8:	01204534 	movhi	r4,33044
8110cfec:	2137b004 	addi	r4,r4,-8512
8110cff0:	1112ccc0 	call	81112ccc <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
8110cff4:	d0a05a17 	ldw	r2,-32408(gp)
8110cff8:	1009883a 	mov	r4,r2
8110cffc:	112e0000 	call	8112e000 <OSMutexPost>
		return bSuccessL;
8110d000:	e0bffc17 	ldw	r2,-16(fp)
8110d004:	00001606 	br	8110d060 <bSendUART64v2+0x2b4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
8110d008:	e0bffb03 	ldbu	r2,-20(fp)
8110d00c:	10c01324 	muli	r3,r2,76
8110d010:	00a04534 	movhi	r2,33044
8110d014:	1090b104 	addi	r2,r2,17092
8110d018:	1885883a 	add	r2,r3,r2
8110d01c:	1009883a 	mov	r4,r2
8110d020:	1113b040 	call	81113b04 <puts>
	xBuffer64[ucIL].bSent = TRUE;
8110d024:	e0fffb03 	ldbu	r3,-20(fp)
8110d028:	00a04534 	movhi	r2,33044
8110d02c:	1090b104 	addi	r2,r2,17092
8110d030:	18c01324 	muli	r3,r3,76
8110d034:	10c5883a 	add	r2,r2,r3
8110d038:	10801004 	addi	r2,r2,64
8110d03c:	00c00044 	movi	r3,1
8110d040:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
8110d044:	d0a05c17 	ldw	r2,-32400(gp)
8110d048:	1009883a 	mov	r4,r2
8110d04c:	112e0000 	call	8112e000 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
8110d050:	d0a05a17 	ldw	r2,-32408(gp)
8110d054:	1009883a 	mov	r4,r2
8110d058:	112e0000 	call	8112e000 <OSMutexPost>

	return bSuccessL;
8110d05c:	e0bffc17 	ldw	r2,-16(fp)
}
8110d060:	e037883a 	mov	sp,fp
8110d064:	dfc00117 	ldw	ra,4(sp)
8110d068:	df000017 	ldw	fp,0(sp)
8110d06c:	dec00204 	addi	sp,sp,8
8110d070:	f800283a 	ret

8110d074 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
8110d074:	defff904 	addi	sp,sp,-28
8110d078:	de00012e 	bgeu	sp,et,8110d080 <bSendUART32v2+0xc>
8110d07c:	003b68fa 	trap	3
8110d080:	dfc00615 	stw	ra,24(sp)
8110d084:	df000515 	stw	fp,20(sp)
8110d088:	df000504 	addi	fp,sp,20
8110d08c:	e13ffe15 	stw	r4,-8(fp)
8110d090:	2805883a 	mov	r2,r5
8110d094:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
8110d098:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8110d09c:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8110d0a0:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8110d0a4:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8110d0a8:	d0a05917 	ldw	r2,-32412(gp)
8110d0ac:	e0fffd04 	addi	r3,fp,-12
8110d0b0:	180d883a 	mov	r6,r3
8110d0b4:	01400a04 	movi	r5,40
8110d0b8:	1009883a 	mov	r4,r2
8110d0bc:	112fa680 	call	8112fa68 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8110d0c0:	e0bffd03 	ldbu	r2,-12(fp)
8110d0c4:	10803fcc 	andi	r2,r2,255
8110d0c8:	10000326 	beq	r2,zero,8110d0d8 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8110d0cc:	110f2c00 	call	8110f2c0 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
8110d0d0:	e0bffc17 	ldw	r2,-16(fp)
8110d0d4:	00009406 	br	8110d328 <bSendUART32v2+0x2b4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8110d0d8:	d0a05617 	ldw	r2,-32424(gp)
8110d0dc:	e0fffd04 	addi	r3,fp,-12
8110d0e0:	180d883a 	mov	r6,r3
8110d0e4:	01400104 	movi	r5,4
8110d0e8:	1009883a 	mov	r4,r2
8110d0ec:	112da5c0 	call	8112da5c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110d0f0:	e0bffd03 	ldbu	r2,-12(fp)
8110d0f4:	10803fcc 	andi	r2,r2,255
8110d0f8:	10001126 	beq	r2,zero,8110d140 <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer64. (bSendUART32v2)\n");
8110d0fc:	d0a04e17 	ldw	r2,-32456(gp)
8110d100:	100f883a 	mov	r7,r2
8110d104:	018013c4 	movi	r6,79
8110d108:	01400044 	movi	r5,1
8110d10c:	01204534 	movhi	r4,33044
8110d110:	2137cc04 	addi	r4,r4,-8400
8110d114:	1112ccc0 	call	81112ccc <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
8110d118:	d0a05917 	ldw	r2,-32412(gp)
8110d11c:	1009883a 	mov	r4,r2
8110d120:	112fdf00 	call	8112fdf0 <OSSemPost>
8110d124:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8110d128:	e0bffd03 	ldbu	r2,-12(fp)
8110d12c:	10803fcc 	andi	r2,r2,255
8110d130:	10000126 	beq	r2,zero,8110d138 <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8110d134:	110f0b80 	call	8110f0b8 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
8110d138:	e0bffc17 	ldw	r2,-16(fp)
8110d13c:	00007a06 	br	8110d328 <bSendUART32v2+0x2b4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	bSuccessL = TRUE;
8110d140:	00800044 	movi	r2,1
8110d144:	e0bffc15 	stw	r2,-16(fp)
	for( ucIL = 0; ucIL < N_32; ucIL++)
8110d148:	e03ffb05 	stb	zero,-20(fp)
8110d14c:	00004506 	br	8110d264 <bSendUART32v2+0x1f0>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
8110d150:	e0fffb03 	ldbu	r3,-20(fp)
8110d154:	00a04574 	movhi	r2,33045
8110d158:	10ba6c04 	addi	r2,r2,-5712
8110d15c:	18c00184 	addi	r3,r3,6
8110d160:	18c7883a 	add	r3,r3,r3
8110d164:	18c7883a 	add	r3,r3,r3
8110d168:	10c5883a 	add	r2,r2,r3
8110d16c:	10800017 	ldw	r2,0(r2)
8110d170:	1000391e 	bne	r2,zero,8110d258 <bSendUART32v2+0x1e4>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
8110d174:	e0bffb03 	ldbu	r2,-20(fp)
8110d178:	10c00b24 	muli	r3,r2,44
8110d17c:	00a04574 	movhi	r2,33045
8110d180:	10a21404 	addi	r2,r2,-30640
8110d184:	1885883a 	add	r2,r3,r2
8110d188:	01800804 	movi	r6,32
8110d18c:	000b883a 	mov	r5,zero
8110d190:	1009883a 	mov	r4,r2
8110d194:	11138300 	call	81113830 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
8110d198:	e0bffb03 	ldbu	r2,-20(fp)
8110d19c:	10c00b24 	muli	r3,r2,44
8110d1a0:	00a04574 	movhi	r2,33045
8110d1a4:	10a21404 	addi	r2,r2,-30640
8110d1a8:	1885883a 	add	r2,r3,r2
8110d1ac:	018007c4 	movi	r6,31
8110d1b0:	e17ffe17 	ldw	r5,-8(fp)
8110d1b4:	1009883a 	mov	r4,r2
8110d1b8:	11136e00 	call	811136e0 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
8110d1bc:	e13ffb03 	ldbu	r4,-20(fp)
8110d1c0:	e0ffff0b 	ldhu	r3,-4(fp)
8110d1c4:	00a04574 	movhi	r2,33045
8110d1c8:	10a21404 	addi	r2,r2,-30640
8110d1cc:	21000b24 	muli	r4,r4,44
8110d1d0:	1105883a 	add	r2,r2,r4
8110d1d4:	10800904 	addi	r2,r2,36
8110d1d8:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
8110d1dc:	e0fffb03 	ldbu	r3,-20(fp)
8110d1e0:	00a04574 	movhi	r2,33045
8110d1e4:	10a21404 	addi	r2,r2,-30640
8110d1e8:	18c00b24 	muli	r3,r3,44
8110d1ec:	10c5883a 	add	r2,r2,r3
8110d1f0:	10800a04 	addi	r2,r2,40
8110d1f4:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
8110d1f8:	e0fffb03 	ldbu	r3,-20(fp)
8110d1fc:	00a04574 	movhi	r2,33045
8110d200:	10a21404 	addi	r2,r2,-30640
8110d204:	18c00b24 	muli	r3,r3,44
8110d208:	10c5883a 	add	r2,r2,r3
8110d20c:	10800984 	addi	r2,r2,38
8110d210:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
8110d214:	e0fffb03 	ldbu	r3,-20(fp)
8110d218:	00a04574 	movhi	r2,33045
8110d21c:	10a21404 	addi	r2,r2,-30640
8110d220:	18c00b24 	muli	r3,r3,44
8110d224:	10c5883a 	add	r2,r2,r3
8110d228:	10800804 	addi	r2,r2,32
8110d22c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
8110d230:	e0fffb03 	ldbu	r3,-20(fp)
8110d234:	00a04574 	movhi	r2,33045
8110d238:	10ba6c04 	addi	r2,r2,-5712
8110d23c:	18c00184 	addi	r3,r3,6
8110d240:	18c7883a 	add	r3,r3,r3
8110d244:	18c7883a 	add	r3,r3,r3
8110d248:	10c5883a 	add	r2,r2,r3
8110d24c:	00c00044 	movi	r3,1
8110d250:	10c00015 	stw	r3,0(r2)
			break;
8110d254:	00000606 	br	8110d270 <bSendUART32v2+0x1fc>

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	bSuccessL = TRUE;
	for( ucIL = 0; ucIL < N_32; ucIL++)
8110d258:	e0bffb03 	ldbu	r2,-20(fp)
8110d25c:	10800044 	addi	r2,r2,1
8110d260:	e0bffb05 	stb	r2,-20(fp)
8110d264:	e0bffb03 	ldbu	r2,-20(fp)
8110d268:	10800230 	cmpltui	r2,r2,8
8110d26c:	103fb81e 	bne	r2,zero,8110d150 <__reset+0xfb0ed150>
			xBuffer32[ucIL].bSent = FALSE;
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	
	SemCount32--; /* Sure that you get the semaphore */
8110d270:	d0a05483 	ldbu	r2,-32430(gp)
8110d274:	10bfffc4 	addi	r2,r2,-1
8110d278:	d0a05485 	stb	r2,-32430(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8110d27c:	d0a05c17 	ldw	r2,-32400(gp)
8110d280:	e0fffd04 	addi	r3,fp,-12
8110d284:	180d883a 	mov	r6,r3
8110d288:	01400084 	movi	r5,2
8110d28c:	1009883a 	mov	r4,r2
8110d290:	112da5c0 	call	8112da5c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8110d294:	e0bffd03 	ldbu	r2,-12(fp)
8110d298:	10803fcc 	andi	r2,r2,255
8110d29c:	10000c26 	beq	r2,zero,8110d2d0 <bSendUART32v2+0x25c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
8110d2a0:	d0a04e17 	ldw	r2,-32456(gp)
8110d2a4:	100f883a 	mov	r7,r2
8110d2a8:	01801bc4 	movi	r6,111
8110d2ac:	01400044 	movi	r5,1
8110d2b0:	01204534 	movhi	r4,33044
8110d2b4:	2137e004 	addi	r4,r4,-8320
8110d2b8:	1112ccc0 	call	81112ccc <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xBuffer64 */
8110d2bc:	d0a05617 	ldw	r2,-32424(gp)
8110d2c0:	1009883a 	mov	r4,r2
8110d2c4:	112e0000 	call	8112e000 <OSMutexPost>
		return bSuccessL;
8110d2c8:	e0bffc17 	ldw	r2,-16(fp)
8110d2cc:	00001606 	br	8110d328 <bSendUART32v2+0x2b4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
8110d2d0:	e0bffb03 	ldbu	r2,-20(fp)
8110d2d4:	10c00b24 	muli	r3,r2,44
8110d2d8:	00a04574 	movhi	r2,33045
8110d2dc:	10a21404 	addi	r2,r2,-30640
8110d2e0:	1885883a 	add	r2,r3,r2
8110d2e4:	1009883a 	mov	r4,r2
8110d2e8:	1113b040 	call	81113b04 <puts>
	xBuffer32[ucIL].bSent = TRUE;
8110d2ec:	e0fffb03 	ldbu	r3,-20(fp)
8110d2f0:	00a04574 	movhi	r2,33045
8110d2f4:	10a21404 	addi	r2,r2,-30640
8110d2f8:	18c00b24 	muli	r3,r3,44
8110d2fc:	10c5883a 	add	r2,r2,r3
8110d300:	10800804 	addi	r2,r2,32
8110d304:	00c00044 	movi	r3,1
8110d308:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
8110d30c:	d0a05c17 	ldw	r2,-32400(gp)
8110d310:	1009883a 	mov	r4,r2
8110d314:	112e0000 	call	8112e000 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
8110d318:	d0a05617 	ldw	r2,-32424(gp)
8110d31c:	1009883a 	mov	r4,r2
8110d320:	112e0000 	call	8112e000 <OSMutexPost>

	return bSuccessL;
8110d324:	e0bffc17 	ldw	r2,-16(fp)
}
8110d328:	e037883a 	mov	sp,fp
8110d32c:	dfc00117 	ldw	ra,4(sp)
8110d330:	df000017 	ldw	fp,0(sp)
8110d334:	dec00204 	addi	sp,sp,8
8110d338:	f800283a 	ret

8110d33c <vSendEthConf>:


void vSendEthConf ( void ) {
8110d33c:	deffc304 	addi	sp,sp,-244
8110d340:	de00012e 	bgeu	sp,et,8110d348 <vSendEthConf+0xc>
8110d344:	003b68fa 	trap	3
8110d348:	dfc03c15 	stw	ra,240(sp)
8110d34c:	df003b15 	stw	fp,236(sp)
8110d350:	dd403a15 	stw	r21,232(sp)
8110d354:	dd003915 	stw	r20,228(sp)
8110d358:	dcc03815 	stw	r19,224(sp)
8110d35c:	dc803715 	stw	r18,220(sp)
8110d360:	dc403615 	stw	r17,216(sp)
8110d364:	dc003515 	stw	r16,212(sp)
8110d368:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
8110d36c:	e03fd98d 	sth	zero,-154(fp)
8110d370:	e03fda0d 	sth	zero,-152(fp)
8110d374:	e0bfda84 	addi	r2,fp,-150
8110d378:	00c01f04 	movi	r3,124
8110d37c:	180d883a 	mov	r6,r3
8110d380:	000b883a 	mov	r5,zero
8110d384:	1009883a 	mov	r4,r2
8110d388:	11138300 	call	81113830 <memset>
    unsigned char crc = 0;
8110d38c:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8110d390:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110d394:	110d7e40 	call	8110d7e4 <usiGetIdCMD>
8110d398:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d39c:	e57fd90b 	ldhu	r21,-156(fp)
8110d3a0:	00a04574 	movhi	r2,33045
8110d3a4:	10831404 	addi	r2,r2,3152
8110d3a8:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8110d3ac:	00a04574 	movhi	r2,33045
8110d3b0:	10831404 	addi	r2,r2,3152
8110d3b4:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d3b8:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8110d3bc:	00a04574 	movhi	r2,33045
8110d3c0:	10831404 	addi	r2,r2,3152
8110d3c4:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d3c8:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8110d3cc:	00a04574 	movhi	r2,33045
8110d3d0:	10831404 	addi	r2,r2,3152
8110d3d4:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d3d8:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8110d3dc:	00a04574 	movhi	r2,33045
8110d3e0:	10831404 	addi	r2,r2,3152
8110d3e4:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d3e8:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8110d3ec:	00a04574 	movhi	r2,33045
8110d3f0:	10831404 	addi	r2,r2,3152
8110d3f4:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d3f8:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8110d3fc:	00a04574 	movhi	r2,33045
8110d400:	10831404 	addi	r2,r2,3152
8110d404:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d408:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8110d40c:	00a04574 	movhi	r2,33045
8110d410:	10831404 	addi	r2,r2,3152
8110d414:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d418:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8110d41c:	00a04574 	movhi	r2,33045
8110d420:	10831404 	addi	r2,r2,3152
8110d424:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d428:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8110d42c:	00a04574 	movhi	r2,33045
8110d430:	10831404 	addi	r2,r2,3152
8110d434:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d438:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8110d43c:	00a04574 	movhi	r2,33045
8110d440:	10831404 	addi	r2,r2,3152
8110d444:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d448:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8110d44c:	00a04574 	movhi	r2,33045
8110d450:	10831404 	addi	r2,r2,3152
8110d454:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d458:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8110d45c:	00a04574 	movhi	r2,33045
8110d460:	10831404 	addi	r2,r2,3152
8110d464:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d468:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8110d46c:	00a04574 	movhi	r2,33045
8110d470:	10831404 	addi	r2,r2,3152
8110d474:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d478:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8110d47c:	00a04574 	movhi	r2,33045
8110d480:	10831404 	addi	r2,r2,3152
8110d484:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d488:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8110d48c:	00a04574 	movhi	r2,33045
8110d490:	10831404 	addi	r2,r2,3152
8110d494:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d498:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8110d49c:	00a04574 	movhi	r2,33045
8110d4a0:	10831404 	addi	r2,r2,3152
8110d4a4:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d4a8:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
8110d4ac:	00a04574 	movhi	r2,33045
8110d4b0:	10831404 	addi	r2,r2,3152
8110d4b4:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8110d4b8:	10bfffcc 	andi	r2,r2,65535
8110d4bc:	e53fd984 	addi	r20,fp,-154
8110d4c0:	d8801115 	stw	r2,68(sp)
8110d4c4:	dcc01015 	stw	r19,64(sp)
8110d4c8:	dc800f15 	stw	r18,60(sp)
8110d4cc:	dc400e15 	stw	r17,56(sp)
8110d4d0:	dc000d15 	stw	r16,52(sp)
8110d4d4:	dbc00c15 	stw	r15,48(sp)
8110d4d8:	db800b15 	stw	r14,44(sp)
8110d4dc:	db400a15 	stw	r13,40(sp)
8110d4e0:	db000915 	stw	r12,36(sp)
8110d4e4:	dac00815 	stw	r11,32(sp)
8110d4e8:	da800715 	stw	r10,28(sp)
8110d4ec:	da400615 	stw	r9,24(sp)
8110d4f0:	da000515 	stw	r8,20(sp)
8110d4f4:	d9c00415 	stw	r7,16(sp)
8110d4f8:	d9800315 	stw	r6,12(sp)
8110d4fc:	d9400215 	stw	r5,8(sp)
8110d500:	d9000115 	stw	r4,4(sp)
8110d504:	d8c00015 	stw	r3,0(sp)
8110d508:	a80f883a 	mov	r7,r21
8110d50c:	018010c4 	movi	r6,67
8110d510:	01604534 	movhi	r5,33044
8110d514:	2977fc04 	addi	r5,r5,-8208
8110d518:	a009883a 	mov	r4,r20
8110d51c:	1113e480 	call	81113e48 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
8110d520:	e0bfd984 	addi	r2,fp,-154
8110d524:	1009883a 	mov	r4,r2
8110d528:	111405c0 	call	8111405c <strlen>
8110d52c:	1007883a 	mov	r3,r2
8110d530:	e0bfd984 	addi	r2,fp,-154
8110d534:	180b883a 	mov	r5,r3
8110d538:	1009883a 	mov	r4,r2
8110d53c:	110ea0c0 	call	8110ea0c <ucCrc8wInit>
8110d540:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
8110d544:	e13fd703 	ldbu	r4,-164(fp)
8110d548:	e0ffd984 	addi	r3,fp,-154
8110d54c:	e0bfd984 	addi	r2,fp,-154
8110d550:	200f883a 	mov	r7,r4
8110d554:	180d883a 	mov	r6,r3
8110d558:	01604534 	movhi	r5,33044
8110d55c:	29781404 	addi	r5,r5,-8112
8110d560:	1009883a 	mov	r4,r2
8110d564:	1113e480 	call	81113e48 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
8110d568:	e0bfd90b 	ldhu	r2,-156(fp)
8110d56c:	10ffffcc 	andi	r3,r2,65535
8110d570:	18e0001c 	xori	r3,r3,32768
8110d574:	18e00004 	addi	r3,r3,-32768
8110d578:	e0bfd984 	addi	r2,fp,-154
8110d57c:	180b883a 	mov	r5,r3
8110d580:	1009883a 	mov	r4,r2
8110d584:	110caec0 	call	8110caec <bSendUART128v2>
8110d588:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
8110d58c:	e0bfd817 	ldw	r2,-160(fp)
8110d590:	10800060 	cmpeqi	r2,r2,1
8110d594:	1000011e 	bne	r2,zero,8110d59c <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
8110d598:	110f4c80 	call	8110f4c8 <vCouldNotSendEthConfUART>
	}
}
8110d59c:	0001883a 	nop
8110d5a0:	e6fffa04 	addi	sp,fp,-24
8110d5a4:	dfc00717 	ldw	ra,28(sp)
8110d5a8:	df000617 	ldw	fp,24(sp)
8110d5ac:	dd400517 	ldw	r21,20(sp)
8110d5b0:	dd000417 	ldw	r20,16(sp)
8110d5b4:	dcc00317 	ldw	r19,12(sp)
8110d5b8:	dc800217 	ldw	r18,8(sp)
8110d5bc:	dc400117 	ldw	r17,4(sp)
8110d5c0:	dc000017 	ldw	r16,0(sp)
8110d5c4:	dec00804 	addi	sp,sp,32
8110d5c8:	f800283a 	ret

8110d5cc <vSendTurnOff>:


void vSendTurnOff ( void ) {
8110d5cc:	defff304 	addi	sp,sp,-52
8110d5d0:	de00012e 	bgeu	sp,et,8110d5d8 <vSendTurnOff+0xc>
8110d5d4:	003b68fa 	trap	3
8110d5d8:	dfc00c15 	stw	ra,48(sp)
8110d5dc:	df000b15 	stw	fp,44(sp)
8110d5e0:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8110d5e4:	e03ff78d 	sth	zero,-34(fp)
8110d5e8:	e03ff80d 	sth	zero,-32(fp)
8110d5ec:	e03ff88d 	sth	zero,-30(fp)
8110d5f0:	e03ff90d 	sth	zero,-28(fp)
8110d5f4:	e03ff98d 	sth	zero,-26(fp)
8110d5f8:	e03ffa0d 	sth	zero,-24(fp)
8110d5fc:	e03ffa8d 	sth	zero,-22(fp)
8110d600:	e03ffb0d 	sth	zero,-20(fp)
8110d604:	e03ffb8d 	sth	zero,-18(fp)
8110d608:	e03ffc0d 	sth	zero,-16(fp)
8110d60c:	e03ffc8d 	sth	zero,-14(fp)
8110d610:	e03ffd0d 	sth	zero,-12(fp)
8110d614:	e03ffd8d 	sth	zero,-10(fp)
8110d618:	e03ffe0d 	sth	zero,-8(fp)
8110d61c:	e03ffe8d 	sth	zero,-6(fp)
8110d620:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8110d624:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8110d628:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110d62c:	110d7e40 	call	8110d7e4 <usiGetIdCMD>
8110d630:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
8110d634:	e0fff70b 	ldhu	r3,-36(fp)
8110d638:	e0bff784 	addi	r2,fp,-34
8110d63c:	180d883a 	mov	r6,r3
8110d640:	01604534 	movhi	r5,33044
8110d644:	29781704 	addi	r5,r5,-8100
8110d648:	1009883a 	mov	r4,r2
8110d64c:	1113e480 	call	81113e48 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8110d650:	e0bff784 	addi	r2,fp,-34
8110d654:	1009883a 	mov	r4,r2
8110d658:	111405c0 	call	8111405c <strlen>
8110d65c:	1007883a 	mov	r3,r2
8110d660:	e0bff784 	addi	r2,fp,-34
8110d664:	180b883a 	mov	r5,r3
8110d668:	1009883a 	mov	r4,r2
8110d66c:	110ea0c0 	call	8110ea0c <ucCrc8wInit>
8110d670:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8110d674:	e13ff503 	ldbu	r4,-44(fp)
8110d678:	e0fff784 	addi	r3,fp,-34
8110d67c:	e0bff784 	addi	r2,fp,-34
8110d680:	200f883a 	mov	r7,r4
8110d684:	180d883a 	mov	r6,r3
8110d688:	01604534 	movhi	r5,33044
8110d68c:	29781404 	addi	r5,r5,-8112
8110d690:	1009883a 	mov	r4,r2
8110d694:	1113e480 	call	81113e48 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8110d698:	e0bff70b 	ldhu	r2,-36(fp)
8110d69c:	10ffffcc 	andi	r3,r2,65535
8110d6a0:	18e0001c 	xori	r3,r3,32768
8110d6a4:	18e00004 	addi	r3,r3,-32768
8110d6a8:	e0bff784 	addi	r2,fp,-34
8110d6ac:	180b883a 	mov	r5,r3
8110d6b0:	1009883a 	mov	r4,r2
8110d6b4:	110d0740 	call	8110d074 <bSendUART32v2>
8110d6b8:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8110d6bc:	e0bff617 	ldw	r2,-40(fp)
8110d6c0:	10800060 	cmpeqi	r2,r2,1
8110d6c4:	1000011e 	bne	r2,zero,8110d6cc <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8110d6c8:	110fb700 	call	8110fb70 <vCouldNotSendTurnOff>
	}
}
8110d6cc:	0001883a 	nop
8110d6d0:	e037883a 	mov	sp,fp
8110d6d4:	dfc00117 	ldw	ra,4(sp)
8110d6d8:	df000017 	ldw	fp,0(sp)
8110d6dc:	dec00204 	addi	sp,sp,8
8110d6e0:	f800283a 	ret

8110d6e4 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
8110d6e4:	deffda04 	addi	sp,sp,-152
8110d6e8:	de00012e 	bgeu	sp,et,8110d6f0 <vSendLog+0xc>
8110d6ec:	003b68fa 	trap	3
8110d6f0:	dfc02515 	stw	ra,148(sp)
8110d6f4:	df002415 	stw	fp,144(sp)
8110d6f8:	df002404 	addi	fp,sp,144
8110d6fc:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
8110d700:	e03fde8d 	sth	zero,-134(fp)
8110d704:	e03fdf0d 	sth	zero,-132(fp)
8110d708:	e0bfdf84 	addi	r2,fp,-130
8110d70c:	00c01f04 	movi	r3,124
8110d710:	180d883a 	mov	r6,r3
8110d714:	000b883a 	mov	r5,zero
8110d718:	1009883a 	mov	r4,r2
8110d71c:	11138300 	call	81113830 <memset>
    unsigned char crc = 0;
8110d720:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8110d724:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110d728:	110d7e40 	call	8110d7e4 <usiGetIdCMD>
8110d72c:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
8110d730:	e0ffde0b 	ldhu	r3,-136(fp)
8110d734:	e0bfde84 	addi	r2,fp,-134
8110d738:	e1ffff17 	ldw	r7,-4(fp)
8110d73c:	180d883a 	mov	r6,r3
8110d740:	01604534 	movhi	r5,33044
8110d744:	29781904 	addi	r5,r5,-8092
8110d748:	1009883a 	mov	r4,r2
8110d74c:	1113e480 	call	81113e48 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
8110d750:	e0bfde84 	addi	r2,fp,-134
8110d754:	1009883a 	mov	r4,r2
8110d758:	111405c0 	call	8111405c <strlen>
8110d75c:	1007883a 	mov	r3,r2
8110d760:	e0bfde84 	addi	r2,fp,-134
8110d764:	180b883a 	mov	r5,r3
8110d768:	1009883a 	mov	r4,r2
8110d76c:	110ea0c0 	call	8110ea0c <ucCrc8wInit>
8110d770:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
8110d774:	e13fdc03 	ldbu	r4,-144(fp)
8110d778:	e0ffde84 	addi	r3,fp,-134
8110d77c:	e0bfde84 	addi	r2,fp,-134
8110d780:	200f883a 	mov	r7,r4
8110d784:	180d883a 	mov	r6,r3
8110d788:	01604534 	movhi	r5,33044
8110d78c:	29781404 	addi	r5,r5,-8112
8110d790:	1009883a 	mov	r4,r2
8110d794:	1113e480 	call	81113e48 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8110d798:	e0bfde0b 	ldhu	r2,-136(fp)
8110d79c:	10ffffcc 	andi	r3,r2,65535
8110d7a0:	18e0001c 	xori	r3,r3,32768
8110d7a4:	18e00004 	addi	r3,r3,-32768
8110d7a8:	e0bfde84 	addi	r2,fp,-134
8110d7ac:	180b883a 	mov	r5,r3
8110d7b0:	1009883a 	mov	r4,r2
8110d7b4:	110caec0 	call	8110caec <bSendUART128v2>
8110d7b8:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
8110d7bc:	e0bfdd17 	ldw	r2,-140(fp)
8110d7c0:	10800060 	cmpeqi	r2,r2,1
8110d7c4:	1000011e 	bne	r2,zero,8110d7cc <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8110d7c8:	110fbd80 	call	8110fbd8 <vCouldNotSendLog>
	}
}
8110d7cc:	0001883a 	nop
8110d7d0:	e037883a 	mov	sp,fp
8110d7d4:	dfc00117 	ldw	ra,4(sp)
8110d7d8:	df000017 	ldw	fp,0(sp)
8110d7dc:	dec00204 	addi	sp,sp,8
8110d7e0:	f800283a 	ret

8110d7e4 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
8110d7e4:	deffff04 	addi	sp,sp,-4
8110d7e8:	de00012e 	bgeu	sp,et,8110d7f0 <usiGetIdCMD+0xc>
8110d7ec:	003b68fa 	trap	3
8110d7f0:	df000015 	stw	fp,0(sp)
8110d7f4:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
8110d7f8:	d0a0540b 	ldhu	r2,-32432(gp)
8110d7fc:	10ffffcc 	andi	r3,r2,65535
8110d800:	00bfffd4 	movui	r2,65535
8110d804:	1880031e 	bne	r3,r2,8110d814 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
8110d808:	00800084 	movi	r2,2
8110d80c:	d0a0540d 	sth	r2,-32432(gp)
8110d810:	00000306 	br	8110d820 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
8110d814:	d0a0540b 	ldhu	r2,-32432(gp)
8110d818:	10800044 	addi	r2,r2,1
8110d81c:	d0a0540d 	sth	r2,-32432(gp)
    return usiIdCMD;
8110d820:	d0a0540b 	ldhu	r2,-32432(gp)
}
8110d824:	e037883a 	mov	sp,fp
8110d828:	df000017 	ldw	fp,0(sp)
8110d82c:	dec00104 	addi	sp,sp,4
8110d830:	f800283a 	ret

8110d834 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
8110d834:	defffb04 	addi	sp,sp,-20
8110d838:	de00012e 	bgeu	sp,et,8110d840 <siPosStr+0xc>
8110d83c:	003b68fa 	trap	3
8110d840:	dfc00415 	stw	ra,16(sp)
8110d844:	df000315 	stw	fp,12(sp)
8110d848:	df000304 	addi	fp,sp,12
8110d84c:	e13ffe15 	stw	r4,-8(fp)
8110d850:	2805883a 	mov	r2,r5
8110d854:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
8110d858:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
8110d85c:	e0bfff03 	ldbu	r2,-4(fp)
8110d860:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
8110d864:	e17ffd04 	addi	r5,fp,-12
8110d868:	e13ffe17 	ldw	r4,-8(fp)
8110d86c:	11140100 	call	81114010 <strcspn>
}
8110d870:	e037883a 	mov	sp,fp
8110d874:	dfc00117 	ldw	ra,4(sp)
8110d878:	df000017 	ldw	fp,0(sp)
8110d87c:	dec00204 	addi	sp,sp,8
8110d880:	f800283a 	ret

8110d884 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
8110d884:	defffc04 	addi	sp,sp,-16
8110d888:	de00012e 	bgeu	sp,et,8110d890 <vTimeoutCheck+0xc>
8110d88c:	003b68fa 	trap	3
8110d890:	dfc00315 	stw	ra,12(sp)
8110d894:	df000215 	stw	fp,8(sp)
8110d898:	df000204 	addi	fp,sp,8
8110d89c:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
8110d8a0:	d0a05317 	ldw	r2,-32436(gp)
8110d8a4:	1009883a 	mov	r4,r2
8110d8a8:	112fdf00 	call	8112fdf0 <OSSemPost>
8110d8ac:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
8110d8b0:	e0bffe03 	ldbu	r2,-8(fp)
8110d8b4:	10000126 	beq	r2,zero,8110d8bc <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
8110d8b8:	110f9000 	call	8110f900 <vFailPostBlockingSemTimeoutTask>
	}
}
8110d8bc:	0001883a 	nop
8110d8c0:	e037883a 	mov	sp,fp
8110d8c4:	dfc00117 	ldw	ra,4(sp)
8110d8c8:	df000017 	ldw	fp,0(sp)
8110d8cc:	dec00204 	addi	sp,sp,8
8110d8d0:	f800283a 	ret

8110d8d4 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
8110d8d4:	deffe304 	addi	sp,sp,-116
8110d8d8:	de00012e 	bgeu	sp,et,8110d8e0 <vSendPusTM64+0xc>
8110d8dc:	003b68fa 	trap	3
8110d8e0:	dfc01815 	stw	ra,96(sp)
8110d8e4:	df001715 	stw	fp,92(sp)
8110d8e8:	df001704 	addi	fp,sp,92
8110d8ec:	e1000215 	stw	r4,8(fp)
8110d8f0:	e1400315 	stw	r5,12(fp)
8110d8f4:	e1800415 	stw	r6,16(fp)
8110d8f8:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
8110d8fc:	e03fef8d 	sth	zero,-66(fp)
8110d900:	e03ff00d 	sth	zero,-64(fp)
8110d904:	e0bff084 	addi	r2,fp,-62
8110d908:	00c00f04 	movi	r3,60
8110d90c:	180d883a 	mov	r6,r3
8110d910:	000b883a 	mov	r5,zero
8110d914:	1009883a 	mov	r4,r2
8110d918:	11138300 	call	81113830 <memset>
    unsigned char crc = 0;
8110d91c:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
8110d920:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8110d924:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110d928:	110d7e40 	call	8110d7e4 <usiGetIdCMD>
8110d92c:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8110d930:	e1bfef0b 	ldhu	r6,-68(fp)
8110d934:	e080030b 	ldhu	r2,12(fp)
8110d938:	11ffffcc 	andi	r7,r2,65535
8110d93c:	e080038b 	ldhu	r2,14(fp)
8110d940:	10bfffcc 	andi	r2,r2,65535
8110d944:	e0c0040b 	ldhu	r3,16(fp)
8110d948:	18ffffcc 	andi	r3,r3,65535
8110d94c:	e100048b 	ldhu	r4,18(fp)
8110d950:	213fffcc 	andi	r4,r4,65535
8110d954:	e140050b 	ldhu	r5,20(fp)
8110d958:	297fffcc 	andi	r5,r5,65535
8110d95c:	e23fef84 	addi	r8,fp,-66
8110d960:	d9400315 	stw	r5,12(sp)
8110d964:	d9000215 	stw	r4,8(sp)
8110d968:	d8c00115 	stw	r3,4(sp)
8110d96c:	d8800015 	stw	r2,0(sp)
8110d970:	01604534 	movhi	r5,33044
8110d974:	29781c04 	addi	r5,r5,-8080
8110d978:	4009883a 	mov	r4,r8
8110d97c:	1113e480 	call	81113e48 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8110d980:	e03fed05 	stb	zero,-76(fp)
8110d984:	00001206 	br	8110d9d0 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8110d988:	e0bfed03 	ldbu	r2,-76(fp)
8110d98c:	10800204 	addi	r2,r2,8
8110d990:	1085883a 	add	r2,r2,r2
8110d994:	e0c00204 	addi	r3,fp,8
8110d998:	1885883a 	add	r2,r3,r2
8110d99c:	1080000b 	ldhu	r2,0(r2)
8110d9a0:	113fffcc 	andi	r4,r2,65535
8110d9a4:	e0ffef84 	addi	r3,fp,-66
8110d9a8:	e0bfef84 	addi	r2,fp,-66
8110d9ac:	200f883a 	mov	r7,r4
8110d9b0:	180d883a 	mov	r6,r3
8110d9b4:	01604534 	movhi	r5,33044
8110d9b8:	29782304 	addi	r5,r5,-8052
8110d9bc:	1009883a 	mov	r4,r2
8110d9c0:	1113e480 	call	81113e48 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8110d9c4:	e0bfed03 	ldbu	r2,-76(fp)
8110d9c8:	10800044 	addi	r2,r2,1
8110d9cc:	e0bfed05 	stb	r2,-76(fp)
8110d9d0:	e0800583 	ldbu	r2,22(fp)
8110d9d4:	10803fcc 	andi	r2,r2,255
8110d9d8:	e0ffed03 	ldbu	r3,-76(fp)
8110d9dc:	18bfea36 	bltu	r3,r2,8110d988 <__reset+0xfb0ed988>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8110d9e0:	e0bfef84 	addi	r2,fp,-66
8110d9e4:	1009883a 	mov	r4,r2
8110d9e8:	111405c0 	call	8111405c <strlen>
8110d9ec:	1007883a 	mov	r3,r2
8110d9f0:	e0bfef84 	addi	r2,fp,-66
8110d9f4:	180b883a 	mov	r5,r3
8110d9f8:	1009883a 	mov	r4,r2
8110d9fc:	110ea0c0 	call	8110ea0c <ucCrc8wInit>
8110da00:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8110da04:	e13fed43 	ldbu	r4,-75(fp)
8110da08:	e0ffef84 	addi	r3,fp,-66
8110da0c:	e0bfef84 	addi	r2,fp,-66
8110da10:	200f883a 	mov	r7,r4
8110da14:	180d883a 	mov	r6,r3
8110da18:	01604534 	movhi	r5,33044
8110da1c:	29781404 	addi	r5,r5,-8112
8110da20:	1009883a 	mov	r4,r2
8110da24:	1113e480 	call	81113e48 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
8110da28:	e0bfef0b 	ldhu	r2,-68(fp)
8110da2c:	10ffffcc 	andi	r3,r2,65535
8110da30:	18e0001c 	xori	r3,r3,32768
8110da34:	18e00004 	addi	r3,r3,-32768
8110da38:	e0bfef84 	addi	r2,fp,-66
8110da3c:	180b883a 	mov	r5,r3
8110da40:	1009883a 	mov	r4,r2
8110da44:	110cdac0 	call	8110cdac <bSendUART64v2>
8110da48:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
8110da4c:	e0bfee17 	ldw	r2,-72(fp)
8110da50:	10800060 	cmpeqi	r2,r2,1
8110da54:	1000031e 	bne	r2,zero,8110da64 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8110da58:	e0bfef84 	addi	r2,fp,-66
8110da5c:	1009883a 	mov	r4,r2
8110da60:	110fc400 	call	8110fc40 <vCouldNotSendTMPusCommand>
	}
}
8110da64:	0001883a 	nop
8110da68:	e037883a 	mov	sp,fp
8110da6c:	dfc00117 	ldw	ra,4(sp)
8110da70:	df000017 	ldw	fp,0(sp)
8110da74:	dec00604 	addi	sp,sp,24
8110da78:	f800283a 	ret

8110da7c <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
8110da7c:	deffd304 	addi	sp,sp,-180
8110da80:	de00012e 	bgeu	sp,et,8110da88 <vSendPusTM128+0xc>
8110da84:	003b68fa 	trap	3
8110da88:	dfc02815 	stw	ra,160(sp)
8110da8c:	df002715 	stw	fp,156(sp)
8110da90:	df002704 	addi	fp,sp,156
8110da94:	e1000215 	stw	r4,8(fp)
8110da98:	e1400315 	stw	r5,12(fp)
8110da9c:	e1800415 	stw	r6,16(fp)
8110daa0:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
8110daa4:	e03fdf8d 	sth	zero,-130(fp)
8110daa8:	e03fe00d 	sth	zero,-128(fp)
8110daac:	e0bfe084 	addi	r2,fp,-126
8110dab0:	00c01f04 	movi	r3,124
8110dab4:	180d883a 	mov	r6,r3
8110dab8:	000b883a 	mov	r5,zero
8110dabc:	1009883a 	mov	r4,r2
8110dac0:	11138300 	call	81113830 <memset>
    unsigned char crc = 0;
8110dac4:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
8110dac8:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
8110dacc:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
8110dad0:	110d7e40 	call	8110d7e4 <usiGetIdCMD>
8110dad4:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8110dad8:	e1bfdf0b 	ldhu	r6,-132(fp)
8110dadc:	e080030b 	ldhu	r2,12(fp)
8110dae0:	11ffffcc 	andi	r7,r2,65535
8110dae4:	e080038b 	ldhu	r2,14(fp)
8110dae8:	10bfffcc 	andi	r2,r2,65535
8110daec:	e0c0040b 	ldhu	r3,16(fp)
8110daf0:	18ffffcc 	andi	r3,r3,65535
8110daf4:	e100048b 	ldhu	r4,18(fp)
8110daf8:	213fffcc 	andi	r4,r4,65535
8110dafc:	e140050b 	ldhu	r5,20(fp)
8110db00:	297fffcc 	andi	r5,r5,65535
8110db04:	e23fdf84 	addi	r8,fp,-130
8110db08:	d9400315 	stw	r5,12(sp)
8110db0c:	d9000215 	stw	r4,8(sp)
8110db10:	d8c00115 	stw	r3,4(sp)
8110db14:	d8800015 	stw	r2,0(sp)
8110db18:	01604534 	movhi	r5,33044
8110db1c:	29781c04 	addi	r5,r5,-8080
8110db20:	4009883a 	mov	r4,r8
8110db24:	1113e480 	call	81113e48 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8110db28:	e03fdd05 	stb	zero,-140(fp)
8110db2c:	00001206 	br	8110db78 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8110db30:	e0bfdd03 	ldbu	r2,-140(fp)
8110db34:	10800204 	addi	r2,r2,8
8110db38:	1085883a 	add	r2,r2,r2
8110db3c:	e0c00204 	addi	r3,fp,8
8110db40:	1885883a 	add	r2,r3,r2
8110db44:	1080000b 	ldhu	r2,0(r2)
8110db48:	113fffcc 	andi	r4,r2,65535
8110db4c:	e0ffdf84 	addi	r3,fp,-130
8110db50:	e0bfdf84 	addi	r2,fp,-130
8110db54:	200f883a 	mov	r7,r4
8110db58:	180d883a 	mov	r6,r3
8110db5c:	01604534 	movhi	r5,33044
8110db60:	29782304 	addi	r5,r5,-8052
8110db64:	1009883a 	mov	r4,r2
8110db68:	1113e480 	call	81113e48 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8110db6c:	e0bfdd03 	ldbu	r2,-140(fp)
8110db70:	10800044 	addi	r2,r2,1
8110db74:	e0bfdd05 	stb	r2,-140(fp)
8110db78:	e0800583 	ldbu	r2,22(fp)
8110db7c:	10803fcc 	andi	r2,r2,255
8110db80:	e0ffdd03 	ldbu	r3,-140(fp)
8110db84:	18bfea36 	bltu	r3,r2,8110db30 <__reset+0xfb0edb30>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8110db88:	e0bfdf84 	addi	r2,fp,-130
8110db8c:	1009883a 	mov	r4,r2
8110db90:	111405c0 	call	8111405c <strlen>
8110db94:	1007883a 	mov	r3,r2
8110db98:	e0bfdf84 	addi	r2,fp,-130
8110db9c:	180b883a 	mov	r5,r3
8110dba0:	1009883a 	mov	r4,r2
8110dba4:	110ea0c0 	call	8110ea0c <ucCrc8wInit>
8110dba8:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8110dbac:	e13fdd43 	ldbu	r4,-139(fp)
8110dbb0:	e0ffdf84 	addi	r3,fp,-130
8110dbb4:	e0bfdf84 	addi	r2,fp,-130
8110dbb8:	200f883a 	mov	r7,r4
8110dbbc:	180d883a 	mov	r6,r3
8110dbc0:	01604534 	movhi	r5,33044
8110dbc4:	29781404 	addi	r5,r5,-8112
8110dbc8:	1009883a 	mov	r4,r2
8110dbcc:	1113e480 	call	81113e48 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
8110dbd0:	e0bfdf0b 	ldhu	r2,-132(fp)
8110dbd4:	10ffffcc 	andi	r3,r2,65535
8110dbd8:	18e0001c 	xori	r3,r3,32768
8110dbdc:	18e00004 	addi	r3,r3,-32768
8110dbe0:	e0bfdf84 	addi	r2,fp,-130
8110dbe4:	180b883a 	mov	r5,r3
8110dbe8:	1009883a 	mov	r4,r2
8110dbec:	110caec0 	call	8110caec <bSendUART128v2>
8110dbf0:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
8110dbf4:	e0bfde17 	ldw	r2,-136(fp)
8110dbf8:	10800060 	cmpeqi	r2,r2,1
8110dbfc:	1000031e 	bne	r2,zero,8110dc0c <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8110dc00:	e0bfdf84 	addi	r2,fp,-130
8110dc04:	1009883a 	mov	r4,r2
8110dc08:	110fc400 	call	8110fc40 <vCouldNotSendTMPusCommand>
	}
}
8110dc0c:	0001883a 	nop
8110dc10:	e037883a 	mov	sp,fp
8110dc14:	dfc00117 	ldw	ra,4(sp)
8110dc18:	df000017 	ldw	fp,0(sp)
8110dc1c:	dec00604 	addi	sp,sp,24
8110dc20:	f800283a 	ret

8110dc24 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
8110dc24:	deffd904 	addi	sp,sp,-156
8110dc28:	de00012e 	bgeu	sp,et,8110dc30 <vTMPusTestConnection+0xc>
8110dc2c:	003b68fa 	trap	3
8110dc30:	dfc02615 	stw	ra,152(sp)
8110dc34:	df002515 	stw	fp,148(sp)
8110dc38:	df002504 	addi	fp,sp,148
8110dc3c:	2005883a 	mov	r2,r4
8110dc40:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
8110dc44:	e0bfff0b 	ldhu	r2,-4(fp)
8110dc48:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 64;
8110dc4c:	00801004 	movi	r2,64
8110dc50:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
8110dc54:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
8110dc58:	00800444 	movi	r2,17
8110dc5c:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
8110dc60:	00800084 	movi	r2,2
8110dc64:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
8110dc68:	d809883a 	mov	r4,sp
8110dc6c:	e0bfef04 	addi	r2,fp,-68
8110dc70:	00c01004 	movi	r3,64
8110dc74:	180d883a 	mov	r6,r3
8110dc78:	100b883a 	mov	r5,r2
8110dc7c:	11136e00 	call	811136e0 <memcpy>
8110dc80:	e13feb17 	ldw	r4,-84(fp)
8110dc84:	e17fec17 	ldw	r5,-80(fp)
8110dc88:	e1bfed17 	ldw	r6,-76(fp)
8110dc8c:	e1ffee17 	ldw	r7,-72(fp)
8110dc90:	110d8d40 	call	8110d8d4 <vSendPusTM64>
}
8110dc94:	0001883a 	nop
8110dc98:	e037883a 	mov	sp,fp
8110dc9c:	dfc00117 	ldw	ra,4(sp)
8110dca0:	df000017 	ldw	fp,0(sp)
8110dca4:	dec00204 	addi	sp,sp,8
8110dca8:	f800283a 	ret

8110dcac <vLoadDefaultETHConf>:

/*Configuration related to the eth connection*/
TConfEth xConfEth;


bool vLoadDefaultETHConf( void ){
8110dcac:	defff504 	addi	sp,sp,-44
8110dcb0:	de00012e 	bgeu	sp,et,8110dcb8 <vLoadDefaultETHConf+0xc>
8110dcb4:	003b68fa 	trap	3
8110dcb8:	dfc00a15 	stw	ra,40(sp)
8110dcbc:	df000915 	stw	fp,36(sp)
8110dcc0:	dc000815 	stw	r16,32(sp)
8110dcc4:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8110dcc8:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
8110dccc:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8110dcd0:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8110dcd4:	d0a05e17 	ldw	r2,-32392(gp)
8110dcd8:	10800058 	cmpnei	r2,r2,1
8110dcdc:	1001f61e 	bne	r2,zero,8110e4b8 <vLoadDefaultETHConf+0x80c>
8110dce0:	1110a380 	call	81110a38 <bSDcardIsPresent>
8110dce4:	1001f426 	beq	r2,zero,8110e4b8 <vLoadDefaultETHConf+0x80c>
8110dce8:	1110a680 	call	81110a68 <bSDcardFAT16Check>
8110dcec:	1001f226 	beq	r2,zero,8110e4b8 <vLoadDefaultETHConf+0x80c>

		siFile = siOpenFile( ETH_FILE_NAME );
8110dcf0:	01204534 	movhi	r4,33044
8110dcf4:	21382504 	addi	r4,r4,-8044
8110dcf8:	1110b900 	call	81110b90 <siOpenFile>
8110dcfc:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8110dd00:	e0bffc0f 	ldh	r2,-16(fp)
8110dd04:	1001e816 	blt	r2,zero,8110e4a8 <vLoadDefaultETHConf+0x7fc>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8110dd08:	e0bffd04 	addi	r2,fp,-12
8110dd0c:	01800204 	movi	r6,8
8110dd10:	01400284 	movi	r5,10
8110dd14:	1009883a 	mov	r4,r2
8110dd18:	11138300 	call	81113830 <memset>
			p_inteiro = inteiro;
8110dd1c:	e0bffd04 	addi	r2,fp,-12
8110dd20:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
8110dd24:	e0bffc0f 	ldh	r2,-16(fp)
8110dd28:	1009883a 	mov	r4,r2
8110dd2c:	1110c0c0 	call	81110c0c <cGetNextChar>
8110dd30:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
8110dd34:	e0bff947 	ldb	r2,-27(fp)
8110dd38:	10800084 	addi	r2,r2,2
8110dd3c:	10c015a8 	cmpgeui	r3,r2,86
8110dd40:	1801cf1e 	bne	r3,zero,8110e480 <vLoadDefaultETHConf+0x7d4>
8110dd44:	100690ba 	slli	r3,r2,2
8110dd48:	00a04474 	movhi	r2,33041
8110dd4c:	10b75704 	addi	r2,r2,-8868
8110dd50:	1885883a 	add	r2,r3,r2
8110dd54:	10800017 	ldw	r2,0(r2)
8110dd58:	1000683a 	jmp	r2
8110dd5c:	8110def4 	orhi	r4,r16,17275
8110dd60:	8110dee8 	cmpgeui	r4,r16,17275
8110dd64:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd68:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd6c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd70:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd74:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd78:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd7c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd80:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd84:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd88:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd8c:	8110e498 	cmpnei	r4,r16,17298
8110dd90:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd94:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dd98:	8110e498 	cmpnei	r4,r16,17298
8110dd9c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dda0:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dda4:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dda8:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddac:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddb0:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddb4:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddb8:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddbc:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddc0:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddc4:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddc8:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddcc:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddd0:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddd4:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddd8:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dddc:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dde0:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dde4:	8110e498 	cmpnei	r4,r16,17298
8110dde8:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddec:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddf0:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddf4:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddf8:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110ddfc:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de00:	8110deb4 	orhi	r4,r16,17274
8110de04:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de08:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de0c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de10:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de14:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de18:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de1c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de20:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de24:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de28:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de2c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de30:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de34:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de38:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de3c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de40:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de44:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de48:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de4c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de50:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de54:	8110e448 	cmpgei	r4,r16,17297
8110de58:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de5c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de60:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de64:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de68:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de6c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de70:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de74:	8110e248 	cmpgei	r4,r16,17289
8110de78:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de7c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de80:	8110e0a8 	cmpgeui	r4,r16,17282
8110de84:	8110e3a0 	cmpeqi	r4,r16,17294
8110de88:	8110dfdc 	xori	r4,r16,17279
8110de8c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de90:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de94:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110de98:	8110df0c 	andi	r4,r16,17276
8110de9c:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dea0:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dea4:	8110e318 	cmpnei	r4,r16,17292
8110dea8:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110deac:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110deb0:	8110e178 	rdprs	r4,r16,17285
					case 39:// single quote '
						c = cGetNextChar(siFile);
8110deb4:	e0bffc0f 	ldh	r2,-16(fp)
8110deb8:	1009883a 	mov	r4,r2
8110debc:	1110c0c0 	call	81110c0c <cGetNextChar>
8110dec0:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
8110dec4:	00000406 	br	8110ded8 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
8110dec8:	e0bffc0f 	ldh	r2,-16(fp)
8110decc:	1009883a 	mov	r4,r2
8110ded0:	1110c0c0 	call	81110c0c <cGetNextChar>
8110ded4:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8110ded8:	e0bff947 	ldb	r2,-27(fp)
8110dedc:	108009d8 	cmpnei	r2,r2,39
8110dee0:	103ff91e 	bne	r2,zero,8110dec8 <__reset+0xfb0edec8>
							c = cGetNextChar(siFile);
						}
						break;
8110dee4:	00016d06 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					case -1: 	//EOF
						bEOF = TRUE;
8110dee8:	00800044 	movi	r2,1
8110deec:	e0bff815 	stw	r2,-32(fp)
						break;
8110def0:	00016a06 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					case -2: 	//EOF
						printf("Problem with SDCard");
8110def4:	01204534 	movhi	r4,33044
8110def8:	21382704 	addi	r4,r4,-8036
8110defc:	11139f80 	call	811139f8 <printf>
						bEOF = TRUE;
8110df00:	00800044 	movi	r2,1
8110df04:	e0bff815 	stw	r2,-32(fp)
						break;
8110df08:	00016406 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
8110df0c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8110df10:	e0bffc0f 	ldh	r2,-16(fp)
8110df14:	1009883a 	mov	r4,r2
8110df18:	1110c0c0 	call	81110c0c <cGetNextChar>
8110df1c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8110df20:	d0e00317 	ldw	r3,-32756(gp)
8110df24:	e0bff947 	ldb	r2,-27(fp)
8110df28:	10800044 	addi	r2,r2,1
8110df2c:	1885883a 	add	r2,r3,r2
8110df30:	10800003 	ldbu	r2,0(r2)
8110df34:	10803fcc 	andi	r2,r2,255
8110df38:	1080010c 	andi	r2,r2,4
8110df3c:	10000626 	beq	r2,zero,8110df58 <vLoadDefaultETHConf+0x2ac>
									(*p_inteiro) = c;
8110df40:	e0bffa17 	ldw	r2,-24(fp)
8110df44:	e0fff943 	ldbu	r3,-27(fp)
8110df48:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8110df4c:	e0bffa17 	ldw	r2,-24(fp)
8110df50:	10800044 	addi	r2,r2,1
8110df54:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
8110df58:	e0bff947 	ldb	r2,-27(fp)
8110df5c:	10800ea0 	cmpeqi	r2,r2,58
8110df60:	1000031e 	bne	r2,zero,8110df70 <vLoadDefaultETHConf+0x2c4>
8110df64:	e0bff947 	ldb	r2,-27(fp)
8110df68:	10800ed8 	cmpnei	r2,r2,59
8110df6c:	103fe81e 	bne	r2,zero,8110df10 <__reset+0xfb0edf10>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110df70:	e0bffa17 	ldw	r2,-24(fp)
8110df74:	00c00284 	movi	r3,10
8110df78:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
8110df7c:	e0bff903 	ldbu	r2,-28(fp)
8110df80:	10800168 	cmpgeui	r2,r2,5
8110df84:	1000021e 	bne	r2,zero,8110df90 <vLoadDefaultETHConf+0x2e4>
8110df88:	e43ff903 	ldbu	r16,-28(fp)
8110df8c:	00000106 	br	8110df94 <vLoadDefaultETHConf+0x2e8>
8110df90:	04000144 	movi	r16,5
8110df94:	e0bffd04 	addi	r2,fp,-12
8110df98:	1009883a 	mov	r4,r2
8110df9c:	11125840 	call	81112584 <atoi>
8110dfa0:	1007883a 	mov	r3,r2
8110dfa4:	00a04574 	movhi	r2,33045
8110dfa8:	10831404 	addi	r2,r2,3152
8110dfac:	1405883a 	add	r2,r2,r16
8110dfb0:	10800404 	addi	r2,r2,16
8110dfb4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8110dfb8:	e0bffd04 	addi	r2,fp,-12
8110dfbc:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8110dfc0:	e0bff903 	ldbu	r2,-28(fp)
8110dfc4:	10800044 	addi	r2,r2,1
8110dfc8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8110dfcc:	e0bff947 	ldb	r2,-27(fp)
8110dfd0:	10800ed8 	cmpnei	r2,r2,59
8110dfd4:	103fce1e 	bne	r2,zero,8110df10 <__reset+0xfb0edf10>

						break;
8110dfd8:	00013006 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					case 'I':

						ucParser = 0;
8110dfdc:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8110dfe0:	e0bffc0f 	ldh	r2,-16(fp)
8110dfe4:	1009883a 	mov	r4,r2
8110dfe8:	1110c0c0 	call	81110c0c <cGetNextChar>
8110dfec:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8110dff0:	d0e00317 	ldw	r3,-32756(gp)
8110dff4:	e0bff947 	ldb	r2,-27(fp)
8110dff8:	10800044 	addi	r2,r2,1
8110dffc:	1885883a 	add	r2,r3,r2
8110e000:	10800003 	ldbu	r2,0(r2)
8110e004:	10803fcc 	andi	r2,r2,255
8110e008:	1080010c 	andi	r2,r2,4
8110e00c:	10000626 	beq	r2,zero,8110e028 <vLoadDefaultETHConf+0x37c>
									(*p_inteiro) = c;
8110e010:	e0bffa17 	ldw	r2,-24(fp)
8110e014:	e0fff943 	ldbu	r3,-27(fp)
8110e018:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8110e01c:	e0bffa17 	ldw	r2,-24(fp)
8110e020:	10800044 	addi	r2,r2,1
8110e024:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8110e028:	e0bff947 	ldb	r2,-27(fp)
8110e02c:	10800ba0 	cmpeqi	r2,r2,46
8110e030:	1000031e 	bne	r2,zero,8110e040 <vLoadDefaultETHConf+0x394>
8110e034:	e0bff947 	ldb	r2,-27(fp)
8110e038:	10800ed8 	cmpnei	r2,r2,59
8110e03c:	103fe81e 	bne	r2,zero,8110dfe0 <__reset+0xfb0edfe0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110e040:	e0bffa17 	ldw	r2,-24(fp)
8110e044:	00c00284 	movi	r3,10
8110e048:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
8110e04c:	e0bff903 	ldbu	r2,-28(fp)
8110e050:	108000e8 	cmpgeui	r2,r2,3
8110e054:	1000021e 	bne	r2,zero,8110e060 <vLoadDefaultETHConf+0x3b4>
8110e058:	e43ff903 	ldbu	r16,-28(fp)
8110e05c:	00000106 	br	8110e064 <vLoadDefaultETHConf+0x3b8>
8110e060:	040000c4 	movi	r16,3
8110e064:	e0bffd04 	addi	r2,fp,-12
8110e068:	1009883a 	mov	r4,r2
8110e06c:	11125840 	call	81112584 <atoi>
8110e070:	1007883a 	mov	r3,r2
8110e074:	00a04574 	movhi	r2,33045
8110e078:	10831404 	addi	r2,r2,3152
8110e07c:	1405883a 	add	r2,r2,r16
8110e080:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8110e084:	e0bffd04 	addi	r2,fp,-12
8110e088:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8110e08c:	e0bff903 	ldbu	r2,-28(fp)
8110e090:	10800044 	addi	r2,r2,1
8110e094:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8110e098:	e0bff947 	ldb	r2,-27(fp)
8110e09c:	10800ed8 	cmpnei	r2,r2,59
8110e0a0:	103fcf1e 	bne	r2,zero,8110dfe0 <__reset+0xfb0edfe0>

						break;
8110e0a4:	0000fd06 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					case 'G':

						ucParser = 0;
8110e0a8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8110e0ac:	e0bffc0f 	ldh	r2,-16(fp)
8110e0b0:	1009883a 	mov	r4,r2
8110e0b4:	1110c0c0 	call	81110c0c <cGetNextChar>
8110e0b8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8110e0bc:	d0e00317 	ldw	r3,-32756(gp)
8110e0c0:	e0bff947 	ldb	r2,-27(fp)
8110e0c4:	10800044 	addi	r2,r2,1
8110e0c8:	1885883a 	add	r2,r3,r2
8110e0cc:	10800003 	ldbu	r2,0(r2)
8110e0d0:	10803fcc 	andi	r2,r2,255
8110e0d4:	1080010c 	andi	r2,r2,4
8110e0d8:	10000626 	beq	r2,zero,8110e0f4 <vLoadDefaultETHConf+0x448>
									(*p_inteiro) = c;
8110e0dc:	e0bffa17 	ldw	r2,-24(fp)
8110e0e0:	e0fff943 	ldbu	r3,-27(fp)
8110e0e4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8110e0e8:	e0bffa17 	ldw	r2,-24(fp)
8110e0ec:	10800044 	addi	r2,r2,1
8110e0f0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8110e0f4:	e0bff947 	ldb	r2,-27(fp)
8110e0f8:	10800ba0 	cmpeqi	r2,r2,46
8110e0fc:	1000031e 	bne	r2,zero,8110e10c <vLoadDefaultETHConf+0x460>
8110e100:	e0bff947 	ldb	r2,-27(fp)
8110e104:	10800ed8 	cmpnei	r2,r2,59
8110e108:	103fe81e 	bne	r2,zero,8110e0ac <__reset+0xfb0ee0ac>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110e10c:	e0bffa17 	ldw	r2,-24(fp)
8110e110:	00c00284 	movi	r3,10
8110e114:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
8110e118:	e0bff903 	ldbu	r2,-28(fp)
8110e11c:	108000e8 	cmpgeui	r2,r2,3
8110e120:	1000021e 	bne	r2,zero,8110e12c <vLoadDefaultETHConf+0x480>
8110e124:	e43ff903 	ldbu	r16,-28(fp)
8110e128:	00000106 	br	8110e130 <vLoadDefaultETHConf+0x484>
8110e12c:	040000c4 	movi	r16,3
8110e130:	e0bffd04 	addi	r2,fp,-12
8110e134:	1009883a 	mov	r4,r2
8110e138:	11125840 	call	81112584 <atoi>
8110e13c:	1007883a 	mov	r3,r2
8110e140:	00a04574 	movhi	r2,33045
8110e144:	10831404 	addi	r2,r2,3152
8110e148:	1405883a 	add	r2,r2,r16
8110e14c:	10800104 	addi	r2,r2,4
8110e150:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8110e154:	e0bffd04 	addi	r2,fp,-12
8110e158:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8110e15c:	e0bff903 	ldbu	r2,-28(fp)
8110e160:	10800044 	addi	r2,r2,1
8110e164:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8110e168:	e0bff947 	ldb	r2,-27(fp)
8110e16c:	10800ed8 	cmpnei	r2,r2,59
8110e170:	103fce1e 	bne	r2,zero,8110e0ac <__reset+0xfb0ee0ac>

						break;
8110e174:	0000c906 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					case 'S':

						ucParser = 0;
8110e178:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8110e17c:	e0bffc0f 	ldh	r2,-16(fp)
8110e180:	1009883a 	mov	r4,r2
8110e184:	1110c0c0 	call	81110c0c <cGetNextChar>
8110e188:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8110e18c:	d0e00317 	ldw	r3,-32756(gp)
8110e190:	e0bff947 	ldb	r2,-27(fp)
8110e194:	10800044 	addi	r2,r2,1
8110e198:	1885883a 	add	r2,r3,r2
8110e19c:	10800003 	ldbu	r2,0(r2)
8110e1a0:	10803fcc 	andi	r2,r2,255
8110e1a4:	1080010c 	andi	r2,r2,4
8110e1a8:	10000626 	beq	r2,zero,8110e1c4 <vLoadDefaultETHConf+0x518>
									(*p_inteiro) = c;
8110e1ac:	e0bffa17 	ldw	r2,-24(fp)
8110e1b0:	e0fff943 	ldbu	r3,-27(fp)
8110e1b4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8110e1b8:	e0bffa17 	ldw	r2,-24(fp)
8110e1bc:	10800044 	addi	r2,r2,1
8110e1c0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8110e1c4:	e0bff947 	ldb	r2,-27(fp)
8110e1c8:	10800ba0 	cmpeqi	r2,r2,46
8110e1cc:	1000031e 	bne	r2,zero,8110e1dc <vLoadDefaultETHConf+0x530>
8110e1d0:	e0bff947 	ldb	r2,-27(fp)
8110e1d4:	10800ed8 	cmpnei	r2,r2,59
8110e1d8:	103fe81e 	bne	r2,zero,8110e17c <__reset+0xfb0ee17c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110e1dc:	e0bffa17 	ldw	r2,-24(fp)
8110e1e0:	00c00284 	movi	r3,10
8110e1e4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
8110e1e8:	e0bff903 	ldbu	r2,-28(fp)
8110e1ec:	108000e8 	cmpgeui	r2,r2,3
8110e1f0:	1000021e 	bne	r2,zero,8110e1fc <vLoadDefaultETHConf+0x550>
8110e1f4:	e43ff903 	ldbu	r16,-28(fp)
8110e1f8:	00000106 	br	8110e200 <vLoadDefaultETHConf+0x554>
8110e1fc:	040000c4 	movi	r16,3
8110e200:	e0bffd04 	addi	r2,fp,-12
8110e204:	1009883a 	mov	r4,r2
8110e208:	11125840 	call	81112584 <atoi>
8110e20c:	1007883a 	mov	r3,r2
8110e210:	00a04574 	movhi	r2,33045
8110e214:	10831404 	addi	r2,r2,3152
8110e218:	1405883a 	add	r2,r2,r16
8110e21c:	10800204 	addi	r2,r2,8
8110e220:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8110e224:	e0bffd04 	addi	r2,fp,-12
8110e228:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8110e22c:	e0bff903 	ldbu	r2,-28(fp)
8110e230:	10800044 	addi	r2,r2,1
8110e234:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8110e238:	e0bff947 	ldb	r2,-27(fp)
8110e23c:	10800ed8 	cmpnei	r2,r2,59
8110e240:	103fce1e 	bne	r2,zero,8110e17c <__reset+0xfb0ee17c>

						break;
8110e244:	00009506 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					case 'D':

						ucParser = 0;
8110e248:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8110e24c:	e0bffc0f 	ldh	r2,-16(fp)
8110e250:	1009883a 	mov	r4,r2
8110e254:	1110c0c0 	call	81110c0c <cGetNextChar>
8110e258:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8110e25c:	d0e00317 	ldw	r3,-32756(gp)
8110e260:	e0bff947 	ldb	r2,-27(fp)
8110e264:	10800044 	addi	r2,r2,1
8110e268:	1885883a 	add	r2,r3,r2
8110e26c:	10800003 	ldbu	r2,0(r2)
8110e270:	10803fcc 	andi	r2,r2,255
8110e274:	1080010c 	andi	r2,r2,4
8110e278:	10000626 	beq	r2,zero,8110e294 <vLoadDefaultETHConf+0x5e8>
									(*p_inteiro) = c;
8110e27c:	e0bffa17 	ldw	r2,-24(fp)
8110e280:	e0fff943 	ldbu	r3,-27(fp)
8110e284:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8110e288:	e0bffa17 	ldw	r2,-24(fp)
8110e28c:	10800044 	addi	r2,r2,1
8110e290:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8110e294:	e0bff947 	ldb	r2,-27(fp)
8110e298:	10800ba0 	cmpeqi	r2,r2,46
8110e29c:	1000031e 	bne	r2,zero,8110e2ac <vLoadDefaultETHConf+0x600>
8110e2a0:	e0bff947 	ldb	r2,-27(fp)
8110e2a4:	10800ed8 	cmpnei	r2,r2,59
8110e2a8:	103fe81e 	bne	r2,zero,8110e24c <__reset+0xfb0ee24c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110e2ac:	e0bffa17 	ldw	r2,-24(fp)
8110e2b0:	00c00284 	movi	r3,10
8110e2b4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
8110e2b8:	e0bff903 	ldbu	r2,-28(fp)
8110e2bc:	108000e8 	cmpgeui	r2,r2,3
8110e2c0:	1000021e 	bne	r2,zero,8110e2cc <vLoadDefaultETHConf+0x620>
8110e2c4:	e43ff903 	ldbu	r16,-28(fp)
8110e2c8:	00000106 	br	8110e2d0 <vLoadDefaultETHConf+0x624>
8110e2cc:	040000c4 	movi	r16,3
8110e2d0:	e0bffd04 	addi	r2,fp,-12
8110e2d4:	1009883a 	mov	r4,r2
8110e2d8:	11125840 	call	81112584 <atoi>
8110e2dc:	1007883a 	mov	r3,r2
8110e2e0:	00a04574 	movhi	r2,33045
8110e2e4:	10831404 	addi	r2,r2,3152
8110e2e8:	1405883a 	add	r2,r2,r16
8110e2ec:	10800304 	addi	r2,r2,12
8110e2f0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8110e2f4:	e0bffd04 	addi	r2,fp,-12
8110e2f8:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8110e2fc:	e0bff903 	ldbu	r2,-28(fp)
8110e300:	10800044 	addi	r2,r2,1
8110e304:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8110e308:	e0bff947 	ldb	r2,-27(fp)
8110e30c:	10800ed8 	cmpnei	r2,r2,59
8110e310:	103fce1e 	bne	r2,zero,8110e24c <__reset+0xfb0ee24c>

						break;						
8110e314:	00006106 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					case 'P':

						do {
							c = cGetNextChar(siFile);
8110e318:	e0bffc0f 	ldh	r2,-16(fp)
8110e31c:	1009883a 	mov	r4,r2
8110e320:	1110c0c0 	call	81110c0c <cGetNextChar>
8110e324:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8110e328:	d0e00317 	ldw	r3,-32756(gp)
8110e32c:	e0bff947 	ldb	r2,-27(fp)
8110e330:	10800044 	addi	r2,r2,1
8110e334:	1885883a 	add	r2,r3,r2
8110e338:	10800003 	ldbu	r2,0(r2)
8110e33c:	10803fcc 	andi	r2,r2,255
8110e340:	1080010c 	andi	r2,r2,4
8110e344:	10000626 	beq	r2,zero,8110e360 <vLoadDefaultETHConf+0x6b4>
								(*p_inteiro) = c;
8110e348:	e0bffa17 	ldw	r2,-24(fp)
8110e34c:	e0fff943 	ldbu	r3,-27(fp)
8110e350:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8110e354:	e0bffa17 	ldw	r2,-24(fp)
8110e358:	10800044 	addi	r2,r2,1
8110e35c:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8110e360:	e0bff947 	ldb	r2,-27(fp)
8110e364:	10800ed8 	cmpnei	r2,r2,59
8110e368:	103feb1e 	bne	r2,zero,8110e318 <__reset+0xfb0ee318>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110e36c:	e0bffa17 	ldw	r2,-24(fp)
8110e370:	00c00284 	movi	r3,10
8110e374:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
8110e378:	e0bffd04 	addi	r2,fp,-12
8110e37c:	1009883a 	mov	r4,r2
8110e380:	11125840 	call	81112584 <atoi>
8110e384:	1007883a 	mov	r3,r2
8110e388:	00a04574 	movhi	r2,33045
8110e38c:	10831404 	addi	r2,r2,3152
8110e390:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8110e394:	e0bffd04 	addi	r2,fp,-12
8110e398:	e0bffa15 	stw	r2,-24(fp)

						break;
8110e39c:	00003f06 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8110e3a0:	e0bffc0f 	ldh	r2,-16(fp)
8110e3a4:	1009883a 	mov	r4,r2
8110e3a8:	1110c0c0 	call	81110c0c <cGetNextChar>
8110e3ac:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8110e3b0:	d0e00317 	ldw	r3,-32756(gp)
8110e3b4:	e0bff947 	ldb	r2,-27(fp)
8110e3b8:	10800044 	addi	r2,r2,1
8110e3bc:	1885883a 	add	r2,r3,r2
8110e3c0:	10800003 	ldbu	r2,0(r2)
8110e3c4:	10803fcc 	andi	r2,r2,255
8110e3c8:	1080010c 	andi	r2,r2,4
8110e3cc:	10000626 	beq	r2,zero,8110e3e8 <vLoadDefaultETHConf+0x73c>
								(*p_inteiro) = c;
8110e3d0:	e0bffa17 	ldw	r2,-24(fp)
8110e3d4:	e0fff943 	ldbu	r3,-27(fp)
8110e3d8:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8110e3dc:	e0bffa17 	ldw	r2,-24(fp)
8110e3e0:	10800044 	addi	r2,r2,1
8110e3e4:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8110e3e8:	e0bff947 	ldb	r2,-27(fp)
8110e3ec:	10800ed8 	cmpnei	r2,r2,59
8110e3f0:	103feb1e 	bne	r2,zero,8110e3a0 <__reset+0xfb0ee3a0>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110e3f4:	e0bffa17 	ldw	r2,-24(fp)
8110e3f8:	00c00284 	movi	r3,10
8110e3fc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8110e400:	e0bffd04 	addi	r2,fp,-12
8110e404:	1009883a 	mov	r4,r2
8110e408:	11125840 	call	81112584 <atoi>
8110e40c:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
8110e410:	e0bffc8f 	ldh	r2,-14(fp)
8110e414:	10800058 	cmpnei	r2,r2,1
8110e418:	1000051e 	bne	r2,zero,8110e430 <vLoadDefaultETHConf+0x784>
							xConfEth.bDHCP = TRUE;
8110e41c:	00a04574 	movhi	r2,33045
8110e420:	10831404 	addi	r2,r2,3152
8110e424:	00c00044 	movi	r3,1
8110e428:	10c00615 	stw	r3,24(r2)
8110e42c:	00000306 	br	8110e43c <vLoadDefaultETHConf+0x790>
						else
							xConfEth.bDHCP = FALSE;
8110e430:	00a04574 	movhi	r2,33045
8110e434:	10831404 	addi	r2,r2,3152
8110e438:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8110e43c:	e0bffd04 	addi	r2,fp,-12
8110e440:	e0bffa15 	stw	r2,-24(fp)

						break;
8110e444:	00001506 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8110e448:	e0bffc0f 	ldh	r2,-16(fp)
8110e44c:	1009883a 	mov	r4,r2
8110e450:	1110bcc0 	call	81110bcc <siCloseFile>
8110e454:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE)
8110e458:	e0bffb17 	ldw	r2,-20(fp)
8110e45c:	1000031e 	bne	r2,zero,8110e46c <vLoadDefaultETHConf+0x7c0>
							printf("Problema em fechar o arquivo\n");
8110e460:	01204534 	movhi	r4,33044
8110e464:	21382c04 	addi	r4,r4,-8016
8110e468:	1113b040 	call	81113b04 <puts>

						/* End of Parser File */
						bEOF = TRUE;
8110e46c:	00800044 	movi	r2,1
8110e470:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8110e474:	00800044 	movi	r2,1
8110e478:	e0bff715 	stw	r2,-36(fp)
						break;
8110e47c:	00000706 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
					default:
						printf("Algum erro ocorreu na leitura do arquivo! c= %i \n", c);
8110e480:	e0bff947 	ldb	r2,-27(fp)
8110e484:	100b883a 	mov	r5,r2
8110e488:	01204534 	movhi	r4,33044
8110e48c:	21383404 	addi	r4,r4,-7984
8110e490:	11139f80 	call	811139f8 <printf>
						break;
8110e494:	00000106 	br	8110e49c <vLoadDefaultETHConf+0x7f0>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8110e498:	0001883a 	nop
						break;
					default:
						printf("Algum erro ocorreu na leitura do arquivo! c= %i \n", c);
						break;
				}
			} while ( bEOF == FALSE );
8110e49c:	e0bff817 	ldw	r2,-32(fp)
8110e4a0:	103e2026 	beq	r2,zero,8110dd24 <__reset+0xfb0edd24>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8110e4a4:	00000706 	br	8110e4c4 <vLoadDefaultETHConf+0x818>
					default:
						printf("Algum erro ocorreu na leitura do arquivo! c= %i \n", c);
						break;
				}
			} while ( bEOF == FALSE );
		} else printf("N�o achou o arquivo - fopen fail\n");
8110e4a8:	01204534 	movhi	r4,33044
8110e4ac:	21384104 	addi	r4,r4,-7932
8110e4b0:	1113b040 	call	81113b04 <puts>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8110e4b4:	00000306 	br	8110e4c4 <vLoadDefaultETHConf+0x818>
						printf("Algum erro ocorreu na leitura do arquivo! c= %i \n", c);
						break;
				}
			} while ( bEOF == FALSE );
		} else printf("N�o achou o arquivo - fopen fail\n");
	} else printf("Sem SDCard\n");
8110e4b8:	01204534 	movhi	r4,33044
8110e4bc:	21384a04 	addi	r4,r4,-7896
8110e4c0:	1113b040 	call	81113b04 <puts>

	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8110e4c4:	e0bff717 	ldw	r2,-36(fp)
8110e4c8:	1000541e 	bne	r2,zero,8110e61c <vLoadDefaultETHConf+0x970>
		/*Enviar mensagem que e gravar log que n�o encontrou o arquivo e come�ara a utilizar o padrao*/
		printf("Aten��o: Arquivo de conex�o n�o foi encontrado. Carregando conf padrao\n");
8110e4cc:	01204534 	movhi	r4,33044
8110e4d0:	21384d04 	addi	r4,r4,-7884
8110e4d4:	1113b040 	call	81113b04 <puts>
		printf("N�o encontrou:'%s'.\n", ETH_FILE_NAME);
8110e4d8:	01604534 	movhi	r5,33044
8110e4dc:	29782504 	addi	r5,r5,-8044
8110e4e0:	01204534 	movhi	r4,33044
8110e4e4:	21386104 	addi	r4,r4,-7804
8110e4e8:	11139f80 	call	811139f8 <printf>


		xConfEth.siPortPUS = 17000;
8110e4ec:	00a04574 	movhi	r2,33045
8110e4f0:	10831404 	addi	r2,r2,3152
8110e4f4:	00d09a04 	movi	r3,17000
8110e4f8:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
8110e4fc:	00a04574 	movhi	r2,33045
8110e500:	10831404 	addi	r2,r2,3152
8110e504:	00fff004 	movi	r3,-64
8110e508:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
8110e50c:	00a04574 	movhi	r2,33045
8110e510:	10831404 	addi	r2,r2,3152
8110e514:	00ffea04 	movi	r3,-88
8110e518:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
8110e51c:	00a04574 	movhi	r2,33045
8110e520:	10831404 	addi	r2,r2,3152
8110e524:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
8110e528:	00a04574 	movhi	r2,33045
8110e52c:	10831404 	addi	r2,r2,3152
8110e530:	00c00144 	movi	r3,5
8110e534:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
8110e538:	00a04574 	movhi	r2,33045
8110e53c:	10831404 	addi	r2,r2,3152
8110e540:	00fff004 	movi	r3,-64
8110e544:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
8110e548:	00a04574 	movhi	r2,33045
8110e54c:	10831404 	addi	r2,r2,3152
8110e550:	00ffea04 	movi	r3,-88
8110e554:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
8110e558:	00a04574 	movhi	r2,33045
8110e55c:	10831404 	addi	r2,r2,3152
8110e560:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
8110e564:	00a04574 	movhi	r2,33045
8110e568:	10831404 	addi	r2,r2,3152
8110e56c:	00c00044 	movi	r3,1
8110e570:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
8110e574:	00a04574 	movhi	r2,33045
8110e578:	10831404 	addi	r2,r2,3152
8110e57c:	00ffffc4 	movi	r3,-1
8110e580:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
8110e584:	00a04574 	movhi	r2,33045
8110e588:	10831404 	addi	r2,r2,3152
8110e58c:	00ffffc4 	movi	r3,-1
8110e590:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
8110e594:	00a04574 	movhi	r2,33045
8110e598:	10831404 	addi	r2,r2,3152
8110e59c:	00ffffc4 	movi	r3,-1
8110e5a0:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
8110e5a4:	00a04574 	movhi	r2,33045
8110e5a8:	10831404 	addi	r2,r2,3152
8110e5ac:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
8110e5b0:	00a04574 	movhi	r2,33045
8110e5b4:	10831404 	addi	r2,r2,3152
8110e5b8:	00ffff04 	movi	r3,-4
8110e5bc:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8110e5c0:	00a04574 	movhi	r2,33045
8110e5c4:	10831404 	addi	r2,r2,3152
8110e5c8:	00fffdc4 	movi	r3,-9
8110e5cc:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8110e5d0:	00a04574 	movhi	r2,33045
8110e5d4:	10831404 	addi	r2,r2,3152
8110e5d8:	00c018c4 	movi	r3,99
8110e5dc:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8110e5e0:	00a04574 	movhi	r2,33045
8110e5e4:	10831404 	addi	r2,r2,3152
8110e5e8:	00c01344 	movi	r3,77
8110e5ec:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8110e5f0:	00a04574 	movhi	r2,33045
8110e5f4:	10831404 	addi	r2,r2,3152
8110e5f8:	00c007c4 	movi	r3,31
8110e5fc:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8110e600:	00a04574 	movhi	r2,33045
8110e604:	10831404 	addi	r2,r2,3152
8110e608:	00c01084 	movi	r3,66
8110e60c:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8110e610:	00a04574 	movhi	r2,33045
8110e614:	10831404 	addi	r2,r2,3152
8110e618:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8110e61c:	e0bff717 	ldw	r2,-36(fp)
}
8110e620:	e6ffff04 	addi	sp,fp,-4
8110e624:	dfc00217 	ldw	ra,8(sp)
8110e628:	df000117 	ldw	fp,4(sp)
8110e62c:	dc000017 	ldw	r16,0(sp)
8110e630:	dec00304 	addi	sp,sp,12
8110e634:	f800283a 	ret

8110e638 <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
8110e638:	defff004 	addi	sp,sp,-64
8110e63c:	de00012e 	bgeu	sp,et,8110e644 <vShowEthConfig+0xc>
8110e640:	003b68fa 	trap	3
8110e644:	dfc00f15 	stw	ra,60(sp)
8110e648:	df000e15 	stw	fp,56(sp)
8110e64c:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8110e650:	d0a04e17 	ldw	r2,-32456(gp)
8110e654:	100f883a 	mov	r7,r2
8110e658:	018007c4 	movi	r6,31
8110e65c:	01400044 	movi	r5,1
8110e660:	01204534 	movhi	r4,33044
8110e664:	21386704 	addi	r4,r4,-7780
8110e668:	1112ccc0 	call	81112ccc <fwrite>

		memset(buffer,0,40);
8110e66c:	01800a04 	movi	r6,40
8110e670:	000b883a 	mov	r5,zero
8110e674:	e13ff604 	addi	r4,fp,-40
8110e678:	11138300 	call	81113830 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
8110e67c:	00a04574 	movhi	r2,33045
8110e680:	10831404 	addi	r2,r2,3152
8110e684:	10800403 	ldbu	r2,16(r2)
8110e688:	11803fcc 	andi	r6,r2,255
8110e68c:	00a04574 	movhi	r2,33045
8110e690:	10831404 	addi	r2,r2,3152
8110e694:	10800443 	ldbu	r2,17(r2)
8110e698:	11c03fcc 	andi	r7,r2,255
8110e69c:	00a04574 	movhi	r2,33045
8110e6a0:	10831404 	addi	r2,r2,3152
8110e6a4:	10800483 	ldbu	r2,18(r2)
8110e6a8:	10c03fcc 	andi	r3,r2,255
8110e6ac:	00a04574 	movhi	r2,33045
8110e6b0:	10831404 	addi	r2,r2,3152
8110e6b4:	108004c3 	ldbu	r2,19(r2)
8110e6b8:	11003fcc 	andi	r4,r2,255
8110e6bc:	00a04574 	movhi	r2,33045
8110e6c0:	10831404 	addi	r2,r2,3152
8110e6c4:	10800503 	ldbu	r2,20(r2)
8110e6c8:	11403fcc 	andi	r5,r2,255
8110e6cc:	00a04574 	movhi	r2,33045
8110e6d0:	10831404 	addi	r2,r2,3152
8110e6d4:	10800543 	ldbu	r2,21(r2)
8110e6d8:	10803fcc 	andi	r2,r2,255
8110e6dc:	d8800315 	stw	r2,12(sp)
8110e6e0:	d9400215 	stw	r5,8(sp)
8110e6e4:	d9000115 	stw	r4,4(sp)
8110e6e8:	d8c00015 	stw	r3,0(sp)
8110e6ec:	01604534 	movhi	r5,33044
8110e6f0:	29786f04 	addi	r5,r5,-7748
8110e6f4:	e13ff604 	addi	r4,fp,-40
8110e6f8:	1113e480 	call	81113e48 <sprintf>
		debug(fp, buffer );
8110e6fc:	d0a04e17 	ldw	r2,-32456(gp)
8110e700:	e17ff604 	addi	r5,fp,-40
8110e704:	1009883a 	mov	r4,r2
8110e708:	11126e00 	call	811126e0 <fprintf>

		memset(buffer,0,40);
8110e70c:	01800a04 	movi	r6,40
8110e710:	000b883a 	mov	r5,zero
8110e714:	e13ff604 	addi	r4,fp,-40
8110e718:	11138300 	call	81113830 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
8110e71c:	00a04574 	movhi	r2,33045
8110e720:	10831404 	addi	r2,r2,3152
8110e724:	10800003 	ldbu	r2,0(r2)
8110e728:	11003fcc 	andi	r4,r2,255
8110e72c:	00a04574 	movhi	r2,33045
8110e730:	10831404 	addi	r2,r2,3152
8110e734:	10800043 	ldbu	r2,1(r2)
8110e738:	11403fcc 	andi	r5,r2,255
8110e73c:	00a04574 	movhi	r2,33045
8110e740:	10831404 	addi	r2,r2,3152
8110e744:	10800083 	ldbu	r2,2(r2)
8110e748:	10c03fcc 	andi	r3,r2,255
8110e74c:	00a04574 	movhi	r2,33045
8110e750:	10831404 	addi	r2,r2,3152
8110e754:	108000c3 	ldbu	r2,3(r2)
8110e758:	10803fcc 	andi	r2,r2,255
8110e75c:	d8800115 	stw	r2,4(sp)
8110e760:	d8c00015 	stw	r3,0(sp)
8110e764:	280f883a 	mov	r7,r5
8110e768:	200d883a 	mov	r6,r4
8110e76c:	01604534 	movhi	r5,33044
8110e770:	29787804 	addi	r5,r5,-7712
8110e774:	e13ff604 	addi	r4,fp,-40
8110e778:	1113e480 	call	81113e48 <sprintf>
		debug(fp, buffer );
8110e77c:	d0a04e17 	ldw	r2,-32456(gp)
8110e780:	e17ff604 	addi	r5,fp,-40
8110e784:	1009883a 	mov	r4,r2
8110e788:	11126e00 	call	811126e0 <fprintf>

		memset(buffer,0,40);
8110e78c:	01800a04 	movi	r6,40
8110e790:	000b883a 	mov	r5,zero
8110e794:	e13ff604 	addi	r4,fp,-40
8110e798:	11138300 	call	81113830 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
8110e79c:	00a04574 	movhi	r2,33045
8110e7a0:	10831404 	addi	r2,r2,3152
8110e7a4:	10800103 	ldbu	r2,4(r2)
8110e7a8:	11003fcc 	andi	r4,r2,255
8110e7ac:	00a04574 	movhi	r2,33045
8110e7b0:	10831404 	addi	r2,r2,3152
8110e7b4:	10800143 	ldbu	r2,5(r2)
8110e7b8:	11403fcc 	andi	r5,r2,255
8110e7bc:	00a04574 	movhi	r2,33045
8110e7c0:	10831404 	addi	r2,r2,3152
8110e7c4:	10800183 	ldbu	r2,6(r2)
8110e7c8:	10c03fcc 	andi	r3,r2,255
8110e7cc:	00a04574 	movhi	r2,33045
8110e7d0:	10831404 	addi	r2,r2,3152
8110e7d4:	108001c3 	ldbu	r2,7(r2)
8110e7d8:	10803fcc 	andi	r2,r2,255
8110e7dc:	d8800115 	stw	r2,4(sp)
8110e7e0:	d8c00015 	stw	r3,0(sp)
8110e7e4:	280f883a 	mov	r7,r5
8110e7e8:	200d883a 	mov	r6,r4
8110e7ec:	01604534 	movhi	r5,33044
8110e7f0:	29787e04 	addi	r5,r5,-7688
8110e7f4:	e13ff604 	addi	r4,fp,-40
8110e7f8:	1113e480 	call	81113e48 <sprintf>
		debug(fp, buffer );
8110e7fc:	d0a04e17 	ldw	r2,-32456(gp)
8110e800:	e17ff604 	addi	r5,fp,-40
8110e804:	1009883a 	mov	r4,r2
8110e808:	11126e00 	call	811126e0 <fprintf>

		memset(buffer,0,40);
8110e80c:	01800a04 	movi	r6,40
8110e810:	000b883a 	mov	r5,zero
8110e814:	e13ff604 	addi	r4,fp,-40
8110e818:	11138300 	call	81113830 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
8110e81c:	00a04574 	movhi	r2,33045
8110e820:	10831404 	addi	r2,r2,3152
8110e824:	10800203 	ldbu	r2,8(r2)
8110e828:	11003fcc 	andi	r4,r2,255
8110e82c:	00a04574 	movhi	r2,33045
8110e830:	10831404 	addi	r2,r2,3152
8110e834:	10800243 	ldbu	r2,9(r2)
8110e838:	11403fcc 	andi	r5,r2,255
8110e83c:	00a04574 	movhi	r2,33045
8110e840:	10831404 	addi	r2,r2,3152
8110e844:	10800283 	ldbu	r2,10(r2)
8110e848:	10c03fcc 	andi	r3,r2,255
8110e84c:	00a04574 	movhi	r2,33045
8110e850:	10831404 	addi	r2,r2,3152
8110e854:	108002c3 	ldbu	r2,11(r2)
8110e858:	10803fcc 	andi	r2,r2,255
8110e85c:	d8800115 	stw	r2,4(sp)
8110e860:	d8c00015 	stw	r3,0(sp)
8110e864:	280f883a 	mov	r7,r5
8110e868:	200d883a 	mov	r6,r4
8110e86c:	01604534 	movhi	r5,33044
8110e870:	29788504 	addi	r5,r5,-7660
8110e874:	e13ff604 	addi	r4,fp,-40
8110e878:	1113e480 	call	81113e48 <sprintf>
		debug(fp, buffer );
8110e87c:	d0a04e17 	ldw	r2,-32456(gp)
8110e880:	e17ff604 	addi	r5,fp,-40
8110e884:	1009883a 	mov	r4,r2
8110e888:	11126e00 	call	811126e0 <fprintf>

		memset(buffer,0,40);
8110e88c:	01800a04 	movi	r6,40
8110e890:	000b883a 	mov	r5,zero
8110e894:	e13ff604 	addi	r4,fp,-40
8110e898:	11138300 	call	81113830 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
8110e89c:	00a04574 	movhi	r2,33045
8110e8a0:	10831404 	addi	r2,r2,3152
8110e8a4:	10800303 	ldbu	r2,12(r2)
8110e8a8:	11003fcc 	andi	r4,r2,255
8110e8ac:	00a04574 	movhi	r2,33045
8110e8b0:	10831404 	addi	r2,r2,3152
8110e8b4:	10800343 	ldbu	r2,13(r2)
8110e8b8:	11403fcc 	andi	r5,r2,255
8110e8bc:	00a04574 	movhi	r2,33045
8110e8c0:	10831404 	addi	r2,r2,3152
8110e8c4:	10800383 	ldbu	r2,14(r2)
8110e8c8:	10c03fcc 	andi	r3,r2,255
8110e8cc:	00a04574 	movhi	r2,33045
8110e8d0:	10831404 	addi	r2,r2,3152
8110e8d4:	108003c3 	ldbu	r2,15(r2)
8110e8d8:	10803fcc 	andi	r2,r2,255
8110e8dc:	d8800115 	stw	r2,4(sp)
8110e8e0:	d8c00015 	stw	r3,0(sp)
8110e8e4:	280f883a 	mov	r7,r5
8110e8e8:	200d883a 	mov	r6,r4
8110e8ec:	01604534 	movhi	r5,33044
8110e8f0:	29788c04 	addi	r5,r5,-7632
8110e8f4:	e13ff604 	addi	r4,fp,-40
8110e8f8:	1113e480 	call	81113e48 <sprintf>
		debug(fp, buffer );
8110e8fc:	d0a04e17 	ldw	r2,-32456(gp)
8110e900:	e17ff604 	addi	r5,fp,-40
8110e904:	1009883a 	mov	r4,r2
8110e908:	11126e00 	call	811126e0 <fprintf>

		memset(buffer,0,40);
8110e90c:	01800a04 	movi	r6,40
8110e910:	000b883a 	mov	r5,zero
8110e914:	e13ff604 	addi	r4,fp,-40
8110e918:	11138300 	call	81113830 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
8110e91c:	00a04574 	movhi	r2,33045
8110e920:	10831404 	addi	r2,r2,3152
8110e924:	1080058b 	ldhu	r2,22(r2)
8110e928:	10bfffcc 	andi	r2,r2,65535
8110e92c:	100d883a 	mov	r6,r2
8110e930:	01604534 	movhi	r5,33044
8110e934:	29789304 	addi	r5,r5,-7604
8110e938:	e13ff604 	addi	r4,fp,-40
8110e93c:	1113e480 	call	81113e48 <sprintf>
		debug(fp, buffer );
8110e940:	d0a04e17 	ldw	r2,-32456(gp)
8110e944:	e17ff604 	addi	r5,fp,-40
8110e948:	1009883a 	mov	r4,r2
8110e94c:	11126e00 	call	811126e0 <fprintf>

	}
8110e950:	0001883a 	nop
8110e954:	e037883a 	mov	sp,fp
8110e958:	dfc00117 	ldw	ra,4(sp)
8110e95c:	df000017 	ldw	fp,0(sp)
8110e960:	dec00204 	addi	sp,sp,8
8110e964:	f800283a 	ret

8110e968 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8110e968:	defffb04 	addi	sp,sp,-20
8110e96c:	de00012e 	bgeu	sp,et,8110e974 <ucCrc8+0xc>
8110e970:	003b68fa 	trap	3
8110e974:	df000415 	stw	fp,16(sp)
8110e978:	df000404 	addi	fp,sp,16
8110e97c:	e13ffd15 	stw	r4,-12(fp)
8110e980:	e17ffe15 	stw	r5,-8(fp)
8110e984:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8110e988:	e0bffe17 	ldw	r2,-8(fp)
8110e98c:	1000021e 	bne	r2,zero,8110e998 <ucCrc8+0x30>
        return 0;
8110e990:	0005883a 	mov	r2,zero
8110e994:	00001906 	br	8110e9fc <ucCrc8+0x94>
    crc &= 0xff;
8110e998:	e0bffd17 	ldw	r2,-12(fp)
8110e99c:	10803fcc 	andi	r2,r2,255
8110e9a0:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
8110e9a4:	e0fffe17 	ldw	r3,-8(fp)
8110e9a8:	e0bfff17 	ldw	r2,-4(fp)
8110e9ac:	1885883a 	add	r2,r3,r2
8110e9b0:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
8110e9b4:	00000d06 	br	8110e9ec <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8110e9b8:	e0bffe17 	ldw	r2,-8(fp)
8110e9bc:	10c00044 	addi	r3,r2,1
8110e9c0:	e0fffe15 	stw	r3,-8(fp)
8110e9c4:	10800003 	ldbu	r2,0(r2)
8110e9c8:	10c03fcc 	andi	r3,r2,255
8110e9cc:	e0bffd17 	ldw	r2,-12(fp)
8110e9d0:	1886f03a 	xor	r3,r3,r2
8110e9d4:	00a04534 	movhi	r2,33044
8110e9d8:	10b89704 	addi	r2,r2,-7588
8110e9dc:	10c5883a 	add	r2,r2,r3
8110e9e0:	10800003 	ldbu	r2,0(r2)
8110e9e4:	10803fcc 	andi	r2,r2,255
8110e9e8:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8110e9ec:	e0fffe17 	ldw	r3,-8(fp)
8110e9f0:	e0bffc17 	ldw	r2,-16(fp)
8110e9f4:	18bff036 	bltu	r3,r2,8110e9b8 <__reset+0xfb0ee9b8>
        crc = crc8_table[crc ^ *data++];
    return crc;
8110e9f8:	e0bffd17 	ldw	r2,-12(fp)
}
8110e9fc:	e037883a 	mov	sp,fp
8110ea00:	df000017 	ldw	fp,0(sp)
8110ea04:	dec00104 	addi	sp,sp,4
8110ea08:	f800283a 	ret

8110ea0c <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8110ea0c:	defffb04 	addi	sp,sp,-20
8110ea10:	de00012e 	bgeu	sp,et,8110ea18 <ucCrc8wInit+0xc>
8110ea14:	003b68fa 	trap	3
8110ea18:	dfc00415 	stw	ra,16(sp)
8110ea1c:	df000315 	stw	fp,12(sp)
8110ea20:	df000304 	addi	fp,sp,12
8110ea24:	e13ffe15 	stw	r4,-8(fp)
8110ea28:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	#ifdef DEBUG_ON
		fprintf(fp,"Debug inside: %s\n", data );
8110ea2c:	d0a04e17 	ldw	r2,-32456(gp)
8110ea30:	e1bffe17 	ldw	r6,-8(fp)
8110ea34:	01604534 	movhi	r5,33044
8110ea38:	2978d704 	addi	r5,r5,-7332
8110ea3c:	1009883a 	mov	r4,r2
8110ea40:	11126e00 	call	811126e0 <fprintf>
	#endif

	crc = ucCrc8(0, NULL, 0);
8110ea44:	000d883a 	mov	r6,zero
8110ea48:	000b883a 	mov	r5,zero
8110ea4c:	0009883a 	mov	r4,zero
8110ea50:	110e9680 	call	8110e968 <ucCrc8>
8110ea54:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8110ea58:	e0bffd03 	ldbu	r2,-12(fp)
8110ea5c:	e1bfff17 	ldw	r6,-4(fp)
8110ea60:	e17ffe17 	ldw	r5,-8(fp)
8110ea64:	1009883a 	mov	r4,r2
8110ea68:	110e9680 	call	8110e968 <ucCrc8>
}
8110ea6c:	e037883a 	mov	sp,fp
8110ea70:	dfc00117 	ldw	ra,4(sp)
8110ea74:	df000017 	ldw	fp,0(sp)
8110ea78:	dec00204 	addi	sp,sp,8
8110ea7c:	f800283a 	ret

8110ea80 <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
8110ea80:	defff904 	addi	sp,sp,-28
8110ea84:	de00012e 	bgeu	sp,et,8110ea8c <printErrorTask+0xc>
8110ea88:	003b68fa 	trap	3
8110ea8c:	dfc00615 	stw	ra,24(sp)
8110ea90:	df000515 	stw	fp,20(sp)
8110ea94:	df000504 	addi	fp,sp,20
8110ea98:	2005883a 	mov	r2,r4
8110ea9c:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
8110eaa0:	e03ffb15 	stw	zero,-20(fp)
8110eaa4:	e03ffc15 	stw	zero,-16(fp)
8110eaa8:	e03ffd15 	stw	zero,-12(fp)
8110eaac:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
8110eab0:	e0bfff03 	ldbu	r2,-4(fp)
8110eab4:	100d883a 	mov	r6,r2
8110eab8:	01604534 	movhi	r5,33044
8110eabc:	2978dc04 	addi	r5,r5,-7312
8110eac0:	e13ffb04 	addi	r4,fp,-20
8110eac4:	1113e480 	call	81113e48 <sprintf>
		debug(fp, buffer);
8110eac8:	d0a04e17 	ldw	r2,-32456(gp)
8110eacc:	e17ffb04 	addi	r5,fp,-20
8110ead0:	1009883a 	mov	r4,r2
8110ead4:	11126e00 	call	811126e0 <fprintf>
	}
8110ead8:	0001883a 	nop
8110eadc:	e037883a 	mov	sp,fp
8110eae0:	dfc00117 	ldw	ra,4(sp)
8110eae4:	df000017 	ldw	fp,0(sp)
8110eae8:	dec00204 	addi	sp,sp,8
8110eaec:	f800283a 	ret

8110eaf0 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
8110eaf0:	defffd04 	addi	sp,sp,-12
8110eaf4:	de00012e 	bgeu	sp,et,8110eafc <vFailCreateMutexSResources+0xc>
8110eaf8:	003b68fa 	trap	3
8110eafc:	dfc00215 	stw	ra,8(sp)
8110eb00:	df000115 	stw	fp,4(sp)
8110eb04:	df000104 	addi	fp,sp,4
8110eb08:	2005883a 	mov	r2,r4
8110eb0c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
8110eb10:	d0a04e17 	ldw	r2,-32456(gp)
8110eb14:	100f883a 	mov	r7,r2
8110eb18:	018008c4 	movi	r6,35
8110eb1c:	01400044 	movi	r5,1
8110eb20:	01204534 	movhi	r4,33044
8110eb24:	2138df04 	addi	r4,r4,-7300
8110eb28:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8110eb2c:	e0bfff03 	ldbu	r2,-4(fp)
8110eb30:	1009883a 	mov	r4,r2
8110eb34:	110ea800 	call	8110ea80 <printErrorTask>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110eb38:	0001883a 	nop
8110eb3c:	e037883a 	mov	sp,fp
8110eb40:	dfc00117 	ldw	ra,4(sp)
8110eb44:	df000017 	ldw	fp,0(sp)
8110eb48:	dec00204 	addi	sp,sp,8
8110eb4c:	f800283a 	ret

8110eb50 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
8110eb50:	defffe04 	addi	sp,sp,-8
8110eb54:	de00012e 	bgeu	sp,et,8110eb5c <vFailCreateSemaphoreResources+0xc>
8110eb58:	003b68fa 	trap	3
8110eb5c:	dfc00115 	stw	ra,4(sp)
8110eb60:	df000015 	stw	fp,0(sp)
8110eb64:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
8110eb68:	d0a04e17 	ldw	r2,-32456(gp)
8110eb6c:	100f883a 	mov	r7,r2
8110eb70:	01800984 	movi	r6,38
8110eb74:	01400044 	movi	r5,1
8110eb78:	01204534 	movhi	r4,33044
8110eb7c:	2138e804 	addi	r4,r4,-7264
8110eb80:	1112ccc0 	call	81112ccc <fwrite>

	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110eb84:	0001883a 	nop
8110eb88:	e037883a 	mov	sp,fp
8110eb8c:	dfc00117 	ldw	ra,4(sp)
8110eb90:	df000017 	ldw	fp,0(sp)
8110eb94:	dec00204 	addi	sp,sp,8
8110eb98:	f800283a 	ret

8110eb9c <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
8110eb9c:	defffe04 	addi	sp,sp,-8
8110eba0:	de00012e 	bgeu	sp,et,8110eba8 <vFailTestCriticasParts+0xc>
8110eba4:	003b68fa 	trap	3
8110eba8:	dfc00115 	stw	ra,4(sp)
8110ebac:	df000015 	stw	fp,0(sp)
8110ebb0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8110ebb4:	d0a04e17 	ldw	r2,-32456(gp)
8110ebb8:	100f883a 	mov	r7,r2
8110ebbc:	018007c4 	movi	r6,31
8110ebc0:	01400044 	movi	r5,1
8110ebc4:	01204534 	movhi	r4,33044
8110ebc8:	2138f204 	addi	r4,r4,-7224
8110ebcc:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110ebd0:	0001883a 	nop
8110ebd4:	e037883a 	mov	sp,fp
8110ebd8:	dfc00117 	ldw	ra,4(sp)
8110ebdc:	df000017 	ldw	fp,0(sp)
8110ebe0:	dec00204 	addi	sp,sp,8
8110ebe4:	f800283a 	ret

8110ebe8 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8110ebe8:	defffe04 	addi	sp,sp,-8
8110ebec:	de00012e 	bgeu	sp,et,8110ebf4 <vFailSendxSemCommInit+0xc>
8110ebf0:	003b68fa 	trap	3
8110ebf4:	dfc00115 	stw	ra,4(sp)
8110ebf8:	df000015 	stw	fp,0(sp)
8110ebfc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
8110ec00:	d0a04e17 	ldw	r2,-32456(gp)
8110ec04:	100f883a 	mov	r7,r2
8110ec08:	01800744 	movi	r6,29
8110ec0c:	01400044 	movi	r5,1
8110ec10:	01204534 	movhi	r4,33044
8110ec14:	2138fa04 	addi	r4,r4,-7192
8110ec18:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8110ec1c:	d0a04e17 	ldw	r2,-32456(gp)
8110ec20:	100f883a 	mov	r7,r2
8110ec24:	01800a44 	movi	r6,41
8110ec28:	01400044 	movi	r5,1
8110ec2c:	01204534 	movhi	r4,33044
8110ec30:	21390204 	addi	r4,r4,-7160
8110ec34:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110ec38:	0001883a 	nop
8110ec3c:	e037883a 	mov	sp,fp
8110ec40:	dfc00117 	ldw	ra,4(sp)
8110ec44:	df000017 	ldw	fp,0(sp)
8110ec48:	dec00204 	addi	sp,sp,8
8110ec4c:	f800283a 	ret

8110ec50 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
8110ec50:	defffe04 	addi	sp,sp,-8
8110ec54:	de00012e 	bgeu	sp,et,8110ec5c <vFailSendPreParsedSemaphore+0xc>
8110ec58:	003b68fa 	trap	3
8110ec5c:	dfc00115 	stw	ra,4(sp)
8110ec60:	df000015 	stw	fp,0(sp)
8110ec64:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
8110ec68:	d0a04e17 	ldw	r2,-32456(gp)
8110ec6c:	100f883a 	mov	r7,r2
8110ec70:	01800904 	movi	r6,36
8110ec74:	01400044 	movi	r5,1
8110ec78:	01204534 	movhi	r4,33044
8110ec7c:	21390d04 	addi	r4,r4,-7116
8110ec80:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110ec84:	0001883a 	nop
8110ec88:	e037883a 	mov	sp,fp
8110ec8c:	dfc00117 	ldw	ra,4(sp)
8110ec90:	df000017 	ldw	fp,0(sp)
8110ec94:	dec00204 	addi	sp,sp,8
8110ec98:	f800283a 	ret

8110ec9c <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
8110ec9c:	defffe04 	addi	sp,sp,-8
8110eca0:	de00012e 	bgeu	sp,et,8110eca8 <vFailSendPreAckReceiverSemaphore+0xc>
8110eca4:	003b68fa 	trap	3
8110eca8:	dfc00115 	stw	ra,4(sp)
8110ecac:	df000015 	stw	fp,0(sp)
8110ecb0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8110ecb4:	d0a04e17 	ldw	r2,-32456(gp)
8110ecb8:	100f883a 	mov	r7,r2
8110ecbc:	01800a44 	movi	r6,41
8110ecc0:	01400044 	movi	r5,1
8110ecc4:	01204534 	movhi	r4,33044
8110ecc8:	21391704 	addi	r4,r4,-7076
8110eccc:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110ecd0:	0001883a 	nop
8110ecd4:	e037883a 	mov	sp,fp
8110ecd8:	dfc00117 	ldw	ra,4(sp)
8110ecdc:	df000017 	ldw	fp,0(sp)
8110ece0:	dec00204 	addi	sp,sp,8
8110ece4:	f800283a 	ret

8110ece8 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8110ece8:	defffe04 	addi	sp,sp,-8
8110ecec:	de00012e 	bgeu	sp,et,8110ecf4 <vFailSendPreAckSenderSemaphore+0xc>
8110ecf0:	003b68fa 	trap	3
8110ecf4:	dfc00115 	stw	ra,4(sp)
8110ecf8:	df000015 	stw	fp,0(sp)
8110ecfc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
8110ed00:	d0a04e17 	ldw	r2,-32456(gp)
8110ed04:	100f883a 	mov	r7,r2
8110ed08:	018009c4 	movi	r6,39
8110ed0c:	01400044 	movi	r5,1
8110ed10:	01204534 	movhi	r4,33044
8110ed14:	21392204 	addi	r4,r4,-7032
8110ed18:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110ed1c:	0001883a 	nop
8110ed20:	e037883a 	mov	sp,fp
8110ed24:	dfc00117 	ldw	ra,4(sp)
8110ed28:	df000017 	ldw	fp,0(sp)
8110ed2c:	dec00204 	addi	sp,sp,8
8110ed30:	f800283a 	ret

8110ed34 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
8110ed34:	defffe04 	addi	sp,sp,-8
8110ed38:	de00012e 	bgeu	sp,et,8110ed40 <vFailGetCountSemaphoreSenderTask+0xc>
8110ed3c:	003b68fa 	trap	3
8110ed40:	dfc00115 	stw	ra,4(sp)
8110ed44:	df000015 	stw	fp,0(sp)
8110ed48:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
8110ed4c:	d0a04e17 	ldw	r2,-32456(gp)
8110ed50:	100f883a 	mov	r7,r2
8110ed54:	01800a44 	movi	r6,41
8110ed58:	01400044 	movi	r5,1
8110ed5c:	01204534 	movhi	r4,33044
8110ed60:	21392c04 	addi	r4,r4,-6992
8110ed64:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
8110ed68:	d0a04e17 	ldw	r2,-32456(gp)
8110ed6c:	100f883a 	mov	r7,r2
8110ed70:	01801104 	movi	r6,68
8110ed74:	01400044 	movi	r5,1
8110ed78:	01204534 	movhi	r4,33044
8110ed7c:	21393704 	addi	r4,r4,-6948
8110ed80:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110ed84:	0001883a 	nop
8110ed88:	e037883a 	mov	sp,fp
8110ed8c:	dfc00117 	ldw	ra,4(sp)
8110ed90:	df000017 	ldw	fp,0(sp)
8110ed94:	dec00204 	addi	sp,sp,8
8110ed98:	f800283a 	ret

8110ed9c <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
8110ed9c:	defffe04 	addi	sp,sp,-8
8110eda0:	de00012e 	bgeu	sp,et,8110eda8 <vFailGetMutexSenderTask+0xc>
8110eda4:	003b68fa 	trap	3
8110eda8:	dfc00115 	stw	ra,4(sp)
8110edac:	df000015 	stw	fp,0(sp)
8110edb0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8110edb4:	d0a04e17 	ldw	r2,-32456(gp)
8110edb8:	100f883a 	mov	r7,r2
8110edbc:	01800804 	movi	r6,32
8110edc0:	01400044 	movi	r5,1
8110edc4:	01204534 	movhi	r4,33044
8110edc8:	21394904 	addi	r4,r4,-6876
8110edcc:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
8110edd0:	d0a04e17 	ldw	r2,-32456(gp)
8110edd4:	100f883a 	mov	r7,r2
8110edd8:	01801084 	movi	r6,66
8110eddc:	01400044 	movi	r5,1
8110ede0:	01204534 	movhi	r4,33044
8110ede4:	21395204 	addi	r4,r4,-6840
8110ede8:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110edec:	0001883a 	nop
8110edf0:	e037883a 	mov	sp,fp
8110edf4:	dfc00117 	ldw	ra,4(sp)
8110edf8:	df000017 	ldw	fp,0(sp)
8110edfc:	dec00204 	addi	sp,sp,8
8110ee00:	f800283a 	ret

8110ee04 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8110ee04:	defffe04 	addi	sp,sp,-8
8110ee08:	de00012e 	bgeu	sp,et,8110ee10 <vFailGetCountSemaphoreReceiverTask+0xc>
8110ee0c:	003b68fa 	trap	3
8110ee10:	dfc00115 	stw	ra,4(sp)
8110ee14:	df000015 	stw	fp,0(sp)
8110ee18:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8110ee1c:	d0a04e17 	ldw	r2,-32456(gp)
8110ee20:	100f883a 	mov	r7,r2
8110ee24:	01800ac4 	movi	r6,43
8110ee28:	01400044 	movi	r5,1
8110ee2c:	01204534 	movhi	r4,33044
8110ee30:	21396304 	addi	r4,r4,-6772
8110ee34:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
8110ee38:	d0a04e17 	ldw	r2,-32456(gp)
8110ee3c:	100f883a 	mov	r7,r2
8110ee40:	01801184 	movi	r6,70
8110ee44:	01400044 	movi	r5,1
8110ee48:	01204534 	movhi	r4,33044
8110ee4c:	21396e04 	addi	r4,r4,-6728
8110ee50:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110ee54:	0001883a 	nop
8110ee58:	e037883a 	mov	sp,fp
8110ee5c:	dfc00117 	ldw	ra,4(sp)
8110ee60:	df000017 	ldw	fp,0(sp)
8110ee64:	dec00204 	addi	sp,sp,8
8110ee68:	f800283a 	ret

8110ee6c <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8110ee6c:	defffe04 	addi	sp,sp,-8
8110ee70:	de00012e 	bgeu	sp,et,8110ee78 <vFailGetMutexReceiverTask+0xc>
8110ee74:	003b68fa 	trap	3
8110ee78:	dfc00115 	stw	ra,4(sp)
8110ee7c:	df000015 	stw	fp,0(sp)
8110ee80:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8110ee84:	d0a04e17 	ldw	r2,-32456(gp)
8110ee88:	100f883a 	mov	r7,r2
8110ee8c:	01800884 	movi	r6,34
8110ee90:	01400044 	movi	r5,1
8110ee94:	01204534 	movhi	r4,33044
8110ee98:	21398004 	addi	r4,r4,-6656
8110ee9c:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
8110eea0:	d0a04e17 	ldw	r2,-32456(gp)
8110eea4:	100f883a 	mov	r7,r2
8110eea8:	01801104 	movi	r6,68
8110eeac:	01400044 	movi	r5,1
8110eeb0:	01204534 	movhi	r4,33044
8110eeb4:	21398904 	addi	r4,r4,-6620
8110eeb8:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110eebc:	0001883a 	nop
8110eec0:	e037883a 	mov	sp,fp
8110eec4:	dfc00117 	ldw	ra,4(sp)
8110eec8:	df000017 	ldw	fp,0(sp)
8110eecc:	dec00204 	addi	sp,sp,8
8110eed0:	f800283a 	ret

8110eed4 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8110eed4:	defffe04 	addi	sp,sp,-8
8110eed8:	de00012e 	bgeu	sp,et,8110eee0 <vFailGetMutexTxUARTSenderTask+0xc>
8110eedc:	003b68fa 	trap	3
8110eee0:	dfc00115 	stw	ra,4(sp)
8110eee4:	df000015 	stw	fp,0(sp)
8110eee8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
8110eeec:	d0a04e17 	ldw	r2,-32456(gp)
8110eef0:	100f883a 	mov	r7,r2
8110eef4:	01800984 	movi	r6,38
8110eef8:	01400044 	movi	r5,1
8110eefc:	01204534 	movhi	r4,33044
8110ef00:	21399b04 	addi	r4,r4,-6548
8110ef04:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8110ef08:	d0a04e17 	ldw	r2,-32456(gp)
8110ef0c:	100f883a 	mov	r7,r2
8110ef10:	01801044 	movi	r6,65
8110ef14:	01400044 	movi	r5,1
8110ef18:	01204534 	movhi	r4,33044
8110ef1c:	2139a504 	addi	r4,r4,-6508
8110ef20:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110ef24:	0001883a 	nop
8110ef28:	e037883a 	mov	sp,fp
8110ef2c:	dfc00117 	ldw	ra,4(sp)
8110ef30:	df000017 	ldw	fp,0(sp)
8110ef34:	dec00204 	addi	sp,sp,8
8110ef38:	f800283a 	ret

8110ef3c <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
8110ef3c:	defffe04 	addi	sp,sp,-8
8110ef40:	de00012e 	bgeu	sp,et,8110ef48 <vFailGetMacRTC+0xc>
8110ef44:	003b68fa 	trap	3
8110ef48:	dfc00115 	stw	ra,4(sp)
8110ef4c:	df000015 	stw	fp,0(sp)
8110ef50:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
8110ef54:	d0a04e17 	ldw	r2,-32456(gp)
8110ef58:	100f883a 	mov	r7,r2
8110ef5c:	018003c4 	movi	r6,15
8110ef60:	01400044 	movi	r5,1
8110ef64:	01204534 	movhi	r4,33044
8110ef68:	2139b604 	addi	r4,r4,-6440
8110ef6c:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110ef70:	0001883a 	nop
8110ef74:	e037883a 	mov	sp,fp
8110ef78:	dfc00117 	ldw	ra,4(sp)
8110ef7c:	df000017 	ldw	fp,0(sp)
8110ef80:	dec00204 	addi	sp,sp,8
8110ef84:	f800283a 	ret

8110ef88 <vFailInitialization>:


void vFailInitialization( void )
{
8110ef88:	defffe04 	addi	sp,sp,-8
8110ef8c:	de00012e 	bgeu	sp,et,8110ef94 <vFailInitialization+0xc>
8110ef90:	003b68fa 	trap	3
8110ef94:	dfc00115 	stw	ra,4(sp)
8110ef98:	df000015 	stw	fp,0(sp)
8110ef9c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
8110efa0:	d0a04e17 	ldw	r2,-32456(gp)
8110efa4:	100f883a 	mov	r7,r2
8110efa8:	01800504 	movi	r6,20
8110efac:	01400044 	movi	r5,1
8110efb0:	01204534 	movhi	r4,33044
8110efb4:	2139ba04 	addi	r4,r4,-6424
8110efb8:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110efbc:	0001883a 	nop
8110efc0:	e037883a 	mov	sp,fp
8110efc4:	dfc00117 	ldw	ra,4(sp)
8110efc8:	df000017 	ldw	fp,0(sp)
8110efcc:	dec00204 	addi	sp,sp,8
8110efd0:	f800283a 	ret

8110efd4 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8110efd4:	defffe04 	addi	sp,sp,-8
8110efd8:	de00012e 	bgeu	sp,et,8110efe0 <vFailReceiverCreate+0xc>
8110efdc:	003b68fa 	trap	3
8110efe0:	dfc00115 	stw	ra,4(sp)
8110efe4:	df000015 	stw	fp,0(sp)
8110efe8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
8110efec:	d0a04e17 	ldw	r2,-32456(gp)
8110eff0:	100f883a 	mov	r7,r2
8110eff4:	01800484 	movi	r6,18
8110eff8:	01400044 	movi	r5,1
8110effc:	01204534 	movhi	r4,33044
8110f000:	2139c004 	addi	r4,r4,-6400
8110f004:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f008:	0001883a 	nop
8110f00c:	e037883a 	mov	sp,fp
8110f010:	dfc00117 	ldw	ra,4(sp)
8110f014:	df000017 	ldw	fp,0(sp)
8110f018:	dec00204 	addi	sp,sp,8
8110f01c:	f800283a 	ret

8110f020 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8110f020:	defffe04 	addi	sp,sp,-8
8110f024:	de00012e 	bgeu	sp,et,8110f02c <vFailSenderCreate+0xc>
8110f028:	003b68fa 	trap	3
8110f02c:	dfc00115 	stw	ra,4(sp)
8110f030:	df000015 	stw	fp,0(sp)
8110f034:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
8110f038:	d0a04e17 	ldw	r2,-32456(gp)
8110f03c:	100f883a 	mov	r7,r2
8110f040:	01800484 	movi	r6,18
8110f044:	01400044 	movi	r5,1
8110f048:	01204534 	movhi	r4,33044
8110f04c:	2139c504 	addi	r4,r4,-6380
8110f050:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f054:	0001883a 	nop
8110f058:	e037883a 	mov	sp,fp
8110f05c:	dfc00117 	ldw	ra,4(sp)
8110f060:	df000017 	ldw	fp,0(sp)
8110f064:	dec00204 	addi	sp,sp,8
8110f068:	f800283a 	ret

8110f06c <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
8110f06c:	defffe04 	addi	sp,sp,-8
8110f070:	de00012e 	bgeu	sp,et,8110f078 <vFailDeleteInitialization+0xc>
8110f074:	003b68fa 	trap	3
8110f078:	dfc00115 	stw	ra,4(sp)
8110f07c:	df000015 	stw	fp,0(sp)
8110f080:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
8110f084:	d0a04e17 	ldw	r2,-32456(gp)
8110f088:	100f883a 	mov	r7,r2
8110f08c:	01800684 	movi	r6,26
8110f090:	01400044 	movi	r5,1
8110f094:	01204534 	movhi	r4,33044
8110f098:	2139ca04 	addi	r4,r4,-6360
8110f09c:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f0a0:	0001883a 	nop
8110f0a4:	e037883a 	mov	sp,fp
8110f0a8:	dfc00117 	ldw	ra,4(sp)
8110f0ac:	df000017 	ldw	fp,0(sp)
8110f0b0:	dec00204 	addi	sp,sp,8
8110f0b4:	f800283a 	ret

8110f0b8 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8110f0b8:	defffe04 	addi	sp,sp,-8
8110f0bc:	de00012e 	bgeu	sp,et,8110f0c4 <vFailSetCountSemaphorexBuffer32+0xc>
8110f0c0:	003b68fa 	trap	3
8110f0c4:	dfc00115 	stw	ra,4(sp)
8110f0c8:	df000015 	stw	fp,0(sp)
8110f0cc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
8110f0d0:	d0a04e17 	ldw	r2,-32456(gp)
8110f0d4:	100f883a 	mov	r7,r2
8110f0d8:	01800a04 	movi	r6,40
8110f0dc:	01400044 	movi	r5,1
8110f0e0:	01204534 	movhi	r4,33044
8110f0e4:	2139d104 	addi	r4,r4,-6332
8110f0e8:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8110f0ec:	d0a04e17 	ldw	r2,-32456(gp)
8110f0f0:	100f883a 	mov	r7,r2
8110f0f4:	018008c4 	movi	r6,35
8110f0f8:	01400044 	movi	r5,1
8110f0fc:	01204534 	movhi	r4,33044
8110f100:	2139dc04 	addi	r4,r4,-6288
8110f104:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f108:	0001883a 	nop
8110f10c:	e037883a 	mov	sp,fp
8110f110:	dfc00117 	ldw	ra,4(sp)
8110f114:	df000017 	ldw	fp,0(sp)
8110f118:	dec00204 	addi	sp,sp,8
8110f11c:	f800283a 	ret

8110f120 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8110f120:	defffe04 	addi	sp,sp,-8
8110f124:	de00012e 	bgeu	sp,et,8110f12c <vFailSetCountSemaphorexBuffer64+0xc>
8110f128:	003b68fa 	trap	3
8110f12c:	dfc00115 	stw	ra,4(sp)
8110f130:	df000015 	stw	fp,0(sp)
8110f134:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8110f138:	d0a04e17 	ldw	r2,-32456(gp)
8110f13c:	100f883a 	mov	r7,r2
8110f140:	01800a04 	movi	r6,40
8110f144:	01400044 	movi	r5,1
8110f148:	01204534 	movhi	r4,33044
8110f14c:	2139e504 	addi	r4,r4,-6252
8110f150:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8110f154:	d0a04e17 	ldw	r2,-32456(gp)
8110f158:	100f883a 	mov	r7,r2
8110f15c:	018008c4 	movi	r6,35
8110f160:	01400044 	movi	r5,1
8110f164:	01204534 	movhi	r4,33044
8110f168:	2139dc04 	addi	r4,r4,-6288
8110f16c:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f170:	0001883a 	nop
8110f174:	e037883a 	mov	sp,fp
8110f178:	dfc00117 	ldw	ra,4(sp)
8110f17c:	df000017 	ldw	fp,0(sp)
8110f180:	dec00204 	addi	sp,sp,8
8110f184:	f800283a 	ret

8110f188 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8110f188:	defffe04 	addi	sp,sp,-8
8110f18c:	de00012e 	bgeu	sp,et,8110f194 <vFailSetCountSemaphorexBuffer128+0xc>
8110f190:	003b68fa 	trap	3
8110f194:	dfc00115 	stw	ra,4(sp)
8110f198:	df000015 	stw	fp,0(sp)
8110f19c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
8110f1a0:	d0a04e17 	ldw	r2,-32456(gp)
8110f1a4:	100f883a 	mov	r7,r2
8110f1a8:	01800a44 	movi	r6,41
8110f1ac:	01400044 	movi	r5,1
8110f1b0:	01204534 	movhi	r4,33044
8110f1b4:	2139f004 	addi	r4,r4,-6208
8110f1b8:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8110f1bc:	d0a04e17 	ldw	r2,-32456(gp)
8110f1c0:	100f883a 	mov	r7,r2
8110f1c4:	018008c4 	movi	r6,35
8110f1c8:	01400044 	movi	r5,1
8110f1cc:	01204534 	movhi	r4,33044
8110f1d0:	2139dc04 	addi	r4,r4,-6288
8110f1d4:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f1d8:	0001883a 	nop
8110f1dc:	e037883a 	mov	sp,fp
8110f1e0:	dfc00117 	ldw	ra,4(sp)
8110f1e4:	df000017 	ldw	fp,0(sp)
8110f1e8:	dec00204 	addi	sp,sp,8
8110f1ec:	f800283a 	ret

8110f1f0 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8110f1f0:	defffe04 	addi	sp,sp,-8
8110f1f4:	de00012e 	bgeu	sp,et,8110f1fc <vFailGetCountSemaphorexBuffer128+0xc>
8110f1f8:	003b68fa 	trap	3
8110f1fc:	dfc00115 	stw	ra,4(sp)
8110f200:	df000015 	stw	fp,0(sp)
8110f204:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8110f208:	d0a04e17 	ldw	r2,-32456(gp)
8110f20c:	100f883a 	mov	r7,r2
8110f210:	01800a44 	movi	r6,41
8110f214:	01400044 	movi	r5,1
8110f218:	01204534 	movhi	r4,33044
8110f21c:	2139fb04 	addi	r4,r4,-6164
8110f220:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8110f224:	d0a04e17 	ldw	r2,-32456(gp)
8110f228:	100f883a 	mov	r7,r2
8110f22c:	01800884 	movi	r6,34
8110f230:	01400044 	movi	r5,1
8110f234:	01204534 	movhi	r4,33044
8110f238:	213a0604 	addi	r4,r4,-6120
8110f23c:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f240:	0001883a 	nop
8110f244:	e037883a 	mov	sp,fp
8110f248:	dfc00117 	ldw	ra,4(sp)
8110f24c:	df000017 	ldw	fp,0(sp)
8110f250:	dec00204 	addi	sp,sp,8
8110f254:	f800283a 	ret

8110f258 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8110f258:	defffe04 	addi	sp,sp,-8
8110f25c:	de00012e 	bgeu	sp,et,8110f264 <vFailGetCountSemaphorexBuffer64+0xc>
8110f260:	003b68fa 	trap	3
8110f264:	dfc00115 	stw	ra,4(sp)
8110f268:	df000015 	stw	fp,0(sp)
8110f26c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
8110f270:	d0a04e17 	ldw	r2,-32456(gp)
8110f274:	100f883a 	mov	r7,r2
8110f278:	01800a04 	movi	r6,40
8110f27c:	01400044 	movi	r5,1
8110f280:	01204534 	movhi	r4,33044
8110f284:	213a0f04 	addi	r4,r4,-6084
8110f288:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8110f28c:	d0a04e17 	ldw	r2,-32456(gp)
8110f290:	100f883a 	mov	r7,r2
8110f294:	01800884 	movi	r6,34
8110f298:	01400044 	movi	r5,1
8110f29c:	01204534 	movhi	r4,33044
8110f2a0:	213a0604 	addi	r4,r4,-6120
8110f2a4:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f2a8:	0001883a 	nop
8110f2ac:	e037883a 	mov	sp,fp
8110f2b0:	dfc00117 	ldw	ra,4(sp)
8110f2b4:	df000017 	ldw	fp,0(sp)
8110f2b8:	dec00204 	addi	sp,sp,8
8110f2bc:	f800283a 	ret

8110f2c0 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8110f2c0:	defffe04 	addi	sp,sp,-8
8110f2c4:	de00012e 	bgeu	sp,et,8110f2cc <vFailGetCountSemaphorexBuffer32+0xc>
8110f2c8:	003b68fa 	trap	3
8110f2cc:	dfc00115 	stw	ra,4(sp)
8110f2d0:	df000015 	stw	fp,0(sp)
8110f2d4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8110f2d8:	d0a04e17 	ldw	r2,-32456(gp)
8110f2dc:	100f883a 	mov	r7,r2
8110f2e0:	01800a04 	movi	r6,40
8110f2e4:	01400044 	movi	r5,1
8110f2e8:	01204534 	movhi	r4,33044
8110f2ec:	213a1a04 	addi	r4,r4,-6040
8110f2f0:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8110f2f4:	d0a04e17 	ldw	r2,-32456(gp)
8110f2f8:	100f883a 	mov	r7,r2
8110f2fc:	01800884 	movi	r6,34
8110f300:	01400044 	movi	r5,1
8110f304:	01204534 	movhi	r4,33044
8110f308:	213a0604 	addi	r4,r4,-6120
8110f30c:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f310:	0001883a 	nop
8110f314:	e037883a 	mov	sp,fp
8110f318:	dfc00117 	ldw	ra,4(sp)
8110f31c:	df000017 	ldw	fp,0(sp)
8110f320:	dec00204 	addi	sp,sp,8
8110f324:	f800283a 	ret

8110f328 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8110f328:	defffe04 	addi	sp,sp,-8
8110f32c:	de00012e 	bgeu	sp,et,8110f334 <vFailFoundBufferRetransmission+0xc>
8110f330:	003b68fa 	trap	3
8110f334:	dfc00115 	stw	ra,4(sp)
8110f338:	df000015 	stw	fp,0(sp)
8110f33c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8110f340:	d0a04e17 	ldw	r2,-32456(gp)
8110f344:	100f883a 	mov	r7,r2
8110f348:	01800a84 	movi	r6,42
8110f34c:	01400044 	movi	r5,1
8110f350:	01204534 	movhi	r4,33044
8110f354:	213a2504 	addi	r4,r4,-5996
8110f358:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
8110f35c:	d0a04e17 	ldw	r2,-32456(gp)
8110f360:	100f883a 	mov	r7,r2
8110f364:	01801204 	movi	r6,72
8110f368:	01400044 	movi	r5,1
8110f36c:	01204534 	movhi	r4,33044
8110f370:	213a3004 	addi	r4,r4,-5952
8110f374:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f378:	0001883a 	nop
8110f37c:	e037883a 	mov	sp,fp
8110f380:	dfc00117 	ldw	ra,4(sp)
8110f384:	df000017 	ldw	fp,0(sp)
8110f388:	dec00204 	addi	sp,sp,8
8110f38c:	f800283a 	ret

8110f390 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8110f390:	defffe04 	addi	sp,sp,-8
8110f394:	de00012e 	bgeu	sp,et,8110f39c <vFailGetCountSemaphorePreParsedBuffer+0xc>
8110f398:	003b68fa 	trap	3
8110f39c:	dfc00115 	stw	ra,4(sp)
8110f3a0:	df000015 	stw	fp,0(sp)
8110f3a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8110f3a8:	d0a04e17 	ldw	r2,-32456(gp)
8110f3ac:	100f883a 	mov	r7,r2
8110f3b0:	01800b84 	movi	r6,46
8110f3b4:	01400044 	movi	r5,1
8110f3b8:	01204534 	movhi	r4,33044
8110f3bc:	213a4304 	addi	r4,r4,-5876
8110f3c0:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8110f3c4:	d0a04e17 	ldw	r2,-32456(gp)
8110f3c8:	100f883a 	mov	r7,r2
8110f3cc:	018010c4 	movi	r6,67
8110f3d0:	01400044 	movi	r5,1
8110f3d4:	01204534 	movhi	r4,33044
8110f3d8:	213a4f04 	addi	r4,r4,-5828
8110f3dc:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f3e0:	0001883a 	nop
8110f3e4:	e037883a 	mov	sp,fp
8110f3e8:	dfc00117 	ldw	ra,4(sp)
8110f3ec:	df000017 	ldw	fp,0(sp)
8110f3f0:	dec00204 	addi	sp,sp,8
8110f3f4:	f800283a 	ret

8110f3f8 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8110f3f8:	defffe04 	addi	sp,sp,-8
8110f3fc:	de00012e 	bgeu	sp,et,8110f404 <vFailGetxMutexPreParsedParserRxTask+0xc>
8110f400:	003b68fa 	trap	3
8110f404:	dfc00115 	stw	ra,4(sp)
8110f408:	df000015 	stw	fp,0(sp)
8110f40c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8110f410:	d0a04e17 	ldw	r2,-32456(gp)
8110f414:	100f883a 	mov	r7,r2
8110f418:	01800b04 	movi	r6,44
8110f41c:	01400044 	movi	r5,1
8110f420:	01204534 	movhi	r4,33044
8110f424:	213a6004 	addi	r4,r4,-5760
8110f428:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
8110f42c:	d0a04e17 	ldw	r2,-32456(gp)
8110f430:	100f883a 	mov	r7,r2
8110f434:	01800fc4 	movi	r6,63
8110f438:	01400044 	movi	r5,1
8110f43c:	01204534 	movhi	r4,33044
8110f440:	213a6c04 	addi	r4,r4,-5712
8110f444:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f448:	0001883a 	nop
8110f44c:	e037883a 	mov	sp,fp
8110f450:	dfc00117 	ldw	ra,4(sp)
8110f454:	df000017 	ldw	fp,0(sp)
8110f458:	dec00204 	addi	sp,sp,8
8110f45c:	f800283a 	ret

8110f460 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8110f460:	defffe04 	addi	sp,sp,-8
8110f464:	de00012e 	bgeu	sp,et,8110f46c <vNoContentInPreParsedBuffer+0xc>
8110f468:	003b68fa 	trap	3
8110f46c:	dfc00115 	stw	ra,4(sp)
8110f470:	df000015 	stw	fp,0(sp)
8110f474:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
8110f478:	d0a04e17 	ldw	r2,-32456(gp)
8110f47c:	100f883a 	mov	r7,r2
8110f480:	01800904 	movi	r6,36
8110f484:	01400044 	movi	r5,1
8110f488:	01204534 	movhi	r4,33044
8110f48c:	213a7c04 	addi	r4,r4,-5648
8110f490:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8110f494:	d0a04e17 	ldw	r2,-32456(gp)
8110f498:	100f883a 	mov	r7,r2
8110f49c:	01801684 	movi	r6,90
8110f4a0:	01400044 	movi	r5,1
8110f4a4:	01204534 	movhi	r4,33044
8110f4a8:	213a8604 	addi	r4,r4,-5608
8110f4ac:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f4b0:	0001883a 	nop
8110f4b4:	e037883a 	mov	sp,fp
8110f4b8:	dfc00117 	ldw	ra,4(sp)
8110f4bc:	df000017 	ldw	fp,0(sp)
8110f4c0:	dec00204 	addi	sp,sp,8
8110f4c4:	f800283a 	ret

8110f4c8 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8110f4c8:	defffe04 	addi	sp,sp,-8
8110f4cc:	de00012e 	bgeu	sp,et,8110f4d4 <vCouldNotSendEthConfUART+0xc>
8110f4d0:	003b68fa 	trap	3
8110f4d4:	dfc00115 	stw	ra,4(sp)
8110f4d8:	df000015 	stw	fp,0(sp)
8110f4dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8110f4e0:	d0a04e17 	ldw	r2,-32456(gp)
8110f4e4:	100f883a 	mov	r7,r2
8110f4e8:	01800844 	movi	r6,33
8110f4ec:	01400044 	movi	r5,1
8110f4f0:	01204534 	movhi	r4,33044
8110f4f4:	213a9d04 	addi	r4,r4,-5516
8110f4f8:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8110f4fc:	d0a04e17 	ldw	r2,-32456(gp)
8110f500:	100f883a 	mov	r7,r2
8110f504:	01801784 	movi	r6,94
8110f508:	01400044 	movi	r5,1
8110f50c:	01204534 	movhi	r4,33044
8110f510:	213aa604 	addi	r4,r4,-5480
8110f514:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f518:	0001883a 	nop
8110f51c:	e037883a 	mov	sp,fp
8110f520:	dfc00117 	ldw	ra,4(sp)
8110f524:	df000017 	ldw	fp,0(sp)
8110f528:	dec00204 	addi	sp,sp,8
8110f52c:	f800283a 	ret

8110f530 <vFailSendNack>:

void vFailSendNack( void )
{
8110f530:	defffe04 	addi	sp,sp,-8
8110f534:	de00012e 	bgeu	sp,et,8110f53c <vFailSendNack+0xc>
8110f538:	003b68fa 	trap	3
8110f53c:	dfc00115 	stw	ra,4(sp)
8110f540:	df000015 	stw	fp,0(sp)
8110f544:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
8110f548:	d0a04e17 	ldw	r2,-32456(gp)
8110f54c:	100f883a 	mov	r7,r2
8110f550:	01800584 	movi	r6,22
8110f554:	01400044 	movi	r5,1
8110f558:	01204534 	movhi	r4,33044
8110f55c:	213abe04 	addi	r4,r4,-5384
8110f560:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8110f564:	d0a04e17 	ldw	r2,-32456(gp)
8110f568:	100f883a 	mov	r7,r2
8110f56c:	01800a84 	movi	r6,42
8110f570:	01400044 	movi	r5,1
8110f574:	01204534 	movhi	r4,33044
8110f578:	213ac404 	addi	r4,r4,-5360
8110f57c:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f580:	0001883a 	nop
8110f584:	e037883a 	mov	sp,fp
8110f588:	dfc00117 	ldw	ra,4(sp)
8110f58c:	df000017 	ldw	fp,0(sp)
8110f590:	dec00204 	addi	sp,sp,8
8110f594:	f800283a 	ret

8110f598 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8110f598:	defffe04 	addi	sp,sp,-8
8110f59c:	de00012e 	bgeu	sp,et,8110f5a4 <vFailSetPreAckSenderBuffer+0xc>
8110f5a0:	003b68fa 	trap	3
8110f5a4:	dfc00115 	stw	ra,4(sp)
8110f5a8:	df000015 	stw	fp,0(sp)
8110f5ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8110f5b0:	d0a04e17 	ldw	r2,-32456(gp)
8110f5b4:	100f883a 	mov	r7,r2
8110f5b8:	018008c4 	movi	r6,35
8110f5bc:	01400044 	movi	r5,1
8110f5c0:	01204534 	movhi	r4,33044
8110f5c4:	213acf04 	addi	r4,r4,-5316
8110f5c8:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8110f5cc:	d0a04e17 	ldw	r2,-32456(gp)
8110f5d0:	100f883a 	mov	r7,r2
8110f5d4:	01801584 	movi	r6,86
8110f5d8:	01400044 	movi	r5,1
8110f5dc:	01204534 	movhi	r4,33044
8110f5e0:	213ad804 	addi	r4,r4,-5280
8110f5e4:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f5e8:	0001883a 	nop
8110f5ec:	e037883a 	mov	sp,fp
8110f5f0:	dfc00117 	ldw	ra,4(sp)
8110f5f4:	df000017 	ldw	fp,0(sp)
8110f5f8:	dec00204 	addi	sp,sp,8
8110f5fc:	f800283a 	ret

8110f600 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8110f600:	defffe04 	addi	sp,sp,-8
8110f604:	de00012e 	bgeu	sp,et,8110f60c <vFailSetPreParsedBuffer+0xc>
8110f608:	003b68fa 	trap	3
8110f60c:	dfc00115 	stw	ra,4(sp)
8110f610:	df000015 	stw	fp,0(sp)
8110f614:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8110f618:	d0a04e17 	ldw	r2,-32456(gp)
8110f61c:	100f883a 	mov	r7,r2
8110f620:	01800804 	movi	r6,32
8110f624:	01400044 	movi	r5,1
8110f628:	01204534 	movhi	r4,33044
8110f62c:	213aee04 	addi	r4,r4,-5192
8110f630:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
8110f634:	d0a04e17 	ldw	r2,-32456(gp)
8110f638:	100f883a 	mov	r7,r2
8110f63c:	018013c4 	movi	r6,79
8110f640:	01400044 	movi	r5,1
8110f644:	01204534 	movhi	r4,33044
8110f648:	213af704 	addi	r4,r4,-5156
8110f64c:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f650:	0001883a 	nop
8110f654:	e037883a 	mov	sp,fp
8110f658:	dfc00117 	ldw	ra,4(sp)
8110f65c:	df000017 	ldw	fp,0(sp)
8110f660:	dec00204 	addi	sp,sp,8
8110f664:	f800283a 	ret

8110f668 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8110f668:	defffe04 	addi	sp,sp,-8
8110f66c:	de00012e 	bgeu	sp,et,8110f674 <vFailSetPreAckReceiverBuffer+0xc>
8110f670:	003b68fa 	trap	3
8110f674:	dfc00115 	stw	ra,4(sp)
8110f678:	df000015 	stw	fp,0(sp)
8110f67c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
8110f680:	d0a04e17 	ldw	r2,-32456(gp)
8110f684:	100f883a 	mov	r7,r2
8110f688:	01800944 	movi	r6,37
8110f68c:	01400044 	movi	r5,1
8110f690:	01204534 	movhi	r4,33044
8110f694:	213b0b04 	addi	r4,r4,-5076
8110f698:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
8110f69c:	d0a04e17 	ldw	r2,-32456(gp)
8110f6a0:	100f883a 	mov	r7,r2
8110f6a4:	018015c4 	movi	r6,87
8110f6a8:	01400044 	movi	r5,1
8110f6ac:	01204534 	movhi	r4,33044
8110f6b0:	213b1504 	addi	r4,r4,-5036
8110f6b4:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f6b8:	0001883a 	nop
8110f6bc:	e037883a 	mov	sp,fp
8110f6c0:	dfc00117 	ldw	ra,4(sp)
8110f6c4:	df000017 	ldw	fp,0(sp)
8110f6c8:	dec00204 	addi	sp,sp,8
8110f6cc:	f800283a 	ret

8110f6d0 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8110f6d0:	defffe04 	addi	sp,sp,-8
8110f6d4:	de00012e 	bgeu	sp,et,8110f6dc <vFailParserCommTaskCreate+0xc>
8110f6d8:	003b68fa 	trap	3
8110f6dc:	dfc00115 	stw	ra,4(sp)
8110f6e0:	df000015 	stw	fp,0(sp)
8110f6e4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
8110f6e8:	d0a04e17 	ldw	r2,-32456(gp)
8110f6ec:	100f883a 	mov	r7,r2
8110f6f0:	01800684 	movi	r6,26
8110f6f4:	01400044 	movi	r5,1
8110f6f8:	01204534 	movhi	r4,33044
8110f6fc:	213b2b04 	addi	r4,r4,-4948
8110f700:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
8110f704:	0001883a 	nop
8110f708:	e037883a 	mov	sp,fp
8110f70c:	dfc00117 	ldw	ra,4(sp)
8110f710:	df000017 	ldw	fp,0(sp)
8110f714:	dec00204 	addi	sp,sp,8
8110f718:	f800283a 	ret

8110f71c <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8110f71c:	defffe04 	addi	sp,sp,-8
8110f720:	de00012e 	bgeu	sp,et,8110f728 <vFailInAckHandlerTaskCreate+0xc>
8110f724:	003b68fa 	trap	3
8110f728:	dfc00115 	stw	ra,4(sp)
8110f72c:	df000015 	stw	fp,0(sp)
8110f730:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8110f734:	d0a04e17 	ldw	r2,-32456(gp)
8110f738:	100f883a 	mov	r7,r2
8110f73c:	01800704 	movi	r6,28
8110f740:	01400044 	movi	r5,1
8110f744:	01204534 	movhi	r4,33044
8110f748:	213b3204 	addi	r4,r4,-4920
8110f74c:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
8110f750:	0001883a 	nop
8110f754:	e037883a 	mov	sp,fp
8110f758:	dfc00117 	ldw	ra,4(sp)
8110f75c:	df000017 	ldw	fp,0(sp)
8110f760:	dec00204 	addi	sp,sp,8
8110f764:	f800283a 	ret

8110f768 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8110f768:	defffe04 	addi	sp,sp,-8
8110f76c:	de00012e 	bgeu	sp,et,8110f774 <vFailOutAckHandlerTaskCreate+0xc>
8110f770:	003b68fa 	trap	3
8110f774:	dfc00115 	stw	ra,4(sp)
8110f778:	df000015 	stw	fp,0(sp)
8110f77c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8110f780:	d0a04e17 	ldw	r2,-32456(gp)
8110f784:	100f883a 	mov	r7,r2
8110f788:	01800704 	movi	r6,28
8110f78c:	01400044 	movi	r5,1
8110f790:	01204534 	movhi	r4,33044
8110f794:	213b3204 	addi	r4,r4,-4920
8110f798:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
8110f79c:	0001883a 	nop
8110f7a0:	e037883a 	mov	sp,fp
8110f7a4:	dfc00117 	ldw	ra,4(sp)
8110f7a8:	df000017 	ldw	fp,0(sp)
8110f7ac:	dec00204 	addi	sp,sp,8
8110f7b0:	f800283a 	ret

8110f7b4 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8110f7b4:	defffe04 	addi	sp,sp,-8
8110f7b8:	de00012e 	bgeu	sp,et,8110f7c0 <vFailCreateTimerRetransmisison+0xc>
8110f7bc:	003b68fa 	trap	3
8110f7c0:	dfc00115 	stw	ra,4(sp)
8110f7c4:	df000015 	stw	fp,0(sp)
8110f7c8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
8110f7cc:	d0a04e17 	ldw	r2,-32456(gp)
8110f7d0:	100f883a 	mov	r7,r2
8110f7d4:	018007c4 	movi	r6,31
8110f7d8:	01400044 	movi	r5,1
8110f7dc:	01204534 	movhi	r4,33044
8110f7e0:	213b3a04 	addi	r4,r4,-4888
8110f7e4:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
8110f7e8:	0001883a 	nop
8110f7ec:	e037883a 	mov	sp,fp
8110f7f0:	dfc00117 	ldw	ra,4(sp)
8110f7f4:	df000017 	ldw	fp,0(sp)
8110f7f8:	dec00204 	addi	sp,sp,8
8110f7fc:	f800283a 	ret

8110f800 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8110f800:	defffe04 	addi	sp,sp,-8
8110f804:	de00012e 	bgeu	sp,et,8110f80c <vCouldNotCheckBufferTimeOutFunction+0xc>
8110f808:	003b68fa 	trap	3
8110f80c:	dfc00115 	stw	ra,4(sp)
8110f810:	df000015 	stw	fp,0(sp)
8110f814:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8110f818:	d0a04e17 	ldw	r2,-32456(gp)
8110f81c:	100f883a 	mov	r7,r2
8110f820:	01800904 	movi	r6,36
8110f824:	01400044 	movi	r5,1
8110f828:	01204534 	movhi	r4,33044
8110f82c:	213b4204 	addi	r4,r4,-4856
8110f830:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
8110f834:	0001883a 	nop
8110f838:	e037883a 	mov	sp,fp
8110f83c:	dfc00117 	ldw	ra,4(sp)
8110f840:	df000017 	ldw	fp,0(sp)
8110f844:	dec00204 	addi	sp,sp,8
8110f848:	f800283a 	ret

8110f84c <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8110f84c:	defffe04 	addi	sp,sp,-8
8110f850:	de00012e 	bgeu	sp,et,8110f858 <vFailTimeoutCheckerTaskCreate+0xc>
8110f854:	003b68fa 	trap	3
8110f858:	dfc00115 	stw	ra,4(sp)
8110f85c:	df000015 	stw	fp,0(sp)
8110f860:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8110f864:	d0a04e17 	ldw	r2,-32456(gp)
8110f868:	100f883a 	mov	r7,r2
8110f86c:	01800a04 	movi	r6,40
8110f870:	01400044 	movi	r5,1
8110f874:	01204534 	movhi	r4,33044
8110f878:	213b4c04 	addi	r4,r4,-4816
8110f87c:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementaï¿½ï¿½o de indicaï¿½ï¿½o de falha antes de finalizar a execuï¿½ï¿½o
	 * Indicar falha com LEDs pois ï¿½ o unico HW inicializada atï¿½ o momento
	 */
}
8110f880:	0001883a 	nop
8110f884:	e037883a 	mov	sp,fp
8110f888:	dfc00117 	ldw	ra,4(sp)
8110f88c:	df000017 	ldw	fp,0(sp)
8110f890:	dec00204 	addi	sp,sp,8
8110f894:	f800283a 	ret

8110f898 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8110f898:	defffe04 	addi	sp,sp,-8
8110f89c:	de00012e 	bgeu	sp,et,8110f8a4 <vFailGetBlockingSemTimeoutTask+0xc>
8110f8a0:	003b68fa 	trap	3
8110f8a4:	dfc00115 	stw	ra,4(sp)
8110f8a8:	df000015 	stw	fp,0(sp)
8110f8ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
8110f8b0:	d0a04e17 	ldw	r2,-32456(gp)
8110f8b4:	100f883a 	mov	r7,r2
8110f8b8:	018009c4 	movi	r6,39
8110f8bc:	01400044 	movi	r5,1
8110f8c0:	01204534 	movhi	r4,33044
8110f8c4:	213b5704 	addi	r4,r4,-4772
8110f8c8:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8110f8cc:	d0a04e17 	ldw	r2,-32456(gp)
8110f8d0:	100f883a 	mov	r7,r2
8110f8d4:	01800cc4 	movi	r6,51
8110f8d8:	01400044 	movi	r5,1
8110f8dc:	01204534 	movhi	r4,33044
8110f8e0:	213b6104 	addi	r4,r4,-4732
8110f8e4:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f8e8:	0001883a 	nop
8110f8ec:	e037883a 	mov	sp,fp
8110f8f0:	dfc00117 	ldw	ra,4(sp)
8110f8f4:	df000017 	ldw	fp,0(sp)
8110f8f8:	dec00204 	addi	sp,sp,8
8110f8fc:	f800283a 	ret

8110f900 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8110f900:	defffe04 	addi	sp,sp,-8
8110f904:	de00012e 	bgeu	sp,et,8110f90c <vFailPostBlockingSemTimeoutTask+0xc>
8110f908:	003b68fa 	trap	3
8110f90c:	dfc00115 	stw	ra,4(sp)
8110f910:	df000015 	stw	fp,0(sp)
8110f914:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8110f918:	d0a04e17 	ldw	r2,-32456(gp)
8110f91c:	100f883a 	mov	r7,r2
8110f920:	01800a04 	movi	r6,40
8110f924:	01400044 	movi	r5,1
8110f928:	01204534 	movhi	r4,33044
8110f92c:	213b6e04 	addi	r4,r4,-4680
8110f930:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
8110f934:	d0a04e17 	ldw	r2,-32456(gp)
8110f938:	100f883a 	mov	r7,r2
8110f93c:	01800c84 	movi	r6,50
8110f940:	01400044 	movi	r5,1
8110f944:	01204534 	movhi	r4,33044
8110f948:	213b7904 	addi	r4,r4,-4636
8110f94c:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f950:	0001883a 	nop
8110f954:	e037883a 	mov	sp,fp
8110f958:	dfc00117 	ldw	ra,4(sp)
8110f95c:	df000017 	ldw	fp,0(sp)
8110f960:	dec00204 	addi	sp,sp,8
8110f964:	f800283a 	ret

8110f968 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8110f968:	defffe04 	addi	sp,sp,-8
8110f96c:	de00012e 	bgeu	sp,et,8110f974 <vFailCouldNotRetransmitTimeoutTask+0xc>
8110f970:	003b68fa 	trap	3
8110f974:	dfc00115 	stw	ra,4(sp)
8110f978:	df000015 	stw	fp,0(sp)
8110f97c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
8110f980:	d0a04e17 	ldw	r2,-32456(gp)
8110f984:	100f883a 	mov	r7,r2
8110f988:	01800ac4 	movi	r6,43
8110f98c:	01400044 	movi	r5,1
8110f990:	01204534 	movhi	r4,33044
8110f994:	213b8604 	addi	r4,r4,-4584
8110f998:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
8110f99c:	d0a04e17 	ldw	r2,-32456(gp)
8110f9a0:	100f883a 	mov	r7,r2
8110f9a4:	01801644 	movi	r6,89
8110f9a8:	01400044 	movi	r5,1
8110f9ac:	01204534 	movhi	r4,33044
8110f9b0:	213b9104 	addi	r4,r4,-4540
8110f9b4:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110f9b8:	0001883a 	nop
8110f9bc:	e037883a 	mov	sp,fp
8110f9c0:	dfc00117 	ldw	ra,4(sp)
8110f9c4:	df000017 	ldw	fp,0(sp)
8110f9c8:	dec00204 	addi	sp,sp,8
8110f9cc:	f800283a 	ret

8110f9d0 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8110f9d0:	defffe04 	addi	sp,sp,-8
8110f9d4:	de00012e 	bgeu	sp,et,8110f9dc <vCouldNotRetransmitB32TimeoutTask+0xc>
8110f9d8:	003b68fa 	trap	3
8110f9dc:	dfc00115 	stw	ra,4(sp)
8110f9e0:	df000015 	stw	fp,0(sp)
8110f9e4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8110f9e8:	d0a04e17 	ldw	r2,-32456(gp)
8110f9ec:	100f883a 	mov	r7,r2
8110f9f0:	01800a84 	movi	r6,42
8110f9f4:	01400044 	movi	r5,1
8110f9f8:	01204534 	movhi	r4,33044
8110f9fc:	213ba804 	addi	r4,r4,-4448
8110fa00:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8110fa04:	d0a04e17 	ldw	r2,-32456(gp)
8110fa08:	100f883a 	mov	r7,r2
8110fa0c:	01801444 	movi	r6,81
8110fa10:	01400044 	movi	r5,1
8110fa14:	01204534 	movhi	r4,33044
8110fa18:	213bb304 	addi	r4,r4,-4404
8110fa1c:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110fa20:	0001883a 	nop
8110fa24:	e037883a 	mov	sp,fp
8110fa28:	dfc00117 	ldw	ra,4(sp)
8110fa2c:	df000017 	ldw	fp,0(sp)
8110fa30:	dec00204 	addi	sp,sp,8
8110fa34:	f800283a 	ret

8110fa38 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8110fa38:	defffe04 	addi	sp,sp,-8
8110fa3c:	de00012e 	bgeu	sp,et,8110fa44 <vCouldNotRetransmitB64TimeoutTask+0xc>
8110fa40:	003b68fa 	trap	3
8110fa44:	dfc00115 	stw	ra,4(sp)
8110fa48:	df000015 	stw	fp,0(sp)
8110fa4c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
8110fa50:	d0a04e17 	ldw	r2,-32456(gp)
8110fa54:	100f883a 	mov	r7,r2
8110fa58:	01800a84 	movi	r6,42
8110fa5c:	01400044 	movi	r5,1
8110fa60:	01204534 	movhi	r4,33044
8110fa64:	213bc804 	addi	r4,r4,-4320
8110fa68:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8110fa6c:	d0a04e17 	ldw	r2,-32456(gp)
8110fa70:	100f883a 	mov	r7,r2
8110fa74:	01801444 	movi	r6,81
8110fa78:	01400044 	movi	r5,1
8110fa7c:	01204534 	movhi	r4,33044
8110fa80:	213bd304 	addi	r4,r4,-4276
8110fa84:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110fa88:	0001883a 	nop
8110fa8c:	e037883a 	mov	sp,fp
8110fa90:	dfc00117 	ldw	ra,4(sp)
8110fa94:	df000017 	ldw	fp,0(sp)
8110fa98:	dec00204 	addi	sp,sp,8
8110fa9c:	f800283a 	ret

8110faa0 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8110faa0:	defffe04 	addi	sp,sp,-8
8110faa4:	de00012e 	bgeu	sp,et,8110faac <vCouldNotRetransmitB128TimeoutTask+0xc>
8110faa8:	003b68fa 	trap	3
8110faac:	dfc00115 	stw	ra,4(sp)
8110fab0:	df000015 	stw	fp,0(sp)
8110fab4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8110fab8:	d0a04e17 	ldw	r2,-32456(gp)
8110fabc:	100f883a 	mov	r7,r2
8110fac0:	01800ac4 	movi	r6,43
8110fac4:	01400044 	movi	r5,1
8110fac8:	01204534 	movhi	r4,33044
8110facc:	213be804 	addi	r4,r4,-4192
8110fad0:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8110fad4:	d0a04e17 	ldw	r2,-32456(gp)
8110fad8:	100f883a 	mov	r7,r2
8110fadc:	01801484 	movi	r6,82
8110fae0:	01400044 	movi	r5,1
8110fae4:	01204534 	movhi	r4,33044
8110fae8:	213bf304 	addi	r4,r4,-4148
8110faec:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110faf0:	0001883a 	nop
8110faf4:	e037883a 	mov	sp,fp
8110faf8:	dfc00117 	ldw	ra,4(sp)
8110fafc:	df000017 	ldw	fp,0(sp)
8110fb00:	dec00204 	addi	sp,sp,8
8110fb04:	f800283a 	ret

8110fb08 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8110fb08:	defffe04 	addi	sp,sp,-8
8110fb0c:	de00012e 	bgeu	sp,et,8110fb14 <vFailStartTimerRetransmission+0xc>
8110fb10:	003b68fa 	trap	3
8110fb14:	dfc00115 	stw	ra,4(sp)
8110fb18:	df000015 	stw	fp,0(sp)
8110fb1c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
8110fb20:	d0a04e17 	ldw	r2,-32456(gp)
8110fb24:	100f883a 	mov	r7,r2
8110fb28:	01800984 	movi	r6,38
8110fb2c:	01400044 	movi	r5,1
8110fb30:	01204534 	movhi	r4,33044
8110fb34:	213c0804 	addi	r4,r4,-4064
8110fb38:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8110fb3c:	d0a04e17 	ldw	r2,-32456(gp)
8110fb40:	100f883a 	mov	r7,r2
8110fb44:	01800d44 	movi	r6,53
8110fb48:	01400044 	movi	r5,1
8110fb4c:	01204534 	movhi	r4,33044
8110fb50:	213c1204 	addi	r4,r4,-4024
8110fb54:	1112ccc0 	call	81112ccc <fwrite>
	#endif
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110fb58:	0001883a 	nop
8110fb5c:	e037883a 	mov	sp,fp
8110fb60:	dfc00117 	ldw	ra,4(sp)
8110fb64:	df000017 	ldw	fp,0(sp)
8110fb68:	dec00204 	addi	sp,sp,8
8110fb6c:	f800283a 	ret

8110fb70 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8110fb70:	defffe04 	addi	sp,sp,-8
8110fb74:	de00012e 	bgeu	sp,et,8110fb7c <vCouldNotSendTurnOff+0xc>
8110fb78:	003b68fa 	trap	3
8110fb7c:	dfc00115 	stw	ra,4(sp)
8110fb80:	df000015 	stw	fp,0(sp)
8110fb84:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
8110fb88:	d0a04e17 	ldw	r2,-32456(gp)
8110fb8c:	100f883a 	mov	r7,r2
8110fb90:	01800744 	movi	r6,29
8110fb94:	01400044 	movi	r5,1
8110fb98:	01204534 	movhi	r4,33044
8110fb9c:	213c2004 	addi	r4,r4,-3968
8110fba0:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
8110fba4:	d0a04e17 	ldw	r2,-32456(gp)
8110fba8:	100f883a 	mov	r7,r2
8110fbac:	01800984 	movi	r6,38
8110fbb0:	01400044 	movi	r5,1
8110fbb4:	01204534 	movhi	r4,33044
8110fbb8:	213c2804 	addi	r4,r4,-3936
8110fbbc:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110fbc0:	0001883a 	nop
8110fbc4:	e037883a 	mov	sp,fp
8110fbc8:	dfc00117 	ldw	ra,4(sp)
8110fbcc:	df000017 	ldw	fp,0(sp)
8110fbd0:	dec00204 	addi	sp,sp,8
8110fbd4:	f800283a 	ret

8110fbd8 <vCouldNotSendLog>:


void vCouldNotSendLog( void )
{
8110fbd8:	defffe04 	addi	sp,sp,-8
8110fbdc:	de00012e 	bgeu	sp,et,8110fbe4 <vCouldNotSendLog+0xc>
8110fbe0:	003b68fa 	trap	3
8110fbe4:	dfc00115 	stw	ra,4(sp)
8110fbe8:	df000015 	stw	fp,0(sp)
8110fbec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
8110fbf0:	d0a04e17 	ldw	r2,-32456(gp)
8110fbf4:	100f883a 	mov	r7,r2
8110fbf8:	01800644 	movi	r6,25
8110fbfc:	01400044 	movi	r5,1
8110fc00:	01204534 	movhi	r4,33044
8110fc04:	213c3204 	addi	r4,r4,-3896
8110fc08:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
8110fc0c:	d0a04e17 	ldw	r2,-32456(gp)
8110fc10:	100f883a 	mov	r7,r2
8110fc14:	018008c4 	movi	r6,35
8110fc18:	01400044 	movi	r5,1
8110fc1c:	01204534 	movhi	r4,33044
8110fc20:	213c3904 	addi	r4,r4,-3868
8110fc24:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110fc28:	0001883a 	nop
8110fc2c:	e037883a 	mov	sp,fp
8110fc30:	dfc00117 	ldw	ra,4(sp)
8110fc34:	df000017 	ldw	fp,0(sp)
8110fc38:	dec00204 	addi	sp,sp,8
8110fc3c:	f800283a 	ret

8110fc40 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8110fc40:	defffd04 	addi	sp,sp,-12
8110fc44:	de00012e 	bgeu	sp,et,8110fc4c <vCouldNotSendTMPusCommand+0xc>
8110fc48:	003b68fa 	trap	3
8110fc4c:	dfc00215 	stw	ra,8(sp)
8110fc50:	df000115 	stw	fp,4(sp)
8110fc54:	df000104 	addi	fp,sp,4
8110fc58:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8110fc5c:	d0a04e17 	ldw	r2,-32456(gp)
8110fc60:	100f883a 	mov	r7,r2
8110fc64:	01800884 	movi	r6,34
8110fc68:	01400044 	movi	r5,1
8110fc6c:	01204534 	movhi	r4,33044
8110fc70:	213c4204 	addi	r4,r4,-3832
8110fc74:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
8110fc78:	d0a04e17 	ldw	r2,-32456(gp)
8110fc7c:	100f883a 	mov	r7,r2
8110fc80:	01800ac4 	movi	r6,43
8110fc84:	01400044 	movi	r5,1
8110fc88:	01204534 	movhi	r4,33044
8110fc8c:	213c4b04 	addi	r4,r4,-3796
8110fc90:	1112ccc0 	call	81112ccc <fwrite>
		debug(fp,"cData");
8110fc94:	d0a04e17 	ldw	r2,-32456(gp)
8110fc98:	100f883a 	mov	r7,r2
8110fc9c:	01800144 	movi	r6,5
8110fca0:	01400044 	movi	r5,1
8110fca4:	01204534 	movhi	r4,33044
8110fca8:	213c5604 	addi	r4,r4,-3752
8110fcac:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110fcb0:	0001883a 	nop
8110fcb4:	e037883a 	mov	sp,fp
8110fcb8:	dfc00117 	ldw	ra,4(sp)
8110fcbc:	df000017 	ldw	fp,0(sp)
8110fcc0:	dec00204 	addi	sp,sp,8
8110fcc4:	f800283a 	ret

8110fcc8 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8110fcc8:	defffe04 	addi	sp,sp,-8
8110fccc:	de00012e 	bgeu	sp,et,8110fcd4 <vWarnCouldNotgetMutexRetrans128+0xc>
8110fcd0:	003b68fa 	trap	3
8110fcd4:	dfc00115 	stw	ra,4(sp)
8110fcd8:	df000015 	stw	fp,0(sp)
8110fcdc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
8110fce0:	d0a04e17 	ldw	r2,-32456(gp)
8110fce4:	100f883a 	mov	r7,r2
8110fce8:	01800a04 	movi	r6,40
8110fcec:	01400044 	movi	r5,1
8110fcf0:	01204534 	movhi	r4,33044
8110fcf4:	213c5804 	addi	r4,r4,-3744
8110fcf8:	1112ccc0 	call	81112ccc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8110fcfc:	d0a04e17 	ldw	r2,-32456(gp)
8110fd00:	100f883a 	mov	r7,r2
8110fd04:	018014c4 	movi	r6,83
8110fd08:	01400044 	movi	r5,1
8110fd0c:	01204534 	movhi	r4,33044
8110fd10:	213c6304 	addi	r4,r4,-3700
8110fd14:	1112ccc0 	call	81112ccc <fwrite>
	#endif	
	/*
	 * Implementa��o de indica��o de falha antes de finalizar a execu��o
	 * Indicar falha com LEDs pois � o unico HW inicializada at� o momento
	 */
}
8110fd18:	0001883a 	nop
8110fd1c:	e037883a 	mov	sp,fp
8110fd20:	dfc00117 	ldw	ra,4(sp)
8110fd24:	df000017 	ldw	fp,0(sp)
8110fd28:	dec00204 	addi	sp,sp,8
8110fd2c:	f800283a 	ret

8110fd30 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8110fd30:	defffd04 	addi	sp,sp,-12
8110fd34:	de00012e 	bgeu	sp,et,8110fd3c <vNFeeNotInUse+0xc>
8110fd38:	003b68fa 	trap	3
8110fd3c:	df000215 	stw	fp,8(sp)
8110fd40:	df000204 	addi	fp,sp,8
8110fd44:	e13ffe15 	stw	r4,-8(fp)
8110fd48:	2805883a 	mov	r2,r5
8110fd4c:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8110fd50:	e0bffe17 	ldw	r2,-8(fp)
8110fd54:	e0ffff03 	ldbu	r3,-4(fp)
8110fd58:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8110fd5c:	e0bffe17 	ldw	r2,-8(fp)
8110fd60:	10002015 	stw	zero,128(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8110fd64:	e0bffe17 	ldw	r2,-8(fp)
8110fd68:	10002115 	stw	zero,132(r2)
}
8110fd6c:	0001883a 	nop
8110fd70:	e037883a 	mov	sp,fp
8110fd74:	df000017 	ldw	fp,0(sp)
8110fd78:	dec00104 	addi	sp,sp,4
8110fd7c:	f800283a 	ret

8110fd80 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8110fd80:	defffb04 	addi	sp,sp,-20
8110fd84:	de00012e 	bgeu	sp,et,8110fd8c <vNFeeStructureInit+0xc>
8110fd88:	003b68fa 	trap	3
8110fd8c:	dfc00415 	stw	ra,16(sp)
8110fd90:	df000315 	stw	fp,12(sp)
8110fd94:	df000304 	addi	fp,sp,12
8110fd98:	e13ffe15 	stw	r4,-8(fp)
8110fd9c:	2805883a 	mov	r2,r5
8110fda0:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8110fda4:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8110fda8:	e0bffe17 	ldw	r2,-8(fp)
8110fdac:	e0ffff03 	ldbu	r3,-4(fp)
8110fdb0:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8110fdb4:	e0bffe17 	ldw	r2,-8(fp)
8110fdb8:	10802804 	addi	r2,r2,160
8110fdbc:	1009883a 	mov	r4,r2
8110fdc0:	110c9f40 	call	8110c9f4 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8110fdc4:	e13ffe17 	ldw	r4,-8(fp)
8110fdc8:	110fe580 	call	8110fe58 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8110fdcc:	e0bffe17 	ldw	r2,-8(fp)
8110fdd0:	00c00044 	movi	r3,1
8110fdd4:	10c02015 	stw	r3,128(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8110fdd8:	e0bffe17 	ldw	r2,-8(fp)
8110fddc:	10002115 	stw	zero,132(r2)
    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeConfig;    
8110fde0:	e0bffe17 	ldw	r2,-8(fp)
8110fde4:	10002615 	stw	zero,152(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8110fde8:	e03ffd05 	stb	zero,-12(fp)
8110fdec:	00000906 	br	8110fe14 <vNFeeStructureInit+0x94>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
8110fdf0:	e0bffd03 	ldbu	r2,-12(fp)
8110fdf4:	e0fffe17 	ldw	r3,-8(fp)
8110fdf8:	1885883a 	add	r2,r3,r2
8110fdfc:	10802504 	addi	r2,r2,148
8110fe00:	e0fffd03 	ldbu	r3,-12(fp)
8110fe04:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8110fe08:	e0bffd03 	ldbu	r2,-12(fp)
8110fe0c:	10800044 	addi	r2,r2,1
8110fe10:	e0bffd05 	stb	r2,-12(fp)
8110fe14:	e0bffd03 	ldbu	r2,-12(fp)
8110fe18:	10800130 	cmpltui	r2,r2,4
8110fe1c:	103ff41e 	bne	r2,zero,8110fdf0 <__reset+0xfb0efdf0>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8110fe20:	e0bffe17 	ldw	r2,-8(fp)
8110fe24:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8110fe28:	e0bffe17 	ldw	r2,-8(fp)
8110fe2c:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8110fe30:	e0bffe17 	ldw	r2,-8(fp)
8110fe34:	10002215 	stw	zero,136(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8110fe38:	e0bffe17 	ldw	r2,-8(fp)
8110fe3c:	10002415 	stw	zero,144(r2)

}
8110fe40:	0001883a 	nop
8110fe44:	e037883a 	mov	sp,fp
8110fe48:	dfc00117 	ldw	ra,4(sp)
8110fe4c:	df000017 	ldw	fp,0(sp)
8110fe50:	dec00204 	addi	sp,sp,8
8110fe54:	f800283a 	ret

8110fe58 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8110fe58:	defff404 	addi	sp,sp,-48
8110fe5c:	de00012e 	bgeu	sp,et,8110fe64 <vUpdateMemMapFEE+0xc>
8110fe60:	003b68fa 	trap	3
8110fe64:	df000b15 	stw	fp,44(sp)
8110fe68:	df000b04 	addi	fp,sp,44
8110fe6c:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8110fe70:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8110fe74:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8110fe78:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8110fe7c:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8110fe80:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8110fe84:	e03ff615 	stw	zero,-40(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8110fe88:	e03ff705 	stb	zero,-36(fp)
    unsigned char ucShiftsL = 0;
8110fe8c:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8110fe90:	e03ff745 	stb	zero,-35(fp)
    unsigned long ulLastOffset = 0;
8110fe94:	e03ff815 	stw	zero,-32(fp)
    unsigned long ulStepHalfCCD = 0;
8110fe98:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8110fe9c:	e17fff17 	ldw	r5,-4(fp)
8110fea0:	01035a34 	movhi	r4,3432
8110fea4:	21348c04 	addi	r4,r4,-11728
8110fea8:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8110feac:	e13fff17 	ldw	r4,-4(fp)
8110feb0:	21000003 	ldbu	r4,0(r4)
8110feb4:	21403fcc 	andi	r5,r4,255
8110feb8:	01035a34 	movhi	r4,3432
8110febc:	21348c04 	addi	r4,r4,-11728
8110fec0:	2909383a 	mul	r4,r5,r4
8110fec4:	200b883a 	mov	r5,r4
8110fec8:	e13fff17 	ldw	r4,-4(fp)
8110fecc:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8110fed0:	e13fff17 	ldw	r4,-4(fp)
8110fed4:	21400117 	ldw	r5,4(r4)
8110fed8:	01033234 	movhi	r4,3272
8110fedc:	21348c04 	addi	r4,r4,-11728
8110fee0:	290b883a 	add	r5,r5,r4
8110fee4:	e13fff17 	ldw	r4,-4(fp)
8110fee8:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8110feec:	e13fff17 	ldw	r4,-4(fp)
8110fef0:	21002a0b 	ldhu	r4,168(r4)
8110fef4:	217fffcc 	andi	r5,r4,65535
8110fef8:	e13fff17 	ldw	r4,-4(fp)
8110fefc:	2100290b 	ldhu	r4,164(r4)
8110ff00:	213fffcc 	andi	r4,r4,65535
8110ff04:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8110ff08:	e13fff17 	ldw	r4,-4(fp)
8110ff0c:	2100298b 	ldhu	r4,166(r4)
8110ff10:	21bfffcc 	andi	r6,r4,65535
8110ff14:	e13fff17 	ldw	r4,-4(fp)
8110ff18:	2100288b 	ldhu	r4,162(r4)
8110ff1c:	213fffcc 	andi	r4,r4,65535
8110ff20:	310d883a 	add	r6,r6,r4
8110ff24:	e13fff17 	ldw	r4,-4(fp)
8110ff28:	2100280b 	ldhu	r4,160(r4)
8110ff2c:	213fffcc 	andi	r4,r4,65535
8110ff30:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8110ff34:	2909383a 	mul	r4,r5,r4
8110ff38:	e13ff915 	stw	r4,-28(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8110ff3c:	e13ff917 	ldw	r4,-28(fp)
8110ff40:	2109883a 	add	r4,r4,r4
8110ff44:	200b883a 	mov	r5,r4
8110ff48:	e13fff17 	ldw	r4,-4(fp)
8110ff4c:	2140048d 	sth	r5,18(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8110ff50:	e13fff17 	ldw	r4,-4(fp)
8110ff54:	2100048b 	ldhu	r4,18(r4)
8110ff58:	213fffcc 	andi	r4,r4,65535
8110ff5c:	2008d0fa 	srli	r4,r4,3
8110ff60:	213fffcc 	andi	r4,r4,65535
8110ff64:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8110ff68:	e13fff17 	ldw	r4,-4(fp)
8110ff6c:	2100048b 	ldhu	r4,18(r4)
8110ff70:	213fffcc 	andi	r4,r4,65535
8110ff74:	210001cc 	andi	r4,r4,7
8110ff78:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8110ff7c:	e13ffb17 	ldw	r4,-20(fp)
8110ff80:	20001326 	beq	r4,zero,8110ffd0 <vUpdateMemMapFEE+0x178>
        ulMemLinesL = ulMemLinesL + 1;
8110ff84:	e13ff517 	ldw	r4,-44(fp)
8110ff88:	21000044 	addi	r4,r4,1
8110ff8c:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8110ff90:	e13fff17 	ldw	r4,-4(fp)
8110ff94:	2100048b 	ldhu	r4,18(r4)
8110ff98:	e17ffb17 	ldw	r5,-20(fp)
8110ff9c:	2149c83a 	sub	r4,r4,r5
8110ffa0:	21000204 	addi	r4,r4,8
8110ffa4:	200b883a 	mov	r5,r4
8110ffa8:	e13fff17 	ldw	r4,-4(fp)
8110ffac:	2140048d 	sth	r5,18(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8110ffb0:	e13ffb17 	ldw	r4,-20(fp)
8110ffb4:	200b883a 	mov	r5,r4
8110ffb8:	01000204 	movi	r4,8
8110ffbc:	2149c83a 	sub	r4,r4,r5
8110ffc0:	200b883a 	mov	r5,r4
8110ffc4:	e13fff17 	ldw	r4,-4(fp)
8110ffc8:	21400505 	stb	r5,20(r4)
8110ffcc:	00000206 	br	8110ffd8 <vUpdateMemMapFEE+0x180>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8110ffd0:	e13fff17 	ldw	r4,-4(fp)
8110ffd4:	20000505 	stb	zero,20(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8110ffd8:	e13ff517 	ldw	r4,-44(fp)
8110ffdc:	2008d13a 	srli	r4,r4,4
8110ffe0:	e13ff615 	stw	r4,-40(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8110ffe4:	e13ff517 	ldw	r4,-44(fp)
8110ffe8:	210003cc 	andi	r4,r4,15
8110ffec:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8110fff0:	e13ffc17 	ldw	r4,-16(fp)
8110fff4:	20000b26 	beq	r4,zero,81110024 <vUpdateMemMapFEE+0x1cc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8110fff8:	e13ff617 	ldw	r4,-40(fp)
8110fffc:	21000044 	addi	r4,r4,1
81110000:	e13ff615 	stw	r4,-40(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
81110004:	e17ff517 	ldw	r5,-44(fp)
81110008:	e13ffc17 	ldw	r4,-16(fp)
8111000c:	290bc83a 	sub	r5,r5,r4
81110010:	e13ff617 	ldw	r4,-40(fp)
81110014:	2909883a 	add	r4,r5,r4
81110018:	21000404 	addi	r4,r4,16
8111001c:	e13ffa15 	stw	r4,-24(fp)
81110020:	00000406 	br	81110034 <vUpdateMemMapFEE+0x1dc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
81110024:	e17ff517 	ldw	r5,-44(fp)
81110028:	e13ff617 	ldw	r4,-40(fp)
8111002c:	2909883a 	add	r4,r5,r4
81110030:	e13ffa15 	stw	r4,-24(fp)
    }

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
81110034:	e13ffb17 	ldw	r4,-20(fp)
81110038:	20000926 	beq	r4,zero,81110060 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111003c:	e13ffc17 	ldw	r4,-16(fp)
81110040:	2109883a 	add	r4,r4,r4
81110044:	2109883a 	add	r4,r4,r4
81110048:	200b883a 	mov	r5,r4
8111004c:	e13ffb17 	ldw	r4,-20(fp)
81110050:	2008d07a 	srli	r4,r4,1
81110054:	2909883a 	add	r4,r5,r4
81110058:	e13ff705 	stb	r4,-36(fp)
8111005c:	00000406 	br	81110070 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
81110060:	e13ffc17 	ldw	r4,-16(fp)
81110064:	2109883a 	add	r4,r4,r4
81110068:	2109883a 	add	r4,r4,r4
8111006c:	e13ff705 	stb	r4,-36(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
81110070:	e13ff703 	ldbu	r4,-36(fp)
81110074:	01401004 	movi	r5,64
81110078:	2909c83a 	sub	r4,r5,r4
8111007c:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
81110080:	e13ffd03 	ldbu	r4,-12(fp)
81110084:	217ff804 	addi	r5,r4,-32
81110088:	28000416 	blt	r5,zero,8111009c <vUpdateMemMapFEE+0x244>
8111008c:	013fffc4 	movi	r4,-1
81110090:	2144d83a 	srl	r2,r4,r5
81110094:	0007883a 	mov	r3,zero
81110098:	00000a06 	br	811100c4 <vUpdateMemMapFEE+0x26c>
8111009c:	017fffc4 	movi	r5,-1
811100a0:	280c907a 	slli	r6,r5,1
811100a4:	014007c4 	movi	r5,31
811100a8:	290bc83a 	sub	r5,r5,r4
811100ac:	314a983a 	sll	r5,r6,r5
811100b0:	01bfffc4 	movi	r6,-1
811100b4:	3104d83a 	srl	r2,r6,r4
811100b8:	2884b03a 	or	r2,r5,r2
811100bc:	017fffc4 	movi	r5,-1
811100c0:	2906d83a 	srl	r3,r5,r4
811100c4:	e13fff17 	ldw	r4,-4(fp)
811100c8:	20800615 	stw	r2,24(r4)
811100cc:	20c00715 	stw	r3,28(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
811100d0:	e0bff617 	ldw	r2,-40(fp)
811100d4:	1007883a 	mov	r3,r2
811100d8:	e0bfff17 	ldw	r2,-4(fp)
811100dc:	10c0040d 	sth	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
811100e0:	e0bfff17 	ldw	r2,-4(fp)
811100e4:	10c00117 	ldw	r3,4(r2)
811100e8:	008004b4 	movhi	r2,18
811100ec:	10a40004 	addi	r2,r2,-28672
811100f0:	1885883a 	add	r2,r3,r2
811100f4:	e0bff815 	stw	r2,-32(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
811100f8:	e0bfff17 	ldw	r2,-4(fp)
811100fc:	1080048b 	ldhu	r2,18(r2)
81110100:	10ffffcc 	andi	r3,r2,65535
81110104:	008000b4 	movhi	r2,2
81110108:	10a40004 	addi	r2,r2,-28672
8111010c:	1885883a 	add	r2,r3,r2
81110110:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81110114:	e03ff745 	stb	zero,-35(fp)
81110118:	00001906 	br	81110180 <vUpdateMemMapFEE+0x328>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111011c:	e0bff743 	ldbu	r2,-35(fp)
81110120:	e0ffff17 	ldw	r3,-4(fp)
81110124:	10800624 	muli	r2,r2,24
81110128:	1885883a 	add	r2,r3,r2
8111012c:	10800804 	addi	r2,r2,32
81110130:	e0fff817 	ldw	r3,-32(fp)
81110134:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81110138:	e0fff817 	ldw	r3,-32(fp)
8111013c:	e0bffe17 	ldw	r2,-8(fp)
81110140:	1885883a 	add	r2,r3,r2
81110144:	e0bff815 	stw	r2,-32(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
81110148:	e0bff743 	ldbu	r2,-35(fp)
8111014c:	e0ffff17 	ldw	r3,-4(fp)
81110150:	10800624 	muli	r2,r2,24
81110154:	1885883a 	add	r2,r3,r2
81110158:	10800b04 	addi	r2,r2,44
8111015c:	e0fff817 	ldw	r3,-32(fp)
81110160:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81110164:	e0fff817 	ldw	r3,-32(fp)
81110168:	e0bffe17 	ldw	r2,-8(fp)
8111016c:	1885883a 	add	r2,r3,r2
81110170:	e0bff815 	stw	r2,-32(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81110174:	e0bff743 	ldbu	r2,-35(fp)
81110178:	10800044 	addi	r2,r2,1
8111017c:	e0bff745 	stb	r2,-35(fp)
81110180:	e0bff743 	ldbu	r2,-35(fp)
81110184:	10800130 	cmpltui	r2,r2,4
81110188:	103fe41e 	bne	r2,zero,8111011c <__reset+0xfb0f011c>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
8111018c:	0001883a 	nop
81110190:	e037883a 	mov	sp,fp
81110194:	df000017 	ldw	fp,0(sp)
81110198:	dec00104 	addi	sp,sp,4
8111019c:	f800283a 	ret

811101a0 <vFeeSpwRMAPLoadDefault>:

/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
811101a0:	defffe04 	addi	sp,sp,-8
811101a4:	de00012e 	bgeu	sp,et,811101ac <vFeeSpwRMAPLoadDefault+0xc>
811101a8:	003b68fa 	trap	3
811101ac:	df000115 	stw	fp,4(sp)
811101b0:	df000104 	addi	fp,sp,4
811101b4:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configurações
}
811101b8:	0001883a 	nop
811101bc:	e037883a 	mov	sp,fp
811101c0:	df000017 	ldw	fp,0(sp)
811101c4:	dec00104 	addi	sp,sp,4
811101c8:	f800283a 	ret

811101cc <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
811101cc:	defffe04 	addi	sp,sp,-8
811101d0:	de00012e 	bgeu	sp,et,811101d8 <vFeeSpwRMAPChangeConfig+0xc>
811101d4:	003b68fa 	trap	3
811101d8:	df000115 	stw	fp,4(sp)
811101dc:	df000104 	addi	fp,sp,4
811101e0:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configurações
}
811101e4:	0001883a 	nop
811101e8:	e037883a 	mov	sp,fp
811101ec:	df000017 	ldw	fp,0(sp)
811101f0:	dec00104 	addi	sp,sp,4
811101f4:	f800283a 	ret

811101f8 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
811101f8:	defffe04 	addi	sp,sp,-8
811101fc:	de00012e 	bgeu	sp,et,81110204 <vFeeSpwRMAPChangeDefault+0xc>
81110200:	003b68fa 	trap	3
81110204:	df000115 	stw	fp,4(sp)
81110208:	df000104 	addi	fp,sp,4
8111020c:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configurações, enviar o numero do FEE tbm
}
81110210:	0001883a 	nop
81110214:	e037883a 	mov	sp,fp
81110218:	df000017 	ldw	fp,0(sp)
8111021c:	dec00104 	addi	sp,sp,4
81110220:	f800283a 	ret

81110224 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
81110224:	defffe04 	addi	sp,sp,-8
81110228:	de00012e 	bgeu	sp,et,81110230 <cFeeSpwChannelEnable+0xc>
8111022c:	003b68fa 	trap	3
81110230:	df000115 	stw	fp,4(sp)
81110234:	df000104 	addi	fp,sp,4
81110238:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o França
}
8111023c:	0001883a 	nop
81110240:	e037883a 	mov	sp,fp
81110244:	df000017 	ldw	fp,0(sp)
81110248:	dec00104 	addi	sp,sp,4
8111024c:	f800283a 	ret

81110250 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
81110250:	defffe04 	addi	sp,sp,-8
81110254:	de00012e 	bgeu	sp,et,8111025c <cFeeSpwChannelDisable+0xc>
81110258:	003b68fa 	trap	3
8111025c:	df000115 	stw	fp,4(sp)
81110260:	df000104 	addi	fp,sp,4
81110264:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o França
}
81110268:	0001883a 	nop
8111026c:	e037883a 	mov	sp,fp
81110270:	df000017 	ldw	fp,0(sp)
81110274:	dec00104 	addi	sp,sp,4
81110278:	f800283a 	ret

8111027c <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111027c:	defffe04 	addi	sp,sp,-8
81110280:	de00012e 	bgeu	sp,et,81110288 <cFeeRMAPDump+0xc>
81110284:	003b68fa 	trap	3
81110288:	df000115 	stw	fp,4(sp)
8111028c:	df000104 	addi	fp,sp,4
81110290:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
81110294:	0001883a 	nop
81110298:	e037883a 	mov	sp,fp
8111029c:	df000017 	ldw	fp,0(sp)
811102a0:	dec00104 	addi	sp,sp,4
811102a4:	f800283a 	ret

811102a8 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
811102a8:	defffe04 	addi	sp,sp,-8
811102ac:	de00012e 	bgeu	sp,et,811102b4 <cFeeRMAPEchoingEnable+0xc>
811102b0:	003b68fa 	trap	3
811102b4:	df000115 	stw	fp,4(sp)
811102b8:	df000104 	addi	fp,sp,4
811102bc:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
811102c0:	e0bfff17 	ldw	r2,-4(fp)
811102c4:	00c00044 	movi	r3,1
811102c8:	10c02315 	stw	r3,140(r2)
}
811102cc:	0001883a 	nop
811102d0:	e037883a 	mov	sp,fp
811102d4:	df000017 	ldw	fp,0(sp)
811102d8:	dec00104 	addi	sp,sp,4
811102dc:	f800283a 	ret

811102e0 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
811102e0:	defffe04 	addi	sp,sp,-8
811102e4:	de00012e 	bgeu	sp,et,811102ec <cFeeRMAPEchoingDisable+0xc>
811102e8:	003b68fa 	trap	3
811102ec:	df000115 	stw	fp,4(sp)
811102f0:	df000104 	addi	fp,sp,4
811102f4:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
811102f8:	e0bfff17 	ldw	r2,-4(fp)
811102fc:	10002315 	stw	zero,140(r2)
}
81110300:	0001883a 	nop
81110304:	e037883a 	mov	sp,fp
81110308:	df000017 	ldw	fp,0(sp)
8111030c:	dec00104 	addi	sp,sp,4
81110310:	f800283a 	ret

81110314 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
81110314:	defffe04 	addi	sp,sp,-8
81110318:	de00012e 	bgeu	sp,et,81110320 <cFeeRMAPLogEnable+0xc>
8111031c:	003b68fa 	trap	3
81110320:	df000115 	stw	fp,4(sp)
81110324:	df000104 	addi	fp,sp,4
81110328:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111032c:	e0bfff17 	ldw	r2,-4(fp)
81110330:	00c00044 	movi	r3,1
81110334:	10c02215 	stw	r3,136(r2)
}
81110338:	0001883a 	nop
8111033c:	e037883a 	mov	sp,fp
81110340:	df000017 	ldw	fp,0(sp)
81110344:	dec00104 	addi	sp,sp,4
81110348:	f800283a 	ret

8111034c <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111034c:	defffe04 	addi	sp,sp,-8
81110350:	de00012e 	bgeu	sp,et,81110358 <cFeeRMAPLogDisable+0xc>
81110354:	003b68fa 	trap	3
81110358:	df000115 	stw	fp,4(sp)
8111035c:	df000104 	addi	fp,sp,4
81110360:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
81110364:	e0bfff17 	ldw	r2,-4(fp)
81110368:	10002215 	stw	zero,136(r2)
}
8111036c:	0001883a 	nop
81110370:	e037883a 	mov	sp,fp
81110374:	df000017 	ldw	fp,0(sp)
81110378:	dec00104 	addi	sp,sp,4
8111037c:	f800283a 	ret

81110380 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
81110380:	defffe04 	addi	sp,sp,-8
81110384:	de00012e 	bgeu	sp,et,8111038c <vInitSimucamBasicHW+0xc>
81110388:	003b68fa 	trap	3
8111038c:	dfc00115 	stw	ra,4(sp)
81110390:	df000015 	stw	fp,0(sp)
81110394:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
81110398:	01403fc4 	movi	r5,255
8111039c:	0009883a 	mov	r4,zero
811103a0:	11060d40 	call	811060d4 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
811103a4:	01400834 	movhi	r5,32
811103a8:	297fffc4 	addi	r5,r5,-1
811103ac:	0009883a 	mov	r4,zero
811103b0:	11061540 	call	81106154 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
811103b4:	01400074 	movhi	r5,1
811103b8:	01000044 	movi	r4,1
811103bc:	11061540 	call	81106154 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
811103c0:	0009883a 	mov	r4,zero
811103c4:	11077300 	call	81107730 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
811103c8:	0009883a 	mov	r4,zero
811103cc:	11078000 	call	81107800 <bSSDisplayUpdate>

}
811103d0:	0001883a 	nop
811103d4:	e037883a 	mov	sp,fp
811103d8:	dfc00117 	ldw	ra,4(sp)
811103dc:	df000017 	ldw	fp,0(sp)
811103e0:	dec00204 	addi	sp,sp,8
811103e4:	f800283a 	ret

811103e8 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
811103e8:	defffd04 	addi	sp,sp,-12
811103ec:	de00012e 	bgeu	sp,et,811103f4 <bLogWriteSDCard+0xc>
811103f0:	003b68fa 	trap	3
811103f4:	df000215 	stw	fp,8(sp)
811103f8:	df000204 	addi	fp,sp,8
811103fc:	e13ffe15 	stw	r4,-8(fp)
81110400:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
81110404:	00800044 	movi	r2,1
}
81110408:	e037883a 	mov	sp,fp
8111040c:	df000017 	ldw	fp,0(sp)
81110410:	dec00104 	addi	sp,sp,4
81110414:	f800283a 	ret

81110418 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
81110418:	deffe004 	addi	sp,sp,-128
8111041c:	de00012e 	bgeu	sp,et,81110424 <vLogWriteNUC+0xc>
81110420:	003b68fa 	trap	3
81110424:	dfc01f15 	stw	ra,124(sp)
81110428:	df001e15 	stw	fp,120(sp)
8111042c:	df001e04 	addi	fp,sp,120
81110430:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
81110434:	e03fe215 	stw	zero,-120(fp)
81110438:	e0bfe304 	addi	r2,fp,-116
8111043c:	00c01b84 	movi	r3,110
81110440:	180d883a 	mov	r6,r3
81110444:	000b883a 	mov	r5,zero
81110448:	1009883a 	mov	r4,r2
8111044c:	11138300 	call	81113830 <memset>
	memset(cTemp,0,114);
81110450:	01801c84 	movi	r6,114
81110454:	000b883a 	mov	r5,zero
81110458:	e13fe204 	addi	r4,fp,-120
8111045c:	11138300 	call	81113830 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
81110460:	e13fff17 	ldw	r4,-4(fp)
81110464:	111405c0 	call	8111405c <strlen>
81110468:	10801c68 	cmpgeui	r2,r2,113
8111046c:	1000031e 	bne	r2,zero,8111047c <vLogWriteNUC+0x64>
81110470:	e13fff17 	ldw	r4,-4(fp)
81110474:	111405c0 	call	8111405c <strlen>
81110478:	00000106 	br	81110480 <vLogWriteNUC+0x68>
8111047c:	00801c44 	movi	r2,113
81110480:	100d883a 	mov	r6,r2
81110484:	e17fff17 	ldw	r5,-4(fp)
81110488:	e13fe204 	addi	r4,fp,-120
8111048c:	11136e00 	call	811136e0 <memcpy>
	vSendLog ( cDataIn );
81110490:	e13fff17 	ldw	r4,-4(fp)
81110494:	110d6e40 	call	8110d6e4 <vSendLog>
}
81110498:	0001883a 	nop
8111049c:	e037883a 	mov	sp,fp
811104a0:	dfc00117 	ldw	ra,4(sp)
811104a4:	df000017 	ldw	fp,0(sp)
811104a8:	dec00204 	addi	sp,sp,8
811104ac:	f800283a 	ret

811104b0 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
811104b0:	defffc04 	addi	sp,sp,-16
811104b4:	de00012e 	bgeu	sp,et,811104bc <vSimucamStructureInit+0xc>
811104b8:	003b68fa 	trap	3
811104bc:	dfc00315 	stw	ra,12(sp)
811104c0:	df000215 	stw	fp,8(sp)
811104c4:	df000204 	addi	fp,sp,8
811104c8:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
811104cc:	e03ffe05 	stb	zero,-8(fp)

    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
811104d0:	e0bfff17 	ldw	r2,-4(fp)
811104d4:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebConfig;
811104d8:	e0bfff17 	ldw	r2,-4(fp)
811104dc:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
811104e0:	e13fff17 	ldw	r4,-4(fp)
811104e4:	111064c0 	call	8111064c <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
811104e8:	e13fff17 	ldw	r4,-4(fp)
811104ec:	11106f00 	call	811106f0 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
811104f0:	e13fff17 	ldw	r4,-4(fp)
811104f4:	11107980 	call	81110798 <vLoadDefaultSyncSource>
    /* Reset TimeCode */
    vResetTimeCode( xMeb );
811104f8:	e13fff17 	ldw	r4,-4(fp)
811104fc:	11108780 	call	81110878 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xMeb );
81110500:	e13fff17 	ldw	r4,-4(fp)
81110504:	11109500 	call	81110950 <vLoadDefaultIdNFEEMaster>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
81110508:	e13fff17 	ldw	r4,-4(fp)
8111050c:	11108ac0 	call	811108ac <vLoadDefaultAutoResetSync>

    // LoadNumberOfNFeesSDCard();
    /* todo: Load from SDCard for now is Hardcoded for 4 instances of NFEE */
    xMeb->ucNofFeesInUse = 2;
81110510:	e0bfff17 	ldw	r2,-4(fp)
81110514:	00c00084 	movi	r3,2
81110518:	10c00205 	stb	r3,8(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111051c:	e0bfff17 	ldw	r2,-4(fp)
81110520:	10800017 	ldw	r2,0(r2)
81110524:	1000391e 	bne	r2,zero,8111060c <vSimucamStructureInit+0x15c>
        /* Are Normal Fee instances */
        for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
81110528:	e03ffe05 	stb	zero,-8(fp)
8111052c:	00003306 	br	811105fc <vSimucamStructureInit+0x14c>
            if ( ucIL < xMeb->ucNofFeesInUse ) {
81110530:	e0bfff17 	ldw	r2,-4(fp)
81110534:	10800203 	ldbu	r2,8(r2)
81110538:	10803fcc 	andi	r2,r2,255
8111053c:	e0fffe03 	ldbu	r3,-8(fp)
81110540:	18800a2e 	bgeu	r3,r2,8111056c <vSimucamStructureInit+0xbc>
                vNFeeStructureInit( &xMeb->xNfee[ ucIL ], ucIL);
81110544:	e0bffe03 	ldbu	r2,-8(fp)
81110548:	10802b24 	muli	r2,r2,172
8111054c:	10800304 	addi	r2,r2,12
81110550:	e0ffff17 	ldw	r3,-4(fp)
81110554:	1885883a 	add	r2,r3,r2
81110558:	e0fffe03 	ldbu	r3,-8(fp)
8111055c:	180b883a 	mov	r5,r3
81110560:	1009883a 	mov	r4,r2
81110564:	110fd800 	call	8110fd80 <vNFeeStructureInit>
81110568:	00000906 	br	81110590 <vSimucamStructureInit+0xe0>
            } else {
                vNFeeNotInUse( &xMeb->xNfee[ ucIL ], ucIL);
8111056c:	e0bffe03 	ldbu	r2,-8(fp)
81110570:	10802b24 	muli	r2,r2,172
81110574:	10800304 	addi	r2,r2,12
81110578:	e0ffff17 	ldw	r3,-4(fp)
8111057c:	1885883a 	add	r2,r3,r2
81110580:	e0fffe03 	ldbu	r3,-8(fp)
81110584:	180b883a 	mov	r5,r3
81110588:	1009883a 	mov	r4,r2
8111058c:	110fd300 	call	8110fd30 <vNFeeNotInUse>
            }
            xMeb->pbEnabledNFEEs[ ucIL ] = &xMeb->xNfee[ ucIL ].xControl.bEnabled;
81110590:	e0bffe03 	ldbu	r2,-8(fp)
81110594:	e0fffe03 	ldbu	r3,-8(fp)
81110598:	18c02b24 	muli	r3,r3,172
8111059c:	18c02304 	addi	r3,r3,140
811105a0:	e13fff17 	ldw	r4,-4(fp)
811105a4:	20c7883a 	add	r3,r4,r3
811105a8:	e13fff17 	ldw	r4,-4(fp)
811105ac:	108042c4 	addi	r2,r2,267
811105b0:	1085883a 	add	r2,r2,r2
811105b4:	1085883a 	add	r2,r2,r2
811105b8:	2085883a 	add	r2,r4,r2
811105bc:	10c00015 	stw	r3,0(r2)
            xMeb->pbRunningDmaNFEEs[ ucIL ] = &xMeb->xNfee[ ucIL ].xControl.bUsingDMA;
811105c0:	e0bffe03 	ldbu	r2,-8(fp)
811105c4:	e0fffe03 	ldbu	r3,-8(fp)
811105c8:	18c02b24 	muli	r3,r3,172
811105cc:	18c02404 	addi	r3,r3,144
811105d0:	e13fff17 	ldw	r4,-4(fp)
811105d4:	20c7883a 	add	r3,r4,r3
811105d8:	e13fff17 	ldw	r4,-4(fp)
811105dc:	10804444 	addi	r2,r2,273
811105e0:	1085883a 	add	r2,r2,r2
811105e4:	1085883a 	add	r2,r2,r2
811105e8:	2085883a 	add	r2,r4,r2
811105ec:	10c00015 	stw	r3,0(r2)
    xMeb->ucNofFeesInUse = 2;

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
        /* Are Normal Fee instances */
        for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
811105f0:	e0bffe03 	ldbu	r2,-8(fp)
811105f4:	10800044 	addi	r2,r2,1
811105f8:	e0bffe05 	stb	r2,-8(fp)
811105fc:	e0bffe03 	ldbu	r2,-8(fp)
81110600:	108001b0 	cmpltui	r2,r2,6
81110604:	103fca1e 	bne	r2,zero,81110530 <__reset+0xfb0f0530>
81110608:	00000806 	br	8111062c <vSimucamStructureInit+0x17c>
            xMeb->pbEnabledNFEEs[ ucIL ] = &xMeb->xNfee[ ucIL ].xControl.bEnabled;
            xMeb->pbRunningDmaNFEEs[ ucIL ] = &xMeb->xNfee[ ucIL ].xControl.bUsingDMA;
        }
    } else {
        /* Are Fast Fee instances */
        for ( ucIL = 0; ucIL < N_OF_FastFEE; ucIL++ ) {
8111060c:	e03ffe05 	stb	zero,-8(fp)
81110610:	00000306 	br	81110620 <vSimucamStructureInit+0x170>
81110614:	e0bffe03 	ldbu	r2,-8(fp)
81110618:	10800044 	addi	r2,r2,1
8111061c:	e0bffe05 	stb	r2,-8(fp)
81110620:	e0bffe03 	ldbu	r2,-8(fp)
81110624:	108000b0 	cmpltui	r2,r2,2
81110628:	103ffa1e 	bne	r2,zero,81110614 <__reset+0xfb0f0614>
            }            
        }
    }

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111062c:	e0bfff17 	ldw	r2,-4(fp)
81110630:	10010505 	stb	zero,1044(r2)

    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
81110634:	0001883a 	nop
81110638:	e037883a 	mov	sp,fp
8111063c:	dfc00117 	ldw	ra,4(sp)
81110640:	df000017 	ldw	fp,0(sp)
81110644:	dec00204 	addi	sp,sp,8
81110648:	f800283a 	ret

8111064c <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8111064c:	defffe04 	addi	sp,sp,-8
81110650:	de00012e 	bgeu	sp,et,81110658 <vLoadDefaultEPValue+0xc>
81110654:	003b68fa 	trap	3
81110658:	df000115 	stw	fp,4(sp)
8111065c:	df000104 	addi	fp,sp,4
81110660:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
81110664:	e0bfff17 	ldw	r2,-4(fp)
81110668:	00d07234 	movhi	r3,16840
8111066c:	10c10615 	stw	r3,1048(r2)
}
81110670:	0001883a 	nop
81110674:	e037883a 	mov	sp,fp
81110678:	df000017 	ldw	fp,0(sp)
8111067c:	dec00104 	addi	sp,sp,4
81110680:	f800283a 	ret

81110684 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81110684:	defffd04 	addi	sp,sp,-12
81110688:	de00012e 	bgeu	sp,et,81110690 <vChangeEPValue+0xc>
8111068c:	003b68fa 	trap	3
81110690:	df000215 	stw	fp,8(sp)
81110694:	df000204 	addi	fp,sp,8
81110698:	e13ffe15 	stw	r4,-8(fp)
8111069c:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
811106a0:	e0bffe17 	ldw	r2,-8(fp)
811106a4:	e0ffff17 	ldw	r3,-4(fp)
811106a8:	10c10615 	stw	r3,1048(r2)
}
811106ac:	0001883a 	nop
811106b0:	e037883a 	mov	sp,fp
811106b4:	df000017 	ldw	fp,0(sp)
811106b8:	dec00104 	addi	sp,sp,4
811106bc:	f800283a 	ret

811106c0 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
811106c0:	defffd04 	addi	sp,sp,-12
811106c4:	de00012e 	bgeu	sp,et,811106cc <vChangeDefaultEPValue+0xc>
811106c8:	003b68fa 	trap	3
811106cc:	df000215 	stw	fp,8(sp)
811106d0:	df000204 	addi	fp,sp,8
811106d4:	e13ffe15 	stw	r4,-8(fp)
811106d8:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
811106dc:	0001883a 	nop
811106e0:	e037883a 	mov	sp,fp
811106e4:	df000017 	ldw	fp,0(sp)
811106e8:	dec00104 	addi	sp,sp,4
811106ec:	f800283a 	ret

811106f0 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
811106f0:	defffe04 	addi	sp,sp,-8
811106f4:	de00012e 	bgeu	sp,et,811106fc <vLoadDefaultRTValue+0xc>
811106f8:	003b68fa 	trap	3
811106fc:	df000115 	stw	fp,4(sp)
81110700:	df000104 	addi	fp,sp,4
81110704:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
81110708:	e0ffff17 	ldw	r3,-4(fp)
8111070c:	00901eb4 	movhi	r2,16506
81110710:	10a66684 	addi	r2,r2,-26214
81110714:	18810715 	stw	r2,1052(r3)
}
81110718:	0001883a 	nop
8111071c:	e037883a 	mov	sp,fp
81110720:	df000017 	ldw	fp,0(sp)
81110724:	dec00104 	addi	sp,sp,4
81110728:	f800283a 	ret

8111072c <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111072c:	defffd04 	addi	sp,sp,-12
81110730:	de00012e 	bgeu	sp,et,81110738 <vChangeRTValue+0xc>
81110734:	003b68fa 	trap	3
81110738:	df000215 	stw	fp,8(sp)
8111073c:	df000204 	addi	fp,sp,8
81110740:	e13ffe15 	stw	r4,-8(fp)
81110744:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
81110748:	e0bffe17 	ldw	r2,-8(fp)
8111074c:	e0ffff17 	ldw	r3,-4(fp)
81110750:	10c10715 	stw	r3,1052(r2)
}
81110754:	0001883a 	nop
81110758:	e037883a 	mov	sp,fp
8111075c:	df000017 	ldw	fp,0(sp)
81110760:	dec00104 	addi	sp,sp,4
81110764:	f800283a 	ret

81110768 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81110768:	defffd04 	addi	sp,sp,-12
8111076c:	de00012e 	bgeu	sp,et,81110774 <vChangeDefaultRTValue+0xc>
81110770:	003b68fa 	trap	3
81110774:	df000215 	stw	fp,8(sp)
81110778:	df000204 	addi	fp,sp,8
8111077c:	e13ffe15 	stw	r4,-8(fp)
81110780:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
81110784:	0001883a 	nop
81110788:	e037883a 	mov	sp,fp
8111078c:	df000017 	ldw	fp,0(sp)
81110790:	dec00104 	addi	sp,sp,4
81110794:	f800283a 	ret

81110798 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
81110798:	defffe04 	addi	sp,sp,-8
8111079c:	de00012e 	bgeu	sp,et,811107a4 <vLoadDefaultSyncSource+0xc>
811107a0:	003b68fa 	trap	3
811107a4:	df000115 	stw	fp,4(sp)
811107a8:	df000104 	addi	fp,sp,4
811107ac:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
811107b0:	e0bfff17 	ldw	r2,-4(fp)
811107b4:	10010815 	stw	zero,1056(r2)
}
811107b8:	0001883a 	nop
811107bc:	e037883a 	mov	sp,fp
811107c0:	df000017 	ldw	fp,0(sp)
811107c4:	dec00104 	addi	sp,sp,4
811107c8:	f800283a 	ret

811107cc <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
811107cc:	defffd04 	addi	sp,sp,-12
811107d0:	de00012e 	bgeu	sp,et,811107d8 <vChangeSyncSource+0xc>
811107d4:	003b68fa 	trap	3
811107d8:	df000215 	stw	fp,8(sp)
811107dc:	df000204 	addi	fp,sp,8
811107e0:	e13ffe15 	stw	r4,-8(fp)
811107e4:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
811107e8:	e0bffe17 	ldw	r2,-8(fp)
811107ec:	e0ffff17 	ldw	r3,-4(fp)
811107f0:	10c10815 	stw	r3,1056(r2)
}
811107f4:	0001883a 	nop
811107f8:	e037883a 	mov	sp,fp
811107fc:	df000017 	ldw	fp,0(sp)
81110800:	dec00104 	addi	sp,sp,4
81110804:	f800283a 	ret

81110808 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
81110808:	defffd04 	addi	sp,sp,-12
8111080c:	de00012e 	bgeu	sp,et,81110814 <vChangeDefaultSyncSource+0xc>
81110810:	003b68fa 	trap	3
81110814:	df000215 	stw	fp,8(sp)
81110818:	df000204 	addi	fp,sp,8
8111081c:	e13ffe15 	stw	r4,-8(fp)
81110820:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
81110824:	0001883a 	nop
81110828:	e037883a 	mov	sp,fp
8111082c:	df000017 	ldw	fp,0(sp)
81110830:	dec00104 	addi	sp,sp,4
81110834:	f800283a 	ret

81110838 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TSimucam_MEB *xMeb, unsigned char ucTime ) {
81110838:	defffd04 	addi	sp,sp,-12
8111083c:	de00012e 	bgeu	sp,et,81110844 <vSetTimeCode+0xc>
81110840:	003b68fa 	trap	3
81110844:	df000215 	stw	fp,8(sp)
81110848:	df000204 	addi	fp,sp,8
8111084c:	e13ffe15 	stw	r4,-8(fp)
81110850:	2805883a 	mov	r2,r5
81110854:	e0bfff05 	stb	r2,-4(fp)
    xMeb->ucTimeCode = ucTime;
81110858:	e0bffe17 	ldw	r2,-8(fp)
8111085c:	e0ffff03 	ldbu	r3,-4(fp)
81110860:	10c10905 	stb	r3,1060(r2)
}
81110864:	0001883a 	nop
81110868:	e037883a 	mov	sp,fp
8111086c:	df000017 	ldw	fp,0(sp)
81110870:	dec00104 	addi	sp,sp,4
81110874:	f800283a 	ret

81110878 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TSimucam_MEB *xMeb ) {
81110878:	defffe04 	addi	sp,sp,-8
8111087c:	de00012e 	bgeu	sp,et,81110884 <vResetTimeCode+0xc>
81110880:	003b68fa 	trap	3
81110884:	df000115 	stw	fp,4(sp)
81110888:	df000104 	addi	fp,sp,4
8111088c:	e13fff15 	stw	r4,-4(fp)
    xMeb->ucTimeCode = 0;
81110890:	e0bfff17 	ldw	r2,-4(fp)
81110894:	10010905 	stb	zero,1060(r2)
}
81110898:	0001883a 	nop
8111089c:	e037883a 	mov	sp,fp
811108a0:	df000017 	ldw	fp,0(sp)
811108a4:	dec00104 	addi	sp,sp,4
811108a8:	f800283a 	ret

811108ac <vLoadDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
811108ac:	defffe04 	addi	sp,sp,-8
811108b0:	de00012e 	bgeu	sp,et,811108b8 <vLoadDefaultAutoResetSync+0xc>
811108b4:	003b68fa 	trap	3
811108b8:	df000115 	stw	fp,4(sp)
811108bc:	df000104 	addi	fp,sp,4
811108c0:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoRestSyncMode = TRUE;
811108c4:	e0bfff17 	ldw	r2,-4(fp)
811108c8:	00c00044 	movi	r3,1
811108cc:	10c10a15 	stw	r3,1064(r2)
}
811108d0:	0001883a 	nop
811108d4:	e037883a 	mov	sp,fp
811108d8:	df000017 	ldw	fp,0(sp)
811108dc:	dec00104 	addi	sp,sp,4
811108e0:	f800283a 	ret

811108e4 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
811108e4:	defffd04 	addi	sp,sp,-12
811108e8:	de00012e 	bgeu	sp,et,811108f0 <vChangeAutoResetSync+0xc>
811108ec:	003b68fa 	trap	3
811108f0:	df000215 	stw	fp,8(sp)
811108f4:	df000204 	addi	fp,sp,8
811108f8:	e13ffe15 	stw	r4,-8(fp)
811108fc:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoRestSyncMode = bAutoReset;
81110900:	e0bffe17 	ldw	r2,-8(fp)
81110904:	e0ffff17 	ldw	r3,-4(fp)
81110908:	10c10a15 	stw	r3,1064(r2)
}
8111090c:	0001883a 	nop
81110910:	e037883a 	mov	sp,fp
81110914:	df000017 	ldw	fp,0(sp)
81110918:	dec00104 	addi	sp,sp,4
8111091c:	f800283a 	ret

81110920 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81110920:	defffd04 	addi	sp,sp,-12
81110924:	de00012e 	bgeu	sp,et,8111092c <vChangeDefaultAutoResetSync+0xc>
81110928:	003b68fa 	trap	3
8111092c:	df000215 	stw	fp,8(sp)
81110930:	df000204 	addi	fp,sp,8
81110934:	e13ffe15 	stw	r4,-8(fp)
81110938:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111093c:	0001883a 	nop
81110940:	e037883a 	mov	sp,fp
81110944:	df000017 	ldw	fp,0(sp)
81110948:	dec00104 	addi	sp,sp,4
8111094c:	f800283a 	ret

81110950 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TSimucam_MEB *xMeb ) {
81110950:	defffe04 	addi	sp,sp,-8
81110954:	de00012e 	bgeu	sp,et,8111095c <vLoadDefaultIdNFEEMaster+0xc>
81110958:	003b68fa 	trap	3
8111095c:	df000115 	stw	fp,4(sp)
81110960:	df000104 	addi	fp,sp,4
81110964:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xMeb->ucIdNFEEMaster = 0;
81110968:	e0bfff17 	ldw	r2,-4(fp)
8111096c:	10010945 	stb	zero,1061(r2)
}
81110970:	0001883a 	nop
81110974:	e037883a 	mov	sp,fp
81110978:	df000017 	ldw	fp,0(sp)
8111097c:	dec00104 	addi	sp,sp,4
81110980:	f800283a 	ret

81110984 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TSimucam_MEB *xMeb, unsigned char ucIdMaster ) {
81110984:	defffd04 	addi	sp,sp,-12
81110988:	de00012e 	bgeu	sp,et,81110990 <vChangeIdNFEEMaster+0xc>
8111098c:	003b68fa 	trap	3
81110990:	df000215 	stw	fp,8(sp)
81110994:	df000204 	addi	fp,sp,8
81110998:	e13ffe15 	stw	r4,-8(fp)
8111099c:	2805883a 	mov	r2,r5
811109a0:	e0bfff05 	stb	r2,-4(fp)
    xMeb->ucIdNFEEMaster = ucIdMaster;
811109a4:	e0bffe17 	ldw	r2,-8(fp)
811109a8:	e0ffff03 	ldbu	r3,-4(fp)
811109ac:	10c10945 	stb	r3,1061(r2)
}
811109b0:	0001883a 	nop
811109b4:	e037883a 	mov	sp,fp
811109b8:	df000017 	ldw	fp,0(sp)
811109bc:	dec00104 	addi	sp,sp,4
811109c0:	f800283a 	ret

811109c4 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TSimucam_MEB *xMeb, unsigned char ucIdMaster ) {
811109c4:	defffd04 	addi	sp,sp,-12
811109c8:	de00012e 	bgeu	sp,et,811109d0 <vChangeDefaultIdNFEEMaster+0xc>
811109cc:	003b68fa 	trap	3
811109d0:	df000215 	stw	fp,8(sp)
811109d4:	df000204 	addi	fp,sp,8
811109d8:	e13ffe15 	stw	r4,-8(fp)
811109dc:	2805883a 	mov	r2,r5
811109e0:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
811109e4:	0001883a 	nop
811109e8:	e037883a 	mov	sp,fp
811109ec:	df000017 	ldw	fp,0(sp)
811109f0:	dec00104 	addi	sp,sp,4
811109f4:	f800283a 	ret

811109f8 <vSyncReset>:

/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
811109f8:	defffc04 	addi	sp,sp,-16
811109fc:	de00012e 	bgeu	sp,et,81110a04 <vSyncReset+0xc>
81110a00:	003b68fa 	trap	3
81110a04:	dfc00315 	stw	ra,12(sp)
81110a08:	df000215 	stw	fp,8(sp)
81110a0c:	df000204 	addi	fp,sp,8
81110a10:	e13ffe15 	stw	r4,-8(fp)
81110a14:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(xMeb);
81110a18:	e13ffe17 	ldw	r4,-8(fp)
81110a1c:	11108780 	call	81110878 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
81110a20:	0001883a 	nop
81110a24:	e037883a 	mov	sp,fp
81110a28:	dfc00117 	ldw	ra,4(sp)
81110a2c:	df000017 	ldw	fp,0(sp)
81110a30:	dec00204 	addi	sp,sp,8
81110a34:	f800283a 	ret

81110a38 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
81110a38:	defffe04 	addi	sp,sp,-8
81110a3c:	de00012e 	bgeu	sp,et,81110a44 <bSDcardIsPresent+0xc>
81110a40:	003b68fa 	trap	3
81110a44:	dfc00115 	stw	ra,4(sp)
81110a48:	df000015 	stw	fp,0(sp)
81110a4c:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
81110a50:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
}
81110a54:	e037883a 	mov	sp,fp
81110a58:	dfc00117 	ldw	ra,4(sp)
81110a5c:	df000017 	ldw	fp,0(sp)
81110a60:	dec00204 	addi	sp,sp,8
81110a64:	f800283a 	ret

81110a68 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
81110a68:	defffe04 	addi	sp,sp,-8
81110a6c:	de00012e 	bgeu	sp,et,81110a74 <bSDcardFAT16Check+0xc>
81110a70:	003b68fa 	trap	3
81110a74:	dfc00115 	stw	ra,4(sp)
81110a78:	df000015 	stw	fp,0(sp)
81110a7c:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
81110a80:	1135f740 	call	81135f74 <alt_up_sd_card_is_FAT16>
}
81110a84:	e037883a 	mov	sp,fp
81110a88:	dfc00117 	ldw	ra,4(sp)
81110a8c:	df000017 	ldw	fp,0(sp)
81110a90:	dec00204 	addi	sp,sp,8
81110a94:	f800283a 	ret

81110a98 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
81110a98:	defffd04 	addi	sp,sp,-12
81110a9c:	de00012e 	bgeu	sp,et,81110aa4 <bInitializeSDCard+0xc>
81110aa0:	003b68fa 	trap	3
81110aa4:	dfc00215 	stw	ra,8(sp)
81110aa8:	df000115 	stw	fp,4(sp)
81110aac:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
81110ab0:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
81110ab4:	d0205f15 	stw	zero,-32388(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
81110ab8:	01204534 	movhi	r4,33044
81110abc:	213c7804 	addi	r4,r4,-3616
81110ac0:	1135de40 	call	81135de4 <alt_up_sd_card_open_dev>
81110ac4:	d0a05f15 	stw	r2,-32388(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
81110ac8:	d0a05f17 	ldw	r2,-32388(gp)
81110acc:	10002226 	beq	r2,zero,81110b58 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
81110ad0:	1110a380 	call	81110a38 <bSDcardIsPresent>
81110ad4:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
81110ad8:	e0bfff17 	ldw	r2,-4(fp)
81110adc:	10001626 	beq	r2,zero,81110b38 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
81110ae0:	1110a680 	call	81110a68 <bSDcardFAT16Check>
81110ae4:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
81110ae8:	e0bfff17 	ldw	r2,-4(fp)
81110aec:	10000a26 	beq	r2,zero,81110b18 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
81110af0:	00800044 	movi	r2,1
81110af4:	d0a05e15 	stw	r2,-32392(gp)
				debug(fp, "SD is up.\r\n");
81110af8:	d0a04e17 	ldw	r2,-32456(gp)
81110afc:	100f883a 	mov	r7,r2
81110b00:	018002c4 	movi	r6,11
81110b04:	01400044 	movi	r5,1
81110b08:	01204534 	movhi	r4,33044
81110b0c:	213c8304 	addi	r4,r4,-3572
81110b10:	1112ccc0 	call	81112ccc <fwrite>
81110b14:	00001806 	br	81110b78 <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
81110b18:	d0a04e17 	ldw	r2,-32456(gp)
81110b1c:	100f883a 	mov	r7,r2
81110b20:	01800984 	movi	r6,38
81110b24:	01400044 	movi	r5,1
81110b28:	01204534 	movhi	r4,33044
81110b2c:	213c8604 	addi	r4,r4,-3560
81110b30:	1112ccc0 	call	81112ccc <fwrite>
81110b34:	00001006 	br	81110b78 <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
81110b38:	d0a04e17 	ldw	r2,-32456(gp)
81110b3c:	100f883a 	mov	r7,r2
81110b40:	01800744 	movi	r6,29
81110b44:	01400044 	movi	r5,1
81110b48:	01204534 	movhi	r4,33044
81110b4c:	213c9004 	addi	r4,r4,-3520
81110b50:	1112ccc0 	call	81112ccc <fwrite>
81110b54:	00000806 	br	81110b78 <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
81110b58:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
81110b5c:	d0a04e17 	ldw	r2,-32456(gp)
81110b60:	100f883a 	mov	r7,r2
81110b64:	018008c4 	movi	r6,35
81110b68:	01400044 	movi	r5,1
81110b6c:	01204534 	movhi	r4,33044
81110b70:	213c9804 	addi	r4,r4,-3488
81110b74:	1112ccc0 	call	81112ccc <fwrite>
	}

	return bSucess;
81110b78:	e0bfff17 	ldw	r2,-4(fp)
}
81110b7c:	e037883a 	mov	sp,fp
81110b80:	dfc00117 	ldw	ra,4(sp)
81110b84:	df000017 	ldw	fp,0(sp)
81110b88:	dec00204 	addi	sp,sp,8
81110b8c:	f800283a 	ret

81110b90 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
81110b90:	defffd04 	addi	sp,sp,-12
81110b94:	de00012e 	bgeu	sp,et,81110b9c <siOpenFile+0xc>
81110b98:	003b68fa 	trap	3
81110b9c:	dfc00215 	stw	ra,8(sp)
81110ba0:	df000115 	stw	fp,4(sp)
81110ba4:	df000104 	addi	fp,sp,4
81110ba8:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
81110bac:	000b883a 	mov	r5,zero
81110bb0:	e13fff17 	ldw	r4,-4(fp)
81110bb4:	11364800 	call	81136480 <alt_up_sd_card_fopen>
}
81110bb8:	e037883a 	mov	sp,fp
81110bbc:	dfc00117 	ldw	ra,4(sp)
81110bc0:	df000017 	ldw	fp,0(sp)
81110bc4:	dec00204 	addi	sp,sp,8
81110bc8:	f800283a 	ret

81110bcc <siCloseFile>:

bool siCloseFile( short int file_handle ) {
81110bcc:	defffd04 	addi	sp,sp,-12
81110bd0:	de00012e 	bgeu	sp,et,81110bd8 <siCloseFile+0xc>
81110bd4:	003b68fa 	trap	3
81110bd8:	dfc00215 	stw	ra,8(sp)
81110bdc:	df000115 	stw	fp,4(sp)
81110be0:	df000104 	addi	fp,sp,4
81110be4:	2005883a 	mov	r2,r4
81110be8:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
81110bec:	e0bfff0f 	ldh	r2,-4(fp)
81110bf0:	1009883a 	mov	r4,r2
81110bf4:	11372cc0 	call	811372cc <alt_up_sd_card_fclose>
}
81110bf8:	e037883a 	mov	sp,fp
81110bfc:	dfc00117 	ldw	ra,4(sp)
81110c00:	df000017 	ldw	fp,0(sp)
81110c04:	dec00204 	addi	sp,sp,8
81110c08:	f800283a 	ret

81110c0c <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
81110c0c:	defffd04 	addi	sp,sp,-12
81110c10:	de00012e 	bgeu	sp,et,81110c18 <cGetNextChar+0xc>
81110c14:	003b68fa 	trap	3
81110c18:	dfc00215 	stw	ra,8(sp)
81110c1c:	df000115 	stw	fp,4(sp)
81110c20:	df000104 	addi	fp,sp,4
81110c24:	2005883a 	mov	r2,r4
81110c28:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
81110c2c:	e0bfff0f 	ldh	r2,-4(fp)
81110c30:	1009883a 	mov	r4,r2
81110c34:	11369240 	call	81136924 <alt_up_sd_card_read>
}
81110c38:	e037883a 	mov	sp,fp
81110c3c:	dfc00117 	ldw	ra,4(sp)
81110c40:	df000017 	ldw	fp,0(sp)
81110c44:	dec00204 	addi	sp,sp,8
81110c48:	f800283a 	ret

81110c4c <bTestSimucamCriticalHW>:


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void )
{
81110c4c:	deffff04 	addi	sp,sp,-4
81110c50:	de00012e 	bgeu	sp,et,81110c58 <bTestSimucamCriticalHW+0xc>
81110c54:	003b68fa 	trap	3
81110c58:	df000015 	stw	fp,0(sp)
81110c5c:	d839883a 	mov	fp,sp
	/*
	 * Verificar com Fran�a quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	return TRUE;
81110c60:	00800044 	movi	r2,1
}
81110c64:	e037883a 	mov	sp,fp
81110c68:	df000017 	ldw	fp,0(sp)
81110c6c:	dec00104 	addi	sp,sp,4
81110c70:	f800283a 	ret

81110c74 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
81110c74:	defffc04 	addi	sp,sp,-16
81110c78:	de00012e 	bgeu	sp,et,81110c80 <_reg_write+0xc>
81110c7c:	003b68fa 	trap	3
81110c80:	df000315 	stw	fp,12(sp)
81110c84:	df000304 	addi	fp,sp,12
81110c88:	e13ffd15 	stw	r4,-12(fp)
81110c8c:	e17ffe15 	stw	r5,-8(fp)
81110c90:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
81110c94:	e0bffe17 	ldw	r2,-8(fp)
81110c98:	1085883a 	add	r2,r2,r2
81110c9c:	1085883a 	add	r2,r2,r2
81110ca0:	1007883a 	mov	r3,r2
81110ca4:	e0bffd17 	ldw	r2,-12(fp)
81110ca8:	1885883a 	add	r2,r3,r2
81110cac:	1007883a 	mov	r3,r2
81110cb0:	e0bfff17 	ldw	r2,-4(fp)
81110cb4:	18800035 	stwio	r2,0(r3)
	return 1;
81110cb8:	00800044 	movi	r2,1

}
81110cbc:	e037883a 	mov	sp,fp
81110cc0:	df000017 	ldw	fp,0(sp)
81110cc4:	dec00104 	addi	sp,sp,4
81110cc8:	f800283a 	ret

81110ccc <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
81110ccc:	defffc04 	addi	sp,sp,-16
81110cd0:	de00012e 	bgeu	sp,et,81110cd8 <_reg_read+0xc>
81110cd4:	003b68fa 	trap	3
81110cd8:	df000315 	stw	fp,12(sp)
81110cdc:	df000304 	addi	fp,sp,12
81110ce0:	e13ffd15 	stw	r4,-12(fp)
81110ce4:	e17ffe15 	stw	r5,-8(fp)
81110ce8:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
81110cec:	e0bffe17 	ldw	r2,-8(fp)
81110cf0:	1085883a 	add	r2,r2,r2
81110cf4:	1085883a 	add	r2,r2,r2
81110cf8:	1007883a 	mov	r3,r2
81110cfc:	e0bffd17 	ldw	r2,-12(fp)
81110d00:	1885883a 	add	r2,r3,r2
81110d04:	10c00037 	ldwio	r3,0(r2)
81110d08:	e0bfff17 	ldw	r2,-4(fp)
81110d0c:	10c00015 	stw	r3,0(r2)
	return 1;
81110d10:	00800044 	movi	r2,1

}
81110d14:	e037883a 	mov	sp,fp
81110d18:	df000017 	ldw	fp,0(sp)
81110d1c:	dec00104 	addi	sp,sp,4
81110d20:	f800283a 	ret

81110d24 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
81110d24:	defffa04 	addi	sp,sp,-24
81110d28:	de00012e 	bgeu	sp,et,81110d30 <_print_codec_status+0xc>
81110d2c:	003b68fa 	trap	3
81110d30:	dfc00515 	stw	ra,20(sp)
81110d34:	df000415 	stw	fp,16(sp)
81110d38:	df000404 	addi	fp,sp,16
81110d3c:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
81110d40:	e0bfff17 	ldw	r2,-4(fp)
81110d44:	1005d1ba 	srai	r2,r2,6
81110d48:	1080004c 	andi	r2,r2,1
81110d4c:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
81110d50:	e0bfff17 	ldw	r2,-4(fp)
81110d54:	1005d17a 	srai	r2,r2,5
81110d58:	1080004c 	andi	r2,r2,1
81110d5c:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
81110d60:	e0bfff17 	ldw	r2,-4(fp)
81110d64:	1005d13a 	srai	r2,r2,4
81110d68:	1080004c 	andi	r2,r2,1
81110d6c:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
81110d70:	00e04534 	movhi	r3,33044
81110d74:	18c77104 	addi	r3,r3,7620
81110d78:	00a04534 	movhi	r2,33044
81110d7c:	10bca104 	addi	r2,r2,-3452
81110d80:	1009883a 	mov	r4,r2
81110d84:	008005c4 	movi	r2,23
81110d88:	100d883a 	mov	r6,r2
81110d8c:	200b883a 	mov	r5,r4
81110d90:	1809883a 	mov	r4,r3
81110d94:	11136e00 	call	811136e0 <memcpy>
	debug(fp, cDebugBuffer);
81110d98:	d0a04e17 	ldw	r2,-32456(gp)
81110d9c:	01604534 	movhi	r5,33044
81110da0:	29477104 	addi	r5,r5,7620
81110da4:	1009883a 	mov	r4,r2
81110da8:	11126e00 	call	811126e0 <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
81110dac:	e0bffc17 	ldw	r2,-16(fp)
81110db0:	10800058 	cmpnei	r2,r2,1
81110db4:	1000031e 	bne	r2,zero,81110dc4 <_print_codec_status+0xa0>
81110db8:	00a04534 	movhi	r2,33044
81110dbc:	10bca704 	addi	r2,r2,-3428
81110dc0:	00000206 	br	81110dcc <_print_codec_status+0xa8>
81110dc4:	00a04534 	movhi	r2,33044
81110dc8:	10bca804 	addi	r2,r2,-3424
81110dcc:	100d883a 	mov	r6,r2
81110dd0:	01604534 	movhi	r5,33044
81110dd4:	297ca904 	addi	r5,r5,-3420
81110dd8:	01204534 	movhi	r4,33044
81110ddc:	21077104 	addi	r4,r4,7620
81110de0:	1113e480 	call	81113e48 <sprintf>
	debug(fp, cDebugBuffer);
81110de4:	d0a04e17 	ldw	r2,-32456(gp)
81110de8:	01604534 	movhi	r5,33044
81110dec:	29477104 	addi	r5,r5,7620
81110df0:	1009883a 	mov	r4,r2
81110df4:	11126e00 	call	811126e0 <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
81110df8:	e0bffd17 	ldw	r2,-12(fp)
81110dfc:	10800058 	cmpnei	r2,r2,1
81110e00:	1000031e 	bne	r2,zero,81110e10 <_print_codec_status+0xec>
81110e04:	00a04534 	movhi	r2,33044
81110e08:	10bca704 	addi	r2,r2,-3428
81110e0c:	00000206 	br	81110e18 <_print_codec_status+0xf4>
81110e10:	00a04534 	movhi	r2,33044
81110e14:	10bca804 	addi	r2,r2,-3424
81110e18:	100d883a 	mov	r6,r2
81110e1c:	01604534 	movhi	r5,33044
81110e20:	297caf04 	addi	r5,r5,-3396
81110e24:	01204534 	movhi	r4,33044
81110e28:	21077104 	addi	r4,r4,7620
81110e2c:	1113e480 	call	81113e48 <sprintf>
	debug(fp, cDebugBuffer);
81110e30:	d0a04e17 	ldw	r2,-32456(gp)
81110e34:	01604534 	movhi	r5,33044
81110e38:	29477104 	addi	r5,r5,7620
81110e3c:	1009883a 	mov	r4,r2
81110e40:	11126e00 	call	811126e0 <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
81110e44:	e0bffe17 	ldw	r2,-8(fp)
81110e48:	10800058 	cmpnei	r2,r2,1
81110e4c:	1000031e 	bne	r2,zero,81110e5c <_print_codec_status+0x138>
81110e50:	00a04534 	movhi	r2,33044
81110e54:	10bca704 	addi	r2,r2,-3428
81110e58:	00000206 	br	81110e64 <_print_codec_status+0x140>
81110e5c:	00a04534 	movhi	r2,33044
81110e60:	10bca804 	addi	r2,r2,-3424
81110e64:	100d883a 	mov	r6,r2
81110e68:	01604534 	movhi	r5,33044
81110e6c:	297cb504 	addi	r5,r5,-3372
81110e70:	01204534 	movhi	r4,33044
81110e74:	21077104 	addi	r4,r4,7620
81110e78:	1113e480 	call	81113e48 <sprintf>
	debug(fp, cDebugBuffer);
81110e7c:	d0a04e17 	ldw	r2,-32456(gp)
81110e80:	01604534 	movhi	r5,33044
81110e84:	29477104 	addi	r5,r5,7620
81110e88:	1009883a 	mov	r4,r2
81110e8c:	11126e00 	call	811126e0 <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
81110e90:	00a04534 	movhi	r2,33044
81110e94:	10877104 	addi	r2,r2,7620
81110e98:	00c00b44 	movi	r3,45
81110e9c:	10c00005 	stb	r3,0(r2)
81110ea0:	00c00b44 	movi	r3,45
81110ea4:	10c00045 	stb	r3,1(r2)
81110ea8:	00c00b44 	movi	r3,45
81110eac:	10c00085 	stb	r3,2(r2)
81110eb0:	00c00b44 	movi	r3,45
81110eb4:	10c000c5 	stb	r3,3(r2)
81110eb8:	00c00b44 	movi	r3,45
81110ebc:	10c00105 	stb	r3,4(r2)
81110ec0:	00c00b44 	movi	r3,45
81110ec4:	10c00145 	stb	r3,5(r2)
81110ec8:	00c00b44 	movi	r3,45
81110ecc:	10c00185 	stb	r3,6(r2)
81110ed0:	00c00b44 	movi	r3,45
81110ed4:	10c001c5 	stb	r3,7(r2)
81110ed8:	00c00804 	movi	r3,32
81110edc:	10c00205 	stb	r3,8(r2)
81110ee0:	00c00804 	movi	r3,32
81110ee4:	10c00245 	stb	r3,9(r2)
81110ee8:	00c00284 	movi	r3,10
81110eec:	10c00285 	stb	r3,10(r2)
81110ef0:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
81110ef4:	d0a04e17 	ldw	r2,-32456(gp)
81110ef8:	01604534 	movhi	r5,33044
81110efc:	29477104 	addi	r5,r5,7620
81110f00:	1009883a 	mov	r4,r2
81110f04:	11126e00 	call	811126e0 <fprintf>
#endif
}
81110f08:	0001883a 	nop
81110f0c:	e037883a 	mov	sp,fp
81110f10:	dfc00117 	ldw	ra,4(sp)
81110f14:	df000017 	ldw	fp,0(sp)
81110f18:	dec00204 	addi	sp,sp,8
81110f1c:	f800283a 	ret

81110f20 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
81110f20:	defffb04 	addi	sp,sp,-20
81110f24:	de00012e 	bgeu	sp,et,81110f2c <_split_codec_status+0xc>
81110f28:	003b68fa 	trap	3
81110f2c:	df000415 	stw	fp,16(sp)
81110f30:	df000404 	addi	fp,sp,16
81110f34:	e13ffc15 	stw	r4,-16(fp)
81110f38:	e17ffd15 	stw	r5,-12(fp)
81110f3c:	e1bffe15 	stw	r6,-8(fp)
81110f40:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
81110f44:	e0bffc17 	ldw	r2,-16(fp)
81110f48:	1005d1ba 	srai	r2,r2,6
81110f4c:	10c0004c 	andi	r3,r2,1
81110f50:	e0bffd17 	ldw	r2,-12(fp)
81110f54:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
81110f58:	e0bffc17 	ldw	r2,-16(fp)
81110f5c:	1005d17a 	srai	r2,r2,5
81110f60:	10c0004c 	andi	r3,r2,1
81110f64:	e0bffe17 	ldw	r2,-8(fp)
81110f68:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
81110f6c:	e0bffc17 	ldw	r2,-16(fp)
81110f70:	1005d13a 	srai	r2,r2,4
81110f74:	10c0004c 	andi	r3,r2,1
81110f78:	e0bfff17 	ldw	r2,-4(fp)
81110f7c:	10c00015 	stw	r3,0(r2)
}
81110f80:	0001883a 	nop
81110f84:	e037883a 	mov	sp,fp
81110f88:	df000017 	ldw	fp,0(sp)
81110f8c:	dec00104 	addi	sp,sp,4
81110f90:	f800283a 	ret

81110f94 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
81110f94:	defffc04 	addi	sp,sp,-16
81110f98:	de00012e 	bgeu	sp,et,81110fa0 <aatoh+0xc>
81110f9c:	003b68fa 	trap	3
81110fa0:	df000315 	stw	fp,12(sp)
81110fa4:	df000304 	addi	fp,sp,12
81110fa8:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
81110fac:	e0bfff17 	ldw	r2,-4(fp)
81110fb0:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81110fb4:	e0bffd17 	ldw	r2,-12(fp)
81110fb8:	10c00003 	ldbu	r3,0(r2)
81110fbc:	e0bffd17 	ldw	r2,-12(fp)
81110fc0:	10800003 	ldbu	r2,0(r2)
81110fc4:	10803fcc 	andi	r2,r2,255
81110fc8:	10800eb0 	cmpltui	r2,r2,58
81110fcc:	1000021e 	bne	r2,zero,81110fd8 <aatoh+0x44>
81110fd0:	00800dc4 	movi	r2,55
81110fd4:	00000106 	br	81110fdc <aatoh+0x48>
81110fd8:	00800c04 	movi	r2,48
81110fdc:	1885c83a 	sub	r2,r3,r2
81110fe0:	1004913a 	slli	r2,r2,4
81110fe4:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
81110fe8:	e0bffd17 	ldw	r2,-12(fp)
81110fec:	10800044 	addi	r2,r2,1
81110ff0:	10c00003 	ldbu	r3,0(r2)
81110ff4:	e0bffd17 	ldw	r2,-12(fp)
81110ff8:	10800044 	addi	r2,r2,1
81110ffc:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81111000:	10803fcc 	andi	r2,r2,255
81111004:	10800eb0 	cmpltui	r2,r2,58
81111008:	1000021e 	bne	r2,zero,81111014 <aatoh+0x80>
8111100c:	00800dc4 	movi	r2,55
81111010:	00000106 	br	81111018 <aatoh+0x84>
81111014:	00800c04 	movi	r2,48
81111018:	1885c83a 	sub	r2,r3,r2
8111101c:	2085883a 	add	r2,r4,r2
81111020:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
81111024:	e0bffe03 	ldbu	r2,-8(fp)
}
81111028:	e037883a 	mov	sp,fp
8111102c:	df000017 	ldw	fp,0(sp)
81111030:	dec00104 	addi	sp,sp,4
81111034:	f800283a 	ret

81111038 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
81111038:	defffd04 	addi	sp,sp,-12
8111103c:	de00012e 	bgeu	sp,et,81111044 <Verif_Error+0xc>
81111040:	003b68fa 	trap	3
81111044:	dfc00215 	stw	ra,8(sp)
81111048:	df000115 	stw	fp,4(sp)
8111104c:	df000104 	addi	fp,sp,4
81111050:	2005883a 	mov	r2,r4
81111054:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
81111058:	e0bfff03 	ldbu	r2,-4(fp)
8111105c:	1000091e 	bne	r2,zero,81111084 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
81111060:	d0a04e17 	ldw	r2,-32456(gp)
81111064:	100f883a 	mov	r7,r2
81111068:	018001c4 	movi	r6,7
8111106c:	01400044 	movi	r5,1
81111070:	01204534 	movhi	r4,33044
81111074:	213cbb04 	addi	r4,r4,-3348
81111078:	1112ccc0 	call	81112ccc <fwrite>
#endif
		return 0;
8111107c:	0005883a 	mov	r2,zero
81111080:	00000106 	br	81111088 <Verif_Error+0x50>
	} else
		return 1;
81111084:	00800044 	movi	r2,1
}
81111088:	e037883a 	mov	sp,fp
8111108c:	dfc00117 	ldw	ra,4(sp)
81111090:	df000017 	ldw	fp,0(sp)
81111094:	dec00204 	addi	sp,sp,8
81111098:	f800283a 	ret

8111109c <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111109c:	defffe04 	addi	sp,sp,-8
811110a0:	de00012e 	bgeu	sp,et,811110a8 <toInt+0xc>
811110a4:	003b68fa 	trap	3
811110a8:	df000115 	stw	fp,4(sp)
811110ac:	df000104 	addi	fp,sp,4
811110b0:	2005883a 	mov	r2,r4
811110b4:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
811110b8:	e0bfff03 	ldbu	r2,-4(fp)
811110bc:	10bff404 	addi	r2,r2,-48
}
811110c0:	e037883a 	mov	sp,fp
811110c4:	df000017 	ldw	fp,0(sp)
811110c8:	dec00104 	addi	sp,sp,4
811110cc:	f800283a 	ret

811110d0 <__divsf3>:
811110d0:	defff504 	addi	sp,sp,-44
811110d4:	200cd5fa 	srli	r6,r4,23
811110d8:	de00012e 	bgeu	sp,et,811110e0 <__divsf3+0x10>
811110dc:	003b68fa 	trap	3
811110e0:	dcc00415 	stw	r19,16(sp)
811110e4:	2026d7fa 	srli	r19,r4,31
811110e8:	00c02034 	movhi	r3,128
811110ec:	dd800715 	stw	r22,28(sp)
811110f0:	dd000515 	stw	r20,20(sp)
811110f4:	dc800315 	stw	r18,12(sp)
811110f8:	18ffffc4 	addi	r3,r3,-1
811110fc:	dfc00a15 	stw	ra,40(sp)
81111100:	df000915 	stw	fp,36(sp)
81111104:	ddc00815 	stw	r23,32(sp)
81111108:	dd400615 	stw	r21,24(sp)
8111110c:	dc400215 	stw	r17,8(sp)
81111110:	dc000115 	stw	r16,4(sp)
81111114:	35003fcc 	andi	r20,r6,255
81111118:	1924703a 	and	r18,r3,r4
8111111c:	9d803fcc 	andi	r22,r19,255
81111120:	a0005226 	beq	r20,zero,8111126c <__divsf3+0x19c>
81111124:	00803fc4 	movi	r2,255
81111128:	a0802e26 	beq	r20,r2,811111e4 <__divsf3+0x114>
8111112c:	91002034 	orhi	r4,r18,128
81111130:	202490fa 	slli	r18,r4,3
81111134:	a53fe044 	addi	r20,r20,-127
81111138:	0021883a 	mov	r16,zero
8111113c:	002f883a 	mov	r23,zero
81111140:	280cd5fa 	srli	r6,r5,23
81111144:	282ad7fa 	srli	r21,r5,31
81111148:	00c02034 	movhi	r3,128
8111114c:	18ffffc4 	addi	r3,r3,-1
81111150:	31803fcc 	andi	r6,r6,255
81111154:	1962703a 	and	r17,r3,r5
81111158:	af003fcc 	andi	fp,r21,255
8111115c:	30004a26 	beq	r6,zero,81111288 <__divsf3+0x1b8>
81111160:	00803fc4 	movi	r2,255
81111164:	30804526 	beq	r6,r2,8111127c <__divsf3+0x1ac>
81111168:	89402034 	orhi	r5,r17,128
8111116c:	282290fa 	slli	r17,r5,3
81111170:	31bfe044 	addi	r6,r6,-127
81111174:	000b883a 	mov	r5,zero
81111178:	2c20b03a 	or	r16,r5,r16
8111117c:	802090ba 	slli	r16,r16,2
81111180:	00a04474 	movhi	r2,33041
81111184:	10846904 	addi	r2,r2,4516
81111188:	80a1883a 	add	r16,r16,r2
8111118c:	81000017 	ldw	r4,0(r16)
81111190:	9d46f03a 	xor	r3,r19,r21
81111194:	180f883a 	mov	r7,r3
81111198:	18803fcc 	andi	r2,r3,255
8111119c:	a18dc83a 	sub	r6,r20,r6
811111a0:	2000683a 	jmp	r4
811111a4:	81111388 	cmpgei	r4,r16,17486
811111a8:	8111120c 	andi	r4,r16,17480
811111ac:	8111137c 	xorhi	r4,r16,17485
811111b0:	811111f8 	rdprs	r4,r16,17479
811111b4:	8111137c 	xorhi	r4,r16,17485
811111b8:	81111354 	ori	r4,r16,17485
811111bc:	8111137c 	xorhi	r4,r16,17485
811111c0:	811111f8 	rdprs	r4,r16,17479
811111c4:	8111120c 	andi	r4,r16,17480
811111c8:	8111120c 	andi	r4,r16,17480
811111cc:	81111354 	ori	r4,r16,17485
811111d0:	811111f8 	rdprs	r4,r16,17479
811111d4:	81111468 	cmpgeui	r4,r16,17489
811111d8:	81111468 	cmpgeui	r4,r16,17489
811111dc:	81111468 	cmpgeui	r4,r16,17489
811111e0:	8111141c 	xori	r4,r16,17488
811111e4:	9000581e 	bne	r18,zero,81111348 <__divsf3+0x278>
811111e8:	04000204 	movi	r16,8
811111ec:	05c00084 	movi	r23,2
811111f0:	003fd306 	br	81111140 <__reset+0xfb0f1140>
811111f4:	0023883a 	mov	r17,zero
811111f8:	e02d883a 	mov	r22,fp
811111fc:	282f883a 	mov	r23,r5
81111200:	00800084 	movi	r2,2
81111204:	b8808f1e 	bne	r23,r2,81111444 <__divsf3+0x374>
81111208:	b005883a 	mov	r2,r22
8111120c:	11c0004c 	andi	r7,r2,1
81111210:	013fffc4 	movi	r4,-1
81111214:	000d883a 	mov	r6,zero
81111218:	21003fcc 	andi	r4,r4,255
8111121c:	200895fa 	slli	r4,r4,23
81111220:	38803fcc 	andi	r2,r7,255
81111224:	00c02034 	movhi	r3,128
81111228:	100497fa 	slli	r2,r2,31
8111122c:	18ffffc4 	addi	r3,r3,-1
81111230:	30c6703a 	and	r3,r6,r3
81111234:	1906b03a 	or	r3,r3,r4
81111238:	1884b03a 	or	r2,r3,r2
8111123c:	dfc00a17 	ldw	ra,40(sp)
81111240:	df000917 	ldw	fp,36(sp)
81111244:	ddc00817 	ldw	r23,32(sp)
81111248:	dd800717 	ldw	r22,28(sp)
8111124c:	dd400617 	ldw	r21,24(sp)
81111250:	dd000517 	ldw	r20,20(sp)
81111254:	dcc00417 	ldw	r19,16(sp)
81111258:	dc800317 	ldw	r18,12(sp)
8111125c:	dc400217 	ldw	r17,8(sp)
81111260:	dc000117 	ldw	r16,4(sp)
81111264:	dec00b04 	addi	sp,sp,44
81111268:	f800283a 	ret
8111126c:	90002b1e 	bne	r18,zero,8111131c <__divsf3+0x24c>
81111270:	04000104 	movi	r16,4
81111274:	05c00044 	movi	r23,1
81111278:	003fb106 	br	81111140 <__reset+0xfb0f1140>
8111127c:	8800251e 	bne	r17,zero,81111314 <__divsf3+0x244>
81111280:	01400084 	movi	r5,2
81111284:	00000206 	br	81111290 <__divsf3+0x1c0>
81111288:	88001a1e 	bne	r17,zero,811112f4 <__divsf3+0x224>
8111128c:	01400044 	movi	r5,1
81111290:	8160b03a 	or	r16,r16,r5
81111294:	802090ba 	slli	r16,r16,2
81111298:	00e04474 	movhi	r3,33041
8111129c:	18c4ad04 	addi	r3,r3,4788
811112a0:	80e1883a 	add	r16,r16,r3
811112a4:	80c00017 	ldw	r3,0(r16)
811112a8:	9d44f03a 	xor	r2,r19,r21
811112ac:	a18dc83a 	sub	r6,r20,r6
811112b0:	1800683a 	jmp	r3
811112b4:	8111120c 	andi	r4,r16,17480
811112b8:	8111120c 	andi	r4,r16,17480
811112bc:	81111458 	cmpnei	r4,r16,17489
811112c0:	811111f4 	orhi	r4,r16,17479
811112c4:	81111458 	cmpnei	r4,r16,17489
811112c8:	81111354 	ori	r4,r16,17485
811112cc:	81111458 	cmpnei	r4,r16,17489
811112d0:	811111f4 	orhi	r4,r16,17479
811112d4:	8111120c 	andi	r4,r16,17480
811112d8:	8111120c 	andi	r4,r16,17480
811112dc:	81111354 	ori	r4,r16,17485
811112e0:	811111f4 	orhi	r4,r16,17479
811112e4:	81111468 	cmpgeui	r4,r16,17489
811112e8:	81111468 	cmpgeui	r4,r16,17489
811112ec:	81111468 	cmpgeui	r4,r16,17489
811112f0:	81111480 	call	88111148 <__reset+0x20f1148>
811112f4:	8809883a 	mov	r4,r17
811112f8:	11125200 	call	81112520 <__clzsi2>
811112fc:	10fffec4 	addi	r3,r2,-5
81111300:	10801d84 	addi	r2,r2,118
81111304:	88e2983a 	sll	r17,r17,r3
81111308:	008dc83a 	sub	r6,zero,r2
8111130c:	000b883a 	mov	r5,zero
81111310:	003f9906 	br	81111178 <__reset+0xfb0f1178>
81111314:	014000c4 	movi	r5,3
81111318:	003f9706 	br	81111178 <__reset+0xfb0f1178>
8111131c:	9009883a 	mov	r4,r18
81111320:	d9400015 	stw	r5,0(sp)
81111324:	11125200 	call	81112520 <__clzsi2>
81111328:	10fffec4 	addi	r3,r2,-5
8111132c:	11801d84 	addi	r6,r2,118
81111330:	90e4983a 	sll	r18,r18,r3
81111334:	01a9c83a 	sub	r20,zero,r6
81111338:	0021883a 	mov	r16,zero
8111133c:	002f883a 	mov	r23,zero
81111340:	d9400017 	ldw	r5,0(sp)
81111344:	003f7e06 	br	81111140 <__reset+0xfb0f1140>
81111348:	04000304 	movi	r16,12
8111134c:	05c000c4 	movi	r23,3
81111350:	003f7b06 	br	81111140 <__reset+0xfb0f1140>
81111354:	01802034 	movhi	r6,128
81111358:	000f883a 	mov	r7,zero
8111135c:	31bfffc4 	addi	r6,r6,-1
81111360:	013fffc4 	movi	r4,-1
81111364:	003fac06 	br	81111218 <__reset+0xfb0f1218>
81111368:	01400044 	movi	r5,1
8111136c:	2909c83a 	sub	r4,r5,r4
81111370:	00c006c4 	movi	r3,27
81111374:	19004b0e 	bge	r3,r4,811114a4 <__divsf3+0x3d4>
81111378:	114e703a 	and	r7,r2,r5
8111137c:	0009883a 	mov	r4,zero
81111380:	000d883a 	mov	r6,zero
81111384:	003fa406 	br	81111218 <__reset+0xfb0f1218>
81111388:	9006917a 	slli	r3,r18,5
8111138c:	8822917a 	slli	r17,r17,5
81111390:	1c40372e 	bgeu	r3,r17,81111470 <__divsf3+0x3a0>
81111394:	31bfffc4 	addi	r6,r6,-1
81111398:	010006c4 	movi	r4,27
8111139c:	000b883a 	mov	r5,zero
811113a0:	180f883a 	mov	r7,r3
811113a4:	294b883a 	add	r5,r5,r5
811113a8:	18c7883a 	add	r3,r3,r3
811113ac:	38000116 	blt	r7,zero,811113b4 <__divsf3+0x2e4>
811113b0:	1c400236 	bltu	r3,r17,811113bc <__divsf3+0x2ec>
811113b4:	1c47c83a 	sub	r3,r3,r17
811113b8:	29400054 	ori	r5,r5,1
811113bc:	213fffc4 	addi	r4,r4,-1
811113c0:	203ff71e 	bne	r4,zero,811113a0 <__reset+0xfb0f13a0>
811113c4:	1806c03a 	cmpne	r3,r3,zero
811113c8:	1962b03a 	or	r17,r3,r5
811113cc:	31001fc4 	addi	r4,r6,127
811113d0:	013fe50e 	bge	zero,r4,81111368 <__reset+0xfb0f1368>
811113d4:	88c001cc 	andi	r3,r17,7
811113d8:	18000426 	beq	r3,zero,811113ec <__divsf3+0x31c>
811113dc:	88c003cc 	andi	r3,r17,15
811113e0:	01400104 	movi	r5,4
811113e4:	19400126 	beq	r3,r5,811113ec <__divsf3+0x31c>
811113e8:	8963883a 	add	r17,r17,r5
811113ec:	88c2002c 	andhi	r3,r17,2048
811113f0:	18000426 	beq	r3,zero,81111404 <__divsf3+0x334>
811113f4:	00fe0034 	movhi	r3,63488
811113f8:	18ffffc4 	addi	r3,r3,-1
811113fc:	31002004 	addi	r4,r6,128
81111400:	88e2703a 	and	r17,r17,r3
81111404:	00c03f84 	movi	r3,254
81111408:	193f8016 	blt	r3,r4,8111120c <__reset+0xfb0f120c>
8111140c:	880c91ba 	slli	r6,r17,6
81111410:	11c0004c 	andi	r7,r2,1
81111414:	300cd27a 	srli	r6,r6,9
81111418:	003f7f06 	br	81111218 <__reset+0xfb0f1218>
8111141c:	9080102c 	andhi	r2,r18,64
81111420:	10000226 	beq	r2,zero,8111142c <__divsf3+0x35c>
81111424:	8880102c 	andhi	r2,r17,64
81111428:	10001826 	beq	r2,zero,8111148c <__divsf3+0x3bc>
8111142c:	00802034 	movhi	r2,128
81111430:	91801034 	orhi	r6,r18,64
81111434:	10bfffc4 	addi	r2,r2,-1
81111438:	980f883a 	mov	r7,r19
8111143c:	308c703a 	and	r6,r6,r2
81111440:	003fc706 	br	81111360 <__reset+0xfb0f1360>
81111444:	008000c4 	movi	r2,3
81111448:	b8802d26 	beq	r23,r2,81111500 <__divsf3+0x430>
8111144c:	00c00044 	movi	r3,1
81111450:	b005883a 	mov	r2,r22
81111454:	b8ffdd1e 	bne	r23,r3,811113cc <__reset+0xfb0f13cc>
81111458:	11c0004c 	andi	r7,r2,1
8111145c:	0009883a 	mov	r4,zero
81111460:	000d883a 	mov	r6,zero
81111464:	003f6c06 	br	81111218 <__reset+0xfb0f1218>
81111468:	9023883a 	mov	r17,r18
8111146c:	003f6406 	br	81111200 <__reset+0xfb0f1200>
81111470:	1c47c83a 	sub	r3,r3,r17
81111474:	01000684 	movi	r4,26
81111478:	01400044 	movi	r5,1
8111147c:	003fc806 	br	811113a0 <__reset+0xfb0f13a0>
81111480:	9080102c 	andhi	r2,r18,64
81111484:	103fe926 	beq	r2,zero,8111142c <__reset+0xfb0f142c>
81111488:	0023883a 	mov	r17,zero
8111148c:	00802034 	movhi	r2,128
81111490:	89801034 	orhi	r6,r17,64
81111494:	10bfffc4 	addi	r2,r2,-1
81111498:	a80f883a 	mov	r7,r21
8111149c:	308c703a 	and	r6,r6,r2
811114a0:	003faf06 	br	81111360 <__reset+0xfb0f1360>
811114a4:	01c00804 	movi	r7,32
811114a8:	390fc83a 	sub	r7,r7,r4
811114ac:	89ce983a 	sll	r7,r17,r7
811114b0:	890ad83a 	srl	r5,r17,r4
811114b4:	380ec03a 	cmpne	r7,r7,zero
811114b8:	29cab03a 	or	r5,r5,r7
811114bc:	28c001cc 	andi	r3,r5,7
811114c0:	18000426 	beq	r3,zero,811114d4 <__divsf3+0x404>
811114c4:	28c003cc 	andi	r3,r5,15
811114c8:	01000104 	movi	r4,4
811114cc:	19000126 	beq	r3,r4,811114d4 <__divsf3+0x404>
811114d0:	290b883a 	add	r5,r5,r4
811114d4:	28c1002c 	andhi	r3,r5,1024
811114d8:	18000426 	beq	r3,zero,811114ec <__divsf3+0x41c>
811114dc:	11c0004c 	andi	r7,r2,1
811114e0:	01000044 	movi	r4,1
811114e4:	000d883a 	mov	r6,zero
811114e8:	003f4b06 	br	81111218 <__reset+0xfb0f1218>
811114ec:	280a91ba 	slli	r5,r5,6
811114f0:	11c0004c 	andi	r7,r2,1
811114f4:	0009883a 	mov	r4,zero
811114f8:	280cd27a 	srli	r6,r5,9
811114fc:	003f4606 	br	81111218 <__reset+0xfb0f1218>
81111500:	00802034 	movhi	r2,128
81111504:	89801034 	orhi	r6,r17,64
81111508:	10bfffc4 	addi	r2,r2,-1
8111150c:	b00f883a 	mov	r7,r22
81111510:	308c703a 	and	r6,r6,r2
81111514:	003f9206 	br	81111360 <__reset+0xfb0f1360>

81111518 <__mulsf3>:
81111518:	defff504 	addi	sp,sp,-44
8111151c:	de00012e 	bgeu	sp,et,81111524 <__mulsf3+0xc>
81111520:	003b68fa 	trap	3
81111524:	dc000115 	stw	r16,4(sp)
81111528:	2020d5fa 	srli	r16,r4,23
8111152c:	dd400615 	stw	r21,24(sp)
81111530:	202ad7fa 	srli	r21,r4,31
81111534:	dc800315 	stw	r18,12(sp)
81111538:	04802034 	movhi	r18,128
8111153c:	df000915 	stw	fp,36(sp)
81111540:	dd000515 	stw	r20,20(sp)
81111544:	94bfffc4 	addi	r18,r18,-1
81111548:	dfc00a15 	stw	ra,40(sp)
8111154c:	ddc00815 	stw	r23,32(sp)
81111550:	dd800715 	stw	r22,28(sp)
81111554:	dcc00415 	stw	r19,16(sp)
81111558:	dc400215 	stw	r17,8(sp)
8111155c:	84003fcc 	andi	r16,r16,255
81111560:	9124703a 	and	r18,r18,r4
81111564:	a829883a 	mov	r20,r21
81111568:	af003fcc 	andi	fp,r21,255
8111156c:	80005426 	beq	r16,zero,811116c0 <__mulsf3+0x1a8>
81111570:	00803fc4 	movi	r2,255
81111574:	80802f26 	beq	r16,r2,81111634 <__mulsf3+0x11c>
81111578:	91002034 	orhi	r4,r18,128
8111157c:	202490fa 	slli	r18,r4,3
81111580:	843fe044 	addi	r16,r16,-127
81111584:	0023883a 	mov	r17,zero
81111588:	002f883a 	mov	r23,zero
8111158c:	2804d5fa 	srli	r2,r5,23
81111590:	282cd7fa 	srli	r22,r5,31
81111594:	01002034 	movhi	r4,128
81111598:	213fffc4 	addi	r4,r4,-1
8111159c:	10803fcc 	andi	r2,r2,255
811115a0:	2166703a 	and	r19,r4,r5
811115a4:	b1803fcc 	andi	r6,r22,255
811115a8:	10004c26 	beq	r2,zero,811116dc <__mulsf3+0x1c4>
811115ac:	00c03fc4 	movi	r3,255
811115b0:	10c04726 	beq	r2,r3,811116d0 <__mulsf3+0x1b8>
811115b4:	99002034 	orhi	r4,r19,128
811115b8:	202690fa 	slli	r19,r4,3
811115bc:	10bfe044 	addi	r2,r2,-127
811115c0:	0007883a 	mov	r3,zero
811115c4:	80a1883a 	add	r16,r16,r2
811115c8:	010003c4 	movi	r4,15
811115cc:	1c44b03a 	or	r2,r3,r17
811115d0:	b56af03a 	xor	r21,r22,r21
811115d4:	81c00044 	addi	r7,r16,1
811115d8:	20806b36 	bltu	r4,r2,81111788 <__mulsf3+0x270>
811115dc:	100490ba 	slli	r2,r2,2
811115e0:	01204474 	movhi	r4,33041
811115e4:	21057d04 	addi	r4,r4,5620
811115e8:	1105883a 	add	r2,r2,r4
811115ec:	10800017 	ldw	r2,0(r2)
811115f0:	1000683a 	jmp	r2
811115f4:	81111788 	cmpgei	r4,r16,17502
811115f8:	81111648 	cmpgei	r4,r16,17497
811115fc:	81111648 	cmpgei	r4,r16,17497
81111600:	81111644 	addi	r4,r16,17497
81111604:	8111176c 	andhi	r4,r16,17501
81111608:	8111176c 	andhi	r4,r16,17501
8111160c:	81111758 	cmpnei	r4,r16,17501
81111610:	81111644 	addi	r4,r16,17497
81111614:	8111176c 	andhi	r4,r16,17501
81111618:	81111758 	cmpnei	r4,r16,17501
8111161c:	8111176c 	andhi	r4,r16,17501
81111620:	81111644 	addi	r4,r16,17497
81111624:	81111778 	rdprs	r4,r16,17501
81111628:	81111778 	rdprs	r4,r16,17501
8111162c:	81111778 	rdprs	r4,r16,17501
81111630:	81111854 	ori	r4,r16,17505
81111634:	90003b1e 	bne	r18,zero,81111724 <__mulsf3+0x20c>
81111638:	04400204 	movi	r17,8
8111163c:	05c00084 	movi	r23,2
81111640:	003fd206 	br	8111158c <__reset+0xfb0f158c>
81111644:	302b883a 	mov	r21,r6
81111648:	00800084 	movi	r2,2
8111164c:	18802626 	beq	r3,r2,811116e8 <__mulsf3+0x1d0>
81111650:	008000c4 	movi	r2,3
81111654:	1880ab26 	beq	r3,r2,81111904 <__mulsf3+0x3ec>
81111658:	00800044 	movi	r2,1
8111165c:	1880a21e 	bne	r3,r2,811118e8 <__mulsf3+0x3d0>
81111660:	a829883a 	mov	r20,r21
81111664:	0007883a 	mov	r3,zero
81111668:	0009883a 	mov	r4,zero
8111166c:	18803fcc 	andi	r2,r3,255
81111670:	100695fa 	slli	r3,r2,23
81111674:	a0803fcc 	andi	r2,r20,255
81111678:	100a97fa 	slli	r5,r2,31
8111167c:	00802034 	movhi	r2,128
81111680:	10bfffc4 	addi	r2,r2,-1
81111684:	2084703a 	and	r2,r4,r2
81111688:	10c4b03a 	or	r2,r2,r3
8111168c:	1144b03a 	or	r2,r2,r5
81111690:	dfc00a17 	ldw	ra,40(sp)
81111694:	df000917 	ldw	fp,36(sp)
81111698:	ddc00817 	ldw	r23,32(sp)
8111169c:	dd800717 	ldw	r22,28(sp)
811116a0:	dd400617 	ldw	r21,24(sp)
811116a4:	dd000517 	ldw	r20,20(sp)
811116a8:	dcc00417 	ldw	r19,16(sp)
811116ac:	dc800317 	ldw	r18,12(sp)
811116b0:	dc400217 	ldw	r17,8(sp)
811116b4:	dc000117 	ldw	r16,4(sp)
811116b8:	dec00b04 	addi	sp,sp,44
811116bc:	f800283a 	ret
811116c0:	90000d1e 	bne	r18,zero,811116f8 <__mulsf3+0x1e0>
811116c4:	04400104 	movi	r17,4
811116c8:	05c00044 	movi	r23,1
811116cc:	003faf06 	br	8111158c <__reset+0xfb0f158c>
811116d0:	9806c03a 	cmpne	r3,r19,zero
811116d4:	18c00084 	addi	r3,r3,2
811116d8:	003fba06 	br	811115c4 <__reset+0xfb0f15c4>
811116dc:	9800141e 	bne	r19,zero,81111730 <__mulsf3+0x218>
811116e0:	00c00044 	movi	r3,1
811116e4:	003fb706 	br	811115c4 <__reset+0xfb0f15c4>
811116e8:	a829883a 	mov	r20,r21
811116ec:	00ffffc4 	movi	r3,-1
811116f0:	0009883a 	mov	r4,zero
811116f4:	003fdd06 	br	8111166c <__reset+0xfb0f166c>
811116f8:	9009883a 	mov	r4,r18
811116fc:	d9400015 	stw	r5,0(sp)
81111700:	11125200 	call	81112520 <__clzsi2>
81111704:	10fffec4 	addi	r3,r2,-5
81111708:	10801d84 	addi	r2,r2,118
8111170c:	90e4983a 	sll	r18,r18,r3
81111710:	00a1c83a 	sub	r16,zero,r2
81111714:	0023883a 	mov	r17,zero
81111718:	002f883a 	mov	r23,zero
8111171c:	d9400017 	ldw	r5,0(sp)
81111720:	003f9a06 	br	8111158c <__reset+0xfb0f158c>
81111724:	04400304 	movi	r17,12
81111728:	05c000c4 	movi	r23,3
8111172c:	003f9706 	br	8111158c <__reset+0xfb0f158c>
81111730:	9809883a 	mov	r4,r19
81111734:	d9800015 	stw	r6,0(sp)
81111738:	11125200 	call	81112520 <__clzsi2>
8111173c:	10fffec4 	addi	r3,r2,-5
81111740:	10801d84 	addi	r2,r2,118
81111744:	98e6983a 	sll	r19,r19,r3
81111748:	0085c83a 	sub	r2,zero,r2
8111174c:	0007883a 	mov	r3,zero
81111750:	d9800017 	ldw	r6,0(sp)
81111754:	003f9b06 	br	811115c4 <__reset+0xfb0f15c4>
81111758:	01002034 	movhi	r4,128
8111175c:	0029883a 	mov	r20,zero
81111760:	213fffc4 	addi	r4,r4,-1
81111764:	00ffffc4 	movi	r3,-1
81111768:	003fc006 	br	8111166c <__reset+0xfb0f166c>
8111176c:	9027883a 	mov	r19,r18
81111770:	b807883a 	mov	r3,r23
81111774:	003fb406 	br	81111648 <__reset+0xfb0f1648>
81111778:	9027883a 	mov	r19,r18
8111177c:	e02b883a 	mov	r21,fp
81111780:	b807883a 	mov	r3,r23
81111784:	003fb006 	br	81111648 <__reset+0xfb0f1648>
81111788:	9004d43a 	srli	r2,r18,16
8111178c:	9810d43a 	srli	r8,r19,16
81111790:	94bfffcc 	andi	r18,r18,65535
81111794:	993fffcc 	andi	r4,r19,65535
81111798:	910d383a 	mul	r6,r18,r4
8111179c:	20a7383a 	mul	r19,r4,r2
811117a0:	9225383a 	mul	r18,r18,r8
811117a4:	3006d43a 	srli	r3,r6,16
811117a8:	1211383a 	mul	r8,r2,r8
811117ac:	94e5883a 	add	r18,r18,r19
811117b0:	1c87883a 	add	r3,r3,r18
811117b4:	1cc0022e 	bgeu	r3,r19,811117c0 <__mulsf3+0x2a8>
811117b8:	00800074 	movhi	r2,1
811117bc:	4091883a 	add	r8,r8,r2
811117c0:	1804943a 	slli	r2,r3,16
811117c4:	31bfffcc 	andi	r6,r6,65535
811117c8:	1806d43a 	srli	r3,r3,16
811117cc:	1185883a 	add	r2,r2,r6
811117d0:	102691ba 	slli	r19,r2,6
811117d4:	1a07883a 	add	r3,r3,r8
811117d8:	1004d6ba 	srli	r2,r2,26
811117dc:	180891ba 	slli	r4,r3,6
811117e0:	9826c03a 	cmpne	r19,r19,zero
811117e4:	9884b03a 	or	r2,r19,r2
811117e8:	1126b03a 	or	r19,r2,r4
811117ec:	9882002c 	andhi	r2,r19,2048
811117f0:	10000426 	beq	r2,zero,81111804 <__mulsf3+0x2ec>
811117f4:	9804d07a 	srli	r2,r19,1
811117f8:	9900004c 	andi	r4,r19,1
811117fc:	3821883a 	mov	r16,r7
81111800:	1126b03a 	or	r19,r2,r4
81111804:	80c01fc4 	addi	r3,r16,127
81111808:	00c0210e 	bge	zero,r3,81111890 <__mulsf3+0x378>
8111180c:	988001cc 	andi	r2,r19,7
81111810:	10000426 	beq	r2,zero,81111824 <__mulsf3+0x30c>
81111814:	988003cc 	andi	r2,r19,15
81111818:	01000104 	movi	r4,4
8111181c:	11000126 	beq	r2,r4,81111824 <__mulsf3+0x30c>
81111820:	9927883a 	add	r19,r19,r4
81111824:	9882002c 	andhi	r2,r19,2048
81111828:	10000426 	beq	r2,zero,8111183c <__mulsf3+0x324>
8111182c:	00be0034 	movhi	r2,63488
81111830:	10bfffc4 	addi	r2,r2,-1
81111834:	80c02004 	addi	r3,r16,128
81111838:	98a6703a 	and	r19,r19,r2
8111183c:	00803f84 	movi	r2,254
81111840:	10ffa916 	blt	r2,r3,811116e8 <__reset+0xfb0f16e8>
81111844:	980891ba 	slli	r4,r19,6
81111848:	a829883a 	mov	r20,r21
8111184c:	2008d27a 	srli	r4,r4,9
81111850:	003f8606 	br	8111166c <__reset+0xfb0f166c>
81111854:	9080102c 	andhi	r2,r18,64
81111858:	10000826 	beq	r2,zero,8111187c <__mulsf3+0x364>
8111185c:	9880102c 	andhi	r2,r19,64
81111860:	1000061e 	bne	r2,zero,8111187c <__mulsf3+0x364>
81111864:	00802034 	movhi	r2,128
81111868:	99001034 	orhi	r4,r19,64
8111186c:	10bfffc4 	addi	r2,r2,-1
81111870:	b029883a 	mov	r20,r22
81111874:	2088703a 	and	r4,r4,r2
81111878:	003fba06 	br	81111764 <__reset+0xfb0f1764>
8111187c:	00802034 	movhi	r2,128
81111880:	91001034 	orhi	r4,r18,64
81111884:	10bfffc4 	addi	r2,r2,-1
81111888:	2088703a 	and	r4,r4,r2
8111188c:	003fb506 	br	81111764 <__reset+0xfb0f1764>
81111890:	00800044 	movi	r2,1
81111894:	10c7c83a 	sub	r3,r2,r3
81111898:	008006c4 	movi	r2,27
8111189c:	10ff7016 	blt	r2,r3,81111660 <__reset+0xfb0f1660>
811118a0:	00800804 	movi	r2,32
811118a4:	10c5c83a 	sub	r2,r2,r3
811118a8:	9884983a 	sll	r2,r19,r2
811118ac:	98c6d83a 	srl	r3,r19,r3
811118b0:	1004c03a 	cmpne	r2,r2,zero
811118b4:	1884b03a 	or	r2,r3,r2
811118b8:	10c001cc 	andi	r3,r2,7
811118bc:	18000426 	beq	r3,zero,811118d0 <__mulsf3+0x3b8>
811118c0:	10c003cc 	andi	r3,r2,15
811118c4:	01000104 	movi	r4,4
811118c8:	19000126 	beq	r3,r4,811118d0 <__mulsf3+0x3b8>
811118cc:	1105883a 	add	r2,r2,r4
811118d0:	10c1002c 	andhi	r3,r2,1024
811118d4:	18000626 	beq	r3,zero,811118f0 <__mulsf3+0x3d8>
811118d8:	a829883a 	mov	r20,r21
811118dc:	00c00044 	movi	r3,1
811118e0:	0009883a 	mov	r4,zero
811118e4:	003f6106 	br	8111166c <__reset+0xfb0f166c>
811118e8:	3821883a 	mov	r16,r7
811118ec:	003fc506 	br	81111804 <__reset+0xfb0f1804>
811118f0:	100491ba 	slli	r2,r2,6
811118f4:	a829883a 	mov	r20,r21
811118f8:	0007883a 	mov	r3,zero
811118fc:	1008d27a 	srli	r4,r2,9
81111900:	003f5a06 	br	8111166c <__reset+0xfb0f166c>
81111904:	00802034 	movhi	r2,128
81111908:	99001034 	orhi	r4,r19,64
8111190c:	10bfffc4 	addi	r2,r2,-1
81111910:	a829883a 	mov	r20,r21
81111914:	2088703a 	and	r4,r4,r2
81111918:	003f9206 	br	81111764 <__reset+0xfb0f1764>

8111191c <__floatsisf>:
8111191c:	defffd04 	addi	sp,sp,-12
81111920:	de00012e 	bgeu	sp,et,81111928 <__floatsisf+0xc>
81111924:	003b68fa 	trap	3
81111928:	dfc00215 	stw	ra,8(sp)
8111192c:	dc400115 	stw	r17,4(sp)
81111930:	dc000015 	stw	r16,0(sp)
81111934:	20003526 	beq	r4,zero,81111a0c <__floatsisf+0xf0>
81111938:	2021883a 	mov	r16,r4
8111193c:	2022d7fa 	srli	r17,r4,31
81111940:	20003616 	blt	r4,zero,81111a1c <__floatsisf+0x100>
81111944:	8009883a 	mov	r4,r16
81111948:	11125200 	call	81112520 <__clzsi2>
8111194c:	00c02784 	movi	r3,158
81111950:	1887c83a 	sub	r3,r3,r2
81111954:	01002584 	movi	r4,150
81111958:	20c01416 	blt	r4,r3,811119ac <__floatsisf+0x90>
8111195c:	20c9c83a 	sub	r4,r4,r3
81111960:	8120983a 	sll	r16,r16,r4
81111964:	00802034 	movhi	r2,128
81111968:	10bfffc4 	addi	r2,r2,-1
8111196c:	8809883a 	mov	r4,r17
81111970:	80a0703a 	and	r16,r16,r2
81111974:	18803fcc 	andi	r2,r3,255
81111978:	100695fa 	slli	r3,r2,23
8111197c:	20803fcc 	andi	r2,r4,255
81111980:	100897fa 	slli	r4,r2,31
81111984:	00802034 	movhi	r2,128
81111988:	10bfffc4 	addi	r2,r2,-1
8111198c:	8084703a 	and	r2,r16,r2
81111990:	10c4b03a 	or	r2,r2,r3
81111994:	1104b03a 	or	r2,r2,r4
81111998:	dfc00217 	ldw	ra,8(sp)
8111199c:	dc400117 	ldw	r17,4(sp)
811119a0:	dc000017 	ldw	r16,0(sp)
811119a4:	dec00304 	addi	sp,sp,12
811119a8:	f800283a 	ret
811119ac:	01002644 	movi	r4,153
811119b0:	20c01c16 	blt	r4,r3,81111a24 <__floatsisf+0x108>
811119b4:	20c9c83a 	sub	r4,r4,r3
811119b8:	8120983a 	sll	r16,r16,r4
811119bc:	013f0034 	movhi	r4,64512
811119c0:	213fffc4 	addi	r4,r4,-1
811119c4:	814001cc 	andi	r5,r16,7
811119c8:	8108703a 	and	r4,r16,r4
811119cc:	28000426 	beq	r5,zero,811119e0 <__floatsisf+0xc4>
811119d0:	840003cc 	andi	r16,r16,15
811119d4:	01400104 	movi	r5,4
811119d8:	81400126 	beq	r16,r5,811119e0 <__floatsisf+0xc4>
811119dc:	2149883a 	add	r4,r4,r5
811119e0:	2141002c 	andhi	r5,r4,1024
811119e4:	28000526 	beq	r5,zero,811119fc <__floatsisf+0xe0>
811119e8:	00c027c4 	movi	r3,159
811119ec:	1887c83a 	sub	r3,r3,r2
811119f0:	00bf0034 	movhi	r2,64512
811119f4:	10bfffc4 	addi	r2,r2,-1
811119f8:	2088703a 	and	r4,r4,r2
811119fc:	202091ba 	slli	r16,r4,6
81111a00:	8809883a 	mov	r4,r17
81111a04:	8020d27a 	srli	r16,r16,9
81111a08:	003fda06 	br	81111974 <__reset+0xfb0f1974>
81111a0c:	0009883a 	mov	r4,zero
81111a10:	0007883a 	mov	r3,zero
81111a14:	0021883a 	mov	r16,zero
81111a18:	003fd606 	br	81111974 <__reset+0xfb0f1974>
81111a1c:	0121c83a 	sub	r16,zero,r4
81111a20:	003fc806 	br	81111944 <__reset+0xfb0f1944>
81111a24:	01002e44 	movi	r4,185
81111a28:	20c9c83a 	sub	r4,r4,r3
81111a2c:	01400144 	movi	r5,5
81111a30:	8108983a 	sll	r4,r16,r4
81111a34:	288bc83a 	sub	r5,r5,r2
81111a38:	8160d83a 	srl	r16,r16,r5
81111a3c:	2008c03a 	cmpne	r4,r4,zero
81111a40:	8120b03a 	or	r16,r16,r4
81111a44:	003fdd06 	br	811119bc <__reset+0xfb0f19bc>

81111a48 <__floatunsisf>:
81111a48:	defffe04 	addi	sp,sp,-8
81111a4c:	de00012e 	bgeu	sp,et,81111a54 <__floatunsisf+0xc>
81111a50:	003b68fa 	trap	3
81111a54:	dfc00115 	stw	ra,4(sp)
81111a58:	dc000015 	stw	r16,0(sp)
81111a5c:	20002c26 	beq	r4,zero,81111b10 <__floatunsisf+0xc8>
81111a60:	2021883a 	mov	r16,r4
81111a64:	11125200 	call	81112520 <__clzsi2>
81111a68:	00c02784 	movi	r3,158
81111a6c:	1887c83a 	sub	r3,r3,r2
81111a70:	01002584 	movi	r4,150
81111a74:	20c00f16 	blt	r4,r3,81111ab4 <__floatunsisf+0x6c>
81111a78:	20c9c83a 	sub	r4,r4,r3
81111a7c:	8108983a 	sll	r4,r16,r4
81111a80:	00802034 	movhi	r2,128
81111a84:	10bfffc4 	addi	r2,r2,-1
81111a88:	2088703a 	and	r4,r4,r2
81111a8c:	18803fcc 	andi	r2,r3,255
81111a90:	100695fa 	slli	r3,r2,23
81111a94:	00802034 	movhi	r2,128
81111a98:	10bfffc4 	addi	r2,r2,-1
81111a9c:	2084703a 	and	r2,r4,r2
81111aa0:	10c4b03a 	or	r2,r2,r3
81111aa4:	dfc00117 	ldw	ra,4(sp)
81111aa8:	dc000017 	ldw	r16,0(sp)
81111aac:	dec00204 	addi	sp,sp,8
81111ab0:	f800283a 	ret
81111ab4:	01002644 	movi	r4,153
81111ab8:	20c01816 	blt	r4,r3,81111b1c <__floatunsisf+0xd4>
81111abc:	20c9c83a 	sub	r4,r4,r3
81111ac0:	8108983a 	sll	r4,r16,r4
81111ac4:	017f0034 	movhi	r5,64512
81111ac8:	297fffc4 	addi	r5,r5,-1
81111acc:	218001cc 	andi	r6,r4,7
81111ad0:	214a703a 	and	r5,r4,r5
81111ad4:	30000426 	beq	r6,zero,81111ae8 <__floatunsisf+0xa0>
81111ad8:	210003cc 	andi	r4,r4,15
81111adc:	01800104 	movi	r6,4
81111ae0:	21800126 	beq	r4,r6,81111ae8 <__floatunsisf+0xa0>
81111ae4:	298b883a 	add	r5,r5,r6
81111ae8:	2901002c 	andhi	r4,r5,1024
81111aec:	20000526 	beq	r4,zero,81111b04 <__floatunsisf+0xbc>
81111af0:	00c027c4 	movi	r3,159
81111af4:	1887c83a 	sub	r3,r3,r2
81111af8:	00bf0034 	movhi	r2,64512
81111afc:	10bfffc4 	addi	r2,r2,-1
81111b00:	288a703a 	and	r5,r5,r2
81111b04:	280891ba 	slli	r4,r5,6
81111b08:	2008d27a 	srli	r4,r4,9
81111b0c:	003fdf06 	br	81111a8c <__reset+0xfb0f1a8c>
81111b10:	0007883a 	mov	r3,zero
81111b14:	0009883a 	mov	r4,zero
81111b18:	003fdc06 	br	81111a8c <__reset+0xfb0f1a8c>
81111b1c:	01402e44 	movi	r5,185
81111b20:	28cbc83a 	sub	r5,r5,r3
81111b24:	01000144 	movi	r4,5
81111b28:	2089c83a 	sub	r4,r4,r2
81111b2c:	814a983a 	sll	r5,r16,r5
81111b30:	8108d83a 	srl	r4,r16,r4
81111b34:	2820c03a 	cmpne	r16,r5,zero
81111b38:	2408b03a 	or	r4,r4,r16
81111b3c:	003fe106 	br	81111ac4 <__reset+0xfb0f1ac4>

81111b40 <__muldf3>:
81111b40:	defff304 	addi	sp,sp,-52
81111b44:	2804d53a 	srli	r2,r5,20
81111b48:	de00012e 	bgeu	sp,et,81111b50 <__muldf3+0x10>
81111b4c:	003b68fa 	trap	3
81111b50:	dd800915 	stw	r22,36(sp)
81111b54:	282cd7fa 	srli	r22,r5,31
81111b58:	dc000315 	stw	r16,12(sp)
81111b5c:	04000434 	movhi	r16,16
81111b60:	dd400815 	stw	r21,32(sp)
81111b64:	dc800515 	stw	r18,20(sp)
81111b68:	843fffc4 	addi	r16,r16,-1
81111b6c:	dfc00c15 	stw	ra,48(sp)
81111b70:	df000b15 	stw	fp,44(sp)
81111b74:	ddc00a15 	stw	r23,40(sp)
81111b78:	dd000715 	stw	r20,28(sp)
81111b7c:	dcc00615 	stw	r19,24(sp)
81111b80:	dc400415 	stw	r17,16(sp)
81111b84:	1481ffcc 	andi	r18,r2,2047
81111b88:	2c20703a 	and	r16,r5,r16
81111b8c:	b02b883a 	mov	r21,r22
81111b90:	b2403fcc 	andi	r9,r22,255
81111b94:	90006026 	beq	r18,zero,81111d18 <__muldf3+0x1d8>
81111b98:	0081ffc4 	movi	r2,2047
81111b9c:	2029883a 	mov	r20,r4
81111ba0:	90803626 	beq	r18,r2,81111c7c <__muldf3+0x13c>
81111ba4:	80800434 	orhi	r2,r16,16
81111ba8:	100490fa 	slli	r2,r2,3
81111bac:	2020d77a 	srli	r16,r4,29
81111bb0:	202890fa 	slli	r20,r4,3
81111bb4:	94bf0044 	addi	r18,r18,-1023
81111bb8:	80a0b03a 	or	r16,r16,r2
81111bbc:	0027883a 	mov	r19,zero
81111bc0:	0039883a 	mov	fp,zero
81111bc4:	3804d53a 	srli	r2,r7,20
81111bc8:	382ed7fa 	srli	r23,r7,31
81111bcc:	04400434 	movhi	r17,16
81111bd0:	8c7fffc4 	addi	r17,r17,-1
81111bd4:	1081ffcc 	andi	r2,r2,2047
81111bd8:	3011883a 	mov	r8,r6
81111bdc:	3c62703a 	and	r17,r7,r17
81111be0:	ba803fcc 	andi	r10,r23,255
81111be4:	10006d26 	beq	r2,zero,81111d9c <__muldf3+0x25c>
81111be8:	00c1ffc4 	movi	r3,2047
81111bec:	10c06526 	beq	r2,r3,81111d84 <__muldf3+0x244>
81111bf0:	88c00434 	orhi	r3,r17,16
81111bf4:	180690fa 	slli	r3,r3,3
81111bf8:	3022d77a 	srli	r17,r6,29
81111bfc:	301090fa 	slli	r8,r6,3
81111c00:	10bf0044 	addi	r2,r2,-1023
81111c04:	88e2b03a 	or	r17,r17,r3
81111c08:	000b883a 	mov	r5,zero
81111c0c:	9085883a 	add	r2,r18,r2
81111c10:	2cc8b03a 	or	r4,r5,r19
81111c14:	00c003c4 	movi	r3,15
81111c18:	bdacf03a 	xor	r22,r23,r22
81111c1c:	12c00044 	addi	r11,r2,1
81111c20:	19009936 	bltu	r3,r4,81111e88 <__muldf3+0x348>
81111c24:	200890ba 	slli	r4,r4,2
81111c28:	00e04474 	movhi	r3,33041
81111c2c:	18c70f04 	addi	r3,r3,7228
81111c30:	20c9883a 	add	r4,r4,r3
81111c34:	20c00017 	ldw	r3,0(r4)
81111c38:	1800683a 	jmp	r3
81111c3c:	81111e88 	cmpgei	r4,r16,17530
81111c40:	81111c9c 	xori	r4,r16,17522
81111c44:	81111c9c 	xori	r4,r16,17522
81111c48:	81111c98 	cmpnei	r4,r16,17522
81111c4c:	81111e64 	muli	r4,r16,17529
81111c50:	81111e64 	muli	r4,r16,17529
81111c54:	81111e4c 	andi	r4,r16,17529
81111c58:	81111c98 	cmpnei	r4,r16,17522
81111c5c:	81111e64 	muli	r4,r16,17529
81111c60:	81111e4c 	andi	r4,r16,17529
81111c64:	81111e64 	muli	r4,r16,17529
81111c68:	81111c98 	cmpnei	r4,r16,17522
81111c6c:	81111e74 	orhi	r4,r16,17529
81111c70:	81111e74 	orhi	r4,r16,17529
81111c74:	81111e74 	orhi	r4,r16,17529
81111c78:	81112090 	cmplti	r4,r16,17538
81111c7c:	2404b03a 	or	r2,r4,r16
81111c80:	10006f1e 	bne	r2,zero,81111e40 <__muldf3+0x300>
81111c84:	04c00204 	movi	r19,8
81111c88:	0021883a 	mov	r16,zero
81111c8c:	0029883a 	mov	r20,zero
81111c90:	07000084 	movi	fp,2
81111c94:	003fcb06 	br	81111bc4 <__reset+0xfb0f1bc4>
81111c98:	502d883a 	mov	r22,r10
81111c9c:	00800084 	movi	r2,2
81111ca0:	28805726 	beq	r5,r2,81111e00 <__muldf3+0x2c0>
81111ca4:	008000c4 	movi	r2,3
81111ca8:	28816626 	beq	r5,r2,81112244 <__muldf3+0x704>
81111cac:	00800044 	movi	r2,1
81111cb0:	2881411e 	bne	r5,r2,811121b8 <__muldf3+0x678>
81111cb4:	b02b883a 	mov	r21,r22
81111cb8:	0005883a 	mov	r2,zero
81111cbc:	000b883a 	mov	r5,zero
81111cc0:	0029883a 	mov	r20,zero
81111cc4:	1004953a 	slli	r2,r2,20
81111cc8:	a8c03fcc 	andi	r3,r21,255
81111ccc:	04400434 	movhi	r17,16
81111cd0:	8c7fffc4 	addi	r17,r17,-1
81111cd4:	180697fa 	slli	r3,r3,31
81111cd8:	2c4a703a 	and	r5,r5,r17
81111cdc:	288ab03a 	or	r5,r5,r2
81111ce0:	28c6b03a 	or	r3,r5,r3
81111ce4:	a005883a 	mov	r2,r20
81111ce8:	dfc00c17 	ldw	ra,48(sp)
81111cec:	df000b17 	ldw	fp,44(sp)
81111cf0:	ddc00a17 	ldw	r23,40(sp)
81111cf4:	dd800917 	ldw	r22,36(sp)
81111cf8:	dd400817 	ldw	r21,32(sp)
81111cfc:	dd000717 	ldw	r20,28(sp)
81111d00:	dcc00617 	ldw	r19,24(sp)
81111d04:	dc800517 	ldw	r18,20(sp)
81111d08:	dc400417 	ldw	r17,16(sp)
81111d0c:	dc000317 	ldw	r16,12(sp)
81111d10:	dec00d04 	addi	sp,sp,52
81111d14:	f800283a 	ret
81111d18:	2404b03a 	or	r2,r4,r16
81111d1c:	2027883a 	mov	r19,r4
81111d20:	10004226 	beq	r2,zero,81111e2c <__muldf3+0x2ec>
81111d24:	8000fc26 	beq	r16,zero,81112118 <__muldf3+0x5d8>
81111d28:	8009883a 	mov	r4,r16
81111d2c:	d9800215 	stw	r6,8(sp)
81111d30:	d9c00015 	stw	r7,0(sp)
81111d34:	da400115 	stw	r9,4(sp)
81111d38:	11125200 	call	81112520 <__clzsi2>
81111d3c:	d9800217 	ldw	r6,8(sp)
81111d40:	d9c00017 	ldw	r7,0(sp)
81111d44:	da400117 	ldw	r9,4(sp)
81111d48:	113ffd44 	addi	r4,r2,-11
81111d4c:	00c00704 	movi	r3,28
81111d50:	1900ed16 	blt	r3,r4,81112108 <__muldf3+0x5c8>
81111d54:	00c00744 	movi	r3,29
81111d58:	147ffe04 	addi	r17,r2,-8
81111d5c:	1907c83a 	sub	r3,r3,r4
81111d60:	8460983a 	sll	r16,r16,r17
81111d64:	98c6d83a 	srl	r3,r19,r3
81111d68:	9c68983a 	sll	r20,r19,r17
81111d6c:	1c20b03a 	or	r16,r3,r16
81111d70:	1080fcc4 	addi	r2,r2,1011
81111d74:	00a5c83a 	sub	r18,zero,r2
81111d78:	0027883a 	mov	r19,zero
81111d7c:	0039883a 	mov	fp,zero
81111d80:	003f9006 	br	81111bc4 <__reset+0xfb0f1bc4>
81111d84:	3446b03a 	or	r3,r6,r17
81111d88:	1800261e 	bne	r3,zero,81111e24 <__muldf3+0x2e4>
81111d8c:	0023883a 	mov	r17,zero
81111d90:	0011883a 	mov	r8,zero
81111d94:	01400084 	movi	r5,2
81111d98:	003f9c06 	br	81111c0c <__reset+0xfb0f1c0c>
81111d9c:	3446b03a 	or	r3,r6,r17
81111da0:	18001c26 	beq	r3,zero,81111e14 <__muldf3+0x2d4>
81111da4:	8800ce26 	beq	r17,zero,811120e0 <__muldf3+0x5a0>
81111da8:	8809883a 	mov	r4,r17
81111dac:	d9800215 	stw	r6,8(sp)
81111db0:	da400115 	stw	r9,4(sp)
81111db4:	da800015 	stw	r10,0(sp)
81111db8:	11125200 	call	81112520 <__clzsi2>
81111dbc:	d9800217 	ldw	r6,8(sp)
81111dc0:	da400117 	ldw	r9,4(sp)
81111dc4:	da800017 	ldw	r10,0(sp)
81111dc8:	113ffd44 	addi	r4,r2,-11
81111dcc:	00c00704 	movi	r3,28
81111dd0:	1900bf16 	blt	r3,r4,811120d0 <__muldf3+0x590>
81111dd4:	00c00744 	movi	r3,29
81111dd8:	123ffe04 	addi	r8,r2,-8
81111ddc:	1907c83a 	sub	r3,r3,r4
81111de0:	8a22983a 	sll	r17,r17,r8
81111de4:	30c6d83a 	srl	r3,r6,r3
81111de8:	3210983a 	sll	r8,r6,r8
81111dec:	1c62b03a 	or	r17,r3,r17
81111df0:	1080fcc4 	addi	r2,r2,1011
81111df4:	0085c83a 	sub	r2,zero,r2
81111df8:	000b883a 	mov	r5,zero
81111dfc:	003f8306 	br	81111c0c <__reset+0xfb0f1c0c>
81111e00:	b02b883a 	mov	r21,r22
81111e04:	0081ffc4 	movi	r2,2047
81111e08:	000b883a 	mov	r5,zero
81111e0c:	0029883a 	mov	r20,zero
81111e10:	003fac06 	br	81111cc4 <__reset+0xfb0f1cc4>
81111e14:	0023883a 	mov	r17,zero
81111e18:	0011883a 	mov	r8,zero
81111e1c:	01400044 	movi	r5,1
81111e20:	003f7a06 	br	81111c0c <__reset+0xfb0f1c0c>
81111e24:	014000c4 	movi	r5,3
81111e28:	003f7806 	br	81111c0c <__reset+0xfb0f1c0c>
81111e2c:	04c00104 	movi	r19,4
81111e30:	0021883a 	mov	r16,zero
81111e34:	0029883a 	mov	r20,zero
81111e38:	07000044 	movi	fp,1
81111e3c:	003f6106 	br	81111bc4 <__reset+0xfb0f1bc4>
81111e40:	04c00304 	movi	r19,12
81111e44:	070000c4 	movi	fp,3
81111e48:	003f5e06 	br	81111bc4 <__reset+0xfb0f1bc4>
81111e4c:	01400434 	movhi	r5,16
81111e50:	002b883a 	mov	r21,zero
81111e54:	297fffc4 	addi	r5,r5,-1
81111e58:	053fffc4 	movi	r20,-1
81111e5c:	0081ffc4 	movi	r2,2047
81111e60:	003f9806 	br	81111cc4 <__reset+0xfb0f1cc4>
81111e64:	8023883a 	mov	r17,r16
81111e68:	a011883a 	mov	r8,r20
81111e6c:	e00b883a 	mov	r5,fp
81111e70:	003f8a06 	br	81111c9c <__reset+0xfb0f1c9c>
81111e74:	8023883a 	mov	r17,r16
81111e78:	a011883a 	mov	r8,r20
81111e7c:	482d883a 	mov	r22,r9
81111e80:	e00b883a 	mov	r5,fp
81111e84:	003f8506 	br	81111c9c <__reset+0xfb0f1c9c>
81111e88:	a00ad43a 	srli	r5,r20,16
81111e8c:	401ad43a 	srli	r13,r8,16
81111e90:	a53fffcc 	andi	r20,r20,65535
81111e94:	423fffcc 	andi	r8,r8,65535
81111e98:	4519383a 	mul	r12,r8,r20
81111e9c:	4147383a 	mul	r3,r8,r5
81111ea0:	6d09383a 	mul	r4,r13,r20
81111ea4:	600cd43a 	srli	r6,r12,16
81111ea8:	2b5d383a 	mul	r14,r5,r13
81111eac:	20c9883a 	add	r4,r4,r3
81111eb0:	310d883a 	add	r6,r6,r4
81111eb4:	30c0022e 	bgeu	r6,r3,81111ec0 <__muldf3+0x380>
81111eb8:	00c00074 	movhi	r3,1
81111ebc:	70dd883a 	add	r14,r14,r3
81111ec0:	8826d43a 	srli	r19,r17,16
81111ec4:	8bffffcc 	andi	r15,r17,65535
81111ec8:	7d23383a 	mul	r17,r15,r20
81111ecc:	7949383a 	mul	r4,r15,r5
81111ed0:	9d29383a 	mul	r20,r19,r20
81111ed4:	8814d43a 	srli	r10,r17,16
81111ed8:	3012943a 	slli	r9,r6,16
81111edc:	a129883a 	add	r20,r20,r4
81111ee0:	633fffcc 	andi	r12,r12,65535
81111ee4:	5515883a 	add	r10,r10,r20
81111ee8:	3006d43a 	srli	r3,r6,16
81111eec:	4b13883a 	add	r9,r9,r12
81111ef0:	2ccb383a 	mul	r5,r5,r19
81111ef4:	5100022e 	bgeu	r10,r4,81111f00 <__muldf3+0x3c0>
81111ef8:	01000074 	movhi	r4,1
81111efc:	290b883a 	add	r5,r5,r4
81111f00:	802ad43a 	srli	r21,r16,16
81111f04:	843fffcc 	andi	r16,r16,65535
81111f08:	440d383a 	mul	r6,r8,r16
81111f0c:	4565383a 	mul	r18,r8,r21
81111f10:	8349383a 	mul	r4,r16,r13
81111f14:	500e943a 	slli	r7,r10,16
81111f18:	3010d43a 	srli	r8,r6,16
81111f1c:	5028d43a 	srli	r20,r10,16
81111f20:	2489883a 	add	r4,r4,r18
81111f24:	8abfffcc 	andi	r10,r17,65535
81111f28:	3a95883a 	add	r10,r7,r10
81111f2c:	4119883a 	add	r12,r8,r4
81111f30:	a169883a 	add	r20,r20,r5
81111f34:	1a87883a 	add	r3,r3,r10
81111f38:	6d5b383a 	mul	r13,r13,r21
81111f3c:	6480022e 	bgeu	r12,r18,81111f48 <__muldf3+0x408>
81111f40:	01000074 	movhi	r4,1
81111f44:	691b883a 	add	r13,r13,r4
81111f48:	7c25383a 	mul	r18,r15,r16
81111f4c:	7d4b383a 	mul	r5,r15,r21
81111f50:	84cf383a 	mul	r7,r16,r19
81111f54:	901ed43a 	srli	r15,r18,16
81111f58:	6008d43a 	srli	r4,r12,16
81111f5c:	6010943a 	slli	r8,r12,16
81111f60:	394f883a 	add	r7,r7,r5
81111f64:	333fffcc 	andi	r12,r6,65535
81111f68:	79df883a 	add	r15,r15,r7
81111f6c:	235b883a 	add	r13,r4,r13
81111f70:	9d63383a 	mul	r17,r19,r21
81111f74:	4309883a 	add	r4,r8,r12
81111f78:	7940022e 	bgeu	r15,r5,81111f84 <__muldf3+0x444>
81111f7c:	01400074 	movhi	r5,1
81111f80:	8963883a 	add	r17,r17,r5
81111f84:	780a943a 	slli	r5,r15,16
81111f88:	91bfffcc 	andi	r6,r18,65535
81111f8c:	70c7883a 	add	r3,r14,r3
81111f90:	298d883a 	add	r6,r5,r6
81111f94:	1a8f803a 	cmpltu	r7,r3,r10
81111f98:	350b883a 	add	r5,r6,r20
81111f9c:	20c7883a 	add	r3,r4,r3
81111fa0:	3955883a 	add	r10,r7,r5
81111fa4:	1909803a 	cmpltu	r4,r3,r4
81111fa8:	6a91883a 	add	r8,r13,r10
81111fac:	780cd43a 	srli	r6,r15,16
81111fb0:	2219883a 	add	r12,r4,r8
81111fb4:	2d0b803a 	cmpltu	r5,r5,r20
81111fb8:	51cf803a 	cmpltu	r7,r10,r7
81111fbc:	29ceb03a 	or	r7,r5,r7
81111fc0:	4351803a 	cmpltu	r8,r8,r13
81111fc4:	610b803a 	cmpltu	r5,r12,r4
81111fc8:	4148b03a 	or	r4,r8,r5
81111fcc:	398f883a 	add	r7,r7,r6
81111fd0:	3909883a 	add	r4,r7,r4
81111fd4:	1810927a 	slli	r8,r3,9
81111fd8:	2449883a 	add	r4,r4,r17
81111fdc:	2008927a 	slli	r4,r4,9
81111fe0:	6022d5fa 	srli	r17,r12,23
81111fe4:	1806d5fa 	srli	r3,r3,23
81111fe8:	4252b03a 	or	r9,r8,r9
81111fec:	600a927a 	slli	r5,r12,9
81111ff0:	4810c03a 	cmpne	r8,r9,zero
81111ff4:	2462b03a 	or	r17,r4,r17
81111ff8:	40c6b03a 	or	r3,r8,r3
81111ffc:	8900402c 	andhi	r4,r17,256
81112000:	1950b03a 	or	r8,r3,r5
81112004:	20000726 	beq	r4,zero,81112024 <__muldf3+0x4e4>
81112008:	4006d07a 	srli	r3,r8,1
8111200c:	880497fa 	slli	r2,r17,31
81112010:	4200004c 	andi	r8,r8,1
81112014:	8822d07a 	srli	r17,r17,1
81112018:	1a10b03a 	or	r8,r3,r8
8111201c:	1210b03a 	or	r8,r2,r8
81112020:	5805883a 	mov	r2,r11
81112024:	1140ffc4 	addi	r5,r2,1023
81112028:	0140440e 	bge	zero,r5,8111213c <__muldf3+0x5fc>
8111202c:	40c001cc 	andi	r3,r8,7
81112030:	18000726 	beq	r3,zero,81112050 <__muldf3+0x510>
81112034:	40c003cc 	andi	r3,r8,15
81112038:	01000104 	movi	r4,4
8111203c:	19000426 	beq	r3,r4,81112050 <__muldf3+0x510>
81112040:	4107883a 	add	r3,r8,r4
81112044:	1a11803a 	cmpltu	r8,r3,r8
81112048:	8a23883a 	add	r17,r17,r8
8111204c:	1811883a 	mov	r8,r3
81112050:	88c0402c 	andhi	r3,r17,256
81112054:	18000426 	beq	r3,zero,81112068 <__muldf3+0x528>
81112058:	11410004 	addi	r5,r2,1024
8111205c:	00bfc034 	movhi	r2,65280
81112060:	10bfffc4 	addi	r2,r2,-1
81112064:	88a2703a 	and	r17,r17,r2
81112068:	0081ff84 	movi	r2,2046
8111206c:	117f6416 	blt	r2,r5,81111e00 <__reset+0xfb0f1e00>
81112070:	8828977a 	slli	r20,r17,29
81112074:	4010d0fa 	srli	r8,r8,3
81112078:	8822927a 	slli	r17,r17,9
8111207c:	2881ffcc 	andi	r2,r5,2047
81112080:	a228b03a 	or	r20,r20,r8
81112084:	880ad33a 	srli	r5,r17,12
81112088:	b02b883a 	mov	r21,r22
8111208c:	003f0d06 	br	81111cc4 <__reset+0xfb0f1cc4>
81112090:	8080022c 	andhi	r2,r16,8
81112094:	10000926 	beq	r2,zero,811120bc <__muldf3+0x57c>
81112098:	8880022c 	andhi	r2,r17,8
8111209c:	1000071e 	bne	r2,zero,811120bc <__muldf3+0x57c>
811120a0:	00800434 	movhi	r2,16
811120a4:	89400234 	orhi	r5,r17,8
811120a8:	10bfffc4 	addi	r2,r2,-1
811120ac:	b82b883a 	mov	r21,r23
811120b0:	288a703a 	and	r5,r5,r2
811120b4:	4029883a 	mov	r20,r8
811120b8:	003f6806 	br	81111e5c <__reset+0xfb0f1e5c>
811120bc:	00800434 	movhi	r2,16
811120c0:	81400234 	orhi	r5,r16,8
811120c4:	10bfffc4 	addi	r2,r2,-1
811120c8:	288a703a 	and	r5,r5,r2
811120cc:	003f6306 	br	81111e5c <__reset+0xfb0f1e5c>
811120d0:	147ff604 	addi	r17,r2,-40
811120d4:	3462983a 	sll	r17,r6,r17
811120d8:	0011883a 	mov	r8,zero
811120dc:	003f4406 	br	81111df0 <__reset+0xfb0f1df0>
811120e0:	3009883a 	mov	r4,r6
811120e4:	d9800215 	stw	r6,8(sp)
811120e8:	da400115 	stw	r9,4(sp)
811120ec:	da800015 	stw	r10,0(sp)
811120f0:	11125200 	call	81112520 <__clzsi2>
811120f4:	10800804 	addi	r2,r2,32
811120f8:	da800017 	ldw	r10,0(sp)
811120fc:	da400117 	ldw	r9,4(sp)
81112100:	d9800217 	ldw	r6,8(sp)
81112104:	003f3006 	br	81111dc8 <__reset+0xfb0f1dc8>
81112108:	143ff604 	addi	r16,r2,-40
8111210c:	9c20983a 	sll	r16,r19,r16
81112110:	0029883a 	mov	r20,zero
81112114:	003f1606 	br	81111d70 <__reset+0xfb0f1d70>
81112118:	d9800215 	stw	r6,8(sp)
8111211c:	d9c00015 	stw	r7,0(sp)
81112120:	da400115 	stw	r9,4(sp)
81112124:	11125200 	call	81112520 <__clzsi2>
81112128:	10800804 	addi	r2,r2,32
8111212c:	da400117 	ldw	r9,4(sp)
81112130:	d9c00017 	ldw	r7,0(sp)
81112134:	d9800217 	ldw	r6,8(sp)
81112138:	003f0306 	br	81111d48 <__reset+0xfb0f1d48>
8111213c:	00c00044 	movi	r3,1
81112140:	1947c83a 	sub	r3,r3,r5
81112144:	00800e04 	movi	r2,56
81112148:	10feda16 	blt	r2,r3,81111cb4 <__reset+0xfb0f1cb4>
8111214c:	008007c4 	movi	r2,31
81112150:	10c01b16 	blt	r2,r3,811121c0 <__muldf3+0x680>
81112154:	00800804 	movi	r2,32
81112158:	10c5c83a 	sub	r2,r2,r3
8111215c:	888a983a 	sll	r5,r17,r2
81112160:	40c8d83a 	srl	r4,r8,r3
81112164:	4084983a 	sll	r2,r8,r2
81112168:	88e2d83a 	srl	r17,r17,r3
8111216c:	2906b03a 	or	r3,r5,r4
81112170:	1004c03a 	cmpne	r2,r2,zero
81112174:	1886b03a 	or	r3,r3,r2
81112178:	188001cc 	andi	r2,r3,7
8111217c:	10000726 	beq	r2,zero,8111219c <__muldf3+0x65c>
81112180:	188003cc 	andi	r2,r3,15
81112184:	01000104 	movi	r4,4
81112188:	11000426 	beq	r2,r4,8111219c <__muldf3+0x65c>
8111218c:	1805883a 	mov	r2,r3
81112190:	10c00104 	addi	r3,r2,4
81112194:	1885803a 	cmpltu	r2,r3,r2
81112198:	88a3883a 	add	r17,r17,r2
8111219c:	8880202c 	andhi	r2,r17,128
811121a0:	10001c26 	beq	r2,zero,81112214 <__muldf3+0x6d4>
811121a4:	b02b883a 	mov	r21,r22
811121a8:	00800044 	movi	r2,1
811121ac:	000b883a 	mov	r5,zero
811121b0:	0029883a 	mov	r20,zero
811121b4:	003ec306 	br	81111cc4 <__reset+0xfb0f1cc4>
811121b8:	5805883a 	mov	r2,r11
811121bc:	003f9906 	br	81112024 <__reset+0xfb0f2024>
811121c0:	00bff844 	movi	r2,-31
811121c4:	1145c83a 	sub	r2,r2,r5
811121c8:	8888d83a 	srl	r4,r17,r2
811121cc:	00800804 	movi	r2,32
811121d0:	18801a26 	beq	r3,r2,8111223c <__muldf3+0x6fc>
811121d4:	00801004 	movi	r2,64
811121d8:	10c5c83a 	sub	r2,r2,r3
811121dc:	8884983a 	sll	r2,r17,r2
811121e0:	1204b03a 	or	r2,r2,r8
811121e4:	1004c03a 	cmpne	r2,r2,zero
811121e8:	2084b03a 	or	r2,r4,r2
811121ec:	144001cc 	andi	r17,r2,7
811121f0:	88000d1e 	bne	r17,zero,81112228 <__muldf3+0x6e8>
811121f4:	000b883a 	mov	r5,zero
811121f8:	1028d0fa 	srli	r20,r2,3
811121fc:	b02b883a 	mov	r21,r22
81112200:	0005883a 	mov	r2,zero
81112204:	a468b03a 	or	r20,r20,r17
81112208:	003eae06 	br	81111cc4 <__reset+0xfb0f1cc4>
8111220c:	1007883a 	mov	r3,r2
81112210:	0023883a 	mov	r17,zero
81112214:	880a927a 	slli	r5,r17,9
81112218:	1805883a 	mov	r2,r3
8111221c:	8822977a 	slli	r17,r17,29
81112220:	280ad33a 	srli	r5,r5,12
81112224:	003ff406 	br	811121f8 <__reset+0xfb0f21f8>
81112228:	10c003cc 	andi	r3,r2,15
8111222c:	01000104 	movi	r4,4
81112230:	193ff626 	beq	r3,r4,8111220c <__reset+0xfb0f220c>
81112234:	0023883a 	mov	r17,zero
81112238:	003fd506 	br	81112190 <__reset+0xfb0f2190>
8111223c:	0005883a 	mov	r2,zero
81112240:	003fe706 	br	811121e0 <__reset+0xfb0f21e0>
81112244:	00800434 	movhi	r2,16
81112248:	89400234 	orhi	r5,r17,8
8111224c:	10bfffc4 	addi	r2,r2,-1
81112250:	b02b883a 	mov	r21,r22
81112254:	288a703a 	and	r5,r5,r2
81112258:	4029883a 	mov	r20,r8
8111225c:	003eff06 	br	81111e5c <__reset+0xfb0f1e5c>

81112260 <__extendsfdf2>:
81112260:	200ad5fa 	srli	r5,r4,23
81112264:	defffd04 	addi	sp,sp,-12
81112268:	de00012e 	bgeu	sp,et,81112270 <__extendsfdf2+0x10>
8111226c:	003b68fa 	trap	3
81112270:	29403fcc 	andi	r5,r5,255
81112274:	dc400115 	stw	r17,4(sp)
81112278:	29800044 	addi	r6,r5,1
8111227c:	04402034 	movhi	r17,128
81112280:	dc000015 	stw	r16,0(sp)
81112284:	8c7fffc4 	addi	r17,r17,-1
81112288:	dfc00215 	stw	ra,8(sp)
8111228c:	31803fcc 	andi	r6,r6,255
81112290:	00800044 	movi	r2,1
81112294:	8922703a 	and	r17,r17,r4
81112298:	2020d7fa 	srli	r16,r4,31
8111229c:	1180110e 	bge	r2,r6,811122e4 <__extendsfdf2+0x84>
811122a0:	880cd0fa 	srli	r6,r17,3
811122a4:	8822977a 	slli	r17,r17,29
811122a8:	2940e004 	addi	r5,r5,896
811122ac:	2941ffcc 	andi	r5,r5,2047
811122b0:	2804953a 	slli	r2,r5,20
811122b4:	01400434 	movhi	r5,16
811122b8:	800697fa 	slli	r3,r16,31
811122bc:	297fffc4 	addi	r5,r5,-1
811122c0:	314a703a 	and	r5,r6,r5
811122c4:	288ab03a 	or	r5,r5,r2
811122c8:	28c6b03a 	or	r3,r5,r3
811122cc:	8805883a 	mov	r2,r17
811122d0:	dfc00217 	ldw	ra,8(sp)
811122d4:	dc400117 	ldw	r17,4(sp)
811122d8:	dc000017 	ldw	r16,0(sp)
811122dc:	dec00304 	addi	sp,sp,12
811122e0:	f800283a 	ret
811122e4:	2800111e 	bne	r5,zero,8111232c <__extendsfdf2+0xcc>
811122e8:	88001c26 	beq	r17,zero,8111235c <__extendsfdf2+0xfc>
811122ec:	8809883a 	mov	r4,r17
811122f0:	11125200 	call	81112520 <__clzsi2>
811122f4:	00c00284 	movi	r3,10
811122f8:	18801b16 	blt	r3,r2,81112368 <__extendsfdf2+0x108>
811122fc:	018002c4 	movi	r6,11
81112300:	308dc83a 	sub	r6,r6,r2
81112304:	11000544 	addi	r4,r2,21
81112308:	8986d83a 	srl	r3,r17,r6
8111230c:	8922983a 	sll	r17,r17,r4
81112310:	0180e244 	movi	r6,905
81112314:	01400434 	movhi	r5,16
81112318:	3085c83a 	sub	r2,r6,r2
8111231c:	297fffc4 	addi	r5,r5,-1
81112320:	194c703a 	and	r6,r3,r5
81112324:	1141ffcc 	andi	r5,r2,2047
81112328:	003fe006 	br	811122ac <__reset+0xfb0f22ac>
8111232c:	88000826 	beq	r17,zero,81112350 <__extendsfdf2+0xf0>
81112330:	880cd0fa 	srli	r6,r17,3
81112334:	00800434 	movhi	r2,16
81112338:	10bfffc4 	addi	r2,r2,-1
8111233c:	31800234 	orhi	r6,r6,8
81112340:	8822977a 	slli	r17,r17,29
81112344:	308c703a 	and	r6,r6,r2
81112348:	0141ffc4 	movi	r5,2047
8111234c:	003fd706 	br	811122ac <__reset+0xfb0f22ac>
81112350:	0141ffc4 	movi	r5,2047
81112354:	000d883a 	mov	r6,zero
81112358:	003fd406 	br	811122ac <__reset+0xfb0f22ac>
8111235c:	000b883a 	mov	r5,zero
81112360:	000d883a 	mov	r6,zero
81112364:	003fd106 	br	811122ac <__reset+0xfb0f22ac>
81112368:	11bffd44 	addi	r6,r2,-11
8111236c:	8986983a 	sll	r3,r17,r6
81112370:	0023883a 	mov	r17,zero
81112374:	003fe606 	br	81112310 <__reset+0xfb0f2310>

81112378 <__truncdfsf2>:
81112378:	2810d53a 	srli	r8,r5,20
8111237c:	01c00434 	movhi	r7,16
81112380:	39ffffc4 	addi	r7,r7,-1
81112384:	29ce703a 	and	r7,r5,r7
81112388:	4201ffcc 	andi	r8,r8,2047
8111238c:	380e90fa 	slli	r7,r7,3
81112390:	200cd77a 	srli	r6,r4,29
81112394:	42400044 	addi	r9,r8,1
81112398:	4a41ffcc 	andi	r9,r9,2047
8111239c:	00c00044 	movi	r3,1
811123a0:	280ad7fa 	srli	r5,r5,31
811123a4:	31ceb03a 	or	r7,r6,r7
811123a8:	200490fa 	slli	r2,r4,3
811123ac:	1a40230e 	bge	r3,r9,8111243c <__truncdfsf2+0xc4>
811123b0:	40ff2004 	addi	r3,r8,-896
811123b4:	01803f84 	movi	r6,254
811123b8:	30c01516 	blt	r6,r3,81112410 <__truncdfsf2+0x98>
811123bc:	00c0380e 	bge	zero,r3,811124a0 <__truncdfsf2+0x128>
811123c0:	200c91ba 	slli	r6,r4,6
811123c4:	380e90fa 	slli	r7,r7,3
811123c8:	1004d77a 	srli	r2,r2,29
811123cc:	300cc03a 	cmpne	r6,r6,zero
811123d0:	31ccb03a 	or	r6,r6,r7
811123d4:	308cb03a 	or	r6,r6,r2
811123d8:	308001cc 	andi	r2,r6,7
811123dc:	10000426 	beq	r2,zero,811123f0 <__truncdfsf2+0x78>
811123e0:	308003cc 	andi	r2,r6,15
811123e4:	01000104 	movi	r4,4
811123e8:	11000126 	beq	r2,r4,811123f0 <__truncdfsf2+0x78>
811123ec:	31800104 	addi	r6,r6,4
811123f0:	3081002c 	andhi	r2,r6,1024
811123f4:	10001626 	beq	r2,zero,81112450 <__truncdfsf2+0xd8>
811123f8:	18c00044 	addi	r3,r3,1
811123fc:	00803fc4 	movi	r2,255
81112400:	18800326 	beq	r3,r2,81112410 <__truncdfsf2+0x98>
81112404:	300c91ba 	slli	r6,r6,6
81112408:	300cd27a 	srli	r6,r6,9
8111240c:	00000206 	br	81112418 <__truncdfsf2+0xa0>
81112410:	00ffffc4 	movi	r3,-1
81112414:	000d883a 	mov	r6,zero
81112418:	18c03fcc 	andi	r3,r3,255
8111241c:	180895fa 	slli	r4,r3,23
81112420:	00c02034 	movhi	r3,128
81112424:	280a97fa 	slli	r5,r5,31
81112428:	18ffffc4 	addi	r3,r3,-1
8111242c:	30c6703a 	and	r3,r6,r3
81112430:	1906b03a 	or	r3,r3,r4
81112434:	1944b03a 	or	r2,r3,r5
81112438:	f800283a 	ret
8111243c:	40000b1e 	bne	r8,zero,8111246c <__truncdfsf2+0xf4>
81112440:	388cb03a 	or	r6,r7,r2
81112444:	0007883a 	mov	r3,zero
81112448:	30000426 	beq	r6,zero,8111245c <__truncdfsf2+0xe4>
8111244c:	01800144 	movi	r6,5
81112450:	00803fc4 	movi	r2,255
81112454:	300cd0fa 	srli	r6,r6,3
81112458:	18800a26 	beq	r3,r2,81112484 <__truncdfsf2+0x10c>
8111245c:	00802034 	movhi	r2,128
81112460:	10bfffc4 	addi	r2,r2,-1
81112464:	308c703a 	and	r6,r6,r2
81112468:	003feb06 	br	81112418 <__reset+0xfb0f2418>
8111246c:	3888b03a 	or	r4,r7,r2
81112470:	203fe726 	beq	r4,zero,81112410 <__reset+0xfb0f2410>
81112474:	380c90fa 	slli	r6,r7,3
81112478:	00c03fc4 	movi	r3,255
8111247c:	31808034 	orhi	r6,r6,512
81112480:	003fd506 	br	811123d8 <__reset+0xfb0f23d8>
81112484:	303fe226 	beq	r6,zero,81112410 <__reset+0xfb0f2410>
81112488:	00802034 	movhi	r2,128
8111248c:	31801034 	orhi	r6,r6,64
81112490:	10bfffc4 	addi	r2,r2,-1
81112494:	00ffffc4 	movi	r3,-1
81112498:	308c703a 	and	r6,r6,r2
8111249c:	003fde06 	br	81112418 <__reset+0xfb0f2418>
811124a0:	013ffa44 	movi	r4,-23
811124a4:	19000e16 	blt	r3,r4,811124e0 <__truncdfsf2+0x168>
811124a8:	01000784 	movi	r4,30
811124ac:	20c9c83a 	sub	r4,r4,r3
811124b0:	018007c4 	movi	r6,31
811124b4:	39c02034 	orhi	r7,r7,128
811124b8:	31000b16 	blt	r6,r4,811124e8 <__truncdfsf2+0x170>
811124bc:	423f2084 	addi	r8,r8,-894
811124c0:	120c983a 	sll	r6,r2,r8
811124c4:	3a0e983a 	sll	r7,r7,r8
811124c8:	1104d83a 	srl	r2,r2,r4
811124cc:	300cc03a 	cmpne	r6,r6,zero
811124d0:	31ceb03a 	or	r7,r6,r7
811124d4:	388cb03a 	or	r6,r7,r2
811124d8:	0007883a 	mov	r3,zero
811124dc:	003fbe06 	br	811123d8 <__reset+0xfb0f23d8>
811124e0:	0007883a 	mov	r3,zero
811124e4:	003fd906 	br	8111244c <__reset+0xfb0f244c>
811124e8:	01bfff84 	movi	r6,-2
811124ec:	30cdc83a 	sub	r6,r6,r3
811124f0:	00c00804 	movi	r3,32
811124f4:	398cd83a 	srl	r6,r7,r6
811124f8:	20c00726 	beq	r4,r3,81112518 <__truncdfsf2+0x1a0>
811124fc:	423f2884 	addi	r8,r8,-862
81112500:	3a0e983a 	sll	r7,r7,r8
81112504:	3884b03a 	or	r2,r7,r2
81112508:	1004c03a 	cmpne	r2,r2,zero
8111250c:	118cb03a 	or	r6,r2,r6
81112510:	0007883a 	mov	r3,zero
81112514:	003fb006 	br	811123d8 <__reset+0xfb0f23d8>
81112518:	000f883a 	mov	r7,zero
8111251c:	003ff906 	br	81112504 <__reset+0xfb0f2504>

81112520 <__clzsi2>:
81112520:	00bfffd4 	movui	r2,65535
81112524:	11000536 	bltu	r2,r4,8111253c <__clzsi2+0x1c>
81112528:	00803fc4 	movi	r2,255
8111252c:	11000f36 	bltu	r2,r4,8111256c <__clzsi2+0x4c>
81112530:	00800804 	movi	r2,32
81112534:	0007883a 	mov	r3,zero
81112538:	00000506 	br	81112550 <__clzsi2+0x30>
8111253c:	00804034 	movhi	r2,256
81112540:	10bfffc4 	addi	r2,r2,-1
81112544:	11000c2e 	bgeu	r2,r4,81112578 <__clzsi2+0x58>
81112548:	00800204 	movi	r2,8
8111254c:	00c00604 	movi	r3,24
81112550:	20c8d83a 	srl	r4,r4,r3
81112554:	00e04534 	movhi	r3,33044
81112558:	18fcbd04 	addi	r3,r3,-3340
8111255c:	1909883a 	add	r4,r3,r4
81112560:	20c00003 	ldbu	r3,0(r4)
81112564:	10c5c83a 	sub	r2,r2,r3
81112568:	f800283a 	ret
8111256c:	00800604 	movi	r2,24
81112570:	00c00204 	movi	r3,8
81112574:	003ff606 	br	81112550 <__reset+0xfb0f2550>
81112578:	00800404 	movi	r2,16
8111257c:	1007883a 	mov	r3,r2
81112580:	003ff306 	br	81112550 <__reset+0xfb0f2550>

81112584 <atoi>:
81112584:	01800284 	movi	r6,10
81112588:	000b883a 	mov	r5,zero
8111258c:	11143781 	jmpi	81114378 <strtol>

81112590 <_atoi_r>:
81112590:	01c00284 	movi	r7,10
81112594:	000d883a 	mov	r6,zero
81112598:	11141381 	jmpi	81114138 <_strtol_r>

8111259c <_fopen_r>:
8111259c:	defffa04 	addi	sp,sp,-24
811125a0:	3005883a 	mov	r2,r6
811125a4:	de00012e 	bgeu	sp,et,811125ac <_fopen_r+0x10>
811125a8:	003b68fa 	trap	3
811125ac:	d80d883a 	mov	r6,sp
811125b0:	dcc00415 	stw	r19,16(sp)
811125b4:	2827883a 	mov	r19,r5
811125b8:	100b883a 	mov	r5,r2
811125bc:	dc800315 	stw	r18,12(sp)
811125c0:	dfc00515 	stw	ra,20(sp)
811125c4:	dc400215 	stw	r17,8(sp)
811125c8:	dc000115 	stw	r16,4(sp)
811125cc:	2025883a 	mov	r18,r4
811125d0:	111c2200 	call	8111c220 <__sflags>
811125d4:	10002726 	beq	r2,zero,81112674 <_fopen_r+0xd8>
811125d8:	9009883a 	mov	r4,r18
811125dc:	1023883a 	mov	r17,r2
811125e0:	111c0980 	call	8111c098 <__sfp>
811125e4:	1021883a 	mov	r16,r2
811125e8:	10002226 	beq	r2,zero,81112674 <_fopen_r+0xd8>
811125ec:	d9800017 	ldw	r6,0(sp)
811125f0:	01c06d84 	movi	r7,438
811125f4:	980b883a 	mov	r5,r19
811125f8:	9009883a 	mov	r4,r18
811125fc:	11139580 	call	81113958 <_open_r>
81112600:	10001916 	blt	r2,zero,81112668 <_fopen_r+0xcc>
81112604:	8080038d 	sth	r2,14(r16)
81112608:	00a04474 	movhi	r2,33041
8111260c:	108faf04 	addi	r2,r2,16060
81112610:	80800815 	stw	r2,32(r16)
81112614:	00a04474 	movhi	r2,33041
81112618:	108fc804 	addi	r2,r2,16160
8111261c:	80800915 	stw	r2,36(r16)
81112620:	00a04474 	movhi	r2,33041
81112624:	108fe904 	addi	r2,r2,16292
81112628:	80800a15 	stw	r2,40(r16)
8111262c:	00a04474 	movhi	r2,33041
81112630:	10900204 	addi	r2,r2,16392
81112634:	8440030d 	sth	r17,12(r16)
81112638:	84000715 	stw	r16,28(r16)
8111263c:	80800b15 	stw	r2,44(r16)
81112640:	8c40400c 	andi	r17,r17,256
81112644:	88000d1e 	bne	r17,zero,8111267c <_fopen_r+0xe0>
81112648:	8005883a 	mov	r2,r16
8111264c:	dfc00517 	ldw	ra,20(sp)
81112650:	dcc00417 	ldw	r19,16(sp)
81112654:	dc800317 	ldw	r18,12(sp)
81112658:	dc400217 	ldw	r17,8(sp)
8111265c:	dc000117 	ldw	r16,4(sp)
81112660:	dec00604 	addi	sp,sp,24
81112664:	f800283a 	ret
81112668:	111c1e00 	call	8111c1e0 <__sfp_lock_acquire>
8111266c:	8000030d 	sth	zero,12(r16)
81112670:	111c1e40 	call	8111c1e4 <__sfp_lock_release>
81112674:	0005883a 	mov	r2,zero
81112678:	003ff406 	br	8111264c <__reset+0xfb0f264c>
8111267c:	01c00084 	movi	r7,2
81112680:	000d883a 	mov	r6,zero
81112684:	800b883a 	mov	r5,r16
81112688:	9009883a 	mov	r4,r18
8111268c:	111270c0 	call	8111270c <_fseek_r>
81112690:	8005883a 	mov	r2,r16
81112694:	003fed06 	br	8111264c <__reset+0xfb0f264c>

81112698 <fopen>:
81112698:	00a04534 	movhi	r2,33044
8111269c:	1086aa04 	addi	r2,r2,6824
811126a0:	280d883a 	mov	r6,r5
811126a4:	200b883a 	mov	r5,r4
811126a8:	11000017 	ldw	r4,0(r2)
811126ac:	111259c1 	jmpi	8111259c <_fopen_r>

811126b0 <_fprintf_r>:
811126b0:	defffe04 	addi	sp,sp,-8
811126b4:	2809883a 	mov	r4,r5
811126b8:	300b883a 	mov	r5,r6
811126bc:	de00012e 	bgeu	sp,et,811126c4 <_fprintf_r+0x14>
811126c0:	003b68fa 	trap	3
811126c4:	dfc00015 	stw	ra,0(sp)
811126c8:	d9c00115 	stw	r7,4(sp)
811126cc:	d9800104 	addi	r6,sp,4
811126d0:	11187740 	call	81118774 <__vfprintf_internal>
811126d4:	dfc00017 	ldw	ra,0(sp)
811126d8:	dec00204 	addi	sp,sp,8
811126dc:	f800283a 	ret

811126e0 <fprintf>:
811126e0:	defffd04 	addi	sp,sp,-12
811126e4:	de00012e 	bgeu	sp,et,811126ec <fprintf+0xc>
811126e8:	003b68fa 	trap	3
811126ec:	dfc00015 	stw	ra,0(sp)
811126f0:	d9800115 	stw	r6,4(sp)
811126f4:	d9c00215 	stw	r7,8(sp)
811126f8:	d9800104 	addi	r6,sp,4
811126fc:	11187740 	call	81118774 <__vfprintf_internal>
81112700:	dfc00017 	ldw	ra,0(sp)
81112704:	dec00304 	addi	sp,sp,12
81112708:	f800283a 	ret

8111270c <_fseek_r>:
8111270c:	111272c1 	jmpi	8111272c <_fseeko_r>

81112710 <fseek>:
81112710:	00a04534 	movhi	r2,33044
81112714:	1086aa04 	addi	r2,r2,6824
81112718:	300f883a 	mov	r7,r6
8111271c:	280d883a 	mov	r6,r5
81112720:	200b883a 	mov	r5,r4
81112724:	11000017 	ldw	r4,0(r2)
81112728:	111272c1 	jmpi	8111272c <_fseeko_r>

8111272c <_fseeko_r>:
8111272c:	deffe804 	addi	sp,sp,-96
81112730:	de00012e 	bgeu	sp,et,81112738 <_fseeko_r+0xc>
81112734:	003b68fa 	trap	3
81112738:	dd401415 	stw	r21,80(sp)
8111273c:	dc801115 	stw	r18,68(sp)
81112740:	dc401015 	stw	r17,64(sp)
81112744:	dc000f15 	stw	r16,60(sp)
81112748:	dfc01715 	stw	ra,92(sp)
8111274c:	ddc01615 	stw	r23,88(sp)
81112750:	dd801515 	stw	r22,84(sp)
81112754:	dd001315 	stw	r20,76(sp)
81112758:	dcc01215 	stw	r19,72(sp)
8111275c:	2023883a 	mov	r17,r4
81112760:	2821883a 	mov	r16,r5
81112764:	302b883a 	mov	r21,r6
81112768:	3825883a 	mov	r18,r7
8111276c:	20000226 	beq	r4,zero,81112778 <_fseeko_r+0x4c>
81112770:	20800e17 	ldw	r2,56(r4)
81112774:	10005a26 	beq	r2,zero,811128e0 <_fseeko_r+0x1b4>
81112778:	8080030b 	ldhu	r2,12(r16)
8111277c:	00c04204 	movi	r3,264
81112780:	1080420c 	andi	r2,r2,264
81112784:	10c05b26 	beq	r2,r3,811128f4 <_fseeko_r+0x1c8>
81112788:	85000a17 	ldw	r20,40(r16)
8111278c:	a000f626 	beq	r20,zero,81112b68 <_fseeko_r+0x43c>
81112790:	00800044 	movi	r2,1
81112794:	90803e26 	beq	r18,r2,81112890 <_fseeko_r+0x164>
81112798:	00800084 	movi	r2,2
8111279c:	90801026 	beq	r18,r2,811127e0 <_fseeko_r+0xb4>
811127a0:	90000f26 	beq	r18,zero,811127e0 <_fseeko_r+0xb4>
811127a4:	00800584 	movi	r2,22
811127a8:	88800015 	stw	r2,0(r17)
811127ac:	04ffffc4 	movi	r19,-1
811127b0:	9805883a 	mov	r2,r19
811127b4:	dfc01717 	ldw	ra,92(sp)
811127b8:	ddc01617 	ldw	r23,88(sp)
811127bc:	dd801517 	ldw	r22,84(sp)
811127c0:	dd401417 	ldw	r21,80(sp)
811127c4:	dd001317 	ldw	r20,76(sp)
811127c8:	dcc01217 	ldw	r19,72(sp)
811127cc:	dc801117 	ldw	r18,68(sp)
811127d0:	dc401017 	ldw	r17,64(sp)
811127d4:	dc000f17 	ldw	r16,60(sp)
811127d8:	dec01804 	addi	sp,sp,96
811127dc:	f800283a 	ret
811127e0:	80800417 	ldw	r2,16(r16)
811127e4:	002f883a 	mov	r23,zero
811127e8:	0027883a 	mov	r19,zero
811127ec:	1000cb26 	beq	r2,zero,81112b1c <_fseeko_r+0x3f0>
811127f0:	8080030b 	ldhu	r2,12(r16)
811127f4:	10c2068c 	andi	r3,r2,2074
811127f8:	1800071e 	bne	r3,zero,81112818 <_fseeko_r+0xec>
811127fc:	10c1000c 	andi	r3,r2,1024
81112800:	1800451e 	bne	r3,zero,81112918 <_fseeko_r+0x1ec>
81112804:	00e04474 	movhi	r3,33041
81112808:	18cfe904 	addi	r3,r3,16292
8111280c:	a0c0b726 	beq	r20,r3,81112aec <_fseeko_r+0x3c0>
81112810:	10820014 	ori	r2,r2,2048
81112814:	8080030d 	sth	r2,12(r16)
81112818:	800b883a 	mov	r5,r16
8111281c:	8809883a 	mov	r4,r17
81112820:	111bdd40 	call	8111bdd4 <_fflush_r>
81112824:	1027883a 	mov	r19,r2
81112828:	103fe01e 	bne	r2,zero,811127ac <__reset+0xfb0f27ac>
8111282c:	81400717 	ldw	r5,28(r16)
81112830:	900f883a 	mov	r7,r18
81112834:	a80d883a 	mov	r6,r21
81112838:	8809883a 	mov	r4,r17
8111283c:	a03ee83a 	callr	r20
81112840:	00ffffc4 	movi	r3,-1
81112844:	10ffd926 	beq	r2,r3,811127ac <__reset+0xfb0f27ac>
81112848:	81400c17 	ldw	r5,48(r16)
8111284c:	28000526 	beq	r5,zero,81112864 <_fseeko_r+0x138>
81112850:	80801004 	addi	r2,r16,64
81112854:	28800226 	beq	r5,r2,81112860 <_fseeko_r+0x134>
81112858:	8809883a 	mov	r4,r17
8111285c:	111c6680 	call	8111c668 <_free_r>
81112860:	80000c15 	stw	zero,48(r16)
81112864:	8080030b 	ldhu	r2,12(r16)
81112868:	80c00417 	ldw	r3,16(r16)
8111286c:	80000115 	stw	zero,4(r16)
81112870:	10bdf7cc 	andi	r2,r2,63455
81112874:	80c00015 	stw	r3,0(r16)
81112878:	8080030d 	sth	r2,12(r16)
8111287c:	01800204 	movi	r6,8
81112880:	000b883a 	mov	r5,zero
81112884:	81001704 	addi	r4,r16,92
81112888:	11138300 	call	81113830 <memset>
8111288c:	003fc806 	br	811127b0 <__reset+0xfb0f27b0>
81112890:	800b883a 	mov	r5,r16
81112894:	8809883a 	mov	r4,r17
81112898:	111bdd40 	call	8111bdd4 <_fflush_r>
8111289c:	8080030b 	ldhu	r2,12(r16)
811128a0:	10c4000c 	andi	r3,r2,4096
811128a4:	18008726 	beq	r3,zero,81112ac4 <_fseeko_r+0x398>
811128a8:	84c01417 	ldw	r19,80(r16)
811128ac:	10c0010c 	andi	r3,r2,4
811128b0:	1800431e 	bne	r3,zero,811129c0 <_fseeko_r+0x294>
811128b4:	1080020c 	andi	r2,r2,8
811128b8:	10008026 	beq	r2,zero,81112abc <_fseeko_r+0x390>
811128bc:	80c00017 	ldw	r3,0(r16)
811128c0:	80800417 	ldw	r2,16(r16)
811128c4:	18000226 	beq	r3,zero,811128d0 <_fseeko_r+0x1a4>
811128c8:	1887c83a 	sub	r3,r3,r2
811128cc:	98e7883a 	add	r19,r19,r3
811128d0:	aceb883a 	add	r21,r21,r19
811128d4:	05c00044 	movi	r23,1
811128d8:	0025883a 	mov	r18,zero
811128dc:	003fc306 	br	811127ec <__reset+0xfb0f27ec>
811128e0:	111c1d00 	call	8111c1d0 <__sinit>
811128e4:	8080030b 	ldhu	r2,12(r16)
811128e8:	00c04204 	movi	r3,264
811128ec:	1080420c 	andi	r2,r2,264
811128f0:	10ffa51e 	bne	r2,r3,81112788 <__reset+0xfb0f2788>
811128f4:	800b883a 	mov	r5,r16
811128f8:	8809883a 	mov	r4,r17
811128fc:	111bdd40 	call	8111bdd4 <_fflush_r>
81112900:	003fa106 	br	81112788 <__reset+0xfb0f2788>
81112904:	8080030b 	ldhu	r2,12(r16)
81112908:	00c10004 	movi	r3,1024
8111290c:	80c01315 	stw	r3,76(r16)
81112910:	10c4b03a 	or	r2,r2,r3
81112914:	8080030d 	sth	r2,12(r16)
81112918:	9000311e 	bne	r18,zero,811129e0 <_fseeko_r+0x2b4>
8111291c:	a82d883a 	mov	r22,r21
81112920:	b800371e 	bne	r23,zero,81112a00 <_fseeko_r+0x2d4>
81112924:	8080030b 	ldhu	r2,12(r16)
81112928:	1084000c 	andi	r2,r2,4096
8111292c:	10007f26 	beq	r2,zero,81112b2c <_fseeko_r+0x400>
81112930:	80801417 	ldw	r2,80(r16)
81112934:	81800117 	ldw	r6,4(r16)
81112938:	81400c17 	ldw	r5,48(r16)
8111293c:	11a7c83a 	sub	r19,r2,r6
81112940:	28008226 	beq	r5,zero,81112b4c <_fseeko_r+0x420>
81112944:	81c00f17 	ldw	r7,60(r16)
81112948:	99e7c83a 	sub	r19,r19,r7
8111294c:	81000e17 	ldw	r4,56(r16)
81112950:	80800417 	ldw	r2,16(r16)
81112954:	99a7883a 	add	r19,r19,r6
81112958:	2087c83a 	sub	r3,r4,r2
8111295c:	98e7c83a 	sub	r19,r19,r3
81112960:	38c7883a 	add	r3,r7,r3
81112964:	b4c02b16 	blt	r22,r19,81112a14 <_fseeko_r+0x2e8>
81112968:	98c9883a 	add	r4,r19,r3
8111296c:	b100292e 	bgeu	r22,r4,81112a14 <_fseeko_r+0x2e8>
81112970:	b4e7c83a 	sub	r19,r22,r19
81112974:	14c5883a 	add	r2,r2,r19
81112978:	1ce7c83a 	sub	r19,r3,r19
8111297c:	80800015 	stw	r2,0(r16)
81112980:	84c00115 	stw	r19,4(r16)
81112984:	28000526 	beq	r5,zero,8111299c <_fseeko_r+0x270>
81112988:	80801004 	addi	r2,r16,64
8111298c:	28800226 	beq	r5,r2,81112998 <_fseeko_r+0x26c>
81112990:	8809883a 	mov	r4,r17
81112994:	111c6680 	call	8111c668 <_free_r>
81112998:	80000c15 	stw	zero,48(r16)
8111299c:	8080030b 	ldhu	r2,12(r16)
811129a0:	01800204 	movi	r6,8
811129a4:	000b883a 	mov	r5,zero
811129a8:	10bff7cc 	andi	r2,r2,65503
811129ac:	8080030d 	sth	r2,12(r16)
811129b0:	81001704 	addi	r4,r16,92
811129b4:	11138300 	call	81113830 <memset>
811129b8:	0027883a 	mov	r19,zero
811129bc:	003f7c06 	br	811127b0 <__reset+0xfb0f27b0>
811129c0:	80c00117 	ldw	r3,4(r16)
811129c4:	80800c17 	ldw	r2,48(r16)
811129c8:	98e7c83a 	sub	r19,r19,r3
811129cc:	10003b26 	beq	r2,zero,81112abc <_fseeko_r+0x390>
811129d0:	80c00f17 	ldw	r3,60(r16)
811129d4:	80800417 	ldw	r2,16(r16)
811129d8:	98e7c83a 	sub	r19,r19,r3
811129dc:	003fbc06 	br	811128d0 <__reset+0xfb0f28d0>
811129e0:	8140038f 	ldh	r5,14(r16)
811129e4:	d80d883a 	mov	r6,sp
811129e8:	8809883a 	mov	r4,r17
811129ec:	1112b940 	call	81112b94 <_fstat_r>
811129f0:	103f891e 	bne	r2,zero,81112818 <__reset+0xfb0f2818>
811129f4:	dd800417 	ldw	r22,16(sp)
811129f8:	adad883a 	add	r22,r21,r22
811129fc:	b83fc926 	beq	r23,zero,81112924 <__reset+0xfb0f2924>
81112a00:	81400c17 	ldw	r5,48(r16)
81112a04:	81800117 	ldw	r6,4(r16)
81112a08:	28005026 	beq	r5,zero,81112b4c <_fseeko_r+0x420>
81112a0c:	81c00f17 	ldw	r7,60(r16)
81112a10:	003fce06 	br	8111294c <__reset+0xfb0f294c>
81112a14:	84c01317 	ldw	r19,76(r16)
81112a18:	81400717 	ldw	r5,28(r16)
81112a1c:	000f883a 	mov	r7,zero
81112a20:	04e7c83a 	sub	r19,zero,r19
81112a24:	9da6703a 	and	r19,r19,r22
81112a28:	980d883a 	mov	r6,r19
81112a2c:	8809883a 	mov	r4,r17
81112a30:	a03ee83a 	callr	r20
81112a34:	00ffffc4 	movi	r3,-1
81112a38:	10ff7726 	beq	r2,r3,81112818 <__reset+0xfb0f2818>
81112a3c:	80800417 	ldw	r2,16(r16)
81112a40:	81400c17 	ldw	r5,48(r16)
81112a44:	80000115 	stw	zero,4(r16)
81112a48:	80800015 	stw	r2,0(r16)
81112a4c:	28000526 	beq	r5,zero,81112a64 <_fseeko_r+0x338>
81112a50:	80801004 	addi	r2,r16,64
81112a54:	28800226 	beq	r5,r2,81112a60 <_fseeko_r+0x334>
81112a58:	8809883a 	mov	r4,r17
81112a5c:	111c6680 	call	8111c668 <_free_r>
81112a60:	80000c15 	stw	zero,48(r16)
81112a64:	8080030b 	ldhu	r2,12(r16)
81112a68:	b4e7c83a 	sub	r19,r22,r19
81112a6c:	10bff7cc 	andi	r2,r2,65503
81112a70:	8080030d 	sth	r2,12(r16)
81112a74:	98000b26 	beq	r19,zero,81112aa4 <_fseeko_r+0x378>
81112a78:	800b883a 	mov	r5,r16
81112a7c:	8809883a 	mov	r4,r17
81112a80:	1113b340 	call	81113b34 <__srefill_r>
81112a84:	103f641e 	bne	r2,zero,81112818 <__reset+0xfb0f2818>
81112a88:	80800117 	ldw	r2,4(r16)
81112a8c:	14ff6236 	bltu	r2,r19,81112818 <__reset+0xfb0f2818>
81112a90:	80c00017 	ldw	r3,0(r16)
81112a94:	14c5c83a 	sub	r2,r2,r19
81112a98:	80800115 	stw	r2,4(r16)
81112a9c:	1ce7883a 	add	r19,r3,r19
81112aa0:	84c00015 	stw	r19,0(r16)
81112aa4:	01800204 	movi	r6,8
81112aa8:	000b883a 	mov	r5,zero
81112aac:	81001704 	addi	r4,r16,92
81112ab0:	11138300 	call	81113830 <memset>
81112ab4:	0027883a 	mov	r19,zero
81112ab8:	003f3d06 	br	811127b0 <__reset+0xfb0f27b0>
81112abc:	80800417 	ldw	r2,16(r16)
81112ac0:	003f8306 	br	811128d0 <__reset+0xfb0f28d0>
81112ac4:	81400717 	ldw	r5,28(r16)
81112ac8:	900f883a 	mov	r7,r18
81112acc:	000d883a 	mov	r6,zero
81112ad0:	8809883a 	mov	r4,r17
81112ad4:	a03ee83a 	callr	r20
81112ad8:	1027883a 	mov	r19,r2
81112adc:	00bfffc4 	movi	r2,-1
81112ae0:	98bf3226 	beq	r19,r2,811127ac <__reset+0xfb0f27ac>
81112ae4:	8080030b 	ldhu	r2,12(r16)
81112ae8:	003f7006 	br	811128ac <__reset+0xfb0f28ac>
81112aec:	8140038f 	ldh	r5,14(r16)
81112af0:	283f4716 	blt	r5,zero,81112810 <__reset+0xfb0f2810>
81112af4:	d80d883a 	mov	r6,sp
81112af8:	8809883a 	mov	r4,r17
81112afc:	1112b940 	call	81112b94 <_fstat_r>
81112b00:	1000041e 	bne	r2,zero,81112b14 <_fseeko_r+0x3e8>
81112b04:	d8800117 	ldw	r2,4(sp)
81112b08:	00e00014 	movui	r3,32768
81112b0c:	10bc000c 	andi	r2,r2,61440
81112b10:	10ff7c26 	beq	r2,r3,81112904 <__reset+0xfb0f2904>
81112b14:	8080030b 	ldhu	r2,12(r16)
81112b18:	003f3d06 	br	81112810 <__reset+0xfb0f2810>
81112b1c:	800b883a 	mov	r5,r16
81112b20:	8809883a 	mov	r4,r17
81112b24:	1112d080 	call	81112d08 <__smakebuf_r>
81112b28:	003f3106 	br	811127f0 <__reset+0xfb0f27f0>
81112b2c:	81400717 	ldw	r5,28(r16)
81112b30:	01c00044 	movi	r7,1
81112b34:	000d883a 	mov	r6,zero
81112b38:	8809883a 	mov	r4,r17
81112b3c:	a03ee83a 	callr	r20
81112b40:	00ffffc4 	movi	r3,-1
81112b44:	10ff7b1e 	bne	r2,r3,81112934 <__reset+0xfb0f2934>
81112b48:	003f3306 	br	81112818 <__reset+0xfb0f2818>
81112b4c:	80c00017 	ldw	r3,0(r16)
81112b50:	80800417 	ldw	r2,16(r16)
81112b54:	000b883a 	mov	r5,zero
81112b58:	1887c83a 	sub	r3,r3,r2
81112b5c:	98e7c83a 	sub	r19,r19,r3
81112b60:	30c7883a 	add	r3,r6,r3
81112b64:	003f7f06 	br	81112964 <__reset+0xfb0f2964>
81112b68:	00800744 	movi	r2,29
81112b6c:	88800015 	stw	r2,0(r17)
81112b70:	04ffffc4 	movi	r19,-1
81112b74:	003f0e06 	br	811127b0 <__reset+0xfb0f27b0>

81112b78 <fseeko>:
81112b78:	00a04534 	movhi	r2,33044
81112b7c:	1086aa04 	addi	r2,r2,6824
81112b80:	300f883a 	mov	r7,r6
81112b84:	280d883a 	mov	r6,r5
81112b88:	200b883a 	mov	r5,r4
81112b8c:	11000017 	ldw	r4,0(r2)
81112b90:	111272c1 	jmpi	8111272c <_fseeko_r>

81112b94 <_fstat_r>:
81112b94:	defffd04 	addi	sp,sp,-12
81112b98:	de00012e 	bgeu	sp,et,81112ba0 <_fstat_r+0xc>
81112b9c:	003b68fa 	trap	3
81112ba0:	2805883a 	mov	r2,r5
81112ba4:	dc000015 	stw	r16,0(sp)
81112ba8:	04204534 	movhi	r16,33044
81112bac:	dc400115 	stw	r17,4(sp)
81112bb0:	84070504 	addi	r16,r16,7188
81112bb4:	2023883a 	mov	r17,r4
81112bb8:	300b883a 	mov	r5,r6
81112bbc:	1009883a 	mov	r4,r2
81112bc0:	dfc00215 	stw	ra,8(sp)
81112bc4:	80000015 	stw	zero,0(r16)
81112bc8:	11280080 	call	81128008 <fstat>
81112bcc:	00ffffc4 	movi	r3,-1
81112bd0:	10c00526 	beq	r2,r3,81112be8 <_fstat_r+0x54>
81112bd4:	dfc00217 	ldw	ra,8(sp)
81112bd8:	dc400117 	ldw	r17,4(sp)
81112bdc:	dc000017 	ldw	r16,0(sp)
81112be0:	dec00304 	addi	sp,sp,12
81112be4:	f800283a 	ret
81112be8:	80c00017 	ldw	r3,0(r16)
81112bec:	183ff926 	beq	r3,zero,81112bd4 <__reset+0xfb0f2bd4>
81112bf0:	88c00015 	stw	r3,0(r17)
81112bf4:	003ff706 	br	81112bd4 <__reset+0xfb0f2bd4>

81112bf8 <_fwrite_r>:
81112bf8:	defff504 	addi	sp,sp,-44
81112bfc:	de00012e 	bgeu	sp,et,81112c04 <_fwrite_r+0xc>
81112c00:	003b68fa 	trap	3
81112c04:	dc800815 	stw	r18,32(sp)
81112c08:	39a5383a 	mul	r18,r7,r6
81112c0c:	d8800304 	addi	r2,sp,12
81112c10:	d8800015 	stw	r2,0(sp)
81112c14:	00800044 	movi	r2,1
81112c18:	dcc00915 	stw	r19,36(sp)
81112c1c:	dc400715 	stw	r17,28(sp)
81112c20:	dc000615 	stw	r16,24(sp)
81112c24:	d9400315 	stw	r5,12(sp)
81112c28:	dfc00a15 	stw	ra,40(sp)
81112c2c:	dc800415 	stw	r18,16(sp)
81112c30:	dc800215 	stw	r18,8(sp)
81112c34:	d8800115 	stw	r2,4(sp)
81112c38:	3027883a 	mov	r19,r6
81112c3c:	3821883a 	mov	r16,r7
81112c40:	2023883a 	mov	r17,r4
81112c44:	d9400b17 	ldw	r5,44(sp)
81112c48:	20000226 	beq	r4,zero,81112c54 <_fwrite_r+0x5c>
81112c4c:	20800e17 	ldw	r2,56(r4)
81112c50:	10001a26 	beq	r2,zero,81112cbc <_fwrite_r+0xc4>
81112c54:	2880030b 	ldhu	r2,12(r5)
81112c58:	10c8000c 	andi	r3,r2,8192
81112c5c:	1800061e 	bne	r3,zero,81112c78 <_fwrite_r+0x80>
81112c60:	29001917 	ldw	r4,100(r5)
81112c64:	00f7ffc4 	movi	r3,-8193
81112c68:	10880014 	ori	r2,r2,8192
81112c6c:	20c6703a 	and	r3,r4,r3
81112c70:	2880030d 	sth	r2,12(r5)
81112c74:	28c01915 	stw	r3,100(r5)
81112c78:	d80d883a 	mov	r6,sp
81112c7c:	8809883a 	mov	r4,r17
81112c80:	111c9800 	call	8111c980 <__sfvwrite_r>
81112c84:	10000b26 	beq	r2,zero,81112cb4 <_fwrite_r+0xbc>
81112c88:	d9000217 	ldw	r4,8(sp)
81112c8c:	980b883a 	mov	r5,r19
81112c90:	9109c83a 	sub	r4,r18,r4
81112c94:	1125b500 	call	81125b50 <__udivsi3>
81112c98:	dfc00a17 	ldw	ra,40(sp)
81112c9c:	dcc00917 	ldw	r19,36(sp)
81112ca0:	dc800817 	ldw	r18,32(sp)
81112ca4:	dc400717 	ldw	r17,28(sp)
81112ca8:	dc000617 	ldw	r16,24(sp)
81112cac:	dec00b04 	addi	sp,sp,44
81112cb0:	f800283a 	ret
81112cb4:	8005883a 	mov	r2,r16
81112cb8:	003ff706 	br	81112c98 <__reset+0xfb0f2c98>
81112cbc:	d9400515 	stw	r5,20(sp)
81112cc0:	111c1d00 	call	8111c1d0 <__sinit>
81112cc4:	d9400517 	ldw	r5,20(sp)
81112cc8:	003fe206 	br	81112c54 <__reset+0xfb0f2c54>

81112ccc <fwrite>:
81112ccc:	defffe04 	addi	sp,sp,-8
81112cd0:	00a04534 	movhi	r2,33044
81112cd4:	de00012e 	bgeu	sp,et,81112cdc <fwrite+0x10>
81112cd8:	003b68fa 	trap	3
81112cdc:	1086aa04 	addi	r2,r2,6824
81112ce0:	d9c00015 	stw	r7,0(sp)
81112ce4:	300f883a 	mov	r7,r6
81112ce8:	280d883a 	mov	r6,r5
81112cec:	200b883a 	mov	r5,r4
81112cf0:	11000017 	ldw	r4,0(r2)
81112cf4:	dfc00115 	stw	ra,4(sp)
81112cf8:	1112bf80 	call	81112bf8 <_fwrite_r>
81112cfc:	dfc00117 	ldw	ra,4(sp)
81112d00:	dec00204 	addi	sp,sp,8
81112d04:	f800283a 	ret

81112d08 <__smakebuf_r>:
81112d08:	2880030b 	ldhu	r2,12(r5)
81112d0c:	10c0008c 	andi	r3,r2,2
81112d10:	1800431e 	bne	r3,zero,81112e20 <__smakebuf_r+0x118>
81112d14:	deffec04 	addi	sp,sp,-80
81112d18:	de00012e 	bgeu	sp,et,81112d20 <__smakebuf_r+0x18>
81112d1c:	003b68fa 	trap	3
81112d20:	dc000f15 	stw	r16,60(sp)
81112d24:	2821883a 	mov	r16,r5
81112d28:	2940038f 	ldh	r5,14(r5)
81112d2c:	dc401015 	stw	r17,64(sp)
81112d30:	dfc01315 	stw	ra,76(sp)
81112d34:	dcc01215 	stw	r19,72(sp)
81112d38:	dc801115 	stw	r18,68(sp)
81112d3c:	2023883a 	mov	r17,r4
81112d40:	28001c16 	blt	r5,zero,81112db4 <__smakebuf_r+0xac>
81112d44:	d80d883a 	mov	r6,sp
81112d48:	1112b940 	call	81112b94 <_fstat_r>
81112d4c:	10001816 	blt	r2,zero,81112db0 <__smakebuf_r+0xa8>
81112d50:	d8800117 	ldw	r2,4(sp)
81112d54:	00e00014 	movui	r3,32768
81112d58:	10bc000c 	andi	r2,r2,61440
81112d5c:	14c80020 	cmpeqi	r19,r2,8192
81112d60:	10c03726 	beq	r2,r3,81112e40 <__smakebuf_r+0x138>
81112d64:	80c0030b 	ldhu	r3,12(r16)
81112d68:	18c20014 	ori	r3,r3,2048
81112d6c:	80c0030d 	sth	r3,12(r16)
81112d70:	00c80004 	movi	r3,8192
81112d74:	10c0521e 	bne	r2,r3,81112ec0 <__smakebuf_r+0x1b8>
81112d78:	8140038f 	ldh	r5,14(r16)
81112d7c:	8809883a 	mov	r4,r17
81112d80:	111cfdc0 	call	8111cfdc <_isatty_r>
81112d84:	10004c26 	beq	r2,zero,81112eb8 <__smakebuf_r+0x1b0>
81112d88:	8080030b 	ldhu	r2,12(r16)
81112d8c:	80c010c4 	addi	r3,r16,67
81112d90:	80c00015 	stw	r3,0(r16)
81112d94:	10800054 	ori	r2,r2,1
81112d98:	8080030d 	sth	r2,12(r16)
81112d9c:	00800044 	movi	r2,1
81112da0:	80c00415 	stw	r3,16(r16)
81112da4:	80800515 	stw	r2,20(r16)
81112da8:	04810004 	movi	r18,1024
81112dac:	00000706 	br	81112dcc <__smakebuf_r+0xc4>
81112db0:	8080030b 	ldhu	r2,12(r16)
81112db4:	10c0200c 	andi	r3,r2,128
81112db8:	18001f1e 	bne	r3,zero,81112e38 <__smakebuf_r+0x130>
81112dbc:	04810004 	movi	r18,1024
81112dc0:	10820014 	ori	r2,r2,2048
81112dc4:	8080030d 	sth	r2,12(r16)
81112dc8:	0027883a 	mov	r19,zero
81112dcc:	900b883a 	mov	r5,r18
81112dd0:	8809883a 	mov	r4,r17
81112dd4:	1112ecc0 	call	81112ecc <_malloc_r>
81112dd8:	10002c26 	beq	r2,zero,81112e8c <__smakebuf_r+0x184>
81112ddc:	80c0030b 	ldhu	r3,12(r16)
81112de0:	012044b4 	movhi	r4,33042
81112de4:	212f9c04 	addi	r4,r4,-16784
81112de8:	89000f15 	stw	r4,60(r17)
81112dec:	18c02014 	ori	r3,r3,128
81112df0:	80c0030d 	sth	r3,12(r16)
81112df4:	80800015 	stw	r2,0(r16)
81112df8:	80800415 	stw	r2,16(r16)
81112dfc:	84800515 	stw	r18,20(r16)
81112e00:	98001a1e 	bne	r19,zero,81112e6c <__smakebuf_r+0x164>
81112e04:	dfc01317 	ldw	ra,76(sp)
81112e08:	dcc01217 	ldw	r19,72(sp)
81112e0c:	dc801117 	ldw	r18,68(sp)
81112e10:	dc401017 	ldw	r17,64(sp)
81112e14:	dc000f17 	ldw	r16,60(sp)
81112e18:	dec01404 	addi	sp,sp,80
81112e1c:	f800283a 	ret
81112e20:	288010c4 	addi	r2,r5,67
81112e24:	28800015 	stw	r2,0(r5)
81112e28:	28800415 	stw	r2,16(r5)
81112e2c:	00800044 	movi	r2,1
81112e30:	28800515 	stw	r2,20(r5)
81112e34:	f800283a 	ret
81112e38:	04801004 	movi	r18,64
81112e3c:	003fe006 	br	81112dc0 <__reset+0xfb0f2dc0>
81112e40:	81000a17 	ldw	r4,40(r16)
81112e44:	00e04474 	movhi	r3,33041
81112e48:	18cfe904 	addi	r3,r3,16292
81112e4c:	20ffc51e 	bne	r4,r3,81112d64 <__reset+0xfb0f2d64>
81112e50:	8080030b 	ldhu	r2,12(r16)
81112e54:	04810004 	movi	r18,1024
81112e58:	84801315 	stw	r18,76(r16)
81112e5c:	1484b03a 	or	r2,r2,r18
81112e60:	8080030d 	sth	r2,12(r16)
81112e64:	0027883a 	mov	r19,zero
81112e68:	003fd806 	br	81112dcc <__reset+0xfb0f2dcc>
81112e6c:	8140038f 	ldh	r5,14(r16)
81112e70:	8809883a 	mov	r4,r17
81112e74:	111cfdc0 	call	8111cfdc <_isatty_r>
81112e78:	103fe226 	beq	r2,zero,81112e04 <__reset+0xfb0f2e04>
81112e7c:	8080030b 	ldhu	r2,12(r16)
81112e80:	10800054 	ori	r2,r2,1
81112e84:	8080030d 	sth	r2,12(r16)
81112e88:	003fde06 	br	81112e04 <__reset+0xfb0f2e04>
81112e8c:	8080030b 	ldhu	r2,12(r16)
81112e90:	10c0800c 	andi	r3,r2,512
81112e94:	183fdb1e 	bne	r3,zero,81112e04 <__reset+0xfb0f2e04>
81112e98:	10800094 	ori	r2,r2,2
81112e9c:	80c010c4 	addi	r3,r16,67
81112ea0:	8080030d 	sth	r2,12(r16)
81112ea4:	00800044 	movi	r2,1
81112ea8:	80c00015 	stw	r3,0(r16)
81112eac:	80c00415 	stw	r3,16(r16)
81112eb0:	80800515 	stw	r2,20(r16)
81112eb4:	003fd306 	br	81112e04 <__reset+0xfb0f2e04>
81112eb8:	04810004 	movi	r18,1024
81112ebc:	003fc306 	br	81112dcc <__reset+0xfb0f2dcc>
81112ec0:	0027883a 	mov	r19,zero
81112ec4:	04810004 	movi	r18,1024
81112ec8:	003fc006 	br	81112dcc <__reset+0xfb0f2dcc>

81112ecc <_malloc_r>:
81112ecc:	defff504 	addi	sp,sp,-44
81112ed0:	de00012e 	bgeu	sp,et,81112ed8 <_malloc_r+0xc>
81112ed4:	003b68fa 	trap	3
81112ed8:	288002c4 	addi	r2,r5,11
81112edc:	dc800315 	stw	r18,12(sp)
81112ee0:	dfc00a15 	stw	ra,40(sp)
81112ee4:	df000915 	stw	fp,36(sp)
81112ee8:	ddc00815 	stw	r23,32(sp)
81112eec:	dd800715 	stw	r22,28(sp)
81112ef0:	dd400615 	stw	r21,24(sp)
81112ef4:	dd000515 	stw	r20,20(sp)
81112ef8:	dcc00415 	stw	r19,16(sp)
81112efc:	dc400215 	stw	r17,8(sp)
81112f00:	dc000115 	stw	r16,4(sp)
81112f04:	00c00584 	movi	r3,22
81112f08:	2025883a 	mov	r18,r4
81112f0c:	18807f2e 	bgeu	r3,r2,8111310c <_malloc_r+0x240>
81112f10:	047ffe04 	movi	r17,-8
81112f14:	1462703a 	and	r17,r2,r17
81112f18:	8800a316 	blt	r17,zero,811131a8 <_malloc_r+0x2dc>
81112f1c:	8940a236 	bltu	r17,r5,811131a8 <_malloc_r+0x2dc>
81112f20:	1128fa00 	call	81128fa0 <__malloc_lock>
81112f24:	00807dc4 	movi	r2,503
81112f28:	1441e92e 	bgeu	r2,r17,811136d0 <_malloc_r+0x804>
81112f2c:	8804d27a 	srli	r2,r17,9
81112f30:	1000a126 	beq	r2,zero,811131b8 <_malloc_r+0x2ec>
81112f34:	00c00104 	movi	r3,4
81112f38:	18811e36 	bltu	r3,r2,811133b4 <_malloc_r+0x4e8>
81112f3c:	8804d1ba 	srli	r2,r17,6
81112f40:	12000e44 	addi	r8,r2,57
81112f44:	11c00e04 	addi	r7,r2,56
81112f48:	4209883a 	add	r4,r8,r8
81112f4c:	04e04534 	movhi	r19,33044
81112f50:	2109883a 	add	r4,r4,r4
81112f54:	9cc08f04 	addi	r19,r19,572
81112f58:	2109883a 	add	r4,r4,r4
81112f5c:	9909883a 	add	r4,r19,r4
81112f60:	24000117 	ldw	r16,4(r4)
81112f64:	213ffe04 	addi	r4,r4,-8
81112f68:	24009726 	beq	r4,r16,811131c8 <_malloc_r+0x2fc>
81112f6c:	80800117 	ldw	r2,4(r16)
81112f70:	01bfff04 	movi	r6,-4
81112f74:	014003c4 	movi	r5,15
81112f78:	1184703a 	and	r2,r2,r6
81112f7c:	1447c83a 	sub	r3,r2,r17
81112f80:	28c00716 	blt	r5,r3,81112fa0 <_malloc_r+0xd4>
81112f84:	1800920e 	bge	r3,zero,811131d0 <_malloc_r+0x304>
81112f88:	84000317 	ldw	r16,12(r16)
81112f8c:	24008e26 	beq	r4,r16,811131c8 <_malloc_r+0x2fc>
81112f90:	80800117 	ldw	r2,4(r16)
81112f94:	1184703a 	and	r2,r2,r6
81112f98:	1447c83a 	sub	r3,r2,r17
81112f9c:	28fff90e 	bge	r5,r3,81112f84 <__reset+0xfb0f2f84>
81112fa0:	3809883a 	mov	r4,r7
81112fa4:	01a04534 	movhi	r6,33044
81112fa8:	9c000417 	ldw	r16,16(r19)
81112fac:	31808f04 	addi	r6,r6,572
81112fb0:	32000204 	addi	r8,r6,8
81112fb4:	82013426 	beq	r16,r8,81113488 <_malloc_r+0x5bc>
81112fb8:	80c00117 	ldw	r3,4(r16)
81112fbc:	00bfff04 	movi	r2,-4
81112fc0:	188e703a 	and	r7,r3,r2
81112fc4:	3c45c83a 	sub	r2,r7,r17
81112fc8:	00c003c4 	movi	r3,15
81112fcc:	18811f16 	blt	r3,r2,8111344c <_malloc_r+0x580>
81112fd0:	32000515 	stw	r8,20(r6)
81112fd4:	32000415 	stw	r8,16(r6)
81112fd8:	10007f0e 	bge	r2,zero,811131d8 <_malloc_r+0x30c>
81112fdc:	00807fc4 	movi	r2,511
81112fe0:	11c0fd36 	bltu	r2,r7,811133d8 <_malloc_r+0x50c>
81112fe4:	3806d0fa 	srli	r3,r7,3
81112fe8:	01c00044 	movi	r7,1
81112fec:	30800117 	ldw	r2,4(r6)
81112ff0:	19400044 	addi	r5,r3,1
81112ff4:	294b883a 	add	r5,r5,r5
81112ff8:	1807d0ba 	srai	r3,r3,2
81112ffc:	294b883a 	add	r5,r5,r5
81113000:	294b883a 	add	r5,r5,r5
81113004:	298b883a 	add	r5,r5,r6
81113008:	38c6983a 	sll	r3,r7,r3
8111300c:	29c00017 	ldw	r7,0(r5)
81113010:	2a7ffe04 	addi	r9,r5,-8
81113014:	1886b03a 	or	r3,r3,r2
81113018:	82400315 	stw	r9,12(r16)
8111301c:	81c00215 	stw	r7,8(r16)
81113020:	30c00115 	stw	r3,4(r6)
81113024:	2c000015 	stw	r16,0(r5)
81113028:	3c000315 	stw	r16,12(r7)
8111302c:	2005d0ba 	srai	r2,r4,2
81113030:	01400044 	movi	r5,1
81113034:	288a983a 	sll	r5,r5,r2
81113038:	19406f36 	bltu	r3,r5,811131f8 <_malloc_r+0x32c>
8111303c:	28c4703a 	and	r2,r5,r3
81113040:	10000a1e 	bne	r2,zero,8111306c <_malloc_r+0x1a0>
81113044:	00bfff04 	movi	r2,-4
81113048:	294b883a 	add	r5,r5,r5
8111304c:	2088703a 	and	r4,r4,r2
81113050:	28c4703a 	and	r2,r5,r3
81113054:	21000104 	addi	r4,r4,4
81113058:	1000041e 	bne	r2,zero,8111306c <_malloc_r+0x1a0>
8111305c:	294b883a 	add	r5,r5,r5
81113060:	28c4703a 	and	r2,r5,r3
81113064:	21000104 	addi	r4,r4,4
81113068:	103ffc26 	beq	r2,zero,8111305c <__reset+0xfb0f305c>
8111306c:	02bfff04 	movi	r10,-4
81113070:	024003c4 	movi	r9,15
81113074:	21800044 	addi	r6,r4,1
81113078:	318d883a 	add	r6,r6,r6
8111307c:	318d883a 	add	r6,r6,r6
81113080:	318d883a 	add	r6,r6,r6
81113084:	998d883a 	add	r6,r19,r6
81113088:	333ffe04 	addi	r12,r6,-8
8111308c:	2017883a 	mov	r11,r4
81113090:	31800104 	addi	r6,r6,4
81113094:	34000017 	ldw	r16,0(r6)
81113098:	31fffd04 	addi	r7,r6,-12
8111309c:	81c0041e 	bne	r16,r7,811130b0 <_malloc_r+0x1e4>
811130a0:	0000fb06 	br	81113490 <_malloc_r+0x5c4>
811130a4:	1801030e 	bge	r3,zero,811134b4 <_malloc_r+0x5e8>
811130a8:	84000317 	ldw	r16,12(r16)
811130ac:	81c0f826 	beq	r16,r7,81113490 <_malloc_r+0x5c4>
811130b0:	80800117 	ldw	r2,4(r16)
811130b4:	1284703a 	and	r2,r2,r10
811130b8:	1447c83a 	sub	r3,r2,r17
811130bc:	48fff90e 	bge	r9,r3,811130a4 <__reset+0xfb0f30a4>
811130c0:	80800317 	ldw	r2,12(r16)
811130c4:	81000217 	ldw	r4,8(r16)
811130c8:	89400054 	ori	r5,r17,1
811130cc:	81400115 	stw	r5,4(r16)
811130d0:	20800315 	stw	r2,12(r4)
811130d4:	11000215 	stw	r4,8(r2)
811130d8:	8463883a 	add	r17,r16,r17
811130dc:	9c400515 	stw	r17,20(r19)
811130e0:	9c400415 	stw	r17,16(r19)
811130e4:	18800054 	ori	r2,r3,1
811130e8:	88800115 	stw	r2,4(r17)
811130ec:	8a000315 	stw	r8,12(r17)
811130f0:	8a000215 	stw	r8,8(r17)
811130f4:	88e3883a 	add	r17,r17,r3
811130f8:	88c00015 	stw	r3,0(r17)
811130fc:	9009883a 	mov	r4,r18
81113100:	11290c80 	call	811290c8 <__malloc_unlock>
81113104:	80800204 	addi	r2,r16,8
81113108:	00001b06 	br	81113178 <_malloc_r+0x2ac>
8111310c:	04400404 	movi	r17,16
81113110:	89402536 	bltu	r17,r5,811131a8 <_malloc_r+0x2dc>
81113114:	1128fa00 	call	81128fa0 <__malloc_lock>
81113118:	00800184 	movi	r2,6
8111311c:	01000084 	movi	r4,2
81113120:	04e04534 	movhi	r19,33044
81113124:	1085883a 	add	r2,r2,r2
81113128:	9cc08f04 	addi	r19,r19,572
8111312c:	1085883a 	add	r2,r2,r2
81113130:	9885883a 	add	r2,r19,r2
81113134:	14000117 	ldw	r16,4(r2)
81113138:	10fffe04 	addi	r3,r2,-8
8111313c:	80c0d926 	beq	r16,r3,811134a4 <_malloc_r+0x5d8>
81113140:	80c00117 	ldw	r3,4(r16)
81113144:	81000317 	ldw	r4,12(r16)
81113148:	00bfff04 	movi	r2,-4
8111314c:	1884703a 	and	r2,r3,r2
81113150:	81400217 	ldw	r5,8(r16)
81113154:	8085883a 	add	r2,r16,r2
81113158:	10c00117 	ldw	r3,4(r2)
8111315c:	29000315 	stw	r4,12(r5)
81113160:	21400215 	stw	r5,8(r4)
81113164:	18c00054 	ori	r3,r3,1
81113168:	10c00115 	stw	r3,4(r2)
8111316c:	9009883a 	mov	r4,r18
81113170:	11290c80 	call	811290c8 <__malloc_unlock>
81113174:	80800204 	addi	r2,r16,8
81113178:	dfc00a17 	ldw	ra,40(sp)
8111317c:	df000917 	ldw	fp,36(sp)
81113180:	ddc00817 	ldw	r23,32(sp)
81113184:	dd800717 	ldw	r22,28(sp)
81113188:	dd400617 	ldw	r21,24(sp)
8111318c:	dd000517 	ldw	r20,20(sp)
81113190:	dcc00417 	ldw	r19,16(sp)
81113194:	dc800317 	ldw	r18,12(sp)
81113198:	dc400217 	ldw	r17,8(sp)
8111319c:	dc000117 	ldw	r16,4(sp)
811131a0:	dec00b04 	addi	sp,sp,44
811131a4:	f800283a 	ret
811131a8:	00800304 	movi	r2,12
811131ac:	90800015 	stw	r2,0(r18)
811131b0:	0005883a 	mov	r2,zero
811131b4:	003ff006 	br	81113178 <__reset+0xfb0f3178>
811131b8:	01002004 	movi	r4,128
811131bc:	02001004 	movi	r8,64
811131c0:	01c00fc4 	movi	r7,63
811131c4:	003f6106 	br	81112f4c <__reset+0xfb0f2f4c>
811131c8:	4009883a 	mov	r4,r8
811131cc:	003f7506 	br	81112fa4 <__reset+0xfb0f2fa4>
811131d0:	81000317 	ldw	r4,12(r16)
811131d4:	003fde06 	br	81113150 <__reset+0xfb0f3150>
811131d8:	81c5883a 	add	r2,r16,r7
811131dc:	11400117 	ldw	r5,4(r2)
811131e0:	9009883a 	mov	r4,r18
811131e4:	29400054 	ori	r5,r5,1
811131e8:	11400115 	stw	r5,4(r2)
811131ec:	11290c80 	call	811290c8 <__malloc_unlock>
811131f0:	80800204 	addi	r2,r16,8
811131f4:	003fe006 	br	81113178 <__reset+0xfb0f3178>
811131f8:	9c000217 	ldw	r16,8(r19)
811131fc:	00bfff04 	movi	r2,-4
81113200:	85800117 	ldw	r22,4(r16)
81113204:	b0ac703a 	and	r22,r22,r2
81113208:	b4400336 	bltu	r22,r17,81113218 <_malloc_r+0x34c>
8111320c:	b445c83a 	sub	r2,r22,r17
81113210:	00c003c4 	movi	r3,15
81113214:	18805d16 	blt	r3,r2,8111338c <_malloc_r+0x4c0>
81113218:	05e04534 	movhi	r23,33044
8111321c:	00a04534 	movhi	r2,33044
81113220:	10870804 	addi	r2,r2,7200
81113224:	bdc6ab04 	addi	r23,r23,6828
81113228:	15400017 	ldw	r21,0(r2)
8111322c:	b8c00017 	ldw	r3,0(r23)
81113230:	00bfffc4 	movi	r2,-1
81113234:	858d883a 	add	r6,r16,r22
81113238:	8d6b883a 	add	r21,r17,r21
8111323c:	1880ea26 	beq	r3,r2,811135e8 <_malloc_r+0x71c>
81113240:	ad4403c4 	addi	r21,r21,4111
81113244:	00bc0004 	movi	r2,-4096
81113248:	a8aa703a 	and	r21,r21,r2
8111324c:	a80b883a 	mov	r5,r21
81113250:	9009883a 	mov	r4,r18
81113254:	d9800015 	stw	r6,0(sp)
81113258:	1113d100 	call	81113d10 <_sbrk_r>
8111325c:	1029883a 	mov	r20,r2
81113260:	00bfffc4 	movi	r2,-1
81113264:	d9800017 	ldw	r6,0(sp)
81113268:	a080e826 	beq	r20,r2,8111360c <_malloc_r+0x740>
8111326c:	a180a636 	bltu	r20,r6,81113508 <_malloc_r+0x63c>
81113270:	07204534 	movhi	fp,33044
81113274:	e7076704 	addi	fp,fp,7580
81113278:	e0800017 	ldw	r2,0(fp)
8111327c:	a887883a 	add	r3,r21,r2
81113280:	e0c00015 	stw	r3,0(fp)
81113284:	3500e626 	beq	r6,r20,81113620 <_malloc_r+0x754>
81113288:	b9000017 	ldw	r4,0(r23)
8111328c:	00bfffc4 	movi	r2,-1
81113290:	2080ee26 	beq	r4,r2,8111364c <_malloc_r+0x780>
81113294:	a185c83a 	sub	r2,r20,r6
81113298:	10c5883a 	add	r2,r2,r3
8111329c:	e0800015 	stw	r2,0(fp)
811132a0:	a0c001cc 	andi	r3,r20,7
811132a4:	1800bc26 	beq	r3,zero,81113598 <_malloc_r+0x6cc>
811132a8:	a0e9c83a 	sub	r20,r20,r3
811132ac:	00840204 	movi	r2,4104
811132b0:	a5000204 	addi	r20,r20,8
811132b4:	10c7c83a 	sub	r3,r2,r3
811132b8:	a545883a 	add	r2,r20,r21
811132bc:	1083ffcc 	andi	r2,r2,4095
811132c0:	18abc83a 	sub	r21,r3,r2
811132c4:	a80b883a 	mov	r5,r21
811132c8:	9009883a 	mov	r4,r18
811132cc:	1113d100 	call	81113d10 <_sbrk_r>
811132d0:	00ffffc4 	movi	r3,-1
811132d4:	10c0e126 	beq	r2,r3,8111365c <_malloc_r+0x790>
811132d8:	1505c83a 	sub	r2,r2,r20
811132dc:	1545883a 	add	r2,r2,r21
811132e0:	10800054 	ori	r2,r2,1
811132e4:	e0c00017 	ldw	r3,0(fp)
811132e8:	9d000215 	stw	r20,8(r19)
811132ec:	a0800115 	stw	r2,4(r20)
811132f0:	a8c7883a 	add	r3,r21,r3
811132f4:	e0c00015 	stw	r3,0(fp)
811132f8:	84c00e26 	beq	r16,r19,81113334 <_malloc_r+0x468>
811132fc:	018003c4 	movi	r6,15
81113300:	3580a72e 	bgeu	r6,r22,811135a0 <_malloc_r+0x6d4>
81113304:	81400117 	ldw	r5,4(r16)
81113308:	013ffe04 	movi	r4,-8
8111330c:	b0bffd04 	addi	r2,r22,-12
81113310:	1104703a 	and	r2,r2,r4
81113314:	2900004c 	andi	r4,r5,1
81113318:	2088b03a 	or	r4,r4,r2
8111331c:	81000115 	stw	r4,4(r16)
81113320:	01400144 	movi	r5,5
81113324:	8089883a 	add	r4,r16,r2
81113328:	21400115 	stw	r5,4(r4)
8111332c:	21400215 	stw	r5,8(r4)
81113330:	3080cd36 	bltu	r6,r2,81113668 <_malloc_r+0x79c>
81113334:	00a04534 	movhi	r2,33044
81113338:	10870704 	addi	r2,r2,7196
8111333c:	11000017 	ldw	r4,0(r2)
81113340:	20c0012e 	bgeu	r4,r3,81113348 <_malloc_r+0x47c>
81113344:	10c00015 	stw	r3,0(r2)
81113348:	00a04534 	movhi	r2,33044
8111334c:	10870604 	addi	r2,r2,7192
81113350:	11000017 	ldw	r4,0(r2)
81113354:	9c000217 	ldw	r16,8(r19)
81113358:	20c0012e 	bgeu	r4,r3,81113360 <_malloc_r+0x494>
8111335c:	10c00015 	stw	r3,0(r2)
81113360:	80c00117 	ldw	r3,4(r16)
81113364:	00bfff04 	movi	r2,-4
81113368:	1886703a 	and	r3,r3,r2
8111336c:	1c45c83a 	sub	r2,r3,r17
81113370:	1c400236 	bltu	r3,r17,8111337c <_malloc_r+0x4b0>
81113374:	00c003c4 	movi	r3,15
81113378:	18800416 	blt	r3,r2,8111338c <_malloc_r+0x4c0>
8111337c:	9009883a 	mov	r4,r18
81113380:	11290c80 	call	811290c8 <__malloc_unlock>
81113384:	0005883a 	mov	r2,zero
81113388:	003f7b06 	br	81113178 <__reset+0xfb0f3178>
8111338c:	88c00054 	ori	r3,r17,1
81113390:	80c00115 	stw	r3,4(r16)
81113394:	8463883a 	add	r17,r16,r17
81113398:	10800054 	ori	r2,r2,1
8111339c:	9c400215 	stw	r17,8(r19)
811133a0:	88800115 	stw	r2,4(r17)
811133a4:	9009883a 	mov	r4,r18
811133a8:	11290c80 	call	811290c8 <__malloc_unlock>
811133ac:	80800204 	addi	r2,r16,8
811133b0:	003f7106 	br	81113178 <__reset+0xfb0f3178>
811133b4:	00c00504 	movi	r3,20
811133b8:	18804a2e 	bgeu	r3,r2,811134e4 <_malloc_r+0x618>
811133bc:	00c01504 	movi	r3,84
811133c0:	18806e36 	bltu	r3,r2,8111357c <_malloc_r+0x6b0>
811133c4:	8804d33a 	srli	r2,r17,12
811133c8:	12001bc4 	addi	r8,r2,111
811133cc:	11c01b84 	addi	r7,r2,110
811133d0:	4209883a 	add	r4,r8,r8
811133d4:	003edd06 	br	81112f4c <__reset+0xfb0f2f4c>
811133d8:	3804d27a 	srli	r2,r7,9
811133dc:	00c00104 	movi	r3,4
811133e0:	1880442e 	bgeu	r3,r2,811134f4 <_malloc_r+0x628>
811133e4:	00c00504 	movi	r3,20
811133e8:	18808136 	bltu	r3,r2,811135f0 <_malloc_r+0x724>
811133ec:	11401704 	addi	r5,r2,92
811133f0:	10c016c4 	addi	r3,r2,91
811133f4:	294b883a 	add	r5,r5,r5
811133f8:	294b883a 	add	r5,r5,r5
811133fc:	294b883a 	add	r5,r5,r5
81113400:	994b883a 	add	r5,r19,r5
81113404:	28800017 	ldw	r2,0(r5)
81113408:	01a04534 	movhi	r6,33044
8111340c:	297ffe04 	addi	r5,r5,-8
81113410:	31808f04 	addi	r6,r6,572
81113414:	28806526 	beq	r5,r2,811135ac <_malloc_r+0x6e0>
81113418:	01bfff04 	movi	r6,-4
8111341c:	10c00117 	ldw	r3,4(r2)
81113420:	1986703a 	and	r3,r3,r6
81113424:	38c0022e 	bgeu	r7,r3,81113430 <_malloc_r+0x564>
81113428:	10800217 	ldw	r2,8(r2)
8111342c:	28bffb1e 	bne	r5,r2,8111341c <__reset+0xfb0f341c>
81113430:	11400317 	ldw	r5,12(r2)
81113434:	98c00117 	ldw	r3,4(r19)
81113438:	81400315 	stw	r5,12(r16)
8111343c:	80800215 	stw	r2,8(r16)
81113440:	2c000215 	stw	r16,8(r5)
81113444:	14000315 	stw	r16,12(r2)
81113448:	003ef806 	br	8111302c <__reset+0xfb0f302c>
8111344c:	88c00054 	ori	r3,r17,1
81113450:	80c00115 	stw	r3,4(r16)
81113454:	8463883a 	add	r17,r16,r17
81113458:	34400515 	stw	r17,20(r6)
8111345c:	34400415 	stw	r17,16(r6)
81113460:	10c00054 	ori	r3,r2,1
81113464:	8a000315 	stw	r8,12(r17)
81113468:	8a000215 	stw	r8,8(r17)
8111346c:	88c00115 	stw	r3,4(r17)
81113470:	88a3883a 	add	r17,r17,r2
81113474:	88800015 	stw	r2,0(r17)
81113478:	9009883a 	mov	r4,r18
8111347c:	11290c80 	call	811290c8 <__malloc_unlock>
81113480:	80800204 	addi	r2,r16,8
81113484:	003f3c06 	br	81113178 <__reset+0xfb0f3178>
81113488:	30c00117 	ldw	r3,4(r6)
8111348c:	003ee706 	br	8111302c <__reset+0xfb0f302c>
81113490:	5ac00044 	addi	r11,r11,1
81113494:	588000cc 	andi	r2,r11,3
81113498:	31800204 	addi	r6,r6,8
8111349c:	103efd1e 	bne	r2,zero,81113094 <__reset+0xfb0f3094>
811134a0:	00002406 	br	81113534 <_malloc_r+0x668>
811134a4:	14000317 	ldw	r16,12(r2)
811134a8:	143f251e 	bne	r2,r16,81113140 <__reset+0xfb0f3140>
811134ac:	21000084 	addi	r4,r4,2
811134b0:	003ebc06 	br	81112fa4 <__reset+0xfb0f2fa4>
811134b4:	8085883a 	add	r2,r16,r2
811134b8:	10c00117 	ldw	r3,4(r2)
811134bc:	81000317 	ldw	r4,12(r16)
811134c0:	81400217 	ldw	r5,8(r16)
811134c4:	18c00054 	ori	r3,r3,1
811134c8:	10c00115 	stw	r3,4(r2)
811134cc:	29000315 	stw	r4,12(r5)
811134d0:	21400215 	stw	r5,8(r4)
811134d4:	9009883a 	mov	r4,r18
811134d8:	11290c80 	call	811290c8 <__malloc_unlock>
811134dc:	80800204 	addi	r2,r16,8
811134e0:	003f2506 	br	81113178 <__reset+0xfb0f3178>
811134e4:	12001704 	addi	r8,r2,92
811134e8:	11c016c4 	addi	r7,r2,91
811134ec:	4209883a 	add	r4,r8,r8
811134f0:	003e9606 	br	81112f4c <__reset+0xfb0f2f4c>
811134f4:	3804d1ba 	srli	r2,r7,6
811134f8:	11400e44 	addi	r5,r2,57
811134fc:	10c00e04 	addi	r3,r2,56
81113500:	294b883a 	add	r5,r5,r5
81113504:	003fbc06 	br	811133f8 <__reset+0xfb0f33f8>
81113508:	84ff5926 	beq	r16,r19,81113270 <__reset+0xfb0f3270>
8111350c:	00a04534 	movhi	r2,33044
81113510:	10808f04 	addi	r2,r2,572
81113514:	14000217 	ldw	r16,8(r2)
81113518:	00bfff04 	movi	r2,-4
8111351c:	80c00117 	ldw	r3,4(r16)
81113520:	1886703a 	and	r3,r3,r2
81113524:	003f9106 	br	8111336c <__reset+0xfb0f336c>
81113528:	60800217 	ldw	r2,8(r12)
8111352c:	213fffc4 	addi	r4,r4,-1
81113530:	1300651e 	bne	r2,r12,811136c8 <_malloc_r+0x7fc>
81113534:	208000cc 	andi	r2,r4,3
81113538:	633ffe04 	addi	r12,r12,-8
8111353c:	103ffa1e 	bne	r2,zero,81113528 <__reset+0xfb0f3528>
81113540:	98800117 	ldw	r2,4(r19)
81113544:	0146303a 	nor	r3,zero,r5
81113548:	1884703a 	and	r2,r3,r2
8111354c:	98800115 	stw	r2,4(r19)
81113550:	294b883a 	add	r5,r5,r5
81113554:	117f2836 	bltu	r2,r5,811131f8 <__reset+0xfb0f31f8>
81113558:	283f2726 	beq	r5,zero,811131f8 <__reset+0xfb0f31f8>
8111355c:	2886703a 	and	r3,r5,r2
81113560:	5809883a 	mov	r4,r11
81113564:	183ec31e 	bne	r3,zero,81113074 <__reset+0xfb0f3074>
81113568:	294b883a 	add	r5,r5,r5
8111356c:	2886703a 	and	r3,r5,r2
81113570:	21000104 	addi	r4,r4,4
81113574:	183ffc26 	beq	r3,zero,81113568 <__reset+0xfb0f3568>
81113578:	003ebe06 	br	81113074 <__reset+0xfb0f3074>
8111357c:	00c05504 	movi	r3,340
81113580:	18801236 	bltu	r3,r2,811135cc <_malloc_r+0x700>
81113584:	8804d3fa 	srli	r2,r17,15
81113588:	12001e04 	addi	r8,r2,120
8111358c:	11c01dc4 	addi	r7,r2,119
81113590:	4209883a 	add	r4,r8,r8
81113594:	003e6d06 	br	81112f4c <__reset+0xfb0f2f4c>
81113598:	00c40004 	movi	r3,4096
8111359c:	003f4606 	br	811132b8 <__reset+0xfb0f32b8>
811135a0:	00800044 	movi	r2,1
811135a4:	a0800115 	stw	r2,4(r20)
811135a8:	003f7406 	br	8111337c <__reset+0xfb0f337c>
811135ac:	1805d0ba 	srai	r2,r3,2
811135b0:	01c00044 	movi	r7,1
811135b4:	30c00117 	ldw	r3,4(r6)
811135b8:	388e983a 	sll	r7,r7,r2
811135bc:	2805883a 	mov	r2,r5
811135c0:	38c6b03a 	or	r3,r7,r3
811135c4:	30c00115 	stw	r3,4(r6)
811135c8:	003f9b06 	br	81113438 <__reset+0xfb0f3438>
811135cc:	00c15504 	movi	r3,1364
811135d0:	18801a36 	bltu	r3,r2,8111363c <_malloc_r+0x770>
811135d4:	8804d4ba 	srli	r2,r17,18
811135d8:	12001f44 	addi	r8,r2,125
811135dc:	11c01f04 	addi	r7,r2,124
811135e0:	4209883a 	add	r4,r8,r8
811135e4:	003e5906 	br	81112f4c <__reset+0xfb0f2f4c>
811135e8:	ad400404 	addi	r21,r21,16
811135ec:	003f1706 	br	8111324c <__reset+0xfb0f324c>
811135f0:	00c01504 	movi	r3,84
811135f4:	18802336 	bltu	r3,r2,81113684 <_malloc_r+0x7b8>
811135f8:	3804d33a 	srli	r2,r7,12
811135fc:	11401bc4 	addi	r5,r2,111
81113600:	10c01b84 	addi	r3,r2,110
81113604:	294b883a 	add	r5,r5,r5
81113608:	003f7b06 	br	811133f8 <__reset+0xfb0f33f8>
8111360c:	9c000217 	ldw	r16,8(r19)
81113610:	00bfff04 	movi	r2,-4
81113614:	80c00117 	ldw	r3,4(r16)
81113618:	1886703a 	and	r3,r3,r2
8111361c:	003f5306 	br	8111336c <__reset+0xfb0f336c>
81113620:	3083ffcc 	andi	r2,r6,4095
81113624:	103f181e 	bne	r2,zero,81113288 <__reset+0xfb0f3288>
81113628:	99000217 	ldw	r4,8(r19)
8111362c:	b545883a 	add	r2,r22,r21
81113630:	10800054 	ori	r2,r2,1
81113634:	20800115 	stw	r2,4(r4)
81113638:	003f3e06 	br	81113334 <__reset+0xfb0f3334>
8111363c:	01003f84 	movi	r4,254
81113640:	02001fc4 	movi	r8,127
81113644:	01c01f84 	movi	r7,126
81113648:	003e4006 	br	81112f4c <__reset+0xfb0f2f4c>
8111364c:	00a04534 	movhi	r2,33044
81113650:	1086ab04 	addi	r2,r2,6828
81113654:	15000015 	stw	r20,0(r2)
81113658:	003f1106 	br	811132a0 <__reset+0xfb0f32a0>
8111365c:	00800044 	movi	r2,1
81113660:	002b883a 	mov	r21,zero
81113664:	003f1f06 	br	811132e4 <__reset+0xfb0f32e4>
81113668:	81400204 	addi	r5,r16,8
8111366c:	9009883a 	mov	r4,r18
81113670:	111c6680 	call	8111c668 <_free_r>
81113674:	00a04534 	movhi	r2,33044
81113678:	10876704 	addi	r2,r2,7580
8111367c:	10c00017 	ldw	r3,0(r2)
81113680:	003f2c06 	br	81113334 <__reset+0xfb0f3334>
81113684:	00c05504 	movi	r3,340
81113688:	18800536 	bltu	r3,r2,811136a0 <_malloc_r+0x7d4>
8111368c:	3804d3fa 	srli	r2,r7,15
81113690:	11401e04 	addi	r5,r2,120
81113694:	10c01dc4 	addi	r3,r2,119
81113698:	294b883a 	add	r5,r5,r5
8111369c:	003f5606 	br	811133f8 <__reset+0xfb0f33f8>
811136a0:	00c15504 	movi	r3,1364
811136a4:	18800536 	bltu	r3,r2,811136bc <_malloc_r+0x7f0>
811136a8:	3804d4ba 	srli	r2,r7,18
811136ac:	11401f44 	addi	r5,r2,125
811136b0:	10c01f04 	addi	r3,r2,124
811136b4:	294b883a 	add	r5,r5,r5
811136b8:	003f4f06 	br	811133f8 <__reset+0xfb0f33f8>
811136bc:	01403f84 	movi	r5,254
811136c0:	00c01f84 	movi	r3,126
811136c4:	003f4c06 	br	811133f8 <__reset+0xfb0f33f8>
811136c8:	98800117 	ldw	r2,4(r19)
811136cc:	003fa006 	br	81113550 <__reset+0xfb0f3550>
811136d0:	8808d0fa 	srli	r4,r17,3
811136d4:	20800044 	addi	r2,r4,1
811136d8:	1085883a 	add	r2,r2,r2
811136dc:	003e9006 	br	81113120 <__reset+0xfb0f3120>

811136e0 <memcpy>:
811136e0:	defffd04 	addi	sp,sp,-12
811136e4:	de00012e 	bgeu	sp,et,811136ec <memcpy+0xc>
811136e8:	003b68fa 	trap	3
811136ec:	00c003c4 	movi	r3,15
811136f0:	dfc00215 	stw	ra,8(sp)
811136f4:	dc400115 	stw	r17,4(sp)
811136f8:	dc000015 	stw	r16,0(sp)
811136fc:	2005883a 	mov	r2,r4
81113700:	1980452e 	bgeu	r3,r6,81113818 <memcpy+0x138>
81113704:	2906b03a 	or	r3,r5,r4
81113708:	18c000cc 	andi	r3,r3,3
8111370c:	1800441e 	bne	r3,zero,81113820 <memcpy+0x140>
81113710:	347ffc04 	addi	r17,r6,-16
81113714:	8822d13a 	srli	r17,r17,4
81113718:	28c00104 	addi	r3,r5,4
8111371c:	23400104 	addi	r13,r4,4
81113720:	8820913a 	slli	r16,r17,4
81113724:	2b000204 	addi	r12,r5,8
81113728:	22c00204 	addi	r11,r4,8
8111372c:	84000504 	addi	r16,r16,20
81113730:	2a800304 	addi	r10,r5,12
81113734:	22400304 	addi	r9,r4,12
81113738:	2c21883a 	add	r16,r5,r16
8111373c:	2811883a 	mov	r8,r5
81113740:	200f883a 	mov	r7,r4
81113744:	41000017 	ldw	r4,0(r8)
81113748:	1fc00017 	ldw	ra,0(r3)
8111374c:	63c00017 	ldw	r15,0(r12)
81113750:	39000015 	stw	r4,0(r7)
81113754:	53800017 	ldw	r14,0(r10)
81113758:	6fc00015 	stw	ra,0(r13)
8111375c:	5bc00015 	stw	r15,0(r11)
81113760:	4b800015 	stw	r14,0(r9)
81113764:	18c00404 	addi	r3,r3,16
81113768:	39c00404 	addi	r7,r7,16
8111376c:	42000404 	addi	r8,r8,16
81113770:	6b400404 	addi	r13,r13,16
81113774:	63000404 	addi	r12,r12,16
81113778:	5ac00404 	addi	r11,r11,16
8111377c:	52800404 	addi	r10,r10,16
81113780:	4a400404 	addi	r9,r9,16
81113784:	1c3fef1e 	bne	r3,r16,81113744 <__reset+0xfb0f3744>
81113788:	89c00044 	addi	r7,r17,1
8111378c:	380e913a 	slli	r7,r7,4
81113790:	310003cc 	andi	r4,r6,15
81113794:	02c000c4 	movi	r11,3
81113798:	11c7883a 	add	r3,r2,r7
8111379c:	29cb883a 	add	r5,r5,r7
811137a0:	5900212e 	bgeu	r11,r4,81113828 <memcpy+0x148>
811137a4:	1813883a 	mov	r9,r3
811137a8:	2811883a 	mov	r8,r5
811137ac:	200f883a 	mov	r7,r4
811137b0:	42800017 	ldw	r10,0(r8)
811137b4:	4a400104 	addi	r9,r9,4
811137b8:	39ffff04 	addi	r7,r7,-4
811137bc:	4abfff15 	stw	r10,-4(r9)
811137c0:	42000104 	addi	r8,r8,4
811137c4:	59fffa36 	bltu	r11,r7,811137b0 <__reset+0xfb0f37b0>
811137c8:	213fff04 	addi	r4,r4,-4
811137cc:	2008d0ba 	srli	r4,r4,2
811137d0:	318000cc 	andi	r6,r6,3
811137d4:	21000044 	addi	r4,r4,1
811137d8:	2109883a 	add	r4,r4,r4
811137dc:	2109883a 	add	r4,r4,r4
811137e0:	1907883a 	add	r3,r3,r4
811137e4:	290b883a 	add	r5,r5,r4
811137e8:	30000626 	beq	r6,zero,81113804 <memcpy+0x124>
811137ec:	198d883a 	add	r6,r3,r6
811137f0:	29c00003 	ldbu	r7,0(r5)
811137f4:	18c00044 	addi	r3,r3,1
811137f8:	29400044 	addi	r5,r5,1
811137fc:	19ffffc5 	stb	r7,-1(r3)
81113800:	19bffb1e 	bne	r3,r6,811137f0 <__reset+0xfb0f37f0>
81113804:	dfc00217 	ldw	ra,8(sp)
81113808:	dc400117 	ldw	r17,4(sp)
8111380c:	dc000017 	ldw	r16,0(sp)
81113810:	dec00304 	addi	sp,sp,12
81113814:	f800283a 	ret
81113818:	2007883a 	mov	r3,r4
8111381c:	003ff206 	br	811137e8 <__reset+0xfb0f37e8>
81113820:	2007883a 	mov	r3,r4
81113824:	003ff106 	br	811137ec <__reset+0xfb0f37ec>
81113828:	200d883a 	mov	r6,r4
8111382c:	003fee06 	br	811137e8 <__reset+0xfb0f37e8>

81113830 <memset>:
81113830:	20c000cc 	andi	r3,r4,3
81113834:	2005883a 	mov	r2,r4
81113838:	18004426 	beq	r3,zero,8111394c <memset+0x11c>
8111383c:	31ffffc4 	addi	r7,r6,-1
81113840:	30004026 	beq	r6,zero,81113944 <memset+0x114>
81113844:	2813883a 	mov	r9,r5
81113848:	200d883a 	mov	r6,r4
8111384c:	2007883a 	mov	r3,r4
81113850:	00000406 	br	81113864 <memset+0x34>
81113854:	3a3fffc4 	addi	r8,r7,-1
81113858:	31800044 	addi	r6,r6,1
8111385c:	38003926 	beq	r7,zero,81113944 <memset+0x114>
81113860:	400f883a 	mov	r7,r8
81113864:	18c00044 	addi	r3,r3,1
81113868:	32400005 	stb	r9,0(r6)
8111386c:	1a0000cc 	andi	r8,r3,3
81113870:	403ff81e 	bne	r8,zero,81113854 <__reset+0xfb0f3854>
81113874:	010000c4 	movi	r4,3
81113878:	21c02d2e 	bgeu	r4,r7,81113930 <memset+0x100>
8111387c:	29003fcc 	andi	r4,r5,255
81113880:	200c923a 	slli	r6,r4,8
81113884:	3108b03a 	or	r4,r6,r4
81113888:	200c943a 	slli	r6,r4,16
8111388c:	218cb03a 	or	r6,r4,r6
81113890:	010003c4 	movi	r4,15
81113894:	21c0182e 	bgeu	r4,r7,811138f8 <memset+0xc8>
81113898:	3b3ffc04 	addi	r12,r7,-16
8111389c:	6018d13a 	srli	r12,r12,4
811138a0:	1a000104 	addi	r8,r3,4
811138a4:	1ac00204 	addi	r11,r3,8
811138a8:	6008913a 	slli	r4,r12,4
811138ac:	1a800304 	addi	r10,r3,12
811138b0:	1813883a 	mov	r9,r3
811138b4:	21000504 	addi	r4,r4,20
811138b8:	1909883a 	add	r4,r3,r4
811138bc:	49800015 	stw	r6,0(r9)
811138c0:	41800015 	stw	r6,0(r8)
811138c4:	59800015 	stw	r6,0(r11)
811138c8:	51800015 	stw	r6,0(r10)
811138cc:	42000404 	addi	r8,r8,16
811138d0:	4a400404 	addi	r9,r9,16
811138d4:	5ac00404 	addi	r11,r11,16
811138d8:	52800404 	addi	r10,r10,16
811138dc:	413ff71e 	bne	r8,r4,811138bc <__reset+0xfb0f38bc>
811138e0:	63000044 	addi	r12,r12,1
811138e4:	6018913a 	slli	r12,r12,4
811138e8:	39c003cc 	andi	r7,r7,15
811138ec:	010000c4 	movi	r4,3
811138f0:	1b07883a 	add	r3,r3,r12
811138f4:	21c00e2e 	bgeu	r4,r7,81113930 <memset+0x100>
811138f8:	1813883a 	mov	r9,r3
811138fc:	3811883a 	mov	r8,r7
81113900:	010000c4 	movi	r4,3
81113904:	49800015 	stw	r6,0(r9)
81113908:	423fff04 	addi	r8,r8,-4
8111390c:	4a400104 	addi	r9,r9,4
81113910:	223ffc36 	bltu	r4,r8,81113904 <__reset+0xfb0f3904>
81113914:	393fff04 	addi	r4,r7,-4
81113918:	2008d0ba 	srli	r4,r4,2
8111391c:	39c000cc 	andi	r7,r7,3
81113920:	21000044 	addi	r4,r4,1
81113924:	2109883a 	add	r4,r4,r4
81113928:	2109883a 	add	r4,r4,r4
8111392c:	1907883a 	add	r3,r3,r4
81113930:	38000526 	beq	r7,zero,81113948 <memset+0x118>
81113934:	19cf883a 	add	r7,r3,r7
81113938:	19400005 	stb	r5,0(r3)
8111393c:	18c00044 	addi	r3,r3,1
81113940:	38fffd1e 	bne	r7,r3,81113938 <__reset+0xfb0f3938>
81113944:	f800283a 	ret
81113948:	f800283a 	ret
8111394c:	2007883a 	mov	r3,r4
81113950:	300f883a 	mov	r7,r6
81113954:	003fc706 	br	81113874 <__reset+0xfb0f3874>

81113958 <_open_r>:
81113958:	defffd04 	addi	sp,sp,-12
8111395c:	de00012e 	bgeu	sp,et,81113964 <_open_r+0xc>
81113960:	003b68fa 	trap	3
81113964:	2805883a 	mov	r2,r5
81113968:	dc000015 	stw	r16,0(sp)
8111396c:	04204534 	movhi	r16,33044
81113970:	dc400115 	stw	r17,4(sp)
81113974:	300b883a 	mov	r5,r6
81113978:	84070504 	addi	r16,r16,7188
8111397c:	2023883a 	mov	r17,r4
81113980:	380d883a 	mov	r6,r7
81113984:	1009883a 	mov	r4,r2
81113988:	dfc00215 	stw	ra,8(sp)
8111398c:	80000015 	stw	zero,0(r16)
81113990:	112862c0 	call	8112862c <open>
81113994:	00ffffc4 	movi	r3,-1
81113998:	10c00526 	beq	r2,r3,811139b0 <_open_r+0x58>
8111399c:	dfc00217 	ldw	ra,8(sp)
811139a0:	dc400117 	ldw	r17,4(sp)
811139a4:	dc000017 	ldw	r16,0(sp)
811139a8:	dec00304 	addi	sp,sp,12
811139ac:	f800283a 	ret
811139b0:	80c00017 	ldw	r3,0(r16)
811139b4:	183ff926 	beq	r3,zero,8111399c <__reset+0xfb0f399c>
811139b8:	88c00015 	stw	r3,0(r17)
811139bc:	003ff706 	br	8111399c <__reset+0xfb0f399c>

811139c0 <_printf_r>:
811139c0:	defffd04 	addi	sp,sp,-12
811139c4:	2805883a 	mov	r2,r5
811139c8:	de00012e 	bgeu	sp,et,811139d0 <_printf_r+0x10>
811139cc:	003b68fa 	trap	3
811139d0:	dfc00015 	stw	ra,0(sp)
811139d4:	d9800115 	stw	r6,4(sp)
811139d8:	d9c00215 	stw	r7,8(sp)
811139dc:	21400217 	ldw	r5,8(r4)
811139e0:	d9c00104 	addi	r7,sp,4
811139e4:	100d883a 	mov	r6,r2
811139e8:	11165740 	call	81116574 <___vfprintf_internal_r>
811139ec:	dfc00017 	ldw	ra,0(sp)
811139f0:	dec00304 	addi	sp,sp,12
811139f4:	f800283a 	ret

811139f8 <printf>:
811139f8:	defffc04 	addi	sp,sp,-16
811139fc:	de00012e 	bgeu	sp,et,81113a04 <printf+0xc>
81113a00:	003b68fa 	trap	3
81113a04:	dfc00015 	stw	ra,0(sp)
81113a08:	d9400115 	stw	r5,4(sp)
81113a0c:	d9800215 	stw	r6,8(sp)
81113a10:	d9c00315 	stw	r7,12(sp)
81113a14:	00a04534 	movhi	r2,33044
81113a18:	1086aa04 	addi	r2,r2,6824
81113a1c:	10800017 	ldw	r2,0(r2)
81113a20:	200b883a 	mov	r5,r4
81113a24:	d9800104 	addi	r6,sp,4
81113a28:	11000217 	ldw	r4,8(r2)
81113a2c:	11187740 	call	81118774 <__vfprintf_internal>
81113a30:	dfc00017 	ldw	ra,0(sp)
81113a34:	dec00404 	addi	sp,sp,16
81113a38:	f800283a 	ret

81113a3c <_puts_r>:
81113a3c:	defff604 	addi	sp,sp,-40
81113a40:	de00012e 	bgeu	sp,et,81113a48 <_puts_r+0xc>
81113a44:	003b68fa 	trap	3
81113a48:	dc000715 	stw	r16,28(sp)
81113a4c:	2021883a 	mov	r16,r4
81113a50:	2809883a 	mov	r4,r5
81113a54:	dc400815 	stw	r17,32(sp)
81113a58:	dfc00915 	stw	ra,36(sp)
81113a5c:	2823883a 	mov	r17,r5
81113a60:	111405c0 	call	8111405c <strlen>
81113a64:	10c00044 	addi	r3,r2,1
81113a68:	d8800115 	stw	r2,4(sp)
81113a6c:	00a04534 	movhi	r2,33044
81113a70:	10bd9f04 	addi	r2,r2,-2436
81113a74:	d8800215 	stw	r2,8(sp)
81113a78:	00800044 	movi	r2,1
81113a7c:	d8800315 	stw	r2,12(sp)
81113a80:	00800084 	movi	r2,2
81113a84:	dc400015 	stw	r17,0(sp)
81113a88:	d8c00615 	stw	r3,24(sp)
81113a8c:	dec00415 	stw	sp,16(sp)
81113a90:	d8800515 	stw	r2,20(sp)
81113a94:	80000226 	beq	r16,zero,81113aa0 <_puts_r+0x64>
81113a98:	80800e17 	ldw	r2,56(r16)
81113a9c:	10001426 	beq	r2,zero,81113af0 <_puts_r+0xb4>
81113aa0:	81400217 	ldw	r5,8(r16)
81113aa4:	2880030b 	ldhu	r2,12(r5)
81113aa8:	10c8000c 	andi	r3,r2,8192
81113aac:	1800061e 	bne	r3,zero,81113ac8 <_puts_r+0x8c>
81113ab0:	29001917 	ldw	r4,100(r5)
81113ab4:	00f7ffc4 	movi	r3,-8193
81113ab8:	10880014 	ori	r2,r2,8192
81113abc:	20c6703a 	and	r3,r4,r3
81113ac0:	2880030d 	sth	r2,12(r5)
81113ac4:	28c01915 	stw	r3,100(r5)
81113ac8:	d9800404 	addi	r6,sp,16
81113acc:	8009883a 	mov	r4,r16
81113ad0:	111c9800 	call	8111c980 <__sfvwrite_r>
81113ad4:	1000091e 	bne	r2,zero,81113afc <_puts_r+0xc0>
81113ad8:	00800284 	movi	r2,10
81113adc:	dfc00917 	ldw	ra,36(sp)
81113ae0:	dc400817 	ldw	r17,32(sp)
81113ae4:	dc000717 	ldw	r16,28(sp)
81113ae8:	dec00a04 	addi	sp,sp,40
81113aec:	f800283a 	ret
81113af0:	8009883a 	mov	r4,r16
81113af4:	111c1d00 	call	8111c1d0 <__sinit>
81113af8:	003fe906 	br	81113aa0 <__reset+0xfb0f3aa0>
81113afc:	00bfffc4 	movi	r2,-1
81113b00:	003ff606 	br	81113adc <__reset+0xfb0f3adc>

81113b04 <puts>:
81113b04:	00a04534 	movhi	r2,33044
81113b08:	1086aa04 	addi	r2,r2,6824
81113b0c:	200b883a 	mov	r5,r4
81113b10:	11000017 	ldw	r4,0(r2)
81113b14:	1113a3c1 	jmpi	81113a3c <_puts_r>

81113b18 <lflush>:
81113b18:	2080030b 	ldhu	r2,12(r4)
81113b1c:	00c00244 	movi	r3,9
81113b20:	1080024c 	andi	r2,r2,9
81113b24:	10c00226 	beq	r2,r3,81113b30 <lflush+0x18>
81113b28:	0005883a 	mov	r2,zero
81113b2c:	f800283a 	ret
81113b30:	111be381 	jmpi	8111be38 <fflush>

81113b34 <__srefill_r>:
81113b34:	defffc04 	addi	sp,sp,-16
81113b38:	de00012e 	bgeu	sp,et,81113b40 <__srefill_r+0xc>
81113b3c:	003b68fa 	trap	3
81113b40:	dc400115 	stw	r17,4(sp)
81113b44:	dc000015 	stw	r16,0(sp)
81113b48:	dfc00315 	stw	ra,12(sp)
81113b4c:	dc800215 	stw	r18,8(sp)
81113b50:	2023883a 	mov	r17,r4
81113b54:	2821883a 	mov	r16,r5
81113b58:	20000226 	beq	r4,zero,81113b64 <__srefill_r+0x30>
81113b5c:	20800e17 	ldw	r2,56(r4)
81113b60:	10003c26 	beq	r2,zero,81113c54 <__srefill_r+0x120>
81113b64:	80c0030b 	ldhu	r3,12(r16)
81113b68:	1908000c 	andi	r4,r3,8192
81113b6c:	1805883a 	mov	r2,r3
81113b70:	2000071e 	bne	r4,zero,81113b90 <__srefill_r+0x5c>
81113b74:	81001917 	ldw	r4,100(r16)
81113b78:	18880014 	ori	r2,r3,8192
81113b7c:	00f7ffc4 	movi	r3,-8193
81113b80:	20c8703a 	and	r4,r4,r3
81113b84:	8080030d 	sth	r2,12(r16)
81113b88:	1007883a 	mov	r3,r2
81113b8c:	81001915 	stw	r4,100(r16)
81113b90:	80000115 	stw	zero,4(r16)
81113b94:	1100080c 	andi	r4,r2,32
81113b98:	2000571e 	bne	r4,zero,81113cf8 <__srefill_r+0x1c4>
81113b9c:	1100010c 	andi	r4,r2,4
81113ba0:	20001f26 	beq	r4,zero,81113c20 <__srefill_r+0xec>
81113ba4:	81400c17 	ldw	r5,48(r16)
81113ba8:	28000826 	beq	r5,zero,81113bcc <__srefill_r+0x98>
81113bac:	80801004 	addi	r2,r16,64
81113bb0:	28800226 	beq	r5,r2,81113bbc <__srefill_r+0x88>
81113bb4:	8809883a 	mov	r4,r17
81113bb8:	111c6680 	call	8111c668 <_free_r>
81113bbc:	80800f17 	ldw	r2,60(r16)
81113bc0:	80000c15 	stw	zero,48(r16)
81113bc4:	80800115 	stw	r2,4(r16)
81113bc8:	1000391e 	bne	r2,zero,81113cb0 <__srefill_r+0x17c>
81113bcc:	80800417 	ldw	r2,16(r16)
81113bd0:	10004b26 	beq	r2,zero,81113d00 <__srefill_r+0x1cc>
81113bd4:	8480030b 	ldhu	r18,12(r16)
81113bd8:	908000cc 	andi	r2,r18,3
81113bdc:	10001f1e 	bne	r2,zero,81113c5c <__srefill_r+0x128>
81113be0:	81800417 	ldw	r6,16(r16)
81113be4:	80800817 	ldw	r2,32(r16)
81113be8:	81c00517 	ldw	r7,20(r16)
81113bec:	81400717 	ldw	r5,28(r16)
81113bf0:	81800015 	stw	r6,0(r16)
81113bf4:	8809883a 	mov	r4,r17
81113bf8:	103ee83a 	callr	r2
81113bfc:	80800115 	stw	r2,4(r16)
81113c00:	00800e0e 	bge	zero,r2,81113c3c <__srefill_r+0x108>
81113c04:	0005883a 	mov	r2,zero
81113c08:	dfc00317 	ldw	ra,12(sp)
81113c0c:	dc800217 	ldw	r18,8(sp)
81113c10:	dc400117 	ldw	r17,4(sp)
81113c14:	dc000017 	ldw	r16,0(sp)
81113c18:	dec00404 	addi	sp,sp,16
81113c1c:	f800283a 	ret
81113c20:	1100040c 	andi	r4,r2,16
81113c24:	20003026 	beq	r4,zero,81113ce8 <__srefill_r+0x1b4>
81113c28:	1080020c 	andi	r2,r2,8
81113c2c:	1000241e 	bne	r2,zero,81113cc0 <__srefill_r+0x18c>
81113c30:	18c00114 	ori	r3,r3,4
81113c34:	80c0030d 	sth	r3,12(r16)
81113c38:	003fe406 	br	81113bcc <__reset+0xfb0f3bcc>
81113c3c:	80c0030b 	ldhu	r3,12(r16)
81113c40:	1000161e 	bne	r2,zero,81113c9c <__srefill_r+0x168>
81113c44:	18c00814 	ori	r3,r3,32
81113c48:	00bfffc4 	movi	r2,-1
81113c4c:	80c0030d 	sth	r3,12(r16)
81113c50:	003fed06 	br	81113c08 <__reset+0xfb0f3c08>
81113c54:	111c1d00 	call	8111c1d0 <__sinit>
81113c58:	003fc206 	br	81113b64 <__reset+0xfb0f3b64>
81113c5c:	00a04534 	movhi	r2,33044
81113c60:	1086a904 	addi	r2,r2,6820
81113c64:	11000017 	ldw	r4,0(r2)
81113c68:	01604474 	movhi	r5,33041
81113c6c:	00800044 	movi	r2,1
81113c70:	294ec604 	addi	r5,r5,15128
81113c74:	8080030d 	sth	r2,12(r16)
81113c78:	111ce440 	call	8111ce44 <_fwalk>
81113c7c:	00800244 	movi	r2,9
81113c80:	8480030d 	sth	r18,12(r16)
81113c84:	9480024c 	andi	r18,r18,9
81113c88:	90bfd51e 	bne	r18,r2,81113be0 <__reset+0xfb0f3be0>
81113c8c:	800b883a 	mov	r5,r16
81113c90:	8809883a 	mov	r4,r17
81113c94:	111bbb00 	call	8111bbb0 <__sflush_r>
81113c98:	003fd106 	br	81113be0 <__reset+0xfb0f3be0>
81113c9c:	18c01014 	ori	r3,r3,64
81113ca0:	80000115 	stw	zero,4(r16)
81113ca4:	00bfffc4 	movi	r2,-1
81113ca8:	80c0030d 	sth	r3,12(r16)
81113cac:	003fd606 	br	81113c08 <__reset+0xfb0f3c08>
81113cb0:	80c00e17 	ldw	r3,56(r16)
81113cb4:	0005883a 	mov	r2,zero
81113cb8:	80c00015 	stw	r3,0(r16)
81113cbc:	003fd206 	br	81113c08 <__reset+0xfb0f3c08>
81113cc0:	800b883a 	mov	r5,r16
81113cc4:	8809883a 	mov	r4,r17
81113cc8:	111bdd40 	call	8111bdd4 <_fflush_r>
81113ccc:	10000a1e 	bne	r2,zero,81113cf8 <__srefill_r+0x1c4>
81113cd0:	8080030b 	ldhu	r2,12(r16)
81113cd4:	00fffdc4 	movi	r3,-9
81113cd8:	80000215 	stw	zero,8(r16)
81113cdc:	1886703a 	and	r3,r3,r2
81113ce0:	80000615 	stw	zero,24(r16)
81113ce4:	003fd206 	br	81113c30 <__reset+0xfb0f3c30>
81113ce8:	00800244 	movi	r2,9
81113cec:	88800015 	stw	r2,0(r17)
81113cf0:	18c01014 	ori	r3,r3,64
81113cf4:	80c0030d 	sth	r3,12(r16)
81113cf8:	00bfffc4 	movi	r2,-1
81113cfc:	003fc206 	br	81113c08 <__reset+0xfb0f3c08>
81113d00:	800b883a 	mov	r5,r16
81113d04:	8809883a 	mov	r4,r17
81113d08:	1112d080 	call	81112d08 <__smakebuf_r>
81113d0c:	003fb106 	br	81113bd4 <__reset+0xfb0f3bd4>

81113d10 <_sbrk_r>:
81113d10:	defffd04 	addi	sp,sp,-12
81113d14:	de00012e 	bgeu	sp,et,81113d1c <_sbrk_r+0xc>
81113d18:	003b68fa 	trap	3
81113d1c:	dc000015 	stw	r16,0(sp)
81113d20:	04204534 	movhi	r16,33044
81113d24:	dc400115 	stw	r17,4(sp)
81113d28:	84070504 	addi	r16,r16,7188
81113d2c:	2023883a 	mov	r17,r4
81113d30:	2809883a 	mov	r4,r5
81113d34:	dfc00215 	stw	ra,8(sp)
81113d38:	80000015 	stw	zero,0(r16)
81113d3c:	112893c0 	call	8112893c <sbrk>
81113d40:	00ffffc4 	movi	r3,-1
81113d44:	10c00526 	beq	r2,r3,81113d5c <_sbrk_r+0x4c>
81113d48:	dfc00217 	ldw	ra,8(sp)
81113d4c:	dc400117 	ldw	r17,4(sp)
81113d50:	dc000017 	ldw	r16,0(sp)
81113d54:	dec00304 	addi	sp,sp,12
81113d58:	f800283a 	ret
81113d5c:	80c00017 	ldw	r3,0(r16)
81113d60:	183ff926 	beq	r3,zero,81113d48 <__reset+0xfb0f3d48>
81113d64:	88c00015 	stw	r3,0(r17)
81113d68:	003ff706 	br	81113d48 <__reset+0xfb0f3d48>

81113d6c <scanf>:
81113d6c:	defffc04 	addi	sp,sp,-16
81113d70:	de00012e 	bgeu	sp,et,81113d78 <scanf+0xc>
81113d74:	003b68fa 	trap	3
81113d78:	dfc00015 	stw	ra,0(sp)
81113d7c:	d9400115 	stw	r5,4(sp)
81113d80:	d9800215 	stw	r6,8(sp)
81113d84:	d9c00315 	stw	r7,12(sp)
81113d88:	00a04534 	movhi	r2,33044
81113d8c:	1086aa04 	addi	r2,r2,6824
81113d90:	200d883a 	mov	r6,r4
81113d94:	11000017 	ldw	r4,0(r2)
81113d98:	d9c00104 	addi	r7,sp,4
81113d9c:	21400117 	ldw	r5,4(r4)
81113da0:	111a0a40 	call	8111a0a4 <_vfscanf_r>
81113da4:	dfc00017 	ldw	ra,0(sp)
81113da8:	dec00404 	addi	sp,sp,16
81113dac:	f800283a 	ret

81113db0 <_scanf_r>:
81113db0:	defffd04 	addi	sp,sp,-12
81113db4:	2805883a 	mov	r2,r5
81113db8:	de00012e 	bgeu	sp,et,81113dc0 <_scanf_r+0x10>
81113dbc:	003b68fa 	trap	3
81113dc0:	dfc00015 	stw	ra,0(sp)
81113dc4:	d9800115 	stw	r6,4(sp)
81113dc8:	d9c00215 	stw	r7,8(sp)
81113dcc:	21400117 	ldw	r5,4(r4)
81113dd0:	d9c00104 	addi	r7,sp,4
81113dd4:	100d883a 	mov	r6,r2
81113dd8:	111a0a40 	call	8111a0a4 <_vfscanf_r>
81113ddc:	dfc00017 	ldw	ra,0(sp)
81113de0:	dec00304 	addi	sp,sp,12
81113de4:	f800283a 	ret

81113de8 <_sprintf_r>:
81113de8:	deffe404 	addi	sp,sp,-112
81113dec:	2807883a 	mov	r3,r5
81113df0:	de00012e 	bgeu	sp,et,81113df8 <_sprintf_r+0x10>
81113df4:	003b68fa 	trap	3
81113df8:	dfc01a15 	stw	ra,104(sp)
81113dfc:	d9c01b15 	stw	r7,108(sp)
81113e00:	00a00034 	movhi	r2,32768
81113e04:	10bfffc4 	addi	r2,r2,-1
81113e08:	02008204 	movi	r8,520
81113e0c:	d8800215 	stw	r2,8(sp)
81113e10:	d8800515 	stw	r2,20(sp)
81113e14:	d9c01b04 	addi	r7,sp,108
81113e18:	d80b883a 	mov	r5,sp
81113e1c:	00bfffc4 	movi	r2,-1
81113e20:	d8c00015 	stw	r3,0(sp)
81113e24:	d8c00415 	stw	r3,16(sp)
81113e28:	da00030d 	sth	r8,12(sp)
81113e2c:	d880038d 	sth	r2,14(sp)
81113e30:	11143940 	call	81114394 <___svfprintf_internal_r>
81113e34:	d8c00017 	ldw	r3,0(sp)
81113e38:	18000005 	stb	zero,0(r3)
81113e3c:	dfc01a17 	ldw	ra,104(sp)
81113e40:	dec01c04 	addi	sp,sp,112
81113e44:	f800283a 	ret

81113e48 <sprintf>:
81113e48:	deffe304 	addi	sp,sp,-116
81113e4c:	2007883a 	mov	r3,r4
81113e50:	de00012e 	bgeu	sp,et,81113e58 <sprintf+0x10>
81113e54:	003b68fa 	trap	3
81113e58:	dfc01a15 	stw	ra,104(sp)
81113e5c:	d9801b15 	stw	r6,108(sp)
81113e60:	d9c01c15 	stw	r7,112(sp)
81113e64:	01204534 	movhi	r4,33044
81113e68:	2106aa04 	addi	r4,r4,6824
81113e6c:	21000017 	ldw	r4,0(r4)
81113e70:	00a00034 	movhi	r2,32768
81113e74:	10bfffc4 	addi	r2,r2,-1
81113e78:	280d883a 	mov	r6,r5
81113e7c:	02008204 	movi	r8,520
81113e80:	d8800215 	stw	r2,8(sp)
81113e84:	d8800515 	stw	r2,20(sp)
81113e88:	d9c01b04 	addi	r7,sp,108
81113e8c:	d80b883a 	mov	r5,sp
81113e90:	00bfffc4 	movi	r2,-1
81113e94:	d8c00015 	stw	r3,0(sp)
81113e98:	d8c00415 	stw	r3,16(sp)
81113e9c:	da00030d 	sth	r8,12(sp)
81113ea0:	d880038d 	sth	r2,14(sp)
81113ea4:	11143940 	call	81114394 <___svfprintf_internal_r>
81113ea8:	d8c00017 	ldw	r3,0(sp)
81113eac:	18000005 	stb	zero,0(r3)
81113eb0:	dfc01a17 	ldw	ra,104(sp)
81113eb4:	dec01d04 	addi	sp,sp,116
81113eb8:	f800283a 	ret

81113ebc <__sread>:
81113ebc:	defffe04 	addi	sp,sp,-8
81113ec0:	de00012e 	bgeu	sp,et,81113ec8 <__sread+0xc>
81113ec4:	003b68fa 	trap	3
81113ec8:	dc000015 	stw	r16,0(sp)
81113ecc:	2821883a 	mov	r16,r5
81113ed0:	2940038f 	ldh	r5,14(r5)
81113ed4:	dfc00115 	stw	ra,4(sp)
81113ed8:	111e6940 	call	8111e694 <_read_r>
81113edc:	10000716 	blt	r2,zero,81113efc <__sread+0x40>
81113ee0:	80c01417 	ldw	r3,80(r16)
81113ee4:	1887883a 	add	r3,r3,r2
81113ee8:	80c01415 	stw	r3,80(r16)
81113eec:	dfc00117 	ldw	ra,4(sp)
81113ef0:	dc000017 	ldw	r16,0(sp)
81113ef4:	dec00204 	addi	sp,sp,8
81113ef8:	f800283a 	ret
81113efc:	80c0030b 	ldhu	r3,12(r16)
81113f00:	18fbffcc 	andi	r3,r3,61439
81113f04:	80c0030d 	sth	r3,12(r16)
81113f08:	dfc00117 	ldw	ra,4(sp)
81113f0c:	dc000017 	ldw	r16,0(sp)
81113f10:	dec00204 	addi	sp,sp,8
81113f14:	f800283a 	ret

81113f18 <__seofread>:
81113f18:	0005883a 	mov	r2,zero
81113f1c:	f800283a 	ret

81113f20 <__swrite>:
81113f20:	defffb04 	addi	sp,sp,-20
81113f24:	de00012e 	bgeu	sp,et,81113f2c <__swrite+0xc>
81113f28:	003b68fa 	trap	3
81113f2c:	2880030b 	ldhu	r2,12(r5)
81113f30:	dcc00315 	stw	r19,12(sp)
81113f34:	dc800215 	stw	r18,8(sp)
81113f38:	dc400115 	stw	r17,4(sp)
81113f3c:	dc000015 	stw	r16,0(sp)
81113f40:	dfc00415 	stw	ra,16(sp)
81113f44:	10c0400c 	andi	r3,r2,256
81113f48:	2821883a 	mov	r16,r5
81113f4c:	2023883a 	mov	r17,r4
81113f50:	3025883a 	mov	r18,r6
81113f54:	3827883a 	mov	r19,r7
81113f58:	18000526 	beq	r3,zero,81113f70 <__swrite+0x50>
81113f5c:	2940038f 	ldh	r5,14(r5)
81113f60:	01c00084 	movi	r7,2
81113f64:	000d883a 	mov	r6,zero
81113f68:	111d14c0 	call	8111d14c <_lseek_r>
81113f6c:	8080030b 	ldhu	r2,12(r16)
81113f70:	8140038f 	ldh	r5,14(r16)
81113f74:	10bbffcc 	andi	r2,r2,61439
81113f78:	980f883a 	mov	r7,r19
81113f7c:	900d883a 	mov	r6,r18
81113f80:	8809883a 	mov	r4,r17
81113f84:	8080030d 	sth	r2,12(r16)
81113f88:	dfc00417 	ldw	ra,16(sp)
81113f8c:	dcc00317 	ldw	r19,12(sp)
81113f90:	dc800217 	ldw	r18,8(sp)
81113f94:	dc400117 	ldw	r17,4(sp)
81113f98:	dc000017 	ldw	r16,0(sp)
81113f9c:	dec00504 	addi	sp,sp,20
81113fa0:	111a0f81 	jmpi	8111a0f8 <_write_r>

81113fa4 <__sseek>:
81113fa4:	defffe04 	addi	sp,sp,-8
81113fa8:	de00012e 	bgeu	sp,et,81113fb0 <__sseek+0xc>
81113fac:	003b68fa 	trap	3
81113fb0:	dc000015 	stw	r16,0(sp)
81113fb4:	2821883a 	mov	r16,r5
81113fb8:	2940038f 	ldh	r5,14(r5)
81113fbc:	dfc00115 	stw	ra,4(sp)
81113fc0:	111d14c0 	call	8111d14c <_lseek_r>
81113fc4:	00ffffc4 	movi	r3,-1
81113fc8:	10c00826 	beq	r2,r3,81113fec <__sseek+0x48>
81113fcc:	80c0030b 	ldhu	r3,12(r16)
81113fd0:	80801415 	stw	r2,80(r16)
81113fd4:	18c40014 	ori	r3,r3,4096
81113fd8:	80c0030d 	sth	r3,12(r16)
81113fdc:	dfc00117 	ldw	ra,4(sp)
81113fe0:	dc000017 	ldw	r16,0(sp)
81113fe4:	dec00204 	addi	sp,sp,8
81113fe8:	f800283a 	ret
81113fec:	80c0030b 	ldhu	r3,12(r16)
81113ff0:	18fbffcc 	andi	r3,r3,61439
81113ff4:	80c0030d 	sth	r3,12(r16)
81113ff8:	dfc00117 	ldw	ra,4(sp)
81113ffc:	dc000017 	ldw	r16,0(sp)
81114000:	dec00204 	addi	sp,sp,8
81114004:	f800283a 	ret

81114008 <__sclose>:
81114008:	2940038f 	ldh	r5,14(r5)
8111400c:	111a2bc1 	jmpi	8111a2bc <_close_r>

81114010 <strcspn>:
81114010:	21c00007 	ldb	r7,0(r4)
81114014:	38000f26 	beq	r7,zero,81114054 <strcspn+0x44>
81114018:	2a000007 	ldb	r8,0(r5)
8111401c:	2005883a 	mov	r2,r4
81114020:	40000726 	beq	r8,zero,81114040 <strcspn+0x30>
81114024:	3a000926 	beq	r7,r8,8111404c <strcspn+0x3c>
81114028:	2807883a 	mov	r3,r5
8111402c:	00000106 	br	81114034 <strcspn+0x24>
81114030:	31c00626 	beq	r6,r7,8111404c <strcspn+0x3c>
81114034:	18c00044 	addi	r3,r3,1
81114038:	19800007 	ldb	r6,0(r3)
8111403c:	303ffc1e 	bne	r6,zero,81114030 <__reset+0xfb0f4030>
81114040:	10800044 	addi	r2,r2,1
81114044:	11c00007 	ldb	r7,0(r2)
81114048:	383ff51e 	bne	r7,zero,81114020 <__reset+0xfb0f4020>
8111404c:	1105c83a 	sub	r2,r2,r4
81114050:	f800283a 	ret
81114054:	0005883a 	mov	r2,zero
81114058:	f800283a 	ret

8111405c <strlen>:
8111405c:	208000cc 	andi	r2,r4,3
81114060:	10002026 	beq	r2,zero,811140e4 <strlen+0x88>
81114064:	20800007 	ldb	r2,0(r4)
81114068:	10002026 	beq	r2,zero,811140ec <strlen+0x90>
8111406c:	2005883a 	mov	r2,r4
81114070:	00000206 	br	8111407c <strlen+0x20>
81114074:	10c00007 	ldb	r3,0(r2)
81114078:	18001826 	beq	r3,zero,811140dc <strlen+0x80>
8111407c:	10800044 	addi	r2,r2,1
81114080:	10c000cc 	andi	r3,r2,3
81114084:	183ffb1e 	bne	r3,zero,81114074 <__reset+0xfb0f4074>
81114088:	10c00017 	ldw	r3,0(r2)
8111408c:	01ffbff4 	movhi	r7,65279
81114090:	39ffbfc4 	addi	r7,r7,-257
81114094:	00ca303a 	nor	r5,zero,r3
81114098:	01a02074 	movhi	r6,32897
8111409c:	19c7883a 	add	r3,r3,r7
811140a0:	31a02004 	addi	r6,r6,-32640
811140a4:	1946703a 	and	r3,r3,r5
811140a8:	1986703a 	and	r3,r3,r6
811140ac:	1800091e 	bne	r3,zero,811140d4 <strlen+0x78>
811140b0:	10800104 	addi	r2,r2,4
811140b4:	10c00017 	ldw	r3,0(r2)
811140b8:	19cb883a 	add	r5,r3,r7
811140bc:	00c6303a 	nor	r3,zero,r3
811140c0:	28c6703a 	and	r3,r5,r3
811140c4:	1986703a 	and	r3,r3,r6
811140c8:	183ff926 	beq	r3,zero,811140b0 <__reset+0xfb0f40b0>
811140cc:	00000106 	br	811140d4 <strlen+0x78>
811140d0:	10800044 	addi	r2,r2,1
811140d4:	10c00007 	ldb	r3,0(r2)
811140d8:	183ffd1e 	bne	r3,zero,811140d0 <__reset+0xfb0f40d0>
811140dc:	1105c83a 	sub	r2,r2,r4
811140e0:	f800283a 	ret
811140e4:	2005883a 	mov	r2,r4
811140e8:	003fe706 	br	81114088 <__reset+0xfb0f4088>
811140ec:	0005883a 	mov	r2,zero
811140f0:	f800283a 	ret

811140f4 <strnlen>:
811140f4:	28000e26 	beq	r5,zero,81114130 <strnlen+0x3c>
811140f8:	20800007 	ldb	r2,0(r4)
811140fc:	10000c26 	beq	r2,zero,81114130 <strnlen+0x3c>
81114100:	20c00044 	addi	r3,r4,1
81114104:	214b883a 	add	r5,r4,r5
81114108:	28c00526 	beq	r5,r3,81114120 <strnlen+0x2c>
8111410c:	19800007 	ldb	r6,0(r3)
81114110:	19c00044 	addi	r7,r3,1
81114114:	30000426 	beq	r6,zero,81114128 <strnlen+0x34>
81114118:	3807883a 	mov	r3,r7
8111411c:	28fffb1e 	bne	r5,r3,8111410c <__reset+0xfb0f410c>
81114120:	2905c83a 	sub	r2,r5,r4
81114124:	f800283a 	ret
81114128:	1905c83a 	sub	r2,r3,r4
8111412c:	f800283a 	ret
81114130:	0005883a 	mov	r2,zero
81114134:	f800283a 	ret

81114138 <_strtol_r>:
81114138:	00a04534 	movhi	r2,33044
8111413c:	defff404 	addi	sp,sp,-48
81114140:	1086a804 	addi	r2,r2,6816
81114144:	de00012e 	bgeu	sp,et,8111414c <_strtol_r+0x14>
81114148:	003b68fa 	trap	3
8111414c:	dd400715 	stw	r21,28(sp)
81114150:	15400017 	ldw	r21,0(r2)
81114154:	dd800815 	stw	r22,32(sp)
81114158:	dd000615 	stw	r20,24(sp)
8111415c:	dcc00515 	stw	r19,20(sp)
81114160:	d9000015 	stw	r4,0(sp)
81114164:	dfc00b15 	stw	ra,44(sp)
81114168:	df000a15 	stw	fp,40(sp)
8111416c:	ddc00915 	stw	r23,36(sp)
81114170:	dc800415 	stw	r18,16(sp)
81114174:	dc400315 	stw	r17,12(sp)
81114178:	dc000215 	stw	r16,8(sp)
8111417c:	2829883a 	mov	r20,r5
81114180:	3027883a 	mov	r19,r6
81114184:	382d883a 	mov	r22,r7
81114188:	2809883a 	mov	r4,r5
8111418c:	24000003 	ldbu	r16,0(r4)
81114190:	24400044 	addi	r17,r4,1
81114194:	2007883a 	mov	r3,r4
81114198:	ac05883a 	add	r2,r21,r16
8111419c:	10800043 	ldbu	r2,1(r2)
811141a0:	8809883a 	mov	r4,r17
811141a4:	1080020c 	andi	r2,r2,8
811141a8:	103ff81e 	bne	r2,zero,8111418c <__reset+0xfb0f418c>
811141ac:	00800b44 	movi	r2,45
811141b0:	80805826 	beq	r16,r2,81114314 <_strtol_r+0x1dc>
811141b4:	00800ac4 	movi	r2,43
811141b8:	80805a26 	beq	r16,r2,81114324 <_strtol_r+0x1ec>
811141bc:	0039883a 	mov	fp,zero
811141c0:	b0004426 	beq	r22,zero,811142d4 <_strtol_r+0x19c>
811141c4:	00800404 	movi	r2,16
811141c8:	b0806026 	beq	r22,r2,8111434c <_strtol_r+0x214>
811141cc:	b02f883a 	mov	r23,r22
811141d0:	00a00034 	movhi	r2,32768
811141d4:	e025003a 	cmpeq	r18,fp,zero
811141d8:	14a5c83a 	sub	r18,r2,r18
811141dc:	b80b883a 	mov	r5,r23
811141e0:	9009883a 	mov	r4,r18
811141e4:	1125bb40 	call	81125bb4 <__umodsi3>
811141e8:	b80b883a 	mov	r5,r23
811141ec:	9009883a 	mov	r4,r18
811141f0:	d8800115 	stw	r2,4(sp)
811141f4:	1125b500 	call	81125b50 <__udivsi3>
811141f8:	ac07883a 	add	r3,r21,r16
811141fc:	18c00043 	ldbu	r3,1(r3)
81114200:	880b883a 	mov	r5,r17
81114204:	000d883a 	mov	r6,zero
81114208:	1a00010c 	andi	r8,r3,4
8111420c:	0009883a 	mov	r4,zero
81114210:	02800044 	movi	r10,1
81114214:	027fffc4 	movi	r9,-1
81114218:	d9c00117 	ldw	r7,4(sp)
8111421c:	40000e26 	beq	r8,zero,81114258 <_strtol_r+0x120>
81114220:	843ff404 	addi	r16,r16,-48
81114224:	8580120e 	bge	r16,r22,81114270 <_strtol_r+0x138>
81114228:	32400526 	beq	r6,r9,81114240 <_strtol_r+0x108>
8111422c:	11002536 	bltu	r2,r4,811142c4 <_strtol_r+0x18c>
81114230:	20802326 	beq	r4,r2,811142c0 <_strtol_r+0x188>
81114234:	25c9383a 	mul	r4,r4,r23
81114238:	01800044 	movi	r6,1
8111423c:	8109883a 	add	r4,r16,r4
81114240:	2c000003 	ldbu	r16,0(r5)
81114244:	29400044 	addi	r5,r5,1
81114248:	ac07883a 	add	r3,r21,r16
8111424c:	18c00043 	ldbu	r3,1(r3)
81114250:	1a00010c 	andi	r8,r3,4
81114254:	403ff21e 	bne	r8,zero,81114220 <__reset+0xfb0f4220>
81114258:	18c000cc 	andi	r3,r3,3
8111425c:	18000426 	beq	r3,zero,81114270 <_strtol_r+0x138>
81114260:	1a801a26 	beq	r3,r10,811142cc <_strtol_r+0x194>
81114264:	00c015c4 	movi	r3,87
81114268:	80e1c83a 	sub	r16,r16,r3
8111426c:	85bfee16 	blt	r16,r22,81114228 <__reset+0xfb0f4228>
81114270:	00bfffc4 	movi	r2,-1
81114274:	30801e26 	beq	r6,r2,811142f0 <_strtol_r+0x1b8>
81114278:	e0001b1e 	bne	fp,zero,811142e8 <_strtol_r+0x1b0>
8111427c:	2005883a 	mov	r2,r4
81114280:	98000326 	beq	r19,zero,81114290 <_strtol_r+0x158>
81114284:	3000211e 	bne	r6,zero,8111430c <_strtol_r+0x1d4>
81114288:	a00b883a 	mov	r5,r20
8111428c:	99400015 	stw	r5,0(r19)
81114290:	dfc00b17 	ldw	ra,44(sp)
81114294:	df000a17 	ldw	fp,40(sp)
81114298:	ddc00917 	ldw	r23,36(sp)
8111429c:	dd800817 	ldw	r22,32(sp)
811142a0:	dd400717 	ldw	r21,28(sp)
811142a4:	dd000617 	ldw	r20,24(sp)
811142a8:	dcc00517 	ldw	r19,20(sp)
811142ac:	dc800417 	ldw	r18,16(sp)
811142b0:	dc400317 	ldw	r17,12(sp)
811142b4:	dc000217 	ldw	r16,8(sp)
811142b8:	dec00c04 	addi	sp,sp,48
811142bc:	f800283a 	ret
811142c0:	3c3fdc0e 	bge	r7,r16,81114234 <__reset+0xfb0f4234>
811142c4:	01bfffc4 	movi	r6,-1
811142c8:	003fdd06 	br	81114240 <__reset+0xfb0f4240>
811142cc:	00c00dc4 	movi	r3,55
811142d0:	003fe506 	br	81114268 <__reset+0xfb0f4268>
811142d4:	00800c04 	movi	r2,48
811142d8:	80801626 	beq	r16,r2,81114334 <_strtol_r+0x1fc>
811142dc:	05800284 	movi	r22,10
811142e0:	b02f883a 	mov	r23,r22
811142e4:	003fba06 	br	811141d0 <__reset+0xfb0f41d0>
811142e8:	0109c83a 	sub	r4,zero,r4
811142ec:	003fe306 	br	8111427c <__reset+0xfb0f427c>
811142f0:	d9000017 	ldw	r4,0(sp)
811142f4:	00c00884 	movi	r3,34
811142f8:	e005003a 	cmpeq	r2,fp,zero
811142fc:	20c00015 	stw	r3,0(r4)
81114300:	00e00034 	movhi	r3,32768
81114304:	1885c83a 	sub	r2,r3,r2
81114308:	983fe126 	beq	r19,zero,81114290 <__reset+0xfb0f4290>
8111430c:	297fffc4 	addi	r5,r5,-1
81114310:	003fde06 	br	8111428c <__reset+0xfb0f428c>
81114314:	1c400084 	addi	r17,r3,2
81114318:	1c000043 	ldbu	r16,1(r3)
8111431c:	07000044 	movi	fp,1
81114320:	003fa706 	br	811141c0 <__reset+0xfb0f41c0>
81114324:	1c400084 	addi	r17,r3,2
81114328:	1c000043 	ldbu	r16,1(r3)
8111432c:	0039883a 	mov	fp,zero
81114330:	003fa306 	br	811141c0 <__reset+0xfb0f41c0>
81114334:	88800003 	ldbu	r2,0(r17)
81114338:	00c01604 	movi	r3,88
8111433c:	108037cc 	andi	r2,r2,223
81114340:	10c00826 	beq	r2,r3,81114364 <_strtol_r+0x22c>
81114344:	05800204 	movi	r22,8
81114348:	003fa006 	br	811141cc <__reset+0xfb0f41cc>
8111434c:	00800c04 	movi	r2,48
81114350:	80bf9e1e 	bne	r16,r2,811141cc <__reset+0xfb0f41cc>
81114354:	88800003 	ldbu	r2,0(r17)
81114358:	00c01604 	movi	r3,88
8111435c:	108037cc 	andi	r2,r2,223
81114360:	10ff9a1e 	bne	r2,r3,811141cc <__reset+0xfb0f41cc>
81114364:	05c00404 	movi	r23,16
81114368:	8c000043 	ldbu	r16,1(r17)
8111436c:	b82d883a 	mov	r22,r23
81114370:	8c400084 	addi	r17,r17,2
81114374:	003f9606 	br	811141d0 <__reset+0xfb0f41d0>

81114378 <strtol>:
81114378:	00a04534 	movhi	r2,33044
8111437c:	1086aa04 	addi	r2,r2,6824
81114380:	300f883a 	mov	r7,r6
81114384:	280d883a 	mov	r6,r5
81114388:	200b883a 	mov	r5,r4
8111438c:	11000017 	ldw	r4,0(r2)
81114390:	11141381 	jmpi	81114138 <_strtol_r>

81114394 <___svfprintf_internal_r>:
81114394:	deffb704 	addi	sp,sp,-292
81114398:	de00012e 	bgeu	sp,et,811143a0 <___svfprintf_internal_r+0xc>
8111439c:	003b68fa 	trap	3
811143a0:	dfc04815 	stw	ra,288(sp)
811143a4:	ddc04615 	stw	r23,280(sp)
811143a8:	d9402c15 	stw	r5,176(sp)
811143ac:	d9003915 	stw	r4,228(sp)
811143b0:	302f883a 	mov	r23,r6
811143b4:	d9c02d15 	stw	r7,180(sp)
811143b8:	df004715 	stw	fp,284(sp)
811143bc:	dd804515 	stw	r22,276(sp)
811143c0:	dd404415 	stw	r21,272(sp)
811143c4:	dd004315 	stw	r20,268(sp)
811143c8:	dcc04215 	stw	r19,264(sp)
811143cc:	dc804115 	stw	r18,260(sp)
811143d0:	dc404015 	stw	r17,256(sp)
811143d4:	dc003f15 	stw	r16,252(sp)
811143d8:	111d11c0 	call	8111d11c <_localeconv_r>
811143dc:	10800017 	ldw	r2,0(r2)
811143e0:	1009883a 	mov	r4,r2
811143e4:	d8803415 	stw	r2,208(sp)
811143e8:	111405c0 	call	8111405c <strlen>
811143ec:	d8c02c17 	ldw	r3,176(sp)
811143f0:	d8803815 	stw	r2,224(sp)
811143f4:	1880030b 	ldhu	r2,12(r3)
811143f8:	1080200c 	andi	r2,r2,128
811143fc:	10000226 	beq	r2,zero,81114408 <___svfprintf_internal_r+0x74>
81114400:	18800417 	ldw	r2,16(r3)
81114404:	10067f26 	beq	r2,zero,81115e04 <___svfprintf_internal_r+0x1a70>
81114408:	dcc03917 	ldw	r19,228(sp)
8111440c:	d8c00404 	addi	r3,sp,16
81114410:	05604534 	movhi	r21,33044
81114414:	d9001e04 	addi	r4,sp,120
81114418:	ad7db084 	addi	r21,r21,-2366
8111441c:	d8c01e15 	stw	r3,120(sp)
81114420:	d8002015 	stw	zero,128(sp)
81114424:	d8001f15 	stw	zero,124(sp)
81114428:	d8003315 	stw	zero,204(sp)
8111442c:	d8003615 	stw	zero,216(sp)
81114430:	d8003715 	stw	zero,220(sp)
81114434:	1811883a 	mov	r8,r3
81114438:	d8003a15 	stw	zero,232(sp)
8111443c:	d8003b15 	stw	zero,236(sp)
81114440:	d8002f15 	stw	zero,188(sp)
81114444:	d9002815 	stw	r4,160(sp)
81114448:	b8800007 	ldb	r2,0(r23)
8111444c:	10026726 	beq	r2,zero,81114dec <___svfprintf_internal_r+0xa58>
81114450:	00c00944 	movi	r3,37
81114454:	b821883a 	mov	r16,r23
81114458:	10c0021e 	bne	r2,r3,81114464 <___svfprintf_internal_r+0xd0>
8111445c:	00001406 	br	811144b0 <___svfprintf_internal_r+0x11c>
81114460:	10c00326 	beq	r2,r3,81114470 <___svfprintf_internal_r+0xdc>
81114464:	84000044 	addi	r16,r16,1
81114468:	80800007 	ldb	r2,0(r16)
8111446c:	103ffc1e 	bne	r2,zero,81114460 <__reset+0xfb0f4460>
81114470:	85e3c83a 	sub	r17,r16,r23
81114474:	88000e26 	beq	r17,zero,811144b0 <___svfprintf_internal_r+0x11c>
81114478:	d8c02017 	ldw	r3,128(sp)
8111447c:	d8801f17 	ldw	r2,124(sp)
81114480:	45c00015 	stw	r23,0(r8)
81114484:	1c47883a 	add	r3,r3,r17
81114488:	10800044 	addi	r2,r2,1
8111448c:	d8c02015 	stw	r3,128(sp)
81114490:	44400115 	stw	r17,4(r8)
81114494:	d8801f15 	stw	r2,124(sp)
81114498:	00c001c4 	movi	r3,7
8111449c:	18809716 	blt	r3,r2,811146fc <___svfprintf_internal_r+0x368>
811144a0:	42000204 	addi	r8,r8,8
811144a4:	d9402f17 	ldw	r5,188(sp)
811144a8:	2c4b883a 	add	r5,r5,r17
811144ac:	d9402f15 	stw	r5,188(sp)
811144b0:	80800007 	ldb	r2,0(r16)
811144b4:	10009826 	beq	r2,zero,81114718 <___svfprintf_internal_r+0x384>
811144b8:	84400047 	ldb	r17,1(r16)
811144bc:	00bfffc4 	movi	r2,-1
811144c0:	85c00044 	addi	r23,r16,1
811144c4:	d8002785 	stb	zero,158(sp)
811144c8:	0007883a 	mov	r3,zero
811144cc:	000f883a 	mov	r7,zero
811144d0:	d8802915 	stw	r2,164(sp)
811144d4:	d8003115 	stw	zero,196(sp)
811144d8:	0025883a 	mov	r18,zero
811144dc:	01401604 	movi	r5,88
811144e0:	01800244 	movi	r6,9
811144e4:	02800a84 	movi	r10,42
811144e8:	02401b04 	movi	r9,108
811144ec:	bdc00044 	addi	r23,r23,1
811144f0:	88bff804 	addi	r2,r17,-32
811144f4:	2882f036 	bltu	r5,r2,811150b8 <___svfprintf_internal_r+0xd24>
811144f8:	100490ba 	slli	r2,r2,2
811144fc:	01204474 	movhi	r4,33041
81114500:	21114404 	addi	r4,r4,17680
81114504:	1105883a 	add	r2,r2,r4
81114508:	10800017 	ldw	r2,0(r2)
8111450c:	1000683a 	jmp	r2
81114510:	81115020 	cmpeqi	r4,r16,17728
81114514:	811150b8 	rdprs	r4,r16,17730
81114518:	811150b8 	rdprs	r4,r16,17730
8111451c:	81115014 	ori	r4,r16,17728
81114520:	811150b8 	rdprs	r4,r16,17730
81114524:	811150b8 	rdprs	r4,r16,17730
81114528:	811150b8 	rdprs	r4,r16,17730
8111452c:	811150b8 	rdprs	r4,r16,17730
81114530:	811150b8 	rdprs	r4,r16,17730
81114534:	811150b8 	rdprs	r4,r16,17730
81114538:	81114774 	orhi	r4,r16,17693
8111453c:	81114f50 	cmplti	r4,r16,17725
81114540:	811150b8 	rdprs	r4,r16,17730
81114544:	81114684 	addi	r4,r16,17690
81114548:	8111479c 	xori	r4,r16,17694
8111454c:	811150b8 	rdprs	r4,r16,17730
81114550:	81114810 	cmplti	r4,r16,17696
81114554:	811147dc 	xori	r4,r16,17695
81114558:	811147dc 	xori	r4,r16,17695
8111455c:	811147dc 	xori	r4,r16,17695
81114560:	811147dc 	xori	r4,r16,17695
81114564:	811147dc 	xori	r4,r16,17695
81114568:	811147dc 	xori	r4,r16,17695
8111456c:	811147dc 	xori	r4,r16,17695
81114570:	811147dc 	xori	r4,r16,17695
81114574:	811147dc 	xori	r4,r16,17695
81114578:	811150b8 	rdprs	r4,r16,17730
8111457c:	811150b8 	rdprs	r4,r16,17730
81114580:	811150b8 	rdprs	r4,r16,17730
81114584:	811150b8 	rdprs	r4,r16,17730
81114588:	811150b8 	rdprs	r4,r16,17730
8111458c:	811150b8 	rdprs	r4,r16,17730
81114590:	811150b8 	rdprs	r4,r16,17730
81114594:	811150b8 	rdprs	r4,r16,17730
81114598:	811150b8 	rdprs	r4,r16,17730
8111459c:	811150b8 	rdprs	r4,r16,17730
811145a0:	811148c8 	cmpgei	r4,r16,17699
811145a4:	8111481c 	xori	r4,r16,17696
811145a8:	811150b8 	rdprs	r4,r16,17730
811145ac:	8111481c 	xori	r4,r16,17696
811145b0:	811150b8 	rdprs	r4,r16,17730
811145b4:	811150b8 	rdprs	r4,r16,17730
811145b8:	811150b8 	rdprs	r4,r16,17730
811145bc:	811150b8 	rdprs	r4,r16,17730
811145c0:	811148bc 	xorhi	r4,r16,17698
811145c4:	811150b8 	rdprs	r4,r16,17730
811145c8:	811150b8 	rdprs	r4,r16,17730
811145cc:	81114984 	addi	r4,r16,17702
811145d0:	811150b8 	rdprs	r4,r16,17730
811145d4:	811150b8 	rdprs	r4,r16,17730
811145d8:	811150b8 	rdprs	r4,r16,17730
811145dc:	811150b8 	rdprs	r4,r16,17730
811145e0:	811150b8 	rdprs	r4,r16,17730
811145e4:	81114df4 	orhi	r4,r16,17719
811145e8:	811150b8 	rdprs	r4,r16,17730
811145ec:	811150b8 	rdprs	r4,r16,17730
811145f0:	81114e54 	ori	r4,r16,17721
811145f4:	811150b8 	rdprs	r4,r16,17730
811145f8:	811150b8 	rdprs	r4,r16,17730
811145fc:	811150b8 	rdprs	r4,r16,17730
81114600:	811150b8 	rdprs	r4,r16,17730
81114604:	811150b8 	rdprs	r4,r16,17730
81114608:	811150b8 	rdprs	r4,r16,17730
8111460c:	811150b8 	rdprs	r4,r16,17730
81114610:	811150b8 	rdprs	r4,r16,17730
81114614:	811150b8 	rdprs	r4,r16,17730
81114618:	811150b8 	rdprs	r4,r16,17730
8111461c:	81114f04 	addi	r4,r16,17724
81114620:	81115040 	call	88111504 <__reset+0x20f1504>
81114624:	8111481c 	xori	r4,r16,17696
81114628:	8111481c 	xori	r4,r16,17696
8111462c:	8111481c 	xori	r4,r16,17696
81114630:	81115094 	ori	r4,r16,17730
81114634:	81115040 	call	88111504 <__reset+0x20f1504>
81114638:	811150b8 	rdprs	r4,r16,17730
8111463c:	811150b8 	rdprs	r4,r16,17730
81114640:	81115050 	cmplti	r4,r16,17729
81114644:	811150b8 	rdprs	r4,r16,17730
81114648:	81115060 	cmpeqi	r4,r16,17729
8111464c:	81114f40 	call	881114f4 <__reset+0x20f14f4>
81114650:	81114690 	cmplti	r4,r16,17690
81114654:	81114f60 	cmpeqi	r4,r16,17725
81114658:	811150b8 	rdprs	r4,r16,17730
8111465c:	81114f6c 	andhi	r4,r16,17725
81114660:	811150b8 	rdprs	r4,r16,17730
81114664:	81114fc8 	cmpgei	r4,r16,17727
81114668:	811150b8 	rdprs	r4,r16,17730
8111466c:	811150b8 	rdprs	r4,r16,17730
81114670:	81114fd8 	cmpnei	r4,r16,17727
81114674:	d9003117 	ldw	r4,196(sp)
81114678:	d8802d15 	stw	r2,180(sp)
8111467c:	0109c83a 	sub	r4,zero,r4
81114680:	d9003115 	stw	r4,196(sp)
81114684:	94800114 	ori	r18,r18,4
81114688:	bc400007 	ldb	r17,0(r23)
8111468c:	003f9706 	br	811144ec <__reset+0xfb0f44ec>
81114690:	00800c04 	movi	r2,48
81114694:	d9002d17 	ldw	r4,180(sp)
81114698:	d9402917 	ldw	r5,164(sp)
8111469c:	d8802705 	stb	r2,156(sp)
811146a0:	00801e04 	movi	r2,120
811146a4:	d8802745 	stb	r2,157(sp)
811146a8:	d8002785 	stb	zero,158(sp)
811146ac:	20c00104 	addi	r3,r4,4
811146b0:	25000017 	ldw	r20,0(r4)
811146b4:	002d883a 	mov	r22,zero
811146b8:	90800094 	ori	r2,r18,2
811146bc:	28028616 	blt	r5,zero,811150d8 <___svfprintf_internal_r+0xd44>
811146c0:	00bfdfc4 	movi	r2,-129
811146c4:	90a4703a 	and	r18,r18,r2
811146c8:	d8c02d15 	stw	r3,180(sp)
811146cc:	94800094 	ori	r18,r18,2
811146d0:	a002731e 	bne	r20,zero,811150a0 <___svfprintf_internal_r+0xd0c>
811146d4:	00a04534 	movhi	r2,33044
811146d8:	10bda904 	addi	r2,r2,-2396
811146dc:	d8803a15 	stw	r2,232(sp)
811146e0:	04401e04 	movi	r17,120
811146e4:	d8c02917 	ldw	r3,164(sp)
811146e8:	0039883a 	mov	fp,zero
811146ec:	1801d526 	beq	r3,zero,81114e44 <___svfprintf_internal_r+0xab0>
811146f0:	0029883a 	mov	r20,zero
811146f4:	002d883a 	mov	r22,zero
811146f8:	0001f106 	br	81114ec0 <___svfprintf_internal_r+0xb2c>
811146fc:	d9402c17 	ldw	r5,176(sp)
81114700:	d9801e04 	addi	r6,sp,120
81114704:	9809883a 	mov	r4,r19
81114708:	1120e540 	call	81120e54 <__ssprint_r>
8111470c:	1000081e 	bne	r2,zero,81114730 <___svfprintf_internal_r+0x39c>
81114710:	da000404 	addi	r8,sp,16
81114714:	003f6306 	br	811144a4 <__reset+0xfb0f44a4>
81114718:	d8802017 	ldw	r2,128(sp)
8111471c:	10000426 	beq	r2,zero,81114730 <___svfprintf_internal_r+0x39c>
81114720:	d9402c17 	ldw	r5,176(sp)
81114724:	d9003917 	ldw	r4,228(sp)
81114728:	d9801e04 	addi	r6,sp,120
8111472c:	1120e540 	call	81120e54 <__ssprint_r>
81114730:	d8802c17 	ldw	r2,176(sp)
81114734:	10c0030b 	ldhu	r3,12(r2)
81114738:	d8802f17 	ldw	r2,188(sp)
8111473c:	18c0100c 	andi	r3,r3,64
81114740:	1805f51e 	bne	r3,zero,81115f18 <___svfprintf_internal_r+0x1b84>
81114744:	dfc04817 	ldw	ra,288(sp)
81114748:	df004717 	ldw	fp,284(sp)
8111474c:	ddc04617 	ldw	r23,280(sp)
81114750:	dd804517 	ldw	r22,276(sp)
81114754:	dd404417 	ldw	r21,272(sp)
81114758:	dd004317 	ldw	r20,268(sp)
8111475c:	dcc04217 	ldw	r19,264(sp)
81114760:	dc804117 	ldw	r18,260(sp)
81114764:	dc404017 	ldw	r17,256(sp)
81114768:	dc003f17 	ldw	r16,252(sp)
8111476c:	dec04904 	addi	sp,sp,292
81114770:	f800283a 	ret
81114774:	d8802d17 	ldw	r2,180(sp)
81114778:	d9002d17 	ldw	r4,180(sp)
8111477c:	10800017 	ldw	r2,0(r2)
81114780:	d8803115 	stw	r2,196(sp)
81114784:	20800104 	addi	r2,r4,4
81114788:	d9003117 	ldw	r4,196(sp)
8111478c:	203fb916 	blt	r4,zero,81114674 <__reset+0xfb0f4674>
81114790:	d8802d15 	stw	r2,180(sp)
81114794:	bc400007 	ldb	r17,0(r23)
81114798:	003f5406 	br	811144ec <__reset+0xfb0f44ec>
8111479c:	bc400007 	ldb	r17,0(r23)
811147a0:	bac00044 	addi	r11,r23,1
811147a4:	8a873926 	beq	r17,r10,8111648c <___svfprintf_internal_r+0x20f8>
811147a8:	88bff404 	addi	r2,r17,-48
811147ac:	0009883a 	mov	r4,zero
811147b0:	30868836 	bltu	r6,r2,811161d4 <___svfprintf_internal_r+0x1e40>
811147b4:	5c400007 	ldb	r17,0(r11)
811147b8:	210002a4 	muli	r4,r4,10
811147bc:	5dc00044 	addi	r23,r11,1
811147c0:	b817883a 	mov	r11,r23
811147c4:	2089883a 	add	r4,r4,r2
811147c8:	88bff404 	addi	r2,r17,-48
811147cc:	30bff92e 	bgeu	r6,r2,811147b4 <__reset+0xfb0f47b4>
811147d0:	2005d716 	blt	r4,zero,81115f30 <___svfprintf_internal_r+0x1b9c>
811147d4:	d9002915 	stw	r4,164(sp)
811147d8:	003f4506 	br	811144f0 <__reset+0xfb0f44f0>
811147dc:	b809883a 	mov	r4,r23
811147e0:	d8003115 	stw	zero,196(sp)
811147e4:	88bff404 	addi	r2,r17,-48
811147e8:	0017883a 	mov	r11,zero
811147ec:	24400007 	ldb	r17,0(r4)
811147f0:	5ac002a4 	muli	r11,r11,10
811147f4:	bdc00044 	addi	r23,r23,1
811147f8:	b809883a 	mov	r4,r23
811147fc:	12d7883a 	add	r11,r2,r11
81114800:	88bff404 	addi	r2,r17,-48
81114804:	30bff92e 	bgeu	r6,r2,811147ec <__reset+0xfb0f47ec>
81114808:	dac03115 	stw	r11,196(sp)
8111480c:	003f3806 	br	811144f0 <__reset+0xfb0f44f0>
81114810:	94802014 	ori	r18,r18,128
81114814:	bc400007 	ldb	r17,0(r23)
81114818:	003f3406 	br	811144ec <__reset+0xfb0f44ec>
8111481c:	18c03fcc 	andi	r3,r3,255
81114820:	1807471e 	bne	r3,zero,81116540 <___svfprintf_internal_r+0x21ac>
81114824:	9080020c 	andi	r2,r18,8
81114828:	10047d26 	beq	r2,zero,81115a20 <___svfprintf_internal_r+0x168c>
8111482c:	d8c02d17 	ldw	r3,180(sp)
81114830:	d9002d17 	ldw	r4,180(sp)
81114834:	d9402d17 	ldw	r5,180(sp)
81114838:	18c00017 	ldw	r3,0(r3)
8111483c:	21000117 	ldw	r4,4(r4)
81114840:	29400204 	addi	r5,r5,8
81114844:	d8c03615 	stw	r3,216(sp)
81114848:	d9003715 	stw	r4,220(sp)
8111484c:	d9402d15 	stw	r5,180(sp)
81114850:	d9003617 	ldw	r4,216(sp)
81114854:	d9403717 	ldw	r5,220(sp)
81114858:	da003e15 	stw	r8,248(sp)
8111485c:	04000044 	movi	r16,1
81114860:	111ec680 	call	8111ec68 <__fpclassifyd>
81114864:	da003e17 	ldw	r8,248(sp)
81114868:	14044b1e 	bne	r2,r16,81115998 <___svfprintf_internal_r+0x1604>
8111486c:	d9003617 	ldw	r4,216(sp)
81114870:	d9403717 	ldw	r5,220(sp)
81114874:	000d883a 	mov	r6,zero
81114878:	000f883a 	mov	r7,zero
8111487c:	11271100 	call	81127110 <__ledf2>
81114880:	da003e17 	ldw	r8,248(sp)
81114884:	1005f316 	blt	r2,zero,81116054 <___svfprintf_internal_r+0x1cc0>
81114888:	df002783 	ldbu	fp,158(sp)
8111488c:	008011c4 	movi	r2,71
81114890:	1445590e 	bge	r2,r17,81115df8 <___svfprintf_internal_r+0x1a64>
81114894:	04204534 	movhi	r16,33044
81114898:	843da104 	addi	r16,r16,-2428
8111489c:	00c000c4 	movi	r3,3
811148a0:	00bfdfc4 	movi	r2,-129
811148a4:	d8c02a15 	stw	r3,168(sp)
811148a8:	90a4703a 	and	r18,r18,r2
811148ac:	d8c02e15 	stw	r3,184(sp)
811148b0:	d8002915 	stw	zero,164(sp)
811148b4:	d8003215 	stw	zero,200(sp)
811148b8:	00006606 	br	81114a54 <___svfprintf_internal_r+0x6c0>
811148bc:	94800214 	ori	r18,r18,8
811148c0:	bc400007 	ldb	r17,0(r23)
811148c4:	003f0906 	br	811144ec <__reset+0xfb0f44ec>
811148c8:	18c03fcc 	andi	r3,r3,255
811148cc:	1807181e 	bne	r3,zero,81116530 <___svfprintf_internal_r+0x219c>
811148d0:	94800414 	ori	r18,r18,16
811148d4:	9080080c 	andi	r2,r18,32
811148d8:	10039626 	beq	r2,zero,81115734 <___svfprintf_internal_r+0x13a0>
811148dc:	d9402d17 	ldw	r5,180(sp)
811148e0:	28800117 	ldw	r2,4(r5)
811148e4:	2d000017 	ldw	r20,0(r5)
811148e8:	29400204 	addi	r5,r5,8
811148ec:	d9402d15 	stw	r5,180(sp)
811148f0:	102d883a 	mov	r22,r2
811148f4:	10039816 	blt	r2,zero,81115758 <___svfprintf_internal_r+0x13c4>
811148f8:	d9402917 	ldw	r5,164(sp)
811148fc:	df002783 	ldbu	fp,158(sp)
81114900:	2803ab16 	blt	r5,zero,811157b0 <___svfprintf_internal_r+0x141c>
81114904:	00ffdfc4 	movi	r3,-129
81114908:	a584b03a 	or	r2,r20,r22
8111490c:	90e4703a 	and	r18,r18,r3
81114910:	10014a26 	beq	r2,zero,81114e3c <___svfprintf_internal_r+0xaa8>
81114914:	b0034b26 	beq	r22,zero,81115644 <___svfprintf_internal_r+0x12b0>
81114918:	dc402a15 	stw	r17,168(sp)
8111491c:	dc001e04 	addi	r16,sp,120
81114920:	b023883a 	mov	r17,r22
81114924:	402d883a 	mov	r22,r8
81114928:	a009883a 	mov	r4,r20
8111492c:	880b883a 	mov	r5,r17
81114930:	01800284 	movi	r6,10
81114934:	000f883a 	mov	r7,zero
81114938:	11255180 	call	81125518 <__umoddi3>
8111493c:	10800c04 	addi	r2,r2,48
81114940:	843fffc4 	addi	r16,r16,-1
81114944:	a009883a 	mov	r4,r20
81114948:	880b883a 	mov	r5,r17
8111494c:	80800005 	stb	r2,0(r16)
81114950:	01800284 	movi	r6,10
81114954:	000f883a 	mov	r7,zero
81114958:	1124f980 	call	81124f98 <__udivdi3>
8111495c:	1029883a 	mov	r20,r2
81114960:	10c4b03a 	or	r2,r2,r3
81114964:	1823883a 	mov	r17,r3
81114968:	103fef1e 	bne	r2,zero,81114928 <__reset+0xfb0f4928>
8111496c:	d8c02817 	ldw	r3,160(sp)
81114970:	dc402a17 	ldw	r17,168(sp)
81114974:	b011883a 	mov	r8,r22
81114978:	1c07c83a 	sub	r3,r3,r16
8111497c:	d8c02e15 	stw	r3,184(sp)
81114980:	00002e06 	br	81114a3c <___svfprintf_internal_r+0x6a8>
81114984:	18c03fcc 	andi	r3,r3,255
81114988:	1806e71e 	bne	r3,zero,81116528 <___svfprintf_internal_r+0x2194>
8111498c:	94800414 	ori	r18,r18,16
81114990:	9080080c 	andi	r2,r18,32
81114994:	1002d426 	beq	r2,zero,811154e8 <___svfprintf_internal_r+0x1154>
81114998:	d9402d17 	ldw	r5,180(sp)
8111499c:	d8c02917 	ldw	r3,164(sp)
811149a0:	d8002785 	stb	zero,158(sp)
811149a4:	28800204 	addi	r2,r5,8
811149a8:	2d000017 	ldw	r20,0(r5)
811149ac:	2d800117 	ldw	r22,4(r5)
811149b0:	18041516 	blt	r3,zero,81115a08 <___svfprintf_internal_r+0x1674>
811149b4:	013fdfc4 	movi	r4,-129
811149b8:	a586b03a 	or	r3,r20,r22
811149bc:	d8802d15 	stw	r2,180(sp)
811149c0:	9124703a 	and	r18,r18,r4
811149c4:	1802d51e 	bne	r3,zero,8111551c <___svfprintf_internal_r+0x1188>
811149c8:	d9402917 	ldw	r5,164(sp)
811149cc:	0039883a 	mov	fp,zero
811149d0:	2806be26 	beq	r5,zero,811164cc <___svfprintf_internal_r+0x2138>
811149d4:	0029883a 	mov	r20,zero
811149d8:	002d883a 	mov	r22,zero
811149dc:	dc001e04 	addi	r16,sp,120
811149e0:	a006d0fa 	srli	r3,r20,3
811149e4:	b008977a 	slli	r4,r22,29
811149e8:	b02cd0fa 	srli	r22,r22,3
811149ec:	a50001cc 	andi	r20,r20,7
811149f0:	a0800c04 	addi	r2,r20,48
811149f4:	843fffc4 	addi	r16,r16,-1
811149f8:	20e8b03a 	or	r20,r4,r3
811149fc:	80800005 	stb	r2,0(r16)
81114a00:	a586b03a 	or	r3,r20,r22
81114a04:	183ff61e 	bne	r3,zero,811149e0 <__reset+0xfb0f49e0>
81114a08:	90c0004c 	andi	r3,r18,1
81114a0c:	18013926 	beq	r3,zero,81114ef4 <___svfprintf_internal_r+0xb60>
81114a10:	10803fcc 	andi	r2,r2,255
81114a14:	1080201c 	xori	r2,r2,128
81114a18:	10bfe004 	addi	r2,r2,-128
81114a1c:	00c00c04 	movi	r3,48
81114a20:	10c13426 	beq	r2,r3,81114ef4 <___svfprintf_internal_r+0xb60>
81114a24:	80ffffc5 	stb	r3,-1(r16)
81114a28:	d8c02817 	ldw	r3,160(sp)
81114a2c:	80bfffc4 	addi	r2,r16,-1
81114a30:	1021883a 	mov	r16,r2
81114a34:	1887c83a 	sub	r3,r3,r2
81114a38:	d8c02e15 	stw	r3,184(sp)
81114a3c:	d8802e17 	ldw	r2,184(sp)
81114a40:	d9002917 	ldw	r4,164(sp)
81114a44:	1100010e 	bge	r2,r4,81114a4c <___svfprintf_internal_r+0x6b8>
81114a48:	2005883a 	mov	r2,r4
81114a4c:	d8802a15 	stw	r2,168(sp)
81114a50:	d8003215 	stw	zero,200(sp)
81114a54:	e7003fcc 	andi	fp,fp,255
81114a58:	e700201c 	xori	fp,fp,128
81114a5c:	e73fe004 	addi	fp,fp,-128
81114a60:	e0000326 	beq	fp,zero,81114a70 <___svfprintf_internal_r+0x6dc>
81114a64:	d8c02a17 	ldw	r3,168(sp)
81114a68:	18c00044 	addi	r3,r3,1
81114a6c:	d8c02a15 	stw	r3,168(sp)
81114a70:	90c0008c 	andi	r3,r18,2
81114a74:	d8c02b15 	stw	r3,172(sp)
81114a78:	18000326 	beq	r3,zero,81114a88 <___svfprintf_internal_r+0x6f4>
81114a7c:	d8c02a17 	ldw	r3,168(sp)
81114a80:	18c00084 	addi	r3,r3,2
81114a84:	d8c02a15 	stw	r3,168(sp)
81114a88:	90c0210c 	andi	r3,r18,132
81114a8c:	d8c03015 	stw	r3,192(sp)
81114a90:	1801a11e 	bne	r3,zero,81115118 <___svfprintf_internal_r+0xd84>
81114a94:	d9003117 	ldw	r4,196(sp)
81114a98:	d8c02a17 	ldw	r3,168(sp)
81114a9c:	20e9c83a 	sub	r20,r4,r3
81114aa0:	05019d0e 	bge	zero,r20,81115118 <___svfprintf_internal_r+0xd84>
81114aa4:	02400404 	movi	r9,16
81114aa8:	d8c02017 	ldw	r3,128(sp)
81114aac:	d8801f17 	ldw	r2,124(sp)
81114ab0:	4d051b0e 	bge	r9,r20,81115f20 <___svfprintf_internal_r+0x1b8c>
81114ab4:	01604534 	movhi	r5,33044
81114ab8:	297db484 	addi	r5,r5,-2350
81114abc:	dc403c15 	stw	r17,240(sp)
81114ac0:	d9403515 	stw	r5,212(sp)
81114ac4:	a023883a 	mov	r17,r20
81114ac8:	482d883a 	mov	r22,r9
81114acc:	9029883a 	mov	r20,r18
81114ad0:	070001c4 	movi	fp,7
81114ad4:	8025883a 	mov	r18,r16
81114ad8:	dc002c17 	ldw	r16,176(sp)
81114adc:	00000306 	br	81114aec <___svfprintf_internal_r+0x758>
81114ae0:	8c7ffc04 	addi	r17,r17,-16
81114ae4:	42000204 	addi	r8,r8,8
81114ae8:	b440130e 	bge	r22,r17,81114b38 <___svfprintf_internal_r+0x7a4>
81114aec:	01204534 	movhi	r4,33044
81114af0:	18c00404 	addi	r3,r3,16
81114af4:	10800044 	addi	r2,r2,1
81114af8:	213db484 	addi	r4,r4,-2350
81114afc:	41000015 	stw	r4,0(r8)
81114b00:	45800115 	stw	r22,4(r8)
81114b04:	d8c02015 	stw	r3,128(sp)
81114b08:	d8801f15 	stw	r2,124(sp)
81114b0c:	e0bff40e 	bge	fp,r2,81114ae0 <__reset+0xfb0f4ae0>
81114b10:	d9801e04 	addi	r6,sp,120
81114b14:	800b883a 	mov	r5,r16
81114b18:	9809883a 	mov	r4,r19
81114b1c:	1120e540 	call	81120e54 <__ssprint_r>
81114b20:	103f031e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81114b24:	8c7ffc04 	addi	r17,r17,-16
81114b28:	d8c02017 	ldw	r3,128(sp)
81114b2c:	d8801f17 	ldw	r2,124(sp)
81114b30:	da000404 	addi	r8,sp,16
81114b34:	b47fed16 	blt	r22,r17,81114aec <__reset+0xfb0f4aec>
81114b38:	9021883a 	mov	r16,r18
81114b3c:	a025883a 	mov	r18,r20
81114b40:	8829883a 	mov	r20,r17
81114b44:	dc403c17 	ldw	r17,240(sp)
81114b48:	d9403517 	ldw	r5,212(sp)
81114b4c:	a0c7883a 	add	r3,r20,r3
81114b50:	10800044 	addi	r2,r2,1
81114b54:	41400015 	stw	r5,0(r8)
81114b58:	45000115 	stw	r20,4(r8)
81114b5c:	d8c02015 	stw	r3,128(sp)
81114b60:	d8801f15 	stw	r2,124(sp)
81114b64:	010001c4 	movi	r4,7
81114b68:	20829f16 	blt	r4,r2,811155e8 <___svfprintf_internal_r+0x1254>
81114b6c:	df002787 	ldb	fp,158(sp)
81114b70:	42000204 	addi	r8,r8,8
81114b74:	e0000c26 	beq	fp,zero,81114ba8 <___svfprintf_internal_r+0x814>
81114b78:	d8801f17 	ldw	r2,124(sp)
81114b7c:	d9002784 	addi	r4,sp,158
81114b80:	18c00044 	addi	r3,r3,1
81114b84:	10800044 	addi	r2,r2,1
81114b88:	41000015 	stw	r4,0(r8)
81114b8c:	01000044 	movi	r4,1
81114b90:	41000115 	stw	r4,4(r8)
81114b94:	d8c02015 	stw	r3,128(sp)
81114b98:	d8801f15 	stw	r2,124(sp)
81114b9c:	010001c4 	movi	r4,7
81114ba0:	20823816 	blt	r4,r2,81115484 <___svfprintf_internal_r+0x10f0>
81114ba4:	42000204 	addi	r8,r8,8
81114ba8:	d8802b17 	ldw	r2,172(sp)
81114bac:	10000c26 	beq	r2,zero,81114be0 <___svfprintf_internal_r+0x84c>
81114bb0:	d8801f17 	ldw	r2,124(sp)
81114bb4:	d9002704 	addi	r4,sp,156
81114bb8:	18c00084 	addi	r3,r3,2
81114bbc:	10800044 	addi	r2,r2,1
81114bc0:	41000015 	stw	r4,0(r8)
81114bc4:	01000084 	movi	r4,2
81114bc8:	41000115 	stw	r4,4(r8)
81114bcc:	d8c02015 	stw	r3,128(sp)
81114bd0:	d8801f15 	stw	r2,124(sp)
81114bd4:	010001c4 	movi	r4,7
81114bd8:	20823216 	blt	r4,r2,811154a4 <___svfprintf_internal_r+0x1110>
81114bdc:	42000204 	addi	r8,r8,8
81114be0:	d9003017 	ldw	r4,192(sp)
81114be4:	00802004 	movi	r2,128
81114be8:	20819726 	beq	r4,r2,81115248 <___svfprintf_internal_r+0xeb4>
81114bec:	d9402917 	ldw	r5,164(sp)
81114bf0:	d8802e17 	ldw	r2,184(sp)
81114bf4:	28adc83a 	sub	r22,r5,r2
81114bf8:	05802f0e 	bge	zero,r22,81114cb8 <___svfprintf_internal_r+0x924>
81114bfc:	07000404 	movi	fp,16
81114c00:	d8801f17 	ldw	r2,124(sp)
81114c04:	e583c00e 	bge	fp,r22,81115b08 <___svfprintf_internal_r+0x1774>
81114c08:	01604534 	movhi	r5,33044
81114c0c:	297db084 	addi	r5,r5,-2366
81114c10:	dc402915 	stw	r17,164(sp)
81114c14:	d9402b15 	stw	r5,172(sp)
81114c18:	b023883a 	mov	r17,r22
81114c1c:	050001c4 	movi	r20,7
81114c20:	902d883a 	mov	r22,r18
81114c24:	8025883a 	mov	r18,r16
81114c28:	dc002c17 	ldw	r16,176(sp)
81114c2c:	00000306 	br	81114c3c <___svfprintf_internal_r+0x8a8>
81114c30:	8c7ffc04 	addi	r17,r17,-16
81114c34:	42000204 	addi	r8,r8,8
81114c38:	e440110e 	bge	fp,r17,81114c80 <___svfprintf_internal_r+0x8ec>
81114c3c:	18c00404 	addi	r3,r3,16
81114c40:	10800044 	addi	r2,r2,1
81114c44:	45400015 	stw	r21,0(r8)
81114c48:	47000115 	stw	fp,4(r8)
81114c4c:	d8c02015 	stw	r3,128(sp)
81114c50:	d8801f15 	stw	r2,124(sp)
81114c54:	a0bff60e 	bge	r20,r2,81114c30 <__reset+0xfb0f4c30>
81114c58:	d9801e04 	addi	r6,sp,120
81114c5c:	800b883a 	mov	r5,r16
81114c60:	9809883a 	mov	r4,r19
81114c64:	1120e540 	call	81120e54 <__ssprint_r>
81114c68:	103eb11e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81114c6c:	8c7ffc04 	addi	r17,r17,-16
81114c70:	d8c02017 	ldw	r3,128(sp)
81114c74:	d8801f17 	ldw	r2,124(sp)
81114c78:	da000404 	addi	r8,sp,16
81114c7c:	e47fef16 	blt	fp,r17,81114c3c <__reset+0xfb0f4c3c>
81114c80:	9021883a 	mov	r16,r18
81114c84:	b025883a 	mov	r18,r22
81114c88:	882d883a 	mov	r22,r17
81114c8c:	dc402917 	ldw	r17,164(sp)
81114c90:	d9002b17 	ldw	r4,172(sp)
81114c94:	1d87883a 	add	r3,r3,r22
81114c98:	10800044 	addi	r2,r2,1
81114c9c:	41000015 	stw	r4,0(r8)
81114ca0:	45800115 	stw	r22,4(r8)
81114ca4:	d8c02015 	stw	r3,128(sp)
81114ca8:	d8801f15 	stw	r2,124(sp)
81114cac:	010001c4 	movi	r4,7
81114cb0:	2081ec16 	blt	r4,r2,81115464 <___svfprintf_internal_r+0x10d0>
81114cb4:	42000204 	addi	r8,r8,8
81114cb8:	9080400c 	andi	r2,r18,256
81114cbc:	1001181e 	bne	r2,zero,81115120 <___svfprintf_internal_r+0xd8c>
81114cc0:	d9402e17 	ldw	r5,184(sp)
81114cc4:	d8801f17 	ldw	r2,124(sp)
81114cc8:	44000015 	stw	r16,0(r8)
81114ccc:	1947883a 	add	r3,r3,r5
81114cd0:	10800044 	addi	r2,r2,1
81114cd4:	41400115 	stw	r5,4(r8)
81114cd8:	d8c02015 	stw	r3,128(sp)
81114cdc:	d8801f15 	stw	r2,124(sp)
81114ce0:	010001c4 	movi	r4,7
81114ce4:	2081d116 	blt	r4,r2,8111542c <___svfprintf_internal_r+0x1098>
81114ce8:	42000204 	addi	r8,r8,8
81114cec:	9480010c 	andi	r18,r18,4
81114cf0:	90003226 	beq	r18,zero,81114dbc <___svfprintf_internal_r+0xa28>
81114cf4:	d9403117 	ldw	r5,196(sp)
81114cf8:	d8802a17 	ldw	r2,168(sp)
81114cfc:	28a1c83a 	sub	r16,r5,r2
81114d00:	04002e0e 	bge	zero,r16,81114dbc <___svfprintf_internal_r+0xa28>
81114d04:	04400404 	movi	r17,16
81114d08:	d8801f17 	ldw	r2,124(sp)
81114d0c:	8c04b90e 	bge	r17,r16,81115ff4 <___svfprintf_internal_r+0x1c60>
81114d10:	01604534 	movhi	r5,33044
81114d14:	297db484 	addi	r5,r5,-2350
81114d18:	d9403515 	stw	r5,212(sp)
81114d1c:	048001c4 	movi	r18,7
81114d20:	dd002c17 	ldw	r20,176(sp)
81114d24:	00000306 	br	81114d34 <___svfprintf_internal_r+0x9a0>
81114d28:	843ffc04 	addi	r16,r16,-16
81114d2c:	42000204 	addi	r8,r8,8
81114d30:	8c00130e 	bge	r17,r16,81114d80 <___svfprintf_internal_r+0x9ec>
81114d34:	01204534 	movhi	r4,33044
81114d38:	18c00404 	addi	r3,r3,16
81114d3c:	10800044 	addi	r2,r2,1
81114d40:	213db484 	addi	r4,r4,-2350
81114d44:	41000015 	stw	r4,0(r8)
81114d48:	44400115 	stw	r17,4(r8)
81114d4c:	d8c02015 	stw	r3,128(sp)
81114d50:	d8801f15 	stw	r2,124(sp)
81114d54:	90bff40e 	bge	r18,r2,81114d28 <__reset+0xfb0f4d28>
81114d58:	d9801e04 	addi	r6,sp,120
81114d5c:	a00b883a 	mov	r5,r20
81114d60:	9809883a 	mov	r4,r19
81114d64:	1120e540 	call	81120e54 <__ssprint_r>
81114d68:	103e711e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81114d6c:	843ffc04 	addi	r16,r16,-16
81114d70:	d8c02017 	ldw	r3,128(sp)
81114d74:	d8801f17 	ldw	r2,124(sp)
81114d78:	da000404 	addi	r8,sp,16
81114d7c:	8c3fed16 	blt	r17,r16,81114d34 <__reset+0xfb0f4d34>
81114d80:	d9403517 	ldw	r5,212(sp)
81114d84:	1c07883a 	add	r3,r3,r16
81114d88:	10800044 	addi	r2,r2,1
81114d8c:	41400015 	stw	r5,0(r8)
81114d90:	44000115 	stw	r16,4(r8)
81114d94:	d8c02015 	stw	r3,128(sp)
81114d98:	d8801f15 	stw	r2,124(sp)
81114d9c:	010001c4 	movi	r4,7
81114da0:	2080060e 	bge	r4,r2,81114dbc <___svfprintf_internal_r+0xa28>
81114da4:	d9402c17 	ldw	r5,176(sp)
81114da8:	d9801e04 	addi	r6,sp,120
81114dac:	9809883a 	mov	r4,r19
81114db0:	1120e540 	call	81120e54 <__ssprint_r>
81114db4:	103e5e1e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81114db8:	d8c02017 	ldw	r3,128(sp)
81114dbc:	d8803117 	ldw	r2,196(sp)
81114dc0:	d9002a17 	ldw	r4,168(sp)
81114dc4:	1100010e 	bge	r2,r4,81114dcc <___svfprintf_internal_r+0xa38>
81114dc8:	2005883a 	mov	r2,r4
81114dcc:	d9402f17 	ldw	r5,188(sp)
81114dd0:	288b883a 	add	r5,r5,r2
81114dd4:	d9402f15 	stw	r5,188(sp)
81114dd8:	18019c1e 	bne	r3,zero,8111544c <___svfprintf_internal_r+0x10b8>
81114ddc:	b8800007 	ldb	r2,0(r23)
81114de0:	d8001f15 	stw	zero,124(sp)
81114de4:	da000404 	addi	r8,sp,16
81114de8:	103d991e 	bne	r2,zero,81114450 <__reset+0xfb0f4450>
81114dec:	b821883a 	mov	r16,r23
81114df0:	003daf06 	br	811144b0 <__reset+0xfb0f44b0>
81114df4:	18c03fcc 	andi	r3,r3,255
81114df8:	1805c71e 	bne	r3,zero,81116518 <___svfprintf_internal_r+0x2184>
81114dfc:	94800414 	ori	r18,r18,16
81114e00:	9080080c 	andi	r2,r18,32
81114e04:	10020126 	beq	r2,zero,8111560c <___svfprintf_internal_r+0x1278>
81114e08:	d8802d17 	ldw	r2,180(sp)
81114e0c:	d9002917 	ldw	r4,164(sp)
81114e10:	d8002785 	stb	zero,158(sp)
81114e14:	10c00204 	addi	r3,r2,8
81114e18:	15000017 	ldw	r20,0(r2)
81114e1c:	15800117 	ldw	r22,4(r2)
81114e20:	20038e16 	blt	r4,zero,81115c5c <___svfprintf_internal_r+0x18c8>
81114e24:	013fdfc4 	movi	r4,-129
81114e28:	a584b03a 	or	r2,r20,r22
81114e2c:	d8c02d15 	stw	r3,180(sp)
81114e30:	9124703a 	and	r18,r18,r4
81114e34:	0039883a 	mov	fp,zero
81114e38:	103eb61e 	bne	r2,zero,81114914 <__reset+0xfb0f4914>
81114e3c:	d8802917 	ldw	r2,164(sp)
81114e40:	1002c81e 	bne	r2,zero,81115964 <___svfprintf_internal_r+0x15d0>
81114e44:	d8002915 	stw	zero,164(sp)
81114e48:	d8002e15 	stw	zero,184(sp)
81114e4c:	dc001e04 	addi	r16,sp,120
81114e50:	003efa06 	br	81114a3c <__reset+0xfb0f4a3c>
81114e54:	18c03fcc 	andi	r3,r3,255
81114e58:	1805ad1e 	bne	r3,zero,81116510 <___svfprintf_internal_r+0x217c>
81114e5c:	01604534 	movhi	r5,33044
81114e60:	297da404 	addi	r5,r5,-2416
81114e64:	d9403a15 	stw	r5,232(sp)
81114e68:	9080080c 	andi	r2,r18,32
81114e6c:	10006126 	beq	r2,zero,81114ff4 <___svfprintf_internal_r+0xc60>
81114e70:	d8802d17 	ldw	r2,180(sp)
81114e74:	15000017 	ldw	r20,0(r2)
81114e78:	15800117 	ldw	r22,4(r2)
81114e7c:	10800204 	addi	r2,r2,8
81114e80:	d8802d15 	stw	r2,180(sp)
81114e84:	9080004c 	andi	r2,r18,1
81114e88:	10018e26 	beq	r2,zero,811154c4 <___svfprintf_internal_r+0x1130>
81114e8c:	a584b03a 	or	r2,r20,r22
81114e90:	10030926 	beq	r2,zero,81115ab8 <___svfprintf_internal_r+0x1724>
81114e94:	d8c02917 	ldw	r3,164(sp)
81114e98:	00800c04 	movi	r2,48
81114e9c:	d8802705 	stb	r2,156(sp)
81114ea0:	dc402745 	stb	r17,157(sp)
81114ea4:	d8002785 	stb	zero,158(sp)
81114ea8:	90800094 	ori	r2,r18,2
81114eac:	18048716 	blt	r3,zero,811160cc <___svfprintf_internal_r+0x1d38>
81114eb0:	00bfdfc4 	movi	r2,-129
81114eb4:	90a4703a 	and	r18,r18,r2
81114eb8:	94800094 	ori	r18,r18,2
81114ebc:	0039883a 	mov	fp,zero
81114ec0:	d9003a17 	ldw	r4,232(sp)
81114ec4:	dc001e04 	addi	r16,sp,120
81114ec8:	a08003cc 	andi	r2,r20,15
81114ecc:	b006973a 	slli	r3,r22,28
81114ed0:	2085883a 	add	r2,r4,r2
81114ed4:	a028d13a 	srli	r20,r20,4
81114ed8:	10800003 	ldbu	r2,0(r2)
81114edc:	b02cd13a 	srli	r22,r22,4
81114ee0:	843fffc4 	addi	r16,r16,-1
81114ee4:	1d28b03a 	or	r20,r3,r20
81114ee8:	80800005 	stb	r2,0(r16)
81114eec:	a584b03a 	or	r2,r20,r22
81114ef0:	103ff51e 	bne	r2,zero,81114ec8 <__reset+0xfb0f4ec8>
81114ef4:	d8c02817 	ldw	r3,160(sp)
81114ef8:	1c07c83a 	sub	r3,r3,r16
81114efc:	d8c02e15 	stw	r3,184(sp)
81114f00:	003ece06 	br	81114a3c <__reset+0xfb0f4a3c>
81114f04:	d8c02d17 	ldw	r3,180(sp)
81114f08:	d9002d17 	ldw	r4,180(sp)
81114f0c:	d8002785 	stb	zero,158(sp)
81114f10:	18800017 	ldw	r2,0(r3)
81114f14:	21000104 	addi	r4,r4,4
81114f18:	00c00044 	movi	r3,1
81114f1c:	d8c02a15 	stw	r3,168(sp)
81114f20:	d8801405 	stb	r2,80(sp)
81114f24:	d9002d15 	stw	r4,180(sp)
81114f28:	d8c02e15 	stw	r3,184(sp)
81114f2c:	d8002915 	stw	zero,164(sp)
81114f30:	d8003215 	stw	zero,200(sp)
81114f34:	dc001404 	addi	r16,sp,80
81114f38:	0039883a 	mov	fp,zero
81114f3c:	003ecc06 	br	81114a70 <__reset+0xfb0f4a70>
81114f40:	18c03fcc 	andi	r3,r3,255
81114f44:	183e9226 	beq	r3,zero,81114990 <__reset+0xfb0f4990>
81114f48:	d9c02785 	stb	r7,158(sp)
81114f4c:	003e9006 	br	81114990 <__reset+0xfb0f4990>
81114f50:	00c00044 	movi	r3,1
81114f54:	01c00ac4 	movi	r7,43
81114f58:	bc400007 	ldb	r17,0(r23)
81114f5c:	003d6306 	br	811144ec <__reset+0xfb0f44ec>
81114f60:	94800814 	ori	r18,r18,32
81114f64:	bc400007 	ldb	r17,0(r23)
81114f68:	003d6006 	br	811144ec <__reset+0xfb0f44ec>
81114f6c:	d8c02d17 	ldw	r3,180(sp)
81114f70:	d8002785 	stb	zero,158(sp)
81114f74:	1c000017 	ldw	r16,0(r3)
81114f78:	1d000104 	addi	r20,r3,4
81114f7c:	80040f26 	beq	r16,zero,81115fbc <___svfprintf_internal_r+0x1c28>
81114f80:	d9002917 	ldw	r4,164(sp)
81114f84:	2003dc16 	blt	r4,zero,81115ef8 <___svfprintf_internal_r+0x1b64>
81114f88:	200d883a 	mov	r6,r4
81114f8c:	000b883a 	mov	r5,zero
81114f90:	8009883a 	mov	r4,r16
81114f94:	da003e15 	stw	r8,248(sp)
81114f98:	111d3f80 	call	8111d3f8 <memchr>
81114f9c:	da003e17 	ldw	r8,248(sp)
81114fa0:	10045826 	beq	r2,zero,81116104 <___svfprintf_internal_r+0x1d70>
81114fa4:	1405c83a 	sub	r2,r2,r16
81114fa8:	d8802e15 	stw	r2,184(sp)
81114fac:	1003d816 	blt	r2,zero,81115f10 <___svfprintf_internal_r+0x1b7c>
81114fb0:	df002783 	ldbu	fp,158(sp)
81114fb4:	d8802a15 	stw	r2,168(sp)
81114fb8:	dd002d15 	stw	r20,180(sp)
81114fbc:	d8002915 	stw	zero,164(sp)
81114fc0:	d8003215 	stw	zero,200(sp)
81114fc4:	003ea306 	br	81114a54 <__reset+0xfb0f4a54>
81114fc8:	18c03fcc 	andi	r3,r3,255
81114fcc:	183f8c26 	beq	r3,zero,81114e00 <__reset+0xfb0f4e00>
81114fd0:	d9c02785 	stb	r7,158(sp)
81114fd4:	003f8a06 	br	81114e00 <__reset+0xfb0f4e00>
81114fd8:	18c03fcc 	andi	r3,r3,255
81114fdc:	1805631e 	bne	r3,zero,8111656c <___svfprintf_internal_r+0x21d8>
81114fe0:	01604534 	movhi	r5,33044
81114fe4:	297da904 	addi	r5,r5,-2396
81114fe8:	d9403a15 	stw	r5,232(sp)
81114fec:	9080080c 	andi	r2,r18,32
81114ff0:	103f9f1e 	bne	r2,zero,81114e70 <__reset+0xfb0f4e70>
81114ff4:	9080040c 	andi	r2,r18,16
81114ff8:	10029c26 	beq	r2,zero,81115a6c <___svfprintf_internal_r+0x16d8>
81114ffc:	d8c02d17 	ldw	r3,180(sp)
81115000:	002d883a 	mov	r22,zero
81115004:	1d000017 	ldw	r20,0(r3)
81115008:	18c00104 	addi	r3,r3,4
8111500c:	d8c02d15 	stw	r3,180(sp)
81115010:	003f9c06 	br	81114e84 <__reset+0xfb0f4e84>
81115014:	94800054 	ori	r18,r18,1
81115018:	bc400007 	ldb	r17,0(r23)
8111501c:	003d3306 	br	811144ec <__reset+0xfb0f44ec>
81115020:	38803fcc 	andi	r2,r7,255
81115024:	1080201c 	xori	r2,r2,128
81115028:	10bfe004 	addi	r2,r2,-128
8111502c:	1002971e 	bne	r2,zero,81115a8c <___svfprintf_internal_r+0x16f8>
81115030:	00c00044 	movi	r3,1
81115034:	01c00804 	movi	r7,32
81115038:	bc400007 	ldb	r17,0(r23)
8111503c:	003d2b06 	br	811144ec <__reset+0xfb0f44ec>
81115040:	18c03fcc 	andi	r3,r3,255
81115044:	183e2326 	beq	r3,zero,811148d4 <__reset+0xfb0f48d4>
81115048:	d9c02785 	stb	r7,158(sp)
8111504c:	003e2106 	br	811148d4 <__reset+0xfb0f48d4>
81115050:	bc400007 	ldb	r17,0(r23)
81115054:	8a430426 	beq	r17,r9,81115c68 <___svfprintf_internal_r+0x18d4>
81115058:	94800414 	ori	r18,r18,16
8111505c:	003d2306 	br	811144ec <__reset+0xfb0f44ec>
81115060:	18c03fcc 	andi	r3,r3,255
81115064:	18053f1e 	bne	r3,zero,81116564 <___svfprintf_internal_r+0x21d0>
81115068:	9080080c 	andi	r2,r18,32
8111506c:	10028926 	beq	r2,zero,81115a94 <___svfprintf_internal_r+0x1700>
81115070:	d9402d17 	ldw	r5,180(sp)
81115074:	d9002f17 	ldw	r4,188(sp)
81115078:	28800017 	ldw	r2,0(r5)
8111507c:	2007d7fa 	srai	r3,r4,31
81115080:	29400104 	addi	r5,r5,4
81115084:	d9402d15 	stw	r5,180(sp)
81115088:	11000015 	stw	r4,0(r2)
8111508c:	10c00115 	stw	r3,4(r2)
81115090:	003ced06 	br	81114448 <__reset+0xfb0f4448>
81115094:	94801014 	ori	r18,r18,64
81115098:	bc400007 	ldb	r17,0(r23)
8111509c:	003d1306 	br	811144ec <__reset+0xfb0f44ec>
811150a0:	01204534 	movhi	r4,33044
811150a4:	213da904 	addi	r4,r4,-2396
811150a8:	0039883a 	mov	fp,zero
811150ac:	d9003a15 	stw	r4,232(sp)
811150b0:	04401e04 	movi	r17,120
811150b4:	003f8206 	br	81114ec0 <__reset+0xfb0f4ec0>
811150b8:	18c03fcc 	andi	r3,r3,255
811150bc:	1805221e 	bne	r3,zero,81116548 <___svfprintf_internal_r+0x21b4>
811150c0:	883d9526 	beq	r17,zero,81114718 <__reset+0xfb0f4718>
811150c4:	00c00044 	movi	r3,1
811150c8:	d8c02a15 	stw	r3,168(sp)
811150cc:	dc401405 	stb	r17,80(sp)
811150d0:	d8002785 	stb	zero,158(sp)
811150d4:	003f9406 	br	81114f28 <__reset+0xfb0f4f28>
811150d8:	01204534 	movhi	r4,33044
811150dc:	213da904 	addi	r4,r4,-2396
811150e0:	d9003a15 	stw	r4,232(sp)
811150e4:	d8c02d15 	stw	r3,180(sp)
811150e8:	1025883a 	mov	r18,r2
811150ec:	04401e04 	movi	r17,120
811150f0:	a584b03a 	or	r2,r20,r22
811150f4:	1000fa1e 	bne	r2,zero,811154e0 <___svfprintf_internal_r+0x114c>
811150f8:	0039883a 	mov	fp,zero
811150fc:	00800084 	movi	r2,2
81115100:	10803fcc 	andi	r2,r2,255
81115104:	00c00044 	movi	r3,1
81115108:	10c21626 	beq	r2,r3,81115964 <___svfprintf_internal_r+0x15d0>
8111510c:	00c00084 	movi	r3,2
81115110:	10fe301e 	bne	r2,r3,811149d4 <__reset+0xfb0f49d4>
81115114:	003d7606 	br	811146f0 <__reset+0xfb0f46f0>
81115118:	d8c02017 	ldw	r3,128(sp)
8111511c:	003e9506 	br	81114b74 <__reset+0xfb0f4b74>
81115120:	00801944 	movi	r2,101
81115124:	14407c0e 	bge	r2,r17,81115318 <___svfprintf_internal_r+0xf84>
81115128:	d9003617 	ldw	r4,216(sp)
8111512c:	d9403717 	ldw	r5,220(sp)
81115130:	000d883a 	mov	r6,zero
81115134:	000f883a 	mov	r7,zero
81115138:	d8c03d15 	stw	r3,244(sp)
8111513c:	da003e15 	stw	r8,248(sp)
81115140:	1126fac0 	call	81126fac <__eqdf2>
81115144:	d8c03d17 	ldw	r3,244(sp)
81115148:	da003e17 	ldw	r8,248(sp)
8111514c:	1000f51e 	bne	r2,zero,81115524 <___svfprintf_internal_r+0x1190>
81115150:	d8801f17 	ldw	r2,124(sp)
81115154:	01204534 	movhi	r4,33044
81115158:	213db004 	addi	r4,r4,-2368
8111515c:	18c00044 	addi	r3,r3,1
81115160:	10800044 	addi	r2,r2,1
81115164:	41000015 	stw	r4,0(r8)
81115168:	01000044 	movi	r4,1
8111516c:	41000115 	stw	r4,4(r8)
81115170:	d8c02015 	stw	r3,128(sp)
81115174:	d8801f15 	stw	r2,124(sp)
81115178:	010001c4 	movi	r4,7
8111517c:	20826616 	blt	r4,r2,81115b18 <___svfprintf_internal_r+0x1784>
81115180:	42000204 	addi	r8,r8,8
81115184:	d8802617 	ldw	r2,152(sp)
81115188:	d9403317 	ldw	r5,204(sp)
8111518c:	11400216 	blt	r2,r5,81115198 <___svfprintf_internal_r+0xe04>
81115190:	9080004c 	andi	r2,r18,1
81115194:	103ed526 	beq	r2,zero,81114cec <__reset+0xfb0f4cec>
81115198:	d8803817 	ldw	r2,224(sp)
8111519c:	d9003417 	ldw	r4,208(sp)
811151a0:	d9403817 	ldw	r5,224(sp)
811151a4:	1887883a 	add	r3,r3,r2
811151a8:	d8801f17 	ldw	r2,124(sp)
811151ac:	41000015 	stw	r4,0(r8)
811151b0:	41400115 	stw	r5,4(r8)
811151b4:	10800044 	addi	r2,r2,1
811151b8:	d8c02015 	stw	r3,128(sp)
811151bc:	d8801f15 	stw	r2,124(sp)
811151c0:	010001c4 	movi	r4,7
811151c4:	2082af16 	blt	r4,r2,81115c84 <___svfprintf_internal_r+0x18f0>
811151c8:	42000204 	addi	r8,r8,8
811151cc:	d8803317 	ldw	r2,204(sp)
811151d0:	143fffc4 	addi	r16,r2,-1
811151d4:	043ec50e 	bge	zero,r16,81114cec <__reset+0xfb0f4cec>
811151d8:	04400404 	movi	r17,16
811151dc:	d8801f17 	ldw	r2,124(sp)
811151e0:	8c00860e 	bge	r17,r16,811153fc <___svfprintf_internal_r+0x1068>
811151e4:	01604534 	movhi	r5,33044
811151e8:	297db084 	addi	r5,r5,-2366
811151ec:	d9402b15 	stw	r5,172(sp)
811151f0:	058001c4 	movi	r22,7
811151f4:	dd002c17 	ldw	r20,176(sp)
811151f8:	00000306 	br	81115208 <___svfprintf_internal_r+0xe74>
811151fc:	42000204 	addi	r8,r8,8
81115200:	843ffc04 	addi	r16,r16,-16
81115204:	8c00800e 	bge	r17,r16,81115408 <___svfprintf_internal_r+0x1074>
81115208:	18c00404 	addi	r3,r3,16
8111520c:	10800044 	addi	r2,r2,1
81115210:	45400015 	stw	r21,0(r8)
81115214:	44400115 	stw	r17,4(r8)
81115218:	d8c02015 	stw	r3,128(sp)
8111521c:	d8801f15 	stw	r2,124(sp)
81115220:	b0bff60e 	bge	r22,r2,811151fc <__reset+0xfb0f51fc>
81115224:	d9801e04 	addi	r6,sp,120
81115228:	a00b883a 	mov	r5,r20
8111522c:	9809883a 	mov	r4,r19
81115230:	1120e540 	call	81120e54 <__ssprint_r>
81115234:	103d3e1e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115238:	d8c02017 	ldw	r3,128(sp)
8111523c:	d8801f17 	ldw	r2,124(sp)
81115240:	da000404 	addi	r8,sp,16
81115244:	003fee06 	br	81115200 <__reset+0xfb0f5200>
81115248:	d9403117 	ldw	r5,196(sp)
8111524c:	d8802a17 	ldw	r2,168(sp)
81115250:	28adc83a 	sub	r22,r5,r2
81115254:	05be650e 	bge	zero,r22,81114bec <__reset+0xfb0f4bec>
81115258:	07000404 	movi	fp,16
8111525c:	d8801f17 	ldw	r2,124(sp)
81115260:	e583a20e 	bge	fp,r22,811160ec <___svfprintf_internal_r+0x1d58>
81115264:	01604534 	movhi	r5,33044
81115268:	297db084 	addi	r5,r5,-2366
8111526c:	dc403015 	stw	r17,192(sp)
81115270:	d9402b15 	stw	r5,172(sp)
81115274:	b023883a 	mov	r17,r22
81115278:	050001c4 	movi	r20,7
8111527c:	902d883a 	mov	r22,r18
81115280:	8025883a 	mov	r18,r16
81115284:	dc002c17 	ldw	r16,176(sp)
81115288:	00000306 	br	81115298 <___svfprintf_internal_r+0xf04>
8111528c:	8c7ffc04 	addi	r17,r17,-16
81115290:	42000204 	addi	r8,r8,8
81115294:	e440110e 	bge	fp,r17,811152dc <___svfprintf_internal_r+0xf48>
81115298:	18c00404 	addi	r3,r3,16
8111529c:	10800044 	addi	r2,r2,1
811152a0:	45400015 	stw	r21,0(r8)
811152a4:	47000115 	stw	fp,4(r8)
811152a8:	d8c02015 	stw	r3,128(sp)
811152ac:	d8801f15 	stw	r2,124(sp)
811152b0:	a0bff60e 	bge	r20,r2,8111528c <__reset+0xfb0f528c>
811152b4:	d9801e04 	addi	r6,sp,120
811152b8:	800b883a 	mov	r5,r16
811152bc:	9809883a 	mov	r4,r19
811152c0:	1120e540 	call	81120e54 <__ssprint_r>
811152c4:	103d1a1e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
811152c8:	8c7ffc04 	addi	r17,r17,-16
811152cc:	d8c02017 	ldw	r3,128(sp)
811152d0:	d8801f17 	ldw	r2,124(sp)
811152d4:	da000404 	addi	r8,sp,16
811152d8:	e47fef16 	blt	fp,r17,81115298 <__reset+0xfb0f5298>
811152dc:	9021883a 	mov	r16,r18
811152e0:	b025883a 	mov	r18,r22
811152e4:	882d883a 	mov	r22,r17
811152e8:	dc403017 	ldw	r17,192(sp)
811152ec:	d9002b17 	ldw	r4,172(sp)
811152f0:	1d87883a 	add	r3,r3,r22
811152f4:	10800044 	addi	r2,r2,1
811152f8:	41000015 	stw	r4,0(r8)
811152fc:	45800115 	stw	r22,4(r8)
81115300:	d8c02015 	stw	r3,128(sp)
81115304:	d8801f15 	stw	r2,124(sp)
81115308:	010001c4 	movi	r4,7
8111530c:	20819a16 	blt	r4,r2,81115978 <___svfprintf_internal_r+0x15e4>
81115310:	42000204 	addi	r8,r8,8
81115314:	003e3506 	br	81114bec <__reset+0xfb0f4bec>
81115318:	d9403317 	ldw	r5,204(sp)
8111531c:	00800044 	movi	r2,1
81115320:	18c00044 	addi	r3,r3,1
81115324:	1141710e 	bge	r2,r5,811158ec <___svfprintf_internal_r+0x1558>
81115328:	dc401f17 	ldw	r17,124(sp)
8111532c:	00800044 	movi	r2,1
81115330:	40800115 	stw	r2,4(r8)
81115334:	8c400044 	addi	r17,r17,1
81115338:	44000015 	stw	r16,0(r8)
8111533c:	d8c02015 	stw	r3,128(sp)
81115340:	dc401f15 	stw	r17,124(sp)
81115344:	008001c4 	movi	r2,7
81115348:	14417416 	blt	r2,r17,8111591c <___svfprintf_internal_r+0x1588>
8111534c:	42000204 	addi	r8,r8,8
81115350:	d8803817 	ldw	r2,224(sp)
81115354:	d9003417 	ldw	r4,208(sp)
81115358:	8c400044 	addi	r17,r17,1
8111535c:	10c7883a 	add	r3,r2,r3
81115360:	40800115 	stw	r2,4(r8)
81115364:	41000015 	stw	r4,0(r8)
81115368:	d8c02015 	stw	r3,128(sp)
8111536c:	dc401f15 	stw	r17,124(sp)
81115370:	008001c4 	movi	r2,7
81115374:	14417216 	blt	r2,r17,81115940 <___svfprintf_internal_r+0x15ac>
81115378:	45800204 	addi	r22,r8,8
8111537c:	d9003617 	ldw	r4,216(sp)
81115380:	d9403717 	ldw	r5,220(sp)
81115384:	000d883a 	mov	r6,zero
81115388:	000f883a 	mov	r7,zero
8111538c:	d8c03d15 	stw	r3,244(sp)
81115390:	1126fac0 	call	81126fac <__eqdf2>
81115394:	d8c03d17 	ldw	r3,244(sp)
81115398:	1000b326 	beq	r2,zero,81115668 <___svfprintf_internal_r+0x12d4>
8111539c:	d9403317 	ldw	r5,204(sp)
811153a0:	84000044 	addi	r16,r16,1
811153a4:	8c400044 	addi	r17,r17,1
811153a8:	28bfffc4 	addi	r2,r5,-1
811153ac:	1887883a 	add	r3,r3,r2
811153b0:	b0800115 	stw	r2,4(r22)
811153b4:	b4000015 	stw	r16,0(r22)
811153b8:	d8c02015 	stw	r3,128(sp)
811153bc:	dc401f15 	stw	r17,124(sp)
811153c0:	008001c4 	movi	r2,7
811153c4:	1440d216 	blt	r2,r17,81115710 <___svfprintf_internal_r+0x137c>
811153c8:	b5800204 	addi	r22,r22,8
811153cc:	d9003b17 	ldw	r4,236(sp)
811153d0:	df0022c4 	addi	fp,sp,139
811153d4:	8c400044 	addi	r17,r17,1
811153d8:	20c7883a 	add	r3,r4,r3
811153dc:	b7000015 	stw	fp,0(r22)
811153e0:	b1000115 	stw	r4,4(r22)
811153e4:	d8c02015 	stw	r3,128(sp)
811153e8:	dc401f15 	stw	r17,124(sp)
811153ec:	008001c4 	movi	r2,7
811153f0:	14400e16 	blt	r2,r17,8111542c <___svfprintf_internal_r+0x1098>
811153f4:	b2000204 	addi	r8,r22,8
811153f8:	003e3c06 	br	81114cec <__reset+0xfb0f4cec>
811153fc:	01204534 	movhi	r4,33044
81115400:	213db084 	addi	r4,r4,-2366
81115404:	d9002b15 	stw	r4,172(sp)
81115408:	d9002b17 	ldw	r4,172(sp)
8111540c:	1c07883a 	add	r3,r3,r16
81115410:	44000115 	stw	r16,4(r8)
81115414:	41000015 	stw	r4,0(r8)
81115418:	10800044 	addi	r2,r2,1
8111541c:	d8c02015 	stw	r3,128(sp)
81115420:	d8801f15 	stw	r2,124(sp)
81115424:	010001c4 	movi	r4,7
81115428:	20be2f0e 	bge	r4,r2,81114ce8 <__reset+0xfb0f4ce8>
8111542c:	d9402c17 	ldw	r5,176(sp)
81115430:	d9801e04 	addi	r6,sp,120
81115434:	9809883a 	mov	r4,r19
81115438:	1120e540 	call	81120e54 <__ssprint_r>
8111543c:	103cbc1e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115440:	d8c02017 	ldw	r3,128(sp)
81115444:	da000404 	addi	r8,sp,16
81115448:	003e2806 	br	81114cec <__reset+0xfb0f4cec>
8111544c:	d9402c17 	ldw	r5,176(sp)
81115450:	d9801e04 	addi	r6,sp,120
81115454:	9809883a 	mov	r4,r19
81115458:	1120e540 	call	81120e54 <__ssprint_r>
8111545c:	103e5f26 	beq	r2,zero,81114ddc <__reset+0xfb0f4ddc>
81115460:	003cb306 	br	81114730 <__reset+0xfb0f4730>
81115464:	d9402c17 	ldw	r5,176(sp)
81115468:	d9801e04 	addi	r6,sp,120
8111546c:	9809883a 	mov	r4,r19
81115470:	1120e540 	call	81120e54 <__ssprint_r>
81115474:	103cae1e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115478:	d8c02017 	ldw	r3,128(sp)
8111547c:	da000404 	addi	r8,sp,16
81115480:	003e0d06 	br	81114cb8 <__reset+0xfb0f4cb8>
81115484:	d9402c17 	ldw	r5,176(sp)
81115488:	d9801e04 	addi	r6,sp,120
8111548c:	9809883a 	mov	r4,r19
81115490:	1120e540 	call	81120e54 <__ssprint_r>
81115494:	103ca61e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115498:	d8c02017 	ldw	r3,128(sp)
8111549c:	da000404 	addi	r8,sp,16
811154a0:	003dc106 	br	81114ba8 <__reset+0xfb0f4ba8>
811154a4:	d9402c17 	ldw	r5,176(sp)
811154a8:	d9801e04 	addi	r6,sp,120
811154ac:	9809883a 	mov	r4,r19
811154b0:	1120e540 	call	81120e54 <__ssprint_r>
811154b4:	103c9e1e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
811154b8:	d8c02017 	ldw	r3,128(sp)
811154bc:	da000404 	addi	r8,sp,16
811154c0:	003dc706 	br	81114be0 <__reset+0xfb0f4be0>
811154c4:	d8802917 	ldw	r2,164(sp)
811154c8:	d8002785 	stb	zero,158(sp)
811154cc:	103f0816 	blt	r2,zero,811150f0 <__reset+0xfb0f50f0>
811154d0:	00ffdfc4 	movi	r3,-129
811154d4:	a584b03a 	or	r2,r20,r22
811154d8:	90e4703a 	and	r18,r18,r3
811154dc:	103c8126 	beq	r2,zero,811146e4 <__reset+0xfb0f46e4>
811154e0:	0039883a 	mov	fp,zero
811154e4:	003e7606 	br	81114ec0 <__reset+0xfb0f4ec0>
811154e8:	9080040c 	andi	r2,r18,16
811154ec:	10013d26 	beq	r2,zero,811159e4 <___svfprintf_internal_r+0x1650>
811154f0:	d9002d17 	ldw	r4,180(sp)
811154f4:	d9402917 	ldw	r5,164(sp)
811154f8:	d8002785 	stb	zero,158(sp)
811154fc:	20800104 	addi	r2,r4,4
81115500:	25000017 	ldw	r20,0(r4)
81115504:	002d883a 	mov	r22,zero
81115508:	28013f16 	blt	r5,zero,81115a08 <___svfprintf_internal_r+0x1674>
8111550c:	00ffdfc4 	movi	r3,-129
81115510:	d8802d15 	stw	r2,180(sp)
81115514:	90e4703a 	and	r18,r18,r3
81115518:	a03d2b26 	beq	r20,zero,811149c8 <__reset+0xfb0f49c8>
8111551c:	0039883a 	mov	fp,zero
81115520:	003d2e06 	br	811149dc <__reset+0xfb0f49dc>
81115524:	dc402617 	ldw	r17,152(sp)
81115528:	0441830e 	bge	zero,r17,81115b38 <___svfprintf_internal_r+0x17a4>
8111552c:	dc403217 	ldw	r17,200(sp)
81115530:	d8803317 	ldw	r2,204(sp)
81115534:	1440010e 	bge	r2,r17,8111553c <___svfprintf_internal_r+0x11a8>
81115538:	1023883a 	mov	r17,r2
8111553c:	04400a0e 	bge	zero,r17,81115568 <___svfprintf_internal_r+0x11d4>
81115540:	d8801f17 	ldw	r2,124(sp)
81115544:	1c47883a 	add	r3,r3,r17
81115548:	44000015 	stw	r16,0(r8)
8111554c:	10800044 	addi	r2,r2,1
81115550:	44400115 	stw	r17,4(r8)
81115554:	d8c02015 	stw	r3,128(sp)
81115558:	d8801f15 	stw	r2,124(sp)
8111555c:	010001c4 	movi	r4,7
81115560:	20827516 	blt	r4,r2,81115f38 <___svfprintf_internal_r+0x1ba4>
81115564:	42000204 	addi	r8,r8,8
81115568:	88027b16 	blt	r17,zero,81115f58 <___svfprintf_internal_r+0x1bc4>
8111556c:	d9003217 	ldw	r4,200(sp)
81115570:	2463c83a 	sub	r17,r4,r17
81115574:	0440990e 	bge	zero,r17,811157dc <___svfprintf_internal_r+0x1448>
81115578:	05800404 	movi	r22,16
8111557c:	d8801f17 	ldw	r2,124(sp)
81115580:	b441530e 	bge	r22,r17,81115ad0 <___svfprintf_internal_r+0x173c>
81115584:	01204534 	movhi	r4,33044
81115588:	213db084 	addi	r4,r4,-2366
8111558c:	d9002b15 	stw	r4,172(sp)
81115590:	070001c4 	movi	fp,7
81115594:	dd002c17 	ldw	r20,176(sp)
81115598:	00000306 	br	811155a8 <___svfprintf_internal_r+0x1214>
8111559c:	42000204 	addi	r8,r8,8
811155a0:	8c7ffc04 	addi	r17,r17,-16
811155a4:	b4414d0e 	bge	r22,r17,81115adc <___svfprintf_internal_r+0x1748>
811155a8:	18c00404 	addi	r3,r3,16
811155ac:	10800044 	addi	r2,r2,1
811155b0:	45400015 	stw	r21,0(r8)
811155b4:	45800115 	stw	r22,4(r8)
811155b8:	d8c02015 	stw	r3,128(sp)
811155bc:	d8801f15 	stw	r2,124(sp)
811155c0:	e0bff60e 	bge	fp,r2,8111559c <__reset+0xfb0f559c>
811155c4:	d9801e04 	addi	r6,sp,120
811155c8:	a00b883a 	mov	r5,r20
811155cc:	9809883a 	mov	r4,r19
811155d0:	1120e540 	call	81120e54 <__ssprint_r>
811155d4:	103c561e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
811155d8:	d8c02017 	ldw	r3,128(sp)
811155dc:	d8801f17 	ldw	r2,124(sp)
811155e0:	da000404 	addi	r8,sp,16
811155e4:	003fee06 	br	811155a0 <__reset+0xfb0f55a0>
811155e8:	d9402c17 	ldw	r5,176(sp)
811155ec:	d9801e04 	addi	r6,sp,120
811155f0:	9809883a 	mov	r4,r19
811155f4:	1120e540 	call	81120e54 <__ssprint_r>
811155f8:	103c4d1e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
811155fc:	d8c02017 	ldw	r3,128(sp)
81115600:	df002787 	ldb	fp,158(sp)
81115604:	da000404 	addi	r8,sp,16
81115608:	003d5a06 	br	81114b74 <__reset+0xfb0f4b74>
8111560c:	9080040c 	andi	r2,r18,16
81115610:	10005c26 	beq	r2,zero,81115784 <___svfprintf_internal_r+0x13f0>
81115614:	d9402d17 	ldw	r5,180(sp)
81115618:	d8c02917 	ldw	r3,164(sp)
8111561c:	d8002785 	stb	zero,158(sp)
81115620:	28800104 	addi	r2,r5,4
81115624:	2d000017 	ldw	r20,0(r5)
81115628:	002d883a 	mov	r22,zero
8111562c:	18005e16 	blt	r3,zero,811157a8 <___svfprintf_internal_r+0x1414>
81115630:	00ffdfc4 	movi	r3,-129
81115634:	d8802d15 	stw	r2,180(sp)
81115638:	90e4703a 	and	r18,r18,r3
8111563c:	0039883a 	mov	fp,zero
81115640:	a03dfe26 	beq	r20,zero,81114e3c <__reset+0xfb0f4e3c>
81115644:	00800244 	movi	r2,9
81115648:	153cb336 	bltu	r2,r20,81114918 <__reset+0xfb0f4918>
8111564c:	a5000c04 	addi	r20,r20,48
81115650:	dc001dc4 	addi	r16,sp,119
81115654:	dd001dc5 	stb	r20,119(sp)
81115658:	d8c02817 	ldw	r3,160(sp)
8111565c:	1c07c83a 	sub	r3,r3,r16
81115660:	d8c02e15 	stw	r3,184(sp)
81115664:	003cf506 	br	81114a3c <__reset+0xfb0f4a3c>
81115668:	d8803317 	ldw	r2,204(sp)
8111566c:	143fffc4 	addi	r16,r2,-1
81115670:	043f560e 	bge	zero,r16,811153cc <__reset+0xfb0f53cc>
81115674:	07000404 	movi	fp,16
81115678:	e403530e 	bge	fp,r16,811163c8 <___svfprintf_internal_r+0x2034>
8111567c:	01604534 	movhi	r5,33044
81115680:	297db084 	addi	r5,r5,-2366
81115684:	d9402b15 	stw	r5,172(sp)
81115688:	01c001c4 	movi	r7,7
8111568c:	dd002c17 	ldw	r20,176(sp)
81115690:	00000306 	br	811156a0 <___svfprintf_internal_r+0x130c>
81115694:	843ffc04 	addi	r16,r16,-16
81115698:	b5800204 	addi	r22,r22,8
8111569c:	e400130e 	bge	fp,r16,811156ec <___svfprintf_internal_r+0x1358>
811156a0:	18c00404 	addi	r3,r3,16
811156a4:	8c400044 	addi	r17,r17,1
811156a8:	b5400015 	stw	r21,0(r22)
811156ac:	b7000115 	stw	fp,4(r22)
811156b0:	d8c02015 	stw	r3,128(sp)
811156b4:	dc401f15 	stw	r17,124(sp)
811156b8:	3c7ff60e 	bge	r7,r17,81115694 <__reset+0xfb0f5694>
811156bc:	d9801e04 	addi	r6,sp,120
811156c0:	a00b883a 	mov	r5,r20
811156c4:	9809883a 	mov	r4,r19
811156c8:	d9c03d15 	stw	r7,244(sp)
811156cc:	1120e540 	call	81120e54 <__ssprint_r>
811156d0:	d9c03d17 	ldw	r7,244(sp)
811156d4:	103c161e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
811156d8:	843ffc04 	addi	r16,r16,-16
811156dc:	d8c02017 	ldw	r3,128(sp)
811156e0:	dc401f17 	ldw	r17,124(sp)
811156e4:	dd800404 	addi	r22,sp,16
811156e8:	e43fed16 	blt	fp,r16,811156a0 <__reset+0xfb0f56a0>
811156ec:	d8802b17 	ldw	r2,172(sp)
811156f0:	1c07883a 	add	r3,r3,r16
811156f4:	8c400044 	addi	r17,r17,1
811156f8:	b0800015 	stw	r2,0(r22)
811156fc:	b4000115 	stw	r16,4(r22)
81115700:	d8c02015 	stw	r3,128(sp)
81115704:	dc401f15 	stw	r17,124(sp)
81115708:	008001c4 	movi	r2,7
8111570c:	147f2e0e 	bge	r2,r17,811153c8 <__reset+0xfb0f53c8>
81115710:	d9402c17 	ldw	r5,176(sp)
81115714:	d9801e04 	addi	r6,sp,120
81115718:	9809883a 	mov	r4,r19
8111571c:	1120e540 	call	81120e54 <__ssprint_r>
81115720:	103c031e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115724:	d8c02017 	ldw	r3,128(sp)
81115728:	dc401f17 	ldw	r17,124(sp)
8111572c:	dd800404 	addi	r22,sp,16
81115730:	003f2606 	br	811153cc <__reset+0xfb0f53cc>
81115734:	9080040c 	andi	r2,r18,16
81115738:	1000c326 	beq	r2,zero,81115a48 <___svfprintf_internal_r+0x16b4>
8111573c:	d8802d17 	ldw	r2,180(sp)
81115740:	15000017 	ldw	r20,0(r2)
81115744:	10800104 	addi	r2,r2,4
81115748:	d8802d15 	stw	r2,180(sp)
8111574c:	a02dd7fa 	srai	r22,r20,31
81115750:	b005883a 	mov	r2,r22
81115754:	103c680e 	bge	r2,zero,811148f8 <__reset+0xfb0f48f8>
81115758:	0529c83a 	sub	r20,zero,r20
8111575c:	a004c03a 	cmpne	r2,r20,zero
81115760:	05adc83a 	sub	r22,zero,r22
81115764:	b0adc83a 	sub	r22,r22,r2
81115768:	d8802917 	ldw	r2,164(sp)
8111576c:	07000b44 	movi	fp,45
81115770:	df002785 	stb	fp,158(sp)
81115774:	10022e16 	blt	r2,zero,81116030 <___svfprintf_internal_r+0x1c9c>
81115778:	00bfdfc4 	movi	r2,-129
8111577c:	90a4703a 	and	r18,r18,r2
81115780:	003c6406 	br	81114914 <__reset+0xfb0f4914>
81115784:	9080100c 	andi	r2,r18,64
81115788:	d8002785 	stb	zero,158(sp)
8111578c:	10012526 	beq	r2,zero,81115c24 <___svfprintf_internal_r+0x1890>
81115790:	d9002d17 	ldw	r4,180(sp)
81115794:	d9402917 	ldw	r5,164(sp)
81115798:	002d883a 	mov	r22,zero
8111579c:	20800104 	addi	r2,r4,4
811157a0:	2500000b 	ldhu	r20,0(r4)
811157a4:	283fa20e 	bge	r5,zero,81115630 <__reset+0xfb0f5630>
811157a8:	d8802d15 	stw	r2,180(sp)
811157ac:	0039883a 	mov	fp,zero
811157b0:	a584b03a 	or	r2,r20,r22
811157b4:	103c571e 	bne	r2,zero,81114914 <__reset+0xfb0f4914>
811157b8:	00800044 	movi	r2,1
811157bc:	003e5006 	br	81115100 <__reset+0xfb0f5100>
811157c0:	d9402c17 	ldw	r5,176(sp)
811157c4:	d9801e04 	addi	r6,sp,120
811157c8:	9809883a 	mov	r4,r19
811157cc:	1120e540 	call	81120e54 <__ssprint_r>
811157d0:	103bd71e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
811157d4:	d8c02017 	ldw	r3,128(sp)
811157d8:	da000404 	addi	r8,sp,16
811157dc:	d9003217 	ldw	r4,200(sp)
811157e0:	d8802617 	ldw	r2,152(sp)
811157e4:	d9403317 	ldw	r5,204(sp)
811157e8:	8123883a 	add	r17,r16,r4
811157ec:	11400216 	blt	r2,r5,811157f8 <___svfprintf_internal_r+0x1464>
811157f0:	9100004c 	andi	r4,r18,1
811157f4:	20000d26 	beq	r4,zero,8111582c <___svfprintf_internal_r+0x1498>
811157f8:	d9003817 	ldw	r4,224(sp)
811157fc:	d9403417 	ldw	r5,208(sp)
81115800:	1907883a 	add	r3,r3,r4
81115804:	d9001f17 	ldw	r4,124(sp)
81115808:	41400015 	stw	r5,0(r8)
8111580c:	d9403817 	ldw	r5,224(sp)
81115810:	21000044 	addi	r4,r4,1
81115814:	d8c02015 	stw	r3,128(sp)
81115818:	41400115 	stw	r5,4(r8)
8111581c:	d9001f15 	stw	r4,124(sp)
81115820:	014001c4 	movi	r5,7
81115824:	2901dc16 	blt	r5,r4,81115f98 <___svfprintf_internal_r+0x1c04>
81115828:	42000204 	addi	r8,r8,8
8111582c:	d9003317 	ldw	r4,204(sp)
81115830:	8121883a 	add	r16,r16,r4
81115834:	2085c83a 	sub	r2,r4,r2
81115838:	8461c83a 	sub	r16,r16,r17
8111583c:	1400010e 	bge	r2,r16,81115844 <___svfprintf_internal_r+0x14b0>
81115840:	1021883a 	mov	r16,r2
81115844:	04000a0e 	bge	zero,r16,81115870 <___svfprintf_internal_r+0x14dc>
81115848:	d9001f17 	ldw	r4,124(sp)
8111584c:	1c07883a 	add	r3,r3,r16
81115850:	44400015 	stw	r17,0(r8)
81115854:	21000044 	addi	r4,r4,1
81115858:	44000115 	stw	r16,4(r8)
8111585c:	d8c02015 	stw	r3,128(sp)
81115860:	d9001f15 	stw	r4,124(sp)
81115864:	014001c4 	movi	r5,7
81115868:	2901e616 	blt	r5,r4,81116004 <___svfprintf_internal_r+0x1c70>
8111586c:	42000204 	addi	r8,r8,8
81115870:	8001f616 	blt	r16,zero,8111604c <___svfprintf_internal_r+0x1cb8>
81115874:	1421c83a 	sub	r16,r2,r16
81115878:	043d1c0e 	bge	zero,r16,81114cec <__reset+0xfb0f4cec>
8111587c:	04400404 	movi	r17,16
81115880:	d8801f17 	ldw	r2,124(sp)
81115884:	8c3edd0e 	bge	r17,r16,811153fc <__reset+0xfb0f53fc>
81115888:	01604534 	movhi	r5,33044
8111588c:	297db084 	addi	r5,r5,-2366
81115890:	d9402b15 	stw	r5,172(sp)
81115894:	058001c4 	movi	r22,7
81115898:	dd002c17 	ldw	r20,176(sp)
8111589c:	00000306 	br	811158ac <___svfprintf_internal_r+0x1518>
811158a0:	42000204 	addi	r8,r8,8
811158a4:	843ffc04 	addi	r16,r16,-16
811158a8:	8c3ed70e 	bge	r17,r16,81115408 <__reset+0xfb0f5408>
811158ac:	18c00404 	addi	r3,r3,16
811158b0:	10800044 	addi	r2,r2,1
811158b4:	45400015 	stw	r21,0(r8)
811158b8:	44400115 	stw	r17,4(r8)
811158bc:	d8c02015 	stw	r3,128(sp)
811158c0:	d8801f15 	stw	r2,124(sp)
811158c4:	b0bff60e 	bge	r22,r2,811158a0 <__reset+0xfb0f58a0>
811158c8:	d9801e04 	addi	r6,sp,120
811158cc:	a00b883a 	mov	r5,r20
811158d0:	9809883a 	mov	r4,r19
811158d4:	1120e540 	call	81120e54 <__ssprint_r>
811158d8:	103b951e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
811158dc:	d8c02017 	ldw	r3,128(sp)
811158e0:	d8801f17 	ldw	r2,124(sp)
811158e4:	da000404 	addi	r8,sp,16
811158e8:	003fee06 	br	811158a4 <__reset+0xfb0f58a4>
811158ec:	9088703a 	and	r4,r18,r2
811158f0:	203e8d1e 	bne	r4,zero,81115328 <__reset+0xfb0f5328>
811158f4:	dc401f17 	ldw	r17,124(sp)
811158f8:	40800115 	stw	r2,4(r8)
811158fc:	44000015 	stw	r16,0(r8)
81115900:	8c400044 	addi	r17,r17,1
81115904:	d8c02015 	stw	r3,128(sp)
81115908:	dc401f15 	stw	r17,124(sp)
8111590c:	008001c4 	movi	r2,7
81115910:	147f7f16 	blt	r2,r17,81115710 <__reset+0xfb0f5710>
81115914:	45800204 	addi	r22,r8,8
81115918:	003eac06 	br	811153cc <__reset+0xfb0f53cc>
8111591c:	d9402c17 	ldw	r5,176(sp)
81115920:	d9801e04 	addi	r6,sp,120
81115924:	9809883a 	mov	r4,r19
81115928:	1120e540 	call	81120e54 <__ssprint_r>
8111592c:	103b801e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115930:	d8c02017 	ldw	r3,128(sp)
81115934:	dc401f17 	ldw	r17,124(sp)
81115938:	da000404 	addi	r8,sp,16
8111593c:	003e8406 	br	81115350 <__reset+0xfb0f5350>
81115940:	d9402c17 	ldw	r5,176(sp)
81115944:	d9801e04 	addi	r6,sp,120
81115948:	9809883a 	mov	r4,r19
8111594c:	1120e540 	call	81120e54 <__ssprint_r>
81115950:	103b771e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115954:	d8c02017 	ldw	r3,128(sp)
81115958:	dc401f17 	ldw	r17,124(sp)
8111595c:	dd800404 	addi	r22,sp,16
81115960:	003e8606 	br	8111537c <__reset+0xfb0f537c>
81115964:	0029883a 	mov	r20,zero
81115968:	a5000c04 	addi	r20,r20,48
8111596c:	dc001dc4 	addi	r16,sp,119
81115970:	dd001dc5 	stb	r20,119(sp)
81115974:	003f3806 	br	81115658 <__reset+0xfb0f5658>
81115978:	d9402c17 	ldw	r5,176(sp)
8111597c:	d9801e04 	addi	r6,sp,120
81115980:	9809883a 	mov	r4,r19
81115984:	1120e540 	call	81120e54 <__ssprint_r>
81115988:	103b691e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
8111598c:	d8c02017 	ldw	r3,128(sp)
81115990:	da000404 	addi	r8,sp,16
81115994:	003c9506 	br	81114bec <__reset+0xfb0f4bec>
81115998:	d9003617 	ldw	r4,216(sp)
8111599c:	d9403717 	ldw	r5,220(sp)
811159a0:	da003e15 	stw	r8,248(sp)
811159a4:	111ec680 	call	8111ec68 <__fpclassifyd>
811159a8:	da003e17 	ldw	r8,248(sp)
811159ac:	1000bd1e 	bne	r2,zero,81115ca4 <___svfprintf_internal_r+0x1910>
811159b0:	008011c4 	movi	r2,71
811159b4:	14411e0e 	bge	r2,r17,81115e30 <___svfprintf_internal_r+0x1a9c>
811159b8:	04204534 	movhi	r16,33044
811159bc:	843da304 	addi	r16,r16,-2420
811159c0:	00c000c4 	movi	r3,3
811159c4:	00bfdfc4 	movi	r2,-129
811159c8:	d8c02a15 	stw	r3,168(sp)
811159cc:	90a4703a 	and	r18,r18,r2
811159d0:	df002783 	ldbu	fp,158(sp)
811159d4:	d8c02e15 	stw	r3,184(sp)
811159d8:	d8002915 	stw	zero,164(sp)
811159dc:	d8003215 	stw	zero,200(sp)
811159e0:	003c1c06 	br	81114a54 <__reset+0xfb0f4a54>
811159e4:	9080100c 	andi	r2,r18,64
811159e8:	d8002785 	stb	zero,158(sp)
811159ec:	10009426 	beq	r2,zero,81115c40 <___svfprintf_internal_r+0x18ac>
811159f0:	d8c02d17 	ldw	r3,180(sp)
811159f4:	d9002917 	ldw	r4,164(sp)
811159f8:	002d883a 	mov	r22,zero
811159fc:	18800104 	addi	r2,r3,4
81115a00:	1d00000b 	ldhu	r20,0(r3)
81115a04:	203ec10e 	bge	r4,zero,8111550c <__reset+0xfb0f550c>
81115a08:	a586b03a 	or	r3,r20,r22
81115a0c:	d8802d15 	stw	r2,180(sp)
81115a10:	183ec21e 	bne	r3,zero,8111551c <__reset+0xfb0f551c>
81115a14:	0039883a 	mov	fp,zero
81115a18:	0005883a 	mov	r2,zero
81115a1c:	003db806 	br	81115100 <__reset+0xfb0f5100>
81115a20:	d8802d17 	ldw	r2,180(sp)
81115a24:	d8c02d17 	ldw	r3,180(sp)
81115a28:	d9002d17 	ldw	r4,180(sp)
81115a2c:	10800017 	ldw	r2,0(r2)
81115a30:	18c00117 	ldw	r3,4(r3)
81115a34:	21000204 	addi	r4,r4,8
81115a38:	d8803615 	stw	r2,216(sp)
81115a3c:	d8c03715 	stw	r3,220(sp)
81115a40:	d9002d15 	stw	r4,180(sp)
81115a44:	003b8206 	br	81114850 <__reset+0xfb0f4850>
81115a48:	9080100c 	andi	r2,r18,64
81115a4c:	10010726 	beq	r2,zero,81115e6c <___svfprintf_internal_r+0x1ad8>
81115a50:	d8c02d17 	ldw	r3,180(sp)
81115a54:	1d00000f 	ldh	r20,0(r3)
81115a58:	18c00104 	addi	r3,r3,4
81115a5c:	d8c02d15 	stw	r3,180(sp)
81115a60:	a02dd7fa 	srai	r22,r20,31
81115a64:	b005883a 	mov	r2,r22
81115a68:	003ba206 	br	811148f4 <__reset+0xfb0f48f4>
81115a6c:	9080100c 	andi	r2,r18,64
81115a70:	10010526 	beq	r2,zero,81115e88 <___svfprintf_internal_r+0x1af4>
81115a74:	d9002d17 	ldw	r4,180(sp)
81115a78:	002d883a 	mov	r22,zero
81115a7c:	2500000b 	ldhu	r20,0(r4)
81115a80:	21000104 	addi	r4,r4,4
81115a84:	d9002d15 	stw	r4,180(sp)
81115a88:	003cfe06 	br	81114e84 <__reset+0xfb0f4e84>
81115a8c:	bc400007 	ldb	r17,0(r23)
81115a90:	003a9606 	br	811144ec <__reset+0xfb0f44ec>
81115a94:	9080040c 	andi	r2,r18,16
81115a98:	10010126 	beq	r2,zero,81115ea0 <___svfprintf_internal_r+0x1b0c>
81115a9c:	d9402d17 	ldw	r5,180(sp)
81115aa0:	d8c02f17 	ldw	r3,188(sp)
81115aa4:	28800017 	ldw	r2,0(r5)
81115aa8:	29400104 	addi	r5,r5,4
81115aac:	d9402d15 	stw	r5,180(sp)
81115ab0:	10c00015 	stw	r3,0(r2)
81115ab4:	003a6406 	br	81114448 <__reset+0xfb0f4448>
81115ab8:	d9002917 	ldw	r4,164(sp)
81115abc:	d8002785 	stb	zero,158(sp)
81115ac0:	203d8d16 	blt	r4,zero,811150f8 <__reset+0xfb0f50f8>
81115ac4:	00bfdfc4 	movi	r2,-129
81115ac8:	90a4703a 	and	r18,r18,r2
81115acc:	003b0506 	br	811146e4 <__reset+0xfb0f46e4>
81115ad0:	01604534 	movhi	r5,33044
81115ad4:	297db084 	addi	r5,r5,-2366
81115ad8:	d9402b15 	stw	r5,172(sp)
81115adc:	d9402b17 	ldw	r5,172(sp)
81115ae0:	1c47883a 	add	r3,r3,r17
81115ae4:	10800044 	addi	r2,r2,1
81115ae8:	41400015 	stw	r5,0(r8)
81115aec:	44400115 	stw	r17,4(r8)
81115af0:	d8c02015 	stw	r3,128(sp)
81115af4:	d8801f15 	stw	r2,124(sp)
81115af8:	010001c4 	movi	r4,7
81115afc:	20bf3016 	blt	r4,r2,811157c0 <__reset+0xfb0f57c0>
81115b00:	42000204 	addi	r8,r8,8
81115b04:	003f3506 	br	811157dc <__reset+0xfb0f57dc>
81115b08:	01204534 	movhi	r4,33044
81115b0c:	213db084 	addi	r4,r4,-2366
81115b10:	d9002b15 	stw	r4,172(sp)
81115b14:	003c5e06 	br	81114c90 <__reset+0xfb0f4c90>
81115b18:	d9402c17 	ldw	r5,176(sp)
81115b1c:	d9801e04 	addi	r6,sp,120
81115b20:	9809883a 	mov	r4,r19
81115b24:	1120e540 	call	81120e54 <__ssprint_r>
81115b28:	103b011e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115b2c:	d8c02017 	ldw	r3,128(sp)
81115b30:	da000404 	addi	r8,sp,16
81115b34:	003d9306 	br	81115184 <__reset+0xfb0f5184>
81115b38:	d8801f17 	ldw	r2,124(sp)
81115b3c:	01604534 	movhi	r5,33044
81115b40:	01000044 	movi	r4,1
81115b44:	18c00044 	addi	r3,r3,1
81115b48:	10800044 	addi	r2,r2,1
81115b4c:	297db004 	addi	r5,r5,-2368
81115b50:	41000115 	stw	r4,4(r8)
81115b54:	41400015 	stw	r5,0(r8)
81115b58:	d8c02015 	stw	r3,128(sp)
81115b5c:	d8801f15 	stw	r2,124(sp)
81115b60:	010001c4 	movi	r4,7
81115b64:	2080b516 	blt	r4,r2,81115e3c <___svfprintf_internal_r+0x1aa8>
81115b68:	42000204 	addi	r8,r8,8
81115b6c:	8800041e 	bne	r17,zero,81115b80 <___svfprintf_internal_r+0x17ec>
81115b70:	d8803317 	ldw	r2,204(sp)
81115b74:	1000021e 	bne	r2,zero,81115b80 <___svfprintf_internal_r+0x17ec>
81115b78:	9080004c 	andi	r2,r18,1
81115b7c:	103c5b26 	beq	r2,zero,81114cec <__reset+0xfb0f4cec>
81115b80:	d9003817 	ldw	r4,224(sp)
81115b84:	d8801f17 	ldw	r2,124(sp)
81115b88:	d9403417 	ldw	r5,208(sp)
81115b8c:	20c7883a 	add	r3,r4,r3
81115b90:	10800044 	addi	r2,r2,1
81115b94:	41000115 	stw	r4,4(r8)
81115b98:	41400015 	stw	r5,0(r8)
81115b9c:	d8c02015 	stw	r3,128(sp)
81115ba0:	d8801f15 	stw	r2,124(sp)
81115ba4:	010001c4 	movi	r4,7
81115ba8:	20818016 	blt	r4,r2,811161ac <___svfprintf_internal_r+0x1e18>
81115bac:	42000204 	addi	r8,r8,8
81115bb0:	0463c83a 	sub	r17,zero,r17
81115bb4:	0440cb0e 	bge	zero,r17,81115ee4 <___svfprintf_internal_r+0x1b50>
81115bb8:	05800404 	movi	r22,16
81115bbc:	b440e80e 	bge	r22,r17,81115f60 <___svfprintf_internal_r+0x1bcc>
81115bc0:	01604534 	movhi	r5,33044
81115bc4:	297db084 	addi	r5,r5,-2366
81115bc8:	d9402b15 	stw	r5,172(sp)
81115bcc:	070001c4 	movi	fp,7
81115bd0:	dd002c17 	ldw	r20,176(sp)
81115bd4:	00000306 	br	81115be4 <___svfprintf_internal_r+0x1850>
81115bd8:	42000204 	addi	r8,r8,8
81115bdc:	8c7ffc04 	addi	r17,r17,-16
81115be0:	b440e20e 	bge	r22,r17,81115f6c <___svfprintf_internal_r+0x1bd8>
81115be4:	18c00404 	addi	r3,r3,16
81115be8:	10800044 	addi	r2,r2,1
81115bec:	45400015 	stw	r21,0(r8)
81115bf0:	45800115 	stw	r22,4(r8)
81115bf4:	d8c02015 	stw	r3,128(sp)
81115bf8:	d8801f15 	stw	r2,124(sp)
81115bfc:	e0bff60e 	bge	fp,r2,81115bd8 <__reset+0xfb0f5bd8>
81115c00:	d9801e04 	addi	r6,sp,120
81115c04:	a00b883a 	mov	r5,r20
81115c08:	9809883a 	mov	r4,r19
81115c0c:	1120e540 	call	81120e54 <__ssprint_r>
81115c10:	103ac71e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115c14:	d8c02017 	ldw	r3,128(sp)
81115c18:	d8801f17 	ldw	r2,124(sp)
81115c1c:	da000404 	addi	r8,sp,16
81115c20:	003fee06 	br	81115bdc <__reset+0xfb0f5bdc>
81115c24:	d8c02d17 	ldw	r3,180(sp)
81115c28:	d9002917 	ldw	r4,164(sp)
81115c2c:	002d883a 	mov	r22,zero
81115c30:	18800104 	addi	r2,r3,4
81115c34:	1d000017 	ldw	r20,0(r3)
81115c38:	203e7d0e 	bge	r4,zero,81115630 <__reset+0xfb0f5630>
81115c3c:	003eda06 	br	811157a8 <__reset+0xfb0f57a8>
81115c40:	d9402d17 	ldw	r5,180(sp)
81115c44:	d8c02917 	ldw	r3,164(sp)
81115c48:	002d883a 	mov	r22,zero
81115c4c:	28800104 	addi	r2,r5,4
81115c50:	2d000017 	ldw	r20,0(r5)
81115c54:	183e2d0e 	bge	r3,zero,8111550c <__reset+0xfb0f550c>
81115c58:	003f6b06 	br	81115a08 <__reset+0xfb0f5a08>
81115c5c:	d8c02d15 	stw	r3,180(sp)
81115c60:	0039883a 	mov	fp,zero
81115c64:	003ed206 	br	811157b0 <__reset+0xfb0f57b0>
81115c68:	bc400043 	ldbu	r17,1(r23)
81115c6c:	94800814 	ori	r18,r18,32
81115c70:	bdc00044 	addi	r23,r23,1
81115c74:	8c403fcc 	andi	r17,r17,255
81115c78:	8c40201c 	xori	r17,r17,128
81115c7c:	8c7fe004 	addi	r17,r17,-128
81115c80:	003a1a06 	br	811144ec <__reset+0xfb0f44ec>
81115c84:	d9402c17 	ldw	r5,176(sp)
81115c88:	d9801e04 	addi	r6,sp,120
81115c8c:	9809883a 	mov	r4,r19
81115c90:	1120e540 	call	81120e54 <__ssprint_r>
81115c94:	103aa61e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115c98:	d8c02017 	ldw	r3,128(sp)
81115c9c:	da000404 	addi	r8,sp,16
81115ca0:	003d4a06 	br	811151cc <__reset+0xfb0f51cc>
81115ca4:	d9002917 	ldw	r4,164(sp)
81115ca8:	05bff7c4 	movi	r22,-33
81115cac:	00bfffc4 	movi	r2,-1
81115cb0:	8dac703a 	and	r22,r17,r22
81115cb4:	20806a26 	beq	r4,r2,81115e60 <___svfprintf_internal_r+0x1acc>
81115cb8:	008011c4 	movi	r2,71
81115cbc:	b0813726 	beq	r22,r2,8111619c <___svfprintf_internal_r+0x1e08>
81115cc0:	d9003717 	ldw	r4,220(sp)
81115cc4:	90c04014 	ori	r3,r18,256
81115cc8:	d8c02b15 	stw	r3,172(sp)
81115ccc:	20015d16 	blt	r4,zero,81116244 <___svfprintf_internal_r+0x1eb0>
81115cd0:	dd003717 	ldw	r20,220(sp)
81115cd4:	d8002a05 	stb	zero,168(sp)
81115cd8:	00801984 	movi	r2,102
81115cdc:	88814026 	beq	r17,r2,811161e0 <___svfprintf_internal_r+0x1e4c>
81115ce0:	00801184 	movi	r2,70
81115ce4:	88817126 	beq	r17,r2,811162ac <___svfprintf_internal_r+0x1f18>
81115ce8:	00801144 	movi	r2,69
81115cec:	b0816226 	beq	r22,r2,81116278 <___svfprintf_internal_r+0x1ee4>
81115cf0:	d8c02917 	ldw	r3,164(sp)
81115cf4:	d8802104 	addi	r2,sp,132
81115cf8:	d8800315 	stw	r2,12(sp)
81115cfc:	d9403617 	ldw	r5,216(sp)
81115d00:	d8802504 	addi	r2,sp,148
81115d04:	d8800215 	stw	r2,8(sp)
81115d08:	d8802604 	addi	r2,sp,152
81115d0c:	d8c00015 	stw	r3,0(sp)
81115d10:	d8800115 	stw	r2,4(sp)
81115d14:	01c00084 	movi	r7,2
81115d18:	a00d883a 	mov	r6,r20
81115d1c:	9809883a 	mov	r4,r19
81115d20:	d8c03d15 	stw	r3,244(sp)
81115d24:	da003e15 	stw	r8,248(sp)
81115d28:	111a5200 	call	8111a520 <_dtoa_r>
81115d2c:	1021883a 	mov	r16,r2
81115d30:	008019c4 	movi	r2,103
81115d34:	d8c03d17 	ldw	r3,244(sp)
81115d38:	da003e17 	ldw	r8,248(sp)
81115d3c:	8880e726 	beq	r17,r2,811160dc <___svfprintf_internal_r+0x1d48>
81115d40:	008011c4 	movi	r2,71
81115d44:	8880d426 	beq	r17,r2,81116098 <___svfprintf_internal_r+0x1d04>
81115d48:	80f9883a 	add	fp,r16,r3
81115d4c:	d9003617 	ldw	r4,216(sp)
81115d50:	000d883a 	mov	r6,zero
81115d54:	000f883a 	mov	r7,zero
81115d58:	a00b883a 	mov	r5,r20
81115d5c:	da003e15 	stw	r8,248(sp)
81115d60:	1126fac0 	call	81126fac <__eqdf2>
81115d64:	da003e17 	ldw	r8,248(sp)
81115d68:	1000e426 	beq	r2,zero,811160fc <___svfprintf_internal_r+0x1d68>
81115d6c:	d8802117 	ldw	r2,132(sp)
81115d70:	1700062e 	bgeu	r2,fp,81115d8c <___svfprintf_internal_r+0x19f8>
81115d74:	01000c04 	movi	r4,48
81115d78:	10c00044 	addi	r3,r2,1
81115d7c:	d8c02115 	stw	r3,132(sp)
81115d80:	11000005 	stb	r4,0(r2)
81115d84:	d8802117 	ldw	r2,132(sp)
81115d88:	173ffb36 	bltu	r2,fp,81115d78 <__reset+0xfb0f5d78>
81115d8c:	1405c83a 	sub	r2,r2,r16
81115d90:	d8803315 	stw	r2,204(sp)
81115d94:	008011c4 	movi	r2,71
81115d98:	b080c526 	beq	r22,r2,811160b0 <___svfprintf_internal_r+0x1d1c>
81115d9c:	00801944 	movi	r2,101
81115da0:	1441d90e 	bge	r2,r17,81116508 <___svfprintf_internal_r+0x2174>
81115da4:	d8c02617 	ldw	r3,152(sp)
81115da8:	00801984 	movi	r2,102
81115dac:	d8c03215 	stw	r3,200(sp)
81115db0:	88813426 	beq	r17,r2,81116284 <___svfprintf_internal_r+0x1ef0>
81115db4:	d8c03217 	ldw	r3,200(sp)
81115db8:	d9003317 	ldw	r4,204(sp)
81115dbc:	19012516 	blt	r3,r4,81116254 <___svfprintf_internal_r+0x1ec0>
81115dc0:	9480004c 	andi	r18,r18,1
81115dc4:	9001841e 	bne	r18,zero,811163d8 <___svfprintf_internal_r+0x2044>
81115dc8:	1805883a 	mov	r2,r3
81115dcc:	1801cc16 	blt	r3,zero,81116500 <___svfprintf_internal_r+0x216c>
81115dd0:	d8c03217 	ldw	r3,200(sp)
81115dd4:	044019c4 	movi	r17,103
81115dd8:	d8c02e15 	stw	r3,184(sp)
81115ddc:	df002a07 	ldb	fp,168(sp)
81115de0:	e000a61e 	bne	fp,zero,8111607c <___svfprintf_internal_r+0x1ce8>
81115de4:	df002783 	ldbu	fp,158(sp)
81115de8:	d8802a15 	stw	r2,168(sp)
81115dec:	dc802b17 	ldw	r18,172(sp)
81115df0:	d8002915 	stw	zero,164(sp)
81115df4:	003b1706 	br	81114a54 <__reset+0xfb0f4a54>
81115df8:	04204534 	movhi	r16,33044
81115dfc:	843da004 	addi	r16,r16,-2432
81115e00:	003aa606 	br	8111489c <__reset+0xfb0f489c>
81115e04:	d9003917 	ldw	r4,228(sp)
81115e08:	04001004 	movi	r16,64
81115e0c:	800b883a 	mov	r5,r16
81115e10:	1112ecc0 	call	81112ecc <_malloc_r>
81115e14:	d9002c17 	ldw	r4,176(sp)
81115e18:	20800015 	stw	r2,0(r4)
81115e1c:	20800415 	stw	r2,16(r4)
81115e20:	1001cb26 	beq	r2,zero,81116550 <___svfprintf_internal_r+0x21bc>
81115e24:	d8802c17 	ldw	r2,176(sp)
81115e28:	14000515 	stw	r16,20(r2)
81115e2c:	00397606 	br	81114408 <__reset+0xfb0f4408>
81115e30:	04204534 	movhi	r16,33044
81115e34:	843da204 	addi	r16,r16,-2424
81115e38:	003ee106 	br	811159c0 <__reset+0xfb0f59c0>
81115e3c:	d9402c17 	ldw	r5,176(sp)
81115e40:	d9801e04 	addi	r6,sp,120
81115e44:	9809883a 	mov	r4,r19
81115e48:	1120e540 	call	81120e54 <__ssprint_r>
81115e4c:	103a381e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115e50:	dc402617 	ldw	r17,152(sp)
81115e54:	d8c02017 	ldw	r3,128(sp)
81115e58:	da000404 	addi	r8,sp,16
81115e5c:	003f4306 	br	81115b6c <__reset+0xfb0f5b6c>
81115e60:	01400184 	movi	r5,6
81115e64:	d9402915 	stw	r5,164(sp)
81115e68:	003f9506 	br	81115cc0 <__reset+0xfb0f5cc0>
81115e6c:	d9002d17 	ldw	r4,180(sp)
81115e70:	25000017 	ldw	r20,0(r4)
81115e74:	21000104 	addi	r4,r4,4
81115e78:	d9002d15 	stw	r4,180(sp)
81115e7c:	a02dd7fa 	srai	r22,r20,31
81115e80:	b005883a 	mov	r2,r22
81115e84:	003a9b06 	br	811148f4 <__reset+0xfb0f48f4>
81115e88:	d9402d17 	ldw	r5,180(sp)
81115e8c:	002d883a 	mov	r22,zero
81115e90:	2d000017 	ldw	r20,0(r5)
81115e94:	29400104 	addi	r5,r5,4
81115e98:	d9402d15 	stw	r5,180(sp)
81115e9c:	003bf906 	br	81114e84 <__reset+0xfb0f4e84>
81115ea0:	9480100c 	andi	r18,r18,64
81115ea4:	90006e26 	beq	r18,zero,81116060 <___svfprintf_internal_r+0x1ccc>
81115ea8:	d9002d17 	ldw	r4,180(sp)
81115eac:	d9402f17 	ldw	r5,188(sp)
81115eb0:	20800017 	ldw	r2,0(r4)
81115eb4:	21000104 	addi	r4,r4,4
81115eb8:	d9002d15 	stw	r4,180(sp)
81115ebc:	1140000d 	sth	r5,0(r2)
81115ec0:	00396106 	br	81114448 <__reset+0xfb0f4448>
81115ec4:	d9402c17 	ldw	r5,176(sp)
81115ec8:	d9801e04 	addi	r6,sp,120
81115ecc:	9809883a 	mov	r4,r19
81115ed0:	1120e540 	call	81120e54 <__ssprint_r>
81115ed4:	103a161e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115ed8:	d8c02017 	ldw	r3,128(sp)
81115edc:	d8801f17 	ldw	r2,124(sp)
81115ee0:	da000404 	addi	r8,sp,16
81115ee4:	d9403317 	ldw	r5,204(sp)
81115ee8:	10800044 	addi	r2,r2,1
81115eec:	44000015 	stw	r16,0(r8)
81115ef0:	28c7883a 	add	r3,r5,r3
81115ef4:	003b7706 	br	81114cd4 <__reset+0xfb0f4cd4>
81115ef8:	8009883a 	mov	r4,r16
81115efc:	da003e15 	stw	r8,248(sp)
81115f00:	111405c0 	call	8111405c <strlen>
81115f04:	d8802e15 	stw	r2,184(sp)
81115f08:	da003e17 	ldw	r8,248(sp)
81115f0c:	103c280e 	bge	r2,zero,81114fb0 <__reset+0xfb0f4fb0>
81115f10:	0005883a 	mov	r2,zero
81115f14:	003c2606 	br	81114fb0 <__reset+0xfb0f4fb0>
81115f18:	00bfffc4 	movi	r2,-1
81115f1c:	003a0906 	br	81114744 <__reset+0xfb0f4744>
81115f20:	01204534 	movhi	r4,33044
81115f24:	213db484 	addi	r4,r4,-2350
81115f28:	d9003515 	stw	r4,212(sp)
81115f2c:	003b0606 	br	81114b48 <__reset+0xfb0f4b48>
81115f30:	013fffc4 	movi	r4,-1
81115f34:	003a2706 	br	811147d4 <__reset+0xfb0f47d4>
81115f38:	d9402c17 	ldw	r5,176(sp)
81115f3c:	d9801e04 	addi	r6,sp,120
81115f40:	9809883a 	mov	r4,r19
81115f44:	1120e540 	call	81120e54 <__ssprint_r>
81115f48:	1039f91e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115f4c:	d8c02017 	ldw	r3,128(sp)
81115f50:	da000404 	addi	r8,sp,16
81115f54:	003d8406 	br	81115568 <__reset+0xfb0f5568>
81115f58:	0023883a 	mov	r17,zero
81115f5c:	003d8306 	br	8111556c <__reset+0xfb0f556c>
81115f60:	01204534 	movhi	r4,33044
81115f64:	213db084 	addi	r4,r4,-2366
81115f68:	d9002b15 	stw	r4,172(sp)
81115f6c:	d9002b17 	ldw	r4,172(sp)
81115f70:	1c47883a 	add	r3,r3,r17
81115f74:	10800044 	addi	r2,r2,1
81115f78:	41000015 	stw	r4,0(r8)
81115f7c:	44400115 	stw	r17,4(r8)
81115f80:	d8c02015 	stw	r3,128(sp)
81115f84:	d8801f15 	stw	r2,124(sp)
81115f88:	010001c4 	movi	r4,7
81115f8c:	20bfcd16 	blt	r4,r2,81115ec4 <__reset+0xfb0f5ec4>
81115f90:	42000204 	addi	r8,r8,8
81115f94:	003fd306 	br	81115ee4 <__reset+0xfb0f5ee4>
81115f98:	d9402c17 	ldw	r5,176(sp)
81115f9c:	d9801e04 	addi	r6,sp,120
81115fa0:	9809883a 	mov	r4,r19
81115fa4:	1120e540 	call	81120e54 <__ssprint_r>
81115fa8:	1039e11e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81115fac:	d8802617 	ldw	r2,152(sp)
81115fb0:	d8c02017 	ldw	r3,128(sp)
81115fb4:	da000404 	addi	r8,sp,16
81115fb8:	003e1c06 	br	8111582c <__reset+0xfb0f582c>
81115fbc:	d8802917 	ldw	r2,164(sp)
81115fc0:	00c00184 	movi	r3,6
81115fc4:	1880012e 	bgeu	r3,r2,81115fcc <___svfprintf_internal_r+0x1c38>
81115fc8:	1805883a 	mov	r2,r3
81115fcc:	d8802e15 	stw	r2,184(sp)
81115fd0:	1000f316 	blt	r2,zero,811163a0 <___svfprintf_internal_r+0x200c>
81115fd4:	04204534 	movhi	r16,33044
81115fd8:	d8802a15 	stw	r2,168(sp)
81115fdc:	dd002d15 	stw	r20,180(sp)
81115fe0:	d8002915 	stw	zero,164(sp)
81115fe4:	d8003215 	stw	zero,200(sp)
81115fe8:	843dae04 	addi	r16,r16,-2376
81115fec:	0039883a 	mov	fp,zero
81115ff0:	003a9f06 	br	81114a70 <__reset+0xfb0f4a70>
81115ff4:	01204534 	movhi	r4,33044
81115ff8:	213db484 	addi	r4,r4,-2350
81115ffc:	d9003515 	stw	r4,212(sp)
81116000:	003b5f06 	br	81114d80 <__reset+0xfb0f4d80>
81116004:	d9402c17 	ldw	r5,176(sp)
81116008:	d9801e04 	addi	r6,sp,120
8111600c:	9809883a 	mov	r4,r19
81116010:	1120e540 	call	81120e54 <__ssprint_r>
81116014:	1039c61e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
81116018:	d8802617 	ldw	r2,152(sp)
8111601c:	d9403317 	ldw	r5,204(sp)
81116020:	d8c02017 	ldw	r3,128(sp)
81116024:	da000404 	addi	r8,sp,16
81116028:	2885c83a 	sub	r2,r5,r2
8111602c:	003e1006 	br	81115870 <__reset+0xfb0f5870>
81116030:	00800044 	movi	r2,1
81116034:	10803fcc 	andi	r2,r2,255
81116038:	00c00044 	movi	r3,1
8111603c:	10fa3526 	beq	r2,r3,81114914 <__reset+0xfb0f4914>
81116040:	00c00084 	movi	r3,2
81116044:	10fb9e26 	beq	r2,r3,81114ec0 <__reset+0xfb0f4ec0>
81116048:	003a6406 	br	811149dc <__reset+0xfb0f49dc>
8111604c:	0021883a 	mov	r16,zero
81116050:	003e0806 	br	81115874 <__reset+0xfb0f5874>
81116054:	07000b44 	movi	fp,45
81116058:	df002785 	stb	fp,158(sp)
8111605c:	003a0b06 	br	8111488c <__reset+0xfb0f488c>
81116060:	d8c02d17 	ldw	r3,180(sp)
81116064:	d9002f17 	ldw	r4,188(sp)
81116068:	18800017 	ldw	r2,0(r3)
8111606c:	18c00104 	addi	r3,r3,4
81116070:	d8c02d15 	stw	r3,180(sp)
81116074:	11000015 	stw	r4,0(r2)
81116078:	0038f306 	br	81114448 <__reset+0xfb0f4448>
8111607c:	00c00b44 	movi	r3,45
81116080:	d8c02785 	stb	r3,158(sp)
81116084:	d8802a15 	stw	r2,168(sp)
81116088:	dc802b17 	ldw	r18,172(sp)
8111608c:	d8002915 	stw	zero,164(sp)
81116090:	07000b44 	movi	fp,45
81116094:	003a7306 	br	81114a64 <__reset+0xfb0f4a64>
81116098:	9080004c 	andi	r2,r18,1
8111609c:	1000941e 	bne	r2,zero,811162f0 <___svfprintf_internal_r+0x1f5c>
811160a0:	d8802117 	ldw	r2,132(sp)
811160a4:	1405c83a 	sub	r2,r2,r16
811160a8:	d8803315 	stw	r2,204(sp)
811160ac:	b441161e 	bne	r22,r17,81116508 <___svfprintf_internal_r+0x2174>
811160b0:	dd802617 	ldw	r22,152(sp)
811160b4:	00bfff44 	movi	r2,-3
811160b8:	b0801a16 	blt	r22,r2,81116124 <___svfprintf_internal_r+0x1d90>
811160bc:	d9402917 	ldw	r5,164(sp)
811160c0:	2d801816 	blt	r5,r22,81116124 <___svfprintf_internal_r+0x1d90>
811160c4:	dd803215 	stw	r22,200(sp)
811160c8:	003f3a06 	br	81115db4 <__reset+0xfb0f5db4>
811160cc:	1025883a 	mov	r18,r2
811160d0:	0039883a 	mov	fp,zero
811160d4:	00800084 	movi	r2,2
811160d8:	003fd606 	br	81116034 <__reset+0xfb0f6034>
811160dc:	9080004c 	andi	r2,r18,1
811160e0:	103f191e 	bne	r2,zero,81115d48 <__reset+0xfb0f5d48>
811160e4:	d8802117 	ldw	r2,132(sp)
811160e8:	003f2806 	br	81115d8c <__reset+0xfb0f5d8c>
811160ec:	01204534 	movhi	r4,33044
811160f0:	213db084 	addi	r4,r4,-2366
811160f4:	d9002b15 	stw	r4,172(sp)
811160f8:	003c7c06 	br	811152ec <__reset+0xfb0f52ec>
811160fc:	e005883a 	mov	r2,fp
81116100:	003f2206 	br	81115d8c <__reset+0xfb0f5d8c>
81116104:	d9402917 	ldw	r5,164(sp)
81116108:	df002783 	ldbu	fp,158(sp)
8111610c:	dd002d15 	stw	r20,180(sp)
81116110:	d9402a15 	stw	r5,168(sp)
81116114:	d9402e15 	stw	r5,184(sp)
81116118:	d8002915 	stw	zero,164(sp)
8111611c:	d8003215 	stw	zero,200(sp)
81116120:	003a4c06 	br	81114a54 <__reset+0xfb0f4a54>
81116124:	8c7fff84 	addi	r17,r17,-2
81116128:	b5bfffc4 	addi	r22,r22,-1
8111612c:	dd802615 	stw	r22,152(sp)
81116130:	dc4022c5 	stb	r17,139(sp)
81116134:	b000c316 	blt	r22,zero,81116444 <___svfprintf_internal_r+0x20b0>
81116138:	00800ac4 	movi	r2,43
8111613c:	d8802305 	stb	r2,140(sp)
81116140:	00800244 	movi	r2,9
81116144:	15806e16 	blt	r2,r22,81116300 <___svfprintf_internal_r+0x1f6c>
81116148:	00800c04 	movi	r2,48
8111614c:	b5800c04 	addi	r22,r22,48
81116150:	d8802345 	stb	r2,141(sp)
81116154:	dd802385 	stb	r22,142(sp)
81116158:	d88023c4 	addi	r2,sp,143
8111615c:	df0022c4 	addi	fp,sp,139
81116160:	d8c03317 	ldw	r3,204(sp)
81116164:	1739c83a 	sub	fp,r2,fp
81116168:	d9003317 	ldw	r4,204(sp)
8111616c:	e0c7883a 	add	r3,fp,r3
81116170:	df003b15 	stw	fp,236(sp)
81116174:	d8c02e15 	stw	r3,184(sp)
81116178:	00800044 	movi	r2,1
8111617c:	1100b70e 	bge	r2,r4,8111645c <___svfprintf_internal_r+0x20c8>
81116180:	d8c02e17 	ldw	r3,184(sp)
81116184:	18c00044 	addi	r3,r3,1
81116188:	d8c02e15 	stw	r3,184(sp)
8111618c:	1805883a 	mov	r2,r3
81116190:	1800b016 	blt	r3,zero,81116454 <___svfprintf_internal_r+0x20c0>
81116194:	d8003215 	stw	zero,200(sp)
81116198:	003f1006 	br	81115ddc <__reset+0xfb0f5ddc>
8111619c:	d8802917 	ldw	r2,164(sp)
811161a0:	103ec71e 	bne	r2,zero,81115cc0 <__reset+0xfb0f5cc0>
811161a4:	dc002915 	stw	r16,164(sp)
811161a8:	003ec506 	br	81115cc0 <__reset+0xfb0f5cc0>
811161ac:	d9402c17 	ldw	r5,176(sp)
811161b0:	d9801e04 	addi	r6,sp,120
811161b4:	9809883a 	mov	r4,r19
811161b8:	1120e540 	call	81120e54 <__ssprint_r>
811161bc:	10395c1e 	bne	r2,zero,81114730 <__reset+0xfb0f4730>
811161c0:	dc402617 	ldw	r17,152(sp)
811161c4:	d8c02017 	ldw	r3,128(sp)
811161c8:	d8801f17 	ldw	r2,124(sp)
811161cc:	da000404 	addi	r8,sp,16
811161d0:	003e7706 	br	81115bb0 <__reset+0xfb0f5bb0>
811161d4:	582f883a 	mov	r23,r11
811161d8:	d8002915 	stw	zero,164(sp)
811161dc:	0038c406 	br	811144f0 <__reset+0xfb0f44f0>
811161e0:	d8c02917 	ldw	r3,164(sp)
811161e4:	d8802104 	addi	r2,sp,132
811161e8:	d8800315 	stw	r2,12(sp)
811161ec:	d9403617 	ldw	r5,216(sp)
811161f0:	d8802504 	addi	r2,sp,148
811161f4:	d8800215 	stw	r2,8(sp)
811161f8:	d8802604 	addi	r2,sp,152
811161fc:	d8c00015 	stw	r3,0(sp)
81116200:	9809883a 	mov	r4,r19
81116204:	d8800115 	stw	r2,4(sp)
81116208:	01c000c4 	movi	r7,3
8111620c:	a00d883a 	mov	r6,r20
81116210:	da003e15 	stw	r8,248(sp)
81116214:	111a5200 	call	8111a520 <_dtoa_r>
81116218:	d9002917 	ldw	r4,164(sp)
8111621c:	da003e17 	ldw	r8,248(sp)
81116220:	1021883a 	mov	r16,r2
81116224:	1139883a 	add	fp,r2,r4
81116228:	2007883a 	mov	r3,r4
8111622c:	81000007 	ldb	r4,0(r16)
81116230:	00800c04 	movi	r2,48
81116234:	20806f26 	beq	r4,r2,811163f4 <___svfprintf_internal_r+0x2060>
81116238:	d8c02617 	ldw	r3,152(sp)
8111623c:	e0f9883a 	add	fp,fp,r3
81116240:	003ec206 	br	81115d4c <__reset+0xfb0f5d4c>
81116244:	00c00b44 	movi	r3,45
81116248:	2520003c 	xorhi	r20,r4,32768
8111624c:	d8c02a05 	stb	r3,168(sp)
81116250:	003ea106 	br	81115cd8 <__reset+0xfb0f5cd8>
81116254:	d8c03217 	ldw	r3,200(sp)
81116258:	00c0890e 	bge	zero,r3,81116480 <___svfprintf_internal_r+0x20ec>
8111625c:	00800044 	movi	r2,1
81116260:	d9003317 	ldw	r4,204(sp)
81116264:	1105883a 	add	r2,r2,r4
81116268:	d8802e15 	stw	r2,184(sp)
8111626c:	10005f16 	blt	r2,zero,811163ec <___svfprintf_internal_r+0x2058>
81116270:	044019c4 	movi	r17,103
81116274:	003ed906 	br	81115ddc <__reset+0xfb0f5ddc>
81116278:	d9002917 	ldw	r4,164(sp)
8111627c:	20c00044 	addi	r3,r4,1
81116280:	003e9c06 	br	81115cf4 <__reset+0xfb0f5cf4>
81116284:	d9002917 	ldw	r4,164(sp)
81116288:	00c0680e 	bge	zero,r3,8111642c <___svfprintf_internal_r+0x2098>
8111628c:	2000461e 	bne	r4,zero,811163a8 <___svfprintf_internal_r+0x2014>
81116290:	9480004c 	andi	r18,r18,1
81116294:	9000441e 	bne	r18,zero,811163a8 <___svfprintf_internal_r+0x2014>
81116298:	1805883a 	mov	r2,r3
8111629c:	1800a016 	blt	r3,zero,81116520 <___svfprintf_internal_r+0x218c>
811162a0:	d8c03217 	ldw	r3,200(sp)
811162a4:	d8c02e15 	stw	r3,184(sp)
811162a8:	003ecc06 	br	81115ddc <__reset+0xfb0f5ddc>
811162ac:	d9402917 	ldw	r5,164(sp)
811162b0:	d8802104 	addi	r2,sp,132
811162b4:	d8800315 	stw	r2,12(sp)
811162b8:	d9400015 	stw	r5,0(sp)
811162bc:	d8802504 	addi	r2,sp,148
811162c0:	d9403617 	ldw	r5,216(sp)
811162c4:	d8800215 	stw	r2,8(sp)
811162c8:	d8802604 	addi	r2,sp,152
811162cc:	d8800115 	stw	r2,4(sp)
811162d0:	01c000c4 	movi	r7,3
811162d4:	a00d883a 	mov	r6,r20
811162d8:	9809883a 	mov	r4,r19
811162dc:	da003e15 	stw	r8,248(sp)
811162e0:	111a5200 	call	8111a520 <_dtoa_r>
811162e4:	d8c02917 	ldw	r3,164(sp)
811162e8:	da003e17 	ldw	r8,248(sp)
811162ec:	1021883a 	mov	r16,r2
811162f0:	00801184 	movi	r2,70
811162f4:	80f9883a 	add	fp,r16,r3
811162f8:	88bfcc26 	beq	r17,r2,8111622c <__reset+0xfb0f622c>
811162fc:	003e9306 	br	81115d4c <__reset+0xfb0f5d4c>
81116300:	df0022c4 	addi	fp,sp,139
81116304:	dc002915 	stw	r16,164(sp)
81116308:	9829883a 	mov	r20,r19
8111630c:	e021883a 	mov	r16,fp
81116310:	4027883a 	mov	r19,r8
81116314:	b009883a 	mov	r4,r22
81116318:	01400284 	movi	r5,10
8111631c:	1125adc0 	call	81125adc <__modsi3>
81116320:	10800c04 	addi	r2,r2,48
81116324:	843fffc4 	addi	r16,r16,-1
81116328:	b009883a 	mov	r4,r22
8111632c:	01400284 	movi	r5,10
81116330:	80800005 	stb	r2,0(r16)
81116334:	1125a580 	call	81125a58 <__divsi3>
81116338:	102d883a 	mov	r22,r2
8111633c:	00800244 	movi	r2,9
81116340:	15bff416 	blt	r2,r22,81116314 <__reset+0xfb0f6314>
81116344:	9811883a 	mov	r8,r19
81116348:	b0800c04 	addi	r2,r22,48
8111634c:	a027883a 	mov	r19,r20
81116350:	8029883a 	mov	r20,r16
81116354:	a17fffc4 	addi	r5,r20,-1
81116358:	a0bfffc5 	stb	r2,-1(r20)
8111635c:	dc002917 	ldw	r16,164(sp)
81116360:	2f00752e 	bgeu	r5,fp,81116538 <___svfprintf_internal_r+0x21a4>
81116364:	d9c02384 	addi	r7,sp,142
81116368:	3d0fc83a 	sub	r7,r7,r20
8111636c:	d9002344 	addi	r4,sp,141
81116370:	e1cf883a 	add	r7,fp,r7
81116374:	00000106 	br	8111637c <___svfprintf_internal_r+0x1fe8>
81116378:	28800003 	ldbu	r2,0(r5)
8111637c:	20800005 	stb	r2,0(r4)
81116380:	21000044 	addi	r4,r4,1
81116384:	29400044 	addi	r5,r5,1
81116388:	21fffb1e 	bne	r4,r7,81116378 <__reset+0xfb0f6378>
8111638c:	d8802304 	addi	r2,sp,140
81116390:	1505c83a 	sub	r2,r2,r20
81116394:	d8c02344 	addi	r3,sp,141
81116398:	1885883a 	add	r2,r3,r2
8111639c:	003f7006 	br	81116160 <__reset+0xfb0f6160>
811163a0:	0005883a 	mov	r2,zero
811163a4:	003f0b06 	br	81115fd4 <__reset+0xfb0f5fd4>
811163a8:	d9002917 	ldw	r4,164(sp)
811163ac:	d8c03217 	ldw	r3,200(sp)
811163b0:	20800044 	addi	r2,r4,1
811163b4:	1885883a 	add	r2,r3,r2
811163b8:	d8802e15 	stw	r2,184(sp)
811163bc:	103e870e 	bge	r2,zero,81115ddc <__reset+0xfb0f5ddc>
811163c0:	0005883a 	mov	r2,zero
811163c4:	003e8506 	br	81115ddc <__reset+0xfb0f5ddc>
811163c8:	01204534 	movhi	r4,33044
811163cc:	213db084 	addi	r4,r4,-2366
811163d0:	d9002b15 	stw	r4,172(sp)
811163d4:	003cc506 	br	811156ec <__reset+0xfb0f56ec>
811163d8:	d8c03217 	ldw	r3,200(sp)
811163dc:	18c00044 	addi	r3,r3,1
811163e0:	d8c02e15 	stw	r3,184(sp)
811163e4:	1805883a 	mov	r2,r3
811163e8:	183fa10e 	bge	r3,zero,81116270 <__reset+0xfb0f6270>
811163ec:	0005883a 	mov	r2,zero
811163f0:	003f9f06 	br	81116270 <__reset+0xfb0f6270>
811163f4:	d9003617 	ldw	r4,216(sp)
811163f8:	000d883a 	mov	r6,zero
811163fc:	000f883a 	mov	r7,zero
81116400:	a00b883a 	mov	r5,r20
81116404:	d8c03d15 	stw	r3,244(sp)
81116408:	da003e15 	stw	r8,248(sp)
8111640c:	1126fac0 	call	81126fac <__eqdf2>
81116410:	d8c03d17 	ldw	r3,244(sp)
81116414:	da003e17 	ldw	r8,248(sp)
81116418:	103f8726 	beq	r2,zero,81116238 <__reset+0xfb0f6238>
8111641c:	00800044 	movi	r2,1
81116420:	10c7c83a 	sub	r3,r2,r3
81116424:	d8c02615 	stw	r3,152(sp)
81116428:	003f8406 	br	8111623c <__reset+0xfb0f623c>
8111642c:	20000e1e 	bne	r4,zero,81116468 <___svfprintf_internal_r+0x20d4>
81116430:	9480004c 	andi	r18,r18,1
81116434:	90000c1e 	bne	r18,zero,81116468 <___svfprintf_internal_r+0x20d4>
81116438:	00800044 	movi	r2,1
8111643c:	d8802e15 	stw	r2,184(sp)
81116440:	003e6606 	br	81115ddc <__reset+0xfb0f5ddc>
81116444:	00800b44 	movi	r2,45
81116448:	05adc83a 	sub	r22,zero,r22
8111644c:	d8802305 	stb	r2,140(sp)
81116450:	003f3b06 	br	81116140 <__reset+0xfb0f6140>
81116454:	0005883a 	mov	r2,zero
81116458:	003f4e06 	br	81116194 <__reset+0xfb0f6194>
8111645c:	90a4703a 	and	r18,r18,r2
81116460:	903f4a26 	beq	r18,zero,8111618c <__reset+0xfb0f618c>
81116464:	003f4606 	br	81116180 <__reset+0xfb0f6180>
81116468:	d8c02917 	ldw	r3,164(sp)
8111646c:	18c00084 	addi	r3,r3,2
81116470:	d8c02e15 	stw	r3,184(sp)
81116474:	1805883a 	mov	r2,r3
81116478:	183e580e 	bge	r3,zero,81115ddc <__reset+0xfb0f5ddc>
8111647c:	003fd006 	br	811163c0 <__reset+0xfb0f63c0>
81116480:	00800084 	movi	r2,2
81116484:	10c5c83a 	sub	r2,r2,r3
81116488:	003f7506 	br	81116260 <__reset+0xfb0f6260>
8111648c:	d8802d17 	ldw	r2,180(sp)
81116490:	d9002d17 	ldw	r4,180(sp)
81116494:	bc400043 	ldbu	r17,1(r23)
81116498:	10800017 	ldw	r2,0(r2)
8111649c:	582f883a 	mov	r23,r11
811164a0:	d8802915 	stw	r2,164(sp)
811164a4:	20800104 	addi	r2,r4,4
811164a8:	d9002917 	ldw	r4,164(sp)
811164ac:	d8802d15 	stw	r2,180(sp)
811164b0:	203df00e 	bge	r4,zero,81115c74 <__reset+0xfb0f5c74>
811164b4:	8c403fcc 	andi	r17,r17,255
811164b8:	00bfffc4 	movi	r2,-1
811164bc:	8c40201c 	xori	r17,r17,128
811164c0:	d8802915 	stw	r2,164(sp)
811164c4:	8c7fe004 	addi	r17,r17,-128
811164c8:	00380806 	br	811144ec <__reset+0xfb0f44ec>
811164cc:	9080004c 	andi	r2,r18,1
811164d0:	0039883a 	mov	fp,zero
811164d4:	10000726 	beq	r2,zero,811164f4 <___svfprintf_internal_r+0x2160>
811164d8:	d8c02817 	ldw	r3,160(sp)
811164dc:	dc001dc4 	addi	r16,sp,119
811164e0:	00800c04 	movi	r2,48
811164e4:	1c07c83a 	sub	r3,r3,r16
811164e8:	d8801dc5 	stb	r2,119(sp)
811164ec:	d8c02e15 	stw	r3,184(sp)
811164f0:	00395206 	br	81114a3c <__reset+0xfb0f4a3c>
811164f4:	d8002e15 	stw	zero,184(sp)
811164f8:	dc001e04 	addi	r16,sp,120
811164fc:	00394f06 	br	81114a3c <__reset+0xfb0f4a3c>
81116500:	0005883a 	mov	r2,zero
81116504:	003e3206 	br	81115dd0 <__reset+0xfb0f5dd0>
81116508:	dd802617 	ldw	r22,152(sp)
8111650c:	003f0606 	br	81116128 <__reset+0xfb0f6128>
81116510:	d9c02785 	stb	r7,158(sp)
81116514:	003a5106 	br	81114e5c <__reset+0xfb0f4e5c>
81116518:	d9c02785 	stb	r7,158(sp)
8111651c:	003a3706 	br	81114dfc <__reset+0xfb0f4dfc>
81116520:	0005883a 	mov	r2,zero
81116524:	003f5e06 	br	811162a0 <__reset+0xfb0f62a0>
81116528:	d9c02785 	stb	r7,158(sp)
8111652c:	00391706 	br	8111498c <__reset+0xfb0f498c>
81116530:	d9c02785 	stb	r7,158(sp)
81116534:	0038e606 	br	811148d0 <__reset+0xfb0f48d0>
81116538:	d8802344 	addi	r2,sp,141
8111653c:	003f0806 	br	81116160 <__reset+0xfb0f6160>
81116540:	d9c02785 	stb	r7,158(sp)
81116544:	0038b706 	br	81114824 <__reset+0xfb0f4824>
81116548:	d9c02785 	stb	r7,158(sp)
8111654c:	003adc06 	br	811150c0 <__reset+0xfb0f50c0>
81116550:	d9403917 	ldw	r5,228(sp)
81116554:	00800304 	movi	r2,12
81116558:	28800015 	stw	r2,0(r5)
8111655c:	00bfffc4 	movi	r2,-1
81116560:	00387806 	br	81114744 <__reset+0xfb0f4744>
81116564:	d9c02785 	stb	r7,158(sp)
81116568:	003abf06 	br	81115068 <__reset+0xfb0f5068>
8111656c:	d9c02785 	stb	r7,158(sp)
81116570:	003a9b06 	br	81114fe0 <__reset+0xfb0f4fe0>

81116574 <___vfprintf_internal_r>:
81116574:	deffb804 	addi	sp,sp,-288
81116578:	de00012e 	bgeu	sp,et,81116580 <___vfprintf_internal_r+0xc>
8111657c:	003b68fa 	trap	3
81116580:	dfc04715 	stw	ra,284(sp)
81116584:	ddc04515 	stw	r23,276(sp)
81116588:	dd404315 	stw	r21,268(sp)
8111658c:	d9002c15 	stw	r4,176(sp)
81116590:	282f883a 	mov	r23,r5
81116594:	302b883a 	mov	r21,r6
81116598:	d9c02d15 	stw	r7,180(sp)
8111659c:	df004615 	stw	fp,280(sp)
811165a0:	dd804415 	stw	r22,272(sp)
811165a4:	dd004215 	stw	r20,264(sp)
811165a8:	dcc04115 	stw	r19,260(sp)
811165ac:	dc804015 	stw	r18,256(sp)
811165b0:	dc403f15 	stw	r17,252(sp)
811165b4:	dc003e15 	stw	r16,248(sp)
811165b8:	111d11c0 	call	8111d11c <_localeconv_r>
811165bc:	10800017 	ldw	r2,0(r2)
811165c0:	1009883a 	mov	r4,r2
811165c4:	d8803415 	stw	r2,208(sp)
811165c8:	111405c0 	call	8111405c <strlen>
811165cc:	d8803715 	stw	r2,220(sp)
811165d0:	d8802c17 	ldw	r2,176(sp)
811165d4:	10000226 	beq	r2,zero,811165e0 <___vfprintf_internal_r+0x6c>
811165d8:	10800e17 	ldw	r2,56(r2)
811165dc:	1000f926 	beq	r2,zero,811169c4 <___vfprintf_internal_r+0x450>
811165e0:	b880030b 	ldhu	r2,12(r23)
811165e4:	10c8000c 	andi	r3,r2,8192
811165e8:	1800061e 	bne	r3,zero,81116604 <___vfprintf_internal_r+0x90>
811165ec:	b9001917 	ldw	r4,100(r23)
811165f0:	00f7ffc4 	movi	r3,-8193
811165f4:	10880014 	ori	r2,r2,8192
811165f8:	20c6703a 	and	r3,r4,r3
811165fc:	b880030d 	sth	r2,12(r23)
81116600:	b8c01915 	stw	r3,100(r23)
81116604:	10c0020c 	andi	r3,r2,8
81116608:	1800c126 	beq	r3,zero,81116910 <___vfprintf_internal_r+0x39c>
8111660c:	b8c00417 	ldw	r3,16(r23)
81116610:	1800bf26 	beq	r3,zero,81116910 <___vfprintf_internal_r+0x39c>
81116614:	1080068c 	andi	r2,r2,26
81116618:	00c00284 	movi	r3,10
8111661c:	10c0c426 	beq	r2,r3,81116930 <___vfprintf_internal_r+0x3bc>
81116620:	d8c00404 	addi	r3,sp,16
81116624:	05204534 	movhi	r20,33044
81116628:	d9001e04 	addi	r4,sp,120
8111662c:	a53db884 	addi	r20,r20,-2334
81116630:	d8c01e15 	stw	r3,120(sp)
81116634:	d8002015 	stw	zero,128(sp)
81116638:	d8001f15 	stw	zero,124(sp)
8111663c:	d8003315 	stw	zero,204(sp)
81116640:	d8003615 	stw	zero,216(sp)
81116644:	d8003815 	stw	zero,224(sp)
81116648:	1811883a 	mov	r8,r3
8111664c:	d8003915 	stw	zero,228(sp)
81116650:	d8003a15 	stw	zero,232(sp)
81116654:	d8002f15 	stw	zero,188(sp)
81116658:	d9002815 	stw	r4,160(sp)
8111665c:	a8800007 	ldb	r2,0(r21)
81116660:	10027b26 	beq	r2,zero,81117050 <___vfprintf_internal_r+0xadc>
81116664:	00c00944 	movi	r3,37
81116668:	a821883a 	mov	r16,r21
8111666c:	10c0021e 	bne	r2,r3,81116678 <___vfprintf_internal_r+0x104>
81116670:	00001406 	br	811166c4 <___vfprintf_internal_r+0x150>
81116674:	10c00326 	beq	r2,r3,81116684 <___vfprintf_internal_r+0x110>
81116678:	84000044 	addi	r16,r16,1
8111667c:	80800007 	ldb	r2,0(r16)
81116680:	103ffc1e 	bne	r2,zero,81116674 <__reset+0xfb0f6674>
81116684:	8563c83a 	sub	r17,r16,r21
81116688:	88000e26 	beq	r17,zero,811166c4 <___vfprintf_internal_r+0x150>
8111668c:	d8c02017 	ldw	r3,128(sp)
81116690:	d8801f17 	ldw	r2,124(sp)
81116694:	45400015 	stw	r21,0(r8)
81116698:	1c47883a 	add	r3,r3,r17
8111669c:	10800044 	addi	r2,r2,1
811166a0:	d8c02015 	stw	r3,128(sp)
811166a4:	44400115 	stw	r17,4(r8)
811166a8:	d8801f15 	stw	r2,124(sp)
811166ac:	00c001c4 	movi	r3,7
811166b0:	1880a716 	blt	r3,r2,81116950 <___vfprintf_internal_r+0x3dc>
811166b4:	42000204 	addi	r8,r8,8
811166b8:	d9402f17 	ldw	r5,188(sp)
811166bc:	2c4b883a 	add	r5,r5,r17
811166c0:	d9402f15 	stw	r5,188(sp)
811166c4:	80800007 	ldb	r2,0(r16)
811166c8:	1000a826 	beq	r2,zero,8111696c <___vfprintf_internal_r+0x3f8>
811166cc:	84400047 	ldb	r17,1(r16)
811166d0:	00bfffc4 	movi	r2,-1
811166d4:	85400044 	addi	r21,r16,1
811166d8:	d8002785 	stb	zero,158(sp)
811166dc:	0007883a 	mov	r3,zero
811166e0:	000f883a 	mov	r7,zero
811166e4:	d8802915 	stw	r2,164(sp)
811166e8:	d8003115 	stw	zero,196(sp)
811166ec:	0025883a 	mov	r18,zero
811166f0:	01401604 	movi	r5,88
811166f4:	01800244 	movi	r6,9
811166f8:	02800a84 	movi	r10,42
811166fc:	02401b04 	movi	r9,108
81116700:	ad400044 	addi	r21,r21,1
81116704:	88bff804 	addi	r2,r17,-32
81116708:	28830436 	bltu	r5,r2,8111731c <___vfprintf_internal_r+0xda8>
8111670c:	100490ba 	slli	r2,r2,2
81116710:	01204474 	movhi	r4,33041
81116714:	2119c904 	addi	r4,r4,26404
81116718:	1105883a 	add	r2,r2,r4
8111671c:	10800017 	ldw	r2,0(r2)
81116720:	1000683a 	jmp	r2
81116724:	8111723c 	xorhi	r4,r16,17864
81116728:	8111731c 	xori	r4,r16,17868
8111672c:	8111731c 	xori	r4,r16,17868
81116730:	8111725c 	xori	r4,r16,17865
81116734:	8111731c 	xori	r4,r16,17868
81116738:	8111731c 	xori	r4,r16,17868
8111673c:	8111731c 	xori	r4,r16,17868
81116740:	8111731c 	xori	r4,r16,17868
81116744:	8111731c 	xori	r4,r16,17868
81116748:	8111731c 	xori	r4,r16,17868
8111674c:	811169d0 	cmplti	r4,r16,17831
81116750:	81117178 	rdprs	r4,r16,17861
81116754:	8111731c 	xori	r4,r16,17868
81116758:	81116898 	cmpnei	r4,r16,17826
8111675c:	811169f8 	rdprs	r4,r16,17831
81116760:	8111731c 	xori	r4,r16,17868
81116764:	81116a38 	rdprs	r4,r16,17832
81116768:	81116a44 	addi	r4,r16,17833
8111676c:	81116a44 	addi	r4,r16,17833
81116770:	81116a44 	addi	r4,r16,17833
81116774:	81116a44 	addi	r4,r16,17833
81116778:	81116a44 	addi	r4,r16,17833
8111677c:	81116a44 	addi	r4,r16,17833
81116780:	81116a44 	addi	r4,r16,17833
81116784:	81116a44 	addi	r4,r16,17833
81116788:	81116a44 	addi	r4,r16,17833
8111678c:	8111731c 	xori	r4,r16,17868
81116790:	8111731c 	xori	r4,r16,17868
81116794:	8111731c 	xori	r4,r16,17868
81116798:	8111731c 	xori	r4,r16,17868
8111679c:	8111731c 	xori	r4,r16,17868
811167a0:	8111731c 	xori	r4,r16,17868
811167a4:	8111731c 	xori	r4,r16,17868
811167a8:	8111731c 	xori	r4,r16,17868
811167ac:	8111731c 	xori	r4,r16,17868
811167b0:	8111731c 	xori	r4,r16,17868
811167b4:	81116a78 	rdprs	r4,r16,17833
811167b8:	81116b34 	orhi	r4,r16,17836
811167bc:	8111731c 	xori	r4,r16,17868
811167c0:	81116b34 	orhi	r4,r16,17836
811167c4:	8111731c 	xori	r4,r16,17868
811167c8:	8111731c 	xori	r4,r16,17868
811167cc:	8111731c 	xori	r4,r16,17868
811167d0:	8111731c 	xori	r4,r16,17868
811167d4:	81116bd4 	ori	r4,r16,17839
811167d8:	8111731c 	xori	r4,r16,17868
811167dc:	8111731c 	xori	r4,r16,17868
811167e0:	81116be0 	cmpeqi	r4,r16,17839
811167e4:	8111731c 	xori	r4,r16,17868
811167e8:	8111731c 	xori	r4,r16,17868
811167ec:	8111731c 	xori	r4,r16,17868
811167f0:	8111731c 	xori	r4,r16,17868
811167f4:	8111731c 	xori	r4,r16,17868
811167f8:	81117058 	cmpnei	r4,r16,17857
811167fc:	8111731c 	xori	r4,r16,17868
81116800:	8111731c 	xori	r4,r16,17868
81116804:	811170b8 	rdprs	r4,r16,17858
81116808:	8111731c 	xori	r4,r16,17868
8111680c:	8111731c 	xori	r4,r16,17868
81116810:	8111731c 	xori	r4,r16,17868
81116814:	8111731c 	xori	r4,r16,17868
81116818:	8111731c 	xori	r4,r16,17868
8111681c:	8111731c 	xori	r4,r16,17868
81116820:	8111731c 	xori	r4,r16,17868
81116824:	8111731c 	xori	r4,r16,17868
81116828:	8111731c 	xori	r4,r16,17868
8111682c:	8111731c 	xori	r4,r16,17868
81116830:	811172c8 	cmpgei	r4,r16,17867
81116834:	81117268 	cmpgeui	r4,r16,17865
81116838:	81116b34 	orhi	r4,r16,17836
8111683c:	81116b34 	orhi	r4,r16,17836
81116840:	81116b34 	orhi	r4,r16,17836
81116844:	81117278 	rdprs	r4,r16,17865
81116848:	81117268 	cmpgeui	r4,r16,17865
8111684c:	8111731c 	xori	r4,r16,17868
81116850:	8111731c 	xori	r4,r16,17868
81116854:	81117284 	addi	r4,r16,17866
81116858:	8111731c 	xori	r4,r16,17868
8111685c:	81117294 	ori	r4,r16,17866
81116860:	81117168 	cmpgeui	r4,r16,17861
81116864:	811168a4 	muli	r4,r16,17826
81116868:	81117188 	cmpgei	r4,r16,17862
8111686c:	8111731c 	xori	r4,r16,17868
81116870:	81117194 	ori	r4,r16,17862
81116874:	8111731c 	xori	r4,r16,17868
81116878:	811171f0 	cmpltui	r4,r16,17863
8111687c:	8111731c 	xori	r4,r16,17868
81116880:	8111731c 	xori	r4,r16,17868
81116884:	81117200 	call	88111720 <__reset+0x20f1720>
81116888:	d9003117 	ldw	r4,196(sp)
8111688c:	d8802d15 	stw	r2,180(sp)
81116890:	0109c83a 	sub	r4,zero,r4
81116894:	d9003115 	stw	r4,196(sp)
81116898:	94800114 	ori	r18,r18,4
8111689c:	ac400007 	ldb	r17,0(r21)
811168a0:	003f9706 	br	81116700 <__reset+0xfb0f6700>
811168a4:	00800c04 	movi	r2,48
811168a8:	d9002d17 	ldw	r4,180(sp)
811168ac:	d9402917 	ldw	r5,164(sp)
811168b0:	d8802705 	stb	r2,156(sp)
811168b4:	00801e04 	movi	r2,120
811168b8:	d8802745 	stb	r2,157(sp)
811168bc:	d8002785 	stb	zero,158(sp)
811168c0:	20c00104 	addi	r3,r4,4
811168c4:	24c00017 	ldw	r19,0(r4)
811168c8:	002d883a 	mov	r22,zero
811168cc:	90800094 	ori	r2,r18,2
811168d0:	28029a16 	blt	r5,zero,8111733c <___vfprintf_internal_r+0xdc8>
811168d4:	00bfdfc4 	movi	r2,-129
811168d8:	90a4703a 	and	r18,r18,r2
811168dc:	d8c02d15 	stw	r3,180(sp)
811168e0:	94800094 	ori	r18,r18,2
811168e4:	9802871e 	bne	r19,zero,81117304 <___vfprintf_internal_r+0xd90>
811168e8:	00a04534 	movhi	r2,33044
811168ec:	10bda904 	addi	r2,r2,-2396
811168f0:	d8803915 	stw	r2,228(sp)
811168f4:	04401e04 	movi	r17,120
811168f8:	d8802917 	ldw	r2,164(sp)
811168fc:	0039883a 	mov	fp,zero
81116900:	1001e926 	beq	r2,zero,811170a8 <___vfprintf_internal_r+0xb34>
81116904:	0027883a 	mov	r19,zero
81116908:	002d883a 	mov	r22,zero
8111690c:	00020506 	br	81117124 <___vfprintf_internal_r+0xbb0>
81116910:	d9002c17 	ldw	r4,176(sp)
81116914:	b80b883a 	mov	r5,r23
81116918:	111a1600 	call	8111a160 <__swsetup_r>
8111691c:	1005ac1e 	bne	r2,zero,81117fd0 <___vfprintf_internal_r+0x1a5c>
81116920:	b880030b 	ldhu	r2,12(r23)
81116924:	00c00284 	movi	r3,10
81116928:	1080068c 	andi	r2,r2,26
8111692c:	10ff3c1e 	bne	r2,r3,81116620 <__reset+0xfb0f6620>
81116930:	b880038f 	ldh	r2,14(r23)
81116934:	103f3a16 	blt	r2,zero,81116620 <__reset+0xfb0f6620>
81116938:	d9c02d17 	ldw	r7,180(sp)
8111693c:	d9002c17 	ldw	r4,176(sp)
81116940:	a80d883a 	mov	r6,r21
81116944:	b80b883a 	mov	r5,r23
81116948:	11187900 	call	81118790 <__sbprintf>
8111694c:	00001106 	br	81116994 <___vfprintf_internal_r+0x420>
81116950:	d9002c17 	ldw	r4,176(sp)
81116954:	d9801e04 	addi	r6,sp,120
81116958:	b80b883a 	mov	r5,r23
8111695c:	11226040 	call	81122604 <__sprint_r>
81116960:	1000081e 	bne	r2,zero,81116984 <___vfprintf_internal_r+0x410>
81116964:	da000404 	addi	r8,sp,16
81116968:	003f5306 	br	811166b8 <__reset+0xfb0f66b8>
8111696c:	d8802017 	ldw	r2,128(sp)
81116970:	10000426 	beq	r2,zero,81116984 <___vfprintf_internal_r+0x410>
81116974:	d9002c17 	ldw	r4,176(sp)
81116978:	d9801e04 	addi	r6,sp,120
8111697c:	b80b883a 	mov	r5,r23
81116980:	11226040 	call	81122604 <__sprint_r>
81116984:	b880030b 	ldhu	r2,12(r23)
81116988:	1080100c 	andi	r2,r2,64
8111698c:	1005901e 	bne	r2,zero,81117fd0 <___vfprintf_internal_r+0x1a5c>
81116990:	d8802f17 	ldw	r2,188(sp)
81116994:	dfc04717 	ldw	ra,284(sp)
81116998:	df004617 	ldw	fp,280(sp)
8111699c:	ddc04517 	ldw	r23,276(sp)
811169a0:	dd804417 	ldw	r22,272(sp)
811169a4:	dd404317 	ldw	r21,268(sp)
811169a8:	dd004217 	ldw	r20,264(sp)
811169ac:	dcc04117 	ldw	r19,260(sp)
811169b0:	dc804017 	ldw	r18,256(sp)
811169b4:	dc403f17 	ldw	r17,252(sp)
811169b8:	dc003e17 	ldw	r16,248(sp)
811169bc:	dec04804 	addi	sp,sp,288
811169c0:	f800283a 	ret
811169c4:	d9002c17 	ldw	r4,176(sp)
811169c8:	111c1d00 	call	8111c1d0 <__sinit>
811169cc:	003f0406 	br	811165e0 <__reset+0xfb0f65e0>
811169d0:	d8802d17 	ldw	r2,180(sp)
811169d4:	d9002d17 	ldw	r4,180(sp)
811169d8:	10800017 	ldw	r2,0(r2)
811169dc:	d8803115 	stw	r2,196(sp)
811169e0:	20800104 	addi	r2,r4,4
811169e4:	d9003117 	ldw	r4,196(sp)
811169e8:	203fa716 	blt	r4,zero,81116888 <__reset+0xfb0f6888>
811169ec:	d8802d15 	stw	r2,180(sp)
811169f0:	ac400007 	ldb	r17,0(r21)
811169f4:	003f4206 	br	81116700 <__reset+0xfb0f6700>
811169f8:	ac400007 	ldb	r17,0(r21)
811169fc:	aac00044 	addi	r11,r21,1
81116a00:	8a872826 	beq	r17,r10,811186a4 <___vfprintf_internal_r+0x2130>
81116a04:	88bff404 	addi	r2,r17,-48
81116a08:	0009883a 	mov	r4,zero
81116a0c:	30867d36 	bltu	r6,r2,81118404 <___vfprintf_internal_r+0x1e90>
81116a10:	5c400007 	ldb	r17,0(r11)
81116a14:	210002a4 	muli	r4,r4,10
81116a18:	5d400044 	addi	r21,r11,1
81116a1c:	a817883a 	mov	r11,r21
81116a20:	2089883a 	add	r4,r4,r2
81116a24:	88bff404 	addi	r2,r17,-48
81116a28:	30bff92e 	bgeu	r6,r2,81116a10 <__reset+0xfb0f6a10>
81116a2c:	2005c916 	blt	r4,zero,81118154 <___vfprintf_internal_r+0x1be0>
81116a30:	d9002915 	stw	r4,164(sp)
81116a34:	003f3306 	br	81116704 <__reset+0xfb0f6704>
81116a38:	94802014 	ori	r18,r18,128
81116a3c:	ac400007 	ldb	r17,0(r21)
81116a40:	003f2f06 	br	81116700 <__reset+0xfb0f6700>
81116a44:	a809883a 	mov	r4,r21
81116a48:	d8003115 	stw	zero,196(sp)
81116a4c:	88bff404 	addi	r2,r17,-48
81116a50:	0017883a 	mov	r11,zero
81116a54:	24400007 	ldb	r17,0(r4)
81116a58:	5ac002a4 	muli	r11,r11,10
81116a5c:	ad400044 	addi	r21,r21,1
81116a60:	a809883a 	mov	r4,r21
81116a64:	12d7883a 	add	r11,r2,r11
81116a68:	88bff404 	addi	r2,r17,-48
81116a6c:	30bff92e 	bgeu	r6,r2,81116a54 <__reset+0xfb0f6a54>
81116a70:	dac03115 	stw	r11,196(sp)
81116a74:	003f2306 	br	81116704 <__reset+0xfb0f6704>
81116a78:	18c03fcc 	andi	r3,r3,255
81116a7c:	18072b1e 	bne	r3,zero,8111872c <___vfprintf_internal_r+0x21b8>
81116a80:	94800414 	ori	r18,r18,16
81116a84:	9080080c 	andi	r2,r18,32
81116a88:	10037b26 	beq	r2,zero,81117878 <___vfprintf_internal_r+0x1304>
81116a8c:	d9402d17 	ldw	r5,180(sp)
81116a90:	28800117 	ldw	r2,4(r5)
81116a94:	2cc00017 	ldw	r19,0(r5)
81116a98:	29400204 	addi	r5,r5,8
81116a9c:	d9402d15 	stw	r5,180(sp)
81116aa0:	102d883a 	mov	r22,r2
81116aa4:	10044b16 	blt	r2,zero,81117bd4 <___vfprintf_internal_r+0x1660>
81116aa8:	d9402917 	ldw	r5,164(sp)
81116aac:	df002783 	ldbu	fp,158(sp)
81116ab0:	2803bc16 	blt	r5,zero,811179a4 <___vfprintf_internal_r+0x1430>
81116ab4:	00ffdfc4 	movi	r3,-129
81116ab8:	9d84b03a 	or	r2,r19,r22
81116abc:	90e4703a 	and	r18,r18,r3
81116ac0:	10017726 	beq	r2,zero,811170a0 <___vfprintf_internal_r+0xb2c>
81116ac4:	b0038326 	beq	r22,zero,811178d4 <___vfprintf_internal_r+0x1360>
81116ac8:	dc402a15 	stw	r17,168(sp)
81116acc:	dc001e04 	addi	r16,sp,120
81116ad0:	b023883a 	mov	r17,r22
81116ad4:	402d883a 	mov	r22,r8
81116ad8:	9809883a 	mov	r4,r19
81116adc:	880b883a 	mov	r5,r17
81116ae0:	01800284 	movi	r6,10
81116ae4:	000f883a 	mov	r7,zero
81116ae8:	11255180 	call	81125518 <__umoddi3>
81116aec:	10800c04 	addi	r2,r2,48
81116af0:	843fffc4 	addi	r16,r16,-1
81116af4:	9809883a 	mov	r4,r19
81116af8:	880b883a 	mov	r5,r17
81116afc:	80800005 	stb	r2,0(r16)
81116b00:	01800284 	movi	r6,10
81116b04:	000f883a 	mov	r7,zero
81116b08:	1124f980 	call	81124f98 <__udivdi3>
81116b0c:	1027883a 	mov	r19,r2
81116b10:	10c4b03a 	or	r2,r2,r3
81116b14:	1823883a 	mov	r17,r3
81116b18:	103fef1e 	bne	r2,zero,81116ad8 <__reset+0xfb0f6ad8>
81116b1c:	d8c02817 	ldw	r3,160(sp)
81116b20:	dc402a17 	ldw	r17,168(sp)
81116b24:	b011883a 	mov	r8,r22
81116b28:	1c07c83a 	sub	r3,r3,r16
81116b2c:	d8c02e15 	stw	r3,184(sp)
81116b30:	00005906 	br	81116c98 <___vfprintf_internal_r+0x724>
81116b34:	18c03fcc 	andi	r3,r3,255
81116b38:	1806fa1e 	bne	r3,zero,81118724 <___vfprintf_internal_r+0x21b0>
81116b3c:	9080020c 	andi	r2,r18,8
81116b40:	10048a26 	beq	r2,zero,81117d6c <___vfprintf_internal_r+0x17f8>
81116b44:	d8c02d17 	ldw	r3,180(sp)
81116b48:	d9002d17 	ldw	r4,180(sp)
81116b4c:	d9402d17 	ldw	r5,180(sp)
81116b50:	18c00017 	ldw	r3,0(r3)
81116b54:	21000117 	ldw	r4,4(r4)
81116b58:	29400204 	addi	r5,r5,8
81116b5c:	d8c03615 	stw	r3,216(sp)
81116b60:	d9003815 	stw	r4,224(sp)
81116b64:	d9402d15 	stw	r5,180(sp)
81116b68:	d9003617 	ldw	r4,216(sp)
81116b6c:	d9403817 	ldw	r5,224(sp)
81116b70:	da003d15 	stw	r8,244(sp)
81116b74:	04000044 	movi	r16,1
81116b78:	111ec680 	call	8111ec68 <__fpclassifyd>
81116b7c:	da003d17 	ldw	r8,244(sp)
81116b80:	14041f1e 	bne	r2,r16,81117c00 <___vfprintf_internal_r+0x168c>
81116b84:	d9003617 	ldw	r4,216(sp)
81116b88:	d9403817 	ldw	r5,224(sp)
81116b8c:	000d883a 	mov	r6,zero
81116b90:	000f883a 	mov	r7,zero
81116b94:	11271100 	call	81127110 <__ledf2>
81116b98:	da003d17 	ldw	r8,244(sp)
81116b9c:	1005be16 	blt	r2,zero,81118298 <___vfprintf_internal_r+0x1d24>
81116ba0:	df002783 	ldbu	fp,158(sp)
81116ba4:	008011c4 	movi	r2,71
81116ba8:	1445330e 	bge	r2,r17,81118078 <___vfprintf_internal_r+0x1b04>
81116bac:	04204534 	movhi	r16,33044
81116bb0:	843da104 	addi	r16,r16,-2428
81116bb4:	00c000c4 	movi	r3,3
81116bb8:	00bfdfc4 	movi	r2,-129
81116bbc:	d8c02a15 	stw	r3,168(sp)
81116bc0:	90a4703a 	and	r18,r18,r2
81116bc4:	d8c02e15 	stw	r3,184(sp)
81116bc8:	d8002915 	stw	zero,164(sp)
81116bcc:	d8003215 	stw	zero,200(sp)
81116bd0:	00003706 	br	81116cb0 <___vfprintf_internal_r+0x73c>
81116bd4:	94800214 	ori	r18,r18,8
81116bd8:	ac400007 	ldb	r17,0(r21)
81116bdc:	003ec806 	br	81116700 <__reset+0xfb0f6700>
81116be0:	18c03fcc 	andi	r3,r3,255
81116be4:	1806db1e 	bne	r3,zero,81118754 <___vfprintf_internal_r+0x21e0>
81116be8:	94800414 	ori	r18,r18,16
81116bec:	9080080c 	andi	r2,r18,32
81116bf0:	1002d826 	beq	r2,zero,81117754 <___vfprintf_internal_r+0x11e0>
81116bf4:	d9402d17 	ldw	r5,180(sp)
81116bf8:	d8c02917 	ldw	r3,164(sp)
81116bfc:	d8002785 	stb	zero,158(sp)
81116c00:	28800204 	addi	r2,r5,8
81116c04:	2cc00017 	ldw	r19,0(r5)
81116c08:	2d800117 	ldw	r22,4(r5)
81116c0c:	18048f16 	blt	r3,zero,81117e4c <___vfprintf_internal_r+0x18d8>
81116c10:	013fdfc4 	movi	r4,-129
81116c14:	9d86b03a 	or	r3,r19,r22
81116c18:	d8802d15 	stw	r2,180(sp)
81116c1c:	9124703a 	and	r18,r18,r4
81116c20:	1802d91e 	bne	r3,zero,81117788 <___vfprintf_internal_r+0x1214>
81116c24:	d8c02917 	ldw	r3,164(sp)
81116c28:	0039883a 	mov	fp,zero
81116c2c:	1805c326 	beq	r3,zero,8111833c <___vfprintf_internal_r+0x1dc8>
81116c30:	0027883a 	mov	r19,zero
81116c34:	002d883a 	mov	r22,zero
81116c38:	dc001e04 	addi	r16,sp,120
81116c3c:	9806d0fa 	srli	r3,r19,3
81116c40:	b008977a 	slli	r4,r22,29
81116c44:	b02cd0fa 	srli	r22,r22,3
81116c48:	9cc001cc 	andi	r19,r19,7
81116c4c:	98800c04 	addi	r2,r19,48
81116c50:	843fffc4 	addi	r16,r16,-1
81116c54:	20e6b03a 	or	r19,r4,r3
81116c58:	80800005 	stb	r2,0(r16)
81116c5c:	9d86b03a 	or	r3,r19,r22
81116c60:	183ff61e 	bne	r3,zero,81116c3c <__reset+0xfb0f6c3c>
81116c64:	90c0004c 	andi	r3,r18,1
81116c68:	18013b26 	beq	r3,zero,81117158 <___vfprintf_internal_r+0xbe4>
81116c6c:	10803fcc 	andi	r2,r2,255
81116c70:	1080201c 	xori	r2,r2,128
81116c74:	10bfe004 	addi	r2,r2,-128
81116c78:	00c00c04 	movi	r3,48
81116c7c:	10c13626 	beq	r2,r3,81117158 <___vfprintf_internal_r+0xbe4>
81116c80:	80ffffc5 	stb	r3,-1(r16)
81116c84:	d8c02817 	ldw	r3,160(sp)
81116c88:	80bfffc4 	addi	r2,r16,-1
81116c8c:	1021883a 	mov	r16,r2
81116c90:	1887c83a 	sub	r3,r3,r2
81116c94:	d8c02e15 	stw	r3,184(sp)
81116c98:	d8802e17 	ldw	r2,184(sp)
81116c9c:	d9002917 	ldw	r4,164(sp)
81116ca0:	1100010e 	bge	r2,r4,81116ca8 <___vfprintf_internal_r+0x734>
81116ca4:	2005883a 	mov	r2,r4
81116ca8:	d8802a15 	stw	r2,168(sp)
81116cac:	d8003215 	stw	zero,200(sp)
81116cb0:	e7003fcc 	andi	fp,fp,255
81116cb4:	e700201c 	xori	fp,fp,128
81116cb8:	e73fe004 	addi	fp,fp,-128
81116cbc:	e0000326 	beq	fp,zero,81116ccc <___vfprintf_internal_r+0x758>
81116cc0:	d8c02a17 	ldw	r3,168(sp)
81116cc4:	18c00044 	addi	r3,r3,1
81116cc8:	d8c02a15 	stw	r3,168(sp)
81116ccc:	90c0008c 	andi	r3,r18,2
81116cd0:	d8c02b15 	stw	r3,172(sp)
81116cd4:	18000326 	beq	r3,zero,81116ce4 <___vfprintf_internal_r+0x770>
81116cd8:	d8c02a17 	ldw	r3,168(sp)
81116cdc:	18c00084 	addi	r3,r3,2
81116ce0:	d8c02a15 	stw	r3,168(sp)
81116ce4:	90c0210c 	andi	r3,r18,132
81116ce8:	d8c03015 	stw	r3,192(sp)
81116cec:	1801a31e 	bne	r3,zero,8111737c <___vfprintf_internal_r+0xe08>
81116cf0:	d9003117 	ldw	r4,196(sp)
81116cf4:	d8c02a17 	ldw	r3,168(sp)
81116cf8:	20e7c83a 	sub	r19,r4,r3
81116cfc:	04c19f0e 	bge	zero,r19,8111737c <___vfprintf_internal_r+0xe08>
81116d00:	02400404 	movi	r9,16
81116d04:	d8c02017 	ldw	r3,128(sp)
81116d08:	d8801f17 	ldw	r2,124(sp)
81116d0c:	4cc50d0e 	bge	r9,r19,81118144 <___vfprintf_internal_r+0x1bd0>
81116d10:	01604534 	movhi	r5,33044
81116d14:	297dbc84 	addi	r5,r5,-2318
81116d18:	dc403b15 	stw	r17,236(sp)
81116d1c:	d9403515 	stw	r5,212(sp)
81116d20:	9823883a 	mov	r17,r19
81116d24:	482d883a 	mov	r22,r9
81116d28:	9027883a 	mov	r19,r18
81116d2c:	070001c4 	movi	fp,7
81116d30:	8025883a 	mov	r18,r16
81116d34:	dc002c17 	ldw	r16,176(sp)
81116d38:	00000306 	br	81116d48 <___vfprintf_internal_r+0x7d4>
81116d3c:	8c7ffc04 	addi	r17,r17,-16
81116d40:	42000204 	addi	r8,r8,8
81116d44:	b440130e 	bge	r22,r17,81116d94 <___vfprintf_internal_r+0x820>
81116d48:	01204534 	movhi	r4,33044
81116d4c:	18c00404 	addi	r3,r3,16
81116d50:	10800044 	addi	r2,r2,1
81116d54:	213dbc84 	addi	r4,r4,-2318
81116d58:	41000015 	stw	r4,0(r8)
81116d5c:	45800115 	stw	r22,4(r8)
81116d60:	d8c02015 	stw	r3,128(sp)
81116d64:	d8801f15 	stw	r2,124(sp)
81116d68:	e0bff40e 	bge	fp,r2,81116d3c <__reset+0xfb0f6d3c>
81116d6c:	d9801e04 	addi	r6,sp,120
81116d70:	b80b883a 	mov	r5,r23
81116d74:	8009883a 	mov	r4,r16
81116d78:	11226040 	call	81122604 <__sprint_r>
81116d7c:	103f011e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81116d80:	8c7ffc04 	addi	r17,r17,-16
81116d84:	d8c02017 	ldw	r3,128(sp)
81116d88:	d8801f17 	ldw	r2,124(sp)
81116d8c:	da000404 	addi	r8,sp,16
81116d90:	b47fed16 	blt	r22,r17,81116d48 <__reset+0xfb0f6d48>
81116d94:	9021883a 	mov	r16,r18
81116d98:	9825883a 	mov	r18,r19
81116d9c:	8827883a 	mov	r19,r17
81116da0:	dc403b17 	ldw	r17,236(sp)
81116da4:	d9403517 	ldw	r5,212(sp)
81116da8:	98c7883a 	add	r3,r19,r3
81116dac:	10800044 	addi	r2,r2,1
81116db0:	41400015 	stw	r5,0(r8)
81116db4:	44c00115 	stw	r19,4(r8)
81116db8:	d8c02015 	stw	r3,128(sp)
81116dbc:	d8801f15 	stw	r2,124(sp)
81116dc0:	010001c4 	movi	r4,7
81116dc4:	2082a316 	blt	r4,r2,81117854 <___vfprintf_internal_r+0x12e0>
81116dc8:	df002787 	ldb	fp,158(sp)
81116dcc:	42000204 	addi	r8,r8,8
81116dd0:	e0000c26 	beq	fp,zero,81116e04 <___vfprintf_internal_r+0x890>
81116dd4:	d8801f17 	ldw	r2,124(sp)
81116dd8:	d9002784 	addi	r4,sp,158
81116ddc:	18c00044 	addi	r3,r3,1
81116de0:	10800044 	addi	r2,r2,1
81116de4:	41000015 	stw	r4,0(r8)
81116de8:	01000044 	movi	r4,1
81116dec:	41000115 	stw	r4,4(r8)
81116df0:	d8c02015 	stw	r3,128(sp)
81116df4:	d8801f15 	stw	r2,124(sp)
81116df8:	010001c4 	movi	r4,7
81116dfc:	20823c16 	blt	r4,r2,811176f0 <___vfprintf_internal_r+0x117c>
81116e00:	42000204 	addi	r8,r8,8
81116e04:	d8802b17 	ldw	r2,172(sp)
81116e08:	10000c26 	beq	r2,zero,81116e3c <___vfprintf_internal_r+0x8c8>
81116e0c:	d8801f17 	ldw	r2,124(sp)
81116e10:	d9002704 	addi	r4,sp,156
81116e14:	18c00084 	addi	r3,r3,2
81116e18:	10800044 	addi	r2,r2,1
81116e1c:	41000015 	stw	r4,0(r8)
81116e20:	01000084 	movi	r4,2
81116e24:	41000115 	stw	r4,4(r8)
81116e28:	d8c02015 	stw	r3,128(sp)
81116e2c:	d8801f15 	stw	r2,124(sp)
81116e30:	010001c4 	movi	r4,7
81116e34:	20823616 	blt	r4,r2,81117710 <___vfprintf_internal_r+0x119c>
81116e38:	42000204 	addi	r8,r8,8
81116e3c:	d9003017 	ldw	r4,192(sp)
81116e40:	00802004 	movi	r2,128
81116e44:	20819926 	beq	r4,r2,811174ac <___vfprintf_internal_r+0xf38>
81116e48:	d9402917 	ldw	r5,164(sp)
81116e4c:	d8802e17 	ldw	r2,184(sp)
81116e50:	28adc83a 	sub	r22,r5,r2
81116e54:	0580310e 	bge	zero,r22,81116f1c <___vfprintf_internal_r+0x9a8>
81116e58:	07000404 	movi	fp,16
81116e5c:	d8801f17 	ldw	r2,124(sp)
81116e60:	e584140e 	bge	fp,r22,81117eb4 <___vfprintf_internal_r+0x1940>
81116e64:	01604534 	movhi	r5,33044
81116e68:	297db884 	addi	r5,r5,-2334
81116e6c:	dc402915 	stw	r17,164(sp)
81116e70:	d9402b15 	stw	r5,172(sp)
81116e74:	b023883a 	mov	r17,r22
81116e78:	04c001c4 	movi	r19,7
81116e7c:	a82d883a 	mov	r22,r21
81116e80:	902b883a 	mov	r21,r18
81116e84:	8025883a 	mov	r18,r16
81116e88:	dc002c17 	ldw	r16,176(sp)
81116e8c:	00000306 	br	81116e9c <___vfprintf_internal_r+0x928>
81116e90:	8c7ffc04 	addi	r17,r17,-16
81116e94:	42000204 	addi	r8,r8,8
81116e98:	e440110e 	bge	fp,r17,81116ee0 <___vfprintf_internal_r+0x96c>
81116e9c:	18c00404 	addi	r3,r3,16
81116ea0:	10800044 	addi	r2,r2,1
81116ea4:	45000015 	stw	r20,0(r8)
81116ea8:	47000115 	stw	fp,4(r8)
81116eac:	d8c02015 	stw	r3,128(sp)
81116eb0:	d8801f15 	stw	r2,124(sp)
81116eb4:	98bff60e 	bge	r19,r2,81116e90 <__reset+0xfb0f6e90>
81116eb8:	d9801e04 	addi	r6,sp,120
81116ebc:	b80b883a 	mov	r5,r23
81116ec0:	8009883a 	mov	r4,r16
81116ec4:	11226040 	call	81122604 <__sprint_r>
81116ec8:	103eae1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81116ecc:	8c7ffc04 	addi	r17,r17,-16
81116ed0:	d8c02017 	ldw	r3,128(sp)
81116ed4:	d8801f17 	ldw	r2,124(sp)
81116ed8:	da000404 	addi	r8,sp,16
81116edc:	e47fef16 	blt	fp,r17,81116e9c <__reset+0xfb0f6e9c>
81116ee0:	9021883a 	mov	r16,r18
81116ee4:	a825883a 	mov	r18,r21
81116ee8:	b02b883a 	mov	r21,r22
81116eec:	882d883a 	mov	r22,r17
81116ef0:	dc402917 	ldw	r17,164(sp)
81116ef4:	d9002b17 	ldw	r4,172(sp)
81116ef8:	1d87883a 	add	r3,r3,r22
81116efc:	10800044 	addi	r2,r2,1
81116f00:	41000015 	stw	r4,0(r8)
81116f04:	45800115 	stw	r22,4(r8)
81116f08:	d8c02015 	stw	r3,128(sp)
81116f0c:	d8801f15 	stw	r2,124(sp)
81116f10:	010001c4 	movi	r4,7
81116f14:	2081ee16 	blt	r4,r2,811176d0 <___vfprintf_internal_r+0x115c>
81116f18:	42000204 	addi	r8,r8,8
81116f1c:	9080400c 	andi	r2,r18,256
81116f20:	1001181e 	bne	r2,zero,81117384 <___vfprintf_internal_r+0xe10>
81116f24:	d9402e17 	ldw	r5,184(sp)
81116f28:	d8801f17 	ldw	r2,124(sp)
81116f2c:	44000015 	stw	r16,0(r8)
81116f30:	1947883a 	add	r3,r3,r5
81116f34:	10800044 	addi	r2,r2,1
81116f38:	41400115 	stw	r5,4(r8)
81116f3c:	d8c02015 	stw	r3,128(sp)
81116f40:	d8801f15 	stw	r2,124(sp)
81116f44:	010001c4 	movi	r4,7
81116f48:	2081d316 	blt	r4,r2,81117698 <___vfprintf_internal_r+0x1124>
81116f4c:	42000204 	addi	r8,r8,8
81116f50:	9480010c 	andi	r18,r18,4
81116f54:	90003226 	beq	r18,zero,81117020 <___vfprintf_internal_r+0xaac>
81116f58:	d9403117 	ldw	r5,196(sp)
81116f5c:	d8802a17 	ldw	r2,168(sp)
81116f60:	28a1c83a 	sub	r16,r5,r2
81116f64:	04002e0e 	bge	zero,r16,81117020 <___vfprintf_internal_r+0xaac>
81116f68:	04400404 	movi	r17,16
81116f6c:	d8801f17 	ldw	r2,124(sp)
81116f70:	8c04a20e 	bge	r17,r16,811181fc <___vfprintf_internal_r+0x1c88>
81116f74:	01604534 	movhi	r5,33044
81116f78:	297dbc84 	addi	r5,r5,-2318
81116f7c:	d9403515 	stw	r5,212(sp)
81116f80:	048001c4 	movi	r18,7
81116f84:	dcc02c17 	ldw	r19,176(sp)
81116f88:	00000306 	br	81116f98 <___vfprintf_internal_r+0xa24>
81116f8c:	843ffc04 	addi	r16,r16,-16
81116f90:	42000204 	addi	r8,r8,8
81116f94:	8c00130e 	bge	r17,r16,81116fe4 <___vfprintf_internal_r+0xa70>
81116f98:	01204534 	movhi	r4,33044
81116f9c:	18c00404 	addi	r3,r3,16
81116fa0:	10800044 	addi	r2,r2,1
81116fa4:	213dbc84 	addi	r4,r4,-2318
81116fa8:	41000015 	stw	r4,0(r8)
81116fac:	44400115 	stw	r17,4(r8)
81116fb0:	d8c02015 	stw	r3,128(sp)
81116fb4:	d8801f15 	stw	r2,124(sp)
81116fb8:	90bff40e 	bge	r18,r2,81116f8c <__reset+0xfb0f6f8c>
81116fbc:	d9801e04 	addi	r6,sp,120
81116fc0:	b80b883a 	mov	r5,r23
81116fc4:	9809883a 	mov	r4,r19
81116fc8:	11226040 	call	81122604 <__sprint_r>
81116fcc:	103e6d1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81116fd0:	843ffc04 	addi	r16,r16,-16
81116fd4:	d8c02017 	ldw	r3,128(sp)
81116fd8:	d8801f17 	ldw	r2,124(sp)
81116fdc:	da000404 	addi	r8,sp,16
81116fe0:	8c3fed16 	blt	r17,r16,81116f98 <__reset+0xfb0f6f98>
81116fe4:	d9403517 	ldw	r5,212(sp)
81116fe8:	1c07883a 	add	r3,r3,r16
81116fec:	10800044 	addi	r2,r2,1
81116ff0:	41400015 	stw	r5,0(r8)
81116ff4:	44000115 	stw	r16,4(r8)
81116ff8:	d8c02015 	stw	r3,128(sp)
81116ffc:	d8801f15 	stw	r2,124(sp)
81117000:	010001c4 	movi	r4,7
81117004:	2080060e 	bge	r4,r2,81117020 <___vfprintf_internal_r+0xaac>
81117008:	d9002c17 	ldw	r4,176(sp)
8111700c:	d9801e04 	addi	r6,sp,120
81117010:	b80b883a 	mov	r5,r23
81117014:	11226040 	call	81122604 <__sprint_r>
81117018:	103e5a1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
8111701c:	d8c02017 	ldw	r3,128(sp)
81117020:	d8803117 	ldw	r2,196(sp)
81117024:	d9002a17 	ldw	r4,168(sp)
81117028:	1100010e 	bge	r2,r4,81117030 <___vfprintf_internal_r+0xabc>
8111702c:	2005883a 	mov	r2,r4
81117030:	d9402f17 	ldw	r5,188(sp)
81117034:	288b883a 	add	r5,r5,r2
81117038:	d9402f15 	stw	r5,188(sp)
8111703c:	18019e1e 	bne	r3,zero,811176b8 <___vfprintf_internal_r+0x1144>
81117040:	a8800007 	ldb	r2,0(r21)
81117044:	d8001f15 	stw	zero,124(sp)
81117048:	da000404 	addi	r8,sp,16
8111704c:	103d851e 	bne	r2,zero,81116664 <__reset+0xfb0f6664>
81117050:	a821883a 	mov	r16,r21
81117054:	003d9b06 	br	811166c4 <__reset+0xfb0f66c4>
81117058:	18c03fcc 	andi	r3,r3,255
8111705c:	1805c11e 	bne	r3,zero,81118764 <___vfprintf_internal_r+0x21f0>
81117060:	94800414 	ori	r18,r18,16
81117064:	9080080c 	andi	r2,r18,32
81117068:	10020c26 	beq	r2,zero,8111789c <___vfprintf_internal_r+0x1328>
8111706c:	d8802d17 	ldw	r2,180(sp)
81117070:	d9002917 	ldw	r4,164(sp)
81117074:	d8002785 	stb	zero,158(sp)
81117078:	10c00204 	addi	r3,r2,8
8111707c:	14c00017 	ldw	r19,0(r2)
81117080:	15800117 	ldw	r22,4(r2)
81117084:	20040f16 	blt	r4,zero,811180c4 <___vfprintf_internal_r+0x1b50>
81117088:	013fdfc4 	movi	r4,-129
8111708c:	9d84b03a 	or	r2,r19,r22
81117090:	d8c02d15 	stw	r3,180(sp)
81117094:	9124703a 	and	r18,r18,r4
81117098:	0039883a 	mov	fp,zero
8111709c:	103e891e 	bne	r2,zero,81116ac4 <__reset+0xfb0f6ac4>
811170a0:	d9002917 	ldw	r4,164(sp)
811170a4:	2002c11e 	bne	r4,zero,81117bac <___vfprintf_internal_r+0x1638>
811170a8:	d8002915 	stw	zero,164(sp)
811170ac:	d8002e15 	stw	zero,184(sp)
811170b0:	dc001e04 	addi	r16,sp,120
811170b4:	003ef806 	br	81116c98 <__reset+0xfb0f6c98>
811170b8:	18c03fcc 	andi	r3,r3,255
811170bc:	18059d1e 	bne	r3,zero,81118734 <___vfprintf_internal_r+0x21c0>
811170c0:	01604534 	movhi	r5,33044
811170c4:	297da404 	addi	r5,r5,-2416
811170c8:	d9403915 	stw	r5,228(sp)
811170cc:	9080080c 	andi	r2,r18,32
811170d0:	10005226 	beq	r2,zero,8111721c <___vfprintf_internal_r+0xca8>
811170d4:	d8802d17 	ldw	r2,180(sp)
811170d8:	14c00017 	ldw	r19,0(r2)
811170dc:	15800117 	ldw	r22,4(r2)
811170e0:	10800204 	addi	r2,r2,8
811170e4:	d8802d15 	stw	r2,180(sp)
811170e8:	9080004c 	andi	r2,r18,1
811170ec:	10019026 	beq	r2,zero,81117730 <___vfprintf_internal_r+0x11bc>
811170f0:	9d84b03a 	or	r2,r19,r22
811170f4:	10036926 	beq	r2,zero,81117e9c <___vfprintf_internal_r+0x1928>
811170f8:	d8c02917 	ldw	r3,164(sp)
811170fc:	00800c04 	movi	r2,48
81117100:	d8802705 	stb	r2,156(sp)
81117104:	dc402745 	stb	r17,157(sp)
81117108:	d8002785 	stb	zero,158(sp)
8111710c:	90800094 	ori	r2,r18,2
81117110:	18045d16 	blt	r3,zero,81118288 <___vfprintf_internal_r+0x1d14>
81117114:	00bfdfc4 	movi	r2,-129
81117118:	90a4703a 	and	r18,r18,r2
8111711c:	94800094 	ori	r18,r18,2
81117120:	0039883a 	mov	fp,zero
81117124:	d9003917 	ldw	r4,228(sp)
81117128:	dc001e04 	addi	r16,sp,120
8111712c:	988003cc 	andi	r2,r19,15
81117130:	b006973a 	slli	r3,r22,28
81117134:	2085883a 	add	r2,r4,r2
81117138:	9826d13a 	srli	r19,r19,4
8111713c:	10800003 	ldbu	r2,0(r2)
81117140:	b02cd13a 	srli	r22,r22,4
81117144:	843fffc4 	addi	r16,r16,-1
81117148:	1ce6b03a 	or	r19,r3,r19
8111714c:	80800005 	stb	r2,0(r16)
81117150:	9d84b03a 	or	r2,r19,r22
81117154:	103ff51e 	bne	r2,zero,8111712c <__reset+0xfb0f712c>
81117158:	d8c02817 	ldw	r3,160(sp)
8111715c:	1c07c83a 	sub	r3,r3,r16
81117160:	d8c02e15 	stw	r3,184(sp)
81117164:	003ecc06 	br	81116c98 <__reset+0xfb0f6c98>
81117168:	18c03fcc 	andi	r3,r3,255
8111716c:	183e9f26 	beq	r3,zero,81116bec <__reset+0xfb0f6bec>
81117170:	d9c02785 	stb	r7,158(sp)
81117174:	003e9d06 	br	81116bec <__reset+0xfb0f6bec>
81117178:	00c00044 	movi	r3,1
8111717c:	01c00ac4 	movi	r7,43
81117180:	ac400007 	ldb	r17,0(r21)
81117184:	003d5e06 	br	81116700 <__reset+0xfb0f6700>
81117188:	94800814 	ori	r18,r18,32
8111718c:	ac400007 	ldb	r17,0(r21)
81117190:	003d5b06 	br	81116700 <__reset+0xfb0f6700>
81117194:	d8c02d17 	ldw	r3,180(sp)
81117198:	d8002785 	stb	zero,158(sp)
8111719c:	1c000017 	ldw	r16,0(r3)
811171a0:	1cc00104 	addi	r19,r3,4
811171a4:	80041926 	beq	r16,zero,8111820c <___vfprintf_internal_r+0x1c98>
811171a8:	d9002917 	ldw	r4,164(sp)
811171ac:	2003d016 	blt	r4,zero,811180f0 <___vfprintf_internal_r+0x1b7c>
811171b0:	200d883a 	mov	r6,r4
811171b4:	000b883a 	mov	r5,zero
811171b8:	8009883a 	mov	r4,r16
811171bc:	da003d15 	stw	r8,244(sp)
811171c0:	111d3f80 	call	8111d3f8 <memchr>
811171c4:	da003d17 	ldw	r8,244(sp)
811171c8:	10045426 	beq	r2,zero,8111831c <___vfprintf_internal_r+0x1da8>
811171cc:	1405c83a 	sub	r2,r2,r16
811171d0:	d8802e15 	stw	r2,184(sp)
811171d4:	1003cc16 	blt	r2,zero,81118108 <___vfprintf_internal_r+0x1b94>
811171d8:	df002783 	ldbu	fp,158(sp)
811171dc:	d8802a15 	stw	r2,168(sp)
811171e0:	dcc02d15 	stw	r19,180(sp)
811171e4:	d8002915 	stw	zero,164(sp)
811171e8:	d8003215 	stw	zero,200(sp)
811171ec:	003eb006 	br	81116cb0 <__reset+0xfb0f6cb0>
811171f0:	18c03fcc 	andi	r3,r3,255
811171f4:	183f9b26 	beq	r3,zero,81117064 <__reset+0xfb0f7064>
811171f8:	d9c02785 	stb	r7,158(sp)
811171fc:	003f9906 	br	81117064 <__reset+0xfb0f7064>
81117200:	18c03fcc 	andi	r3,r3,255
81117204:	1805551e 	bne	r3,zero,8111875c <___vfprintf_internal_r+0x21e8>
81117208:	01604534 	movhi	r5,33044
8111720c:	297da904 	addi	r5,r5,-2396
81117210:	d9403915 	stw	r5,228(sp)
81117214:	9080080c 	andi	r2,r18,32
81117218:	103fae1e 	bne	r2,zero,811170d4 <__reset+0xfb0f70d4>
8111721c:	9080040c 	andi	r2,r18,16
81117220:	1002de26 	beq	r2,zero,81117d9c <___vfprintf_internal_r+0x1828>
81117224:	d8c02d17 	ldw	r3,180(sp)
81117228:	002d883a 	mov	r22,zero
8111722c:	1cc00017 	ldw	r19,0(r3)
81117230:	18c00104 	addi	r3,r3,4
81117234:	d8c02d15 	stw	r3,180(sp)
81117238:	003fab06 	br	811170e8 <__reset+0xfb0f70e8>
8111723c:	38803fcc 	andi	r2,r7,255
81117240:	1080201c 	xori	r2,r2,128
81117244:	10bfe004 	addi	r2,r2,-128
81117248:	1002d21e 	bne	r2,zero,81117d94 <___vfprintf_internal_r+0x1820>
8111724c:	00c00044 	movi	r3,1
81117250:	01c00804 	movi	r7,32
81117254:	ac400007 	ldb	r17,0(r21)
81117258:	003d2906 	br	81116700 <__reset+0xfb0f6700>
8111725c:	94800054 	ori	r18,r18,1
81117260:	ac400007 	ldb	r17,0(r21)
81117264:	003d2606 	br	81116700 <__reset+0xfb0f6700>
81117268:	18c03fcc 	andi	r3,r3,255
8111726c:	183e0526 	beq	r3,zero,81116a84 <__reset+0xfb0f6a84>
81117270:	d9c02785 	stb	r7,158(sp)
81117274:	003e0306 	br	81116a84 <__reset+0xfb0f6a84>
81117278:	94801014 	ori	r18,r18,64
8111727c:	ac400007 	ldb	r17,0(r21)
81117280:	003d1f06 	br	81116700 <__reset+0xfb0f6700>
81117284:	ac400007 	ldb	r17,0(r21)
81117288:	8a438726 	beq	r17,r9,811180a8 <___vfprintf_internal_r+0x1b34>
8111728c:	94800414 	ori	r18,r18,16
81117290:	003d1b06 	br	81116700 <__reset+0xfb0f6700>
81117294:	18c03fcc 	andi	r3,r3,255
81117298:	1805341e 	bne	r3,zero,8111876c <___vfprintf_internal_r+0x21f8>
8111729c:	9080080c 	andi	r2,r18,32
811172a0:	1002cd26 	beq	r2,zero,81117dd8 <___vfprintf_internal_r+0x1864>
811172a4:	d9402d17 	ldw	r5,180(sp)
811172a8:	d9002f17 	ldw	r4,188(sp)
811172ac:	28800017 	ldw	r2,0(r5)
811172b0:	2007d7fa 	srai	r3,r4,31
811172b4:	29400104 	addi	r5,r5,4
811172b8:	d9402d15 	stw	r5,180(sp)
811172bc:	11000015 	stw	r4,0(r2)
811172c0:	10c00115 	stw	r3,4(r2)
811172c4:	003ce506 	br	8111665c <__reset+0xfb0f665c>
811172c8:	d8c02d17 	ldw	r3,180(sp)
811172cc:	d9002d17 	ldw	r4,180(sp)
811172d0:	d8002785 	stb	zero,158(sp)
811172d4:	18800017 	ldw	r2,0(r3)
811172d8:	21000104 	addi	r4,r4,4
811172dc:	00c00044 	movi	r3,1
811172e0:	d8c02a15 	stw	r3,168(sp)
811172e4:	d8801405 	stb	r2,80(sp)
811172e8:	d9002d15 	stw	r4,180(sp)
811172ec:	d8c02e15 	stw	r3,184(sp)
811172f0:	d8002915 	stw	zero,164(sp)
811172f4:	d8003215 	stw	zero,200(sp)
811172f8:	dc001404 	addi	r16,sp,80
811172fc:	0039883a 	mov	fp,zero
81117300:	003e7206 	br	81116ccc <__reset+0xfb0f6ccc>
81117304:	01204534 	movhi	r4,33044
81117308:	213da904 	addi	r4,r4,-2396
8111730c:	0039883a 	mov	fp,zero
81117310:	d9003915 	stw	r4,228(sp)
81117314:	04401e04 	movi	r17,120
81117318:	003f8206 	br	81117124 <__reset+0xfb0f7124>
8111731c:	18c03fcc 	andi	r3,r3,255
81117320:	1805061e 	bne	r3,zero,8111873c <___vfprintf_internal_r+0x21c8>
81117324:	883d9126 	beq	r17,zero,8111696c <__reset+0xfb0f696c>
81117328:	00c00044 	movi	r3,1
8111732c:	d8c02a15 	stw	r3,168(sp)
81117330:	dc401405 	stb	r17,80(sp)
81117334:	d8002785 	stb	zero,158(sp)
81117338:	003fec06 	br	811172ec <__reset+0xfb0f72ec>
8111733c:	01604534 	movhi	r5,33044
81117340:	297da904 	addi	r5,r5,-2396
81117344:	d9403915 	stw	r5,228(sp)
81117348:	d8c02d15 	stw	r3,180(sp)
8111734c:	1025883a 	mov	r18,r2
81117350:	04401e04 	movi	r17,120
81117354:	9d84b03a 	or	r2,r19,r22
81117358:	1000fc1e 	bne	r2,zero,8111774c <___vfprintf_internal_r+0x11d8>
8111735c:	0039883a 	mov	fp,zero
81117360:	00800084 	movi	r2,2
81117364:	10803fcc 	andi	r2,r2,255
81117368:	00c00044 	movi	r3,1
8111736c:	10c20f26 	beq	r2,r3,81117bac <___vfprintf_internal_r+0x1638>
81117370:	00c00084 	movi	r3,2
81117374:	10fd6326 	beq	r2,r3,81116904 <__reset+0xfb0f6904>
81117378:	003e2d06 	br	81116c30 <__reset+0xfb0f6c30>
8111737c:	d8c02017 	ldw	r3,128(sp)
81117380:	003e9306 	br	81116dd0 <__reset+0xfb0f6dd0>
81117384:	00801944 	movi	r2,101
81117388:	14407e0e 	bge	r2,r17,81117584 <___vfprintf_internal_r+0x1010>
8111738c:	d9003617 	ldw	r4,216(sp)
81117390:	d9403817 	ldw	r5,224(sp)
81117394:	000d883a 	mov	r6,zero
81117398:	000f883a 	mov	r7,zero
8111739c:	d8c03c15 	stw	r3,240(sp)
811173a0:	da003d15 	stw	r8,244(sp)
811173a4:	1126fac0 	call	81126fac <__eqdf2>
811173a8:	d8c03c17 	ldw	r3,240(sp)
811173ac:	da003d17 	ldw	r8,244(sp)
811173b0:	1000f71e 	bne	r2,zero,81117790 <___vfprintf_internal_r+0x121c>
811173b4:	d8801f17 	ldw	r2,124(sp)
811173b8:	01204534 	movhi	r4,33044
811173bc:	213db004 	addi	r4,r4,-2368
811173c0:	18c00044 	addi	r3,r3,1
811173c4:	10800044 	addi	r2,r2,1
811173c8:	41000015 	stw	r4,0(r8)
811173cc:	01000044 	movi	r4,1
811173d0:	41000115 	stw	r4,4(r8)
811173d4:	d8c02015 	stw	r3,128(sp)
811173d8:	d8801f15 	stw	r2,124(sp)
811173dc:	010001c4 	movi	r4,7
811173e0:	2082b816 	blt	r4,r2,81117ec4 <___vfprintf_internal_r+0x1950>
811173e4:	42000204 	addi	r8,r8,8
811173e8:	d8802617 	ldw	r2,152(sp)
811173ec:	d9403317 	ldw	r5,204(sp)
811173f0:	11400216 	blt	r2,r5,811173fc <___vfprintf_internal_r+0xe88>
811173f4:	9080004c 	andi	r2,r18,1
811173f8:	103ed526 	beq	r2,zero,81116f50 <__reset+0xfb0f6f50>
811173fc:	d8803717 	ldw	r2,220(sp)
81117400:	d9003417 	ldw	r4,208(sp)
81117404:	d9403717 	ldw	r5,220(sp)
81117408:	1887883a 	add	r3,r3,r2
8111740c:	d8801f17 	ldw	r2,124(sp)
81117410:	41000015 	stw	r4,0(r8)
81117414:	41400115 	stw	r5,4(r8)
81117418:	10800044 	addi	r2,r2,1
8111741c:	d8c02015 	stw	r3,128(sp)
81117420:	d8801f15 	stw	r2,124(sp)
81117424:	010001c4 	movi	r4,7
81117428:	20832916 	blt	r4,r2,811180d0 <___vfprintf_internal_r+0x1b5c>
8111742c:	42000204 	addi	r8,r8,8
81117430:	d8803317 	ldw	r2,204(sp)
81117434:	143fffc4 	addi	r16,r2,-1
81117438:	043ec50e 	bge	zero,r16,81116f50 <__reset+0xfb0f6f50>
8111743c:	04400404 	movi	r17,16
81117440:	d8801f17 	ldw	r2,124(sp)
81117444:	8c00880e 	bge	r17,r16,81117668 <___vfprintf_internal_r+0x10f4>
81117448:	01604534 	movhi	r5,33044
8111744c:	297db884 	addi	r5,r5,-2334
81117450:	d9402b15 	stw	r5,172(sp)
81117454:	058001c4 	movi	r22,7
81117458:	dcc02c17 	ldw	r19,176(sp)
8111745c:	00000306 	br	8111746c <___vfprintf_internal_r+0xef8>
81117460:	42000204 	addi	r8,r8,8
81117464:	843ffc04 	addi	r16,r16,-16
81117468:	8c00820e 	bge	r17,r16,81117674 <___vfprintf_internal_r+0x1100>
8111746c:	18c00404 	addi	r3,r3,16
81117470:	10800044 	addi	r2,r2,1
81117474:	45000015 	stw	r20,0(r8)
81117478:	44400115 	stw	r17,4(r8)
8111747c:	d8c02015 	stw	r3,128(sp)
81117480:	d8801f15 	stw	r2,124(sp)
81117484:	b0bff60e 	bge	r22,r2,81117460 <__reset+0xfb0f7460>
81117488:	d9801e04 	addi	r6,sp,120
8111748c:	b80b883a 	mov	r5,r23
81117490:	9809883a 	mov	r4,r19
81117494:	11226040 	call	81122604 <__sprint_r>
81117498:	103d3a1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
8111749c:	d8c02017 	ldw	r3,128(sp)
811174a0:	d8801f17 	ldw	r2,124(sp)
811174a4:	da000404 	addi	r8,sp,16
811174a8:	003fee06 	br	81117464 <__reset+0xfb0f7464>
811174ac:	d9403117 	ldw	r5,196(sp)
811174b0:	d8802a17 	ldw	r2,168(sp)
811174b4:	28adc83a 	sub	r22,r5,r2
811174b8:	05be630e 	bge	zero,r22,81116e48 <__reset+0xfb0f6e48>
811174bc:	07000404 	movi	fp,16
811174c0:	d8801f17 	ldw	r2,124(sp)
811174c4:	e5838f0e 	bge	fp,r22,81118304 <___vfprintf_internal_r+0x1d90>
811174c8:	01604534 	movhi	r5,33044
811174cc:	297db884 	addi	r5,r5,-2334
811174d0:	dc403015 	stw	r17,192(sp)
811174d4:	d9402b15 	stw	r5,172(sp)
811174d8:	b023883a 	mov	r17,r22
811174dc:	04c001c4 	movi	r19,7
811174e0:	a82d883a 	mov	r22,r21
811174e4:	902b883a 	mov	r21,r18
811174e8:	8025883a 	mov	r18,r16
811174ec:	dc002c17 	ldw	r16,176(sp)
811174f0:	00000306 	br	81117500 <___vfprintf_internal_r+0xf8c>
811174f4:	8c7ffc04 	addi	r17,r17,-16
811174f8:	42000204 	addi	r8,r8,8
811174fc:	e440110e 	bge	fp,r17,81117544 <___vfprintf_internal_r+0xfd0>
81117500:	18c00404 	addi	r3,r3,16
81117504:	10800044 	addi	r2,r2,1
81117508:	45000015 	stw	r20,0(r8)
8111750c:	47000115 	stw	fp,4(r8)
81117510:	d8c02015 	stw	r3,128(sp)
81117514:	d8801f15 	stw	r2,124(sp)
81117518:	98bff60e 	bge	r19,r2,811174f4 <__reset+0xfb0f74f4>
8111751c:	d9801e04 	addi	r6,sp,120
81117520:	b80b883a 	mov	r5,r23
81117524:	8009883a 	mov	r4,r16
81117528:	11226040 	call	81122604 <__sprint_r>
8111752c:	103d151e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117530:	8c7ffc04 	addi	r17,r17,-16
81117534:	d8c02017 	ldw	r3,128(sp)
81117538:	d8801f17 	ldw	r2,124(sp)
8111753c:	da000404 	addi	r8,sp,16
81117540:	e47fef16 	blt	fp,r17,81117500 <__reset+0xfb0f7500>
81117544:	9021883a 	mov	r16,r18
81117548:	a825883a 	mov	r18,r21
8111754c:	b02b883a 	mov	r21,r22
81117550:	882d883a 	mov	r22,r17
81117554:	dc403017 	ldw	r17,192(sp)
81117558:	d9002b17 	ldw	r4,172(sp)
8111755c:	1d87883a 	add	r3,r3,r22
81117560:	10800044 	addi	r2,r2,1
81117564:	41000015 	stw	r4,0(r8)
81117568:	45800115 	stw	r22,4(r8)
8111756c:	d8c02015 	stw	r3,128(sp)
81117570:	d8801f15 	stw	r2,124(sp)
81117574:	010001c4 	movi	r4,7
81117578:	20818e16 	blt	r4,r2,81117bb4 <___vfprintf_internal_r+0x1640>
8111757c:	42000204 	addi	r8,r8,8
81117580:	003e3106 	br	81116e48 <__reset+0xfb0f6e48>
81117584:	d9403317 	ldw	r5,204(sp)
81117588:	00800044 	movi	r2,1
8111758c:	18c00044 	addi	r3,r3,1
81117590:	1141530e 	bge	r2,r5,81117ae0 <___vfprintf_internal_r+0x156c>
81117594:	dc401f17 	ldw	r17,124(sp)
81117598:	00800044 	movi	r2,1
8111759c:	40800115 	stw	r2,4(r8)
811175a0:	8c400044 	addi	r17,r17,1
811175a4:	44000015 	stw	r16,0(r8)
811175a8:	d8c02015 	stw	r3,128(sp)
811175ac:	dc401f15 	stw	r17,124(sp)
811175b0:	008001c4 	movi	r2,7
811175b4:	14416b16 	blt	r2,r17,81117b64 <___vfprintf_internal_r+0x15f0>
811175b8:	42000204 	addi	r8,r8,8
811175bc:	d8803717 	ldw	r2,220(sp)
811175c0:	d9003417 	ldw	r4,208(sp)
811175c4:	8c400044 	addi	r17,r17,1
811175c8:	10c7883a 	add	r3,r2,r3
811175cc:	40800115 	stw	r2,4(r8)
811175d0:	41000015 	stw	r4,0(r8)
811175d4:	d8c02015 	stw	r3,128(sp)
811175d8:	dc401f15 	stw	r17,124(sp)
811175dc:	008001c4 	movi	r2,7
811175e0:	14416916 	blt	r2,r17,81117b88 <___vfprintf_internal_r+0x1614>
811175e4:	45800204 	addi	r22,r8,8
811175e8:	d9003617 	ldw	r4,216(sp)
811175ec:	d9403817 	ldw	r5,224(sp)
811175f0:	000d883a 	mov	r6,zero
811175f4:	000f883a 	mov	r7,zero
811175f8:	d8c03c15 	stw	r3,240(sp)
811175fc:	1126fac0 	call	81126fac <__eqdf2>
81117600:	d8c03c17 	ldw	r3,240(sp)
81117604:	1000bc26 	beq	r2,zero,811178f8 <___vfprintf_internal_r+0x1384>
81117608:	d9403317 	ldw	r5,204(sp)
8111760c:	84000044 	addi	r16,r16,1
81117610:	8c400044 	addi	r17,r17,1
81117614:	28bfffc4 	addi	r2,r5,-1
81117618:	1887883a 	add	r3,r3,r2
8111761c:	b0800115 	stw	r2,4(r22)
81117620:	b4000015 	stw	r16,0(r22)
81117624:	d8c02015 	stw	r3,128(sp)
81117628:	dc401f15 	stw	r17,124(sp)
8111762c:	008001c4 	movi	r2,7
81117630:	14414316 	blt	r2,r17,81117b40 <___vfprintf_internal_r+0x15cc>
81117634:	b5800204 	addi	r22,r22,8
81117638:	d9003a17 	ldw	r4,232(sp)
8111763c:	df0022c4 	addi	fp,sp,139
81117640:	8c400044 	addi	r17,r17,1
81117644:	20c7883a 	add	r3,r4,r3
81117648:	b7000015 	stw	fp,0(r22)
8111764c:	b1000115 	stw	r4,4(r22)
81117650:	d8c02015 	stw	r3,128(sp)
81117654:	dc401f15 	stw	r17,124(sp)
81117658:	008001c4 	movi	r2,7
8111765c:	14400e16 	blt	r2,r17,81117698 <___vfprintf_internal_r+0x1124>
81117660:	b2000204 	addi	r8,r22,8
81117664:	003e3a06 	br	81116f50 <__reset+0xfb0f6f50>
81117668:	01204534 	movhi	r4,33044
8111766c:	213db884 	addi	r4,r4,-2334
81117670:	d9002b15 	stw	r4,172(sp)
81117674:	d9002b17 	ldw	r4,172(sp)
81117678:	1c07883a 	add	r3,r3,r16
8111767c:	44000115 	stw	r16,4(r8)
81117680:	41000015 	stw	r4,0(r8)
81117684:	10800044 	addi	r2,r2,1
81117688:	d8c02015 	stw	r3,128(sp)
8111768c:	d8801f15 	stw	r2,124(sp)
81117690:	010001c4 	movi	r4,7
81117694:	20be2d0e 	bge	r4,r2,81116f4c <__reset+0xfb0f6f4c>
81117698:	d9002c17 	ldw	r4,176(sp)
8111769c:	d9801e04 	addi	r6,sp,120
811176a0:	b80b883a 	mov	r5,r23
811176a4:	11226040 	call	81122604 <__sprint_r>
811176a8:	103cb61e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
811176ac:	d8c02017 	ldw	r3,128(sp)
811176b0:	da000404 	addi	r8,sp,16
811176b4:	003e2606 	br	81116f50 <__reset+0xfb0f6f50>
811176b8:	d9002c17 	ldw	r4,176(sp)
811176bc:	d9801e04 	addi	r6,sp,120
811176c0:	b80b883a 	mov	r5,r23
811176c4:	11226040 	call	81122604 <__sprint_r>
811176c8:	103e5d26 	beq	r2,zero,81117040 <__reset+0xfb0f7040>
811176cc:	003cad06 	br	81116984 <__reset+0xfb0f6984>
811176d0:	d9002c17 	ldw	r4,176(sp)
811176d4:	d9801e04 	addi	r6,sp,120
811176d8:	b80b883a 	mov	r5,r23
811176dc:	11226040 	call	81122604 <__sprint_r>
811176e0:	103ca81e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
811176e4:	d8c02017 	ldw	r3,128(sp)
811176e8:	da000404 	addi	r8,sp,16
811176ec:	003e0b06 	br	81116f1c <__reset+0xfb0f6f1c>
811176f0:	d9002c17 	ldw	r4,176(sp)
811176f4:	d9801e04 	addi	r6,sp,120
811176f8:	b80b883a 	mov	r5,r23
811176fc:	11226040 	call	81122604 <__sprint_r>
81117700:	103ca01e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117704:	d8c02017 	ldw	r3,128(sp)
81117708:	da000404 	addi	r8,sp,16
8111770c:	003dbd06 	br	81116e04 <__reset+0xfb0f6e04>
81117710:	d9002c17 	ldw	r4,176(sp)
81117714:	d9801e04 	addi	r6,sp,120
81117718:	b80b883a 	mov	r5,r23
8111771c:	11226040 	call	81122604 <__sprint_r>
81117720:	103c981e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117724:	d8c02017 	ldw	r3,128(sp)
81117728:	da000404 	addi	r8,sp,16
8111772c:	003dc306 	br	81116e3c <__reset+0xfb0f6e3c>
81117730:	d8802917 	ldw	r2,164(sp)
81117734:	d8002785 	stb	zero,158(sp)
81117738:	103f0616 	blt	r2,zero,81117354 <__reset+0xfb0f7354>
8111773c:	00ffdfc4 	movi	r3,-129
81117740:	9d84b03a 	or	r2,r19,r22
81117744:	90e4703a 	and	r18,r18,r3
81117748:	103c6b26 	beq	r2,zero,811168f8 <__reset+0xfb0f68f8>
8111774c:	0039883a 	mov	fp,zero
81117750:	003e7406 	br	81117124 <__reset+0xfb0f7124>
81117754:	9080040c 	andi	r2,r18,16
81117758:	1001b326 	beq	r2,zero,81117e28 <___vfprintf_internal_r+0x18b4>
8111775c:	d9002d17 	ldw	r4,180(sp)
81117760:	d9402917 	ldw	r5,164(sp)
81117764:	d8002785 	stb	zero,158(sp)
81117768:	20800104 	addi	r2,r4,4
8111776c:	24c00017 	ldw	r19,0(r4)
81117770:	002d883a 	mov	r22,zero
81117774:	2801b516 	blt	r5,zero,81117e4c <___vfprintf_internal_r+0x18d8>
81117778:	00ffdfc4 	movi	r3,-129
8111777c:	d8802d15 	stw	r2,180(sp)
81117780:	90e4703a 	and	r18,r18,r3
81117784:	983d2726 	beq	r19,zero,81116c24 <__reset+0xfb0f6c24>
81117788:	0039883a 	mov	fp,zero
8111778c:	003d2a06 	br	81116c38 <__reset+0xfb0f6c38>
81117790:	dc402617 	ldw	r17,152(sp)
81117794:	0441d30e 	bge	zero,r17,81117ee4 <___vfprintf_internal_r+0x1970>
81117798:	dc403217 	ldw	r17,200(sp)
8111779c:	d8803317 	ldw	r2,204(sp)
811177a0:	1440010e 	bge	r2,r17,811177a8 <___vfprintf_internal_r+0x1234>
811177a4:	1023883a 	mov	r17,r2
811177a8:	04400a0e 	bge	zero,r17,811177d4 <___vfprintf_internal_r+0x1260>
811177ac:	d8801f17 	ldw	r2,124(sp)
811177b0:	1c47883a 	add	r3,r3,r17
811177b4:	44000015 	stw	r16,0(r8)
811177b8:	10800044 	addi	r2,r2,1
811177bc:	44400115 	stw	r17,4(r8)
811177c0:	d8c02015 	stw	r3,128(sp)
811177c4:	d8801f15 	stw	r2,124(sp)
811177c8:	010001c4 	movi	r4,7
811177cc:	20826516 	blt	r4,r2,81118164 <___vfprintf_internal_r+0x1bf0>
811177d0:	42000204 	addi	r8,r8,8
811177d4:	88026116 	blt	r17,zero,8111815c <___vfprintf_internal_r+0x1be8>
811177d8:	d9003217 	ldw	r4,200(sp)
811177dc:	2463c83a 	sub	r17,r4,r17
811177e0:	04407b0e 	bge	zero,r17,811179d0 <___vfprintf_internal_r+0x145c>
811177e4:	05800404 	movi	r22,16
811177e8:	d8801f17 	ldw	r2,124(sp)
811177ec:	b4419d0e 	bge	r22,r17,81117e64 <___vfprintf_internal_r+0x18f0>
811177f0:	01204534 	movhi	r4,33044
811177f4:	213db884 	addi	r4,r4,-2334
811177f8:	d9002b15 	stw	r4,172(sp)
811177fc:	070001c4 	movi	fp,7
81117800:	dcc02c17 	ldw	r19,176(sp)
81117804:	00000306 	br	81117814 <___vfprintf_internal_r+0x12a0>
81117808:	42000204 	addi	r8,r8,8
8111780c:	8c7ffc04 	addi	r17,r17,-16
81117810:	b441970e 	bge	r22,r17,81117e70 <___vfprintf_internal_r+0x18fc>
81117814:	18c00404 	addi	r3,r3,16
81117818:	10800044 	addi	r2,r2,1
8111781c:	45000015 	stw	r20,0(r8)
81117820:	45800115 	stw	r22,4(r8)
81117824:	d8c02015 	stw	r3,128(sp)
81117828:	d8801f15 	stw	r2,124(sp)
8111782c:	e0bff60e 	bge	fp,r2,81117808 <__reset+0xfb0f7808>
81117830:	d9801e04 	addi	r6,sp,120
81117834:	b80b883a 	mov	r5,r23
81117838:	9809883a 	mov	r4,r19
8111783c:	11226040 	call	81122604 <__sprint_r>
81117840:	103c501e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117844:	d8c02017 	ldw	r3,128(sp)
81117848:	d8801f17 	ldw	r2,124(sp)
8111784c:	da000404 	addi	r8,sp,16
81117850:	003fee06 	br	8111780c <__reset+0xfb0f780c>
81117854:	d9002c17 	ldw	r4,176(sp)
81117858:	d9801e04 	addi	r6,sp,120
8111785c:	b80b883a 	mov	r5,r23
81117860:	11226040 	call	81122604 <__sprint_r>
81117864:	103c471e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117868:	d8c02017 	ldw	r3,128(sp)
8111786c:	df002787 	ldb	fp,158(sp)
81117870:	da000404 	addi	r8,sp,16
81117874:	003d5606 	br	81116dd0 <__reset+0xfb0f6dd0>
81117878:	9080040c 	andi	r2,r18,16
8111787c:	10016126 	beq	r2,zero,81117e04 <___vfprintf_internal_r+0x1890>
81117880:	d8802d17 	ldw	r2,180(sp)
81117884:	14c00017 	ldw	r19,0(r2)
81117888:	10800104 	addi	r2,r2,4
8111788c:	d8802d15 	stw	r2,180(sp)
81117890:	982dd7fa 	srai	r22,r19,31
81117894:	b005883a 	mov	r2,r22
81117898:	003c8206 	br	81116aa4 <__reset+0xfb0f6aa4>
8111789c:	9080040c 	andi	r2,r18,16
811178a0:	10003526 	beq	r2,zero,81117978 <___vfprintf_internal_r+0x1404>
811178a4:	d9402d17 	ldw	r5,180(sp)
811178a8:	d8c02917 	ldw	r3,164(sp)
811178ac:	d8002785 	stb	zero,158(sp)
811178b0:	28800104 	addi	r2,r5,4
811178b4:	2cc00017 	ldw	r19,0(r5)
811178b8:	002d883a 	mov	r22,zero
811178bc:	18003716 	blt	r3,zero,8111799c <___vfprintf_internal_r+0x1428>
811178c0:	00ffdfc4 	movi	r3,-129
811178c4:	d8802d15 	stw	r2,180(sp)
811178c8:	90e4703a 	and	r18,r18,r3
811178cc:	0039883a 	mov	fp,zero
811178d0:	983df326 	beq	r19,zero,811170a0 <__reset+0xfb0f70a0>
811178d4:	00800244 	movi	r2,9
811178d8:	14fc7b36 	bltu	r2,r19,81116ac8 <__reset+0xfb0f6ac8>
811178dc:	d8c02817 	ldw	r3,160(sp)
811178e0:	dc001dc4 	addi	r16,sp,119
811178e4:	9cc00c04 	addi	r19,r19,48
811178e8:	1c07c83a 	sub	r3,r3,r16
811178ec:	dcc01dc5 	stb	r19,119(sp)
811178f0:	d8c02e15 	stw	r3,184(sp)
811178f4:	003ce806 	br	81116c98 <__reset+0xfb0f6c98>
811178f8:	d8803317 	ldw	r2,204(sp)
811178fc:	143fffc4 	addi	r16,r2,-1
81117900:	043f4d0e 	bge	zero,r16,81117638 <__reset+0xfb0f7638>
81117904:	07000404 	movi	fp,16
81117908:	e400810e 	bge	fp,r16,81117b10 <___vfprintf_internal_r+0x159c>
8111790c:	01604534 	movhi	r5,33044
81117910:	297db884 	addi	r5,r5,-2334
81117914:	d9402b15 	stw	r5,172(sp)
81117918:	01c001c4 	movi	r7,7
8111791c:	dcc02c17 	ldw	r19,176(sp)
81117920:	00000306 	br	81117930 <___vfprintf_internal_r+0x13bc>
81117924:	b5800204 	addi	r22,r22,8
81117928:	843ffc04 	addi	r16,r16,-16
8111792c:	e4007b0e 	bge	fp,r16,81117b1c <___vfprintf_internal_r+0x15a8>
81117930:	18c00404 	addi	r3,r3,16
81117934:	8c400044 	addi	r17,r17,1
81117938:	b5000015 	stw	r20,0(r22)
8111793c:	b7000115 	stw	fp,4(r22)
81117940:	d8c02015 	stw	r3,128(sp)
81117944:	dc401f15 	stw	r17,124(sp)
81117948:	3c7ff60e 	bge	r7,r17,81117924 <__reset+0xfb0f7924>
8111794c:	d9801e04 	addi	r6,sp,120
81117950:	b80b883a 	mov	r5,r23
81117954:	9809883a 	mov	r4,r19
81117958:	d9c03c15 	stw	r7,240(sp)
8111795c:	11226040 	call	81122604 <__sprint_r>
81117960:	d9c03c17 	ldw	r7,240(sp)
81117964:	103c071e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117968:	d8c02017 	ldw	r3,128(sp)
8111796c:	dc401f17 	ldw	r17,124(sp)
81117970:	dd800404 	addi	r22,sp,16
81117974:	003fec06 	br	81117928 <__reset+0xfb0f7928>
81117978:	9080100c 	andi	r2,r18,64
8111797c:	d8002785 	stb	zero,158(sp)
81117980:	10010e26 	beq	r2,zero,81117dbc <___vfprintf_internal_r+0x1848>
81117984:	d9002d17 	ldw	r4,180(sp)
81117988:	d9402917 	ldw	r5,164(sp)
8111798c:	002d883a 	mov	r22,zero
81117990:	20800104 	addi	r2,r4,4
81117994:	24c0000b 	ldhu	r19,0(r4)
81117998:	283fc90e 	bge	r5,zero,811178c0 <__reset+0xfb0f78c0>
8111799c:	d8802d15 	stw	r2,180(sp)
811179a0:	0039883a 	mov	fp,zero
811179a4:	9d84b03a 	or	r2,r19,r22
811179a8:	103c461e 	bne	r2,zero,81116ac4 <__reset+0xfb0f6ac4>
811179ac:	00800044 	movi	r2,1
811179b0:	003e6c06 	br	81117364 <__reset+0xfb0f7364>
811179b4:	d9002c17 	ldw	r4,176(sp)
811179b8:	d9801e04 	addi	r6,sp,120
811179bc:	b80b883a 	mov	r5,r23
811179c0:	11226040 	call	81122604 <__sprint_r>
811179c4:	103bef1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
811179c8:	d8c02017 	ldw	r3,128(sp)
811179cc:	da000404 	addi	r8,sp,16
811179d0:	d9003217 	ldw	r4,200(sp)
811179d4:	d8802617 	ldw	r2,152(sp)
811179d8:	d9403317 	ldw	r5,204(sp)
811179dc:	8123883a 	add	r17,r16,r4
811179e0:	11400216 	blt	r2,r5,811179ec <___vfprintf_internal_r+0x1478>
811179e4:	9100004c 	andi	r4,r18,1
811179e8:	20000d26 	beq	r4,zero,81117a20 <___vfprintf_internal_r+0x14ac>
811179ec:	d9003717 	ldw	r4,220(sp)
811179f0:	d9403417 	ldw	r5,208(sp)
811179f4:	1907883a 	add	r3,r3,r4
811179f8:	d9001f17 	ldw	r4,124(sp)
811179fc:	41400015 	stw	r5,0(r8)
81117a00:	d9403717 	ldw	r5,220(sp)
81117a04:	21000044 	addi	r4,r4,1
81117a08:	d8c02015 	stw	r3,128(sp)
81117a0c:	41400115 	stw	r5,4(r8)
81117a10:	d9001f15 	stw	r4,124(sp)
81117a14:	014001c4 	movi	r5,7
81117a18:	2901e816 	blt	r5,r4,811181bc <___vfprintf_internal_r+0x1c48>
81117a1c:	42000204 	addi	r8,r8,8
81117a20:	d9003317 	ldw	r4,204(sp)
81117a24:	8121883a 	add	r16,r16,r4
81117a28:	2085c83a 	sub	r2,r4,r2
81117a2c:	8461c83a 	sub	r16,r16,r17
81117a30:	1400010e 	bge	r2,r16,81117a38 <___vfprintf_internal_r+0x14c4>
81117a34:	1021883a 	mov	r16,r2
81117a38:	04000a0e 	bge	zero,r16,81117a64 <___vfprintf_internal_r+0x14f0>
81117a3c:	d9001f17 	ldw	r4,124(sp)
81117a40:	1c07883a 	add	r3,r3,r16
81117a44:	44400015 	stw	r17,0(r8)
81117a48:	21000044 	addi	r4,r4,1
81117a4c:	44000115 	stw	r16,4(r8)
81117a50:	d8c02015 	stw	r3,128(sp)
81117a54:	d9001f15 	stw	r4,124(sp)
81117a58:	014001c4 	movi	r5,7
81117a5c:	2901fb16 	blt	r5,r4,8111824c <___vfprintf_internal_r+0x1cd8>
81117a60:	42000204 	addi	r8,r8,8
81117a64:	8001f716 	blt	r16,zero,81118244 <___vfprintf_internal_r+0x1cd0>
81117a68:	1421c83a 	sub	r16,r2,r16
81117a6c:	043d380e 	bge	zero,r16,81116f50 <__reset+0xfb0f6f50>
81117a70:	04400404 	movi	r17,16
81117a74:	d8801f17 	ldw	r2,124(sp)
81117a78:	8c3efb0e 	bge	r17,r16,81117668 <__reset+0xfb0f7668>
81117a7c:	01604534 	movhi	r5,33044
81117a80:	297db884 	addi	r5,r5,-2334
81117a84:	d9402b15 	stw	r5,172(sp)
81117a88:	058001c4 	movi	r22,7
81117a8c:	dcc02c17 	ldw	r19,176(sp)
81117a90:	00000306 	br	81117aa0 <___vfprintf_internal_r+0x152c>
81117a94:	42000204 	addi	r8,r8,8
81117a98:	843ffc04 	addi	r16,r16,-16
81117a9c:	8c3ef50e 	bge	r17,r16,81117674 <__reset+0xfb0f7674>
81117aa0:	18c00404 	addi	r3,r3,16
81117aa4:	10800044 	addi	r2,r2,1
81117aa8:	45000015 	stw	r20,0(r8)
81117aac:	44400115 	stw	r17,4(r8)
81117ab0:	d8c02015 	stw	r3,128(sp)
81117ab4:	d8801f15 	stw	r2,124(sp)
81117ab8:	b0bff60e 	bge	r22,r2,81117a94 <__reset+0xfb0f7a94>
81117abc:	d9801e04 	addi	r6,sp,120
81117ac0:	b80b883a 	mov	r5,r23
81117ac4:	9809883a 	mov	r4,r19
81117ac8:	11226040 	call	81122604 <__sprint_r>
81117acc:	103bad1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117ad0:	d8c02017 	ldw	r3,128(sp)
81117ad4:	d8801f17 	ldw	r2,124(sp)
81117ad8:	da000404 	addi	r8,sp,16
81117adc:	003fee06 	br	81117a98 <__reset+0xfb0f7a98>
81117ae0:	9088703a 	and	r4,r18,r2
81117ae4:	203eab1e 	bne	r4,zero,81117594 <__reset+0xfb0f7594>
81117ae8:	dc401f17 	ldw	r17,124(sp)
81117aec:	40800115 	stw	r2,4(r8)
81117af0:	44000015 	stw	r16,0(r8)
81117af4:	8c400044 	addi	r17,r17,1
81117af8:	d8c02015 	stw	r3,128(sp)
81117afc:	dc401f15 	stw	r17,124(sp)
81117b00:	008001c4 	movi	r2,7
81117b04:	14400e16 	blt	r2,r17,81117b40 <___vfprintf_internal_r+0x15cc>
81117b08:	45800204 	addi	r22,r8,8
81117b0c:	003eca06 	br	81117638 <__reset+0xfb0f7638>
81117b10:	01204534 	movhi	r4,33044
81117b14:	213db884 	addi	r4,r4,-2334
81117b18:	d9002b15 	stw	r4,172(sp)
81117b1c:	d8802b17 	ldw	r2,172(sp)
81117b20:	1c07883a 	add	r3,r3,r16
81117b24:	8c400044 	addi	r17,r17,1
81117b28:	b0800015 	stw	r2,0(r22)
81117b2c:	b4000115 	stw	r16,4(r22)
81117b30:	d8c02015 	stw	r3,128(sp)
81117b34:	dc401f15 	stw	r17,124(sp)
81117b38:	008001c4 	movi	r2,7
81117b3c:	147ebd0e 	bge	r2,r17,81117634 <__reset+0xfb0f7634>
81117b40:	d9002c17 	ldw	r4,176(sp)
81117b44:	d9801e04 	addi	r6,sp,120
81117b48:	b80b883a 	mov	r5,r23
81117b4c:	11226040 	call	81122604 <__sprint_r>
81117b50:	103b8c1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117b54:	d8c02017 	ldw	r3,128(sp)
81117b58:	dc401f17 	ldw	r17,124(sp)
81117b5c:	dd800404 	addi	r22,sp,16
81117b60:	003eb506 	br	81117638 <__reset+0xfb0f7638>
81117b64:	d9002c17 	ldw	r4,176(sp)
81117b68:	d9801e04 	addi	r6,sp,120
81117b6c:	b80b883a 	mov	r5,r23
81117b70:	11226040 	call	81122604 <__sprint_r>
81117b74:	103b831e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117b78:	d8c02017 	ldw	r3,128(sp)
81117b7c:	dc401f17 	ldw	r17,124(sp)
81117b80:	da000404 	addi	r8,sp,16
81117b84:	003e8d06 	br	811175bc <__reset+0xfb0f75bc>
81117b88:	d9002c17 	ldw	r4,176(sp)
81117b8c:	d9801e04 	addi	r6,sp,120
81117b90:	b80b883a 	mov	r5,r23
81117b94:	11226040 	call	81122604 <__sprint_r>
81117b98:	103b7a1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117b9c:	d8c02017 	ldw	r3,128(sp)
81117ba0:	dc401f17 	ldw	r17,124(sp)
81117ba4:	dd800404 	addi	r22,sp,16
81117ba8:	003e8f06 	br	811175e8 <__reset+0xfb0f75e8>
81117bac:	0027883a 	mov	r19,zero
81117bb0:	003f4a06 	br	811178dc <__reset+0xfb0f78dc>
81117bb4:	d9002c17 	ldw	r4,176(sp)
81117bb8:	d9801e04 	addi	r6,sp,120
81117bbc:	b80b883a 	mov	r5,r23
81117bc0:	11226040 	call	81122604 <__sprint_r>
81117bc4:	103b6f1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117bc8:	d8c02017 	ldw	r3,128(sp)
81117bcc:	da000404 	addi	r8,sp,16
81117bd0:	003c9d06 	br	81116e48 <__reset+0xfb0f6e48>
81117bd4:	04e7c83a 	sub	r19,zero,r19
81117bd8:	9804c03a 	cmpne	r2,r19,zero
81117bdc:	05adc83a 	sub	r22,zero,r22
81117be0:	b0adc83a 	sub	r22,r22,r2
81117be4:	d8802917 	ldw	r2,164(sp)
81117be8:	07000b44 	movi	fp,45
81117bec:	df002785 	stb	fp,158(sp)
81117bf0:	10017b16 	blt	r2,zero,811181e0 <___vfprintf_internal_r+0x1c6c>
81117bf4:	00bfdfc4 	movi	r2,-129
81117bf8:	90a4703a 	and	r18,r18,r2
81117bfc:	003bb106 	br	81116ac4 <__reset+0xfb0f6ac4>
81117c00:	d9003617 	ldw	r4,216(sp)
81117c04:	d9403817 	ldw	r5,224(sp)
81117c08:	da003d15 	stw	r8,244(sp)
81117c0c:	111ec680 	call	8111ec68 <__fpclassifyd>
81117c10:	da003d17 	ldw	r8,244(sp)
81117c14:	1000f026 	beq	r2,zero,81117fd8 <___vfprintf_internal_r+0x1a64>
81117c18:	d9002917 	ldw	r4,164(sp)
81117c1c:	05bff7c4 	movi	r22,-33
81117c20:	00bfffc4 	movi	r2,-1
81117c24:	8dac703a 	and	r22,r17,r22
81117c28:	20820026 	beq	r4,r2,8111842c <___vfprintf_internal_r+0x1eb8>
81117c2c:	008011c4 	movi	r2,71
81117c30:	b081f726 	beq	r22,r2,81118410 <___vfprintf_internal_r+0x1e9c>
81117c34:	d9003817 	ldw	r4,224(sp)
81117c38:	90c04014 	ori	r3,r18,256
81117c3c:	d8c02b15 	stw	r3,172(sp)
81117c40:	20021516 	blt	r4,zero,81118498 <___vfprintf_internal_r+0x1f24>
81117c44:	dcc03817 	ldw	r19,224(sp)
81117c48:	d8002a05 	stb	zero,168(sp)
81117c4c:	00801984 	movi	r2,102
81117c50:	8881f926 	beq	r17,r2,81118438 <___vfprintf_internal_r+0x1ec4>
81117c54:	00801184 	movi	r2,70
81117c58:	88821c26 	beq	r17,r2,811184cc <___vfprintf_internal_r+0x1f58>
81117c5c:	00801144 	movi	r2,69
81117c60:	b081ef26 	beq	r22,r2,81118420 <___vfprintf_internal_r+0x1eac>
81117c64:	d8c02917 	ldw	r3,164(sp)
81117c68:	d8802104 	addi	r2,sp,132
81117c6c:	d8800315 	stw	r2,12(sp)
81117c70:	d9403617 	ldw	r5,216(sp)
81117c74:	d8802504 	addi	r2,sp,148
81117c78:	d9002c17 	ldw	r4,176(sp)
81117c7c:	d8800215 	stw	r2,8(sp)
81117c80:	d8802604 	addi	r2,sp,152
81117c84:	d8c00015 	stw	r3,0(sp)
81117c88:	d8800115 	stw	r2,4(sp)
81117c8c:	01c00084 	movi	r7,2
81117c90:	980d883a 	mov	r6,r19
81117c94:	d8c03c15 	stw	r3,240(sp)
81117c98:	da003d15 	stw	r8,244(sp)
81117c9c:	111a5200 	call	8111a520 <_dtoa_r>
81117ca0:	1021883a 	mov	r16,r2
81117ca4:	008019c4 	movi	r2,103
81117ca8:	d8c03c17 	ldw	r3,240(sp)
81117cac:	da003d17 	ldw	r8,244(sp)
81117cb0:	88817126 	beq	r17,r2,81118278 <___vfprintf_internal_r+0x1d04>
81117cb4:	008011c4 	movi	r2,71
81117cb8:	88829226 	beq	r17,r2,81118704 <___vfprintf_internal_r+0x2190>
81117cbc:	80f9883a 	add	fp,r16,r3
81117cc0:	d9003617 	ldw	r4,216(sp)
81117cc4:	000d883a 	mov	r6,zero
81117cc8:	000f883a 	mov	r7,zero
81117ccc:	980b883a 	mov	r5,r19
81117cd0:	da003d15 	stw	r8,244(sp)
81117cd4:	1126fac0 	call	81126fac <__eqdf2>
81117cd8:	da003d17 	ldw	r8,244(sp)
81117cdc:	10018d26 	beq	r2,zero,81118314 <___vfprintf_internal_r+0x1da0>
81117ce0:	d8802117 	ldw	r2,132(sp)
81117ce4:	1700062e 	bgeu	r2,fp,81117d00 <___vfprintf_internal_r+0x178c>
81117ce8:	01000c04 	movi	r4,48
81117cec:	10c00044 	addi	r3,r2,1
81117cf0:	d8c02115 	stw	r3,132(sp)
81117cf4:	11000005 	stb	r4,0(r2)
81117cf8:	d8802117 	ldw	r2,132(sp)
81117cfc:	173ffb36 	bltu	r2,fp,81117cec <__reset+0xfb0f7cec>
81117d00:	1405c83a 	sub	r2,r2,r16
81117d04:	d8803315 	stw	r2,204(sp)
81117d08:	008011c4 	movi	r2,71
81117d0c:	b0817626 	beq	r22,r2,811182e8 <___vfprintf_internal_r+0x1d74>
81117d10:	00801944 	movi	r2,101
81117d14:	1442810e 	bge	r2,r17,8111871c <___vfprintf_internal_r+0x21a8>
81117d18:	d8c02617 	ldw	r3,152(sp)
81117d1c:	00801984 	movi	r2,102
81117d20:	d8c03215 	stw	r3,200(sp)
81117d24:	8881fe26 	beq	r17,r2,81118520 <___vfprintf_internal_r+0x1fac>
81117d28:	d8c03217 	ldw	r3,200(sp)
81117d2c:	d9003317 	ldw	r4,204(sp)
81117d30:	1901dd16 	blt	r3,r4,811184a8 <___vfprintf_internal_r+0x1f34>
81117d34:	9480004c 	andi	r18,r18,1
81117d38:	90022b1e 	bne	r18,zero,811185e8 <___vfprintf_internal_r+0x2074>
81117d3c:	1805883a 	mov	r2,r3
81117d40:	18028016 	blt	r3,zero,81118744 <___vfprintf_internal_r+0x21d0>
81117d44:	d8c03217 	ldw	r3,200(sp)
81117d48:	044019c4 	movi	r17,103
81117d4c:	d8c02e15 	stw	r3,184(sp)
81117d50:	df002a07 	ldb	fp,168(sp)
81117d54:	e001531e 	bne	fp,zero,811182a4 <___vfprintf_internal_r+0x1d30>
81117d58:	df002783 	ldbu	fp,158(sp)
81117d5c:	d8802a15 	stw	r2,168(sp)
81117d60:	dc802b17 	ldw	r18,172(sp)
81117d64:	d8002915 	stw	zero,164(sp)
81117d68:	003bd106 	br	81116cb0 <__reset+0xfb0f6cb0>
81117d6c:	d8802d17 	ldw	r2,180(sp)
81117d70:	d8c02d17 	ldw	r3,180(sp)
81117d74:	d9002d17 	ldw	r4,180(sp)
81117d78:	10800017 	ldw	r2,0(r2)
81117d7c:	18c00117 	ldw	r3,4(r3)
81117d80:	21000204 	addi	r4,r4,8
81117d84:	d8803615 	stw	r2,216(sp)
81117d88:	d8c03815 	stw	r3,224(sp)
81117d8c:	d9002d15 	stw	r4,180(sp)
81117d90:	003b7506 	br	81116b68 <__reset+0xfb0f6b68>
81117d94:	ac400007 	ldb	r17,0(r21)
81117d98:	003a5906 	br	81116700 <__reset+0xfb0f6700>
81117d9c:	9080100c 	andi	r2,r18,64
81117da0:	1000a826 	beq	r2,zero,81118044 <___vfprintf_internal_r+0x1ad0>
81117da4:	d9002d17 	ldw	r4,180(sp)
81117da8:	002d883a 	mov	r22,zero
81117dac:	24c0000b 	ldhu	r19,0(r4)
81117db0:	21000104 	addi	r4,r4,4
81117db4:	d9002d15 	stw	r4,180(sp)
81117db8:	003ccb06 	br	811170e8 <__reset+0xfb0f70e8>
81117dbc:	d8c02d17 	ldw	r3,180(sp)
81117dc0:	d9002917 	ldw	r4,164(sp)
81117dc4:	002d883a 	mov	r22,zero
81117dc8:	18800104 	addi	r2,r3,4
81117dcc:	1cc00017 	ldw	r19,0(r3)
81117dd0:	203ebb0e 	bge	r4,zero,811178c0 <__reset+0xfb0f78c0>
81117dd4:	003ef106 	br	8111799c <__reset+0xfb0f799c>
81117dd8:	9080040c 	andi	r2,r18,16
81117ddc:	1000921e 	bne	r2,zero,81118028 <___vfprintf_internal_r+0x1ab4>
81117de0:	9480100c 	andi	r18,r18,64
81117de4:	90013926 	beq	r18,zero,811182cc <___vfprintf_internal_r+0x1d58>
81117de8:	d9002d17 	ldw	r4,180(sp)
81117dec:	d9402f17 	ldw	r5,188(sp)
81117df0:	20800017 	ldw	r2,0(r4)
81117df4:	21000104 	addi	r4,r4,4
81117df8:	d9002d15 	stw	r4,180(sp)
81117dfc:	1140000d 	sth	r5,0(r2)
81117e00:	003a1606 	br	8111665c <__reset+0xfb0f665c>
81117e04:	9080100c 	andi	r2,r18,64
81117e08:	10008026 	beq	r2,zero,8111800c <___vfprintf_internal_r+0x1a98>
81117e0c:	d8c02d17 	ldw	r3,180(sp)
81117e10:	1cc0000f 	ldh	r19,0(r3)
81117e14:	18c00104 	addi	r3,r3,4
81117e18:	d8c02d15 	stw	r3,180(sp)
81117e1c:	982dd7fa 	srai	r22,r19,31
81117e20:	b005883a 	mov	r2,r22
81117e24:	003b1f06 	br	81116aa4 <__reset+0xfb0f6aa4>
81117e28:	9080100c 	andi	r2,r18,64
81117e2c:	d8002785 	stb	zero,158(sp)
81117e30:	10008a1e 	bne	r2,zero,8111805c <___vfprintf_internal_r+0x1ae8>
81117e34:	d9402d17 	ldw	r5,180(sp)
81117e38:	d8c02917 	ldw	r3,164(sp)
81117e3c:	002d883a 	mov	r22,zero
81117e40:	28800104 	addi	r2,r5,4
81117e44:	2cc00017 	ldw	r19,0(r5)
81117e48:	183e4b0e 	bge	r3,zero,81117778 <__reset+0xfb0f7778>
81117e4c:	9d86b03a 	or	r3,r19,r22
81117e50:	d8802d15 	stw	r2,180(sp)
81117e54:	183e4c1e 	bne	r3,zero,81117788 <__reset+0xfb0f7788>
81117e58:	0039883a 	mov	fp,zero
81117e5c:	0005883a 	mov	r2,zero
81117e60:	003d4006 	br	81117364 <__reset+0xfb0f7364>
81117e64:	01604534 	movhi	r5,33044
81117e68:	297db884 	addi	r5,r5,-2334
81117e6c:	d9402b15 	stw	r5,172(sp)
81117e70:	d9402b17 	ldw	r5,172(sp)
81117e74:	1c47883a 	add	r3,r3,r17
81117e78:	10800044 	addi	r2,r2,1
81117e7c:	41400015 	stw	r5,0(r8)
81117e80:	44400115 	stw	r17,4(r8)
81117e84:	d8c02015 	stw	r3,128(sp)
81117e88:	d8801f15 	stw	r2,124(sp)
81117e8c:	010001c4 	movi	r4,7
81117e90:	20bec816 	blt	r4,r2,811179b4 <__reset+0xfb0f79b4>
81117e94:	42000204 	addi	r8,r8,8
81117e98:	003ecd06 	br	811179d0 <__reset+0xfb0f79d0>
81117e9c:	d9002917 	ldw	r4,164(sp)
81117ea0:	d8002785 	stb	zero,158(sp)
81117ea4:	203d2d16 	blt	r4,zero,8111735c <__reset+0xfb0f735c>
81117ea8:	00bfdfc4 	movi	r2,-129
81117eac:	90a4703a 	and	r18,r18,r2
81117eb0:	003a9106 	br	811168f8 <__reset+0xfb0f68f8>
81117eb4:	01204534 	movhi	r4,33044
81117eb8:	213db884 	addi	r4,r4,-2334
81117ebc:	d9002b15 	stw	r4,172(sp)
81117ec0:	003c0c06 	br	81116ef4 <__reset+0xfb0f6ef4>
81117ec4:	d9002c17 	ldw	r4,176(sp)
81117ec8:	d9801e04 	addi	r6,sp,120
81117ecc:	b80b883a 	mov	r5,r23
81117ed0:	11226040 	call	81122604 <__sprint_r>
81117ed4:	103aab1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117ed8:	d8c02017 	ldw	r3,128(sp)
81117edc:	da000404 	addi	r8,sp,16
81117ee0:	003d4106 	br	811173e8 <__reset+0xfb0f73e8>
81117ee4:	d8801f17 	ldw	r2,124(sp)
81117ee8:	01604534 	movhi	r5,33044
81117eec:	01000044 	movi	r4,1
81117ef0:	18c00044 	addi	r3,r3,1
81117ef4:	10800044 	addi	r2,r2,1
81117ef8:	297db004 	addi	r5,r5,-2368
81117efc:	41000115 	stw	r4,4(r8)
81117f00:	41400015 	stw	r5,0(r8)
81117f04:	d8c02015 	stw	r3,128(sp)
81117f08:	d8801f15 	stw	r2,124(sp)
81117f0c:	010001c4 	movi	r4,7
81117f10:	20805c16 	blt	r4,r2,81118084 <___vfprintf_internal_r+0x1b10>
81117f14:	42000204 	addi	r8,r8,8
81117f18:	8800041e 	bne	r17,zero,81117f2c <___vfprintf_internal_r+0x19b8>
81117f1c:	d8803317 	ldw	r2,204(sp)
81117f20:	1000021e 	bne	r2,zero,81117f2c <___vfprintf_internal_r+0x19b8>
81117f24:	9080004c 	andi	r2,r18,1
81117f28:	103c0926 	beq	r2,zero,81116f50 <__reset+0xfb0f6f50>
81117f2c:	d9003717 	ldw	r4,220(sp)
81117f30:	d8801f17 	ldw	r2,124(sp)
81117f34:	d9403417 	ldw	r5,208(sp)
81117f38:	20c7883a 	add	r3,r4,r3
81117f3c:	10800044 	addi	r2,r2,1
81117f40:	41000115 	stw	r4,4(r8)
81117f44:	41400015 	stw	r5,0(r8)
81117f48:	d8c02015 	stw	r3,128(sp)
81117f4c:	d8801f15 	stw	r2,124(sp)
81117f50:	010001c4 	movi	r4,7
81117f54:	20812116 	blt	r4,r2,811183dc <___vfprintf_internal_r+0x1e68>
81117f58:	42000204 	addi	r8,r8,8
81117f5c:	0463c83a 	sub	r17,zero,r17
81117f60:	0440730e 	bge	zero,r17,81118130 <___vfprintf_internal_r+0x1bbc>
81117f64:	05800404 	movi	r22,16
81117f68:	b440860e 	bge	r22,r17,81118184 <___vfprintf_internal_r+0x1c10>
81117f6c:	01604534 	movhi	r5,33044
81117f70:	297db884 	addi	r5,r5,-2334
81117f74:	d9402b15 	stw	r5,172(sp)
81117f78:	070001c4 	movi	fp,7
81117f7c:	dcc02c17 	ldw	r19,176(sp)
81117f80:	00000306 	br	81117f90 <___vfprintf_internal_r+0x1a1c>
81117f84:	42000204 	addi	r8,r8,8
81117f88:	8c7ffc04 	addi	r17,r17,-16
81117f8c:	b440800e 	bge	r22,r17,81118190 <___vfprintf_internal_r+0x1c1c>
81117f90:	18c00404 	addi	r3,r3,16
81117f94:	10800044 	addi	r2,r2,1
81117f98:	45000015 	stw	r20,0(r8)
81117f9c:	45800115 	stw	r22,4(r8)
81117fa0:	d8c02015 	stw	r3,128(sp)
81117fa4:	d8801f15 	stw	r2,124(sp)
81117fa8:	e0bff60e 	bge	fp,r2,81117f84 <__reset+0xfb0f7f84>
81117fac:	d9801e04 	addi	r6,sp,120
81117fb0:	b80b883a 	mov	r5,r23
81117fb4:	9809883a 	mov	r4,r19
81117fb8:	11226040 	call	81122604 <__sprint_r>
81117fbc:	103a711e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81117fc0:	d8c02017 	ldw	r3,128(sp)
81117fc4:	d8801f17 	ldw	r2,124(sp)
81117fc8:	da000404 	addi	r8,sp,16
81117fcc:	003fee06 	br	81117f88 <__reset+0xfb0f7f88>
81117fd0:	00bfffc4 	movi	r2,-1
81117fd4:	003a6f06 	br	81116994 <__reset+0xfb0f6994>
81117fd8:	008011c4 	movi	r2,71
81117fdc:	1440b816 	blt	r2,r17,811182c0 <___vfprintf_internal_r+0x1d4c>
81117fe0:	04204534 	movhi	r16,33044
81117fe4:	843da204 	addi	r16,r16,-2424
81117fe8:	00c000c4 	movi	r3,3
81117fec:	00bfdfc4 	movi	r2,-129
81117ff0:	d8c02a15 	stw	r3,168(sp)
81117ff4:	90a4703a 	and	r18,r18,r2
81117ff8:	df002783 	ldbu	fp,158(sp)
81117ffc:	d8c02e15 	stw	r3,184(sp)
81118000:	d8002915 	stw	zero,164(sp)
81118004:	d8003215 	stw	zero,200(sp)
81118008:	003b2906 	br	81116cb0 <__reset+0xfb0f6cb0>
8111800c:	d9002d17 	ldw	r4,180(sp)
81118010:	24c00017 	ldw	r19,0(r4)
81118014:	21000104 	addi	r4,r4,4
81118018:	d9002d15 	stw	r4,180(sp)
8111801c:	982dd7fa 	srai	r22,r19,31
81118020:	b005883a 	mov	r2,r22
81118024:	003a9f06 	br	81116aa4 <__reset+0xfb0f6aa4>
81118028:	d9402d17 	ldw	r5,180(sp)
8111802c:	d8c02f17 	ldw	r3,188(sp)
81118030:	28800017 	ldw	r2,0(r5)
81118034:	29400104 	addi	r5,r5,4
81118038:	d9402d15 	stw	r5,180(sp)
8111803c:	10c00015 	stw	r3,0(r2)
81118040:	00398606 	br	8111665c <__reset+0xfb0f665c>
81118044:	d9402d17 	ldw	r5,180(sp)
81118048:	002d883a 	mov	r22,zero
8111804c:	2cc00017 	ldw	r19,0(r5)
81118050:	29400104 	addi	r5,r5,4
81118054:	d9402d15 	stw	r5,180(sp)
81118058:	003c2306 	br	811170e8 <__reset+0xfb0f70e8>
8111805c:	d8c02d17 	ldw	r3,180(sp)
81118060:	d9002917 	ldw	r4,164(sp)
81118064:	002d883a 	mov	r22,zero
81118068:	18800104 	addi	r2,r3,4
8111806c:	1cc0000b 	ldhu	r19,0(r3)
81118070:	203dc10e 	bge	r4,zero,81117778 <__reset+0xfb0f7778>
81118074:	003f7506 	br	81117e4c <__reset+0xfb0f7e4c>
81118078:	04204534 	movhi	r16,33044
8111807c:	843da004 	addi	r16,r16,-2432
81118080:	003acc06 	br	81116bb4 <__reset+0xfb0f6bb4>
81118084:	d9002c17 	ldw	r4,176(sp)
81118088:	d9801e04 	addi	r6,sp,120
8111808c:	b80b883a 	mov	r5,r23
81118090:	11226040 	call	81122604 <__sprint_r>
81118094:	103a3b1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81118098:	dc402617 	ldw	r17,152(sp)
8111809c:	d8c02017 	ldw	r3,128(sp)
811180a0:	da000404 	addi	r8,sp,16
811180a4:	003f9c06 	br	81117f18 <__reset+0xfb0f7f18>
811180a8:	ac400043 	ldbu	r17,1(r21)
811180ac:	94800814 	ori	r18,r18,32
811180b0:	ad400044 	addi	r21,r21,1
811180b4:	8c403fcc 	andi	r17,r17,255
811180b8:	8c40201c 	xori	r17,r17,128
811180bc:	8c7fe004 	addi	r17,r17,-128
811180c0:	00398f06 	br	81116700 <__reset+0xfb0f6700>
811180c4:	d8c02d15 	stw	r3,180(sp)
811180c8:	0039883a 	mov	fp,zero
811180cc:	003e3506 	br	811179a4 <__reset+0xfb0f79a4>
811180d0:	d9002c17 	ldw	r4,176(sp)
811180d4:	d9801e04 	addi	r6,sp,120
811180d8:	b80b883a 	mov	r5,r23
811180dc:	11226040 	call	81122604 <__sprint_r>
811180e0:	103a281e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
811180e4:	d8c02017 	ldw	r3,128(sp)
811180e8:	da000404 	addi	r8,sp,16
811180ec:	003cd006 	br	81117430 <__reset+0xfb0f7430>
811180f0:	8009883a 	mov	r4,r16
811180f4:	da003d15 	stw	r8,244(sp)
811180f8:	111405c0 	call	8111405c <strlen>
811180fc:	d8802e15 	stw	r2,184(sp)
81118100:	da003d17 	ldw	r8,244(sp)
81118104:	103c340e 	bge	r2,zero,811171d8 <__reset+0xfb0f71d8>
81118108:	0005883a 	mov	r2,zero
8111810c:	003c3206 	br	811171d8 <__reset+0xfb0f71d8>
81118110:	d9002c17 	ldw	r4,176(sp)
81118114:	d9801e04 	addi	r6,sp,120
81118118:	b80b883a 	mov	r5,r23
8111811c:	11226040 	call	81122604 <__sprint_r>
81118120:	103a181e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81118124:	d8c02017 	ldw	r3,128(sp)
81118128:	d8801f17 	ldw	r2,124(sp)
8111812c:	da000404 	addi	r8,sp,16
81118130:	d9403317 	ldw	r5,204(sp)
81118134:	10800044 	addi	r2,r2,1
81118138:	44000015 	stw	r16,0(r8)
8111813c:	28c7883a 	add	r3,r5,r3
81118140:	003b7d06 	br	81116f38 <__reset+0xfb0f6f38>
81118144:	01204534 	movhi	r4,33044
81118148:	213dbc84 	addi	r4,r4,-2318
8111814c:	d9003515 	stw	r4,212(sp)
81118150:	003b1406 	br	81116da4 <__reset+0xfb0f6da4>
81118154:	013fffc4 	movi	r4,-1
81118158:	003a3506 	br	81116a30 <__reset+0xfb0f6a30>
8111815c:	0023883a 	mov	r17,zero
81118160:	003d9d06 	br	811177d8 <__reset+0xfb0f77d8>
81118164:	d9002c17 	ldw	r4,176(sp)
81118168:	d9801e04 	addi	r6,sp,120
8111816c:	b80b883a 	mov	r5,r23
81118170:	11226040 	call	81122604 <__sprint_r>
81118174:	103a031e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81118178:	d8c02017 	ldw	r3,128(sp)
8111817c:	da000404 	addi	r8,sp,16
81118180:	003d9406 	br	811177d4 <__reset+0xfb0f77d4>
81118184:	01204534 	movhi	r4,33044
81118188:	213db884 	addi	r4,r4,-2334
8111818c:	d9002b15 	stw	r4,172(sp)
81118190:	d9002b17 	ldw	r4,172(sp)
81118194:	1c47883a 	add	r3,r3,r17
81118198:	10800044 	addi	r2,r2,1
8111819c:	41000015 	stw	r4,0(r8)
811181a0:	44400115 	stw	r17,4(r8)
811181a4:	d8c02015 	stw	r3,128(sp)
811181a8:	d8801f15 	stw	r2,124(sp)
811181ac:	010001c4 	movi	r4,7
811181b0:	20bfd716 	blt	r4,r2,81118110 <__reset+0xfb0f8110>
811181b4:	42000204 	addi	r8,r8,8
811181b8:	003fdd06 	br	81118130 <__reset+0xfb0f8130>
811181bc:	d9002c17 	ldw	r4,176(sp)
811181c0:	d9801e04 	addi	r6,sp,120
811181c4:	b80b883a 	mov	r5,r23
811181c8:	11226040 	call	81122604 <__sprint_r>
811181cc:	1039ed1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
811181d0:	d8802617 	ldw	r2,152(sp)
811181d4:	d8c02017 	ldw	r3,128(sp)
811181d8:	da000404 	addi	r8,sp,16
811181dc:	003e1006 	br	81117a20 <__reset+0xfb0f7a20>
811181e0:	00800044 	movi	r2,1
811181e4:	10803fcc 	andi	r2,r2,255
811181e8:	00c00044 	movi	r3,1
811181ec:	10fa3526 	beq	r2,r3,81116ac4 <__reset+0xfb0f6ac4>
811181f0:	00c00084 	movi	r3,2
811181f4:	10fbcb26 	beq	r2,r3,81117124 <__reset+0xfb0f7124>
811181f8:	003a8f06 	br	81116c38 <__reset+0xfb0f6c38>
811181fc:	01204534 	movhi	r4,33044
81118200:	213dbc84 	addi	r4,r4,-2318
81118204:	d9003515 	stw	r4,212(sp)
81118208:	003b7606 	br	81116fe4 <__reset+0xfb0f6fe4>
8111820c:	d8802917 	ldw	r2,164(sp)
81118210:	00c00184 	movi	r3,6
81118214:	1880012e 	bgeu	r3,r2,8111821c <___vfprintf_internal_r+0x1ca8>
81118218:	1805883a 	mov	r2,r3
8111821c:	d8802e15 	stw	r2,184(sp)
81118220:	1000ef16 	blt	r2,zero,811185e0 <___vfprintf_internal_r+0x206c>
81118224:	04204534 	movhi	r16,33044
81118228:	d8802a15 	stw	r2,168(sp)
8111822c:	dcc02d15 	stw	r19,180(sp)
81118230:	d8002915 	stw	zero,164(sp)
81118234:	d8003215 	stw	zero,200(sp)
81118238:	843dae04 	addi	r16,r16,-2376
8111823c:	0039883a 	mov	fp,zero
81118240:	003aa206 	br	81116ccc <__reset+0xfb0f6ccc>
81118244:	0021883a 	mov	r16,zero
81118248:	003e0706 	br	81117a68 <__reset+0xfb0f7a68>
8111824c:	d9002c17 	ldw	r4,176(sp)
81118250:	d9801e04 	addi	r6,sp,120
81118254:	b80b883a 	mov	r5,r23
81118258:	11226040 	call	81122604 <__sprint_r>
8111825c:	1039c91e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
81118260:	d8802617 	ldw	r2,152(sp)
81118264:	d9403317 	ldw	r5,204(sp)
81118268:	d8c02017 	ldw	r3,128(sp)
8111826c:	da000404 	addi	r8,sp,16
81118270:	2885c83a 	sub	r2,r5,r2
81118274:	003dfb06 	br	81117a64 <__reset+0xfb0f7a64>
81118278:	9080004c 	andi	r2,r18,1
8111827c:	103e8f1e 	bne	r2,zero,81117cbc <__reset+0xfb0f7cbc>
81118280:	d8802117 	ldw	r2,132(sp)
81118284:	003e9e06 	br	81117d00 <__reset+0xfb0f7d00>
81118288:	1025883a 	mov	r18,r2
8111828c:	0039883a 	mov	fp,zero
81118290:	00800084 	movi	r2,2
81118294:	003fd306 	br	811181e4 <__reset+0xfb0f81e4>
81118298:	07000b44 	movi	fp,45
8111829c:	df002785 	stb	fp,158(sp)
811182a0:	003a4006 	br	81116ba4 <__reset+0xfb0f6ba4>
811182a4:	00c00b44 	movi	r3,45
811182a8:	d8c02785 	stb	r3,158(sp)
811182ac:	d8802a15 	stw	r2,168(sp)
811182b0:	dc802b17 	ldw	r18,172(sp)
811182b4:	d8002915 	stw	zero,164(sp)
811182b8:	07000b44 	movi	fp,45
811182bc:	003a8006 	br	81116cc0 <__reset+0xfb0f6cc0>
811182c0:	04204534 	movhi	r16,33044
811182c4:	843da304 	addi	r16,r16,-2420
811182c8:	003f4706 	br	81117fe8 <__reset+0xfb0f7fe8>
811182cc:	d8c02d17 	ldw	r3,180(sp)
811182d0:	d9002f17 	ldw	r4,188(sp)
811182d4:	18800017 	ldw	r2,0(r3)
811182d8:	18c00104 	addi	r3,r3,4
811182dc:	d8c02d15 	stw	r3,180(sp)
811182e0:	11000015 	stw	r4,0(r2)
811182e4:	0038dd06 	br	8111665c <__reset+0xfb0f665c>
811182e8:	dd802617 	ldw	r22,152(sp)
811182ec:	00bfff44 	movi	r2,-3
811182f0:	b0801c16 	blt	r22,r2,81118364 <___vfprintf_internal_r+0x1df0>
811182f4:	d9402917 	ldw	r5,164(sp)
811182f8:	2d801a16 	blt	r5,r22,81118364 <___vfprintf_internal_r+0x1df0>
811182fc:	dd803215 	stw	r22,200(sp)
81118300:	003e8906 	br	81117d28 <__reset+0xfb0f7d28>
81118304:	01204534 	movhi	r4,33044
81118308:	213db884 	addi	r4,r4,-2334
8111830c:	d9002b15 	stw	r4,172(sp)
81118310:	003c9106 	br	81117558 <__reset+0xfb0f7558>
81118314:	e005883a 	mov	r2,fp
81118318:	003e7906 	br	81117d00 <__reset+0xfb0f7d00>
8111831c:	d9402917 	ldw	r5,164(sp)
81118320:	df002783 	ldbu	fp,158(sp)
81118324:	dcc02d15 	stw	r19,180(sp)
81118328:	d9402a15 	stw	r5,168(sp)
8111832c:	d9402e15 	stw	r5,184(sp)
81118330:	d8002915 	stw	zero,164(sp)
81118334:	d8003215 	stw	zero,200(sp)
81118338:	003a5d06 	br	81116cb0 <__reset+0xfb0f6cb0>
8111833c:	9080004c 	andi	r2,r18,1
81118340:	0039883a 	mov	fp,zero
81118344:	10000426 	beq	r2,zero,81118358 <___vfprintf_internal_r+0x1de4>
81118348:	00800c04 	movi	r2,48
8111834c:	dc001dc4 	addi	r16,sp,119
81118350:	d8801dc5 	stb	r2,119(sp)
81118354:	003b8006 	br	81117158 <__reset+0xfb0f7158>
81118358:	d8002e15 	stw	zero,184(sp)
8111835c:	dc001e04 	addi	r16,sp,120
81118360:	003a4d06 	br	81116c98 <__reset+0xfb0f6c98>
81118364:	8c7fff84 	addi	r17,r17,-2
81118368:	b5bfffc4 	addi	r22,r22,-1
8111836c:	dd802615 	stw	r22,152(sp)
81118370:	dc4022c5 	stb	r17,139(sp)
81118374:	b000bf16 	blt	r22,zero,81118674 <___vfprintf_internal_r+0x2100>
81118378:	00800ac4 	movi	r2,43
8111837c:	d8802305 	stb	r2,140(sp)
81118380:	00800244 	movi	r2,9
81118384:	15807016 	blt	r2,r22,81118548 <___vfprintf_internal_r+0x1fd4>
81118388:	00800c04 	movi	r2,48
8111838c:	b5800c04 	addi	r22,r22,48
81118390:	d8802345 	stb	r2,141(sp)
81118394:	dd802385 	stb	r22,142(sp)
81118398:	d88023c4 	addi	r2,sp,143
8111839c:	df0022c4 	addi	fp,sp,139
811183a0:	d8c03317 	ldw	r3,204(sp)
811183a4:	1739c83a 	sub	fp,r2,fp
811183a8:	d9003317 	ldw	r4,204(sp)
811183ac:	e0c7883a 	add	r3,fp,r3
811183b0:	df003a15 	stw	fp,232(sp)
811183b4:	d8c02e15 	stw	r3,184(sp)
811183b8:	00800044 	movi	r2,1
811183bc:	1100b30e 	bge	r2,r4,8111868c <___vfprintf_internal_r+0x2118>
811183c0:	d8c02e17 	ldw	r3,184(sp)
811183c4:	18c00044 	addi	r3,r3,1
811183c8:	d8c02e15 	stw	r3,184(sp)
811183cc:	1805883a 	mov	r2,r3
811183d0:	1800ac16 	blt	r3,zero,81118684 <___vfprintf_internal_r+0x2110>
811183d4:	d8003215 	stw	zero,200(sp)
811183d8:	003e5d06 	br	81117d50 <__reset+0xfb0f7d50>
811183dc:	d9002c17 	ldw	r4,176(sp)
811183e0:	d9801e04 	addi	r6,sp,120
811183e4:	b80b883a 	mov	r5,r23
811183e8:	11226040 	call	81122604 <__sprint_r>
811183ec:	1039651e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
811183f0:	dc402617 	ldw	r17,152(sp)
811183f4:	d8c02017 	ldw	r3,128(sp)
811183f8:	d8801f17 	ldw	r2,124(sp)
811183fc:	da000404 	addi	r8,sp,16
81118400:	003ed606 	br	81117f5c <__reset+0xfb0f7f5c>
81118404:	582b883a 	mov	r21,r11
81118408:	d8002915 	stw	zero,164(sp)
8111840c:	0038bd06 	br	81116704 <__reset+0xfb0f6704>
81118410:	d8802917 	ldw	r2,164(sp)
81118414:	103e071e 	bne	r2,zero,81117c34 <__reset+0xfb0f7c34>
81118418:	dc002915 	stw	r16,164(sp)
8111841c:	003e0506 	br	81117c34 <__reset+0xfb0f7c34>
81118420:	d9002917 	ldw	r4,164(sp)
81118424:	20c00044 	addi	r3,r4,1
81118428:	003e0f06 	br	81117c68 <__reset+0xfb0f7c68>
8111842c:	01400184 	movi	r5,6
81118430:	d9402915 	stw	r5,164(sp)
81118434:	003dff06 	br	81117c34 <__reset+0xfb0f7c34>
81118438:	d8802104 	addi	r2,sp,132
8111843c:	d8800315 	stw	r2,12(sp)
81118440:	d8802504 	addi	r2,sp,148
81118444:	d8800215 	stw	r2,8(sp)
81118448:	d8802604 	addi	r2,sp,152
8111844c:	d8800115 	stw	r2,4(sp)
81118450:	d8802917 	ldw	r2,164(sp)
81118454:	d9403617 	ldw	r5,216(sp)
81118458:	d9002c17 	ldw	r4,176(sp)
8111845c:	d8800015 	stw	r2,0(sp)
81118460:	01c000c4 	movi	r7,3
81118464:	980d883a 	mov	r6,r19
81118468:	da003d15 	stw	r8,244(sp)
8111846c:	111a5200 	call	8111a520 <_dtoa_r>
81118470:	d8c02917 	ldw	r3,164(sp)
81118474:	da003d17 	ldw	r8,244(sp)
81118478:	1021883a 	mov	r16,r2
8111847c:	10f9883a 	add	fp,r2,r3
81118480:	81000007 	ldb	r4,0(r16)
81118484:	00800c04 	movi	r2,48
81118488:	20805e26 	beq	r4,r2,81118604 <___vfprintf_internal_r+0x2090>
8111848c:	d8c02617 	ldw	r3,152(sp)
81118490:	e0f9883a 	add	fp,fp,r3
81118494:	003e0a06 	br	81117cc0 <__reset+0xfb0f7cc0>
81118498:	00c00b44 	movi	r3,45
8111849c:	24e0003c 	xorhi	r19,r4,32768
811184a0:	d8c02a05 	stb	r3,168(sp)
811184a4:	003de906 	br	81117c4c <__reset+0xfb0f7c4c>
811184a8:	d8c03217 	ldw	r3,200(sp)
811184ac:	00c07a0e 	bge	zero,r3,81118698 <___vfprintf_internal_r+0x2124>
811184b0:	00800044 	movi	r2,1
811184b4:	d9003317 	ldw	r4,204(sp)
811184b8:	1105883a 	add	r2,r2,r4
811184bc:	d8802e15 	stw	r2,184(sp)
811184c0:	10004e16 	blt	r2,zero,811185fc <___vfprintf_internal_r+0x2088>
811184c4:	044019c4 	movi	r17,103
811184c8:	003e2106 	br	81117d50 <__reset+0xfb0f7d50>
811184cc:	d9002917 	ldw	r4,164(sp)
811184d0:	d8802104 	addi	r2,sp,132
811184d4:	d8800315 	stw	r2,12(sp)
811184d8:	d9000015 	stw	r4,0(sp)
811184dc:	d8802504 	addi	r2,sp,148
811184e0:	d9403617 	ldw	r5,216(sp)
811184e4:	d9002c17 	ldw	r4,176(sp)
811184e8:	d8800215 	stw	r2,8(sp)
811184ec:	d8802604 	addi	r2,sp,152
811184f0:	d8800115 	stw	r2,4(sp)
811184f4:	01c000c4 	movi	r7,3
811184f8:	980d883a 	mov	r6,r19
811184fc:	da003d15 	stw	r8,244(sp)
81118500:	111a5200 	call	8111a520 <_dtoa_r>
81118504:	d8c02917 	ldw	r3,164(sp)
81118508:	da003d17 	ldw	r8,244(sp)
8111850c:	1021883a 	mov	r16,r2
81118510:	00801184 	movi	r2,70
81118514:	80f9883a 	add	fp,r16,r3
81118518:	88bfd926 	beq	r17,r2,81118480 <__reset+0xfb0f8480>
8111851c:	003de806 	br	81117cc0 <__reset+0xfb0f7cc0>
81118520:	d9002917 	ldw	r4,164(sp)
81118524:	00c04d0e 	bge	zero,r3,8111865c <___vfprintf_internal_r+0x20e8>
81118528:	2000441e 	bne	r4,zero,8111863c <___vfprintf_internal_r+0x20c8>
8111852c:	9480004c 	andi	r18,r18,1
81118530:	9000421e 	bne	r18,zero,8111863c <___vfprintf_internal_r+0x20c8>
81118534:	1805883a 	mov	r2,r3
81118538:	18007016 	blt	r3,zero,811186fc <___vfprintf_internal_r+0x2188>
8111853c:	d8c03217 	ldw	r3,200(sp)
81118540:	d8c02e15 	stw	r3,184(sp)
81118544:	003e0206 	br	81117d50 <__reset+0xfb0f7d50>
81118548:	df0022c4 	addi	fp,sp,139
8111854c:	dc002915 	stw	r16,164(sp)
81118550:	4027883a 	mov	r19,r8
81118554:	e021883a 	mov	r16,fp
81118558:	b009883a 	mov	r4,r22
8111855c:	01400284 	movi	r5,10
81118560:	1125adc0 	call	81125adc <__modsi3>
81118564:	10800c04 	addi	r2,r2,48
81118568:	843fffc4 	addi	r16,r16,-1
8111856c:	b009883a 	mov	r4,r22
81118570:	01400284 	movi	r5,10
81118574:	80800005 	stb	r2,0(r16)
81118578:	1125a580 	call	81125a58 <__divsi3>
8111857c:	102d883a 	mov	r22,r2
81118580:	00800244 	movi	r2,9
81118584:	15bff416 	blt	r2,r22,81118558 <__reset+0xfb0f8558>
81118588:	9811883a 	mov	r8,r19
8111858c:	b0800c04 	addi	r2,r22,48
81118590:	8027883a 	mov	r19,r16
81118594:	997fffc4 	addi	r5,r19,-1
81118598:	98bfffc5 	stb	r2,-1(r19)
8111859c:	dc002917 	ldw	r16,164(sp)
811185a0:	2f006a2e 	bgeu	r5,fp,8111874c <___vfprintf_internal_r+0x21d8>
811185a4:	d9c02384 	addi	r7,sp,142
811185a8:	3ccfc83a 	sub	r7,r7,r19
811185ac:	d9002344 	addi	r4,sp,141
811185b0:	e1cf883a 	add	r7,fp,r7
811185b4:	00000106 	br	811185bc <___vfprintf_internal_r+0x2048>
811185b8:	28800003 	ldbu	r2,0(r5)
811185bc:	20800005 	stb	r2,0(r4)
811185c0:	21000044 	addi	r4,r4,1
811185c4:	29400044 	addi	r5,r5,1
811185c8:	393ffb1e 	bne	r7,r4,811185b8 <__reset+0xfb0f85b8>
811185cc:	d8802304 	addi	r2,sp,140
811185d0:	14c5c83a 	sub	r2,r2,r19
811185d4:	d8c02344 	addi	r3,sp,141
811185d8:	1885883a 	add	r2,r3,r2
811185dc:	003f7006 	br	811183a0 <__reset+0xfb0f83a0>
811185e0:	0005883a 	mov	r2,zero
811185e4:	003f0f06 	br	81118224 <__reset+0xfb0f8224>
811185e8:	d8c03217 	ldw	r3,200(sp)
811185ec:	18c00044 	addi	r3,r3,1
811185f0:	d8c02e15 	stw	r3,184(sp)
811185f4:	1805883a 	mov	r2,r3
811185f8:	183fb20e 	bge	r3,zero,811184c4 <__reset+0xfb0f84c4>
811185fc:	0005883a 	mov	r2,zero
81118600:	003fb006 	br	811184c4 <__reset+0xfb0f84c4>
81118604:	d9003617 	ldw	r4,216(sp)
81118608:	000d883a 	mov	r6,zero
8111860c:	000f883a 	mov	r7,zero
81118610:	980b883a 	mov	r5,r19
81118614:	d8c03c15 	stw	r3,240(sp)
81118618:	da003d15 	stw	r8,244(sp)
8111861c:	1126fac0 	call	81126fac <__eqdf2>
81118620:	d8c03c17 	ldw	r3,240(sp)
81118624:	da003d17 	ldw	r8,244(sp)
81118628:	103f9826 	beq	r2,zero,8111848c <__reset+0xfb0f848c>
8111862c:	00800044 	movi	r2,1
81118630:	10c7c83a 	sub	r3,r2,r3
81118634:	d8c02615 	stw	r3,152(sp)
81118638:	003f9506 	br	81118490 <__reset+0xfb0f8490>
8111863c:	d9002917 	ldw	r4,164(sp)
81118640:	d8c03217 	ldw	r3,200(sp)
81118644:	20800044 	addi	r2,r4,1
81118648:	1885883a 	add	r2,r3,r2
8111864c:	d8802e15 	stw	r2,184(sp)
81118650:	103dbf0e 	bge	r2,zero,81117d50 <__reset+0xfb0f7d50>
81118654:	0005883a 	mov	r2,zero
81118658:	003dbd06 	br	81117d50 <__reset+0xfb0f7d50>
8111865c:	2000211e 	bne	r4,zero,811186e4 <___vfprintf_internal_r+0x2170>
81118660:	9480004c 	andi	r18,r18,1
81118664:	90001f1e 	bne	r18,zero,811186e4 <___vfprintf_internal_r+0x2170>
81118668:	00800044 	movi	r2,1
8111866c:	d8802e15 	stw	r2,184(sp)
81118670:	003db706 	br	81117d50 <__reset+0xfb0f7d50>
81118674:	00800b44 	movi	r2,45
81118678:	05adc83a 	sub	r22,zero,r22
8111867c:	d8802305 	stb	r2,140(sp)
81118680:	003f3f06 	br	81118380 <__reset+0xfb0f8380>
81118684:	0005883a 	mov	r2,zero
81118688:	003f5206 	br	811183d4 <__reset+0xfb0f83d4>
8111868c:	90a4703a 	and	r18,r18,r2
81118690:	903f4e26 	beq	r18,zero,811183cc <__reset+0xfb0f83cc>
81118694:	003f4a06 	br	811183c0 <__reset+0xfb0f83c0>
81118698:	00800084 	movi	r2,2
8111869c:	10c5c83a 	sub	r2,r2,r3
811186a0:	003f8406 	br	811184b4 <__reset+0xfb0f84b4>
811186a4:	d8802d17 	ldw	r2,180(sp)
811186a8:	d9002d17 	ldw	r4,180(sp)
811186ac:	ac400043 	ldbu	r17,1(r21)
811186b0:	10800017 	ldw	r2,0(r2)
811186b4:	582b883a 	mov	r21,r11
811186b8:	d8802915 	stw	r2,164(sp)
811186bc:	20800104 	addi	r2,r4,4
811186c0:	d9002917 	ldw	r4,164(sp)
811186c4:	d8802d15 	stw	r2,180(sp)
811186c8:	203e7a0e 	bge	r4,zero,811180b4 <__reset+0xfb0f80b4>
811186cc:	8c403fcc 	andi	r17,r17,255
811186d0:	00bfffc4 	movi	r2,-1
811186d4:	8c40201c 	xori	r17,r17,128
811186d8:	d8802915 	stw	r2,164(sp)
811186dc:	8c7fe004 	addi	r17,r17,-128
811186e0:	00380706 	br	81116700 <__reset+0xfb0f6700>
811186e4:	d8c02917 	ldw	r3,164(sp)
811186e8:	18c00084 	addi	r3,r3,2
811186ec:	d8c02e15 	stw	r3,184(sp)
811186f0:	1805883a 	mov	r2,r3
811186f4:	183d960e 	bge	r3,zero,81117d50 <__reset+0xfb0f7d50>
811186f8:	003fd606 	br	81118654 <__reset+0xfb0f8654>
811186fc:	0005883a 	mov	r2,zero
81118700:	003f8e06 	br	8111853c <__reset+0xfb0f853c>
81118704:	9080004c 	andi	r2,r18,1
81118708:	103f811e 	bne	r2,zero,81118510 <__reset+0xfb0f8510>
8111870c:	d8802117 	ldw	r2,132(sp)
81118710:	1405c83a 	sub	r2,r2,r16
81118714:	d8803315 	stw	r2,204(sp)
81118718:	b47ef326 	beq	r22,r17,811182e8 <__reset+0xfb0f82e8>
8111871c:	dd802617 	ldw	r22,152(sp)
81118720:	003f1106 	br	81118368 <__reset+0xfb0f8368>
81118724:	d9c02785 	stb	r7,158(sp)
81118728:	00390406 	br	81116b3c <__reset+0xfb0f6b3c>
8111872c:	d9c02785 	stb	r7,158(sp)
81118730:	0038d306 	br	81116a80 <__reset+0xfb0f6a80>
81118734:	d9c02785 	stb	r7,158(sp)
81118738:	003a6106 	br	811170c0 <__reset+0xfb0f70c0>
8111873c:	d9c02785 	stb	r7,158(sp)
81118740:	003af806 	br	81117324 <__reset+0xfb0f7324>
81118744:	0005883a 	mov	r2,zero
81118748:	003d7e06 	br	81117d44 <__reset+0xfb0f7d44>
8111874c:	d8802344 	addi	r2,sp,141
81118750:	003f1306 	br	811183a0 <__reset+0xfb0f83a0>
81118754:	d9c02785 	stb	r7,158(sp)
81118758:	00392306 	br	81116be8 <__reset+0xfb0f6be8>
8111875c:	d9c02785 	stb	r7,158(sp)
81118760:	003aa906 	br	81117208 <__reset+0xfb0f7208>
81118764:	d9c02785 	stb	r7,158(sp)
81118768:	003a3d06 	br	81117060 <__reset+0xfb0f7060>
8111876c:	d9c02785 	stb	r7,158(sp)
81118770:	003aca06 	br	8111729c <__reset+0xfb0f729c>

81118774 <__vfprintf_internal>:
81118774:	00a04534 	movhi	r2,33044
81118778:	1086aa04 	addi	r2,r2,6824
8111877c:	300f883a 	mov	r7,r6
81118780:	280d883a 	mov	r6,r5
81118784:	200b883a 	mov	r5,r4
81118788:	11000017 	ldw	r4,0(r2)
8111878c:	11165741 	jmpi	81116574 <___vfprintf_internal_r>

81118790 <__sbprintf>:
81118790:	defee204 	addi	sp,sp,-1144
81118794:	de00012e 	bgeu	sp,et,8111879c <__sbprintf+0xc>
81118798:	003b68fa 	trap	3
8111879c:	2880030b 	ldhu	r2,12(r5)
811187a0:	2ac01917 	ldw	r11,100(r5)
811187a4:	2a80038b 	ldhu	r10,14(r5)
811187a8:	2a400717 	ldw	r9,28(r5)
811187ac:	2a000917 	ldw	r8,36(r5)
811187b0:	00c10004 	movi	r3,1024
811187b4:	dc011a15 	stw	r16,1128(sp)
811187b8:	10bfff4c 	andi	r2,r2,65533
811187bc:	2821883a 	mov	r16,r5
811187c0:	d8cb883a 	add	r5,sp,r3
811187c4:	dc811c15 	stw	r18,1136(sp)
811187c8:	dc411b15 	stw	r17,1132(sp)
811187cc:	dfc11d15 	stw	ra,1140(sp)
811187d0:	2025883a 	mov	r18,r4
811187d4:	d881030d 	sth	r2,1036(sp)
811187d8:	dac11915 	stw	r11,1124(sp)
811187dc:	da81038d 	sth	r10,1038(sp)
811187e0:	da410715 	stw	r9,1052(sp)
811187e4:	da010915 	stw	r8,1060(sp)
811187e8:	dec10015 	stw	sp,1024(sp)
811187ec:	dec10415 	stw	sp,1040(sp)
811187f0:	d8c10215 	stw	r3,1032(sp)
811187f4:	d8c10515 	stw	r3,1044(sp)
811187f8:	d8010615 	stw	zero,1048(sp)
811187fc:	11165740 	call	81116574 <___vfprintf_internal_r>
81118800:	1023883a 	mov	r17,r2
81118804:	10000416 	blt	r2,zero,81118818 <__sbprintf+0x88>
81118808:	d9410004 	addi	r5,sp,1024
8111880c:	9009883a 	mov	r4,r18
81118810:	111bdd40 	call	8111bdd4 <_fflush_r>
81118814:	10000d1e 	bne	r2,zero,8111884c <__sbprintf+0xbc>
81118818:	d881030b 	ldhu	r2,1036(sp)
8111881c:	1080100c 	andi	r2,r2,64
81118820:	10000326 	beq	r2,zero,81118830 <__sbprintf+0xa0>
81118824:	8080030b 	ldhu	r2,12(r16)
81118828:	10801014 	ori	r2,r2,64
8111882c:	8080030d 	sth	r2,12(r16)
81118830:	8805883a 	mov	r2,r17
81118834:	dfc11d17 	ldw	ra,1140(sp)
81118838:	dc811c17 	ldw	r18,1136(sp)
8111883c:	dc411b17 	ldw	r17,1132(sp)
81118840:	dc011a17 	ldw	r16,1128(sp)
81118844:	dec11e04 	addi	sp,sp,1144
81118848:	f800283a 	ret
8111884c:	047fffc4 	movi	r17,-1
81118850:	003ff106 	br	81118818 <__reset+0xfb0f8818>

81118854 <__svfscanf_r>:
81118854:	deff4b04 	addi	sp,sp,-724
81118858:	de00012e 	bgeu	sp,et,81118860 <__svfscanf_r+0xc>
8111885c:	003b68fa 	trap	3
81118860:	2880030b 	ldhu	r2,12(r5)
81118864:	df00b315 	stw	fp,716(sp)
81118868:	dd80b115 	stw	r22,708(sp)
8111886c:	dfc0b415 	stw	ra,720(sp)
81118870:	ddc0b215 	stw	r23,712(sp)
81118874:	dd40b015 	stw	r21,704(sp)
81118878:	dd00af15 	stw	r20,700(sp)
8111887c:	dcc0ae15 	stw	r19,696(sp)
81118880:	dc80ad15 	stw	r18,692(sp)
81118884:	dc40ac15 	stw	r17,688(sp)
81118888:	dc00ab15 	stw	r16,684(sp)
8111888c:	10c8000c 	andi	r3,r2,8192
81118890:	d9c09c15 	stw	r7,624(sp)
81118894:	2839883a 	mov	fp,r5
81118898:	202d883a 	mov	r22,r4
8111889c:	1800061e 	bne	r3,zero,811188b8 <__svfscanf_r+0x64>
811188a0:	29001917 	ldw	r4,100(r5)
811188a4:	00f7ffc4 	movi	r3,-8193
811188a8:	10880014 	ori	r2,r2,8192
811188ac:	20c6703a 	and	r3,r4,r3
811188b0:	2880030d 	sth	r2,12(r5)
811188b4:	28c01915 	stw	r3,100(r5)
811188b8:	30800003 	ldbu	r2,0(r6)
811188bc:	0021883a 	mov	r16,zero
811188c0:	05e04534 	movhi	r23,33044
811188c4:	d800a115 	stw	zero,644(sp)
811188c8:	d8009e15 	stw	zero,632(sp)
811188cc:	d800a015 	stw	zero,640(sp)
811188d0:	d8809b15 	stw	r2,620(sp)
811188d4:	bdc6a804 	addi	r23,r23,6816
811188d8:	8025883a 	mov	r18,r16
811188dc:	35000044 	addi	r20,r6,1
811188e0:	10001e26 	beq	r2,zero,8111895c <__svfscanf_r+0x108>
811188e4:	b9c00017 	ldw	r7,0(r23)
811188e8:	3887883a 	add	r3,r7,r2
811188ec:	18c00043 	ldbu	r3,1(r3)
811188f0:	18c0020c 	andi	r3,r3,8
811188f4:	18001b26 	beq	r3,zero,81118964 <__svfscanf_r+0x110>
811188f8:	e0800117 	ldw	r2,4(fp)
811188fc:	00800e0e 	bge	zero,r2,81118938 <__svfscanf_r+0xe4>
81118900:	e0c00017 	ldw	r3,0(fp)
81118904:	b9000017 	ldw	r4,0(r23)
81118908:	18800003 	ldbu	r2,0(r3)
8111890c:	2085883a 	add	r2,r4,r2
81118910:	10800043 	ldbu	r2,1(r2)
81118914:	1080020c 	andi	r2,r2,8
81118918:	10000b26 	beq	r2,zero,81118948 <__svfscanf_r+0xf4>
8111891c:	e0800117 	ldw	r2,4(fp)
81118920:	18c00044 	addi	r3,r3,1
81118924:	e0c00015 	stw	r3,0(fp)
81118928:	10bfffc4 	addi	r2,r2,-1
8111892c:	e0800115 	stw	r2,4(fp)
81118930:	94800044 	addi	r18,r18,1
81118934:	00bff216 	blt	zero,r2,81118900 <__reset+0xfb0f8900>
81118938:	e00b883a 	mov	r5,fp
8111893c:	b009883a 	mov	r4,r22
81118940:	1113b340 	call	81113b34 <__srefill_r>
81118944:	103fee26 	beq	r2,zero,81118900 <__reset+0xfb0f8900>
81118948:	a00d883a 	mov	r6,r20
8111894c:	30800003 	ldbu	r2,0(r6)
81118950:	35000044 	addi	r20,r6,1
81118954:	d8809b15 	stw	r2,620(sp)
81118958:	103fe21e 	bne	r2,zero,811188e4 <__reset+0xfb0f88e4>
8111895c:	d880a017 	ldw	r2,640(sp)
81118960:	00009906 	br	81118bc8 <__svfscanf_r+0x374>
81118964:	00c00944 	movi	r3,37
81118968:	10c0881e 	bne	r2,r3,81118b8c <__svfscanf_r+0x338>
8111896c:	30c00043 	ldbu	r3,1(r6)
81118970:	0023883a 	mov	r17,zero
81118974:	0027883a 	mov	r19,zero
81118978:	01001e04 	movi	r4,120
8111897c:	01401b04 	movi	r5,108
81118980:	a1800044 	addi	r6,r20,1
81118984:	20c0a236 	bltu	r4,r3,81118c10 <__svfscanf_r+0x3bc>
81118988:	180490ba 	slli	r2,r3,2
8111898c:	022044b4 	movhi	r8,33042
81118990:	42226804 	addi	r8,r8,-30304
81118994:	1205883a 	add	r2,r2,r8
81118998:	10800017 	ldw	r2,0(r2)
8111899c:	1000683a 	jmp	r2
811189a0:	81118bc4 	addi	r4,r16,17967
811189a4:	81118c10 	cmplti	r4,r16,17968
811189a8:	81118c10 	cmplti	r4,r16,17968
811189ac:	81118c10 	cmplti	r4,r16,17968
811189b0:	81118c10 	cmplti	r4,r16,17968
811189b4:	81118c10 	cmplti	r4,r16,17968
811189b8:	81118c10 	cmplti	r4,r16,17968
811189bc:	81118c10 	cmplti	r4,r16,17968
811189c0:	81118c10 	cmplti	r4,r16,17968
811189c4:	81118c10 	cmplti	r4,r16,17968
811189c8:	81118c10 	cmplti	r4,r16,17968
811189cc:	81118c10 	cmplti	r4,r16,17968
811189d0:	81118c10 	cmplti	r4,r16,17968
811189d4:	81118c10 	cmplti	r4,r16,17968
811189d8:	81118c10 	cmplti	r4,r16,17968
811189dc:	81118c10 	cmplti	r4,r16,17968
811189e0:	81118c10 	cmplti	r4,r16,17968
811189e4:	81118c10 	cmplti	r4,r16,17968
811189e8:	81118c10 	cmplti	r4,r16,17968
811189ec:	81118c10 	cmplti	r4,r16,17968
811189f0:	81118c10 	cmplti	r4,r16,17968
811189f4:	81118c10 	cmplti	r4,r16,17968
811189f8:	81118c10 	cmplti	r4,r16,17968
811189fc:	81118c10 	cmplti	r4,r16,17968
81118a00:	81118c10 	cmplti	r4,r16,17968
81118a04:	81118c10 	cmplti	r4,r16,17968
81118a08:	81118c10 	cmplti	r4,r16,17968
81118a0c:	81118c10 	cmplti	r4,r16,17968
81118a10:	81118c10 	cmplti	r4,r16,17968
81118a14:	81118c10 	cmplti	r4,r16,17968
81118a18:	81118c10 	cmplti	r4,r16,17968
81118a1c:	81118c10 	cmplti	r4,r16,17968
81118a20:	81118c10 	cmplti	r4,r16,17968
81118a24:	81118c10 	cmplti	r4,r16,17968
81118a28:	81118c10 	cmplti	r4,r16,17968
81118a2c:	81118c10 	cmplti	r4,r16,17968
81118a30:	81118c10 	cmplti	r4,r16,17968
81118a34:	81118b84 	addi	r4,r16,17966
81118a38:	81118c10 	cmplti	r4,r16,17968
81118a3c:	81118c10 	cmplti	r4,r16,17968
81118a40:	81118c10 	cmplti	r4,r16,17968
81118a44:	81118c10 	cmplti	r4,r16,17968
81118a48:	81118bf8 	rdprs	r4,r16,17967
81118a4c:	81118c10 	cmplti	r4,r16,17968
81118a50:	81118c10 	cmplti	r4,r16,17968
81118a54:	81118c10 	cmplti	r4,r16,17968
81118a58:	81118c10 	cmplti	r4,r16,17968
81118a5c:	81118c10 	cmplti	r4,r16,17968
81118a60:	81118d2c 	andhi	r4,r16,17972
81118a64:	81118d2c 	andhi	r4,r16,17972
81118a68:	81118d2c 	andhi	r4,r16,17972
81118a6c:	81118d2c 	andhi	r4,r16,17972
81118a70:	81118d2c 	andhi	r4,r16,17972
81118a74:	81118d2c 	andhi	r4,r16,17972
81118a78:	81118d2c 	andhi	r4,r16,17972
81118a7c:	81118d2c 	andhi	r4,r16,17972
81118a80:	81118d2c 	andhi	r4,r16,17972
81118a84:	81118d2c 	andhi	r4,r16,17972
81118a88:	81118c10 	cmplti	r4,r16,17968
81118a8c:	81118c10 	cmplti	r4,r16,17968
81118a90:	81118c10 	cmplti	r4,r16,17968
81118a94:	81118c10 	cmplti	r4,r16,17968
81118a98:	81118c10 	cmplti	r4,r16,17968
81118a9c:	81118c10 	cmplti	r4,r16,17968
81118aa0:	81118c10 	cmplti	r4,r16,17968
81118aa4:	81118c10 	cmplti	r4,r16,17968
81118aa8:	81118c10 	cmplti	r4,r16,17968
81118aac:	81118c10 	cmplti	r4,r16,17968
81118ab0:	81118d00 	call	881118d0 <__reset+0x20f18d0>
81118ab4:	81118db0 	cmpltui	r4,r16,17974
81118ab8:	81118c10 	cmplti	r4,r16,17968
81118abc:	81118db0 	cmpltui	r4,r16,17974
81118ac0:	81118c10 	cmplti	r4,r16,17968
81118ac4:	81118c10 	cmplti	r4,r16,17968
81118ac8:	81118c10 	cmplti	r4,r16,17968
81118acc:	81118c10 	cmplti	r4,r16,17968
81118ad0:	81118d9c 	xori	r4,r16,17974
81118ad4:	81118c10 	cmplti	r4,r16,17968
81118ad8:	81118c10 	cmplti	r4,r16,17968
81118adc:	81118d70 	cmpltui	r4,r16,17973
81118ae0:	81118c10 	cmplti	r4,r16,17968
81118ae4:	81118c10 	cmplti	r4,r16,17968
81118ae8:	81118c10 	cmplti	r4,r16,17968
81118aec:	81118c10 	cmplti	r4,r16,17968
81118af0:	81118c10 	cmplti	r4,r16,17968
81118af4:	81118c10 	cmplti	r4,r16,17968
81118af8:	81118c10 	cmplti	r4,r16,17968
81118afc:	81118c10 	cmplti	r4,r16,17968
81118b00:	81118d48 	cmpgei	r4,r16,17973
81118b04:	81118c10 	cmplti	r4,r16,17968
81118b08:	81118c10 	cmplti	r4,r16,17968
81118b0c:	81118ee4 	muli	r4,r16,17979
81118b10:	81118c10 	cmplti	r4,r16,17968
81118b14:	81118c10 	cmplti	r4,r16,17968
81118b18:	81118c10 	cmplti	r4,r16,17968
81118b1c:	81118c10 	cmplti	r4,r16,17968
81118b20:	81118c10 	cmplti	r4,r16,17968
81118b24:	81118c10 	cmplti	r4,r16,17968
81118b28:	81118c10 	cmplti	r4,r16,17968
81118b2c:	81118e68 	cmpgeui	r4,r16,17977
81118b30:	81118e40 	call	881118e4 <__reset+0x20f18e4>
81118b34:	81118db0 	cmpltui	r4,r16,17974
81118b38:	81118db0 	cmpltui	r4,r16,17974
81118b3c:	81118db0 	cmpltui	r4,r16,17974
81118b40:	81118e2c 	andhi	r4,r16,17976
81118b44:	81118f70 	cmpltui	r4,r16,17981
81118b48:	81118c10 	cmplti	r4,r16,17968
81118b4c:	81118c10 	cmplti	r4,r16,17968
81118b50:	81118e18 	cmpnei	r4,r16,17976
81118b54:	81118c10 	cmplti	r4,r16,17968
81118b58:	81118de8 	cmpgeui	r4,r16,17975
81118b5c:	81118dc4 	addi	r4,r16,17975
81118b60:	81118cd4 	ori	r4,r16,17971
81118b64:	81118c10 	cmplti	r4,r16,17968
81118b68:	81118c10 	cmplti	r4,r16,17968
81118b6c:	81118cc0 	call	881118cc <__reset+0x20f18cc>
81118b70:	81118c10 	cmplti	r4,r16,17968
81118b74:	81118c48 	cmpgei	r4,r16,17969
81118b78:	81118c10 	cmplti	r4,r16,17968
81118b7c:	81118c10 	cmplti	r4,r16,17968
81118b80:	81118d48 	cmpgei	r4,r16,17973
81118b84:	d9809d15 	stw	r6,628(sp)
81118b88:	3029883a 	mov	r20,r6
81118b8c:	e0800117 	ldw	r2,4(fp)
81118b90:	0081aa0e 	bge	zero,r2,8111923c <__svfscanf_r+0x9e8>
81118b94:	e0800017 	ldw	r2,0(fp)
81118b98:	a0ffffc3 	ldbu	r3,-1(r20)
81118b9c:	11000003 	ldbu	r4,0(r2)
81118ba0:	20ff6e1e 	bne	r4,r3,8111895c <__reset+0xfb0f895c>
81118ba4:	e0c00117 	ldw	r3,4(fp)
81118ba8:	10800044 	addi	r2,r2,1
81118bac:	e0800015 	stw	r2,0(fp)
81118bb0:	18bfffc4 	addi	r2,r3,-1
81118bb4:	e0800115 	stw	r2,4(fp)
81118bb8:	94800044 	addi	r18,r18,1
81118bbc:	a00d883a 	mov	r6,r20
81118bc0:	003f6206 	br	8111894c <__reset+0xfb0f894c>
81118bc4:	00bfffc4 	movi	r2,-1
81118bc8:	dfc0b417 	ldw	ra,720(sp)
81118bcc:	df00b317 	ldw	fp,716(sp)
81118bd0:	ddc0b217 	ldw	r23,712(sp)
81118bd4:	dd80b117 	ldw	r22,708(sp)
81118bd8:	dd40b017 	ldw	r21,704(sp)
81118bdc:	dd00af17 	ldw	r20,700(sp)
81118be0:	dcc0ae17 	ldw	r19,696(sp)
81118be4:	dc80ad17 	ldw	r18,692(sp)
81118be8:	dc40ac17 	ldw	r17,688(sp)
81118bec:	dc00ab17 	ldw	r16,684(sp)
81118bf0:	dec0b504 	addi	sp,sp,724
81118bf4:	f800283a 	ret
81118bf8:	a0800043 	ldbu	r2,1(r20)
81118bfc:	3029883a 	mov	r20,r6
81118c00:	8c400414 	ori	r17,r17,16
81118c04:	10c03fcc 	andi	r3,r2,255
81118c08:	a1800044 	addi	r6,r20,1
81118c0c:	20ff5e2e 	bgeu	r4,r3,81118988 <__reset+0xfb0f8988>
81118c10:	38c7883a 	add	r3,r7,r3
81118c14:	18800043 	ldbu	r2,1(r3)
81118c18:	d9809d15 	stw	r6,628(sp)
81118c1c:	00c00044 	movi	r3,1
81118c20:	108000cc 	andi	r2,r2,3
81118c24:	10c18f26 	beq	r2,r3,81119264 <__svfscanf_r+0xa10>
81118c28:	e0800117 	ldw	r2,4(fp)
81118c2c:	00808716 	blt	zero,r2,81118e4c <__svfscanf_r+0x5f8>
81118c30:	e00b883a 	mov	r5,fp
81118c34:	b009883a 	mov	r4,r22
81118c38:	1113b340 	call	81113b34 <__srefill_r>
81118c3c:	1001431e 	bne	r2,zero,8111914c <__svfscanf_r+0x8f8>
81118c40:	b9c00017 	ldw	r7,0(r23)
81118c44:	00008106 	br	81118e4c <__svfscanf_r+0x5f8>
81118c48:	e0800117 	ldw	r2,4(fp)
81118c4c:	d9809d15 	stw	r6,628(sp)
81118c50:	0081a30e 	bge	zero,r2,811192e0 <__svfscanf_r+0xa8c>
81118c54:	00a044b4 	movhi	r2,33042
81118c58:	10824104 	addi	r2,r2,2308
81118c5c:	02000284 	movi	r8,10
81118c60:	d880a115 	stw	r2,644(sp)
81118c64:	da009e15 	stw	r8,632(sp)
81118c68:	050000c4 	movi	r20,3
81118c6c:	e0c00017 	ldw	r3,0(fp)
81118c70:	00000206 	br	81118c7c <__svfscanf_r+0x428>
81118c74:	18c00044 	addi	r3,r3,1
81118c78:	e0c00015 	stw	r3,0(fp)
81118c7c:	19000003 	ldbu	r4,0(r3)
81118c80:	20803fcc 	andi	r2,r4,255
81118c84:	3885883a 	add	r2,r7,r2
81118c88:	10800043 	ldbu	r2,1(r2)
81118c8c:	1140020c 	andi	r5,r2,8
81118c90:	2801ab26 	beq	r5,zero,81119340 <__svfscanf_r+0xaec>
81118c94:	e0800117 	ldw	r2,4(fp)
81118c98:	94800044 	addi	r18,r18,1
81118c9c:	10bfffc4 	addi	r2,r2,-1
81118ca0:	e0800115 	stw	r2,4(fp)
81118ca4:	00bff316 	blt	zero,r2,81118c74 <__reset+0xfb0f8c74>
81118ca8:	e00b883a 	mov	r5,fp
81118cac:	b009883a 	mov	r4,r22
81118cb0:	1113b340 	call	81113b34 <__srefill_r>
81118cb4:	1001251e 	bne	r2,zero,8111914c <__svfscanf_r+0x8f8>
81118cb8:	b9c00017 	ldw	r7,0(r23)
81118cbc:	003feb06 	br	81118c6c <__reset+0xfb0f8c6c>
81118cc0:	e0800117 	ldw	r2,4(fp)
81118cc4:	d9809d15 	stw	r6,628(sp)
81118cc8:	00818b0e 	bge	zero,r2,811192f8 <__svfscanf_r+0xaa4>
81118ccc:	05000084 	movi	r20,2
81118cd0:	003fe606 	br	81118c6c <__reset+0xfb0f8c6c>
81118cd4:	e0800117 	ldw	r2,4(fp)
81118cd8:	d9809d15 	stw	r6,628(sp)
81118cdc:	8c408814 	ori	r17,r17,544
81118ce0:	00801d0e 	bge	zero,r2,81118d58 <__svfscanf_r+0x504>
81118ce4:	00a044b4 	movhi	r2,33042
81118ce8:	10824104 	addi	r2,r2,2308
81118cec:	02000404 	movi	r8,16
81118cf0:	d880a115 	stw	r2,644(sp)
81118cf4:	da009e15 	stw	r8,632(sp)
81118cf8:	050000c4 	movi	r20,3
81118cfc:	003fdb06 	br	81118c6c <__reset+0xfb0f8c6c>
81118d00:	e0800117 	ldw	r2,4(fp)
81118d04:	d9809d15 	stw	r6,628(sp)
81118d08:	8c400054 	ori	r17,r17,1
81118d0c:	00bfc80e 	bge	zero,r2,81118c30 <__reset+0xfb0f8c30>
81118d10:	00e04474 	movhi	r3,33041
81118d14:	18d04e04 	addi	r3,r3,16696
81118d18:	02000284 	movi	r8,10
81118d1c:	d8c0a115 	stw	r3,644(sp)
81118d20:	da009e15 	stw	r8,632(sp)
81118d24:	050000c4 	movi	r20,3
81118d28:	003fd006 	br	81118c6c <__reset+0xfb0f8c6c>
81118d2c:	9cc002a4 	muli	r19,r19,10
81118d30:	a0800043 	ldbu	r2,1(r20)
81118d34:	3029883a 	mov	r20,r6
81118d38:	98e7883a 	add	r19,r19,r3
81118d3c:	9cfff404 	addi	r19,r19,-48
81118d40:	10c03fcc 	andi	r3,r2,255
81118d44:	003f0e06 	br	81118980 <__reset+0xfb0f8980>
81118d48:	e0800117 	ldw	r2,4(fp)
81118d4c:	d9809d15 	stw	r6,628(sp)
81118d50:	8c408014 	ori	r17,r17,512
81118d54:	00bfe316 	blt	zero,r2,81118ce4 <__reset+0xfb0f8ce4>
81118d58:	e00b883a 	mov	r5,fp
81118d5c:	b009883a 	mov	r4,r22
81118d60:	1113b340 	call	81113b34 <__srefill_r>
81118d64:	1000f91e 	bne	r2,zero,8111914c <__svfscanf_r+0x8f8>
81118d68:	b9c00017 	ldw	r7,0(r23)
81118d6c:	003fdd06 	br	81118ce4 <__reset+0xfb0f8ce4>
81118d70:	e0800117 	ldw	r2,4(fp)
81118d74:	d9809d15 	stw	r6,628(sp)
81118d78:	8c400054 	ori	r17,r17,1
81118d7c:	0080140e 	bge	zero,r2,81118dd0 <__svfscanf_r+0x57c>
81118d80:	00a044b4 	movhi	r2,33042
81118d84:	10824104 	addi	r2,r2,2308
81118d88:	02000204 	movi	r8,8
81118d8c:	d880a115 	stw	r2,644(sp)
81118d90:	da009e15 	stw	r8,632(sp)
81118d94:	050000c4 	movi	r20,3
81118d98:	003fb406 	br	81118c6c <__reset+0xfb0f8c6c>
81118d9c:	a0800043 	ldbu	r2,1(r20)
81118da0:	8c400094 	ori	r17,r17,2
81118da4:	3029883a 	mov	r20,r6
81118da8:	10c03fcc 	andi	r3,r2,255
81118dac:	003ef406 	br	81118980 <__reset+0xfb0f8980>
81118db0:	e0800117 	ldw	r2,4(fp)
81118db4:	d9809d15 	stw	r6,628(sp)
81118db8:	0081420e 	bge	zero,r2,811192c4 <__svfscanf_r+0xa70>
81118dbc:	05000104 	movi	r20,4
81118dc0:	003faa06 	br	81118c6c <__reset+0xfb0f8c6c>
81118dc4:	e0800117 	ldw	r2,4(fp)
81118dc8:	d9809d15 	stw	r6,628(sp)
81118dcc:	00bfec16 	blt	zero,r2,81118d80 <__reset+0xfb0f8d80>
81118dd0:	e00b883a 	mov	r5,fp
81118dd4:	b009883a 	mov	r4,r22
81118dd8:	1113b340 	call	81113b34 <__srefill_r>
81118ddc:	1000db1e 	bne	r2,zero,8111914c <__svfscanf_r+0x8f8>
81118de0:	b9c00017 	ldw	r7,0(r23)
81118de4:	003fe606 	br	81118d80 <__reset+0xfb0f8d80>
81118de8:	d9809d15 	stw	r6,628(sp)
81118dec:	8880040c 	andi	r2,r17,16
81118df0:	10009c1e 	bne	r2,zero,81119064 <__svfscanf_r+0x810>
81118df4:	8880010c 	andi	r2,r17,4
81118df8:	10011e26 	beq	r2,zero,81119274 <__svfscanf_r+0xa20>
81118dfc:	da009c17 	ldw	r8,624(sp)
81118e00:	3029883a 	mov	r20,r6
81118e04:	40800017 	ldw	r2,0(r8)
81118e08:	42000104 	addi	r8,r8,4
81118e0c:	da009c15 	stw	r8,624(sp)
81118e10:	1480000d 	sth	r18,0(r2)
81118e14:	003ecc06 	br	81118948 <__reset+0xfb0f8948>
81118e18:	a0c00043 	ldbu	r3,1(r20)
81118e1c:	19410c26 	beq	r3,r5,81119250 <__svfscanf_r+0x9fc>
81118e20:	8c400054 	ori	r17,r17,1
81118e24:	3029883a 	mov	r20,r6
81118e28:	003ed506 	br	81118980 <__reset+0xfb0f8980>
81118e2c:	a0800043 	ldbu	r2,1(r20)
81118e30:	8c400114 	ori	r17,r17,4
81118e34:	3029883a 	mov	r20,r6
81118e38:	10c03fcc 	andi	r3,r2,255
81118e3c:	003ed006 	br	81118980 <__reset+0xfb0f8980>
81118e40:	e0800117 	ldw	r2,4(fp)
81118e44:	d9809d15 	stw	r6,628(sp)
81118e48:	00bf790e 	bge	zero,r2,81118c30 <__reset+0xfb0f8c30>
81118e4c:	00a04474 	movhi	r2,33041
81118e50:	10904e04 	addi	r2,r2,16696
81118e54:	02000284 	movi	r8,10
81118e58:	d880a115 	stw	r2,644(sp)
81118e5c:	da009e15 	stw	r8,632(sp)
81118e60:	050000c4 	movi	r20,3
81118e64:	003f8106 	br	81118c6c <__reset+0xfb0f8c6c>
81118e68:	e0800117 	ldw	r2,4(fp)
81118e6c:	d9809d15 	stw	r6,628(sp)
81118e70:	0080c40e 	bge	zero,r2,81119184 <__svfscanf_r+0x930>
81118e74:	9800011e 	bne	r19,zero,81118e7c <__svfscanf_r+0x628>
81118e78:	04c00044 	movi	r19,1
81118e7c:	8880004c 	andi	r2,r17,1
81118e80:	1000441e 	bne	r2,zero,81118f94 <__svfscanf_r+0x740>
81118e84:	8c40040c 	andi	r17,r17,16
81118e88:	8800da26 	beq	r17,zero,811191f4 <__svfscanf_r+0x9a0>
81118e8c:	0021883a 	mov	r16,zero
81118e90:	00000806 	br	81118eb4 <__svfscanf_r+0x660>
81118e94:	1887883a 	add	r3,r3,r2
81118e98:	e00b883a 	mov	r5,fp
81118e9c:	b009883a 	mov	r4,r22
81118ea0:	e0c00015 	stw	r3,0(fp)
81118ea4:	80a1883a 	add	r16,r16,r2
81118ea8:	98a7c83a 	sub	r19,r19,r2
81118eac:	1113b340 	call	81113b34 <__srefill_r>
81118eb0:	1000ca1e 	bne	r2,zero,811191dc <__svfscanf_r+0x988>
81118eb4:	e0800117 	ldw	r2,4(fp)
81118eb8:	e0c00017 	ldw	r3,0(fp)
81118ebc:	14fff516 	blt	r2,r19,81118e94 <__reset+0xfb0f8e94>
81118ec0:	14c5c83a 	sub	r2,r2,r19
81118ec4:	1cd5883a 	add	r10,r3,r19
81118ec8:	84e1883a 	add	r16,r16,r19
81118ecc:	e0800115 	stw	r2,4(fp)
81118ed0:	e2800015 	stw	r10,0(fp)
81118ed4:	dd009d17 	ldw	r20,628(sp)
81118ed8:	9425883a 	add	r18,r18,r16
81118edc:	a00d883a 	mov	r6,r20
81118ee0:	003e9a06 	br	8111894c <__reset+0xfb0f894c>
81118ee4:	300b883a 	mov	r5,r6
81118ee8:	d9005884 	addi	r4,sp,354
81118eec:	d9809d15 	stw	r6,628(sp)
81118ef0:	111ecdc0 	call	8111ecdc <__sccl>
81118ef4:	1029883a 	mov	r20,r2
81118ef8:	e0800117 	ldw	r2,4(fp)
81118efc:	0081050e 	bge	zero,r2,81119314 <__svfscanf_r+0xac0>
81118f00:	e1000017 	ldw	r4,0(fp)
81118f04:	20800003 	ldbu	r2,0(r4)
81118f08:	98005926 	beq	r19,zero,81119070 <__svfscanf_r+0x81c>
81118f0c:	8c40040c 	andi	r17,r17,16
81118f10:	88005a26 	beq	r17,zero,8111907c <__svfscanf_r+0x828>
81118f14:	9823883a 	mov	r17,r19
81118f18:	0021883a 	mov	r16,zero
81118f1c:	00000106 	br	81118f24 <__svfscanf_r+0x6d0>
81118f20:	20800003 	ldbu	r2,0(r4)
81118f24:	10803fcc 	andi	r2,r2,255
81118f28:	d8c05884 	addi	r3,sp,354
81118f2c:	1885883a 	add	r2,r3,r2
81118f30:	10800007 	ldb	r2,0(r2)
81118f34:	1000ad26 	beq	r2,zero,811191ec <__svfscanf_r+0x998>
81118f38:	e0800117 	ldw	r2,4(fp)
81118f3c:	21000044 	addi	r4,r4,1
81118f40:	84000044 	addi	r16,r16,1
81118f44:	10bfffc4 	addi	r2,r2,-1
81118f48:	e0800115 	stw	r2,4(fp)
81118f4c:	e1000015 	stw	r4,0(fp)
81118f50:	84c0a026 	beq	r16,r19,811191d4 <__svfscanf_r+0x980>
81118f54:	00bff216 	blt	zero,r2,81118f20 <__reset+0xfb0f8f20>
81118f58:	e00b883a 	mov	r5,fp
81118f5c:	b009883a 	mov	r4,r22
81118f60:	1113b340 	call	81113b34 <__srefill_r>
81118f64:	10009a1e 	bne	r2,zero,811191d0 <__svfscanf_r+0x97c>
81118f68:	e1000017 	ldw	r4,0(fp)
81118f6c:	003fec06 	br	81118f20 <__reset+0xfb0f8f20>
81118f70:	e0800117 	ldw	r2,4(fp)
81118f74:	d9809d15 	stw	r6,628(sp)
81118f78:	0080eb0e 	bge	zero,r2,81119328 <__svfscanf_r+0xad4>
81118f7c:	00a04474 	movhi	r2,33041
81118f80:	10904e04 	addi	r2,r2,16696
81118f84:	d880a115 	stw	r2,644(sp)
81118f88:	d8009e15 	stw	zero,632(sp)
81118f8c:	050000c4 	movi	r20,3
81118f90:	003f3606 	br	81118c6c <__reset+0xfb0f8c6c>
81118f94:	dd409904 	addi	r21,sp,612
81118f98:	8c40040c 	andi	r17,r17,16
81118f9c:	01800204 	movi	r6,8
81118fa0:	000b883a 	mov	r5,zero
81118fa4:	a809883a 	mov	r4,r21
81118fa8:	dc409f15 	stw	r17,636(sp)
81118fac:	11138300 	call	81113830 <memset>
81118fb0:	dc409f17 	ldw	r17,636(sp)
81118fb4:	88006e26 	beq	r17,zero,81119170 <__svfscanf_r+0x91c>
81118fb8:	0029883a 	mov	r20,zero
81118fbc:	0023883a 	mov	r17,zero
81118fc0:	111d0f80 	call	8111d0f8 <__locale_mb_cur_max>
81118fc4:	14406126 	beq	r2,r17,8111914c <__svfscanf_r+0x8f8>
81118fc8:	e0800017 	ldw	r2,0(fp)
81118fcc:	e0c00117 	ldw	r3,4(fp)
81118fd0:	d9000104 	addi	r4,sp,4
81118fd4:	12000003 	ldbu	r8,0(r2)
81118fd8:	18ffffc4 	addi	r3,r3,-1
81118fdc:	10800044 	addi	r2,r2,1
81118fe0:	e0c00115 	stw	r3,4(fp)
81118fe4:	e0800015 	stw	r2,0(fp)
81118fe8:	8c000044 	addi	r16,r17,1
81118fec:	dd400015 	stw	r21,0(sp)
81118ff0:	2463883a 	add	r17,r4,r17
81118ff4:	200d883a 	mov	r6,r4
81118ff8:	a00b883a 	mov	r5,r20
81118ffc:	800f883a 	mov	r7,r16
81119000:	b009883a 	mov	r4,r22
81119004:	8a000005 	stb	r8,0(r17)
81119008:	111d1b40 	call	8111d1b4 <_mbrtowc_r>
8111900c:	017fffc4 	movi	r5,-1
81119010:	11404e26 	beq	r2,r5,8111914c <__svfscanf_r+0x8f8>
81119014:	1000601e 	bne	r2,zero,81119198 <__svfscanf_r+0x944>
81119018:	da009f17 	ldw	r8,636(sp)
8111901c:	4000641e 	bne	r8,zero,811191b0 <__svfscanf_r+0x95c>
81119020:	a0000015 	stw	zero,0(r20)
81119024:	9425883a 	add	r18,r18,r16
81119028:	9967883a 	add	r19,r19,r5
8111902c:	a5000104 	addi	r20,r20,4
81119030:	e0800117 	ldw	r2,4(fp)
81119034:	0023883a 	mov	r17,zero
81119038:	00804b16 	blt	zero,r2,81119168 <__svfscanf_r+0x914>
8111903c:	e00b883a 	mov	r5,fp
81119040:	b009883a 	mov	r4,r22
81119044:	1113b340 	call	81113b34 <__srefill_r>
81119048:	10004726 	beq	r2,zero,81119168 <__svfscanf_r+0x914>
8111904c:	88003f1e 	bne	r17,zero,8111914c <__svfscanf_r+0x8f8>
81119050:	d8c09f17 	ldw	r3,636(sp)
81119054:	1800031e 	bne	r3,zero,81119064 <__svfscanf_r+0x810>
81119058:	da00a017 	ldw	r8,640(sp)
8111905c:	42000044 	addi	r8,r8,1
81119060:	da00a015 	stw	r8,640(sp)
81119064:	dd009d17 	ldw	r20,628(sp)
81119068:	a00d883a 	mov	r6,r20
8111906c:	003e3706 	br	8111894c <__reset+0xfb0f894c>
81119070:	8c40040c 	andi	r17,r17,16
81119074:	04ffffc4 	movi	r19,-1
81119078:	883fa61e 	bne	r17,zero,81118f14 <__reset+0xfb0f8f14>
8111907c:	da009c17 	ldw	r8,624(sp)
81119080:	9abfffc4 	addi	r10,r19,-1
81119084:	44000017 	ldw	r16,0(r8)
81119088:	44400104 	addi	r17,r8,4
8111908c:	8007883a 	mov	r3,r16
81119090:	82ab883a 	add	r21,r16,r10
81119094:	00000306 	br	811190a4 <__svfscanf_r+0x850>
81119098:	e1000017 	ldw	r4,0(fp)
8111909c:	9807883a 	mov	r3,r19
811190a0:	20800003 	ldbu	r2,0(r4)
811190a4:	10803fcc 	andi	r2,r2,255
811190a8:	d9405884 	addi	r5,sp,354
811190ac:	2885883a 	add	r2,r5,r2
811190b0:	10800007 	ldb	r2,0(r2)
811190b4:	10004b26 	beq	r2,zero,811191e4 <__svfscanf_r+0x990>
811190b8:	e0800117 	ldw	r2,4(fp)
811190bc:	21400044 	addi	r5,r4,1
811190c0:	e1400015 	stw	r5,0(fp)
811190c4:	10bfffc4 	addi	r2,r2,-1
811190c8:	e0800115 	stw	r2,4(fp)
811190cc:	20800003 	ldbu	r2,0(r4)
811190d0:	1cc00044 	addi	r19,r3,1
811190d4:	18800005 	stb	r2,0(r3)
811190d8:	1d400726 	beq	r3,r21,811190f8 <__svfscanf_r+0x8a4>
811190dc:	e0800117 	ldw	r2,4(fp)
811190e0:	00bfed16 	blt	zero,r2,81119098 <__reset+0xfb0f9098>
811190e4:	e00b883a 	mov	r5,fp
811190e8:	b009883a 	mov	r4,r22
811190ec:	1113b340 	call	81113b34 <__srefill_r>
811190f0:	103fe926 	beq	r2,zero,81119098 <__reset+0xfb0f9098>
811190f4:	84c01526 	beq	r16,r19,8111914c <__svfscanf_r+0x8f8>
811190f8:	9c21c83a 	sub	r16,r19,r16
811190fc:	803e1726 	beq	r16,zero,8111895c <__reset+0xfb0f895c>
81119100:	da00a017 	ldw	r8,640(sp)
81119104:	98000005 	stb	zero,0(r19)
81119108:	dc409c15 	stw	r17,624(sp)
8111910c:	42000044 	addi	r8,r8,1
81119110:	da00a015 	stw	r8,640(sp)
81119114:	9425883a 	add	r18,r18,r16
81119118:	a00d883a 	mov	r6,r20
8111911c:	003e0b06 	br	8111894c <__reset+0xfb0f894c>
81119120:	017fff84 	movi	r5,-2
81119124:	11439b1e 	bne	r2,r5,81119f94 <__svfscanf_r+0x1740>
81119128:	8821883a 	mov	r16,r17
8111912c:	e0800117 	ldw	r2,4(fp)
81119130:	0082e516 	blt	zero,r2,81119cc8 <__svfscanf_r+0x1474>
81119134:	e00b883a 	mov	r5,fp
81119138:	b009883a 	mov	r4,r22
8111913c:	1113b340 	call	81113b34 <__srefill_r>
81119140:	1002e126 	beq	r2,zero,81119cc8 <__svfscanf_r+0x1474>
81119144:	dc409f17 	ldw	r17,636(sp)
81119148:	8002e826 	beq	r16,zero,81119cec <__svfscanf_r+0x1498>
8111914c:	da00a017 	ldw	r8,640(sp)
81119150:	403e9c26 	beq	r8,zero,81118bc4 <__reset+0xfb0f8bc4>
81119154:	e080030b 	ldhu	r2,12(fp)
81119158:	1080100c 	andi	r2,r2,64
8111915c:	103e991e 	bne	r2,zero,81118bc4 <__reset+0xfb0f8bc4>
81119160:	4005883a 	mov	r2,r8
81119164:	003e9806 	br	81118bc8 <__reset+0xfb0f8bc8>
81119168:	983f951e 	bne	r19,zero,81118fc0 <__reset+0xfb0f8fc0>
8111916c:	003fb806 	br	81119050 <__reset+0xfb0f9050>
81119170:	da009c17 	ldw	r8,624(sp)
81119174:	45000017 	ldw	r20,0(r8)
81119178:	42000104 	addi	r8,r8,4
8111917c:	da009c15 	stw	r8,624(sp)
81119180:	003f8e06 	br	81118fbc <__reset+0xfb0f8fbc>
81119184:	e00b883a 	mov	r5,fp
81119188:	b009883a 	mov	r4,r22
8111918c:	1113b340 	call	81113b34 <__srefill_r>
81119190:	103f3826 	beq	r2,zero,81118e74 <__reset+0xfb0f8e74>
81119194:	003fed06 	br	8111914c <__reset+0xfb0f914c>
81119198:	00ffff84 	movi	r3,-2
8111919c:	10c0071e 	bne	r2,r3,811191bc <__svfscanf_r+0x968>
811191a0:	e0800117 	ldw	r2,4(fp)
811191a4:	8023883a 	mov	r17,r16
811191a8:	00bf8516 	blt	zero,r2,81118fc0 <__reset+0xfb0f8fc0>
811191ac:	003fa306 	br	8111903c <__reset+0xfb0f903c>
811191b0:	9425883a 	add	r18,r18,r16
811191b4:	9cffffc4 	addi	r19,r19,-1
811191b8:	003f9d06 	br	81119030 <__reset+0xfb0f9030>
811191bc:	da009f17 	ldw	r8,636(sp)
811191c0:	9425883a 	add	r18,r18,r16
811191c4:	9cffffc4 	addi	r19,r19,-1
811191c8:	403f9826 	beq	r8,zero,8111902c <__reset+0xfb0f902c>
811191cc:	003f9806 	br	81119030 <__reset+0xfb0f9030>
811191d0:	8023883a 	mov	r17,r16
811191d4:	8821883a 	mov	r16,r17
811191d8:	003fce06 	br	81119114 <__reset+0xfb0f9114>
811191dc:	803f3d1e 	bne	r16,zero,81118ed4 <__reset+0xfb0f8ed4>
811191e0:	003fda06 	br	8111914c <__reset+0xfb0f914c>
811191e4:	1827883a 	mov	r19,r3
811191e8:	003fc306 	br	811190f8 <__reset+0xfb0f90f8>
811191ec:	803fc91e 	bne	r16,zero,81119114 <__reset+0xfb0f9114>
811191f0:	003dda06 	br	8111895c <__reset+0xfb0f895c>
811191f4:	da009c17 	ldw	r8,624(sp)
811191f8:	df000015 	stw	fp,0(sp)
811191fc:	980f883a 	mov	r7,r19
81119200:	41400017 	ldw	r5,0(r8)
81119204:	01800044 	movi	r6,1
81119208:	b009883a 	mov	r4,r22
8111920c:	111c2cc0 	call	8111c2cc <_fread_r>
81119210:	da009c17 	ldw	r8,624(sp)
81119214:	40c00104 	addi	r3,r8,4
81119218:	103fcc26 	beq	r2,zero,8111914c <__reset+0xfb0f914c>
8111921c:	da00a017 	ldw	r8,640(sp)
81119220:	dd009d17 	ldw	r20,628(sp)
81119224:	90a5883a 	add	r18,r18,r2
81119228:	42000044 	addi	r8,r8,1
8111922c:	da00a015 	stw	r8,640(sp)
81119230:	d8c09c15 	stw	r3,624(sp)
81119234:	a00d883a 	mov	r6,r20
81119238:	003dc406 	br	8111894c <__reset+0xfb0f894c>
8111923c:	e00b883a 	mov	r5,fp
81119240:	b009883a 	mov	r4,r22
81119244:	1113b340 	call	81113b34 <__srefill_r>
81119248:	103e5226 	beq	r2,zero,81118b94 <__reset+0xfb0f8b94>
8111924c:	003fbf06 	br	8111914c <__reset+0xfb0f914c>
81119250:	a0800083 	ldbu	r2,2(r20)
81119254:	8c400094 	ori	r17,r17,2
81119258:	a5000084 	addi	r20,r20,2
8111925c:	10c03fcc 	andi	r3,r2,255
81119260:	003dc706 	br	81118980 <__reset+0xfb0f8980>
81119264:	e0800117 	ldw	r2,4(fp)
81119268:	88e2b03a 	or	r17,r17,r3
8111926c:	00bef716 	blt	zero,r2,81118e4c <__reset+0xfb0f8e4c>
81119270:	003e6f06 	br	81118c30 <__reset+0xfb0f8c30>
81119274:	8880004c 	andi	r2,r17,1
81119278:	10000b1e 	bne	r2,zero,811192a8 <__svfscanf_r+0xa54>
8111927c:	8c40008c 	andi	r17,r17,2
81119280:	88000926 	beq	r17,zero,811192a8 <__svfscanf_r+0xa54>
81119284:	da009c17 	ldw	r8,624(sp)
81119288:	9007d7fa 	srai	r3,r18,31
8111928c:	dd009d17 	ldw	r20,628(sp)
81119290:	40800017 	ldw	r2,0(r8)
81119294:	42000104 	addi	r8,r8,4
81119298:	da009c15 	stw	r8,624(sp)
8111929c:	14800015 	stw	r18,0(r2)
811192a0:	10c00115 	stw	r3,4(r2)
811192a4:	003da806 	br	81118948 <__reset+0xfb0f8948>
811192a8:	da009c17 	ldw	r8,624(sp)
811192ac:	dd009d17 	ldw	r20,628(sp)
811192b0:	40800017 	ldw	r2,0(r8)
811192b4:	42000104 	addi	r8,r8,4
811192b8:	da009c15 	stw	r8,624(sp)
811192bc:	14800015 	stw	r18,0(r2)
811192c0:	003da106 	br	81118948 <__reset+0xfb0f8948>
811192c4:	e00b883a 	mov	r5,fp
811192c8:	b009883a 	mov	r4,r22
811192cc:	1113b340 	call	81113b34 <__srefill_r>
811192d0:	103f9e1e 	bne	r2,zero,8111914c <__reset+0xfb0f914c>
811192d4:	b9c00017 	ldw	r7,0(r23)
811192d8:	05000104 	movi	r20,4
811192dc:	003e6306 	br	81118c6c <__reset+0xfb0f8c6c>
811192e0:	e00b883a 	mov	r5,fp
811192e4:	b009883a 	mov	r4,r22
811192e8:	1113b340 	call	81113b34 <__srefill_r>
811192ec:	103f971e 	bne	r2,zero,8111914c <__reset+0xfb0f914c>
811192f0:	b9c00017 	ldw	r7,0(r23)
811192f4:	003e5706 	br	81118c54 <__reset+0xfb0f8c54>
811192f8:	e00b883a 	mov	r5,fp
811192fc:	b009883a 	mov	r4,r22
81119300:	1113b340 	call	81113b34 <__srefill_r>
81119304:	103f911e 	bne	r2,zero,8111914c <__reset+0xfb0f914c>
81119308:	b9c00017 	ldw	r7,0(r23)
8111930c:	05000084 	movi	r20,2
81119310:	003e5606 	br	81118c6c <__reset+0xfb0f8c6c>
81119314:	e00b883a 	mov	r5,fp
81119318:	b009883a 	mov	r4,r22
8111931c:	1113b340 	call	81113b34 <__srefill_r>
81119320:	103ef726 	beq	r2,zero,81118f00 <__reset+0xfb0f8f00>
81119324:	003f8906 	br	8111914c <__reset+0xfb0f914c>
81119328:	e00b883a 	mov	r5,fp
8111932c:	b009883a 	mov	r4,r22
81119330:	1113b340 	call	81113b34 <__srefill_r>
81119334:	103f851e 	bne	r2,zero,8111914c <__reset+0xfb0f914c>
81119338:	b9c00017 	ldw	r7,0(r23)
8111933c:	003f0f06 	br	81118f7c <__reset+0xfb0f8f7c>
81119340:	014000c4 	movi	r5,3
81119344:	a1414a26 	beq	r20,r5,81119870 <__svfscanf_r+0x101c>
81119348:	01000104 	movi	r4,4
8111934c:	a101f11e 	bne	r20,r4,81119b14 <__svfscanf_r+0x12c0>
81119350:	b009883a 	mov	r4,r22
81119354:	111d11c0 	call	8111d11c <_localeconv_r>
81119358:	10800017 	ldw	r2,0(r2)
8111935c:	98ffffc4 	addi	r3,r19,-1
81119360:	d880a315 	stw	r2,652(sp)
81119364:	00805704 	movi	r2,348
81119368:	10c21e2e 	bgeu	r2,r3,81119be4 <__svfscanf_r+0x1390>
8111936c:	9cffa8c4 	addi	r19,r19,-349
81119370:	dcc0a215 	stw	r19,648(sp)
81119374:	04c05744 	movi	r19,349
81119378:	8d01e014 	ori	r20,r17,1920
8111937c:	0023883a 	mov	r17,zero
81119380:	dc000104 	addi	r16,sp,4
81119384:	8805883a 	mov	r2,r17
81119388:	0019883a 	mov	r12,zero
8111938c:	8023883a 	mov	r17,r16
81119390:	b007883a 	mov	r3,r22
81119394:	9821883a 	mov	r16,r19
81119398:	002b883a 	mov	r21,zero
8111939c:	d800a515 	stw	zero,660(sp)
811193a0:	d800a415 	stw	zero,656(sp)
811193a4:	d8009f15 	stw	zero,636(sp)
811193a8:	01c01384 	movi	r7,78
811193ac:	602d883a 	mov	r22,r12
811193b0:	1027883a 	mov	r19,r2
811193b4:	e1000017 	ldw	r4,0(fp)
811193b8:	21400003 	ldbu	r5,0(r4)
811193bc:	28bff544 	addi	r2,r5,-43
811193c0:	10803fcc 	andi	r2,r2,255
811193c4:	38810e36 	bltu	r7,r2,81119800 <__svfscanf_r+0xfac>
811193c8:	100490ba 	slli	r2,r2,2
811193cc:	01a044b4 	movhi	r6,33042
811193d0:	31a4f804 	addi	r6,r6,-27680
811193d4:	1185883a 	add	r2,r2,r6
811193d8:	10800017 	ldw	r2,0(r2)
811193dc:	1000683a 	jmp	r2
811193e0:	811196d8 	cmpnei	r4,r16,18011
811193e4:	81119800 	call	88111980 <__reset+0x20f1980>
811193e8:	811196d8 	cmpnei	r4,r16,18011
811193ec:	81119800 	call	88111980 <__reset+0x20f1980>
811193f0:	81119800 	call	88111980 <__reset+0x20f1980>
811193f4:	811196ac 	andhi	r4,r16,18010
811193f8:	8111951c 	xori	r4,r16,18004
811193fc:	8111951c 	xori	r4,r16,18004
81119400:	8111951c 	xori	r4,r16,18004
81119404:	8111951c 	xori	r4,r16,18004
81119408:	8111951c 	xori	r4,r16,18004
8111940c:	8111951c 	xori	r4,r16,18004
81119410:	8111951c 	xori	r4,r16,18004
81119414:	8111951c 	xori	r4,r16,18004
81119418:	8111951c 	xori	r4,r16,18004
8111941c:	81119800 	call	88111980 <__reset+0x20f1980>
81119420:	81119800 	call	88111980 <__reset+0x20f1980>
81119424:	81119800 	call	88111980 <__reset+0x20f1980>
81119428:	81119800 	call	88111980 <__reset+0x20f1980>
8111942c:	81119800 	call	88111980 <__reset+0x20f1980>
81119430:	81119800 	call	88111980 <__reset+0x20f1980>
81119434:	81119800 	call	88111980 <__reset+0x20f1980>
81119438:	811197f0 	cmpltui	r4,r16,18015
8111943c:	81119800 	call	88111980 <__reset+0x20f1980>
81119440:	81119800 	call	88111980 <__reset+0x20f1980>
81119444:	81119800 	call	88111980 <__reset+0x20f1980>
81119448:	811197ac 	andhi	r4,r16,18014
8111944c:	81119790 	cmplti	r4,r16,18014
81119450:	81119800 	call	88111980 <__reset+0x20f1980>
81119454:	81119800 	call	88111980 <__reset+0x20f1980>
81119458:	8111975c 	xori	r4,r16,18013
8111945c:	81119800 	call	88111980 <__reset+0x20f1980>
81119460:	81119800 	call	88111980 <__reset+0x20f1980>
81119464:	81119800 	call	88111980 <__reset+0x20f1980>
81119468:	81119800 	call	88111980 <__reset+0x20f1980>
8111946c:	81119724 	muli	r4,r16,18012
81119470:	81119800 	call	88111980 <__reset+0x20f1980>
81119474:	81119800 	call	88111980 <__reset+0x20f1980>
81119478:	81119800 	call	88111980 <__reset+0x20f1980>
8111947c:	81119800 	call	88111980 <__reset+0x20f1980>
81119480:	81119800 	call	88111980 <__reset+0x20f1980>
81119484:	81119708 	cmpgei	r4,r16,18012
81119488:	81119800 	call	88111980 <__reset+0x20f1980>
8111948c:	81119800 	call	88111980 <__reset+0x20f1980>
81119490:	81119800 	call	88111980 <__reset+0x20f1980>
81119494:	81119800 	call	88111980 <__reset+0x20f1980>
81119498:	811196ec 	andhi	r4,r16,18011
8111949c:	81119800 	call	88111980 <__reset+0x20f1980>
811194a0:	81119800 	call	88111980 <__reset+0x20f1980>
811194a4:	81119800 	call	88111980 <__reset+0x20f1980>
811194a8:	81119800 	call	88111980 <__reset+0x20f1980>
811194ac:	81119800 	call	88111980 <__reset+0x20f1980>
811194b0:	81119800 	call	88111980 <__reset+0x20f1980>
811194b4:	81119800 	call	88111980 <__reset+0x20f1980>
811194b8:	811197f0 	cmpltui	r4,r16,18015
811194bc:	81119800 	call	88111980 <__reset+0x20f1980>
811194c0:	81119800 	call	88111980 <__reset+0x20f1980>
811194c4:	81119800 	call	88111980 <__reset+0x20f1980>
811194c8:	811197ac 	andhi	r4,r16,18014
811194cc:	81119790 	cmplti	r4,r16,18014
811194d0:	81119800 	call	88111980 <__reset+0x20f1980>
811194d4:	81119800 	call	88111980 <__reset+0x20f1980>
811194d8:	8111975c 	xori	r4,r16,18013
811194dc:	81119800 	call	88111980 <__reset+0x20f1980>
811194e0:	81119800 	call	88111980 <__reset+0x20f1980>
811194e4:	81119800 	call	88111980 <__reset+0x20f1980>
811194e8:	81119800 	call	88111980 <__reset+0x20f1980>
811194ec:	81119724 	muli	r4,r16,18012
811194f0:	81119800 	call	88111980 <__reset+0x20f1980>
811194f4:	81119800 	call	88111980 <__reset+0x20f1980>
811194f8:	81119800 	call	88111980 <__reset+0x20f1980>
811194fc:	81119800 	call	88111980 <__reset+0x20f1980>
81119500:	81119800 	call	88111980 <__reset+0x20f1980>
81119504:	81119708 	cmpgei	r4,r16,18012
81119508:	81119800 	call	88111980 <__reset+0x20f1980>
8111950c:	81119800 	call	88111980 <__reset+0x20f1980>
81119510:	81119800 	call	88111980 <__reset+0x20f1980>
81119514:	81119800 	call	88111980 <__reset+0x20f1980>
81119518:	811196ec 	andhi	r4,r16,18011
8111951c:	a8803fcc 	andi	r2,r21,255
81119520:	1080201c 	xori	r2,r2,128
81119524:	10bfe004 	addi	r2,r2,-128
81119528:	b085883a 	add	r2,r22,r2
8111952c:	10000d1e 	bne	r2,zero,81119564 <__svfscanf_r+0xd10>
81119530:	00bf9fc4 	movi	r2,-385
81119534:	a0a8703a 	and	r20,r20,r2
81119538:	89400005 	stb	r5,0(r17)
8111953c:	8c400044 	addi	r17,r17,1
81119540:	e0800117 	ldw	r2,4(fp)
81119544:	843fffc4 	addi	r16,r16,-1
81119548:	94800044 	addi	r18,r18,1
8111954c:	10bfffc4 	addi	r2,r2,-1
81119550:	e0800115 	stw	r2,4(fp)
81119554:	0080b40e 	bge	zero,r2,81119828 <__svfscanf_r+0xfd4>
81119558:	21000044 	addi	r4,r4,1
8111955c:	e1000015 	stw	r4,0(fp)
81119560:	803f941e 	bne	r16,zero,811193b4 <__reset+0xfb0f93b4>
81119564:	8821883a 	mov	r16,r17
81119568:	b019883a 	mov	r12,r22
8111956c:	9823883a 	mov	r17,r19
81119570:	182d883a 	mov	r22,r3
81119574:	9801961e 	bne	r19,zero,81119bd0 <__svfscanf_r+0x137c>
81119578:	633fffc4 	addi	r12,r12,-1
8111957c:	00800044 	movi	r2,1
81119580:	1302882e 	bgeu	r2,r12,81119fa4 <__svfscanf_r+0x1750>
81119584:	a8803fcc 	andi	r2,r21,255
81119588:	1080201c 	xori	r2,r2,128
8111958c:	10bfe004 	addi	r2,r2,-128
81119590:	113fffc4 	addi	r4,r2,-1
81119594:	01400184 	movi	r5,6
81119598:	29001136 	bltu	r5,r4,811195e0 <__svfscanf_r+0xd8c>
8111959c:	01000084 	movi	r4,2
811195a0:	2082900e 	bge	r4,r2,81119fe4 <__svfscanf_r+0x1790>
811195a4:	00c000c4 	movi	r3,3
811195a8:	10c00d26 	beq	r2,r3,811195e0 <__svfscanf_r+0xd8c>
811195ac:	9425c83a 	sub	r18,r18,r16
811195b0:	1827883a 	mov	r19,r3
811195b4:	843fffc4 	addi	r16,r16,-1
811195b8:	81400007 	ldb	r5,0(r16)
811195bc:	e00d883a 	mov	r6,fp
811195c0:	b009883a 	mov	r4,r22
811195c4:	112234c0 	call	8112234c <_ungetc_r>
811195c8:	a8bfffc4 	addi	r2,r21,-1
811195cc:	10c03fcc 	andi	r3,r2,255
811195d0:	8493883a 	add	r9,r16,r18
811195d4:	102b883a 	mov	r21,r2
811195d8:	98fff636 	bltu	r19,r3,811195b4 <__reset+0xfb0f95b4>
811195dc:	4825883a 	mov	r18,r9
811195e0:	a080400c 	andi	r2,r20,256
811195e4:	10001426 	beq	r2,zero,81119638 <__svfscanf_r+0xde4>
811195e8:	a081000c 	andi	r2,r20,1024
811195ec:	1002571e 	bne	r2,zero,81119f4c <__svfscanf_r+0x16f8>
811195f0:	817fffc7 	ldb	r5,-1(r16)
811195f4:	00801944 	movi	r2,101
811195f8:	84ffffc4 	addi	r19,r16,-1
811195fc:	957fffc4 	addi	r21,r18,-1
81119600:	28800826 	beq	r5,r2,81119624 <__svfscanf_r+0xdd0>
81119604:	00801144 	movi	r2,69
81119608:	28800626 	beq	r5,r2,81119624 <__svfscanf_r+0xdd0>
8111960c:	e00d883a 	mov	r6,fp
81119610:	b009883a 	mov	r4,r22
81119614:	112234c0 	call	8112234c <_ungetc_r>
81119618:	817fff87 	ldb	r5,-2(r16)
8111961c:	84ffff84 	addi	r19,r16,-2
81119620:	957fff84 	addi	r21,r18,-2
81119624:	e00d883a 	mov	r6,fp
81119628:	b009883a 	mov	r4,r22
8111962c:	112234c0 	call	8112234c <_ungetc_r>
81119630:	a825883a 	mov	r18,r21
81119634:	9821883a 	mov	r16,r19
81119638:	a080040c 	andi	r2,r20,16
8111963c:	103e891e 	bne	r2,zero,81119064 <__reset+0xfb0f9064>
81119640:	80000005 	stb	zero,0(r16)
81119644:	a081800c 	andi	r2,r20,1536
81119648:	01010004 	movi	r4,1024
8111964c:	1101dd26 	beq	r2,r4,81119dc4 <__svfscanf_r+0x1570>
81119650:	da00a417 	ldw	r8,656(sp)
81119654:	4001e71e 	bne	r8,zero,81119df4 <__svfscanf_r+0x15a0>
81119658:	000d883a 	mov	r6,zero
8111965c:	d9400104 	addi	r5,sp,4
81119660:	b009883a 	mov	r4,r22
81119664:	111eefc0 	call	8111eefc <_strtod_r>
81119668:	1021883a 	mov	r16,r2
8111966c:	a080004c 	andi	r2,r20,1
81119670:	1000021e 	bne	r2,zero,8111967c <__svfscanf_r+0xe28>
81119674:	a2c0008c 	andi	r11,r20,2
81119678:	5801e826 	beq	r11,zero,81119e1c <__svfscanf_r+0x15c8>
8111967c:	da009c17 	ldw	r8,624(sp)
81119680:	40800017 	ldw	r2,0(r8)
81119684:	42000104 	addi	r8,r8,4
81119688:	da009c15 	stw	r8,624(sp)
8111968c:	14000015 	stw	r16,0(r2)
81119690:	10c00115 	stw	r3,4(r2)
81119694:	da00a017 	ldw	r8,640(sp)
81119698:	dd009d17 	ldw	r20,628(sp)
8111969c:	42000044 	addi	r8,r8,1
811196a0:	da00a015 	stw	r8,640(sp)
811196a4:	a00d883a 	mov	r6,r20
811196a8:	003ca806 	br	8111894c <__reset+0xfb0f894c>
811196ac:	a080400c 	andi	r2,r20,256
811196b0:	103f9a26 	beq	r2,zero,8111951c <__reset+0xfb0f951c>
811196b4:	da00a217 	ldw	r8,648(sp)
811196b8:	00bfdfc4 	movi	r2,-129
811196bc:	a0a8703a 	and	r20,r20,r2
811196c0:	9cc00044 	addi	r19,r19,1
811196c4:	403f9e26 	beq	r8,zero,81119540 <__reset+0xfb0f9540>
811196c8:	423fffc4 	addi	r8,r8,-1
811196cc:	da00a215 	stw	r8,648(sp)
811196d0:	84000044 	addi	r16,r16,1
811196d4:	003f9a06 	br	81119540 <__reset+0xfb0f9540>
811196d8:	a080200c 	andi	r2,r20,128
811196dc:	103fa126 	beq	r2,zero,81119564 <__reset+0xfb0f9564>
811196e0:	00bfdfc4 	movi	r2,-129
811196e4:	a0a8703a 	and	r20,r20,r2
811196e8:	003f9306 	br	81119538 <__reset+0xfb0f9538>
811196ec:	a8803fcc 	andi	r2,r21,255
811196f0:	1080201c 	xori	r2,r2,128
811196f4:	10bfe004 	addi	r2,r2,-128
811196f8:	020001c4 	movi	r8,7
811196fc:	123f991e 	bne	r2,r8,81119564 <__reset+0xfb0f9564>
81119700:	05400204 	movi	r21,8
81119704:	003f8c06 	br	81119538 <__reset+0xfb0f9538>
81119708:	a8803fcc 	andi	r2,r21,255
8111970c:	1080201c 	xori	r2,r2,128
81119710:	10bfe004 	addi	r2,r2,-128
81119714:	01800184 	movi	r6,6
81119718:	11bf921e 	bne	r2,r6,81119564 <__reset+0xfb0f9564>
8111971c:	054001c4 	movi	r21,7
81119720:	003f8506 	br	81119538 <__reset+0xfb0f9538>
81119724:	b000491e 	bne	r22,zero,8111984c <__svfscanf_r+0xff8>
81119728:	9800031e 	bne	r19,zero,81119738 <__svfscanf_r+0xee4>
8111972c:	a081c00c 	andi	r2,r20,1792
81119730:	0181c004 	movi	r6,1792
81119734:	11819f26 	beq	r2,r6,81119db4 <__svfscanf_r+0x1560>
81119738:	a8803fcc 	andi	r2,r21,255
8111973c:	1080201c 	xori	r2,r2,128
81119740:	10bfe004 	addi	r2,r2,-128
81119744:	01800044 	movi	r6,1
81119748:	11800226 	beq	r2,r6,81119754 <__svfscanf_r+0xf00>
8111974c:	01800104 	movi	r6,4
81119750:	11bf841e 	bne	r2,r6,81119564 <__reset+0xfb0f9564>
81119754:	ad400044 	addi	r21,r21,1
81119758:	003f7706 	br	81119538 <__reset+0xfb0f9538>
8111975c:	a8803fcc 	andi	r2,r21,255
81119760:	1080201c 	xori	r2,r2,128
81119764:	10bfe004 	addi	r2,r2,-128
81119768:	10003c1e 	bne	r2,zero,8111985c <__svfscanf_r+0x1008>
8111976c:	9801141e 	bne	r19,zero,81119bc0 <__svfscanf_r+0x136c>
81119770:	a081c00c 	andi	r2,r20,1792
81119774:	0181c004 	movi	r6,1792
81119778:	11818226 	beq	r2,r6,81119d84 <__svfscanf_r+0x1530>
8111977c:	8821883a 	mov	r16,r17
81119780:	b019883a 	mov	r12,r22
81119784:	9823883a 	mov	r17,r19
81119788:	182d883a 	mov	r22,r3
8111978c:	003f7a06 	br	81119578 <__reset+0xfb0f9578>
81119790:	a8803fcc 	andi	r2,r21,255
81119794:	1080201c 	xori	r2,r2,128
81119798:	10bfe004 	addi	r2,r2,-128
8111979c:	01800084 	movi	r6,2
811197a0:	11bf701e 	bne	r2,r6,81119564 <__reset+0xfb0f9564>
811197a4:	054000c4 	movi	r21,3
811197a8:	003f6306 	br	81119538 <__reset+0xfb0f9538>
811197ac:	a081400c 	andi	r2,r20,1280
811197b0:	01810004 	movi	r6,1024
811197b4:	11800326 	beq	r2,r6,811197c4 <__svfscanf_r+0xf70>
811197b8:	a184703a 	and	r2,r20,r6
811197bc:	103f6926 	beq	r2,zero,81119564 <__reset+0xfb0f9564>
811197c0:	983fee26 	beq	r19,zero,8111977c <__reset+0xfb0f977c>
811197c4:	a080800c 	andi	r2,r20,512
811197c8:	1000041e 	bne	r2,zero,811197dc <__svfscanf_r+0xf88>
811197cc:	da009f17 	ldw	r8,636(sp)
811197d0:	dc40a515 	stw	r17,660(sp)
811197d4:	9a27c83a 	sub	r19,r19,r8
811197d8:	dcc0a415 	stw	r19,656(sp)
811197dc:	00be1fc4 	movi	r2,-1921
811197e0:	a0a8703a 	and	r20,r20,r2
811197e4:	a5006014 	ori	r20,r20,384
811197e8:	0027883a 	mov	r19,zero
811197ec:	003f5206 	br	81119538 <__reset+0xfb0f9538>
811197f0:	00800044 	movi	r2,1
811197f4:	b0bf5b1e 	bne	r22,r2,81119564 <__reset+0xfb0f9564>
811197f8:	05800084 	movi	r22,2
811197fc:	003f4e06 	br	81119538 <__reset+0xfb0f9538>
81119800:	d980a317 	ldw	r6,652(sp)
81119804:	30800003 	ldbu	r2,0(r6)
81119808:	29803fcc 	andi	r6,r5,255
8111980c:	30bf551e 	bne	r6,r2,81119564 <__reset+0xfb0f9564>
81119810:	a080800c 	andi	r2,r20,512
81119814:	103f5326 	beq	r2,zero,81119564 <__reset+0xfb0f9564>
81119818:	023f5fc4 	movi	r8,-641
8111981c:	a228703a 	and	r20,r20,r8
81119820:	dcc09f15 	stw	r19,636(sp)
81119824:	003f4406 	br	81119538 <__reset+0xfb0f9538>
81119828:	1809883a 	mov	r4,r3
8111982c:	e00b883a 	mov	r5,fp
81119830:	d8c0a615 	stw	r3,664(sp)
81119834:	d9c0aa15 	stw	r7,680(sp)
81119838:	1113b340 	call	81113b34 <__srefill_r>
8111983c:	d8c0a617 	ldw	r3,664(sp)
81119840:	d9c0aa17 	ldw	r7,680(sp)
81119844:	103f4626 	beq	r2,zero,81119560 <__reset+0xfb0f9560>
81119848:	003f4606 	br	81119564 <__reset+0xfb0f9564>
8111984c:	00800084 	movi	r2,2
81119850:	b0bfb91e 	bne	r22,r2,81119738 <__reset+0xfb0f9738>
81119854:	058000c4 	movi	r22,3
81119858:	003f3706 	br	81119538 <__reset+0xfb0f9538>
8111985c:	018000c4 	movi	r6,3
81119860:	11bfbc26 	beq	r2,r6,81119754 <__reset+0xfb0f9754>
81119864:	01800144 	movi	r6,5
81119868:	11bfba26 	beq	r2,r6,81119754 <__reset+0xfb0f9754>
8111986c:	003f3d06 	br	81119564 <__reset+0xfb0f9564>
81119870:	98bfffc4 	addi	r2,r19,-1
81119874:	01405704 	movi	r5,348
81119878:	2880d82e 	bgeu	r5,r2,81119bdc <__svfscanf_r+0x1388>
8111987c:	99ffa8c4 	addi	r7,r19,-349
81119880:	04c05744 	movi	r19,349
81119884:	8c436014 	ori	r17,r17,3456
81119888:	9013883a 	mov	r9,r18
8111988c:	8825883a 	mov	r18,r17
81119890:	dc409e17 	ldw	r17,632(sp)
81119894:	0029883a 	mov	r20,zero
81119898:	dc000104 	addi	r16,sp,4
8111989c:	05401344 	movi	r21,77
811198a0:	02c08004 	movi	r11,512
811198a4:	01bf7fc4 	movi	r6,-513
811198a8:	023fdfc4 	movi	r8,-129
811198ac:	20bff544 	addi	r2,r4,-43
811198b0:	10803fcc 	andi	r2,r2,255
811198b4:	a8807236 	bltu	r21,r2,81119a80 <__svfscanf_r+0x122c>
811198b8:	100490ba 	slli	r2,r2,2
811198bc:	016044b4 	movhi	r5,33042
811198c0:	29663404 	addi	r5,r5,-26416
811198c4:	1145883a 	add	r2,r2,r5
811198c8:	10800017 	ldw	r2,0(r2)
811198cc:	1000683a 	jmp	r2
811198d0:	81119b04 	addi	r4,r16,18028
811198d4:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811198d8:	81119b04 	addi	r4,r16,18028
811198dc:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811198e0:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811198e4:	81119adc 	xori	r4,r16,18027
811198e8:	81119abc 	xorhi	r4,r16,18026
811198ec:	81119abc 	xorhi	r4,r16,18026
811198f0:	81119abc 	xorhi	r4,r16,18026
811198f4:	81119abc 	xorhi	r4,r16,18026
811198f8:	81119abc 	xorhi	r4,r16,18026
811198fc:	81119abc 	xorhi	r4,r16,18026
81119900:	81119abc 	xorhi	r4,r16,18026
81119904:	81119a64 	muli	r4,r16,18025
81119908:	81119a64 	muli	r4,r16,18025
8111990c:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119910:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119914:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119918:	81119a80 	call	881119a8 <__reset+0x20f19a8>
8111991c:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119920:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119924:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119928:	81119a50 	cmplti	r4,r16,18025
8111992c:	81119a50 	cmplti	r4,r16,18025
81119930:	81119a50 	cmplti	r4,r16,18025
81119934:	81119a50 	cmplti	r4,r16,18025
81119938:	81119a50 	cmplti	r4,r16,18025
8111993c:	81119a50 	cmplti	r4,r16,18025
81119940:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119944:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119948:	81119a80 	call	881119a8 <__reset+0x20f19a8>
8111994c:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119950:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119954:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119958:	81119a80 	call	881119a8 <__reset+0x20f19a8>
8111995c:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119960:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119964:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119968:	81119a80 	call	881119a8 <__reset+0x20f19a8>
8111996c:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119970:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119974:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119978:	81119a80 	call	881119a8 <__reset+0x20f19a8>
8111997c:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119980:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119984:	81119a08 	cmpgei	r4,r16,18024
81119988:	81119a80 	call	881119a8 <__reset+0x20f19a8>
8111998c:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119990:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119994:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119998:	81119a80 	call	881119a8 <__reset+0x20f19a8>
8111999c:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199a0:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199a4:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199a8:	81119a50 	cmplti	r4,r16,18025
811199ac:	81119a50 	cmplti	r4,r16,18025
811199b0:	81119a50 	cmplti	r4,r16,18025
811199b4:	81119a50 	cmplti	r4,r16,18025
811199b8:	81119a50 	cmplti	r4,r16,18025
811199bc:	81119a50 	cmplti	r4,r16,18025
811199c0:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199c4:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199c8:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199cc:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199d0:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199d4:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199d8:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199dc:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199e0:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199e4:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199e8:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199ec:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199f0:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199f4:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199f8:	81119a80 	call	881119a8 <__reset+0x20f19a8>
811199fc:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119a00:	81119a80 	call	881119a8 <__reset+0x20f19a8>
81119a04:	81119a08 	cmpgei	r4,r16,18024
81119a08:	9081800c 	andi	r2,r18,1536
81119a0c:	12c01c1e 	bne	r2,r11,81119a80 <__svfscanf_r+0x122c>
81119a10:	91a4703a 	and	r18,r18,r6
81119a14:	94814014 	ori	r18,r18,1280
81119a18:	04400404 	movi	r17,16
81119a1c:	81000005 	stb	r4,0(r16)
81119a20:	84000044 	addi	r16,r16,1
81119a24:	e0800117 	ldw	r2,4(fp)
81119a28:	10bfffc4 	addi	r2,r2,-1
81119a2c:	e0800115 	stw	r2,4(fp)
81119a30:	0080540e 	bge	zero,r2,81119b84 <__svfscanf_r+0x1330>
81119a34:	18c00044 	addi	r3,r3,1
81119a38:	e0c00015 	stw	r3,0(fp)
81119a3c:	9cffffc4 	addi	r19,r19,-1
81119a40:	98000f26 	beq	r19,zero,81119a80 <__svfscanf_r+0x122c>
81119a44:	e0c00017 	ldw	r3,0(fp)
81119a48:	19000003 	ldbu	r4,0(r3)
81119a4c:	003f9706 	br	811198ac <__reset+0xfb0f98ac>
81119a50:	00800284 	movi	r2,10
81119a54:	14400a0e 	bge	r2,r17,81119a80 <__svfscanf_r+0x122c>
81119a58:	00bd1fc4 	movi	r2,-2945
81119a5c:	90a4703a 	and	r18,r18,r2
81119a60:	003fee06 	br	81119a1c <__reset+0xfb0f9a1c>
81119a64:	01604534 	movhi	r5,33044
81119a68:	8c63883a 	add	r17,r17,r17
81119a6c:	297dc284 	addi	r5,r5,-2294
81119a70:	2c45883a 	add	r2,r5,r17
81119a74:	1440000f 	ldh	r17,0(r2)
81119a78:	00800204 	movi	r2,8
81119a7c:	147ff616 	blt	r2,r17,81119a58 <__reset+0xfb0f9a58>
81119a80:	dc409e15 	stw	r17,632(sp)
81119a84:	9023883a 	mov	r17,r18
81119a88:	8880400c 	andi	r2,r17,256
81119a8c:	4825883a 	mov	r18,r9
81119a90:	10000426 	beq	r2,zero,81119aa4 <__svfscanf_r+0x1250>
81119a94:	d9800104 	addi	r6,sp,4
81119a98:	3400be36 	bltu	r6,r16,81119d94 <__svfscanf_r+0x1540>
81119a9c:	da000104 	addi	r8,sp,4
81119aa0:	443bae26 	beq	r8,r16,8111895c <__reset+0xfb0f895c>
81119aa4:	8880040c 	andi	r2,r17,16
81119aa8:	10009326 	beq	r2,zero,81119cf8 <__svfscanf_r+0x14a4>
81119aac:	d8800104 	addi	r2,sp,4
81119ab0:	80a1c83a 	sub	r16,r16,r2
81119ab4:	8521883a 	add	r16,r16,r20
81119ab8:	003d0606 	br	81118ed4 <__reset+0xfb0f8ed4>
81119abc:	01604534 	movhi	r5,33044
81119ac0:	8c63883a 	add	r17,r17,r17
81119ac4:	297dc284 	addi	r5,r5,-2294
81119ac8:	2c45883a 	add	r2,r5,r17
81119acc:	1440000f 	ldh	r17,0(r2)
81119ad0:	00bd1fc4 	movi	r2,-2945
81119ad4:	90a4703a 	and	r18,r18,r2
81119ad8:	003fd006 	br	81119a1c <__reset+0xfb0f9a1c>
81119adc:	9082000c 	andi	r2,r18,2048
81119ae0:	103fce26 	beq	r2,zero,81119a1c <__reset+0xfb0f9a1c>
81119ae4:	8800021e 	bne	r17,zero,81119af0 <__svfscanf_r+0x129c>
81119ae8:	94808014 	ori	r18,r18,512
81119aec:	04400204 	movi	r17,8
81119af0:	9081000c 	andi	r2,r18,1024
81119af4:	10009426 	beq	r2,zero,81119d48 <__svfscanf_r+0x14f4>
81119af8:	00be9fc4 	movi	r2,-1409
81119afc:	90a4703a 	and	r18,r18,r2
81119b00:	003fc606 	br	81119a1c <__reset+0xfb0f9a1c>
81119b04:	9080200c 	andi	r2,r18,128
81119b08:	103fdd26 	beq	r2,zero,81119a80 <__reset+0xfb0f9a80>
81119b0c:	9224703a 	and	r18,r18,r8
81119b10:	003fc206 	br	81119a1c <__reset+0xfb0f9a1c>
81119b14:	9800011e 	bne	r19,zero,81119b1c <__svfscanf_r+0x12c8>
81119b18:	04ffffc4 	movi	r19,-1
81119b1c:	8900004c 	andi	r4,r17,1
81119b20:	20005b1e 	bne	r4,zero,81119c90 <__svfscanf_r+0x143c>
81119b24:	8c40040c 	andi	r17,r17,16
81119b28:	88003026 	beq	r17,zero,81119bec <__svfscanf_r+0x1398>
81119b2c:	0021883a 	mov	r16,zero
81119b30:	00000306 	br	81119b40 <__svfscanf_r+0x12ec>
81119b34:	18800003 	ldbu	r2,0(r3)
81119b38:	3885883a 	add	r2,r7,r2
81119b3c:	10800043 	ldbu	r2,1(r2)
81119b40:	1080020c 	andi	r2,r2,8
81119b44:	103ce31e 	bne	r2,zero,81118ed4 <__reset+0xfb0f8ed4>
81119b48:	e0800117 	ldw	r2,4(fp)
81119b4c:	18c00044 	addi	r3,r3,1
81119b50:	84000044 	addi	r16,r16,1
81119b54:	10bfffc4 	addi	r2,r2,-1
81119b58:	e0800115 	stw	r2,4(fp)
81119b5c:	e0c00015 	stw	r3,0(fp)
81119b60:	84fcdc26 	beq	r16,r19,81118ed4 <__reset+0xfb0f8ed4>
81119b64:	00bff316 	blt	zero,r2,81119b34 <__reset+0xfb0f9b34>
81119b68:	e00b883a 	mov	r5,fp
81119b6c:	b009883a 	mov	r4,r22
81119b70:	1113b340 	call	81113b34 <__srefill_r>
81119b74:	103cd71e 	bne	r2,zero,81118ed4 <__reset+0xfb0f8ed4>
81119b78:	b9c00017 	ldw	r7,0(r23)
81119b7c:	e0c00017 	ldw	r3,0(fp)
81119b80:	003fec06 	br	81119b34 <__reset+0xfb0f9b34>
81119b84:	e00b883a 	mov	r5,fp
81119b88:	b009883a 	mov	r4,r22
81119b8c:	d980a715 	stw	r6,668(sp)
81119b90:	d9c0aa15 	stw	r7,680(sp)
81119b94:	da00a815 	stw	r8,672(sp)
81119b98:	da40a915 	stw	r9,676(sp)
81119b9c:	dac0a615 	stw	r11,664(sp)
81119ba0:	1113b340 	call	81113b34 <__srefill_r>
81119ba4:	d980a717 	ldw	r6,668(sp)
81119ba8:	d9c0aa17 	ldw	r7,680(sp)
81119bac:	da00a817 	ldw	r8,672(sp)
81119bb0:	da40a917 	ldw	r9,676(sp)
81119bb4:	dac0a617 	ldw	r11,664(sp)
81119bb8:	103fa026 	beq	r2,zero,81119a3c <__reset+0xfb0f9a3c>
81119bbc:	003fb006 	br	81119a80 <__reset+0xfb0f9a80>
81119bc0:	8821883a 	mov	r16,r17
81119bc4:	b019883a 	mov	r12,r22
81119bc8:	9823883a 	mov	r17,r19
81119bcc:	182d883a 	mov	r22,r3
81119bd0:	00bfbfc4 	movi	r2,-257
81119bd4:	a0a8703a 	and	r20,r20,r2
81119bd8:	003e6706 	br	81119578 <__reset+0xfb0f9578>
81119bdc:	000f883a 	mov	r7,zero
81119be0:	003f2806 	br	81119884 <__reset+0xfb0f9884>
81119be4:	d800a215 	stw	zero,648(sp)
81119be8:	003de306 	br	81119378 <__reset+0xfb0f9378>
81119bec:	da009c17 	ldw	r8,624(sp)
81119bf0:	9abfffc4 	addi	r10,r19,-1
81119bf4:	44400017 	ldw	r17,0(r8)
81119bf8:	44000104 	addi	r16,r8,4
81119bfc:	880b883a 	mov	r5,r17
81119c00:	8aa9883a 	add	r20,r17,r10
81119c04:	00000606 	br	81119c20 <__svfscanf_r+0x13cc>
81119c08:	e0c00017 	ldw	r3,0(fp)
81119c0c:	b9000017 	ldw	r4,0(r23)
81119c10:	a80b883a 	mov	r5,r21
81119c14:	18800003 	ldbu	r2,0(r3)
81119c18:	2085883a 	add	r2,r4,r2
81119c1c:	10800043 	ldbu	r2,1(r2)
81119c20:	1080020c 	andi	r2,r2,8
81119c24:	1000551e 	bne	r2,zero,81119d7c <__svfscanf_r+0x1528>
81119c28:	e0800117 	ldw	r2,4(fp)
81119c2c:	19000044 	addi	r4,r3,1
81119c30:	e1000015 	stw	r4,0(fp)
81119c34:	10bfffc4 	addi	r2,r2,-1
81119c38:	e0800115 	stw	r2,4(fp)
81119c3c:	18800003 	ldbu	r2,0(r3)
81119c40:	2d400044 	addi	r21,r5,1
81119c44:	a827883a 	mov	r19,r21
81119c48:	28800005 	stb	r2,0(r5)
81119c4c:	2d000626 	beq	r5,r20,81119c68 <__svfscanf_r+0x1414>
81119c50:	e0800117 	ldw	r2,4(fp)
81119c54:	00bfec16 	blt	zero,r2,81119c08 <__reset+0xfb0f9c08>
81119c58:	e00b883a 	mov	r5,fp
81119c5c:	b009883a 	mov	r4,r22
81119c60:	1113b340 	call	81113b34 <__srefill_r>
81119c64:	103fe826 	beq	r2,zero,81119c08 <__reset+0xfb0f9c08>
81119c68:	da00a017 	ldw	r8,640(sp)
81119c6c:	dd009d17 	ldw	r20,628(sp)
81119c70:	9c63c83a 	sub	r17,r19,r17
81119c74:	42000044 	addi	r8,r8,1
81119c78:	98000005 	stb	zero,0(r19)
81119c7c:	9465883a 	add	r18,r18,r17
81119c80:	da00a015 	stw	r8,640(sp)
81119c84:	dc009c15 	stw	r16,624(sp)
81119c88:	a00d883a 	mov	r6,r20
81119c8c:	003b2f06 	br	8111894c <__reset+0xfb0f894c>
81119c90:	dd409904 	addi	r21,sp,612
81119c94:	8c40040c 	andi	r17,r17,16
81119c98:	01800204 	movi	r6,8
81119c9c:	000b883a 	mov	r5,zero
81119ca0:	a809883a 	mov	r4,r21
81119ca4:	11138300 	call	81113830 <memset>
81119ca8:	8800401e 	bne	r17,zero,81119dac <__svfscanf_r+0x1558>
81119cac:	da009c17 	ldw	r8,624(sp)
81119cb0:	45000017 	ldw	r20,0(r8)
81119cb4:	42000104 	addi	r8,r8,4
81119cb8:	da009c15 	stw	r8,624(sp)
81119cbc:	000d883a 	mov	r6,zero
81119cc0:	3021883a 	mov	r16,r6
81119cc4:	dc409f15 	stw	r17,636(sp)
81119cc8:	e0800017 	ldw	r2,0(fp)
81119ccc:	b8c00017 	ldw	r3,0(r23)
81119cd0:	10800003 	ldbu	r2,0(r2)
81119cd4:	1885883a 	add	r2,r3,r2
81119cd8:	10800043 	ldbu	r2,1(r2)
81119cdc:	1080020c 	andi	r2,r2,8
81119ce0:	1000011e 	bne	r2,zero,81119ce8 <__svfscanf_r+0x1494>
81119ce4:	9800701e 	bne	r19,zero,81119ea8 <__svfscanf_r+0x1654>
81119ce8:	dc409f17 	ldw	r17,636(sp)
81119cec:	883cdd1e 	bne	r17,zero,81119064 <__reset+0xfb0f9064>
81119cf0:	a0000015 	stw	zero,0(r20)
81119cf4:	003cd806 	br	81119058 <__reset+0xfb0f9058>
81119cf8:	d9c09e17 	ldw	r7,632(sp)
81119cfc:	da00a117 	ldw	r8,644(sp)
81119d00:	000d883a 	mov	r6,zero
81119d04:	d9400104 	addi	r5,sp,4
81119d08:	b009883a 	mov	r4,r22
81119d0c:	80000005 	stb	zero,0(r16)
81119d10:	403ee83a 	callr	r8
81119d14:	88c0080c 	andi	r3,r17,32
81119d18:	1800121e 	bne	r3,zero,81119d64 <__svfscanf_r+0x1510>
81119d1c:	88c0010c 	andi	r3,r17,4
81119d20:	18004d26 	beq	r3,zero,81119e58 <__svfscanf_r+0x1604>
81119d24:	da009c17 	ldw	r8,624(sp)
81119d28:	40c00017 	ldw	r3,0(r8)
81119d2c:	42000104 	addi	r8,r8,4
81119d30:	da009c15 	stw	r8,624(sp)
81119d34:	1880000d 	sth	r2,0(r3)
81119d38:	da00a017 	ldw	r8,640(sp)
81119d3c:	42000044 	addi	r8,r8,1
81119d40:	da00a015 	stw	r8,640(sp)
81119d44:	003f5906 	br	81119aac <__reset+0xfb0f9aac>
81119d48:	00bf1fc4 	movi	r2,-897
81119d4c:	90a4703a 	and	r18,r18,r2
81119d50:	38000226 	beq	r7,zero,81119d5c <__svfscanf_r+0x1508>
81119d54:	39ffffc4 	addi	r7,r7,-1
81119d58:	9cc00044 	addi	r19,r19,1
81119d5c:	a5000044 	addi	r20,r20,1
81119d60:	003f3006 	br	81119a24 <__reset+0xfb0f9a24>
81119d64:	da009c17 	ldw	r8,624(sp)
81119d68:	40c00017 	ldw	r3,0(r8)
81119d6c:	42000104 	addi	r8,r8,4
81119d70:	da009c15 	stw	r8,624(sp)
81119d74:	18800015 	stw	r2,0(r3)
81119d78:	003fef06 	br	81119d38 <__reset+0xfb0f9d38>
81119d7c:	2827883a 	mov	r19,r5
81119d80:	003fb906 	br	81119c68 <__reset+0xfb0f9c68>
81119d84:	01be1fc4 	movi	r6,-1921
81119d88:	a1a8703a 	and	r20,r20,r6
81119d8c:	05400044 	movi	r21,1
81119d90:	003de906 	br	81119538 <__reset+0xfb0f9538>
81119d94:	817fffc7 	ldb	r5,-1(r16)
81119d98:	e00d883a 	mov	r6,fp
81119d9c:	b009883a 	mov	r4,r22
81119da0:	843fffc4 	addi	r16,r16,-1
81119da4:	112234c0 	call	8112234c <_ungetc_r>
81119da8:	003f3c06 	br	81119a9c <__reset+0xfb0f9a9c>
81119dac:	dd009b04 	addi	r20,sp,620
81119db0:	003fc206 	br	81119cbc <__reset+0xfb0f9cbc>
81119db4:	00be1fc4 	movi	r2,-1921
81119db8:	a0a8703a 	and	r20,r20,r2
81119dbc:	05800044 	movi	r22,1
81119dc0:	003ddd06 	br	81119538 <__reset+0xfb0f9538>
81119dc4:	d8c09f17 	ldw	r3,636(sp)
81119dc8:	88e3c83a 	sub	r17,r17,r3
81119dcc:	044dc83a 	sub	r6,zero,r17
81119dd0:	883e2126 	beq	r17,zero,81119658 <__reset+0xfb0f9658>
81119dd4:	d88055c4 	addi	r2,sp,343
81119dd8:	80800136 	bltu	r16,r2,81119de0 <__svfscanf_r+0x158c>
81119ddc:	dc005584 	addi	r16,sp,342
81119de0:	01604534 	movhi	r5,33044
81119de4:	297dc104 	addi	r5,r5,-2300
81119de8:	8009883a 	mov	r4,r16
81119dec:	1113e480 	call	81113e48 <sprintf>
81119df0:	003e1906 	br	81119658 <__reset+0xfb0f9658>
81119df4:	d8c0a517 	ldw	r3,660(sp)
81119df8:	000d883a 	mov	r6,zero
81119dfc:	01c00284 	movi	r7,10
81119e00:	19400044 	addi	r5,r3,1
81119e04:	b009883a 	mov	r4,r22
81119e08:	11141380 	call	81114138 <_strtol_r>
81119e0c:	da00a417 	ldw	r8,656(sp)
81119e10:	dc00a517 	ldw	r16,660(sp)
81119e14:	120dc83a 	sub	r6,r2,r8
81119e18:	003fee06 	br	81119dd4 <__reset+0xfb0f9dd4>
81119e1c:	da009c17 	ldw	r8,624(sp)
81119e20:	180b883a 	mov	r5,r3
81119e24:	8009883a 	mov	r4,r16
81119e28:	45000017 	ldw	r20,0(r8)
81119e2c:	44400104 	addi	r17,r8,4
81119e30:	d8c0a615 	stw	r3,664(sp)
81119e34:	111ec680 	call	8111ec68 <__fpclassifyd>
81119e38:	d8c0a617 	ldw	r3,664(sp)
81119e3c:	10006426 	beq	r2,zero,81119fd0 <__svfscanf_r+0x177c>
81119e40:	8009883a 	mov	r4,r16
81119e44:	180b883a 	mov	r5,r3
81119e48:	11123780 	call	81112378 <__truncdfsf2>
81119e4c:	a0800015 	stw	r2,0(r20)
81119e50:	dc409c15 	stw	r17,624(sp)
81119e54:	003e0f06 	br	81119694 <__reset+0xfb0f9694>
81119e58:	88c0004c 	andi	r3,r17,1
81119e5c:	183fc11e 	bne	r3,zero,81119d64 <__reset+0xfb0f9d64>
81119e60:	8c40008c 	andi	r17,r17,2
81119e64:	883fbf26 	beq	r17,zero,81119d64 <__reset+0xfb0f9d64>
81119e68:	da00a117 	ldw	r8,644(sp)
81119e6c:	00a044b4 	movhi	r2,33042
81119e70:	10824104 	addi	r2,r2,2308
81119e74:	d9c09e17 	ldw	r7,632(sp)
81119e78:	000d883a 	mov	r6,zero
81119e7c:	d9400104 	addi	r5,sp,4
81119e80:	b009883a 	mov	r4,r22
81119e84:	40806226 	beq	r8,r2,8111a010 <__svfscanf_r+0x17bc>
81119e88:	112061c0 	call	8112061c <_strtoll_r>
81119e8c:	da009c17 	ldw	r8,624(sp)
81119e90:	41000017 	ldw	r4,0(r8)
81119e94:	42000104 	addi	r8,r8,4
81119e98:	da009c15 	stw	r8,624(sp)
81119e9c:	20800015 	stw	r2,0(r4)
81119ea0:	20c00115 	stw	r3,4(r4)
81119ea4:	003fa406 	br	81119d38 <__reset+0xfb0f9d38>
81119ea8:	111d0f80 	call	8111d0f8 <__locale_mb_cur_max>
81119eac:	80bca726 	beq	r16,r2,8111914c <__reset+0xfb0f914c>
81119eb0:	e0800017 	ldw	r2,0(fp)
81119eb4:	e1000117 	ldw	r4,4(fp)
81119eb8:	d8c00104 	addi	r3,sp,4
81119ebc:	12000003 	ldbu	r8,0(r2)
81119ec0:	213fffc4 	addi	r4,r4,-1
81119ec4:	10800044 	addi	r2,r2,1
81119ec8:	e1000115 	stw	r4,4(fp)
81119ecc:	e0800015 	stw	r2,0(fp)
81119ed0:	84400044 	addi	r17,r16,1
81119ed4:	dd400015 	stw	r21,0(sp)
81119ed8:	1c21883a 	add	r16,r3,r16
81119edc:	b009883a 	mov	r4,r22
81119ee0:	880f883a 	mov	r7,r17
81119ee4:	180d883a 	mov	r6,r3
81119ee8:	a00b883a 	mov	r5,r20
81119eec:	82000005 	stb	r8,0(r16)
81119ef0:	111d1b40 	call	8111d1b4 <_mbrtowc_r>
81119ef4:	013fffc4 	movi	r4,-1
81119ef8:	113c9426 	beq	r2,r4,8111914c <__reset+0xfb0f914c>
81119efc:	103c881e 	bne	r2,zero,81119120 <__reset+0xfb0f9120>
81119f00:	a0000015 	stw	zero,0(r20)
81119f04:	0009883a 	mov	r4,zero
81119f08:	111d0380 	call	8111d038 <iswspace>
81119f0c:	10001a26 	beq	r2,zero,81119f78 <__svfscanf_r+0x1724>
81119f10:	8821883a 	mov	r16,r17
81119f14:	dc409f17 	ldw	r17,636(sp)
81119f18:	803f7426 	beq	r16,zero,81119cec <__reset+0xfb0f9cec>
81119f1c:	843fffc4 	addi	r16,r16,-1
81119f20:	d9800104 	addi	r6,sp,4
81119f24:	342b883a 	add	r21,r6,r16
81119f28:	00000106 	br	81119f30 <__svfscanf_r+0x16dc>
81119f2c:	843fffc4 	addi	r16,r16,-1
81119f30:	a9400003 	ldbu	r5,0(r21)
81119f34:	e00d883a 	mov	r6,fp
81119f38:	b009883a 	mov	r4,r22
81119f3c:	112234c0 	call	8112234c <_ungetc_r>
81119f40:	ad7fffc4 	addi	r21,r21,-1
81119f44:	803ff91e 	bne	r16,zero,81119f2c <__reset+0xfb0f9f2c>
81119f48:	003f6806 	br	81119cec <__reset+0xfb0f9cec>
81119f4c:	d9800104 	addi	r6,sp,4
81119f50:	802b883a 	mov	r21,r16
81119f54:	343a812e 	bgeu	r6,r16,8111895c <__reset+0xfb0f895c>
81119f58:	ad7fffc4 	addi	r21,r21,-1
81119f5c:	a9400007 	ldb	r5,0(r21)
81119f60:	e00d883a 	mov	r6,fp
81119f64:	b009883a 	mov	r4,r22
81119f68:	112234c0 	call	8112234c <_ungetc_r>
81119f6c:	da000104 	addi	r8,sp,4
81119f70:	457ff91e 	bne	r8,r21,81119f58 <__reset+0xfb0f9f58>
81119f74:	003a7906 	br	8111895c <__reset+0xfb0f895c>
81119f78:	da009f17 	ldw	r8,636(sp)
81119f7c:	9465883a 	add	r18,r18,r17
81119f80:	9cffffc4 	addi	r19,r19,-1
81119f84:	4000051e 	bne	r8,zero,81119f9c <__svfscanf_r+0x1748>
81119f88:	a5000104 	addi	r20,r20,4
81119f8c:	0021883a 	mov	r16,zero
81119f90:	003c6606 	br	8111912c <__reset+0xfb0f912c>
81119f94:	a1000017 	ldw	r4,0(r20)
81119f98:	003fdb06 	br	81119f08 <__reset+0xfb0f9f08>
81119f9c:	0021883a 	mov	r16,zero
81119fa0:	003c6206 	br	8111912c <__reset+0xfb0f912c>
81119fa4:	d8800104 	addi	r2,sp,4
81119fa8:	802b883a 	mov	r21,r16
81119fac:	143a6b2e 	bgeu	r2,r16,8111895c <__reset+0xfb0f895c>
81119fb0:	ad7fffc4 	addi	r21,r21,-1
81119fb4:	a9400007 	ldb	r5,0(r21)
81119fb8:	e00d883a 	mov	r6,fp
81119fbc:	b009883a 	mov	r4,r22
81119fc0:	112234c0 	call	8112234c <_ungetc_r>
81119fc4:	d8c00104 	addi	r3,sp,4
81119fc8:	1d7ff91e 	bne	r3,r21,81119fb0 <__reset+0xfb0f9fb0>
81119fcc:	003a6306 	br	8111895c <__reset+0xfb0f895c>
81119fd0:	0009883a 	mov	r4,zero
81119fd4:	111edac0 	call	8111edac <nanf>
81119fd8:	a0800015 	stw	r2,0(r20)
81119fdc:	dc409c15 	stw	r17,624(sp)
81119fe0:	003dac06 	br	81119694 <__reset+0xfb0f9694>
81119fe4:	d9000104 	addi	r4,sp,4
81119fe8:	802b883a 	mov	r21,r16
81119fec:	243a5b2e 	bgeu	r4,r16,8111895c <__reset+0xfb0f895c>
81119ff0:	ad7fffc4 	addi	r21,r21,-1
81119ff4:	a9400007 	ldb	r5,0(r21)
81119ff8:	e00d883a 	mov	r6,fp
81119ffc:	b009883a 	mov	r4,r22
8111a000:	112234c0 	call	8112234c <_ungetc_r>
8111a004:	d9400104 	addi	r5,sp,4
8111a008:	2d7ff91e 	bne	r5,r21,81119ff0 <__reset+0xfb0f9ff0>
8111a00c:	003a5306 	br	8111895c <__reset+0xfb0f895c>
8111a010:	1120b740 	call	81120b74 <_strtoull_r>
8111a014:	003f9d06 	br	81119e8c <__reset+0xfb0f9e8c>

8111a018 <vfscanf>:
8111a018:	00a04534 	movhi	r2,33044
8111a01c:	defffb04 	addi	sp,sp,-20
8111a020:	1086aa04 	addi	r2,r2,6824
8111a024:	de00012e 	bgeu	sp,et,8111a02c <vfscanf+0x14>
8111a028:	003b68fa 	trap	3
8111a02c:	dc000215 	stw	r16,8(sp)
8111a030:	14000017 	ldw	r16,0(r2)
8111a034:	dc400315 	stw	r17,12(sp)
8111a038:	dfc00415 	stw	ra,16(sp)
8111a03c:	2023883a 	mov	r17,r4
8111a040:	80000826 	beq	r16,zero,8111a064 <vfscanf+0x4c>
8111a044:	80800e17 	ldw	r2,56(r16)
8111a048:	1000061e 	bne	r2,zero,8111a064 <vfscanf+0x4c>
8111a04c:	8009883a 	mov	r4,r16
8111a050:	d9400015 	stw	r5,0(sp)
8111a054:	d9800115 	stw	r6,4(sp)
8111a058:	111c1d00 	call	8111c1d0 <__sinit>
8111a05c:	d9800117 	ldw	r6,4(sp)
8111a060:	d9400017 	ldw	r5,0(sp)
8111a064:	300f883a 	mov	r7,r6
8111a068:	8009883a 	mov	r4,r16
8111a06c:	280d883a 	mov	r6,r5
8111a070:	880b883a 	mov	r5,r17
8111a074:	dfc00417 	ldw	ra,16(sp)
8111a078:	dc400317 	ldw	r17,12(sp)
8111a07c:	dc000217 	ldw	r16,8(sp)
8111a080:	dec00504 	addi	sp,sp,20
8111a084:	11188541 	jmpi	81118854 <__svfscanf_r>

8111a088 <__svfscanf>:
8111a088:	00a04534 	movhi	r2,33044
8111a08c:	1086aa04 	addi	r2,r2,6824
8111a090:	300f883a 	mov	r7,r6
8111a094:	280d883a 	mov	r6,r5
8111a098:	200b883a 	mov	r5,r4
8111a09c:	11000017 	ldw	r4,0(r2)
8111a0a0:	11188541 	jmpi	81118854 <__svfscanf_r>

8111a0a4 <_vfscanf_r>:
8111a0a4:	defffb04 	addi	sp,sp,-20
8111a0a8:	de00012e 	bgeu	sp,et,8111a0b0 <_vfscanf_r+0xc>
8111a0ac:	003b68fa 	trap	3
8111a0b0:	dc000315 	stw	r16,12(sp)
8111a0b4:	dfc00415 	stw	ra,16(sp)
8111a0b8:	2021883a 	mov	r16,r4
8111a0bc:	20000926 	beq	r4,zero,8111a0e4 <_vfscanf_r+0x40>
8111a0c0:	20800e17 	ldw	r2,56(r4)
8111a0c4:	1000071e 	bne	r2,zero,8111a0e4 <_vfscanf_r+0x40>
8111a0c8:	d9400015 	stw	r5,0(sp)
8111a0cc:	d9800115 	stw	r6,4(sp)
8111a0d0:	d9c00215 	stw	r7,8(sp)
8111a0d4:	111c1d00 	call	8111c1d0 <__sinit>
8111a0d8:	d9c00217 	ldw	r7,8(sp)
8111a0dc:	d9800117 	ldw	r6,4(sp)
8111a0e0:	d9400017 	ldw	r5,0(sp)
8111a0e4:	8009883a 	mov	r4,r16
8111a0e8:	dfc00417 	ldw	ra,16(sp)
8111a0ec:	dc000317 	ldw	r16,12(sp)
8111a0f0:	dec00504 	addi	sp,sp,20
8111a0f4:	11188541 	jmpi	81118854 <__svfscanf_r>

8111a0f8 <_write_r>:
8111a0f8:	defffd04 	addi	sp,sp,-12
8111a0fc:	de00012e 	bgeu	sp,et,8111a104 <_write_r+0xc>
8111a100:	003b68fa 	trap	3
8111a104:	2805883a 	mov	r2,r5
8111a108:	dc000015 	stw	r16,0(sp)
8111a10c:	04204534 	movhi	r16,33044
8111a110:	dc400115 	stw	r17,4(sp)
8111a114:	300b883a 	mov	r5,r6
8111a118:	84070504 	addi	r16,r16,7188
8111a11c:	2023883a 	mov	r17,r4
8111a120:	380d883a 	mov	r6,r7
8111a124:	1009883a 	mov	r4,r2
8111a128:	dfc00215 	stw	ra,8(sp)
8111a12c:	80000015 	stw	zero,0(r16)
8111a130:	1128d6c0 	call	81128d6c <write>
8111a134:	00ffffc4 	movi	r3,-1
8111a138:	10c00526 	beq	r2,r3,8111a150 <_write_r+0x58>
8111a13c:	dfc00217 	ldw	ra,8(sp)
8111a140:	dc400117 	ldw	r17,4(sp)
8111a144:	dc000017 	ldw	r16,0(sp)
8111a148:	dec00304 	addi	sp,sp,12
8111a14c:	f800283a 	ret
8111a150:	80c00017 	ldw	r3,0(r16)
8111a154:	183ff926 	beq	r3,zero,8111a13c <__reset+0xfb0fa13c>
8111a158:	88c00015 	stw	r3,0(r17)
8111a15c:	003ff706 	br	8111a13c <__reset+0xfb0fa13c>

8111a160 <__swsetup_r>:
8111a160:	00a04534 	movhi	r2,33044
8111a164:	defffd04 	addi	sp,sp,-12
8111a168:	1086aa04 	addi	r2,r2,6824
8111a16c:	de00012e 	bgeu	sp,et,8111a174 <__swsetup_r+0x14>
8111a170:	003b68fa 	trap	3
8111a174:	dc400115 	stw	r17,4(sp)
8111a178:	2023883a 	mov	r17,r4
8111a17c:	11000017 	ldw	r4,0(r2)
8111a180:	dc000015 	stw	r16,0(sp)
8111a184:	dfc00215 	stw	ra,8(sp)
8111a188:	2821883a 	mov	r16,r5
8111a18c:	20000226 	beq	r4,zero,8111a198 <__swsetup_r+0x38>
8111a190:	20800e17 	ldw	r2,56(r4)
8111a194:	10003126 	beq	r2,zero,8111a25c <__swsetup_r+0xfc>
8111a198:	8080030b 	ldhu	r2,12(r16)
8111a19c:	10c0020c 	andi	r3,r2,8
8111a1a0:	1009883a 	mov	r4,r2
8111a1a4:	18000f26 	beq	r3,zero,8111a1e4 <__swsetup_r+0x84>
8111a1a8:	80c00417 	ldw	r3,16(r16)
8111a1ac:	18001526 	beq	r3,zero,8111a204 <__swsetup_r+0xa4>
8111a1b0:	1100004c 	andi	r4,r2,1
8111a1b4:	20001c1e 	bne	r4,zero,8111a228 <__swsetup_r+0xc8>
8111a1b8:	1080008c 	andi	r2,r2,2
8111a1bc:	1000291e 	bne	r2,zero,8111a264 <__swsetup_r+0x104>
8111a1c0:	80800517 	ldw	r2,20(r16)
8111a1c4:	80800215 	stw	r2,8(r16)
8111a1c8:	18001c26 	beq	r3,zero,8111a23c <__swsetup_r+0xdc>
8111a1cc:	0005883a 	mov	r2,zero
8111a1d0:	dfc00217 	ldw	ra,8(sp)
8111a1d4:	dc400117 	ldw	r17,4(sp)
8111a1d8:	dc000017 	ldw	r16,0(sp)
8111a1dc:	dec00304 	addi	sp,sp,12
8111a1e0:	f800283a 	ret
8111a1e4:	2080040c 	andi	r2,r4,16
8111a1e8:	10002e26 	beq	r2,zero,8111a2a4 <__swsetup_r+0x144>
8111a1ec:	2080010c 	andi	r2,r4,4
8111a1f0:	10001e1e 	bne	r2,zero,8111a26c <__swsetup_r+0x10c>
8111a1f4:	80c00417 	ldw	r3,16(r16)
8111a1f8:	20800214 	ori	r2,r4,8
8111a1fc:	8080030d 	sth	r2,12(r16)
8111a200:	183feb1e 	bne	r3,zero,8111a1b0 <__reset+0xfb0fa1b0>
8111a204:	1100a00c 	andi	r4,r2,640
8111a208:	01408004 	movi	r5,512
8111a20c:	217fe826 	beq	r4,r5,8111a1b0 <__reset+0xfb0fa1b0>
8111a210:	800b883a 	mov	r5,r16
8111a214:	8809883a 	mov	r4,r17
8111a218:	1112d080 	call	81112d08 <__smakebuf_r>
8111a21c:	8080030b 	ldhu	r2,12(r16)
8111a220:	80c00417 	ldw	r3,16(r16)
8111a224:	003fe206 	br	8111a1b0 <__reset+0xfb0fa1b0>
8111a228:	80800517 	ldw	r2,20(r16)
8111a22c:	80000215 	stw	zero,8(r16)
8111a230:	0085c83a 	sub	r2,zero,r2
8111a234:	80800615 	stw	r2,24(r16)
8111a238:	183fe41e 	bne	r3,zero,8111a1cc <__reset+0xfb0fa1cc>
8111a23c:	80c0030b 	ldhu	r3,12(r16)
8111a240:	0005883a 	mov	r2,zero
8111a244:	1900200c 	andi	r4,r3,128
8111a248:	203fe126 	beq	r4,zero,8111a1d0 <__reset+0xfb0fa1d0>
8111a24c:	18c01014 	ori	r3,r3,64
8111a250:	80c0030d 	sth	r3,12(r16)
8111a254:	00bfffc4 	movi	r2,-1
8111a258:	003fdd06 	br	8111a1d0 <__reset+0xfb0fa1d0>
8111a25c:	111c1d00 	call	8111c1d0 <__sinit>
8111a260:	003fcd06 	br	8111a198 <__reset+0xfb0fa198>
8111a264:	0005883a 	mov	r2,zero
8111a268:	003fd606 	br	8111a1c4 <__reset+0xfb0fa1c4>
8111a26c:	81400c17 	ldw	r5,48(r16)
8111a270:	28000626 	beq	r5,zero,8111a28c <__swsetup_r+0x12c>
8111a274:	80801004 	addi	r2,r16,64
8111a278:	28800326 	beq	r5,r2,8111a288 <__swsetup_r+0x128>
8111a27c:	8809883a 	mov	r4,r17
8111a280:	111c6680 	call	8111c668 <_free_r>
8111a284:	8100030b 	ldhu	r4,12(r16)
8111a288:	80000c15 	stw	zero,48(r16)
8111a28c:	80c00417 	ldw	r3,16(r16)
8111a290:	00bff6c4 	movi	r2,-37
8111a294:	1108703a 	and	r4,r2,r4
8111a298:	80000115 	stw	zero,4(r16)
8111a29c:	80c00015 	stw	r3,0(r16)
8111a2a0:	003fd506 	br	8111a1f8 <__reset+0xfb0fa1f8>
8111a2a4:	00800244 	movi	r2,9
8111a2a8:	88800015 	stw	r2,0(r17)
8111a2ac:	20801014 	ori	r2,r4,64
8111a2b0:	8080030d 	sth	r2,12(r16)
8111a2b4:	00bfffc4 	movi	r2,-1
8111a2b8:	003fc506 	br	8111a1d0 <__reset+0xfb0fa1d0>

8111a2bc <_close_r>:
8111a2bc:	defffd04 	addi	sp,sp,-12
8111a2c0:	de00012e 	bgeu	sp,et,8111a2c8 <_close_r+0xc>
8111a2c4:	003b68fa 	trap	3
8111a2c8:	dc000015 	stw	r16,0(sp)
8111a2cc:	04204534 	movhi	r16,33044
8111a2d0:	dc400115 	stw	r17,4(sp)
8111a2d4:	84070504 	addi	r16,r16,7188
8111a2d8:	2023883a 	mov	r17,r4
8111a2dc:	2809883a 	mov	r4,r5
8111a2e0:	dfc00215 	stw	ra,8(sp)
8111a2e4:	80000015 	stw	zero,0(r16)
8111a2e8:	1127e900 	call	81127e90 <close>
8111a2ec:	00ffffc4 	movi	r3,-1
8111a2f0:	10c00526 	beq	r2,r3,8111a308 <_close_r+0x4c>
8111a2f4:	dfc00217 	ldw	ra,8(sp)
8111a2f8:	dc400117 	ldw	r17,4(sp)
8111a2fc:	dc000017 	ldw	r16,0(sp)
8111a300:	dec00304 	addi	sp,sp,12
8111a304:	f800283a 	ret
8111a308:	80c00017 	ldw	r3,0(r16)
8111a30c:	183ff926 	beq	r3,zero,8111a2f4 <__reset+0xfb0fa2f4>
8111a310:	88c00015 	stw	r3,0(r17)
8111a314:	003ff706 	br	8111a2f4 <__reset+0xfb0fa2f4>

8111a318 <quorem>:
8111a318:	defff704 	addi	sp,sp,-36
8111a31c:	de00012e 	bgeu	sp,et,8111a324 <quorem+0xc>
8111a320:	003b68fa 	trap	3
8111a324:	dc800215 	stw	r18,8(sp)
8111a328:	20800417 	ldw	r2,16(r4)
8111a32c:	2c800417 	ldw	r18,16(r5)
8111a330:	dfc00815 	stw	ra,32(sp)
8111a334:	ddc00715 	stw	r23,28(sp)
8111a338:	dd800615 	stw	r22,24(sp)
8111a33c:	dd400515 	stw	r21,20(sp)
8111a340:	dd000415 	stw	r20,16(sp)
8111a344:	dcc00315 	stw	r19,12(sp)
8111a348:	dc400115 	stw	r17,4(sp)
8111a34c:	dc000015 	stw	r16,0(sp)
8111a350:	14807116 	blt	r2,r18,8111a518 <quorem+0x200>
8111a354:	94bfffc4 	addi	r18,r18,-1
8111a358:	94ad883a 	add	r22,r18,r18
8111a35c:	b5ad883a 	add	r22,r22,r22
8111a360:	2c400504 	addi	r17,r5,20
8111a364:	8da9883a 	add	r20,r17,r22
8111a368:	25400504 	addi	r21,r4,20
8111a36c:	282f883a 	mov	r23,r5
8111a370:	adad883a 	add	r22,r21,r22
8111a374:	a1400017 	ldw	r5,0(r20)
8111a378:	2021883a 	mov	r16,r4
8111a37c:	b1000017 	ldw	r4,0(r22)
8111a380:	29400044 	addi	r5,r5,1
8111a384:	1125b500 	call	81125b50 <__udivsi3>
8111a388:	1027883a 	mov	r19,r2
8111a38c:	10002c26 	beq	r2,zero,8111a440 <quorem+0x128>
8111a390:	a813883a 	mov	r9,r21
8111a394:	880b883a 	mov	r5,r17
8111a398:	0009883a 	mov	r4,zero
8111a39c:	000d883a 	mov	r6,zero
8111a3a0:	2a000017 	ldw	r8,0(r5)
8111a3a4:	49c00017 	ldw	r7,0(r9)
8111a3a8:	29400104 	addi	r5,r5,4
8111a3ac:	40bfffcc 	andi	r2,r8,65535
8111a3b0:	14c5383a 	mul	r2,r2,r19
8111a3b4:	4010d43a 	srli	r8,r8,16
8111a3b8:	38ffffcc 	andi	r3,r7,65535
8111a3bc:	1105883a 	add	r2,r2,r4
8111a3c0:	1008d43a 	srli	r4,r2,16
8111a3c4:	44d1383a 	mul	r8,r8,r19
8111a3c8:	198d883a 	add	r6,r3,r6
8111a3cc:	10ffffcc 	andi	r3,r2,65535
8111a3d0:	30c7c83a 	sub	r3,r6,r3
8111a3d4:	380ed43a 	srli	r7,r7,16
8111a3d8:	4105883a 	add	r2,r8,r4
8111a3dc:	180dd43a 	srai	r6,r3,16
8111a3e0:	113fffcc 	andi	r4,r2,65535
8111a3e4:	390fc83a 	sub	r7,r7,r4
8111a3e8:	398d883a 	add	r6,r7,r6
8111a3ec:	300e943a 	slli	r7,r6,16
8111a3f0:	18ffffcc 	andi	r3,r3,65535
8111a3f4:	1008d43a 	srli	r4,r2,16
8111a3f8:	38ceb03a 	or	r7,r7,r3
8111a3fc:	49c00015 	stw	r7,0(r9)
8111a400:	300dd43a 	srai	r6,r6,16
8111a404:	4a400104 	addi	r9,r9,4
8111a408:	a17fe52e 	bgeu	r20,r5,8111a3a0 <__reset+0xfb0fa3a0>
8111a40c:	b0800017 	ldw	r2,0(r22)
8111a410:	10000b1e 	bne	r2,zero,8111a440 <quorem+0x128>
8111a414:	b0bfff04 	addi	r2,r22,-4
8111a418:	a880082e 	bgeu	r21,r2,8111a43c <quorem+0x124>
8111a41c:	b0ffff17 	ldw	r3,-4(r22)
8111a420:	18000326 	beq	r3,zero,8111a430 <quorem+0x118>
8111a424:	00000506 	br	8111a43c <quorem+0x124>
8111a428:	10c00017 	ldw	r3,0(r2)
8111a42c:	1800031e 	bne	r3,zero,8111a43c <quorem+0x124>
8111a430:	10bfff04 	addi	r2,r2,-4
8111a434:	94bfffc4 	addi	r18,r18,-1
8111a438:	a8bffb36 	bltu	r21,r2,8111a428 <__reset+0xfb0fa428>
8111a43c:	84800415 	stw	r18,16(r16)
8111a440:	b80b883a 	mov	r5,r23
8111a444:	8009883a 	mov	r4,r16
8111a448:	111df380 	call	8111df38 <__mcmp>
8111a44c:	10002616 	blt	r2,zero,8111a4e8 <quorem+0x1d0>
8111a450:	9cc00044 	addi	r19,r19,1
8111a454:	a805883a 	mov	r2,r21
8111a458:	000b883a 	mov	r5,zero
8111a45c:	11000017 	ldw	r4,0(r2)
8111a460:	89800017 	ldw	r6,0(r17)
8111a464:	10800104 	addi	r2,r2,4
8111a468:	20ffffcc 	andi	r3,r4,65535
8111a46c:	194b883a 	add	r5,r3,r5
8111a470:	30ffffcc 	andi	r3,r6,65535
8111a474:	28c7c83a 	sub	r3,r5,r3
8111a478:	300cd43a 	srli	r6,r6,16
8111a47c:	2008d43a 	srli	r4,r4,16
8111a480:	180bd43a 	srai	r5,r3,16
8111a484:	18ffffcc 	andi	r3,r3,65535
8111a488:	2189c83a 	sub	r4,r4,r6
8111a48c:	2149883a 	add	r4,r4,r5
8111a490:	200c943a 	slli	r6,r4,16
8111a494:	8c400104 	addi	r17,r17,4
8111a498:	200bd43a 	srai	r5,r4,16
8111a49c:	30c6b03a 	or	r3,r6,r3
8111a4a0:	10ffff15 	stw	r3,-4(r2)
8111a4a4:	a47fed2e 	bgeu	r20,r17,8111a45c <__reset+0xfb0fa45c>
8111a4a8:	9485883a 	add	r2,r18,r18
8111a4ac:	1085883a 	add	r2,r2,r2
8111a4b0:	a887883a 	add	r3,r21,r2
8111a4b4:	18800017 	ldw	r2,0(r3)
8111a4b8:	10000b1e 	bne	r2,zero,8111a4e8 <quorem+0x1d0>
8111a4bc:	18bfff04 	addi	r2,r3,-4
8111a4c0:	a880082e 	bgeu	r21,r2,8111a4e4 <quorem+0x1cc>
8111a4c4:	18ffff17 	ldw	r3,-4(r3)
8111a4c8:	18000326 	beq	r3,zero,8111a4d8 <quorem+0x1c0>
8111a4cc:	00000506 	br	8111a4e4 <quorem+0x1cc>
8111a4d0:	10c00017 	ldw	r3,0(r2)
8111a4d4:	1800031e 	bne	r3,zero,8111a4e4 <quorem+0x1cc>
8111a4d8:	10bfff04 	addi	r2,r2,-4
8111a4dc:	94bfffc4 	addi	r18,r18,-1
8111a4e0:	a8bffb36 	bltu	r21,r2,8111a4d0 <__reset+0xfb0fa4d0>
8111a4e4:	84800415 	stw	r18,16(r16)
8111a4e8:	9805883a 	mov	r2,r19
8111a4ec:	dfc00817 	ldw	ra,32(sp)
8111a4f0:	ddc00717 	ldw	r23,28(sp)
8111a4f4:	dd800617 	ldw	r22,24(sp)
8111a4f8:	dd400517 	ldw	r21,20(sp)
8111a4fc:	dd000417 	ldw	r20,16(sp)
8111a500:	dcc00317 	ldw	r19,12(sp)
8111a504:	dc800217 	ldw	r18,8(sp)
8111a508:	dc400117 	ldw	r17,4(sp)
8111a50c:	dc000017 	ldw	r16,0(sp)
8111a510:	dec00904 	addi	sp,sp,36
8111a514:	f800283a 	ret
8111a518:	0005883a 	mov	r2,zero
8111a51c:	003ff306 	br	8111a4ec <__reset+0xfb0fa4ec>

8111a520 <_dtoa_r>:
8111a520:	deffde04 	addi	sp,sp,-136
8111a524:	de00012e 	bgeu	sp,et,8111a52c <_dtoa_r+0xc>
8111a528:	003b68fa 	trap	3
8111a52c:	20801017 	ldw	r2,64(r4)
8111a530:	df002015 	stw	fp,128(sp)
8111a534:	dcc01b15 	stw	r19,108(sp)
8111a538:	dc801a15 	stw	r18,104(sp)
8111a53c:	dc401915 	stw	r17,100(sp)
8111a540:	dc001815 	stw	r16,96(sp)
8111a544:	dfc02115 	stw	ra,132(sp)
8111a548:	ddc01f15 	stw	r23,124(sp)
8111a54c:	dd801e15 	stw	r22,120(sp)
8111a550:	dd401d15 	stw	r21,116(sp)
8111a554:	dd001c15 	stw	r20,112(sp)
8111a558:	d9c00315 	stw	r7,12(sp)
8111a55c:	2039883a 	mov	fp,r4
8111a560:	3023883a 	mov	r17,r6
8111a564:	2825883a 	mov	r18,r5
8111a568:	dc002417 	ldw	r16,144(sp)
8111a56c:	3027883a 	mov	r19,r6
8111a570:	10000826 	beq	r2,zero,8111a594 <_dtoa_r+0x74>
8111a574:	21801117 	ldw	r6,68(r4)
8111a578:	00c00044 	movi	r3,1
8111a57c:	100b883a 	mov	r5,r2
8111a580:	1986983a 	sll	r3,r3,r6
8111a584:	11800115 	stw	r6,4(r2)
8111a588:	10c00215 	stw	r3,8(r2)
8111a58c:	111d6e80 	call	8111d6e8 <_Bfree>
8111a590:	e0001015 	stw	zero,64(fp)
8111a594:	88002e16 	blt	r17,zero,8111a650 <_dtoa_r+0x130>
8111a598:	80000015 	stw	zero,0(r16)
8111a59c:	889ffc2c 	andhi	r2,r17,32752
8111a5a0:	00dffc34 	movhi	r3,32752
8111a5a4:	10c01c26 	beq	r2,r3,8111a618 <_dtoa_r+0xf8>
8111a5a8:	000d883a 	mov	r6,zero
8111a5ac:	000f883a 	mov	r7,zero
8111a5b0:	9009883a 	mov	r4,r18
8111a5b4:	980b883a 	mov	r5,r19
8111a5b8:	1126fac0 	call	81126fac <__eqdf2>
8111a5bc:	10002b1e 	bne	r2,zero,8111a66c <_dtoa_r+0x14c>
8111a5c0:	d9c02317 	ldw	r7,140(sp)
8111a5c4:	00800044 	movi	r2,1
8111a5c8:	38800015 	stw	r2,0(r7)
8111a5cc:	d8802517 	ldw	r2,148(sp)
8111a5d0:	10019e26 	beq	r2,zero,8111ac4c <_dtoa_r+0x72c>
8111a5d4:	d8c02517 	ldw	r3,148(sp)
8111a5d8:	00a04534 	movhi	r2,33044
8111a5dc:	10bdb044 	addi	r2,r2,-2367
8111a5e0:	18800015 	stw	r2,0(r3)
8111a5e4:	10bfffc4 	addi	r2,r2,-1
8111a5e8:	dfc02117 	ldw	ra,132(sp)
8111a5ec:	df002017 	ldw	fp,128(sp)
8111a5f0:	ddc01f17 	ldw	r23,124(sp)
8111a5f4:	dd801e17 	ldw	r22,120(sp)
8111a5f8:	dd401d17 	ldw	r21,116(sp)
8111a5fc:	dd001c17 	ldw	r20,112(sp)
8111a600:	dcc01b17 	ldw	r19,108(sp)
8111a604:	dc801a17 	ldw	r18,104(sp)
8111a608:	dc401917 	ldw	r17,100(sp)
8111a60c:	dc001817 	ldw	r16,96(sp)
8111a610:	dec02204 	addi	sp,sp,136
8111a614:	f800283a 	ret
8111a618:	d8c02317 	ldw	r3,140(sp)
8111a61c:	0089c3c4 	movi	r2,9999
8111a620:	18800015 	stw	r2,0(r3)
8111a624:	90017726 	beq	r18,zero,8111ac04 <_dtoa_r+0x6e4>
8111a628:	00a04534 	movhi	r2,33044
8111a62c:	10bdce04 	addi	r2,r2,-2248
8111a630:	d9002517 	ldw	r4,148(sp)
8111a634:	203fec26 	beq	r4,zero,8111a5e8 <__reset+0xfb0fa5e8>
8111a638:	10c000c7 	ldb	r3,3(r2)
8111a63c:	1801781e 	bne	r3,zero,8111ac20 <_dtoa_r+0x700>
8111a640:	10c000c4 	addi	r3,r2,3
8111a644:	d9802517 	ldw	r6,148(sp)
8111a648:	30c00015 	stw	r3,0(r6)
8111a64c:	003fe606 	br	8111a5e8 <__reset+0xfb0fa5e8>
8111a650:	04e00034 	movhi	r19,32768
8111a654:	9cffffc4 	addi	r19,r19,-1
8111a658:	00800044 	movi	r2,1
8111a65c:	8ce6703a 	and	r19,r17,r19
8111a660:	80800015 	stw	r2,0(r16)
8111a664:	9823883a 	mov	r17,r19
8111a668:	003fcc06 	br	8111a59c <__reset+0xfb0fa59c>
8111a66c:	d8800204 	addi	r2,sp,8
8111a670:	d8800015 	stw	r2,0(sp)
8111a674:	d9c00104 	addi	r7,sp,4
8111a678:	900b883a 	mov	r5,r18
8111a67c:	980d883a 	mov	r6,r19
8111a680:	e009883a 	mov	r4,fp
8111a684:	8820d53a 	srli	r16,r17,20
8111a688:	111e3140 	call	8111e314 <__d2b>
8111a68c:	d8800915 	stw	r2,36(sp)
8111a690:	8001651e 	bne	r16,zero,8111ac28 <_dtoa_r+0x708>
8111a694:	dd800217 	ldw	r22,8(sp)
8111a698:	dc000117 	ldw	r16,4(sp)
8111a69c:	00800804 	movi	r2,32
8111a6a0:	b421883a 	add	r16,r22,r16
8111a6a4:	80c10c84 	addi	r3,r16,1074
8111a6a8:	10c2d10e 	bge	r2,r3,8111b1f0 <_dtoa_r+0xcd0>
8111a6ac:	00801004 	movi	r2,64
8111a6b0:	81010484 	addi	r4,r16,1042
8111a6b4:	10c7c83a 	sub	r3,r2,r3
8111a6b8:	9108d83a 	srl	r4,r18,r4
8111a6bc:	88e2983a 	sll	r17,r17,r3
8111a6c0:	2448b03a 	or	r4,r4,r17
8111a6c4:	1127c6c0 	call	81127c6c <__floatunsidf>
8111a6c8:	017f8434 	movhi	r5,65040
8111a6cc:	01800044 	movi	r6,1
8111a6d0:	1009883a 	mov	r4,r2
8111a6d4:	194b883a 	add	r5,r3,r5
8111a6d8:	843fffc4 	addi	r16,r16,-1
8111a6dc:	d9801115 	stw	r6,68(sp)
8111a6e0:	000d883a 	mov	r6,zero
8111a6e4:	01cffe34 	movhi	r7,16376
8111a6e8:	11272040 	call	81127204 <__subdf3>
8111a6ec:	0198dbf4 	movhi	r6,25455
8111a6f0:	01cff4f4 	movhi	r7,16339
8111a6f4:	3190d844 	addi	r6,r6,17249
8111a6f8:	39e1e9c4 	addi	r7,r7,-30809
8111a6fc:	1009883a 	mov	r4,r2
8111a700:	180b883a 	mov	r5,r3
8111a704:	1111b400 	call	81111b40 <__muldf3>
8111a708:	01a2d874 	movhi	r6,35681
8111a70c:	01cff1f4 	movhi	r7,16327
8111a710:	31b22cc4 	addi	r6,r6,-14157
8111a714:	39e28a04 	addi	r7,r7,-30168
8111a718:	180b883a 	mov	r5,r3
8111a71c:	1009883a 	mov	r4,r2
8111a720:	1125e080 	call	81125e08 <__adddf3>
8111a724:	8009883a 	mov	r4,r16
8111a728:	1029883a 	mov	r20,r2
8111a72c:	1823883a 	mov	r17,r3
8111a730:	1127b880 	call	81127b88 <__floatsidf>
8111a734:	019427f4 	movhi	r6,20639
8111a738:	01cff4f4 	movhi	r7,16339
8111a73c:	319e7ec4 	addi	r6,r6,31227
8111a740:	39d104c4 	addi	r7,r7,17427
8111a744:	1009883a 	mov	r4,r2
8111a748:	180b883a 	mov	r5,r3
8111a74c:	1111b400 	call	81111b40 <__muldf3>
8111a750:	100d883a 	mov	r6,r2
8111a754:	180f883a 	mov	r7,r3
8111a758:	a009883a 	mov	r4,r20
8111a75c:	880b883a 	mov	r5,r17
8111a760:	1125e080 	call	81125e08 <__adddf3>
8111a764:	1009883a 	mov	r4,r2
8111a768:	180b883a 	mov	r5,r3
8111a76c:	1029883a 	mov	r20,r2
8111a770:	1823883a 	mov	r17,r3
8111a774:	1127b080 	call	81127b08 <__fixdfsi>
8111a778:	000d883a 	mov	r6,zero
8111a77c:	000f883a 	mov	r7,zero
8111a780:	a009883a 	mov	r4,r20
8111a784:	880b883a 	mov	r5,r17
8111a788:	d8800515 	stw	r2,20(sp)
8111a78c:	11271100 	call	81127110 <__ledf2>
8111a790:	10028716 	blt	r2,zero,8111b1b0 <_dtoa_r+0xc90>
8111a794:	d8c00517 	ldw	r3,20(sp)
8111a798:	00800584 	movi	r2,22
8111a79c:	10c27536 	bltu	r2,r3,8111b174 <_dtoa_r+0xc54>
8111a7a0:	180490fa 	slli	r2,r3,3
8111a7a4:	00e04534 	movhi	r3,33044
8111a7a8:	18fde904 	addi	r3,r3,-2140
8111a7ac:	1885883a 	add	r2,r3,r2
8111a7b0:	11000017 	ldw	r4,0(r2)
8111a7b4:	11400117 	ldw	r5,4(r2)
8111a7b8:	900d883a 	mov	r6,r18
8111a7bc:	980f883a 	mov	r7,r19
8111a7c0:	11270340 	call	81127034 <__gedf2>
8111a7c4:	00828d0e 	bge	zero,r2,8111b1fc <_dtoa_r+0xcdc>
8111a7c8:	d9000517 	ldw	r4,20(sp)
8111a7cc:	d8000e15 	stw	zero,56(sp)
8111a7d0:	213fffc4 	addi	r4,r4,-1
8111a7d4:	d9000515 	stw	r4,20(sp)
8111a7d8:	b42dc83a 	sub	r22,r22,r16
8111a7dc:	b5bfffc4 	addi	r22,r22,-1
8111a7e0:	b0026f16 	blt	r22,zero,8111b1a0 <_dtoa_r+0xc80>
8111a7e4:	d8000815 	stw	zero,32(sp)
8111a7e8:	d9c00517 	ldw	r7,20(sp)
8111a7ec:	38026416 	blt	r7,zero,8111b180 <_dtoa_r+0xc60>
8111a7f0:	b1ed883a 	add	r22,r22,r7
8111a7f4:	d9c00d15 	stw	r7,52(sp)
8111a7f8:	d8000a15 	stw	zero,40(sp)
8111a7fc:	d9800317 	ldw	r6,12(sp)
8111a800:	00800244 	movi	r2,9
8111a804:	11811436 	bltu	r2,r6,8111ac58 <_dtoa_r+0x738>
8111a808:	00800144 	movi	r2,5
8111a80c:	1184e10e 	bge	r2,r6,8111bb94 <_dtoa_r+0x1674>
8111a810:	31bfff04 	addi	r6,r6,-4
8111a814:	d9800315 	stw	r6,12(sp)
8111a818:	0023883a 	mov	r17,zero
8111a81c:	d9800317 	ldw	r6,12(sp)
8111a820:	008000c4 	movi	r2,3
8111a824:	30836726 	beq	r6,r2,8111b5c4 <_dtoa_r+0x10a4>
8111a828:	1183410e 	bge	r2,r6,8111b530 <_dtoa_r+0x1010>
8111a82c:	d9c00317 	ldw	r7,12(sp)
8111a830:	00800104 	movi	r2,4
8111a834:	38827c26 	beq	r7,r2,8111b228 <_dtoa_r+0xd08>
8111a838:	00800144 	movi	r2,5
8111a83c:	3884c41e 	bne	r7,r2,8111bb50 <_dtoa_r+0x1630>
8111a840:	00800044 	movi	r2,1
8111a844:	d8800b15 	stw	r2,44(sp)
8111a848:	d8c00517 	ldw	r3,20(sp)
8111a84c:	d9002217 	ldw	r4,136(sp)
8111a850:	1907883a 	add	r3,r3,r4
8111a854:	19800044 	addi	r6,r3,1
8111a858:	d8c00c15 	stw	r3,48(sp)
8111a85c:	d9800615 	stw	r6,24(sp)
8111a860:	0183a40e 	bge	zero,r6,8111b6f4 <_dtoa_r+0x11d4>
8111a864:	d9800617 	ldw	r6,24(sp)
8111a868:	3021883a 	mov	r16,r6
8111a86c:	e0001115 	stw	zero,68(fp)
8111a870:	008005c4 	movi	r2,23
8111a874:	1184c92e 	bgeu	r2,r6,8111bb9c <_dtoa_r+0x167c>
8111a878:	00c00044 	movi	r3,1
8111a87c:	00800104 	movi	r2,4
8111a880:	1085883a 	add	r2,r2,r2
8111a884:	11000504 	addi	r4,r2,20
8111a888:	180b883a 	mov	r5,r3
8111a88c:	18c00044 	addi	r3,r3,1
8111a890:	313ffb2e 	bgeu	r6,r4,8111a880 <__reset+0xfb0fa880>
8111a894:	e1401115 	stw	r5,68(fp)
8111a898:	e009883a 	mov	r4,fp
8111a89c:	111d6380 	call	8111d638 <_Balloc>
8111a8a0:	d8800715 	stw	r2,28(sp)
8111a8a4:	e0801015 	stw	r2,64(fp)
8111a8a8:	00800384 	movi	r2,14
8111a8ac:	1400f736 	bltu	r2,r16,8111ac8c <_dtoa_r+0x76c>
8111a8b0:	8800f626 	beq	r17,zero,8111ac8c <_dtoa_r+0x76c>
8111a8b4:	d9c00517 	ldw	r7,20(sp)
8111a8b8:	01c39a0e 	bge	zero,r7,8111b724 <_dtoa_r+0x1204>
8111a8bc:	388003cc 	andi	r2,r7,15
8111a8c0:	100490fa 	slli	r2,r2,3
8111a8c4:	382bd13a 	srai	r21,r7,4
8111a8c8:	00e04534 	movhi	r3,33044
8111a8cc:	18fde904 	addi	r3,r3,-2140
8111a8d0:	1885883a 	add	r2,r3,r2
8111a8d4:	a8c0040c 	andi	r3,r21,16
8111a8d8:	12400017 	ldw	r9,0(r2)
8111a8dc:	12000117 	ldw	r8,4(r2)
8111a8e0:	18037926 	beq	r3,zero,8111b6c8 <_dtoa_r+0x11a8>
8111a8e4:	00a04534 	movhi	r2,33044
8111a8e8:	10bddf04 	addi	r2,r2,-2180
8111a8ec:	11800817 	ldw	r6,32(r2)
8111a8f0:	11c00917 	ldw	r7,36(r2)
8111a8f4:	9009883a 	mov	r4,r18
8111a8f8:	980b883a 	mov	r5,r19
8111a8fc:	da001715 	stw	r8,92(sp)
8111a900:	da401615 	stw	r9,88(sp)
8111a904:	11266bc0 	call	811266bc <__divdf3>
8111a908:	da001717 	ldw	r8,92(sp)
8111a90c:	da401617 	ldw	r9,88(sp)
8111a910:	ad4003cc 	andi	r21,r21,15
8111a914:	040000c4 	movi	r16,3
8111a918:	1023883a 	mov	r17,r2
8111a91c:	1829883a 	mov	r20,r3
8111a920:	a8001126 	beq	r21,zero,8111a968 <_dtoa_r+0x448>
8111a924:	05e04534 	movhi	r23,33044
8111a928:	bdfddf04 	addi	r23,r23,-2180
8111a92c:	4805883a 	mov	r2,r9
8111a930:	4007883a 	mov	r3,r8
8111a934:	a980004c 	andi	r6,r21,1
8111a938:	1009883a 	mov	r4,r2
8111a93c:	a82bd07a 	srai	r21,r21,1
8111a940:	180b883a 	mov	r5,r3
8111a944:	30000426 	beq	r6,zero,8111a958 <_dtoa_r+0x438>
8111a948:	b9800017 	ldw	r6,0(r23)
8111a94c:	b9c00117 	ldw	r7,4(r23)
8111a950:	84000044 	addi	r16,r16,1
8111a954:	1111b400 	call	81111b40 <__muldf3>
8111a958:	bdc00204 	addi	r23,r23,8
8111a95c:	a83ff51e 	bne	r21,zero,8111a934 <__reset+0xfb0fa934>
8111a960:	1013883a 	mov	r9,r2
8111a964:	1811883a 	mov	r8,r3
8111a968:	480d883a 	mov	r6,r9
8111a96c:	400f883a 	mov	r7,r8
8111a970:	8809883a 	mov	r4,r17
8111a974:	a00b883a 	mov	r5,r20
8111a978:	11266bc0 	call	811266bc <__divdf3>
8111a97c:	d8800f15 	stw	r2,60(sp)
8111a980:	d8c01015 	stw	r3,64(sp)
8111a984:	d8c00e17 	ldw	r3,56(sp)
8111a988:	18000626 	beq	r3,zero,8111a9a4 <_dtoa_r+0x484>
8111a98c:	d9000f17 	ldw	r4,60(sp)
8111a990:	d9401017 	ldw	r5,64(sp)
8111a994:	000d883a 	mov	r6,zero
8111a998:	01cffc34 	movhi	r7,16368
8111a99c:	11271100 	call	81127110 <__ledf2>
8111a9a0:	10040b16 	blt	r2,zero,8111b9d0 <_dtoa_r+0x14b0>
8111a9a4:	8009883a 	mov	r4,r16
8111a9a8:	1127b880 	call	81127b88 <__floatsidf>
8111a9ac:	d9800f17 	ldw	r6,60(sp)
8111a9b0:	d9c01017 	ldw	r7,64(sp)
8111a9b4:	1009883a 	mov	r4,r2
8111a9b8:	180b883a 	mov	r5,r3
8111a9bc:	1111b400 	call	81111b40 <__muldf3>
8111a9c0:	000d883a 	mov	r6,zero
8111a9c4:	01d00734 	movhi	r7,16412
8111a9c8:	1009883a 	mov	r4,r2
8111a9cc:	180b883a 	mov	r5,r3
8111a9d0:	1125e080 	call	81125e08 <__adddf3>
8111a9d4:	1021883a 	mov	r16,r2
8111a9d8:	d8800617 	ldw	r2,24(sp)
8111a9dc:	047f3034 	movhi	r17,64704
8111a9e0:	1c63883a 	add	r17,r3,r17
8111a9e4:	10031826 	beq	r2,zero,8111b648 <_dtoa_r+0x1128>
8111a9e8:	d8c00517 	ldw	r3,20(sp)
8111a9ec:	db000617 	ldw	r12,24(sp)
8111a9f0:	d8c01315 	stw	r3,76(sp)
8111a9f4:	d9000b17 	ldw	r4,44(sp)
8111a9f8:	20038f26 	beq	r4,zero,8111b838 <_dtoa_r+0x1318>
8111a9fc:	60bfffc4 	addi	r2,r12,-1
8111aa00:	100490fa 	slli	r2,r2,3
8111aa04:	00e04534 	movhi	r3,33044
8111aa08:	18fde904 	addi	r3,r3,-2140
8111aa0c:	1885883a 	add	r2,r3,r2
8111aa10:	11800017 	ldw	r6,0(r2)
8111aa14:	11c00117 	ldw	r7,4(r2)
8111aa18:	d8800717 	ldw	r2,28(sp)
8111aa1c:	0009883a 	mov	r4,zero
8111aa20:	014ff834 	movhi	r5,16352
8111aa24:	db001615 	stw	r12,88(sp)
8111aa28:	15c00044 	addi	r23,r2,1
8111aa2c:	11266bc0 	call	811266bc <__divdf3>
8111aa30:	800d883a 	mov	r6,r16
8111aa34:	880f883a 	mov	r7,r17
8111aa38:	1009883a 	mov	r4,r2
8111aa3c:	180b883a 	mov	r5,r3
8111aa40:	11272040 	call	81127204 <__subdf3>
8111aa44:	d9401017 	ldw	r5,64(sp)
8111aa48:	d9000f17 	ldw	r4,60(sp)
8111aa4c:	102b883a 	mov	r21,r2
8111aa50:	d8c01215 	stw	r3,72(sp)
8111aa54:	1127b080 	call	81127b08 <__fixdfsi>
8111aa58:	1009883a 	mov	r4,r2
8111aa5c:	1029883a 	mov	r20,r2
8111aa60:	1127b880 	call	81127b88 <__floatsidf>
8111aa64:	d9000f17 	ldw	r4,60(sp)
8111aa68:	d9401017 	ldw	r5,64(sp)
8111aa6c:	100d883a 	mov	r6,r2
8111aa70:	180f883a 	mov	r7,r3
8111aa74:	11272040 	call	81127204 <__subdf3>
8111aa78:	1823883a 	mov	r17,r3
8111aa7c:	d8c00717 	ldw	r3,28(sp)
8111aa80:	d9401217 	ldw	r5,72(sp)
8111aa84:	a2000c04 	addi	r8,r20,48
8111aa88:	1021883a 	mov	r16,r2
8111aa8c:	1a000005 	stb	r8,0(r3)
8111aa90:	800d883a 	mov	r6,r16
8111aa94:	880f883a 	mov	r7,r17
8111aa98:	a809883a 	mov	r4,r21
8111aa9c:	4029883a 	mov	r20,r8
8111aaa0:	11270340 	call	81127034 <__gedf2>
8111aaa4:	00841d16 	blt	zero,r2,8111bb1c <_dtoa_r+0x15fc>
8111aaa8:	800d883a 	mov	r6,r16
8111aaac:	880f883a 	mov	r7,r17
8111aab0:	0009883a 	mov	r4,zero
8111aab4:	014ffc34 	movhi	r5,16368
8111aab8:	11272040 	call	81127204 <__subdf3>
8111aabc:	d9401217 	ldw	r5,72(sp)
8111aac0:	100d883a 	mov	r6,r2
8111aac4:	180f883a 	mov	r7,r3
8111aac8:	a809883a 	mov	r4,r21
8111aacc:	11270340 	call	81127034 <__gedf2>
8111aad0:	db001617 	ldw	r12,88(sp)
8111aad4:	00840e16 	blt	zero,r2,8111bb10 <_dtoa_r+0x15f0>
8111aad8:	00800044 	movi	r2,1
8111aadc:	13006b0e 	bge	r2,r12,8111ac8c <_dtoa_r+0x76c>
8111aae0:	d9000717 	ldw	r4,28(sp)
8111aae4:	dd800f15 	stw	r22,60(sp)
8111aae8:	dcc01015 	stw	r19,64(sp)
8111aaec:	2319883a 	add	r12,r4,r12
8111aaf0:	dcc01217 	ldw	r19,72(sp)
8111aaf4:	602d883a 	mov	r22,r12
8111aaf8:	dc801215 	stw	r18,72(sp)
8111aafc:	b825883a 	mov	r18,r23
8111ab00:	00000906 	br	8111ab28 <_dtoa_r+0x608>
8111ab04:	11272040 	call	81127204 <__subdf3>
8111ab08:	a80d883a 	mov	r6,r21
8111ab0c:	980f883a 	mov	r7,r19
8111ab10:	1009883a 	mov	r4,r2
8111ab14:	180b883a 	mov	r5,r3
8111ab18:	11271100 	call	81127110 <__ledf2>
8111ab1c:	1003e816 	blt	r2,zero,8111bac0 <_dtoa_r+0x15a0>
8111ab20:	b825883a 	mov	r18,r23
8111ab24:	bd83e926 	beq	r23,r22,8111bacc <_dtoa_r+0x15ac>
8111ab28:	a809883a 	mov	r4,r21
8111ab2c:	980b883a 	mov	r5,r19
8111ab30:	000d883a 	mov	r6,zero
8111ab34:	01d00934 	movhi	r7,16420
8111ab38:	1111b400 	call	81111b40 <__muldf3>
8111ab3c:	000d883a 	mov	r6,zero
8111ab40:	01d00934 	movhi	r7,16420
8111ab44:	8009883a 	mov	r4,r16
8111ab48:	880b883a 	mov	r5,r17
8111ab4c:	102b883a 	mov	r21,r2
8111ab50:	1827883a 	mov	r19,r3
8111ab54:	1111b400 	call	81111b40 <__muldf3>
8111ab58:	180b883a 	mov	r5,r3
8111ab5c:	1009883a 	mov	r4,r2
8111ab60:	1821883a 	mov	r16,r3
8111ab64:	1023883a 	mov	r17,r2
8111ab68:	1127b080 	call	81127b08 <__fixdfsi>
8111ab6c:	1009883a 	mov	r4,r2
8111ab70:	1029883a 	mov	r20,r2
8111ab74:	1127b880 	call	81127b88 <__floatsidf>
8111ab78:	8809883a 	mov	r4,r17
8111ab7c:	800b883a 	mov	r5,r16
8111ab80:	100d883a 	mov	r6,r2
8111ab84:	180f883a 	mov	r7,r3
8111ab88:	11272040 	call	81127204 <__subdf3>
8111ab8c:	a5000c04 	addi	r20,r20,48
8111ab90:	a80d883a 	mov	r6,r21
8111ab94:	980f883a 	mov	r7,r19
8111ab98:	1009883a 	mov	r4,r2
8111ab9c:	180b883a 	mov	r5,r3
8111aba0:	95000005 	stb	r20,0(r18)
8111aba4:	1021883a 	mov	r16,r2
8111aba8:	1823883a 	mov	r17,r3
8111abac:	11271100 	call	81127110 <__ledf2>
8111abb0:	bdc00044 	addi	r23,r23,1
8111abb4:	800d883a 	mov	r6,r16
8111abb8:	880f883a 	mov	r7,r17
8111abbc:	0009883a 	mov	r4,zero
8111abc0:	014ffc34 	movhi	r5,16368
8111abc4:	103fcf0e 	bge	r2,zero,8111ab04 <__reset+0xfb0fab04>
8111abc8:	d8c01317 	ldw	r3,76(sp)
8111abcc:	d8c00515 	stw	r3,20(sp)
8111abd0:	d9400917 	ldw	r5,36(sp)
8111abd4:	e009883a 	mov	r4,fp
8111abd8:	111d6e80 	call	8111d6e8 <_Bfree>
8111abdc:	d9000517 	ldw	r4,20(sp)
8111abe0:	d9802317 	ldw	r6,140(sp)
8111abe4:	d9c02517 	ldw	r7,148(sp)
8111abe8:	b8000005 	stb	zero,0(r23)
8111abec:	20800044 	addi	r2,r4,1
8111abf0:	30800015 	stw	r2,0(r6)
8111abf4:	3802aa26 	beq	r7,zero,8111b6a0 <_dtoa_r+0x1180>
8111abf8:	3dc00015 	stw	r23,0(r7)
8111abfc:	d8800717 	ldw	r2,28(sp)
8111ac00:	003e7906 	br	8111a5e8 <__reset+0xfb0fa5e8>
8111ac04:	00800434 	movhi	r2,16
8111ac08:	10bfffc4 	addi	r2,r2,-1
8111ac0c:	88a2703a 	and	r17,r17,r2
8111ac10:	883e851e 	bne	r17,zero,8111a628 <__reset+0xfb0fa628>
8111ac14:	00a04534 	movhi	r2,33044
8111ac18:	10bdcb04 	addi	r2,r2,-2260
8111ac1c:	003e8406 	br	8111a630 <__reset+0xfb0fa630>
8111ac20:	10c00204 	addi	r3,r2,8
8111ac24:	003e8706 	br	8111a644 <__reset+0xfb0fa644>
8111ac28:	01400434 	movhi	r5,16
8111ac2c:	297fffc4 	addi	r5,r5,-1
8111ac30:	994a703a 	and	r5,r19,r5
8111ac34:	9009883a 	mov	r4,r18
8111ac38:	843f0044 	addi	r16,r16,-1023
8111ac3c:	294ffc34 	orhi	r5,r5,16368
8111ac40:	dd800217 	ldw	r22,8(sp)
8111ac44:	d8001115 	stw	zero,68(sp)
8111ac48:	003ea506 	br	8111a6e0 <__reset+0xfb0fa6e0>
8111ac4c:	00a04534 	movhi	r2,33044
8111ac50:	10bdb004 	addi	r2,r2,-2368
8111ac54:	003e6406 	br	8111a5e8 <__reset+0xfb0fa5e8>
8111ac58:	e0001115 	stw	zero,68(fp)
8111ac5c:	000b883a 	mov	r5,zero
8111ac60:	e009883a 	mov	r4,fp
8111ac64:	111d6380 	call	8111d638 <_Balloc>
8111ac68:	01bfffc4 	movi	r6,-1
8111ac6c:	01c00044 	movi	r7,1
8111ac70:	d8800715 	stw	r2,28(sp)
8111ac74:	d9800c15 	stw	r6,48(sp)
8111ac78:	e0801015 	stw	r2,64(fp)
8111ac7c:	d8000315 	stw	zero,12(sp)
8111ac80:	d9c00b15 	stw	r7,44(sp)
8111ac84:	d9800615 	stw	r6,24(sp)
8111ac88:	d8002215 	stw	zero,136(sp)
8111ac8c:	d8800117 	ldw	r2,4(sp)
8111ac90:	10008916 	blt	r2,zero,8111aeb8 <_dtoa_r+0x998>
8111ac94:	d9000517 	ldw	r4,20(sp)
8111ac98:	00c00384 	movi	r3,14
8111ac9c:	19008616 	blt	r3,r4,8111aeb8 <_dtoa_r+0x998>
8111aca0:	200490fa 	slli	r2,r4,3
8111aca4:	00e04534 	movhi	r3,33044
8111aca8:	d9802217 	ldw	r6,136(sp)
8111acac:	18fde904 	addi	r3,r3,-2140
8111acb0:	1885883a 	add	r2,r3,r2
8111acb4:	14000017 	ldw	r16,0(r2)
8111acb8:	14400117 	ldw	r17,4(r2)
8111acbc:	30016316 	blt	r6,zero,8111b24c <_dtoa_r+0xd2c>
8111acc0:	800d883a 	mov	r6,r16
8111acc4:	880f883a 	mov	r7,r17
8111acc8:	9009883a 	mov	r4,r18
8111accc:	980b883a 	mov	r5,r19
8111acd0:	11266bc0 	call	811266bc <__divdf3>
8111acd4:	180b883a 	mov	r5,r3
8111acd8:	1009883a 	mov	r4,r2
8111acdc:	1127b080 	call	81127b08 <__fixdfsi>
8111ace0:	1009883a 	mov	r4,r2
8111ace4:	102b883a 	mov	r21,r2
8111ace8:	1127b880 	call	81127b88 <__floatsidf>
8111acec:	800d883a 	mov	r6,r16
8111acf0:	880f883a 	mov	r7,r17
8111acf4:	1009883a 	mov	r4,r2
8111acf8:	180b883a 	mov	r5,r3
8111acfc:	1111b400 	call	81111b40 <__muldf3>
8111ad00:	100d883a 	mov	r6,r2
8111ad04:	180f883a 	mov	r7,r3
8111ad08:	9009883a 	mov	r4,r18
8111ad0c:	980b883a 	mov	r5,r19
8111ad10:	11272040 	call	81127204 <__subdf3>
8111ad14:	d9c00717 	ldw	r7,28(sp)
8111ad18:	1009883a 	mov	r4,r2
8111ad1c:	a8800c04 	addi	r2,r21,48
8111ad20:	38800005 	stb	r2,0(r7)
8111ad24:	3dc00044 	addi	r23,r7,1
8111ad28:	d9c00617 	ldw	r7,24(sp)
8111ad2c:	01800044 	movi	r6,1
8111ad30:	180b883a 	mov	r5,r3
8111ad34:	2005883a 	mov	r2,r4
8111ad38:	39803826 	beq	r7,r6,8111ae1c <_dtoa_r+0x8fc>
8111ad3c:	000d883a 	mov	r6,zero
8111ad40:	01d00934 	movhi	r7,16420
8111ad44:	1111b400 	call	81111b40 <__muldf3>
8111ad48:	000d883a 	mov	r6,zero
8111ad4c:	000f883a 	mov	r7,zero
8111ad50:	1009883a 	mov	r4,r2
8111ad54:	180b883a 	mov	r5,r3
8111ad58:	1025883a 	mov	r18,r2
8111ad5c:	1827883a 	mov	r19,r3
8111ad60:	1126fac0 	call	81126fac <__eqdf2>
8111ad64:	103f9a26 	beq	r2,zero,8111abd0 <__reset+0xfb0fabd0>
8111ad68:	d9c00617 	ldw	r7,24(sp)
8111ad6c:	d8c00717 	ldw	r3,28(sp)
8111ad70:	b829883a 	mov	r20,r23
8111ad74:	38bfffc4 	addi	r2,r7,-1
8111ad78:	18ad883a 	add	r22,r3,r2
8111ad7c:	00000a06 	br	8111ada8 <_dtoa_r+0x888>
8111ad80:	1111b400 	call	81111b40 <__muldf3>
8111ad84:	000d883a 	mov	r6,zero
8111ad88:	000f883a 	mov	r7,zero
8111ad8c:	1009883a 	mov	r4,r2
8111ad90:	180b883a 	mov	r5,r3
8111ad94:	1025883a 	mov	r18,r2
8111ad98:	1827883a 	mov	r19,r3
8111ad9c:	b829883a 	mov	r20,r23
8111ada0:	1126fac0 	call	81126fac <__eqdf2>
8111ada4:	103f8a26 	beq	r2,zero,8111abd0 <__reset+0xfb0fabd0>
8111ada8:	800d883a 	mov	r6,r16
8111adac:	880f883a 	mov	r7,r17
8111adb0:	9009883a 	mov	r4,r18
8111adb4:	980b883a 	mov	r5,r19
8111adb8:	11266bc0 	call	811266bc <__divdf3>
8111adbc:	180b883a 	mov	r5,r3
8111adc0:	1009883a 	mov	r4,r2
8111adc4:	1127b080 	call	81127b08 <__fixdfsi>
8111adc8:	1009883a 	mov	r4,r2
8111adcc:	102b883a 	mov	r21,r2
8111add0:	1127b880 	call	81127b88 <__floatsidf>
8111add4:	800d883a 	mov	r6,r16
8111add8:	880f883a 	mov	r7,r17
8111addc:	1009883a 	mov	r4,r2
8111ade0:	180b883a 	mov	r5,r3
8111ade4:	1111b400 	call	81111b40 <__muldf3>
8111ade8:	100d883a 	mov	r6,r2
8111adec:	180f883a 	mov	r7,r3
8111adf0:	9009883a 	mov	r4,r18
8111adf4:	980b883a 	mov	r5,r19
8111adf8:	11272040 	call	81127204 <__subdf3>
8111adfc:	aa000c04 	addi	r8,r21,48
8111ae00:	a2000005 	stb	r8,0(r20)
8111ae04:	000d883a 	mov	r6,zero
8111ae08:	01d00934 	movhi	r7,16420
8111ae0c:	1009883a 	mov	r4,r2
8111ae10:	180b883a 	mov	r5,r3
8111ae14:	a5c00044 	addi	r23,r20,1
8111ae18:	b53fd91e 	bne	r22,r20,8111ad80 <__reset+0xfb0fad80>
8111ae1c:	100d883a 	mov	r6,r2
8111ae20:	180f883a 	mov	r7,r3
8111ae24:	1009883a 	mov	r4,r2
8111ae28:	180b883a 	mov	r5,r3
8111ae2c:	1125e080 	call	81125e08 <__adddf3>
8111ae30:	100d883a 	mov	r6,r2
8111ae34:	180f883a 	mov	r7,r3
8111ae38:	8009883a 	mov	r4,r16
8111ae3c:	880b883a 	mov	r5,r17
8111ae40:	1027883a 	mov	r19,r2
8111ae44:	1825883a 	mov	r18,r3
8111ae48:	11271100 	call	81127110 <__ledf2>
8111ae4c:	10000816 	blt	r2,zero,8111ae70 <_dtoa_r+0x950>
8111ae50:	980d883a 	mov	r6,r19
8111ae54:	900f883a 	mov	r7,r18
8111ae58:	8009883a 	mov	r4,r16
8111ae5c:	880b883a 	mov	r5,r17
8111ae60:	1126fac0 	call	81126fac <__eqdf2>
8111ae64:	103f5a1e 	bne	r2,zero,8111abd0 <__reset+0xfb0fabd0>
8111ae68:	ad40004c 	andi	r21,r21,1
8111ae6c:	a83f5826 	beq	r21,zero,8111abd0 <__reset+0xfb0fabd0>
8111ae70:	bd3fffc3 	ldbu	r20,-1(r23)
8111ae74:	b8bfffc4 	addi	r2,r23,-1
8111ae78:	1007883a 	mov	r3,r2
8111ae7c:	01400e44 	movi	r5,57
8111ae80:	d9800717 	ldw	r6,28(sp)
8111ae84:	00000506 	br	8111ae9c <_dtoa_r+0x97c>
8111ae88:	18ffffc4 	addi	r3,r3,-1
8111ae8c:	11824726 	beq	r2,r6,8111b7ac <_dtoa_r+0x128c>
8111ae90:	1d000003 	ldbu	r20,0(r3)
8111ae94:	102f883a 	mov	r23,r2
8111ae98:	10bfffc4 	addi	r2,r2,-1
8111ae9c:	a1003fcc 	andi	r4,r20,255
8111aea0:	2100201c 	xori	r4,r4,128
8111aea4:	213fe004 	addi	r4,r4,-128
8111aea8:	217ff726 	beq	r4,r5,8111ae88 <__reset+0xfb0fae88>
8111aeac:	a2000044 	addi	r8,r20,1
8111aeb0:	12000005 	stb	r8,0(r2)
8111aeb4:	003f4606 	br	8111abd0 <__reset+0xfb0fabd0>
8111aeb8:	d9000b17 	ldw	r4,44(sp)
8111aebc:	2000c826 	beq	r4,zero,8111b1e0 <_dtoa_r+0xcc0>
8111aec0:	d9800317 	ldw	r6,12(sp)
8111aec4:	00c00044 	movi	r3,1
8111aec8:	1980f90e 	bge	r3,r6,8111b2b0 <_dtoa_r+0xd90>
8111aecc:	d8800617 	ldw	r2,24(sp)
8111aed0:	d8c00a17 	ldw	r3,40(sp)
8111aed4:	157fffc4 	addi	r21,r2,-1
8111aed8:	1d41f316 	blt	r3,r21,8111b6a8 <_dtoa_r+0x1188>
8111aedc:	1d6bc83a 	sub	r21,r3,r21
8111aee0:	d9c00617 	ldw	r7,24(sp)
8111aee4:	3802aa16 	blt	r7,zero,8111b990 <_dtoa_r+0x1470>
8111aee8:	dd000817 	ldw	r20,32(sp)
8111aeec:	d8800617 	ldw	r2,24(sp)
8111aef0:	d8c00817 	ldw	r3,32(sp)
8111aef4:	01400044 	movi	r5,1
8111aef8:	e009883a 	mov	r4,fp
8111aefc:	1887883a 	add	r3,r3,r2
8111af00:	d8c00815 	stw	r3,32(sp)
8111af04:	b0ad883a 	add	r22,r22,r2
8111af08:	111da5c0 	call	8111da5c <__i2b>
8111af0c:	1023883a 	mov	r17,r2
8111af10:	a0000826 	beq	r20,zero,8111af34 <_dtoa_r+0xa14>
8111af14:	0580070e 	bge	zero,r22,8111af34 <_dtoa_r+0xa14>
8111af18:	a005883a 	mov	r2,r20
8111af1c:	b500b916 	blt	r22,r20,8111b204 <_dtoa_r+0xce4>
8111af20:	d9000817 	ldw	r4,32(sp)
8111af24:	a0a9c83a 	sub	r20,r20,r2
8111af28:	b0adc83a 	sub	r22,r22,r2
8111af2c:	2089c83a 	sub	r4,r4,r2
8111af30:	d9000815 	stw	r4,32(sp)
8111af34:	d9800a17 	ldw	r6,40(sp)
8111af38:	0181810e 	bge	zero,r6,8111b540 <_dtoa_r+0x1020>
8111af3c:	d9c00b17 	ldw	r7,44(sp)
8111af40:	3800b326 	beq	r7,zero,8111b210 <_dtoa_r+0xcf0>
8111af44:	a800b226 	beq	r21,zero,8111b210 <_dtoa_r+0xcf0>
8111af48:	880b883a 	mov	r5,r17
8111af4c:	a80d883a 	mov	r6,r21
8111af50:	e009883a 	mov	r4,fp
8111af54:	111dca00 	call	8111dca0 <__pow5mult>
8111af58:	d9800917 	ldw	r6,36(sp)
8111af5c:	100b883a 	mov	r5,r2
8111af60:	e009883a 	mov	r4,fp
8111af64:	1023883a 	mov	r17,r2
8111af68:	111daa00 	call	8111daa0 <__multiply>
8111af6c:	1021883a 	mov	r16,r2
8111af70:	d8800a17 	ldw	r2,40(sp)
8111af74:	d9400917 	ldw	r5,36(sp)
8111af78:	e009883a 	mov	r4,fp
8111af7c:	1545c83a 	sub	r2,r2,r21
8111af80:	d8800a15 	stw	r2,40(sp)
8111af84:	111d6e80 	call	8111d6e8 <_Bfree>
8111af88:	d8c00a17 	ldw	r3,40(sp)
8111af8c:	18009f1e 	bne	r3,zero,8111b20c <_dtoa_r+0xcec>
8111af90:	05c00044 	movi	r23,1
8111af94:	e009883a 	mov	r4,fp
8111af98:	b80b883a 	mov	r5,r23
8111af9c:	111da5c0 	call	8111da5c <__i2b>
8111afa0:	d9000d17 	ldw	r4,52(sp)
8111afa4:	102b883a 	mov	r21,r2
8111afa8:	2000ce26 	beq	r4,zero,8111b2e4 <_dtoa_r+0xdc4>
8111afac:	200d883a 	mov	r6,r4
8111afb0:	100b883a 	mov	r5,r2
8111afb4:	e009883a 	mov	r4,fp
8111afb8:	111dca00 	call	8111dca0 <__pow5mult>
8111afbc:	d9800317 	ldw	r6,12(sp)
8111afc0:	102b883a 	mov	r21,r2
8111afc4:	b981810e 	bge	r23,r6,8111b5cc <_dtoa_r+0x10ac>
8111afc8:	0027883a 	mov	r19,zero
8111afcc:	a8800417 	ldw	r2,16(r21)
8111afd0:	05c00804 	movi	r23,32
8111afd4:	10800104 	addi	r2,r2,4
8111afd8:	1085883a 	add	r2,r2,r2
8111afdc:	1085883a 	add	r2,r2,r2
8111afe0:	a885883a 	add	r2,r21,r2
8111afe4:	11000017 	ldw	r4,0(r2)
8111afe8:	111d9440 	call	8111d944 <__hi0bits>
8111afec:	b885c83a 	sub	r2,r23,r2
8111aff0:	1585883a 	add	r2,r2,r22
8111aff4:	108007cc 	andi	r2,r2,31
8111aff8:	1000b326 	beq	r2,zero,8111b2c8 <_dtoa_r+0xda8>
8111affc:	00c00804 	movi	r3,32
8111b000:	1887c83a 	sub	r3,r3,r2
8111b004:	01000104 	movi	r4,4
8111b008:	20c2cd0e 	bge	r4,r3,8111bb40 <_dtoa_r+0x1620>
8111b00c:	00c00704 	movi	r3,28
8111b010:	1885c83a 	sub	r2,r3,r2
8111b014:	d8c00817 	ldw	r3,32(sp)
8111b018:	a0a9883a 	add	r20,r20,r2
8111b01c:	b0ad883a 	add	r22,r22,r2
8111b020:	1887883a 	add	r3,r3,r2
8111b024:	d8c00815 	stw	r3,32(sp)
8111b028:	d9800817 	ldw	r6,32(sp)
8111b02c:	0180040e 	bge	zero,r6,8111b040 <_dtoa_r+0xb20>
8111b030:	800b883a 	mov	r5,r16
8111b034:	e009883a 	mov	r4,fp
8111b038:	111dde80 	call	8111dde8 <__lshift>
8111b03c:	1021883a 	mov	r16,r2
8111b040:	0580050e 	bge	zero,r22,8111b058 <_dtoa_r+0xb38>
8111b044:	a80b883a 	mov	r5,r21
8111b048:	b00d883a 	mov	r6,r22
8111b04c:	e009883a 	mov	r4,fp
8111b050:	111dde80 	call	8111dde8 <__lshift>
8111b054:	102b883a 	mov	r21,r2
8111b058:	d9c00e17 	ldw	r7,56(sp)
8111b05c:	3801211e 	bne	r7,zero,8111b4e4 <_dtoa_r+0xfc4>
8111b060:	d9800617 	ldw	r6,24(sp)
8111b064:	0181380e 	bge	zero,r6,8111b548 <_dtoa_r+0x1028>
8111b068:	d8c00b17 	ldw	r3,44(sp)
8111b06c:	1800ab1e 	bne	r3,zero,8111b31c <_dtoa_r+0xdfc>
8111b070:	dc800717 	ldw	r18,28(sp)
8111b074:	dcc00617 	ldw	r19,24(sp)
8111b078:	9029883a 	mov	r20,r18
8111b07c:	00000206 	br	8111b088 <_dtoa_r+0xb68>
8111b080:	111d7100 	call	8111d710 <__multadd>
8111b084:	1021883a 	mov	r16,r2
8111b088:	a80b883a 	mov	r5,r21
8111b08c:	8009883a 	mov	r4,r16
8111b090:	111a3180 	call	8111a318 <quorem>
8111b094:	10800c04 	addi	r2,r2,48
8111b098:	90800005 	stb	r2,0(r18)
8111b09c:	94800044 	addi	r18,r18,1
8111b0a0:	9507c83a 	sub	r3,r18,r20
8111b0a4:	000f883a 	mov	r7,zero
8111b0a8:	01800284 	movi	r6,10
8111b0ac:	800b883a 	mov	r5,r16
8111b0b0:	e009883a 	mov	r4,fp
8111b0b4:	1cfff216 	blt	r3,r19,8111b080 <__reset+0xfb0fb080>
8111b0b8:	1011883a 	mov	r8,r2
8111b0bc:	d8800617 	ldw	r2,24(sp)
8111b0c0:	0082370e 	bge	zero,r2,8111b9a0 <_dtoa_r+0x1480>
8111b0c4:	d9000717 	ldw	r4,28(sp)
8111b0c8:	0025883a 	mov	r18,zero
8111b0cc:	20af883a 	add	r23,r4,r2
8111b0d0:	01800044 	movi	r6,1
8111b0d4:	800b883a 	mov	r5,r16
8111b0d8:	e009883a 	mov	r4,fp
8111b0dc:	da001715 	stw	r8,92(sp)
8111b0e0:	111dde80 	call	8111dde8 <__lshift>
8111b0e4:	a80b883a 	mov	r5,r21
8111b0e8:	1009883a 	mov	r4,r2
8111b0ec:	d8800915 	stw	r2,36(sp)
8111b0f0:	111df380 	call	8111df38 <__mcmp>
8111b0f4:	da001717 	ldw	r8,92(sp)
8111b0f8:	0081800e 	bge	zero,r2,8111b6fc <_dtoa_r+0x11dc>
8111b0fc:	b93fffc3 	ldbu	r4,-1(r23)
8111b100:	b8bfffc4 	addi	r2,r23,-1
8111b104:	1007883a 	mov	r3,r2
8111b108:	01800e44 	movi	r6,57
8111b10c:	d9c00717 	ldw	r7,28(sp)
8111b110:	00000506 	br	8111b128 <_dtoa_r+0xc08>
8111b114:	18ffffc4 	addi	r3,r3,-1
8111b118:	11c12326 	beq	r2,r7,8111b5a8 <_dtoa_r+0x1088>
8111b11c:	19000003 	ldbu	r4,0(r3)
8111b120:	102f883a 	mov	r23,r2
8111b124:	10bfffc4 	addi	r2,r2,-1
8111b128:	21403fcc 	andi	r5,r4,255
8111b12c:	2940201c 	xori	r5,r5,128
8111b130:	297fe004 	addi	r5,r5,-128
8111b134:	29bff726 	beq	r5,r6,8111b114 <__reset+0xfb0fb114>
8111b138:	21000044 	addi	r4,r4,1
8111b13c:	11000005 	stb	r4,0(r2)
8111b140:	a80b883a 	mov	r5,r21
8111b144:	e009883a 	mov	r4,fp
8111b148:	111d6e80 	call	8111d6e8 <_Bfree>
8111b14c:	883ea026 	beq	r17,zero,8111abd0 <__reset+0xfb0fabd0>
8111b150:	90000426 	beq	r18,zero,8111b164 <_dtoa_r+0xc44>
8111b154:	94400326 	beq	r18,r17,8111b164 <_dtoa_r+0xc44>
8111b158:	900b883a 	mov	r5,r18
8111b15c:	e009883a 	mov	r4,fp
8111b160:	111d6e80 	call	8111d6e8 <_Bfree>
8111b164:	880b883a 	mov	r5,r17
8111b168:	e009883a 	mov	r4,fp
8111b16c:	111d6e80 	call	8111d6e8 <_Bfree>
8111b170:	003e9706 	br	8111abd0 <__reset+0xfb0fabd0>
8111b174:	01800044 	movi	r6,1
8111b178:	d9800e15 	stw	r6,56(sp)
8111b17c:	003d9606 	br	8111a7d8 <__reset+0xfb0fa7d8>
8111b180:	d8800817 	ldw	r2,32(sp)
8111b184:	d8c00517 	ldw	r3,20(sp)
8111b188:	d8000d15 	stw	zero,52(sp)
8111b18c:	10c5c83a 	sub	r2,r2,r3
8111b190:	00c9c83a 	sub	r4,zero,r3
8111b194:	d8800815 	stw	r2,32(sp)
8111b198:	d9000a15 	stw	r4,40(sp)
8111b19c:	003d9706 	br	8111a7fc <__reset+0xfb0fa7fc>
8111b1a0:	05adc83a 	sub	r22,zero,r22
8111b1a4:	dd800815 	stw	r22,32(sp)
8111b1a8:	002d883a 	mov	r22,zero
8111b1ac:	003d8e06 	br	8111a7e8 <__reset+0xfb0fa7e8>
8111b1b0:	d9000517 	ldw	r4,20(sp)
8111b1b4:	1127b880 	call	81127b88 <__floatsidf>
8111b1b8:	100d883a 	mov	r6,r2
8111b1bc:	180f883a 	mov	r7,r3
8111b1c0:	a009883a 	mov	r4,r20
8111b1c4:	880b883a 	mov	r5,r17
8111b1c8:	1126fac0 	call	81126fac <__eqdf2>
8111b1cc:	103d7126 	beq	r2,zero,8111a794 <__reset+0xfb0fa794>
8111b1d0:	d9c00517 	ldw	r7,20(sp)
8111b1d4:	39ffffc4 	addi	r7,r7,-1
8111b1d8:	d9c00515 	stw	r7,20(sp)
8111b1dc:	003d6d06 	br	8111a794 <__reset+0xfb0fa794>
8111b1e0:	dd400a17 	ldw	r21,40(sp)
8111b1e4:	dd000817 	ldw	r20,32(sp)
8111b1e8:	0023883a 	mov	r17,zero
8111b1ec:	003f4806 	br	8111af10 <__reset+0xfb0faf10>
8111b1f0:	10e3c83a 	sub	r17,r2,r3
8111b1f4:	9448983a 	sll	r4,r18,r17
8111b1f8:	003d3206 	br	8111a6c4 <__reset+0xfb0fa6c4>
8111b1fc:	d8000e15 	stw	zero,56(sp)
8111b200:	003d7506 	br	8111a7d8 <__reset+0xfb0fa7d8>
8111b204:	b005883a 	mov	r2,r22
8111b208:	003f4506 	br	8111af20 <__reset+0xfb0faf20>
8111b20c:	dc000915 	stw	r16,36(sp)
8111b210:	d9800a17 	ldw	r6,40(sp)
8111b214:	d9400917 	ldw	r5,36(sp)
8111b218:	e009883a 	mov	r4,fp
8111b21c:	111dca00 	call	8111dca0 <__pow5mult>
8111b220:	1021883a 	mov	r16,r2
8111b224:	003f5a06 	br	8111af90 <__reset+0xfb0faf90>
8111b228:	01c00044 	movi	r7,1
8111b22c:	d9c00b15 	stw	r7,44(sp)
8111b230:	d8802217 	ldw	r2,136(sp)
8111b234:	0081280e 	bge	zero,r2,8111b6d8 <_dtoa_r+0x11b8>
8111b238:	100d883a 	mov	r6,r2
8111b23c:	1021883a 	mov	r16,r2
8111b240:	d8800c15 	stw	r2,48(sp)
8111b244:	d8800615 	stw	r2,24(sp)
8111b248:	003d8806 	br	8111a86c <__reset+0xfb0fa86c>
8111b24c:	d8800617 	ldw	r2,24(sp)
8111b250:	00be9b16 	blt	zero,r2,8111acc0 <__reset+0xfb0facc0>
8111b254:	10010f1e 	bne	r2,zero,8111b694 <_dtoa_r+0x1174>
8111b258:	880b883a 	mov	r5,r17
8111b25c:	000d883a 	mov	r6,zero
8111b260:	01d00534 	movhi	r7,16404
8111b264:	8009883a 	mov	r4,r16
8111b268:	1111b400 	call	81111b40 <__muldf3>
8111b26c:	900d883a 	mov	r6,r18
8111b270:	980f883a 	mov	r7,r19
8111b274:	1009883a 	mov	r4,r2
8111b278:	180b883a 	mov	r5,r3
8111b27c:	11270340 	call	81127034 <__gedf2>
8111b280:	002b883a 	mov	r21,zero
8111b284:	0023883a 	mov	r17,zero
8111b288:	1000bf16 	blt	r2,zero,8111b588 <_dtoa_r+0x1068>
8111b28c:	d9802217 	ldw	r6,136(sp)
8111b290:	ddc00717 	ldw	r23,28(sp)
8111b294:	018c303a 	nor	r6,zero,r6
8111b298:	d9800515 	stw	r6,20(sp)
8111b29c:	a80b883a 	mov	r5,r21
8111b2a0:	e009883a 	mov	r4,fp
8111b2a4:	111d6e80 	call	8111d6e8 <_Bfree>
8111b2a8:	883e4926 	beq	r17,zero,8111abd0 <__reset+0xfb0fabd0>
8111b2ac:	003fad06 	br	8111b164 <__reset+0xfb0fb164>
8111b2b0:	d9c01117 	ldw	r7,68(sp)
8111b2b4:	3801bc26 	beq	r7,zero,8111b9a8 <_dtoa_r+0x1488>
8111b2b8:	10810cc4 	addi	r2,r2,1075
8111b2bc:	dd400a17 	ldw	r21,40(sp)
8111b2c0:	dd000817 	ldw	r20,32(sp)
8111b2c4:	003f0a06 	br	8111aef0 <__reset+0xfb0faef0>
8111b2c8:	00800704 	movi	r2,28
8111b2cc:	d9000817 	ldw	r4,32(sp)
8111b2d0:	a0a9883a 	add	r20,r20,r2
8111b2d4:	b0ad883a 	add	r22,r22,r2
8111b2d8:	2089883a 	add	r4,r4,r2
8111b2dc:	d9000815 	stw	r4,32(sp)
8111b2e0:	003f5106 	br	8111b028 <__reset+0xfb0fb028>
8111b2e4:	d8c00317 	ldw	r3,12(sp)
8111b2e8:	b8c1fc0e 	bge	r23,r3,8111badc <_dtoa_r+0x15bc>
8111b2ec:	0027883a 	mov	r19,zero
8111b2f0:	b805883a 	mov	r2,r23
8111b2f4:	003f3e06 	br	8111aff0 <__reset+0xfb0faff0>
8111b2f8:	880b883a 	mov	r5,r17
8111b2fc:	e009883a 	mov	r4,fp
8111b300:	000f883a 	mov	r7,zero
8111b304:	01800284 	movi	r6,10
8111b308:	111d7100 	call	8111d710 <__multadd>
8111b30c:	d9000c17 	ldw	r4,48(sp)
8111b310:	1023883a 	mov	r17,r2
8111b314:	0102040e 	bge	zero,r4,8111bb28 <_dtoa_r+0x1608>
8111b318:	d9000615 	stw	r4,24(sp)
8111b31c:	0500050e 	bge	zero,r20,8111b334 <_dtoa_r+0xe14>
8111b320:	880b883a 	mov	r5,r17
8111b324:	a00d883a 	mov	r6,r20
8111b328:	e009883a 	mov	r4,fp
8111b32c:	111dde80 	call	8111dde8 <__lshift>
8111b330:	1023883a 	mov	r17,r2
8111b334:	9801241e 	bne	r19,zero,8111b7c8 <_dtoa_r+0x12a8>
8111b338:	8829883a 	mov	r20,r17
8111b33c:	d9000617 	ldw	r4,24(sp)
8111b340:	dcc00717 	ldw	r19,28(sp)
8111b344:	9480004c 	andi	r18,r18,1
8111b348:	20bfffc4 	addi	r2,r4,-1
8111b34c:	9885883a 	add	r2,r19,r2
8111b350:	d8800415 	stw	r2,16(sp)
8111b354:	dc800615 	stw	r18,24(sp)
8111b358:	a80b883a 	mov	r5,r21
8111b35c:	8009883a 	mov	r4,r16
8111b360:	111a3180 	call	8111a318 <quorem>
8111b364:	880b883a 	mov	r5,r17
8111b368:	8009883a 	mov	r4,r16
8111b36c:	102f883a 	mov	r23,r2
8111b370:	111df380 	call	8111df38 <__mcmp>
8111b374:	a80b883a 	mov	r5,r21
8111b378:	a00d883a 	mov	r6,r20
8111b37c:	e009883a 	mov	r4,fp
8111b380:	102d883a 	mov	r22,r2
8111b384:	111df980 	call	8111df98 <__mdiff>
8111b388:	1007883a 	mov	r3,r2
8111b38c:	10800317 	ldw	r2,12(r2)
8111b390:	bc800c04 	addi	r18,r23,48
8111b394:	180b883a 	mov	r5,r3
8111b398:	10004e1e 	bne	r2,zero,8111b4d4 <_dtoa_r+0xfb4>
8111b39c:	8009883a 	mov	r4,r16
8111b3a0:	d8c01615 	stw	r3,88(sp)
8111b3a4:	111df380 	call	8111df38 <__mcmp>
8111b3a8:	d8c01617 	ldw	r3,88(sp)
8111b3ac:	e009883a 	mov	r4,fp
8111b3b0:	d8801615 	stw	r2,88(sp)
8111b3b4:	180b883a 	mov	r5,r3
8111b3b8:	111d6e80 	call	8111d6e8 <_Bfree>
8111b3bc:	d8801617 	ldw	r2,88(sp)
8111b3c0:	1000041e 	bne	r2,zero,8111b3d4 <_dtoa_r+0xeb4>
8111b3c4:	d9800317 	ldw	r6,12(sp)
8111b3c8:	3000021e 	bne	r6,zero,8111b3d4 <_dtoa_r+0xeb4>
8111b3cc:	d8c00617 	ldw	r3,24(sp)
8111b3d0:	18003726 	beq	r3,zero,8111b4b0 <_dtoa_r+0xf90>
8111b3d4:	b0002016 	blt	r22,zero,8111b458 <_dtoa_r+0xf38>
8111b3d8:	b000041e 	bne	r22,zero,8111b3ec <_dtoa_r+0xecc>
8111b3dc:	d9000317 	ldw	r4,12(sp)
8111b3e0:	2000021e 	bne	r4,zero,8111b3ec <_dtoa_r+0xecc>
8111b3e4:	d8c00617 	ldw	r3,24(sp)
8111b3e8:	18001b26 	beq	r3,zero,8111b458 <_dtoa_r+0xf38>
8111b3ec:	00810716 	blt	zero,r2,8111b80c <_dtoa_r+0x12ec>
8111b3f0:	d8c00417 	ldw	r3,16(sp)
8111b3f4:	9d800044 	addi	r22,r19,1
8111b3f8:	9c800005 	stb	r18,0(r19)
8111b3fc:	b02f883a 	mov	r23,r22
8111b400:	98c10626 	beq	r19,r3,8111b81c <_dtoa_r+0x12fc>
8111b404:	800b883a 	mov	r5,r16
8111b408:	000f883a 	mov	r7,zero
8111b40c:	01800284 	movi	r6,10
8111b410:	e009883a 	mov	r4,fp
8111b414:	111d7100 	call	8111d710 <__multadd>
8111b418:	1021883a 	mov	r16,r2
8111b41c:	000f883a 	mov	r7,zero
8111b420:	01800284 	movi	r6,10
8111b424:	880b883a 	mov	r5,r17
8111b428:	e009883a 	mov	r4,fp
8111b42c:	8d002526 	beq	r17,r20,8111b4c4 <_dtoa_r+0xfa4>
8111b430:	111d7100 	call	8111d710 <__multadd>
8111b434:	a00b883a 	mov	r5,r20
8111b438:	000f883a 	mov	r7,zero
8111b43c:	01800284 	movi	r6,10
8111b440:	e009883a 	mov	r4,fp
8111b444:	1023883a 	mov	r17,r2
8111b448:	111d7100 	call	8111d710 <__multadd>
8111b44c:	1029883a 	mov	r20,r2
8111b450:	b027883a 	mov	r19,r22
8111b454:	003fc006 	br	8111b358 <__reset+0xfb0fb358>
8111b458:	9011883a 	mov	r8,r18
8111b45c:	00800e0e 	bge	zero,r2,8111b498 <_dtoa_r+0xf78>
8111b460:	800b883a 	mov	r5,r16
8111b464:	01800044 	movi	r6,1
8111b468:	e009883a 	mov	r4,fp
8111b46c:	da001715 	stw	r8,92(sp)
8111b470:	111dde80 	call	8111dde8 <__lshift>
8111b474:	a80b883a 	mov	r5,r21
8111b478:	1009883a 	mov	r4,r2
8111b47c:	1021883a 	mov	r16,r2
8111b480:	111df380 	call	8111df38 <__mcmp>
8111b484:	da001717 	ldw	r8,92(sp)
8111b488:	0081960e 	bge	zero,r2,8111bae4 <_dtoa_r+0x15c4>
8111b48c:	00800e44 	movi	r2,57
8111b490:	40817026 	beq	r8,r2,8111ba54 <_dtoa_r+0x1534>
8111b494:	ba000c44 	addi	r8,r23,49
8111b498:	8825883a 	mov	r18,r17
8111b49c:	9dc00044 	addi	r23,r19,1
8111b4a0:	9a000005 	stb	r8,0(r19)
8111b4a4:	a023883a 	mov	r17,r20
8111b4a8:	dc000915 	stw	r16,36(sp)
8111b4ac:	003f2406 	br	8111b140 <__reset+0xfb0fb140>
8111b4b0:	00800e44 	movi	r2,57
8111b4b4:	9011883a 	mov	r8,r18
8111b4b8:	90816626 	beq	r18,r2,8111ba54 <_dtoa_r+0x1534>
8111b4bc:	05bff516 	blt	zero,r22,8111b494 <__reset+0xfb0fb494>
8111b4c0:	003ff506 	br	8111b498 <__reset+0xfb0fb498>
8111b4c4:	111d7100 	call	8111d710 <__multadd>
8111b4c8:	1023883a 	mov	r17,r2
8111b4cc:	1029883a 	mov	r20,r2
8111b4d0:	003fdf06 	br	8111b450 <__reset+0xfb0fb450>
8111b4d4:	e009883a 	mov	r4,fp
8111b4d8:	111d6e80 	call	8111d6e8 <_Bfree>
8111b4dc:	00800044 	movi	r2,1
8111b4e0:	003fbc06 	br	8111b3d4 <__reset+0xfb0fb3d4>
8111b4e4:	a80b883a 	mov	r5,r21
8111b4e8:	8009883a 	mov	r4,r16
8111b4ec:	111df380 	call	8111df38 <__mcmp>
8111b4f0:	103edb0e 	bge	r2,zero,8111b060 <__reset+0xfb0fb060>
8111b4f4:	800b883a 	mov	r5,r16
8111b4f8:	000f883a 	mov	r7,zero
8111b4fc:	01800284 	movi	r6,10
8111b500:	e009883a 	mov	r4,fp
8111b504:	111d7100 	call	8111d710 <__multadd>
8111b508:	1021883a 	mov	r16,r2
8111b50c:	d8800517 	ldw	r2,20(sp)
8111b510:	d8c00b17 	ldw	r3,44(sp)
8111b514:	10bfffc4 	addi	r2,r2,-1
8111b518:	d8800515 	stw	r2,20(sp)
8111b51c:	183f761e 	bne	r3,zero,8111b2f8 <__reset+0xfb0fb2f8>
8111b520:	d9000c17 	ldw	r4,48(sp)
8111b524:	0101730e 	bge	zero,r4,8111baf4 <_dtoa_r+0x15d4>
8111b528:	d9000615 	stw	r4,24(sp)
8111b52c:	003ed006 	br	8111b070 <__reset+0xfb0fb070>
8111b530:	00800084 	movi	r2,2
8111b534:	3081861e 	bne	r6,r2,8111bb50 <_dtoa_r+0x1630>
8111b538:	d8000b15 	stw	zero,44(sp)
8111b53c:	003f3c06 	br	8111b230 <__reset+0xfb0fb230>
8111b540:	dc000917 	ldw	r16,36(sp)
8111b544:	003e9206 	br	8111af90 <__reset+0xfb0faf90>
8111b548:	d9c00317 	ldw	r7,12(sp)
8111b54c:	00800084 	movi	r2,2
8111b550:	11fec50e 	bge	r2,r7,8111b068 <__reset+0xfb0fb068>
8111b554:	d9000617 	ldw	r4,24(sp)
8111b558:	20013c1e 	bne	r4,zero,8111ba4c <_dtoa_r+0x152c>
8111b55c:	a80b883a 	mov	r5,r21
8111b560:	000f883a 	mov	r7,zero
8111b564:	01800144 	movi	r6,5
8111b568:	e009883a 	mov	r4,fp
8111b56c:	111d7100 	call	8111d710 <__multadd>
8111b570:	100b883a 	mov	r5,r2
8111b574:	8009883a 	mov	r4,r16
8111b578:	102b883a 	mov	r21,r2
8111b57c:	111df380 	call	8111df38 <__mcmp>
8111b580:	dc000915 	stw	r16,36(sp)
8111b584:	00bf410e 	bge	zero,r2,8111b28c <__reset+0xfb0fb28c>
8111b588:	d9c00717 	ldw	r7,28(sp)
8111b58c:	00800c44 	movi	r2,49
8111b590:	38800005 	stb	r2,0(r7)
8111b594:	d8800517 	ldw	r2,20(sp)
8111b598:	3dc00044 	addi	r23,r7,1
8111b59c:	10800044 	addi	r2,r2,1
8111b5a0:	d8800515 	stw	r2,20(sp)
8111b5a4:	003f3d06 	br	8111b29c <__reset+0xfb0fb29c>
8111b5a8:	d9800517 	ldw	r6,20(sp)
8111b5ac:	d9c00717 	ldw	r7,28(sp)
8111b5b0:	00800c44 	movi	r2,49
8111b5b4:	31800044 	addi	r6,r6,1
8111b5b8:	d9800515 	stw	r6,20(sp)
8111b5bc:	38800005 	stb	r2,0(r7)
8111b5c0:	003edf06 	br	8111b140 <__reset+0xfb0fb140>
8111b5c4:	d8000b15 	stw	zero,44(sp)
8111b5c8:	003c9f06 	br	8111a848 <__reset+0xfb0fa848>
8111b5cc:	903e7e1e 	bne	r18,zero,8111afc8 <__reset+0xfb0fafc8>
8111b5d0:	00800434 	movhi	r2,16
8111b5d4:	10bfffc4 	addi	r2,r2,-1
8111b5d8:	9884703a 	and	r2,r19,r2
8111b5dc:	1000ea1e 	bne	r2,zero,8111b988 <_dtoa_r+0x1468>
8111b5e0:	9cdffc2c 	andhi	r19,r19,32752
8111b5e4:	9800e826 	beq	r19,zero,8111b988 <_dtoa_r+0x1468>
8111b5e8:	d9c00817 	ldw	r7,32(sp)
8111b5ec:	b5800044 	addi	r22,r22,1
8111b5f0:	04c00044 	movi	r19,1
8111b5f4:	39c00044 	addi	r7,r7,1
8111b5f8:	d9c00815 	stw	r7,32(sp)
8111b5fc:	d8800d17 	ldw	r2,52(sp)
8111b600:	103e721e 	bne	r2,zero,8111afcc <__reset+0xfb0fafcc>
8111b604:	00800044 	movi	r2,1
8111b608:	003e7906 	br	8111aff0 <__reset+0xfb0faff0>
8111b60c:	8009883a 	mov	r4,r16
8111b610:	1127b880 	call	81127b88 <__floatsidf>
8111b614:	d9800f17 	ldw	r6,60(sp)
8111b618:	d9c01017 	ldw	r7,64(sp)
8111b61c:	1009883a 	mov	r4,r2
8111b620:	180b883a 	mov	r5,r3
8111b624:	1111b400 	call	81111b40 <__muldf3>
8111b628:	000d883a 	mov	r6,zero
8111b62c:	01d00734 	movhi	r7,16412
8111b630:	1009883a 	mov	r4,r2
8111b634:	180b883a 	mov	r5,r3
8111b638:	1125e080 	call	81125e08 <__adddf3>
8111b63c:	047f3034 	movhi	r17,64704
8111b640:	1021883a 	mov	r16,r2
8111b644:	1c63883a 	add	r17,r3,r17
8111b648:	d9000f17 	ldw	r4,60(sp)
8111b64c:	d9401017 	ldw	r5,64(sp)
8111b650:	000d883a 	mov	r6,zero
8111b654:	01d00534 	movhi	r7,16404
8111b658:	11272040 	call	81127204 <__subdf3>
8111b65c:	800d883a 	mov	r6,r16
8111b660:	880f883a 	mov	r7,r17
8111b664:	1009883a 	mov	r4,r2
8111b668:	180b883a 	mov	r5,r3
8111b66c:	102b883a 	mov	r21,r2
8111b670:	1829883a 	mov	r20,r3
8111b674:	11270340 	call	81127034 <__gedf2>
8111b678:	00806c16 	blt	zero,r2,8111b82c <_dtoa_r+0x130c>
8111b67c:	89e0003c 	xorhi	r7,r17,32768
8111b680:	800d883a 	mov	r6,r16
8111b684:	a809883a 	mov	r4,r21
8111b688:	a00b883a 	mov	r5,r20
8111b68c:	11271100 	call	81127110 <__ledf2>
8111b690:	103d7e0e 	bge	r2,zero,8111ac8c <__reset+0xfb0fac8c>
8111b694:	002b883a 	mov	r21,zero
8111b698:	0023883a 	mov	r17,zero
8111b69c:	003efb06 	br	8111b28c <__reset+0xfb0fb28c>
8111b6a0:	d8800717 	ldw	r2,28(sp)
8111b6a4:	003bd006 	br	8111a5e8 <__reset+0xfb0fa5e8>
8111b6a8:	d9000a17 	ldw	r4,40(sp)
8111b6ac:	d9800d17 	ldw	r6,52(sp)
8111b6b0:	dd400a15 	stw	r21,40(sp)
8111b6b4:	a905c83a 	sub	r2,r21,r4
8111b6b8:	308d883a 	add	r6,r6,r2
8111b6bc:	d9800d15 	stw	r6,52(sp)
8111b6c0:	002b883a 	mov	r21,zero
8111b6c4:	003e0606 	br	8111aee0 <__reset+0xfb0faee0>
8111b6c8:	9023883a 	mov	r17,r18
8111b6cc:	9829883a 	mov	r20,r19
8111b6d0:	04000084 	movi	r16,2
8111b6d4:	003c9206 	br	8111a920 <__reset+0xfb0fa920>
8111b6d8:	04000044 	movi	r16,1
8111b6dc:	dc000c15 	stw	r16,48(sp)
8111b6e0:	dc000615 	stw	r16,24(sp)
8111b6e4:	dc002215 	stw	r16,136(sp)
8111b6e8:	e0001115 	stw	zero,68(fp)
8111b6ec:	000b883a 	mov	r5,zero
8111b6f0:	003c6906 	br	8111a898 <__reset+0xfb0fa898>
8111b6f4:	3021883a 	mov	r16,r6
8111b6f8:	003ffb06 	br	8111b6e8 <__reset+0xfb0fb6e8>
8111b6fc:	1000021e 	bne	r2,zero,8111b708 <_dtoa_r+0x11e8>
8111b700:	4200004c 	andi	r8,r8,1
8111b704:	403e7d1e 	bne	r8,zero,8111b0fc <__reset+0xfb0fb0fc>
8111b708:	01000c04 	movi	r4,48
8111b70c:	00000106 	br	8111b714 <_dtoa_r+0x11f4>
8111b710:	102f883a 	mov	r23,r2
8111b714:	b8bfffc4 	addi	r2,r23,-1
8111b718:	10c00007 	ldb	r3,0(r2)
8111b71c:	193ffc26 	beq	r3,r4,8111b710 <__reset+0xfb0fb710>
8111b720:	003e8706 	br	8111b140 <__reset+0xfb0fb140>
8111b724:	d8800517 	ldw	r2,20(sp)
8111b728:	00a3c83a 	sub	r17,zero,r2
8111b72c:	8800a426 	beq	r17,zero,8111b9c0 <_dtoa_r+0x14a0>
8111b730:	888003cc 	andi	r2,r17,15
8111b734:	100490fa 	slli	r2,r2,3
8111b738:	00e04534 	movhi	r3,33044
8111b73c:	18fde904 	addi	r3,r3,-2140
8111b740:	1885883a 	add	r2,r3,r2
8111b744:	11800017 	ldw	r6,0(r2)
8111b748:	11c00117 	ldw	r7,4(r2)
8111b74c:	9009883a 	mov	r4,r18
8111b750:	980b883a 	mov	r5,r19
8111b754:	8823d13a 	srai	r17,r17,4
8111b758:	1111b400 	call	81111b40 <__muldf3>
8111b75c:	d8800f15 	stw	r2,60(sp)
8111b760:	d8c01015 	stw	r3,64(sp)
8111b764:	8800e826 	beq	r17,zero,8111bb08 <_dtoa_r+0x15e8>
8111b768:	05204534 	movhi	r20,33044
8111b76c:	a53ddf04 	addi	r20,r20,-2180
8111b770:	04000084 	movi	r16,2
8111b774:	8980004c 	andi	r6,r17,1
8111b778:	1009883a 	mov	r4,r2
8111b77c:	8823d07a 	srai	r17,r17,1
8111b780:	180b883a 	mov	r5,r3
8111b784:	30000426 	beq	r6,zero,8111b798 <_dtoa_r+0x1278>
8111b788:	a1800017 	ldw	r6,0(r20)
8111b78c:	a1c00117 	ldw	r7,4(r20)
8111b790:	84000044 	addi	r16,r16,1
8111b794:	1111b400 	call	81111b40 <__muldf3>
8111b798:	a5000204 	addi	r20,r20,8
8111b79c:	883ff51e 	bne	r17,zero,8111b774 <__reset+0xfb0fb774>
8111b7a0:	d8800f15 	stw	r2,60(sp)
8111b7a4:	d8c01015 	stw	r3,64(sp)
8111b7a8:	003c7606 	br	8111a984 <__reset+0xfb0fa984>
8111b7ac:	00c00c04 	movi	r3,48
8111b7b0:	10c00005 	stb	r3,0(r2)
8111b7b4:	d8c00517 	ldw	r3,20(sp)
8111b7b8:	bd3fffc3 	ldbu	r20,-1(r23)
8111b7bc:	18c00044 	addi	r3,r3,1
8111b7c0:	d8c00515 	stw	r3,20(sp)
8111b7c4:	003db906 	br	8111aeac <__reset+0xfb0faeac>
8111b7c8:	89400117 	ldw	r5,4(r17)
8111b7cc:	e009883a 	mov	r4,fp
8111b7d0:	111d6380 	call	8111d638 <_Balloc>
8111b7d4:	89800417 	ldw	r6,16(r17)
8111b7d8:	89400304 	addi	r5,r17,12
8111b7dc:	11000304 	addi	r4,r2,12
8111b7e0:	31800084 	addi	r6,r6,2
8111b7e4:	318d883a 	add	r6,r6,r6
8111b7e8:	318d883a 	add	r6,r6,r6
8111b7ec:	1027883a 	mov	r19,r2
8111b7f0:	11136e00 	call	811136e0 <memcpy>
8111b7f4:	01800044 	movi	r6,1
8111b7f8:	980b883a 	mov	r5,r19
8111b7fc:	e009883a 	mov	r4,fp
8111b800:	111dde80 	call	8111dde8 <__lshift>
8111b804:	1029883a 	mov	r20,r2
8111b808:	003ecc06 	br	8111b33c <__reset+0xfb0fb33c>
8111b80c:	00800e44 	movi	r2,57
8111b810:	90809026 	beq	r18,r2,8111ba54 <_dtoa_r+0x1534>
8111b814:	92000044 	addi	r8,r18,1
8111b818:	003f1f06 	br	8111b498 <__reset+0xfb0fb498>
8111b81c:	9011883a 	mov	r8,r18
8111b820:	8825883a 	mov	r18,r17
8111b824:	a023883a 	mov	r17,r20
8111b828:	003e2906 	br	8111b0d0 <__reset+0xfb0fb0d0>
8111b82c:	002b883a 	mov	r21,zero
8111b830:	0023883a 	mov	r17,zero
8111b834:	003f5406 	br	8111b588 <__reset+0xfb0fb588>
8111b838:	61bfffc4 	addi	r6,r12,-1
8111b83c:	300490fa 	slli	r2,r6,3
8111b840:	00e04534 	movhi	r3,33044
8111b844:	18fde904 	addi	r3,r3,-2140
8111b848:	1885883a 	add	r2,r3,r2
8111b84c:	11000017 	ldw	r4,0(r2)
8111b850:	11400117 	ldw	r5,4(r2)
8111b854:	d8800717 	ldw	r2,28(sp)
8111b858:	880f883a 	mov	r7,r17
8111b85c:	d9801215 	stw	r6,72(sp)
8111b860:	800d883a 	mov	r6,r16
8111b864:	db001615 	stw	r12,88(sp)
8111b868:	15c00044 	addi	r23,r2,1
8111b86c:	1111b400 	call	81111b40 <__muldf3>
8111b870:	d9401017 	ldw	r5,64(sp)
8111b874:	d9000f17 	ldw	r4,60(sp)
8111b878:	d8c01515 	stw	r3,84(sp)
8111b87c:	d8801415 	stw	r2,80(sp)
8111b880:	1127b080 	call	81127b08 <__fixdfsi>
8111b884:	1009883a 	mov	r4,r2
8111b888:	1021883a 	mov	r16,r2
8111b88c:	1127b880 	call	81127b88 <__floatsidf>
8111b890:	d9000f17 	ldw	r4,60(sp)
8111b894:	d9401017 	ldw	r5,64(sp)
8111b898:	100d883a 	mov	r6,r2
8111b89c:	180f883a 	mov	r7,r3
8111b8a0:	11272040 	call	81127204 <__subdf3>
8111b8a4:	1829883a 	mov	r20,r3
8111b8a8:	d8c00717 	ldw	r3,28(sp)
8111b8ac:	84000c04 	addi	r16,r16,48
8111b8b0:	1023883a 	mov	r17,r2
8111b8b4:	1c000005 	stb	r16,0(r3)
8111b8b8:	db001617 	ldw	r12,88(sp)
8111b8bc:	00800044 	movi	r2,1
8111b8c0:	60802226 	beq	r12,r2,8111b94c <_dtoa_r+0x142c>
8111b8c4:	d9c00717 	ldw	r7,28(sp)
8111b8c8:	8805883a 	mov	r2,r17
8111b8cc:	b82b883a 	mov	r21,r23
8111b8d0:	3b19883a 	add	r12,r7,r12
8111b8d4:	6023883a 	mov	r17,r12
8111b8d8:	a007883a 	mov	r3,r20
8111b8dc:	dc800f15 	stw	r18,60(sp)
8111b8e0:	000d883a 	mov	r6,zero
8111b8e4:	01d00934 	movhi	r7,16420
8111b8e8:	1009883a 	mov	r4,r2
8111b8ec:	180b883a 	mov	r5,r3
8111b8f0:	1111b400 	call	81111b40 <__muldf3>
8111b8f4:	180b883a 	mov	r5,r3
8111b8f8:	1009883a 	mov	r4,r2
8111b8fc:	1829883a 	mov	r20,r3
8111b900:	1025883a 	mov	r18,r2
8111b904:	1127b080 	call	81127b08 <__fixdfsi>
8111b908:	1009883a 	mov	r4,r2
8111b90c:	1021883a 	mov	r16,r2
8111b910:	1127b880 	call	81127b88 <__floatsidf>
8111b914:	100d883a 	mov	r6,r2
8111b918:	180f883a 	mov	r7,r3
8111b91c:	9009883a 	mov	r4,r18
8111b920:	a00b883a 	mov	r5,r20
8111b924:	84000c04 	addi	r16,r16,48
8111b928:	11272040 	call	81127204 <__subdf3>
8111b92c:	ad400044 	addi	r21,r21,1
8111b930:	ac3fffc5 	stb	r16,-1(r21)
8111b934:	ac7fea1e 	bne	r21,r17,8111b8e0 <__reset+0xfb0fb8e0>
8111b938:	1023883a 	mov	r17,r2
8111b93c:	d8801217 	ldw	r2,72(sp)
8111b940:	dc800f17 	ldw	r18,60(sp)
8111b944:	1829883a 	mov	r20,r3
8111b948:	b8af883a 	add	r23,r23,r2
8111b94c:	d9001417 	ldw	r4,80(sp)
8111b950:	d9401517 	ldw	r5,84(sp)
8111b954:	000d883a 	mov	r6,zero
8111b958:	01cff834 	movhi	r7,16352
8111b95c:	1125e080 	call	81125e08 <__adddf3>
8111b960:	880d883a 	mov	r6,r17
8111b964:	a00f883a 	mov	r7,r20
8111b968:	1009883a 	mov	r4,r2
8111b96c:	180b883a 	mov	r5,r3
8111b970:	11271100 	call	81127110 <__ledf2>
8111b974:	10003e0e 	bge	r2,zero,8111ba70 <_dtoa_r+0x1550>
8111b978:	d9001317 	ldw	r4,76(sp)
8111b97c:	bd3fffc3 	ldbu	r20,-1(r23)
8111b980:	d9000515 	stw	r4,20(sp)
8111b984:	003d3b06 	br	8111ae74 <__reset+0xfb0fae74>
8111b988:	0027883a 	mov	r19,zero
8111b98c:	003f1b06 	br	8111b5fc <__reset+0xfb0fb5fc>
8111b990:	d8800817 	ldw	r2,32(sp)
8111b994:	11e9c83a 	sub	r20,r2,r7
8111b998:	0005883a 	mov	r2,zero
8111b99c:	003d5406 	br	8111aef0 <__reset+0xfb0faef0>
8111b9a0:	00800044 	movi	r2,1
8111b9a4:	003dc706 	br	8111b0c4 <__reset+0xfb0fb0c4>
8111b9a8:	d8c00217 	ldw	r3,8(sp)
8111b9ac:	00800d84 	movi	r2,54
8111b9b0:	dd400a17 	ldw	r21,40(sp)
8111b9b4:	10c5c83a 	sub	r2,r2,r3
8111b9b8:	dd000817 	ldw	r20,32(sp)
8111b9bc:	003d4c06 	br	8111aef0 <__reset+0xfb0faef0>
8111b9c0:	dc800f15 	stw	r18,60(sp)
8111b9c4:	dcc01015 	stw	r19,64(sp)
8111b9c8:	04000084 	movi	r16,2
8111b9cc:	003bed06 	br	8111a984 <__reset+0xfb0fa984>
8111b9d0:	d9000617 	ldw	r4,24(sp)
8111b9d4:	203f0d26 	beq	r4,zero,8111b60c <__reset+0xfb0fb60c>
8111b9d8:	d9800c17 	ldw	r6,48(sp)
8111b9dc:	01bcab0e 	bge	zero,r6,8111ac8c <__reset+0xfb0fac8c>
8111b9e0:	d9401017 	ldw	r5,64(sp)
8111b9e4:	d9000f17 	ldw	r4,60(sp)
8111b9e8:	000d883a 	mov	r6,zero
8111b9ec:	01d00934 	movhi	r7,16420
8111b9f0:	1111b400 	call	81111b40 <__muldf3>
8111b9f4:	81000044 	addi	r4,r16,1
8111b9f8:	d8800f15 	stw	r2,60(sp)
8111b9fc:	d8c01015 	stw	r3,64(sp)
8111ba00:	1127b880 	call	81127b88 <__floatsidf>
8111ba04:	d9800f17 	ldw	r6,60(sp)
8111ba08:	d9c01017 	ldw	r7,64(sp)
8111ba0c:	1009883a 	mov	r4,r2
8111ba10:	180b883a 	mov	r5,r3
8111ba14:	1111b400 	call	81111b40 <__muldf3>
8111ba18:	01d00734 	movhi	r7,16412
8111ba1c:	000d883a 	mov	r6,zero
8111ba20:	1009883a 	mov	r4,r2
8111ba24:	180b883a 	mov	r5,r3
8111ba28:	1125e080 	call	81125e08 <__adddf3>
8111ba2c:	d9c00517 	ldw	r7,20(sp)
8111ba30:	047f3034 	movhi	r17,64704
8111ba34:	1021883a 	mov	r16,r2
8111ba38:	39ffffc4 	addi	r7,r7,-1
8111ba3c:	d9c01315 	stw	r7,76(sp)
8111ba40:	1c63883a 	add	r17,r3,r17
8111ba44:	db000c17 	ldw	r12,48(sp)
8111ba48:	003bea06 	br	8111a9f4 <__reset+0xfb0fa9f4>
8111ba4c:	dc000915 	stw	r16,36(sp)
8111ba50:	003e0e06 	br	8111b28c <__reset+0xfb0fb28c>
8111ba54:	01000e44 	movi	r4,57
8111ba58:	8825883a 	mov	r18,r17
8111ba5c:	9dc00044 	addi	r23,r19,1
8111ba60:	99000005 	stb	r4,0(r19)
8111ba64:	a023883a 	mov	r17,r20
8111ba68:	dc000915 	stw	r16,36(sp)
8111ba6c:	003da406 	br	8111b100 <__reset+0xfb0fb100>
8111ba70:	d9801417 	ldw	r6,80(sp)
8111ba74:	d9c01517 	ldw	r7,84(sp)
8111ba78:	0009883a 	mov	r4,zero
8111ba7c:	014ff834 	movhi	r5,16352
8111ba80:	11272040 	call	81127204 <__subdf3>
8111ba84:	880d883a 	mov	r6,r17
8111ba88:	a00f883a 	mov	r7,r20
8111ba8c:	1009883a 	mov	r4,r2
8111ba90:	180b883a 	mov	r5,r3
8111ba94:	11270340 	call	81127034 <__gedf2>
8111ba98:	00bc7c0e 	bge	zero,r2,8111ac8c <__reset+0xfb0fac8c>
8111ba9c:	01000c04 	movi	r4,48
8111baa0:	00000106 	br	8111baa8 <_dtoa_r+0x1588>
8111baa4:	102f883a 	mov	r23,r2
8111baa8:	b8bfffc4 	addi	r2,r23,-1
8111baac:	10c00007 	ldb	r3,0(r2)
8111bab0:	193ffc26 	beq	r3,r4,8111baa4 <__reset+0xfb0fbaa4>
8111bab4:	d9801317 	ldw	r6,76(sp)
8111bab8:	d9800515 	stw	r6,20(sp)
8111babc:	003c4406 	br	8111abd0 <__reset+0xfb0fabd0>
8111bac0:	d9801317 	ldw	r6,76(sp)
8111bac4:	d9800515 	stw	r6,20(sp)
8111bac8:	003cea06 	br	8111ae74 <__reset+0xfb0fae74>
8111bacc:	dd800f17 	ldw	r22,60(sp)
8111bad0:	dcc01017 	ldw	r19,64(sp)
8111bad4:	dc801217 	ldw	r18,72(sp)
8111bad8:	003c6c06 	br	8111ac8c <__reset+0xfb0fac8c>
8111badc:	903e031e 	bne	r18,zero,8111b2ec <__reset+0xfb0fb2ec>
8111bae0:	003ebb06 	br	8111b5d0 <__reset+0xfb0fb5d0>
8111bae4:	103e6c1e 	bne	r2,zero,8111b498 <__reset+0xfb0fb498>
8111bae8:	4080004c 	andi	r2,r8,1
8111baec:	103e6a26 	beq	r2,zero,8111b498 <__reset+0xfb0fb498>
8111baf0:	003e6606 	br	8111b48c <__reset+0xfb0fb48c>
8111baf4:	d8c00317 	ldw	r3,12(sp)
8111baf8:	00800084 	movi	r2,2
8111bafc:	10c02916 	blt	r2,r3,8111bba4 <_dtoa_r+0x1684>
8111bb00:	d9000c17 	ldw	r4,48(sp)
8111bb04:	003e8806 	br	8111b528 <__reset+0xfb0fb528>
8111bb08:	04000084 	movi	r16,2
8111bb0c:	003b9d06 	br	8111a984 <__reset+0xfb0fa984>
8111bb10:	d9001317 	ldw	r4,76(sp)
8111bb14:	d9000515 	stw	r4,20(sp)
8111bb18:	003cd606 	br	8111ae74 <__reset+0xfb0fae74>
8111bb1c:	d8801317 	ldw	r2,76(sp)
8111bb20:	d8800515 	stw	r2,20(sp)
8111bb24:	003c2a06 	br	8111abd0 <__reset+0xfb0fabd0>
8111bb28:	d9800317 	ldw	r6,12(sp)
8111bb2c:	00800084 	movi	r2,2
8111bb30:	11801516 	blt	r2,r6,8111bb88 <_dtoa_r+0x1668>
8111bb34:	d9c00c17 	ldw	r7,48(sp)
8111bb38:	d9c00615 	stw	r7,24(sp)
8111bb3c:	003df706 	br	8111b31c <__reset+0xfb0fb31c>
8111bb40:	193d3926 	beq	r3,r4,8111b028 <__reset+0xfb0fb028>
8111bb44:	00c00f04 	movi	r3,60
8111bb48:	1885c83a 	sub	r2,r3,r2
8111bb4c:	003ddf06 	br	8111b2cc <__reset+0xfb0fb2cc>
8111bb50:	e009883a 	mov	r4,fp
8111bb54:	e0001115 	stw	zero,68(fp)
8111bb58:	000b883a 	mov	r5,zero
8111bb5c:	111d6380 	call	8111d638 <_Balloc>
8111bb60:	d8800715 	stw	r2,28(sp)
8111bb64:	d8c00717 	ldw	r3,28(sp)
8111bb68:	00bfffc4 	movi	r2,-1
8111bb6c:	01000044 	movi	r4,1
8111bb70:	d8800c15 	stw	r2,48(sp)
8111bb74:	e0c01015 	stw	r3,64(fp)
8111bb78:	d9000b15 	stw	r4,44(sp)
8111bb7c:	d8800615 	stw	r2,24(sp)
8111bb80:	d8002215 	stw	zero,136(sp)
8111bb84:	003c4106 	br	8111ac8c <__reset+0xfb0fac8c>
8111bb88:	d8c00c17 	ldw	r3,48(sp)
8111bb8c:	d8c00615 	stw	r3,24(sp)
8111bb90:	003e7006 	br	8111b554 <__reset+0xfb0fb554>
8111bb94:	04400044 	movi	r17,1
8111bb98:	003b2006 	br	8111a81c <__reset+0xfb0fa81c>
8111bb9c:	000b883a 	mov	r5,zero
8111bba0:	003b3d06 	br	8111a898 <__reset+0xfb0fa898>
8111bba4:	d8800c17 	ldw	r2,48(sp)
8111bba8:	d8800615 	stw	r2,24(sp)
8111bbac:	003e6906 	br	8111b554 <__reset+0xfb0fb554>

8111bbb0 <__sflush_r>:
8111bbb0:	defffb04 	addi	sp,sp,-20
8111bbb4:	de00012e 	bgeu	sp,et,8111bbbc <__sflush_r+0xc>
8111bbb8:	003b68fa 	trap	3
8111bbbc:	2880030b 	ldhu	r2,12(r5)
8111bbc0:	dcc00315 	stw	r19,12(sp)
8111bbc4:	dc400115 	stw	r17,4(sp)
8111bbc8:	dfc00415 	stw	ra,16(sp)
8111bbcc:	dc800215 	stw	r18,8(sp)
8111bbd0:	dc000015 	stw	r16,0(sp)
8111bbd4:	10c0020c 	andi	r3,r2,8
8111bbd8:	2823883a 	mov	r17,r5
8111bbdc:	2027883a 	mov	r19,r4
8111bbe0:	1800311e 	bne	r3,zero,8111bca8 <__sflush_r+0xf8>
8111bbe4:	28c00117 	ldw	r3,4(r5)
8111bbe8:	10820014 	ori	r2,r2,2048
8111bbec:	2880030d 	sth	r2,12(r5)
8111bbf0:	00c04b0e 	bge	zero,r3,8111bd20 <__sflush_r+0x170>
8111bbf4:	8a000a17 	ldw	r8,40(r17)
8111bbf8:	40002326 	beq	r8,zero,8111bc88 <__sflush_r+0xd8>
8111bbfc:	9c000017 	ldw	r16,0(r19)
8111bc00:	10c4000c 	andi	r3,r2,4096
8111bc04:	98000015 	stw	zero,0(r19)
8111bc08:	18004826 	beq	r3,zero,8111bd2c <__sflush_r+0x17c>
8111bc0c:	89801417 	ldw	r6,80(r17)
8111bc10:	10c0010c 	andi	r3,r2,4
8111bc14:	18000626 	beq	r3,zero,8111bc30 <__sflush_r+0x80>
8111bc18:	88c00117 	ldw	r3,4(r17)
8111bc1c:	88800c17 	ldw	r2,48(r17)
8111bc20:	30cdc83a 	sub	r6,r6,r3
8111bc24:	10000226 	beq	r2,zero,8111bc30 <__sflush_r+0x80>
8111bc28:	88800f17 	ldw	r2,60(r17)
8111bc2c:	308dc83a 	sub	r6,r6,r2
8111bc30:	89400717 	ldw	r5,28(r17)
8111bc34:	000f883a 	mov	r7,zero
8111bc38:	9809883a 	mov	r4,r19
8111bc3c:	403ee83a 	callr	r8
8111bc40:	00ffffc4 	movi	r3,-1
8111bc44:	10c04426 	beq	r2,r3,8111bd58 <__sflush_r+0x1a8>
8111bc48:	88c0030b 	ldhu	r3,12(r17)
8111bc4c:	89000417 	ldw	r4,16(r17)
8111bc50:	88000115 	stw	zero,4(r17)
8111bc54:	197dffcc 	andi	r5,r3,63487
8111bc58:	8940030d 	sth	r5,12(r17)
8111bc5c:	89000015 	stw	r4,0(r17)
8111bc60:	18c4000c 	andi	r3,r3,4096
8111bc64:	18002c1e 	bne	r3,zero,8111bd18 <__sflush_r+0x168>
8111bc68:	89400c17 	ldw	r5,48(r17)
8111bc6c:	9c000015 	stw	r16,0(r19)
8111bc70:	28000526 	beq	r5,zero,8111bc88 <__sflush_r+0xd8>
8111bc74:	88801004 	addi	r2,r17,64
8111bc78:	28800226 	beq	r5,r2,8111bc84 <__sflush_r+0xd4>
8111bc7c:	9809883a 	mov	r4,r19
8111bc80:	111c6680 	call	8111c668 <_free_r>
8111bc84:	88000c15 	stw	zero,48(r17)
8111bc88:	0005883a 	mov	r2,zero
8111bc8c:	dfc00417 	ldw	ra,16(sp)
8111bc90:	dcc00317 	ldw	r19,12(sp)
8111bc94:	dc800217 	ldw	r18,8(sp)
8111bc98:	dc400117 	ldw	r17,4(sp)
8111bc9c:	dc000017 	ldw	r16,0(sp)
8111bca0:	dec00504 	addi	sp,sp,20
8111bca4:	f800283a 	ret
8111bca8:	2c800417 	ldw	r18,16(r5)
8111bcac:	903ff626 	beq	r18,zero,8111bc88 <__reset+0xfb0fbc88>
8111bcb0:	2c000017 	ldw	r16,0(r5)
8111bcb4:	108000cc 	andi	r2,r2,3
8111bcb8:	2c800015 	stw	r18,0(r5)
8111bcbc:	84a1c83a 	sub	r16,r16,r18
8111bcc0:	1000131e 	bne	r2,zero,8111bd10 <__sflush_r+0x160>
8111bcc4:	28800517 	ldw	r2,20(r5)
8111bcc8:	88800215 	stw	r2,8(r17)
8111bccc:	04000316 	blt	zero,r16,8111bcdc <__sflush_r+0x12c>
8111bcd0:	003fed06 	br	8111bc88 <__reset+0xfb0fbc88>
8111bcd4:	90a5883a 	add	r18,r18,r2
8111bcd8:	043feb0e 	bge	zero,r16,8111bc88 <__reset+0xfb0fbc88>
8111bcdc:	88800917 	ldw	r2,36(r17)
8111bce0:	89400717 	ldw	r5,28(r17)
8111bce4:	800f883a 	mov	r7,r16
8111bce8:	900d883a 	mov	r6,r18
8111bcec:	9809883a 	mov	r4,r19
8111bcf0:	103ee83a 	callr	r2
8111bcf4:	80a1c83a 	sub	r16,r16,r2
8111bcf8:	00bff616 	blt	zero,r2,8111bcd4 <__reset+0xfb0fbcd4>
8111bcfc:	88c0030b 	ldhu	r3,12(r17)
8111bd00:	00bfffc4 	movi	r2,-1
8111bd04:	18c01014 	ori	r3,r3,64
8111bd08:	88c0030d 	sth	r3,12(r17)
8111bd0c:	003fdf06 	br	8111bc8c <__reset+0xfb0fbc8c>
8111bd10:	0005883a 	mov	r2,zero
8111bd14:	003fec06 	br	8111bcc8 <__reset+0xfb0fbcc8>
8111bd18:	88801415 	stw	r2,80(r17)
8111bd1c:	003fd206 	br	8111bc68 <__reset+0xfb0fbc68>
8111bd20:	28c00f17 	ldw	r3,60(r5)
8111bd24:	00ffb316 	blt	zero,r3,8111bbf4 <__reset+0xfb0fbbf4>
8111bd28:	003fd706 	br	8111bc88 <__reset+0xfb0fbc88>
8111bd2c:	89400717 	ldw	r5,28(r17)
8111bd30:	000d883a 	mov	r6,zero
8111bd34:	01c00044 	movi	r7,1
8111bd38:	9809883a 	mov	r4,r19
8111bd3c:	403ee83a 	callr	r8
8111bd40:	100d883a 	mov	r6,r2
8111bd44:	00bfffc4 	movi	r2,-1
8111bd48:	30801426 	beq	r6,r2,8111bd9c <__sflush_r+0x1ec>
8111bd4c:	8880030b 	ldhu	r2,12(r17)
8111bd50:	8a000a17 	ldw	r8,40(r17)
8111bd54:	003fae06 	br	8111bc10 <__reset+0xfb0fbc10>
8111bd58:	98c00017 	ldw	r3,0(r19)
8111bd5c:	183fba26 	beq	r3,zero,8111bc48 <__reset+0xfb0fbc48>
8111bd60:	01000744 	movi	r4,29
8111bd64:	19000626 	beq	r3,r4,8111bd80 <__sflush_r+0x1d0>
8111bd68:	01000584 	movi	r4,22
8111bd6c:	19000426 	beq	r3,r4,8111bd80 <__sflush_r+0x1d0>
8111bd70:	88c0030b 	ldhu	r3,12(r17)
8111bd74:	18c01014 	ori	r3,r3,64
8111bd78:	88c0030d 	sth	r3,12(r17)
8111bd7c:	003fc306 	br	8111bc8c <__reset+0xfb0fbc8c>
8111bd80:	8880030b 	ldhu	r2,12(r17)
8111bd84:	88c00417 	ldw	r3,16(r17)
8111bd88:	88000115 	stw	zero,4(r17)
8111bd8c:	10bdffcc 	andi	r2,r2,63487
8111bd90:	8880030d 	sth	r2,12(r17)
8111bd94:	88c00015 	stw	r3,0(r17)
8111bd98:	003fb306 	br	8111bc68 <__reset+0xfb0fbc68>
8111bd9c:	98800017 	ldw	r2,0(r19)
8111bda0:	103fea26 	beq	r2,zero,8111bd4c <__reset+0xfb0fbd4c>
8111bda4:	00c00744 	movi	r3,29
8111bda8:	10c00226 	beq	r2,r3,8111bdb4 <__sflush_r+0x204>
8111bdac:	00c00584 	movi	r3,22
8111bdb0:	10c0031e 	bne	r2,r3,8111bdc0 <__sflush_r+0x210>
8111bdb4:	9c000015 	stw	r16,0(r19)
8111bdb8:	0005883a 	mov	r2,zero
8111bdbc:	003fb306 	br	8111bc8c <__reset+0xfb0fbc8c>
8111bdc0:	88c0030b 	ldhu	r3,12(r17)
8111bdc4:	3005883a 	mov	r2,r6
8111bdc8:	18c01014 	ori	r3,r3,64
8111bdcc:	88c0030d 	sth	r3,12(r17)
8111bdd0:	003fae06 	br	8111bc8c <__reset+0xfb0fbc8c>

8111bdd4 <_fflush_r>:
8111bdd4:	defffd04 	addi	sp,sp,-12
8111bdd8:	de00012e 	bgeu	sp,et,8111bde0 <_fflush_r+0xc>
8111bddc:	003b68fa 	trap	3
8111bde0:	dc000115 	stw	r16,4(sp)
8111bde4:	dfc00215 	stw	ra,8(sp)
8111bde8:	2021883a 	mov	r16,r4
8111bdec:	20000226 	beq	r4,zero,8111bdf8 <_fflush_r+0x24>
8111bdf0:	20800e17 	ldw	r2,56(r4)
8111bdf4:	10000c26 	beq	r2,zero,8111be28 <_fflush_r+0x54>
8111bdf8:	2880030f 	ldh	r2,12(r5)
8111bdfc:	1000051e 	bne	r2,zero,8111be14 <_fflush_r+0x40>
8111be00:	0005883a 	mov	r2,zero
8111be04:	dfc00217 	ldw	ra,8(sp)
8111be08:	dc000117 	ldw	r16,4(sp)
8111be0c:	dec00304 	addi	sp,sp,12
8111be10:	f800283a 	ret
8111be14:	8009883a 	mov	r4,r16
8111be18:	dfc00217 	ldw	ra,8(sp)
8111be1c:	dc000117 	ldw	r16,4(sp)
8111be20:	dec00304 	addi	sp,sp,12
8111be24:	111bbb01 	jmpi	8111bbb0 <__sflush_r>
8111be28:	d9400015 	stw	r5,0(sp)
8111be2c:	111c1d00 	call	8111c1d0 <__sinit>
8111be30:	d9400017 	ldw	r5,0(sp)
8111be34:	003ff006 	br	8111bdf8 <__reset+0xfb0fbdf8>

8111be38 <fflush>:
8111be38:	20000526 	beq	r4,zero,8111be50 <fflush+0x18>
8111be3c:	00a04534 	movhi	r2,33044
8111be40:	1086aa04 	addi	r2,r2,6824
8111be44:	200b883a 	mov	r5,r4
8111be48:	11000017 	ldw	r4,0(r2)
8111be4c:	111bdd41 	jmpi	8111bdd4 <_fflush_r>
8111be50:	00a04534 	movhi	r2,33044
8111be54:	1086a904 	addi	r2,r2,6820
8111be58:	11000017 	ldw	r4,0(r2)
8111be5c:	016044b4 	movhi	r5,33042
8111be60:	296f7504 	addi	r5,r5,-16940
8111be64:	111cf101 	jmpi	8111cf10 <_fwalk_reent>

8111be68 <__fp_unlock>:
8111be68:	0005883a 	mov	r2,zero
8111be6c:	f800283a 	ret

8111be70 <_cleanup_r>:
8111be70:	016044b4 	movhi	r5,33042
8111be74:	294f0b04 	addi	r5,r5,15404
8111be78:	111cf101 	jmpi	8111cf10 <_fwalk_reent>

8111be7c <__sinit.part.1>:
8111be7c:	defff704 	addi	sp,sp,-36
8111be80:	00e044b4 	movhi	r3,33042
8111be84:	de00012e 	bgeu	sp,et,8111be8c <__sinit.part.1+0x10>
8111be88:	003b68fa 	trap	3
8111be8c:	18ef9c04 	addi	r3,r3,-16784
8111be90:	dfc00815 	stw	ra,32(sp)
8111be94:	ddc00715 	stw	r23,28(sp)
8111be98:	dd800615 	stw	r22,24(sp)
8111be9c:	dd400515 	stw	r21,20(sp)
8111bea0:	dd000415 	stw	r20,16(sp)
8111bea4:	dcc00315 	stw	r19,12(sp)
8111bea8:	dc800215 	stw	r18,8(sp)
8111beac:	dc400115 	stw	r17,4(sp)
8111beb0:	dc000015 	stw	r16,0(sp)
8111beb4:	24000117 	ldw	r16,4(r4)
8111beb8:	20c00f15 	stw	r3,60(r4)
8111bebc:	2080bb04 	addi	r2,r4,748
8111bec0:	00c000c4 	movi	r3,3
8111bec4:	20c0b915 	stw	r3,740(r4)
8111bec8:	2080ba15 	stw	r2,744(r4)
8111becc:	2000b815 	stw	zero,736(r4)
8111bed0:	05c00204 	movi	r23,8
8111bed4:	00800104 	movi	r2,4
8111bed8:	2025883a 	mov	r18,r4
8111bedc:	b80d883a 	mov	r6,r23
8111bee0:	81001704 	addi	r4,r16,92
8111bee4:	000b883a 	mov	r5,zero
8111bee8:	80000015 	stw	zero,0(r16)
8111beec:	80000115 	stw	zero,4(r16)
8111bef0:	80000215 	stw	zero,8(r16)
8111bef4:	8080030d 	sth	r2,12(r16)
8111bef8:	80001915 	stw	zero,100(r16)
8111befc:	8000038d 	sth	zero,14(r16)
8111bf00:	80000415 	stw	zero,16(r16)
8111bf04:	80000515 	stw	zero,20(r16)
8111bf08:	80000615 	stw	zero,24(r16)
8111bf0c:	11138300 	call	81113830 <memset>
8111bf10:	05a04474 	movhi	r22,33041
8111bf14:	94400217 	ldw	r17,8(r18)
8111bf18:	05604474 	movhi	r21,33041
8111bf1c:	05204474 	movhi	r20,33041
8111bf20:	04e04474 	movhi	r19,33041
8111bf24:	b58faf04 	addi	r22,r22,16060
8111bf28:	ad4fc804 	addi	r21,r21,16160
8111bf2c:	a50fe904 	addi	r20,r20,16292
8111bf30:	9cd00204 	addi	r19,r19,16392
8111bf34:	85800815 	stw	r22,32(r16)
8111bf38:	85400915 	stw	r21,36(r16)
8111bf3c:	85000a15 	stw	r20,40(r16)
8111bf40:	84c00b15 	stw	r19,44(r16)
8111bf44:	84000715 	stw	r16,28(r16)
8111bf48:	00800284 	movi	r2,10
8111bf4c:	8880030d 	sth	r2,12(r17)
8111bf50:	00800044 	movi	r2,1
8111bf54:	b80d883a 	mov	r6,r23
8111bf58:	89001704 	addi	r4,r17,92
8111bf5c:	000b883a 	mov	r5,zero
8111bf60:	88000015 	stw	zero,0(r17)
8111bf64:	88000115 	stw	zero,4(r17)
8111bf68:	88000215 	stw	zero,8(r17)
8111bf6c:	88001915 	stw	zero,100(r17)
8111bf70:	8880038d 	sth	r2,14(r17)
8111bf74:	88000415 	stw	zero,16(r17)
8111bf78:	88000515 	stw	zero,20(r17)
8111bf7c:	88000615 	stw	zero,24(r17)
8111bf80:	11138300 	call	81113830 <memset>
8111bf84:	94000317 	ldw	r16,12(r18)
8111bf88:	00800484 	movi	r2,18
8111bf8c:	8c400715 	stw	r17,28(r17)
8111bf90:	8d800815 	stw	r22,32(r17)
8111bf94:	8d400915 	stw	r21,36(r17)
8111bf98:	8d000a15 	stw	r20,40(r17)
8111bf9c:	8cc00b15 	stw	r19,44(r17)
8111bfa0:	8080030d 	sth	r2,12(r16)
8111bfa4:	00800084 	movi	r2,2
8111bfa8:	80000015 	stw	zero,0(r16)
8111bfac:	80000115 	stw	zero,4(r16)
8111bfb0:	80000215 	stw	zero,8(r16)
8111bfb4:	80001915 	stw	zero,100(r16)
8111bfb8:	8080038d 	sth	r2,14(r16)
8111bfbc:	80000415 	stw	zero,16(r16)
8111bfc0:	80000515 	stw	zero,20(r16)
8111bfc4:	80000615 	stw	zero,24(r16)
8111bfc8:	b80d883a 	mov	r6,r23
8111bfcc:	000b883a 	mov	r5,zero
8111bfd0:	81001704 	addi	r4,r16,92
8111bfd4:	11138300 	call	81113830 <memset>
8111bfd8:	00800044 	movi	r2,1
8111bfdc:	84000715 	stw	r16,28(r16)
8111bfe0:	85800815 	stw	r22,32(r16)
8111bfe4:	85400915 	stw	r21,36(r16)
8111bfe8:	85000a15 	stw	r20,40(r16)
8111bfec:	84c00b15 	stw	r19,44(r16)
8111bff0:	90800e15 	stw	r2,56(r18)
8111bff4:	dfc00817 	ldw	ra,32(sp)
8111bff8:	ddc00717 	ldw	r23,28(sp)
8111bffc:	dd800617 	ldw	r22,24(sp)
8111c000:	dd400517 	ldw	r21,20(sp)
8111c004:	dd000417 	ldw	r20,16(sp)
8111c008:	dcc00317 	ldw	r19,12(sp)
8111c00c:	dc800217 	ldw	r18,8(sp)
8111c010:	dc400117 	ldw	r17,4(sp)
8111c014:	dc000017 	ldw	r16,0(sp)
8111c018:	dec00904 	addi	sp,sp,36
8111c01c:	f800283a 	ret

8111c020 <__fp_lock>:
8111c020:	0005883a 	mov	r2,zero
8111c024:	f800283a 	ret

8111c028 <__sfmoreglue>:
8111c028:	defffc04 	addi	sp,sp,-16
8111c02c:	de00012e 	bgeu	sp,et,8111c034 <__sfmoreglue+0xc>
8111c030:	003b68fa 	trap	3
8111c034:	dc400115 	stw	r17,4(sp)
8111c038:	2c7fffc4 	addi	r17,r5,-1
8111c03c:	8c401a24 	muli	r17,r17,104
8111c040:	dc800215 	stw	r18,8(sp)
8111c044:	2825883a 	mov	r18,r5
8111c048:	89401d04 	addi	r5,r17,116
8111c04c:	dc000015 	stw	r16,0(sp)
8111c050:	dfc00315 	stw	ra,12(sp)
8111c054:	1112ecc0 	call	81112ecc <_malloc_r>
8111c058:	1021883a 	mov	r16,r2
8111c05c:	10000726 	beq	r2,zero,8111c07c <__sfmoreglue+0x54>
8111c060:	11000304 	addi	r4,r2,12
8111c064:	10000015 	stw	zero,0(r2)
8111c068:	14800115 	stw	r18,4(r2)
8111c06c:	11000215 	stw	r4,8(r2)
8111c070:	89801a04 	addi	r6,r17,104
8111c074:	000b883a 	mov	r5,zero
8111c078:	11138300 	call	81113830 <memset>
8111c07c:	8005883a 	mov	r2,r16
8111c080:	dfc00317 	ldw	ra,12(sp)
8111c084:	dc800217 	ldw	r18,8(sp)
8111c088:	dc400117 	ldw	r17,4(sp)
8111c08c:	dc000017 	ldw	r16,0(sp)
8111c090:	dec00404 	addi	sp,sp,16
8111c094:	f800283a 	ret

8111c098 <__sfp>:
8111c098:	defffb04 	addi	sp,sp,-20
8111c09c:	de00012e 	bgeu	sp,et,8111c0a4 <__sfp+0xc>
8111c0a0:	003b68fa 	trap	3
8111c0a4:	dc000015 	stw	r16,0(sp)
8111c0a8:	04204534 	movhi	r16,33044
8111c0ac:	8406a904 	addi	r16,r16,6820
8111c0b0:	dcc00315 	stw	r19,12(sp)
8111c0b4:	2027883a 	mov	r19,r4
8111c0b8:	81000017 	ldw	r4,0(r16)
8111c0bc:	dfc00415 	stw	ra,16(sp)
8111c0c0:	dc800215 	stw	r18,8(sp)
8111c0c4:	20800e17 	ldw	r2,56(r4)
8111c0c8:	dc400115 	stw	r17,4(sp)
8111c0cc:	1000021e 	bne	r2,zero,8111c0d8 <__sfp+0x40>
8111c0d0:	111be7c0 	call	8111be7c <__sinit.part.1>
8111c0d4:	81000017 	ldw	r4,0(r16)
8111c0d8:	2480b804 	addi	r18,r4,736
8111c0dc:	047fffc4 	movi	r17,-1
8111c0e0:	91000117 	ldw	r4,4(r18)
8111c0e4:	94000217 	ldw	r16,8(r18)
8111c0e8:	213fffc4 	addi	r4,r4,-1
8111c0ec:	20000a16 	blt	r4,zero,8111c118 <__sfp+0x80>
8111c0f0:	8080030f 	ldh	r2,12(r16)
8111c0f4:	10000c26 	beq	r2,zero,8111c128 <__sfp+0x90>
8111c0f8:	80c01d04 	addi	r3,r16,116
8111c0fc:	00000206 	br	8111c108 <__sfp+0x70>
8111c100:	18bfe60f 	ldh	r2,-104(r3)
8111c104:	10000826 	beq	r2,zero,8111c128 <__sfp+0x90>
8111c108:	213fffc4 	addi	r4,r4,-1
8111c10c:	1c3ffd04 	addi	r16,r3,-12
8111c110:	18c01a04 	addi	r3,r3,104
8111c114:	247ffa1e 	bne	r4,r17,8111c100 <__reset+0xfb0fc100>
8111c118:	90800017 	ldw	r2,0(r18)
8111c11c:	10001d26 	beq	r2,zero,8111c194 <__sfp+0xfc>
8111c120:	1025883a 	mov	r18,r2
8111c124:	003fee06 	br	8111c0e0 <__reset+0xfb0fc0e0>
8111c128:	00bfffc4 	movi	r2,-1
8111c12c:	8080038d 	sth	r2,14(r16)
8111c130:	00800044 	movi	r2,1
8111c134:	8080030d 	sth	r2,12(r16)
8111c138:	80001915 	stw	zero,100(r16)
8111c13c:	80000015 	stw	zero,0(r16)
8111c140:	80000215 	stw	zero,8(r16)
8111c144:	80000115 	stw	zero,4(r16)
8111c148:	80000415 	stw	zero,16(r16)
8111c14c:	80000515 	stw	zero,20(r16)
8111c150:	80000615 	stw	zero,24(r16)
8111c154:	01800204 	movi	r6,8
8111c158:	000b883a 	mov	r5,zero
8111c15c:	81001704 	addi	r4,r16,92
8111c160:	11138300 	call	81113830 <memset>
8111c164:	8005883a 	mov	r2,r16
8111c168:	80000c15 	stw	zero,48(r16)
8111c16c:	80000d15 	stw	zero,52(r16)
8111c170:	80001115 	stw	zero,68(r16)
8111c174:	80001215 	stw	zero,72(r16)
8111c178:	dfc00417 	ldw	ra,16(sp)
8111c17c:	dcc00317 	ldw	r19,12(sp)
8111c180:	dc800217 	ldw	r18,8(sp)
8111c184:	dc400117 	ldw	r17,4(sp)
8111c188:	dc000017 	ldw	r16,0(sp)
8111c18c:	dec00504 	addi	sp,sp,20
8111c190:	f800283a 	ret
8111c194:	01400104 	movi	r5,4
8111c198:	9809883a 	mov	r4,r19
8111c19c:	111c0280 	call	8111c028 <__sfmoreglue>
8111c1a0:	90800015 	stw	r2,0(r18)
8111c1a4:	103fde1e 	bne	r2,zero,8111c120 <__reset+0xfb0fc120>
8111c1a8:	00800304 	movi	r2,12
8111c1ac:	98800015 	stw	r2,0(r19)
8111c1b0:	0005883a 	mov	r2,zero
8111c1b4:	003ff006 	br	8111c178 <__reset+0xfb0fc178>

8111c1b8 <_cleanup>:
8111c1b8:	00a04534 	movhi	r2,33044
8111c1bc:	1086a904 	addi	r2,r2,6820
8111c1c0:	11000017 	ldw	r4,0(r2)
8111c1c4:	016044b4 	movhi	r5,33042
8111c1c8:	294f0b04 	addi	r5,r5,15404
8111c1cc:	111cf101 	jmpi	8111cf10 <_fwalk_reent>

8111c1d0 <__sinit>:
8111c1d0:	20800e17 	ldw	r2,56(r4)
8111c1d4:	10000126 	beq	r2,zero,8111c1dc <__sinit+0xc>
8111c1d8:	f800283a 	ret
8111c1dc:	111be7c1 	jmpi	8111be7c <__sinit.part.1>

8111c1e0 <__sfp_lock_acquire>:
8111c1e0:	f800283a 	ret

8111c1e4 <__sfp_lock_release>:
8111c1e4:	f800283a 	ret

8111c1e8 <__sinit_lock_acquire>:
8111c1e8:	f800283a 	ret

8111c1ec <__sinit_lock_release>:
8111c1ec:	f800283a 	ret

8111c1f0 <__fp_lock_all>:
8111c1f0:	00a04534 	movhi	r2,33044
8111c1f4:	1086aa04 	addi	r2,r2,6824
8111c1f8:	11000017 	ldw	r4,0(r2)
8111c1fc:	016044b4 	movhi	r5,33042
8111c200:	29700804 	addi	r5,r5,-16352
8111c204:	111ce441 	jmpi	8111ce44 <_fwalk>

8111c208 <__fp_unlock_all>:
8111c208:	00a04534 	movhi	r2,33044
8111c20c:	1086aa04 	addi	r2,r2,6824
8111c210:	11000017 	ldw	r4,0(r2)
8111c214:	016044b4 	movhi	r5,33042
8111c218:	296f9a04 	addi	r5,r5,-16792
8111c21c:	111ce441 	jmpi	8111ce44 <_fwalk>

8111c220 <__sflags>:
8111c220:	28800007 	ldb	r2,0(r5)
8111c224:	00c01c84 	movi	r3,114
8111c228:	10c02426 	beq	r2,r3,8111c2bc <__sflags+0x9c>
8111c22c:	00c01dc4 	movi	r3,119
8111c230:	10c01e26 	beq	r2,r3,8111c2ac <__sflags+0x8c>
8111c234:	00c01844 	movi	r3,97
8111c238:	10c00426 	beq	r2,r3,8111c24c <__sflags+0x2c>
8111c23c:	00800584 	movi	r2,22
8111c240:	20800015 	stw	r2,0(r4)
8111c244:	0005883a 	mov	r2,zero
8111c248:	f800283a 	ret
8111c24c:	02c08204 	movi	r11,520
8111c250:	01000044 	movi	r4,1
8111c254:	00804204 	movi	r2,264
8111c258:	01c00ac4 	movi	r7,43
8111c25c:	02bff8c4 	movi	r10,-29
8111c260:	027fff04 	movi	r9,-4
8111c264:	02001e04 	movi	r8,120
8111c268:	29400044 	addi	r5,r5,1
8111c26c:	28c00007 	ldb	r3,0(r5)
8111c270:	18000626 	beq	r3,zero,8111c28c <__sflags+0x6c>
8111c274:	19c00826 	beq	r3,r7,8111c298 <__sflags+0x78>
8111c278:	1a3ffb1e 	bne	r3,r8,8111c268 <__reset+0xfb0fc268>
8111c27c:	29400044 	addi	r5,r5,1
8111c280:	28c00007 	ldb	r3,0(r5)
8111c284:	21020014 	ori	r4,r4,2048
8111c288:	183ffa1e 	bne	r3,zero,8111c274 <__reset+0xfb0fc274>
8111c28c:	22c8b03a 	or	r4,r4,r11
8111c290:	31000015 	stw	r4,0(r6)
8111c294:	f800283a 	ret
8111c298:	1284703a 	and	r2,r2,r10
8111c29c:	2248703a 	and	r4,r4,r9
8111c2a0:	10800414 	ori	r2,r2,16
8111c2a4:	21000094 	ori	r4,r4,2
8111c2a8:	003fef06 	br	8111c268 <__reset+0xfb0fc268>
8111c2ac:	02c18004 	movi	r11,1536
8111c2b0:	01000044 	movi	r4,1
8111c2b4:	00800204 	movi	r2,8
8111c2b8:	003fe706 	br	8111c258 <__reset+0xfb0fc258>
8111c2bc:	0017883a 	mov	r11,zero
8111c2c0:	0009883a 	mov	r4,zero
8111c2c4:	00800104 	movi	r2,4
8111c2c8:	003fe306 	br	8111c258 <__reset+0xfb0fc258>

8111c2cc <_fread_r>:
8111c2cc:	defff404 	addi	sp,sp,-48
8111c2d0:	de00012e 	bgeu	sp,et,8111c2d8 <_fread_r+0xc>
8111c2d4:	003b68fa 	trap	3
8111c2d8:	dd800815 	stw	r22,32(sp)
8111c2dc:	39ad383a 	mul	r22,r7,r6
8111c2e0:	dc000215 	stw	r16,8(sp)
8111c2e4:	dfc00b15 	stw	ra,44(sp)
8111c2e8:	df000a15 	stw	fp,40(sp)
8111c2ec:	ddc00915 	stw	r23,36(sp)
8111c2f0:	dd400715 	stw	r21,28(sp)
8111c2f4:	dd000615 	stw	r20,24(sp)
8111c2f8:	dcc00515 	stw	r19,20(sp)
8111c2fc:	dc800415 	stw	r18,16(sp)
8111c300:	dc400315 	stw	r17,12(sp)
8111c304:	dc000c17 	ldw	r16,48(sp)
8111c308:	b0003b26 	beq	r22,zero,8111c3f8 <_fread_r+0x12c>
8111c30c:	302f883a 	mov	r23,r6
8111c310:	382b883a 	mov	r21,r7
8111c314:	2029883a 	mov	r20,r4
8111c318:	2827883a 	mov	r19,r5
8111c31c:	20000226 	beq	r4,zero,8111c328 <_fread_r+0x5c>
8111c320:	20800e17 	ldw	r2,56(r4)
8111c324:	10006e26 	beq	r2,zero,8111c4e0 <_fread_r+0x214>
8111c328:	8080030b 	ldhu	r2,12(r16)
8111c32c:	10c8000c 	andi	r3,r2,8192
8111c330:	1800061e 	bne	r3,zero,8111c34c <_fread_r+0x80>
8111c334:	81001917 	ldw	r4,100(r16)
8111c338:	00f7ffc4 	movi	r3,-8193
8111c33c:	10880014 	ori	r2,r2,8192
8111c340:	20c6703a 	and	r3,r4,r3
8111c344:	8080030d 	sth	r2,12(r16)
8111c348:	80c01915 	stw	r3,100(r16)
8111c34c:	84400117 	ldw	r17,4(r16)
8111c350:	88005f16 	blt	r17,zero,8111c4d0 <_fread_r+0x204>
8111c354:	8809883a 	mov	r4,r17
8111c358:	1080008c 	andi	r2,r2,2
8111c35c:	1000281e 	bne	r2,zero,8111c400 <_fread_r+0x134>
8111c360:	b025883a 	mov	r18,r22
8111c364:	00000b06 	br	8111c394 <_fread_r+0xc8>
8111c368:	11136e00 	call	811136e0 <memcpy>
8111c36c:	80800017 	ldw	r2,0(r16)
8111c370:	9c67883a 	add	r19,r19,r17
8111c374:	9465c83a 	sub	r18,r18,r17
8111c378:	1463883a 	add	r17,r2,r17
8111c37c:	800b883a 	mov	r5,r16
8111c380:	a009883a 	mov	r4,r20
8111c384:	84400015 	stw	r17,0(r16)
8111c388:	1113b340 	call	81113b34 <__srefill_r>
8111c38c:	10004c1e 	bne	r2,zero,8111c4c0 <_fread_r+0x1f4>
8111c390:	84400117 	ldw	r17,4(r16)
8111c394:	880d883a 	mov	r6,r17
8111c398:	9809883a 	mov	r4,r19
8111c39c:	81400017 	ldw	r5,0(r16)
8111c3a0:	8cbff136 	bltu	r17,r18,8111c368 <__reset+0xfb0fc368>
8111c3a4:	900d883a 	mov	r6,r18
8111c3a8:	11136e00 	call	811136e0 <memcpy>
8111c3ac:	80c00117 	ldw	r3,4(r16)
8111c3b0:	81000017 	ldw	r4,0(r16)
8111c3b4:	a805883a 	mov	r2,r21
8111c3b8:	1c87c83a 	sub	r3,r3,r18
8111c3bc:	24a5883a 	add	r18,r4,r18
8111c3c0:	80c00115 	stw	r3,4(r16)
8111c3c4:	84800015 	stw	r18,0(r16)
8111c3c8:	dfc00b17 	ldw	ra,44(sp)
8111c3cc:	df000a17 	ldw	fp,40(sp)
8111c3d0:	ddc00917 	ldw	r23,36(sp)
8111c3d4:	dd800817 	ldw	r22,32(sp)
8111c3d8:	dd400717 	ldw	r21,28(sp)
8111c3dc:	dd000617 	ldw	r20,24(sp)
8111c3e0:	dcc00517 	ldw	r19,20(sp)
8111c3e4:	dc800417 	ldw	r18,16(sp)
8111c3e8:	dc400317 	ldw	r17,12(sp)
8111c3ec:	dc000217 	ldw	r16,8(sp)
8111c3f0:	dec00c04 	addi	sp,sp,48
8111c3f4:	f800283a 	ret
8111c3f8:	0005883a 	mov	r2,zero
8111c3fc:	003ff206 	br	8111c3c8 <__reset+0xfb0fc3c8>
8111c400:	b007883a 	mov	r3,r22
8111c404:	2580012e 	bgeu	r4,r22,8111c40c <_fread_r+0x140>
8111c408:	2007883a 	mov	r3,r4
8111c40c:	81400017 	ldw	r5,0(r16)
8111c410:	180d883a 	mov	r6,r3
8111c414:	9809883a 	mov	r4,r19
8111c418:	d8c00115 	stw	r3,4(sp)
8111c41c:	11136e00 	call	811136e0 <memcpy>
8111c420:	d8c00117 	ldw	r3,4(sp)
8111c424:	84400017 	ldw	r17,0(r16)
8111c428:	80800117 	ldw	r2,4(r16)
8111c42c:	81400c17 	ldw	r5,48(r16)
8111c430:	88e3883a 	add	r17,r17,r3
8111c434:	10c5c83a 	sub	r2,r2,r3
8111c438:	84400015 	stw	r17,0(r16)
8111c43c:	80800115 	stw	r2,4(r16)
8111c440:	b0e5c83a 	sub	r18,r22,r3
8111c444:	28002b26 	beq	r5,zero,8111c4f4 <_fread_r+0x228>
8111c448:	90002b26 	beq	r18,zero,8111c4f8 <_fread_r+0x22c>
8111c44c:	80801004 	addi	r2,r16,64
8111c450:	28800526 	beq	r5,r2,8111c468 <_fread_r+0x19c>
8111c454:	a009883a 	mov	r4,r20
8111c458:	d8c00115 	stw	r3,4(sp)
8111c45c:	111c6680 	call	8111c668 <_free_r>
8111c460:	d8c00117 	ldw	r3,4(sp)
8111c464:	84400017 	ldw	r17,0(r16)
8111c468:	80000c15 	stw	zero,48(r16)
8111c46c:	80800517 	ldw	r2,20(r16)
8111c470:	87000417 	ldw	fp,16(r16)
8111c474:	98e7883a 	add	r19,r19,r3
8111c478:	d8800015 	stw	r2,0(sp)
8111c47c:	00000106 	br	8111c484 <_fread_r+0x1b8>
8111c480:	90001d26 	beq	r18,zero,8111c4f8 <_fread_r+0x22c>
8111c484:	84c00415 	stw	r19,16(r16)
8111c488:	84800515 	stw	r18,20(r16)
8111c48c:	84c00015 	stw	r19,0(r16)
8111c490:	a009883a 	mov	r4,r20
8111c494:	800b883a 	mov	r5,r16
8111c498:	1113b340 	call	81113b34 <__srefill_r>
8111c49c:	d9000017 	ldw	r4,0(sp)
8111c4a0:	80c00117 	ldw	r3,4(r16)
8111c4a4:	87000415 	stw	fp,16(r16)
8111c4a8:	81000515 	stw	r4,20(r16)
8111c4ac:	84400015 	stw	r17,0(r16)
8111c4b0:	80000115 	stw	zero,4(r16)
8111c4b4:	90e5c83a 	sub	r18,r18,r3
8111c4b8:	98e7883a 	add	r19,r19,r3
8111c4bc:	103ff026 	beq	r2,zero,8111c480 <__reset+0xfb0fc480>
8111c4c0:	b80b883a 	mov	r5,r23
8111c4c4:	b489c83a 	sub	r4,r22,r18
8111c4c8:	1125b500 	call	81125b50 <__udivsi3>
8111c4cc:	003fbe06 	br	8111c3c8 <__reset+0xfb0fc3c8>
8111c4d0:	80000115 	stw	zero,4(r16)
8111c4d4:	0009883a 	mov	r4,zero
8111c4d8:	0023883a 	mov	r17,zero
8111c4dc:	003f9e06 	br	8111c358 <__reset+0xfb0fc358>
8111c4e0:	111c1d00 	call	8111c1d0 <__sinit>
8111c4e4:	8080030b 	ldhu	r2,12(r16)
8111c4e8:	10c8000c 	andi	r3,r2,8192
8111c4ec:	183f971e 	bne	r3,zero,8111c34c <__reset+0xfb0fc34c>
8111c4f0:	003f9006 	br	8111c334 <__reset+0xfb0fc334>
8111c4f4:	903fdd1e 	bne	r18,zero,8111c46c <__reset+0xfb0fc46c>
8111c4f8:	a805883a 	mov	r2,r21
8111c4fc:	003fb206 	br	8111c3c8 <__reset+0xfb0fc3c8>

8111c500 <fread>:
8111c500:	defffe04 	addi	sp,sp,-8
8111c504:	00a04534 	movhi	r2,33044
8111c508:	de00012e 	bgeu	sp,et,8111c510 <fread+0x10>
8111c50c:	003b68fa 	trap	3
8111c510:	1086aa04 	addi	r2,r2,6824
8111c514:	d9c00015 	stw	r7,0(sp)
8111c518:	300f883a 	mov	r7,r6
8111c51c:	280d883a 	mov	r6,r5
8111c520:	200b883a 	mov	r5,r4
8111c524:	11000017 	ldw	r4,0(r2)
8111c528:	dfc00115 	stw	ra,4(sp)
8111c52c:	111c2cc0 	call	8111c2cc <_fread_r>
8111c530:	dfc00117 	ldw	ra,4(sp)
8111c534:	dec00204 	addi	sp,sp,8
8111c538:	f800283a 	ret

8111c53c <_malloc_trim_r>:
8111c53c:	defffb04 	addi	sp,sp,-20
8111c540:	de00012e 	bgeu	sp,et,8111c548 <_malloc_trim_r+0xc>
8111c544:	003b68fa 	trap	3
8111c548:	dcc00315 	stw	r19,12(sp)
8111c54c:	04e04534 	movhi	r19,33044
8111c550:	dc800215 	stw	r18,8(sp)
8111c554:	dc400115 	stw	r17,4(sp)
8111c558:	dc000015 	stw	r16,0(sp)
8111c55c:	dfc00415 	stw	ra,16(sp)
8111c560:	2821883a 	mov	r16,r5
8111c564:	9cc08f04 	addi	r19,r19,572
8111c568:	2025883a 	mov	r18,r4
8111c56c:	1128fa00 	call	81128fa0 <__malloc_lock>
8111c570:	98800217 	ldw	r2,8(r19)
8111c574:	14400117 	ldw	r17,4(r2)
8111c578:	00bfff04 	movi	r2,-4
8111c57c:	88a2703a 	and	r17,r17,r2
8111c580:	8c21c83a 	sub	r16,r17,r16
8111c584:	8403fbc4 	addi	r16,r16,4079
8111c588:	8020d33a 	srli	r16,r16,12
8111c58c:	0083ffc4 	movi	r2,4095
8111c590:	843fffc4 	addi	r16,r16,-1
8111c594:	8020933a 	slli	r16,r16,12
8111c598:	1400060e 	bge	r2,r16,8111c5b4 <_malloc_trim_r+0x78>
8111c59c:	000b883a 	mov	r5,zero
8111c5a0:	9009883a 	mov	r4,r18
8111c5a4:	1113d100 	call	81113d10 <_sbrk_r>
8111c5a8:	98c00217 	ldw	r3,8(r19)
8111c5ac:	1c47883a 	add	r3,r3,r17
8111c5b0:	10c00a26 	beq	r2,r3,8111c5dc <_malloc_trim_r+0xa0>
8111c5b4:	9009883a 	mov	r4,r18
8111c5b8:	11290c80 	call	811290c8 <__malloc_unlock>
8111c5bc:	0005883a 	mov	r2,zero
8111c5c0:	dfc00417 	ldw	ra,16(sp)
8111c5c4:	dcc00317 	ldw	r19,12(sp)
8111c5c8:	dc800217 	ldw	r18,8(sp)
8111c5cc:	dc400117 	ldw	r17,4(sp)
8111c5d0:	dc000017 	ldw	r16,0(sp)
8111c5d4:	dec00504 	addi	sp,sp,20
8111c5d8:	f800283a 	ret
8111c5dc:	040bc83a 	sub	r5,zero,r16
8111c5e0:	9009883a 	mov	r4,r18
8111c5e4:	1113d100 	call	81113d10 <_sbrk_r>
8111c5e8:	00ffffc4 	movi	r3,-1
8111c5ec:	10c00d26 	beq	r2,r3,8111c624 <_malloc_trim_r+0xe8>
8111c5f0:	00e04534 	movhi	r3,33044
8111c5f4:	18c76704 	addi	r3,r3,7580
8111c5f8:	18800017 	ldw	r2,0(r3)
8111c5fc:	99000217 	ldw	r4,8(r19)
8111c600:	8c23c83a 	sub	r17,r17,r16
8111c604:	8c400054 	ori	r17,r17,1
8111c608:	1421c83a 	sub	r16,r2,r16
8111c60c:	24400115 	stw	r17,4(r4)
8111c610:	9009883a 	mov	r4,r18
8111c614:	1c000015 	stw	r16,0(r3)
8111c618:	11290c80 	call	811290c8 <__malloc_unlock>
8111c61c:	00800044 	movi	r2,1
8111c620:	003fe706 	br	8111c5c0 <__reset+0xfb0fc5c0>
8111c624:	000b883a 	mov	r5,zero
8111c628:	9009883a 	mov	r4,r18
8111c62c:	1113d100 	call	81113d10 <_sbrk_r>
8111c630:	99000217 	ldw	r4,8(r19)
8111c634:	014003c4 	movi	r5,15
8111c638:	1107c83a 	sub	r3,r2,r4
8111c63c:	28ffdd0e 	bge	r5,r3,8111c5b4 <__reset+0xfb0fc5b4>
8111c640:	01604534 	movhi	r5,33044
8111c644:	2946ab04 	addi	r5,r5,6828
8111c648:	29400017 	ldw	r5,0(r5)
8111c64c:	18c00054 	ori	r3,r3,1
8111c650:	20c00115 	stw	r3,4(r4)
8111c654:	00e04534 	movhi	r3,33044
8111c658:	1145c83a 	sub	r2,r2,r5
8111c65c:	18c76704 	addi	r3,r3,7580
8111c660:	18800015 	stw	r2,0(r3)
8111c664:	003fd306 	br	8111c5b4 <__reset+0xfb0fc5b4>

8111c668 <_free_r>:
8111c668:	28004326 	beq	r5,zero,8111c778 <_free_r+0x110>
8111c66c:	defffd04 	addi	sp,sp,-12
8111c670:	de00012e 	bgeu	sp,et,8111c678 <_free_r+0x10>
8111c674:	003b68fa 	trap	3
8111c678:	dc400115 	stw	r17,4(sp)
8111c67c:	dc000015 	stw	r16,0(sp)
8111c680:	2023883a 	mov	r17,r4
8111c684:	2821883a 	mov	r16,r5
8111c688:	dfc00215 	stw	ra,8(sp)
8111c68c:	1128fa00 	call	81128fa0 <__malloc_lock>
8111c690:	81ffff17 	ldw	r7,-4(r16)
8111c694:	00bfff84 	movi	r2,-2
8111c698:	01204534 	movhi	r4,33044
8111c69c:	81bffe04 	addi	r6,r16,-8
8111c6a0:	3884703a 	and	r2,r7,r2
8111c6a4:	21008f04 	addi	r4,r4,572
8111c6a8:	308b883a 	add	r5,r6,r2
8111c6ac:	2a400117 	ldw	r9,4(r5)
8111c6b0:	22000217 	ldw	r8,8(r4)
8111c6b4:	00ffff04 	movi	r3,-4
8111c6b8:	48c6703a 	and	r3,r9,r3
8111c6bc:	2a005726 	beq	r5,r8,8111c81c <_free_r+0x1b4>
8111c6c0:	28c00115 	stw	r3,4(r5)
8111c6c4:	39c0004c 	andi	r7,r7,1
8111c6c8:	3800091e 	bne	r7,zero,8111c6f0 <_free_r+0x88>
8111c6cc:	823ffe17 	ldw	r8,-8(r16)
8111c6d0:	22400204 	addi	r9,r4,8
8111c6d4:	320dc83a 	sub	r6,r6,r8
8111c6d8:	31c00217 	ldw	r7,8(r6)
8111c6dc:	1205883a 	add	r2,r2,r8
8111c6e0:	3a406526 	beq	r7,r9,8111c878 <_free_r+0x210>
8111c6e4:	32000317 	ldw	r8,12(r6)
8111c6e8:	3a000315 	stw	r8,12(r7)
8111c6ec:	41c00215 	stw	r7,8(r8)
8111c6f0:	28cf883a 	add	r7,r5,r3
8111c6f4:	39c00117 	ldw	r7,4(r7)
8111c6f8:	39c0004c 	andi	r7,r7,1
8111c6fc:	38003a26 	beq	r7,zero,8111c7e8 <_free_r+0x180>
8111c700:	10c00054 	ori	r3,r2,1
8111c704:	30c00115 	stw	r3,4(r6)
8111c708:	3087883a 	add	r3,r6,r2
8111c70c:	18800015 	stw	r2,0(r3)
8111c710:	00c07fc4 	movi	r3,511
8111c714:	18801936 	bltu	r3,r2,8111c77c <_free_r+0x114>
8111c718:	1004d0fa 	srli	r2,r2,3
8111c71c:	01c00044 	movi	r7,1
8111c720:	21400117 	ldw	r5,4(r4)
8111c724:	10c00044 	addi	r3,r2,1
8111c728:	18c7883a 	add	r3,r3,r3
8111c72c:	1005d0ba 	srai	r2,r2,2
8111c730:	18c7883a 	add	r3,r3,r3
8111c734:	18c7883a 	add	r3,r3,r3
8111c738:	1907883a 	add	r3,r3,r4
8111c73c:	3884983a 	sll	r2,r7,r2
8111c740:	19c00017 	ldw	r7,0(r3)
8111c744:	1a3ffe04 	addi	r8,r3,-8
8111c748:	1144b03a 	or	r2,r2,r5
8111c74c:	32000315 	stw	r8,12(r6)
8111c750:	31c00215 	stw	r7,8(r6)
8111c754:	20800115 	stw	r2,4(r4)
8111c758:	19800015 	stw	r6,0(r3)
8111c75c:	39800315 	stw	r6,12(r7)
8111c760:	8809883a 	mov	r4,r17
8111c764:	dfc00217 	ldw	ra,8(sp)
8111c768:	dc400117 	ldw	r17,4(sp)
8111c76c:	dc000017 	ldw	r16,0(sp)
8111c770:	dec00304 	addi	sp,sp,12
8111c774:	11290c81 	jmpi	811290c8 <__malloc_unlock>
8111c778:	f800283a 	ret
8111c77c:	100ad27a 	srli	r5,r2,9
8111c780:	00c00104 	movi	r3,4
8111c784:	19404a36 	bltu	r3,r5,8111c8b0 <_free_r+0x248>
8111c788:	100ad1ba 	srli	r5,r2,6
8111c78c:	28c00e44 	addi	r3,r5,57
8111c790:	18c7883a 	add	r3,r3,r3
8111c794:	29400e04 	addi	r5,r5,56
8111c798:	18c7883a 	add	r3,r3,r3
8111c79c:	18c7883a 	add	r3,r3,r3
8111c7a0:	1909883a 	add	r4,r3,r4
8111c7a4:	20c00017 	ldw	r3,0(r4)
8111c7a8:	01e04534 	movhi	r7,33044
8111c7ac:	213ffe04 	addi	r4,r4,-8
8111c7b0:	39c08f04 	addi	r7,r7,572
8111c7b4:	20c04426 	beq	r4,r3,8111c8c8 <_free_r+0x260>
8111c7b8:	01ffff04 	movi	r7,-4
8111c7bc:	19400117 	ldw	r5,4(r3)
8111c7c0:	29ca703a 	and	r5,r5,r7
8111c7c4:	1140022e 	bgeu	r2,r5,8111c7d0 <_free_r+0x168>
8111c7c8:	18c00217 	ldw	r3,8(r3)
8111c7cc:	20fffb1e 	bne	r4,r3,8111c7bc <__reset+0xfb0fc7bc>
8111c7d0:	19000317 	ldw	r4,12(r3)
8111c7d4:	31000315 	stw	r4,12(r6)
8111c7d8:	30c00215 	stw	r3,8(r6)
8111c7dc:	21800215 	stw	r6,8(r4)
8111c7e0:	19800315 	stw	r6,12(r3)
8111c7e4:	003fde06 	br	8111c760 <__reset+0xfb0fc760>
8111c7e8:	29c00217 	ldw	r7,8(r5)
8111c7ec:	10c5883a 	add	r2,r2,r3
8111c7f0:	00e04534 	movhi	r3,33044
8111c7f4:	18c09104 	addi	r3,r3,580
8111c7f8:	38c03b26 	beq	r7,r3,8111c8e8 <_free_r+0x280>
8111c7fc:	2a000317 	ldw	r8,12(r5)
8111c800:	11400054 	ori	r5,r2,1
8111c804:	3087883a 	add	r3,r6,r2
8111c808:	3a000315 	stw	r8,12(r7)
8111c80c:	41c00215 	stw	r7,8(r8)
8111c810:	31400115 	stw	r5,4(r6)
8111c814:	18800015 	stw	r2,0(r3)
8111c818:	003fbd06 	br	8111c710 <__reset+0xfb0fc710>
8111c81c:	39c0004c 	andi	r7,r7,1
8111c820:	10c5883a 	add	r2,r2,r3
8111c824:	3800071e 	bne	r7,zero,8111c844 <_free_r+0x1dc>
8111c828:	81fffe17 	ldw	r7,-8(r16)
8111c82c:	31cdc83a 	sub	r6,r6,r7
8111c830:	30c00317 	ldw	r3,12(r6)
8111c834:	31400217 	ldw	r5,8(r6)
8111c838:	11c5883a 	add	r2,r2,r7
8111c83c:	28c00315 	stw	r3,12(r5)
8111c840:	19400215 	stw	r5,8(r3)
8111c844:	10c00054 	ori	r3,r2,1
8111c848:	30c00115 	stw	r3,4(r6)
8111c84c:	00e04534 	movhi	r3,33044
8111c850:	18c6ac04 	addi	r3,r3,6832
8111c854:	18c00017 	ldw	r3,0(r3)
8111c858:	21800215 	stw	r6,8(r4)
8111c85c:	10ffc036 	bltu	r2,r3,8111c760 <__reset+0xfb0fc760>
8111c860:	00a04534 	movhi	r2,33044
8111c864:	10870804 	addi	r2,r2,7200
8111c868:	11400017 	ldw	r5,0(r2)
8111c86c:	8809883a 	mov	r4,r17
8111c870:	111c53c0 	call	8111c53c <_malloc_trim_r>
8111c874:	003fba06 	br	8111c760 <__reset+0xfb0fc760>
8111c878:	28c9883a 	add	r4,r5,r3
8111c87c:	21000117 	ldw	r4,4(r4)
8111c880:	2100004c 	andi	r4,r4,1
8111c884:	2000391e 	bne	r4,zero,8111c96c <_free_r+0x304>
8111c888:	29c00217 	ldw	r7,8(r5)
8111c88c:	29000317 	ldw	r4,12(r5)
8111c890:	1885883a 	add	r2,r3,r2
8111c894:	10c00054 	ori	r3,r2,1
8111c898:	39000315 	stw	r4,12(r7)
8111c89c:	21c00215 	stw	r7,8(r4)
8111c8a0:	30c00115 	stw	r3,4(r6)
8111c8a4:	308d883a 	add	r6,r6,r2
8111c8a8:	30800015 	stw	r2,0(r6)
8111c8ac:	003fac06 	br	8111c760 <__reset+0xfb0fc760>
8111c8b0:	00c00504 	movi	r3,20
8111c8b4:	19401536 	bltu	r3,r5,8111c90c <_free_r+0x2a4>
8111c8b8:	28c01704 	addi	r3,r5,92
8111c8bc:	18c7883a 	add	r3,r3,r3
8111c8c0:	294016c4 	addi	r5,r5,91
8111c8c4:	003fb406 	br	8111c798 <__reset+0xfb0fc798>
8111c8c8:	280bd0ba 	srai	r5,r5,2
8111c8cc:	00c00044 	movi	r3,1
8111c8d0:	38800117 	ldw	r2,4(r7)
8111c8d4:	194a983a 	sll	r5,r3,r5
8111c8d8:	2007883a 	mov	r3,r4
8111c8dc:	2884b03a 	or	r2,r5,r2
8111c8e0:	38800115 	stw	r2,4(r7)
8111c8e4:	003fbb06 	br	8111c7d4 <__reset+0xfb0fc7d4>
8111c8e8:	21800515 	stw	r6,20(r4)
8111c8ec:	21800415 	stw	r6,16(r4)
8111c8f0:	10c00054 	ori	r3,r2,1
8111c8f4:	31c00315 	stw	r7,12(r6)
8111c8f8:	31c00215 	stw	r7,8(r6)
8111c8fc:	30c00115 	stw	r3,4(r6)
8111c900:	308d883a 	add	r6,r6,r2
8111c904:	30800015 	stw	r2,0(r6)
8111c908:	003f9506 	br	8111c760 <__reset+0xfb0fc760>
8111c90c:	00c01504 	movi	r3,84
8111c910:	19400536 	bltu	r3,r5,8111c928 <_free_r+0x2c0>
8111c914:	100ad33a 	srli	r5,r2,12
8111c918:	28c01bc4 	addi	r3,r5,111
8111c91c:	18c7883a 	add	r3,r3,r3
8111c920:	29401b84 	addi	r5,r5,110
8111c924:	003f9c06 	br	8111c798 <__reset+0xfb0fc798>
8111c928:	00c05504 	movi	r3,340
8111c92c:	19400536 	bltu	r3,r5,8111c944 <_free_r+0x2dc>
8111c930:	100ad3fa 	srli	r5,r2,15
8111c934:	28c01e04 	addi	r3,r5,120
8111c938:	18c7883a 	add	r3,r3,r3
8111c93c:	29401dc4 	addi	r5,r5,119
8111c940:	003f9506 	br	8111c798 <__reset+0xfb0fc798>
8111c944:	00c15504 	movi	r3,1364
8111c948:	19400536 	bltu	r3,r5,8111c960 <_free_r+0x2f8>
8111c94c:	100ad4ba 	srli	r5,r2,18
8111c950:	28c01f44 	addi	r3,r5,125
8111c954:	18c7883a 	add	r3,r3,r3
8111c958:	29401f04 	addi	r5,r5,124
8111c95c:	003f8e06 	br	8111c798 <__reset+0xfb0fc798>
8111c960:	00c03f84 	movi	r3,254
8111c964:	01401f84 	movi	r5,126
8111c968:	003f8b06 	br	8111c798 <__reset+0xfb0fc798>
8111c96c:	10c00054 	ori	r3,r2,1
8111c970:	30c00115 	stw	r3,4(r6)
8111c974:	308d883a 	add	r6,r6,r2
8111c978:	30800015 	stw	r2,0(r6)
8111c97c:	003f7806 	br	8111c760 <__reset+0xfb0fc760>

8111c980 <__sfvwrite_r>:
8111c980:	30800217 	ldw	r2,8(r6)
8111c984:	10006926 	beq	r2,zero,8111cb2c <__sfvwrite_r+0x1ac>
8111c988:	defff404 	addi	sp,sp,-48
8111c98c:	de00012e 	bgeu	sp,et,8111c994 <__sfvwrite_r+0x14>
8111c990:	003b68fa 	trap	3
8111c994:	28c0030b 	ldhu	r3,12(r5)
8111c998:	dd400715 	stw	r21,28(sp)
8111c99c:	dd000615 	stw	r20,24(sp)
8111c9a0:	dc000215 	stw	r16,8(sp)
8111c9a4:	dfc00b15 	stw	ra,44(sp)
8111c9a8:	df000a15 	stw	fp,40(sp)
8111c9ac:	ddc00915 	stw	r23,36(sp)
8111c9b0:	dd800815 	stw	r22,32(sp)
8111c9b4:	dcc00515 	stw	r19,20(sp)
8111c9b8:	dc800415 	stw	r18,16(sp)
8111c9bc:	dc400315 	stw	r17,12(sp)
8111c9c0:	1880020c 	andi	r2,r3,8
8111c9c4:	2821883a 	mov	r16,r5
8111c9c8:	202b883a 	mov	r21,r4
8111c9cc:	3029883a 	mov	r20,r6
8111c9d0:	10002726 	beq	r2,zero,8111ca70 <__sfvwrite_r+0xf0>
8111c9d4:	28800417 	ldw	r2,16(r5)
8111c9d8:	10002526 	beq	r2,zero,8111ca70 <__sfvwrite_r+0xf0>
8111c9dc:	1880008c 	andi	r2,r3,2
8111c9e0:	a4400017 	ldw	r17,0(r20)
8111c9e4:	10002a26 	beq	r2,zero,8111ca90 <__sfvwrite_r+0x110>
8111c9e8:	05a00034 	movhi	r22,32768
8111c9ec:	0027883a 	mov	r19,zero
8111c9f0:	0025883a 	mov	r18,zero
8111c9f4:	b5bf0004 	addi	r22,r22,-1024
8111c9f8:	980d883a 	mov	r6,r19
8111c9fc:	a809883a 	mov	r4,r21
8111ca00:	90004626 	beq	r18,zero,8111cb1c <__sfvwrite_r+0x19c>
8111ca04:	900f883a 	mov	r7,r18
8111ca08:	b480022e 	bgeu	r22,r18,8111ca14 <__sfvwrite_r+0x94>
8111ca0c:	01e00034 	movhi	r7,32768
8111ca10:	39ff0004 	addi	r7,r7,-1024
8111ca14:	80800917 	ldw	r2,36(r16)
8111ca18:	81400717 	ldw	r5,28(r16)
8111ca1c:	103ee83a 	callr	r2
8111ca20:	0080570e 	bge	zero,r2,8111cb80 <__sfvwrite_r+0x200>
8111ca24:	a0c00217 	ldw	r3,8(r20)
8111ca28:	98a7883a 	add	r19,r19,r2
8111ca2c:	90a5c83a 	sub	r18,r18,r2
8111ca30:	1885c83a 	sub	r2,r3,r2
8111ca34:	a0800215 	stw	r2,8(r20)
8111ca38:	103fef1e 	bne	r2,zero,8111c9f8 <__reset+0xfb0fc9f8>
8111ca3c:	0005883a 	mov	r2,zero
8111ca40:	dfc00b17 	ldw	ra,44(sp)
8111ca44:	df000a17 	ldw	fp,40(sp)
8111ca48:	ddc00917 	ldw	r23,36(sp)
8111ca4c:	dd800817 	ldw	r22,32(sp)
8111ca50:	dd400717 	ldw	r21,28(sp)
8111ca54:	dd000617 	ldw	r20,24(sp)
8111ca58:	dcc00517 	ldw	r19,20(sp)
8111ca5c:	dc800417 	ldw	r18,16(sp)
8111ca60:	dc400317 	ldw	r17,12(sp)
8111ca64:	dc000217 	ldw	r16,8(sp)
8111ca68:	dec00c04 	addi	sp,sp,48
8111ca6c:	f800283a 	ret
8111ca70:	800b883a 	mov	r5,r16
8111ca74:	a809883a 	mov	r4,r21
8111ca78:	111a1600 	call	8111a160 <__swsetup_r>
8111ca7c:	1000eb1e 	bne	r2,zero,8111ce2c <__sfvwrite_r+0x4ac>
8111ca80:	80c0030b 	ldhu	r3,12(r16)
8111ca84:	a4400017 	ldw	r17,0(r20)
8111ca88:	1880008c 	andi	r2,r3,2
8111ca8c:	103fd61e 	bne	r2,zero,8111c9e8 <__reset+0xfb0fc9e8>
8111ca90:	1880004c 	andi	r2,r3,1
8111ca94:	10003f1e 	bne	r2,zero,8111cb94 <__sfvwrite_r+0x214>
8111ca98:	0039883a 	mov	fp,zero
8111ca9c:	0025883a 	mov	r18,zero
8111caa0:	90001a26 	beq	r18,zero,8111cb0c <__sfvwrite_r+0x18c>
8111caa4:	1880800c 	andi	r2,r3,512
8111caa8:	84c00217 	ldw	r19,8(r16)
8111caac:	10002126 	beq	r2,zero,8111cb34 <__sfvwrite_r+0x1b4>
8111cab0:	982f883a 	mov	r23,r19
8111cab4:	94c09336 	bltu	r18,r19,8111cd04 <__sfvwrite_r+0x384>
8111cab8:	1881200c 	andi	r2,r3,1152
8111cabc:	10009e1e 	bne	r2,zero,8111cd38 <__sfvwrite_r+0x3b8>
8111cac0:	81000017 	ldw	r4,0(r16)
8111cac4:	b80d883a 	mov	r6,r23
8111cac8:	e00b883a 	mov	r5,fp
8111cacc:	111d4dc0 	call	8111d4dc <memmove>
8111cad0:	80c00217 	ldw	r3,8(r16)
8111cad4:	81000017 	ldw	r4,0(r16)
8111cad8:	9005883a 	mov	r2,r18
8111cadc:	1ce7c83a 	sub	r19,r3,r19
8111cae0:	25cf883a 	add	r7,r4,r23
8111cae4:	84c00215 	stw	r19,8(r16)
8111cae8:	81c00015 	stw	r7,0(r16)
8111caec:	a0c00217 	ldw	r3,8(r20)
8111caf0:	e0b9883a 	add	fp,fp,r2
8111caf4:	90a5c83a 	sub	r18,r18,r2
8111caf8:	18a7c83a 	sub	r19,r3,r2
8111cafc:	a4c00215 	stw	r19,8(r20)
8111cb00:	983fce26 	beq	r19,zero,8111ca3c <__reset+0xfb0fca3c>
8111cb04:	80c0030b 	ldhu	r3,12(r16)
8111cb08:	903fe61e 	bne	r18,zero,8111caa4 <__reset+0xfb0fcaa4>
8111cb0c:	8f000017 	ldw	fp,0(r17)
8111cb10:	8c800117 	ldw	r18,4(r17)
8111cb14:	8c400204 	addi	r17,r17,8
8111cb18:	003fe106 	br	8111caa0 <__reset+0xfb0fcaa0>
8111cb1c:	8cc00017 	ldw	r19,0(r17)
8111cb20:	8c800117 	ldw	r18,4(r17)
8111cb24:	8c400204 	addi	r17,r17,8
8111cb28:	003fb306 	br	8111c9f8 <__reset+0xfb0fc9f8>
8111cb2c:	0005883a 	mov	r2,zero
8111cb30:	f800283a 	ret
8111cb34:	81000017 	ldw	r4,0(r16)
8111cb38:	80800417 	ldw	r2,16(r16)
8111cb3c:	11005736 	bltu	r2,r4,8111cc9c <__sfvwrite_r+0x31c>
8111cb40:	85c00517 	ldw	r23,20(r16)
8111cb44:	95c05536 	bltu	r18,r23,8111cc9c <__sfvwrite_r+0x31c>
8111cb48:	00a00034 	movhi	r2,32768
8111cb4c:	10bfffc4 	addi	r2,r2,-1
8111cb50:	9009883a 	mov	r4,r18
8111cb54:	1480012e 	bgeu	r2,r18,8111cb5c <__sfvwrite_r+0x1dc>
8111cb58:	1009883a 	mov	r4,r2
8111cb5c:	b80b883a 	mov	r5,r23
8111cb60:	1125a580 	call	81125a58 <__divsi3>
8111cb64:	15cf383a 	mul	r7,r2,r23
8111cb68:	81400717 	ldw	r5,28(r16)
8111cb6c:	80800917 	ldw	r2,36(r16)
8111cb70:	e00d883a 	mov	r6,fp
8111cb74:	a809883a 	mov	r4,r21
8111cb78:	103ee83a 	callr	r2
8111cb7c:	00bfdb16 	blt	zero,r2,8111caec <__reset+0xfb0fcaec>
8111cb80:	8080030b 	ldhu	r2,12(r16)
8111cb84:	10801014 	ori	r2,r2,64
8111cb88:	8080030d 	sth	r2,12(r16)
8111cb8c:	00bfffc4 	movi	r2,-1
8111cb90:	003fab06 	br	8111ca40 <__reset+0xfb0fca40>
8111cb94:	0027883a 	mov	r19,zero
8111cb98:	0011883a 	mov	r8,zero
8111cb9c:	0039883a 	mov	fp,zero
8111cba0:	0025883a 	mov	r18,zero
8111cba4:	90001f26 	beq	r18,zero,8111cc24 <__sfvwrite_r+0x2a4>
8111cba8:	40005a26 	beq	r8,zero,8111cd14 <__sfvwrite_r+0x394>
8111cbac:	982d883a 	mov	r22,r19
8111cbb0:	94c0012e 	bgeu	r18,r19,8111cbb8 <__sfvwrite_r+0x238>
8111cbb4:	902d883a 	mov	r22,r18
8111cbb8:	81000017 	ldw	r4,0(r16)
8111cbbc:	80800417 	ldw	r2,16(r16)
8111cbc0:	b02f883a 	mov	r23,r22
8111cbc4:	81c00517 	ldw	r7,20(r16)
8111cbc8:	1100032e 	bgeu	r2,r4,8111cbd8 <__sfvwrite_r+0x258>
8111cbcc:	80c00217 	ldw	r3,8(r16)
8111cbd0:	38c7883a 	add	r3,r7,r3
8111cbd4:	1d801816 	blt	r3,r22,8111cc38 <__sfvwrite_r+0x2b8>
8111cbd8:	b1c03e16 	blt	r22,r7,8111ccd4 <__sfvwrite_r+0x354>
8111cbdc:	80800917 	ldw	r2,36(r16)
8111cbe0:	81400717 	ldw	r5,28(r16)
8111cbe4:	e00d883a 	mov	r6,fp
8111cbe8:	da000115 	stw	r8,4(sp)
8111cbec:	a809883a 	mov	r4,r21
8111cbf0:	103ee83a 	callr	r2
8111cbf4:	102f883a 	mov	r23,r2
8111cbf8:	da000117 	ldw	r8,4(sp)
8111cbfc:	00bfe00e 	bge	zero,r2,8111cb80 <__reset+0xfb0fcb80>
8111cc00:	9de7c83a 	sub	r19,r19,r23
8111cc04:	98001f26 	beq	r19,zero,8111cc84 <__sfvwrite_r+0x304>
8111cc08:	a0800217 	ldw	r2,8(r20)
8111cc0c:	e5f9883a 	add	fp,fp,r23
8111cc10:	95e5c83a 	sub	r18,r18,r23
8111cc14:	15efc83a 	sub	r23,r2,r23
8111cc18:	a5c00215 	stw	r23,8(r20)
8111cc1c:	b83f8726 	beq	r23,zero,8111ca3c <__reset+0xfb0fca3c>
8111cc20:	903fe11e 	bne	r18,zero,8111cba8 <__reset+0xfb0fcba8>
8111cc24:	8f000017 	ldw	fp,0(r17)
8111cc28:	8c800117 	ldw	r18,4(r17)
8111cc2c:	0011883a 	mov	r8,zero
8111cc30:	8c400204 	addi	r17,r17,8
8111cc34:	003fdb06 	br	8111cba4 <__reset+0xfb0fcba4>
8111cc38:	180d883a 	mov	r6,r3
8111cc3c:	e00b883a 	mov	r5,fp
8111cc40:	da000115 	stw	r8,4(sp)
8111cc44:	d8c00015 	stw	r3,0(sp)
8111cc48:	111d4dc0 	call	8111d4dc <memmove>
8111cc4c:	d8c00017 	ldw	r3,0(sp)
8111cc50:	80800017 	ldw	r2,0(r16)
8111cc54:	800b883a 	mov	r5,r16
8111cc58:	a809883a 	mov	r4,r21
8111cc5c:	10c5883a 	add	r2,r2,r3
8111cc60:	80800015 	stw	r2,0(r16)
8111cc64:	d8c00015 	stw	r3,0(sp)
8111cc68:	111bdd40 	call	8111bdd4 <_fflush_r>
8111cc6c:	d8c00017 	ldw	r3,0(sp)
8111cc70:	da000117 	ldw	r8,4(sp)
8111cc74:	103fc21e 	bne	r2,zero,8111cb80 <__reset+0xfb0fcb80>
8111cc78:	182f883a 	mov	r23,r3
8111cc7c:	9de7c83a 	sub	r19,r19,r23
8111cc80:	983fe11e 	bne	r19,zero,8111cc08 <__reset+0xfb0fcc08>
8111cc84:	800b883a 	mov	r5,r16
8111cc88:	a809883a 	mov	r4,r21
8111cc8c:	111bdd40 	call	8111bdd4 <_fflush_r>
8111cc90:	103fbb1e 	bne	r2,zero,8111cb80 <__reset+0xfb0fcb80>
8111cc94:	0011883a 	mov	r8,zero
8111cc98:	003fdb06 	br	8111cc08 <__reset+0xfb0fcc08>
8111cc9c:	94c0012e 	bgeu	r18,r19,8111cca4 <__sfvwrite_r+0x324>
8111cca0:	9027883a 	mov	r19,r18
8111cca4:	980d883a 	mov	r6,r19
8111cca8:	e00b883a 	mov	r5,fp
8111ccac:	111d4dc0 	call	8111d4dc <memmove>
8111ccb0:	80800217 	ldw	r2,8(r16)
8111ccb4:	80c00017 	ldw	r3,0(r16)
8111ccb8:	14c5c83a 	sub	r2,r2,r19
8111ccbc:	1cc7883a 	add	r3,r3,r19
8111ccc0:	80800215 	stw	r2,8(r16)
8111ccc4:	80c00015 	stw	r3,0(r16)
8111ccc8:	10004326 	beq	r2,zero,8111cdd8 <__sfvwrite_r+0x458>
8111cccc:	9805883a 	mov	r2,r19
8111ccd0:	003f8606 	br	8111caec <__reset+0xfb0fcaec>
8111ccd4:	b00d883a 	mov	r6,r22
8111ccd8:	e00b883a 	mov	r5,fp
8111ccdc:	da000115 	stw	r8,4(sp)
8111cce0:	111d4dc0 	call	8111d4dc <memmove>
8111cce4:	80800217 	ldw	r2,8(r16)
8111cce8:	80c00017 	ldw	r3,0(r16)
8111ccec:	da000117 	ldw	r8,4(sp)
8111ccf0:	1585c83a 	sub	r2,r2,r22
8111ccf4:	1dad883a 	add	r22,r3,r22
8111ccf8:	80800215 	stw	r2,8(r16)
8111ccfc:	85800015 	stw	r22,0(r16)
8111cd00:	003fbf06 	br	8111cc00 <__reset+0xfb0fcc00>
8111cd04:	81000017 	ldw	r4,0(r16)
8111cd08:	9027883a 	mov	r19,r18
8111cd0c:	902f883a 	mov	r23,r18
8111cd10:	003f6c06 	br	8111cac4 <__reset+0xfb0fcac4>
8111cd14:	900d883a 	mov	r6,r18
8111cd18:	01400284 	movi	r5,10
8111cd1c:	e009883a 	mov	r4,fp
8111cd20:	111d3f80 	call	8111d3f8 <memchr>
8111cd24:	10003e26 	beq	r2,zero,8111ce20 <__sfvwrite_r+0x4a0>
8111cd28:	10800044 	addi	r2,r2,1
8111cd2c:	1727c83a 	sub	r19,r2,fp
8111cd30:	02000044 	movi	r8,1
8111cd34:	003f9d06 	br	8111cbac <__reset+0xfb0fcbac>
8111cd38:	80800517 	ldw	r2,20(r16)
8111cd3c:	81400417 	ldw	r5,16(r16)
8111cd40:	81c00017 	ldw	r7,0(r16)
8111cd44:	10a7883a 	add	r19,r2,r2
8111cd48:	9885883a 	add	r2,r19,r2
8111cd4c:	1026d7fa 	srli	r19,r2,31
8111cd50:	396dc83a 	sub	r22,r7,r5
8111cd54:	b1000044 	addi	r4,r22,1
8111cd58:	9885883a 	add	r2,r19,r2
8111cd5c:	1027d07a 	srai	r19,r2,1
8111cd60:	2485883a 	add	r2,r4,r18
8111cd64:	980d883a 	mov	r6,r19
8111cd68:	9880022e 	bgeu	r19,r2,8111cd74 <__sfvwrite_r+0x3f4>
8111cd6c:	1027883a 	mov	r19,r2
8111cd70:	100d883a 	mov	r6,r2
8111cd74:	18c1000c 	andi	r3,r3,1024
8111cd78:	18001c26 	beq	r3,zero,8111cdec <__sfvwrite_r+0x46c>
8111cd7c:	300b883a 	mov	r5,r6
8111cd80:	a809883a 	mov	r4,r21
8111cd84:	1112ecc0 	call	81112ecc <_malloc_r>
8111cd88:	102f883a 	mov	r23,r2
8111cd8c:	10002926 	beq	r2,zero,8111ce34 <__sfvwrite_r+0x4b4>
8111cd90:	81400417 	ldw	r5,16(r16)
8111cd94:	b00d883a 	mov	r6,r22
8111cd98:	1009883a 	mov	r4,r2
8111cd9c:	11136e00 	call	811136e0 <memcpy>
8111cda0:	8080030b 	ldhu	r2,12(r16)
8111cda4:	00fedfc4 	movi	r3,-1153
8111cda8:	10c4703a 	and	r2,r2,r3
8111cdac:	10802014 	ori	r2,r2,128
8111cdb0:	8080030d 	sth	r2,12(r16)
8111cdb4:	bd89883a 	add	r4,r23,r22
8111cdb8:	9d8fc83a 	sub	r7,r19,r22
8111cdbc:	85c00415 	stw	r23,16(r16)
8111cdc0:	84c00515 	stw	r19,20(r16)
8111cdc4:	81000015 	stw	r4,0(r16)
8111cdc8:	9027883a 	mov	r19,r18
8111cdcc:	81c00215 	stw	r7,8(r16)
8111cdd0:	902f883a 	mov	r23,r18
8111cdd4:	003f3b06 	br	8111cac4 <__reset+0xfb0fcac4>
8111cdd8:	800b883a 	mov	r5,r16
8111cddc:	a809883a 	mov	r4,r21
8111cde0:	111bdd40 	call	8111bdd4 <_fflush_r>
8111cde4:	103fb926 	beq	r2,zero,8111cccc <__reset+0xfb0fcccc>
8111cde8:	003f6506 	br	8111cb80 <__reset+0xfb0fcb80>
8111cdec:	a809883a 	mov	r4,r21
8111cdf0:	111e6fc0 	call	8111e6fc <_realloc_r>
8111cdf4:	102f883a 	mov	r23,r2
8111cdf8:	103fee1e 	bne	r2,zero,8111cdb4 <__reset+0xfb0fcdb4>
8111cdfc:	81400417 	ldw	r5,16(r16)
8111ce00:	a809883a 	mov	r4,r21
8111ce04:	111c6680 	call	8111c668 <_free_r>
8111ce08:	8080030b 	ldhu	r2,12(r16)
8111ce0c:	00ffdfc4 	movi	r3,-129
8111ce10:	1884703a 	and	r2,r3,r2
8111ce14:	00c00304 	movi	r3,12
8111ce18:	a8c00015 	stw	r3,0(r21)
8111ce1c:	003f5906 	br	8111cb84 <__reset+0xfb0fcb84>
8111ce20:	94c00044 	addi	r19,r18,1
8111ce24:	02000044 	movi	r8,1
8111ce28:	003f6006 	br	8111cbac <__reset+0xfb0fcbac>
8111ce2c:	00bfffc4 	movi	r2,-1
8111ce30:	003f0306 	br	8111ca40 <__reset+0xfb0fca40>
8111ce34:	00800304 	movi	r2,12
8111ce38:	a8800015 	stw	r2,0(r21)
8111ce3c:	8080030b 	ldhu	r2,12(r16)
8111ce40:	003f5006 	br	8111cb84 <__reset+0xfb0fcb84>

8111ce44 <_fwalk>:
8111ce44:	defff704 	addi	sp,sp,-36
8111ce48:	de00012e 	bgeu	sp,et,8111ce50 <_fwalk+0xc>
8111ce4c:	003b68fa 	trap	3
8111ce50:	dd000415 	stw	r20,16(sp)
8111ce54:	dfc00815 	stw	ra,32(sp)
8111ce58:	ddc00715 	stw	r23,28(sp)
8111ce5c:	dd800615 	stw	r22,24(sp)
8111ce60:	dd400515 	stw	r21,20(sp)
8111ce64:	dcc00315 	stw	r19,12(sp)
8111ce68:	dc800215 	stw	r18,8(sp)
8111ce6c:	dc400115 	stw	r17,4(sp)
8111ce70:	dc000015 	stw	r16,0(sp)
8111ce74:	2500b804 	addi	r20,r4,736
8111ce78:	a0002326 	beq	r20,zero,8111cf08 <_fwalk+0xc4>
8111ce7c:	282b883a 	mov	r21,r5
8111ce80:	002f883a 	mov	r23,zero
8111ce84:	05800044 	movi	r22,1
8111ce88:	04ffffc4 	movi	r19,-1
8111ce8c:	a4400117 	ldw	r17,4(r20)
8111ce90:	a4800217 	ldw	r18,8(r20)
8111ce94:	8c7fffc4 	addi	r17,r17,-1
8111ce98:	88000d16 	blt	r17,zero,8111ced0 <_fwalk+0x8c>
8111ce9c:	94000304 	addi	r16,r18,12
8111cea0:	94800384 	addi	r18,r18,14
8111cea4:	8080000b 	ldhu	r2,0(r16)
8111cea8:	8c7fffc4 	addi	r17,r17,-1
8111ceac:	813ffd04 	addi	r4,r16,-12
8111ceb0:	b080042e 	bgeu	r22,r2,8111cec4 <_fwalk+0x80>
8111ceb4:	9080000f 	ldh	r2,0(r18)
8111ceb8:	14c00226 	beq	r2,r19,8111cec4 <_fwalk+0x80>
8111cebc:	a83ee83a 	callr	r21
8111cec0:	b8aeb03a 	or	r23,r23,r2
8111cec4:	84001a04 	addi	r16,r16,104
8111cec8:	94801a04 	addi	r18,r18,104
8111cecc:	8cfff51e 	bne	r17,r19,8111cea4 <__reset+0xfb0fcea4>
8111ced0:	a5000017 	ldw	r20,0(r20)
8111ced4:	a03fed1e 	bne	r20,zero,8111ce8c <__reset+0xfb0fce8c>
8111ced8:	b805883a 	mov	r2,r23
8111cedc:	dfc00817 	ldw	ra,32(sp)
8111cee0:	ddc00717 	ldw	r23,28(sp)
8111cee4:	dd800617 	ldw	r22,24(sp)
8111cee8:	dd400517 	ldw	r21,20(sp)
8111ceec:	dd000417 	ldw	r20,16(sp)
8111cef0:	dcc00317 	ldw	r19,12(sp)
8111cef4:	dc800217 	ldw	r18,8(sp)
8111cef8:	dc400117 	ldw	r17,4(sp)
8111cefc:	dc000017 	ldw	r16,0(sp)
8111cf00:	dec00904 	addi	sp,sp,36
8111cf04:	f800283a 	ret
8111cf08:	002f883a 	mov	r23,zero
8111cf0c:	003ff206 	br	8111ced8 <__reset+0xfb0fced8>

8111cf10 <_fwalk_reent>:
8111cf10:	defff704 	addi	sp,sp,-36
8111cf14:	de00012e 	bgeu	sp,et,8111cf1c <_fwalk_reent+0xc>
8111cf18:	003b68fa 	trap	3
8111cf1c:	dd000415 	stw	r20,16(sp)
8111cf20:	dfc00815 	stw	ra,32(sp)
8111cf24:	ddc00715 	stw	r23,28(sp)
8111cf28:	dd800615 	stw	r22,24(sp)
8111cf2c:	dd400515 	stw	r21,20(sp)
8111cf30:	dcc00315 	stw	r19,12(sp)
8111cf34:	dc800215 	stw	r18,8(sp)
8111cf38:	dc400115 	stw	r17,4(sp)
8111cf3c:	dc000015 	stw	r16,0(sp)
8111cf40:	2500b804 	addi	r20,r4,736
8111cf44:	a0002326 	beq	r20,zero,8111cfd4 <_fwalk_reent+0xc4>
8111cf48:	282b883a 	mov	r21,r5
8111cf4c:	2027883a 	mov	r19,r4
8111cf50:	002f883a 	mov	r23,zero
8111cf54:	05800044 	movi	r22,1
8111cf58:	04bfffc4 	movi	r18,-1
8111cf5c:	a4400117 	ldw	r17,4(r20)
8111cf60:	a4000217 	ldw	r16,8(r20)
8111cf64:	8c7fffc4 	addi	r17,r17,-1
8111cf68:	88000c16 	blt	r17,zero,8111cf9c <_fwalk_reent+0x8c>
8111cf6c:	84000304 	addi	r16,r16,12
8111cf70:	8080000b 	ldhu	r2,0(r16)
8111cf74:	8c7fffc4 	addi	r17,r17,-1
8111cf78:	817ffd04 	addi	r5,r16,-12
8111cf7c:	b080052e 	bgeu	r22,r2,8111cf94 <_fwalk_reent+0x84>
8111cf80:	8080008f 	ldh	r2,2(r16)
8111cf84:	9809883a 	mov	r4,r19
8111cf88:	14800226 	beq	r2,r18,8111cf94 <_fwalk_reent+0x84>
8111cf8c:	a83ee83a 	callr	r21
8111cf90:	b8aeb03a 	or	r23,r23,r2
8111cf94:	84001a04 	addi	r16,r16,104
8111cf98:	8cbff51e 	bne	r17,r18,8111cf70 <__reset+0xfb0fcf70>
8111cf9c:	a5000017 	ldw	r20,0(r20)
8111cfa0:	a03fee1e 	bne	r20,zero,8111cf5c <__reset+0xfb0fcf5c>
8111cfa4:	b805883a 	mov	r2,r23
8111cfa8:	dfc00817 	ldw	ra,32(sp)
8111cfac:	ddc00717 	ldw	r23,28(sp)
8111cfb0:	dd800617 	ldw	r22,24(sp)
8111cfb4:	dd400517 	ldw	r21,20(sp)
8111cfb8:	dd000417 	ldw	r20,16(sp)
8111cfbc:	dcc00317 	ldw	r19,12(sp)
8111cfc0:	dc800217 	ldw	r18,8(sp)
8111cfc4:	dc400117 	ldw	r17,4(sp)
8111cfc8:	dc000017 	ldw	r16,0(sp)
8111cfcc:	dec00904 	addi	sp,sp,36
8111cfd0:	f800283a 	ret
8111cfd4:	002f883a 	mov	r23,zero
8111cfd8:	003ff206 	br	8111cfa4 <__reset+0xfb0fcfa4>

8111cfdc <_isatty_r>:
8111cfdc:	defffd04 	addi	sp,sp,-12
8111cfe0:	de00012e 	bgeu	sp,et,8111cfe8 <_isatty_r+0xc>
8111cfe4:	003b68fa 	trap	3
8111cfe8:	dc000015 	stw	r16,0(sp)
8111cfec:	04204534 	movhi	r16,33044
8111cff0:	dc400115 	stw	r17,4(sp)
8111cff4:	84070504 	addi	r16,r16,7188
8111cff8:	2023883a 	mov	r17,r4
8111cffc:	2809883a 	mov	r4,r5
8111d000:	dfc00215 	stw	ra,8(sp)
8111d004:	80000015 	stw	zero,0(r16)
8111d008:	112828c0 	call	8112828c <isatty>
8111d00c:	00ffffc4 	movi	r3,-1
8111d010:	10c00526 	beq	r2,r3,8111d028 <_isatty_r+0x4c>
8111d014:	dfc00217 	ldw	ra,8(sp)
8111d018:	dc400117 	ldw	r17,4(sp)
8111d01c:	dc000017 	ldw	r16,0(sp)
8111d020:	dec00304 	addi	sp,sp,12
8111d024:	f800283a 	ret
8111d028:	80c00017 	ldw	r3,0(r16)
8111d02c:	183ff926 	beq	r3,zero,8111d014 <__reset+0xfb0fd014>
8111d030:	88c00015 	stw	r3,0(r17)
8111d034:	003ff706 	br	8111d014 <__reset+0xfb0fd014>

8111d038 <iswspace>:
8111d038:	00803fc4 	movi	r2,255
8111d03c:	11000836 	bltu	r2,r4,8111d060 <iswspace+0x28>
8111d040:	00a04534 	movhi	r2,33044
8111d044:	1086a804 	addi	r2,r2,6816
8111d048:	10800017 	ldw	r2,0(r2)
8111d04c:	1109883a 	add	r4,r2,r4
8111d050:	20800043 	ldbu	r2,1(r4)
8111d054:	1080020c 	andi	r2,r2,8
8111d058:	10803fcc 	andi	r2,r2,255
8111d05c:	f800283a 	ret
8111d060:	0005883a 	mov	r2,zero
8111d064:	f800283a 	ret

8111d068 <_setlocale_r>:
8111d068:	30001d26 	beq	r6,zero,8111d0e0 <_setlocale_r+0x78>
8111d06c:	01604534 	movhi	r5,33044
8111d070:	defffe04 	addi	sp,sp,-8
8111d074:	297dcf04 	addi	r5,r5,-2244
8111d078:	3009883a 	mov	r4,r6
8111d07c:	de00012e 	bgeu	sp,et,8111d084 <_setlocale_r+0x1c>
8111d080:	003b68fa 	trap	3
8111d084:	dc000015 	stw	r16,0(sp)
8111d088:	dfc00115 	stw	ra,4(sp)
8111d08c:	3021883a 	mov	r16,r6
8111d090:	111edb40 	call	8111edb4 <strcmp>
8111d094:	1000061e 	bne	r2,zero,8111d0b0 <_setlocale_r+0x48>
8111d098:	00a04534 	movhi	r2,33044
8111d09c:	10bd9e04 	addi	r2,r2,-2440
8111d0a0:	dfc00117 	ldw	ra,4(sp)
8111d0a4:	dc000017 	ldw	r16,0(sp)
8111d0a8:	dec00204 	addi	sp,sp,8
8111d0ac:	f800283a 	ret
8111d0b0:	01604534 	movhi	r5,33044
8111d0b4:	297d9e04 	addi	r5,r5,-2440
8111d0b8:	8009883a 	mov	r4,r16
8111d0bc:	111edb40 	call	8111edb4 <strcmp>
8111d0c0:	103ff526 	beq	r2,zero,8111d098 <__reset+0xfb0fd098>
8111d0c4:	01604534 	movhi	r5,33044
8111d0c8:	297da804 	addi	r5,r5,-2400
8111d0cc:	8009883a 	mov	r4,r16
8111d0d0:	111edb40 	call	8111edb4 <strcmp>
8111d0d4:	103ff026 	beq	r2,zero,8111d098 <__reset+0xfb0fd098>
8111d0d8:	0005883a 	mov	r2,zero
8111d0dc:	003ff006 	br	8111d0a0 <__reset+0xfb0fd0a0>
8111d0e0:	00a04534 	movhi	r2,33044
8111d0e4:	10bd9e04 	addi	r2,r2,-2440
8111d0e8:	f800283a 	ret

8111d0ec <__locale_charset>:
8111d0ec:	00a04534 	movhi	r2,33044
8111d0f0:	10819904 	addi	r2,r2,1636
8111d0f4:	f800283a 	ret

8111d0f8 <__locale_mb_cur_max>:
8111d0f8:	00a04534 	movhi	r2,33044
8111d0fc:	1086ad04 	addi	r2,r2,6836
8111d100:	10800017 	ldw	r2,0(r2)
8111d104:	f800283a 	ret

8111d108 <__locale_msgcharset>:
8111d108:	00a04534 	movhi	r2,33044
8111d10c:	10819104 	addi	r2,r2,1604
8111d110:	f800283a 	ret

8111d114 <__locale_cjk_lang>:
8111d114:	0005883a 	mov	r2,zero
8111d118:	f800283a 	ret

8111d11c <_localeconv_r>:
8111d11c:	00a04534 	movhi	r2,33044
8111d120:	1081a104 	addi	r2,r2,1668
8111d124:	f800283a 	ret

8111d128 <setlocale>:
8111d128:	00a04534 	movhi	r2,33044
8111d12c:	1086aa04 	addi	r2,r2,6824
8111d130:	280d883a 	mov	r6,r5
8111d134:	200b883a 	mov	r5,r4
8111d138:	11000017 	ldw	r4,0(r2)
8111d13c:	111d0681 	jmpi	8111d068 <_setlocale_r>

8111d140 <localeconv>:
8111d140:	00a04534 	movhi	r2,33044
8111d144:	1081a104 	addi	r2,r2,1668
8111d148:	f800283a 	ret

8111d14c <_lseek_r>:
8111d14c:	defffd04 	addi	sp,sp,-12
8111d150:	de00012e 	bgeu	sp,et,8111d158 <_lseek_r+0xc>
8111d154:	003b68fa 	trap	3
8111d158:	2805883a 	mov	r2,r5
8111d15c:	dc000015 	stw	r16,0(sp)
8111d160:	04204534 	movhi	r16,33044
8111d164:	dc400115 	stw	r17,4(sp)
8111d168:	300b883a 	mov	r5,r6
8111d16c:	84070504 	addi	r16,r16,7188
8111d170:	2023883a 	mov	r17,r4
8111d174:	380d883a 	mov	r6,r7
8111d178:	1009883a 	mov	r4,r2
8111d17c:	dfc00215 	stw	ra,8(sp)
8111d180:	80000015 	stw	zero,0(r16)
8111d184:	112837c0 	call	8112837c <lseek>
8111d188:	00ffffc4 	movi	r3,-1
8111d18c:	10c00526 	beq	r2,r3,8111d1a4 <_lseek_r+0x58>
8111d190:	dfc00217 	ldw	ra,8(sp)
8111d194:	dc400117 	ldw	r17,4(sp)
8111d198:	dc000017 	ldw	r16,0(sp)
8111d19c:	dec00304 	addi	sp,sp,12
8111d1a0:	f800283a 	ret
8111d1a4:	80c00017 	ldw	r3,0(r16)
8111d1a8:	183ff926 	beq	r3,zero,8111d190 <__reset+0xfb0fd190>
8111d1ac:	88c00015 	stw	r3,0(r17)
8111d1b0:	003ff706 	br	8111d190 <__reset+0xfb0fd190>

8111d1b4 <_mbrtowc_r>:
8111d1b4:	defff704 	addi	sp,sp,-36
8111d1b8:	00a04534 	movhi	r2,33044
8111d1bc:	de00012e 	bgeu	sp,et,8111d1c4 <_mbrtowc_r+0x10>
8111d1c0:	003b68fa 	trap	3
8111d1c4:	1086ae04 	addi	r2,r2,6840
8111d1c8:	dc800715 	stw	r18,28(sp)
8111d1cc:	dc400615 	stw	r17,24(sp)
8111d1d0:	dc000515 	stw	r16,20(sp)
8111d1d4:	dfc00815 	stw	ra,32(sp)
8111d1d8:	2021883a 	mov	r16,r4
8111d1dc:	dc400917 	ldw	r17,36(sp)
8111d1e0:	14800017 	ldw	r18,0(r2)
8111d1e4:	30001626 	beq	r6,zero,8111d240 <_mbrtowc_r+0x8c>
8111d1e8:	d9400215 	stw	r5,8(sp)
8111d1ec:	d9800315 	stw	r6,12(sp)
8111d1f0:	d9c00415 	stw	r7,16(sp)
8111d1f4:	111d0ec0 	call	8111d0ec <__locale_charset>
8111d1f8:	d9c00417 	ldw	r7,16(sp)
8111d1fc:	d9800317 	ldw	r6,12(sp)
8111d200:	d9400217 	ldw	r5,8(sp)
8111d204:	d8800015 	stw	r2,0(sp)
8111d208:	dc400115 	stw	r17,4(sp)
8111d20c:	8009883a 	mov	r4,r16
8111d210:	903ee83a 	callr	r18
8111d214:	00ffffc4 	movi	r3,-1
8111d218:	10c0031e 	bne	r2,r3,8111d228 <_mbrtowc_r+0x74>
8111d21c:	88000015 	stw	zero,0(r17)
8111d220:	00c02284 	movi	r3,138
8111d224:	80c00015 	stw	r3,0(r16)
8111d228:	dfc00817 	ldw	ra,32(sp)
8111d22c:	dc800717 	ldw	r18,28(sp)
8111d230:	dc400617 	ldw	r17,24(sp)
8111d234:	dc000517 	ldw	r16,20(sp)
8111d238:	dec00904 	addi	sp,sp,36
8111d23c:	f800283a 	ret
8111d240:	111d0ec0 	call	8111d0ec <__locale_charset>
8111d244:	01a04534 	movhi	r6,33044
8111d248:	31bda804 	addi	r6,r6,-2400
8111d24c:	dc400115 	stw	r17,4(sp)
8111d250:	d8800015 	stw	r2,0(sp)
8111d254:	01c00044 	movi	r7,1
8111d258:	000b883a 	mov	r5,zero
8111d25c:	8009883a 	mov	r4,r16
8111d260:	903ee83a 	callr	r18
8111d264:	003feb06 	br	8111d214 <__reset+0xfb0fd214>

8111d268 <mbrtowc>:
8111d268:	defff704 	addi	sp,sp,-36
8111d26c:	00a04534 	movhi	r2,33044
8111d270:	de00012e 	bgeu	sp,et,8111d278 <mbrtowc+0x10>
8111d274:	003b68fa 	trap	3
8111d278:	1086aa04 	addi	r2,r2,6824
8111d27c:	dc800415 	stw	r18,16(sp)
8111d280:	dc400315 	stw	r17,12(sp)
8111d284:	dfc00815 	stw	ra,32(sp)
8111d288:	dd400715 	stw	r21,28(sp)
8111d28c:	dd000615 	stw	r20,24(sp)
8111d290:	dcc00515 	stw	r19,20(sp)
8111d294:	dc000215 	stw	r16,8(sp)
8111d298:	3825883a 	mov	r18,r7
8111d29c:	14400017 	ldw	r17,0(r2)
8111d2a0:	28001c26 	beq	r5,zero,8111d314 <mbrtowc+0xac>
8111d2a4:	00a04534 	movhi	r2,33044
8111d2a8:	1086ae04 	addi	r2,r2,6840
8111d2ac:	15400017 	ldw	r21,0(r2)
8111d2b0:	2821883a 	mov	r16,r5
8111d2b4:	2027883a 	mov	r19,r4
8111d2b8:	3029883a 	mov	r20,r6
8111d2bc:	111d0ec0 	call	8111d0ec <__locale_charset>
8111d2c0:	d8800015 	stw	r2,0(sp)
8111d2c4:	dc800115 	stw	r18,4(sp)
8111d2c8:	a00f883a 	mov	r7,r20
8111d2cc:	800d883a 	mov	r6,r16
8111d2d0:	980b883a 	mov	r5,r19
8111d2d4:	8809883a 	mov	r4,r17
8111d2d8:	a83ee83a 	callr	r21
8111d2dc:	00ffffc4 	movi	r3,-1
8111d2e0:	10c0031e 	bne	r2,r3,8111d2f0 <mbrtowc+0x88>
8111d2e4:	90000015 	stw	zero,0(r18)
8111d2e8:	00c02284 	movi	r3,138
8111d2ec:	88c00015 	stw	r3,0(r17)
8111d2f0:	dfc00817 	ldw	ra,32(sp)
8111d2f4:	dd400717 	ldw	r21,28(sp)
8111d2f8:	dd000617 	ldw	r20,24(sp)
8111d2fc:	dcc00517 	ldw	r19,20(sp)
8111d300:	dc800417 	ldw	r18,16(sp)
8111d304:	dc400317 	ldw	r17,12(sp)
8111d308:	dc000217 	ldw	r16,8(sp)
8111d30c:	dec00904 	addi	sp,sp,36
8111d310:	f800283a 	ret
8111d314:	00a04534 	movhi	r2,33044
8111d318:	1086ae04 	addi	r2,r2,6840
8111d31c:	14000017 	ldw	r16,0(r2)
8111d320:	111d0ec0 	call	8111d0ec <__locale_charset>
8111d324:	01a04534 	movhi	r6,33044
8111d328:	31bda804 	addi	r6,r6,-2400
8111d32c:	dc800115 	stw	r18,4(sp)
8111d330:	d8800015 	stw	r2,0(sp)
8111d334:	01c00044 	movi	r7,1
8111d338:	000b883a 	mov	r5,zero
8111d33c:	8809883a 	mov	r4,r17
8111d340:	803ee83a 	callr	r16
8111d344:	003fe506 	br	8111d2dc <__reset+0xfb0fd2dc>

8111d348 <__ascii_mbtowc>:
8111d348:	deffff04 	addi	sp,sp,-4
8111d34c:	de00012e 	bgeu	sp,et,8111d354 <__ascii_mbtowc+0xc>
8111d350:	003b68fa 	trap	3
8111d354:	28000826 	beq	r5,zero,8111d378 <__ascii_mbtowc+0x30>
8111d358:	30000926 	beq	r6,zero,8111d380 <__ascii_mbtowc+0x38>
8111d35c:	38000b26 	beq	r7,zero,8111d38c <__ascii_mbtowc+0x44>
8111d360:	30800003 	ldbu	r2,0(r6)
8111d364:	28800015 	stw	r2,0(r5)
8111d368:	30800003 	ldbu	r2,0(r6)
8111d36c:	1004c03a 	cmpne	r2,r2,zero
8111d370:	dec00104 	addi	sp,sp,4
8111d374:	f800283a 	ret
8111d378:	d80b883a 	mov	r5,sp
8111d37c:	303ff71e 	bne	r6,zero,8111d35c <__reset+0xfb0fd35c>
8111d380:	0005883a 	mov	r2,zero
8111d384:	dec00104 	addi	sp,sp,4
8111d388:	f800283a 	ret
8111d38c:	00bfff84 	movi	r2,-2
8111d390:	003ff706 	br	8111d370 <__reset+0xfb0fd370>

8111d394 <_mbtowc_r>:
8111d394:	00a04534 	movhi	r2,33044
8111d398:	defff804 	addi	sp,sp,-32
8111d39c:	1086ae04 	addi	r2,r2,6840
8111d3a0:	de00012e 	bgeu	sp,et,8111d3a8 <_mbtowc_r+0x14>
8111d3a4:	003b68fa 	trap	3
8111d3a8:	dfc00715 	stw	ra,28(sp)
8111d3ac:	dc000615 	stw	r16,24(sp)
8111d3b0:	14000017 	ldw	r16,0(r2)
8111d3b4:	d9000215 	stw	r4,8(sp)
8111d3b8:	d9400315 	stw	r5,12(sp)
8111d3bc:	d9800415 	stw	r6,16(sp)
8111d3c0:	d9c00515 	stw	r7,20(sp)
8111d3c4:	111d0ec0 	call	8111d0ec <__locale_charset>
8111d3c8:	d8800015 	stw	r2,0(sp)
8111d3cc:	d8800817 	ldw	r2,32(sp)
8111d3d0:	d9c00517 	ldw	r7,20(sp)
8111d3d4:	d9800417 	ldw	r6,16(sp)
8111d3d8:	d9400317 	ldw	r5,12(sp)
8111d3dc:	d9000217 	ldw	r4,8(sp)
8111d3e0:	d8800115 	stw	r2,4(sp)
8111d3e4:	803ee83a 	callr	r16
8111d3e8:	dfc00717 	ldw	ra,28(sp)
8111d3ec:	dc000617 	ldw	r16,24(sp)
8111d3f0:	dec00804 	addi	sp,sp,32
8111d3f4:	f800283a 	ret

8111d3f8 <memchr>:
8111d3f8:	208000cc 	andi	r2,r4,3
8111d3fc:	280f883a 	mov	r7,r5
8111d400:	10003426 	beq	r2,zero,8111d4d4 <memchr+0xdc>
8111d404:	30bfffc4 	addi	r2,r6,-1
8111d408:	30001a26 	beq	r6,zero,8111d474 <memchr+0x7c>
8111d40c:	20c00003 	ldbu	r3,0(r4)
8111d410:	29803fcc 	andi	r6,r5,255
8111d414:	30c0051e 	bne	r6,r3,8111d42c <memchr+0x34>
8111d418:	00001806 	br	8111d47c <memchr+0x84>
8111d41c:	10001526 	beq	r2,zero,8111d474 <memchr+0x7c>
8111d420:	20c00003 	ldbu	r3,0(r4)
8111d424:	10bfffc4 	addi	r2,r2,-1
8111d428:	30c01426 	beq	r6,r3,8111d47c <memchr+0x84>
8111d42c:	21000044 	addi	r4,r4,1
8111d430:	20c000cc 	andi	r3,r4,3
8111d434:	183ff91e 	bne	r3,zero,8111d41c <__reset+0xfb0fd41c>
8111d438:	020000c4 	movi	r8,3
8111d43c:	40801136 	bltu	r8,r2,8111d484 <memchr+0x8c>
8111d440:	10000c26 	beq	r2,zero,8111d474 <memchr+0x7c>
8111d444:	20c00003 	ldbu	r3,0(r4)
8111d448:	29403fcc 	andi	r5,r5,255
8111d44c:	28c00b26 	beq	r5,r3,8111d47c <memchr+0x84>
8111d450:	20c00044 	addi	r3,r4,1
8111d454:	39803fcc 	andi	r6,r7,255
8111d458:	2089883a 	add	r4,r4,r2
8111d45c:	00000306 	br	8111d46c <memchr+0x74>
8111d460:	18c00044 	addi	r3,r3,1
8111d464:	197fffc3 	ldbu	r5,-1(r3)
8111d468:	31400526 	beq	r6,r5,8111d480 <memchr+0x88>
8111d46c:	1805883a 	mov	r2,r3
8111d470:	20fffb1e 	bne	r4,r3,8111d460 <__reset+0xfb0fd460>
8111d474:	0005883a 	mov	r2,zero
8111d478:	f800283a 	ret
8111d47c:	2005883a 	mov	r2,r4
8111d480:	f800283a 	ret
8111d484:	28c03fcc 	andi	r3,r5,255
8111d488:	1812923a 	slli	r9,r3,8
8111d48c:	02ffbff4 	movhi	r11,65279
8111d490:	02a02074 	movhi	r10,32897
8111d494:	48d2b03a 	or	r9,r9,r3
8111d498:	4806943a 	slli	r3,r9,16
8111d49c:	5affbfc4 	addi	r11,r11,-257
8111d4a0:	52a02004 	addi	r10,r10,-32640
8111d4a4:	48d2b03a 	or	r9,r9,r3
8111d4a8:	20c00017 	ldw	r3,0(r4)
8111d4ac:	48c6f03a 	xor	r3,r9,r3
8111d4b0:	1acd883a 	add	r6,r3,r11
8111d4b4:	00c6303a 	nor	r3,zero,r3
8111d4b8:	30c6703a 	and	r3,r6,r3
8111d4bc:	1a86703a 	and	r3,r3,r10
8111d4c0:	183fe01e 	bne	r3,zero,8111d444 <__reset+0xfb0fd444>
8111d4c4:	10bfff04 	addi	r2,r2,-4
8111d4c8:	21000104 	addi	r4,r4,4
8111d4cc:	40bff636 	bltu	r8,r2,8111d4a8 <__reset+0xfb0fd4a8>
8111d4d0:	003fdb06 	br	8111d440 <__reset+0xfb0fd440>
8111d4d4:	3005883a 	mov	r2,r6
8111d4d8:	003fd706 	br	8111d438 <__reset+0xfb0fd438>

8111d4dc <memmove>:
8111d4dc:	2005883a 	mov	r2,r4
8111d4e0:	29000b2e 	bgeu	r5,r4,8111d510 <memmove+0x34>
8111d4e4:	298f883a 	add	r7,r5,r6
8111d4e8:	21c0092e 	bgeu	r4,r7,8111d510 <memmove+0x34>
8111d4ec:	2187883a 	add	r3,r4,r6
8111d4f0:	198bc83a 	sub	r5,r3,r6
8111d4f4:	30004826 	beq	r6,zero,8111d618 <memmove+0x13c>
8111d4f8:	39ffffc4 	addi	r7,r7,-1
8111d4fc:	39000003 	ldbu	r4,0(r7)
8111d500:	18ffffc4 	addi	r3,r3,-1
8111d504:	19000005 	stb	r4,0(r3)
8111d508:	28fffb1e 	bne	r5,r3,8111d4f8 <__reset+0xfb0fd4f8>
8111d50c:	f800283a 	ret
8111d510:	00c003c4 	movi	r3,15
8111d514:	1980412e 	bgeu	r3,r6,8111d61c <memmove+0x140>
8111d518:	2886b03a 	or	r3,r5,r2
8111d51c:	18c000cc 	andi	r3,r3,3
8111d520:	1800401e 	bne	r3,zero,8111d624 <memmove+0x148>
8111d524:	33fffc04 	addi	r15,r6,-16
8111d528:	781ed13a 	srli	r15,r15,4
8111d52c:	28c00104 	addi	r3,r5,4
8111d530:	13400104 	addi	r13,r2,4
8111d534:	781c913a 	slli	r14,r15,4
8111d538:	2b000204 	addi	r12,r5,8
8111d53c:	12c00204 	addi	r11,r2,8
8111d540:	73800504 	addi	r14,r14,20
8111d544:	2a800304 	addi	r10,r5,12
8111d548:	12400304 	addi	r9,r2,12
8111d54c:	2b9d883a 	add	r14,r5,r14
8111d550:	2811883a 	mov	r8,r5
8111d554:	100f883a 	mov	r7,r2
8111d558:	41000017 	ldw	r4,0(r8)
8111d55c:	39c00404 	addi	r7,r7,16
8111d560:	18c00404 	addi	r3,r3,16
8111d564:	393ffc15 	stw	r4,-16(r7)
8111d568:	193ffc17 	ldw	r4,-16(r3)
8111d56c:	6b400404 	addi	r13,r13,16
8111d570:	5ac00404 	addi	r11,r11,16
8111d574:	693ffc15 	stw	r4,-16(r13)
8111d578:	61000017 	ldw	r4,0(r12)
8111d57c:	4a400404 	addi	r9,r9,16
8111d580:	42000404 	addi	r8,r8,16
8111d584:	593ffc15 	stw	r4,-16(r11)
8111d588:	51000017 	ldw	r4,0(r10)
8111d58c:	63000404 	addi	r12,r12,16
8111d590:	52800404 	addi	r10,r10,16
8111d594:	493ffc15 	stw	r4,-16(r9)
8111d598:	1bbfef1e 	bne	r3,r14,8111d558 <__reset+0xfb0fd558>
8111d59c:	79000044 	addi	r4,r15,1
8111d5a0:	2008913a 	slli	r4,r4,4
8111d5a4:	328003cc 	andi	r10,r6,15
8111d5a8:	02c000c4 	movi	r11,3
8111d5ac:	1107883a 	add	r3,r2,r4
8111d5b0:	290b883a 	add	r5,r5,r4
8111d5b4:	5a801e2e 	bgeu	r11,r10,8111d630 <memmove+0x154>
8111d5b8:	1813883a 	mov	r9,r3
8111d5bc:	2811883a 	mov	r8,r5
8111d5c0:	500f883a 	mov	r7,r10
8111d5c4:	41000017 	ldw	r4,0(r8)
8111d5c8:	4a400104 	addi	r9,r9,4
8111d5cc:	39ffff04 	addi	r7,r7,-4
8111d5d0:	493fff15 	stw	r4,-4(r9)
8111d5d4:	42000104 	addi	r8,r8,4
8111d5d8:	59fffa36 	bltu	r11,r7,8111d5c4 <__reset+0xfb0fd5c4>
8111d5dc:	513fff04 	addi	r4,r10,-4
8111d5e0:	2008d0ba 	srli	r4,r4,2
8111d5e4:	318000cc 	andi	r6,r6,3
8111d5e8:	21000044 	addi	r4,r4,1
8111d5ec:	2109883a 	add	r4,r4,r4
8111d5f0:	2109883a 	add	r4,r4,r4
8111d5f4:	1907883a 	add	r3,r3,r4
8111d5f8:	290b883a 	add	r5,r5,r4
8111d5fc:	30000b26 	beq	r6,zero,8111d62c <memmove+0x150>
8111d600:	198d883a 	add	r6,r3,r6
8111d604:	29c00003 	ldbu	r7,0(r5)
8111d608:	18c00044 	addi	r3,r3,1
8111d60c:	29400044 	addi	r5,r5,1
8111d610:	19ffffc5 	stb	r7,-1(r3)
8111d614:	19bffb1e 	bne	r3,r6,8111d604 <__reset+0xfb0fd604>
8111d618:	f800283a 	ret
8111d61c:	1007883a 	mov	r3,r2
8111d620:	003ff606 	br	8111d5fc <__reset+0xfb0fd5fc>
8111d624:	1007883a 	mov	r3,r2
8111d628:	003ff506 	br	8111d600 <__reset+0xfb0fd600>
8111d62c:	f800283a 	ret
8111d630:	500d883a 	mov	r6,r10
8111d634:	003ff106 	br	8111d5fc <__reset+0xfb0fd5fc>

8111d638 <_Balloc>:
8111d638:	defffc04 	addi	sp,sp,-16
8111d63c:	de00012e 	bgeu	sp,et,8111d644 <_Balloc+0xc>
8111d640:	003b68fa 	trap	3
8111d644:	20801317 	ldw	r2,76(r4)
8111d648:	dc400115 	stw	r17,4(sp)
8111d64c:	dc000015 	stw	r16,0(sp)
8111d650:	dfc00315 	stw	ra,12(sp)
8111d654:	dc800215 	stw	r18,8(sp)
8111d658:	2023883a 	mov	r17,r4
8111d65c:	2821883a 	mov	r16,r5
8111d660:	10000f26 	beq	r2,zero,8111d6a0 <_Balloc+0x68>
8111d664:	8407883a 	add	r3,r16,r16
8111d668:	18c7883a 	add	r3,r3,r3
8111d66c:	10c7883a 	add	r3,r2,r3
8111d670:	18800017 	ldw	r2,0(r3)
8111d674:	10001126 	beq	r2,zero,8111d6bc <_Balloc+0x84>
8111d678:	11000017 	ldw	r4,0(r2)
8111d67c:	19000015 	stw	r4,0(r3)
8111d680:	10000415 	stw	zero,16(r2)
8111d684:	10000315 	stw	zero,12(r2)
8111d688:	dfc00317 	ldw	ra,12(sp)
8111d68c:	dc800217 	ldw	r18,8(sp)
8111d690:	dc400117 	ldw	r17,4(sp)
8111d694:	dc000017 	ldw	r16,0(sp)
8111d698:	dec00404 	addi	sp,sp,16
8111d69c:	f800283a 	ret
8111d6a0:	01800844 	movi	r6,33
8111d6a4:	01400104 	movi	r5,4
8111d6a8:	1123b600 	call	81123b60 <_calloc_r>
8111d6ac:	88801315 	stw	r2,76(r17)
8111d6b0:	103fec1e 	bne	r2,zero,8111d664 <__reset+0xfb0fd664>
8111d6b4:	0005883a 	mov	r2,zero
8111d6b8:	003ff306 	br	8111d688 <__reset+0xfb0fd688>
8111d6bc:	01400044 	movi	r5,1
8111d6c0:	2c24983a 	sll	r18,r5,r16
8111d6c4:	8809883a 	mov	r4,r17
8111d6c8:	91800144 	addi	r6,r18,5
8111d6cc:	318d883a 	add	r6,r6,r6
8111d6d0:	318d883a 	add	r6,r6,r6
8111d6d4:	1123b600 	call	81123b60 <_calloc_r>
8111d6d8:	103ff626 	beq	r2,zero,8111d6b4 <__reset+0xfb0fd6b4>
8111d6dc:	14000115 	stw	r16,4(r2)
8111d6e0:	14800215 	stw	r18,8(r2)
8111d6e4:	003fe606 	br	8111d680 <__reset+0xfb0fd680>

8111d6e8 <_Bfree>:
8111d6e8:	28000826 	beq	r5,zero,8111d70c <_Bfree+0x24>
8111d6ec:	28c00117 	ldw	r3,4(r5)
8111d6f0:	20801317 	ldw	r2,76(r4)
8111d6f4:	18c7883a 	add	r3,r3,r3
8111d6f8:	18c7883a 	add	r3,r3,r3
8111d6fc:	10c5883a 	add	r2,r2,r3
8111d700:	10c00017 	ldw	r3,0(r2)
8111d704:	28c00015 	stw	r3,0(r5)
8111d708:	11400015 	stw	r5,0(r2)
8111d70c:	f800283a 	ret

8111d710 <__multadd>:
8111d710:	defffa04 	addi	sp,sp,-24
8111d714:	de00012e 	bgeu	sp,et,8111d71c <__multadd+0xc>
8111d718:	003b68fa 	trap	3
8111d71c:	0011883a 	mov	r8,zero
8111d720:	dc800315 	stw	r18,12(sp)
8111d724:	dc400215 	stw	r17,8(sp)
8111d728:	dc000115 	stw	r16,4(sp)
8111d72c:	2823883a 	mov	r17,r5
8111d730:	2c000417 	ldw	r16,16(r5)
8111d734:	dfc00515 	stw	ra,20(sp)
8111d738:	dcc00415 	stw	r19,16(sp)
8111d73c:	2025883a 	mov	r18,r4
8111d740:	29400504 	addi	r5,r5,20
8111d744:	28c00017 	ldw	r3,0(r5)
8111d748:	29400104 	addi	r5,r5,4
8111d74c:	42000044 	addi	r8,r8,1
8111d750:	18bfffcc 	andi	r2,r3,65535
8111d754:	1185383a 	mul	r2,r2,r6
8111d758:	1806d43a 	srli	r3,r3,16
8111d75c:	11cf883a 	add	r7,r2,r7
8111d760:	3808d43a 	srli	r4,r7,16
8111d764:	1987383a 	mul	r3,r3,r6
8111d768:	38bfffcc 	andi	r2,r7,65535
8111d76c:	1907883a 	add	r3,r3,r4
8111d770:	1808943a 	slli	r4,r3,16
8111d774:	180ed43a 	srli	r7,r3,16
8111d778:	2085883a 	add	r2,r4,r2
8111d77c:	28bfff15 	stw	r2,-4(r5)
8111d780:	443ff016 	blt	r8,r16,8111d744 <__reset+0xfb0fd744>
8111d784:	38000926 	beq	r7,zero,8111d7ac <__multadd+0x9c>
8111d788:	88800217 	ldw	r2,8(r17)
8111d78c:	80800f0e 	bge	r16,r2,8111d7cc <__multadd+0xbc>
8111d790:	80800144 	addi	r2,r16,5
8111d794:	1085883a 	add	r2,r2,r2
8111d798:	1085883a 	add	r2,r2,r2
8111d79c:	8885883a 	add	r2,r17,r2
8111d7a0:	11c00015 	stw	r7,0(r2)
8111d7a4:	84000044 	addi	r16,r16,1
8111d7a8:	8c000415 	stw	r16,16(r17)
8111d7ac:	8805883a 	mov	r2,r17
8111d7b0:	dfc00517 	ldw	ra,20(sp)
8111d7b4:	dcc00417 	ldw	r19,16(sp)
8111d7b8:	dc800317 	ldw	r18,12(sp)
8111d7bc:	dc400217 	ldw	r17,8(sp)
8111d7c0:	dc000117 	ldw	r16,4(sp)
8111d7c4:	dec00604 	addi	sp,sp,24
8111d7c8:	f800283a 	ret
8111d7cc:	89400117 	ldw	r5,4(r17)
8111d7d0:	9009883a 	mov	r4,r18
8111d7d4:	d9c00015 	stw	r7,0(sp)
8111d7d8:	29400044 	addi	r5,r5,1
8111d7dc:	111d6380 	call	8111d638 <_Balloc>
8111d7e0:	89800417 	ldw	r6,16(r17)
8111d7e4:	89400304 	addi	r5,r17,12
8111d7e8:	11000304 	addi	r4,r2,12
8111d7ec:	31800084 	addi	r6,r6,2
8111d7f0:	318d883a 	add	r6,r6,r6
8111d7f4:	318d883a 	add	r6,r6,r6
8111d7f8:	1027883a 	mov	r19,r2
8111d7fc:	11136e00 	call	811136e0 <memcpy>
8111d800:	d9c00017 	ldw	r7,0(sp)
8111d804:	88000a26 	beq	r17,zero,8111d830 <__multadd+0x120>
8111d808:	88c00117 	ldw	r3,4(r17)
8111d80c:	90801317 	ldw	r2,76(r18)
8111d810:	18c7883a 	add	r3,r3,r3
8111d814:	18c7883a 	add	r3,r3,r3
8111d818:	10c5883a 	add	r2,r2,r3
8111d81c:	10c00017 	ldw	r3,0(r2)
8111d820:	88c00015 	stw	r3,0(r17)
8111d824:	14400015 	stw	r17,0(r2)
8111d828:	9823883a 	mov	r17,r19
8111d82c:	003fd806 	br	8111d790 <__reset+0xfb0fd790>
8111d830:	9823883a 	mov	r17,r19
8111d834:	003fd606 	br	8111d790 <__reset+0xfb0fd790>

8111d838 <__s2b>:
8111d838:	defff904 	addi	sp,sp,-28
8111d83c:	de00012e 	bgeu	sp,et,8111d844 <__s2b+0xc>
8111d840:	003b68fa 	trap	3
8111d844:	dc400115 	stw	r17,4(sp)
8111d848:	dc000015 	stw	r16,0(sp)
8111d84c:	2023883a 	mov	r17,r4
8111d850:	2821883a 	mov	r16,r5
8111d854:	39000204 	addi	r4,r7,8
8111d858:	01400244 	movi	r5,9
8111d85c:	dcc00315 	stw	r19,12(sp)
8111d860:	dc800215 	stw	r18,8(sp)
8111d864:	dfc00615 	stw	ra,24(sp)
8111d868:	dd400515 	stw	r21,20(sp)
8111d86c:	dd000415 	stw	r20,16(sp)
8111d870:	3825883a 	mov	r18,r7
8111d874:	3027883a 	mov	r19,r6
8111d878:	1125a580 	call	81125a58 <__divsi3>
8111d87c:	00c00044 	movi	r3,1
8111d880:	000b883a 	mov	r5,zero
8111d884:	1880030e 	bge	r3,r2,8111d894 <__s2b+0x5c>
8111d888:	18c7883a 	add	r3,r3,r3
8111d88c:	29400044 	addi	r5,r5,1
8111d890:	18bffd16 	blt	r3,r2,8111d888 <__reset+0xfb0fd888>
8111d894:	8809883a 	mov	r4,r17
8111d898:	111d6380 	call	8111d638 <_Balloc>
8111d89c:	d8c00717 	ldw	r3,28(sp)
8111d8a0:	10c00515 	stw	r3,20(r2)
8111d8a4:	00c00044 	movi	r3,1
8111d8a8:	10c00415 	stw	r3,16(r2)
8111d8ac:	00c00244 	movi	r3,9
8111d8b0:	1cc0210e 	bge	r3,r19,8111d938 <__s2b+0x100>
8111d8b4:	80eb883a 	add	r21,r16,r3
8111d8b8:	a829883a 	mov	r20,r21
8111d8bc:	84e1883a 	add	r16,r16,r19
8111d8c0:	a1c00007 	ldb	r7,0(r20)
8111d8c4:	01800284 	movi	r6,10
8111d8c8:	a5000044 	addi	r20,r20,1
8111d8cc:	100b883a 	mov	r5,r2
8111d8d0:	39fff404 	addi	r7,r7,-48
8111d8d4:	8809883a 	mov	r4,r17
8111d8d8:	111d7100 	call	8111d710 <__multadd>
8111d8dc:	a43ff81e 	bne	r20,r16,8111d8c0 <__reset+0xfb0fd8c0>
8111d8e0:	ace1883a 	add	r16,r21,r19
8111d8e4:	843ffe04 	addi	r16,r16,-8
8111d8e8:	9c800a0e 	bge	r19,r18,8111d914 <__s2b+0xdc>
8111d8ec:	94e5c83a 	sub	r18,r18,r19
8111d8f0:	84a5883a 	add	r18,r16,r18
8111d8f4:	81c00007 	ldb	r7,0(r16)
8111d8f8:	01800284 	movi	r6,10
8111d8fc:	84000044 	addi	r16,r16,1
8111d900:	100b883a 	mov	r5,r2
8111d904:	39fff404 	addi	r7,r7,-48
8111d908:	8809883a 	mov	r4,r17
8111d90c:	111d7100 	call	8111d710 <__multadd>
8111d910:	84bff81e 	bne	r16,r18,8111d8f4 <__reset+0xfb0fd8f4>
8111d914:	dfc00617 	ldw	ra,24(sp)
8111d918:	dd400517 	ldw	r21,20(sp)
8111d91c:	dd000417 	ldw	r20,16(sp)
8111d920:	dcc00317 	ldw	r19,12(sp)
8111d924:	dc800217 	ldw	r18,8(sp)
8111d928:	dc400117 	ldw	r17,4(sp)
8111d92c:	dc000017 	ldw	r16,0(sp)
8111d930:	dec00704 	addi	sp,sp,28
8111d934:	f800283a 	ret
8111d938:	84000284 	addi	r16,r16,10
8111d93c:	1827883a 	mov	r19,r3
8111d940:	003fe906 	br	8111d8e8 <__reset+0xfb0fd8e8>

8111d944 <__hi0bits>:
8111d944:	20bfffec 	andhi	r2,r4,65535
8111d948:	1000141e 	bne	r2,zero,8111d99c <__hi0bits+0x58>
8111d94c:	2008943a 	slli	r4,r4,16
8111d950:	00800404 	movi	r2,16
8111d954:	20ffc02c 	andhi	r3,r4,65280
8111d958:	1800021e 	bne	r3,zero,8111d964 <__hi0bits+0x20>
8111d95c:	2008923a 	slli	r4,r4,8
8111d960:	10800204 	addi	r2,r2,8
8111d964:	20fc002c 	andhi	r3,r4,61440
8111d968:	1800021e 	bne	r3,zero,8111d974 <__hi0bits+0x30>
8111d96c:	2008913a 	slli	r4,r4,4
8111d970:	10800104 	addi	r2,r2,4
8111d974:	20f0002c 	andhi	r3,r4,49152
8111d978:	1800031e 	bne	r3,zero,8111d988 <__hi0bits+0x44>
8111d97c:	2109883a 	add	r4,r4,r4
8111d980:	10800084 	addi	r2,r2,2
8111d984:	2109883a 	add	r4,r4,r4
8111d988:	20000316 	blt	r4,zero,8111d998 <__hi0bits+0x54>
8111d98c:	2110002c 	andhi	r4,r4,16384
8111d990:	2000041e 	bne	r4,zero,8111d9a4 <__hi0bits+0x60>
8111d994:	00800804 	movi	r2,32
8111d998:	f800283a 	ret
8111d99c:	0005883a 	mov	r2,zero
8111d9a0:	003fec06 	br	8111d954 <__reset+0xfb0fd954>
8111d9a4:	10800044 	addi	r2,r2,1
8111d9a8:	f800283a 	ret

8111d9ac <__lo0bits>:
8111d9ac:	20c00017 	ldw	r3,0(r4)
8111d9b0:	188001cc 	andi	r2,r3,7
8111d9b4:	10000826 	beq	r2,zero,8111d9d8 <__lo0bits+0x2c>
8111d9b8:	1880004c 	andi	r2,r3,1
8111d9bc:	1000211e 	bne	r2,zero,8111da44 <__lo0bits+0x98>
8111d9c0:	1880008c 	andi	r2,r3,2
8111d9c4:	1000211e 	bne	r2,zero,8111da4c <__lo0bits+0xa0>
8111d9c8:	1806d0ba 	srli	r3,r3,2
8111d9cc:	00800084 	movi	r2,2
8111d9d0:	20c00015 	stw	r3,0(r4)
8111d9d4:	f800283a 	ret
8111d9d8:	18bfffcc 	andi	r2,r3,65535
8111d9dc:	10001326 	beq	r2,zero,8111da2c <__lo0bits+0x80>
8111d9e0:	0005883a 	mov	r2,zero
8111d9e4:	19403fcc 	andi	r5,r3,255
8111d9e8:	2800021e 	bne	r5,zero,8111d9f4 <__lo0bits+0x48>
8111d9ec:	1806d23a 	srli	r3,r3,8
8111d9f0:	10800204 	addi	r2,r2,8
8111d9f4:	194003cc 	andi	r5,r3,15
8111d9f8:	2800021e 	bne	r5,zero,8111da04 <__lo0bits+0x58>
8111d9fc:	1806d13a 	srli	r3,r3,4
8111da00:	10800104 	addi	r2,r2,4
8111da04:	194000cc 	andi	r5,r3,3
8111da08:	2800021e 	bne	r5,zero,8111da14 <__lo0bits+0x68>
8111da0c:	1806d0ba 	srli	r3,r3,2
8111da10:	10800084 	addi	r2,r2,2
8111da14:	1940004c 	andi	r5,r3,1
8111da18:	2800081e 	bne	r5,zero,8111da3c <__lo0bits+0x90>
8111da1c:	1806d07a 	srli	r3,r3,1
8111da20:	1800051e 	bne	r3,zero,8111da38 <__lo0bits+0x8c>
8111da24:	00800804 	movi	r2,32
8111da28:	f800283a 	ret
8111da2c:	1806d43a 	srli	r3,r3,16
8111da30:	00800404 	movi	r2,16
8111da34:	003feb06 	br	8111d9e4 <__reset+0xfb0fd9e4>
8111da38:	10800044 	addi	r2,r2,1
8111da3c:	20c00015 	stw	r3,0(r4)
8111da40:	f800283a 	ret
8111da44:	0005883a 	mov	r2,zero
8111da48:	f800283a 	ret
8111da4c:	1806d07a 	srli	r3,r3,1
8111da50:	00800044 	movi	r2,1
8111da54:	20c00015 	stw	r3,0(r4)
8111da58:	f800283a 	ret

8111da5c <__i2b>:
8111da5c:	defffd04 	addi	sp,sp,-12
8111da60:	de00012e 	bgeu	sp,et,8111da68 <__i2b+0xc>
8111da64:	003b68fa 	trap	3
8111da68:	dc000015 	stw	r16,0(sp)
8111da6c:	04000044 	movi	r16,1
8111da70:	dc400115 	stw	r17,4(sp)
8111da74:	2823883a 	mov	r17,r5
8111da78:	800b883a 	mov	r5,r16
8111da7c:	dfc00215 	stw	ra,8(sp)
8111da80:	111d6380 	call	8111d638 <_Balloc>
8111da84:	14400515 	stw	r17,20(r2)
8111da88:	14000415 	stw	r16,16(r2)
8111da8c:	dfc00217 	ldw	ra,8(sp)
8111da90:	dc400117 	ldw	r17,4(sp)
8111da94:	dc000017 	ldw	r16,0(sp)
8111da98:	dec00304 	addi	sp,sp,12
8111da9c:	f800283a 	ret

8111daa0 <__multiply>:
8111daa0:	defffa04 	addi	sp,sp,-24
8111daa4:	de00012e 	bgeu	sp,et,8111daac <__multiply+0xc>
8111daa8:	003b68fa 	trap	3
8111daac:	dcc00315 	stw	r19,12(sp)
8111dab0:	dc800215 	stw	r18,8(sp)
8111dab4:	34c00417 	ldw	r19,16(r6)
8111dab8:	2c800417 	ldw	r18,16(r5)
8111dabc:	dd000415 	stw	r20,16(sp)
8111dac0:	dc400115 	stw	r17,4(sp)
8111dac4:	dfc00515 	stw	ra,20(sp)
8111dac8:	dc000015 	stw	r16,0(sp)
8111dacc:	2829883a 	mov	r20,r5
8111dad0:	3023883a 	mov	r17,r6
8111dad4:	94c0050e 	bge	r18,r19,8111daec <__multiply+0x4c>
8111dad8:	9007883a 	mov	r3,r18
8111dadc:	3029883a 	mov	r20,r6
8111dae0:	9825883a 	mov	r18,r19
8111dae4:	2823883a 	mov	r17,r5
8111dae8:	1827883a 	mov	r19,r3
8111daec:	a0800217 	ldw	r2,8(r20)
8111daf0:	94e1883a 	add	r16,r18,r19
8111daf4:	a1400117 	ldw	r5,4(r20)
8111daf8:	1400010e 	bge	r2,r16,8111db00 <__multiply+0x60>
8111dafc:	29400044 	addi	r5,r5,1
8111db00:	111d6380 	call	8111d638 <_Balloc>
8111db04:	8415883a 	add	r10,r16,r16
8111db08:	12c00504 	addi	r11,r2,20
8111db0c:	5295883a 	add	r10,r10,r10
8111db10:	5a95883a 	add	r10,r11,r10
8111db14:	5807883a 	mov	r3,r11
8111db18:	5a80032e 	bgeu	r11,r10,8111db28 <__multiply+0x88>
8111db1c:	18000015 	stw	zero,0(r3)
8111db20:	18c00104 	addi	r3,r3,4
8111db24:	1abffd36 	bltu	r3,r10,8111db1c <__reset+0xfb0fdb1c>
8111db28:	9ce7883a 	add	r19,r19,r19
8111db2c:	94a5883a 	add	r18,r18,r18
8111db30:	89800504 	addi	r6,r17,20
8111db34:	9ce7883a 	add	r19,r19,r19
8111db38:	a3400504 	addi	r13,r20,20
8111db3c:	94a5883a 	add	r18,r18,r18
8111db40:	34d9883a 	add	r12,r6,r19
8111db44:	6c93883a 	add	r9,r13,r18
8111db48:	3300422e 	bgeu	r6,r12,8111dc54 <__multiply+0x1b4>
8111db4c:	37c00017 	ldw	ra,0(r6)
8111db50:	fbffffcc 	andi	r15,ra,65535
8111db54:	78001b26 	beq	r15,zero,8111dbc4 <__multiply+0x124>
8111db58:	5811883a 	mov	r8,r11
8111db5c:	681d883a 	mov	r14,r13
8111db60:	000f883a 	mov	r7,zero
8111db64:	71000017 	ldw	r4,0(r14)
8111db68:	40c00017 	ldw	r3,0(r8)
8111db6c:	73800104 	addi	r14,r14,4
8111db70:	217fffcc 	andi	r5,r4,65535
8111db74:	2bcb383a 	mul	r5,r5,r15
8111db78:	2008d43a 	srli	r4,r4,16
8111db7c:	1c7fffcc 	andi	r17,r3,65535
8111db80:	2c4b883a 	add	r5,r5,r17
8111db84:	29cb883a 	add	r5,r5,r7
8111db88:	23c9383a 	mul	r4,r4,r15
8111db8c:	1806d43a 	srli	r3,r3,16
8111db90:	280ed43a 	srli	r7,r5,16
8111db94:	297fffcc 	andi	r5,r5,65535
8111db98:	20c7883a 	add	r3,r4,r3
8111db9c:	19c7883a 	add	r3,r3,r7
8111dba0:	1808943a 	slli	r4,r3,16
8111dba4:	4023883a 	mov	r17,r8
8111dba8:	180ed43a 	srli	r7,r3,16
8111dbac:	214ab03a 	or	r5,r4,r5
8111dbb0:	41400015 	stw	r5,0(r8)
8111dbb4:	42000104 	addi	r8,r8,4
8111dbb8:	727fea36 	bltu	r14,r9,8111db64 <__reset+0xfb0fdb64>
8111dbbc:	89c00115 	stw	r7,4(r17)
8111dbc0:	37c00017 	ldw	ra,0(r6)
8111dbc4:	f83ed43a 	srli	ra,ra,16
8111dbc8:	f8001f26 	beq	ra,zero,8111dc48 <__multiply+0x1a8>
8111dbcc:	58c00017 	ldw	r3,0(r11)
8111dbd0:	681d883a 	mov	r14,r13
8111dbd4:	581f883a 	mov	r15,r11
8111dbd8:	1811883a 	mov	r8,r3
8111dbdc:	5825883a 	mov	r18,r11
8111dbe0:	000f883a 	mov	r7,zero
8111dbe4:	00000106 	br	8111dbec <__multiply+0x14c>
8111dbe8:	8825883a 	mov	r18,r17
8111dbec:	7140000b 	ldhu	r5,0(r14)
8111dbf0:	4010d43a 	srli	r8,r8,16
8111dbf4:	193fffcc 	andi	r4,r3,65535
8111dbf8:	2fcb383a 	mul	r5,r5,ra
8111dbfc:	7bc00104 	addi	r15,r15,4
8111dc00:	73800104 	addi	r14,r14,4
8111dc04:	2a0b883a 	add	r5,r5,r8
8111dc08:	29cb883a 	add	r5,r5,r7
8111dc0c:	2806943a 	slli	r3,r5,16
8111dc10:	94400104 	addi	r17,r18,4
8111dc14:	280ad43a 	srli	r5,r5,16
8111dc18:	1908b03a 	or	r4,r3,r4
8111dc1c:	793fff15 	stw	r4,-4(r15)
8111dc20:	70ffff17 	ldw	r3,-4(r14)
8111dc24:	8a000017 	ldw	r8,0(r17)
8111dc28:	1806d43a 	srli	r3,r3,16
8111dc2c:	413fffcc 	andi	r4,r8,65535
8111dc30:	1fc7383a 	mul	r3,r3,ra
8111dc34:	1907883a 	add	r3,r3,r4
8111dc38:	1947883a 	add	r3,r3,r5
8111dc3c:	180ed43a 	srli	r7,r3,16
8111dc40:	727fe936 	bltu	r14,r9,8111dbe8 <__reset+0xfb0fdbe8>
8111dc44:	90c00115 	stw	r3,4(r18)
8111dc48:	31800104 	addi	r6,r6,4
8111dc4c:	5ac00104 	addi	r11,r11,4
8111dc50:	333fbe36 	bltu	r6,r12,8111db4c <__reset+0xfb0fdb4c>
8111dc54:	0400090e 	bge	zero,r16,8111dc7c <__multiply+0x1dc>
8111dc58:	50ffff17 	ldw	r3,-4(r10)
8111dc5c:	52bfff04 	addi	r10,r10,-4
8111dc60:	18000326 	beq	r3,zero,8111dc70 <__multiply+0x1d0>
8111dc64:	00000506 	br	8111dc7c <__multiply+0x1dc>
8111dc68:	50c00017 	ldw	r3,0(r10)
8111dc6c:	1800031e 	bne	r3,zero,8111dc7c <__multiply+0x1dc>
8111dc70:	843fffc4 	addi	r16,r16,-1
8111dc74:	52bfff04 	addi	r10,r10,-4
8111dc78:	803ffb1e 	bne	r16,zero,8111dc68 <__reset+0xfb0fdc68>
8111dc7c:	14000415 	stw	r16,16(r2)
8111dc80:	dfc00517 	ldw	ra,20(sp)
8111dc84:	dd000417 	ldw	r20,16(sp)
8111dc88:	dcc00317 	ldw	r19,12(sp)
8111dc8c:	dc800217 	ldw	r18,8(sp)
8111dc90:	dc400117 	ldw	r17,4(sp)
8111dc94:	dc000017 	ldw	r16,0(sp)
8111dc98:	dec00604 	addi	sp,sp,24
8111dc9c:	f800283a 	ret

8111dca0 <__pow5mult>:
8111dca0:	defffa04 	addi	sp,sp,-24
8111dca4:	de00012e 	bgeu	sp,et,8111dcac <__pow5mult+0xc>
8111dca8:	003b68fa 	trap	3
8111dcac:	308000cc 	andi	r2,r6,3
8111dcb0:	dcc00315 	stw	r19,12(sp)
8111dcb4:	dc000015 	stw	r16,0(sp)
8111dcb8:	dfc00515 	stw	ra,20(sp)
8111dcbc:	dd000415 	stw	r20,16(sp)
8111dcc0:	dc800215 	stw	r18,8(sp)
8111dcc4:	dc400115 	stw	r17,4(sp)
8111dcc8:	3021883a 	mov	r16,r6
8111dccc:	2027883a 	mov	r19,r4
8111dcd0:	10002f1e 	bne	r2,zero,8111dd90 <__pow5mult+0xf0>
8111dcd4:	2825883a 	mov	r18,r5
8111dcd8:	8021d0ba 	srai	r16,r16,2
8111dcdc:	80001a26 	beq	r16,zero,8111dd48 <__pow5mult+0xa8>
8111dce0:	9c401217 	ldw	r17,72(r19)
8111dce4:	8800061e 	bne	r17,zero,8111dd00 <__pow5mult+0x60>
8111dce8:	00003406 	br	8111ddbc <__pow5mult+0x11c>
8111dcec:	8021d07a 	srai	r16,r16,1
8111dcf0:	80001526 	beq	r16,zero,8111dd48 <__pow5mult+0xa8>
8111dcf4:	88800017 	ldw	r2,0(r17)
8111dcf8:	10001c26 	beq	r2,zero,8111dd6c <__pow5mult+0xcc>
8111dcfc:	1023883a 	mov	r17,r2
8111dd00:	8080004c 	andi	r2,r16,1
8111dd04:	103ff926 	beq	r2,zero,8111dcec <__reset+0xfb0fdcec>
8111dd08:	880d883a 	mov	r6,r17
8111dd0c:	900b883a 	mov	r5,r18
8111dd10:	9809883a 	mov	r4,r19
8111dd14:	111daa00 	call	8111daa0 <__multiply>
8111dd18:	90001b26 	beq	r18,zero,8111dd88 <__pow5mult+0xe8>
8111dd1c:	91000117 	ldw	r4,4(r18)
8111dd20:	98c01317 	ldw	r3,76(r19)
8111dd24:	8021d07a 	srai	r16,r16,1
8111dd28:	2109883a 	add	r4,r4,r4
8111dd2c:	2109883a 	add	r4,r4,r4
8111dd30:	1907883a 	add	r3,r3,r4
8111dd34:	19000017 	ldw	r4,0(r3)
8111dd38:	91000015 	stw	r4,0(r18)
8111dd3c:	1c800015 	stw	r18,0(r3)
8111dd40:	1025883a 	mov	r18,r2
8111dd44:	803feb1e 	bne	r16,zero,8111dcf4 <__reset+0xfb0fdcf4>
8111dd48:	9005883a 	mov	r2,r18
8111dd4c:	dfc00517 	ldw	ra,20(sp)
8111dd50:	dd000417 	ldw	r20,16(sp)
8111dd54:	dcc00317 	ldw	r19,12(sp)
8111dd58:	dc800217 	ldw	r18,8(sp)
8111dd5c:	dc400117 	ldw	r17,4(sp)
8111dd60:	dc000017 	ldw	r16,0(sp)
8111dd64:	dec00604 	addi	sp,sp,24
8111dd68:	f800283a 	ret
8111dd6c:	880d883a 	mov	r6,r17
8111dd70:	880b883a 	mov	r5,r17
8111dd74:	9809883a 	mov	r4,r19
8111dd78:	111daa00 	call	8111daa0 <__multiply>
8111dd7c:	88800015 	stw	r2,0(r17)
8111dd80:	10000015 	stw	zero,0(r2)
8111dd84:	003fdd06 	br	8111dcfc <__reset+0xfb0fdcfc>
8111dd88:	1025883a 	mov	r18,r2
8111dd8c:	003fd706 	br	8111dcec <__reset+0xfb0fdcec>
8111dd90:	10bfffc4 	addi	r2,r2,-1
8111dd94:	1085883a 	add	r2,r2,r2
8111dd98:	00e04534 	movhi	r3,33044
8111dd9c:	18fdd204 	addi	r3,r3,-2232
8111dda0:	1085883a 	add	r2,r2,r2
8111dda4:	1885883a 	add	r2,r3,r2
8111dda8:	11800017 	ldw	r6,0(r2)
8111ddac:	000f883a 	mov	r7,zero
8111ddb0:	111d7100 	call	8111d710 <__multadd>
8111ddb4:	1025883a 	mov	r18,r2
8111ddb8:	003fc706 	br	8111dcd8 <__reset+0xfb0fdcd8>
8111ddbc:	05000044 	movi	r20,1
8111ddc0:	a00b883a 	mov	r5,r20
8111ddc4:	9809883a 	mov	r4,r19
8111ddc8:	111d6380 	call	8111d638 <_Balloc>
8111ddcc:	1023883a 	mov	r17,r2
8111ddd0:	00809c44 	movi	r2,625
8111ddd4:	88800515 	stw	r2,20(r17)
8111ddd8:	8d000415 	stw	r20,16(r17)
8111dddc:	9c401215 	stw	r17,72(r19)
8111dde0:	88000015 	stw	zero,0(r17)
8111dde4:	003fc606 	br	8111dd00 <__reset+0xfb0fdd00>

8111dde8 <__lshift>:
8111dde8:	defff904 	addi	sp,sp,-28
8111ddec:	de00012e 	bgeu	sp,et,8111ddf4 <__lshift+0xc>
8111ddf0:	003b68fa 	trap	3
8111ddf4:	dd400515 	stw	r21,20(sp)
8111ddf8:	dcc00315 	stw	r19,12(sp)
8111ddfc:	302bd17a 	srai	r21,r6,5
8111de00:	2cc00417 	ldw	r19,16(r5)
8111de04:	28800217 	ldw	r2,8(r5)
8111de08:	dd000415 	stw	r20,16(sp)
8111de0c:	ace7883a 	add	r19,r21,r19
8111de10:	dc800215 	stw	r18,8(sp)
8111de14:	dc400115 	stw	r17,4(sp)
8111de18:	dc000015 	stw	r16,0(sp)
8111de1c:	dfc00615 	stw	ra,24(sp)
8111de20:	9c000044 	addi	r16,r19,1
8111de24:	2823883a 	mov	r17,r5
8111de28:	3029883a 	mov	r20,r6
8111de2c:	2025883a 	mov	r18,r4
8111de30:	29400117 	ldw	r5,4(r5)
8111de34:	1400030e 	bge	r2,r16,8111de44 <__lshift+0x5c>
8111de38:	1085883a 	add	r2,r2,r2
8111de3c:	29400044 	addi	r5,r5,1
8111de40:	143ffd16 	blt	r2,r16,8111de38 <__reset+0xfb0fde38>
8111de44:	9009883a 	mov	r4,r18
8111de48:	111d6380 	call	8111d638 <_Balloc>
8111de4c:	10c00504 	addi	r3,r2,20
8111de50:	0540070e 	bge	zero,r21,8111de70 <__lshift+0x88>
8111de54:	ad6b883a 	add	r21,r21,r21
8111de58:	ad6b883a 	add	r21,r21,r21
8111de5c:	1809883a 	mov	r4,r3
8111de60:	1d47883a 	add	r3,r3,r21
8111de64:	20000015 	stw	zero,0(r4)
8111de68:	21000104 	addi	r4,r4,4
8111de6c:	193ffd1e 	bne	r3,r4,8111de64 <__reset+0xfb0fde64>
8111de70:	8a000417 	ldw	r8,16(r17)
8111de74:	89000504 	addi	r4,r17,20
8111de78:	a18007cc 	andi	r6,r20,31
8111de7c:	4211883a 	add	r8,r8,r8
8111de80:	4211883a 	add	r8,r8,r8
8111de84:	2211883a 	add	r8,r4,r8
8111de88:	30002326 	beq	r6,zero,8111df18 <__lshift+0x130>
8111de8c:	02400804 	movi	r9,32
8111de90:	4993c83a 	sub	r9,r9,r6
8111de94:	000b883a 	mov	r5,zero
8111de98:	21c00017 	ldw	r7,0(r4)
8111de9c:	1815883a 	mov	r10,r3
8111dea0:	18c00104 	addi	r3,r3,4
8111dea4:	398e983a 	sll	r7,r7,r6
8111dea8:	21000104 	addi	r4,r4,4
8111deac:	394ab03a 	or	r5,r7,r5
8111deb0:	197fff15 	stw	r5,-4(r3)
8111deb4:	217fff17 	ldw	r5,-4(r4)
8111deb8:	2a4ad83a 	srl	r5,r5,r9
8111debc:	223ff636 	bltu	r4,r8,8111de98 <__reset+0xfb0fde98>
8111dec0:	51400115 	stw	r5,4(r10)
8111dec4:	28001a1e 	bne	r5,zero,8111df30 <__lshift+0x148>
8111dec8:	843fffc4 	addi	r16,r16,-1
8111decc:	14000415 	stw	r16,16(r2)
8111ded0:	88000826 	beq	r17,zero,8111def4 <__lshift+0x10c>
8111ded4:	89000117 	ldw	r4,4(r17)
8111ded8:	90c01317 	ldw	r3,76(r18)
8111dedc:	2109883a 	add	r4,r4,r4
8111dee0:	2109883a 	add	r4,r4,r4
8111dee4:	1907883a 	add	r3,r3,r4
8111dee8:	19000017 	ldw	r4,0(r3)
8111deec:	89000015 	stw	r4,0(r17)
8111def0:	1c400015 	stw	r17,0(r3)
8111def4:	dfc00617 	ldw	ra,24(sp)
8111def8:	dd400517 	ldw	r21,20(sp)
8111defc:	dd000417 	ldw	r20,16(sp)
8111df00:	dcc00317 	ldw	r19,12(sp)
8111df04:	dc800217 	ldw	r18,8(sp)
8111df08:	dc400117 	ldw	r17,4(sp)
8111df0c:	dc000017 	ldw	r16,0(sp)
8111df10:	dec00704 	addi	sp,sp,28
8111df14:	f800283a 	ret
8111df18:	21400017 	ldw	r5,0(r4)
8111df1c:	18c00104 	addi	r3,r3,4
8111df20:	21000104 	addi	r4,r4,4
8111df24:	197fff15 	stw	r5,-4(r3)
8111df28:	223ffb36 	bltu	r4,r8,8111df18 <__reset+0xfb0fdf18>
8111df2c:	003fe606 	br	8111dec8 <__reset+0xfb0fdec8>
8111df30:	9c000084 	addi	r16,r19,2
8111df34:	003fe406 	br	8111dec8 <__reset+0xfb0fdec8>

8111df38 <__mcmp>:
8111df38:	20800417 	ldw	r2,16(r4)
8111df3c:	28c00417 	ldw	r3,16(r5)
8111df40:	10c5c83a 	sub	r2,r2,r3
8111df44:	1000111e 	bne	r2,zero,8111df8c <__mcmp+0x54>
8111df48:	18c7883a 	add	r3,r3,r3
8111df4c:	18c7883a 	add	r3,r3,r3
8111df50:	21000504 	addi	r4,r4,20
8111df54:	29400504 	addi	r5,r5,20
8111df58:	20c5883a 	add	r2,r4,r3
8111df5c:	28cb883a 	add	r5,r5,r3
8111df60:	00000106 	br	8111df68 <__mcmp+0x30>
8111df64:	20800a2e 	bgeu	r4,r2,8111df90 <__mcmp+0x58>
8111df68:	10bfff04 	addi	r2,r2,-4
8111df6c:	297fff04 	addi	r5,r5,-4
8111df70:	11800017 	ldw	r6,0(r2)
8111df74:	28c00017 	ldw	r3,0(r5)
8111df78:	30fffa26 	beq	r6,r3,8111df64 <__reset+0xfb0fdf64>
8111df7c:	30c00236 	bltu	r6,r3,8111df88 <__mcmp+0x50>
8111df80:	00800044 	movi	r2,1
8111df84:	f800283a 	ret
8111df88:	00bfffc4 	movi	r2,-1
8111df8c:	f800283a 	ret
8111df90:	0005883a 	mov	r2,zero
8111df94:	f800283a 	ret

8111df98 <__mdiff>:
8111df98:	defffa04 	addi	sp,sp,-24
8111df9c:	de00012e 	bgeu	sp,et,8111dfa4 <__mdiff+0xc>
8111dfa0:	003b68fa 	trap	3
8111dfa4:	28c00417 	ldw	r3,16(r5)
8111dfa8:	30800417 	ldw	r2,16(r6)
8111dfac:	dcc00315 	stw	r19,12(sp)
8111dfb0:	dc800215 	stw	r18,8(sp)
8111dfb4:	dfc00515 	stw	ra,20(sp)
8111dfb8:	dd000415 	stw	r20,16(sp)
8111dfbc:	dc400115 	stw	r17,4(sp)
8111dfc0:	dc000015 	stw	r16,0(sp)
8111dfc4:	1887c83a 	sub	r3,r3,r2
8111dfc8:	2825883a 	mov	r18,r5
8111dfcc:	3027883a 	mov	r19,r6
8111dfd0:	1800141e 	bne	r3,zero,8111e024 <__mdiff+0x8c>
8111dfd4:	1085883a 	add	r2,r2,r2
8111dfd8:	1085883a 	add	r2,r2,r2
8111dfdc:	2a000504 	addi	r8,r5,20
8111dfe0:	34000504 	addi	r16,r6,20
8111dfe4:	4087883a 	add	r3,r8,r2
8111dfe8:	8085883a 	add	r2,r16,r2
8111dfec:	00000106 	br	8111dff4 <__mdiff+0x5c>
8111dff0:	40c0592e 	bgeu	r8,r3,8111e158 <__mdiff+0x1c0>
8111dff4:	18ffff04 	addi	r3,r3,-4
8111dff8:	10bfff04 	addi	r2,r2,-4
8111dffc:	19c00017 	ldw	r7,0(r3)
8111e000:	11400017 	ldw	r5,0(r2)
8111e004:	397ffa26 	beq	r7,r5,8111dff0 <__reset+0xfb0fdff0>
8111e008:	3940592e 	bgeu	r7,r5,8111e170 <__mdiff+0x1d8>
8111e00c:	9005883a 	mov	r2,r18
8111e010:	4023883a 	mov	r17,r8
8111e014:	9825883a 	mov	r18,r19
8111e018:	05000044 	movi	r20,1
8111e01c:	1027883a 	mov	r19,r2
8111e020:	00000406 	br	8111e034 <__mdiff+0x9c>
8111e024:	18005616 	blt	r3,zero,8111e180 <__mdiff+0x1e8>
8111e028:	34400504 	addi	r17,r6,20
8111e02c:	2c000504 	addi	r16,r5,20
8111e030:	0029883a 	mov	r20,zero
8111e034:	91400117 	ldw	r5,4(r18)
8111e038:	111d6380 	call	8111d638 <_Balloc>
8111e03c:	92400417 	ldw	r9,16(r18)
8111e040:	9b000417 	ldw	r12,16(r19)
8111e044:	12c00504 	addi	r11,r2,20
8111e048:	4a51883a 	add	r8,r9,r9
8111e04c:	6319883a 	add	r12,r12,r12
8111e050:	4211883a 	add	r8,r8,r8
8111e054:	6319883a 	add	r12,r12,r12
8111e058:	15000315 	stw	r20,12(r2)
8111e05c:	8211883a 	add	r8,r16,r8
8111e060:	8b19883a 	add	r12,r17,r12
8111e064:	0007883a 	mov	r3,zero
8111e068:	81400017 	ldw	r5,0(r16)
8111e06c:	89c00017 	ldw	r7,0(r17)
8111e070:	59800104 	addi	r6,r11,4
8111e074:	293fffcc 	andi	r4,r5,65535
8111e078:	20c7883a 	add	r3,r4,r3
8111e07c:	393fffcc 	andi	r4,r7,65535
8111e080:	1909c83a 	sub	r4,r3,r4
8111e084:	280ad43a 	srli	r5,r5,16
8111e088:	380ed43a 	srli	r7,r7,16
8111e08c:	2007d43a 	srai	r3,r4,16
8111e090:	213fffcc 	andi	r4,r4,65535
8111e094:	29cbc83a 	sub	r5,r5,r7
8111e098:	28c7883a 	add	r3,r5,r3
8111e09c:	180a943a 	slli	r5,r3,16
8111e0a0:	8c400104 	addi	r17,r17,4
8111e0a4:	84000104 	addi	r16,r16,4
8111e0a8:	2908b03a 	or	r4,r5,r4
8111e0ac:	59000015 	stw	r4,0(r11)
8111e0b0:	1807d43a 	srai	r3,r3,16
8111e0b4:	3015883a 	mov	r10,r6
8111e0b8:	3017883a 	mov	r11,r6
8111e0bc:	8b3fea36 	bltu	r17,r12,8111e068 <__reset+0xfb0fe068>
8111e0c0:	8200162e 	bgeu	r16,r8,8111e11c <__mdiff+0x184>
8111e0c4:	8017883a 	mov	r11,r16
8111e0c8:	59400017 	ldw	r5,0(r11)
8111e0cc:	31800104 	addi	r6,r6,4
8111e0d0:	5ac00104 	addi	r11,r11,4
8111e0d4:	293fffcc 	andi	r4,r5,65535
8111e0d8:	20c7883a 	add	r3,r4,r3
8111e0dc:	280ed43a 	srli	r7,r5,16
8111e0e0:	180bd43a 	srai	r5,r3,16
8111e0e4:	193fffcc 	andi	r4,r3,65535
8111e0e8:	3947883a 	add	r3,r7,r5
8111e0ec:	180a943a 	slli	r5,r3,16
8111e0f0:	1807d43a 	srai	r3,r3,16
8111e0f4:	2908b03a 	or	r4,r5,r4
8111e0f8:	313fff15 	stw	r4,-4(r6)
8111e0fc:	5a3ff236 	bltu	r11,r8,8111e0c8 <__reset+0xfb0fe0c8>
8111e100:	0406303a 	nor	r3,zero,r16
8111e104:	1a07883a 	add	r3,r3,r8
8111e108:	1806d0ba 	srli	r3,r3,2
8111e10c:	18c00044 	addi	r3,r3,1
8111e110:	18c7883a 	add	r3,r3,r3
8111e114:	18c7883a 	add	r3,r3,r3
8111e118:	50d5883a 	add	r10,r10,r3
8111e11c:	50ffff04 	addi	r3,r10,-4
8111e120:	2000041e 	bne	r4,zero,8111e134 <__mdiff+0x19c>
8111e124:	18ffff04 	addi	r3,r3,-4
8111e128:	19000017 	ldw	r4,0(r3)
8111e12c:	4a7fffc4 	addi	r9,r9,-1
8111e130:	203ffc26 	beq	r4,zero,8111e124 <__reset+0xfb0fe124>
8111e134:	12400415 	stw	r9,16(r2)
8111e138:	dfc00517 	ldw	ra,20(sp)
8111e13c:	dd000417 	ldw	r20,16(sp)
8111e140:	dcc00317 	ldw	r19,12(sp)
8111e144:	dc800217 	ldw	r18,8(sp)
8111e148:	dc400117 	ldw	r17,4(sp)
8111e14c:	dc000017 	ldw	r16,0(sp)
8111e150:	dec00604 	addi	sp,sp,24
8111e154:	f800283a 	ret
8111e158:	000b883a 	mov	r5,zero
8111e15c:	111d6380 	call	8111d638 <_Balloc>
8111e160:	00c00044 	movi	r3,1
8111e164:	10c00415 	stw	r3,16(r2)
8111e168:	10000515 	stw	zero,20(r2)
8111e16c:	003ff206 	br	8111e138 <__reset+0xfb0fe138>
8111e170:	8023883a 	mov	r17,r16
8111e174:	0029883a 	mov	r20,zero
8111e178:	4021883a 	mov	r16,r8
8111e17c:	003fad06 	br	8111e034 <__reset+0xfb0fe034>
8111e180:	9005883a 	mov	r2,r18
8111e184:	94400504 	addi	r17,r18,20
8111e188:	9c000504 	addi	r16,r19,20
8111e18c:	9825883a 	mov	r18,r19
8111e190:	05000044 	movi	r20,1
8111e194:	1027883a 	mov	r19,r2
8111e198:	003fa606 	br	8111e034 <__reset+0xfb0fe034>

8111e19c <__ulp>:
8111e19c:	295ffc2c 	andhi	r5,r5,32752
8111e1a0:	00bf3034 	movhi	r2,64704
8111e1a4:	2887883a 	add	r3,r5,r2
8111e1a8:	00c0020e 	bge	zero,r3,8111e1b4 <__ulp+0x18>
8111e1ac:	0005883a 	mov	r2,zero
8111e1b0:	f800283a 	ret
8111e1b4:	00c7c83a 	sub	r3,zero,r3
8111e1b8:	1807d53a 	srai	r3,r3,20
8111e1bc:	008004c4 	movi	r2,19
8111e1c0:	10c00b0e 	bge	r2,r3,8111e1f0 <__ulp+0x54>
8111e1c4:	18bffb04 	addi	r2,r3,-20
8111e1c8:	01000784 	movi	r4,30
8111e1cc:	0007883a 	mov	r3,zero
8111e1d0:	20800516 	blt	r4,r2,8111e1e8 <__ulp+0x4c>
8111e1d4:	010007c4 	movi	r4,31
8111e1d8:	2089c83a 	sub	r4,r4,r2
8111e1dc:	00800044 	movi	r2,1
8111e1e0:	1104983a 	sll	r2,r2,r4
8111e1e4:	f800283a 	ret
8111e1e8:	00800044 	movi	r2,1
8111e1ec:	f800283a 	ret
8111e1f0:	01400234 	movhi	r5,8
8111e1f4:	28c7d83a 	sra	r3,r5,r3
8111e1f8:	0005883a 	mov	r2,zero
8111e1fc:	f800283a 	ret

8111e200 <__b2d>:
8111e200:	defffa04 	addi	sp,sp,-24
8111e204:	de00012e 	bgeu	sp,et,8111e20c <__b2d+0xc>
8111e208:	003b68fa 	trap	3
8111e20c:	dc000015 	stw	r16,0(sp)
8111e210:	24000417 	ldw	r16,16(r4)
8111e214:	dc400115 	stw	r17,4(sp)
8111e218:	24400504 	addi	r17,r4,20
8111e21c:	8421883a 	add	r16,r16,r16
8111e220:	8421883a 	add	r16,r16,r16
8111e224:	8c21883a 	add	r16,r17,r16
8111e228:	dc800215 	stw	r18,8(sp)
8111e22c:	84bfff17 	ldw	r18,-4(r16)
8111e230:	dd000415 	stw	r20,16(sp)
8111e234:	dcc00315 	stw	r19,12(sp)
8111e238:	9009883a 	mov	r4,r18
8111e23c:	2829883a 	mov	r20,r5
8111e240:	dfc00515 	stw	ra,20(sp)
8111e244:	111d9440 	call	8111d944 <__hi0bits>
8111e248:	00c00804 	movi	r3,32
8111e24c:	1889c83a 	sub	r4,r3,r2
8111e250:	a1000015 	stw	r4,0(r20)
8111e254:	01000284 	movi	r4,10
8111e258:	84ffff04 	addi	r19,r16,-4
8111e25c:	20801216 	blt	r4,r2,8111e2a8 <__b2d+0xa8>
8111e260:	018002c4 	movi	r6,11
8111e264:	308dc83a 	sub	r6,r6,r2
8111e268:	9186d83a 	srl	r3,r18,r6
8111e26c:	18cffc34 	orhi	r3,r3,16368
8111e270:	8cc0212e 	bgeu	r17,r19,8111e2f8 <__b2d+0xf8>
8111e274:	813ffe17 	ldw	r4,-8(r16)
8111e278:	218cd83a 	srl	r6,r4,r6
8111e27c:	10800544 	addi	r2,r2,21
8111e280:	9084983a 	sll	r2,r18,r2
8111e284:	1184b03a 	or	r2,r2,r6
8111e288:	dfc00517 	ldw	ra,20(sp)
8111e28c:	dd000417 	ldw	r20,16(sp)
8111e290:	dcc00317 	ldw	r19,12(sp)
8111e294:	dc800217 	ldw	r18,8(sp)
8111e298:	dc400117 	ldw	r17,4(sp)
8111e29c:	dc000017 	ldw	r16,0(sp)
8111e2a0:	dec00604 	addi	sp,sp,24
8111e2a4:	f800283a 	ret
8111e2a8:	8cc00f2e 	bgeu	r17,r19,8111e2e8 <__b2d+0xe8>
8111e2ac:	117ffd44 	addi	r5,r2,-11
8111e2b0:	80bffe17 	ldw	r2,-8(r16)
8111e2b4:	28000e26 	beq	r5,zero,8111e2f0 <__b2d+0xf0>
8111e2b8:	1949c83a 	sub	r4,r3,r5
8111e2bc:	9164983a 	sll	r18,r18,r5
8111e2c0:	1106d83a 	srl	r3,r2,r4
8111e2c4:	81bffe04 	addi	r6,r16,-8
8111e2c8:	948ffc34 	orhi	r18,r18,16368
8111e2cc:	90c6b03a 	or	r3,r18,r3
8111e2d0:	89800e2e 	bgeu	r17,r6,8111e30c <__b2d+0x10c>
8111e2d4:	81bffd17 	ldw	r6,-12(r16)
8111e2d8:	1144983a 	sll	r2,r2,r5
8111e2dc:	310ad83a 	srl	r5,r6,r4
8111e2e0:	2884b03a 	or	r2,r5,r2
8111e2e4:	003fe806 	br	8111e288 <__reset+0xfb0fe288>
8111e2e8:	10bffd44 	addi	r2,r2,-11
8111e2ec:	1000041e 	bne	r2,zero,8111e300 <__b2d+0x100>
8111e2f0:	90cffc34 	orhi	r3,r18,16368
8111e2f4:	003fe406 	br	8111e288 <__reset+0xfb0fe288>
8111e2f8:	000d883a 	mov	r6,zero
8111e2fc:	003fdf06 	br	8111e27c <__reset+0xfb0fe27c>
8111e300:	90a4983a 	sll	r18,r18,r2
8111e304:	0005883a 	mov	r2,zero
8111e308:	003ff906 	br	8111e2f0 <__reset+0xfb0fe2f0>
8111e30c:	1144983a 	sll	r2,r2,r5
8111e310:	003fdd06 	br	8111e288 <__reset+0xfb0fe288>

8111e314 <__d2b>:
8111e314:	defff804 	addi	sp,sp,-32
8111e318:	de00012e 	bgeu	sp,et,8111e320 <__d2b+0xc>
8111e31c:	003b68fa 	trap	3
8111e320:	dc000215 	stw	r16,8(sp)
8111e324:	3021883a 	mov	r16,r6
8111e328:	dc400315 	stw	r17,12(sp)
8111e32c:	8022907a 	slli	r17,r16,1
8111e330:	dd000615 	stw	r20,24(sp)
8111e334:	2829883a 	mov	r20,r5
8111e338:	01400044 	movi	r5,1
8111e33c:	dcc00515 	stw	r19,20(sp)
8111e340:	dc800415 	stw	r18,16(sp)
8111e344:	dfc00715 	stw	ra,28(sp)
8111e348:	3825883a 	mov	r18,r7
8111e34c:	8822d57a 	srli	r17,r17,21
8111e350:	111d6380 	call	8111d638 <_Balloc>
8111e354:	1027883a 	mov	r19,r2
8111e358:	00800434 	movhi	r2,16
8111e35c:	10bfffc4 	addi	r2,r2,-1
8111e360:	808c703a 	and	r6,r16,r2
8111e364:	88000126 	beq	r17,zero,8111e36c <__d2b+0x58>
8111e368:	31800434 	orhi	r6,r6,16
8111e36c:	d9800015 	stw	r6,0(sp)
8111e370:	a0002426 	beq	r20,zero,8111e404 <__d2b+0xf0>
8111e374:	d9000104 	addi	r4,sp,4
8111e378:	dd000115 	stw	r20,4(sp)
8111e37c:	111d9ac0 	call	8111d9ac <__lo0bits>
8111e380:	d8c00017 	ldw	r3,0(sp)
8111e384:	10002f1e 	bne	r2,zero,8111e444 <__d2b+0x130>
8111e388:	d9000117 	ldw	r4,4(sp)
8111e38c:	99000515 	stw	r4,20(r19)
8111e390:	1821003a 	cmpeq	r16,r3,zero
8111e394:	01000084 	movi	r4,2
8111e398:	2421c83a 	sub	r16,r4,r16
8111e39c:	98c00615 	stw	r3,24(r19)
8111e3a0:	9c000415 	stw	r16,16(r19)
8111e3a4:	88001f1e 	bne	r17,zero,8111e424 <__d2b+0x110>
8111e3a8:	10bef384 	addi	r2,r2,-1074
8111e3ac:	90800015 	stw	r2,0(r18)
8111e3b0:	00900034 	movhi	r2,16384
8111e3b4:	10bfffc4 	addi	r2,r2,-1
8111e3b8:	8085883a 	add	r2,r16,r2
8111e3bc:	1085883a 	add	r2,r2,r2
8111e3c0:	1085883a 	add	r2,r2,r2
8111e3c4:	9885883a 	add	r2,r19,r2
8111e3c8:	11000517 	ldw	r4,20(r2)
8111e3cc:	8020917a 	slli	r16,r16,5
8111e3d0:	111d9440 	call	8111d944 <__hi0bits>
8111e3d4:	d8c00817 	ldw	r3,32(sp)
8111e3d8:	8085c83a 	sub	r2,r16,r2
8111e3dc:	18800015 	stw	r2,0(r3)
8111e3e0:	9805883a 	mov	r2,r19
8111e3e4:	dfc00717 	ldw	ra,28(sp)
8111e3e8:	dd000617 	ldw	r20,24(sp)
8111e3ec:	dcc00517 	ldw	r19,20(sp)
8111e3f0:	dc800417 	ldw	r18,16(sp)
8111e3f4:	dc400317 	ldw	r17,12(sp)
8111e3f8:	dc000217 	ldw	r16,8(sp)
8111e3fc:	dec00804 	addi	sp,sp,32
8111e400:	f800283a 	ret
8111e404:	d809883a 	mov	r4,sp
8111e408:	111d9ac0 	call	8111d9ac <__lo0bits>
8111e40c:	d8c00017 	ldw	r3,0(sp)
8111e410:	04000044 	movi	r16,1
8111e414:	9c000415 	stw	r16,16(r19)
8111e418:	98c00515 	stw	r3,20(r19)
8111e41c:	10800804 	addi	r2,r2,32
8111e420:	883fe126 	beq	r17,zero,8111e3a8 <__reset+0xfb0fe3a8>
8111e424:	00c00d44 	movi	r3,53
8111e428:	8c7ef344 	addi	r17,r17,-1075
8111e42c:	88a3883a 	add	r17,r17,r2
8111e430:	1885c83a 	sub	r2,r3,r2
8111e434:	d8c00817 	ldw	r3,32(sp)
8111e438:	94400015 	stw	r17,0(r18)
8111e43c:	18800015 	stw	r2,0(r3)
8111e440:	003fe706 	br	8111e3e0 <__reset+0xfb0fe3e0>
8111e444:	01000804 	movi	r4,32
8111e448:	2089c83a 	sub	r4,r4,r2
8111e44c:	1908983a 	sll	r4,r3,r4
8111e450:	d9400117 	ldw	r5,4(sp)
8111e454:	1886d83a 	srl	r3,r3,r2
8111e458:	2148b03a 	or	r4,r4,r5
8111e45c:	99000515 	stw	r4,20(r19)
8111e460:	d8c00015 	stw	r3,0(sp)
8111e464:	003fca06 	br	8111e390 <__reset+0xfb0fe390>

8111e468 <__ratio>:
8111e468:	defff904 	addi	sp,sp,-28
8111e46c:	de00012e 	bgeu	sp,et,8111e474 <__ratio+0xc>
8111e470:	003b68fa 	trap	3
8111e474:	dc400315 	stw	r17,12(sp)
8111e478:	2823883a 	mov	r17,r5
8111e47c:	d9400104 	addi	r5,sp,4
8111e480:	dfc00615 	stw	ra,24(sp)
8111e484:	dcc00515 	stw	r19,20(sp)
8111e488:	dc800415 	stw	r18,16(sp)
8111e48c:	2027883a 	mov	r19,r4
8111e490:	dc000215 	stw	r16,8(sp)
8111e494:	111e2000 	call	8111e200 <__b2d>
8111e498:	d80b883a 	mov	r5,sp
8111e49c:	8809883a 	mov	r4,r17
8111e4a0:	1025883a 	mov	r18,r2
8111e4a4:	1821883a 	mov	r16,r3
8111e4a8:	111e2000 	call	8111e200 <__b2d>
8111e4ac:	8a000417 	ldw	r8,16(r17)
8111e4b0:	99000417 	ldw	r4,16(r19)
8111e4b4:	d9400117 	ldw	r5,4(sp)
8111e4b8:	2209c83a 	sub	r4,r4,r8
8111e4bc:	2010917a 	slli	r8,r4,5
8111e4c0:	d9000017 	ldw	r4,0(sp)
8111e4c4:	2909c83a 	sub	r4,r5,r4
8111e4c8:	4109883a 	add	r4,r8,r4
8111e4cc:	01000e0e 	bge	zero,r4,8111e508 <__ratio+0xa0>
8111e4d0:	2008953a 	slli	r4,r4,20
8111e4d4:	2421883a 	add	r16,r4,r16
8111e4d8:	100d883a 	mov	r6,r2
8111e4dc:	180f883a 	mov	r7,r3
8111e4e0:	9009883a 	mov	r4,r18
8111e4e4:	800b883a 	mov	r5,r16
8111e4e8:	11266bc0 	call	811266bc <__divdf3>
8111e4ec:	dfc00617 	ldw	ra,24(sp)
8111e4f0:	dcc00517 	ldw	r19,20(sp)
8111e4f4:	dc800417 	ldw	r18,16(sp)
8111e4f8:	dc400317 	ldw	r17,12(sp)
8111e4fc:	dc000217 	ldw	r16,8(sp)
8111e500:	dec00704 	addi	sp,sp,28
8111e504:	f800283a 	ret
8111e508:	2008953a 	slli	r4,r4,20
8111e50c:	1907c83a 	sub	r3,r3,r4
8111e510:	003ff106 	br	8111e4d8 <__reset+0xfb0fe4d8>

8111e514 <_mprec_log10>:
8111e514:	defffe04 	addi	sp,sp,-8
8111e518:	de00012e 	bgeu	sp,et,8111e520 <_mprec_log10+0xc>
8111e51c:	003b68fa 	trap	3
8111e520:	008005c4 	movi	r2,23
8111e524:	dc000015 	stw	r16,0(sp)
8111e528:	dfc00115 	stw	ra,4(sp)
8111e52c:	2021883a 	mov	r16,r4
8111e530:	11000d0e 	bge	r2,r4,8111e568 <_mprec_log10+0x54>
8111e534:	0005883a 	mov	r2,zero
8111e538:	00cffc34 	movhi	r3,16368
8111e53c:	843fffc4 	addi	r16,r16,-1
8111e540:	000d883a 	mov	r6,zero
8111e544:	01d00934 	movhi	r7,16420
8111e548:	1009883a 	mov	r4,r2
8111e54c:	180b883a 	mov	r5,r3
8111e550:	1111b400 	call	81111b40 <__muldf3>
8111e554:	803ff91e 	bne	r16,zero,8111e53c <__reset+0xfb0fe53c>
8111e558:	dfc00117 	ldw	ra,4(sp)
8111e55c:	dc000017 	ldw	r16,0(sp)
8111e560:	dec00204 	addi	sp,sp,8
8111e564:	f800283a 	ret
8111e568:	202090fa 	slli	r16,r4,3
8111e56c:	00a04534 	movhi	r2,33044
8111e570:	10bde904 	addi	r2,r2,-2140
8111e574:	1421883a 	add	r16,r2,r16
8111e578:	80800017 	ldw	r2,0(r16)
8111e57c:	80c00117 	ldw	r3,4(r16)
8111e580:	dfc00117 	ldw	ra,4(sp)
8111e584:	dc000017 	ldw	r16,0(sp)
8111e588:	dec00204 	addi	sp,sp,8
8111e58c:	f800283a 	ret

8111e590 <__copybits>:
8111e590:	297fffc4 	addi	r5,r5,-1
8111e594:	280fd17a 	srai	r7,r5,5
8111e598:	30c00417 	ldw	r3,16(r6)
8111e59c:	30800504 	addi	r2,r6,20
8111e5a0:	39c00044 	addi	r7,r7,1
8111e5a4:	18c7883a 	add	r3,r3,r3
8111e5a8:	39cf883a 	add	r7,r7,r7
8111e5ac:	18c7883a 	add	r3,r3,r3
8111e5b0:	39cf883a 	add	r7,r7,r7
8111e5b4:	10c7883a 	add	r3,r2,r3
8111e5b8:	21cf883a 	add	r7,r4,r7
8111e5bc:	10c00d2e 	bgeu	r2,r3,8111e5f4 <__copybits+0x64>
8111e5c0:	200b883a 	mov	r5,r4
8111e5c4:	12000017 	ldw	r8,0(r2)
8111e5c8:	29400104 	addi	r5,r5,4
8111e5cc:	10800104 	addi	r2,r2,4
8111e5d0:	2a3fff15 	stw	r8,-4(r5)
8111e5d4:	10fffb36 	bltu	r2,r3,8111e5c4 <__reset+0xfb0fe5c4>
8111e5d8:	1985c83a 	sub	r2,r3,r6
8111e5dc:	10bffac4 	addi	r2,r2,-21
8111e5e0:	1004d0ba 	srli	r2,r2,2
8111e5e4:	10800044 	addi	r2,r2,1
8111e5e8:	1085883a 	add	r2,r2,r2
8111e5ec:	1085883a 	add	r2,r2,r2
8111e5f0:	2089883a 	add	r4,r4,r2
8111e5f4:	21c0032e 	bgeu	r4,r7,8111e604 <__copybits+0x74>
8111e5f8:	20000015 	stw	zero,0(r4)
8111e5fc:	21000104 	addi	r4,r4,4
8111e600:	21fffd36 	bltu	r4,r7,8111e5f8 <__reset+0xfb0fe5f8>
8111e604:	f800283a 	ret

8111e608 <__any_on>:
8111e608:	20c00417 	ldw	r3,16(r4)
8111e60c:	2805d17a 	srai	r2,r5,5
8111e610:	21000504 	addi	r4,r4,20
8111e614:	18800d0e 	bge	r3,r2,8111e64c <__any_on+0x44>
8111e618:	18c7883a 	add	r3,r3,r3
8111e61c:	18c7883a 	add	r3,r3,r3
8111e620:	20c7883a 	add	r3,r4,r3
8111e624:	20c0192e 	bgeu	r4,r3,8111e68c <__any_on+0x84>
8111e628:	18bfff17 	ldw	r2,-4(r3)
8111e62c:	18ffff04 	addi	r3,r3,-4
8111e630:	1000041e 	bne	r2,zero,8111e644 <__any_on+0x3c>
8111e634:	20c0142e 	bgeu	r4,r3,8111e688 <__any_on+0x80>
8111e638:	18ffff04 	addi	r3,r3,-4
8111e63c:	19400017 	ldw	r5,0(r3)
8111e640:	283ffc26 	beq	r5,zero,8111e634 <__reset+0xfb0fe634>
8111e644:	00800044 	movi	r2,1
8111e648:	f800283a 	ret
8111e64c:	10c00a0e 	bge	r2,r3,8111e678 <__any_on+0x70>
8111e650:	1085883a 	add	r2,r2,r2
8111e654:	1085883a 	add	r2,r2,r2
8111e658:	294007cc 	andi	r5,r5,31
8111e65c:	2087883a 	add	r3,r4,r2
8111e660:	283ff026 	beq	r5,zero,8111e624 <__reset+0xfb0fe624>
8111e664:	19800017 	ldw	r6,0(r3)
8111e668:	3144d83a 	srl	r2,r6,r5
8111e66c:	114a983a 	sll	r5,r2,r5
8111e670:	317ff41e 	bne	r6,r5,8111e644 <__reset+0xfb0fe644>
8111e674:	003feb06 	br	8111e624 <__reset+0xfb0fe624>
8111e678:	1085883a 	add	r2,r2,r2
8111e67c:	1085883a 	add	r2,r2,r2
8111e680:	2087883a 	add	r3,r4,r2
8111e684:	003fe706 	br	8111e624 <__reset+0xfb0fe624>
8111e688:	f800283a 	ret
8111e68c:	0005883a 	mov	r2,zero
8111e690:	f800283a 	ret

8111e694 <_read_r>:
8111e694:	defffd04 	addi	sp,sp,-12
8111e698:	de00012e 	bgeu	sp,et,8111e6a0 <_read_r+0xc>
8111e69c:	003b68fa 	trap	3
8111e6a0:	2805883a 	mov	r2,r5
8111e6a4:	dc000015 	stw	r16,0(sp)
8111e6a8:	04204534 	movhi	r16,33044
8111e6ac:	dc400115 	stw	r17,4(sp)
8111e6b0:	300b883a 	mov	r5,r6
8111e6b4:	84070504 	addi	r16,r16,7188
8111e6b8:	2023883a 	mov	r17,r4
8111e6bc:	380d883a 	mov	r6,r7
8111e6c0:	1009883a 	mov	r4,r2
8111e6c4:	dfc00215 	stw	ra,8(sp)
8111e6c8:	80000015 	stw	zero,0(r16)
8111e6cc:	11287cc0 	call	811287cc <read>
8111e6d0:	00ffffc4 	movi	r3,-1
8111e6d4:	10c00526 	beq	r2,r3,8111e6ec <_read_r+0x58>
8111e6d8:	dfc00217 	ldw	ra,8(sp)
8111e6dc:	dc400117 	ldw	r17,4(sp)
8111e6e0:	dc000017 	ldw	r16,0(sp)
8111e6e4:	dec00304 	addi	sp,sp,12
8111e6e8:	f800283a 	ret
8111e6ec:	80c00017 	ldw	r3,0(r16)
8111e6f0:	183ff926 	beq	r3,zero,8111e6d8 <__reset+0xfb0fe6d8>
8111e6f4:	88c00015 	stw	r3,0(r17)
8111e6f8:	003ff706 	br	8111e6d8 <__reset+0xfb0fe6d8>

8111e6fc <_realloc_r>:
8111e6fc:	defff604 	addi	sp,sp,-40
8111e700:	de00012e 	bgeu	sp,et,8111e708 <_realloc_r+0xc>
8111e704:	003b68fa 	trap	3
8111e708:	dc800215 	stw	r18,8(sp)
8111e70c:	dfc00915 	stw	ra,36(sp)
8111e710:	df000815 	stw	fp,32(sp)
8111e714:	ddc00715 	stw	r23,28(sp)
8111e718:	dd800615 	stw	r22,24(sp)
8111e71c:	dd400515 	stw	r21,20(sp)
8111e720:	dd000415 	stw	r20,16(sp)
8111e724:	dcc00315 	stw	r19,12(sp)
8111e728:	dc400115 	stw	r17,4(sp)
8111e72c:	dc000015 	stw	r16,0(sp)
8111e730:	3025883a 	mov	r18,r6
8111e734:	2800b726 	beq	r5,zero,8111ea14 <_realloc_r+0x318>
8111e738:	282b883a 	mov	r21,r5
8111e73c:	2029883a 	mov	r20,r4
8111e740:	1128fa00 	call	81128fa0 <__malloc_lock>
8111e744:	a8bfff17 	ldw	r2,-4(r21)
8111e748:	043fff04 	movi	r16,-4
8111e74c:	90c002c4 	addi	r3,r18,11
8111e750:	01000584 	movi	r4,22
8111e754:	acfffe04 	addi	r19,r21,-8
8111e758:	1420703a 	and	r16,r2,r16
8111e75c:	20c0332e 	bgeu	r4,r3,8111e82c <_realloc_r+0x130>
8111e760:	047ffe04 	movi	r17,-8
8111e764:	1c62703a 	and	r17,r3,r17
8111e768:	8807883a 	mov	r3,r17
8111e76c:	88005816 	blt	r17,zero,8111e8d0 <_realloc_r+0x1d4>
8111e770:	8c805736 	bltu	r17,r18,8111e8d0 <_realloc_r+0x1d4>
8111e774:	80c0300e 	bge	r16,r3,8111e838 <_realloc_r+0x13c>
8111e778:	07204534 	movhi	fp,33044
8111e77c:	e7008f04 	addi	fp,fp,572
8111e780:	e1c00217 	ldw	r7,8(fp)
8111e784:	9c09883a 	add	r4,r19,r16
8111e788:	22000117 	ldw	r8,4(r4)
8111e78c:	21c06326 	beq	r4,r7,8111e91c <_realloc_r+0x220>
8111e790:	017fff84 	movi	r5,-2
8111e794:	414a703a 	and	r5,r8,r5
8111e798:	214b883a 	add	r5,r4,r5
8111e79c:	29800117 	ldw	r6,4(r5)
8111e7a0:	3180004c 	andi	r6,r6,1
8111e7a4:	30003f26 	beq	r6,zero,8111e8a4 <_realloc_r+0x1a8>
8111e7a8:	1080004c 	andi	r2,r2,1
8111e7ac:	10008326 	beq	r2,zero,8111e9bc <_realloc_r+0x2c0>
8111e7b0:	900b883a 	mov	r5,r18
8111e7b4:	a009883a 	mov	r4,r20
8111e7b8:	1112ecc0 	call	81112ecc <_malloc_r>
8111e7bc:	1025883a 	mov	r18,r2
8111e7c0:	10011e26 	beq	r2,zero,8111ec3c <_realloc_r+0x540>
8111e7c4:	a93fff17 	ldw	r4,-4(r21)
8111e7c8:	10fffe04 	addi	r3,r2,-8
8111e7cc:	00bfff84 	movi	r2,-2
8111e7d0:	2084703a 	and	r2,r4,r2
8111e7d4:	9885883a 	add	r2,r19,r2
8111e7d8:	1880ee26 	beq	r3,r2,8111eb94 <_realloc_r+0x498>
8111e7dc:	81bfff04 	addi	r6,r16,-4
8111e7e0:	00800904 	movi	r2,36
8111e7e4:	1180b836 	bltu	r2,r6,8111eac8 <_realloc_r+0x3cc>
8111e7e8:	00c004c4 	movi	r3,19
8111e7ec:	19809636 	bltu	r3,r6,8111ea48 <_realloc_r+0x34c>
8111e7f0:	9005883a 	mov	r2,r18
8111e7f4:	a807883a 	mov	r3,r21
8111e7f8:	19000017 	ldw	r4,0(r3)
8111e7fc:	11000015 	stw	r4,0(r2)
8111e800:	19000117 	ldw	r4,4(r3)
8111e804:	11000115 	stw	r4,4(r2)
8111e808:	18c00217 	ldw	r3,8(r3)
8111e80c:	10c00215 	stw	r3,8(r2)
8111e810:	a80b883a 	mov	r5,r21
8111e814:	a009883a 	mov	r4,r20
8111e818:	111c6680 	call	8111c668 <_free_r>
8111e81c:	a009883a 	mov	r4,r20
8111e820:	11290c80 	call	811290c8 <__malloc_unlock>
8111e824:	9005883a 	mov	r2,r18
8111e828:	00001206 	br	8111e874 <_realloc_r+0x178>
8111e82c:	00c00404 	movi	r3,16
8111e830:	1823883a 	mov	r17,r3
8111e834:	003fce06 	br	8111e770 <__reset+0xfb0fe770>
8111e838:	a825883a 	mov	r18,r21
8111e83c:	8445c83a 	sub	r2,r16,r17
8111e840:	00c003c4 	movi	r3,15
8111e844:	18802636 	bltu	r3,r2,8111e8e0 <_realloc_r+0x1e4>
8111e848:	99800117 	ldw	r6,4(r19)
8111e84c:	9c07883a 	add	r3,r19,r16
8111e850:	3180004c 	andi	r6,r6,1
8111e854:	3420b03a 	or	r16,r6,r16
8111e858:	9c000115 	stw	r16,4(r19)
8111e85c:	18800117 	ldw	r2,4(r3)
8111e860:	10800054 	ori	r2,r2,1
8111e864:	18800115 	stw	r2,4(r3)
8111e868:	a009883a 	mov	r4,r20
8111e86c:	11290c80 	call	811290c8 <__malloc_unlock>
8111e870:	9005883a 	mov	r2,r18
8111e874:	dfc00917 	ldw	ra,36(sp)
8111e878:	df000817 	ldw	fp,32(sp)
8111e87c:	ddc00717 	ldw	r23,28(sp)
8111e880:	dd800617 	ldw	r22,24(sp)
8111e884:	dd400517 	ldw	r21,20(sp)
8111e888:	dd000417 	ldw	r20,16(sp)
8111e88c:	dcc00317 	ldw	r19,12(sp)
8111e890:	dc800217 	ldw	r18,8(sp)
8111e894:	dc400117 	ldw	r17,4(sp)
8111e898:	dc000017 	ldw	r16,0(sp)
8111e89c:	dec00a04 	addi	sp,sp,40
8111e8a0:	f800283a 	ret
8111e8a4:	017fff04 	movi	r5,-4
8111e8a8:	414a703a 	and	r5,r8,r5
8111e8ac:	814d883a 	add	r6,r16,r5
8111e8b0:	30c01f16 	blt	r6,r3,8111e930 <_realloc_r+0x234>
8111e8b4:	20800317 	ldw	r2,12(r4)
8111e8b8:	20c00217 	ldw	r3,8(r4)
8111e8bc:	a825883a 	mov	r18,r21
8111e8c0:	3021883a 	mov	r16,r6
8111e8c4:	18800315 	stw	r2,12(r3)
8111e8c8:	10c00215 	stw	r3,8(r2)
8111e8cc:	003fdb06 	br	8111e83c <__reset+0xfb0fe83c>
8111e8d0:	00800304 	movi	r2,12
8111e8d4:	a0800015 	stw	r2,0(r20)
8111e8d8:	0005883a 	mov	r2,zero
8111e8dc:	003fe506 	br	8111e874 <__reset+0xfb0fe874>
8111e8e0:	98c00117 	ldw	r3,4(r19)
8111e8e4:	9c4b883a 	add	r5,r19,r17
8111e8e8:	11000054 	ori	r4,r2,1
8111e8ec:	18c0004c 	andi	r3,r3,1
8111e8f0:	1c62b03a 	or	r17,r3,r17
8111e8f4:	9c400115 	stw	r17,4(r19)
8111e8f8:	29000115 	stw	r4,4(r5)
8111e8fc:	2885883a 	add	r2,r5,r2
8111e900:	10c00117 	ldw	r3,4(r2)
8111e904:	29400204 	addi	r5,r5,8
8111e908:	a009883a 	mov	r4,r20
8111e90c:	18c00054 	ori	r3,r3,1
8111e910:	10c00115 	stw	r3,4(r2)
8111e914:	111c6680 	call	8111c668 <_free_r>
8111e918:	003fd306 	br	8111e868 <__reset+0xfb0fe868>
8111e91c:	017fff04 	movi	r5,-4
8111e920:	414a703a 	and	r5,r8,r5
8111e924:	89800404 	addi	r6,r17,16
8111e928:	8151883a 	add	r8,r16,r5
8111e92c:	4180590e 	bge	r8,r6,8111ea94 <_realloc_r+0x398>
8111e930:	1080004c 	andi	r2,r2,1
8111e934:	103f9e1e 	bne	r2,zero,8111e7b0 <__reset+0xfb0fe7b0>
8111e938:	adbffe17 	ldw	r22,-8(r21)
8111e93c:	00bfff04 	movi	r2,-4
8111e940:	9dadc83a 	sub	r22,r19,r22
8111e944:	b1800117 	ldw	r6,4(r22)
8111e948:	3084703a 	and	r2,r6,r2
8111e94c:	20002026 	beq	r4,zero,8111e9d0 <_realloc_r+0x2d4>
8111e950:	80af883a 	add	r23,r16,r2
8111e954:	b96f883a 	add	r23,r23,r5
8111e958:	21c05f26 	beq	r4,r7,8111ead8 <_realloc_r+0x3dc>
8111e95c:	b8c01c16 	blt	r23,r3,8111e9d0 <_realloc_r+0x2d4>
8111e960:	20800317 	ldw	r2,12(r4)
8111e964:	20c00217 	ldw	r3,8(r4)
8111e968:	81bfff04 	addi	r6,r16,-4
8111e96c:	01000904 	movi	r4,36
8111e970:	18800315 	stw	r2,12(r3)
8111e974:	10c00215 	stw	r3,8(r2)
8111e978:	b0c00217 	ldw	r3,8(r22)
8111e97c:	b0800317 	ldw	r2,12(r22)
8111e980:	b4800204 	addi	r18,r22,8
8111e984:	18800315 	stw	r2,12(r3)
8111e988:	10c00215 	stw	r3,8(r2)
8111e98c:	21801b36 	bltu	r4,r6,8111e9fc <_realloc_r+0x300>
8111e990:	008004c4 	movi	r2,19
8111e994:	1180352e 	bgeu	r2,r6,8111ea6c <_realloc_r+0x370>
8111e998:	a8800017 	ldw	r2,0(r21)
8111e99c:	b0800215 	stw	r2,8(r22)
8111e9a0:	a8800117 	ldw	r2,4(r21)
8111e9a4:	b0800315 	stw	r2,12(r22)
8111e9a8:	008006c4 	movi	r2,27
8111e9ac:	11807f36 	bltu	r2,r6,8111ebac <_realloc_r+0x4b0>
8111e9b0:	b0800404 	addi	r2,r22,16
8111e9b4:	ad400204 	addi	r21,r21,8
8111e9b8:	00002d06 	br	8111ea70 <_realloc_r+0x374>
8111e9bc:	adbffe17 	ldw	r22,-8(r21)
8111e9c0:	00bfff04 	movi	r2,-4
8111e9c4:	9dadc83a 	sub	r22,r19,r22
8111e9c8:	b1000117 	ldw	r4,4(r22)
8111e9cc:	2084703a 	and	r2,r4,r2
8111e9d0:	b03f7726 	beq	r22,zero,8111e7b0 <__reset+0xfb0fe7b0>
8111e9d4:	80af883a 	add	r23,r16,r2
8111e9d8:	b8ff7516 	blt	r23,r3,8111e7b0 <__reset+0xfb0fe7b0>
8111e9dc:	b0800317 	ldw	r2,12(r22)
8111e9e0:	b0c00217 	ldw	r3,8(r22)
8111e9e4:	81bfff04 	addi	r6,r16,-4
8111e9e8:	01000904 	movi	r4,36
8111e9ec:	18800315 	stw	r2,12(r3)
8111e9f0:	10c00215 	stw	r3,8(r2)
8111e9f4:	b4800204 	addi	r18,r22,8
8111e9f8:	21bfe52e 	bgeu	r4,r6,8111e990 <__reset+0xfb0fe990>
8111e9fc:	a80b883a 	mov	r5,r21
8111ea00:	9009883a 	mov	r4,r18
8111ea04:	111d4dc0 	call	8111d4dc <memmove>
8111ea08:	b821883a 	mov	r16,r23
8111ea0c:	b027883a 	mov	r19,r22
8111ea10:	003f8a06 	br	8111e83c <__reset+0xfb0fe83c>
8111ea14:	300b883a 	mov	r5,r6
8111ea18:	dfc00917 	ldw	ra,36(sp)
8111ea1c:	df000817 	ldw	fp,32(sp)
8111ea20:	ddc00717 	ldw	r23,28(sp)
8111ea24:	dd800617 	ldw	r22,24(sp)
8111ea28:	dd400517 	ldw	r21,20(sp)
8111ea2c:	dd000417 	ldw	r20,16(sp)
8111ea30:	dcc00317 	ldw	r19,12(sp)
8111ea34:	dc800217 	ldw	r18,8(sp)
8111ea38:	dc400117 	ldw	r17,4(sp)
8111ea3c:	dc000017 	ldw	r16,0(sp)
8111ea40:	dec00a04 	addi	sp,sp,40
8111ea44:	1112ecc1 	jmpi	81112ecc <_malloc_r>
8111ea48:	a8c00017 	ldw	r3,0(r21)
8111ea4c:	90c00015 	stw	r3,0(r18)
8111ea50:	a8c00117 	ldw	r3,4(r21)
8111ea54:	90c00115 	stw	r3,4(r18)
8111ea58:	00c006c4 	movi	r3,27
8111ea5c:	19804536 	bltu	r3,r6,8111eb74 <_realloc_r+0x478>
8111ea60:	90800204 	addi	r2,r18,8
8111ea64:	a8c00204 	addi	r3,r21,8
8111ea68:	003f6306 	br	8111e7f8 <__reset+0xfb0fe7f8>
8111ea6c:	9005883a 	mov	r2,r18
8111ea70:	a8c00017 	ldw	r3,0(r21)
8111ea74:	b821883a 	mov	r16,r23
8111ea78:	b027883a 	mov	r19,r22
8111ea7c:	10c00015 	stw	r3,0(r2)
8111ea80:	a8c00117 	ldw	r3,4(r21)
8111ea84:	10c00115 	stw	r3,4(r2)
8111ea88:	a8c00217 	ldw	r3,8(r21)
8111ea8c:	10c00215 	stw	r3,8(r2)
8111ea90:	003f6a06 	br	8111e83c <__reset+0xfb0fe83c>
8111ea94:	9c67883a 	add	r19,r19,r17
8111ea98:	4445c83a 	sub	r2,r8,r17
8111ea9c:	e4c00215 	stw	r19,8(fp)
8111eaa0:	10800054 	ori	r2,r2,1
8111eaa4:	98800115 	stw	r2,4(r19)
8111eaa8:	a8bfff17 	ldw	r2,-4(r21)
8111eaac:	a009883a 	mov	r4,r20
8111eab0:	1080004c 	andi	r2,r2,1
8111eab4:	1462b03a 	or	r17,r2,r17
8111eab8:	ac7fff15 	stw	r17,-4(r21)
8111eabc:	11290c80 	call	811290c8 <__malloc_unlock>
8111eac0:	a805883a 	mov	r2,r21
8111eac4:	003f6b06 	br	8111e874 <__reset+0xfb0fe874>
8111eac8:	a80b883a 	mov	r5,r21
8111eacc:	9009883a 	mov	r4,r18
8111ead0:	111d4dc0 	call	8111d4dc <memmove>
8111ead4:	003f4e06 	br	8111e810 <__reset+0xfb0fe810>
8111ead8:	89000404 	addi	r4,r17,16
8111eadc:	b93fbc16 	blt	r23,r4,8111e9d0 <__reset+0xfb0fe9d0>
8111eae0:	b0800317 	ldw	r2,12(r22)
8111eae4:	b0c00217 	ldw	r3,8(r22)
8111eae8:	81bfff04 	addi	r6,r16,-4
8111eaec:	01000904 	movi	r4,36
8111eaf0:	18800315 	stw	r2,12(r3)
8111eaf4:	10c00215 	stw	r3,8(r2)
8111eaf8:	b4800204 	addi	r18,r22,8
8111eafc:	21804336 	bltu	r4,r6,8111ec0c <_realloc_r+0x510>
8111eb00:	008004c4 	movi	r2,19
8111eb04:	11803f2e 	bgeu	r2,r6,8111ec04 <_realloc_r+0x508>
8111eb08:	a8800017 	ldw	r2,0(r21)
8111eb0c:	b0800215 	stw	r2,8(r22)
8111eb10:	a8800117 	ldw	r2,4(r21)
8111eb14:	b0800315 	stw	r2,12(r22)
8111eb18:	008006c4 	movi	r2,27
8111eb1c:	11803f36 	bltu	r2,r6,8111ec1c <_realloc_r+0x520>
8111eb20:	b0800404 	addi	r2,r22,16
8111eb24:	ad400204 	addi	r21,r21,8
8111eb28:	a8c00017 	ldw	r3,0(r21)
8111eb2c:	10c00015 	stw	r3,0(r2)
8111eb30:	a8c00117 	ldw	r3,4(r21)
8111eb34:	10c00115 	stw	r3,4(r2)
8111eb38:	a8c00217 	ldw	r3,8(r21)
8111eb3c:	10c00215 	stw	r3,8(r2)
8111eb40:	b447883a 	add	r3,r22,r17
8111eb44:	bc45c83a 	sub	r2,r23,r17
8111eb48:	e0c00215 	stw	r3,8(fp)
8111eb4c:	10800054 	ori	r2,r2,1
8111eb50:	18800115 	stw	r2,4(r3)
8111eb54:	b0800117 	ldw	r2,4(r22)
8111eb58:	a009883a 	mov	r4,r20
8111eb5c:	1080004c 	andi	r2,r2,1
8111eb60:	1462b03a 	or	r17,r2,r17
8111eb64:	b4400115 	stw	r17,4(r22)
8111eb68:	11290c80 	call	811290c8 <__malloc_unlock>
8111eb6c:	9005883a 	mov	r2,r18
8111eb70:	003f4006 	br	8111e874 <__reset+0xfb0fe874>
8111eb74:	a8c00217 	ldw	r3,8(r21)
8111eb78:	90c00215 	stw	r3,8(r18)
8111eb7c:	a8c00317 	ldw	r3,12(r21)
8111eb80:	90c00315 	stw	r3,12(r18)
8111eb84:	30801126 	beq	r6,r2,8111ebcc <_realloc_r+0x4d0>
8111eb88:	90800404 	addi	r2,r18,16
8111eb8c:	a8c00404 	addi	r3,r21,16
8111eb90:	003f1906 	br	8111e7f8 <__reset+0xfb0fe7f8>
8111eb94:	90ffff17 	ldw	r3,-4(r18)
8111eb98:	00bfff04 	movi	r2,-4
8111eb9c:	a825883a 	mov	r18,r21
8111eba0:	1884703a 	and	r2,r3,r2
8111eba4:	80a1883a 	add	r16,r16,r2
8111eba8:	003f2406 	br	8111e83c <__reset+0xfb0fe83c>
8111ebac:	a8800217 	ldw	r2,8(r21)
8111ebb0:	b0800415 	stw	r2,16(r22)
8111ebb4:	a8800317 	ldw	r2,12(r21)
8111ebb8:	b0800515 	stw	r2,20(r22)
8111ebbc:	31000a26 	beq	r6,r4,8111ebe8 <_realloc_r+0x4ec>
8111ebc0:	b0800604 	addi	r2,r22,24
8111ebc4:	ad400404 	addi	r21,r21,16
8111ebc8:	003fa906 	br	8111ea70 <__reset+0xfb0fea70>
8111ebcc:	a9000417 	ldw	r4,16(r21)
8111ebd0:	90800604 	addi	r2,r18,24
8111ebd4:	a8c00604 	addi	r3,r21,24
8111ebd8:	91000415 	stw	r4,16(r18)
8111ebdc:	a9000517 	ldw	r4,20(r21)
8111ebe0:	91000515 	stw	r4,20(r18)
8111ebe4:	003f0406 	br	8111e7f8 <__reset+0xfb0fe7f8>
8111ebe8:	a8c00417 	ldw	r3,16(r21)
8111ebec:	ad400604 	addi	r21,r21,24
8111ebf0:	b0800804 	addi	r2,r22,32
8111ebf4:	b0c00615 	stw	r3,24(r22)
8111ebf8:	a8ffff17 	ldw	r3,-4(r21)
8111ebfc:	b0c00715 	stw	r3,28(r22)
8111ec00:	003f9b06 	br	8111ea70 <__reset+0xfb0fea70>
8111ec04:	9005883a 	mov	r2,r18
8111ec08:	003fc706 	br	8111eb28 <__reset+0xfb0feb28>
8111ec0c:	a80b883a 	mov	r5,r21
8111ec10:	9009883a 	mov	r4,r18
8111ec14:	111d4dc0 	call	8111d4dc <memmove>
8111ec18:	003fc906 	br	8111eb40 <__reset+0xfb0feb40>
8111ec1c:	a8800217 	ldw	r2,8(r21)
8111ec20:	b0800415 	stw	r2,16(r22)
8111ec24:	a8800317 	ldw	r2,12(r21)
8111ec28:	b0800515 	stw	r2,20(r22)
8111ec2c:	31000726 	beq	r6,r4,8111ec4c <_realloc_r+0x550>
8111ec30:	b0800604 	addi	r2,r22,24
8111ec34:	ad400404 	addi	r21,r21,16
8111ec38:	003fbb06 	br	8111eb28 <__reset+0xfb0feb28>
8111ec3c:	a009883a 	mov	r4,r20
8111ec40:	11290c80 	call	811290c8 <__malloc_unlock>
8111ec44:	0005883a 	mov	r2,zero
8111ec48:	003f0a06 	br	8111e874 <__reset+0xfb0fe874>
8111ec4c:	a8c00417 	ldw	r3,16(r21)
8111ec50:	ad400604 	addi	r21,r21,24
8111ec54:	b0800804 	addi	r2,r22,32
8111ec58:	b0c00615 	stw	r3,24(r22)
8111ec5c:	a8ffff17 	ldw	r3,-4(r21)
8111ec60:	b0c00715 	stw	r3,28(r22)
8111ec64:	003fb006 	br	8111eb28 <__reset+0xfb0feb28>

8111ec68 <__fpclassifyd>:
8111ec68:	00a00034 	movhi	r2,32768
8111ec6c:	10bfffc4 	addi	r2,r2,-1
8111ec70:	2884703a 	and	r2,r5,r2
8111ec74:	10000726 	beq	r2,zero,8111ec94 <__fpclassifyd+0x2c>
8111ec78:	00fffc34 	movhi	r3,65520
8111ec7c:	019ff834 	movhi	r6,32736
8111ec80:	28c7883a 	add	r3,r5,r3
8111ec84:	31bfffc4 	addi	r6,r6,-1
8111ec88:	30c00536 	bltu	r6,r3,8111eca0 <__fpclassifyd+0x38>
8111ec8c:	00800104 	movi	r2,4
8111ec90:	f800283a 	ret
8111ec94:	2000021e 	bne	r4,zero,8111eca0 <__fpclassifyd+0x38>
8111ec98:	00800084 	movi	r2,2
8111ec9c:	f800283a 	ret
8111eca0:	00dffc34 	movhi	r3,32752
8111eca4:	019ff834 	movhi	r6,32736
8111eca8:	28cb883a 	add	r5,r5,r3
8111ecac:	31bfffc4 	addi	r6,r6,-1
8111ecb0:	317ff62e 	bgeu	r6,r5,8111ec8c <__reset+0xfb0fec8c>
8111ecb4:	01400434 	movhi	r5,16
8111ecb8:	297fffc4 	addi	r5,r5,-1
8111ecbc:	28800236 	bltu	r5,r2,8111ecc8 <__fpclassifyd+0x60>
8111ecc0:	008000c4 	movi	r2,3
8111ecc4:	f800283a 	ret
8111ecc8:	10c00226 	beq	r2,r3,8111ecd4 <__fpclassifyd+0x6c>
8111eccc:	0005883a 	mov	r2,zero
8111ecd0:	f800283a 	ret
8111ecd4:	2005003a 	cmpeq	r2,r4,zero
8111ecd8:	f800283a 	ret

8111ecdc <__sccl>:
8111ecdc:	2a000003 	ldbu	r8,0(r5)
8111ece0:	00801784 	movi	r2,94
8111ece4:	40802a26 	beq	r8,r2,8111ed90 <__sccl+0xb4>
8111ece8:	29400044 	addi	r5,r5,1
8111ecec:	000f883a 	mov	r7,zero
8111ecf0:	0013883a 	mov	r9,zero
8111ecf4:	2007883a 	mov	r3,r4
8111ecf8:	21804004 	addi	r6,r4,256
8111ecfc:	19c00005 	stb	r7,0(r3)
8111ed00:	18c00044 	addi	r3,r3,1
8111ed04:	19bffd1e 	bne	r3,r6,8111ecfc <__reset+0xfb0fecfc>
8111ed08:	40001126 	beq	r8,zero,8111ed50 <__sccl+0x74>
8111ed0c:	00800044 	movi	r2,1
8111ed10:	124fc83a 	sub	r7,r2,r9
8111ed14:	02800b44 	movi	r10,45
8111ed18:	02c01744 	movi	r11,93
8111ed1c:	2205883a 	add	r2,r4,r8
8111ed20:	11c00005 	stb	r7,0(r2)
8111ed24:	28800044 	addi	r2,r5,1
8111ed28:	28c00003 	ldbu	r3,0(r5)
8111ed2c:	1a800a26 	beq	r3,r10,8111ed58 <__sccl+0x7c>
8111ed30:	1ac00426 	beq	r3,r11,8111ed44 <__sccl+0x68>
8111ed34:	18000426 	beq	r3,zero,8111ed48 <__sccl+0x6c>
8111ed38:	1811883a 	mov	r8,r3
8111ed3c:	100b883a 	mov	r5,r2
8111ed40:	003ff606 	br	8111ed1c <__reset+0xfb0fed1c>
8111ed44:	f800283a 	ret
8111ed48:	2805883a 	mov	r2,r5
8111ed4c:	f800283a 	ret
8111ed50:	28bfffc4 	addi	r2,r5,-1
8111ed54:	f800283a 	ret
8111ed58:	12400003 	ldbu	r9,0(r2)
8111ed5c:	4ac01126 	beq	r9,r11,8111eda4 <__sccl+0xc8>
8111ed60:	4a001016 	blt	r9,r8,8111eda4 <__sccl+0xc8>
8111ed64:	41800044 	addi	r6,r8,1
8111ed68:	29400084 	addi	r5,r5,2
8111ed6c:	2187883a 	add	r3,r4,r6
8111ed70:	00000106 	br	8111ed78 <__sccl+0x9c>
8111ed74:	31800044 	addi	r6,r6,1
8111ed78:	19c00005 	stb	r7,0(r3)
8111ed7c:	3011883a 	mov	r8,r6
8111ed80:	18c00044 	addi	r3,r3,1
8111ed84:	327ffb16 	blt	r6,r9,8111ed74 <__reset+0xfb0fed74>
8111ed88:	10800084 	addi	r2,r2,2
8111ed8c:	003fe606 	br	8111ed28 <__reset+0xfb0fed28>
8111ed90:	2a000043 	ldbu	r8,1(r5)
8111ed94:	01c00044 	movi	r7,1
8111ed98:	29400084 	addi	r5,r5,2
8111ed9c:	02400044 	movi	r9,1
8111eda0:	003fd406 	br	8111ecf4 <__reset+0xfb0fecf4>
8111eda4:	5011883a 	mov	r8,r10
8111eda8:	003fe406 	br	8111ed3c <__reset+0xfb0fed3c>

8111edac <nanf>:
8111edac:	009ff034 	movhi	r2,32704
8111edb0:	f800283a 	ret

8111edb4 <strcmp>:
8111edb4:	2144b03a 	or	r2,r4,r5
8111edb8:	108000cc 	andi	r2,r2,3
8111edbc:	1000171e 	bne	r2,zero,8111ee1c <strcmp+0x68>
8111edc0:	20800017 	ldw	r2,0(r4)
8111edc4:	28c00017 	ldw	r3,0(r5)
8111edc8:	10c0141e 	bne	r2,r3,8111ee1c <strcmp+0x68>
8111edcc:	027fbff4 	movhi	r9,65279
8111edd0:	4a7fbfc4 	addi	r9,r9,-257
8111edd4:	0086303a 	nor	r3,zero,r2
8111edd8:	02202074 	movhi	r8,32897
8111eddc:	1245883a 	add	r2,r2,r9
8111ede0:	42202004 	addi	r8,r8,-32640
8111ede4:	10c4703a 	and	r2,r2,r3
8111ede8:	1204703a 	and	r2,r2,r8
8111edec:	10000226 	beq	r2,zero,8111edf8 <strcmp+0x44>
8111edf0:	00002306 	br	8111ee80 <strcmp+0xcc>
8111edf4:	1000221e 	bne	r2,zero,8111ee80 <strcmp+0xcc>
8111edf8:	21000104 	addi	r4,r4,4
8111edfc:	20c00017 	ldw	r3,0(r4)
8111ee00:	29400104 	addi	r5,r5,4
8111ee04:	29800017 	ldw	r6,0(r5)
8111ee08:	1a4f883a 	add	r7,r3,r9
8111ee0c:	00c4303a 	nor	r2,zero,r3
8111ee10:	3884703a 	and	r2,r7,r2
8111ee14:	1204703a 	and	r2,r2,r8
8111ee18:	19bff626 	beq	r3,r6,8111edf4 <__reset+0xfb0fedf4>
8111ee1c:	20800003 	ldbu	r2,0(r4)
8111ee20:	10c03fcc 	andi	r3,r2,255
8111ee24:	18c0201c 	xori	r3,r3,128
8111ee28:	18ffe004 	addi	r3,r3,-128
8111ee2c:	18000c26 	beq	r3,zero,8111ee60 <strcmp+0xac>
8111ee30:	29800007 	ldb	r6,0(r5)
8111ee34:	19800326 	beq	r3,r6,8111ee44 <strcmp+0x90>
8111ee38:	00001306 	br	8111ee88 <strcmp+0xd4>
8111ee3c:	29800007 	ldb	r6,0(r5)
8111ee40:	11800b1e 	bne	r2,r6,8111ee70 <strcmp+0xbc>
8111ee44:	21000044 	addi	r4,r4,1
8111ee48:	20c00003 	ldbu	r3,0(r4)
8111ee4c:	29400044 	addi	r5,r5,1
8111ee50:	18803fcc 	andi	r2,r3,255
8111ee54:	1080201c 	xori	r2,r2,128
8111ee58:	10bfe004 	addi	r2,r2,-128
8111ee5c:	103ff71e 	bne	r2,zero,8111ee3c <__reset+0xfb0fee3c>
8111ee60:	0007883a 	mov	r3,zero
8111ee64:	28800003 	ldbu	r2,0(r5)
8111ee68:	1885c83a 	sub	r2,r3,r2
8111ee6c:	f800283a 	ret
8111ee70:	28800003 	ldbu	r2,0(r5)
8111ee74:	18c03fcc 	andi	r3,r3,255
8111ee78:	1885c83a 	sub	r2,r3,r2
8111ee7c:	f800283a 	ret
8111ee80:	0005883a 	mov	r2,zero
8111ee84:	f800283a 	ret
8111ee88:	10c03fcc 	andi	r3,r2,255
8111ee8c:	003ff506 	br	8111ee64 <__reset+0xfb0fee64>

8111ee90 <sulp>:
8111ee90:	defffd04 	addi	sp,sp,-12
8111ee94:	de00012e 	bgeu	sp,et,8111ee9c <sulp+0xc>
8111ee98:	003b68fa 	trap	3
8111ee9c:	dc400115 	stw	r17,4(sp)
8111eea0:	3023883a 	mov	r17,r6
8111eea4:	dc000015 	stw	r16,0(sp)
8111eea8:	dfc00215 	stw	ra,8(sp)
8111eeac:	2821883a 	mov	r16,r5
8111eeb0:	111e19c0 	call	8111e19c <__ulp>
8111eeb4:	88000c26 	beq	r17,zero,8111eee8 <sulp+0x58>
8111eeb8:	841ffc2c 	andhi	r16,r16,32752
8111eebc:	8020d53a 	srli	r16,r16,20
8111eec0:	01c01ac4 	movi	r7,107
8111eec4:	3c21c83a 	sub	r16,r7,r16
8111eec8:	0400070e 	bge	zero,r16,8111eee8 <sulp+0x58>
8111eecc:	8020953a 	slli	r16,r16,20
8111eed0:	01cffc34 	movhi	r7,16368
8111eed4:	000d883a 	mov	r6,zero
8111eed8:	81cf883a 	add	r7,r16,r7
8111eedc:	1009883a 	mov	r4,r2
8111eee0:	180b883a 	mov	r5,r3
8111eee4:	1111b400 	call	81111b40 <__muldf3>
8111eee8:	dfc00217 	ldw	ra,8(sp)
8111eeec:	dc400117 	ldw	r17,4(sp)
8111eef0:	dc000017 	ldw	r16,0(sp)
8111eef4:	dec00304 	addi	sp,sp,12
8111eef8:	f800283a 	ret

8111eefc <_strtod_r>:
8111eefc:	deffe204 	addi	sp,sp,-120
8111ef00:	de00012e 	bgeu	sp,et,8111ef08 <_strtod_r+0xc>
8111ef04:	003b68fa 	trap	3
8111ef08:	ddc01b15 	stw	r23,108(sp)
8111ef0c:	dd001815 	stw	r20,96(sp)
8111ef10:	dc801615 	stw	r18,88(sp)
8111ef14:	dc401515 	stw	r17,84(sp)
8111ef18:	dc001415 	stw	r16,80(sp)
8111ef1c:	d9400615 	stw	r5,24(sp)
8111ef20:	dfc01d15 	stw	ra,116(sp)
8111ef24:	df001c15 	stw	fp,112(sp)
8111ef28:	dd801a15 	stw	r22,104(sp)
8111ef2c:	dd401915 	stw	r21,100(sp)
8111ef30:	dcc01715 	stw	r19,92(sp)
8111ef34:	2021883a 	mov	r16,r4
8111ef38:	d8000515 	stw	zero,20(sp)
8111ef3c:	2809883a 	mov	r4,r5
8111ef40:	20800003 	ldbu	r2,0(r4)
8111ef44:	01e044b4 	movhi	r7,33042
8111ef48:	282f883a 	mov	r23,r5
8111ef4c:	10c03fcc 	andi	r3,r2,255
8111ef50:	01400b44 	movi	r5,45
8111ef54:	39fbde04 	addi	r7,r7,-4232
8111ef58:	3029883a 	mov	r20,r6
8111ef5c:	0025883a 	mov	r18,zero
8111ef60:	0023883a 	mov	r17,zero
8111ef64:	28c0ba36 	bltu	r5,r3,8111f250 <_strtod_r+0x354>
8111ef68:	180690ba 	slli	r3,r3,2
8111ef6c:	19c7883a 	add	r3,r3,r7
8111ef70:	18c00017 	ldw	r3,0(r3)
8111ef74:	1800683a 	jmp	r3
8111ef78:	8111f038 	rdprs	r4,r16,18368
8111ef7c:	8111f250 	cmplti	r4,r16,18377
8111ef80:	8111f250 	cmplti	r4,r16,18377
8111ef84:	8111f250 	cmplti	r4,r16,18377
8111ef88:	8111f250 	cmplti	r4,r16,18377
8111ef8c:	8111f250 	cmplti	r4,r16,18377
8111ef90:	8111f250 	cmplti	r4,r16,18377
8111ef94:	8111f250 	cmplti	r4,r16,18377
8111ef98:	8111f250 	cmplti	r4,r16,18377
8111ef9c:	8111f23c 	xorhi	r4,r16,18376
8111efa0:	8111f23c 	xorhi	r4,r16,18376
8111efa4:	8111f23c 	xorhi	r4,r16,18376
8111efa8:	8111f23c 	xorhi	r4,r16,18376
8111efac:	8111f23c 	xorhi	r4,r16,18376
8111efb0:	8111f250 	cmplti	r4,r16,18377
8111efb4:	8111f250 	cmplti	r4,r16,18377
8111efb8:	8111f250 	cmplti	r4,r16,18377
8111efbc:	8111f250 	cmplti	r4,r16,18377
8111efc0:	8111f250 	cmplti	r4,r16,18377
8111efc4:	8111f250 	cmplti	r4,r16,18377
8111efc8:	8111f250 	cmplti	r4,r16,18377
8111efcc:	8111f250 	cmplti	r4,r16,18377
8111efd0:	8111f250 	cmplti	r4,r16,18377
8111efd4:	8111f250 	cmplti	r4,r16,18377
8111efd8:	8111f250 	cmplti	r4,r16,18377
8111efdc:	8111f250 	cmplti	r4,r16,18377
8111efe0:	8111f250 	cmplti	r4,r16,18377
8111efe4:	8111f250 	cmplti	r4,r16,18377
8111efe8:	8111f250 	cmplti	r4,r16,18377
8111efec:	8111f250 	cmplti	r4,r16,18377
8111eff0:	8111f250 	cmplti	r4,r16,18377
8111eff4:	8111f250 	cmplti	r4,r16,18377
8111eff8:	8111f23c 	xorhi	r4,r16,18376
8111effc:	8111f250 	cmplti	r4,r16,18377
8111f000:	8111f250 	cmplti	r4,r16,18377
8111f004:	8111f250 	cmplti	r4,r16,18377
8111f008:	8111f250 	cmplti	r4,r16,18377
8111f00c:	8111f250 	cmplti	r4,r16,18377
8111f010:	8111f250 	cmplti	r4,r16,18377
8111f014:	8111f250 	cmplti	r4,r16,18377
8111f018:	8111f250 	cmplti	r4,r16,18377
8111f01c:	8111f250 	cmplti	r4,r16,18377
8111f020:	8111f250 	cmplti	r4,r16,18377
8111f024:	8111f090 	cmplti	r4,r16,18370
8111f028:	8111f250 	cmplti	r4,r16,18377
8111f02c:	8111f230 	cmpltui	r4,r16,18376
8111f030:	00801244 	movi	r2,73
8111f034:	88843526 	beq	r17,r2,8112010c <_strtod_r+0x1210>
8111f038:	002b883a 	mov	r21,zero
8111f03c:	002d883a 	mov	r22,zero
8111f040:	a0000526 	beq	r20,zero,8111f058 <_strtod_r+0x15c>
8111f044:	d8000715 	stw	zero,28(sp)
8111f048:	a5c00015 	stw	r23,0(r20)
8111f04c:	d9000717 	ldw	r4,28(sp)
8111f050:	20000126 	beq	r4,zero,8111f058 <_strtod_r+0x15c>
8111f054:	b5a0003c 	xorhi	r22,r22,32768
8111f058:	a805883a 	mov	r2,r21
8111f05c:	b007883a 	mov	r3,r22
8111f060:	dfc01d17 	ldw	ra,116(sp)
8111f064:	df001c17 	ldw	fp,112(sp)
8111f068:	ddc01b17 	ldw	r23,108(sp)
8111f06c:	dd801a17 	ldw	r22,104(sp)
8111f070:	dd401917 	ldw	r21,100(sp)
8111f074:	dd001817 	ldw	r20,96(sp)
8111f078:	dcc01717 	ldw	r19,92(sp)
8111f07c:	dc801617 	ldw	r18,88(sp)
8111f080:	dc401517 	ldw	r17,84(sp)
8111f084:	dc001417 	ldw	r16,80(sp)
8111f088:	dec01e04 	addi	sp,sp,120
8111f08c:	f800283a 	ret
8111f090:	d8000715 	stw	zero,28(sp)
8111f094:	24c00044 	addi	r19,r4,1
8111f098:	dcc00615 	stw	r19,24(sp)
8111f09c:	20800043 	ldbu	r2,1(r4)
8111f0a0:	10c03fcc 	andi	r3,r2,255
8111f0a4:	18c0201c 	xori	r3,r3,128
8111f0a8:	18ffe004 	addi	r3,r3,-128
8111f0ac:	183fe226 	beq	r3,zero,8111f038 <__reset+0xfb0ff038>
8111f0b0:	11403fcc 	andi	r5,r2,255
8111f0b4:	2940201c 	xori	r5,r5,128
8111f0b8:	297fe004 	addi	r5,r5,-128
8111f0bc:	00c00c04 	movi	r3,48
8111f0c0:	28c0e526 	beq	r5,r3,8111f458 <_strtod_r+0x55c>
8111f0c4:	dcc00815 	stw	r19,32(sp)
8111f0c8:	0025883a 	mov	r18,zero
8111f0cc:	10fff404 	addi	r3,r2,-48
8111f0d0:	18c03fcc 	andi	r3,r3,255
8111f0d4:	01000244 	movi	r4,9
8111f0d8:	20c37536 	bltu	r4,r3,8111feb0 <_strtod_r+0xfb4>
8111f0dc:	dd400817 	ldw	r21,32(sp)
8111f0e0:	0027883a 	mov	r19,zero
8111f0e4:	0039883a 	mov	fp,zero
8111f0e8:	002d883a 	mov	r22,zero
8111f0ec:	01400204 	movi	r5,8
8111f0f0:	2d805a16 	blt	r5,r22,8111f25c <_strtod_r+0x360>
8111f0f4:	e70002a4 	muli	fp,fp,10
8111f0f8:	10c03fcc 	andi	r3,r2,255
8111f0fc:	18c0201c 	xori	r3,r3,128
8111f100:	18ffe004 	addi	r3,r3,-128
8111f104:	e0f9883a 	add	fp,fp,r3
8111f108:	e73ff404 	addi	fp,fp,-48
8111f10c:	ad400044 	addi	r21,r21,1
8111f110:	dd400615 	stw	r21,24(sp)
8111f114:	a8800003 	ldbu	r2,0(r21)
8111f118:	b5800044 	addi	r22,r22,1
8111f11c:	10fff404 	addi	r3,r2,-48
8111f120:	18c03fcc 	andi	r3,r3,255
8111f124:	20fff22e 	bgeu	r4,r3,8111f0f0 <__reset+0xfb0ff0f0>
8111f128:	14403fcc 	andi	r17,r2,255
8111f12c:	8c40201c 	xori	r17,r17,128
8111f130:	8c7fe004 	addi	r17,r17,-128
8111f134:	8009883a 	mov	r4,r16
8111f138:	111d11c0 	call	8111d11c <_localeconv_r>
8111f13c:	11400017 	ldw	r5,0(r2)
8111f140:	8009883a 	mov	r4,r16
8111f144:	d9401315 	stw	r5,76(sp)
8111f148:	111d11c0 	call	8111d11c <_localeconv_r>
8111f14c:	11000017 	ldw	r4,0(r2)
8111f150:	111405c0 	call	8111405c <strlen>
8111f154:	d9401317 	ldw	r5,76(sp)
8111f158:	100d883a 	mov	r6,r2
8111f15c:	a809883a 	mov	r4,r21
8111f160:	1124aec0 	call	81124aec <strncmp>
8111f164:	1000ce26 	beq	r2,zero,8111f4a0 <_strtod_r+0x5a4>
8111f168:	b013883a 	mov	r9,r22
8111f16c:	000b883a 	mov	r5,zero
8111f170:	0015883a 	mov	r10,zero
8111f174:	0017883a 	mov	r11,zero
8111f178:	00801944 	movi	r2,101
8111f17c:	88807826 	beq	r17,r2,8111f360 <_strtod_r+0x464>
8111f180:	00801144 	movi	r2,69
8111f184:	88807626 	beq	r17,r2,8111f360 <_strtod_r+0x464>
8111f188:	002b883a 	mov	r21,zero
8111f18c:	48003d1e 	bne	r9,zero,8111f284 <_strtod_r+0x388>
8111f190:	2800391e 	bne	r5,zero,8111f278 <_strtod_r+0x37c>
8111f194:	9000381e 	bne	r18,zero,8111f278 <_strtod_r+0x37c>
8111f198:	583fa71e 	bne	r11,zero,8111f038 <__reset+0xfb0ff038>
8111f19c:	00801384 	movi	r2,78
8111f1a0:	88800526 	beq	r17,r2,8111f1b8 <_strtod_r+0x2bc>
8111f1a4:	147fa20e 	bge	r2,r17,8111f030 <__reset+0xfb0ff030>
8111f1a8:	00801a44 	movi	r2,105
8111f1ac:	8883d726 	beq	r17,r2,8112010c <_strtod_r+0x1210>
8111f1b0:	00801b84 	movi	r2,110
8111f1b4:	88bfa01e 	bne	r17,r2,8111f038 <__reset+0xfb0ff038>
8111f1b8:	01604534 	movhi	r5,33044
8111f1bc:	d9000617 	ldw	r4,24(sp)
8111f1c0:	297e1e04 	addi	r5,r5,-1928
8111f1c4:	01c00644 	movi	r7,25
8111f1c8:	00000b06 	br	8111f1f8 <_strtod_r+0x2fc>
8111f1cc:	21000044 	addi	r4,r4,1
8111f1d0:	20800003 	ldbu	r2,0(r4)
8111f1d4:	10ffefc4 	addi	r3,r2,-65
8111f1d8:	10803fcc 	andi	r2,r2,255
8111f1dc:	1080201c 	xori	r2,r2,128
8111f1e0:	18c03fcc 	andi	r3,r3,255
8111f1e4:	10bfe004 	addi	r2,r2,-128
8111f1e8:	38c00136 	bltu	r7,r3,8111f1f0 <_strtod_r+0x2f4>
8111f1ec:	10800804 	addi	r2,r2,32
8111f1f0:	29400044 	addi	r5,r5,1
8111f1f4:	11bf901e 	bne	r2,r6,8111f038 <__reset+0xfb0ff038>
8111f1f8:	29800007 	ldb	r6,0(r5)
8111f1fc:	303ff31e 	bne	r6,zero,8111f1cc <__reset+0xfb0ff1cc>
8111f200:	20800044 	addi	r2,r4,1
8111f204:	d8800615 	stw	r2,24(sp)
8111f208:	20c00047 	ldb	r3,1(r4)
8111f20c:	00800a04 	movi	r2,40
8111f210:	18849d26 	beq	r3,r2,81120488 <_strtod_r+0x158c>
8111f214:	047ffe34 	movhi	r17,65528
8111f218:	0025883a 	mov	r18,zero
8111f21c:	902b883a 	mov	r21,r18
8111f220:	882d883a 	mov	r22,r17
8111f224:	a03f8926 	beq	r20,zero,8111f04c <__reset+0xfb0ff04c>
8111f228:	ddc00617 	ldw	r23,24(sp)
8111f22c:	003f8606 	br	8111f048 <__reset+0xfb0ff048>
8111f230:	00800044 	movi	r2,1
8111f234:	d8800715 	stw	r2,28(sp)
8111f238:	003f9606 	br	8111f094 <__reset+0xfb0ff094>
8111f23c:	21000044 	addi	r4,r4,1
8111f240:	d9000615 	stw	r4,24(sp)
8111f244:	20800003 	ldbu	r2,0(r4)
8111f248:	10c03fcc 	andi	r3,r2,255
8111f24c:	28ff462e 	bgeu	r5,r3,8111ef68 <__reset+0xfb0fef68>
8111f250:	2027883a 	mov	r19,r4
8111f254:	d8000715 	stw	zero,28(sp)
8111f258:	003f9506 	br	8111f0b0 <__reset+0xfb0ff0b0>
8111f25c:	9cc002a4 	muli	r19,r19,10
8111f260:	10803fcc 	andi	r2,r2,255
8111f264:	1080201c 	xori	r2,r2,128
8111f268:	10bfe004 	addi	r2,r2,-128
8111f26c:	9885883a 	add	r2,r19,r2
8111f270:	14fff404 	addi	r19,r2,-48
8111f274:	003fa506 	br	8111f10c <__reset+0xfb0ff10c>
8111f278:	002b883a 	mov	r21,zero
8111f27c:	002d883a 	mov	r22,zero
8111f280:	003fe806 	br	8111f224 <__reset+0xfb0ff224>
8111f284:	aaabc83a 	sub	r21,r21,r10
8111f288:	b000011e 	bne	r22,zero,8111f290 <_strtod_r+0x394>
8111f28c:	482d883a 	mov	r22,r9
8111f290:	00800404 	movi	r2,16
8111f294:	482f883a 	mov	r23,r9
8111f298:	1240010e 	bge	r2,r9,8111f2a0 <_strtod_r+0x3a4>
8111f29c:	102f883a 	mov	r23,r2
8111f2a0:	e009883a 	mov	r4,fp
8111f2a4:	da401315 	stw	r9,76(sp)
8111f2a8:	1127c6c0 	call	81127c6c <__floatunsidf>
8111f2ac:	1025883a 	mov	r18,r2
8111f2b0:	00800244 	movi	r2,9
8111f2b4:	1823883a 	mov	r17,r3
8111f2b8:	da401317 	ldw	r9,76(sp)
8111f2bc:	15c0160e 	bge	r2,r23,8111f318 <_strtod_r+0x41c>
8111f2c0:	b8bffdc4 	addi	r2,r23,-9
8111f2c4:	100490fa 	slli	r2,r2,3
8111f2c8:	180b883a 	mov	r5,r3
8111f2cc:	00e04534 	movhi	r3,33044
8111f2d0:	18fde904 	addi	r3,r3,-2140
8111f2d4:	1885883a 	add	r2,r3,r2
8111f2d8:	11800017 	ldw	r6,0(r2)
8111f2dc:	11c00117 	ldw	r7,4(r2)
8111f2e0:	9009883a 	mov	r4,r18
8111f2e4:	1111b400 	call	81111b40 <__muldf3>
8111f2e8:	9809883a 	mov	r4,r19
8111f2ec:	1025883a 	mov	r18,r2
8111f2f0:	1823883a 	mov	r17,r3
8111f2f4:	1127c6c0 	call	81127c6c <__floatunsidf>
8111f2f8:	9009883a 	mov	r4,r18
8111f2fc:	880b883a 	mov	r5,r17
8111f300:	100d883a 	mov	r6,r2
8111f304:	180f883a 	mov	r7,r3
8111f308:	1125e080 	call	81125e08 <__adddf3>
8111f30c:	da401317 	ldw	r9,76(sp)
8111f310:	1025883a 	mov	r18,r2
8111f314:	1823883a 	mov	r17,r3
8111f318:	008003c4 	movi	r2,15
8111f31c:	12407b16 	blt	r2,r9,8111f50c <_strtod_r+0x610>
8111f320:	a83fbe26 	beq	r21,zero,8111f21c <__reset+0xfb0ff21c>
8111f324:	0543670e 	bge	zero,r21,811200c4 <_strtod_r+0x11c8>
8111f328:	00c00584 	movi	r3,22
8111f32c:	1d42e816 	blt	r3,r21,8111fed0 <_strtod_r+0xfd4>
8111f330:	a82a90fa 	slli	r21,r21,3
8111f334:	00a04534 	movhi	r2,33044
8111f338:	10bde904 	addi	r2,r2,-2140
8111f33c:	1545883a 	add	r2,r2,r21
8111f340:	11000017 	ldw	r4,0(r2)
8111f344:	11400117 	ldw	r5,4(r2)
8111f348:	900d883a 	mov	r6,r18
8111f34c:	880f883a 	mov	r7,r17
8111f350:	1111b400 	call	81111b40 <__muldf3>
8111f354:	102b883a 	mov	r21,r2
8111f358:	182d883a 	mov	r22,r3
8111f35c:	003fb106 	br	8111f224 <__reset+0xfb0ff224>
8111f360:	4801b526 	beq	r9,zero,8111fa38 <_strtod_r+0xb3c>
8111f364:	ddc00617 	ldw	r23,24(sp)
8111f368:	00c00ac4 	movi	r3,43
8111f36c:	b8800044 	addi	r2,r23,1
8111f370:	d8800615 	stw	r2,24(sp)
8111f374:	b8800047 	ldb	r2,1(r23)
8111f378:	10c1e926 	beq	r2,r3,8111fb20 <_strtod_r+0xc24>
8111f37c:	00c00b44 	movi	r3,45
8111f380:	10c1ec26 	beq	r2,r3,8111fb34 <_strtod_r+0xc38>
8111f384:	1023883a 	mov	r17,r2
8111f388:	0019883a 	mov	r12,zero
8111f38c:	88bff404 	addi	r2,r17,-48
8111f390:	00c00244 	movi	r3,9
8111f394:	1881b736 	bltu	r3,r2,8111fa74 <_strtod_r+0xb78>
8111f398:	00800c04 	movi	r2,48
8111f39c:	8880071e 	bne	r17,r2,8111f3bc <_strtod_r+0x4c0>
8111f3a0:	d8800617 	ldw	r2,24(sp)
8111f3a4:	8807883a 	mov	r3,r17
8111f3a8:	10800044 	addi	r2,r2,1
8111f3ac:	d8800615 	stw	r2,24(sp)
8111f3b0:	14400007 	ldb	r17,0(r2)
8111f3b4:	10800044 	addi	r2,r2,1
8111f3b8:	88fffc26 	beq	r17,r3,8111f3ac <__reset+0xfb0ff3ac>
8111f3bc:	88bff3c4 	addi	r2,r17,-49
8111f3c0:	00c00204 	movi	r3,8
8111f3c4:	18bf7036 	bltu	r3,r2,8111f188 <__reset+0xfb0ff188>
8111f3c8:	db800617 	ldw	r14,24(sp)
8111f3cc:	88bff404 	addi	r2,r17,-48
8111f3d0:	03400244 	movi	r13,9
8111f3d4:	71c00044 	addi	r7,r14,1
8111f3d8:	d9c00615 	stw	r7,24(sp)
8111f3dc:	74400043 	ldbu	r17,1(r14)
8111f3e0:	88fff404 	addi	r3,r17,-48
8111f3e4:	8c403fcc 	andi	r17,r17,255
8111f3e8:	8c40201c 	xori	r17,r17,128
8111f3ec:	18c03fcc 	andi	r3,r3,255
8111f3f0:	8c7fe004 	addi	r17,r17,-128
8111f3f4:	68c00e36 	bltu	r13,r3,8111f430 <_strtod_r+0x534>
8111f3f8:	71000084 	addi	r4,r14,2
8111f3fc:	d9000615 	stw	r4,24(sp)
8111f400:	108002a4 	muli	r2,r2,10
8111f404:	21800003 	ldbu	r6,0(r4)
8111f408:	200f883a 	mov	r7,r4
8111f40c:	1463883a 	add	r17,r2,r17
8111f410:	30fff404 	addi	r3,r6,-48
8111f414:	88bff404 	addi	r2,r17,-48
8111f418:	34403fcc 	andi	r17,r6,255
8111f41c:	8c40201c 	xori	r17,r17,128
8111f420:	18c03fcc 	andi	r3,r3,255
8111f424:	8c7fe004 	addi	r17,r17,-128
8111f428:	21000044 	addi	r4,r4,1
8111f42c:	68fff32e 	bgeu	r13,r3,8111f3fc <__reset+0xfb0ff3fc>
8111f430:	3b8fc83a 	sub	r7,r7,r14
8111f434:	00c00204 	movi	r3,8
8111f438:	19c29716 	blt	r3,r7,8111fe98 <_strtod_r+0xf9c>
8111f43c:	102b883a 	mov	r21,r2
8111f440:	009387c4 	movi	r2,19999
8111f444:	1540010e 	bge	r2,r21,8111f44c <_strtod_r+0x550>
8111f448:	102b883a 	mov	r21,r2
8111f44c:	603f4f26 	beq	r12,zero,8111f18c <__reset+0xfb0ff18c>
8111f450:	056bc83a 	sub	r21,zero,r21
8111f454:	003f4d06 	br	8111f18c <__reset+0xfb0ff18c>
8111f458:	98800047 	ldb	r2,1(r19)
8111f45c:	00c01604 	movi	r3,88
8111f460:	10c1de26 	beq	r2,r3,8111fbdc <_strtod_r+0xce0>
8111f464:	00c01e04 	movi	r3,120
8111f468:	10c1dc26 	beq	r2,r3,8111fbdc <_strtod_r+0xce0>
8111f46c:	98c00044 	addi	r3,r19,1
8111f470:	1827883a 	mov	r19,r3
8111f474:	d8c00615 	stw	r3,24(sp)
8111f478:	18c00044 	addi	r3,r3,1
8111f47c:	18bfffc3 	ldbu	r2,-1(r3)
8111f480:	11003fcc 	andi	r4,r2,255
8111f484:	2100201c 	xori	r4,r4,128
8111f488:	213fe004 	addi	r4,r4,-128
8111f48c:	217ff826 	beq	r4,r5,8111f470 <__reset+0xfb0ff470>
8111f490:	203f7926 	beq	r4,zero,8111f278 <__reset+0xfb0ff278>
8111f494:	dcc00815 	stw	r19,32(sp)
8111f498:	04800044 	movi	r18,1
8111f49c:	003f0b06 	br	8111f0cc <__reset+0xfb0ff0cc>
8111f4a0:	8009883a 	mov	r4,r16
8111f4a4:	111d11c0 	call	8111d11c <_localeconv_r>
8111f4a8:	11000017 	ldw	r4,0(r2)
8111f4ac:	111405c0 	call	8111405c <strlen>
8111f4b0:	d8c00617 	ldw	r3,24(sp)
8111f4b4:	1885883a 	add	r2,r3,r2
8111f4b8:	d8800615 	stw	r2,24(sp)
8111f4bc:	14400007 	ldb	r17,0(r2)
8111f4c0:	b001881e 	bne	r22,zero,8111fae4 <_strtod_r+0xbe8>
8111f4c4:	00c00c04 	movi	r3,48
8111f4c8:	88c3391e 	bne	r17,r3,811201b0 <_strtod_r+0x12b4>
8111f4cc:	10c00044 	addi	r3,r2,1
8111f4d0:	8809883a 	mov	r4,r17
8111f4d4:	d8c00615 	stw	r3,24(sp)
8111f4d8:	1c400007 	ldb	r17,0(r3)
8111f4dc:	188bc83a 	sub	r5,r3,r2
8111f4e0:	18c00044 	addi	r3,r3,1
8111f4e4:	893ffb26 	beq	r17,r4,8111f4d4 <__reset+0xfb0ff4d4>
8111f4e8:	88bff3c4 	addi	r2,r17,-49
8111f4ec:	00c00204 	movi	r3,8
8111f4f0:	1882e72e 	bgeu	r3,r2,81120090 <_strtod_r+0x1194>
8111f4f4:	00801944 	movi	r2,101
8111f4f8:	88814d26 	beq	r17,r2,8111fa30 <_strtod_r+0xb34>
8111f4fc:	0013883a 	mov	r9,zero
8111f500:	0015883a 	mov	r10,zero
8111f504:	02c00044 	movi	r11,1
8111f508:	003f1d06 	br	8111f180 <__reset+0xfb0ff180>
8111f50c:	4defc83a 	sub	r23,r9,r23
8111f510:	bd6f883a 	add	r23,r23,r21
8111f514:	05c21e0e 	bge	zero,r23,8111fd90 <_strtod_r+0xe94>
8111f518:	b88003cc 	andi	r2,r23,15
8111f51c:	10000d26 	beq	r2,zero,8111f554 <_strtod_r+0x658>
8111f520:	100490fa 	slli	r2,r2,3
8111f524:	00e04534 	movhi	r3,33044
8111f528:	18fde904 	addi	r3,r3,-2140
8111f52c:	1885883a 	add	r2,r3,r2
8111f530:	11000017 	ldw	r4,0(r2)
8111f534:	11400117 	ldw	r5,4(r2)
8111f538:	900d883a 	mov	r6,r18
8111f53c:	880f883a 	mov	r7,r17
8111f540:	da401315 	stw	r9,76(sp)
8111f544:	1111b400 	call	81111b40 <__muldf3>
8111f548:	da401317 	ldw	r9,76(sp)
8111f54c:	1025883a 	mov	r18,r2
8111f550:	1823883a 	mov	r17,r3
8111f554:	023ffc04 	movi	r8,-16
8111f558:	ba10703a 	and	r8,r23,r8
8111f55c:	40003c26 	beq	r8,zero,8111f650 <_strtod_r+0x754>
8111f560:	00804d04 	movi	r2,308
8111f564:	1201cd16 	blt	r2,r8,8111fc9c <_strtod_r+0xda0>
8111f568:	4011d13a 	srai	r8,r8,4
8111f56c:	03000044 	movi	r12,1
8111f570:	62037c0e 	bge	r12,r8,81120364 <_strtod_r+0x1468>
8111f574:	01204534 	movhi	r4,33044
8111f578:	213ddf04 	addi	r4,r4,-2180
8111f57c:	2015883a 	mov	r10,r4
8111f580:	0027883a 	mov	r19,zero
8111f584:	d9000915 	stw	r4,36(sp)
8111f588:	9005883a 	mov	r2,r18
8111f58c:	8807883a 	mov	r3,r17
8111f590:	dc000c15 	stw	r16,48(sp)
8111f594:	dc800e15 	stw	r18,56(sp)
8111f598:	9821883a 	mov	r16,r19
8111f59c:	0009883a 	mov	r4,zero
8111f5a0:	8827883a 	mov	r19,r17
8111f5a4:	602f883a 	mov	r23,r12
8111f5a8:	da400a15 	stw	r9,40(sp)
8111f5ac:	5025883a 	mov	r18,r10
8111f5b0:	4023883a 	mov	r17,r8
8111f5b4:	8980004c 	andi	r6,r17,1
8111f5b8:	30000626 	beq	r6,zero,8111f5d4 <_strtod_r+0x6d8>
8111f5bc:	91800017 	ldw	r6,0(r18)
8111f5c0:	91c00117 	ldw	r7,4(r18)
8111f5c4:	1009883a 	mov	r4,r2
8111f5c8:	180b883a 	mov	r5,r3
8111f5cc:	1111b400 	call	81111b40 <__muldf3>
8111f5d0:	01000044 	movi	r4,1
8111f5d4:	8823d07a 	srai	r17,r17,1
8111f5d8:	84000044 	addi	r16,r16,1
8111f5dc:	94800204 	addi	r18,r18,8
8111f5e0:	8dfff41e 	bne	r17,r23,8111f5b4 <__reset+0xfb0ff5b4>
8111f5e4:	21003fcc 	andi	r4,r4,255
8111f5e8:	9823883a 	mov	r17,r19
8111f5ec:	da400a17 	ldw	r9,40(sp)
8111f5f0:	8027883a 	mov	r19,r16
8111f5f4:	dc800e17 	ldw	r18,56(sp)
8111f5f8:	dc000c17 	ldw	r16,48(sp)
8111f5fc:	2003b11e 	bne	r4,zero,811204c4 <_strtod_r+0x15c8>
8111f600:	981690fa 	slli	r11,r19,3
8111f604:	d8800917 	ldw	r2,36(sp)
8111f608:	01ff2c34 	movhi	r7,64688
8111f60c:	900d883a 	mov	r6,r18
8111f610:	12ef883a 	add	r23,r2,r11
8111f614:	b9000017 	ldw	r4,0(r23)
8111f618:	b9400117 	ldw	r5,4(r23)
8111f61c:	89cf883a 	add	r7,r17,r7
8111f620:	da401315 	stw	r9,76(sp)
8111f624:	1111b400 	call	81111b40 <__muldf3>
8111f628:	1025883a 	mov	r18,r2
8111f62c:	011f2834 	movhi	r4,31904
8111f630:	189ffc2c 	andhi	r2,r3,32752
8111f634:	da401317 	ldw	r9,76(sp)
8111f638:	20819836 	bltu	r4,r2,8111fc9c <_strtod_r+0xda0>
8111f63c:	011f2434 	movhi	r4,31888
8111f640:	2083382e 	bgeu	r4,r2,81120324 <_strtod_r+0x1428>
8111f644:	045ffc34 	movhi	r17,32752
8111f648:	8c7fffc4 	addi	r17,r17,-1
8111f64c:	04bfffc4 	movi	r18,-1
8111f650:	d8000915 	stw	zero,36(sp)
8111f654:	d9400817 	ldw	r5,32(sp)
8111f658:	df000015 	stw	fp,0(sp)
8111f65c:	480f883a 	mov	r7,r9
8111f660:	b00d883a 	mov	r6,r22
8111f664:	8009883a 	mov	r4,r16
8111f668:	111d8380 	call	8111d838 <__s2b>
8111f66c:	d8800815 	stw	r2,32(sp)
8111f670:	10018a26 	beq	r2,zero,8111fc9c <_strtod_r+0xda0>
8111f674:	a807d7fa 	srai	r3,r21,31
8111f678:	0545c83a 	sub	r2,zero,r21
8111f67c:	dd400a15 	stw	r21,40(sp)
8111f680:	1886703a 	and	r3,r3,r2
8111f684:	d8c00c15 	stw	r3,48(sp)
8111f688:	a8013516 	blt	r21,zero,8111fb60 <_strtod_r+0xc64>
8111f68c:	d9400817 	ldw	r5,32(sp)
8111f690:	0011883a 	mov	r8,zero
8111f694:	0027883a 	mov	r19,zero
8111f698:	29400304 	addi	r5,r5,12
8111f69c:	d9400f15 	stw	r5,60(sp)
8111f6a0:	402b883a 	mov	r21,r8
8111f6a4:	dd001215 	stw	r20,72(sp)
8111f6a8:	d8800817 	ldw	r2,32(sp)
8111f6ac:	8009883a 	mov	r4,r16
8111f6b0:	11400117 	ldw	r5,4(r2)
8111f6b4:	111d6380 	call	8111d638 <_Balloc>
8111f6b8:	1029883a 	mov	r20,r2
8111f6bc:	10012d26 	beq	r2,zero,8111fb74 <_strtod_r+0xc78>
8111f6c0:	d8c00817 	ldw	r3,32(sp)
8111f6c4:	d9400f17 	ldw	r5,60(sp)
8111f6c8:	11000304 	addi	r4,r2,12
8111f6cc:	19800417 	ldw	r6,16(r3)
8111f6d0:	31800084 	addi	r6,r6,2
8111f6d4:	318d883a 	add	r6,r6,r6
8111f6d8:	318d883a 	add	r6,r6,r6
8111f6dc:	11136e00 	call	811136e0 <memcpy>
8111f6e0:	d9000204 	addi	r4,sp,8
8111f6e4:	d9000015 	stw	r4,0(sp)
8111f6e8:	d9c00404 	addi	r7,sp,16
8111f6ec:	900b883a 	mov	r5,r18
8111f6f0:	880d883a 	mov	r6,r17
8111f6f4:	8009883a 	mov	r4,r16
8111f6f8:	111e3140 	call	8111e314 <__d2b>
8111f6fc:	d8800515 	stw	r2,20(sp)
8111f700:	dc801115 	stw	r18,68(sp)
8111f704:	dc401015 	stw	r17,64(sp)
8111f708:	10027c26 	beq	r2,zero,811200fc <_strtod_r+0x1200>
8111f70c:	01400044 	movi	r5,1
8111f710:	8009883a 	mov	r4,r16
8111f714:	111da5c0 	call	8111da5c <__i2b>
8111f718:	1027883a 	mov	r19,r2
8111f71c:	10011526 	beq	r2,zero,8111fb74 <_strtod_r+0xc78>
8111f720:	d8800417 	ldw	r2,16(sp)
8111f724:	1000c816 	blt	r2,zero,8111fa48 <_strtod_r+0xb4c>
8111f728:	d9400c17 	ldw	r5,48(sp)
8111f72c:	d9000a17 	ldw	r4,40(sp)
8111f730:	28ad883a 	add	r22,r5,r2
8111f734:	d9400917 	ldw	r5,36(sp)
8111f738:	df000217 	ldw	fp,8(sp)
8111f73c:	05ff0084 	movi	r23,-1022
8111f740:	1147c83a 	sub	r3,r2,r5
8111f744:	1f07883a 	add	r3,r3,fp
8111f748:	00800d84 	movi	r2,54
8111f74c:	18ffffc4 	addi	r3,r3,-1
8111f750:	1739c83a 	sub	fp,r2,fp
8111f754:	1dc0a50e 	bge	r3,r23,8111f9ec <_strtod_r+0xaf0>
8111f758:	b8efc83a 	sub	r23,r23,r3
8111f75c:	008007c4 	movi	r2,31
8111f760:	e5f9c83a 	sub	fp,fp,r23
8111f764:	15c0bc16 	blt	r2,r23,8111fa58 <_strtod_r+0xb5c>
8111f768:	00800044 	movi	r2,1
8111f76c:	15c4983a 	sll	r2,r2,r23
8111f770:	d8000b15 	stw	zero,44(sp)
8111f774:	d8800d15 	stw	r2,52(sp)
8111f778:	2707883a 	add	r3,r4,fp
8111f77c:	d9000917 	ldw	r4,36(sp)
8111f780:	b739883a 	add	fp,r22,fp
8111f784:	20ef883a 	add	r23,r4,r3
8111f788:	b009883a 	mov	r4,r22
8111f78c:	e580010e 	bge	fp,r22,8111f794 <_strtod_r+0x898>
8111f790:	e009883a 	mov	r4,fp
8111f794:	b805883a 	mov	r2,r23
8111f798:	25c0010e 	bge	r4,r23,8111f7a0 <_strtod_r+0x8a4>
8111f79c:	2005883a 	mov	r2,r4
8111f7a0:	0080030e 	bge	zero,r2,8111f7b0 <_strtod_r+0x8b4>
8111f7a4:	e0b9c83a 	sub	fp,fp,r2
8111f7a8:	b8afc83a 	sub	r23,r23,r2
8111f7ac:	b0adc83a 	sub	r22,r22,r2
8111f7b0:	d9400c17 	ldw	r5,48(sp)
8111f7b4:	28001126 	beq	r5,zero,8111f7fc <_strtod_r+0x900>
8111f7b8:	280d883a 	mov	r6,r5
8111f7bc:	8009883a 	mov	r4,r16
8111f7c0:	980b883a 	mov	r5,r19
8111f7c4:	111dca00 	call	8111dca0 <__pow5mult>
8111f7c8:	1027883a 	mov	r19,r2
8111f7cc:	1000e926 	beq	r2,zero,8111fb74 <_strtod_r+0xc78>
8111f7d0:	d9800517 	ldw	r6,20(sp)
8111f7d4:	100b883a 	mov	r5,r2
8111f7d8:	8009883a 	mov	r4,r16
8111f7dc:	111daa00 	call	8111daa0 <__multiply>
8111f7e0:	1000e426 	beq	r2,zero,8111fb74 <_strtod_r+0xc78>
8111f7e4:	d9400517 	ldw	r5,20(sp)
8111f7e8:	8009883a 	mov	r4,r16
8111f7ec:	d8801315 	stw	r2,76(sp)
8111f7f0:	111d6e80 	call	8111d6e8 <_Bfree>
8111f7f4:	d8801317 	ldw	r2,76(sp)
8111f7f8:	d8800515 	stw	r2,20(sp)
8111f7fc:	0700060e 	bge	zero,fp,8111f818 <_strtod_r+0x91c>
8111f800:	d9400517 	ldw	r5,20(sp)
8111f804:	e00d883a 	mov	r6,fp
8111f808:	8009883a 	mov	r4,r16
8111f80c:	111dde80 	call	8111dde8 <__lshift>
8111f810:	d8800515 	stw	r2,20(sp)
8111f814:	10023926 	beq	r2,zero,811200fc <_strtod_r+0x1200>
8111f818:	d8800a17 	ldw	r2,40(sp)
8111f81c:	10000626 	beq	r2,zero,8111f838 <_strtod_r+0x93c>
8111f820:	d9800a17 	ldw	r6,40(sp)
8111f824:	a00b883a 	mov	r5,r20
8111f828:	8009883a 	mov	r4,r16
8111f82c:	111dca00 	call	8111dca0 <__pow5mult>
8111f830:	1029883a 	mov	r20,r2
8111f834:	1000cf26 	beq	r2,zero,8111fb74 <_strtod_r+0xc78>
8111f838:	05c0060e 	bge	zero,r23,8111f854 <_strtod_r+0x958>
8111f83c:	a00b883a 	mov	r5,r20
8111f840:	b80d883a 	mov	r6,r23
8111f844:	8009883a 	mov	r4,r16
8111f848:	111dde80 	call	8111dde8 <__lshift>
8111f84c:	1029883a 	mov	r20,r2
8111f850:	1000c826 	beq	r2,zero,8111fb74 <_strtod_r+0xc78>
8111f854:	0580060e 	bge	zero,r22,8111f870 <_strtod_r+0x974>
8111f858:	980b883a 	mov	r5,r19
8111f85c:	b00d883a 	mov	r6,r22
8111f860:	8009883a 	mov	r4,r16
8111f864:	111dde80 	call	8111dde8 <__lshift>
8111f868:	1027883a 	mov	r19,r2
8111f86c:	1000c126 	beq	r2,zero,8111fb74 <_strtod_r+0xc78>
8111f870:	d9400517 	ldw	r5,20(sp)
8111f874:	a00d883a 	mov	r6,r20
8111f878:	8009883a 	mov	r4,r16
8111f87c:	111df980 	call	8111df98 <__mdiff>
8111f880:	102b883a 	mov	r21,r2
8111f884:	1000bb26 	beq	r2,zero,8111fb74 <_strtod_r+0xc78>
8111f888:	10c00317 	ldw	r3,12(r2)
8111f88c:	980b883a 	mov	r5,r19
8111f890:	10000315 	stw	zero,12(r2)
8111f894:	1009883a 	mov	r4,r2
8111f898:	d8c00e15 	stw	r3,56(sp)
8111f89c:	111df380 	call	8111df38 <__mcmp>
8111f8a0:	10027616 	blt	r2,zero,8112027c <_strtod_r+0x1380>
8111f8a4:	10024426 	beq	r2,zero,811201b8 <_strtod_r+0x12bc>
8111f8a8:	980b883a 	mov	r5,r19
8111f8ac:	a809883a 	mov	r4,r21
8111f8b0:	111e4680 	call	8111e468 <__ratio>
8111f8b4:	000d883a 	mov	r6,zero
8111f8b8:	01d00034 	movhi	r7,16384
8111f8bc:	1009883a 	mov	r4,r2
8111f8c0:	180b883a 	mov	r5,r3
8111f8c4:	102f883a 	mov	r23,r2
8111f8c8:	182d883a 	mov	r22,r3
8111f8cc:	11271100 	call	81127110 <__ledf2>
8111f8d0:	00804a16 	blt	zero,r2,8111f9fc <_strtod_r+0xb00>
8111f8d4:	d9400e17 	ldw	r5,56(sp)
8111f8d8:	28006b26 	beq	r5,zero,8111fa88 <_strtod_r+0xb8c>
8111f8dc:	058ffc34 	movhi	r22,16368
8111f8e0:	d8000b15 	stw	zero,44(sp)
8111f8e4:	d8000d15 	stw	zero,52(sp)
8111f8e8:	b02f883a 	mov	r23,r22
8111f8ec:	8f1ffc2c 	andhi	fp,r17,32752
8111f8f0:	009ff834 	movhi	r2,32736
8111f8f4:	e080cd26 	beq	fp,r2,8111fc2c <_strtod_r+0xd30>
8111f8f8:	d9400917 	ldw	r5,36(sp)
8111f8fc:	28001a26 	beq	r5,zero,8111f968 <_strtod_r+0xa6c>
8111f900:	0081a834 	movhi	r2,1696
8111f904:	17001836 	bltu	r2,fp,8111f968 <_strtod_r+0xa6c>
8111f908:	d9000d17 	ldw	r4,52(sp)
8111f90c:	01d07834 	movhi	r7,16864
8111f910:	39ffffc4 	addi	r7,r7,-1
8111f914:	01bff034 	movhi	r6,65472
8111f918:	b80b883a 	mov	r5,r23
8111f91c:	11271100 	call	81127110 <__ledf2>
8111f920:	00800e16 	blt	zero,r2,8111f95c <_strtod_r+0xa60>
8111f924:	d9000d17 	ldw	r4,52(sp)
8111f928:	b80b883a 	mov	r5,r23
8111f92c:	1124f1c0 	call	81124f1c <__fixunsdfsi>
8111f930:	10018126 	beq	r2,zero,8111ff38 <_strtod_r+0x103c>
8111f934:	1009883a 	mov	r4,r2
8111f938:	1127c6c0 	call	81127c6c <__floatunsidf>
8111f93c:	d8800d15 	stw	r2,52(sp)
8111f940:	182f883a 	mov	r23,r3
8111f944:	d8800e17 	ldw	r2,56(sp)
8111f948:	1001791e 	bne	r2,zero,8111ff30 <_strtod_r+0x1034>
8111f94c:	ba20003c 	xorhi	r8,r23,32768
8111f950:	d8c00d17 	ldw	r3,52(sp)
8111f954:	402d883a 	mov	r22,r8
8111f958:	d8c00b15 	stw	r3,44(sp)
8111f95c:	0081ac34 	movhi	r2,1712
8111f960:	b091883a 	add	r8,r22,r2
8111f964:	472dc83a 	sub	r22,r8,fp
8111f968:	9009883a 	mov	r4,r18
8111f96c:	880b883a 	mov	r5,r17
8111f970:	111e19c0 	call	8111e19c <__ulp>
8111f974:	d9000b17 	ldw	r4,44(sp)
8111f978:	b00b883a 	mov	r5,r22
8111f97c:	100d883a 	mov	r6,r2
8111f980:	180f883a 	mov	r7,r3
8111f984:	1111b400 	call	81111b40 <__muldf3>
8111f988:	900d883a 	mov	r6,r18
8111f98c:	880f883a 	mov	r7,r17
8111f990:	1009883a 	mov	r4,r2
8111f994:	180b883a 	mov	r5,r3
8111f998:	1125e080 	call	81125e08 <__adddf3>
8111f99c:	1025883a 	mov	r18,r2
8111f9a0:	1823883a 	mov	r17,r3
8111f9a4:	182d883a 	mov	r22,r3
8111f9a8:	d9000917 	ldw	r4,36(sp)
8111f9ac:	2000021e 	bne	r4,zero,8111f9b8 <_strtod_r+0xabc>
8111f9b0:	b09ffc2c 	andhi	r2,r22,32752
8111f9b4:	e080be26 	beq	fp,r2,8111fcb0 <_strtod_r+0xdb4>
8111f9b8:	d9400517 	ldw	r5,20(sp)
8111f9bc:	8009883a 	mov	r4,r16
8111f9c0:	111d6e80 	call	8111d6e8 <_Bfree>
8111f9c4:	a00b883a 	mov	r5,r20
8111f9c8:	8009883a 	mov	r4,r16
8111f9cc:	111d6e80 	call	8111d6e8 <_Bfree>
8111f9d0:	980b883a 	mov	r5,r19
8111f9d4:	8009883a 	mov	r4,r16
8111f9d8:	111d6e80 	call	8111d6e8 <_Bfree>
8111f9dc:	a80b883a 	mov	r5,r21
8111f9e0:	8009883a 	mov	r4,r16
8111f9e4:	111d6e80 	call	8111d6e8 <_Bfree>
8111f9e8:	003f2f06 	br	8111f6a8 <__reset+0xfb0ff6a8>
8111f9ec:	00c00044 	movi	r3,1
8111f9f0:	d8000b15 	stw	zero,44(sp)
8111f9f4:	d8c00d15 	stw	r3,52(sp)
8111f9f8:	003f5f06 	br	8111f778 <__reset+0xfb0ff778>
8111f9fc:	b809883a 	mov	r4,r23
8111fa00:	000d883a 	mov	r6,zero
8111fa04:	01cff834 	movhi	r7,16352
8111fa08:	b00b883a 	mov	r5,r22
8111fa0c:	1111b400 	call	81111b40 <__muldf3>
8111fa10:	d9000e17 	ldw	r4,56(sp)
8111fa14:	d8800d15 	stw	r2,52(sp)
8111fa18:	182f883a 	mov	r23,r3
8111fa1c:	2000181e 	bne	r4,zero,8111fa80 <_strtod_r+0xb84>
8111fa20:	1a20003c 	xorhi	r8,r3,32768
8111fa24:	d8800b15 	stw	r2,44(sp)
8111fa28:	402d883a 	mov	r22,r8
8111fa2c:	003faf06 	br	8111f8ec <__reset+0xfb0ff8ec>
8111fa30:	0015883a 	mov	r10,zero
8111fa34:	02c00044 	movi	r11,1
8111fa38:	2800011e 	bne	r5,zero,8111fa40 <_strtod_r+0xb44>
8111fa3c:	903d7e26 	beq	r18,zero,8111f038 <__reset+0xfb0ff038>
8111fa40:	0013883a 	mov	r9,zero
8111fa44:	003e4706 	br	8111f364 <__reset+0xfb0ff364>
8111fa48:	d8c00a17 	ldw	r3,40(sp)
8111fa4c:	dd800c17 	ldw	r22,48(sp)
8111fa50:	1889c83a 	sub	r4,r3,r2
8111fa54:	003f3706 	br	8111f734 <__reset+0xfb0ff734>
8111fa58:	00bef884 	movi	r2,-1054
8111fa5c:	05c00044 	movi	r23,1
8111fa60:	10c5c83a 	sub	r2,r2,r3
8111fa64:	b884983a 	sll	r2,r23,r2
8111fa68:	ddc00d15 	stw	r23,52(sp)
8111fa6c:	d8800b15 	stw	r2,44(sp)
8111fa70:	003f4106 	br	8111f778 <__reset+0xfb0ff778>
8111fa74:	ddc00615 	stw	r23,24(sp)
8111fa78:	002b883a 	mov	r21,zero
8111fa7c:	003dc306 	br	8111f18c <__reset+0xfb0ff18c>
8111fa80:	1811883a 	mov	r8,r3
8111fa84:	003fe706 	br	8111fa24 <__reset+0xfb0ffa24>
8111fa88:	90002e1e 	bne	r18,zero,8111fb44 <_strtod_r+0xc48>
8111fa8c:	00c00434 	movhi	r3,16
8111fa90:	18ffffc4 	addi	r3,r3,-1
8111fa94:	88c4703a 	and	r2,r17,r3
8111fa98:	10002c1e 	bne	r2,zero,8111fb4c <_strtod_r+0xc50>
8111fa9c:	000d883a 	mov	r6,zero
8111faa0:	01cffc34 	movhi	r7,16368
8111faa4:	b809883a 	mov	r4,r23
8111faa8:	b00b883a 	mov	r5,r22
8111faac:	11271100 	call	81127110 <__ledf2>
8111fab0:	10021716 	blt	r2,zero,81120310 <_strtod_r+0x1414>
8111fab4:	b809883a 	mov	r4,r23
8111fab8:	b00b883a 	mov	r5,r22
8111fabc:	000d883a 	mov	r6,zero
8111fac0:	01cff834 	movhi	r7,16352
8111fac4:	1111b400 	call	81111b40 <__muldf3>
8111fac8:	d8800d15 	stw	r2,52(sp)
8111facc:	182f883a 	mov	r23,r3
8111fad0:	102d883a 	mov	r22,r2
8111fad4:	1a20003c 	xorhi	r8,r3,32768
8111fad8:	dd800b15 	stw	r22,44(sp)
8111fadc:	402d883a 	mov	r22,r8
8111fae0:	003f8206 	br	8111f8ec <__reset+0xfb0ff8ec>
8111fae4:	b013883a 	mov	r9,r22
8111fae8:	000b883a 	mov	r5,zero
8111faec:	0015883a 	mov	r10,zero
8111faf0:	893ff404 	addi	r4,r17,-48
8111faf4:	00800244 	movi	r2,9
8111faf8:	11001036 	bltu	r2,r4,8111fb3c <_strtod_r+0xc40>
8111fafc:	28c00044 	addi	r3,r5,1
8111fb00:	2023883a 	mov	r17,r4
8111fb04:	20014d1e 	bne	r4,zero,8112003c <_strtod_r+0x1140>
8111fb08:	d9800617 	ldw	r6,24(sp)
8111fb0c:	180b883a 	mov	r5,r3
8111fb10:	30800044 	addi	r2,r6,1
8111fb14:	d8800615 	stw	r2,24(sp)
8111fb18:	34400047 	ldb	r17,1(r6)
8111fb1c:	003ff406 	br	8111faf0 <__reset+0xfb0ffaf0>
8111fb20:	0019883a 	mov	r12,zero
8111fb24:	b8800084 	addi	r2,r23,2
8111fb28:	d8800615 	stw	r2,24(sp)
8111fb2c:	bc400087 	ldb	r17,2(r23)
8111fb30:	003e1606 	br	8111f38c <__reset+0xfb0ff38c>
8111fb34:	03000044 	movi	r12,1
8111fb38:	003ffa06 	br	8111fb24 <__reset+0xfb0ffb24>
8111fb3c:	02c00044 	movi	r11,1
8111fb40:	003d8d06 	br	8111f178 <__reset+0xfb0ff178>
8111fb44:	00800044 	movi	r2,1
8111fb48:	9080fe26 	beq	r18,r2,8111ff44 <_strtod_r+0x1048>
8111fb4c:	d8000b15 	stw	zero,44(sp)
8111fb50:	05affc34 	movhi	r22,49136
8111fb54:	d8000d15 	stw	zero,52(sp)
8111fb58:	05cffc34 	movhi	r23,16368
8111fb5c:	003f6306 	br	8111f8ec <__reset+0xfb0ff8ec>
8111fb60:	d8000a15 	stw	zero,40(sp)
8111fb64:	003ec906 	br	8111f68c <__reset+0xfb0ff68c>
8111fb68:	d9001117 	ldw	r4,68(sp)
8111fb6c:	00bfffc4 	movi	r2,-1
8111fb70:	2080461e 	bne	r4,r2,8111fc8c <_strtod_r+0xd90>
8111fb74:	dd000a15 	stw	r20,40(sp)
8111fb78:	dd001217 	ldw	r20,72(sp)
8111fb7c:	a811883a 	mov	r8,r21
8111fb80:	d8800517 	ldw	r2,20(sp)
8111fb84:	00c00884 	movi	r3,34
8111fb88:	80c00015 	stw	r3,0(r16)
8111fb8c:	002b883a 	mov	r21,zero
8111fb90:	059ffc34 	movhi	r22,32752
8111fb94:	100b883a 	mov	r5,r2
8111fb98:	8009883a 	mov	r4,r16
8111fb9c:	da001315 	stw	r8,76(sp)
8111fba0:	111d6e80 	call	8111d6e8 <_Bfree>
8111fba4:	d9400a17 	ldw	r5,40(sp)
8111fba8:	8009883a 	mov	r4,r16
8111fbac:	111d6e80 	call	8111d6e8 <_Bfree>
8111fbb0:	980b883a 	mov	r5,r19
8111fbb4:	8009883a 	mov	r4,r16
8111fbb8:	111d6e80 	call	8111d6e8 <_Bfree>
8111fbbc:	d9400817 	ldw	r5,32(sp)
8111fbc0:	8009883a 	mov	r4,r16
8111fbc4:	111d6e80 	call	8111d6e8 <_Bfree>
8111fbc8:	da001317 	ldw	r8,76(sp)
8111fbcc:	8009883a 	mov	r4,r16
8111fbd0:	400b883a 	mov	r5,r8
8111fbd4:	111d6e80 	call	8111d6e8 <_Bfree>
8111fbd8:	003d9206 	br	8111f224 <__reset+0xfb0ff224>
8111fbdc:	d8c00717 	ldw	r3,28(sp)
8111fbe0:	d8800504 	addi	r2,sp,20
8111fbe4:	01a04534 	movhi	r6,33044
8111fbe8:	31be2404 	addi	r6,r6,-1904
8111fbec:	d8c00115 	stw	r3,4(sp)
8111fbf0:	d8800015 	stw	r2,0(sp)
8111fbf4:	d9c00404 	addi	r7,sp,16
8111fbf8:	d9400604 	addi	r5,sp,24
8111fbfc:	8009883a 	mov	r4,r16
8111fc00:	11240500 	call	81124050 <__gethex>
8111fc04:	154001cc 	andi	r21,r2,7
8111fc08:	a83d9b26 	beq	r21,zero,8111f278 <__reset+0xfb0ff278>
8111fc0c:	00c00184 	movi	r3,6
8111fc10:	a8c0d61e 	bne	r21,r3,8111ff6c <_strtod_r+0x1070>
8111fc14:	9cc00044 	addi	r19,r19,1
8111fc18:	dcc00615 	stw	r19,24(sp)
8111fc1c:	002b883a 	mov	r21,zero
8111fc20:	002d883a 	mov	r22,zero
8111fc24:	d8000715 	stw	zero,28(sp)
8111fc28:	003d7e06 	br	8111f224 <__reset+0xfb0ff224>
8111fc2c:	00bf2c34 	movhi	r2,64688
8111fc30:	88a3883a 	add	r17,r17,r2
8111fc34:	9009883a 	mov	r4,r18
8111fc38:	880b883a 	mov	r5,r17
8111fc3c:	111e19c0 	call	8111e19c <__ulp>
8111fc40:	d9000b17 	ldw	r4,44(sp)
8111fc44:	100d883a 	mov	r6,r2
8111fc48:	180f883a 	mov	r7,r3
8111fc4c:	b00b883a 	mov	r5,r22
8111fc50:	1111b400 	call	81111b40 <__muldf3>
8111fc54:	900d883a 	mov	r6,r18
8111fc58:	180b883a 	mov	r5,r3
8111fc5c:	880f883a 	mov	r7,r17
8111fc60:	1009883a 	mov	r4,r2
8111fc64:	1125e080 	call	81125e08 <__adddf3>
8111fc68:	015f2834 	movhi	r5,31904
8111fc6c:	1025883a 	mov	r18,r2
8111fc70:	297fffc4 	addi	r5,r5,-1
8111fc74:	189ffc2c 	andhi	r2,r3,32752
8111fc78:	2880892e 	bgeu	r5,r2,8111fea0 <_strtod_r+0xfa4>
8111fc7c:	d8801017 	ldw	r2,64(sp)
8111fc80:	00dffc34 	movhi	r3,32752
8111fc84:	18ffffc4 	addi	r3,r3,-1
8111fc88:	10ffb726 	beq	r2,r3,8111fb68 <__reset+0xfb0ffb68>
8111fc8c:	045ffc34 	movhi	r17,32752
8111fc90:	8c7fffc4 	addi	r17,r17,-1
8111fc94:	04bfffc4 	movi	r18,-1
8111fc98:	003f4706 	br	8111f9b8 <__reset+0xfb0ff9b8>
8111fc9c:	00800884 	movi	r2,34
8111fca0:	80800015 	stw	r2,0(r16)
8111fca4:	002b883a 	mov	r21,zero
8111fca8:	059ffc34 	movhi	r22,32752
8111fcac:	003d5d06 	br	8111f224 <__reset+0xfb0ff224>
8111fcb0:	d9000d17 	ldw	r4,52(sp)
8111fcb4:	b80b883a 	mov	r5,r23
8111fcb8:	1127b080 	call	81127b08 <__fixdfsi>
8111fcbc:	1009883a 	mov	r4,r2
8111fcc0:	1127b880 	call	81127b88 <__floatsidf>
8111fcc4:	d9000d17 	ldw	r4,52(sp)
8111fcc8:	b80b883a 	mov	r5,r23
8111fccc:	100d883a 	mov	r6,r2
8111fcd0:	180f883a 	mov	r7,r3
8111fcd4:	11272040 	call	81127204 <__subdf3>
8111fcd8:	d9400e17 	ldw	r5,56(sp)
8111fcdc:	1039883a 	mov	fp,r2
8111fce0:	182f883a 	mov	r23,r3
8111fce4:	2800141e 	bne	r5,zero,8111fd38 <_strtod_r+0xe3c>
8111fce8:	9000131e 	bne	r18,zero,8111fd38 <_strtod_r+0xe3c>
8111fcec:	00800434 	movhi	r2,16
8111fcf0:	10bfffc4 	addi	r2,r2,-1
8111fcf4:	b0ac703a 	and	r22,r22,r2
8111fcf8:	b0000f1e 	bne	r22,zero,8111fd38 <_strtod_r+0xe3c>
8111fcfc:	01a52834 	movhi	r6,38048
8111fd00:	01cff434 	movhi	r7,16336
8111fd04:	318d6544 	addi	r6,r6,13717
8111fd08:	39ffffc4 	addi	r7,r7,-1
8111fd0c:	e009883a 	mov	r4,fp
8111fd10:	180b883a 	mov	r5,r3
8111fd14:	11271100 	call	81127110 <__ledf2>
8111fd18:	103f270e 	bge	r2,zero,8111f9b8 <__reset+0xfb0ff9b8>
8111fd1c:	dd000a15 	stw	r20,40(sp)
8111fd20:	a811883a 	mov	r8,r21
8111fd24:	dd001217 	ldw	r20,72(sp)
8111fd28:	d8800517 	ldw	r2,20(sp)
8111fd2c:	002b883a 	mov	r21,zero
8111fd30:	882d883a 	mov	r22,r17
8111fd34:	003f9706 	br	8111fb94 <__reset+0xfb0ffb94>
8111fd38:	01a52834 	movhi	r6,38048
8111fd3c:	01cff834 	movhi	r7,16352
8111fd40:	318d6544 	addi	r6,r6,13717
8111fd44:	39ffffc4 	addi	r7,r7,-1
8111fd48:	e009883a 	mov	r4,fp
8111fd4c:	b80b883a 	mov	r5,r23
8111fd50:	11271100 	call	81127110 <__ledf2>
8111fd54:	10000716 	blt	r2,zero,8111fd74 <_strtod_r+0xe78>
8111fd58:	018d6c34 	movhi	r6,13744
8111fd5c:	31b94d44 	addi	r6,r6,-6859
8111fd60:	01cff834 	movhi	r7,16352
8111fd64:	e009883a 	mov	r4,fp
8111fd68:	b80b883a 	mov	r5,r23
8111fd6c:	11270340 	call	81127034 <__gedf2>
8111fd70:	00bf110e 	bge	zero,r2,8111f9b8 <__reset+0xfb0ff9b8>
8111fd74:	dd000a15 	stw	r20,40(sp)
8111fd78:	a811883a 	mov	r8,r21
8111fd7c:	dd001217 	ldw	r20,72(sp)
8111fd80:	d8800517 	ldw	r2,20(sp)
8111fd84:	902b883a 	mov	r21,r18
8111fd88:	882d883a 	mov	r22,r17
8111fd8c:	003f8106 	br	8111fb94 <__reset+0xfb0ffb94>
8111fd90:	b83e2f26 	beq	r23,zero,8111f650 <__reset+0xfb0ff650>
8111fd94:	05efc83a 	sub	r23,zero,r23
8111fd98:	b88003cc 	andi	r2,r23,15
8111fd9c:	10000d26 	beq	r2,zero,8111fdd4 <_strtod_r+0xed8>
8111fda0:	100490fa 	slli	r2,r2,3
8111fda4:	00e04534 	movhi	r3,33044
8111fda8:	18fde904 	addi	r3,r3,-2140
8111fdac:	1885883a 	add	r2,r3,r2
8111fdb0:	11800017 	ldw	r6,0(r2)
8111fdb4:	11c00117 	ldw	r7,4(r2)
8111fdb8:	9009883a 	mov	r4,r18
8111fdbc:	880b883a 	mov	r5,r17
8111fdc0:	da401315 	stw	r9,76(sp)
8111fdc4:	11266bc0 	call	811266bc <__divdf3>
8111fdc8:	da401317 	ldw	r9,76(sp)
8111fdcc:	1025883a 	mov	r18,r2
8111fdd0:	1823883a 	mov	r17,r3
8111fdd4:	b82fd13a 	srai	r23,r23,4
8111fdd8:	b83e1d26 	beq	r23,zero,8111f650 <__reset+0xfb0ff650>
8111fddc:	008007c4 	movi	r2,31
8111fde0:	15c02816 	blt	r2,r23,8111fe84 <_strtod_r+0xf88>
8111fde4:	b880040c 	andi	r2,r23,16
8111fde8:	10019726 	beq	r2,zero,81120448 <_strtod_r+0x154c>
8111fdec:	05c1880e 	bge	zero,r23,81120410 <_strtod_r+0x1514>
8111fdf0:	00c01a84 	movi	r3,106
8111fdf4:	d8c00915 	stw	r3,36(sp)
8111fdf8:	04e04534 	movhi	r19,33044
8111fdfc:	9cfe2904 	addi	r19,r19,-1884
8111fe00:	8807883a 	mov	r3,r17
8111fe04:	9005883a 	mov	r2,r18
8111fe08:	8023883a 	mov	r17,r16
8111fe0c:	0009883a 	mov	r4,zero
8111fe10:	9821883a 	mov	r16,r19
8111fe14:	da400a15 	stw	r9,40(sp)
8111fe18:	1827883a 	mov	r19,r3
8111fe1c:	b980004c 	andi	r6,r23,1
8111fe20:	30000626 	beq	r6,zero,8111fe3c <_strtod_r+0xf40>
8111fe24:	81800017 	ldw	r6,0(r16)
8111fe28:	81c00117 	ldw	r7,4(r16)
8111fe2c:	1009883a 	mov	r4,r2
8111fe30:	180b883a 	mov	r5,r3
8111fe34:	1111b400 	call	81111b40 <__muldf3>
8111fe38:	01000044 	movi	r4,1
8111fe3c:	b82fd07a 	srai	r23,r23,1
8111fe40:	84000204 	addi	r16,r16,8
8111fe44:	b83ff51e 	bne	r23,zero,8111fe1c <__reset+0xfb0ffe1c>
8111fe48:	21003fcc 	andi	r4,r4,255
8111fe4c:	8821883a 	mov	r16,r17
8111fe50:	da400a17 	ldw	r9,40(sp)
8111fe54:	9823883a 	mov	r17,r19
8111fe58:	2001a51e 	bne	r4,zero,811204f0 <_strtod_r+0x15f4>
8111fe5c:	d9000917 	ldw	r4,36(sp)
8111fe60:	20016d1e 	bne	r4,zero,81120418 <_strtod_r+0x151c>
8111fe64:	000d883a 	mov	r6,zero
8111fe68:	000f883a 	mov	r7,zero
8111fe6c:	9009883a 	mov	r4,r18
8111fe70:	880b883a 	mov	r5,r17
8111fe74:	da401315 	stw	r9,76(sp)
8111fe78:	1126fac0 	call	81126fac <__eqdf2>
8111fe7c:	da401317 	ldw	r9,76(sp)
8111fe80:	103df41e 	bne	r2,zero,8111f654 <__reset+0xfb0ff654>
8111fe84:	00800884 	movi	r2,34
8111fe88:	80800015 	stw	r2,0(r16)
8111fe8c:	002b883a 	mov	r21,zero
8111fe90:	002d883a 	mov	r22,zero
8111fe94:	003ce306 	br	8111f224 <__reset+0xfb0ff224>
8111fe98:	055387c4 	movi	r21,19999
8111fe9c:	003d6b06 	br	8111f44c <__reset+0xfb0ff44c>
8111fea0:	0440d434 	movhi	r17,848
8111fea4:	1c63883a 	add	r17,r3,r17
8111fea8:	882d883a 	mov	r22,r17
8111feac:	003ebe06 	br	8111f9a8 <__reset+0xfb0ff9a8>
8111feb0:	14403fcc 	andi	r17,r2,255
8111feb4:	8c40201c 	xori	r17,r17,128
8111feb8:	8c7fe004 	addi	r17,r17,-128
8111febc:	dd400817 	ldw	r21,32(sp)
8111fec0:	0027883a 	mov	r19,zero
8111fec4:	0039883a 	mov	fp,zero
8111fec8:	002d883a 	mov	r22,zero
8111fecc:	003c9906 	br	8111f134 <__reset+0xfb0ff134>
8111fed0:	00c00944 	movi	r3,37
8111fed4:	1a47c83a 	sub	r3,r3,r9
8111fed8:	1d7d8c16 	blt	r3,r21,8111f50c <__reset+0xfb0ff50c>
8111fedc:	1261c83a 	sub	r16,r2,r9
8111fee0:	800490fa 	slli	r2,r16,3
8111fee4:	04e04534 	movhi	r19,33044
8111fee8:	9cfde904 	addi	r19,r19,-2140
8111feec:	9885883a 	add	r2,r19,r2
8111fef0:	11000017 	ldw	r4,0(r2)
8111fef4:	11400117 	ldw	r5,4(r2)
8111fef8:	900d883a 	mov	r6,r18
8111fefc:	880f883a 	mov	r7,r17
8111ff00:	1111b400 	call	81111b40 <__muldf3>
8111ff04:	ac0dc83a 	sub	r6,r21,r16
8111ff08:	300c90fa 	slli	r6,r6,3
8111ff0c:	1009883a 	mov	r4,r2
8111ff10:	180b883a 	mov	r5,r3
8111ff14:	9985883a 	add	r2,r19,r6
8111ff18:	11800017 	ldw	r6,0(r2)
8111ff1c:	11c00117 	ldw	r7,4(r2)
8111ff20:	1111b400 	call	81111b40 <__muldf3>
8111ff24:	102b883a 	mov	r21,r2
8111ff28:	182d883a 	mov	r22,r3
8111ff2c:	003cbd06 	br	8111f224 <__reset+0xfb0ff224>
8111ff30:	b811883a 	mov	r8,r23
8111ff34:	003e8606 	br	8111f950 <__reset+0xfb0ff950>
8111ff38:	d8000d15 	stw	zero,52(sp)
8111ff3c:	05cffc34 	movhi	r23,16368
8111ff40:	003e8006 	br	8111f944 <__reset+0xfb0ff944>
8111ff44:	883f011e 	bne	r17,zero,8111fb4c <__reset+0xfb0ffb4c>
8111ff48:	dd000a15 	stw	r20,40(sp)
8111ff4c:	dd001217 	ldw	r20,72(sp)
8111ff50:	a811883a 	mov	r8,r21
8111ff54:	00800884 	movi	r2,34
8111ff58:	80800015 	stw	r2,0(r16)
8111ff5c:	002b883a 	mov	r21,zero
8111ff60:	d8800517 	ldw	r2,20(sp)
8111ff64:	002d883a 	mov	r22,zero
8111ff68:	003f0a06 	br	8111fb94 <__reset+0xfb0ffb94>
8111ff6c:	d9800517 	ldw	r6,20(sp)
8111ff70:	30000826 	beq	r6,zero,8111ff94 <_strtod_r+0x1098>
8111ff74:	01400d44 	movi	r5,53
8111ff78:	d9000204 	addi	r4,sp,8
8111ff7c:	d8801315 	stw	r2,76(sp)
8111ff80:	111e5900 	call	8111e590 <__copybits>
8111ff84:	d9400517 	ldw	r5,20(sp)
8111ff88:	8009883a 	mov	r4,r16
8111ff8c:	111d6e80 	call	8111d6e8 <_Bfree>
8111ff90:	d8801317 	ldw	r2,76(sp)
8111ff94:	00c00184 	movi	r3,6
8111ff98:	1d400f36 	bltu	r3,r21,8111ffd8 <_strtod_r+0x10dc>
8111ff9c:	a82a90ba 	slli	r21,r21,2
8111ffa0:	00e044b4 	movhi	r3,33042
8111ffa4:	18ffed04 	addi	r3,r3,-76
8111ffa8:	a8eb883a 	add	r21,r21,r3
8111ffac:	a8c00017 	ldw	r3,0(r21)
8111ffb0:	1800683a 	jmp	r3
8111ffb4:	81120030 	cmpltui	r4,r16,18432
8111ffb8:	81120008 	cmpgei	r4,r16,18432
8111ffbc:	8111ffec 	andhi	r4,r16,18431
8111ffc0:	8111ffd0 	cmplti	r4,r16,18431
8111ffc4:	8111fff8 	rdprs	r4,r16,18431
8111ffc8:	81120008 	cmpgei	r4,r16,18432
8111ffcc:	81120030 	cmpltui	r4,r16,18432
8111ffd0:	045ffc34 	movhi	r17,32752
8111ffd4:	0025883a 	mov	r18,zero
8111ffd8:	1080020c 	andi	r2,r2,8
8111ffdc:	902b883a 	mov	r21,r18
8111ffe0:	103c8f26 	beq	r2,zero,8111f220 <__reset+0xfb0ff220>
8111ffe4:	8da00034 	orhi	r22,r17,32768
8111ffe8:	003c8e06 	br	8111f224 <__reset+0xfb0ff224>
8111ffec:	dc800217 	ldw	r18,8(sp)
8111fff0:	dc400317 	ldw	r17,12(sp)
8111fff4:	003ff806 	br	8111ffd8 <__reset+0xfb0fffd8>
8111fff8:	04600034 	movhi	r17,32768
8111fffc:	8c7fffc4 	addi	r17,r17,-1
81120000:	04bfffc4 	movi	r18,-1
81120004:	003ff406 	br	8111ffd8 <__reset+0xfb0fffd8>
81120008:	d8c00417 	ldw	r3,16(sp)
8112000c:	dc400317 	ldw	r17,12(sp)
81120010:	013ffc34 	movhi	r4,65520
81120014:	18c10cc4 	addi	r3,r3,1075
81120018:	1806953a 	slli	r3,r3,20
8112001c:	213fffc4 	addi	r4,r4,-1
81120020:	8922703a 	and	r17,r17,r4
81120024:	dc800217 	ldw	r18,8(sp)
81120028:	88e2b03a 	or	r17,r17,r3
8112002c:	003fea06 	br	8111ffd8 <__reset+0xfb0fffd8>
81120030:	0023883a 	mov	r17,zero
81120034:	0025883a 	mov	r18,zero
81120038:	003fe706 	br	8111ffd8 <__reset+0xfb0fffd8>
8112003c:	01800044 	movi	r6,1
81120040:	50d5883a 	add	r10,r10,r3
81120044:	2a4b883a 	add	r5,r5,r9
81120048:	19811a26 	beq	r3,r6,811204b4 <_strtod_r+0x15b8>
8112004c:	01800204 	movi	r6,8
81120050:	01c00404 	movi	r7,16
81120054:	4a400044 	addi	r9,r9,1
81120058:	48bfffc4 	addi	r2,r9,-1
8112005c:	30801616 	blt	r6,r2,811200b8 <_strtod_r+0x11bc>
81120060:	e70002a4 	muli	fp,fp,10
81120064:	497ffb1e 	bne	r9,r5,81120054 <__reset+0xfb100054>
81120068:	d9800617 	ldw	r6,24(sp)
8112006c:	4a400044 	addi	r9,r9,1
81120070:	00c00204 	movi	r3,8
81120074:	19400c0e 	bge	r3,r5,811200a8 <_strtod_r+0x11ac>
81120078:	00800404 	movi	r2,16
8112007c:	000b883a 	mov	r5,zero
81120080:	127ea316 	blt	r2,r9,8111fb10 <__reset+0xfb0ffb10>
81120084:	988002a4 	muli	r2,r19,10
81120088:	20a7883a 	add	r19,r4,r2
8112008c:	003ea006 	br	8111fb10 <__reset+0xfb0ffb10>
81120090:	d8800617 	ldw	r2,24(sp)
81120094:	8c7ff404 	addi	r17,r17,-48
81120098:	2a800044 	addi	r10,r5,1
8112009c:	d8800815 	stw	r2,32(sp)
811200a0:	100d883a 	mov	r6,r2
811200a4:	02400044 	movi	r9,1
811200a8:	e08002a4 	muli	r2,fp,10
811200ac:	000b883a 	mov	r5,zero
811200b0:	88b9883a 	add	fp,r17,r2
811200b4:	003e9606 	br	8111fb10 <__reset+0xfb0ffb10>
811200b8:	3a7fea16 	blt	r7,r9,81120064 <__reset+0xfb100064>
811200bc:	9cc002a4 	muli	r19,r19,10
811200c0:	003fe806 	br	81120064 <__reset+0xfb100064>
811200c4:	00bffa84 	movi	r2,-22
811200c8:	a8bd1016 	blt	r21,r2,8111f50c <__reset+0xfb0ff50c>
811200cc:	a82a90fa 	slli	r21,r21,3
811200d0:	00a04534 	movhi	r2,33044
811200d4:	10bde904 	addi	r2,r2,-2140
811200d8:	1545c83a 	sub	r2,r2,r21
811200dc:	11800017 	ldw	r6,0(r2)
811200e0:	11c00117 	ldw	r7,4(r2)
811200e4:	9009883a 	mov	r4,r18
811200e8:	880b883a 	mov	r5,r17
811200ec:	11266bc0 	call	811266bc <__divdf3>
811200f0:	102b883a 	mov	r21,r2
811200f4:	182d883a 	mov	r22,r3
811200f8:	003c4a06 	br	8111f224 <__reset+0xfb0ff224>
811200fc:	dd000a15 	stw	r20,40(sp)
81120100:	a811883a 	mov	r8,r21
81120104:	dd001217 	ldw	r20,72(sp)
81120108:	003e9e06 	br	8111fb84 <__reset+0xfb0ffb84>
8112010c:	01604534 	movhi	r5,33044
81120110:	d9000617 	ldw	r4,24(sp)
81120114:	297e1b04 	addi	r5,r5,-1940
81120118:	01c00644 	movi	r7,25
8112011c:	00000b06 	br	8112014c <_strtod_r+0x1250>
81120120:	21000044 	addi	r4,r4,1
81120124:	20800003 	ldbu	r2,0(r4)
81120128:	10ffefc4 	addi	r3,r2,-65
8112012c:	10803fcc 	andi	r2,r2,255
81120130:	1080201c 	xori	r2,r2,128
81120134:	18c03fcc 	andi	r3,r3,255
81120138:	10bfe004 	addi	r2,r2,-128
8112013c:	38c00136 	bltu	r7,r3,81120144 <_strtod_r+0x1248>
81120140:	10800804 	addi	r2,r2,32
81120144:	29400044 	addi	r5,r5,1
81120148:	11bbbb1e 	bne	r2,r6,8111f038 <__reset+0xfb0ff038>
8112014c:	29800007 	ldb	r6,0(r5)
81120150:	303ff31e 	bne	r6,zero,81120120 <__reset+0xfb100120>
81120154:	01a04534 	movhi	r6,33044
81120158:	d9000615 	stw	r4,24(sp)
8112015c:	31be1c04 	addi	r6,r6,-1936
81120160:	200b883a 	mov	r5,r4
81120164:	02000644 	movi	r8,25
81120168:	00000a06 	br	81120194 <_strtod_r+0x1298>
8112016c:	28800003 	ldbu	r2,0(r5)
81120170:	10ffefc4 	addi	r3,r2,-65
81120174:	10803fcc 	andi	r2,r2,255
81120178:	1080201c 	xori	r2,r2,128
8112017c:	18c03fcc 	andi	r3,r3,255
81120180:	10bfe004 	addi	r2,r2,-128
81120184:	40c00136 	bltu	r8,r3,8112018c <_strtod_r+0x1290>
81120188:	10800804 	addi	r2,r2,32
8112018c:	31800044 	addi	r6,r6,1
81120190:	11c0711e 	bne	r2,r7,81120358 <_strtod_r+0x145c>
81120194:	31c00007 	ldb	r7,0(r6)
81120198:	29400044 	addi	r5,r5,1
8112019c:	383ff31e 	bne	r7,zero,8112016c <__reset+0xfb10016c>
811201a0:	d9400615 	stw	r5,24(sp)
811201a4:	045ffc34 	movhi	r17,32752
811201a8:	0025883a 	mov	r18,zero
811201ac:	003c1b06 	br	8111f21c <__reset+0xfb0ff21c>
811201b0:	000b883a 	mov	r5,zero
811201b4:	003ccc06 	br	8111f4e8 <__reset+0xfb0ff4e8>
811201b8:	d9400e17 	ldw	r5,56(sp)
811201bc:	dd000a15 	stw	r20,40(sp)
811201c0:	00800434 	movhi	r2,16
811201c4:	a811883a 	mov	r8,r21
811201c8:	dd001217 	ldw	r20,72(sp)
811201cc:	dd401117 	ldw	r21,68(sp)
811201d0:	dd801017 	ldw	r22,64(sp)
811201d4:	10bfffc4 	addi	r2,r2,-1
811201d8:	28005626 	beq	r5,zero,81120334 <_strtod_r+0x1438>
811201dc:	8886703a 	and	r3,r17,r2
811201e0:	18807826 	beq	r3,r2,811203c4 <_strtod_r+0x14c8>
811201e4:	d8c00b17 	ldw	r3,44(sp)
811201e8:	18005726 	beq	r3,zero,81120348 <_strtod_r+0x144c>
811201ec:	1c44703a 	and	r2,r3,r17
811201f0:	10000f26 	beq	r2,zero,81120230 <_strtod_r+0x1334>
811201f4:	d9000e17 	ldw	r4,56(sp)
811201f8:	d9800917 	ldw	r6,36(sp)
811201fc:	20005e26 	beq	r4,zero,81120378 <_strtod_r+0x147c>
81120200:	9009883a 	mov	r4,r18
81120204:	880b883a 	mov	r5,r17
81120208:	da001315 	stw	r8,76(sp)
8112020c:	111ee900 	call	8111ee90 <sulp>
81120210:	100d883a 	mov	r6,r2
81120214:	180f883a 	mov	r7,r3
81120218:	9009883a 	mov	r4,r18
8112021c:	880b883a 	mov	r5,r17
81120220:	1125e080 	call	81125e08 <__adddf3>
81120224:	da001317 	ldw	r8,76(sp)
81120228:	102b883a 	mov	r21,r2
8112022c:	182d883a 	mov	r22,r3
81120230:	d8c00917 	ldw	r3,36(sp)
81120234:	18000f26 	beq	r3,zero,81120274 <_strtod_r+0x1378>
81120238:	a809883a 	mov	r4,r21
8112023c:	b00b883a 	mov	r5,r22
81120240:	000d883a 	mov	r6,zero
81120244:	01ce5434 	movhi	r7,14672
81120248:	da001315 	stw	r8,76(sp)
8112024c:	1111b400 	call	81111b40 <__muldf3>
81120250:	102b883a 	mov	r21,r2
81120254:	182d883a 	mov	r22,r3
81120258:	da001317 	ldw	r8,76(sp)
8112025c:	1800051e 	bne	r3,zero,81120274 <_strtod_r+0x1378>
81120260:	d8800517 	ldw	r2,20(sp)
81120264:	a83e4b1e 	bne	r21,zero,8111fb94 <__reset+0xfb0ffb94>
81120268:	00c00884 	movi	r3,34
8112026c:	80c00015 	stw	r3,0(r16)
81120270:	003e4806 	br	8111fb94 <__reset+0xfb0ffb94>
81120274:	d8800517 	ldw	r2,20(sp)
81120278:	003e4606 	br	8111fb94 <__reset+0xfb0ffb94>
8112027c:	d9000e17 	ldw	r4,56(sp)
81120280:	dd000a15 	stw	r20,40(sp)
81120284:	a811883a 	mov	r8,r21
81120288:	dd001217 	ldw	r20,72(sp)
8112028c:	dd401117 	ldw	r21,68(sp)
81120290:	dd801017 	ldw	r22,64(sp)
81120294:	203fe61e 	bne	r4,zero,81120230 <__reset+0xfb100230>
81120298:	903fe51e 	bne	r18,zero,81120230 <__reset+0xfb100230>
8112029c:	00800434 	movhi	r2,16
811202a0:	10bfffc4 	addi	r2,r2,-1
811202a4:	8884703a 	and	r2,r17,r2
811202a8:	103fe11e 	bne	r2,zero,81120230 <__reset+0xfb100230>
811202ac:	8ddffc2c 	andhi	r23,r17,32752
811202b0:	0081ac34 	movhi	r2,1712
811202b4:	15ffde2e 	bgeu	r2,r23,81120230 <__reset+0xfb100230>
811202b8:	40800517 	ldw	r2,20(r8)
811202bc:	1000031e 	bne	r2,zero,811202cc <_strtod_r+0x13d0>
811202c0:	40800417 	ldw	r2,16(r8)
811202c4:	00c00044 	movi	r3,1
811202c8:	18bfd90e 	bge	r3,r2,81120230 <__reset+0xfb100230>
811202cc:	400b883a 	mov	r5,r8
811202d0:	01800044 	movi	r6,1
811202d4:	8009883a 	mov	r4,r16
811202d8:	111dde80 	call	8111dde8 <__lshift>
811202dc:	980b883a 	mov	r5,r19
811202e0:	1009883a 	mov	r4,r2
811202e4:	d8801315 	stw	r2,76(sp)
811202e8:	111df380 	call	8111df38 <__mcmp>
811202ec:	da001317 	ldw	r8,76(sp)
811202f0:	00bfcf0e 	bge	zero,r2,81120230 <__reset+0xfb100230>
811202f4:	d8c00917 	ldw	r3,36(sp)
811202f8:	18005c26 	beq	r3,zero,8112046c <_strtod_r+0x1570>
811202fc:	0081ac34 	movhi	r2,1712
81120300:	15c05a16 	blt	r2,r23,8112046c <_strtod_r+0x1570>
81120304:	0080dc34 	movhi	r2,880
81120308:	15ffcb16 	blt	r2,r23,81120238 <__reset+0xfb100238>
8112030c:	003f1106 	br	8111ff54 <__reset+0xfb0fff54>
81120310:	002d883a 	mov	r22,zero
81120314:	022ff834 	movhi	r8,49120
81120318:	d8000d15 	stw	zero,52(sp)
8112031c:	05cff834 	movhi	r23,16352
81120320:	003ded06 	br	8111fad8 <__reset+0xfb0ffad8>
81120324:	0440d434 	movhi	r17,848
81120328:	1c63883a 	add	r17,r3,r17
8112032c:	d8000915 	stw	zero,36(sp)
81120330:	003cc806 	br	8111f654 <__reset+0xfb0ff654>
81120334:	8884703a 	and	r2,r17,r2
81120338:	103faa1e 	bne	r2,zero,811201e4 <__reset+0xfb1001e4>
8112033c:	903fa91e 	bne	r18,zero,811201e4 <__reset+0xfb1001e4>
81120340:	8ddffc2c 	andhi	r23,r17,32752
81120344:	003feb06 	br	811202f4 <__reset+0xfb1002f4>
81120348:	d8c00d17 	ldw	r3,52(sp)
8112034c:	1cae703a 	and	r23,r3,r18
81120350:	b83fb726 	beq	r23,zero,81120230 <__reset+0xfb100230>
81120354:	003fa706 	br	811201f4 <__reset+0xfb1001f4>
81120358:	21000044 	addi	r4,r4,1
8112035c:	d9000615 	stw	r4,24(sp)
81120360:	003f9006 	br	811201a4 <__reset+0xfb1001a4>
81120364:	01604534 	movhi	r5,33044
81120368:	297ddf04 	addi	r5,r5,-2180
8112036c:	d9400915 	stw	r5,36(sp)
81120370:	0027883a 	mov	r19,zero
81120374:	003ca206 	br	8111f600 <__reset+0xfb0ff600>
81120378:	9009883a 	mov	r4,r18
8112037c:	880b883a 	mov	r5,r17
81120380:	da001315 	stw	r8,76(sp)
81120384:	111ee900 	call	8111ee90 <sulp>
81120388:	100d883a 	mov	r6,r2
8112038c:	180f883a 	mov	r7,r3
81120390:	9009883a 	mov	r4,r18
81120394:	880b883a 	mov	r5,r17
81120398:	11272040 	call	81127204 <__subdf3>
8112039c:	000d883a 	mov	r6,zero
811203a0:	000f883a 	mov	r7,zero
811203a4:	1009883a 	mov	r4,r2
811203a8:	180b883a 	mov	r5,r3
811203ac:	102b883a 	mov	r21,r2
811203b0:	182d883a 	mov	r22,r3
811203b4:	1126fac0 	call	81126fac <__eqdf2>
811203b8:	da001317 	ldw	r8,76(sp)
811203bc:	103ee526 	beq	r2,zero,8111ff54 <__reset+0xfb0fff54>
811203c0:	003f9b06 	br	81120230 <__reset+0xfb100230>
811203c4:	d8800917 	ldw	r2,36(sp)
811203c8:	10002226 	beq	r2,zero,81120454 <_strtod_r+0x1558>
811203cc:	889ffc2c 	andhi	r2,r17,32752
811203d0:	00c1a834 	movhi	r3,1696
811203d4:	18801f36 	bltu	r3,r2,81120454 <_strtod_r+0x1558>
811203d8:	1004d53a 	srli	r2,r2,20
811203dc:	00c01ac4 	movi	r3,107
811203e0:	1887c83a 	sub	r3,r3,r2
811203e4:	00bfffc4 	movi	r2,-1
811203e8:	10c4983a 	sll	r2,r2,r3
811203ec:	14bf7d1e 	bne	r2,r18,811201e4 <__reset+0xfb1001e4>
811203f0:	00dffc34 	movhi	r3,32752
811203f4:	18ffffc4 	addi	r3,r3,-1
811203f8:	88c03526 	beq	r17,r3,811204d0 <_strtod_r+0x15d4>
811203fc:	8c5ffc2c 	andhi	r17,r17,32752
81120400:	00800434 	movhi	r2,16
81120404:	002b883a 	mov	r21,zero
81120408:	88ad883a 	add	r22,r17,r2
8112040c:	003f8806 	br	81120230 <__reset+0xfb100230>
81120410:	01401a84 	movi	r5,106
81120414:	d9400915 	stw	r5,36(sp)
81120418:	8ddffc2c 	andhi	r23,r17,32752
8112041c:	b82ed53a 	srli	r23,r23,20
81120420:	00801ac4 	movi	r2,107
81120424:	15c5c83a 	sub	r2,r2,r23
81120428:	00be8e0e 	bge	zero,r2,8111fe64 <__reset+0xfb0ffe64>
8112042c:	00c007c4 	movi	r3,31
81120430:	18800a0e 	bge	r3,r2,8112045c <_strtod_r+0x1560>
81120434:	00c00d04 	movi	r3,52
81120438:	0025883a 	mov	r18,zero
8112043c:	1880270e 	bge	r3,r2,811204dc <_strtod_r+0x15e0>
81120440:	0440dc34 	movhi	r17,880
81120444:	003e8706 	br	8111fe64 <__reset+0xfb0ffe64>
81120448:	d8000915 	stw	zero,36(sp)
8112044c:	05fe6a16 	blt	zero,r23,8111fdf8 <__reset+0xfb0ffdf8>
81120450:	003e8406 	br	8111fe64 <__reset+0xfb0ffe64>
81120454:	00bfffc4 	movi	r2,-1
81120458:	003fe406 	br	811203ec <__reset+0xfb1003ec>
8112045c:	00ffffc4 	movi	r3,-1
81120460:	1884983a 	sll	r2,r3,r2
81120464:	14a4703a 	and	r18,r2,r18
81120468:	003e7e06 	br	8111fe64 <__reset+0xfb0ffe64>
8112046c:	00bffc34 	movhi	r2,65520
81120470:	b8af883a 	add	r23,r23,r2
81120474:	057fffc4 	movi	r21,-1
81120478:	00800434 	movhi	r2,16
8112047c:	1545883a 	add	r2,r2,r21
81120480:	b8acb03a 	or	r22,r23,r2
81120484:	003f6a06 	br	81120230 <__reset+0xfb100230>
81120488:	01604534 	movhi	r5,33044
8112048c:	297e1f04 	addi	r5,r5,-1924
81120490:	d9800204 	addi	r6,sp,8
81120494:	d9000604 	addi	r4,sp,24
81120498:	11248880 	call	81124888 <__hexnan>
8112049c:	00c00144 	movi	r3,5
811204a0:	10fb5c1e 	bne	r2,r3,8111f214 <__reset+0xfb0ff214>
811204a4:	dc400317 	ldw	r17,12(sp)
811204a8:	dc800217 	ldw	r18,8(sp)
811204ac:	8c5ffc34 	orhi	r17,r17,32752
811204b0:	003b5a06 	br	8111f21c <__reset+0xfb0ff21c>
811204b4:	480b883a 	mov	r5,r9
811204b8:	d9800617 	ldw	r6,24(sp)
811204bc:	4a400044 	addi	r9,r9,1
811204c0:	003eeb06 	br	81120070 <__reset+0xfb100070>
811204c4:	1025883a 	mov	r18,r2
811204c8:	1823883a 	mov	r17,r3
811204cc:	003c4c06 	br	8111f600 <__reset+0xfb0ff600>
811204d0:	00ffffc4 	movi	r3,-1
811204d4:	10ffc91e 	bne	r2,r3,811203fc <__reset+0xfb1003fc>
811204d8:	003da906 	br	8111fb80 <__reset+0xfb0ffb80>
811204dc:	10bff804 	addi	r2,r2,-32
811204e0:	00ffffc4 	movi	r3,-1
811204e4:	1884983a 	sll	r2,r3,r2
811204e8:	1462703a 	and	r17,r2,r17
811204ec:	003e5d06 	br	8111fe64 <__reset+0xfb0ffe64>
811204f0:	1025883a 	mov	r18,r2
811204f4:	1823883a 	mov	r17,r3
811204f8:	003e5806 	br	8111fe5c <__reset+0xfb0ffe5c>

811204fc <strtod>:
811204fc:	00a04534 	movhi	r2,33044
81120500:	1086aa04 	addi	r2,r2,6824
81120504:	280d883a 	mov	r6,r5
81120508:	200b883a 	mov	r5,r4
8112050c:	11000017 	ldw	r4,0(r2)
81120510:	111eefc1 	jmpi	8111eefc <_strtod_r>

81120514 <strtof>:
81120514:	defffb04 	addi	sp,sp,-20
81120518:	de00012e 	bgeu	sp,et,81120520 <strtof+0xc>
8112051c:	003b68fa 	trap	3
81120520:	dcc00315 	stw	r19,12(sp)
81120524:	04e04534 	movhi	r19,33044
81120528:	9cc6aa04 	addi	r19,r19,6824
8112052c:	280d883a 	mov	r6,r5
81120530:	200b883a 	mov	r5,r4
81120534:	99000017 	ldw	r4,0(r19)
81120538:	dfc00415 	stw	ra,16(sp)
8112053c:	dc800215 	stw	r18,8(sp)
81120540:	dc400115 	stw	r17,4(sp)
81120544:	dc000015 	stw	r16,0(sp)
81120548:	111eefc0 	call	8111eefc <_strtod_r>
8112054c:	1009883a 	mov	r4,r2
81120550:	180b883a 	mov	r5,r3
81120554:	1025883a 	mov	r18,r2
81120558:	1823883a 	mov	r17,r3
8112055c:	11123780 	call	81112378 <__truncdfsf2>
81120560:	000b883a 	mov	r5,zero
81120564:	1009883a 	mov	r4,r2
81120568:	1021883a 	mov	r16,r2
8112056c:	1125c0c0 	call	81125c0c <__eqsf2>
81120570:	1000111e 	bne	r2,zero,811205b8 <strtof+0xa4>
81120574:	000d883a 	mov	r6,zero
81120578:	000f883a 	mov	r7,zero
8112057c:	9009883a 	mov	r4,r18
81120580:	880b883a 	mov	r5,r17
81120584:	1126fac0 	call	81126fac <__eqdf2>
81120588:	10000b26 	beq	r2,zero,811205b8 <strtof+0xa4>
8112058c:	98800017 	ldw	r2,0(r19)
81120590:	00c00884 	movi	r3,34
81120594:	10c00015 	stw	r3,0(r2)
81120598:	8005883a 	mov	r2,r16
8112059c:	dfc00417 	ldw	ra,16(sp)
811205a0:	dcc00317 	ldw	r19,12(sp)
811205a4:	dc800217 	ldw	r18,8(sp)
811205a8:	dc400117 	ldw	r17,4(sp)
811205ac:	dc000017 	ldw	r16,0(sp)
811205b0:	dec00504 	addi	sp,sp,20
811205b4:	f800283a 	ret
811205b8:	015fe034 	movhi	r5,32640
811205bc:	297fffc4 	addi	r5,r5,-1
811205c0:	8009883a 	mov	r4,r16
811205c4:	1125c840 	call	81125c84 <__gesf2>
811205c8:	0080070e 	bge	zero,r2,811205e8 <strtof+0xd4>
811205cc:	01dffc34 	movhi	r7,32752
811205d0:	39ffffc4 	addi	r7,r7,-1
811205d4:	01bfffc4 	movi	r6,-1
811205d8:	9009883a 	mov	r4,r18
811205dc:	880b883a 	mov	r5,r17
811205e0:	11270340 	call	81127034 <__gedf2>
811205e4:	00bfe90e 	bge	zero,r2,8112058c <__reset+0xfb10058c>
811205e8:	017fe034 	movhi	r5,65408
811205ec:	297fffc4 	addi	r5,r5,-1
811205f0:	8009883a 	mov	r4,r16
811205f4:	1125d400 	call	81125d40 <__lesf2>
811205f8:	103fe70e 	bge	r2,zero,81120598 <__reset+0xfb100598>
811205fc:	01fffc34 	movhi	r7,65520
81120600:	39ffffc4 	addi	r7,r7,-1
81120604:	01bfffc4 	movi	r6,-1
81120608:	9009883a 	mov	r4,r18
8112060c:	880b883a 	mov	r5,r17
81120610:	11271100 	call	81127110 <__ledf2>
81120614:	103fdd0e 	bge	r2,zero,8112058c <__reset+0xfb10058c>
81120618:	003fdf06 	br	81120598 <__reset+0xfb100598>

8112061c <_strtoll_r>:
8112061c:	00a04534 	movhi	r2,33044
81120620:	defff304 	addi	sp,sp,-52
81120624:	1086a804 	addi	r2,r2,6816
81120628:	de00012e 	bgeu	sp,et,81120630 <_strtoll_r+0x14>
8112062c:	003b68fa 	trap	3
81120630:	dc800515 	stw	r18,20(sp)
81120634:	14800017 	ldw	r18,0(r2)
81120638:	dd800915 	stw	r22,36(sp)
8112063c:	dd400815 	stw	r21,32(sp)
81120640:	dcc00615 	stw	r19,24(sp)
81120644:	d9000015 	stw	r4,0(sp)
81120648:	dfc00c15 	stw	ra,48(sp)
8112064c:	df000b15 	stw	fp,44(sp)
81120650:	ddc00a15 	stw	r23,40(sp)
81120654:	dd000715 	stw	r20,28(sp)
81120658:	dc400415 	stw	r17,16(sp)
8112065c:	dc000315 	stw	r16,12(sp)
81120660:	282d883a 	mov	r22,r5
81120664:	302b883a 	mov	r21,r6
81120668:	3827883a 	mov	r19,r7
8112066c:	2809883a 	mov	r4,r5
81120670:	24000003 	ldbu	r16,0(r4)
81120674:	24400044 	addi	r17,r4,1
81120678:	2007883a 	mov	r3,r4
8112067c:	9405883a 	add	r2,r18,r16
81120680:	10800043 	ldbu	r2,1(r2)
81120684:	8809883a 	mov	r4,r17
81120688:	1080020c 	andi	r2,r2,8
8112068c:	103ff81e 	bne	r2,zero,81120670 <__reset+0xfb100670>
81120690:	00800b44 	movi	r2,45
81120694:	80807826 	beq	r16,r2,81120878 <_strtoll_r+0x25c>
81120698:	00800ac4 	movi	r2,43
8112069c:	80807a26 	beq	r16,r2,81120888 <_strtoll_r+0x26c>
811206a0:	0039883a 	mov	fp,zero
811206a4:	98004e26 	beq	r19,zero,811207e0 <_strtoll_r+0x1c4>
811206a8:	00800404 	movi	r2,16
811206ac:	98808226 	beq	r19,r2,811208b8 <_strtoll_r+0x29c>
811206b0:	982fd7fa 	srai	r23,r19,31
811206b4:	9829883a 	mov	r20,r19
811206b8:	e0004f26 	beq	fp,zero,811207f8 <_strtoll_r+0x1dc>
811206bc:	0017883a 	mov	r11,zero
811206c0:	02a00034 	movhi	r10,32768
811206c4:	5809883a 	mov	r4,r11
811206c8:	500b883a 	mov	r5,r10
811206cc:	a00d883a 	mov	r6,r20
811206d0:	b80f883a 	mov	r7,r23
811206d4:	da800215 	stw	r10,8(sp)
811206d8:	dac00115 	stw	r11,4(sp)
811206dc:	11255180 	call	81125518 <__umoddi3>
811206e0:	dac00117 	ldw	r11,4(sp)
811206e4:	da800217 	ldw	r10,8(sp)
811206e8:	a00d883a 	mov	r6,r20
811206ec:	5809883a 	mov	r4,r11
811206f0:	500b883a 	mov	r5,r10
811206f4:	b80f883a 	mov	r7,r23
811206f8:	d8800115 	stw	r2,4(sp)
811206fc:	1124f980 	call	81124f98 <__udivdi3>
81120700:	9409883a 	add	r4,r18,r16
81120704:	21000043 	ldbu	r4,1(r4)
81120708:	1019883a 	mov	r12,r2
8112070c:	880b883a 	mov	r5,r17
81120710:	2240010c 	andi	r9,r4,4
81120714:	0015883a 	mov	r10,zero
81120718:	000d883a 	mov	r6,zero
8112071c:	000f883a 	mov	r7,zero
81120720:	03400044 	movi	r13,1
81120724:	02ffffc4 	movi	r11,-1
81120728:	da000117 	ldw	r8,4(sp)
8112072c:	48000d26 	beq	r9,zero,81120764 <_strtoll_r+0x148>
81120730:	843ff404 	addi	r16,r16,-48
81120734:	84c0110e 	bge	r16,r19,8112077c <_strtoll_r+0x160>
81120738:	52c00426 	beq	r10,r11,8112074c <_strtoll_r+0x130>
8112073c:	19c00236 	bltu	r3,r7,81120748 <_strtoll_r+0x12c>
81120740:	38c0311e 	bne	r7,r3,81120808 <_strtoll_r+0x1ec>
81120744:	6180302e 	bgeu	r12,r6,81120808 <_strtoll_r+0x1ec>
81120748:	02bfffc4 	movi	r10,-1
8112074c:	2c000003 	ldbu	r16,0(r5)
81120750:	29400044 	addi	r5,r5,1
81120754:	9409883a 	add	r4,r18,r16
81120758:	21000043 	ldbu	r4,1(r4)
8112075c:	2240010c 	andi	r9,r4,4
81120760:	483ff31e 	bne	r9,zero,81120730 <__reset+0xfb100730>
81120764:	210000cc 	andi	r4,r4,3
81120768:	20000426 	beq	r4,zero,8112077c <_strtoll_r+0x160>
8112076c:	23403426 	beq	r4,r13,81120840 <_strtoll_r+0x224>
81120770:	008015c4 	movi	r2,87
81120774:	80a1c83a 	sub	r16,r16,r2
81120778:	84ffef16 	blt	r16,r19,81120738 <__reset+0xfb100738>
8112077c:	00bfffc4 	movi	r2,-1
81120780:	50803426 	beq	r10,r2,81120854 <_strtoll_r+0x238>
81120784:	e0000426 	beq	fp,zero,81120798 <_strtoll_r+0x17c>
81120788:	018dc83a 	sub	r6,zero,r6
8112078c:	3004c03a 	cmpne	r2,r6,zero
81120790:	01e1c83a 	sub	r16,zero,r7
81120794:	808fc83a 	sub	r7,r16,r2
81120798:	3005883a 	mov	r2,r6
8112079c:	3807883a 	mov	r3,r7
811207a0:	a8000326 	beq	r21,zero,811207b0 <_strtoll_r+0x194>
811207a4:	5000321e 	bne	r10,zero,81120870 <_strtoll_r+0x254>
811207a8:	b00b883a 	mov	r5,r22
811207ac:	a9400015 	stw	r5,0(r21)
811207b0:	dfc00c17 	ldw	ra,48(sp)
811207b4:	df000b17 	ldw	fp,44(sp)
811207b8:	ddc00a17 	ldw	r23,40(sp)
811207bc:	dd800917 	ldw	r22,36(sp)
811207c0:	dd400817 	ldw	r21,32(sp)
811207c4:	dd000717 	ldw	r20,28(sp)
811207c8:	dcc00617 	ldw	r19,24(sp)
811207cc:	dc800517 	ldw	r18,20(sp)
811207d0:	dc400417 	ldw	r17,16(sp)
811207d4:	dc000317 	ldw	r16,12(sp)
811207d8:	dec00d04 	addi	sp,sp,52
811207dc:	f800283a 	ret
811207e0:	00800c04 	movi	r2,48
811207e4:	80802c26 	beq	r16,r2,81120898 <_strtoll_r+0x27c>
811207e8:	05000284 	movi	r20,10
811207ec:	002f883a 	mov	r23,zero
811207f0:	a027883a 	mov	r19,r20
811207f4:	e03fb11e 	bne	fp,zero,811206bc <__reset+0xfb1006bc>
811207f8:	02a00034 	movhi	r10,32768
811207fc:	52bfffc4 	addi	r10,r10,-1
81120800:	02ffffc4 	movi	r11,-1
81120804:	003faf06 	br	811206c4 <__reset+0xfb1006c4>
81120808:	33000f26 	beq	r6,r12,81120848 <_strtoll_r+0x22c>
8112080c:	b985383a 	mul	r2,r23,r6
81120810:	3d0f383a 	mul	r7,r7,r20
81120814:	3508383a 	mulxuu	r4,r6,r20
81120818:	350d383a 	mul	r6,r6,r20
8112081c:	8013d7fa 	srai	r9,r16,31
81120820:	388f883a 	add	r7,r7,r2
81120824:	818d883a 	add	r6,r16,r6
81120828:	390f883a 	add	r7,r7,r4
8112082c:	3421803a 	cmpltu	r16,r6,r16
81120830:	49cf883a 	add	r7,r9,r7
81120834:	81cf883a 	add	r7,r16,r7
81120838:	02800044 	movi	r10,1
8112083c:	003fc306 	br	8112074c <__reset+0xfb10074c>
81120840:	00800dc4 	movi	r2,55
81120844:	003fcb06 	br	81120774 <__reset+0xfb100774>
81120848:	38fff01e 	bne	r7,r3,8112080c <__reset+0xfb10080c>
8112084c:	443fbe16 	blt	r8,r16,81120748 <__reset+0xfb100748>
81120850:	003fee06 	br	8112080c <__reset+0xfb10080c>
81120854:	e0002426 	beq	fp,zero,811208e8 <_strtoll_r+0x2cc>
81120858:	0005883a 	mov	r2,zero
8112085c:	00e00034 	movhi	r3,32768
81120860:	d9800017 	ldw	r6,0(sp)
81120864:	01000884 	movi	r4,34
81120868:	31000015 	stw	r4,0(r6)
8112086c:	a83fd026 	beq	r21,zero,811207b0 <__reset+0xfb1007b0>
81120870:	297fffc4 	addi	r5,r5,-1
81120874:	003fcd06 	br	811207ac <__reset+0xfb1007ac>
81120878:	1c400084 	addi	r17,r3,2
8112087c:	1c000043 	ldbu	r16,1(r3)
81120880:	07000044 	movi	fp,1
81120884:	003f8706 	br	811206a4 <__reset+0xfb1006a4>
81120888:	1c400084 	addi	r17,r3,2
8112088c:	1c000043 	ldbu	r16,1(r3)
81120890:	0039883a 	mov	fp,zero
81120894:	003f8306 	br	811206a4 <__reset+0xfb1006a4>
81120898:	88800003 	ldbu	r2,0(r17)
8112089c:	00c01604 	movi	r3,88
811208a0:	108037cc 	andi	r2,r2,223
811208a4:	10c00a26 	beq	r2,r3,811208d0 <_strtoll_r+0x2b4>
811208a8:	05000204 	movi	r20,8
811208ac:	002f883a 	mov	r23,zero
811208b0:	a027883a 	mov	r19,r20
811208b4:	003f8006 	br	811206b8 <__reset+0xfb1006b8>
811208b8:	00800c04 	movi	r2,48
811208bc:	80800e1e 	bne	r16,r2,811208f8 <_strtoll_r+0x2dc>
811208c0:	88800003 	ldbu	r2,0(r17)
811208c4:	00c01604 	movi	r3,88
811208c8:	108037cc 	andi	r2,r2,223
811208cc:	10c00a1e 	bne	r2,r3,811208f8 <_strtoll_r+0x2dc>
811208d0:	05000404 	movi	r20,16
811208d4:	8c000043 	ldbu	r16,1(r17)
811208d8:	002f883a 	mov	r23,zero
811208dc:	8c400084 	addi	r17,r17,2
811208e0:	a027883a 	mov	r19,r20
811208e4:	003f7406 	br	811206b8 <__reset+0xfb1006b8>
811208e8:	00e00034 	movhi	r3,32768
811208ec:	18ffffc4 	addi	r3,r3,-1
811208f0:	5005883a 	mov	r2,r10
811208f4:	003fda06 	br	81120860 <__reset+0xfb100860>
811208f8:	9829883a 	mov	r20,r19
811208fc:	002f883a 	mov	r23,zero
81120900:	003f6d06 	br	811206b8 <__reset+0xfb1006b8>

81120904 <_strtoul_r>:
81120904:	00a04534 	movhi	r2,33044
81120908:	defff604 	addi	sp,sp,-40
8112090c:	1086a804 	addi	r2,r2,6816
81120910:	de00012e 	bgeu	sp,et,81120918 <_strtoul_r+0x14>
81120914:	003b68fa 	trap	3
81120918:	dc800315 	stw	r18,12(sp)
8112091c:	14800017 	ldw	r18,0(r2)
81120920:	dd400615 	stw	r21,24(sp)
81120924:	dd000515 	stw	r20,20(sp)
81120928:	dcc00415 	stw	r19,16(sp)
8112092c:	2029883a 	mov	r20,r4
81120930:	dfc00915 	stw	ra,36(sp)
81120934:	ddc00815 	stw	r23,32(sp)
81120938:	dd800715 	stw	r22,28(sp)
8112093c:	dc400215 	stw	r17,8(sp)
81120940:	dc000115 	stw	r16,4(sp)
81120944:	2827883a 	mov	r19,r5
81120948:	382b883a 	mov	r21,r7
8112094c:	2809883a 	mov	r4,r5
81120950:	24000003 	ldbu	r16,0(r4)
81120954:	24400044 	addi	r17,r4,1
81120958:	2007883a 	mov	r3,r4
8112095c:	9405883a 	add	r2,r18,r16
81120960:	10800043 	ldbu	r2,1(r2)
81120964:	8809883a 	mov	r4,r17
81120968:	1080020c 	andi	r2,r2,8
8112096c:	103ff81e 	bne	r2,zero,81120950 <__reset+0xfb100950>
81120970:	00800b44 	movi	r2,45
81120974:	80805326 	beq	r16,r2,81120ac4 <_strtoul_r+0x1c0>
81120978:	00800ac4 	movi	r2,43
8112097c:	80805526 	beq	r16,r2,81120ad4 <_strtoul_r+0x1d0>
81120980:	002f883a 	mov	r23,zero
81120984:	a8000f26 	beq	r21,zero,811209c4 <_strtoul_r+0xc0>
81120988:	00800404 	movi	r2,16
8112098c:	a8805f26 	beq	r21,r2,81120b0c <_strtoul_r+0x208>
81120990:	013fffc4 	movi	r4,-1
81120994:	a80b883a 	mov	r5,r21
81120998:	d9800015 	stw	r6,0(sp)
8112099c:	1125b500 	call	81125b50 <__udivsi3>
811209a0:	a80b883a 	mov	r5,r21
811209a4:	013fffc4 	movi	r4,-1
811209a8:	102d883a 	mov	r22,r2
811209ac:	1125bb40 	call	81125bb4 <__umodsi3>
811209b0:	d9800017 	ldw	r6,0(sp)
811209b4:	1019883a 	mov	r12,r2
811209b8:	a817883a 	mov	r11,r21
811209bc:	b00f883a 	mov	r7,r22
811209c0:	00000706 	br	811209e0 <_strtoul_r+0xdc>
811209c4:	00800c04 	movi	r2,48
811209c8:	80804626 	beq	r16,r2,81120ae4 <_strtoul_r+0x1e0>
811209cc:	05400284 	movi	r21,10
811209d0:	01c666b4 	movhi	r7,6554
811209d4:	03000144 	movi	r12,5
811209d8:	39e66644 	addi	r7,r7,-26215
811209dc:	a817883a 	mov	r11,r21
811209e0:	9407883a 	add	r3,r18,r16
811209e4:	18c00043 	ldbu	r3,1(r3)
811209e8:	8809883a 	mov	r4,r17
811209ec:	0011883a 	mov	r8,zero
811209f0:	1940010c 	andi	r5,r3,4
811209f4:	0005883a 	mov	r2,zero
811209f8:	02800044 	movi	r10,1
811209fc:	027fffc4 	movi	r9,-1
81120a00:	28000e26 	beq	r5,zero,81120a3c <_strtoul_r+0x138>
81120a04:	843ff404 	addi	r16,r16,-48
81120a08:	8540120e 	bge	r16,r21,81120a54 <_strtoul_r+0x150>
81120a0c:	42400526 	beq	r8,r9,81120a24 <_strtoul_r+0x120>
81120a10:	38802236 	bltu	r7,r2,81120a9c <_strtoul_r+0x198>
81120a14:	11c02026 	beq	r2,r7,81120a98 <_strtoul_r+0x194>
81120a18:	12c5383a 	mul	r2,r2,r11
81120a1c:	02000044 	movi	r8,1
81120a20:	8085883a 	add	r2,r16,r2
81120a24:	24000003 	ldbu	r16,0(r4)
81120a28:	21000044 	addi	r4,r4,1
81120a2c:	9407883a 	add	r3,r18,r16
81120a30:	18c00043 	ldbu	r3,1(r3)
81120a34:	1940010c 	andi	r5,r3,4
81120a38:	283ff21e 	bne	r5,zero,81120a04 <__reset+0xfb100a04>
81120a3c:	18c000cc 	andi	r3,r3,3
81120a40:	18000426 	beq	r3,zero,81120a54 <_strtoul_r+0x150>
81120a44:	1a801726 	beq	r3,r10,81120aa4 <_strtoul_r+0x1a0>
81120a48:	00c015c4 	movi	r3,87
81120a4c:	80e1c83a 	sub	r16,r16,r3
81120a50:	857fee16 	blt	r16,r21,81120a0c <__reset+0xfb100a0c>
81120a54:	40001516 	blt	r8,zero,81120aac <_strtoul_r+0x1a8>
81120a58:	b8000126 	beq	r23,zero,81120a60 <_strtoul_r+0x15c>
81120a5c:	0085c83a 	sub	r2,zero,r2
81120a60:	30000226 	beq	r6,zero,81120a6c <_strtoul_r+0x168>
81120a64:	4000151e 	bne	r8,zero,81120abc <_strtoul_r+0x1b8>
81120a68:	34c00015 	stw	r19,0(r6)
81120a6c:	dfc00917 	ldw	ra,36(sp)
81120a70:	ddc00817 	ldw	r23,32(sp)
81120a74:	dd800717 	ldw	r22,28(sp)
81120a78:	dd400617 	ldw	r21,24(sp)
81120a7c:	dd000517 	ldw	r20,20(sp)
81120a80:	dcc00417 	ldw	r19,16(sp)
81120a84:	dc800317 	ldw	r18,12(sp)
81120a88:	dc400217 	ldw	r17,8(sp)
81120a8c:	dc000117 	ldw	r16,4(sp)
81120a90:	dec00a04 	addi	sp,sp,40
81120a94:	f800283a 	ret
81120a98:	643fdf0e 	bge	r12,r16,81120a18 <__reset+0xfb100a18>
81120a9c:	023fffc4 	movi	r8,-1
81120aa0:	003fe006 	br	81120a24 <__reset+0xfb100a24>
81120aa4:	00c00dc4 	movi	r3,55
81120aa8:	003fe806 	br	81120a4c <__reset+0xfb100a4c>
81120aac:	00800884 	movi	r2,34
81120ab0:	a0800015 	stw	r2,0(r20)
81120ab4:	00bfffc4 	movi	r2,-1
81120ab8:	303fec26 	beq	r6,zero,81120a6c <__reset+0xfb100a6c>
81120abc:	24ffffc4 	addi	r19,r4,-1
81120ac0:	003fe906 	br	81120a68 <__reset+0xfb100a68>
81120ac4:	1c400084 	addi	r17,r3,2
81120ac8:	1c000043 	ldbu	r16,1(r3)
81120acc:	05c00044 	movi	r23,1
81120ad0:	003fac06 	br	81120984 <__reset+0xfb100984>
81120ad4:	1c400084 	addi	r17,r3,2
81120ad8:	1c000043 	ldbu	r16,1(r3)
81120adc:	002f883a 	mov	r23,zero
81120ae0:	003fa806 	br	81120984 <__reset+0xfb100984>
81120ae4:	88800003 	ldbu	r2,0(r17)
81120ae8:	00c01604 	movi	r3,88
81120aec:	108037cc 	andi	r2,r2,223
81120af0:	10c00c26 	beq	r2,r3,81120b24 <_strtoul_r+0x220>
81120af4:	05400204 	movi	r21,8
81120af8:	01c80034 	movhi	r7,8192
81120afc:	030001c4 	movi	r12,7
81120b00:	39ffffc4 	addi	r7,r7,-1
81120b04:	a817883a 	mov	r11,r21
81120b08:	003fb506 	br	811209e0 <__reset+0xfb1009e0>
81120b0c:	00800c04 	movi	r2,48
81120b10:	80800c1e 	bne	r16,r2,81120b44 <_strtoul_r+0x240>
81120b14:	88800003 	ldbu	r2,0(r17)
81120b18:	00c01604 	movi	r3,88
81120b1c:	108037cc 	andi	r2,r2,223
81120b20:	10c0081e 	bne	r2,r3,81120b44 <_strtoul_r+0x240>
81120b24:	02c00404 	movi	r11,16
81120b28:	05840034 	movhi	r22,4096
81120b2c:	8c000043 	ldbu	r16,1(r17)
81120b30:	030003c4 	movi	r12,15
81120b34:	8c400084 	addi	r17,r17,2
81120b38:	b5bfffc4 	addi	r22,r22,-1
81120b3c:	582b883a 	mov	r21,r11
81120b40:	003f9e06 	br	811209bc <__reset+0xfb1009bc>
81120b44:	01c40034 	movhi	r7,4096
81120b48:	030003c4 	movi	r12,15
81120b4c:	39ffffc4 	addi	r7,r7,-1
81120b50:	a817883a 	mov	r11,r21
81120b54:	003fa206 	br	811209e0 <__reset+0xfb1009e0>

81120b58 <strtoul>:
81120b58:	00a04534 	movhi	r2,33044
81120b5c:	1086aa04 	addi	r2,r2,6824
81120b60:	300f883a 	mov	r7,r6
81120b64:	280d883a 	mov	r6,r5
81120b68:	200b883a 	mov	r5,r4
81120b6c:	11000017 	ldw	r4,0(r2)
81120b70:	11209041 	jmpi	81120904 <_strtoul_r>

81120b74 <_strtoull_r>:
81120b74:	00a04534 	movhi	r2,33044
81120b78:	defff404 	addi	sp,sp,-48
81120b7c:	1086a804 	addi	r2,r2,6816
81120b80:	de00012e 	bgeu	sp,et,81120b88 <_strtoull_r+0x14>
81120b84:	003b68fa 	trap	3
81120b88:	dc400315 	stw	r17,12(sp)
81120b8c:	14400017 	ldw	r17,0(r2)
81120b90:	dd400715 	stw	r21,28(sp)
81120b94:	dd000615 	stw	r20,24(sp)
81120b98:	dcc00515 	stw	r19,20(sp)
81120b9c:	dc800415 	stw	r18,16(sp)
81120ba0:	dfc00b15 	stw	ra,44(sp)
81120ba4:	df000a15 	stw	fp,40(sp)
81120ba8:	ddc00915 	stw	r23,36(sp)
81120bac:	dd800815 	stw	r22,32(sp)
81120bb0:	dc000215 	stw	r16,8(sp)
81120bb4:	2827883a 	mov	r19,r5
81120bb8:	202b883a 	mov	r21,r4
81120bbc:	3029883a 	mov	r20,r6
81120bc0:	3825883a 	mov	r18,r7
81120bc4:	2807883a 	mov	r3,r5
81120bc8:	1c000003 	ldbu	r16,0(r3)
81120bcc:	1f000044 	addi	fp,r3,1
81120bd0:	1809883a 	mov	r4,r3
81120bd4:	8c05883a 	add	r2,r17,r16
81120bd8:	10800043 	ldbu	r2,1(r2)
81120bdc:	e007883a 	mov	r3,fp
81120be0:	1080020c 	andi	r2,r2,8
81120be4:	103ff81e 	bne	r2,zero,81120bc8 <__reset+0xfb100bc8>
81120be8:	00800b44 	movi	r2,45
81120bec:	80806e26 	beq	r16,r2,81120da8 <_strtoull_r+0x234>
81120bf0:	00800ac4 	movi	r2,43
81120bf4:	80807026 	beq	r16,r2,81120db8 <_strtoull_r+0x244>
81120bf8:	002f883a 	mov	r23,zero
81120bfc:	90001426 	beq	r18,zero,81120c50 <_strtoull_r+0xdc>
81120c00:	00800404 	movi	r2,16
81120c04:	90807c26 	beq	r18,r2,81120df8 <_strtoull_r+0x284>
81120c08:	902dd7fa 	srai	r22,r18,31
81120c0c:	013fffc4 	movi	r4,-1
81120c10:	200b883a 	mov	r5,r4
81120c14:	900d883a 	mov	r6,r18
81120c18:	b00f883a 	mov	r7,r22
81120c1c:	1124f980 	call	81124f98 <__udivdi3>
81120c20:	013fffc4 	movi	r4,-1
81120c24:	900d883a 	mov	r6,r18
81120c28:	b00f883a 	mov	r7,r22
81120c2c:	200b883a 	mov	r5,r4
81120c30:	d8c00115 	stw	r3,4(sp)
81120c34:	d8800015 	stw	r2,0(sp)
81120c38:	11255180 	call	81125518 <__umoddi3>
81120c3c:	101b883a 	mov	r13,r2
81120c40:	9015883a 	mov	r10,r18
81120c44:	dac00017 	ldw	r11,0(sp)
81120c48:	da000117 	ldw	r8,4(sp)
81120c4c:	00000a06 	br	81120c78 <_strtoull_r+0x104>
81120c50:	00800c04 	movi	r2,48
81120c54:	80805c26 	beq	r16,r2,81120dc8 <_strtoull_r+0x254>
81120c58:	02800284 	movi	r10,10
81120c5c:	02e666b4 	movhi	r11,39322
81120c60:	020666b4 	movhi	r8,6554
81120c64:	03400144 	movi	r13,5
81120c68:	5ae66644 	addi	r11,r11,-26215
81120c6c:	42266644 	addi	r8,r8,-26215
81120c70:	002d883a 	mov	r22,zero
81120c74:	5025883a 	mov	r18,r10
81120c78:	8c0b883a 	add	r5,r17,r16
81120c7c:	29400043 	ldbu	r5,1(r5)
81120c80:	e009883a 	mov	r4,fp
81120c84:	000f883a 	mov	r7,zero
81120c88:	2980010c 	andi	r6,r5,4
81120c8c:	0005883a 	mov	r2,zero
81120c90:	0007883a 	mov	r3,zero
81120c94:	03000044 	movi	r12,1
81120c98:	027fffc4 	movi	r9,-1
81120c9c:	30000d26 	beq	r6,zero,81120cd4 <_strtoull_r+0x160>
81120ca0:	843ff404 	addi	r16,r16,-48
81120ca4:	8480110e 	bge	r16,r18,81120cec <_strtoull_r+0x178>
81120ca8:	3a400426 	beq	r7,r9,81120cbc <_strtoull_r+0x148>
81120cac:	40c00236 	bltu	r8,r3,81120cb8 <_strtoull_r+0x144>
81120cb0:	1a00231e 	bne	r3,r8,81120d40 <_strtoull_r+0x1cc>
81120cb4:	5880222e 	bgeu	r11,r2,81120d40 <_strtoull_r+0x1cc>
81120cb8:	01ffffc4 	movi	r7,-1
81120cbc:	24000003 	ldbu	r16,0(r4)
81120cc0:	21000044 	addi	r4,r4,1
81120cc4:	8c0b883a 	add	r5,r17,r16
81120cc8:	29400043 	ldbu	r5,1(r5)
81120ccc:	2980010c 	andi	r6,r5,4
81120cd0:	303ff31e 	bne	r6,zero,81120ca0 <__reset+0xfb100ca0>
81120cd4:	294000cc 	andi	r5,r5,3
81120cd8:	28000426 	beq	r5,zero,81120cec <_strtoull_r+0x178>
81120cdc:	2b002626 	beq	r5,r12,81120d78 <_strtoull_r+0x204>
81120ce0:	014015c4 	movi	r5,87
81120ce4:	8161c83a 	sub	r16,r16,r5
81120ce8:	84bfef16 	blt	r16,r18,81120ca8 <__reset+0xfb100ca8>
81120cec:	38002716 	blt	r7,zero,81120d8c <_strtoull_r+0x218>
81120cf0:	b8000426 	beq	r23,zero,81120d04 <_strtoull_r+0x190>
81120cf4:	0085c83a 	sub	r2,zero,r2
81120cf8:	100ac03a 	cmpne	r5,r2,zero
81120cfc:	00e1c83a 	sub	r16,zero,r3
81120d00:	8147c83a 	sub	r3,r16,r5
81120d04:	a0000226 	beq	r20,zero,81120d10 <_strtoull_r+0x19c>
81120d08:	3800251e 	bne	r7,zero,81120da0 <_strtoull_r+0x22c>
81120d0c:	a4c00015 	stw	r19,0(r20)
81120d10:	dfc00b17 	ldw	ra,44(sp)
81120d14:	df000a17 	ldw	fp,40(sp)
81120d18:	ddc00917 	ldw	r23,36(sp)
81120d1c:	dd800817 	ldw	r22,32(sp)
81120d20:	dd400717 	ldw	r21,28(sp)
81120d24:	dd000617 	ldw	r20,24(sp)
81120d28:	dcc00517 	ldw	r19,20(sp)
81120d2c:	dc800417 	ldw	r18,16(sp)
81120d30:	dc400317 	ldw	r17,12(sp)
81120d34:	dc000217 	ldw	r16,8(sp)
81120d38:	dec00c04 	addi	sp,sp,48
81120d3c:	f800283a 	ret
81120d40:	12c00f26 	beq	r2,r11,81120d80 <_strtoull_r+0x20c>
81120d44:	b08d383a 	mul	r6,r22,r2
81120d48:	1a87383a 	mul	r3,r3,r10
81120d4c:	128a383a 	mulxuu	r5,r2,r10
81120d50:	1285383a 	mul	r2,r2,r10
81120d54:	800fd7fa 	srai	r7,r16,31
81120d58:	1987883a 	add	r3,r3,r6
81120d5c:	8085883a 	add	r2,r16,r2
81120d60:	1947883a 	add	r3,r3,r5
81120d64:	38c7883a 	add	r3,r7,r3
81120d68:	1421803a 	cmpltu	r16,r2,r16
81120d6c:	80c7883a 	add	r3,r16,r3
81120d70:	01c00044 	movi	r7,1
81120d74:	003fd106 	br	81120cbc <__reset+0xfb100cbc>
81120d78:	01400dc4 	movi	r5,55
81120d7c:	003fd906 	br	81120ce4 <__reset+0xfb100ce4>
81120d80:	1a3ff01e 	bne	r3,r8,81120d44 <__reset+0xfb100d44>
81120d84:	6c3fcc16 	blt	r13,r16,81120cb8 <__reset+0xfb100cb8>
81120d88:	003fee06 	br	81120d44 <__reset+0xfb100d44>
81120d8c:	00800884 	movi	r2,34
81120d90:	a8800015 	stw	r2,0(r21)
81120d94:	00bfffc4 	movi	r2,-1
81120d98:	1007883a 	mov	r3,r2
81120d9c:	a03fdc26 	beq	r20,zero,81120d10 <__reset+0xfb100d10>
81120da0:	24ffffc4 	addi	r19,r4,-1
81120da4:	003fd906 	br	81120d0c <__reset+0xfb100d0c>
81120da8:	27000084 	addi	fp,r4,2
81120dac:	24000043 	ldbu	r16,1(r4)
81120db0:	05c00044 	movi	r23,1
81120db4:	003f9106 	br	81120bfc <__reset+0xfb100bfc>
81120db8:	27000084 	addi	fp,r4,2
81120dbc:	24000043 	ldbu	r16,1(r4)
81120dc0:	002f883a 	mov	r23,zero
81120dc4:	003f8d06 	br	81120bfc <__reset+0xfb100bfc>
81120dc8:	e0800003 	ldbu	r2,0(fp)
81120dcc:	00c01604 	movi	r3,88
81120dd0:	108037cc 	andi	r2,r2,223
81120dd4:	10c00e26 	beq	r2,r3,81120e10 <_strtoull_r+0x29c>
81120dd8:	02800204 	movi	r10,8
81120ddc:	02ffffc4 	movi	r11,-1
81120de0:	02080034 	movhi	r8,8192
81120de4:	034001c4 	movi	r13,7
81120de8:	42d1883a 	add	r8,r8,r11
81120dec:	002d883a 	mov	r22,zero
81120df0:	5025883a 	mov	r18,r10
81120df4:	003fa006 	br	81120c78 <__reset+0xfb100c78>
81120df8:	00800c04 	movi	r2,48
81120dfc:	80800e1e 	bne	r16,r2,81120e38 <_strtoull_r+0x2c4>
81120e00:	e0800003 	ldbu	r2,0(fp)
81120e04:	00c01604 	movi	r3,88
81120e08:	108037cc 	andi	r2,r2,223
81120e0c:	10c00a1e 	bne	r2,r3,81120e38 <_strtoull_r+0x2c4>
81120e10:	02800404 	movi	r10,16
81120e14:	02ffffc4 	movi	r11,-1
81120e18:	02040034 	movhi	r8,4096
81120e1c:	e4000043 	ldbu	r16,1(fp)
81120e20:	034003c4 	movi	r13,15
81120e24:	e7000084 	addi	fp,fp,2
81120e28:	42d1883a 	add	r8,r8,r11
81120e2c:	002d883a 	mov	r22,zero
81120e30:	5025883a 	mov	r18,r10
81120e34:	003f9006 	br	81120c78 <__reset+0xfb100c78>
81120e38:	02ffffc4 	movi	r11,-1
81120e3c:	02040034 	movhi	r8,4096
81120e40:	034003c4 	movi	r13,15
81120e44:	42d1883a 	add	r8,r8,r11
81120e48:	9015883a 	mov	r10,r18
81120e4c:	002d883a 	mov	r22,zero
81120e50:	003f8906 	br	81120c78 <__reset+0xfb100c78>

81120e54 <__ssprint_r>:
81120e54:	defff604 	addi	sp,sp,-40
81120e58:	de00012e 	bgeu	sp,et,81120e60 <__ssprint_r+0xc>
81120e5c:	003b68fa 	trap	3
81120e60:	30800217 	ldw	r2,8(r6)
81120e64:	dc800215 	stw	r18,8(sp)
81120e68:	dfc00915 	stw	ra,36(sp)
81120e6c:	df000815 	stw	fp,32(sp)
81120e70:	ddc00715 	stw	r23,28(sp)
81120e74:	dd800615 	stw	r22,24(sp)
81120e78:	dd400515 	stw	r21,20(sp)
81120e7c:	dd000415 	stw	r20,16(sp)
81120e80:	dcc00315 	stw	r19,12(sp)
81120e84:	dc400115 	stw	r17,4(sp)
81120e88:	dc000015 	stw	r16,0(sp)
81120e8c:	3025883a 	mov	r18,r6
81120e90:	10005826 	beq	r2,zero,81120ff4 <__ssprint_r+0x1a0>
81120e94:	2027883a 	mov	r19,r4
81120e98:	35c00017 	ldw	r23,0(r6)
81120e9c:	29000017 	ldw	r4,0(r5)
81120ea0:	28800217 	ldw	r2,8(r5)
81120ea4:	2823883a 	mov	r17,r5
81120ea8:	0039883a 	mov	fp,zero
81120eac:	0021883a 	mov	r16,zero
81120eb0:	80003926 	beq	r16,zero,81120f98 <__ssprint_r+0x144>
81120eb4:	102b883a 	mov	r21,r2
81120eb8:	102d883a 	mov	r22,r2
81120ebc:	80803a36 	bltu	r16,r2,81120fa8 <__ssprint_r+0x154>
81120ec0:	88c0030b 	ldhu	r3,12(r17)
81120ec4:	1881200c 	andi	r2,r3,1152
81120ec8:	10002626 	beq	r2,zero,81120f64 <__ssprint_r+0x110>
81120ecc:	88800517 	ldw	r2,20(r17)
81120ed0:	89400417 	ldw	r5,16(r17)
81120ed4:	81800044 	addi	r6,r16,1
81120ed8:	108f883a 	add	r7,r2,r2
81120edc:	3885883a 	add	r2,r7,r2
81120ee0:	100ed7fa 	srli	r7,r2,31
81120ee4:	216dc83a 	sub	r22,r4,r5
81120ee8:	3589883a 	add	r4,r6,r22
81120eec:	3885883a 	add	r2,r7,r2
81120ef0:	102bd07a 	srai	r21,r2,1
81120ef4:	a80d883a 	mov	r6,r21
81120ef8:	a900022e 	bgeu	r21,r4,81120f04 <__ssprint_r+0xb0>
81120efc:	202b883a 	mov	r21,r4
81120f00:	200d883a 	mov	r6,r4
81120f04:	18c1000c 	andi	r3,r3,1024
81120f08:	18002a26 	beq	r3,zero,81120fb4 <__ssprint_r+0x160>
81120f0c:	300b883a 	mov	r5,r6
81120f10:	9809883a 	mov	r4,r19
81120f14:	1112ecc0 	call	81112ecc <_malloc_r>
81120f18:	1029883a 	mov	r20,r2
81120f1c:	10002c26 	beq	r2,zero,81120fd0 <__ssprint_r+0x17c>
81120f20:	89400417 	ldw	r5,16(r17)
81120f24:	b00d883a 	mov	r6,r22
81120f28:	1009883a 	mov	r4,r2
81120f2c:	11136e00 	call	811136e0 <memcpy>
81120f30:	8880030b 	ldhu	r2,12(r17)
81120f34:	00fedfc4 	movi	r3,-1153
81120f38:	10c4703a 	and	r2,r2,r3
81120f3c:	10802014 	ori	r2,r2,128
81120f40:	8880030d 	sth	r2,12(r17)
81120f44:	a589883a 	add	r4,r20,r22
81120f48:	adadc83a 	sub	r22,r21,r22
81120f4c:	8d400515 	stw	r21,20(r17)
81120f50:	8d800215 	stw	r22,8(r17)
81120f54:	8d000415 	stw	r20,16(r17)
81120f58:	89000015 	stw	r4,0(r17)
81120f5c:	802b883a 	mov	r21,r16
81120f60:	802d883a 	mov	r22,r16
81120f64:	b00d883a 	mov	r6,r22
81120f68:	e00b883a 	mov	r5,fp
81120f6c:	111d4dc0 	call	8111d4dc <memmove>
81120f70:	88800217 	ldw	r2,8(r17)
81120f74:	89000017 	ldw	r4,0(r17)
81120f78:	90c00217 	ldw	r3,8(r18)
81120f7c:	1545c83a 	sub	r2,r2,r21
81120f80:	2589883a 	add	r4,r4,r22
81120f84:	88800215 	stw	r2,8(r17)
81120f88:	89000015 	stw	r4,0(r17)
81120f8c:	1c21c83a 	sub	r16,r3,r16
81120f90:	94000215 	stw	r16,8(r18)
81120f94:	80001726 	beq	r16,zero,81120ff4 <__ssprint_r+0x1a0>
81120f98:	bf000017 	ldw	fp,0(r23)
81120f9c:	bc000117 	ldw	r16,4(r23)
81120fa0:	bdc00204 	addi	r23,r23,8
81120fa4:	003fc206 	br	81120eb0 <__reset+0xfb100eb0>
81120fa8:	802b883a 	mov	r21,r16
81120fac:	802d883a 	mov	r22,r16
81120fb0:	003fec06 	br	81120f64 <__reset+0xfb100f64>
81120fb4:	9809883a 	mov	r4,r19
81120fb8:	111e6fc0 	call	8111e6fc <_realloc_r>
81120fbc:	1029883a 	mov	r20,r2
81120fc0:	103fe01e 	bne	r2,zero,81120f44 <__reset+0xfb100f44>
81120fc4:	89400417 	ldw	r5,16(r17)
81120fc8:	9809883a 	mov	r4,r19
81120fcc:	111c6680 	call	8111c668 <_free_r>
81120fd0:	88c0030b 	ldhu	r3,12(r17)
81120fd4:	00800304 	movi	r2,12
81120fd8:	98800015 	stw	r2,0(r19)
81120fdc:	18c01014 	ori	r3,r3,64
81120fe0:	88c0030d 	sth	r3,12(r17)
81120fe4:	00bfffc4 	movi	r2,-1
81120fe8:	90000215 	stw	zero,8(r18)
81120fec:	90000115 	stw	zero,4(r18)
81120ff0:	00000206 	br	81120ffc <__ssprint_r+0x1a8>
81120ff4:	90000115 	stw	zero,4(r18)
81120ff8:	0005883a 	mov	r2,zero
81120ffc:	dfc00917 	ldw	ra,36(sp)
81121000:	df000817 	ldw	fp,32(sp)
81121004:	ddc00717 	ldw	r23,28(sp)
81121008:	dd800617 	ldw	r22,24(sp)
8112100c:	dd400517 	ldw	r21,20(sp)
81121010:	dd000417 	ldw	r20,16(sp)
81121014:	dcc00317 	ldw	r19,12(sp)
81121018:	dc800217 	ldw	r18,8(sp)
8112101c:	dc400117 	ldw	r17,4(sp)
81121020:	dc000017 	ldw	r16,0(sp)
81121024:	dec00a04 	addi	sp,sp,40
81121028:	f800283a 	ret

8112102c <___svfiprintf_internal_r>:
8112102c:	deffc804 	addi	sp,sp,-224
81121030:	de00012e 	bgeu	sp,et,81121038 <___svfiprintf_internal_r+0xc>
81121034:	003b68fa 	trap	3
81121038:	2880030b 	ldhu	r2,12(r5)
8112103c:	dcc03115 	stw	r19,196(sp)
81121040:	dfc03715 	stw	ra,220(sp)
81121044:	df003615 	stw	fp,216(sp)
81121048:	ddc03515 	stw	r23,212(sp)
8112104c:	dd803415 	stw	r22,208(sp)
81121050:	dd403315 	stw	r21,204(sp)
81121054:	dd003215 	stw	r20,200(sp)
81121058:	dc803015 	stw	r18,192(sp)
8112105c:	dc402f15 	stw	r17,188(sp)
81121060:	dc002e15 	stw	r16,184(sp)
81121064:	d9402715 	stw	r5,156(sp)
81121068:	d9002a15 	stw	r4,168(sp)
8112106c:	1080200c 	andi	r2,r2,128
81121070:	d9c02315 	stw	r7,140(sp)
81121074:	3027883a 	mov	r19,r6
81121078:	10000226 	beq	r2,zero,81121084 <___svfiprintf_internal_r+0x58>
8112107c:	28800417 	ldw	r2,16(r5)
81121080:	10041d26 	beq	r2,zero,811220f8 <___svfiprintf_internal_r+0x10cc>
81121084:	dac01a04 	addi	r11,sp,104
81121088:	dac01e15 	stw	r11,120(sp)
8112108c:	d8801e17 	ldw	r2,120(sp)
81121090:	dac019c4 	addi	r11,sp,103
81121094:	dd402a17 	ldw	r21,168(sp)
81121098:	ddc02717 	ldw	r23,156(sp)
8112109c:	05a04534 	movhi	r22,33044
811210a0:	05204534 	movhi	r20,33044
811210a4:	dac01f15 	stw	r11,124(sp)
811210a8:	12d7c83a 	sub	r11,r2,r11
811210ac:	b5be3704 	addi	r22,r22,-1828
811210b0:	a53e3304 	addi	r20,r20,-1844
811210b4:	dec01a15 	stw	sp,104(sp)
811210b8:	d8001c15 	stw	zero,112(sp)
811210bc:	d8001b15 	stw	zero,108(sp)
811210c0:	d811883a 	mov	r8,sp
811210c4:	d8002915 	stw	zero,164(sp)
811210c8:	d8002515 	stw	zero,148(sp)
811210cc:	dac02b15 	stw	r11,172(sp)
811210d0:	98800007 	ldb	r2,0(r19)
811210d4:	1002dd26 	beq	r2,zero,81121c4c <___svfiprintf_internal_r+0xc20>
811210d8:	00c00944 	movi	r3,37
811210dc:	9823883a 	mov	r17,r19
811210e0:	10c0021e 	bne	r2,r3,811210ec <___svfiprintf_internal_r+0xc0>
811210e4:	00001406 	br	81121138 <___svfiprintf_internal_r+0x10c>
811210e8:	10c00326 	beq	r2,r3,811210f8 <___svfiprintf_internal_r+0xcc>
811210ec:	8c400044 	addi	r17,r17,1
811210f0:	88800007 	ldb	r2,0(r17)
811210f4:	103ffc1e 	bne	r2,zero,811210e8 <__reset+0xfb1010e8>
811210f8:	8ce1c83a 	sub	r16,r17,r19
811210fc:	80000e26 	beq	r16,zero,81121138 <___svfiprintf_internal_r+0x10c>
81121100:	d8c01c17 	ldw	r3,112(sp)
81121104:	d8801b17 	ldw	r2,108(sp)
81121108:	44c00015 	stw	r19,0(r8)
8112110c:	1c07883a 	add	r3,r3,r16
81121110:	10800044 	addi	r2,r2,1
81121114:	d8c01c15 	stw	r3,112(sp)
81121118:	44000115 	stw	r16,4(r8)
8112111c:	d8801b15 	stw	r2,108(sp)
81121120:	00c001c4 	movi	r3,7
81121124:	18831e16 	blt	r3,r2,81121da0 <___svfiprintf_internal_r+0xd74>
81121128:	42000204 	addi	r8,r8,8
8112112c:	dac02517 	ldw	r11,148(sp)
81121130:	5c17883a 	add	r11,r11,r16
81121134:	dac02515 	stw	r11,148(sp)
81121138:	88800007 	ldb	r2,0(r17)
8112113c:	1002c526 	beq	r2,zero,81121c54 <___svfiprintf_internal_r+0xc28>
81121140:	88c00047 	ldb	r3,1(r17)
81121144:	8cc00044 	addi	r19,r17,1
81121148:	d8001d85 	stb	zero,118(sp)
8112114c:	0009883a 	mov	r4,zero
81121150:	000f883a 	mov	r7,zero
81121154:	043fffc4 	movi	r16,-1
81121158:	d8002415 	stw	zero,144(sp)
8112115c:	0025883a 	mov	r18,zero
81121160:	01401604 	movi	r5,88
81121164:	01800244 	movi	r6,9
81121168:	02800a84 	movi	r10,42
8112116c:	02401b04 	movi	r9,108
81121170:	9cc00044 	addi	r19,r19,1
81121174:	18bff804 	addi	r2,r3,-32
81121178:	2881dd36 	bltu	r5,r2,811218f0 <___svfiprintf_internal_r+0x8c4>
8112117c:	100490ba 	slli	r2,r2,2
81121180:	02e044b4 	movhi	r11,33042
81121184:	5ac46504 	addi	r11,r11,4500
81121188:	12c5883a 	add	r2,r2,r11
8112118c:	10800017 	ldw	r2,0(r2)
81121190:	1000683a 	jmp	r2
81121194:	81121390 	cmplti	r4,r16,18510
81121198:	811218f0 	cmpltui	r4,r16,18531
8112119c:	811218f0 	cmpltui	r4,r16,18531
811211a0:	81121384 	addi	r4,r16,18510
811211a4:	811218f0 	cmpltui	r4,r16,18531
811211a8:	811218f0 	cmpltui	r4,r16,18531
811211ac:	811218f0 	cmpltui	r4,r16,18531
811211b0:	811218f0 	cmpltui	r4,r16,18531
811211b4:	811218f0 	cmpltui	r4,r16,18531
811211b8:	811218f0 	cmpltui	r4,r16,18531
811211bc:	811212f8 	rdprs	r4,r16,18507
811211c0:	811214d4 	ori	r4,r16,18515
811211c4:	811218f0 	cmpltui	r4,r16,18531
811211c8:	81121324 	muli	r4,r16,18508
811211cc:	81121924 	muli	r4,r16,18532
811211d0:	811218f0 	cmpltui	r4,r16,18531
811211d4:	81121918 	cmpnei	r4,r16,18532
811211d8:	811218b8 	rdprs	r4,r16,18530
811211dc:	811218b8 	rdprs	r4,r16,18530
811211e0:	811218b8 	rdprs	r4,r16,18530
811211e4:	811218b8 	rdprs	r4,r16,18530
811211e8:	811218b8 	rdprs	r4,r16,18530
811211ec:	811218b8 	rdprs	r4,r16,18530
811211f0:	811218b8 	rdprs	r4,r16,18530
811211f4:	811218b8 	rdprs	r4,r16,18530
811211f8:	811218b8 	rdprs	r4,r16,18530
811211fc:	811218f0 	cmpltui	r4,r16,18531
81121200:	811218f0 	cmpltui	r4,r16,18531
81121204:	811218f0 	cmpltui	r4,r16,18531
81121208:	811218f0 	cmpltui	r4,r16,18531
8112120c:	811218f0 	cmpltui	r4,r16,18531
81121210:	811218f0 	cmpltui	r4,r16,18531
81121214:	811218f0 	cmpltui	r4,r16,18531
81121218:	811218f0 	cmpltui	r4,r16,18531
8112121c:	811218f0 	cmpltui	r4,r16,18531
81121220:	811218f0 	cmpltui	r4,r16,18531
81121224:	81121854 	ori	r4,r16,18529
81121228:	811218f0 	cmpltui	r4,r16,18531
8112122c:	811218f0 	cmpltui	r4,r16,18531
81121230:	811218f0 	cmpltui	r4,r16,18531
81121234:	811218f0 	cmpltui	r4,r16,18531
81121238:	811218f0 	cmpltui	r4,r16,18531
8112123c:	811218f0 	cmpltui	r4,r16,18531
81121240:	811218f0 	cmpltui	r4,r16,18531
81121244:	811218f0 	cmpltui	r4,r16,18531
81121248:	811218f0 	cmpltui	r4,r16,18531
8112124c:	811218f0 	cmpltui	r4,r16,18531
81121250:	811219cc 	andi	r4,r16,18535
81121254:	811218f0 	cmpltui	r4,r16,18531
81121258:	811218f0 	cmpltui	r4,r16,18531
8112125c:	811218f0 	cmpltui	r4,r16,18531
81121260:	811218f0 	cmpltui	r4,r16,18531
81121264:	811218f0 	cmpltui	r4,r16,18531
81121268:	81121964 	muli	r4,r16,18533
8112126c:	811218f0 	cmpltui	r4,r16,18531
81121270:	811218f0 	cmpltui	r4,r16,18531
81121274:	81121698 	cmpnei	r4,r16,18522
81121278:	811218f0 	cmpltui	r4,r16,18531
8112127c:	811218f0 	cmpltui	r4,r16,18531
81121280:	811218f0 	cmpltui	r4,r16,18531
81121284:	811218f0 	cmpltui	r4,r16,18531
81121288:	811218f0 	cmpltui	r4,r16,18531
8112128c:	811218f0 	cmpltui	r4,r16,18531
81121290:	811218f0 	cmpltui	r4,r16,18531
81121294:	811218f0 	cmpltui	r4,r16,18531
81121298:	811218f0 	cmpltui	r4,r16,18531
8112129c:	811218f0 	cmpltui	r4,r16,18531
811212a0:	81121588 	cmpgei	r4,r16,18518
811212a4:	81121734 	orhi	r4,r16,18524
811212a8:	811218f0 	cmpltui	r4,r16,18531
811212ac:	811218f0 	cmpltui	r4,r16,18531
811212b0:	811218f0 	cmpltui	r4,r16,18531
811212b4:	81121728 	cmpgeui	r4,r16,18524
811212b8:	81121734 	orhi	r4,r16,18524
811212bc:	811218f0 	cmpltui	r4,r16,18531
811212c0:	811218f0 	cmpltui	r4,r16,18531
811212c4:	81121718 	cmpnei	r4,r16,18524
811212c8:	811218f0 	cmpltui	r4,r16,18531
811212cc:	811216dc 	xori	r4,r16,18523
811212d0:	811214e4 	muli	r4,r16,18515
811212d4:	81121330 	cmpltui	r4,r16,18508
811212d8:	81121848 	cmpgei	r4,r16,18529
811212dc:	811218f0 	cmpltui	r4,r16,18531
811212e0:	811217fc 	xorhi	r4,r16,18527
811212e4:	811218f0 	cmpltui	r4,r16,18531
811212e8:	81121454 	ori	r4,r16,18513
811212ec:	811218f0 	cmpltui	r4,r16,18531
811212f0:	811218f0 	cmpltui	r4,r16,18531
811212f4:	811213b0 	cmpltui	r4,r16,18510
811212f8:	dac02317 	ldw	r11,140(sp)
811212fc:	5ac00017 	ldw	r11,0(r11)
81121300:	dac02415 	stw	r11,144(sp)
81121304:	dac02317 	ldw	r11,140(sp)
81121308:	58800104 	addi	r2,r11,4
8112130c:	dac02417 	ldw	r11,144(sp)
81121310:	5802e90e 	bge	r11,zero,81121eb8 <___svfiprintf_internal_r+0xe8c>
81121314:	dac02417 	ldw	r11,144(sp)
81121318:	d8802315 	stw	r2,140(sp)
8112131c:	02d7c83a 	sub	r11,zero,r11
81121320:	dac02415 	stw	r11,144(sp)
81121324:	94800114 	ori	r18,r18,4
81121328:	98c00007 	ldb	r3,0(r19)
8112132c:	003f9006 	br	81121170 <__reset+0xfb101170>
81121330:	00800c04 	movi	r2,48
81121334:	dac02317 	ldw	r11,140(sp)
81121338:	d8801d05 	stb	r2,116(sp)
8112133c:	00801e04 	movi	r2,120
81121340:	d8801d45 	stb	r2,117(sp)
81121344:	d8001d85 	stb	zero,118(sp)
81121348:	58c00104 	addi	r3,r11,4
8112134c:	5f000017 	ldw	fp,0(r11)
81121350:	0013883a 	mov	r9,zero
81121354:	90800094 	ori	r2,r18,2
81121358:	80032b16 	blt	r16,zero,81122008 <___svfiprintf_internal_r+0xfdc>
8112135c:	00bfdfc4 	movi	r2,-129
81121360:	90a4703a 	and	r18,r18,r2
81121364:	d8c02315 	stw	r3,140(sp)
81121368:	94800094 	ori	r18,r18,2
8112136c:	e002dc26 	beq	fp,zero,81121ee0 <___svfiprintf_internal_r+0xeb4>
81121370:	01204534 	movhi	r4,33044
81121374:	213da904 	addi	r4,r4,-2396
81121378:	0015883a 	mov	r10,zero
8112137c:	d9002915 	stw	r4,164(sp)
81121380:	00002306 	br	81121410 <___svfiprintf_internal_r+0x3e4>
81121384:	94800054 	ori	r18,r18,1
81121388:	98c00007 	ldb	r3,0(r19)
8112138c:	003f7806 	br	81121170 <__reset+0xfb101170>
81121390:	38803fcc 	andi	r2,r7,255
81121394:	1080201c 	xori	r2,r2,128
81121398:	10bfe004 	addi	r2,r2,-128
8112139c:	1002f31e 	bne	r2,zero,81121f6c <___svfiprintf_internal_r+0xf40>
811213a0:	01000044 	movi	r4,1
811213a4:	01c00804 	movi	r7,32
811213a8:	98c00007 	ldb	r3,0(r19)
811213ac:	003f7006 	br	81121170 <__reset+0xfb101170>
811213b0:	21003fcc 	andi	r4,r4,255
811213b4:	2003aa1e 	bne	r4,zero,81122260 <___svfiprintf_internal_r+0x1234>
811213b8:	00a04534 	movhi	r2,33044
811213bc:	10bda904 	addi	r2,r2,-2396
811213c0:	d8802915 	stw	r2,164(sp)
811213c4:	9080080c 	andi	r2,r18,32
811213c8:	1000ba26 	beq	r2,zero,811216b4 <___svfiprintf_internal_r+0x688>
811213cc:	dac02317 	ldw	r11,140(sp)
811213d0:	5f000017 	ldw	fp,0(r11)
811213d4:	5a400117 	ldw	r9,4(r11)
811213d8:	5ac00204 	addi	r11,r11,8
811213dc:	dac02315 	stw	r11,140(sp)
811213e0:	9080004c 	andi	r2,r18,1
811213e4:	10029026 	beq	r2,zero,81121e28 <___svfiprintf_internal_r+0xdfc>
811213e8:	e244b03a 	or	r2,fp,r9
811213ec:	1002d41e 	bne	r2,zero,81121f40 <___svfiprintf_internal_r+0xf14>
811213f0:	d8001d85 	stb	zero,118(sp)
811213f4:	80030b16 	blt	r16,zero,81122024 <___svfiprintf_internal_r+0xff8>
811213f8:	00bfdfc4 	movi	r2,-129
811213fc:	90a4703a 	and	r18,r18,r2
81121400:	0015883a 	mov	r10,zero
81121404:	80002426 	beq	r16,zero,81121498 <___svfiprintf_internal_r+0x46c>
81121408:	0039883a 	mov	fp,zero
8112140c:	0013883a 	mov	r9,zero
81121410:	d9002917 	ldw	r4,164(sp)
81121414:	dc401a04 	addi	r17,sp,104
81121418:	e08003cc 	andi	r2,fp,15
8112141c:	4806973a 	slli	r3,r9,28
81121420:	2085883a 	add	r2,r4,r2
81121424:	e038d13a 	srli	fp,fp,4
81121428:	10800003 	ldbu	r2,0(r2)
8112142c:	4812d13a 	srli	r9,r9,4
81121430:	8c7fffc4 	addi	r17,r17,-1
81121434:	1f38b03a 	or	fp,r3,fp
81121438:	88800005 	stb	r2,0(r17)
8112143c:	e244b03a 	or	r2,fp,r9
81121440:	103ff51e 	bne	r2,zero,81121418 <__reset+0xfb101418>
81121444:	dac01e17 	ldw	r11,120(sp)
81121448:	5c57c83a 	sub	r11,r11,r17
8112144c:	dac02115 	stw	r11,132(sp)
81121450:	00001406 	br	811214a4 <___svfiprintf_internal_r+0x478>
81121454:	21003fcc 	andi	r4,r4,255
81121458:	2003741e 	bne	r4,zero,8112222c <___svfiprintf_internal_r+0x1200>
8112145c:	9080080c 	andi	r2,r18,32
81121460:	10014526 	beq	r2,zero,81121978 <___svfiprintf_internal_r+0x94c>
81121464:	dac02317 	ldw	r11,140(sp)
81121468:	d8001d85 	stb	zero,118(sp)
8112146c:	58c00204 	addi	r3,r11,8
81121470:	5f000017 	ldw	fp,0(r11)
81121474:	5a400117 	ldw	r9,4(r11)
81121478:	8002d916 	blt	r16,zero,81121fe0 <___svfiprintf_internal_r+0xfb4>
8112147c:	013fdfc4 	movi	r4,-129
81121480:	e244b03a 	or	r2,fp,r9
81121484:	d8c02315 	stw	r3,140(sp)
81121488:	9124703a 	and	r18,r18,r4
8112148c:	0015883a 	mov	r10,zero
81121490:	1000b91e 	bne	r2,zero,81121778 <___svfiprintf_internal_r+0x74c>
81121494:	8002e61e 	bne	r16,zero,81122030 <___svfiprintf_internal_r+0x1004>
81121498:	0021883a 	mov	r16,zero
8112149c:	d8002115 	stw	zero,132(sp)
811214a0:	dc401a04 	addi	r17,sp,104
811214a4:	d8c02117 	ldw	r3,132(sp)
811214a8:	dc002015 	stw	r16,128(sp)
811214ac:	80c0010e 	bge	r16,r3,811214b4 <___svfiprintf_internal_r+0x488>
811214b0:	d8c02015 	stw	r3,128(sp)
811214b4:	52803fcc 	andi	r10,r10,255
811214b8:	5280201c 	xori	r10,r10,128
811214bc:	52bfe004 	addi	r10,r10,-128
811214c0:	50003c26 	beq	r10,zero,811215b4 <___svfiprintf_internal_r+0x588>
811214c4:	dac02017 	ldw	r11,128(sp)
811214c8:	5ac00044 	addi	r11,r11,1
811214cc:	dac02015 	stw	r11,128(sp)
811214d0:	00003806 	br	811215b4 <___svfiprintf_internal_r+0x588>
811214d4:	01000044 	movi	r4,1
811214d8:	01c00ac4 	movi	r7,43
811214dc:	98c00007 	ldb	r3,0(r19)
811214e0:	003f2306 	br	81121170 <__reset+0xfb101170>
811214e4:	21003fcc 	andi	r4,r4,255
811214e8:	2003481e 	bne	r4,zero,8112220c <___svfiprintf_internal_r+0x11e0>
811214ec:	9080080c 	andi	r2,r18,32
811214f0:	10013b26 	beq	r2,zero,811219e0 <___svfiprintf_internal_r+0x9b4>
811214f4:	dac02317 	ldw	r11,140(sp)
811214f8:	d8001d85 	stb	zero,118(sp)
811214fc:	58800204 	addi	r2,r11,8
81121500:	5f000017 	ldw	fp,0(r11)
81121504:	5a400117 	ldw	r9,4(r11)
81121508:	8002a816 	blt	r16,zero,81121fac <___svfiprintf_internal_r+0xf80>
8112150c:	013fdfc4 	movi	r4,-129
81121510:	e246b03a 	or	r3,fp,r9
81121514:	d8802315 	stw	r2,140(sp)
81121518:	9124703a 	and	r18,r18,r4
8112151c:	18013c26 	beq	r3,zero,81121a10 <___svfiprintf_internal_r+0x9e4>
81121520:	0015883a 	mov	r10,zero
81121524:	dc401a04 	addi	r17,sp,104
81121528:	e006d0fa 	srli	r3,fp,3
8112152c:	4808977a 	slli	r4,r9,29
81121530:	4812d0fa 	srli	r9,r9,3
81121534:	e70001cc 	andi	fp,fp,7
81121538:	e0800c04 	addi	r2,fp,48
8112153c:	8c7fffc4 	addi	r17,r17,-1
81121540:	20f8b03a 	or	fp,r4,r3
81121544:	88800005 	stb	r2,0(r17)
81121548:	e246b03a 	or	r3,fp,r9
8112154c:	183ff61e 	bne	r3,zero,81121528 <__reset+0xfb101528>
81121550:	90c0004c 	andi	r3,r18,1
81121554:	1800a526 	beq	r3,zero,811217ec <___svfiprintf_internal_r+0x7c0>
81121558:	10803fcc 	andi	r2,r2,255
8112155c:	1080201c 	xori	r2,r2,128
81121560:	10bfe004 	addi	r2,r2,-128
81121564:	00c00c04 	movi	r3,48
81121568:	10ffb626 	beq	r2,r3,81121444 <__reset+0xfb101444>
8112156c:	88ffffc5 	stb	r3,-1(r17)
81121570:	d8c01e17 	ldw	r3,120(sp)
81121574:	88bfffc4 	addi	r2,r17,-1
81121578:	1023883a 	mov	r17,r2
8112157c:	1887c83a 	sub	r3,r3,r2
81121580:	d8c02115 	stw	r3,132(sp)
81121584:	003fc706 	br	811214a4 <__reset+0xfb1014a4>
81121588:	dac02317 	ldw	r11,140(sp)
8112158c:	00c00044 	movi	r3,1
81121590:	d8c02015 	stw	r3,128(sp)
81121594:	58800017 	ldw	r2,0(r11)
81121598:	5ac00104 	addi	r11,r11,4
8112159c:	d8001d85 	stb	zero,118(sp)
811215a0:	d8801005 	stb	r2,64(sp)
811215a4:	dac02315 	stw	r11,140(sp)
811215a8:	d8c02115 	stw	r3,132(sp)
811215ac:	dc401004 	addi	r17,sp,64
811215b0:	0021883a 	mov	r16,zero
811215b4:	90c0008c 	andi	r3,r18,2
811215b8:	d8c02215 	stw	r3,136(sp)
811215bc:	18000326 	beq	r3,zero,811215cc <___svfiprintf_internal_r+0x5a0>
811215c0:	dac02017 	ldw	r11,128(sp)
811215c4:	5ac00084 	addi	r11,r11,2
811215c8:	dac02015 	stw	r11,128(sp)
811215cc:	90c0210c 	andi	r3,r18,132
811215d0:	d8c02615 	stw	r3,152(sp)
811215d4:	1801131e 	bne	r3,zero,81121a24 <___svfiprintf_internal_r+0x9f8>
811215d8:	dac02417 	ldw	r11,144(sp)
811215dc:	d8c02017 	ldw	r3,128(sp)
811215e0:	58f9c83a 	sub	fp,r11,r3
811215e4:	07010f0e 	bge	zero,fp,81121a24 <___svfiprintf_internal_r+0x9f8>
811215e8:	02400404 	movi	r9,16
811215ec:	d8c01c17 	ldw	r3,112(sp)
811215f0:	d8801b17 	ldw	r2,108(sp)
811215f4:	4f02d60e 	bge	r9,fp,81122150 <___svfiprintf_internal_r+0x1124>
811215f8:	01604534 	movhi	r5,33044
811215fc:	297e3704 	addi	r5,r5,-1828
81121600:	d9402815 	stw	r5,160(sp)
81121604:	028001c4 	movi	r10,7
81121608:	00000306 	br	81121618 <___svfiprintf_internal_r+0x5ec>
8112160c:	e73ffc04 	addi	fp,fp,-16
81121610:	42000204 	addi	r8,r8,8
81121614:	4f00150e 	bge	r9,fp,8112166c <___svfiprintf_internal_r+0x640>
81121618:	18c00404 	addi	r3,r3,16
8112161c:	10800044 	addi	r2,r2,1
81121620:	45800015 	stw	r22,0(r8)
81121624:	42400115 	stw	r9,4(r8)
81121628:	d8c01c15 	stw	r3,112(sp)
8112162c:	d8801b15 	stw	r2,108(sp)
81121630:	50bff60e 	bge	r10,r2,8112160c <__reset+0xfb10160c>
81121634:	d9801a04 	addi	r6,sp,104
81121638:	b80b883a 	mov	r5,r23
8112163c:	a809883a 	mov	r4,r21
81121640:	da402c15 	stw	r9,176(sp)
81121644:	da802d15 	stw	r10,180(sp)
81121648:	1120e540 	call	81120e54 <__ssprint_r>
8112164c:	da402c17 	ldw	r9,176(sp)
81121650:	da802d17 	ldw	r10,180(sp)
81121654:	1001851e 	bne	r2,zero,81121c6c <___svfiprintf_internal_r+0xc40>
81121658:	e73ffc04 	addi	fp,fp,-16
8112165c:	d8c01c17 	ldw	r3,112(sp)
81121660:	d8801b17 	ldw	r2,108(sp)
81121664:	d811883a 	mov	r8,sp
81121668:	4f3feb16 	blt	r9,fp,81121618 <__reset+0xfb101618>
8112166c:	dac02817 	ldw	r11,160(sp)
81121670:	e0c7883a 	add	r3,fp,r3
81121674:	10800044 	addi	r2,r2,1
81121678:	42c00015 	stw	r11,0(r8)
8112167c:	47000115 	stw	fp,4(r8)
81121680:	d8c01c15 	stw	r3,112(sp)
81121684:	d8801b15 	stw	r2,108(sp)
81121688:	010001c4 	movi	r4,7
8112168c:	2081ee16 	blt	r4,r2,81121e48 <___svfiprintf_internal_r+0xe1c>
81121690:	42000204 	addi	r8,r8,8
81121694:	0000e506 	br	81121a2c <___svfiprintf_internal_r+0xa00>
81121698:	21003fcc 	andi	r4,r4,255
8112169c:	2002dd1e 	bne	r4,zero,81122214 <___svfiprintf_internal_r+0x11e8>
811216a0:	00a04534 	movhi	r2,33044
811216a4:	10bda404 	addi	r2,r2,-2416
811216a8:	d8802915 	stw	r2,164(sp)
811216ac:	9080080c 	andi	r2,r18,32
811216b0:	103f461e 	bne	r2,zero,811213cc <__reset+0xfb1013cc>
811216b4:	9080040c 	andi	r2,r18,16
811216b8:	10022e1e 	bne	r2,zero,81121f74 <___svfiprintf_internal_r+0xf48>
811216bc:	9080100c 	andi	r2,r18,64
811216c0:	dac02317 	ldw	r11,140(sp)
811216c4:	10027326 	beq	r2,zero,81122094 <___svfiprintf_internal_r+0x1068>
811216c8:	5f00000b 	ldhu	fp,0(r11)
811216cc:	5ac00104 	addi	r11,r11,4
811216d0:	0013883a 	mov	r9,zero
811216d4:	dac02315 	stw	r11,140(sp)
811216d8:	003f4106 	br	811213e0 <__reset+0xfb1013e0>
811216dc:	21003fcc 	andi	r4,r4,255
811216e0:	2002e11e 	bne	r4,zero,81122268 <___svfiprintf_internal_r+0x123c>
811216e4:	9080080c 	andi	r2,r18,32
811216e8:	1002011e 	bne	r2,zero,81121ef0 <___svfiprintf_internal_r+0xec4>
811216ec:	9080040c 	andi	r2,r18,16
811216f0:	10023e1e 	bne	r2,zero,81121fec <___svfiprintf_internal_r+0xfc0>
811216f4:	9480100c 	andi	r18,r18,64
811216f8:	90023c26 	beq	r18,zero,81121fec <___svfiprintf_internal_r+0xfc0>
811216fc:	dac02317 	ldw	r11,140(sp)
81121700:	58800017 	ldw	r2,0(r11)
81121704:	5ac00104 	addi	r11,r11,4
81121708:	dac02315 	stw	r11,140(sp)
8112170c:	dac02517 	ldw	r11,148(sp)
81121710:	12c0000d 	sth	r11,0(r2)
81121714:	003e6e06 	br	811210d0 <__reset+0xfb1010d0>
81121718:	98c00007 	ldb	r3,0(r19)
8112171c:	1a422926 	beq	r3,r9,81121fc4 <___svfiprintf_internal_r+0xf98>
81121720:	94800414 	ori	r18,r18,16
81121724:	003e9206 	br	81121170 <__reset+0xfb101170>
81121728:	94801014 	ori	r18,r18,64
8112172c:	98c00007 	ldb	r3,0(r19)
81121730:	003e8f06 	br	81121170 <__reset+0xfb101170>
81121734:	21003fcc 	andi	r4,r4,255
81121738:	2002c71e 	bne	r4,zero,81122258 <___svfiprintf_internal_r+0x122c>
8112173c:	9080080c 	andi	r2,r18,32
81121740:	10004926 	beq	r2,zero,81121868 <___svfiprintf_internal_r+0x83c>
81121744:	dac02317 	ldw	r11,140(sp)
81121748:	58800117 	ldw	r2,4(r11)
8112174c:	5f000017 	ldw	fp,0(r11)
81121750:	5ac00204 	addi	r11,r11,8
81121754:	dac02315 	stw	r11,140(sp)
81121758:	1013883a 	mov	r9,r2
8112175c:	10004b16 	blt	r2,zero,8112188c <___svfiprintf_internal_r+0x860>
81121760:	da801d83 	ldbu	r10,118(sp)
81121764:	8001cb16 	blt	r16,zero,81121e94 <___svfiprintf_internal_r+0xe68>
81121768:	00ffdfc4 	movi	r3,-129
8112176c:	e244b03a 	or	r2,fp,r9
81121770:	90e4703a 	and	r18,r18,r3
81121774:	103f4726 	beq	r2,zero,81121494 <__reset+0xfb101494>
81121778:	48008c26 	beq	r9,zero,811219ac <___svfiprintf_internal_r+0x980>
8112177c:	dc802015 	stw	r18,128(sp)
81121780:	dc002115 	stw	r16,132(sp)
81121784:	dc401a04 	addi	r17,sp,104
81121788:	e021883a 	mov	r16,fp
8112178c:	da002215 	stw	r8,136(sp)
81121790:	5039883a 	mov	fp,r10
81121794:	4825883a 	mov	r18,r9
81121798:	8009883a 	mov	r4,r16
8112179c:	900b883a 	mov	r5,r18
811217a0:	01800284 	movi	r6,10
811217a4:	000f883a 	mov	r7,zero
811217a8:	11255180 	call	81125518 <__umoddi3>
811217ac:	10800c04 	addi	r2,r2,48
811217b0:	8c7fffc4 	addi	r17,r17,-1
811217b4:	8009883a 	mov	r4,r16
811217b8:	900b883a 	mov	r5,r18
811217bc:	88800005 	stb	r2,0(r17)
811217c0:	01800284 	movi	r6,10
811217c4:	000f883a 	mov	r7,zero
811217c8:	1124f980 	call	81124f98 <__udivdi3>
811217cc:	1021883a 	mov	r16,r2
811217d0:	10c4b03a 	or	r2,r2,r3
811217d4:	1825883a 	mov	r18,r3
811217d8:	103fef1e 	bne	r2,zero,81121798 <__reset+0xfb101798>
811217dc:	dc802017 	ldw	r18,128(sp)
811217e0:	dc002117 	ldw	r16,132(sp)
811217e4:	da002217 	ldw	r8,136(sp)
811217e8:	e015883a 	mov	r10,fp
811217ec:	d8c01e17 	ldw	r3,120(sp)
811217f0:	1c47c83a 	sub	r3,r3,r17
811217f4:	d8c02115 	stw	r3,132(sp)
811217f8:	003f2a06 	br	811214a4 <__reset+0xfb1014a4>
811217fc:	dac02317 	ldw	r11,140(sp)
81121800:	d8001d85 	stb	zero,118(sp)
81121804:	5c400017 	ldw	r17,0(r11)
81121808:	5f000104 	addi	fp,r11,4
8112180c:	88022f26 	beq	r17,zero,811220cc <___svfiprintf_internal_r+0x10a0>
81121810:	80022516 	blt	r16,zero,811220a8 <___svfiprintf_internal_r+0x107c>
81121814:	800d883a 	mov	r6,r16
81121818:	000b883a 	mov	r5,zero
8112181c:	8809883a 	mov	r4,r17
81121820:	da002c15 	stw	r8,176(sp)
81121824:	111d3f80 	call	8111d3f8 <memchr>
81121828:	da002c17 	ldw	r8,176(sp)
8112182c:	10026426 	beq	r2,zero,811221c0 <___svfiprintf_internal_r+0x1194>
81121830:	1445c83a 	sub	r2,r2,r17
81121834:	d8802115 	stw	r2,132(sp)
81121838:	da801d83 	ldbu	r10,118(sp)
8112183c:	df002315 	stw	fp,140(sp)
81121840:	0021883a 	mov	r16,zero
81121844:	003f1706 	br	811214a4 <__reset+0xfb1014a4>
81121848:	94800814 	ori	r18,r18,32
8112184c:	98c00007 	ldb	r3,0(r19)
81121850:	003e4706 	br	81121170 <__reset+0xfb101170>
81121854:	21003fcc 	andi	r4,r4,255
81121858:	2002701e 	bne	r4,zero,8112221c <___svfiprintf_internal_r+0x11f0>
8112185c:	94800414 	ori	r18,r18,16
81121860:	9080080c 	andi	r2,r18,32
81121864:	103fb71e 	bne	r2,zero,81121744 <__reset+0xfb101744>
81121868:	9080040c 	andi	r2,r18,16
8112186c:	1001ab26 	beq	r2,zero,81121f1c <___svfiprintf_internal_r+0xef0>
81121870:	dac02317 	ldw	r11,140(sp)
81121874:	5f000017 	ldw	fp,0(r11)
81121878:	5ac00104 	addi	r11,r11,4
8112187c:	dac02315 	stw	r11,140(sp)
81121880:	e013d7fa 	srai	r9,fp,31
81121884:	4805883a 	mov	r2,r9
81121888:	103fb50e 	bge	r2,zero,81121760 <__reset+0xfb101760>
8112188c:	0739c83a 	sub	fp,zero,fp
81121890:	02800b44 	movi	r10,45
81121894:	e004c03a 	cmpne	r2,fp,zero
81121898:	0253c83a 	sub	r9,zero,r9
8112189c:	da801d85 	stb	r10,118(sp)
811218a0:	4893c83a 	sub	r9,r9,r2
811218a4:	80023016 	blt	r16,zero,81122168 <___svfiprintf_internal_r+0x113c>
811218a8:	00bfdfc4 	movi	r2,-129
811218ac:	90a4703a 	and	r18,r18,r2
811218b0:	483fb21e 	bne	r9,zero,8112177c <__reset+0xfb10177c>
811218b4:	00003d06 	br	811219ac <___svfiprintf_internal_r+0x980>
811218b8:	9817883a 	mov	r11,r19
811218bc:	d8002415 	stw	zero,144(sp)
811218c0:	18bff404 	addi	r2,r3,-48
811218c4:	0019883a 	mov	r12,zero
811218c8:	58c00007 	ldb	r3,0(r11)
811218cc:	630002a4 	muli	r12,r12,10
811218d0:	9cc00044 	addi	r19,r19,1
811218d4:	9817883a 	mov	r11,r19
811218d8:	1319883a 	add	r12,r2,r12
811218dc:	18bff404 	addi	r2,r3,-48
811218e0:	30bff92e 	bgeu	r6,r2,811218c8 <__reset+0xfb1018c8>
811218e4:	db002415 	stw	r12,144(sp)
811218e8:	18bff804 	addi	r2,r3,-32
811218ec:	28be232e 	bgeu	r5,r2,8112117c <__reset+0xfb10117c>
811218f0:	21003fcc 	andi	r4,r4,255
811218f4:	20024b1e 	bne	r4,zero,81122224 <___svfiprintf_internal_r+0x11f8>
811218f8:	1800d626 	beq	r3,zero,81121c54 <___svfiprintf_internal_r+0xc28>
811218fc:	02c00044 	movi	r11,1
81121900:	dac02015 	stw	r11,128(sp)
81121904:	d8c01005 	stb	r3,64(sp)
81121908:	d8001d85 	stb	zero,118(sp)
8112190c:	dac02115 	stw	r11,132(sp)
81121910:	dc401004 	addi	r17,sp,64
81121914:	003f2606 	br	811215b0 <__reset+0xfb1015b0>
81121918:	94802014 	ori	r18,r18,128
8112191c:	98c00007 	ldb	r3,0(r19)
81121920:	003e1306 	br	81121170 <__reset+0xfb101170>
81121924:	98c00007 	ldb	r3,0(r19)
81121928:	9ac00044 	addi	r11,r19,1
8112192c:	1a822b26 	beq	r3,r10,811221dc <___svfiprintf_internal_r+0x11b0>
81121930:	18bff404 	addi	r2,r3,-48
81121934:	0021883a 	mov	r16,zero
81121938:	30821e36 	bltu	r6,r2,811221b4 <___svfiprintf_internal_r+0x1188>
8112193c:	58c00007 	ldb	r3,0(r11)
81121940:	840002a4 	muli	r16,r16,10
81121944:	5cc00044 	addi	r19,r11,1
81121948:	9817883a 	mov	r11,r19
8112194c:	80a1883a 	add	r16,r16,r2
81121950:	18bff404 	addi	r2,r3,-48
81121954:	30bff92e 	bgeu	r6,r2,8112193c <__reset+0xfb10193c>
81121958:	803e060e 	bge	r16,zero,81121174 <__reset+0xfb101174>
8112195c:	043fffc4 	movi	r16,-1
81121960:	003e0406 	br	81121174 <__reset+0xfb101174>
81121964:	21003fcc 	andi	r4,r4,255
81121968:	2002371e 	bne	r4,zero,81122248 <___svfiprintf_internal_r+0x121c>
8112196c:	94800414 	ori	r18,r18,16
81121970:	9080080c 	andi	r2,r18,32
81121974:	103ebb1e 	bne	r2,zero,81121464 <__reset+0xfb101464>
81121978:	9080040c 	andi	r2,r18,16
8112197c:	10013b26 	beq	r2,zero,81121e6c <___svfiprintf_internal_r+0xe40>
81121980:	dac02317 	ldw	r11,140(sp)
81121984:	d8001d85 	stb	zero,118(sp)
81121988:	0013883a 	mov	r9,zero
8112198c:	58800104 	addi	r2,r11,4
81121990:	5f000017 	ldw	fp,0(r11)
81121994:	80013d16 	blt	r16,zero,81121e8c <___svfiprintf_internal_r+0xe60>
81121998:	00ffdfc4 	movi	r3,-129
8112199c:	d8802315 	stw	r2,140(sp)
811219a0:	90e4703a 	and	r18,r18,r3
811219a4:	0015883a 	mov	r10,zero
811219a8:	e03eba26 	beq	fp,zero,81121494 <__reset+0xfb101494>
811219ac:	00800244 	movi	r2,9
811219b0:	173f7236 	bltu	r2,fp,8112177c <__reset+0xfb10177c>
811219b4:	dac02b17 	ldw	r11,172(sp)
811219b8:	e7000c04 	addi	fp,fp,48
811219bc:	df0019c5 	stb	fp,103(sp)
811219c0:	dac02115 	stw	r11,132(sp)
811219c4:	dc4019c4 	addi	r17,sp,103
811219c8:	003eb606 	br	811214a4 <__reset+0xfb1014a4>
811219cc:	21003fcc 	andi	r4,r4,255
811219d0:	20021f1e 	bne	r4,zero,81122250 <___svfiprintf_internal_r+0x1224>
811219d4:	94800414 	ori	r18,r18,16
811219d8:	9080080c 	andi	r2,r18,32
811219dc:	103ec51e 	bne	r2,zero,811214f4 <__reset+0xfb1014f4>
811219e0:	9080040c 	andi	r2,r18,16
811219e4:	10016926 	beq	r2,zero,81121f8c <___svfiprintf_internal_r+0xf60>
811219e8:	dac02317 	ldw	r11,140(sp)
811219ec:	d8001d85 	stb	zero,118(sp)
811219f0:	0013883a 	mov	r9,zero
811219f4:	58800104 	addi	r2,r11,4
811219f8:	5f000017 	ldw	fp,0(r11)
811219fc:	80016b16 	blt	r16,zero,81121fac <___svfiprintf_internal_r+0xf80>
81121a00:	00ffdfc4 	movi	r3,-129
81121a04:	d8802315 	stw	r2,140(sp)
81121a08:	90e4703a 	and	r18,r18,r3
81121a0c:	e03ec41e 	bne	fp,zero,81121520 <__reset+0xfb101520>
81121a10:	0015883a 	mov	r10,zero
81121a14:	8001c226 	beq	r16,zero,81122120 <___svfiprintf_internal_r+0x10f4>
81121a18:	0039883a 	mov	fp,zero
81121a1c:	0013883a 	mov	r9,zero
81121a20:	003ec006 	br	81121524 <__reset+0xfb101524>
81121a24:	d8c01c17 	ldw	r3,112(sp)
81121a28:	d8801b17 	ldw	r2,108(sp)
81121a2c:	d9001d87 	ldb	r4,118(sp)
81121a30:	20000b26 	beq	r4,zero,81121a60 <___svfiprintf_internal_r+0xa34>
81121a34:	d9001d84 	addi	r4,sp,118
81121a38:	18c00044 	addi	r3,r3,1
81121a3c:	10800044 	addi	r2,r2,1
81121a40:	41000015 	stw	r4,0(r8)
81121a44:	01000044 	movi	r4,1
81121a48:	41000115 	stw	r4,4(r8)
81121a4c:	d8c01c15 	stw	r3,112(sp)
81121a50:	d8801b15 	stw	r2,108(sp)
81121a54:	010001c4 	movi	r4,7
81121a58:	2080e116 	blt	r4,r2,81121de0 <___svfiprintf_internal_r+0xdb4>
81121a5c:	42000204 	addi	r8,r8,8
81121a60:	dac02217 	ldw	r11,136(sp)
81121a64:	58000b26 	beq	r11,zero,81121a94 <___svfiprintf_internal_r+0xa68>
81121a68:	d9001d04 	addi	r4,sp,116
81121a6c:	18c00084 	addi	r3,r3,2
81121a70:	10800044 	addi	r2,r2,1
81121a74:	41000015 	stw	r4,0(r8)
81121a78:	01000084 	movi	r4,2
81121a7c:	41000115 	stw	r4,4(r8)
81121a80:	d8c01c15 	stw	r3,112(sp)
81121a84:	d8801b15 	stw	r2,108(sp)
81121a88:	010001c4 	movi	r4,7
81121a8c:	2080dd16 	blt	r4,r2,81121e04 <___svfiprintf_internal_r+0xdd8>
81121a90:	42000204 	addi	r8,r8,8
81121a94:	dac02617 	ldw	r11,152(sp)
81121a98:	01002004 	movi	r4,128
81121a9c:	59008426 	beq	r11,r4,81121cb0 <___svfiprintf_internal_r+0xc84>
81121aa0:	dac02117 	ldw	r11,132(sp)
81121aa4:	82e1c83a 	sub	r16,r16,r11
81121aa8:	0400270e 	bge	zero,r16,81121b48 <___svfiprintf_internal_r+0xb1c>
81121aac:	01c00404 	movi	r7,16
81121ab0:	3c016a0e 	bge	r7,r16,8112205c <___svfiprintf_internal_r+0x1030>
81121ab4:	01604534 	movhi	r5,33044
81121ab8:	297e3304 	addi	r5,r5,-1844
81121abc:	d9402215 	stw	r5,136(sp)
81121ac0:	070001c4 	movi	fp,7
81121ac4:	00000306 	br	81121ad4 <___svfiprintf_internal_r+0xaa8>
81121ac8:	843ffc04 	addi	r16,r16,-16
81121acc:	42000204 	addi	r8,r8,8
81121ad0:	3c00130e 	bge	r7,r16,81121b20 <___svfiprintf_internal_r+0xaf4>
81121ad4:	18c00404 	addi	r3,r3,16
81121ad8:	10800044 	addi	r2,r2,1
81121adc:	45000015 	stw	r20,0(r8)
81121ae0:	41c00115 	stw	r7,4(r8)
81121ae4:	d8c01c15 	stw	r3,112(sp)
81121ae8:	d8801b15 	stw	r2,108(sp)
81121aec:	e0bff60e 	bge	fp,r2,81121ac8 <__reset+0xfb101ac8>
81121af0:	d9801a04 	addi	r6,sp,104
81121af4:	b80b883a 	mov	r5,r23
81121af8:	a809883a 	mov	r4,r21
81121afc:	d9c02c15 	stw	r7,176(sp)
81121b00:	1120e540 	call	81120e54 <__ssprint_r>
81121b04:	d9c02c17 	ldw	r7,176(sp)
81121b08:	1000581e 	bne	r2,zero,81121c6c <___svfiprintf_internal_r+0xc40>
81121b0c:	843ffc04 	addi	r16,r16,-16
81121b10:	d8c01c17 	ldw	r3,112(sp)
81121b14:	d8801b17 	ldw	r2,108(sp)
81121b18:	d811883a 	mov	r8,sp
81121b1c:	3c3fed16 	blt	r7,r16,81121ad4 <__reset+0xfb101ad4>
81121b20:	dac02217 	ldw	r11,136(sp)
81121b24:	1c07883a 	add	r3,r3,r16
81121b28:	10800044 	addi	r2,r2,1
81121b2c:	42c00015 	stw	r11,0(r8)
81121b30:	44000115 	stw	r16,4(r8)
81121b34:	d8c01c15 	stw	r3,112(sp)
81121b38:	d8801b15 	stw	r2,108(sp)
81121b3c:	010001c4 	movi	r4,7
81121b40:	20809e16 	blt	r4,r2,81121dbc <___svfiprintf_internal_r+0xd90>
81121b44:	42000204 	addi	r8,r8,8
81121b48:	dac02117 	ldw	r11,132(sp)
81121b4c:	10800044 	addi	r2,r2,1
81121b50:	44400015 	stw	r17,0(r8)
81121b54:	58c7883a 	add	r3,r11,r3
81121b58:	42c00115 	stw	r11,4(r8)
81121b5c:	d8c01c15 	stw	r3,112(sp)
81121b60:	d8801b15 	stw	r2,108(sp)
81121b64:	010001c4 	movi	r4,7
81121b68:	20807f16 	blt	r4,r2,81121d68 <___svfiprintf_internal_r+0xd3c>
81121b6c:	42000204 	addi	r8,r8,8
81121b70:	9480010c 	andi	r18,r18,4
81121b74:	90002926 	beq	r18,zero,81121c1c <___svfiprintf_internal_r+0xbf0>
81121b78:	dac02417 	ldw	r11,144(sp)
81121b7c:	d8802017 	ldw	r2,128(sp)
81121b80:	58a1c83a 	sub	r16,r11,r2
81121b84:	0400250e 	bge	zero,r16,81121c1c <___svfiprintf_internal_r+0xbf0>
81121b88:	04400404 	movi	r17,16
81121b8c:	d8801b17 	ldw	r2,108(sp)
81121b90:	8c017c0e 	bge	r17,r16,81122184 <___svfiprintf_internal_r+0x1158>
81121b94:	01604534 	movhi	r5,33044
81121b98:	297e3704 	addi	r5,r5,-1828
81121b9c:	d9402815 	stw	r5,160(sp)
81121ba0:	048001c4 	movi	r18,7
81121ba4:	00000306 	br	81121bb4 <___svfiprintf_internal_r+0xb88>
81121ba8:	843ffc04 	addi	r16,r16,-16
81121bac:	42000204 	addi	r8,r8,8
81121bb0:	8c00110e 	bge	r17,r16,81121bf8 <___svfiprintf_internal_r+0xbcc>
81121bb4:	18c00404 	addi	r3,r3,16
81121bb8:	10800044 	addi	r2,r2,1
81121bbc:	45800015 	stw	r22,0(r8)
81121bc0:	44400115 	stw	r17,4(r8)
81121bc4:	d8c01c15 	stw	r3,112(sp)
81121bc8:	d8801b15 	stw	r2,108(sp)
81121bcc:	90bff60e 	bge	r18,r2,81121ba8 <__reset+0xfb101ba8>
81121bd0:	d9801a04 	addi	r6,sp,104
81121bd4:	b80b883a 	mov	r5,r23
81121bd8:	a809883a 	mov	r4,r21
81121bdc:	1120e540 	call	81120e54 <__ssprint_r>
81121be0:	1000221e 	bne	r2,zero,81121c6c <___svfiprintf_internal_r+0xc40>
81121be4:	843ffc04 	addi	r16,r16,-16
81121be8:	d8c01c17 	ldw	r3,112(sp)
81121bec:	d8801b17 	ldw	r2,108(sp)
81121bf0:	d811883a 	mov	r8,sp
81121bf4:	8c3fef16 	blt	r17,r16,81121bb4 <__reset+0xfb101bb4>
81121bf8:	dac02817 	ldw	r11,160(sp)
81121bfc:	1c07883a 	add	r3,r3,r16
81121c00:	10800044 	addi	r2,r2,1
81121c04:	42c00015 	stw	r11,0(r8)
81121c08:	44000115 	stw	r16,4(r8)
81121c0c:	d8c01c15 	stw	r3,112(sp)
81121c10:	d8801b15 	stw	r2,108(sp)
81121c14:	010001c4 	movi	r4,7
81121c18:	2080aa16 	blt	r4,r2,81121ec4 <___svfiprintf_internal_r+0xe98>
81121c1c:	d8802417 	ldw	r2,144(sp)
81121c20:	dac02017 	ldw	r11,128(sp)
81121c24:	12c0010e 	bge	r2,r11,81121c2c <___svfiprintf_internal_r+0xc00>
81121c28:	5805883a 	mov	r2,r11
81121c2c:	dac02517 	ldw	r11,148(sp)
81121c30:	5897883a 	add	r11,r11,r2
81121c34:	dac02515 	stw	r11,148(sp)
81121c38:	1800531e 	bne	r3,zero,81121d88 <___svfiprintf_internal_r+0xd5c>
81121c3c:	98800007 	ldb	r2,0(r19)
81121c40:	d8001b15 	stw	zero,108(sp)
81121c44:	d811883a 	mov	r8,sp
81121c48:	103d231e 	bne	r2,zero,811210d8 <__reset+0xfb1010d8>
81121c4c:	9823883a 	mov	r17,r19
81121c50:	003d3906 	br	81121138 <__reset+0xfb101138>
81121c54:	d8801c17 	ldw	r2,112(sp)
81121c58:	10000426 	beq	r2,zero,81121c6c <___svfiprintf_internal_r+0xc40>
81121c5c:	d9402717 	ldw	r5,156(sp)
81121c60:	d9002a17 	ldw	r4,168(sp)
81121c64:	d9801a04 	addi	r6,sp,104
81121c68:	1120e540 	call	81120e54 <__ssprint_r>
81121c6c:	dac02717 	ldw	r11,156(sp)
81121c70:	d8802517 	ldw	r2,148(sp)
81121c74:	58c0030b 	ldhu	r3,12(r11)
81121c78:	18c0100c 	andi	r3,r3,64
81121c7c:	1801381e 	bne	r3,zero,81122160 <___svfiprintf_internal_r+0x1134>
81121c80:	dfc03717 	ldw	ra,220(sp)
81121c84:	df003617 	ldw	fp,216(sp)
81121c88:	ddc03517 	ldw	r23,212(sp)
81121c8c:	dd803417 	ldw	r22,208(sp)
81121c90:	dd403317 	ldw	r21,204(sp)
81121c94:	dd003217 	ldw	r20,200(sp)
81121c98:	dcc03117 	ldw	r19,196(sp)
81121c9c:	dc803017 	ldw	r18,192(sp)
81121ca0:	dc402f17 	ldw	r17,188(sp)
81121ca4:	dc002e17 	ldw	r16,184(sp)
81121ca8:	dec03804 	addi	sp,sp,224
81121cac:	f800283a 	ret
81121cb0:	dac02417 	ldw	r11,144(sp)
81121cb4:	d9002017 	ldw	r4,128(sp)
81121cb8:	5939c83a 	sub	fp,r11,r4
81121cbc:	073f780e 	bge	zero,fp,81121aa0 <__reset+0xfb101aa0>
81121cc0:	02400404 	movi	r9,16
81121cc4:	4f01370e 	bge	r9,fp,811221a4 <___svfiprintf_internal_r+0x1178>
81121cc8:	02e04534 	movhi	r11,33044
81121ccc:	5afe3304 	addi	r11,r11,-1844
81121cd0:	dac02215 	stw	r11,136(sp)
81121cd4:	028001c4 	movi	r10,7
81121cd8:	00000306 	br	81121ce8 <___svfiprintf_internal_r+0xcbc>
81121cdc:	e73ffc04 	addi	fp,fp,-16
81121ce0:	42000204 	addi	r8,r8,8
81121ce4:	4f00150e 	bge	r9,fp,81121d3c <___svfiprintf_internal_r+0xd10>
81121ce8:	18c00404 	addi	r3,r3,16
81121cec:	10800044 	addi	r2,r2,1
81121cf0:	45000015 	stw	r20,0(r8)
81121cf4:	42400115 	stw	r9,4(r8)
81121cf8:	d8c01c15 	stw	r3,112(sp)
81121cfc:	d8801b15 	stw	r2,108(sp)
81121d00:	50bff60e 	bge	r10,r2,81121cdc <__reset+0xfb101cdc>
81121d04:	d9801a04 	addi	r6,sp,104
81121d08:	b80b883a 	mov	r5,r23
81121d0c:	a809883a 	mov	r4,r21
81121d10:	da402c15 	stw	r9,176(sp)
81121d14:	da802d15 	stw	r10,180(sp)
81121d18:	1120e540 	call	81120e54 <__ssprint_r>
81121d1c:	da402c17 	ldw	r9,176(sp)
81121d20:	da802d17 	ldw	r10,180(sp)
81121d24:	103fd11e 	bne	r2,zero,81121c6c <__reset+0xfb101c6c>
81121d28:	e73ffc04 	addi	fp,fp,-16
81121d2c:	d8c01c17 	ldw	r3,112(sp)
81121d30:	d8801b17 	ldw	r2,108(sp)
81121d34:	d811883a 	mov	r8,sp
81121d38:	4f3feb16 	blt	r9,fp,81121ce8 <__reset+0xfb101ce8>
81121d3c:	dac02217 	ldw	r11,136(sp)
81121d40:	1f07883a 	add	r3,r3,fp
81121d44:	10800044 	addi	r2,r2,1
81121d48:	42c00015 	stw	r11,0(r8)
81121d4c:	47000115 	stw	fp,4(r8)
81121d50:	d8c01c15 	stw	r3,112(sp)
81121d54:	d8801b15 	stw	r2,108(sp)
81121d58:	010001c4 	movi	r4,7
81121d5c:	2080b616 	blt	r4,r2,81122038 <___svfiprintf_internal_r+0x100c>
81121d60:	42000204 	addi	r8,r8,8
81121d64:	003f4e06 	br	81121aa0 <__reset+0xfb101aa0>
81121d68:	d9801a04 	addi	r6,sp,104
81121d6c:	b80b883a 	mov	r5,r23
81121d70:	a809883a 	mov	r4,r21
81121d74:	1120e540 	call	81120e54 <__ssprint_r>
81121d78:	103fbc1e 	bne	r2,zero,81121c6c <__reset+0xfb101c6c>
81121d7c:	d8c01c17 	ldw	r3,112(sp)
81121d80:	d811883a 	mov	r8,sp
81121d84:	003f7a06 	br	81121b70 <__reset+0xfb101b70>
81121d88:	d9801a04 	addi	r6,sp,104
81121d8c:	b80b883a 	mov	r5,r23
81121d90:	a809883a 	mov	r4,r21
81121d94:	1120e540 	call	81120e54 <__ssprint_r>
81121d98:	103fa826 	beq	r2,zero,81121c3c <__reset+0xfb101c3c>
81121d9c:	003fb306 	br	81121c6c <__reset+0xfb101c6c>
81121da0:	d9801a04 	addi	r6,sp,104
81121da4:	b80b883a 	mov	r5,r23
81121da8:	a809883a 	mov	r4,r21
81121dac:	1120e540 	call	81120e54 <__ssprint_r>
81121db0:	103fae1e 	bne	r2,zero,81121c6c <__reset+0xfb101c6c>
81121db4:	d811883a 	mov	r8,sp
81121db8:	003cdc06 	br	8112112c <__reset+0xfb10112c>
81121dbc:	d9801a04 	addi	r6,sp,104
81121dc0:	b80b883a 	mov	r5,r23
81121dc4:	a809883a 	mov	r4,r21
81121dc8:	1120e540 	call	81120e54 <__ssprint_r>
81121dcc:	103fa71e 	bne	r2,zero,81121c6c <__reset+0xfb101c6c>
81121dd0:	d8c01c17 	ldw	r3,112(sp)
81121dd4:	d8801b17 	ldw	r2,108(sp)
81121dd8:	d811883a 	mov	r8,sp
81121ddc:	003f5a06 	br	81121b48 <__reset+0xfb101b48>
81121de0:	d9801a04 	addi	r6,sp,104
81121de4:	b80b883a 	mov	r5,r23
81121de8:	a809883a 	mov	r4,r21
81121dec:	1120e540 	call	81120e54 <__ssprint_r>
81121df0:	103f9e1e 	bne	r2,zero,81121c6c <__reset+0xfb101c6c>
81121df4:	d8c01c17 	ldw	r3,112(sp)
81121df8:	d8801b17 	ldw	r2,108(sp)
81121dfc:	d811883a 	mov	r8,sp
81121e00:	003f1706 	br	81121a60 <__reset+0xfb101a60>
81121e04:	d9801a04 	addi	r6,sp,104
81121e08:	b80b883a 	mov	r5,r23
81121e0c:	a809883a 	mov	r4,r21
81121e10:	1120e540 	call	81120e54 <__ssprint_r>
81121e14:	103f951e 	bne	r2,zero,81121c6c <__reset+0xfb101c6c>
81121e18:	d8c01c17 	ldw	r3,112(sp)
81121e1c:	d8801b17 	ldw	r2,108(sp)
81121e20:	d811883a 	mov	r8,sp
81121e24:	003f1b06 	br	81121a94 <__reset+0xfb101a94>
81121e28:	d8001d85 	stb	zero,118(sp)
81121e2c:	80007b16 	blt	r16,zero,8112201c <___svfiprintf_internal_r+0xff0>
81121e30:	00ffdfc4 	movi	r3,-129
81121e34:	e244b03a 	or	r2,fp,r9
81121e38:	90e4703a 	and	r18,r18,r3
81121e3c:	103d7026 	beq	r2,zero,81121400 <__reset+0xfb101400>
81121e40:	0015883a 	mov	r10,zero
81121e44:	003d7206 	br	81121410 <__reset+0xfb101410>
81121e48:	d9801a04 	addi	r6,sp,104
81121e4c:	b80b883a 	mov	r5,r23
81121e50:	a809883a 	mov	r4,r21
81121e54:	1120e540 	call	81120e54 <__ssprint_r>
81121e58:	103f841e 	bne	r2,zero,81121c6c <__reset+0xfb101c6c>
81121e5c:	d8c01c17 	ldw	r3,112(sp)
81121e60:	d8801b17 	ldw	r2,108(sp)
81121e64:	d811883a 	mov	r8,sp
81121e68:	003ef006 	br	81121a2c <__reset+0xfb101a2c>
81121e6c:	9080100c 	andi	r2,r18,64
81121e70:	d8001d85 	stb	zero,118(sp)
81121e74:	dac02317 	ldw	r11,140(sp)
81121e78:	10008126 	beq	r2,zero,81122080 <___svfiprintf_internal_r+0x1054>
81121e7c:	58800104 	addi	r2,r11,4
81121e80:	5f00000b 	ldhu	fp,0(r11)
81121e84:	0013883a 	mov	r9,zero
81121e88:	803ec30e 	bge	r16,zero,81121998 <__reset+0xfb101998>
81121e8c:	d8802315 	stw	r2,140(sp)
81121e90:	0015883a 	mov	r10,zero
81121e94:	e244b03a 	or	r2,fp,r9
81121e98:	103e371e 	bne	r2,zero,81121778 <__reset+0xfb101778>
81121e9c:	00800044 	movi	r2,1
81121ea0:	10803fcc 	andi	r2,r2,255
81121ea4:	00c00044 	movi	r3,1
81121ea8:	10c06126 	beq	r2,r3,81122030 <___svfiprintf_internal_r+0x1004>
81121eac:	00c00084 	movi	r3,2
81121eb0:	10fd5526 	beq	r2,r3,81121408 <__reset+0xfb101408>
81121eb4:	003ed806 	br	81121a18 <__reset+0xfb101a18>
81121eb8:	d8802315 	stw	r2,140(sp)
81121ebc:	98c00007 	ldb	r3,0(r19)
81121ec0:	003cab06 	br	81121170 <__reset+0xfb101170>
81121ec4:	d9801a04 	addi	r6,sp,104
81121ec8:	b80b883a 	mov	r5,r23
81121ecc:	a809883a 	mov	r4,r21
81121ed0:	1120e540 	call	81120e54 <__ssprint_r>
81121ed4:	103f651e 	bne	r2,zero,81121c6c <__reset+0xfb101c6c>
81121ed8:	d8c01c17 	ldw	r3,112(sp)
81121edc:	003f4f06 	br	81121c1c <__reset+0xfb101c1c>
81121ee0:	00a04534 	movhi	r2,33044
81121ee4:	10bda904 	addi	r2,r2,-2396
81121ee8:	d8802915 	stw	r2,164(sp)
81121eec:	003d4406 	br	81121400 <__reset+0xfb101400>
81121ef0:	dac02317 	ldw	r11,140(sp)
81121ef4:	58800017 	ldw	r2,0(r11)
81121ef8:	dac02517 	ldw	r11,148(sp)
81121efc:	5807d7fa 	srai	r3,r11,31
81121f00:	dac02317 	ldw	r11,140(sp)
81121f04:	10c00115 	stw	r3,4(r2)
81121f08:	5ac00104 	addi	r11,r11,4
81121f0c:	dac02315 	stw	r11,140(sp)
81121f10:	dac02517 	ldw	r11,148(sp)
81121f14:	12c00015 	stw	r11,0(r2)
81121f18:	003c6d06 	br	811210d0 <__reset+0xfb1010d0>
81121f1c:	9080100c 	andi	r2,r18,64
81121f20:	dac02317 	ldw	r11,140(sp)
81121f24:	103e5326 	beq	r2,zero,81121874 <__reset+0xfb101874>
81121f28:	5f00000f 	ldh	fp,0(r11)
81121f2c:	5ac00104 	addi	r11,r11,4
81121f30:	dac02315 	stw	r11,140(sp)
81121f34:	e013d7fa 	srai	r9,fp,31
81121f38:	4805883a 	mov	r2,r9
81121f3c:	003e0706 	br	8112175c <__reset+0xfb10175c>
81121f40:	00800c04 	movi	r2,48
81121f44:	d8801d05 	stb	r2,116(sp)
81121f48:	d8c01d45 	stb	r3,117(sp)
81121f4c:	d8001d85 	stb	zero,118(sp)
81121f50:	90800094 	ori	r2,r18,2
81121f54:	80008f16 	blt	r16,zero,81122194 <___svfiprintf_internal_r+0x1168>
81121f58:	00bfdfc4 	movi	r2,-129
81121f5c:	90a4703a 	and	r18,r18,r2
81121f60:	94800094 	ori	r18,r18,2
81121f64:	0015883a 	mov	r10,zero
81121f68:	003d2906 	br	81121410 <__reset+0xfb101410>
81121f6c:	98c00007 	ldb	r3,0(r19)
81121f70:	003c7f06 	br	81121170 <__reset+0xfb101170>
81121f74:	dac02317 	ldw	r11,140(sp)
81121f78:	0013883a 	mov	r9,zero
81121f7c:	5f000017 	ldw	fp,0(r11)
81121f80:	5ac00104 	addi	r11,r11,4
81121f84:	dac02315 	stw	r11,140(sp)
81121f88:	003d1506 	br	811213e0 <__reset+0xfb1013e0>
81121f8c:	9080100c 	andi	r2,r18,64
81121f90:	d8001d85 	stb	zero,118(sp)
81121f94:	dac02317 	ldw	r11,140(sp)
81121f98:	10003426 	beq	r2,zero,8112206c <___svfiprintf_internal_r+0x1040>
81121f9c:	58800104 	addi	r2,r11,4
81121fa0:	5f00000b 	ldhu	fp,0(r11)
81121fa4:	0013883a 	mov	r9,zero
81121fa8:	803e950e 	bge	r16,zero,81121a00 <__reset+0xfb101a00>
81121fac:	e246b03a 	or	r3,fp,r9
81121fb0:	d8802315 	stw	r2,140(sp)
81121fb4:	183d5a1e 	bne	r3,zero,81121520 <__reset+0xfb101520>
81121fb8:	0015883a 	mov	r10,zero
81121fbc:	0005883a 	mov	r2,zero
81121fc0:	003fb706 	br	81121ea0 <__reset+0xfb101ea0>
81121fc4:	98c00043 	ldbu	r3,1(r19)
81121fc8:	94800814 	ori	r18,r18,32
81121fcc:	9cc00044 	addi	r19,r19,1
81121fd0:	18c03fcc 	andi	r3,r3,255
81121fd4:	18c0201c 	xori	r3,r3,128
81121fd8:	18ffe004 	addi	r3,r3,-128
81121fdc:	003c6406 	br	81121170 <__reset+0xfb101170>
81121fe0:	d8c02315 	stw	r3,140(sp)
81121fe4:	0015883a 	mov	r10,zero
81121fe8:	003faa06 	br	81121e94 <__reset+0xfb101e94>
81121fec:	dac02317 	ldw	r11,140(sp)
81121ff0:	58800017 	ldw	r2,0(r11)
81121ff4:	5ac00104 	addi	r11,r11,4
81121ff8:	dac02315 	stw	r11,140(sp)
81121ffc:	dac02517 	ldw	r11,148(sp)
81122000:	12c00015 	stw	r11,0(r2)
81122004:	003c3206 	br	811210d0 <__reset+0xfb1010d0>
81122008:	01204534 	movhi	r4,33044
8112200c:	213da904 	addi	r4,r4,-2396
81122010:	d9002915 	stw	r4,164(sp)
81122014:	d8c02315 	stw	r3,140(sp)
81122018:	1025883a 	mov	r18,r2
8112201c:	e244b03a 	or	r2,fp,r9
81122020:	103f871e 	bne	r2,zero,81121e40 <__reset+0xfb101e40>
81122024:	0015883a 	mov	r10,zero
81122028:	00800084 	movi	r2,2
8112202c:	003f9c06 	br	81121ea0 <__reset+0xfb101ea0>
81122030:	0039883a 	mov	fp,zero
81122034:	003e5f06 	br	811219b4 <__reset+0xfb1019b4>
81122038:	d9801a04 	addi	r6,sp,104
8112203c:	b80b883a 	mov	r5,r23
81122040:	a809883a 	mov	r4,r21
81122044:	1120e540 	call	81120e54 <__ssprint_r>
81122048:	103f081e 	bne	r2,zero,81121c6c <__reset+0xfb101c6c>
8112204c:	d8c01c17 	ldw	r3,112(sp)
81122050:	d8801b17 	ldw	r2,108(sp)
81122054:	d811883a 	mov	r8,sp
81122058:	003e9106 	br	81121aa0 <__reset+0xfb101aa0>
8112205c:	01204534 	movhi	r4,33044
81122060:	213e3304 	addi	r4,r4,-1844
81122064:	d9002215 	stw	r4,136(sp)
81122068:	003ead06 	br	81121b20 <__reset+0xfb101b20>
8112206c:	58800104 	addi	r2,r11,4
81122070:	5f000017 	ldw	fp,0(r11)
81122074:	0013883a 	mov	r9,zero
81122078:	803e610e 	bge	r16,zero,81121a00 <__reset+0xfb101a00>
8112207c:	003fcb06 	br	81121fac <__reset+0xfb101fac>
81122080:	58800104 	addi	r2,r11,4
81122084:	5f000017 	ldw	fp,0(r11)
81122088:	0013883a 	mov	r9,zero
8112208c:	803e420e 	bge	r16,zero,81121998 <__reset+0xfb101998>
81122090:	003f7e06 	br	81121e8c <__reset+0xfb101e8c>
81122094:	5f000017 	ldw	fp,0(r11)
81122098:	5ac00104 	addi	r11,r11,4
8112209c:	0013883a 	mov	r9,zero
811220a0:	dac02315 	stw	r11,140(sp)
811220a4:	003cce06 	br	811213e0 <__reset+0xfb1013e0>
811220a8:	8809883a 	mov	r4,r17
811220ac:	da002c15 	stw	r8,176(sp)
811220b0:	111405c0 	call	8111405c <strlen>
811220b4:	d8802115 	stw	r2,132(sp)
811220b8:	da801d83 	ldbu	r10,118(sp)
811220bc:	df002315 	stw	fp,140(sp)
811220c0:	0021883a 	mov	r16,zero
811220c4:	da002c17 	ldw	r8,176(sp)
811220c8:	003cf606 	br	811214a4 <__reset+0xfb1014a4>
811220cc:	00800184 	movi	r2,6
811220d0:	1400012e 	bgeu	r2,r16,811220d8 <___svfiprintf_internal_r+0x10ac>
811220d4:	1021883a 	mov	r16,r2
811220d8:	dc002115 	stw	r16,132(sp)
811220dc:	8005883a 	mov	r2,r16
811220e0:	80003c16 	blt	r16,zero,811221d4 <___svfiprintf_internal_r+0x11a8>
811220e4:	04604534 	movhi	r17,33044
811220e8:	d8802015 	stw	r2,128(sp)
811220ec:	df002315 	stw	fp,140(sp)
811220f0:	8c7dae04 	addi	r17,r17,-2376
811220f4:	003d2e06 	br	811215b0 <__reset+0xfb1015b0>
811220f8:	04001004 	movi	r16,64
811220fc:	800b883a 	mov	r5,r16
81122100:	1112ecc0 	call	81112ecc <_malloc_r>
81122104:	dac02717 	ldw	r11,156(sp)
81122108:	58800015 	stw	r2,0(r11)
8112210c:	58800415 	stw	r2,16(r11)
81122110:	10004826 	beq	r2,zero,81122234 <___svfiprintf_internal_r+0x1208>
81122114:	dac02717 	ldw	r11,156(sp)
81122118:	5c000515 	stw	r16,20(r11)
8112211c:	003bd906 	br	81121084 <__reset+0xfb101084>
81122120:	9080004c 	andi	r2,r18,1
81122124:	0015883a 	mov	r10,zero
81122128:	10000626 	beq	r2,zero,81122144 <___svfiprintf_internal_r+0x1118>
8112212c:	dac02b17 	ldw	r11,172(sp)
81122130:	00800c04 	movi	r2,48
81122134:	d88019c5 	stb	r2,103(sp)
81122138:	dac02115 	stw	r11,132(sp)
8112213c:	dc4019c4 	addi	r17,sp,103
81122140:	003cd806 	br	811214a4 <__reset+0xfb1014a4>
81122144:	d8002115 	stw	zero,132(sp)
81122148:	dc401a04 	addi	r17,sp,104
8112214c:	003cd506 	br	811214a4 <__reset+0xfb1014a4>
81122150:	01204534 	movhi	r4,33044
81122154:	213e3704 	addi	r4,r4,-1828
81122158:	d9002815 	stw	r4,160(sp)
8112215c:	003d4306 	br	8112166c <__reset+0xfb10166c>
81122160:	00bfffc4 	movi	r2,-1
81122164:	003ec606 	br	81121c80 <__reset+0xfb101c80>
81122168:	00800044 	movi	r2,1
8112216c:	10803fcc 	andi	r2,r2,255
81122170:	00c00044 	movi	r3,1
81122174:	10fd8026 	beq	r2,r3,81121778 <__reset+0xfb101778>
81122178:	00c00084 	movi	r3,2
8112217c:	10fca426 	beq	r2,r3,81121410 <__reset+0xfb101410>
81122180:	003ce806 	br	81121524 <__reset+0xfb101524>
81122184:	01204534 	movhi	r4,33044
81122188:	213e3704 	addi	r4,r4,-1828
8112218c:	d9002815 	stw	r4,160(sp)
81122190:	003e9906 	br	81121bf8 <__reset+0xfb101bf8>
81122194:	1025883a 	mov	r18,r2
81122198:	0015883a 	mov	r10,zero
8112219c:	00800084 	movi	r2,2
811221a0:	003ff206 	br	8112216c <__reset+0xfb10216c>
811221a4:	01604534 	movhi	r5,33044
811221a8:	297e3304 	addi	r5,r5,-1844
811221ac:	d9402215 	stw	r5,136(sp)
811221b0:	003ee206 	br	81121d3c <__reset+0xfb101d3c>
811221b4:	5827883a 	mov	r19,r11
811221b8:	0021883a 	mov	r16,zero
811221bc:	003bed06 	br	81121174 <__reset+0xfb101174>
811221c0:	dc002115 	stw	r16,132(sp)
811221c4:	da801d83 	ldbu	r10,118(sp)
811221c8:	df002315 	stw	fp,140(sp)
811221cc:	0021883a 	mov	r16,zero
811221d0:	003cb406 	br	811214a4 <__reset+0xfb1014a4>
811221d4:	0005883a 	mov	r2,zero
811221d8:	003fc206 	br	811220e4 <__reset+0xfb1020e4>
811221dc:	d8802317 	ldw	r2,140(sp)
811221e0:	98c00043 	ldbu	r3,1(r19)
811221e4:	5827883a 	mov	r19,r11
811221e8:	14000017 	ldw	r16,0(r2)
811221ec:	10800104 	addi	r2,r2,4
811221f0:	d8802315 	stw	r2,140(sp)
811221f4:	803f760e 	bge	r16,zero,81121fd0 <__reset+0xfb101fd0>
811221f8:	18c03fcc 	andi	r3,r3,255
811221fc:	18c0201c 	xori	r3,r3,128
81122200:	043fffc4 	movi	r16,-1
81122204:	18ffe004 	addi	r3,r3,-128
81122208:	003bd906 	br	81121170 <__reset+0xfb101170>
8112220c:	d9c01d85 	stb	r7,118(sp)
81122210:	003cb606 	br	811214ec <__reset+0xfb1014ec>
81122214:	d9c01d85 	stb	r7,118(sp)
81122218:	003d2106 	br	811216a0 <__reset+0xfb1016a0>
8112221c:	d9c01d85 	stb	r7,118(sp)
81122220:	003d8e06 	br	8112185c <__reset+0xfb10185c>
81122224:	d9c01d85 	stb	r7,118(sp)
81122228:	003db306 	br	811218f8 <__reset+0xfb1018f8>
8112222c:	d9c01d85 	stb	r7,118(sp)
81122230:	003c8a06 	br	8112145c <__reset+0xfb10145c>
81122234:	dac02a17 	ldw	r11,168(sp)
81122238:	00800304 	movi	r2,12
8112223c:	58800015 	stw	r2,0(r11)
81122240:	00bfffc4 	movi	r2,-1
81122244:	003e8e06 	br	81121c80 <__reset+0xfb101c80>
81122248:	d9c01d85 	stb	r7,118(sp)
8112224c:	003dc706 	br	8112196c <__reset+0xfb10196c>
81122250:	d9c01d85 	stb	r7,118(sp)
81122254:	003ddf06 	br	811219d4 <__reset+0xfb1019d4>
81122258:	d9c01d85 	stb	r7,118(sp)
8112225c:	003d3706 	br	8112173c <__reset+0xfb10173c>
81122260:	d9c01d85 	stb	r7,118(sp)
81122264:	003c5406 	br	811213b8 <__reset+0xfb1013b8>
81122268:	d9c01d85 	stb	r7,118(sp)
8112226c:	003d1d06 	br	811216e4 <__reset+0xfb1016e4>

81122270 <__submore>:
81122270:	defffa04 	addi	sp,sp,-24
81122274:	de00012e 	bgeu	sp,et,8112227c <__submore+0xc>
81122278:	003b68fa 	trap	3
8112227c:	dc000015 	stw	r16,0(sp)
81122280:	2821883a 	mov	r16,r5
81122284:	29400c17 	ldw	r5,48(r5)
81122288:	dfc00515 	stw	ra,20(sp)
8112228c:	dd000415 	stw	r20,16(sp)
81122290:	dcc00315 	stw	r19,12(sp)
81122294:	dc800215 	stw	r18,8(sp)
81122298:	dc400115 	stw	r17,4(sp)
8112229c:	80801004 	addi	r2,r16,64
811222a0:	28801726 	beq	r5,r2,81122300 <__submore+0x90>
811222a4:	84400d17 	ldw	r17,52(r16)
811222a8:	8c67883a 	add	r19,r17,r17
811222ac:	980d883a 	mov	r6,r19
811222b0:	111e6fc0 	call	8111e6fc <_realloc_r>
811222b4:	1025883a 	mov	r18,r2
811222b8:	10002226 	beq	r2,zero,81122344 <__submore+0xd4>
811222bc:	1469883a 	add	r20,r2,r17
811222c0:	880d883a 	mov	r6,r17
811222c4:	100b883a 	mov	r5,r2
811222c8:	a009883a 	mov	r4,r20
811222cc:	11136e00 	call	811136e0 <memcpy>
811222d0:	0005883a 	mov	r2,zero
811222d4:	85000015 	stw	r20,0(r16)
811222d8:	84800c15 	stw	r18,48(r16)
811222dc:	84c00d15 	stw	r19,52(r16)
811222e0:	dfc00517 	ldw	ra,20(sp)
811222e4:	dd000417 	ldw	r20,16(sp)
811222e8:	dcc00317 	ldw	r19,12(sp)
811222ec:	dc800217 	ldw	r18,8(sp)
811222f0:	dc400117 	ldw	r17,4(sp)
811222f4:	dc000017 	ldw	r16,0(sp)
811222f8:	dec00604 	addi	sp,sp,24
811222fc:	f800283a 	ret
81122300:	04410004 	movi	r17,1024
81122304:	880b883a 	mov	r5,r17
81122308:	1112ecc0 	call	81112ecc <_malloc_r>
8112230c:	1007883a 	mov	r3,r2
81122310:	10000c26 	beq	r2,zero,81122344 <__submore+0xd4>
81122314:	80801083 	ldbu	r2,66(r16)
81122318:	80c00c15 	stw	r3,48(r16)
8112231c:	84400d15 	stw	r17,52(r16)
81122320:	1880ffc5 	stb	r2,1023(r3)
81122324:	81401043 	ldbu	r5,65(r16)
81122328:	1900ff44 	addi	r4,r3,1021
8112232c:	0005883a 	mov	r2,zero
81122330:	1940ff85 	stb	r5,1022(r3)
81122334:	81401003 	ldbu	r5,64(r16)
81122338:	1940ff45 	stb	r5,1021(r3)
8112233c:	81000015 	stw	r4,0(r16)
81122340:	003fe706 	br	811222e0 <__reset+0xfb1022e0>
81122344:	00bfffc4 	movi	r2,-1
81122348:	003fe506 	br	811222e0 <__reset+0xfb1022e0>

8112234c <_ungetc_r>:
8112234c:	00bfffc4 	movi	r2,-1
81122350:	28806326 	beq	r5,r2,811224e0 <_ungetc_r+0x194>
81122354:	defffb04 	addi	sp,sp,-20
81122358:	de00012e 	bgeu	sp,et,81122360 <_ungetc_r+0x14>
8112235c:	003b68fa 	trap	3
81122360:	dcc00315 	stw	r19,12(sp)
81122364:	dc400115 	stw	r17,4(sp)
81122368:	dc000015 	stw	r16,0(sp)
8112236c:	dfc00415 	stw	ra,16(sp)
81122370:	dc800215 	stw	r18,8(sp)
81122374:	2023883a 	mov	r17,r4
81122378:	3021883a 	mov	r16,r6
8112237c:	2827883a 	mov	r19,r5
81122380:	20000226 	beq	r4,zero,8112238c <_ungetc_r+0x40>
81122384:	20800e17 	ldw	r2,56(r4)
81122388:	10002e26 	beq	r2,zero,81122444 <_ungetc_r+0xf8>
8112238c:	80c0030b 	ldhu	r3,12(r16)
81122390:	1888000c 	andi	r2,r3,8192
81122394:	1000051e 	bne	r2,zero,811223ac <_ungetc_r+0x60>
81122398:	81001917 	ldw	r4,100(r16)
8112239c:	00b7ffc4 	movi	r2,-8193
811223a0:	18c80014 	ori	r3,r3,8192
811223a4:	2084703a 	and	r2,r4,r2
811223a8:	80801915 	stw	r2,100(r16)
811223ac:	00bff7c4 	movi	r2,-33
811223b0:	1884703a 	and	r2,r3,r2
811223b4:	8080030d 	sth	r2,12(r16)
811223b8:	1900010c 	andi	r4,r3,4
811223bc:	2000061e 	bne	r4,zero,811223d8 <_ungetc_r+0x8c>
811223c0:	1900040c 	andi	r4,r3,16
811223c4:	20001d26 	beq	r4,zero,8112243c <_ungetc_r+0xf0>
811223c8:	18c0020c 	andi	r3,r3,8
811223cc:	1800331e 	bne	r3,zero,8112249c <_ungetc_r+0x150>
811223d0:	10800114 	ori	r2,r2,4
811223d4:	8080030d 	sth	r2,12(r16)
811223d8:	80800c17 	ldw	r2,48(r16)
811223dc:	9c803fcc 	andi	r18,r19,255
811223e0:	10001a26 	beq	r2,zero,8112244c <_ungetc_r+0x100>
811223e4:	80c00117 	ldw	r3,4(r16)
811223e8:	80800d17 	ldw	r2,52(r16)
811223ec:	18800f0e 	bge	r3,r2,8112242c <_ungetc_r+0xe0>
811223f0:	80c00017 	ldw	r3,0(r16)
811223f4:	9005883a 	mov	r2,r18
811223f8:	193fffc4 	addi	r4,r3,-1
811223fc:	81000015 	stw	r4,0(r16)
81122400:	1cffffc5 	stb	r19,-1(r3)
81122404:	80c00117 	ldw	r3,4(r16)
81122408:	18c00044 	addi	r3,r3,1
8112240c:	80c00115 	stw	r3,4(r16)
81122410:	dfc00417 	ldw	ra,16(sp)
81122414:	dcc00317 	ldw	r19,12(sp)
81122418:	dc800217 	ldw	r18,8(sp)
8112241c:	dc400117 	ldw	r17,4(sp)
81122420:	dc000017 	ldw	r16,0(sp)
81122424:	dec00504 	addi	sp,sp,20
81122428:	f800283a 	ret
8112242c:	800b883a 	mov	r5,r16
81122430:	8809883a 	mov	r4,r17
81122434:	11222700 	call	81122270 <__submore>
81122438:	103fed26 	beq	r2,zero,811223f0 <__reset+0xfb1023f0>
8112243c:	00bfffc4 	movi	r2,-1
81122440:	003ff306 	br	81122410 <__reset+0xfb102410>
81122444:	111c1d00 	call	8111c1d0 <__sinit>
81122448:	003fd006 	br	8112238c <__reset+0xfb10238c>
8112244c:	80c00417 	ldw	r3,16(r16)
81122450:	80800017 	ldw	r2,0(r16)
81122454:	18000326 	beq	r3,zero,81122464 <_ungetc_r+0x118>
81122458:	1880022e 	bgeu	r3,r2,81122464 <_ungetc_r+0x118>
8112245c:	10ffffc3 	ldbu	r3,-1(r2)
81122460:	90c01826 	beq	r18,r3,811224c4 <_ungetc_r+0x178>
81122464:	81400117 	ldw	r5,4(r16)
81122468:	80800e15 	stw	r2,56(r16)
8112246c:	008000c4 	movi	r2,3
81122470:	81001004 	addi	r4,r16,64
81122474:	80c01084 	addi	r3,r16,66
81122478:	80800d15 	stw	r2,52(r16)
8112247c:	00800044 	movi	r2,1
81122480:	80800115 	stw	r2,4(r16)
81122484:	81400f15 	stw	r5,60(r16)
81122488:	81000c15 	stw	r4,48(r16)
8112248c:	84c01085 	stb	r19,66(r16)
81122490:	80c00015 	stw	r3,0(r16)
81122494:	9005883a 	mov	r2,r18
81122498:	003fdd06 	br	81122410 <__reset+0xfb102410>
8112249c:	800b883a 	mov	r5,r16
811224a0:	8809883a 	mov	r4,r17
811224a4:	111bdd40 	call	8111bdd4 <_fflush_r>
811224a8:	103fe41e 	bne	r2,zero,8112243c <__reset+0xfb10243c>
811224ac:	8080030b 	ldhu	r2,12(r16)
811224b0:	00fffdc4 	movi	r3,-9
811224b4:	80000215 	stw	zero,8(r16)
811224b8:	1884703a 	and	r2,r3,r2
811224bc:	80000615 	stw	zero,24(r16)
811224c0:	003fc306 	br	811223d0 <__reset+0xfb1023d0>
811224c4:	80c00117 	ldw	r3,4(r16)
811224c8:	10bfffc4 	addi	r2,r2,-1
811224cc:	80800015 	stw	r2,0(r16)
811224d0:	18800044 	addi	r2,r3,1
811224d4:	80800115 	stw	r2,4(r16)
811224d8:	9005883a 	mov	r2,r18
811224dc:	003fcc06 	br	81122410 <__reset+0xfb102410>
811224e0:	00bfffc4 	movi	r2,-1
811224e4:	f800283a 	ret

811224e8 <ungetc>:
811224e8:	00a04534 	movhi	r2,33044
811224ec:	1086aa04 	addi	r2,r2,6824
811224f0:	280d883a 	mov	r6,r5
811224f4:	200b883a 	mov	r5,r4
811224f8:	11000017 	ldw	r4,0(r2)
811224fc:	112234c1 	jmpi	8112234c <_ungetc_r>

81122500 <__sprint_r.part.0>:
81122500:	defff604 	addi	sp,sp,-40
81122504:	de00012e 	bgeu	sp,et,8112250c <__sprint_r.part.0+0xc>
81122508:	003b68fa 	trap	3
8112250c:	28801917 	ldw	r2,100(r5)
81122510:	dd400515 	stw	r21,20(sp)
81122514:	dfc00915 	stw	ra,36(sp)
81122518:	df000815 	stw	fp,32(sp)
8112251c:	ddc00715 	stw	r23,28(sp)
81122520:	dd800615 	stw	r22,24(sp)
81122524:	dd000415 	stw	r20,16(sp)
81122528:	dcc00315 	stw	r19,12(sp)
8112252c:	dc800215 	stw	r18,8(sp)
81122530:	dc400115 	stw	r17,4(sp)
81122534:	dc000015 	stw	r16,0(sp)
81122538:	1088000c 	andi	r2,r2,8192
8112253c:	302b883a 	mov	r21,r6
81122540:	10002e26 	beq	r2,zero,811225fc <__sprint_r.part.0+0xfc>
81122544:	30800217 	ldw	r2,8(r6)
81122548:	35800017 	ldw	r22,0(r6)
8112254c:	10002926 	beq	r2,zero,811225f4 <__sprint_r.part.0+0xf4>
81122550:	2827883a 	mov	r19,r5
81122554:	2029883a 	mov	r20,r4
81122558:	b5c00104 	addi	r23,r22,4
8112255c:	04bfffc4 	movi	r18,-1
81122560:	bc400017 	ldw	r17,0(r23)
81122564:	b4000017 	ldw	r16,0(r22)
81122568:	0039883a 	mov	fp,zero
8112256c:	8822d0ba 	srli	r17,r17,2
81122570:	8800031e 	bne	r17,zero,81122580 <__sprint_r.part.0+0x80>
81122574:	00001806 	br	811225d8 <__sprint_r.part.0+0xd8>
81122578:	84000104 	addi	r16,r16,4
8112257c:	8f001526 	beq	r17,fp,811225d4 <__sprint_r.part.0+0xd4>
81122580:	81400017 	ldw	r5,0(r16)
81122584:	980d883a 	mov	r6,r19
81122588:	a009883a 	mov	r4,r20
8112258c:	1123ea40 	call	81123ea4 <_fputwc_r>
81122590:	e7000044 	addi	fp,fp,1
81122594:	14bff81e 	bne	r2,r18,81122578 <__reset+0xfb102578>
81122598:	9005883a 	mov	r2,r18
8112259c:	a8000215 	stw	zero,8(r21)
811225a0:	a8000115 	stw	zero,4(r21)
811225a4:	dfc00917 	ldw	ra,36(sp)
811225a8:	df000817 	ldw	fp,32(sp)
811225ac:	ddc00717 	ldw	r23,28(sp)
811225b0:	dd800617 	ldw	r22,24(sp)
811225b4:	dd400517 	ldw	r21,20(sp)
811225b8:	dd000417 	ldw	r20,16(sp)
811225bc:	dcc00317 	ldw	r19,12(sp)
811225c0:	dc800217 	ldw	r18,8(sp)
811225c4:	dc400117 	ldw	r17,4(sp)
811225c8:	dc000017 	ldw	r16,0(sp)
811225cc:	dec00a04 	addi	sp,sp,40
811225d0:	f800283a 	ret
811225d4:	a8800217 	ldw	r2,8(r21)
811225d8:	8c63883a 	add	r17,r17,r17
811225dc:	8c63883a 	add	r17,r17,r17
811225e0:	1445c83a 	sub	r2,r2,r17
811225e4:	a8800215 	stw	r2,8(r21)
811225e8:	b5800204 	addi	r22,r22,8
811225ec:	bdc00204 	addi	r23,r23,8
811225f0:	103fdb1e 	bne	r2,zero,81122560 <__reset+0xfb102560>
811225f4:	0005883a 	mov	r2,zero
811225f8:	003fe806 	br	8112259c <__reset+0xfb10259c>
811225fc:	111c9800 	call	8111c980 <__sfvwrite_r>
81122600:	003fe606 	br	8112259c <__reset+0xfb10259c>

81122604 <__sprint_r>:
81122604:	30c00217 	ldw	r3,8(r6)
81122608:	18000126 	beq	r3,zero,81122610 <__sprint_r+0xc>
8112260c:	11225001 	jmpi	81122500 <__sprint_r.part.0>
81122610:	30000115 	stw	zero,4(r6)
81122614:	0005883a 	mov	r2,zero
81122618:	f800283a 	ret

8112261c <___vfiprintf_internal_r>:
8112261c:	deffc904 	addi	sp,sp,-220
81122620:	de00012e 	bgeu	sp,et,81122628 <___vfiprintf_internal_r+0xc>
81122624:	003b68fa 	trap	3
81122628:	df003515 	stw	fp,212(sp)
8112262c:	dd003115 	stw	r20,196(sp)
81122630:	dfc03615 	stw	ra,216(sp)
81122634:	ddc03415 	stw	r23,208(sp)
81122638:	dd803315 	stw	r22,204(sp)
8112263c:	dd403215 	stw	r21,200(sp)
81122640:	dcc03015 	stw	r19,192(sp)
81122644:	dc802f15 	stw	r18,188(sp)
81122648:	dc402e15 	stw	r17,184(sp)
8112264c:	dc002d15 	stw	r16,180(sp)
81122650:	d9002015 	stw	r4,128(sp)
81122654:	d9c02215 	stw	r7,136(sp)
81122658:	2829883a 	mov	r20,r5
8112265c:	3039883a 	mov	fp,r6
81122660:	20000226 	beq	r4,zero,8112266c <___vfiprintf_internal_r+0x50>
81122664:	20800e17 	ldw	r2,56(r4)
81122668:	1000cf26 	beq	r2,zero,811229a8 <___vfiprintf_internal_r+0x38c>
8112266c:	a080030b 	ldhu	r2,12(r20)
81122670:	10c8000c 	andi	r3,r2,8192
81122674:	1800061e 	bne	r3,zero,81122690 <___vfiprintf_internal_r+0x74>
81122678:	a1001917 	ldw	r4,100(r20)
8112267c:	00f7ffc4 	movi	r3,-8193
81122680:	10880014 	ori	r2,r2,8192
81122684:	20c6703a 	and	r3,r4,r3
81122688:	a080030d 	sth	r2,12(r20)
8112268c:	a0c01915 	stw	r3,100(r20)
81122690:	10c0020c 	andi	r3,r2,8
81122694:	1800a926 	beq	r3,zero,8112293c <___vfiprintf_internal_r+0x320>
81122698:	a0c00417 	ldw	r3,16(r20)
8112269c:	1800a726 	beq	r3,zero,8112293c <___vfiprintf_internal_r+0x320>
811226a0:	1080068c 	andi	r2,r2,26
811226a4:	00c00284 	movi	r3,10
811226a8:	10c0ac26 	beq	r2,r3,8112295c <___vfiprintf_internal_r+0x340>
811226ac:	da801a04 	addi	r10,sp,104
811226b0:	da801e15 	stw	r10,120(sp)
811226b4:	d8801e17 	ldw	r2,120(sp)
811226b8:	da8019c4 	addi	r10,sp,103
811226bc:	05a04534 	movhi	r22,33044
811226c0:	05e04534 	movhi	r23,33044
811226c4:	da801f15 	stw	r10,124(sp)
811226c8:	1295c83a 	sub	r10,r2,r10
811226cc:	b5be3f04 	addi	r22,r22,-1796
811226d0:	bdfe3b04 	addi	r23,r23,-1812
811226d4:	dec01a15 	stw	sp,104(sp)
811226d8:	d8001c15 	stw	zero,112(sp)
811226dc:	d8001b15 	stw	zero,108(sp)
811226e0:	d8002615 	stw	zero,152(sp)
811226e4:	d8002315 	stw	zero,140(sp)
811226e8:	da802715 	stw	r10,156(sp)
811226ec:	d811883a 	mov	r8,sp
811226f0:	dd002115 	stw	r20,132(sp)
811226f4:	e021883a 	mov	r16,fp
811226f8:	80800007 	ldb	r2,0(r16)
811226fc:	1003ea26 	beq	r2,zero,811236a8 <___vfiprintf_internal_r+0x108c>
81122700:	00c00944 	movi	r3,37
81122704:	8025883a 	mov	r18,r16
81122708:	10c0021e 	bne	r2,r3,81122714 <___vfiprintf_internal_r+0xf8>
8112270c:	00001606 	br	81122768 <___vfiprintf_internal_r+0x14c>
81122710:	10c00326 	beq	r2,r3,81122720 <___vfiprintf_internal_r+0x104>
81122714:	94800044 	addi	r18,r18,1
81122718:	90800007 	ldb	r2,0(r18)
8112271c:	103ffc1e 	bne	r2,zero,81122710 <__reset+0xfb102710>
81122720:	9423c83a 	sub	r17,r18,r16
81122724:	88001026 	beq	r17,zero,81122768 <___vfiprintf_internal_r+0x14c>
81122728:	d8c01c17 	ldw	r3,112(sp)
8112272c:	d8801b17 	ldw	r2,108(sp)
81122730:	44000015 	stw	r16,0(r8)
81122734:	88c7883a 	add	r3,r17,r3
81122738:	10800044 	addi	r2,r2,1
8112273c:	44400115 	stw	r17,4(r8)
81122740:	d8c01c15 	stw	r3,112(sp)
81122744:	d8801b15 	stw	r2,108(sp)
81122748:	010001c4 	movi	r4,7
8112274c:	2080760e 	bge	r4,r2,81122928 <___vfiprintf_internal_r+0x30c>
81122750:	1803821e 	bne	r3,zero,8112355c <___vfiprintf_internal_r+0xf40>
81122754:	da802317 	ldw	r10,140(sp)
81122758:	d8001b15 	stw	zero,108(sp)
8112275c:	d811883a 	mov	r8,sp
81122760:	5455883a 	add	r10,r10,r17
81122764:	da802315 	stw	r10,140(sp)
81122768:	90800007 	ldb	r2,0(r18)
8112276c:	10044626 	beq	r2,zero,81123888 <___vfiprintf_internal_r+0x126c>
81122770:	90c00047 	ldb	r3,1(r18)
81122774:	94000044 	addi	r16,r18,1
81122778:	d8001d85 	stb	zero,118(sp)
8112277c:	0009883a 	mov	r4,zero
81122780:	000f883a 	mov	r7,zero
81122784:	027fffc4 	movi	r9,-1
81122788:	0023883a 	mov	r17,zero
8112278c:	0029883a 	mov	r20,zero
81122790:	01401604 	movi	r5,88
81122794:	01800244 	movi	r6,9
81122798:	03400a84 	movi	r13,42
8112279c:	03001b04 	movi	r12,108
811227a0:	84000044 	addi	r16,r16,1
811227a4:	18bff804 	addi	r2,r3,-32
811227a8:	28827336 	bltu	r5,r2,81123178 <___vfiprintf_internal_r+0xb5c>
811227ac:	100490ba 	slli	r2,r2,2
811227b0:	02a044b4 	movhi	r10,33042
811227b4:	5289f104 	addi	r10,r10,10180
811227b8:	1285883a 	add	r2,r2,r10
811227bc:	10800017 	ldw	r2,0(r2)
811227c0:	1000683a 	jmp	r2
811227c4:	81122eac 	andhi	r4,r16,18618
811227c8:	81123178 	rdprs	r4,r16,18629
811227cc:	81123178 	rdprs	r4,r16,18629
811227d0:	81122ecc 	andi	r4,r16,18619
811227d4:	81123178 	rdprs	r4,r16,18629
811227d8:	81123178 	rdprs	r4,r16,18629
811227dc:	81123178 	rdprs	r4,r16,18629
811227e0:	81123178 	rdprs	r4,r16,18629
811227e4:	81123178 	rdprs	r4,r16,18629
811227e8:	81123178 	rdprs	r4,r16,18629
811227ec:	811230b4 	orhi	r4,r16,18626
811227f0:	811230d0 	cmplti	r4,r16,18627
811227f4:	81123178 	rdprs	r4,r16,18629
811227f8:	811229b8 	rdprs	r4,r16,18598
811227fc:	811230e0 	cmpeqi	r4,r16,18627
81122800:	81123178 	rdprs	r4,r16,18629
81122804:	81122ed8 	cmpnei	r4,r16,18619
81122808:	81122ee4 	muli	r4,r16,18619
8112280c:	81122ee4 	muli	r4,r16,18619
81122810:	81122ee4 	muli	r4,r16,18619
81122814:	81122ee4 	muli	r4,r16,18619
81122818:	81122ee4 	muli	r4,r16,18619
8112281c:	81122ee4 	muli	r4,r16,18619
81122820:	81122ee4 	muli	r4,r16,18619
81122824:	81122ee4 	muli	r4,r16,18619
81122828:	81122ee4 	muli	r4,r16,18619
8112282c:	81123178 	rdprs	r4,r16,18629
81122830:	81123178 	rdprs	r4,r16,18629
81122834:	81123178 	rdprs	r4,r16,18629
81122838:	81123178 	rdprs	r4,r16,18629
8112283c:	81123178 	rdprs	r4,r16,18629
81122840:	81123178 	rdprs	r4,r16,18629
81122844:	81123178 	rdprs	r4,r16,18629
81122848:	81123178 	rdprs	r4,r16,18629
8112284c:	81123178 	rdprs	r4,r16,18629
81122850:	81123178 	rdprs	r4,r16,18629
81122854:	81122f10 	cmplti	r4,r16,18620
81122858:	81123178 	rdprs	r4,r16,18629
8112285c:	81123178 	rdprs	r4,r16,18629
81122860:	81123178 	rdprs	r4,r16,18629
81122864:	81123178 	rdprs	r4,r16,18629
81122868:	81123178 	rdprs	r4,r16,18629
8112286c:	81123178 	rdprs	r4,r16,18629
81122870:	81123178 	rdprs	r4,r16,18629
81122874:	81123178 	rdprs	r4,r16,18629
81122878:	81123178 	rdprs	r4,r16,18629
8112287c:	81123178 	rdprs	r4,r16,18629
81122880:	81122f48 	cmpgei	r4,r16,18621
81122884:	81123178 	rdprs	r4,r16,18629
81122888:	81123178 	rdprs	r4,r16,18629
8112288c:	81123178 	rdprs	r4,r16,18629
81122890:	81123178 	rdprs	r4,r16,18629
81122894:	81123178 	rdprs	r4,r16,18629
81122898:	81122fa0 	cmpeqi	r4,r16,18622
8112289c:	81123178 	rdprs	r4,r16,18629
811228a0:	81123178 	rdprs	r4,r16,18629
811228a4:	81123010 	cmplti	r4,r16,18624
811228a8:	81123178 	rdprs	r4,r16,18629
811228ac:	81123178 	rdprs	r4,r16,18629
811228b0:	81123178 	rdprs	r4,r16,18629
811228b4:	81123178 	rdprs	r4,r16,18629
811228b8:	81123178 	rdprs	r4,r16,18629
811228bc:	81123178 	rdprs	r4,r16,18629
811228c0:	81123178 	rdprs	r4,r16,18629
811228c4:	81123178 	rdprs	r4,r16,18629
811228c8:	81123178 	rdprs	r4,r16,18629
811228cc:	81123178 	rdprs	r4,r16,18629
811228d0:	81122dbc 	xorhi	r4,r16,18614
811228d4:	81122de8 	cmpgeui	r4,r16,18615
811228d8:	81123178 	rdprs	r4,r16,18629
811228dc:	81123178 	rdprs	r4,r16,18629
811228e0:	81123178 	rdprs	r4,r16,18629
811228e4:	81123120 	cmpeqi	r4,r16,18628
811228e8:	81122de8 	cmpgeui	r4,r16,18615
811228ec:	81123178 	rdprs	r4,r16,18629
811228f0:	81123178 	rdprs	r4,r16,18629
811228f4:	81122c7c 	xorhi	r4,r16,18609
811228f8:	81123178 	rdprs	r4,r16,18629
811228fc:	81122c8c 	andi	r4,r16,18610
81122900:	81122cc8 	cmpgei	r4,r16,18611
81122904:	811229c4 	addi	r4,r16,18599
81122908:	81122c70 	cmpltui	r4,r16,18609
8112290c:	81123178 	rdprs	r4,r16,18629
81122910:	8112304c 	andi	r4,r16,18625
81122914:	81123178 	rdprs	r4,r16,18629
81122918:	811230a4 	muli	r4,r16,18626
8112291c:	81123178 	rdprs	r4,r16,18629
81122920:	81123178 	rdprs	r4,r16,18629
81122924:	81122d68 	cmpgeui	r4,r16,18613
81122928:	42000204 	addi	r8,r8,8
8112292c:	da802317 	ldw	r10,140(sp)
81122930:	5455883a 	add	r10,r10,r17
81122934:	da802315 	stw	r10,140(sp)
81122938:	003f8b06 	br	81122768 <__reset+0xfb102768>
8112293c:	d9002017 	ldw	r4,128(sp)
81122940:	a00b883a 	mov	r5,r20
81122944:	111a1600 	call	8111a160 <__swsetup_r>
81122948:	1003b11e 	bne	r2,zero,81123810 <___vfiprintf_internal_r+0x11f4>
8112294c:	a080030b 	ldhu	r2,12(r20)
81122950:	00c00284 	movi	r3,10
81122954:	1080068c 	andi	r2,r2,26
81122958:	10ff541e 	bne	r2,r3,811226ac <__reset+0xfb1026ac>
8112295c:	a080038f 	ldh	r2,14(r20)
81122960:	103f5216 	blt	r2,zero,811226ac <__reset+0xfb1026ac>
81122964:	d9c02217 	ldw	r7,136(sp)
81122968:	d9002017 	ldw	r4,128(sp)
8112296c:	e00d883a 	mov	r6,fp
81122970:	a00b883a 	mov	r5,r20
81122974:	1123a9c0 	call	81123a9c <__sbprintf>
81122978:	dfc03617 	ldw	ra,216(sp)
8112297c:	df003517 	ldw	fp,212(sp)
81122980:	ddc03417 	ldw	r23,208(sp)
81122984:	dd803317 	ldw	r22,204(sp)
81122988:	dd403217 	ldw	r21,200(sp)
8112298c:	dd003117 	ldw	r20,196(sp)
81122990:	dcc03017 	ldw	r19,192(sp)
81122994:	dc802f17 	ldw	r18,188(sp)
81122998:	dc402e17 	ldw	r17,184(sp)
8112299c:	dc002d17 	ldw	r16,180(sp)
811229a0:	dec03704 	addi	sp,sp,220
811229a4:	f800283a 	ret
811229a8:	111c1d00 	call	8111c1d0 <__sinit>
811229ac:	003f2f06 	br	8112266c <__reset+0xfb10266c>
811229b0:	0463c83a 	sub	r17,zero,r17
811229b4:	d8802215 	stw	r2,136(sp)
811229b8:	a5000114 	ori	r20,r20,4
811229bc:	80c00007 	ldb	r3,0(r16)
811229c0:	003f7706 	br	811227a0 <__reset+0xfb1027a0>
811229c4:	00800c04 	movi	r2,48
811229c8:	da802217 	ldw	r10,136(sp)
811229cc:	d8801d05 	stb	r2,116(sp)
811229d0:	00801e04 	movi	r2,120
811229d4:	d8801d45 	stb	r2,117(sp)
811229d8:	d8001d85 	stb	zero,118(sp)
811229dc:	50c00104 	addi	r3,r10,4
811229e0:	54800017 	ldw	r18,0(r10)
811229e4:	0027883a 	mov	r19,zero
811229e8:	a0800094 	ori	r2,r20,2
811229ec:	48030b16 	blt	r9,zero,8112361c <___vfiprintf_internal_r+0x1000>
811229f0:	00bfdfc4 	movi	r2,-129
811229f4:	a096703a 	and	r11,r20,r2
811229f8:	d8c02215 	stw	r3,136(sp)
811229fc:	5d000094 	ori	r20,r11,2
81122a00:	90032b1e 	bne	r18,zero,811236b0 <___vfiprintf_internal_r+0x1094>
81122a04:	00a04534 	movhi	r2,33044
81122a08:	10bda904 	addi	r2,r2,-2396
81122a0c:	d8802615 	stw	r2,152(sp)
81122a10:	0039883a 	mov	fp,zero
81122a14:	48017b1e 	bne	r9,zero,81123004 <___vfiprintf_internal_r+0x9e8>
81122a18:	0013883a 	mov	r9,zero
81122a1c:	0027883a 	mov	r19,zero
81122a20:	dd401a04 	addi	r21,sp,104
81122a24:	4825883a 	mov	r18,r9
81122a28:	4cc0010e 	bge	r9,r19,81122a30 <___vfiprintf_internal_r+0x414>
81122a2c:	9825883a 	mov	r18,r19
81122a30:	e7003fcc 	andi	fp,fp,255
81122a34:	e700201c 	xori	fp,fp,128
81122a38:	e73fe004 	addi	fp,fp,-128
81122a3c:	e0000126 	beq	fp,zero,81122a44 <___vfiprintf_internal_r+0x428>
81122a40:	94800044 	addi	r18,r18,1
81122a44:	a380008c 	andi	r14,r20,2
81122a48:	70000126 	beq	r14,zero,81122a50 <___vfiprintf_internal_r+0x434>
81122a4c:	94800084 	addi	r18,r18,2
81122a50:	a700210c 	andi	fp,r20,132
81122a54:	e001df1e 	bne	fp,zero,811231d4 <___vfiprintf_internal_r+0xbb8>
81122a58:	8c87c83a 	sub	r3,r17,r18
81122a5c:	00c1dd0e 	bge	zero,r3,811231d4 <___vfiprintf_internal_r+0xbb8>
81122a60:	01c00404 	movi	r7,16
81122a64:	d8801c17 	ldw	r2,112(sp)
81122a68:	38c3ad0e 	bge	r7,r3,81123920 <___vfiprintf_internal_r+0x1304>
81122a6c:	02a04534 	movhi	r10,33044
81122a70:	52be3f04 	addi	r10,r10,-1796
81122a74:	dc002915 	stw	r16,164(sp)
81122a78:	d9801b17 	ldw	r6,108(sp)
81122a7c:	da802415 	stw	r10,144(sp)
81122a80:	03c001c4 	movi	r15,7
81122a84:	da402515 	stw	r9,148(sp)
81122a88:	db802815 	stw	r14,160(sp)
81122a8c:	1821883a 	mov	r16,r3
81122a90:	00000506 	br	81122aa8 <___vfiprintf_internal_r+0x48c>
81122a94:	31400084 	addi	r5,r6,2
81122a98:	42000204 	addi	r8,r8,8
81122a9c:	200d883a 	mov	r6,r4
81122aa0:	843ffc04 	addi	r16,r16,-16
81122aa4:	3c000d0e 	bge	r7,r16,81122adc <___vfiprintf_internal_r+0x4c0>
81122aa8:	10800404 	addi	r2,r2,16
81122aac:	31000044 	addi	r4,r6,1
81122ab0:	45800015 	stw	r22,0(r8)
81122ab4:	41c00115 	stw	r7,4(r8)
81122ab8:	d8801c15 	stw	r2,112(sp)
81122abc:	d9001b15 	stw	r4,108(sp)
81122ac0:	793ff40e 	bge	r15,r4,81122a94 <__reset+0xfb102a94>
81122ac4:	1001b51e 	bne	r2,zero,8112319c <___vfiprintf_internal_r+0xb80>
81122ac8:	843ffc04 	addi	r16,r16,-16
81122acc:	000d883a 	mov	r6,zero
81122ad0:	01400044 	movi	r5,1
81122ad4:	d811883a 	mov	r8,sp
81122ad8:	3c3ff316 	blt	r7,r16,81122aa8 <__reset+0xfb102aa8>
81122adc:	8007883a 	mov	r3,r16
81122ae0:	da402517 	ldw	r9,148(sp)
81122ae4:	db802817 	ldw	r14,160(sp)
81122ae8:	dc002917 	ldw	r16,164(sp)
81122aec:	da802417 	ldw	r10,144(sp)
81122af0:	1885883a 	add	r2,r3,r2
81122af4:	40c00115 	stw	r3,4(r8)
81122af8:	42800015 	stw	r10,0(r8)
81122afc:	d8801c15 	stw	r2,112(sp)
81122b00:	d9401b15 	stw	r5,108(sp)
81122b04:	00c001c4 	movi	r3,7
81122b08:	19426016 	blt	r3,r5,8112348c <___vfiprintf_internal_r+0xe70>
81122b0c:	d8c01d87 	ldb	r3,118(sp)
81122b10:	42000204 	addi	r8,r8,8
81122b14:	29000044 	addi	r4,r5,1
81122b18:	1801b31e 	bne	r3,zero,811231e8 <___vfiprintf_internal_r+0xbcc>
81122b1c:	7001c026 	beq	r14,zero,81123220 <___vfiprintf_internal_r+0xc04>
81122b20:	d8c01d04 	addi	r3,sp,116
81122b24:	10800084 	addi	r2,r2,2
81122b28:	40c00015 	stw	r3,0(r8)
81122b2c:	00c00084 	movi	r3,2
81122b30:	40c00115 	stw	r3,4(r8)
81122b34:	d8801c15 	stw	r2,112(sp)
81122b38:	d9001b15 	stw	r4,108(sp)
81122b3c:	00c001c4 	movi	r3,7
81122b40:	1902650e 	bge	r3,r4,811234d8 <___vfiprintf_internal_r+0xebc>
81122b44:	10029a1e 	bne	r2,zero,811235b0 <___vfiprintf_internal_r+0xf94>
81122b48:	00c02004 	movi	r3,128
81122b4c:	01000044 	movi	r4,1
81122b50:	000b883a 	mov	r5,zero
81122b54:	d811883a 	mov	r8,sp
81122b58:	e0c1b31e 	bne	fp,r3,81123228 <___vfiprintf_internal_r+0xc0c>
81122b5c:	8cb9c83a 	sub	fp,r17,r18
81122b60:	0701b10e 	bge	zero,fp,81123228 <___vfiprintf_internal_r+0xc0c>
81122b64:	01c00404 	movi	r7,16
81122b68:	3f03890e 	bge	r7,fp,81123990 <___vfiprintf_internal_r+0x1374>
81122b6c:	00e04534 	movhi	r3,33044
81122b70:	18fe3b04 	addi	r3,r3,-1812
81122b74:	d8c02415 	stw	r3,144(sp)
81122b78:	8007883a 	mov	r3,r16
81122b7c:	034001c4 	movi	r13,7
81122b80:	e021883a 	mov	r16,fp
81122b84:	da402515 	stw	r9,148(sp)
81122b88:	1839883a 	mov	fp,r3
81122b8c:	00000506 	br	81122ba4 <___vfiprintf_internal_r+0x588>
81122b90:	29800084 	addi	r6,r5,2
81122b94:	42000204 	addi	r8,r8,8
81122b98:	180b883a 	mov	r5,r3
81122b9c:	843ffc04 	addi	r16,r16,-16
81122ba0:	3c000d0e 	bge	r7,r16,81122bd8 <___vfiprintf_internal_r+0x5bc>
81122ba4:	10800404 	addi	r2,r2,16
81122ba8:	28c00044 	addi	r3,r5,1
81122bac:	45c00015 	stw	r23,0(r8)
81122bb0:	41c00115 	stw	r7,4(r8)
81122bb4:	d8801c15 	stw	r2,112(sp)
81122bb8:	d8c01b15 	stw	r3,108(sp)
81122bbc:	68fff40e 	bge	r13,r3,81122b90 <__reset+0xfb102b90>
81122bc0:	1002241e 	bne	r2,zero,81123454 <___vfiprintf_internal_r+0xe38>
81122bc4:	843ffc04 	addi	r16,r16,-16
81122bc8:	01800044 	movi	r6,1
81122bcc:	000b883a 	mov	r5,zero
81122bd0:	d811883a 	mov	r8,sp
81122bd4:	3c3ff316 	blt	r7,r16,81122ba4 <__reset+0xfb102ba4>
81122bd8:	da402517 	ldw	r9,148(sp)
81122bdc:	e007883a 	mov	r3,fp
81122be0:	8039883a 	mov	fp,r16
81122be4:	1821883a 	mov	r16,r3
81122be8:	d8c02417 	ldw	r3,144(sp)
81122bec:	1705883a 	add	r2,r2,fp
81122bf0:	47000115 	stw	fp,4(r8)
81122bf4:	40c00015 	stw	r3,0(r8)
81122bf8:	d8801c15 	stw	r2,112(sp)
81122bfc:	d9801b15 	stw	r6,108(sp)
81122c00:	00c001c4 	movi	r3,7
81122c04:	19827616 	blt	r3,r6,811235e0 <___vfiprintf_internal_r+0xfc4>
81122c08:	4cf9c83a 	sub	fp,r9,r19
81122c0c:	42000204 	addi	r8,r8,8
81122c10:	31000044 	addi	r4,r6,1
81122c14:	300b883a 	mov	r5,r6
81122c18:	07018516 	blt	zero,fp,81123230 <___vfiprintf_internal_r+0xc14>
81122c1c:	9885883a 	add	r2,r19,r2
81122c20:	45400015 	stw	r21,0(r8)
81122c24:	44c00115 	stw	r19,4(r8)
81122c28:	d8801c15 	stw	r2,112(sp)
81122c2c:	d9001b15 	stw	r4,108(sp)
81122c30:	00c001c4 	movi	r3,7
81122c34:	1901dd0e 	bge	r3,r4,811233ac <___vfiprintf_internal_r+0xd90>
81122c38:	1002401e 	bne	r2,zero,8112353c <___vfiprintf_internal_r+0xf20>
81122c3c:	d8001b15 	stw	zero,108(sp)
81122c40:	a2c0010c 	andi	r11,r20,4
81122c44:	58000226 	beq	r11,zero,81122c50 <___vfiprintf_internal_r+0x634>
81122c48:	8ca7c83a 	sub	r19,r17,r18
81122c4c:	04c2f216 	blt	zero,r19,81123818 <___vfiprintf_internal_r+0x11fc>
81122c50:	8c80010e 	bge	r17,r18,81122c58 <___vfiprintf_internal_r+0x63c>
81122c54:	9023883a 	mov	r17,r18
81122c58:	da802317 	ldw	r10,140(sp)
81122c5c:	5455883a 	add	r10,r10,r17
81122c60:	da802315 	stw	r10,140(sp)
81122c64:	d8001b15 	stw	zero,108(sp)
81122c68:	d811883a 	mov	r8,sp
81122c6c:	003ea206 	br	811226f8 <__reset+0xfb1026f8>
81122c70:	a5000814 	ori	r20,r20,32
81122c74:	80c00007 	ldb	r3,0(r16)
81122c78:	003ec906 	br	811227a0 <__reset+0xfb1027a0>
81122c7c:	80c00007 	ldb	r3,0(r16)
81122c80:	1b030926 	beq	r3,r12,811238a8 <___vfiprintf_internal_r+0x128c>
81122c84:	a5000414 	ori	r20,r20,16
81122c88:	003ec506 	br	811227a0 <__reset+0xfb1027a0>
81122c8c:	21003fcc 	andi	r4,r4,255
81122c90:	20035e1e 	bne	r4,zero,81123a0c <___vfiprintf_internal_r+0x13f0>
81122c94:	a080080c 	andi	r2,r20,32
81122c98:	1002a526 	beq	r2,zero,81123730 <___vfiprintf_internal_r+0x1114>
81122c9c:	da802217 	ldw	r10,136(sp)
81122ca0:	50800017 	ldw	r2,0(r10)
81122ca4:	da802317 	ldw	r10,140(sp)
81122ca8:	5007d7fa 	srai	r3,r10,31
81122cac:	da802217 	ldw	r10,136(sp)
81122cb0:	10c00115 	stw	r3,4(r2)
81122cb4:	52800104 	addi	r10,r10,4
81122cb8:	da802215 	stw	r10,136(sp)
81122cbc:	da802317 	ldw	r10,140(sp)
81122cc0:	12800015 	stw	r10,0(r2)
81122cc4:	003e8c06 	br	811226f8 <__reset+0xfb1026f8>
81122cc8:	21003fcc 	andi	r4,r4,255
81122ccc:	2003511e 	bne	r4,zero,81123a14 <___vfiprintf_internal_r+0x13f8>
81122cd0:	a080080c 	andi	r2,r20,32
81122cd4:	1000a126 	beq	r2,zero,81122f5c <___vfiprintf_internal_r+0x940>
81122cd8:	da802217 	ldw	r10,136(sp)
81122cdc:	d8001d85 	stb	zero,118(sp)
81122ce0:	50800204 	addi	r2,r10,8
81122ce4:	54800017 	ldw	r18,0(r10)
81122ce8:	54c00117 	ldw	r19,4(r10)
81122cec:	4802b416 	blt	r9,zero,811237c0 <___vfiprintf_internal_r+0x11a4>
81122cf0:	013fdfc4 	movi	r4,-129
81122cf4:	94c6b03a 	or	r3,r18,r19
81122cf8:	d8802215 	stw	r2,136(sp)
81122cfc:	a128703a 	and	r20,r20,r4
81122d00:	1800a226 	beq	r3,zero,81122f8c <___vfiprintf_internal_r+0x970>
81122d04:	0039883a 	mov	fp,zero
81122d08:	dd401a04 	addi	r21,sp,104
81122d0c:	9006d0fa 	srli	r3,r18,3
81122d10:	9808977a 	slli	r4,r19,29
81122d14:	9826d0fa 	srli	r19,r19,3
81122d18:	948001cc 	andi	r18,r18,7
81122d1c:	90800c04 	addi	r2,r18,48
81122d20:	ad7fffc4 	addi	r21,r21,-1
81122d24:	20e4b03a 	or	r18,r4,r3
81122d28:	a8800005 	stb	r2,0(r21)
81122d2c:	94c6b03a 	or	r3,r18,r19
81122d30:	183ff61e 	bne	r3,zero,81122d0c <__reset+0xfb102d0c>
81122d34:	a0c0004c 	andi	r3,r20,1
81122d38:	18005926 	beq	r3,zero,81122ea0 <___vfiprintf_internal_r+0x884>
81122d3c:	10803fcc 	andi	r2,r2,255
81122d40:	1080201c 	xori	r2,r2,128
81122d44:	10bfe004 	addi	r2,r2,-128
81122d48:	00c00c04 	movi	r3,48
81122d4c:	10c05426 	beq	r2,r3,81122ea0 <___vfiprintf_internal_r+0x884>
81122d50:	da801e17 	ldw	r10,120(sp)
81122d54:	a8bfffc4 	addi	r2,r21,-1
81122d58:	a8ffffc5 	stb	r3,-1(r21)
81122d5c:	50a7c83a 	sub	r19,r10,r2
81122d60:	102b883a 	mov	r21,r2
81122d64:	003f2f06 	br	81122a24 <__reset+0xfb102a24>
81122d68:	21003fcc 	andi	r4,r4,255
81122d6c:	2003421e 	bne	r4,zero,81123a78 <___vfiprintf_internal_r+0x145c>
81122d70:	00a04534 	movhi	r2,33044
81122d74:	10bda904 	addi	r2,r2,-2396
81122d78:	d8802615 	stw	r2,152(sp)
81122d7c:	a080080c 	andi	r2,r20,32
81122d80:	1000aa26 	beq	r2,zero,8112302c <___vfiprintf_internal_r+0xa10>
81122d84:	da802217 	ldw	r10,136(sp)
81122d88:	54800017 	ldw	r18,0(r10)
81122d8c:	54c00117 	ldw	r19,4(r10)
81122d90:	52800204 	addi	r10,r10,8
81122d94:	da802215 	stw	r10,136(sp)
81122d98:	a080004c 	andi	r2,r20,1
81122d9c:	1001d226 	beq	r2,zero,811234e8 <___vfiprintf_internal_r+0xecc>
81122da0:	94c4b03a 	or	r2,r18,r19
81122da4:	1002351e 	bne	r2,zero,8112367c <___vfiprintf_internal_r+0x1060>
81122da8:	d8001d85 	stb	zero,118(sp)
81122dac:	48022216 	blt	r9,zero,81123638 <___vfiprintf_internal_r+0x101c>
81122db0:	00bfdfc4 	movi	r2,-129
81122db4:	a0a8703a 	and	r20,r20,r2
81122db8:	003f1506 	br	81122a10 <__reset+0xfb102a10>
81122dbc:	da802217 	ldw	r10,136(sp)
81122dc0:	04800044 	movi	r18,1
81122dc4:	d8001d85 	stb	zero,118(sp)
81122dc8:	50800017 	ldw	r2,0(r10)
81122dcc:	52800104 	addi	r10,r10,4
81122dd0:	da802215 	stw	r10,136(sp)
81122dd4:	d8801005 	stb	r2,64(sp)
81122dd8:	9027883a 	mov	r19,r18
81122ddc:	dd401004 	addi	r21,sp,64
81122de0:	0013883a 	mov	r9,zero
81122de4:	003f1706 	br	81122a44 <__reset+0xfb102a44>
81122de8:	21003fcc 	andi	r4,r4,255
81122dec:	2003201e 	bne	r4,zero,81123a70 <___vfiprintf_internal_r+0x1454>
81122df0:	a080080c 	andi	r2,r20,32
81122df4:	10004b26 	beq	r2,zero,81122f24 <___vfiprintf_internal_r+0x908>
81122df8:	da802217 	ldw	r10,136(sp)
81122dfc:	50800117 	ldw	r2,4(r10)
81122e00:	54800017 	ldw	r18,0(r10)
81122e04:	52800204 	addi	r10,r10,8
81122e08:	da802215 	stw	r10,136(sp)
81122e0c:	1027883a 	mov	r19,r2
81122e10:	10022c16 	blt	r2,zero,811236c4 <___vfiprintf_internal_r+0x10a8>
81122e14:	df001d83 	ldbu	fp,118(sp)
81122e18:	48007216 	blt	r9,zero,81122fe4 <___vfiprintf_internal_r+0x9c8>
81122e1c:	00ffdfc4 	movi	r3,-129
81122e20:	94c4b03a 	or	r2,r18,r19
81122e24:	a0e8703a 	and	r20,r20,r3
81122e28:	1000cc26 	beq	r2,zero,8112315c <___vfiprintf_internal_r+0xb40>
81122e2c:	98021026 	beq	r19,zero,81123670 <___vfiprintf_internal_r+0x1054>
81122e30:	dc402415 	stw	r17,144(sp)
81122e34:	dc002515 	stw	r16,148(sp)
81122e38:	9823883a 	mov	r17,r19
81122e3c:	9021883a 	mov	r16,r18
81122e40:	dd401a04 	addi	r21,sp,104
81122e44:	4825883a 	mov	r18,r9
81122e48:	4027883a 	mov	r19,r8
81122e4c:	8009883a 	mov	r4,r16
81122e50:	880b883a 	mov	r5,r17
81122e54:	01800284 	movi	r6,10
81122e58:	000f883a 	mov	r7,zero
81122e5c:	11255180 	call	81125518 <__umoddi3>
81122e60:	10800c04 	addi	r2,r2,48
81122e64:	ad7fffc4 	addi	r21,r21,-1
81122e68:	8009883a 	mov	r4,r16
81122e6c:	880b883a 	mov	r5,r17
81122e70:	a8800005 	stb	r2,0(r21)
81122e74:	01800284 	movi	r6,10
81122e78:	000f883a 	mov	r7,zero
81122e7c:	1124f980 	call	81124f98 <__udivdi3>
81122e80:	1021883a 	mov	r16,r2
81122e84:	10c4b03a 	or	r2,r2,r3
81122e88:	1823883a 	mov	r17,r3
81122e8c:	103fef1e 	bne	r2,zero,81122e4c <__reset+0xfb102e4c>
81122e90:	dc402417 	ldw	r17,144(sp)
81122e94:	dc002517 	ldw	r16,148(sp)
81122e98:	9013883a 	mov	r9,r18
81122e9c:	9811883a 	mov	r8,r19
81122ea0:	da801e17 	ldw	r10,120(sp)
81122ea4:	5567c83a 	sub	r19,r10,r21
81122ea8:	003ede06 	br	81122a24 <__reset+0xfb102a24>
81122eac:	38803fcc 	andi	r2,r7,255
81122eb0:	1080201c 	xori	r2,r2,128
81122eb4:	10bfe004 	addi	r2,r2,-128
81122eb8:	1002371e 	bne	r2,zero,81123798 <___vfiprintf_internal_r+0x117c>
81122ebc:	01000044 	movi	r4,1
81122ec0:	01c00804 	movi	r7,32
81122ec4:	80c00007 	ldb	r3,0(r16)
81122ec8:	003e3506 	br	811227a0 <__reset+0xfb1027a0>
81122ecc:	a5000054 	ori	r20,r20,1
81122ed0:	80c00007 	ldb	r3,0(r16)
81122ed4:	003e3206 	br	811227a0 <__reset+0xfb1027a0>
81122ed8:	a5002014 	ori	r20,r20,128
81122edc:	80c00007 	ldb	r3,0(r16)
81122ee0:	003e2f06 	br	811227a0 <__reset+0xfb1027a0>
81122ee4:	8015883a 	mov	r10,r16
81122ee8:	0023883a 	mov	r17,zero
81122eec:	18bff404 	addi	r2,r3,-48
81122ef0:	50c00007 	ldb	r3,0(r10)
81122ef4:	8c4002a4 	muli	r17,r17,10
81122ef8:	84000044 	addi	r16,r16,1
81122efc:	8015883a 	mov	r10,r16
81122f00:	1463883a 	add	r17,r2,r17
81122f04:	18bff404 	addi	r2,r3,-48
81122f08:	30bff92e 	bgeu	r6,r2,81122ef0 <__reset+0xfb102ef0>
81122f0c:	003e2506 	br	811227a4 <__reset+0xfb1027a4>
81122f10:	21003fcc 	andi	r4,r4,255
81122f14:	2002d41e 	bne	r4,zero,81123a68 <___vfiprintf_internal_r+0x144c>
81122f18:	a5000414 	ori	r20,r20,16
81122f1c:	a080080c 	andi	r2,r20,32
81122f20:	103fb51e 	bne	r2,zero,81122df8 <__reset+0xfb102df8>
81122f24:	a080040c 	andi	r2,r20,16
81122f28:	1001f826 	beq	r2,zero,8112370c <___vfiprintf_internal_r+0x10f0>
81122f2c:	da802217 	ldw	r10,136(sp)
81122f30:	54800017 	ldw	r18,0(r10)
81122f34:	52800104 	addi	r10,r10,4
81122f38:	da802215 	stw	r10,136(sp)
81122f3c:	9027d7fa 	srai	r19,r18,31
81122f40:	9805883a 	mov	r2,r19
81122f44:	003fb206 	br	81122e10 <__reset+0xfb102e10>
81122f48:	21003fcc 	andi	r4,r4,255
81122f4c:	2002c41e 	bne	r4,zero,81123a60 <___vfiprintf_internal_r+0x1444>
81122f50:	a5000414 	ori	r20,r20,16
81122f54:	a080080c 	andi	r2,r20,32
81122f58:	103f5f1e 	bne	r2,zero,81122cd8 <__reset+0xfb102cd8>
81122f5c:	a080040c 	andi	r2,r20,16
81122f60:	10020f26 	beq	r2,zero,811237a0 <___vfiprintf_internal_r+0x1184>
81122f64:	da802217 	ldw	r10,136(sp)
81122f68:	d8001d85 	stb	zero,118(sp)
81122f6c:	0027883a 	mov	r19,zero
81122f70:	50800104 	addi	r2,r10,4
81122f74:	54800017 	ldw	r18,0(r10)
81122f78:	48021116 	blt	r9,zero,811237c0 <___vfiprintf_internal_r+0x11a4>
81122f7c:	00ffdfc4 	movi	r3,-129
81122f80:	d8802215 	stw	r2,136(sp)
81122f84:	a0e8703a 	and	r20,r20,r3
81122f88:	903f5e1e 	bne	r18,zero,81122d04 <__reset+0xfb102d04>
81122f8c:	0039883a 	mov	fp,zero
81122f90:	4802a626 	beq	r9,zero,81123a2c <___vfiprintf_internal_r+0x1410>
81122f94:	0025883a 	mov	r18,zero
81122f98:	0027883a 	mov	r19,zero
81122f9c:	003f5a06 	br	81122d08 <__reset+0xfb102d08>
81122fa0:	21003fcc 	andi	r4,r4,255
81122fa4:	20029f1e 	bne	r4,zero,81123a24 <___vfiprintf_internal_r+0x1408>
81122fa8:	a5000414 	ori	r20,r20,16
81122fac:	a080080c 	andi	r2,r20,32
81122fb0:	10005e1e 	bne	r2,zero,8112312c <___vfiprintf_internal_r+0xb10>
81122fb4:	a080040c 	andi	r2,r20,16
81122fb8:	1001a21e 	bne	r2,zero,81123644 <___vfiprintf_internal_r+0x1028>
81122fbc:	a080100c 	andi	r2,r20,64
81122fc0:	d8001d85 	stb	zero,118(sp)
81122fc4:	da802217 	ldw	r10,136(sp)
81122fc8:	1002231e 	bne	r2,zero,81123858 <___vfiprintf_internal_r+0x123c>
81122fcc:	50800104 	addi	r2,r10,4
81122fd0:	54800017 	ldw	r18,0(r10)
81122fd4:	0027883a 	mov	r19,zero
81122fd8:	4801a00e 	bge	r9,zero,8112365c <___vfiprintf_internal_r+0x1040>
81122fdc:	d8802215 	stw	r2,136(sp)
81122fe0:	0039883a 	mov	fp,zero
81122fe4:	94c4b03a 	or	r2,r18,r19
81122fe8:	103f901e 	bne	r2,zero,81122e2c <__reset+0xfb102e2c>
81122fec:	00800044 	movi	r2,1
81122ff0:	10803fcc 	andi	r2,r2,255
81122ff4:	00c00044 	movi	r3,1
81122ff8:	10c05926 	beq	r2,r3,81123160 <___vfiprintf_internal_r+0xb44>
81122ffc:	00c00084 	movi	r3,2
81123000:	10ffe41e 	bne	r2,r3,81122f94 <__reset+0xfb102f94>
81123004:	0025883a 	mov	r18,zero
81123008:	0027883a 	mov	r19,zero
8112300c:	00013d06 	br	81123504 <___vfiprintf_internal_r+0xee8>
81123010:	21003fcc 	andi	r4,r4,255
81123014:	2002811e 	bne	r4,zero,81123a1c <___vfiprintf_internal_r+0x1400>
81123018:	00a04534 	movhi	r2,33044
8112301c:	10bda404 	addi	r2,r2,-2416
81123020:	d8802615 	stw	r2,152(sp)
81123024:	a080080c 	andi	r2,r20,32
81123028:	103f561e 	bne	r2,zero,81122d84 <__reset+0xfb102d84>
8112302c:	a080040c 	andi	r2,r20,16
81123030:	1001d126 	beq	r2,zero,81123778 <___vfiprintf_internal_r+0x115c>
81123034:	da802217 	ldw	r10,136(sp)
81123038:	0027883a 	mov	r19,zero
8112303c:	54800017 	ldw	r18,0(r10)
81123040:	52800104 	addi	r10,r10,4
81123044:	da802215 	stw	r10,136(sp)
81123048:	003f5306 	br	81122d98 <__reset+0xfb102d98>
8112304c:	da802217 	ldw	r10,136(sp)
81123050:	d8001d85 	stb	zero,118(sp)
81123054:	55400017 	ldw	r21,0(r10)
81123058:	50c00104 	addi	r3,r10,4
8112305c:	a8024226 	beq	r21,zero,81123968 <___vfiprintf_internal_r+0x134c>
81123060:	48021816 	blt	r9,zero,811238c4 <___vfiprintf_internal_r+0x12a8>
81123064:	480d883a 	mov	r6,r9
81123068:	000b883a 	mov	r5,zero
8112306c:	a809883a 	mov	r4,r21
81123070:	d8c02a15 	stw	r3,168(sp)
81123074:	da002b15 	stw	r8,172(sp)
81123078:	da402c15 	stw	r9,176(sp)
8112307c:	111d3f80 	call	8111d3f8 <memchr>
81123080:	d8c02a17 	ldw	r3,168(sp)
81123084:	da002b17 	ldw	r8,172(sp)
81123088:	da402c17 	ldw	r9,176(sp)
8112308c:	10024826 	beq	r2,zero,811239b0 <___vfiprintf_internal_r+0x1394>
81123090:	1567c83a 	sub	r19,r2,r21
81123094:	df001d83 	ldbu	fp,118(sp)
81123098:	d8c02215 	stw	r3,136(sp)
8112309c:	0013883a 	mov	r9,zero
811230a0:	003e6006 	br	81122a24 <__reset+0xfb102a24>
811230a4:	21003fcc 	andi	r4,r4,255
811230a8:	203fc026 	beq	r4,zero,81122fac <__reset+0xfb102fac>
811230ac:	d9c01d85 	stb	r7,118(sp)
811230b0:	003fbe06 	br	81122fac <__reset+0xfb102fac>
811230b4:	da802217 	ldw	r10,136(sp)
811230b8:	54400017 	ldw	r17,0(r10)
811230bc:	50800104 	addi	r2,r10,4
811230c0:	883e3b16 	blt	r17,zero,811229b0 <__reset+0xfb1029b0>
811230c4:	d8802215 	stw	r2,136(sp)
811230c8:	80c00007 	ldb	r3,0(r16)
811230cc:	003db406 	br	811227a0 <__reset+0xfb1027a0>
811230d0:	01000044 	movi	r4,1
811230d4:	01c00ac4 	movi	r7,43
811230d8:	80c00007 	ldb	r3,0(r16)
811230dc:	003db006 	br	811227a0 <__reset+0xfb1027a0>
811230e0:	80c00007 	ldb	r3,0(r16)
811230e4:	82800044 	addi	r10,r16,1
811230e8:	1b423c26 	beq	r3,r13,811239dc <___vfiprintf_internal_r+0x13c0>
811230ec:	18bff404 	addi	r2,r3,-48
811230f0:	0013883a 	mov	r9,zero
811230f4:	30822b36 	bltu	r6,r2,811239a4 <___vfiprintf_internal_r+0x1388>
811230f8:	50c00007 	ldb	r3,0(r10)
811230fc:	4a4002a4 	muli	r9,r9,10
81123100:	54000044 	addi	r16,r10,1
81123104:	8015883a 	mov	r10,r16
81123108:	4893883a 	add	r9,r9,r2
8112310c:	18bff404 	addi	r2,r3,-48
81123110:	30bff92e 	bgeu	r6,r2,811230f8 <__reset+0xfb1030f8>
81123114:	483da30e 	bge	r9,zero,811227a4 <__reset+0xfb1027a4>
81123118:	027fffc4 	movi	r9,-1
8112311c:	003da106 	br	811227a4 <__reset+0xfb1027a4>
81123120:	a5001014 	ori	r20,r20,64
81123124:	80c00007 	ldb	r3,0(r16)
81123128:	003d9d06 	br	811227a0 <__reset+0xfb1027a0>
8112312c:	da802217 	ldw	r10,136(sp)
81123130:	d8001d85 	stb	zero,118(sp)
81123134:	50c00204 	addi	r3,r10,8
81123138:	54800017 	ldw	r18,0(r10)
8112313c:	54c00117 	ldw	r19,4(r10)
81123140:	4801ca16 	blt	r9,zero,8112386c <___vfiprintf_internal_r+0x1250>
81123144:	013fdfc4 	movi	r4,-129
81123148:	94c4b03a 	or	r2,r18,r19
8112314c:	d8c02215 	stw	r3,136(sp)
81123150:	a128703a 	and	r20,r20,r4
81123154:	0039883a 	mov	fp,zero
81123158:	103f341e 	bne	r2,zero,81122e2c <__reset+0xfb102e2c>
8112315c:	483e2e26 	beq	r9,zero,81122a18 <__reset+0xfb102a18>
81123160:	0025883a 	mov	r18,zero
81123164:	94800c04 	addi	r18,r18,48
81123168:	dc8019c5 	stb	r18,103(sp)
8112316c:	dcc02717 	ldw	r19,156(sp)
81123170:	dd4019c4 	addi	r21,sp,103
81123174:	003e2b06 	br	81122a24 <__reset+0xfb102a24>
81123178:	21003fcc 	andi	r4,r4,255
8112317c:	2002361e 	bne	r4,zero,81123a58 <___vfiprintf_internal_r+0x143c>
81123180:	1801c126 	beq	r3,zero,81123888 <___vfiprintf_internal_r+0x126c>
81123184:	04800044 	movi	r18,1
81123188:	d8c01005 	stb	r3,64(sp)
8112318c:	d8001d85 	stb	zero,118(sp)
81123190:	9027883a 	mov	r19,r18
81123194:	dd401004 	addi	r21,sp,64
81123198:	003f1106 	br	81122de0 <__reset+0xfb102de0>
8112319c:	d9402117 	ldw	r5,132(sp)
811231a0:	d9002017 	ldw	r4,128(sp)
811231a4:	d9801a04 	addi	r6,sp,104
811231a8:	d9c02b15 	stw	r7,172(sp)
811231ac:	dbc02a15 	stw	r15,168(sp)
811231b0:	11225000 	call	81122500 <__sprint_r.part.0>
811231b4:	d9c02b17 	ldw	r7,172(sp)
811231b8:	dbc02a17 	ldw	r15,168(sp)
811231bc:	10006d1e 	bne	r2,zero,81123374 <___vfiprintf_internal_r+0xd58>
811231c0:	d9801b17 	ldw	r6,108(sp)
811231c4:	d8801c17 	ldw	r2,112(sp)
811231c8:	d811883a 	mov	r8,sp
811231cc:	31400044 	addi	r5,r6,1
811231d0:	003e3306 	br	81122aa0 <__reset+0xfb102aa0>
811231d4:	d9401b17 	ldw	r5,108(sp)
811231d8:	d8801c17 	ldw	r2,112(sp)
811231dc:	29000044 	addi	r4,r5,1
811231e0:	d8c01d87 	ldb	r3,118(sp)
811231e4:	183e4d26 	beq	r3,zero,81122b1c <__reset+0xfb102b1c>
811231e8:	00c00044 	movi	r3,1
811231ec:	d9401d84 	addi	r5,sp,118
811231f0:	10c5883a 	add	r2,r2,r3
811231f4:	41400015 	stw	r5,0(r8)
811231f8:	40c00115 	stw	r3,4(r8)
811231fc:	d8801c15 	stw	r2,112(sp)
81123200:	d9001b15 	stw	r4,108(sp)
81123204:	014001c4 	movi	r5,7
81123208:	2900a90e 	bge	r5,r4,811234b0 <___vfiprintf_internal_r+0xe94>
8112320c:	1000da1e 	bne	r2,zero,81123578 <___vfiprintf_internal_r+0xf5c>
81123210:	7000ab1e 	bne	r14,zero,811234c0 <___vfiprintf_internal_r+0xea4>
81123214:	000b883a 	mov	r5,zero
81123218:	1809883a 	mov	r4,r3
8112321c:	d811883a 	mov	r8,sp
81123220:	00c02004 	movi	r3,128
81123224:	e0fe4d26 	beq	fp,r3,81122b5c <__reset+0xfb102b5c>
81123228:	4cf9c83a 	sub	fp,r9,r19
8112322c:	073e7b0e 	bge	zero,fp,81122c1c <__reset+0xfb102c1c>
81123230:	01c00404 	movi	r7,16
81123234:	3f01900e 	bge	r7,fp,81123878 <___vfiprintf_internal_r+0x125c>
81123238:	00e04534 	movhi	r3,33044
8112323c:	18fe3b04 	addi	r3,r3,-1812
81123240:	d8c02415 	stw	r3,144(sp)
81123244:	034001c4 	movi	r13,7
81123248:	00000506 	br	81123260 <___vfiprintf_internal_r+0xc44>
8112324c:	29000084 	addi	r4,r5,2
81123250:	42000204 	addi	r8,r8,8
81123254:	180b883a 	mov	r5,r3
81123258:	e73ffc04 	addi	fp,fp,-16
8112325c:	3f000d0e 	bge	r7,fp,81123294 <___vfiprintf_internal_r+0xc78>
81123260:	10800404 	addi	r2,r2,16
81123264:	28c00044 	addi	r3,r5,1
81123268:	45c00015 	stw	r23,0(r8)
8112326c:	41c00115 	stw	r7,4(r8)
81123270:	d8801c15 	stw	r2,112(sp)
81123274:	d8c01b15 	stw	r3,108(sp)
81123278:	68fff40e 	bge	r13,r3,8112324c <__reset+0xfb10324c>
8112327c:	1000101e 	bne	r2,zero,811232c0 <___vfiprintf_internal_r+0xca4>
81123280:	e73ffc04 	addi	fp,fp,-16
81123284:	01000044 	movi	r4,1
81123288:	000b883a 	mov	r5,zero
8112328c:	d811883a 	mov	r8,sp
81123290:	3f3ff316 	blt	r7,fp,81123260 <__reset+0xfb103260>
81123294:	da802417 	ldw	r10,144(sp)
81123298:	1705883a 	add	r2,r2,fp
8112329c:	47000115 	stw	fp,4(r8)
811232a0:	42800015 	stw	r10,0(r8)
811232a4:	d8801c15 	stw	r2,112(sp)
811232a8:	d9001b15 	stw	r4,108(sp)
811232ac:	00c001c4 	movi	r3,7
811232b0:	19003616 	blt	r3,r4,8112338c <___vfiprintf_internal_r+0xd70>
811232b4:	42000204 	addi	r8,r8,8
811232b8:	21000044 	addi	r4,r4,1
811232bc:	003e5706 	br	81122c1c <__reset+0xfb102c1c>
811232c0:	d9402117 	ldw	r5,132(sp)
811232c4:	d9002017 	ldw	r4,128(sp)
811232c8:	d9801a04 	addi	r6,sp,104
811232cc:	d9c02b15 	stw	r7,172(sp)
811232d0:	db402a15 	stw	r13,168(sp)
811232d4:	11225000 	call	81122500 <__sprint_r.part.0>
811232d8:	d9c02b17 	ldw	r7,172(sp)
811232dc:	db402a17 	ldw	r13,168(sp)
811232e0:	1000241e 	bne	r2,zero,81123374 <___vfiprintf_internal_r+0xd58>
811232e4:	d9401b17 	ldw	r5,108(sp)
811232e8:	d8801c17 	ldw	r2,112(sp)
811232ec:	d811883a 	mov	r8,sp
811232f0:	29000044 	addi	r4,r5,1
811232f4:	003fd806 	br	81123258 <__reset+0xfb103258>
811232f8:	d9401b17 	ldw	r5,108(sp)
811232fc:	00e04534 	movhi	r3,33044
81123300:	18fe3f04 	addi	r3,r3,-1796
81123304:	d8c02415 	stw	r3,144(sp)
81123308:	29400044 	addi	r5,r5,1
8112330c:	d8c02417 	ldw	r3,144(sp)
81123310:	14c5883a 	add	r2,r2,r19
81123314:	44c00115 	stw	r19,4(r8)
81123318:	40c00015 	stw	r3,0(r8)
8112331c:	d8801c15 	stw	r2,112(sp)
81123320:	d9401b15 	stw	r5,108(sp)
81123324:	00c001c4 	movi	r3,7
81123328:	1940070e 	bge	r3,r5,81123348 <___vfiprintf_internal_r+0xd2c>
8112332c:	103e4826 	beq	r2,zero,81122c50 <__reset+0xfb102c50>
81123330:	d9402117 	ldw	r5,132(sp)
81123334:	d9002017 	ldw	r4,128(sp)
81123338:	d9801a04 	addi	r6,sp,104
8112333c:	11225000 	call	81122500 <__sprint_r.part.0>
81123340:	10000c1e 	bne	r2,zero,81123374 <___vfiprintf_internal_r+0xd58>
81123344:	d8801c17 	ldw	r2,112(sp)
81123348:	8c80010e 	bge	r17,r18,81123350 <___vfiprintf_internal_r+0xd34>
8112334c:	9023883a 	mov	r17,r18
81123350:	da802317 	ldw	r10,140(sp)
81123354:	5455883a 	add	r10,r10,r17
81123358:	da802315 	stw	r10,140(sp)
8112335c:	103e4126 	beq	r2,zero,81122c64 <__reset+0xfb102c64>
81123360:	d9402117 	ldw	r5,132(sp)
81123364:	d9002017 	ldw	r4,128(sp)
81123368:	d9801a04 	addi	r6,sp,104
8112336c:	11225000 	call	81122500 <__sprint_r.part.0>
81123370:	103e3c26 	beq	r2,zero,81122c64 <__reset+0xfb102c64>
81123374:	dd002117 	ldw	r20,132(sp)
81123378:	a080030b 	ldhu	r2,12(r20)
8112337c:	1080100c 	andi	r2,r2,64
81123380:	1001231e 	bne	r2,zero,81123810 <___vfiprintf_internal_r+0x11f4>
81123384:	d8802317 	ldw	r2,140(sp)
81123388:	003d7b06 	br	81122978 <__reset+0xfb102978>
8112338c:	1000991e 	bne	r2,zero,811235f4 <___vfiprintf_internal_r+0xfd8>
81123390:	00c00044 	movi	r3,1
81123394:	9805883a 	mov	r2,r19
81123398:	dd400015 	stw	r21,0(sp)
8112339c:	dcc00115 	stw	r19,4(sp)
811233a0:	dcc01c15 	stw	r19,112(sp)
811233a4:	d8c01b15 	stw	r3,108(sp)
811233a8:	d811883a 	mov	r8,sp
811233ac:	42000204 	addi	r8,r8,8
811233b0:	a2c0010c 	andi	r11,r20,4
811233b4:	583fe426 	beq	r11,zero,81123348 <__reset+0xfb103348>
811233b8:	8ca7c83a 	sub	r19,r17,r18
811233bc:	04ffe20e 	bge	zero,r19,81123348 <__reset+0xfb103348>
811233c0:	01c00404 	movi	r7,16
811233c4:	3cffcc0e 	bge	r7,r19,811232f8 <__reset+0xfb1032f8>
811233c8:	02a04534 	movhi	r10,33044
811233cc:	52be3f04 	addi	r10,r10,-1796
811233d0:	d9001b17 	ldw	r4,108(sp)
811233d4:	da802415 	stw	r10,144(sp)
811233d8:	382b883a 	mov	r21,r7
811233dc:	050001c4 	movi	r20,7
811233e0:	df002017 	ldw	fp,128(sp)
811233e4:	00000506 	br	811233fc <___vfiprintf_internal_r+0xde0>
811233e8:	21400084 	addi	r5,r4,2
811233ec:	42000204 	addi	r8,r8,8
811233f0:	1809883a 	mov	r4,r3
811233f4:	9cfffc04 	addi	r19,r19,-16
811233f8:	acffc40e 	bge	r21,r19,8112330c <__reset+0xfb10330c>
811233fc:	10800404 	addi	r2,r2,16
81123400:	20c00044 	addi	r3,r4,1
81123404:	45800015 	stw	r22,0(r8)
81123408:	45400115 	stw	r21,4(r8)
8112340c:	d8801c15 	stw	r2,112(sp)
81123410:	d8c01b15 	stw	r3,108(sp)
81123414:	a0fff40e 	bge	r20,r3,811233e8 <__reset+0xfb1033e8>
81123418:	1000041e 	bne	r2,zero,8112342c <___vfiprintf_internal_r+0xe10>
8112341c:	01400044 	movi	r5,1
81123420:	0009883a 	mov	r4,zero
81123424:	d811883a 	mov	r8,sp
81123428:	003ff206 	br	811233f4 <__reset+0xfb1033f4>
8112342c:	d9402117 	ldw	r5,132(sp)
81123430:	d9801a04 	addi	r6,sp,104
81123434:	e009883a 	mov	r4,fp
81123438:	11225000 	call	81122500 <__sprint_r.part.0>
8112343c:	103fcd1e 	bne	r2,zero,81123374 <__reset+0xfb103374>
81123440:	d9001b17 	ldw	r4,108(sp)
81123444:	d8801c17 	ldw	r2,112(sp)
81123448:	d811883a 	mov	r8,sp
8112344c:	21400044 	addi	r5,r4,1
81123450:	003fe806 	br	811233f4 <__reset+0xfb1033f4>
81123454:	d9402117 	ldw	r5,132(sp)
81123458:	d9002017 	ldw	r4,128(sp)
8112345c:	d9801a04 	addi	r6,sp,104
81123460:	d9c02b15 	stw	r7,172(sp)
81123464:	db402a15 	stw	r13,168(sp)
81123468:	11225000 	call	81122500 <__sprint_r.part.0>
8112346c:	d9c02b17 	ldw	r7,172(sp)
81123470:	db402a17 	ldw	r13,168(sp)
81123474:	103fbf1e 	bne	r2,zero,81123374 <__reset+0xfb103374>
81123478:	d9401b17 	ldw	r5,108(sp)
8112347c:	d8801c17 	ldw	r2,112(sp)
81123480:	d811883a 	mov	r8,sp
81123484:	29800044 	addi	r6,r5,1
81123488:	003dc406 	br	81122b9c <__reset+0xfb102b9c>
8112348c:	1000d21e 	bne	r2,zero,811237d8 <___vfiprintf_internal_r+0x11bc>
81123490:	d8c01d87 	ldb	r3,118(sp)
81123494:	18009526 	beq	r3,zero,811236ec <___vfiprintf_internal_r+0x10d0>
81123498:	00800044 	movi	r2,1
8112349c:	d8c01d84 	addi	r3,sp,118
811234a0:	1009883a 	mov	r4,r2
811234a4:	d8c00015 	stw	r3,0(sp)
811234a8:	d8800115 	stw	r2,4(sp)
811234ac:	d811883a 	mov	r8,sp
811234b0:	200b883a 	mov	r5,r4
811234b4:	42000204 	addi	r8,r8,8
811234b8:	21000044 	addi	r4,r4,1
811234bc:	003d9706 	br	81122b1c <__reset+0xfb102b1c>
811234c0:	d9001d04 	addi	r4,sp,116
811234c4:	00800084 	movi	r2,2
811234c8:	d9000015 	stw	r4,0(sp)
811234cc:	d8800115 	stw	r2,4(sp)
811234d0:	1809883a 	mov	r4,r3
811234d4:	d811883a 	mov	r8,sp
811234d8:	200b883a 	mov	r5,r4
811234dc:	42000204 	addi	r8,r8,8
811234e0:	21000044 	addi	r4,r4,1
811234e4:	003f4e06 	br	81123220 <__reset+0xfb103220>
811234e8:	d8001d85 	stb	zero,118(sp)
811234ec:	48005016 	blt	r9,zero,81123630 <___vfiprintf_internal_r+0x1014>
811234f0:	00ffdfc4 	movi	r3,-129
811234f4:	94c4b03a 	or	r2,r18,r19
811234f8:	a0e8703a 	and	r20,r20,r3
811234fc:	103d4426 	beq	r2,zero,81122a10 <__reset+0xfb102a10>
81123500:	0039883a 	mov	fp,zero
81123504:	d9002617 	ldw	r4,152(sp)
81123508:	dd401a04 	addi	r21,sp,104
8112350c:	908003cc 	andi	r2,r18,15
81123510:	9806973a 	slli	r3,r19,28
81123514:	2085883a 	add	r2,r4,r2
81123518:	9024d13a 	srli	r18,r18,4
8112351c:	10800003 	ldbu	r2,0(r2)
81123520:	9826d13a 	srli	r19,r19,4
81123524:	ad7fffc4 	addi	r21,r21,-1
81123528:	1ca4b03a 	or	r18,r3,r18
8112352c:	a8800005 	stb	r2,0(r21)
81123530:	94c4b03a 	or	r2,r18,r19
81123534:	103ff51e 	bne	r2,zero,8112350c <__reset+0xfb10350c>
81123538:	003e5906 	br	81122ea0 <__reset+0xfb102ea0>
8112353c:	d9402117 	ldw	r5,132(sp)
81123540:	d9002017 	ldw	r4,128(sp)
81123544:	d9801a04 	addi	r6,sp,104
81123548:	11225000 	call	81122500 <__sprint_r.part.0>
8112354c:	103f891e 	bne	r2,zero,81123374 <__reset+0xfb103374>
81123550:	d8801c17 	ldw	r2,112(sp)
81123554:	d811883a 	mov	r8,sp
81123558:	003f9506 	br	811233b0 <__reset+0xfb1033b0>
8112355c:	d9402117 	ldw	r5,132(sp)
81123560:	d9002017 	ldw	r4,128(sp)
81123564:	d9801a04 	addi	r6,sp,104
81123568:	11225000 	call	81122500 <__sprint_r.part.0>
8112356c:	103f811e 	bne	r2,zero,81123374 <__reset+0xfb103374>
81123570:	d811883a 	mov	r8,sp
81123574:	003ced06 	br	8112292c <__reset+0xfb10292c>
81123578:	d9402117 	ldw	r5,132(sp)
8112357c:	d9002017 	ldw	r4,128(sp)
81123580:	d9801a04 	addi	r6,sp,104
81123584:	da402c15 	stw	r9,176(sp)
81123588:	db802a15 	stw	r14,168(sp)
8112358c:	11225000 	call	81122500 <__sprint_r.part.0>
81123590:	da402c17 	ldw	r9,176(sp)
81123594:	db802a17 	ldw	r14,168(sp)
81123598:	103f761e 	bne	r2,zero,81123374 <__reset+0xfb103374>
8112359c:	d9401b17 	ldw	r5,108(sp)
811235a0:	d8801c17 	ldw	r2,112(sp)
811235a4:	d811883a 	mov	r8,sp
811235a8:	29000044 	addi	r4,r5,1
811235ac:	003d5b06 	br	81122b1c <__reset+0xfb102b1c>
811235b0:	d9402117 	ldw	r5,132(sp)
811235b4:	d9002017 	ldw	r4,128(sp)
811235b8:	d9801a04 	addi	r6,sp,104
811235bc:	da402c15 	stw	r9,176(sp)
811235c0:	11225000 	call	81122500 <__sprint_r.part.0>
811235c4:	da402c17 	ldw	r9,176(sp)
811235c8:	103f6a1e 	bne	r2,zero,81123374 <__reset+0xfb103374>
811235cc:	d9401b17 	ldw	r5,108(sp)
811235d0:	d8801c17 	ldw	r2,112(sp)
811235d4:	d811883a 	mov	r8,sp
811235d8:	29000044 	addi	r4,r5,1
811235dc:	003f1006 	br	81123220 <__reset+0xfb103220>
811235e0:	1000c31e 	bne	r2,zero,811238f0 <___vfiprintf_internal_r+0x12d4>
811235e4:	01000044 	movi	r4,1
811235e8:	000b883a 	mov	r5,zero
811235ec:	d811883a 	mov	r8,sp
811235f0:	003f0d06 	br	81123228 <__reset+0xfb103228>
811235f4:	d9402117 	ldw	r5,132(sp)
811235f8:	d9002017 	ldw	r4,128(sp)
811235fc:	d9801a04 	addi	r6,sp,104
81123600:	11225000 	call	81122500 <__sprint_r.part.0>
81123604:	103f5b1e 	bne	r2,zero,81123374 <__reset+0xfb103374>
81123608:	d9001b17 	ldw	r4,108(sp)
8112360c:	d8801c17 	ldw	r2,112(sp)
81123610:	d811883a 	mov	r8,sp
81123614:	21000044 	addi	r4,r4,1
81123618:	003d8006 	br	81122c1c <__reset+0xfb102c1c>
8112361c:	01204534 	movhi	r4,33044
81123620:	213da904 	addi	r4,r4,-2396
81123624:	d9002615 	stw	r4,152(sp)
81123628:	d8c02215 	stw	r3,136(sp)
8112362c:	1029883a 	mov	r20,r2
81123630:	94c4b03a 	or	r2,r18,r19
81123634:	103fb21e 	bne	r2,zero,81123500 <__reset+0xfb103500>
81123638:	0039883a 	mov	fp,zero
8112363c:	00800084 	movi	r2,2
81123640:	003e6b06 	br	81122ff0 <__reset+0xfb102ff0>
81123644:	da802217 	ldw	r10,136(sp)
81123648:	d8001d85 	stb	zero,118(sp)
8112364c:	0027883a 	mov	r19,zero
81123650:	50800104 	addi	r2,r10,4
81123654:	54800017 	ldw	r18,0(r10)
81123658:	483e6016 	blt	r9,zero,81122fdc <__reset+0xfb102fdc>
8112365c:	00ffdfc4 	movi	r3,-129
81123660:	d8802215 	stw	r2,136(sp)
81123664:	a0e8703a 	and	r20,r20,r3
81123668:	0039883a 	mov	fp,zero
8112366c:	903ebb26 	beq	r18,zero,8112315c <__reset+0xfb10315c>
81123670:	00800244 	movi	r2,9
81123674:	14bdee36 	bltu	r2,r18,81122e30 <__reset+0xfb102e30>
81123678:	003eba06 	br	81123164 <__reset+0xfb103164>
8112367c:	00800c04 	movi	r2,48
81123680:	d8c01d45 	stb	r3,117(sp)
81123684:	d8801d05 	stb	r2,116(sp)
81123688:	d8001d85 	stb	zero,118(sp)
8112368c:	a0c00094 	ori	r3,r20,2
81123690:	4800a916 	blt	r9,zero,81123938 <___vfiprintf_internal_r+0x131c>
81123694:	00bfdfc4 	movi	r2,-129
81123698:	a096703a 	and	r11,r20,r2
8112369c:	5d000094 	ori	r20,r11,2
811236a0:	0039883a 	mov	fp,zero
811236a4:	003f9706 	br	81123504 <__reset+0xfb103504>
811236a8:	8025883a 	mov	r18,r16
811236ac:	003c2e06 	br	81122768 <__reset+0xfb102768>
811236b0:	00a04534 	movhi	r2,33044
811236b4:	10bda904 	addi	r2,r2,-2396
811236b8:	0039883a 	mov	fp,zero
811236bc:	d8802615 	stw	r2,152(sp)
811236c0:	003f9006 	br	81123504 <__reset+0xfb103504>
811236c4:	04a5c83a 	sub	r18,zero,r18
811236c8:	07000b44 	movi	fp,45
811236cc:	9004c03a 	cmpne	r2,r18,zero
811236d0:	04e7c83a 	sub	r19,zero,r19
811236d4:	df001d85 	stb	fp,118(sp)
811236d8:	98a7c83a 	sub	r19,r19,r2
811236dc:	48009f16 	blt	r9,zero,8112395c <___vfiprintf_internal_r+0x1340>
811236e0:	00bfdfc4 	movi	r2,-129
811236e4:	a0a8703a 	and	r20,r20,r2
811236e8:	003dd006 	br	81122e2c <__reset+0xfb102e2c>
811236ec:	70004c26 	beq	r14,zero,81123820 <___vfiprintf_internal_r+0x1204>
811236f0:	00800084 	movi	r2,2
811236f4:	d8c01d04 	addi	r3,sp,116
811236f8:	d8c00015 	stw	r3,0(sp)
811236fc:	d8800115 	stw	r2,4(sp)
81123700:	01000044 	movi	r4,1
81123704:	d811883a 	mov	r8,sp
81123708:	003f7306 	br	811234d8 <__reset+0xfb1034d8>
8112370c:	a080100c 	andi	r2,r20,64
81123710:	da802217 	ldw	r10,136(sp)
81123714:	103e0626 	beq	r2,zero,81122f30 <__reset+0xfb102f30>
81123718:	5480000f 	ldh	r18,0(r10)
8112371c:	52800104 	addi	r10,r10,4
81123720:	da802215 	stw	r10,136(sp)
81123724:	9027d7fa 	srai	r19,r18,31
81123728:	9805883a 	mov	r2,r19
8112372c:	003db806 	br	81122e10 <__reset+0xfb102e10>
81123730:	a080040c 	andi	r2,r20,16
81123734:	1000091e 	bne	r2,zero,8112375c <___vfiprintf_internal_r+0x1140>
81123738:	a2c0100c 	andi	r11,r20,64
8112373c:	58000726 	beq	r11,zero,8112375c <___vfiprintf_internal_r+0x1140>
81123740:	da802217 	ldw	r10,136(sp)
81123744:	50800017 	ldw	r2,0(r10)
81123748:	52800104 	addi	r10,r10,4
8112374c:	da802215 	stw	r10,136(sp)
81123750:	da802317 	ldw	r10,140(sp)
81123754:	1280000d 	sth	r10,0(r2)
81123758:	003be706 	br	811226f8 <__reset+0xfb1026f8>
8112375c:	da802217 	ldw	r10,136(sp)
81123760:	50800017 	ldw	r2,0(r10)
81123764:	52800104 	addi	r10,r10,4
81123768:	da802215 	stw	r10,136(sp)
8112376c:	da802317 	ldw	r10,140(sp)
81123770:	12800015 	stw	r10,0(r2)
81123774:	003be006 	br	811226f8 <__reset+0xfb1026f8>
81123778:	a080100c 	andi	r2,r20,64
8112377c:	da802217 	ldw	r10,136(sp)
81123780:	10003026 	beq	r2,zero,81123844 <___vfiprintf_internal_r+0x1228>
81123784:	5480000b 	ldhu	r18,0(r10)
81123788:	52800104 	addi	r10,r10,4
8112378c:	0027883a 	mov	r19,zero
81123790:	da802215 	stw	r10,136(sp)
81123794:	003d8006 	br	81122d98 <__reset+0xfb102d98>
81123798:	80c00007 	ldb	r3,0(r16)
8112379c:	003c0006 	br	811227a0 <__reset+0xfb1027a0>
811237a0:	a080100c 	andi	r2,r20,64
811237a4:	d8001d85 	stb	zero,118(sp)
811237a8:	da802217 	ldw	r10,136(sp)
811237ac:	1000201e 	bne	r2,zero,81123830 <___vfiprintf_internal_r+0x1214>
811237b0:	50800104 	addi	r2,r10,4
811237b4:	54800017 	ldw	r18,0(r10)
811237b8:	0027883a 	mov	r19,zero
811237bc:	483def0e 	bge	r9,zero,81122f7c <__reset+0xfb102f7c>
811237c0:	94c6b03a 	or	r3,r18,r19
811237c4:	d8802215 	stw	r2,136(sp)
811237c8:	183d4e1e 	bne	r3,zero,81122d04 <__reset+0xfb102d04>
811237cc:	0039883a 	mov	fp,zero
811237d0:	0005883a 	mov	r2,zero
811237d4:	003e0606 	br	81122ff0 <__reset+0xfb102ff0>
811237d8:	d9402117 	ldw	r5,132(sp)
811237dc:	d9002017 	ldw	r4,128(sp)
811237e0:	d9801a04 	addi	r6,sp,104
811237e4:	da402c15 	stw	r9,176(sp)
811237e8:	db802a15 	stw	r14,168(sp)
811237ec:	11225000 	call	81122500 <__sprint_r.part.0>
811237f0:	da402c17 	ldw	r9,176(sp)
811237f4:	db802a17 	ldw	r14,168(sp)
811237f8:	103ede1e 	bne	r2,zero,81123374 <__reset+0xfb103374>
811237fc:	d9401b17 	ldw	r5,108(sp)
81123800:	d8801c17 	ldw	r2,112(sp)
81123804:	d811883a 	mov	r8,sp
81123808:	29000044 	addi	r4,r5,1
8112380c:	003e7406 	br	811231e0 <__reset+0xfb1031e0>
81123810:	00bfffc4 	movi	r2,-1
81123814:	003c5806 	br	81122978 <__reset+0xfb102978>
81123818:	d811883a 	mov	r8,sp
8112381c:	003ee806 	br	811233c0 <__reset+0xfb1033c0>
81123820:	000b883a 	mov	r5,zero
81123824:	01000044 	movi	r4,1
81123828:	d811883a 	mov	r8,sp
8112382c:	003e7c06 	br	81123220 <__reset+0xfb103220>
81123830:	50800104 	addi	r2,r10,4
81123834:	5480000b 	ldhu	r18,0(r10)
81123838:	0027883a 	mov	r19,zero
8112383c:	483dcf0e 	bge	r9,zero,81122f7c <__reset+0xfb102f7c>
81123840:	003fdf06 	br	811237c0 <__reset+0xfb1037c0>
81123844:	54800017 	ldw	r18,0(r10)
81123848:	52800104 	addi	r10,r10,4
8112384c:	0027883a 	mov	r19,zero
81123850:	da802215 	stw	r10,136(sp)
81123854:	003d5006 	br	81122d98 <__reset+0xfb102d98>
81123858:	50800104 	addi	r2,r10,4
8112385c:	5480000b 	ldhu	r18,0(r10)
81123860:	0027883a 	mov	r19,zero
81123864:	483f7d0e 	bge	r9,zero,8112365c <__reset+0xfb10365c>
81123868:	003ddc06 	br	81122fdc <__reset+0xfb102fdc>
8112386c:	d8c02215 	stw	r3,136(sp)
81123870:	0039883a 	mov	fp,zero
81123874:	003ddb06 	br	81122fe4 <__reset+0xfb102fe4>
81123878:	02a04534 	movhi	r10,33044
8112387c:	52be3b04 	addi	r10,r10,-1812
81123880:	da802415 	stw	r10,144(sp)
81123884:	003e8306 	br	81123294 <__reset+0xfb103294>
81123888:	d8801c17 	ldw	r2,112(sp)
8112388c:	dd002117 	ldw	r20,132(sp)
81123890:	103eb926 	beq	r2,zero,81123378 <__reset+0xfb103378>
81123894:	d9002017 	ldw	r4,128(sp)
81123898:	d9801a04 	addi	r6,sp,104
8112389c:	a00b883a 	mov	r5,r20
811238a0:	11225000 	call	81122500 <__sprint_r.part.0>
811238a4:	003eb406 	br	81123378 <__reset+0xfb103378>
811238a8:	80c00043 	ldbu	r3,1(r16)
811238ac:	a5000814 	ori	r20,r20,32
811238b0:	84000044 	addi	r16,r16,1
811238b4:	18c03fcc 	andi	r3,r3,255
811238b8:	18c0201c 	xori	r3,r3,128
811238bc:	18ffe004 	addi	r3,r3,-128
811238c0:	003bb706 	br	811227a0 <__reset+0xfb1027a0>
811238c4:	a809883a 	mov	r4,r21
811238c8:	d8c02a15 	stw	r3,168(sp)
811238cc:	da002b15 	stw	r8,172(sp)
811238d0:	111405c0 	call	8111405c <strlen>
811238d4:	d8c02a17 	ldw	r3,168(sp)
811238d8:	1027883a 	mov	r19,r2
811238dc:	df001d83 	ldbu	fp,118(sp)
811238e0:	d8c02215 	stw	r3,136(sp)
811238e4:	0013883a 	mov	r9,zero
811238e8:	da002b17 	ldw	r8,172(sp)
811238ec:	003c4d06 	br	81122a24 <__reset+0xfb102a24>
811238f0:	d9402117 	ldw	r5,132(sp)
811238f4:	d9002017 	ldw	r4,128(sp)
811238f8:	d9801a04 	addi	r6,sp,104
811238fc:	da402c15 	stw	r9,176(sp)
81123900:	11225000 	call	81122500 <__sprint_r.part.0>
81123904:	da402c17 	ldw	r9,176(sp)
81123908:	103e9a1e 	bne	r2,zero,81123374 <__reset+0xfb103374>
8112390c:	d9401b17 	ldw	r5,108(sp)
81123910:	d8801c17 	ldw	r2,112(sp)
81123914:	d811883a 	mov	r8,sp
81123918:	29000044 	addi	r4,r5,1
8112391c:	003e4206 	br	81123228 <__reset+0xfb103228>
81123920:	d9401b17 	ldw	r5,108(sp)
81123924:	01204534 	movhi	r4,33044
81123928:	213e3f04 	addi	r4,r4,-1796
8112392c:	d9002415 	stw	r4,144(sp)
81123930:	29400044 	addi	r5,r5,1
81123934:	003c6d06 	br	81122aec <__reset+0xfb102aec>
81123938:	0039883a 	mov	fp,zero
8112393c:	00800084 	movi	r2,2
81123940:	10803fcc 	andi	r2,r2,255
81123944:	01000044 	movi	r4,1
81123948:	11001e26 	beq	r2,r4,811239c4 <___vfiprintf_internal_r+0x13a8>
8112394c:	01000084 	movi	r4,2
81123950:	11001e1e 	bne	r2,r4,811239cc <___vfiprintf_internal_r+0x13b0>
81123954:	1829883a 	mov	r20,r3
81123958:	003eea06 	br	81123504 <__reset+0xfb103504>
8112395c:	a007883a 	mov	r3,r20
81123960:	00800044 	movi	r2,1
81123964:	003ff606 	br	81123940 <__reset+0xfb103940>
81123968:	00800184 	movi	r2,6
8112396c:	1240012e 	bgeu	r2,r9,81123974 <___vfiprintf_internal_r+0x1358>
81123970:	1013883a 	mov	r9,r2
81123974:	4827883a 	mov	r19,r9
81123978:	4825883a 	mov	r18,r9
8112397c:	48001516 	blt	r9,zero,811239d4 <___vfiprintf_internal_r+0x13b8>
81123980:	05604534 	movhi	r21,33044
81123984:	d8c02215 	stw	r3,136(sp)
81123988:	ad7dae04 	addi	r21,r21,-2376
8112398c:	003d1406 	br	81122de0 <__reset+0xfb102de0>
81123990:	02a04534 	movhi	r10,33044
81123994:	52be3b04 	addi	r10,r10,-1812
81123998:	da802415 	stw	r10,144(sp)
8112399c:	200d883a 	mov	r6,r4
811239a0:	003c9106 	br	81122be8 <__reset+0xfb102be8>
811239a4:	5021883a 	mov	r16,r10
811239a8:	0013883a 	mov	r9,zero
811239ac:	003b7d06 	br	811227a4 <__reset+0xfb1027a4>
811239b0:	4827883a 	mov	r19,r9
811239b4:	df001d83 	ldbu	fp,118(sp)
811239b8:	d8c02215 	stw	r3,136(sp)
811239bc:	0013883a 	mov	r9,zero
811239c0:	003c1806 	br	81122a24 <__reset+0xfb102a24>
811239c4:	1829883a 	mov	r20,r3
811239c8:	003d1806 	br	81122e2c <__reset+0xfb102e2c>
811239cc:	1829883a 	mov	r20,r3
811239d0:	003ccd06 	br	81122d08 <__reset+0xfb102d08>
811239d4:	0025883a 	mov	r18,zero
811239d8:	003fe906 	br	81123980 <__reset+0xfb103980>
811239dc:	d8802217 	ldw	r2,136(sp)
811239e0:	80c00043 	ldbu	r3,1(r16)
811239e4:	5021883a 	mov	r16,r10
811239e8:	12400017 	ldw	r9,0(r2)
811239ec:	10800104 	addi	r2,r2,4
811239f0:	d8802215 	stw	r2,136(sp)
811239f4:	483faf0e 	bge	r9,zero,811238b4 <__reset+0xfb1038b4>
811239f8:	18c03fcc 	andi	r3,r3,255
811239fc:	18c0201c 	xori	r3,r3,128
81123a00:	027fffc4 	movi	r9,-1
81123a04:	18ffe004 	addi	r3,r3,-128
81123a08:	003b6506 	br	811227a0 <__reset+0xfb1027a0>
81123a0c:	d9c01d85 	stb	r7,118(sp)
81123a10:	003ca006 	br	81122c94 <__reset+0xfb102c94>
81123a14:	d9c01d85 	stb	r7,118(sp)
81123a18:	003cad06 	br	81122cd0 <__reset+0xfb102cd0>
81123a1c:	d9c01d85 	stb	r7,118(sp)
81123a20:	003d7d06 	br	81123018 <__reset+0xfb103018>
81123a24:	d9c01d85 	stb	r7,118(sp)
81123a28:	003d5f06 	br	81122fa8 <__reset+0xfb102fa8>
81123a2c:	a080004c 	andi	r2,r20,1
81123a30:	0039883a 	mov	fp,zero
81123a34:	10000526 	beq	r2,zero,81123a4c <___vfiprintf_internal_r+0x1430>
81123a38:	00800c04 	movi	r2,48
81123a3c:	d88019c5 	stb	r2,103(sp)
81123a40:	dcc02717 	ldw	r19,156(sp)
81123a44:	dd4019c4 	addi	r21,sp,103
81123a48:	003bf606 	br	81122a24 <__reset+0xfb102a24>
81123a4c:	0027883a 	mov	r19,zero
81123a50:	dd401a04 	addi	r21,sp,104
81123a54:	003bf306 	br	81122a24 <__reset+0xfb102a24>
81123a58:	d9c01d85 	stb	r7,118(sp)
81123a5c:	003dc806 	br	81123180 <__reset+0xfb103180>
81123a60:	d9c01d85 	stb	r7,118(sp)
81123a64:	003d3a06 	br	81122f50 <__reset+0xfb102f50>
81123a68:	d9c01d85 	stb	r7,118(sp)
81123a6c:	003d2a06 	br	81122f18 <__reset+0xfb102f18>
81123a70:	d9c01d85 	stb	r7,118(sp)
81123a74:	003cde06 	br	81122df0 <__reset+0xfb102df0>
81123a78:	d9c01d85 	stb	r7,118(sp)
81123a7c:	003cbc06 	br	81122d70 <__reset+0xfb102d70>

81123a80 <__vfiprintf_internal>:
81123a80:	00a04534 	movhi	r2,33044
81123a84:	1086aa04 	addi	r2,r2,6824
81123a88:	300f883a 	mov	r7,r6
81123a8c:	280d883a 	mov	r6,r5
81123a90:	200b883a 	mov	r5,r4
81123a94:	11000017 	ldw	r4,0(r2)
81123a98:	112261c1 	jmpi	8112261c <___vfiprintf_internal_r>

81123a9c <__sbprintf>:
81123a9c:	defee204 	addi	sp,sp,-1144
81123aa0:	de00012e 	bgeu	sp,et,81123aa8 <__sbprintf+0xc>
81123aa4:	003b68fa 	trap	3
81123aa8:	2880030b 	ldhu	r2,12(r5)
81123aac:	2ac01917 	ldw	r11,100(r5)
81123ab0:	2a80038b 	ldhu	r10,14(r5)
81123ab4:	2a400717 	ldw	r9,28(r5)
81123ab8:	2a000917 	ldw	r8,36(r5)
81123abc:	00c10004 	movi	r3,1024
81123ac0:	dc011a15 	stw	r16,1128(sp)
81123ac4:	10bfff4c 	andi	r2,r2,65533
81123ac8:	2821883a 	mov	r16,r5
81123acc:	d8cb883a 	add	r5,sp,r3
81123ad0:	dc811c15 	stw	r18,1136(sp)
81123ad4:	dc411b15 	stw	r17,1132(sp)
81123ad8:	dfc11d15 	stw	ra,1140(sp)
81123adc:	2025883a 	mov	r18,r4
81123ae0:	d881030d 	sth	r2,1036(sp)
81123ae4:	dac11915 	stw	r11,1124(sp)
81123ae8:	da81038d 	sth	r10,1038(sp)
81123aec:	da410715 	stw	r9,1052(sp)
81123af0:	da010915 	stw	r8,1060(sp)
81123af4:	dec10015 	stw	sp,1024(sp)
81123af8:	dec10415 	stw	sp,1040(sp)
81123afc:	d8c10215 	stw	r3,1032(sp)
81123b00:	d8c10515 	stw	r3,1044(sp)
81123b04:	d8010615 	stw	zero,1048(sp)
81123b08:	112261c0 	call	8112261c <___vfiprintf_internal_r>
81123b0c:	1023883a 	mov	r17,r2
81123b10:	10000416 	blt	r2,zero,81123b24 <__sbprintf+0x88>
81123b14:	d9410004 	addi	r5,sp,1024
81123b18:	9009883a 	mov	r4,r18
81123b1c:	111bdd40 	call	8111bdd4 <_fflush_r>
81123b20:	10000d1e 	bne	r2,zero,81123b58 <__sbprintf+0xbc>
81123b24:	d881030b 	ldhu	r2,1036(sp)
81123b28:	1080100c 	andi	r2,r2,64
81123b2c:	10000326 	beq	r2,zero,81123b3c <__sbprintf+0xa0>
81123b30:	8080030b 	ldhu	r2,12(r16)
81123b34:	10801014 	ori	r2,r2,64
81123b38:	8080030d 	sth	r2,12(r16)
81123b3c:	8805883a 	mov	r2,r17
81123b40:	dfc11d17 	ldw	ra,1140(sp)
81123b44:	dc811c17 	ldw	r18,1136(sp)
81123b48:	dc411b17 	ldw	r17,1132(sp)
81123b4c:	dc011a17 	ldw	r16,1128(sp)
81123b50:	dec11e04 	addi	sp,sp,1144
81123b54:	f800283a 	ret
81123b58:	047fffc4 	movi	r17,-1
81123b5c:	003ff106 	br	81123b24 <__reset+0xfb103b24>

81123b60 <_calloc_r>:
81123b60:	298b383a 	mul	r5,r5,r6
81123b64:	defffe04 	addi	sp,sp,-8
81123b68:	de00012e 	bgeu	sp,et,81123b70 <_calloc_r+0x10>
81123b6c:	003b68fa 	trap	3
81123b70:	dfc00115 	stw	ra,4(sp)
81123b74:	dc000015 	stw	r16,0(sp)
81123b78:	1112ecc0 	call	81112ecc <_malloc_r>
81123b7c:	10002926 	beq	r2,zero,81123c24 <_calloc_r+0xc4>
81123b80:	11bfff17 	ldw	r6,-4(r2)
81123b84:	1021883a 	mov	r16,r2
81123b88:	00bfff04 	movi	r2,-4
81123b8c:	308c703a 	and	r6,r6,r2
81123b90:	00c00904 	movi	r3,36
81123b94:	308d883a 	add	r6,r6,r2
81123b98:	19801636 	bltu	r3,r6,81123bf4 <_calloc_r+0x94>
81123b9c:	008004c4 	movi	r2,19
81123ba0:	11800b2e 	bgeu	r2,r6,81123bd0 <_calloc_r+0x70>
81123ba4:	80000015 	stw	zero,0(r16)
81123ba8:	80000115 	stw	zero,4(r16)
81123bac:	008006c4 	movi	r2,27
81123bb0:	11801a2e 	bgeu	r2,r6,81123c1c <_calloc_r+0xbc>
81123bb4:	80000215 	stw	zero,8(r16)
81123bb8:	80000315 	stw	zero,12(r16)
81123bbc:	30c0151e 	bne	r6,r3,81123c14 <_calloc_r+0xb4>
81123bc0:	80000415 	stw	zero,16(r16)
81123bc4:	80800604 	addi	r2,r16,24
81123bc8:	80000515 	stw	zero,20(r16)
81123bcc:	00000106 	br	81123bd4 <_calloc_r+0x74>
81123bd0:	8005883a 	mov	r2,r16
81123bd4:	10000015 	stw	zero,0(r2)
81123bd8:	10000115 	stw	zero,4(r2)
81123bdc:	10000215 	stw	zero,8(r2)
81123be0:	8005883a 	mov	r2,r16
81123be4:	dfc00117 	ldw	ra,4(sp)
81123be8:	dc000017 	ldw	r16,0(sp)
81123bec:	dec00204 	addi	sp,sp,8
81123bf0:	f800283a 	ret
81123bf4:	000b883a 	mov	r5,zero
81123bf8:	8009883a 	mov	r4,r16
81123bfc:	11138300 	call	81113830 <memset>
81123c00:	8005883a 	mov	r2,r16
81123c04:	dfc00117 	ldw	ra,4(sp)
81123c08:	dc000017 	ldw	r16,0(sp)
81123c0c:	dec00204 	addi	sp,sp,8
81123c10:	f800283a 	ret
81123c14:	80800404 	addi	r2,r16,16
81123c18:	003fee06 	br	81123bd4 <__reset+0xfb103bd4>
81123c1c:	80800204 	addi	r2,r16,8
81123c20:	003fec06 	br	81123bd4 <__reset+0xfb103bd4>
81123c24:	0005883a 	mov	r2,zero
81123c28:	003fee06 	br	81123be4 <__reset+0xfb103be4>

81123c2c <_fclose_r>:
81123c2c:	28003b26 	beq	r5,zero,81123d1c <_fclose_r+0xf0>
81123c30:	defffc04 	addi	sp,sp,-16
81123c34:	de00012e 	bgeu	sp,et,81123c3c <_fclose_r+0x10>
81123c38:	003b68fa 	trap	3
81123c3c:	dc400115 	stw	r17,4(sp)
81123c40:	dc000015 	stw	r16,0(sp)
81123c44:	dfc00315 	stw	ra,12(sp)
81123c48:	dc800215 	stw	r18,8(sp)
81123c4c:	2023883a 	mov	r17,r4
81123c50:	2821883a 	mov	r16,r5
81123c54:	20000226 	beq	r4,zero,81123c60 <_fclose_r+0x34>
81123c58:	20800e17 	ldw	r2,56(r4)
81123c5c:	10002726 	beq	r2,zero,81123cfc <_fclose_r+0xd0>
81123c60:	8080030f 	ldh	r2,12(r16)
81123c64:	1000071e 	bne	r2,zero,81123c84 <_fclose_r+0x58>
81123c68:	0005883a 	mov	r2,zero
81123c6c:	dfc00317 	ldw	ra,12(sp)
81123c70:	dc800217 	ldw	r18,8(sp)
81123c74:	dc400117 	ldw	r17,4(sp)
81123c78:	dc000017 	ldw	r16,0(sp)
81123c7c:	dec00404 	addi	sp,sp,16
81123c80:	f800283a 	ret
81123c84:	800b883a 	mov	r5,r16
81123c88:	8809883a 	mov	r4,r17
81123c8c:	111bbb00 	call	8111bbb0 <__sflush_r>
81123c90:	1025883a 	mov	r18,r2
81123c94:	80800b17 	ldw	r2,44(r16)
81123c98:	10000426 	beq	r2,zero,81123cac <_fclose_r+0x80>
81123c9c:	81400717 	ldw	r5,28(r16)
81123ca0:	8809883a 	mov	r4,r17
81123ca4:	103ee83a 	callr	r2
81123ca8:	10001616 	blt	r2,zero,81123d04 <_fclose_r+0xd8>
81123cac:	8080030b 	ldhu	r2,12(r16)
81123cb0:	1080200c 	andi	r2,r2,128
81123cb4:	1000151e 	bne	r2,zero,81123d0c <_fclose_r+0xe0>
81123cb8:	81400c17 	ldw	r5,48(r16)
81123cbc:	28000526 	beq	r5,zero,81123cd4 <_fclose_r+0xa8>
81123cc0:	80801004 	addi	r2,r16,64
81123cc4:	28800226 	beq	r5,r2,81123cd0 <_fclose_r+0xa4>
81123cc8:	8809883a 	mov	r4,r17
81123ccc:	111c6680 	call	8111c668 <_free_r>
81123cd0:	80000c15 	stw	zero,48(r16)
81123cd4:	81401117 	ldw	r5,68(r16)
81123cd8:	28000326 	beq	r5,zero,81123ce8 <_fclose_r+0xbc>
81123cdc:	8809883a 	mov	r4,r17
81123ce0:	111c6680 	call	8111c668 <_free_r>
81123ce4:	80001115 	stw	zero,68(r16)
81123ce8:	111c1e00 	call	8111c1e0 <__sfp_lock_acquire>
81123cec:	8000030d 	sth	zero,12(r16)
81123cf0:	111c1e40 	call	8111c1e4 <__sfp_lock_release>
81123cf4:	9005883a 	mov	r2,r18
81123cf8:	003fdc06 	br	81123c6c <__reset+0xfb103c6c>
81123cfc:	111c1d00 	call	8111c1d0 <__sinit>
81123d00:	003fd706 	br	81123c60 <__reset+0xfb103c60>
81123d04:	04bfffc4 	movi	r18,-1
81123d08:	003fe806 	br	81123cac <__reset+0xfb103cac>
81123d0c:	81400417 	ldw	r5,16(r16)
81123d10:	8809883a 	mov	r4,r17
81123d14:	111c6680 	call	8111c668 <_free_r>
81123d18:	003fe706 	br	81123cb8 <__reset+0xfb103cb8>
81123d1c:	0005883a 	mov	r2,zero
81123d20:	f800283a 	ret

81123d24 <fclose>:
81123d24:	00a04534 	movhi	r2,33044
81123d28:	1086aa04 	addi	r2,r2,6824
81123d2c:	200b883a 	mov	r5,r4
81123d30:	11000017 	ldw	r4,0(r2)
81123d34:	1123c2c1 	jmpi	81123c2c <_fclose_r>

81123d38 <__fputwc>:
81123d38:	defff804 	addi	sp,sp,-32
81123d3c:	de00012e 	bgeu	sp,et,81123d44 <__fputwc+0xc>
81123d40:	003b68fa 	trap	3
81123d44:	dcc00415 	stw	r19,16(sp)
81123d48:	dc800315 	stw	r18,12(sp)
81123d4c:	dc000115 	stw	r16,4(sp)
81123d50:	dfc00715 	stw	ra,28(sp)
81123d54:	dd400615 	stw	r21,24(sp)
81123d58:	dd000515 	stw	r20,20(sp)
81123d5c:	dc400215 	stw	r17,8(sp)
81123d60:	2027883a 	mov	r19,r4
81123d64:	2825883a 	mov	r18,r5
81123d68:	3021883a 	mov	r16,r6
81123d6c:	111d0f80 	call	8111d0f8 <__locale_mb_cur_max>
81123d70:	00c00044 	movi	r3,1
81123d74:	10c03e26 	beq	r2,r3,81123e70 <__fputwc+0x138>
81123d78:	81c01704 	addi	r7,r16,92
81123d7c:	900d883a 	mov	r6,r18
81123d80:	d80b883a 	mov	r5,sp
81123d84:	9809883a 	mov	r4,r19
81123d88:	1124d1c0 	call	81124d1c <_wcrtomb_r>
81123d8c:	1029883a 	mov	r20,r2
81123d90:	00bfffc4 	movi	r2,-1
81123d94:	a0802026 	beq	r20,r2,81123e18 <__fputwc+0xe0>
81123d98:	d9400003 	ldbu	r5,0(sp)
81123d9c:	a0001c26 	beq	r20,zero,81123e10 <__fputwc+0xd8>
81123da0:	0023883a 	mov	r17,zero
81123da4:	05400284 	movi	r21,10
81123da8:	00000906 	br	81123dd0 <__fputwc+0x98>
81123dac:	80800017 	ldw	r2,0(r16)
81123db0:	11400005 	stb	r5,0(r2)
81123db4:	80c00017 	ldw	r3,0(r16)
81123db8:	18c00044 	addi	r3,r3,1
81123dbc:	80c00015 	stw	r3,0(r16)
81123dc0:	8c400044 	addi	r17,r17,1
81123dc4:	dc45883a 	add	r2,sp,r17
81123dc8:	8d00112e 	bgeu	r17,r20,81123e10 <__fputwc+0xd8>
81123dcc:	11400003 	ldbu	r5,0(r2)
81123dd0:	80c00217 	ldw	r3,8(r16)
81123dd4:	18ffffc4 	addi	r3,r3,-1
81123dd8:	80c00215 	stw	r3,8(r16)
81123ddc:	183ff30e 	bge	r3,zero,81123dac <__reset+0xfb103dac>
81123de0:	80800617 	ldw	r2,24(r16)
81123de4:	18801916 	blt	r3,r2,81123e4c <__fputwc+0x114>
81123de8:	80800017 	ldw	r2,0(r16)
81123dec:	11400005 	stb	r5,0(r2)
81123df0:	80800017 	ldw	r2,0(r16)
81123df4:	10c00003 	ldbu	r3,0(r2)
81123df8:	10800044 	addi	r2,r2,1
81123dfc:	1d402326 	beq	r3,r21,81123e8c <__fputwc+0x154>
81123e00:	80800015 	stw	r2,0(r16)
81123e04:	8c400044 	addi	r17,r17,1
81123e08:	dc45883a 	add	r2,sp,r17
81123e0c:	8d3fef36 	bltu	r17,r20,81123dcc <__reset+0xfb103dcc>
81123e10:	9005883a 	mov	r2,r18
81123e14:	00000406 	br	81123e28 <__fputwc+0xf0>
81123e18:	80c0030b 	ldhu	r3,12(r16)
81123e1c:	a005883a 	mov	r2,r20
81123e20:	18c01014 	ori	r3,r3,64
81123e24:	80c0030d 	sth	r3,12(r16)
81123e28:	dfc00717 	ldw	ra,28(sp)
81123e2c:	dd400617 	ldw	r21,24(sp)
81123e30:	dd000517 	ldw	r20,20(sp)
81123e34:	dcc00417 	ldw	r19,16(sp)
81123e38:	dc800317 	ldw	r18,12(sp)
81123e3c:	dc400217 	ldw	r17,8(sp)
81123e40:	dc000117 	ldw	r16,4(sp)
81123e44:	dec00804 	addi	sp,sp,32
81123e48:	f800283a 	ret
81123e4c:	800d883a 	mov	r6,r16
81123e50:	29403fcc 	andi	r5,r5,255
81123e54:	9809883a 	mov	r4,r19
81123e58:	1124bbc0 	call	81124bbc <__swbuf_r>
81123e5c:	10bfffe0 	cmpeqi	r2,r2,-1
81123e60:	10803fcc 	andi	r2,r2,255
81123e64:	103fd626 	beq	r2,zero,81123dc0 <__reset+0xfb103dc0>
81123e68:	00bfffc4 	movi	r2,-1
81123e6c:	003fee06 	br	81123e28 <__reset+0xfb103e28>
81123e70:	90ffffc4 	addi	r3,r18,-1
81123e74:	01003f84 	movi	r4,254
81123e78:	20ffbf36 	bltu	r4,r3,81123d78 <__reset+0xfb103d78>
81123e7c:	900b883a 	mov	r5,r18
81123e80:	dc800005 	stb	r18,0(sp)
81123e84:	1029883a 	mov	r20,r2
81123e88:	003fc506 	br	81123da0 <__reset+0xfb103da0>
81123e8c:	800d883a 	mov	r6,r16
81123e90:	a80b883a 	mov	r5,r21
81123e94:	9809883a 	mov	r4,r19
81123e98:	1124bbc0 	call	81124bbc <__swbuf_r>
81123e9c:	10bfffe0 	cmpeqi	r2,r2,-1
81123ea0:	003fef06 	br	81123e60 <__reset+0xfb103e60>

81123ea4 <_fputwc_r>:
81123ea4:	3080030b 	ldhu	r2,12(r6)
81123ea8:	10c8000c 	andi	r3,r2,8192
81123eac:	1800051e 	bne	r3,zero,81123ec4 <_fputwc_r+0x20>
81123eb0:	30c01917 	ldw	r3,100(r6)
81123eb4:	10880014 	ori	r2,r2,8192
81123eb8:	3080030d 	sth	r2,12(r6)
81123ebc:	18880014 	ori	r2,r3,8192
81123ec0:	30801915 	stw	r2,100(r6)
81123ec4:	1123d381 	jmpi	81123d38 <__fputwc>

81123ec8 <fputwc>:
81123ec8:	00a04534 	movhi	r2,33044
81123ecc:	defffc04 	addi	sp,sp,-16
81123ed0:	1086aa04 	addi	r2,r2,6824
81123ed4:	de00012e 	bgeu	sp,et,81123edc <fputwc+0x14>
81123ed8:	003b68fa 	trap	3
81123edc:	dc000115 	stw	r16,4(sp)
81123ee0:	14000017 	ldw	r16,0(r2)
81123ee4:	dc400215 	stw	r17,8(sp)
81123ee8:	dfc00315 	stw	ra,12(sp)
81123eec:	2023883a 	mov	r17,r4
81123ef0:	80000226 	beq	r16,zero,81123efc <fputwc+0x34>
81123ef4:	80800e17 	ldw	r2,56(r16)
81123ef8:	10001026 	beq	r2,zero,81123f3c <fputwc+0x74>
81123efc:	2880030b 	ldhu	r2,12(r5)
81123f00:	10c8000c 	andi	r3,r2,8192
81123f04:	1800051e 	bne	r3,zero,81123f1c <fputwc+0x54>
81123f08:	28c01917 	ldw	r3,100(r5)
81123f0c:	10880014 	ori	r2,r2,8192
81123f10:	2880030d 	sth	r2,12(r5)
81123f14:	18880014 	ori	r2,r3,8192
81123f18:	28801915 	stw	r2,100(r5)
81123f1c:	280d883a 	mov	r6,r5
81123f20:	8009883a 	mov	r4,r16
81123f24:	880b883a 	mov	r5,r17
81123f28:	dfc00317 	ldw	ra,12(sp)
81123f2c:	dc400217 	ldw	r17,8(sp)
81123f30:	dc000117 	ldw	r16,4(sp)
81123f34:	dec00404 	addi	sp,sp,16
81123f38:	1123d381 	jmpi	81123d38 <__fputwc>
81123f3c:	8009883a 	mov	r4,r16
81123f40:	d9400015 	stw	r5,0(sp)
81123f44:	111c1d00 	call	8111c1d0 <__sinit>
81123f48:	d9400017 	ldw	r5,0(sp)
81123f4c:	003feb06 	br	81123efc <__reset+0xfb103efc>

81123f50 <rshift>:
81123f50:	2807d17a 	srai	r3,r5,5
81123f54:	20800417 	ldw	r2,16(r4)
81123f58:	22000504 	addi	r8,r4,20
81123f5c:	1880250e 	bge	r3,r2,81123ff4 <rshift+0xa4>
81123f60:	1085883a 	add	r2,r2,r2
81123f64:	18c7883a 	add	r3,r3,r3
81123f68:	1085883a 	add	r2,r2,r2
81123f6c:	18c7883a 	add	r3,r3,r3
81123f70:	294007cc 	andi	r5,r5,31
81123f74:	4085883a 	add	r2,r8,r2
81123f78:	40c7883a 	add	r3,r8,r3
81123f7c:	28002026 	beq	r5,zero,81124000 <rshift+0xb0>
81123f80:	19800017 	ldw	r6,0(r3)
81123f84:	02c00804 	movi	r11,32
81123f88:	19c00104 	addi	r7,r3,4
81123f8c:	5957c83a 	sub	r11,r11,r5
81123f90:	314cd83a 	srl	r6,r6,r5
81123f94:	38802c2e 	bgeu	r7,r2,81124048 <rshift+0xf8>
81123f98:	4015883a 	mov	r10,r8
81123f9c:	3a400017 	ldw	r9,0(r7)
81123fa0:	52800104 	addi	r10,r10,4
81123fa4:	39c00104 	addi	r7,r7,4
81123fa8:	4ad2983a 	sll	r9,r9,r11
81123fac:	498cb03a 	or	r6,r9,r6
81123fb0:	51bfff15 	stw	r6,-4(r10)
81123fb4:	39bfff17 	ldw	r6,-4(r7)
81123fb8:	314cd83a 	srl	r6,r6,r5
81123fbc:	38bff736 	bltu	r7,r2,81123f9c <__reset+0xfb103f9c>
81123fc0:	10c7c83a 	sub	r3,r2,r3
81123fc4:	18fffec4 	addi	r3,r3,-5
81123fc8:	1806d0ba 	srli	r3,r3,2
81123fcc:	18c00044 	addi	r3,r3,1
81123fd0:	18c7883a 	add	r3,r3,r3
81123fd4:	18c7883a 	add	r3,r3,r3
81123fd8:	40c7883a 	add	r3,r8,r3
81123fdc:	19800015 	stw	r6,0(r3)
81123fe0:	30000126 	beq	r6,zero,81123fe8 <rshift+0x98>
81123fe4:	18c00104 	addi	r3,r3,4
81123fe8:	1a05c83a 	sub	r2,r3,r8
81123fec:	1005d0ba 	srai	r2,r2,2
81123ff0:	00001206 	br	8112403c <rshift+0xec>
81123ff4:	20000415 	stw	zero,16(r4)
81123ff8:	20000515 	stw	zero,20(r4)
81123ffc:	f800283a 	ret
81124000:	18bffc2e 	bgeu	r3,r2,81123ff4 <__reset+0xfb103ff4>
81124004:	180d883a 	mov	r6,r3
81124008:	400b883a 	mov	r5,r8
8112400c:	31c00017 	ldw	r7,0(r6)
81124010:	29400104 	addi	r5,r5,4
81124014:	31800104 	addi	r6,r6,4
81124018:	29ffff15 	stw	r7,-4(r5)
8112401c:	30bffb36 	bltu	r6,r2,8112400c <__reset+0xfb10400c>
81124020:	00c6303a 	nor	r3,zero,r3
81124024:	1885883a 	add	r2,r3,r2
81124028:	1004d0ba 	srli	r2,r2,2
8112402c:	10800044 	addi	r2,r2,1
81124030:	1085883a 	add	r2,r2,r2
81124034:	1085883a 	add	r2,r2,r2
81124038:	1005d0ba 	srai	r2,r2,2
8112403c:	20800415 	stw	r2,16(r4)
81124040:	103fed26 	beq	r2,zero,81123ff8 <__reset+0xfb103ff8>
81124044:	f800283a 	ret
81124048:	4007883a 	mov	r3,r8
8112404c:	003fe306 	br	81123fdc <__reset+0xfb103fdc>

81124050 <__gethex>:
81124050:	deffeb04 	addi	sp,sp,-84
81124054:	de00012e 	bgeu	sp,et,8112405c <__gethex+0xc>
81124058:	003b68fa 	trap	3
8112405c:	dfc01415 	stw	ra,80(sp)
81124060:	dd801115 	stw	r22,68(sp)
81124064:	dcc00e15 	stw	r19,56(sp)
81124068:	dc800d15 	stw	r18,52(sp)
8112406c:	2827883a 	mov	r19,r5
81124070:	d9000115 	stw	r4,4(sp)
81124074:	d9800015 	stw	r6,0(sp)
81124078:	d9c00415 	stw	r7,16(sp)
8112407c:	df001315 	stw	fp,76(sp)
81124080:	ddc01215 	stw	r23,72(sp)
81124084:	dd401015 	stw	r21,64(sp)
81124088:	dd000f15 	stw	r20,60(sp)
8112408c:	dc400c15 	stw	r17,48(sp)
81124090:	dc000b15 	stw	r16,44(sp)
81124094:	111d11c0 	call	8111d11c <_localeconv_r>
81124098:	14800017 	ldw	r18,0(r2)
8112409c:	9009883a 	mov	r4,r18
811240a0:	111405c0 	call	8111405c <strlen>
811240a4:	98c00017 	ldw	r3,0(r19)
811240a8:	102d883a 	mov	r22,r2
811240ac:	9085883a 	add	r2,r18,r2
811240b0:	10bfffc3 	ldbu	r2,-1(r2)
811240b4:	19000083 	ldbu	r4,2(r3)
811240b8:	d8800305 	stb	r2,12(sp)
811240bc:	00800c04 	movi	r2,48
811240c0:	2081521e 	bne	r4,r2,8112460c <__gethex+0x5bc>
811240c4:	017fff84 	movi	r5,-2
811240c8:	188000c4 	addi	r2,r3,3
811240cc:	28cbc83a 	sub	r5,r5,r3
811240d0:	200d883a 	mov	r6,r4
811240d4:	28a3883a 	add	r17,r5,r2
811240d8:	102b883a 	mov	r21,r2
811240dc:	10800044 	addi	r2,r2,1
811240e0:	113fffc3 	ldbu	r4,-1(r2)
811240e4:	21bffb26 	beq	r4,r6,811240d4 <__reset+0xfb1040d4>
811240e8:	05204534 	movhi	r20,33044
811240ec:	a53e4304 	addi	r20,r20,-1780
811240f0:	a109883a 	add	r4,r20,r4
811240f4:	20800003 	ldbu	r2,0(r4)
811240f8:	10008826 	beq	r2,zero,8112431c <__gethex+0x2cc>
811240fc:	a8800003 	ldbu	r2,0(r21)
81124100:	0015883a 	mov	r10,zero
81124104:	002f883a 	mov	r23,zero
81124108:	a085883a 	add	r2,r20,r2
8112410c:	10800003 	ldbu	r2,0(r2)
81124110:	a821883a 	mov	r16,r21
81124114:	10000526 	beq	r2,zero,8112412c <__gethex+0xdc>
81124118:	84000044 	addi	r16,r16,1
8112411c:	80800003 	ldbu	r2,0(r16)
81124120:	a085883a 	add	r2,r20,r2
81124124:	10800003 	ldbu	r2,0(r2)
81124128:	103ffb1e 	bne	r2,zero,81124118 <__reset+0xfb104118>
8112412c:	b00d883a 	mov	r6,r22
81124130:	900b883a 	mov	r5,r18
81124134:	8009883a 	mov	r4,r16
81124138:	da800a15 	stw	r10,40(sp)
8112413c:	1124aec0 	call	81124aec <strncmp>
81124140:	da800a17 	ldw	r10,40(sp)
81124144:	1000031e 	bne	r2,zero,81124154 <__gethex+0x104>
81124148:	b8015226 	beq	r23,zero,81124694 <__gethex+0x644>
8112414c:	80800003 	ldbu	r2,0(r16)
81124150:	00000206 	br	8112415c <__gethex+0x10c>
81124154:	80800003 	ldbu	r2,0(r16)
81124158:	b8011f26 	beq	r23,zero,811245d8 <__gethex+0x588>
8112415c:	85efc83a 	sub	r23,r16,r23
81124160:	bdef883a 	add	r23,r23,r23
81124164:	bdef883a 	add	r23,r23,r23
81124168:	05efc83a 	sub	r23,zero,r23
8112416c:	10803fcc 	andi	r2,r2,255
81124170:	01001404 	movi	r4,80
81124174:	11008626 	beq	r2,r4,81124390 <__gethex+0x340>
81124178:	01001c04 	movi	r4,112
8112417c:	11008426 	beq	r2,r4,81124390 <__gethex+0x340>
81124180:	8039883a 	mov	fp,r16
81124184:	9c000015 	stw	r16,0(r19)
81124188:	5000711e 	bne	r10,zero,81124350 <__gethex+0x300>
8112418c:	e545c83a 	sub	r2,fp,r21
81124190:	10bfffc4 	addi	r2,r2,-1
81124194:	010001c4 	movi	r4,7
81124198:	000b883a 	mov	r5,zero
8112419c:	2080030e 	bge	r4,r2,811241ac <__gethex+0x15c>
811241a0:	1005d07a 	srai	r2,r2,1
811241a4:	29400044 	addi	r5,r5,1
811241a8:	20bffd16 	blt	r4,r2,811241a0 <__reset+0xfb1041a0>
811241ac:	d9000117 	ldw	r4,4(sp)
811241b0:	111d6380 	call	8111d638 <_Balloc>
811241b4:	10c00504 	addi	r3,r2,20
811241b8:	d8c00215 	stw	r3,8(sp)
811241bc:	1021883a 	mov	r16,r2
811241c0:	af01732e 	bgeu	r21,fp,81124790 <__gethex+0x740>
811241c4:	dc400303 	ldbu	r17,12(sp)
811241c8:	03400044 	movi	r13,1
811241cc:	1815883a 	mov	r10,r3
811241d0:	0013883a 	mov	r9,zero
811241d4:	0027883a 	mov	r19,zero
811241d8:	6d9bc83a 	sub	r13,r13,r22
811241dc:	02c00804 	movi	r11,32
811241e0:	e0bfffc3 	ldbu	r2,-1(fp)
811241e4:	e3bfffc4 	addi	r14,fp,-1
811241e8:	88803026 	beq	r17,r2,811242ac <__gethex+0x25c>
811241ec:	9ac04526 	beq	r19,r11,81124304 <__gethex+0x2b4>
811241f0:	980b883a 	mov	r5,r19
811241f4:	9cc00104 	addi	r19,r19,4
811241f8:	e13fffc3 	ldbu	r4,-1(fp)
811241fc:	7039883a 	mov	fp,r14
81124200:	a109883a 	add	r4,r20,r4
81124204:	20800003 	ldbu	r2,0(r4)
81124208:	108003cc 	andi	r2,r2,15
8112420c:	1144983a 	sll	r2,r2,r5
81124210:	4892b03a 	or	r9,r9,r2
81124214:	af3ff236 	bltu	r21,fp,811241e0 <__reset+0xfb1041e0>
81124218:	d8c00217 	ldw	r3,8(sp)
8112421c:	50800104 	addi	r2,r10,4
81124220:	52400015 	stw	r9,0(r10)
81124224:	10c5c83a 	sub	r2,r2,r3
81124228:	1005d0ba 	srai	r2,r2,2
8112422c:	4809883a 	mov	r4,r9
81124230:	80800415 	stw	r2,16(r16)
81124234:	1022917a 	slli	r17,r2,5
81124238:	111d9440 	call	8111d944 <__hi0bits>
8112423c:	d8c00017 	ldw	r3,0(sp)
81124240:	8885c83a 	sub	r2,r17,r2
81124244:	1c800017 	ldw	r18,0(r3)
81124248:	9080c716 	blt	r18,r2,81124568 <__gethex+0x518>
8112424c:	1480e416 	blt	r2,r18,811245e0 <__gethex+0x590>
81124250:	0027883a 	mov	r19,zero
81124254:	d8c00017 	ldw	r3,0(sp)
81124258:	18800217 	ldw	r2,8(r3)
8112425c:	15c08d16 	blt	r2,r23,81124494 <__gethex+0x444>
81124260:	d8c00017 	ldw	r3,0(sp)
81124264:	18800117 	ldw	r2,4(r3)
81124268:	b880aa0e 	bge	r23,r2,81124514 <__gethex+0x4c4>
8112426c:	15efc83a 	sub	r23,r2,r23
81124270:	bc80ed16 	blt	r23,r18,81124628 <__gethex+0x5d8>
81124274:	18c00317 	ldw	r3,12(r3)
81124278:	01000084 	movi	r4,2
8112427c:	19014926 	beq	r3,r4,811247a4 <__gethex+0x754>
81124280:	010000c4 	movi	r4,3
81124284:	19012e26 	beq	r3,r4,81124740 <__gethex+0x6f0>
81124288:	01000044 	movi	r4,1
8112428c:	19014826 	beq	r3,r4,811247b0 <__gethex+0x760>
81124290:	d9000117 	ldw	r4,4(sp)
81124294:	800b883a 	mov	r5,r16
81124298:	111d6e80 	call	8111d6e8 <_Bfree>
8112429c:	d8801517 	ldw	r2,84(sp)
811242a0:	10000015 	stw	zero,0(r2)
811242a4:	00801404 	movi	r2,80
811242a8:	00002b06 	br	81124358 <__gethex+0x308>
811242ac:	735f883a 	add	r15,r14,r13
811242b0:	7d7fce36 	bltu	r15,r21,811241ec <__reset+0xfb1041ec>
811242b4:	7809883a 	mov	r4,r15
811242b8:	b00d883a 	mov	r6,r22
811242bc:	900b883a 	mov	r5,r18
811242c0:	da400515 	stw	r9,20(sp)
811242c4:	da800a15 	stw	r10,40(sp)
811242c8:	dac00915 	stw	r11,36(sp)
811242cc:	db400815 	stw	r13,32(sp)
811242d0:	db800615 	stw	r14,24(sp)
811242d4:	dbc00715 	stw	r15,28(sp)
811242d8:	1124aec0 	call	81124aec <strncmp>
811242dc:	da400517 	ldw	r9,20(sp)
811242e0:	da800a17 	ldw	r10,40(sp)
811242e4:	dac00917 	ldw	r11,36(sp)
811242e8:	db400817 	ldw	r13,32(sp)
811242ec:	db800617 	ldw	r14,24(sp)
811242f0:	dbc00717 	ldw	r15,28(sp)
811242f4:	103fbd1e 	bne	r2,zero,811241ec <__reset+0xfb1041ec>
811242f8:	7839883a 	mov	fp,r15
811242fc:	af3fb836 	bltu	r21,fp,811241e0 <__reset+0xfb1041e0>
81124300:	003fc506 	br	81124218 <__reset+0xfb104218>
81124304:	04c00104 	movi	r19,4
81124308:	52400015 	stw	r9,0(r10)
8112430c:	000b883a 	mov	r5,zero
81124310:	54d5883a 	add	r10,r10,r19
81124314:	0013883a 	mov	r9,zero
81124318:	003fb706 	br	811241f8 <__reset+0xfb1041f8>
8112431c:	b00d883a 	mov	r6,r22
81124320:	900b883a 	mov	r5,r18
81124324:	a809883a 	mov	r4,r21
81124328:	1124aec0 	call	81124aec <strncmp>
8112432c:	10006426 	beq	r2,zero,811244c0 <__gethex+0x470>
81124330:	a8800003 	ldbu	r2,0(r21)
81124334:	a821883a 	mov	r16,r21
81124338:	10803fcc 	andi	r2,r2,255
8112433c:	01001404 	movi	r4,80
81124340:	11001126 	beq	r2,r4,81124388 <__gethex+0x338>
81124344:	01001c04 	movi	r4,112
81124348:	11000f26 	beq	r2,r4,81124388 <__gethex+0x338>
8112434c:	9c000015 	stw	r16,0(r19)
81124350:	8800831e 	bne	r17,zero,81124560 <__gethex+0x510>
81124354:	00800184 	movi	r2,6
81124358:	dfc01417 	ldw	ra,80(sp)
8112435c:	df001317 	ldw	fp,76(sp)
81124360:	ddc01217 	ldw	r23,72(sp)
81124364:	dd801117 	ldw	r22,68(sp)
81124368:	dd401017 	ldw	r21,64(sp)
8112436c:	dd000f17 	ldw	r20,60(sp)
81124370:	dcc00e17 	ldw	r19,56(sp)
81124374:	dc800d17 	ldw	r18,52(sp)
81124378:	dc400c17 	ldw	r17,48(sp)
8112437c:	dc000b17 	ldw	r16,44(sp)
81124380:	dec01504 	addi	sp,sp,84
81124384:	f800283a 	ret
81124388:	002f883a 	mov	r23,zero
8112438c:	02800044 	movi	r10,1
81124390:	80800043 	ldbu	r2,1(r16)
81124394:	01400ac4 	movi	r5,43
81124398:	11003fcc 	andi	r4,r2,255
8112439c:	21406e26 	beq	r4,r5,81124558 <__gethex+0x508>
811243a0:	01400b44 	movi	r5,45
811243a4:	21404226 	beq	r4,r5,811244b0 <__gethex+0x460>
811243a8:	81400044 	addi	r5,r16,1
811243ac:	000d883a 	mov	r6,zero
811243b0:	10803fcc 	andi	r2,r2,255
811243b4:	a085883a 	add	r2,r20,r2
811243b8:	11000003 	ldbu	r4,0(r2)
811243bc:	03000604 	movi	r12,24
811243c0:	20bfffc4 	addi	r2,r4,-1
811243c4:	10803fcc 	andi	r2,r2,255
811243c8:	60bf6d36 	bltu	r12,r2,81124180 <__reset+0xfb104180>
811243cc:	2ac00043 	ldbu	r11,1(r5)
811243d0:	20803fcc 	andi	r2,r4,255
811243d4:	01204534 	movhi	r4,33044
811243d8:	213e4304 	addi	r4,r4,-1780
811243dc:	22c9883a 	add	r4,r4,r11
811243e0:	23400003 	ldbu	r13,0(r4)
811243e4:	10bffc04 	addi	r2,r2,-16
811243e8:	29400044 	addi	r5,r5,1
811243ec:	693fffc4 	addi	r4,r13,-1
811243f0:	21003fcc 	andi	r4,r4,255
811243f4:	6b403fcc 	andi	r13,r13,255
811243f8:	61000b36 	bltu	r12,r4,81124428 <__gethex+0x3d8>
811243fc:	29400044 	addi	r5,r5,1
81124400:	29000003 	ldbu	r4,0(r5)
81124404:	108002a4 	muli	r2,r2,10
81124408:	a109883a 	add	r4,r20,r4
8112440c:	22c00003 	ldbu	r11,0(r4)
81124410:	1345883a 	add	r2,r2,r13
81124414:	10bffc04 	addi	r2,r2,-16
81124418:	593fffc4 	addi	r4,r11,-1
8112441c:	21003fcc 	andi	r4,r4,255
81124420:	5b403fcc 	andi	r13,r11,255
81124424:	613ff52e 	bgeu	r12,r4,811243fc <__reset+0xfb1043fc>
81124428:	30000126 	beq	r6,zero,81124430 <__gethex+0x3e0>
8112442c:	0085c83a 	sub	r2,zero,r2
81124430:	8039883a 	mov	fp,r16
81124434:	b8af883a 	add	r23,r23,r2
81124438:	2821883a 	mov	r16,r5
8112443c:	003f5106 	br	81124184 <__reset+0xfb104184>
81124440:	80800217 	ldw	r2,8(r16)
81124444:	e080f00e 	bge	fp,r2,81124808 <__gethex+0x7b8>
81124448:	e007883a 	mov	r3,fp
8112444c:	18800144 	addi	r2,r3,5
81124450:	1085883a 	add	r2,r2,r2
81124454:	18c00044 	addi	r3,r3,1
81124458:	1085883a 	add	r2,r2,r2
8112445c:	8085883a 	add	r2,r16,r2
81124460:	80c00415 	stw	r3,16(r16)
81124464:	01000044 	movi	r4,1
81124468:	11000015 	stw	r4,0(r2)
8112446c:	00800084 	movi	r2,2
81124470:	8880d826 	beq	r17,r2,811247d4 <__gethex+0x784>
81124474:	e0c0ac0e 	bge	fp,r3,81124728 <__gethex+0x6d8>
81124478:	01400044 	movi	r5,1
8112447c:	8009883a 	mov	r4,r16
81124480:	1123f500 	call	81123f50 <rshift>
81124484:	d8c00017 	ldw	r3,0(sp)
81124488:	bdc00044 	addi	r23,r23,1
8112448c:	18800217 	ldw	r2,8(r3)
81124490:	15c0a70e 	bge	r2,r23,81124730 <__gethex+0x6e0>
81124494:	d9000117 	ldw	r4,4(sp)
81124498:	800b883a 	mov	r5,r16
8112449c:	111d6e80 	call	8111d6e8 <_Bfree>
811244a0:	d9001517 	ldw	r4,84(sp)
811244a4:	008028c4 	movi	r2,163
811244a8:	20000015 	stw	zero,0(r4)
811244ac:	003faa06 	br	81124358 <__reset+0xfb104358>
811244b0:	01800044 	movi	r6,1
811244b4:	80800083 	ldbu	r2,2(r16)
811244b8:	81400084 	addi	r5,r16,2
811244bc:	003fbc06 	br	811243b0 <__reset+0xfb1043b0>
811244c0:	ada1883a 	add	r16,r21,r22
811244c4:	81000003 	ldbu	r4,0(r16)
811244c8:	21403fcc 	andi	r5,r4,255
811244cc:	a145883a 	add	r2,r20,r5
811244d0:	10800003 	ldbu	r2,0(r2)
811244d4:	11803fcc 	andi	r6,r2,255
811244d8:	30004f26 	beq	r6,zero,81124618 <__gethex+0x5c8>
811244dc:	00c00c04 	movi	r3,48
811244e0:	802b883a 	mov	r21,r16
811244e4:	28c0061e 	bne	r5,r3,81124500 <__gethex+0x4b0>
811244e8:	2809883a 	mov	r4,r5
811244ec:	ad400044 	addi	r21,r21,1
811244f0:	a8800003 	ldbu	r2,0(r21)
811244f4:	113ffd26 	beq	r2,r4,811244ec <__reset+0xfb1044ec>
811244f8:	a085883a 	add	r2,r20,r2
811244fc:	10800003 	ldbu	r2,0(r2)
81124500:	10803fcc 	andi	r2,r2,255
81124504:	1015003a 	cmpeq	r10,r2,zero
81124508:	802f883a 	mov	r23,r16
8112450c:	04400044 	movi	r17,1
81124510:	003eff06 	br	81124110 <__reset+0xfb104110>
81124514:	04400044 	movi	r17,1
81124518:	98000926 	beq	r19,zero,81124540 <__gethex+0x4f0>
8112451c:	d8c00017 	ldw	r3,0(sp)
81124520:	18800317 	ldw	r2,12(r3)
81124524:	00c00084 	movi	r3,2
81124528:	10c06826 	beq	r2,r3,811246cc <__gethex+0x67c>
8112452c:	00c000c4 	movi	r3,3
81124530:	10c06a26 	beq	r2,r3,811246dc <__gethex+0x68c>
81124534:	00c00044 	movi	r3,1
81124538:	10c08d26 	beq	r2,r3,81124770 <__gethex+0x720>
8112453c:	8c400414 	ori	r17,r17,16
81124540:	d9001517 	ldw	r4,84(sp)
81124544:	d8c00417 	ldw	r3,16(sp)
81124548:	8805883a 	mov	r2,r17
8112454c:	24000015 	stw	r16,0(r4)
81124550:	1dc00015 	stw	r23,0(r3)
81124554:	003f8006 	br	81124358 <__reset+0xfb104358>
81124558:	000d883a 	mov	r6,zero
8112455c:	003fd506 	br	811244b4 <__reset+0xfb1044b4>
81124560:	0005883a 	mov	r2,zero
81124564:	003f7c06 	br	81124358 <__reset+0xfb104358>
81124568:	14a3c83a 	sub	r17,r2,r18
8112456c:	880b883a 	mov	r5,r17
81124570:	8009883a 	mov	r4,r16
81124574:	111e6080 	call	8111e608 <__any_on>
81124578:	10002926 	beq	r2,zero,81124620 <__gethex+0x5d0>
8112457c:	897fffc4 	addi	r5,r17,-1
81124580:	2807d17a 	srai	r3,r5,5
81124584:	d8800217 	ldw	r2,8(sp)
81124588:	290007cc 	andi	r4,r5,31
8112458c:	18c7883a 	add	r3,r3,r3
81124590:	18c7883a 	add	r3,r3,r3
81124594:	04c00044 	movi	r19,1
81124598:	10c7883a 	add	r3,r2,r3
8112459c:	9908983a 	sll	r4,r19,r4
811245a0:	18c00017 	ldw	r3,0(r3)
811245a4:	20c6703a 	and	r3,r4,r3
811245a8:	18000626 	beq	r3,zero,811245c4 <__gethex+0x574>
811245ac:	99407b0e 	bge	r19,r5,8112479c <__gethex+0x74c>
811245b0:	897fff84 	addi	r5,r17,-2
811245b4:	8009883a 	mov	r4,r16
811245b8:	111e6080 	call	8111e608 <__any_on>
811245bc:	10007726 	beq	r2,zero,8112479c <__gethex+0x74c>
811245c0:	04c000c4 	movi	r19,3
811245c4:	880b883a 	mov	r5,r17
811245c8:	8009883a 	mov	r4,r16
811245cc:	1123f500 	call	81123f50 <rshift>
811245d0:	bc6f883a 	add	r23,r23,r17
811245d4:	003f1f06 	br	81124254 <__reset+0xfb104254>
811245d8:	002f883a 	mov	r23,zero
811245dc:	003ee306 	br	8112416c <__reset+0xfb10416c>
811245e0:	d9000117 	ldw	r4,4(sp)
811245e4:	90a3c83a 	sub	r17,r18,r2
811245e8:	800b883a 	mov	r5,r16
811245ec:	880d883a 	mov	r6,r17
811245f0:	111dde80 	call	8111dde8 <__lshift>
811245f4:	10c00504 	addi	r3,r2,20
811245f8:	1021883a 	mov	r16,r2
811245fc:	bc6fc83a 	sub	r23,r23,r17
81124600:	d8c00215 	stw	r3,8(sp)
81124604:	0027883a 	mov	r19,zero
81124608:	003f1206 	br	81124254 <__reset+0xfb104254>
8112460c:	1d400084 	addi	r21,r3,2
81124610:	0023883a 	mov	r17,zero
81124614:	003eb406 	br	811240e8 <__reset+0xfb1040e8>
81124618:	2005883a 	mov	r2,r4
8112461c:	003f4606 	br	81124338 <__reset+0xfb104338>
81124620:	0027883a 	mov	r19,zero
81124624:	003fe706 	br	811245c4 <__reset+0xfb1045c4>
81124628:	bc7fffc4 	addi	r17,r23,-1
8112462c:	9800421e 	bne	r19,zero,81124738 <__gethex+0x6e8>
81124630:	88000426 	beq	r17,zero,81124644 <__gethex+0x5f4>
81124634:	880b883a 	mov	r5,r17
81124638:	8009883a 	mov	r4,r16
8112463c:	111e6080 	call	8111e608 <__any_on>
81124640:	1027883a 	mov	r19,r2
81124644:	8805d17a 	srai	r2,r17,5
81124648:	d8c00217 	ldw	r3,8(sp)
8112464c:	8c4007cc 	andi	r17,r17,31
81124650:	1085883a 	add	r2,r2,r2
81124654:	1085883a 	add	r2,r2,r2
81124658:	1885883a 	add	r2,r3,r2
8112465c:	00c00044 	movi	r3,1
81124660:	1c62983a 	sll	r17,r3,r17
81124664:	10800017 	ldw	r2,0(r2)
81124668:	8884703a 	and	r2,r17,r2
8112466c:	10000126 	beq	r2,zero,81124674 <__gethex+0x624>
81124670:	9cc00094 	ori	r19,r19,2
81124674:	b80b883a 	mov	r5,r23
81124678:	8009883a 	mov	r4,r16
8112467c:	1123f500 	call	81123f50 <rshift>
81124680:	d8c00017 	ldw	r3,0(sp)
81124684:	95e5c83a 	sub	r18,r18,r23
81124688:	04400084 	movi	r17,2
8112468c:	1dc00117 	ldw	r23,4(r3)
81124690:	003fa106 	br	81124518 <__reset+0xfb104518>
81124694:	85af883a 	add	r23,r16,r22
81124698:	b8800003 	ldbu	r2,0(r23)
8112469c:	b821883a 	mov	r16,r23
811246a0:	11003fcc 	andi	r4,r2,255
811246a4:	a109883a 	add	r4,r20,r4
811246a8:	21000003 	ldbu	r4,0(r4)
811246ac:	203eaa26 	beq	r4,zero,81124158 <__reset+0xfb104158>
811246b0:	84000044 	addi	r16,r16,1
811246b4:	80800003 	ldbu	r2,0(r16)
811246b8:	11003fcc 	andi	r4,r2,255
811246bc:	a109883a 	add	r4,r20,r4
811246c0:	21000003 	ldbu	r4,0(r4)
811246c4:	203ffa1e 	bne	r4,zero,811246b0 <__reset+0xfb1046b0>
811246c8:	003ea306 	br	81124158 <__reset+0xfb104158>
811246cc:	d9001617 	ldw	r4,88(sp)
811246d0:	00800044 	movi	r2,1
811246d4:	1109c83a 	sub	r4,r2,r4
811246d8:	d9001615 	stw	r4,88(sp)
811246dc:	d8801617 	ldw	r2,88(sp)
811246e0:	103f9626 	beq	r2,zero,8112453c <__reset+0xfb10453c>
811246e4:	87000417 	ldw	fp,16(r16)
811246e8:	d9800217 	ldw	r6,8(sp)
811246ec:	013fffc4 	movi	r4,-1
811246f0:	e727883a 	add	r19,fp,fp
811246f4:	9ce7883a 	add	r19,r19,r19
811246f8:	3005883a 	mov	r2,r6
811246fc:	34cb883a 	add	r5,r6,r19
81124700:	00000306 	br	81124710 <__gethex+0x6c0>
81124704:	10000015 	stw	zero,0(r2)
81124708:	10800104 	addi	r2,r2,4
8112470c:	117f4c2e 	bgeu	r2,r5,81124440 <__reset+0xfb104440>
81124710:	10c00017 	ldw	r3,0(r2)
81124714:	193ffb26 	beq	r3,r4,81124704 <__reset+0xfb104704>
81124718:	18c00044 	addi	r3,r3,1
8112471c:	10c00015 	stw	r3,0(r2)
81124720:	00800084 	movi	r2,2
81124724:	88802b26 	beq	r17,r2,811247d4 <__gethex+0x784>
81124728:	948007cc 	andi	r18,r18,31
8112472c:	90002f1e 	bne	r18,zero,811247ec <__gethex+0x79c>
81124730:	04400844 	movi	r17,33
81124734:	003f8206 	br	81124540 <__reset+0xfb104540>
81124738:	04c00044 	movi	r19,1
8112473c:	003fc106 	br	81124644 <__reset+0xfb104644>
81124740:	d8c01617 	ldw	r3,88(sp)
81124744:	183ed226 	beq	r3,zero,81124290 <__reset+0xfb104290>
81124748:	d8c00417 	ldw	r3,16(sp)
8112474c:	d9001517 	ldw	r4,84(sp)
81124750:	18800015 	stw	r2,0(r3)
81124754:	d8c00217 	ldw	r3,8(sp)
81124758:	00800044 	movi	r2,1
8112475c:	80800415 	stw	r2,16(r16)
81124760:	18800015 	stw	r2,0(r3)
81124764:	24000015 	stw	r16,0(r4)
81124768:	00801884 	movi	r2,98
8112476c:	003efa06 	br	81124358 <__reset+0xfb104358>
81124770:	9880008c 	andi	r2,r19,2
81124774:	103f7126 	beq	r2,zero,8112453c <__reset+0xfb10453c>
81124778:	d8c00217 	ldw	r3,8(sp)
8112477c:	18800017 	ldw	r2,0(r3)
81124780:	9884b03a 	or	r2,r19,r2
81124784:	1080004c 	andi	r2,r2,1
81124788:	103fd61e 	bne	r2,zero,811246e4 <__reset+0xfb1046e4>
8112478c:	003f6b06 	br	8112453c <__reset+0xfb10453c>
81124790:	da800217 	ldw	r10,8(sp)
81124794:	0013883a 	mov	r9,zero
81124798:	003e9f06 	br	81124218 <__reset+0xfb104218>
8112479c:	04c00084 	movi	r19,2
811247a0:	003f8806 	br	811245c4 <__reset+0xfb1045c4>
811247a4:	d9001617 	ldw	r4,88(sp)
811247a8:	203fe726 	beq	r4,zero,81124748 <__reset+0xfb104748>
811247ac:	003eb806 	br	81124290 <__reset+0xfb104290>
811247b0:	95feb71e 	bne	r18,r23,81124290 <__reset+0xfb104290>
811247b4:	1cbfe40e 	bge	r3,r18,81124748 <__reset+0xfb104748>
811247b8:	917fffc4 	addi	r5,r18,-1
811247bc:	8009883a 	mov	r4,r16
811247c0:	111e6080 	call	8111e608 <__any_on>
811247c4:	103eb226 	beq	r2,zero,81124290 <__reset+0xfb104290>
811247c8:	d8c00017 	ldw	r3,0(sp)
811247cc:	18800117 	ldw	r2,4(r3)
811247d0:	003fdd06 	br	81124748 <__reset+0xfb104748>
811247d4:	d8c00017 	ldw	r3,0(sp)
811247d8:	18800017 	ldw	r2,0(r3)
811247dc:	10bfffc4 	addi	r2,r2,-1
811247e0:	90801c26 	beq	r18,r2,81124854 <__gethex+0x804>
811247e4:	04400884 	movi	r17,34
811247e8:	003f5506 	br	81124540 <__reset+0xfb104540>
811247ec:	34c5883a 	add	r2,r6,r19
811247f0:	113fff17 	ldw	r4,-4(r2)
811247f4:	111d9440 	call	8111d944 <__hi0bits>
811247f8:	00c00804 	movi	r3,32
811247fc:	1ca5c83a 	sub	r18,r3,r18
81124800:	14bfcb0e 	bge	r2,r18,81124730 <__reset+0xfb104730>
81124804:	003f1c06 	br	81124478 <__reset+0xfb104478>
81124808:	81400117 	ldw	r5,4(r16)
8112480c:	d9000117 	ldw	r4,4(sp)
81124810:	29400044 	addi	r5,r5,1
81124814:	111d6380 	call	8111d638 <_Balloc>
81124818:	81800417 	ldw	r6,16(r16)
8112481c:	81400304 	addi	r5,r16,12
81124820:	11000304 	addi	r4,r2,12
81124824:	31800084 	addi	r6,r6,2
81124828:	318d883a 	add	r6,r6,r6
8112482c:	318d883a 	add	r6,r6,r6
81124830:	1029883a 	mov	r20,r2
81124834:	11136e00 	call	811136e0 <memcpy>
81124838:	d9000117 	ldw	r4,4(sp)
8112483c:	800b883a 	mov	r5,r16
81124840:	a021883a 	mov	r16,r20
81124844:	111d6e80 	call	8111d6e8 <_Bfree>
81124848:	a0c00417 	ldw	r3,16(r20)
8112484c:	a1800504 	addi	r6,r20,20
81124850:	003efe06 	br	8112444c <__reset+0xfb10444c>
81124854:	9005d17a 	srai	r2,r18,5
81124858:	944007cc 	andi	r17,r18,31
8112485c:	1085883a 	add	r2,r2,r2
81124860:	1085883a 	add	r2,r2,r2
81124864:	3087883a 	add	r3,r6,r2
81124868:	00800044 	movi	r2,1
8112486c:	1462983a 	sll	r17,r2,r17
81124870:	18800017 	ldw	r2,0(r3)
81124874:	8884703a 	and	r2,r17,r2
81124878:	1022c03a 	cmpne	r17,r2,zero
8112487c:	00800884 	movi	r2,34
81124880:	1463c83a 	sub	r17,r2,r17
81124884:	003f2e06 	br	81124540 <__reset+0xfb104540>

81124888 <__hexnan>:
81124888:	defff904 	addi	sp,sp,-28
8112488c:	de00012e 	bgeu	sp,et,81124894 <__hexnan+0xc>
81124890:	003b68fa 	trap	3
81124894:	dc800215 	stw	r18,8(sp)
81124898:	2c800017 	ldw	r18,0(r5)
8112489c:	dfc00615 	stw	ra,24(sp)
811248a0:	dd400515 	stw	r21,20(sp)
811248a4:	901fd17a 	srai	r15,r18,5
811248a8:	dd000415 	stw	r20,16(sp)
811248ac:	dcc00315 	stw	r19,12(sp)
811248b0:	7bdf883a 	add	r15,r15,r15
811248b4:	7bdf883a 	add	r15,r15,r15
811248b8:	dc400115 	stw	r17,4(sp)
811248bc:	dc000015 	stw	r16,0(sp)
811248c0:	948007cc 	andi	r18,r18,31
811248c4:	33df883a 	add	r15,r6,r15
811248c8:	90000126 	beq	r18,zero,811248d0 <__hexnan+0x48>
811248cc:	7bc00104 	addi	r15,r15,4
811248d0:	22000017 	ldw	r8,0(r4)
811248d4:	7affff04 	addi	r11,r15,-4
811248d8:	03a04534 	movhi	r14,33044
811248dc:	783fff15 	stw	zero,-4(r15)
811248e0:	581b883a 	mov	r13,r11
811248e4:	580b883a 	mov	r5,r11
811248e8:	000f883a 	mov	r7,zero
811248ec:	003f883a 	mov	ra,zero
811248f0:	0019883a 	mov	r12,zero
811248f4:	73be4304 	addi	r14,r14,-1780
811248f8:	04400204 	movi	r17,8
811248fc:	04000804 	movi	r16,32
81124900:	04c001c4 	movi	r19,7
81124904:	42000044 	addi	r8,r8,1
81124908:	40c00003 	ldbu	r3,0(r8)
8112490c:	18001d26 	beq	r3,zero,81124984 <__hexnan+0xfc>
81124910:	70c5883a 	add	r2,r14,r3
81124914:	10800003 	ldbu	r2,0(r2)
81124918:	12403fcc 	andi	r9,r2,255
8112491c:	4800301e 	bne	r9,zero,811249e0 <__hexnan+0x158>
81124920:	80c04236 	bltu	r16,r3,81124a2c <__hexnan+0x1a4>
81124924:	fb3ff70e 	bge	ra,r12,81124904 <__reset+0xfb104904>
81124928:	2b40112e 	bgeu	r5,r13,81124970 <__hexnan+0xe8>
8112492c:	99c01016 	blt	r19,r7,81124970 <__hexnan+0xe8>
81124930:	89e9c83a 	sub	r20,r17,r7
81124934:	a529883a 	add	r20,r20,r20
81124938:	2a800017 	ldw	r10,0(r5)
8112493c:	a529883a 	add	r20,r20,r20
81124940:	852bc83a 	sub	r21,r16,r20
81124944:	28c00104 	addi	r3,r5,4
81124948:	2805883a 	mov	r2,r5
8112494c:	19c00017 	ldw	r7,0(r3)
81124950:	10800104 	addi	r2,r2,4
81124954:	18c00104 	addi	r3,r3,4
81124958:	3d52983a 	sll	r9,r7,r21
8112495c:	4a92b03a 	or	r9,r9,r10
81124960:	3d14d83a 	srl	r10,r7,r20
81124964:	127fff15 	stw	r9,-4(r2)
81124968:	1abfff15 	stw	r10,-4(r3)
8112496c:	137ff736 	bltu	r2,r13,8112494c <__reset+0xfb10494c>
81124970:	31402836 	bltu	r6,r5,81124a14 <__hexnan+0x18c>
81124974:	42000044 	addi	r8,r8,1
81124978:	40c00003 	ldbu	r3,0(r8)
8112497c:	01c00204 	movi	r7,8
81124980:	183fe31e 	bne	r3,zero,81124910 <__reset+0xfb104910>
81124984:	60002b26 	beq	r12,zero,81124a34 <__hexnan+0x1ac>
81124988:	2b40022e 	bgeu	r5,r13,81124994 <__hexnan+0x10c>
8112498c:	008001c4 	movi	r2,7
81124990:	11c0430e 	bge	r2,r7,81124aa0 <__hexnan+0x218>
81124994:	3140312e 	bgeu	r6,r5,81124a5c <__hexnan+0x1d4>
81124998:	3007883a 	mov	r3,r6
8112499c:	29000017 	ldw	r4,0(r5)
811249a0:	18800104 	addi	r2,r3,4
811249a4:	29400104 	addi	r5,r5,4
811249a8:	19000015 	stw	r4,0(r3)
811249ac:	1007883a 	mov	r3,r2
811249b0:	597ffa2e 	bgeu	r11,r5,8112499c <__reset+0xfb10499c>
811249b4:	10000015 	stw	zero,0(r2)
811249b8:	10800104 	addi	r2,r2,4
811249bc:	58bffd2e 	bgeu	r11,r2,811249b4 <__reset+0xfb1049b4>
811249c0:	78bfff17 	ldw	r2,-4(r15)
811249c4:	1000041e 	bne	r2,zero,811249d8 <__hexnan+0x150>
811249c8:	32c02d26 	beq	r6,r11,81124a80 <__hexnan+0x1f8>
811249cc:	5affff04 	addi	r11,r11,-4
811249d0:	58800017 	ldw	r2,0(r11)
811249d4:	103ffc26 	beq	r2,zero,811249c8 <__reset+0xfb1049c8>
811249d8:	00800144 	movi	r2,5
811249dc:	00001606 	br	81124a38 <__hexnan+0x1b0>
811249e0:	39c00044 	addi	r7,r7,1
811249e4:	63000044 	addi	r12,r12,1
811249e8:	89c0040e 	bge	r17,r7,811249fc <__hexnan+0x174>
811249ec:	317fc52e 	bgeu	r6,r5,81124904 <__reset+0xfb104904>
811249f0:	283fff15 	stw	zero,-4(r5)
811249f4:	01c00044 	movi	r7,1
811249f8:	297fff04 	addi	r5,r5,-4
811249fc:	28c00017 	ldw	r3,0(r5)
81124a00:	108003cc 	andi	r2,r2,15
81124a04:	1806913a 	slli	r3,r3,4
81124a08:	1884b03a 	or	r2,r3,r2
81124a0c:	28800015 	stw	r2,0(r5)
81124a10:	003fbc06 	br	81124904 <__reset+0xfb104904>
81124a14:	2b7fff04 	addi	r13,r5,-4
81124a18:	283fff15 	stw	zero,-4(r5)
81124a1c:	603f883a 	mov	ra,r12
81124a20:	680b883a 	mov	r5,r13
81124a24:	000f883a 	mov	r7,zero
81124a28:	003fb606 	br	81124904 <__reset+0xfb104904>
81124a2c:	00800a44 	movi	r2,41
81124a30:	18801726 	beq	r3,r2,81124a90 <__hexnan+0x208>
81124a34:	00800104 	movi	r2,4
81124a38:	dfc00617 	ldw	ra,24(sp)
81124a3c:	dd400517 	ldw	r21,20(sp)
81124a40:	dd000417 	ldw	r20,16(sp)
81124a44:	dcc00317 	ldw	r19,12(sp)
81124a48:	dc800217 	ldw	r18,8(sp)
81124a4c:	dc400117 	ldw	r17,4(sp)
81124a50:	dc000017 	ldw	r16,0(sp)
81124a54:	dec00704 	addi	sp,sp,28
81124a58:	f800283a 	ret
81124a5c:	903fd826 	beq	r18,zero,811249c0 <__reset+0xfb1049c0>
81124a60:	00c00804 	movi	r3,32
81124a64:	1ca5c83a 	sub	r18,r3,r18
81124a68:	00ffffc4 	movi	r3,-1
81124a6c:	78bfff17 	ldw	r2,-4(r15)
81124a70:	1c86d83a 	srl	r3,r3,r18
81124a74:	1884703a 	and	r2,r3,r2
81124a78:	78bfff15 	stw	r2,-4(r15)
81124a7c:	003fd106 	br	811249c4 <__reset+0xfb1049c4>
81124a80:	00800044 	movi	r2,1
81124a84:	58800015 	stw	r2,0(r11)
81124a88:	00800144 	movi	r2,5
81124a8c:	003fea06 	br	81124a38 <__reset+0xfb104a38>
81124a90:	42000044 	addi	r8,r8,1
81124a94:	22000015 	stw	r8,0(r4)
81124a98:	603fbb1e 	bne	r12,zero,81124988 <__reset+0xfb104988>
81124a9c:	003fe506 	br	81124a34 <__reset+0xfb104a34>
81124aa0:	02400204 	movi	r9,8
81124aa4:	49d3c83a 	sub	r9,r9,r7
81124aa8:	4a53883a 	add	r9,r9,r9
81124aac:	2a000017 	ldw	r8,0(r5)
81124ab0:	4a53883a 	add	r9,r9,r9
81124ab4:	02800804 	movi	r10,32
81124ab8:	5255c83a 	sub	r10,r10,r9
81124abc:	28c00104 	addi	r3,r5,4
81124ac0:	2805883a 	mov	r2,r5
81124ac4:	19c00017 	ldw	r7,0(r3)
81124ac8:	10800104 	addi	r2,r2,4
81124acc:	18c00104 	addi	r3,r3,4
81124ad0:	3a88983a 	sll	r4,r7,r10
81124ad4:	2208b03a 	or	r4,r4,r8
81124ad8:	3a50d83a 	srl	r8,r7,r9
81124adc:	113fff15 	stw	r4,-4(r2)
81124ae0:	1a3fff15 	stw	r8,-4(r3)
81124ae4:	137ff736 	bltu	r2,r13,81124ac4 <__reset+0xfb104ac4>
81124ae8:	003faa06 	br	81124994 <__reset+0xfb104994>

81124aec <strncmp>:
81124aec:	30003126 	beq	r6,zero,81124bb4 <strncmp+0xc8>
81124af0:	2144b03a 	or	r2,r4,r5
81124af4:	108000cc 	andi	r2,r2,3
81124af8:	10001e1e 	bne	r2,zero,81124b74 <strncmp+0x88>
81124afc:	024000c4 	movi	r9,3
81124b00:	49801c2e 	bgeu	r9,r6,81124b74 <strncmp+0x88>
81124b04:	20800017 	ldw	r2,0(r4)
81124b08:	28c00017 	ldw	r3,0(r5)
81124b0c:	10c0191e 	bne	r2,r3,81124b74 <strncmp+0x88>
81124b10:	31bfff04 	addi	r6,r6,-4
81124b14:	30002726 	beq	r6,zero,81124bb4 <strncmp+0xc8>
81124b18:	02ffbff4 	movhi	r11,65279
81124b1c:	5affbfc4 	addi	r11,r11,-257
81124b20:	0086303a 	nor	r3,zero,r2
81124b24:	02a02074 	movhi	r10,32897
81124b28:	12c5883a 	add	r2,r2,r11
81124b2c:	52a02004 	addi	r10,r10,-32640
81124b30:	10c4703a 	and	r2,r2,r3
81124b34:	1284703a 	and	r2,r2,r10
81124b38:	10000b26 	beq	r2,zero,81124b68 <strncmp+0x7c>
81124b3c:	00001d06 	br	81124bb4 <strncmp+0xc8>
81124b40:	20c00017 	ldw	r3,0(r4)
81124b44:	29c00017 	ldw	r7,0(r5)
81124b48:	1ad1883a 	add	r8,r3,r11
81124b4c:	00c4303a 	nor	r2,zero,r3
81124b50:	4084703a 	and	r2,r8,r2
81124b54:	1284703a 	and	r2,r2,r10
81124b58:	19c0061e 	bne	r3,r7,81124b74 <strncmp+0x88>
81124b5c:	31bfff04 	addi	r6,r6,-4
81124b60:	30001426 	beq	r6,zero,81124bb4 <strncmp+0xc8>
81124b64:	1000131e 	bne	r2,zero,81124bb4 <strncmp+0xc8>
81124b68:	21000104 	addi	r4,r4,4
81124b6c:	29400104 	addi	r5,r5,4
81124b70:	49bff336 	bltu	r9,r6,81124b40 <__reset+0xfb104b40>
81124b74:	28800007 	ldb	r2,0(r5)
81124b78:	20c00007 	ldb	r3,0(r4)
81124b7c:	31bfffc4 	addi	r6,r6,-1
81124b80:	10c0081e 	bne	r2,r3,81124ba4 <strncmp+0xb8>
81124b84:	30000b26 	beq	r6,zero,81124bb4 <strncmp+0xc8>
81124b88:	10000a26 	beq	r2,zero,81124bb4 <strncmp+0xc8>
81124b8c:	21000044 	addi	r4,r4,1
81124b90:	29400044 	addi	r5,r5,1
81124b94:	20800007 	ldb	r2,0(r4)
81124b98:	28c00007 	ldb	r3,0(r5)
81124b9c:	31bfffc4 	addi	r6,r6,-1
81124ba0:	10fff826 	beq	r2,r3,81124b84 <__reset+0xfb104b84>
81124ba4:	20800003 	ldbu	r2,0(r4)
81124ba8:	28c00003 	ldbu	r3,0(r5)
81124bac:	10c5c83a 	sub	r2,r2,r3
81124bb0:	f800283a 	ret
81124bb4:	0005883a 	mov	r2,zero
81124bb8:	f800283a 	ret

81124bbc <__swbuf_r>:
81124bbc:	defffb04 	addi	sp,sp,-20
81124bc0:	de00012e 	bgeu	sp,et,81124bc8 <__swbuf_r+0xc>
81124bc4:	003b68fa 	trap	3
81124bc8:	dcc00315 	stw	r19,12(sp)
81124bcc:	dc800215 	stw	r18,8(sp)
81124bd0:	dc000015 	stw	r16,0(sp)
81124bd4:	dfc00415 	stw	ra,16(sp)
81124bd8:	dc400115 	stw	r17,4(sp)
81124bdc:	2025883a 	mov	r18,r4
81124be0:	2827883a 	mov	r19,r5
81124be4:	3021883a 	mov	r16,r6
81124be8:	20000226 	beq	r4,zero,81124bf4 <__swbuf_r+0x38>
81124bec:	20800e17 	ldw	r2,56(r4)
81124bf0:	10004226 	beq	r2,zero,81124cfc <__swbuf_r+0x140>
81124bf4:	80800617 	ldw	r2,24(r16)
81124bf8:	8100030b 	ldhu	r4,12(r16)
81124bfc:	80800215 	stw	r2,8(r16)
81124c00:	2080020c 	andi	r2,r4,8
81124c04:	10003626 	beq	r2,zero,81124ce0 <__swbuf_r+0x124>
81124c08:	80c00417 	ldw	r3,16(r16)
81124c0c:	18003426 	beq	r3,zero,81124ce0 <__swbuf_r+0x124>
81124c10:	2088000c 	andi	r2,r4,8192
81124c14:	9c403fcc 	andi	r17,r19,255
81124c18:	10001a26 	beq	r2,zero,81124c84 <__swbuf_r+0xc8>
81124c1c:	80800017 	ldw	r2,0(r16)
81124c20:	81000517 	ldw	r4,20(r16)
81124c24:	10c7c83a 	sub	r3,r2,r3
81124c28:	1900200e 	bge	r3,r4,81124cac <__swbuf_r+0xf0>
81124c2c:	18c00044 	addi	r3,r3,1
81124c30:	81000217 	ldw	r4,8(r16)
81124c34:	11400044 	addi	r5,r2,1
81124c38:	81400015 	stw	r5,0(r16)
81124c3c:	213fffc4 	addi	r4,r4,-1
81124c40:	81000215 	stw	r4,8(r16)
81124c44:	14c00005 	stb	r19,0(r2)
81124c48:	80800517 	ldw	r2,20(r16)
81124c4c:	10c01e26 	beq	r2,r3,81124cc8 <__swbuf_r+0x10c>
81124c50:	8080030b 	ldhu	r2,12(r16)
81124c54:	1080004c 	andi	r2,r2,1
81124c58:	10000226 	beq	r2,zero,81124c64 <__swbuf_r+0xa8>
81124c5c:	00800284 	movi	r2,10
81124c60:	88801926 	beq	r17,r2,81124cc8 <__swbuf_r+0x10c>
81124c64:	8805883a 	mov	r2,r17
81124c68:	dfc00417 	ldw	ra,16(sp)
81124c6c:	dcc00317 	ldw	r19,12(sp)
81124c70:	dc800217 	ldw	r18,8(sp)
81124c74:	dc400117 	ldw	r17,4(sp)
81124c78:	dc000017 	ldw	r16,0(sp)
81124c7c:	dec00504 	addi	sp,sp,20
81124c80:	f800283a 	ret
81124c84:	81401917 	ldw	r5,100(r16)
81124c88:	00b7ffc4 	movi	r2,-8193
81124c8c:	21080014 	ori	r4,r4,8192
81124c90:	2884703a 	and	r2,r5,r2
81124c94:	80801915 	stw	r2,100(r16)
81124c98:	80800017 	ldw	r2,0(r16)
81124c9c:	8100030d 	sth	r4,12(r16)
81124ca0:	81000517 	ldw	r4,20(r16)
81124ca4:	10c7c83a 	sub	r3,r2,r3
81124ca8:	193fe016 	blt	r3,r4,81124c2c <__reset+0xfb104c2c>
81124cac:	800b883a 	mov	r5,r16
81124cb0:	9009883a 	mov	r4,r18
81124cb4:	111bdd40 	call	8111bdd4 <_fflush_r>
81124cb8:	1000071e 	bne	r2,zero,81124cd8 <__swbuf_r+0x11c>
81124cbc:	80800017 	ldw	r2,0(r16)
81124cc0:	00c00044 	movi	r3,1
81124cc4:	003fda06 	br	81124c30 <__reset+0xfb104c30>
81124cc8:	800b883a 	mov	r5,r16
81124ccc:	9009883a 	mov	r4,r18
81124cd0:	111bdd40 	call	8111bdd4 <_fflush_r>
81124cd4:	103fe326 	beq	r2,zero,81124c64 <__reset+0xfb104c64>
81124cd8:	00bfffc4 	movi	r2,-1
81124cdc:	003fe206 	br	81124c68 <__reset+0xfb104c68>
81124ce0:	800b883a 	mov	r5,r16
81124ce4:	9009883a 	mov	r4,r18
81124ce8:	111a1600 	call	8111a160 <__swsetup_r>
81124cec:	103ffa1e 	bne	r2,zero,81124cd8 <__reset+0xfb104cd8>
81124cf0:	8100030b 	ldhu	r4,12(r16)
81124cf4:	80c00417 	ldw	r3,16(r16)
81124cf8:	003fc506 	br	81124c10 <__reset+0xfb104c10>
81124cfc:	111c1d00 	call	8111c1d0 <__sinit>
81124d00:	003fbc06 	br	81124bf4 <__reset+0xfb104bf4>

81124d04 <__swbuf>:
81124d04:	00a04534 	movhi	r2,33044
81124d08:	1086aa04 	addi	r2,r2,6824
81124d0c:	280d883a 	mov	r6,r5
81124d10:	200b883a 	mov	r5,r4
81124d14:	11000017 	ldw	r4,0(r2)
81124d18:	1124bbc1 	jmpi	81124bbc <__swbuf_r>

81124d1c <_wcrtomb_r>:
81124d1c:	defff604 	addi	sp,sp,-40
81124d20:	00a04534 	movhi	r2,33044
81124d24:	de00012e 	bgeu	sp,et,81124d2c <_wcrtomb_r+0x10>
81124d28:	003b68fa 	trap	3
81124d2c:	1086af04 	addi	r2,r2,6844
81124d30:	dc800815 	stw	r18,32(sp)
81124d34:	dc400715 	stw	r17,28(sp)
81124d38:	dc000615 	stw	r16,24(sp)
81124d3c:	dfc00915 	stw	ra,36(sp)
81124d40:	2021883a 	mov	r16,r4
81124d44:	3823883a 	mov	r17,r7
81124d48:	14800017 	ldw	r18,0(r2)
81124d4c:	28001426 	beq	r5,zero,81124da0 <_wcrtomb_r+0x84>
81124d50:	d9400415 	stw	r5,16(sp)
81124d54:	d9800515 	stw	r6,20(sp)
81124d58:	111d0ec0 	call	8111d0ec <__locale_charset>
81124d5c:	d9800517 	ldw	r6,20(sp)
81124d60:	d9400417 	ldw	r5,16(sp)
81124d64:	100f883a 	mov	r7,r2
81124d68:	dc400015 	stw	r17,0(sp)
81124d6c:	8009883a 	mov	r4,r16
81124d70:	903ee83a 	callr	r18
81124d74:	00ffffc4 	movi	r3,-1
81124d78:	10c0031e 	bne	r2,r3,81124d88 <_wcrtomb_r+0x6c>
81124d7c:	88000015 	stw	zero,0(r17)
81124d80:	00c02284 	movi	r3,138
81124d84:	80c00015 	stw	r3,0(r16)
81124d88:	dfc00917 	ldw	ra,36(sp)
81124d8c:	dc800817 	ldw	r18,32(sp)
81124d90:	dc400717 	ldw	r17,28(sp)
81124d94:	dc000617 	ldw	r16,24(sp)
81124d98:	dec00a04 	addi	sp,sp,40
81124d9c:	f800283a 	ret
81124da0:	111d0ec0 	call	8111d0ec <__locale_charset>
81124da4:	100f883a 	mov	r7,r2
81124da8:	dc400015 	stw	r17,0(sp)
81124dac:	000d883a 	mov	r6,zero
81124db0:	d9400104 	addi	r5,sp,4
81124db4:	8009883a 	mov	r4,r16
81124db8:	903ee83a 	callr	r18
81124dbc:	003fed06 	br	81124d74 <__reset+0xfb104d74>

81124dc0 <wcrtomb>:
81124dc0:	defff604 	addi	sp,sp,-40
81124dc4:	00a04534 	movhi	r2,33044
81124dc8:	de00012e 	bgeu	sp,et,81124dd0 <wcrtomb+0x10>
81124dcc:	003b68fa 	trap	3
81124dd0:	1086aa04 	addi	r2,r2,6824
81124dd4:	dc800615 	stw	r18,24(sp)
81124dd8:	dc400515 	stw	r17,20(sp)
81124ddc:	dfc00915 	stw	ra,36(sp)
81124de0:	dd000815 	stw	r20,32(sp)
81124de4:	dcc00715 	stw	r19,28(sp)
81124de8:	dc000415 	stw	r16,16(sp)
81124dec:	3025883a 	mov	r18,r6
81124df0:	14400017 	ldw	r17,0(r2)
81124df4:	20001926 	beq	r4,zero,81124e5c <wcrtomb+0x9c>
81124df8:	00a04534 	movhi	r2,33044
81124dfc:	1086af04 	addi	r2,r2,6844
81124e00:	15000017 	ldw	r20,0(r2)
81124e04:	2021883a 	mov	r16,r4
81124e08:	2827883a 	mov	r19,r5
81124e0c:	111d0ec0 	call	8111d0ec <__locale_charset>
81124e10:	100f883a 	mov	r7,r2
81124e14:	dc800015 	stw	r18,0(sp)
81124e18:	980d883a 	mov	r6,r19
81124e1c:	800b883a 	mov	r5,r16
81124e20:	8809883a 	mov	r4,r17
81124e24:	a03ee83a 	callr	r20
81124e28:	00ffffc4 	movi	r3,-1
81124e2c:	10c0031e 	bne	r2,r3,81124e3c <wcrtomb+0x7c>
81124e30:	90000015 	stw	zero,0(r18)
81124e34:	00c02284 	movi	r3,138
81124e38:	88c00015 	stw	r3,0(r17)
81124e3c:	dfc00917 	ldw	ra,36(sp)
81124e40:	dd000817 	ldw	r20,32(sp)
81124e44:	dcc00717 	ldw	r19,28(sp)
81124e48:	dc800617 	ldw	r18,24(sp)
81124e4c:	dc400517 	ldw	r17,20(sp)
81124e50:	dc000417 	ldw	r16,16(sp)
81124e54:	dec00a04 	addi	sp,sp,40
81124e58:	f800283a 	ret
81124e5c:	00a04534 	movhi	r2,33044
81124e60:	1086af04 	addi	r2,r2,6844
81124e64:	14000017 	ldw	r16,0(r2)
81124e68:	111d0ec0 	call	8111d0ec <__locale_charset>
81124e6c:	100f883a 	mov	r7,r2
81124e70:	dc800015 	stw	r18,0(sp)
81124e74:	000d883a 	mov	r6,zero
81124e78:	d9400104 	addi	r5,sp,4
81124e7c:	8809883a 	mov	r4,r17
81124e80:	803ee83a 	callr	r16
81124e84:	003fe806 	br	81124e28 <__reset+0xfb104e28>

81124e88 <__ascii_wctomb>:
81124e88:	28000526 	beq	r5,zero,81124ea0 <__ascii_wctomb+0x18>
81124e8c:	00803fc4 	movi	r2,255
81124e90:	11800536 	bltu	r2,r6,81124ea8 <__ascii_wctomb+0x20>
81124e94:	29800005 	stb	r6,0(r5)
81124e98:	00800044 	movi	r2,1
81124e9c:	f800283a 	ret
81124ea0:	0005883a 	mov	r2,zero
81124ea4:	f800283a 	ret
81124ea8:	00802284 	movi	r2,138
81124eac:	20800015 	stw	r2,0(r4)
81124eb0:	00bfffc4 	movi	r2,-1
81124eb4:	f800283a 	ret

81124eb8 <_wctomb_r>:
81124eb8:	00a04534 	movhi	r2,33044
81124ebc:	defff904 	addi	sp,sp,-28
81124ec0:	1086af04 	addi	r2,r2,6844
81124ec4:	de00012e 	bgeu	sp,et,81124ecc <_wctomb_r+0x14>
81124ec8:	003b68fa 	trap	3
81124ecc:	dfc00615 	stw	ra,24(sp)
81124ed0:	dc400515 	stw	r17,20(sp)
81124ed4:	dc000415 	stw	r16,16(sp)
81124ed8:	3823883a 	mov	r17,r7
81124edc:	14000017 	ldw	r16,0(r2)
81124ee0:	d9000115 	stw	r4,4(sp)
81124ee4:	d9400215 	stw	r5,8(sp)
81124ee8:	d9800315 	stw	r6,12(sp)
81124eec:	111d0ec0 	call	8111d0ec <__locale_charset>
81124ef0:	d9800317 	ldw	r6,12(sp)
81124ef4:	d9400217 	ldw	r5,8(sp)
81124ef8:	d9000117 	ldw	r4,4(sp)
81124efc:	100f883a 	mov	r7,r2
81124f00:	dc400015 	stw	r17,0(sp)
81124f04:	803ee83a 	callr	r16
81124f08:	dfc00617 	ldw	ra,24(sp)
81124f0c:	dc400517 	ldw	r17,20(sp)
81124f10:	dc000417 	ldw	r16,16(sp)
81124f14:	dec00704 	addi	sp,sp,28
81124f18:	f800283a 	ret

81124f1c <__fixunsdfsi>:
81124f1c:	defffd04 	addi	sp,sp,-12
81124f20:	000d883a 	mov	r6,zero
81124f24:	01d07834 	movhi	r7,16864
81124f28:	de00012e 	bgeu	sp,et,81124f30 <__fixunsdfsi+0x14>
81124f2c:	003b68fa 	trap	3
81124f30:	dc400115 	stw	r17,4(sp)
81124f34:	dc000015 	stw	r16,0(sp)
81124f38:	dfc00215 	stw	ra,8(sp)
81124f3c:	2023883a 	mov	r17,r4
81124f40:	2821883a 	mov	r16,r5
81124f44:	11270340 	call	81127034 <__gedf2>
81124f48:	1000080e 	bge	r2,zero,81124f6c <__fixunsdfsi+0x50>
81124f4c:	8809883a 	mov	r4,r17
81124f50:	800b883a 	mov	r5,r16
81124f54:	1127b080 	call	81127b08 <__fixdfsi>
81124f58:	dfc00217 	ldw	ra,8(sp)
81124f5c:	dc400117 	ldw	r17,4(sp)
81124f60:	dc000017 	ldw	r16,0(sp)
81124f64:	dec00304 	addi	sp,sp,12
81124f68:	f800283a 	ret
81124f6c:	000d883a 	mov	r6,zero
81124f70:	01d07834 	movhi	r7,16864
81124f74:	8809883a 	mov	r4,r17
81124f78:	800b883a 	mov	r5,r16
81124f7c:	11272040 	call	81127204 <__subdf3>
81124f80:	180b883a 	mov	r5,r3
81124f84:	1009883a 	mov	r4,r2
81124f88:	1127b080 	call	81127b08 <__fixdfsi>
81124f8c:	00e00034 	movhi	r3,32768
81124f90:	10c5883a 	add	r2,r2,r3
81124f94:	003ff006 	br	81124f58 <__reset+0xfb104f58>

81124f98 <__udivdi3>:
81124f98:	defff504 	addi	sp,sp,-44
81124f9c:	de00012e 	bgeu	sp,et,81124fa4 <__udivdi3+0xc>
81124fa0:	003b68fa 	trap	3
81124fa4:	dcc00415 	stw	r19,16(sp)
81124fa8:	dc000115 	stw	r16,4(sp)
81124fac:	dfc00a15 	stw	ra,40(sp)
81124fb0:	df000915 	stw	fp,36(sp)
81124fb4:	ddc00815 	stw	r23,32(sp)
81124fb8:	dd800715 	stw	r22,28(sp)
81124fbc:	dd400615 	stw	r21,24(sp)
81124fc0:	dd000515 	stw	r20,20(sp)
81124fc4:	dc800315 	stw	r18,12(sp)
81124fc8:	dc400215 	stw	r17,8(sp)
81124fcc:	2027883a 	mov	r19,r4
81124fd0:	2821883a 	mov	r16,r5
81124fd4:	3800411e 	bne	r7,zero,811250dc <__udivdi3+0x144>
81124fd8:	3023883a 	mov	r17,r6
81124fdc:	2025883a 	mov	r18,r4
81124fe0:	2980522e 	bgeu	r5,r6,8112512c <__udivdi3+0x194>
81124fe4:	00bfffd4 	movui	r2,65535
81124fe8:	282d883a 	mov	r22,r5
81124fec:	1180a836 	bltu	r2,r6,81125290 <__udivdi3+0x2f8>
81124ff0:	00803fc4 	movi	r2,255
81124ff4:	1185803a 	cmpltu	r2,r2,r6
81124ff8:	100490fa 	slli	r2,r2,3
81124ffc:	3086d83a 	srl	r3,r6,r2
81125000:	01204534 	movhi	r4,33044
81125004:	213cbd04 	addi	r4,r4,-3340
81125008:	20c7883a 	add	r3,r4,r3
8112500c:	18c00003 	ldbu	r3,0(r3)
81125010:	1885883a 	add	r2,r3,r2
81125014:	00c00804 	movi	r3,32
81125018:	1887c83a 	sub	r3,r3,r2
8112501c:	18000526 	beq	r3,zero,81125034 <__udivdi3+0x9c>
81125020:	80e0983a 	sll	r16,r16,r3
81125024:	9884d83a 	srl	r2,r19,r2
81125028:	30e2983a 	sll	r17,r6,r3
8112502c:	98e4983a 	sll	r18,r19,r3
81125030:	142cb03a 	or	r22,r2,r16
81125034:	882ad43a 	srli	r21,r17,16
81125038:	b009883a 	mov	r4,r22
8112503c:	8d3fffcc 	andi	r20,r17,65535
81125040:	a80b883a 	mov	r5,r21
81125044:	1125bb40 	call	81125bb4 <__umodsi3>
81125048:	b009883a 	mov	r4,r22
8112504c:	a80b883a 	mov	r5,r21
81125050:	1027883a 	mov	r19,r2
81125054:	1125b500 	call	81125b50 <__udivsi3>
81125058:	102d883a 	mov	r22,r2
8112505c:	9826943a 	slli	r19,r19,16
81125060:	9004d43a 	srli	r2,r18,16
81125064:	a5a1383a 	mul	r16,r20,r22
81125068:	14c4b03a 	or	r2,r2,r19
8112506c:	1400052e 	bgeu	r2,r16,81125084 <__udivdi3+0xec>
81125070:	1445883a 	add	r2,r2,r17
81125074:	b0ffffc4 	addi	r3,r22,-1
81125078:	14400136 	bltu	r2,r17,81125080 <__udivdi3+0xe8>
8112507c:	14012336 	bltu	r2,r16,8112550c <__udivdi3+0x574>
81125080:	182d883a 	mov	r22,r3
81125084:	1421c83a 	sub	r16,r2,r16
81125088:	a80b883a 	mov	r5,r21
8112508c:	8009883a 	mov	r4,r16
81125090:	1125bb40 	call	81125bb4 <__umodsi3>
81125094:	1027883a 	mov	r19,r2
81125098:	a80b883a 	mov	r5,r21
8112509c:	8009883a 	mov	r4,r16
811250a0:	1125b500 	call	81125b50 <__udivsi3>
811250a4:	9826943a 	slli	r19,r19,16
811250a8:	a0a9383a 	mul	r20,r20,r2
811250ac:	94bfffcc 	andi	r18,r18,65535
811250b0:	94e4b03a 	or	r18,r18,r19
811250b4:	9500052e 	bgeu	r18,r20,811250cc <__udivdi3+0x134>
811250b8:	8ca5883a 	add	r18,r17,r18
811250bc:	10ffffc4 	addi	r3,r2,-1
811250c0:	9440f136 	bltu	r18,r17,81125488 <__udivdi3+0x4f0>
811250c4:	9500f02e 	bgeu	r18,r20,81125488 <__udivdi3+0x4f0>
811250c8:	10bfff84 	addi	r2,r2,-2
811250cc:	b00c943a 	slli	r6,r22,16
811250d0:	0007883a 	mov	r3,zero
811250d4:	3084b03a 	or	r2,r6,r2
811250d8:	00005906 	br	81125240 <__udivdi3+0x2a8>
811250dc:	29c05636 	bltu	r5,r7,81125238 <__udivdi3+0x2a0>
811250e0:	00bfffd4 	movui	r2,65535
811250e4:	11c0622e 	bgeu	r2,r7,81125270 <__udivdi3+0x2d8>
811250e8:	00804034 	movhi	r2,256
811250ec:	10bfffc4 	addi	r2,r2,-1
811250f0:	11c0ee36 	bltu	r2,r7,811254ac <__udivdi3+0x514>
811250f4:	00800404 	movi	r2,16
811250f8:	3886d83a 	srl	r3,r7,r2
811250fc:	01204534 	movhi	r4,33044
81125100:	213cbd04 	addi	r4,r4,-3340
81125104:	20c7883a 	add	r3,r4,r3
81125108:	18c00003 	ldbu	r3,0(r3)
8112510c:	05400804 	movi	r21,32
81125110:	1885883a 	add	r2,r3,r2
81125114:	a8abc83a 	sub	r21,r21,r2
81125118:	a800621e 	bne	r21,zero,811252a4 <__udivdi3+0x30c>
8112511c:	3c00e936 	bltu	r7,r16,811254c4 <__udivdi3+0x52c>
81125120:	9985403a 	cmpgeu	r2,r19,r6
81125124:	0007883a 	mov	r3,zero
81125128:	00004506 	br	81125240 <__udivdi3+0x2a8>
8112512c:	3000041e 	bne	r6,zero,81125140 <__udivdi3+0x1a8>
81125130:	000b883a 	mov	r5,zero
81125134:	01000044 	movi	r4,1
81125138:	1125b500 	call	81125b50 <__udivsi3>
8112513c:	1023883a 	mov	r17,r2
81125140:	00bfffd4 	movui	r2,65535
81125144:	14404e2e 	bgeu	r2,r17,81125280 <__udivdi3+0x2e8>
81125148:	00804034 	movhi	r2,256
8112514c:	10bfffc4 	addi	r2,r2,-1
81125150:	1440d836 	bltu	r2,r17,811254b4 <__udivdi3+0x51c>
81125154:	00800404 	movi	r2,16
81125158:	8886d83a 	srl	r3,r17,r2
8112515c:	01204534 	movhi	r4,33044
81125160:	213cbd04 	addi	r4,r4,-3340
81125164:	20c7883a 	add	r3,r4,r3
81125168:	18c00003 	ldbu	r3,0(r3)
8112516c:	1885883a 	add	r2,r3,r2
81125170:	00c00804 	movi	r3,32
81125174:	1887c83a 	sub	r3,r3,r2
81125178:	18008f1e 	bne	r3,zero,811253b8 <__udivdi3+0x420>
8112517c:	882ad43a 	srli	r21,r17,16
81125180:	8461c83a 	sub	r16,r16,r17
81125184:	8d3fffcc 	andi	r20,r17,65535
81125188:	00c00044 	movi	r3,1
8112518c:	8009883a 	mov	r4,r16
81125190:	a80b883a 	mov	r5,r21
81125194:	d8c00015 	stw	r3,0(sp)
81125198:	1125bb40 	call	81125bb4 <__umodsi3>
8112519c:	8009883a 	mov	r4,r16
811251a0:	a80b883a 	mov	r5,r21
811251a4:	1027883a 	mov	r19,r2
811251a8:	1125b500 	call	81125b50 <__udivsi3>
811251ac:	9826943a 	slli	r19,r19,16
811251b0:	9008d43a 	srli	r4,r18,16
811251b4:	1521383a 	mul	r16,r2,r20
811251b8:	102d883a 	mov	r22,r2
811251bc:	24c8b03a 	or	r4,r4,r19
811251c0:	d8c00017 	ldw	r3,0(sp)
811251c4:	2400052e 	bgeu	r4,r16,811251dc <__udivdi3+0x244>
811251c8:	2449883a 	add	r4,r4,r17
811251cc:	b0bfffc4 	addi	r2,r22,-1
811251d0:	24400136 	bltu	r4,r17,811251d8 <__udivdi3+0x240>
811251d4:	2400ca36 	bltu	r4,r16,81125500 <__udivdi3+0x568>
811251d8:	102d883a 	mov	r22,r2
811251dc:	2421c83a 	sub	r16,r4,r16
811251e0:	a80b883a 	mov	r5,r21
811251e4:	8009883a 	mov	r4,r16
811251e8:	d8c00015 	stw	r3,0(sp)
811251ec:	1125bb40 	call	81125bb4 <__umodsi3>
811251f0:	1027883a 	mov	r19,r2
811251f4:	a80b883a 	mov	r5,r21
811251f8:	8009883a 	mov	r4,r16
811251fc:	1125b500 	call	81125b50 <__udivsi3>
81125200:	9826943a 	slli	r19,r19,16
81125204:	1529383a 	mul	r20,r2,r20
81125208:	94bfffcc 	andi	r18,r18,65535
8112520c:	94e4b03a 	or	r18,r18,r19
81125210:	d8c00017 	ldw	r3,0(sp)
81125214:	9500052e 	bgeu	r18,r20,8112522c <__udivdi3+0x294>
81125218:	8ca5883a 	add	r18,r17,r18
8112521c:	113fffc4 	addi	r4,r2,-1
81125220:	94409736 	bltu	r18,r17,81125480 <__udivdi3+0x4e8>
81125224:	9500962e 	bgeu	r18,r20,81125480 <__udivdi3+0x4e8>
81125228:	10bfff84 	addi	r2,r2,-2
8112522c:	b00c943a 	slli	r6,r22,16
81125230:	3084b03a 	or	r2,r6,r2
81125234:	00000206 	br	81125240 <__udivdi3+0x2a8>
81125238:	0007883a 	mov	r3,zero
8112523c:	0005883a 	mov	r2,zero
81125240:	dfc00a17 	ldw	ra,40(sp)
81125244:	df000917 	ldw	fp,36(sp)
81125248:	ddc00817 	ldw	r23,32(sp)
8112524c:	dd800717 	ldw	r22,28(sp)
81125250:	dd400617 	ldw	r21,24(sp)
81125254:	dd000517 	ldw	r20,20(sp)
81125258:	dcc00417 	ldw	r19,16(sp)
8112525c:	dc800317 	ldw	r18,12(sp)
81125260:	dc400217 	ldw	r17,8(sp)
81125264:	dc000117 	ldw	r16,4(sp)
81125268:	dec00b04 	addi	sp,sp,44
8112526c:	f800283a 	ret
81125270:	00803fc4 	movi	r2,255
81125274:	11c5803a 	cmpltu	r2,r2,r7
81125278:	100490fa 	slli	r2,r2,3
8112527c:	003f9e06 	br	811250f8 <__reset+0xfb1050f8>
81125280:	00803fc4 	movi	r2,255
81125284:	1445803a 	cmpltu	r2,r2,r17
81125288:	100490fa 	slli	r2,r2,3
8112528c:	003fb206 	br	81125158 <__reset+0xfb105158>
81125290:	00804034 	movhi	r2,256
81125294:	10bfffc4 	addi	r2,r2,-1
81125298:	11808836 	bltu	r2,r6,811254bc <__udivdi3+0x524>
8112529c:	00800404 	movi	r2,16
811252a0:	003f5606 	br	81124ffc <__reset+0xfb104ffc>
811252a4:	30aed83a 	srl	r23,r6,r2
811252a8:	3d4e983a 	sll	r7,r7,r21
811252ac:	80acd83a 	srl	r22,r16,r2
811252b0:	9884d83a 	srl	r2,r19,r2
811252b4:	3deeb03a 	or	r23,r7,r23
811252b8:	b824d43a 	srli	r18,r23,16
811252bc:	8560983a 	sll	r16,r16,r21
811252c0:	b009883a 	mov	r4,r22
811252c4:	900b883a 	mov	r5,r18
811252c8:	3568983a 	sll	r20,r6,r21
811252cc:	1420b03a 	or	r16,r2,r16
811252d0:	1125bb40 	call	81125bb4 <__umodsi3>
811252d4:	b009883a 	mov	r4,r22
811252d8:	900b883a 	mov	r5,r18
811252dc:	1023883a 	mov	r17,r2
811252e0:	1125b500 	call	81125b50 <__udivsi3>
811252e4:	8808943a 	slli	r4,r17,16
811252e8:	bf3fffcc 	andi	fp,r23,65535
811252ec:	8006d43a 	srli	r3,r16,16
811252f0:	e0a3383a 	mul	r17,fp,r2
811252f4:	100d883a 	mov	r6,r2
811252f8:	1906b03a 	or	r3,r3,r4
811252fc:	1c40042e 	bgeu	r3,r17,81125310 <__udivdi3+0x378>
81125300:	1dc7883a 	add	r3,r3,r23
81125304:	10bfffc4 	addi	r2,r2,-1
81125308:	1dc0752e 	bgeu	r3,r23,811254e0 <__udivdi3+0x548>
8112530c:	100d883a 	mov	r6,r2
81125310:	1c63c83a 	sub	r17,r3,r17
81125314:	900b883a 	mov	r5,r18
81125318:	8809883a 	mov	r4,r17
8112531c:	d9800015 	stw	r6,0(sp)
81125320:	1125bb40 	call	81125bb4 <__umodsi3>
81125324:	102d883a 	mov	r22,r2
81125328:	8809883a 	mov	r4,r17
8112532c:	900b883a 	mov	r5,r18
81125330:	1125b500 	call	81125b50 <__udivsi3>
81125334:	b02c943a 	slli	r22,r22,16
81125338:	e089383a 	mul	r4,fp,r2
8112533c:	843fffcc 	andi	r16,r16,65535
81125340:	85a0b03a 	or	r16,r16,r22
81125344:	d9800017 	ldw	r6,0(sp)
81125348:	8100042e 	bgeu	r16,r4,8112535c <__udivdi3+0x3c4>
8112534c:	85e1883a 	add	r16,r16,r23
81125350:	10ffffc4 	addi	r3,r2,-1
81125354:	85c05e2e 	bgeu	r16,r23,811254d0 <__udivdi3+0x538>
81125358:	1805883a 	mov	r2,r3
8112535c:	300c943a 	slli	r6,r6,16
81125360:	a17fffcc 	andi	r5,r20,65535
81125364:	a028d43a 	srli	r20,r20,16
81125368:	3084b03a 	or	r2,r6,r2
8112536c:	10ffffcc 	andi	r3,r2,65535
81125370:	100cd43a 	srli	r6,r2,16
81125374:	194f383a 	mul	r7,r3,r5
81125378:	1d07383a 	mul	r3,r3,r20
8112537c:	314b383a 	mul	r5,r6,r5
81125380:	3810d43a 	srli	r8,r7,16
81125384:	8121c83a 	sub	r16,r16,r4
81125388:	1947883a 	add	r3,r3,r5
8112538c:	40c7883a 	add	r3,r8,r3
81125390:	350d383a 	mul	r6,r6,r20
81125394:	1940022e 	bgeu	r3,r5,811253a0 <__udivdi3+0x408>
81125398:	01000074 	movhi	r4,1
8112539c:	310d883a 	add	r6,r6,r4
811253a0:	1828d43a 	srli	r20,r3,16
811253a4:	a18d883a 	add	r6,r20,r6
811253a8:	81803e36 	bltu	r16,r6,811254a4 <__udivdi3+0x50c>
811253ac:	81803826 	beq	r16,r6,81125490 <__udivdi3+0x4f8>
811253b0:	0007883a 	mov	r3,zero
811253b4:	003fa206 	br	81125240 <__reset+0xfb105240>
811253b8:	88e2983a 	sll	r17,r17,r3
811253bc:	80a8d83a 	srl	r20,r16,r2
811253c0:	80e0983a 	sll	r16,r16,r3
811253c4:	882ad43a 	srli	r21,r17,16
811253c8:	9884d83a 	srl	r2,r19,r2
811253cc:	a009883a 	mov	r4,r20
811253d0:	a80b883a 	mov	r5,r21
811253d4:	142eb03a 	or	r23,r2,r16
811253d8:	98e4983a 	sll	r18,r19,r3
811253dc:	1125bb40 	call	81125bb4 <__umodsi3>
811253e0:	a009883a 	mov	r4,r20
811253e4:	a80b883a 	mov	r5,r21
811253e8:	1021883a 	mov	r16,r2
811253ec:	1125b500 	call	81125b50 <__udivsi3>
811253f0:	1039883a 	mov	fp,r2
811253f4:	8d3fffcc 	andi	r20,r17,65535
811253f8:	8020943a 	slli	r16,r16,16
811253fc:	b804d43a 	srli	r2,r23,16
81125400:	a72d383a 	mul	r22,r20,fp
81125404:	1404b03a 	or	r2,r2,r16
81125408:	1580062e 	bgeu	r2,r22,81125424 <__udivdi3+0x48c>
8112540c:	1445883a 	add	r2,r2,r17
81125410:	e0ffffc4 	addi	r3,fp,-1
81125414:	14403836 	bltu	r2,r17,811254f8 <__udivdi3+0x560>
81125418:	1580372e 	bgeu	r2,r22,811254f8 <__udivdi3+0x560>
8112541c:	e73fff84 	addi	fp,fp,-2
81125420:	1445883a 	add	r2,r2,r17
81125424:	15adc83a 	sub	r22,r2,r22
81125428:	a80b883a 	mov	r5,r21
8112542c:	b009883a 	mov	r4,r22
81125430:	1125bb40 	call	81125bb4 <__umodsi3>
81125434:	1027883a 	mov	r19,r2
81125438:	b009883a 	mov	r4,r22
8112543c:	a80b883a 	mov	r5,r21
81125440:	1125b500 	call	81125b50 <__udivsi3>
81125444:	9826943a 	slli	r19,r19,16
81125448:	a0a1383a 	mul	r16,r20,r2
8112544c:	b93fffcc 	andi	r4,r23,65535
81125450:	24c8b03a 	or	r4,r4,r19
81125454:	2400062e 	bgeu	r4,r16,81125470 <__udivdi3+0x4d8>
81125458:	2449883a 	add	r4,r4,r17
8112545c:	10ffffc4 	addi	r3,r2,-1
81125460:	24402336 	bltu	r4,r17,811254f0 <__udivdi3+0x558>
81125464:	2400222e 	bgeu	r4,r16,811254f0 <__udivdi3+0x558>
81125468:	10bfff84 	addi	r2,r2,-2
8112546c:	2449883a 	add	r4,r4,r17
81125470:	e038943a 	slli	fp,fp,16
81125474:	2421c83a 	sub	r16,r4,r16
81125478:	e086b03a 	or	r3,fp,r2
8112547c:	003f4306 	br	8112518c <__reset+0xfb10518c>
81125480:	2005883a 	mov	r2,r4
81125484:	003f6906 	br	8112522c <__reset+0xfb10522c>
81125488:	1805883a 	mov	r2,r3
8112548c:	003f0f06 	br	811250cc <__reset+0xfb1050cc>
81125490:	1806943a 	slli	r3,r3,16
81125494:	9d66983a 	sll	r19,r19,r21
81125498:	39ffffcc 	andi	r7,r7,65535
8112549c:	19c7883a 	add	r3,r3,r7
811254a0:	98ffc32e 	bgeu	r19,r3,811253b0 <__reset+0xfb1053b0>
811254a4:	10bfffc4 	addi	r2,r2,-1
811254a8:	003fc106 	br	811253b0 <__reset+0xfb1053b0>
811254ac:	00800604 	movi	r2,24
811254b0:	003f1106 	br	811250f8 <__reset+0xfb1050f8>
811254b4:	00800604 	movi	r2,24
811254b8:	003f2706 	br	81125158 <__reset+0xfb105158>
811254bc:	00800604 	movi	r2,24
811254c0:	003ece06 	br	81124ffc <__reset+0xfb104ffc>
811254c4:	0007883a 	mov	r3,zero
811254c8:	00800044 	movi	r2,1
811254cc:	003f5c06 	br	81125240 <__reset+0xfb105240>
811254d0:	813fa12e 	bgeu	r16,r4,81125358 <__reset+0xfb105358>
811254d4:	10bfff84 	addi	r2,r2,-2
811254d8:	85e1883a 	add	r16,r16,r23
811254dc:	003f9f06 	br	8112535c <__reset+0xfb10535c>
811254e0:	1c7f8a2e 	bgeu	r3,r17,8112530c <__reset+0xfb10530c>
811254e4:	31bfff84 	addi	r6,r6,-2
811254e8:	1dc7883a 	add	r3,r3,r23
811254ec:	003f8806 	br	81125310 <__reset+0xfb105310>
811254f0:	1805883a 	mov	r2,r3
811254f4:	003fde06 	br	81125470 <__reset+0xfb105470>
811254f8:	1839883a 	mov	fp,r3
811254fc:	003fc906 	br	81125424 <__reset+0xfb105424>
81125500:	b5bfff84 	addi	r22,r22,-2
81125504:	2449883a 	add	r4,r4,r17
81125508:	003f3406 	br	811251dc <__reset+0xfb1051dc>
8112550c:	b5bfff84 	addi	r22,r22,-2
81125510:	1445883a 	add	r2,r2,r17
81125514:	003edb06 	br	81125084 <__reset+0xfb105084>

81125518 <__umoddi3>:
81125518:	defff404 	addi	sp,sp,-48
8112551c:	de00012e 	bgeu	sp,et,81125524 <__umoddi3+0xc>
81125520:	003b68fa 	trap	3
81125524:	df000a15 	stw	fp,40(sp)
81125528:	dc400315 	stw	r17,12(sp)
8112552c:	dc000215 	stw	r16,8(sp)
81125530:	dfc00b15 	stw	ra,44(sp)
81125534:	ddc00915 	stw	r23,36(sp)
81125538:	dd800815 	stw	r22,32(sp)
8112553c:	dd400715 	stw	r21,28(sp)
81125540:	dd000615 	stw	r20,24(sp)
81125544:	dcc00515 	stw	r19,20(sp)
81125548:	dc800415 	stw	r18,16(sp)
8112554c:	2021883a 	mov	r16,r4
81125550:	2823883a 	mov	r17,r5
81125554:	2839883a 	mov	fp,r5
81125558:	38003c1e 	bne	r7,zero,8112564c <__umoddi3+0x134>
8112555c:	3027883a 	mov	r19,r6
81125560:	2029883a 	mov	r20,r4
81125564:	2980512e 	bgeu	r5,r6,811256ac <__umoddi3+0x194>
81125568:	00bfffd4 	movui	r2,65535
8112556c:	11809a36 	bltu	r2,r6,811257d8 <__umoddi3+0x2c0>
81125570:	01003fc4 	movi	r4,255
81125574:	2189803a 	cmpltu	r4,r4,r6
81125578:	200890fa 	slli	r4,r4,3
8112557c:	3104d83a 	srl	r2,r6,r4
81125580:	00e04534 	movhi	r3,33044
81125584:	18fcbd04 	addi	r3,r3,-3340
81125588:	1885883a 	add	r2,r3,r2
8112558c:	10c00003 	ldbu	r3,0(r2)
81125590:	00800804 	movi	r2,32
81125594:	1909883a 	add	r4,r3,r4
81125598:	1125c83a 	sub	r18,r2,r4
8112559c:	90000526 	beq	r18,zero,811255b4 <__umoddi3+0x9c>
811255a0:	8ca2983a 	sll	r17,r17,r18
811255a4:	8108d83a 	srl	r4,r16,r4
811255a8:	34a6983a 	sll	r19,r6,r18
811255ac:	84a8983a 	sll	r20,r16,r18
811255b0:	2478b03a 	or	fp,r4,r17
811255b4:	982ed43a 	srli	r23,r19,16
811255b8:	e009883a 	mov	r4,fp
811255bc:	9dbfffcc 	andi	r22,r19,65535
811255c0:	b80b883a 	mov	r5,r23
811255c4:	1125bb40 	call	81125bb4 <__umodsi3>
811255c8:	e009883a 	mov	r4,fp
811255cc:	b80b883a 	mov	r5,r23
811255d0:	102b883a 	mov	r21,r2
811255d4:	1125b500 	call	81125b50 <__udivsi3>
811255d8:	a806943a 	slli	r3,r21,16
811255dc:	a008d43a 	srli	r4,r20,16
811255e0:	b085383a 	mul	r2,r22,r2
811255e4:	20c8b03a 	or	r4,r4,r3
811255e8:	2080032e 	bgeu	r4,r2,811255f8 <__umoddi3+0xe0>
811255ec:	24c9883a 	add	r4,r4,r19
811255f0:	24c00136 	bltu	r4,r19,811255f8 <__umoddi3+0xe0>
811255f4:	20811036 	bltu	r4,r2,81125a38 <__umoddi3+0x520>
811255f8:	20abc83a 	sub	r21,r4,r2
811255fc:	b80b883a 	mov	r5,r23
81125600:	a809883a 	mov	r4,r21
81125604:	1125bb40 	call	81125bb4 <__umodsi3>
81125608:	1023883a 	mov	r17,r2
8112560c:	b80b883a 	mov	r5,r23
81125610:	a809883a 	mov	r4,r21
81125614:	1125b500 	call	81125b50 <__udivsi3>
81125618:	8822943a 	slli	r17,r17,16
8112561c:	b085383a 	mul	r2,r22,r2
81125620:	a0ffffcc 	andi	r3,r20,65535
81125624:	1c46b03a 	or	r3,r3,r17
81125628:	1880042e 	bgeu	r3,r2,8112563c <__umoddi3+0x124>
8112562c:	1cc7883a 	add	r3,r3,r19
81125630:	1cc00236 	bltu	r3,r19,8112563c <__umoddi3+0x124>
81125634:	1880012e 	bgeu	r3,r2,8112563c <__umoddi3+0x124>
81125638:	1cc7883a 	add	r3,r3,r19
8112563c:	1885c83a 	sub	r2,r3,r2
81125640:	1484d83a 	srl	r2,r2,r18
81125644:	0007883a 	mov	r3,zero
81125648:	00004f06 	br	81125788 <__umoddi3+0x270>
8112564c:	29c04c36 	bltu	r5,r7,81125780 <__umoddi3+0x268>
81125650:	00bfffd4 	movui	r2,65535
81125654:	11c0582e 	bgeu	r2,r7,811257b8 <__umoddi3+0x2a0>
81125658:	00804034 	movhi	r2,256
8112565c:	10bfffc4 	addi	r2,r2,-1
81125660:	11c0e736 	bltu	r2,r7,81125a00 <__umoddi3+0x4e8>
81125664:	01000404 	movi	r4,16
81125668:	3904d83a 	srl	r2,r7,r4
8112566c:	00e04534 	movhi	r3,33044
81125670:	18fcbd04 	addi	r3,r3,-3340
81125674:	1885883a 	add	r2,r3,r2
81125678:	14c00003 	ldbu	r19,0(r2)
8112567c:	00c00804 	movi	r3,32
81125680:	9927883a 	add	r19,r19,r4
81125684:	1ce9c83a 	sub	r20,r3,r19
81125688:	a000581e 	bne	r20,zero,811257ec <__umoddi3+0x2d4>
8112568c:	3c400136 	bltu	r7,r17,81125694 <__umoddi3+0x17c>
81125690:	8180eb36 	bltu	r16,r6,81125a40 <__umoddi3+0x528>
81125694:	8185c83a 	sub	r2,r16,r6
81125698:	89e3c83a 	sub	r17,r17,r7
8112569c:	8089803a 	cmpltu	r4,r16,r2
811256a0:	8939c83a 	sub	fp,r17,r4
811256a4:	e007883a 	mov	r3,fp
811256a8:	00003706 	br	81125788 <__umoddi3+0x270>
811256ac:	3000041e 	bne	r6,zero,811256c0 <__umoddi3+0x1a8>
811256b0:	000b883a 	mov	r5,zero
811256b4:	01000044 	movi	r4,1
811256b8:	1125b500 	call	81125b50 <__udivsi3>
811256bc:	1027883a 	mov	r19,r2
811256c0:	00bfffd4 	movui	r2,65535
811256c4:	14c0402e 	bgeu	r2,r19,811257c8 <__umoddi3+0x2b0>
811256c8:	00804034 	movhi	r2,256
811256cc:	10bfffc4 	addi	r2,r2,-1
811256d0:	14c0cd36 	bltu	r2,r19,81125a08 <__umoddi3+0x4f0>
811256d4:	00800404 	movi	r2,16
811256d8:	9886d83a 	srl	r3,r19,r2
811256dc:	01204534 	movhi	r4,33044
811256e0:	213cbd04 	addi	r4,r4,-3340
811256e4:	20c7883a 	add	r3,r4,r3
811256e8:	18c00003 	ldbu	r3,0(r3)
811256ec:	1887883a 	add	r3,r3,r2
811256f0:	00800804 	movi	r2,32
811256f4:	10e5c83a 	sub	r18,r2,r3
811256f8:	9000901e 	bne	r18,zero,8112593c <__umoddi3+0x424>
811256fc:	982cd43a 	srli	r22,r19,16
81125700:	8ce3c83a 	sub	r17,r17,r19
81125704:	9d7fffcc 	andi	r21,r19,65535
81125708:	b00b883a 	mov	r5,r22
8112570c:	8809883a 	mov	r4,r17
81125710:	1125bb40 	call	81125bb4 <__umodsi3>
81125714:	8809883a 	mov	r4,r17
81125718:	b00b883a 	mov	r5,r22
8112571c:	1021883a 	mov	r16,r2
81125720:	1125b500 	call	81125b50 <__udivsi3>
81125724:	8006943a 	slli	r3,r16,16
81125728:	a008d43a 	srli	r4,r20,16
8112572c:	1545383a 	mul	r2,r2,r21
81125730:	20c8b03a 	or	r4,r4,r3
81125734:	2080042e 	bgeu	r4,r2,81125748 <__umoddi3+0x230>
81125738:	24c9883a 	add	r4,r4,r19
8112573c:	24c00236 	bltu	r4,r19,81125748 <__umoddi3+0x230>
81125740:	2080012e 	bgeu	r4,r2,81125748 <__umoddi3+0x230>
81125744:	24c9883a 	add	r4,r4,r19
81125748:	20a1c83a 	sub	r16,r4,r2
8112574c:	b00b883a 	mov	r5,r22
81125750:	8009883a 	mov	r4,r16
81125754:	1125bb40 	call	81125bb4 <__umodsi3>
81125758:	1023883a 	mov	r17,r2
8112575c:	b00b883a 	mov	r5,r22
81125760:	8009883a 	mov	r4,r16
81125764:	1125b500 	call	81125b50 <__udivsi3>
81125768:	8822943a 	slli	r17,r17,16
8112576c:	1545383a 	mul	r2,r2,r21
81125770:	a53fffcc 	andi	r20,r20,65535
81125774:	a446b03a 	or	r3,r20,r17
81125778:	18bfb02e 	bgeu	r3,r2,8112563c <__reset+0xfb10563c>
8112577c:	003fab06 	br	8112562c <__reset+0xfb10562c>
81125780:	2005883a 	mov	r2,r4
81125784:	2807883a 	mov	r3,r5
81125788:	dfc00b17 	ldw	ra,44(sp)
8112578c:	df000a17 	ldw	fp,40(sp)
81125790:	ddc00917 	ldw	r23,36(sp)
81125794:	dd800817 	ldw	r22,32(sp)
81125798:	dd400717 	ldw	r21,28(sp)
8112579c:	dd000617 	ldw	r20,24(sp)
811257a0:	dcc00517 	ldw	r19,20(sp)
811257a4:	dc800417 	ldw	r18,16(sp)
811257a8:	dc400317 	ldw	r17,12(sp)
811257ac:	dc000217 	ldw	r16,8(sp)
811257b0:	dec00c04 	addi	sp,sp,48
811257b4:	f800283a 	ret
811257b8:	04c03fc4 	movi	r19,255
811257bc:	99c9803a 	cmpltu	r4,r19,r7
811257c0:	200890fa 	slli	r4,r4,3
811257c4:	003fa806 	br	81125668 <__reset+0xfb105668>
811257c8:	00803fc4 	movi	r2,255
811257cc:	14c5803a 	cmpltu	r2,r2,r19
811257d0:	100490fa 	slli	r2,r2,3
811257d4:	003fc006 	br	811256d8 <__reset+0xfb1056d8>
811257d8:	00804034 	movhi	r2,256
811257dc:	10bfffc4 	addi	r2,r2,-1
811257e0:	11808b36 	bltu	r2,r6,81125a10 <__umoddi3+0x4f8>
811257e4:	01000404 	movi	r4,16
811257e8:	003f6406 	br	8112557c <__reset+0xfb10557c>
811257ec:	34c4d83a 	srl	r2,r6,r19
811257f0:	3d0e983a 	sll	r7,r7,r20
811257f4:	8cf8d83a 	srl	fp,r17,r19
811257f8:	8d10983a 	sll	r8,r17,r20
811257fc:	38aab03a 	or	r21,r7,r2
81125800:	a82cd43a 	srli	r22,r21,16
81125804:	84e2d83a 	srl	r17,r16,r19
81125808:	e009883a 	mov	r4,fp
8112580c:	b00b883a 	mov	r5,r22
81125810:	8a22b03a 	or	r17,r17,r8
81125814:	3524983a 	sll	r18,r6,r20
81125818:	1125bb40 	call	81125bb4 <__umodsi3>
8112581c:	e009883a 	mov	r4,fp
81125820:	b00b883a 	mov	r5,r22
81125824:	102f883a 	mov	r23,r2
81125828:	1125b500 	call	81125b50 <__udivsi3>
8112582c:	100d883a 	mov	r6,r2
81125830:	b808943a 	slli	r4,r23,16
81125834:	aa3fffcc 	andi	r8,r21,65535
81125838:	8804d43a 	srli	r2,r17,16
8112583c:	41af383a 	mul	r23,r8,r6
81125840:	8520983a 	sll	r16,r16,r20
81125844:	1104b03a 	or	r2,r2,r4
81125848:	15c0042e 	bgeu	r2,r23,8112585c <__umoddi3+0x344>
8112584c:	1545883a 	add	r2,r2,r21
81125850:	30ffffc4 	addi	r3,r6,-1
81125854:	1540742e 	bgeu	r2,r21,81125a28 <__umoddi3+0x510>
81125858:	180d883a 	mov	r6,r3
8112585c:	15efc83a 	sub	r23,r2,r23
81125860:	b00b883a 	mov	r5,r22
81125864:	b809883a 	mov	r4,r23
81125868:	d9800115 	stw	r6,4(sp)
8112586c:	da000015 	stw	r8,0(sp)
81125870:	1125bb40 	call	81125bb4 <__umodsi3>
81125874:	b00b883a 	mov	r5,r22
81125878:	b809883a 	mov	r4,r23
8112587c:	1039883a 	mov	fp,r2
81125880:	1125b500 	call	81125b50 <__udivsi3>
81125884:	da000017 	ldw	r8,0(sp)
81125888:	e038943a 	slli	fp,fp,16
8112588c:	100b883a 	mov	r5,r2
81125890:	4089383a 	mul	r4,r8,r2
81125894:	8a3fffcc 	andi	r8,r17,65535
81125898:	4710b03a 	or	r8,r8,fp
8112589c:	d9800117 	ldw	r6,4(sp)
811258a0:	4100042e 	bgeu	r8,r4,811258b4 <__umoddi3+0x39c>
811258a4:	4551883a 	add	r8,r8,r21
811258a8:	10bfffc4 	addi	r2,r2,-1
811258ac:	45405a2e 	bgeu	r8,r21,81125a18 <__umoddi3+0x500>
811258b0:	100b883a 	mov	r5,r2
811258b4:	300c943a 	slli	r6,r6,16
811258b8:	91ffffcc 	andi	r7,r18,65535
811258bc:	9004d43a 	srli	r2,r18,16
811258c0:	314cb03a 	or	r6,r6,r5
811258c4:	317fffcc 	andi	r5,r6,65535
811258c8:	300cd43a 	srli	r6,r6,16
811258cc:	29d3383a 	mul	r9,r5,r7
811258d0:	288b383a 	mul	r5,r5,r2
811258d4:	31cf383a 	mul	r7,r6,r7
811258d8:	4806d43a 	srli	r3,r9,16
811258dc:	4111c83a 	sub	r8,r8,r4
811258e0:	29cb883a 	add	r5,r5,r7
811258e4:	194b883a 	add	r5,r3,r5
811258e8:	3085383a 	mul	r2,r6,r2
811258ec:	29c0022e 	bgeu	r5,r7,811258f8 <__umoddi3+0x3e0>
811258f0:	00c00074 	movhi	r3,1
811258f4:	10c5883a 	add	r2,r2,r3
811258f8:	2808d43a 	srli	r4,r5,16
811258fc:	280a943a 	slli	r5,r5,16
81125900:	4a7fffcc 	andi	r9,r9,65535
81125904:	2085883a 	add	r2,r4,r2
81125908:	2a4b883a 	add	r5,r5,r9
8112590c:	40803636 	bltu	r8,r2,811259e8 <__umoddi3+0x4d0>
81125910:	40804d26 	beq	r8,r2,81125a48 <__umoddi3+0x530>
81125914:	4089c83a 	sub	r4,r8,r2
81125918:	280f883a 	mov	r7,r5
8112591c:	81cfc83a 	sub	r7,r16,r7
81125920:	81c7803a 	cmpltu	r3,r16,r7
81125924:	20c7c83a 	sub	r3,r4,r3
81125928:	1cc4983a 	sll	r2,r3,r19
8112592c:	3d0ed83a 	srl	r7,r7,r20
81125930:	1d06d83a 	srl	r3,r3,r20
81125934:	11c4b03a 	or	r2,r2,r7
81125938:	003f9306 	br	81125788 <__reset+0xfb105788>
8112593c:	9ca6983a 	sll	r19,r19,r18
81125940:	88e8d83a 	srl	r20,r17,r3
81125944:	80c4d83a 	srl	r2,r16,r3
81125948:	982cd43a 	srli	r22,r19,16
8112594c:	8ca2983a 	sll	r17,r17,r18
81125950:	a009883a 	mov	r4,r20
81125954:	b00b883a 	mov	r5,r22
81125958:	1478b03a 	or	fp,r2,r17
8112595c:	1125bb40 	call	81125bb4 <__umodsi3>
81125960:	a009883a 	mov	r4,r20
81125964:	b00b883a 	mov	r5,r22
81125968:	1023883a 	mov	r17,r2
8112596c:	1125b500 	call	81125b50 <__udivsi3>
81125970:	9d7fffcc 	andi	r21,r19,65535
81125974:	880a943a 	slli	r5,r17,16
81125978:	e008d43a 	srli	r4,fp,16
8112597c:	a885383a 	mul	r2,r21,r2
81125980:	84a8983a 	sll	r20,r16,r18
81125984:	2148b03a 	or	r4,r4,r5
81125988:	2080042e 	bgeu	r4,r2,8112599c <__umoddi3+0x484>
8112598c:	24c9883a 	add	r4,r4,r19
81125990:	24c00236 	bltu	r4,r19,8112599c <__umoddi3+0x484>
81125994:	2080012e 	bgeu	r4,r2,8112599c <__umoddi3+0x484>
81125998:	24c9883a 	add	r4,r4,r19
8112599c:	20a3c83a 	sub	r17,r4,r2
811259a0:	b00b883a 	mov	r5,r22
811259a4:	8809883a 	mov	r4,r17
811259a8:	1125bb40 	call	81125bb4 <__umodsi3>
811259ac:	102f883a 	mov	r23,r2
811259b0:	8809883a 	mov	r4,r17
811259b4:	b00b883a 	mov	r5,r22
811259b8:	1125b500 	call	81125b50 <__udivsi3>
811259bc:	b82e943a 	slli	r23,r23,16
811259c0:	a885383a 	mul	r2,r21,r2
811259c4:	e13fffcc 	andi	r4,fp,65535
811259c8:	25c8b03a 	or	r4,r4,r23
811259cc:	2080042e 	bgeu	r4,r2,811259e0 <__umoddi3+0x4c8>
811259d0:	24c9883a 	add	r4,r4,r19
811259d4:	24c00236 	bltu	r4,r19,811259e0 <__umoddi3+0x4c8>
811259d8:	2080012e 	bgeu	r4,r2,811259e0 <__umoddi3+0x4c8>
811259dc:	24c9883a 	add	r4,r4,r19
811259e0:	20a3c83a 	sub	r17,r4,r2
811259e4:	003f4806 	br	81125708 <__reset+0xfb105708>
811259e8:	2c8fc83a 	sub	r7,r5,r18
811259ec:	1545c83a 	sub	r2,r2,r21
811259f0:	29cb803a 	cmpltu	r5,r5,r7
811259f4:	1145c83a 	sub	r2,r2,r5
811259f8:	4089c83a 	sub	r4,r8,r2
811259fc:	003fc706 	br	8112591c <__reset+0xfb10591c>
81125a00:	01000604 	movi	r4,24
81125a04:	003f1806 	br	81125668 <__reset+0xfb105668>
81125a08:	00800604 	movi	r2,24
81125a0c:	003f3206 	br	811256d8 <__reset+0xfb1056d8>
81125a10:	01000604 	movi	r4,24
81125a14:	003ed906 	br	8112557c <__reset+0xfb10557c>
81125a18:	413fa52e 	bgeu	r8,r4,811258b0 <__reset+0xfb1058b0>
81125a1c:	297fff84 	addi	r5,r5,-2
81125a20:	4551883a 	add	r8,r8,r21
81125a24:	003fa306 	br	811258b4 <__reset+0xfb1058b4>
81125a28:	15ff8b2e 	bgeu	r2,r23,81125858 <__reset+0xfb105858>
81125a2c:	31bfff84 	addi	r6,r6,-2
81125a30:	1545883a 	add	r2,r2,r21
81125a34:	003f8906 	br	8112585c <__reset+0xfb10585c>
81125a38:	24c9883a 	add	r4,r4,r19
81125a3c:	003eee06 	br	811255f8 <__reset+0xfb1055f8>
81125a40:	8005883a 	mov	r2,r16
81125a44:	003f1706 	br	811256a4 <__reset+0xfb1056a4>
81125a48:	817fe736 	bltu	r16,r5,811259e8 <__reset+0xfb1059e8>
81125a4c:	280f883a 	mov	r7,r5
81125a50:	0009883a 	mov	r4,zero
81125a54:	003fb106 	br	8112591c <__reset+0xfb10591c>

81125a58 <__divsi3>:
81125a58:	20001b16 	blt	r4,zero,81125ac8 <__divsi3+0x70>
81125a5c:	000f883a 	mov	r7,zero
81125a60:	28001616 	blt	r5,zero,81125abc <__divsi3+0x64>
81125a64:	200d883a 	mov	r6,r4
81125a68:	29001a2e 	bgeu	r5,r4,81125ad4 <__divsi3+0x7c>
81125a6c:	00800804 	movi	r2,32
81125a70:	00c00044 	movi	r3,1
81125a74:	00000106 	br	81125a7c <__divsi3+0x24>
81125a78:	10000d26 	beq	r2,zero,81125ab0 <__divsi3+0x58>
81125a7c:	294b883a 	add	r5,r5,r5
81125a80:	10bfffc4 	addi	r2,r2,-1
81125a84:	18c7883a 	add	r3,r3,r3
81125a88:	293ffb36 	bltu	r5,r4,81125a78 <__reset+0xfb105a78>
81125a8c:	0005883a 	mov	r2,zero
81125a90:	18000726 	beq	r3,zero,81125ab0 <__divsi3+0x58>
81125a94:	0005883a 	mov	r2,zero
81125a98:	31400236 	bltu	r6,r5,81125aa4 <__divsi3+0x4c>
81125a9c:	314dc83a 	sub	r6,r6,r5
81125aa0:	10c4b03a 	or	r2,r2,r3
81125aa4:	1806d07a 	srli	r3,r3,1
81125aa8:	280ad07a 	srli	r5,r5,1
81125aac:	183ffa1e 	bne	r3,zero,81125a98 <__reset+0xfb105a98>
81125ab0:	38000126 	beq	r7,zero,81125ab8 <__divsi3+0x60>
81125ab4:	0085c83a 	sub	r2,zero,r2
81125ab8:	f800283a 	ret
81125abc:	014bc83a 	sub	r5,zero,r5
81125ac0:	39c0005c 	xori	r7,r7,1
81125ac4:	003fe706 	br	81125a64 <__reset+0xfb105a64>
81125ac8:	0109c83a 	sub	r4,zero,r4
81125acc:	01c00044 	movi	r7,1
81125ad0:	003fe306 	br	81125a60 <__reset+0xfb105a60>
81125ad4:	00c00044 	movi	r3,1
81125ad8:	003fee06 	br	81125a94 <__reset+0xfb105a94>

81125adc <__modsi3>:
81125adc:	20001716 	blt	r4,zero,81125b3c <__modsi3+0x60>
81125ae0:	000f883a 	mov	r7,zero
81125ae4:	2005883a 	mov	r2,r4
81125ae8:	28001216 	blt	r5,zero,81125b34 <__modsi3+0x58>
81125aec:	2900162e 	bgeu	r5,r4,81125b48 <__modsi3+0x6c>
81125af0:	01800804 	movi	r6,32
81125af4:	00c00044 	movi	r3,1
81125af8:	00000106 	br	81125b00 <__modsi3+0x24>
81125afc:	30000a26 	beq	r6,zero,81125b28 <__modsi3+0x4c>
81125b00:	294b883a 	add	r5,r5,r5
81125b04:	31bfffc4 	addi	r6,r6,-1
81125b08:	18c7883a 	add	r3,r3,r3
81125b0c:	293ffb36 	bltu	r5,r4,81125afc <__reset+0xfb105afc>
81125b10:	18000526 	beq	r3,zero,81125b28 <__modsi3+0x4c>
81125b14:	1806d07a 	srli	r3,r3,1
81125b18:	11400136 	bltu	r2,r5,81125b20 <__modsi3+0x44>
81125b1c:	1145c83a 	sub	r2,r2,r5
81125b20:	280ad07a 	srli	r5,r5,1
81125b24:	183ffb1e 	bne	r3,zero,81125b14 <__reset+0xfb105b14>
81125b28:	38000126 	beq	r7,zero,81125b30 <__modsi3+0x54>
81125b2c:	0085c83a 	sub	r2,zero,r2
81125b30:	f800283a 	ret
81125b34:	014bc83a 	sub	r5,zero,r5
81125b38:	003fec06 	br	81125aec <__reset+0xfb105aec>
81125b3c:	0109c83a 	sub	r4,zero,r4
81125b40:	01c00044 	movi	r7,1
81125b44:	003fe706 	br	81125ae4 <__reset+0xfb105ae4>
81125b48:	00c00044 	movi	r3,1
81125b4c:	003ff106 	br	81125b14 <__reset+0xfb105b14>

81125b50 <__udivsi3>:
81125b50:	200d883a 	mov	r6,r4
81125b54:	2900152e 	bgeu	r5,r4,81125bac <__udivsi3+0x5c>
81125b58:	28001416 	blt	r5,zero,81125bac <__udivsi3+0x5c>
81125b5c:	00800804 	movi	r2,32
81125b60:	00c00044 	movi	r3,1
81125b64:	00000206 	br	81125b70 <__udivsi3+0x20>
81125b68:	10000e26 	beq	r2,zero,81125ba4 <__udivsi3+0x54>
81125b6c:	28000516 	blt	r5,zero,81125b84 <__udivsi3+0x34>
81125b70:	294b883a 	add	r5,r5,r5
81125b74:	10bfffc4 	addi	r2,r2,-1
81125b78:	18c7883a 	add	r3,r3,r3
81125b7c:	293ffa36 	bltu	r5,r4,81125b68 <__reset+0xfb105b68>
81125b80:	18000826 	beq	r3,zero,81125ba4 <__udivsi3+0x54>
81125b84:	0005883a 	mov	r2,zero
81125b88:	31400236 	bltu	r6,r5,81125b94 <__udivsi3+0x44>
81125b8c:	314dc83a 	sub	r6,r6,r5
81125b90:	10c4b03a 	or	r2,r2,r3
81125b94:	1806d07a 	srli	r3,r3,1
81125b98:	280ad07a 	srli	r5,r5,1
81125b9c:	183ffa1e 	bne	r3,zero,81125b88 <__reset+0xfb105b88>
81125ba0:	f800283a 	ret
81125ba4:	0005883a 	mov	r2,zero
81125ba8:	f800283a 	ret
81125bac:	00c00044 	movi	r3,1
81125bb0:	003ff406 	br	81125b84 <__reset+0xfb105b84>

81125bb4 <__umodsi3>:
81125bb4:	2005883a 	mov	r2,r4
81125bb8:	2900122e 	bgeu	r5,r4,81125c04 <__umodsi3+0x50>
81125bbc:	28001116 	blt	r5,zero,81125c04 <__umodsi3+0x50>
81125bc0:	01800804 	movi	r6,32
81125bc4:	00c00044 	movi	r3,1
81125bc8:	00000206 	br	81125bd4 <__umodsi3+0x20>
81125bcc:	30000c26 	beq	r6,zero,81125c00 <__umodsi3+0x4c>
81125bd0:	28000516 	blt	r5,zero,81125be8 <__umodsi3+0x34>
81125bd4:	294b883a 	add	r5,r5,r5
81125bd8:	31bfffc4 	addi	r6,r6,-1
81125bdc:	18c7883a 	add	r3,r3,r3
81125be0:	293ffa36 	bltu	r5,r4,81125bcc <__reset+0xfb105bcc>
81125be4:	18000626 	beq	r3,zero,81125c00 <__umodsi3+0x4c>
81125be8:	1806d07a 	srli	r3,r3,1
81125bec:	11400136 	bltu	r2,r5,81125bf4 <__umodsi3+0x40>
81125bf0:	1145c83a 	sub	r2,r2,r5
81125bf4:	280ad07a 	srli	r5,r5,1
81125bf8:	183ffb1e 	bne	r3,zero,81125be8 <__reset+0xfb105be8>
81125bfc:	f800283a 	ret
81125c00:	f800283a 	ret
81125c04:	00c00044 	movi	r3,1
81125c08:	003ff706 	br	81125be8 <__reset+0xfb105be8>

81125c0c <__eqsf2>:
81125c0c:	2006d5fa 	srli	r3,r4,23
81125c10:	280cd5fa 	srli	r6,r5,23
81125c14:	01c02034 	movhi	r7,128
81125c18:	39ffffc4 	addi	r7,r7,-1
81125c1c:	18c03fcc 	andi	r3,r3,255
81125c20:	02003fc4 	movi	r8,255
81125c24:	3904703a 	and	r2,r7,r4
81125c28:	31803fcc 	andi	r6,r6,255
81125c2c:	394e703a 	and	r7,r7,r5
81125c30:	2008d7fa 	srli	r4,r4,31
81125c34:	280ad7fa 	srli	r5,r5,31
81125c38:	1a000d26 	beq	r3,r8,81125c70 <__eqsf2+0x64>
81125c3c:	02003fc4 	movi	r8,255
81125c40:	32000826 	beq	r6,r8,81125c64 <__eqsf2+0x58>
81125c44:	19800226 	beq	r3,r6,81125c50 <__eqsf2+0x44>
81125c48:	00800044 	movi	r2,1
81125c4c:	f800283a 	ret
81125c50:	11fffd1e 	bne	r2,r7,81125c48 <__reset+0xfb105c48>
81125c54:	21400926 	beq	r4,r5,81125c7c <__eqsf2+0x70>
81125c58:	183ffb1e 	bne	r3,zero,81125c48 <__reset+0xfb105c48>
81125c5c:	1004c03a 	cmpne	r2,r2,zero
81125c60:	f800283a 	ret
81125c64:	383ff726 	beq	r7,zero,81125c44 <__reset+0xfb105c44>
81125c68:	00800044 	movi	r2,1
81125c6c:	f800283a 	ret
81125c70:	103ff226 	beq	r2,zero,81125c3c <__reset+0xfb105c3c>
81125c74:	00800044 	movi	r2,1
81125c78:	f800283a 	ret
81125c7c:	0005883a 	mov	r2,zero
81125c80:	f800283a 	ret

81125c84 <__gesf2>:
81125c84:	2004d5fa 	srli	r2,r4,23
81125c88:	2806d5fa 	srli	r3,r5,23
81125c8c:	01802034 	movhi	r6,128
81125c90:	31bfffc4 	addi	r6,r6,-1
81125c94:	10803fcc 	andi	r2,r2,255
81125c98:	01c03fc4 	movi	r7,255
81125c9c:	3110703a 	and	r8,r6,r4
81125ca0:	18c03fcc 	andi	r3,r3,255
81125ca4:	314c703a 	and	r6,r6,r5
81125ca8:	2008d7fa 	srli	r4,r4,31
81125cac:	280ad7fa 	srli	r5,r5,31
81125cb0:	11c01926 	beq	r2,r7,81125d18 <__gesf2+0x94>
81125cb4:	01c03fc4 	movi	r7,255
81125cb8:	19c00f26 	beq	r3,r7,81125cf8 <__gesf2+0x74>
81125cbc:	1000061e 	bne	r2,zero,81125cd8 <__gesf2+0x54>
81125cc0:	400f003a 	cmpeq	r7,r8,zero
81125cc4:	1800071e 	bne	r3,zero,81125ce4 <__gesf2+0x60>
81125cc8:	3000061e 	bne	r6,zero,81125ce4 <__gesf2+0x60>
81125ccc:	0005883a 	mov	r2,zero
81125cd0:	40000e1e 	bne	r8,zero,81125d0c <__gesf2+0x88>
81125cd4:	f800283a 	ret
81125cd8:	18000a1e 	bne	r3,zero,81125d04 <__gesf2+0x80>
81125cdc:	30000b26 	beq	r6,zero,81125d0c <__gesf2+0x88>
81125ce0:	000f883a 	mov	r7,zero
81125ce4:	29403fcc 	andi	r5,r5,255
81125ce8:	38000726 	beq	r7,zero,81125d08 <__gesf2+0x84>
81125cec:	28000826 	beq	r5,zero,81125d10 <__gesf2+0x8c>
81125cf0:	00800044 	movi	r2,1
81125cf4:	f800283a 	ret
81125cf8:	303ff026 	beq	r6,zero,81125cbc <__reset+0xfb105cbc>
81125cfc:	00bfff84 	movi	r2,-2
81125d00:	f800283a 	ret
81125d04:	29403fcc 	andi	r5,r5,255
81125d08:	21400526 	beq	r4,r5,81125d20 <__gesf2+0x9c>
81125d0c:	203ff826 	beq	r4,zero,81125cf0 <__reset+0xfb105cf0>
81125d10:	00bfffc4 	movi	r2,-1
81125d14:	f800283a 	ret
81125d18:	403fe626 	beq	r8,zero,81125cb4 <__reset+0xfb105cb4>
81125d1c:	003ff706 	br	81125cfc <__reset+0xfb105cfc>
81125d20:	18bffa16 	blt	r3,r2,81125d0c <__reset+0xfb105d0c>
81125d24:	10c00216 	blt	r2,r3,81125d30 <__gesf2+0xac>
81125d28:	323ff836 	bltu	r6,r8,81125d0c <__reset+0xfb105d0c>
81125d2c:	4180022e 	bgeu	r8,r6,81125d38 <__gesf2+0xb4>
81125d30:	203fef1e 	bne	r4,zero,81125cf0 <__reset+0xfb105cf0>
81125d34:	003ff606 	br	81125d10 <__reset+0xfb105d10>
81125d38:	0005883a 	mov	r2,zero
81125d3c:	f800283a 	ret

81125d40 <__lesf2>:
81125d40:	2004d5fa 	srli	r2,r4,23
81125d44:	280cd5fa 	srli	r6,r5,23
81125d48:	00c02034 	movhi	r3,128
81125d4c:	18ffffc4 	addi	r3,r3,-1
81125d50:	10803fcc 	andi	r2,r2,255
81125d54:	01c03fc4 	movi	r7,255
81125d58:	1910703a 	and	r8,r3,r4
81125d5c:	31803fcc 	andi	r6,r6,255
81125d60:	1946703a 	and	r3,r3,r5
81125d64:	2008d7fa 	srli	r4,r4,31
81125d68:	280ad7fa 	srli	r5,r5,31
81125d6c:	11c01b26 	beq	r2,r7,81125ddc <__lesf2+0x9c>
81125d70:	01c03fc4 	movi	r7,255
81125d74:	31c01126 	beq	r6,r7,81125dbc <__lesf2+0x7c>
81125d78:	1000071e 	bne	r2,zero,81125d98 <__lesf2+0x58>
81125d7c:	400f003a 	cmpeq	r7,r8,zero
81125d80:	21003fcc 	andi	r4,r4,255
81125d84:	3000081e 	bne	r6,zero,81125da8 <__lesf2+0x68>
81125d88:	1800071e 	bne	r3,zero,81125da8 <__lesf2+0x68>
81125d8c:	0005883a 	mov	r2,zero
81125d90:	40000f1e 	bne	r8,zero,81125dd0 <__lesf2+0x90>
81125d94:	f800283a 	ret
81125d98:	21003fcc 	andi	r4,r4,255
81125d9c:	30000a1e 	bne	r6,zero,81125dc8 <__lesf2+0x88>
81125da0:	18000b26 	beq	r3,zero,81125dd0 <__lesf2+0x90>
81125da4:	000f883a 	mov	r7,zero
81125da8:	29403fcc 	andi	r5,r5,255
81125dac:	38000726 	beq	r7,zero,81125dcc <__lesf2+0x8c>
81125db0:	28000826 	beq	r5,zero,81125dd4 <__lesf2+0x94>
81125db4:	00800044 	movi	r2,1
81125db8:	f800283a 	ret
81125dbc:	183fee26 	beq	r3,zero,81125d78 <__reset+0xfb105d78>
81125dc0:	00800084 	movi	r2,2
81125dc4:	f800283a 	ret
81125dc8:	29403fcc 	andi	r5,r5,255
81125dcc:	21400626 	beq	r4,r5,81125de8 <__lesf2+0xa8>
81125dd0:	203ff826 	beq	r4,zero,81125db4 <__reset+0xfb105db4>
81125dd4:	00bfffc4 	movi	r2,-1
81125dd8:	f800283a 	ret
81125ddc:	403fe426 	beq	r8,zero,81125d70 <__reset+0xfb105d70>
81125de0:	00800084 	movi	r2,2
81125de4:	f800283a 	ret
81125de8:	30bff916 	blt	r6,r2,81125dd0 <__reset+0xfb105dd0>
81125dec:	11800216 	blt	r2,r6,81125df8 <__lesf2+0xb8>
81125df0:	1a3ff736 	bltu	r3,r8,81125dd0 <__reset+0xfb105dd0>
81125df4:	40c0022e 	bgeu	r8,r3,81125e00 <__lesf2+0xc0>
81125df8:	203fee1e 	bne	r4,zero,81125db4 <__reset+0xfb105db4>
81125dfc:	003ff506 	br	81125dd4 <__reset+0xfb105dd4>
81125e00:	0005883a 	mov	r2,zero
81125e04:	f800283a 	ret

81125e08 <__adddf3>:
81125e08:	02c00434 	movhi	r11,16
81125e0c:	5affffc4 	addi	r11,r11,-1
81125e10:	2806d7fa 	srli	r3,r5,31
81125e14:	2ad4703a 	and	r10,r5,r11
81125e18:	3ad2703a 	and	r9,r7,r11
81125e1c:	3804d53a 	srli	r2,r7,20
81125e20:	3018d77a 	srli	r12,r6,29
81125e24:	280ad53a 	srli	r5,r5,20
81125e28:	501490fa 	slli	r10,r10,3
81125e2c:	2010d77a 	srli	r8,r4,29
81125e30:	481290fa 	slli	r9,r9,3
81125e34:	380ed7fa 	srli	r7,r7,31
81125e38:	defffb04 	addi	sp,sp,-20
81125e3c:	de00012e 	bgeu	sp,et,81125e44 <__adddf3+0x3c>
81125e40:	003b68fa 	trap	3
81125e44:	dc800215 	stw	r18,8(sp)
81125e48:	dc400115 	stw	r17,4(sp)
81125e4c:	dc000015 	stw	r16,0(sp)
81125e50:	dfc00415 	stw	ra,16(sp)
81125e54:	dcc00315 	stw	r19,12(sp)
81125e58:	1c803fcc 	andi	r18,r3,255
81125e5c:	2c01ffcc 	andi	r16,r5,2047
81125e60:	5210b03a 	or	r8,r10,r8
81125e64:	202290fa 	slli	r17,r4,3
81125e68:	1081ffcc 	andi	r2,r2,2047
81125e6c:	4b12b03a 	or	r9,r9,r12
81125e70:	300c90fa 	slli	r6,r6,3
81125e74:	91c07526 	beq	r18,r7,8112604c <__adddf3+0x244>
81125e78:	8087c83a 	sub	r3,r16,r2
81125e7c:	00c0ab0e 	bge	zero,r3,8112612c <__adddf3+0x324>
81125e80:	10002a1e 	bne	r2,zero,81125f2c <__adddf3+0x124>
81125e84:	4984b03a 	or	r2,r9,r6
81125e88:	1000961e 	bne	r2,zero,811260e4 <__adddf3+0x2dc>
81125e8c:	888001cc 	andi	r2,r17,7
81125e90:	10000726 	beq	r2,zero,81125eb0 <__adddf3+0xa8>
81125e94:	888003cc 	andi	r2,r17,15
81125e98:	00c00104 	movi	r3,4
81125e9c:	10c00426 	beq	r2,r3,81125eb0 <__adddf3+0xa8>
81125ea0:	88c7883a 	add	r3,r17,r3
81125ea4:	1c63803a 	cmpltu	r17,r3,r17
81125ea8:	4451883a 	add	r8,r8,r17
81125eac:	1823883a 	mov	r17,r3
81125eb0:	4080202c 	andhi	r2,r8,128
81125eb4:	10005926 	beq	r2,zero,8112601c <__adddf3+0x214>
81125eb8:	84000044 	addi	r16,r16,1
81125ebc:	0081ffc4 	movi	r2,2047
81125ec0:	8080ba26 	beq	r16,r2,811261ac <__adddf3+0x3a4>
81125ec4:	00bfe034 	movhi	r2,65408
81125ec8:	10bfffc4 	addi	r2,r2,-1
81125ecc:	4090703a 	and	r8,r8,r2
81125ed0:	4004977a 	slli	r2,r8,29
81125ed4:	4010927a 	slli	r8,r8,9
81125ed8:	8822d0fa 	srli	r17,r17,3
81125edc:	8401ffcc 	andi	r16,r16,2047
81125ee0:	4010d33a 	srli	r8,r8,12
81125ee4:	9007883a 	mov	r3,r18
81125ee8:	1444b03a 	or	r2,r2,r17
81125eec:	8401ffcc 	andi	r16,r16,2047
81125ef0:	8020953a 	slli	r16,r16,20
81125ef4:	18c03fcc 	andi	r3,r3,255
81125ef8:	01000434 	movhi	r4,16
81125efc:	213fffc4 	addi	r4,r4,-1
81125f00:	180697fa 	slli	r3,r3,31
81125f04:	4110703a 	and	r8,r8,r4
81125f08:	4410b03a 	or	r8,r8,r16
81125f0c:	40c6b03a 	or	r3,r8,r3
81125f10:	dfc00417 	ldw	ra,16(sp)
81125f14:	dcc00317 	ldw	r19,12(sp)
81125f18:	dc800217 	ldw	r18,8(sp)
81125f1c:	dc400117 	ldw	r17,4(sp)
81125f20:	dc000017 	ldw	r16,0(sp)
81125f24:	dec00504 	addi	sp,sp,20
81125f28:	f800283a 	ret
81125f2c:	0081ffc4 	movi	r2,2047
81125f30:	80bfd626 	beq	r16,r2,81125e8c <__reset+0xfb105e8c>
81125f34:	4a402034 	orhi	r9,r9,128
81125f38:	00800e04 	movi	r2,56
81125f3c:	10c09f16 	blt	r2,r3,811261bc <__adddf3+0x3b4>
81125f40:	008007c4 	movi	r2,31
81125f44:	10c0c216 	blt	r2,r3,81126250 <__adddf3+0x448>
81125f48:	00800804 	movi	r2,32
81125f4c:	10c5c83a 	sub	r2,r2,r3
81125f50:	488a983a 	sll	r5,r9,r2
81125f54:	30c8d83a 	srl	r4,r6,r3
81125f58:	3084983a 	sll	r2,r6,r2
81125f5c:	48c6d83a 	srl	r3,r9,r3
81125f60:	290cb03a 	or	r6,r5,r4
81125f64:	1004c03a 	cmpne	r2,r2,zero
81125f68:	308cb03a 	or	r6,r6,r2
81125f6c:	898dc83a 	sub	r6,r17,r6
81125f70:	89a3803a 	cmpltu	r17,r17,r6
81125f74:	40d1c83a 	sub	r8,r8,r3
81125f78:	4451c83a 	sub	r8,r8,r17
81125f7c:	3023883a 	mov	r17,r6
81125f80:	4080202c 	andhi	r2,r8,128
81125f84:	10002326 	beq	r2,zero,81126014 <__adddf3+0x20c>
81125f88:	04c02034 	movhi	r19,128
81125f8c:	9cffffc4 	addi	r19,r19,-1
81125f90:	44e6703a 	and	r19,r8,r19
81125f94:	98007626 	beq	r19,zero,81126170 <__adddf3+0x368>
81125f98:	9809883a 	mov	r4,r19
81125f9c:	11125200 	call	81112520 <__clzsi2>
81125fa0:	10fffe04 	addi	r3,r2,-8
81125fa4:	010007c4 	movi	r4,31
81125fa8:	20c07716 	blt	r4,r3,81126188 <__adddf3+0x380>
81125fac:	00800804 	movi	r2,32
81125fb0:	10c5c83a 	sub	r2,r2,r3
81125fb4:	8884d83a 	srl	r2,r17,r2
81125fb8:	98d0983a 	sll	r8,r19,r3
81125fbc:	88e2983a 	sll	r17,r17,r3
81125fc0:	1204b03a 	or	r2,r2,r8
81125fc4:	1c007416 	blt	r3,r16,81126198 <__adddf3+0x390>
81125fc8:	1c21c83a 	sub	r16,r3,r16
81125fcc:	82000044 	addi	r8,r16,1
81125fd0:	00c007c4 	movi	r3,31
81125fd4:	1a009116 	blt	r3,r8,8112621c <__adddf3+0x414>
81125fd8:	00c00804 	movi	r3,32
81125fdc:	1a07c83a 	sub	r3,r3,r8
81125fe0:	8a08d83a 	srl	r4,r17,r8
81125fe4:	88e2983a 	sll	r17,r17,r3
81125fe8:	10c6983a 	sll	r3,r2,r3
81125fec:	1210d83a 	srl	r8,r2,r8
81125ff0:	8804c03a 	cmpne	r2,r17,zero
81125ff4:	1906b03a 	or	r3,r3,r4
81125ff8:	18a2b03a 	or	r17,r3,r2
81125ffc:	0021883a 	mov	r16,zero
81126000:	003fa206 	br	81125e8c <__reset+0xfb105e8c>
81126004:	1890b03a 	or	r8,r3,r2
81126008:	40017d26 	beq	r8,zero,81126600 <__adddf3+0x7f8>
8112600c:	1011883a 	mov	r8,r2
81126010:	1823883a 	mov	r17,r3
81126014:	888001cc 	andi	r2,r17,7
81126018:	103f9e1e 	bne	r2,zero,81125e94 <__reset+0xfb105e94>
8112601c:	4004977a 	slli	r2,r8,29
81126020:	8822d0fa 	srli	r17,r17,3
81126024:	4010d0fa 	srli	r8,r8,3
81126028:	9007883a 	mov	r3,r18
8112602c:	1444b03a 	or	r2,r2,r17
81126030:	0101ffc4 	movi	r4,2047
81126034:	81002426 	beq	r16,r4,811260c8 <__adddf3+0x2c0>
81126038:	8120703a 	and	r16,r16,r4
8112603c:	01000434 	movhi	r4,16
81126040:	213fffc4 	addi	r4,r4,-1
81126044:	4110703a 	and	r8,r8,r4
81126048:	003fa806 	br	81125eec <__reset+0xfb105eec>
8112604c:	8089c83a 	sub	r4,r16,r2
81126050:	01005e0e 	bge	zero,r4,811261cc <__adddf3+0x3c4>
81126054:	10002b26 	beq	r2,zero,81126104 <__adddf3+0x2fc>
81126058:	0081ffc4 	movi	r2,2047
8112605c:	80bf8b26 	beq	r16,r2,81125e8c <__reset+0xfb105e8c>
81126060:	4a402034 	orhi	r9,r9,128
81126064:	00800e04 	movi	r2,56
81126068:	1100a40e 	bge	r2,r4,811262fc <__adddf3+0x4f4>
8112606c:	498cb03a 	or	r6,r9,r6
81126070:	300ac03a 	cmpne	r5,r6,zero
81126074:	0013883a 	mov	r9,zero
81126078:	2c4b883a 	add	r5,r5,r17
8112607c:	2c63803a 	cmpltu	r17,r5,r17
81126080:	4a11883a 	add	r8,r9,r8
81126084:	8a11883a 	add	r8,r17,r8
81126088:	2823883a 	mov	r17,r5
8112608c:	4080202c 	andhi	r2,r8,128
81126090:	103fe026 	beq	r2,zero,81126014 <__reset+0xfb106014>
81126094:	84000044 	addi	r16,r16,1
81126098:	0081ffc4 	movi	r2,2047
8112609c:	8080d226 	beq	r16,r2,811263e8 <__adddf3+0x5e0>
811260a0:	00bfe034 	movhi	r2,65408
811260a4:	10bfffc4 	addi	r2,r2,-1
811260a8:	4090703a 	and	r8,r8,r2
811260ac:	880ad07a 	srli	r5,r17,1
811260b0:	400897fa 	slli	r4,r8,31
811260b4:	88c0004c 	andi	r3,r17,1
811260b8:	28e2b03a 	or	r17,r5,r3
811260bc:	4010d07a 	srli	r8,r8,1
811260c0:	2462b03a 	or	r17,r4,r17
811260c4:	003f7106 	br	81125e8c <__reset+0xfb105e8c>
811260c8:	4088b03a 	or	r4,r8,r2
811260cc:	20014526 	beq	r4,zero,811265e4 <__adddf3+0x7dc>
811260d0:	01000434 	movhi	r4,16
811260d4:	42000234 	orhi	r8,r8,8
811260d8:	213fffc4 	addi	r4,r4,-1
811260dc:	4110703a 	and	r8,r8,r4
811260e0:	003f8206 	br	81125eec <__reset+0xfb105eec>
811260e4:	18ffffc4 	addi	r3,r3,-1
811260e8:	1800491e 	bne	r3,zero,81126210 <__adddf3+0x408>
811260ec:	898bc83a 	sub	r5,r17,r6
811260f0:	8963803a 	cmpltu	r17,r17,r5
811260f4:	4251c83a 	sub	r8,r8,r9
811260f8:	4451c83a 	sub	r8,r8,r17
811260fc:	2823883a 	mov	r17,r5
81126100:	003f9f06 	br	81125f80 <__reset+0xfb105f80>
81126104:	4984b03a 	or	r2,r9,r6
81126108:	103f6026 	beq	r2,zero,81125e8c <__reset+0xfb105e8c>
8112610c:	213fffc4 	addi	r4,r4,-1
81126110:	2000931e 	bne	r4,zero,81126360 <__adddf3+0x558>
81126114:	898d883a 	add	r6,r17,r6
81126118:	3463803a 	cmpltu	r17,r6,r17
8112611c:	4251883a 	add	r8,r8,r9
81126120:	8a11883a 	add	r8,r17,r8
81126124:	3023883a 	mov	r17,r6
81126128:	003fd806 	br	8112608c <__reset+0xfb10608c>
8112612c:	1800541e 	bne	r3,zero,81126280 <__adddf3+0x478>
81126130:	80800044 	addi	r2,r16,1
81126134:	1081ffcc 	andi	r2,r2,2047
81126138:	00c00044 	movi	r3,1
8112613c:	1880a00e 	bge	r3,r2,811263c0 <__adddf3+0x5b8>
81126140:	8989c83a 	sub	r4,r17,r6
81126144:	8905803a 	cmpltu	r2,r17,r4
81126148:	4267c83a 	sub	r19,r8,r9
8112614c:	98a7c83a 	sub	r19,r19,r2
81126150:	9880202c 	andhi	r2,r19,128
81126154:	10006326 	beq	r2,zero,811262e4 <__adddf3+0x4dc>
81126158:	3463c83a 	sub	r17,r6,r17
8112615c:	4a07c83a 	sub	r3,r9,r8
81126160:	344d803a 	cmpltu	r6,r6,r17
81126164:	19a7c83a 	sub	r19,r3,r6
81126168:	3825883a 	mov	r18,r7
8112616c:	983f8a1e 	bne	r19,zero,81125f98 <__reset+0xfb105f98>
81126170:	8809883a 	mov	r4,r17
81126174:	11125200 	call	81112520 <__clzsi2>
81126178:	10800804 	addi	r2,r2,32
8112617c:	10fffe04 	addi	r3,r2,-8
81126180:	010007c4 	movi	r4,31
81126184:	20ff890e 	bge	r4,r3,81125fac <__reset+0xfb105fac>
81126188:	10bff604 	addi	r2,r2,-40
8112618c:	8884983a 	sll	r2,r17,r2
81126190:	0023883a 	mov	r17,zero
81126194:	1c3f8c0e 	bge	r3,r16,81125fc8 <__reset+0xfb105fc8>
81126198:	023fe034 	movhi	r8,65408
8112619c:	423fffc4 	addi	r8,r8,-1
811261a0:	80e1c83a 	sub	r16,r16,r3
811261a4:	1210703a 	and	r8,r2,r8
811261a8:	003f3806 	br	81125e8c <__reset+0xfb105e8c>
811261ac:	9007883a 	mov	r3,r18
811261b0:	0011883a 	mov	r8,zero
811261b4:	0005883a 	mov	r2,zero
811261b8:	003f4c06 	br	81125eec <__reset+0xfb105eec>
811261bc:	498cb03a 	or	r6,r9,r6
811261c0:	300cc03a 	cmpne	r6,r6,zero
811261c4:	0007883a 	mov	r3,zero
811261c8:	003f6806 	br	81125f6c <__reset+0xfb105f6c>
811261cc:	20009c1e 	bne	r4,zero,81126440 <__adddf3+0x638>
811261d0:	80800044 	addi	r2,r16,1
811261d4:	1141ffcc 	andi	r5,r2,2047
811261d8:	01000044 	movi	r4,1
811261dc:	2140670e 	bge	r4,r5,8112637c <__adddf3+0x574>
811261e0:	0101ffc4 	movi	r4,2047
811261e4:	11007f26 	beq	r2,r4,811263e4 <__adddf3+0x5dc>
811261e8:	898d883a 	add	r6,r17,r6
811261ec:	4247883a 	add	r3,r8,r9
811261f0:	3451803a 	cmpltu	r8,r6,r17
811261f4:	40d1883a 	add	r8,r8,r3
811261f8:	402297fa 	slli	r17,r8,31
811261fc:	300cd07a 	srli	r6,r6,1
81126200:	4010d07a 	srli	r8,r8,1
81126204:	1021883a 	mov	r16,r2
81126208:	89a2b03a 	or	r17,r17,r6
8112620c:	003f1f06 	br	81125e8c <__reset+0xfb105e8c>
81126210:	0081ffc4 	movi	r2,2047
81126214:	80bf481e 	bne	r16,r2,81125f38 <__reset+0xfb105f38>
81126218:	003f1c06 	br	81125e8c <__reset+0xfb105e8c>
8112621c:	843ff844 	addi	r16,r16,-31
81126220:	01000804 	movi	r4,32
81126224:	1406d83a 	srl	r3,r2,r16
81126228:	41005026 	beq	r8,r4,8112636c <__adddf3+0x564>
8112622c:	01001004 	movi	r4,64
81126230:	2211c83a 	sub	r8,r4,r8
81126234:	1204983a 	sll	r2,r2,r8
81126238:	88a2b03a 	or	r17,r17,r2
8112623c:	8822c03a 	cmpne	r17,r17,zero
81126240:	1c62b03a 	or	r17,r3,r17
81126244:	0011883a 	mov	r8,zero
81126248:	0021883a 	mov	r16,zero
8112624c:	003f7106 	br	81126014 <__reset+0xfb106014>
81126250:	193ff804 	addi	r4,r3,-32
81126254:	00800804 	movi	r2,32
81126258:	4908d83a 	srl	r4,r9,r4
8112625c:	18804526 	beq	r3,r2,81126374 <__adddf3+0x56c>
81126260:	00801004 	movi	r2,64
81126264:	10c5c83a 	sub	r2,r2,r3
81126268:	4886983a 	sll	r3,r9,r2
8112626c:	198cb03a 	or	r6,r3,r6
81126270:	300cc03a 	cmpne	r6,r6,zero
81126274:	218cb03a 	or	r6,r4,r6
81126278:	0007883a 	mov	r3,zero
8112627c:	003f3b06 	br	81125f6c <__reset+0xfb105f6c>
81126280:	80002a26 	beq	r16,zero,8112632c <__adddf3+0x524>
81126284:	0101ffc4 	movi	r4,2047
81126288:	11006826 	beq	r2,r4,8112642c <__adddf3+0x624>
8112628c:	00c7c83a 	sub	r3,zero,r3
81126290:	42002034 	orhi	r8,r8,128
81126294:	01000e04 	movi	r4,56
81126298:	20c07c16 	blt	r4,r3,8112648c <__adddf3+0x684>
8112629c:	010007c4 	movi	r4,31
811262a0:	20c0da16 	blt	r4,r3,8112660c <__adddf3+0x804>
811262a4:	01000804 	movi	r4,32
811262a8:	20c9c83a 	sub	r4,r4,r3
811262ac:	4114983a 	sll	r10,r8,r4
811262b0:	88cad83a 	srl	r5,r17,r3
811262b4:	8908983a 	sll	r4,r17,r4
811262b8:	40c6d83a 	srl	r3,r8,r3
811262bc:	5162b03a 	or	r17,r10,r5
811262c0:	2008c03a 	cmpne	r4,r4,zero
811262c4:	8922b03a 	or	r17,r17,r4
811262c8:	3463c83a 	sub	r17,r6,r17
811262cc:	48c7c83a 	sub	r3,r9,r3
811262d0:	344d803a 	cmpltu	r6,r6,r17
811262d4:	1991c83a 	sub	r8,r3,r6
811262d8:	1021883a 	mov	r16,r2
811262dc:	3825883a 	mov	r18,r7
811262e0:	003f2706 	br	81125f80 <__reset+0xfb105f80>
811262e4:	24d0b03a 	or	r8,r4,r19
811262e8:	40001b1e 	bne	r8,zero,81126358 <__adddf3+0x550>
811262ec:	0005883a 	mov	r2,zero
811262f0:	0007883a 	mov	r3,zero
811262f4:	0021883a 	mov	r16,zero
811262f8:	003f4d06 	br	81126030 <__reset+0xfb106030>
811262fc:	008007c4 	movi	r2,31
81126300:	11003c16 	blt	r2,r4,811263f4 <__adddf3+0x5ec>
81126304:	00800804 	movi	r2,32
81126308:	1105c83a 	sub	r2,r2,r4
8112630c:	488e983a 	sll	r7,r9,r2
81126310:	310ad83a 	srl	r5,r6,r4
81126314:	3084983a 	sll	r2,r6,r2
81126318:	4912d83a 	srl	r9,r9,r4
8112631c:	394ab03a 	or	r5,r7,r5
81126320:	1004c03a 	cmpne	r2,r2,zero
81126324:	288ab03a 	or	r5,r5,r2
81126328:	003f5306 	br	81126078 <__reset+0xfb106078>
8112632c:	4448b03a 	or	r4,r8,r17
81126330:	20003e26 	beq	r4,zero,8112642c <__adddf3+0x624>
81126334:	00c6303a 	nor	r3,zero,r3
81126338:	18003a1e 	bne	r3,zero,81126424 <__adddf3+0x61c>
8112633c:	3463c83a 	sub	r17,r6,r17
81126340:	4a07c83a 	sub	r3,r9,r8
81126344:	344d803a 	cmpltu	r6,r6,r17
81126348:	1991c83a 	sub	r8,r3,r6
8112634c:	1021883a 	mov	r16,r2
81126350:	3825883a 	mov	r18,r7
81126354:	003f0a06 	br	81125f80 <__reset+0xfb105f80>
81126358:	2023883a 	mov	r17,r4
8112635c:	003f0d06 	br	81125f94 <__reset+0xfb105f94>
81126360:	0081ffc4 	movi	r2,2047
81126364:	80bf3f1e 	bne	r16,r2,81126064 <__reset+0xfb106064>
81126368:	003ec806 	br	81125e8c <__reset+0xfb105e8c>
8112636c:	0005883a 	mov	r2,zero
81126370:	003fb106 	br	81126238 <__reset+0xfb106238>
81126374:	0007883a 	mov	r3,zero
81126378:	003fbc06 	br	8112626c <__reset+0xfb10626c>
8112637c:	4444b03a 	or	r2,r8,r17
81126380:	8000871e 	bne	r16,zero,811265a0 <__adddf3+0x798>
81126384:	1000ba26 	beq	r2,zero,81126670 <__adddf3+0x868>
81126388:	4984b03a 	or	r2,r9,r6
8112638c:	103ebf26 	beq	r2,zero,81125e8c <__reset+0xfb105e8c>
81126390:	8985883a 	add	r2,r17,r6
81126394:	4247883a 	add	r3,r8,r9
81126398:	1451803a 	cmpltu	r8,r2,r17
8112639c:	40d1883a 	add	r8,r8,r3
811263a0:	40c0202c 	andhi	r3,r8,128
811263a4:	1023883a 	mov	r17,r2
811263a8:	183f1a26 	beq	r3,zero,81126014 <__reset+0xfb106014>
811263ac:	00bfe034 	movhi	r2,65408
811263b0:	10bfffc4 	addi	r2,r2,-1
811263b4:	2021883a 	mov	r16,r4
811263b8:	4090703a 	and	r8,r8,r2
811263bc:	003eb306 	br	81125e8c <__reset+0xfb105e8c>
811263c0:	4444b03a 	or	r2,r8,r17
811263c4:	8000291e 	bne	r16,zero,8112646c <__adddf3+0x664>
811263c8:	10004b1e 	bne	r2,zero,811264f8 <__adddf3+0x6f0>
811263cc:	4990b03a 	or	r8,r9,r6
811263d0:	40008b26 	beq	r8,zero,81126600 <__adddf3+0x7f8>
811263d4:	4811883a 	mov	r8,r9
811263d8:	3023883a 	mov	r17,r6
811263dc:	3825883a 	mov	r18,r7
811263e0:	003eaa06 	br	81125e8c <__reset+0xfb105e8c>
811263e4:	1021883a 	mov	r16,r2
811263e8:	0011883a 	mov	r8,zero
811263ec:	0005883a 	mov	r2,zero
811263f0:	003f0f06 	br	81126030 <__reset+0xfb106030>
811263f4:	217ff804 	addi	r5,r4,-32
811263f8:	00800804 	movi	r2,32
811263fc:	494ad83a 	srl	r5,r9,r5
81126400:	20807d26 	beq	r4,r2,811265f8 <__adddf3+0x7f0>
81126404:	00801004 	movi	r2,64
81126408:	1109c83a 	sub	r4,r2,r4
8112640c:	4912983a 	sll	r9,r9,r4
81126410:	498cb03a 	or	r6,r9,r6
81126414:	300cc03a 	cmpne	r6,r6,zero
81126418:	298ab03a 	or	r5,r5,r6
8112641c:	0013883a 	mov	r9,zero
81126420:	003f1506 	br	81126078 <__reset+0xfb106078>
81126424:	0101ffc4 	movi	r4,2047
81126428:	113f9a1e 	bne	r2,r4,81126294 <__reset+0xfb106294>
8112642c:	4811883a 	mov	r8,r9
81126430:	3023883a 	mov	r17,r6
81126434:	1021883a 	mov	r16,r2
81126438:	3825883a 	mov	r18,r7
8112643c:	003e9306 	br	81125e8c <__reset+0xfb105e8c>
81126440:	8000161e 	bne	r16,zero,8112649c <__adddf3+0x694>
81126444:	444ab03a 	or	r5,r8,r17
81126448:	28005126 	beq	r5,zero,81126590 <__adddf3+0x788>
8112644c:	0108303a 	nor	r4,zero,r4
81126450:	20004d1e 	bne	r4,zero,81126588 <__adddf3+0x780>
81126454:	89a3883a 	add	r17,r17,r6
81126458:	4253883a 	add	r9,r8,r9
8112645c:	898d803a 	cmpltu	r6,r17,r6
81126460:	3251883a 	add	r8,r6,r9
81126464:	1021883a 	mov	r16,r2
81126468:	003f0806 	br	8112608c <__reset+0xfb10608c>
8112646c:	1000301e 	bne	r2,zero,81126530 <__adddf3+0x728>
81126470:	4984b03a 	or	r2,r9,r6
81126474:	10007126 	beq	r2,zero,8112663c <__adddf3+0x834>
81126478:	4811883a 	mov	r8,r9
8112647c:	3023883a 	mov	r17,r6
81126480:	3825883a 	mov	r18,r7
81126484:	0401ffc4 	movi	r16,2047
81126488:	003e8006 	br	81125e8c <__reset+0xfb105e8c>
8112648c:	4462b03a 	or	r17,r8,r17
81126490:	8822c03a 	cmpne	r17,r17,zero
81126494:	0007883a 	mov	r3,zero
81126498:	003f8b06 	br	811262c8 <__reset+0xfb1062c8>
8112649c:	0141ffc4 	movi	r5,2047
811264a0:	11403b26 	beq	r2,r5,81126590 <__adddf3+0x788>
811264a4:	0109c83a 	sub	r4,zero,r4
811264a8:	42002034 	orhi	r8,r8,128
811264ac:	01400e04 	movi	r5,56
811264b0:	29006716 	blt	r5,r4,81126650 <__adddf3+0x848>
811264b4:	014007c4 	movi	r5,31
811264b8:	29007016 	blt	r5,r4,8112667c <__adddf3+0x874>
811264bc:	01400804 	movi	r5,32
811264c0:	290bc83a 	sub	r5,r5,r4
811264c4:	4154983a 	sll	r10,r8,r5
811264c8:	890ed83a 	srl	r7,r17,r4
811264cc:	894a983a 	sll	r5,r17,r5
811264d0:	4108d83a 	srl	r4,r8,r4
811264d4:	51e2b03a 	or	r17,r10,r7
811264d8:	280ac03a 	cmpne	r5,r5,zero
811264dc:	8962b03a 	or	r17,r17,r5
811264e0:	89a3883a 	add	r17,r17,r6
811264e4:	2253883a 	add	r9,r4,r9
811264e8:	898d803a 	cmpltu	r6,r17,r6
811264ec:	3251883a 	add	r8,r6,r9
811264f0:	1021883a 	mov	r16,r2
811264f4:	003ee506 	br	8112608c <__reset+0xfb10608c>
811264f8:	4984b03a 	or	r2,r9,r6
811264fc:	103e6326 	beq	r2,zero,81125e8c <__reset+0xfb105e8c>
81126500:	8987c83a 	sub	r3,r17,r6
81126504:	88c9803a 	cmpltu	r4,r17,r3
81126508:	4245c83a 	sub	r2,r8,r9
8112650c:	1105c83a 	sub	r2,r2,r4
81126510:	1100202c 	andhi	r4,r2,128
81126514:	203ebb26 	beq	r4,zero,81126004 <__reset+0xfb106004>
81126518:	3463c83a 	sub	r17,r6,r17
8112651c:	4a07c83a 	sub	r3,r9,r8
81126520:	344d803a 	cmpltu	r6,r6,r17
81126524:	1991c83a 	sub	r8,r3,r6
81126528:	3825883a 	mov	r18,r7
8112652c:	003e5706 	br	81125e8c <__reset+0xfb105e8c>
81126530:	4984b03a 	or	r2,r9,r6
81126534:	10002e26 	beq	r2,zero,811265f0 <__adddf3+0x7e8>
81126538:	4004d0fa 	srli	r2,r8,3
8112653c:	8822d0fa 	srli	r17,r17,3
81126540:	4010977a 	slli	r8,r8,29
81126544:	10c0022c 	andhi	r3,r2,8
81126548:	4462b03a 	or	r17,r8,r17
8112654c:	18000826 	beq	r3,zero,81126570 <__adddf3+0x768>
81126550:	4808d0fa 	srli	r4,r9,3
81126554:	20c0022c 	andhi	r3,r4,8
81126558:	1800051e 	bne	r3,zero,81126570 <__adddf3+0x768>
8112655c:	300cd0fa 	srli	r6,r6,3
81126560:	4806977a 	slli	r3,r9,29
81126564:	2005883a 	mov	r2,r4
81126568:	3825883a 	mov	r18,r7
8112656c:	19a2b03a 	or	r17,r3,r6
81126570:	8810d77a 	srli	r8,r17,29
81126574:	100490fa 	slli	r2,r2,3
81126578:	882290fa 	slli	r17,r17,3
8112657c:	0401ffc4 	movi	r16,2047
81126580:	4090b03a 	or	r8,r8,r2
81126584:	003e4106 	br	81125e8c <__reset+0xfb105e8c>
81126588:	0141ffc4 	movi	r5,2047
8112658c:	117fc71e 	bne	r2,r5,811264ac <__reset+0xfb1064ac>
81126590:	4811883a 	mov	r8,r9
81126594:	3023883a 	mov	r17,r6
81126598:	1021883a 	mov	r16,r2
8112659c:	003e3b06 	br	81125e8c <__reset+0xfb105e8c>
811265a0:	10002f26 	beq	r2,zero,81126660 <__adddf3+0x858>
811265a4:	4984b03a 	or	r2,r9,r6
811265a8:	10001126 	beq	r2,zero,811265f0 <__adddf3+0x7e8>
811265ac:	4004d0fa 	srli	r2,r8,3
811265b0:	8822d0fa 	srli	r17,r17,3
811265b4:	4010977a 	slli	r8,r8,29
811265b8:	10c0022c 	andhi	r3,r2,8
811265bc:	4462b03a 	or	r17,r8,r17
811265c0:	183feb26 	beq	r3,zero,81126570 <__reset+0xfb106570>
811265c4:	4808d0fa 	srli	r4,r9,3
811265c8:	20c0022c 	andhi	r3,r4,8
811265cc:	183fe81e 	bne	r3,zero,81126570 <__reset+0xfb106570>
811265d0:	300cd0fa 	srli	r6,r6,3
811265d4:	4806977a 	slli	r3,r9,29
811265d8:	2005883a 	mov	r2,r4
811265dc:	19a2b03a 	or	r17,r3,r6
811265e0:	003fe306 	br	81126570 <__reset+0xfb106570>
811265e4:	0011883a 	mov	r8,zero
811265e8:	0005883a 	mov	r2,zero
811265ec:	003e3f06 	br	81125eec <__reset+0xfb105eec>
811265f0:	0401ffc4 	movi	r16,2047
811265f4:	003e2506 	br	81125e8c <__reset+0xfb105e8c>
811265f8:	0013883a 	mov	r9,zero
811265fc:	003f8406 	br	81126410 <__reset+0xfb106410>
81126600:	0005883a 	mov	r2,zero
81126604:	0007883a 	mov	r3,zero
81126608:	003e8906 	br	81126030 <__reset+0xfb106030>
8112660c:	197ff804 	addi	r5,r3,-32
81126610:	01000804 	movi	r4,32
81126614:	414ad83a 	srl	r5,r8,r5
81126618:	19002426 	beq	r3,r4,811266ac <__adddf3+0x8a4>
8112661c:	01001004 	movi	r4,64
81126620:	20c7c83a 	sub	r3,r4,r3
81126624:	40c6983a 	sll	r3,r8,r3
81126628:	1c46b03a 	or	r3,r3,r17
8112662c:	1806c03a 	cmpne	r3,r3,zero
81126630:	28e2b03a 	or	r17,r5,r3
81126634:	0007883a 	mov	r3,zero
81126638:	003f2306 	br	811262c8 <__reset+0xfb1062c8>
8112663c:	0007883a 	mov	r3,zero
81126640:	5811883a 	mov	r8,r11
81126644:	00bfffc4 	movi	r2,-1
81126648:	0401ffc4 	movi	r16,2047
8112664c:	003e7806 	br	81126030 <__reset+0xfb106030>
81126650:	4462b03a 	or	r17,r8,r17
81126654:	8822c03a 	cmpne	r17,r17,zero
81126658:	0009883a 	mov	r4,zero
8112665c:	003fa006 	br	811264e0 <__reset+0xfb1064e0>
81126660:	4811883a 	mov	r8,r9
81126664:	3023883a 	mov	r17,r6
81126668:	0401ffc4 	movi	r16,2047
8112666c:	003e0706 	br	81125e8c <__reset+0xfb105e8c>
81126670:	4811883a 	mov	r8,r9
81126674:	3023883a 	mov	r17,r6
81126678:	003e0406 	br	81125e8c <__reset+0xfb105e8c>
8112667c:	21fff804 	addi	r7,r4,-32
81126680:	01400804 	movi	r5,32
81126684:	41ced83a 	srl	r7,r8,r7
81126688:	21400a26 	beq	r4,r5,811266b4 <__adddf3+0x8ac>
8112668c:	01401004 	movi	r5,64
81126690:	2909c83a 	sub	r4,r5,r4
81126694:	4108983a 	sll	r4,r8,r4
81126698:	2448b03a 	or	r4,r4,r17
8112669c:	2008c03a 	cmpne	r4,r4,zero
811266a0:	3922b03a 	or	r17,r7,r4
811266a4:	0009883a 	mov	r4,zero
811266a8:	003f8d06 	br	811264e0 <__reset+0xfb1064e0>
811266ac:	0007883a 	mov	r3,zero
811266b0:	003fdd06 	br	81126628 <__reset+0xfb106628>
811266b4:	0009883a 	mov	r4,zero
811266b8:	003ff706 	br	81126698 <__reset+0xfb106698>

811266bc <__divdf3>:
811266bc:	defff204 	addi	sp,sp,-56
811266c0:	de00012e 	bgeu	sp,et,811266c8 <__divdf3+0xc>
811266c4:	003b68fa 	trap	3
811266c8:	dd400915 	stw	r21,36(sp)
811266cc:	282ad53a 	srli	r21,r5,20
811266d0:	dd000815 	stw	r20,32(sp)
811266d4:	2828d7fa 	srli	r20,r5,31
811266d8:	dc000415 	stw	r16,16(sp)
811266dc:	04000434 	movhi	r16,16
811266e0:	df000c15 	stw	fp,48(sp)
811266e4:	843fffc4 	addi	r16,r16,-1
811266e8:	dfc00d15 	stw	ra,52(sp)
811266ec:	ddc00b15 	stw	r23,44(sp)
811266f0:	dd800a15 	stw	r22,40(sp)
811266f4:	dcc00715 	stw	r19,28(sp)
811266f8:	dc800615 	stw	r18,24(sp)
811266fc:	dc400515 	stw	r17,20(sp)
81126700:	ad41ffcc 	andi	r21,r21,2047
81126704:	2c20703a 	and	r16,r5,r16
81126708:	a7003fcc 	andi	fp,r20,255
8112670c:	a8006126 	beq	r21,zero,81126894 <__divdf3+0x1d8>
81126710:	0081ffc4 	movi	r2,2047
81126714:	2025883a 	mov	r18,r4
81126718:	a8803726 	beq	r21,r2,811267f8 <__divdf3+0x13c>
8112671c:	80800434 	orhi	r2,r16,16
81126720:	100490fa 	slli	r2,r2,3
81126724:	2020d77a 	srli	r16,r4,29
81126728:	202490fa 	slli	r18,r4,3
8112672c:	ad7f0044 	addi	r21,r21,-1023
81126730:	80a0b03a 	or	r16,r16,r2
81126734:	0027883a 	mov	r19,zero
81126738:	0013883a 	mov	r9,zero
8112673c:	3804d53a 	srli	r2,r7,20
81126740:	382cd7fa 	srli	r22,r7,31
81126744:	04400434 	movhi	r17,16
81126748:	8c7fffc4 	addi	r17,r17,-1
8112674c:	1081ffcc 	andi	r2,r2,2047
81126750:	3011883a 	mov	r8,r6
81126754:	3c62703a 	and	r17,r7,r17
81126758:	b5c03fcc 	andi	r23,r22,255
8112675c:	10006c26 	beq	r2,zero,81126910 <__divdf3+0x254>
81126760:	00c1ffc4 	movi	r3,2047
81126764:	10c06426 	beq	r2,r3,811268f8 <__divdf3+0x23c>
81126768:	88c00434 	orhi	r3,r17,16
8112676c:	180690fa 	slli	r3,r3,3
81126770:	3022d77a 	srli	r17,r6,29
81126774:	301090fa 	slli	r8,r6,3
81126778:	10bf0044 	addi	r2,r2,-1023
8112677c:	88e2b03a 	or	r17,r17,r3
81126780:	000f883a 	mov	r7,zero
81126784:	a58cf03a 	xor	r6,r20,r22
81126788:	3cc8b03a 	or	r4,r7,r19
8112678c:	a8abc83a 	sub	r21,r21,r2
81126790:	008003c4 	movi	r2,15
81126794:	3007883a 	mov	r3,r6
81126798:	34c03fcc 	andi	r19,r6,255
8112679c:	11009036 	bltu	r2,r4,811269e0 <__divdf3+0x324>
811267a0:	200890ba 	slli	r4,r4,2
811267a4:	00a044b4 	movhi	r2,33042
811267a8:	1099ee04 	addi	r2,r2,26552
811267ac:	2089883a 	add	r4,r4,r2
811267b0:	20800017 	ldw	r2,0(r4)
811267b4:	1000683a 	jmp	r2
811267b8:	811269e0 	cmpeqi	r4,r16,18855
811267bc:	81126830 	cmpltui	r4,r16,18848
811267c0:	811269d0 	cmplti	r4,r16,18855
811267c4:	81126824 	muli	r4,r16,18848
811267c8:	811269d0 	cmplti	r4,r16,18855
811267cc:	811269a4 	muli	r4,r16,18854
811267d0:	811269d0 	cmplti	r4,r16,18855
811267d4:	81126824 	muli	r4,r16,18848
811267d8:	81126830 	cmpltui	r4,r16,18848
811267dc:	81126830 	cmpltui	r4,r16,18848
811267e0:	811269a4 	muli	r4,r16,18854
811267e4:	81126824 	muli	r4,r16,18848
811267e8:	81126814 	ori	r4,r16,18848
811267ec:	81126814 	ori	r4,r16,18848
811267f0:	81126814 	ori	r4,r16,18848
811267f4:	81126cc4 	addi	r4,r16,18867
811267f8:	2404b03a 	or	r2,r4,r16
811267fc:	1000661e 	bne	r2,zero,81126998 <__divdf3+0x2dc>
81126800:	04c00204 	movi	r19,8
81126804:	0021883a 	mov	r16,zero
81126808:	0025883a 	mov	r18,zero
8112680c:	02400084 	movi	r9,2
81126810:	003fca06 	br	8112673c <__reset+0xfb10673c>
81126814:	8023883a 	mov	r17,r16
81126818:	9011883a 	mov	r8,r18
8112681c:	e02f883a 	mov	r23,fp
81126820:	480f883a 	mov	r7,r9
81126824:	00800084 	movi	r2,2
81126828:	3881311e 	bne	r7,r2,81126cf0 <__divdf3+0x634>
8112682c:	b827883a 	mov	r19,r23
81126830:	98c0004c 	andi	r3,r19,1
81126834:	0081ffc4 	movi	r2,2047
81126838:	000b883a 	mov	r5,zero
8112683c:	0025883a 	mov	r18,zero
81126840:	1004953a 	slli	r2,r2,20
81126844:	18c03fcc 	andi	r3,r3,255
81126848:	04400434 	movhi	r17,16
8112684c:	8c7fffc4 	addi	r17,r17,-1
81126850:	180697fa 	slli	r3,r3,31
81126854:	2c4a703a 	and	r5,r5,r17
81126858:	288ab03a 	or	r5,r5,r2
8112685c:	28c6b03a 	or	r3,r5,r3
81126860:	9005883a 	mov	r2,r18
81126864:	dfc00d17 	ldw	ra,52(sp)
81126868:	df000c17 	ldw	fp,48(sp)
8112686c:	ddc00b17 	ldw	r23,44(sp)
81126870:	dd800a17 	ldw	r22,40(sp)
81126874:	dd400917 	ldw	r21,36(sp)
81126878:	dd000817 	ldw	r20,32(sp)
8112687c:	dcc00717 	ldw	r19,28(sp)
81126880:	dc800617 	ldw	r18,24(sp)
81126884:	dc400517 	ldw	r17,20(sp)
81126888:	dc000417 	ldw	r16,16(sp)
8112688c:	dec00e04 	addi	sp,sp,56
81126890:	f800283a 	ret
81126894:	2404b03a 	or	r2,r4,r16
81126898:	2027883a 	mov	r19,r4
8112689c:	10003926 	beq	r2,zero,81126984 <__divdf3+0x2c8>
811268a0:	80012e26 	beq	r16,zero,81126d5c <__divdf3+0x6a0>
811268a4:	8009883a 	mov	r4,r16
811268a8:	d9800315 	stw	r6,12(sp)
811268ac:	d9c00215 	stw	r7,8(sp)
811268b0:	11125200 	call	81112520 <__clzsi2>
811268b4:	d9800317 	ldw	r6,12(sp)
811268b8:	d9c00217 	ldw	r7,8(sp)
811268bc:	113ffd44 	addi	r4,r2,-11
811268c0:	00c00704 	movi	r3,28
811268c4:	19012116 	blt	r3,r4,81126d4c <__divdf3+0x690>
811268c8:	00c00744 	movi	r3,29
811268cc:	147ffe04 	addi	r17,r2,-8
811268d0:	1907c83a 	sub	r3,r3,r4
811268d4:	8460983a 	sll	r16,r16,r17
811268d8:	98c6d83a 	srl	r3,r19,r3
811268dc:	9c64983a 	sll	r18,r19,r17
811268e0:	1c20b03a 	or	r16,r3,r16
811268e4:	1080fcc4 	addi	r2,r2,1011
811268e8:	00abc83a 	sub	r21,zero,r2
811268ec:	0027883a 	mov	r19,zero
811268f0:	0013883a 	mov	r9,zero
811268f4:	003f9106 	br	8112673c <__reset+0xfb10673c>
811268f8:	3446b03a 	or	r3,r6,r17
811268fc:	18001f1e 	bne	r3,zero,8112697c <__divdf3+0x2c0>
81126900:	0023883a 	mov	r17,zero
81126904:	0011883a 	mov	r8,zero
81126908:	01c00084 	movi	r7,2
8112690c:	003f9d06 	br	81126784 <__reset+0xfb106784>
81126910:	3446b03a 	or	r3,r6,r17
81126914:	18001526 	beq	r3,zero,8112696c <__divdf3+0x2b0>
81126918:	88011b26 	beq	r17,zero,81126d88 <__divdf3+0x6cc>
8112691c:	8809883a 	mov	r4,r17
81126920:	d9800315 	stw	r6,12(sp)
81126924:	da400115 	stw	r9,4(sp)
81126928:	11125200 	call	81112520 <__clzsi2>
8112692c:	d9800317 	ldw	r6,12(sp)
81126930:	da400117 	ldw	r9,4(sp)
81126934:	113ffd44 	addi	r4,r2,-11
81126938:	00c00704 	movi	r3,28
8112693c:	19010e16 	blt	r3,r4,81126d78 <__divdf3+0x6bc>
81126940:	00c00744 	movi	r3,29
81126944:	123ffe04 	addi	r8,r2,-8
81126948:	1907c83a 	sub	r3,r3,r4
8112694c:	8a22983a 	sll	r17,r17,r8
81126950:	30c6d83a 	srl	r3,r6,r3
81126954:	3210983a 	sll	r8,r6,r8
81126958:	1c62b03a 	or	r17,r3,r17
8112695c:	1080fcc4 	addi	r2,r2,1011
81126960:	0085c83a 	sub	r2,zero,r2
81126964:	000f883a 	mov	r7,zero
81126968:	003f8606 	br	81126784 <__reset+0xfb106784>
8112696c:	0023883a 	mov	r17,zero
81126970:	0011883a 	mov	r8,zero
81126974:	01c00044 	movi	r7,1
81126978:	003f8206 	br	81126784 <__reset+0xfb106784>
8112697c:	01c000c4 	movi	r7,3
81126980:	003f8006 	br	81126784 <__reset+0xfb106784>
81126984:	04c00104 	movi	r19,4
81126988:	0021883a 	mov	r16,zero
8112698c:	0025883a 	mov	r18,zero
81126990:	02400044 	movi	r9,1
81126994:	003f6906 	br	8112673c <__reset+0xfb10673c>
81126998:	04c00304 	movi	r19,12
8112699c:	024000c4 	movi	r9,3
811269a0:	003f6606 	br	8112673c <__reset+0xfb10673c>
811269a4:	01400434 	movhi	r5,16
811269a8:	0007883a 	mov	r3,zero
811269ac:	297fffc4 	addi	r5,r5,-1
811269b0:	04bfffc4 	movi	r18,-1
811269b4:	0081ffc4 	movi	r2,2047
811269b8:	003fa106 	br	81126840 <__reset+0xfb106840>
811269bc:	00c00044 	movi	r3,1
811269c0:	1887c83a 	sub	r3,r3,r2
811269c4:	01000e04 	movi	r4,56
811269c8:	20c1210e 	bge	r4,r3,81126e50 <__divdf3+0x794>
811269cc:	98c0004c 	andi	r3,r19,1
811269d0:	0005883a 	mov	r2,zero
811269d4:	000b883a 	mov	r5,zero
811269d8:	0025883a 	mov	r18,zero
811269dc:	003f9806 	br	81126840 <__reset+0xfb106840>
811269e0:	8c00fd36 	bltu	r17,r16,81126dd8 <__divdf3+0x71c>
811269e4:	8440fb26 	beq	r16,r17,81126dd4 <__divdf3+0x718>
811269e8:	8007883a 	mov	r3,r16
811269ec:	ad7fffc4 	addi	r21,r21,-1
811269f0:	0021883a 	mov	r16,zero
811269f4:	4004d63a 	srli	r2,r8,24
811269f8:	8822923a 	slli	r17,r17,8
811269fc:	1809883a 	mov	r4,r3
81126a00:	402c923a 	slli	r22,r8,8
81126a04:	88b8b03a 	or	fp,r17,r2
81126a08:	e028d43a 	srli	r20,fp,16
81126a0c:	d8c00015 	stw	r3,0(sp)
81126a10:	e5ffffcc 	andi	r23,fp,65535
81126a14:	a00b883a 	mov	r5,r20
81126a18:	1125b500 	call	81125b50 <__udivsi3>
81126a1c:	d8c00017 	ldw	r3,0(sp)
81126a20:	a00b883a 	mov	r5,r20
81126a24:	d8800315 	stw	r2,12(sp)
81126a28:	1809883a 	mov	r4,r3
81126a2c:	1125bb40 	call	81125bb4 <__umodsi3>
81126a30:	d9800317 	ldw	r6,12(sp)
81126a34:	1006943a 	slli	r3,r2,16
81126a38:	9004d43a 	srli	r2,r18,16
81126a3c:	b9a3383a 	mul	r17,r23,r6
81126a40:	10c4b03a 	or	r2,r2,r3
81126a44:	1440062e 	bgeu	r2,r17,81126a60 <__divdf3+0x3a4>
81126a48:	1705883a 	add	r2,r2,fp
81126a4c:	30ffffc4 	addi	r3,r6,-1
81126a50:	1700ee36 	bltu	r2,fp,81126e0c <__divdf3+0x750>
81126a54:	1440ed2e 	bgeu	r2,r17,81126e0c <__divdf3+0x750>
81126a58:	31bfff84 	addi	r6,r6,-2
81126a5c:	1705883a 	add	r2,r2,fp
81126a60:	1463c83a 	sub	r17,r2,r17
81126a64:	a00b883a 	mov	r5,r20
81126a68:	8809883a 	mov	r4,r17
81126a6c:	d9800315 	stw	r6,12(sp)
81126a70:	1125b500 	call	81125b50 <__udivsi3>
81126a74:	a00b883a 	mov	r5,r20
81126a78:	8809883a 	mov	r4,r17
81126a7c:	d8800215 	stw	r2,8(sp)
81126a80:	1125bb40 	call	81125bb4 <__umodsi3>
81126a84:	d9c00217 	ldw	r7,8(sp)
81126a88:	1004943a 	slli	r2,r2,16
81126a8c:	94bfffcc 	andi	r18,r18,65535
81126a90:	b9d1383a 	mul	r8,r23,r7
81126a94:	90a4b03a 	or	r18,r18,r2
81126a98:	d9800317 	ldw	r6,12(sp)
81126a9c:	9200062e 	bgeu	r18,r8,81126ab8 <__divdf3+0x3fc>
81126aa0:	9725883a 	add	r18,r18,fp
81126aa4:	38bfffc4 	addi	r2,r7,-1
81126aa8:	9700d636 	bltu	r18,fp,81126e04 <__divdf3+0x748>
81126aac:	9200d52e 	bgeu	r18,r8,81126e04 <__divdf3+0x748>
81126ab0:	39ffff84 	addi	r7,r7,-2
81126ab4:	9725883a 	add	r18,r18,fp
81126ab8:	3004943a 	slli	r2,r6,16
81126abc:	b012d43a 	srli	r9,r22,16
81126ac0:	b1bfffcc 	andi	r6,r22,65535
81126ac4:	11e2b03a 	or	r17,r2,r7
81126ac8:	8806d43a 	srli	r3,r17,16
81126acc:	893fffcc 	andi	r4,r17,65535
81126ad0:	218b383a 	mul	r5,r4,r6
81126ad4:	30c5383a 	mul	r2,r6,r3
81126ad8:	2249383a 	mul	r4,r4,r9
81126adc:	280ed43a 	srli	r7,r5,16
81126ae0:	9225c83a 	sub	r18,r18,r8
81126ae4:	2089883a 	add	r4,r4,r2
81126ae8:	3909883a 	add	r4,r7,r4
81126aec:	1a47383a 	mul	r3,r3,r9
81126af0:	2080022e 	bgeu	r4,r2,81126afc <__divdf3+0x440>
81126af4:	00800074 	movhi	r2,1
81126af8:	1887883a 	add	r3,r3,r2
81126afc:	2004d43a 	srli	r2,r4,16
81126b00:	2008943a 	slli	r4,r4,16
81126b04:	297fffcc 	andi	r5,r5,65535
81126b08:	10c7883a 	add	r3,r2,r3
81126b0c:	2149883a 	add	r4,r4,r5
81126b10:	90c0a536 	bltu	r18,r3,81126da8 <__divdf3+0x6ec>
81126b14:	90c0bf26 	beq	r18,r3,81126e14 <__divdf3+0x758>
81126b18:	90c7c83a 	sub	r3,r18,r3
81126b1c:	810fc83a 	sub	r7,r16,r4
81126b20:	81e5803a 	cmpltu	r18,r16,r7
81126b24:	1ca5c83a 	sub	r18,r3,r18
81126b28:	e480c126 	beq	fp,r18,81126e30 <__divdf3+0x774>
81126b2c:	a00b883a 	mov	r5,r20
81126b30:	9009883a 	mov	r4,r18
81126b34:	d9800315 	stw	r6,12(sp)
81126b38:	d9c00215 	stw	r7,8(sp)
81126b3c:	da400115 	stw	r9,4(sp)
81126b40:	1125b500 	call	81125b50 <__udivsi3>
81126b44:	a00b883a 	mov	r5,r20
81126b48:	9009883a 	mov	r4,r18
81126b4c:	d8800015 	stw	r2,0(sp)
81126b50:	1125bb40 	call	81125bb4 <__umodsi3>
81126b54:	d9c00217 	ldw	r7,8(sp)
81126b58:	da000017 	ldw	r8,0(sp)
81126b5c:	1006943a 	slli	r3,r2,16
81126b60:	3804d43a 	srli	r2,r7,16
81126b64:	ba21383a 	mul	r16,r23,r8
81126b68:	d9800317 	ldw	r6,12(sp)
81126b6c:	10c4b03a 	or	r2,r2,r3
81126b70:	da400117 	ldw	r9,4(sp)
81126b74:	1400062e 	bgeu	r2,r16,81126b90 <__divdf3+0x4d4>
81126b78:	1705883a 	add	r2,r2,fp
81126b7c:	40ffffc4 	addi	r3,r8,-1
81126b80:	1700ad36 	bltu	r2,fp,81126e38 <__divdf3+0x77c>
81126b84:	1400ac2e 	bgeu	r2,r16,81126e38 <__divdf3+0x77c>
81126b88:	423fff84 	addi	r8,r8,-2
81126b8c:	1705883a 	add	r2,r2,fp
81126b90:	1421c83a 	sub	r16,r2,r16
81126b94:	a00b883a 	mov	r5,r20
81126b98:	8009883a 	mov	r4,r16
81126b9c:	d9800315 	stw	r6,12(sp)
81126ba0:	d9c00215 	stw	r7,8(sp)
81126ba4:	da000015 	stw	r8,0(sp)
81126ba8:	da400115 	stw	r9,4(sp)
81126bac:	1125b500 	call	81125b50 <__udivsi3>
81126bb0:	8009883a 	mov	r4,r16
81126bb4:	a00b883a 	mov	r5,r20
81126bb8:	1025883a 	mov	r18,r2
81126bbc:	1125bb40 	call	81125bb4 <__umodsi3>
81126bc0:	d9c00217 	ldw	r7,8(sp)
81126bc4:	1004943a 	slli	r2,r2,16
81126bc8:	bcaf383a 	mul	r23,r23,r18
81126bcc:	393fffcc 	andi	r4,r7,65535
81126bd0:	2088b03a 	or	r4,r4,r2
81126bd4:	d9800317 	ldw	r6,12(sp)
81126bd8:	da000017 	ldw	r8,0(sp)
81126bdc:	da400117 	ldw	r9,4(sp)
81126be0:	25c0062e 	bgeu	r4,r23,81126bfc <__divdf3+0x540>
81126be4:	2709883a 	add	r4,r4,fp
81126be8:	90bfffc4 	addi	r2,r18,-1
81126bec:	27009436 	bltu	r4,fp,81126e40 <__divdf3+0x784>
81126bf0:	25c0932e 	bgeu	r4,r23,81126e40 <__divdf3+0x784>
81126bf4:	94bfff84 	addi	r18,r18,-2
81126bf8:	2709883a 	add	r4,r4,fp
81126bfc:	4004943a 	slli	r2,r8,16
81126c00:	25efc83a 	sub	r23,r4,r23
81126c04:	1490b03a 	or	r8,r2,r18
81126c08:	4008d43a 	srli	r4,r8,16
81126c0c:	40ffffcc 	andi	r3,r8,65535
81126c10:	30c5383a 	mul	r2,r6,r3
81126c14:	1a47383a 	mul	r3,r3,r9
81126c18:	310d383a 	mul	r6,r6,r4
81126c1c:	100ad43a 	srli	r5,r2,16
81126c20:	4913383a 	mul	r9,r9,r4
81126c24:	1987883a 	add	r3,r3,r6
81126c28:	28c7883a 	add	r3,r5,r3
81126c2c:	1980022e 	bgeu	r3,r6,81126c38 <__divdf3+0x57c>
81126c30:	01000074 	movhi	r4,1
81126c34:	4913883a 	add	r9,r9,r4
81126c38:	1808d43a 	srli	r4,r3,16
81126c3c:	1806943a 	slli	r3,r3,16
81126c40:	10bfffcc 	andi	r2,r2,65535
81126c44:	2253883a 	add	r9,r4,r9
81126c48:	1887883a 	add	r3,r3,r2
81126c4c:	ba403836 	bltu	r23,r9,81126d30 <__divdf3+0x674>
81126c50:	ba403626 	beq	r23,r9,81126d2c <__divdf3+0x670>
81126c54:	42000054 	ori	r8,r8,1
81126c58:	a880ffc4 	addi	r2,r21,1023
81126c5c:	00bf570e 	bge	zero,r2,811269bc <__reset+0xfb1069bc>
81126c60:	40c001cc 	andi	r3,r8,7
81126c64:	18000726 	beq	r3,zero,81126c84 <__divdf3+0x5c8>
81126c68:	40c003cc 	andi	r3,r8,15
81126c6c:	01000104 	movi	r4,4
81126c70:	19000426 	beq	r3,r4,81126c84 <__divdf3+0x5c8>
81126c74:	4107883a 	add	r3,r8,r4
81126c78:	1a11803a 	cmpltu	r8,r3,r8
81126c7c:	8a23883a 	add	r17,r17,r8
81126c80:	1811883a 	mov	r8,r3
81126c84:	88c0402c 	andhi	r3,r17,256
81126c88:	18000426 	beq	r3,zero,81126c9c <__divdf3+0x5e0>
81126c8c:	00ffc034 	movhi	r3,65280
81126c90:	18ffffc4 	addi	r3,r3,-1
81126c94:	a8810004 	addi	r2,r21,1024
81126c98:	88e2703a 	and	r17,r17,r3
81126c9c:	00c1ff84 	movi	r3,2046
81126ca0:	18bee316 	blt	r3,r2,81126830 <__reset+0xfb106830>
81126ca4:	8824977a 	slli	r18,r17,29
81126ca8:	4010d0fa 	srli	r8,r8,3
81126cac:	8822927a 	slli	r17,r17,9
81126cb0:	1081ffcc 	andi	r2,r2,2047
81126cb4:	9224b03a 	or	r18,r18,r8
81126cb8:	880ad33a 	srli	r5,r17,12
81126cbc:	98c0004c 	andi	r3,r19,1
81126cc0:	003edf06 	br	81126840 <__reset+0xfb106840>
81126cc4:	8080022c 	andhi	r2,r16,8
81126cc8:	10001226 	beq	r2,zero,81126d14 <__divdf3+0x658>
81126ccc:	8880022c 	andhi	r2,r17,8
81126cd0:	1000101e 	bne	r2,zero,81126d14 <__divdf3+0x658>
81126cd4:	00800434 	movhi	r2,16
81126cd8:	89400234 	orhi	r5,r17,8
81126cdc:	10bfffc4 	addi	r2,r2,-1
81126ce0:	b007883a 	mov	r3,r22
81126ce4:	288a703a 	and	r5,r5,r2
81126ce8:	4025883a 	mov	r18,r8
81126cec:	003f3106 	br	811269b4 <__reset+0xfb1069b4>
81126cf0:	008000c4 	movi	r2,3
81126cf4:	3880a626 	beq	r7,r2,81126f90 <__divdf3+0x8d4>
81126cf8:	00800044 	movi	r2,1
81126cfc:	3880521e 	bne	r7,r2,81126e48 <__divdf3+0x78c>
81126d00:	b807883a 	mov	r3,r23
81126d04:	0005883a 	mov	r2,zero
81126d08:	000b883a 	mov	r5,zero
81126d0c:	0025883a 	mov	r18,zero
81126d10:	003ecb06 	br	81126840 <__reset+0xfb106840>
81126d14:	00800434 	movhi	r2,16
81126d18:	81400234 	orhi	r5,r16,8
81126d1c:	10bfffc4 	addi	r2,r2,-1
81126d20:	a007883a 	mov	r3,r20
81126d24:	288a703a 	and	r5,r5,r2
81126d28:	003f2206 	br	811269b4 <__reset+0xfb1069b4>
81126d2c:	183fca26 	beq	r3,zero,81126c58 <__reset+0xfb106c58>
81126d30:	e5ef883a 	add	r23,fp,r23
81126d34:	40bfffc4 	addi	r2,r8,-1
81126d38:	bf00392e 	bgeu	r23,fp,81126e20 <__divdf3+0x764>
81126d3c:	1011883a 	mov	r8,r2
81126d40:	ba7fc41e 	bne	r23,r9,81126c54 <__reset+0xfb106c54>
81126d44:	b0ffc31e 	bne	r22,r3,81126c54 <__reset+0xfb106c54>
81126d48:	003fc306 	br	81126c58 <__reset+0xfb106c58>
81126d4c:	143ff604 	addi	r16,r2,-40
81126d50:	9c20983a 	sll	r16,r19,r16
81126d54:	0025883a 	mov	r18,zero
81126d58:	003ee206 	br	811268e4 <__reset+0xfb1068e4>
81126d5c:	d9800315 	stw	r6,12(sp)
81126d60:	d9c00215 	stw	r7,8(sp)
81126d64:	11125200 	call	81112520 <__clzsi2>
81126d68:	10800804 	addi	r2,r2,32
81126d6c:	d9c00217 	ldw	r7,8(sp)
81126d70:	d9800317 	ldw	r6,12(sp)
81126d74:	003ed106 	br	811268bc <__reset+0xfb1068bc>
81126d78:	147ff604 	addi	r17,r2,-40
81126d7c:	3462983a 	sll	r17,r6,r17
81126d80:	0011883a 	mov	r8,zero
81126d84:	003ef506 	br	8112695c <__reset+0xfb10695c>
81126d88:	3009883a 	mov	r4,r6
81126d8c:	d9800315 	stw	r6,12(sp)
81126d90:	da400115 	stw	r9,4(sp)
81126d94:	11125200 	call	81112520 <__clzsi2>
81126d98:	10800804 	addi	r2,r2,32
81126d9c:	da400117 	ldw	r9,4(sp)
81126da0:	d9800317 	ldw	r6,12(sp)
81126da4:	003ee306 	br	81126934 <__reset+0xfb106934>
81126da8:	85a1883a 	add	r16,r16,r22
81126dac:	8585803a 	cmpltu	r2,r16,r22
81126db0:	1705883a 	add	r2,r2,fp
81126db4:	14a5883a 	add	r18,r2,r18
81126db8:	88bfffc4 	addi	r2,r17,-1
81126dbc:	e4800c2e 	bgeu	fp,r18,81126df0 <__divdf3+0x734>
81126dc0:	90c03e36 	bltu	r18,r3,81126ebc <__divdf3+0x800>
81126dc4:	1c806926 	beq	r3,r18,81126f6c <__divdf3+0x8b0>
81126dc8:	90c7c83a 	sub	r3,r18,r3
81126dcc:	1023883a 	mov	r17,r2
81126dd0:	003f5206 	br	81126b1c <__reset+0xfb106b1c>
81126dd4:	923f0436 	bltu	r18,r8,811269e8 <__reset+0xfb1069e8>
81126dd8:	800897fa 	slli	r4,r16,31
81126ddc:	9004d07a 	srli	r2,r18,1
81126de0:	8006d07a 	srli	r3,r16,1
81126de4:	902097fa 	slli	r16,r18,31
81126de8:	20a4b03a 	or	r18,r4,r2
81126dec:	003f0106 	br	811269f4 <__reset+0xfb1069f4>
81126df0:	e4bff51e 	bne	fp,r18,81126dc8 <__reset+0xfb106dc8>
81126df4:	85bff22e 	bgeu	r16,r22,81126dc0 <__reset+0xfb106dc0>
81126df8:	e0c7c83a 	sub	r3,fp,r3
81126dfc:	1023883a 	mov	r17,r2
81126e00:	003f4606 	br	81126b1c <__reset+0xfb106b1c>
81126e04:	100f883a 	mov	r7,r2
81126e08:	003f2b06 	br	81126ab8 <__reset+0xfb106ab8>
81126e0c:	180d883a 	mov	r6,r3
81126e10:	003f1306 	br	81126a60 <__reset+0xfb106a60>
81126e14:	813fe436 	bltu	r16,r4,81126da8 <__reset+0xfb106da8>
81126e18:	0007883a 	mov	r3,zero
81126e1c:	003f3f06 	br	81126b1c <__reset+0xfb106b1c>
81126e20:	ba402c36 	bltu	r23,r9,81126ed4 <__divdf3+0x818>
81126e24:	4dc05426 	beq	r9,r23,81126f78 <__divdf3+0x8bc>
81126e28:	1011883a 	mov	r8,r2
81126e2c:	003f8906 	br	81126c54 <__reset+0xfb106c54>
81126e30:	023fffc4 	movi	r8,-1
81126e34:	003f8806 	br	81126c58 <__reset+0xfb106c58>
81126e38:	1811883a 	mov	r8,r3
81126e3c:	003f5406 	br	81126b90 <__reset+0xfb106b90>
81126e40:	1025883a 	mov	r18,r2
81126e44:	003f6d06 	br	81126bfc <__reset+0xfb106bfc>
81126e48:	b827883a 	mov	r19,r23
81126e4c:	003f8206 	br	81126c58 <__reset+0xfb106c58>
81126e50:	010007c4 	movi	r4,31
81126e54:	20c02616 	blt	r4,r3,81126ef0 <__divdf3+0x834>
81126e58:	00800804 	movi	r2,32
81126e5c:	10c5c83a 	sub	r2,r2,r3
81126e60:	888a983a 	sll	r5,r17,r2
81126e64:	40c8d83a 	srl	r4,r8,r3
81126e68:	4084983a 	sll	r2,r8,r2
81126e6c:	88e2d83a 	srl	r17,r17,r3
81126e70:	2906b03a 	or	r3,r5,r4
81126e74:	1004c03a 	cmpne	r2,r2,zero
81126e78:	1886b03a 	or	r3,r3,r2
81126e7c:	188001cc 	andi	r2,r3,7
81126e80:	10000726 	beq	r2,zero,81126ea0 <__divdf3+0x7e4>
81126e84:	188003cc 	andi	r2,r3,15
81126e88:	01000104 	movi	r4,4
81126e8c:	11000426 	beq	r2,r4,81126ea0 <__divdf3+0x7e4>
81126e90:	1805883a 	mov	r2,r3
81126e94:	10c00104 	addi	r3,r2,4
81126e98:	1885803a 	cmpltu	r2,r3,r2
81126e9c:	88a3883a 	add	r17,r17,r2
81126ea0:	8880202c 	andhi	r2,r17,128
81126ea4:	10002726 	beq	r2,zero,81126f44 <__divdf3+0x888>
81126ea8:	98c0004c 	andi	r3,r19,1
81126eac:	00800044 	movi	r2,1
81126eb0:	000b883a 	mov	r5,zero
81126eb4:	0025883a 	mov	r18,zero
81126eb8:	003e6106 	br	81126840 <__reset+0xfb106840>
81126ebc:	85a1883a 	add	r16,r16,r22
81126ec0:	8585803a 	cmpltu	r2,r16,r22
81126ec4:	1705883a 	add	r2,r2,fp
81126ec8:	14a5883a 	add	r18,r2,r18
81126ecc:	8c7fff84 	addi	r17,r17,-2
81126ed0:	003f1106 	br	81126b18 <__reset+0xfb106b18>
81126ed4:	b589883a 	add	r4,r22,r22
81126ed8:	25ad803a 	cmpltu	r22,r4,r22
81126edc:	b739883a 	add	fp,r22,fp
81126ee0:	40bfff84 	addi	r2,r8,-2
81126ee4:	bf2f883a 	add	r23,r23,fp
81126ee8:	202d883a 	mov	r22,r4
81126eec:	003f9306 	br	81126d3c <__reset+0xfb106d3c>
81126ef0:	013ff844 	movi	r4,-31
81126ef4:	2085c83a 	sub	r2,r4,r2
81126ef8:	8888d83a 	srl	r4,r17,r2
81126efc:	00800804 	movi	r2,32
81126f00:	18802126 	beq	r3,r2,81126f88 <__divdf3+0x8cc>
81126f04:	00801004 	movi	r2,64
81126f08:	10c5c83a 	sub	r2,r2,r3
81126f0c:	8884983a 	sll	r2,r17,r2
81126f10:	1204b03a 	or	r2,r2,r8
81126f14:	1004c03a 	cmpne	r2,r2,zero
81126f18:	2084b03a 	or	r2,r4,r2
81126f1c:	144001cc 	andi	r17,r2,7
81126f20:	88000d1e 	bne	r17,zero,81126f58 <__divdf3+0x89c>
81126f24:	000b883a 	mov	r5,zero
81126f28:	1024d0fa 	srli	r18,r2,3
81126f2c:	98c0004c 	andi	r3,r19,1
81126f30:	0005883a 	mov	r2,zero
81126f34:	9464b03a 	or	r18,r18,r17
81126f38:	003e4106 	br	81126840 <__reset+0xfb106840>
81126f3c:	1007883a 	mov	r3,r2
81126f40:	0023883a 	mov	r17,zero
81126f44:	880a927a 	slli	r5,r17,9
81126f48:	1805883a 	mov	r2,r3
81126f4c:	8822977a 	slli	r17,r17,29
81126f50:	280ad33a 	srli	r5,r5,12
81126f54:	003ff406 	br	81126f28 <__reset+0xfb106f28>
81126f58:	10c003cc 	andi	r3,r2,15
81126f5c:	01000104 	movi	r4,4
81126f60:	193ff626 	beq	r3,r4,81126f3c <__reset+0xfb106f3c>
81126f64:	0023883a 	mov	r17,zero
81126f68:	003fca06 	br	81126e94 <__reset+0xfb106e94>
81126f6c:	813fd336 	bltu	r16,r4,81126ebc <__reset+0xfb106ebc>
81126f70:	1023883a 	mov	r17,r2
81126f74:	003fa806 	br	81126e18 <__reset+0xfb106e18>
81126f78:	b0ffd636 	bltu	r22,r3,81126ed4 <__reset+0xfb106ed4>
81126f7c:	1011883a 	mov	r8,r2
81126f80:	b0ff341e 	bne	r22,r3,81126c54 <__reset+0xfb106c54>
81126f84:	003f3406 	br	81126c58 <__reset+0xfb106c58>
81126f88:	0005883a 	mov	r2,zero
81126f8c:	003fe006 	br	81126f10 <__reset+0xfb106f10>
81126f90:	00800434 	movhi	r2,16
81126f94:	89400234 	orhi	r5,r17,8
81126f98:	10bfffc4 	addi	r2,r2,-1
81126f9c:	b807883a 	mov	r3,r23
81126fa0:	288a703a 	and	r5,r5,r2
81126fa4:	4025883a 	mov	r18,r8
81126fa8:	003e8206 	br	811269b4 <__reset+0xfb1069b4>

81126fac <__eqdf2>:
81126fac:	2804d53a 	srli	r2,r5,20
81126fb0:	3806d53a 	srli	r3,r7,20
81126fb4:	02000434 	movhi	r8,16
81126fb8:	423fffc4 	addi	r8,r8,-1
81126fbc:	1081ffcc 	andi	r2,r2,2047
81126fc0:	0281ffc4 	movi	r10,2047
81126fc4:	2a12703a 	and	r9,r5,r8
81126fc8:	18c1ffcc 	andi	r3,r3,2047
81126fcc:	3a10703a 	and	r8,r7,r8
81126fd0:	280ad7fa 	srli	r5,r5,31
81126fd4:	380ed7fa 	srli	r7,r7,31
81126fd8:	12801026 	beq	r2,r10,8112701c <__eqdf2+0x70>
81126fdc:	0281ffc4 	movi	r10,2047
81126fe0:	1a800a26 	beq	r3,r10,8112700c <__eqdf2+0x60>
81126fe4:	10c00226 	beq	r2,r3,81126ff0 <__eqdf2+0x44>
81126fe8:	00800044 	movi	r2,1
81126fec:	f800283a 	ret
81126ff0:	4a3ffd1e 	bne	r9,r8,81126fe8 <__reset+0xfb106fe8>
81126ff4:	21bffc1e 	bne	r4,r6,81126fe8 <__reset+0xfb106fe8>
81126ff8:	29c00c26 	beq	r5,r7,8112702c <__eqdf2+0x80>
81126ffc:	103ffa1e 	bne	r2,zero,81126fe8 <__reset+0xfb106fe8>
81127000:	2244b03a 	or	r2,r4,r9
81127004:	1004c03a 	cmpne	r2,r2,zero
81127008:	f800283a 	ret
8112700c:	3214b03a 	or	r10,r6,r8
81127010:	503ff426 	beq	r10,zero,81126fe4 <__reset+0xfb106fe4>
81127014:	00800044 	movi	r2,1
81127018:	f800283a 	ret
8112701c:	2254b03a 	or	r10,r4,r9
81127020:	503fee26 	beq	r10,zero,81126fdc <__reset+0xfb106fdc>
81127024:	00800044 	movi	r2,1
81127028:	f800283a 	ret
8112702c:	0005883a 	mov	r2,zero
81127030:	f800283a 	ret

81127034 <__gedf2>:
81127034:	2804d53a 	srli	r2,r5,20
81127038:	3806d53a 	srli	r3,r7,20
8112703c:	02000434 	movhi	r8,16
81127040:	423fffc4 	addi	r8,r8,-1
81127044:	1081ffcc 	andi	r2,r2,2047
81127048:	0241ffc4 	movi	r9,2047
8112704c:	2a14703a 	and	r10,r5,r8
81127050:	18c1ffcc 	andi	r3,r3,2047
81127054:	3a10703a 	and	r8,r7,r8
81127058:	280ad7fa 	srli	r5,r5,31
8112705c:	380ed7fa 	srli	r7,r7,31
81127060:	12401d26 	beq	r2,r9,811270d8 <__gedf2+0xa4>
81127064:	0241ffc4 	movi	r9,2047
81127068:	1a401226 	beq	r3,r9,811270b4 <__gedf2+0x80>
8112706c:	1000081e 	bne	r2,zero,81127090 <__gedf2+0x5c>
81127070:	2296b03a 	or	r11,r4,r10
81127074:	5813003a 	cmpeq	r9,r11,zero
81127078:	1800091e 	bne	r3,zero,811270a0 <__gedf2+0x6c>
8112707c:	3218b03a 	or	r12,r6,r8
81127080:	6000071e 	bne	r12,zero,811270a0 <__gedf2+0x6c>
81127084:	0005883a 	mov	r2,zero
81127088:	5800101e 	bne	r11,zero,811270cc <__gedf2+0x98>
8112708c:	f800283a 	ret
81127090:	18000c1e 	bne	r3,zero,811270c4 <__gedf2+0x90>
81127094:	3212b03a 	or	r9,r6,r8
81127098:	48000c26 	beq	r9,zero,811270cc <__gedf2+0x98>
8112709c:	0013883a 	mov	r9,zero
811270a0:	39c03fcc 	andi	r7,r7,255
811270a4:	48000826 	beq	r9,zero,811270c8 <__gedf2+0x94>
811270a8:	38000926 	beq	r7,zero,811270d0 <__gedf2+0x9c>
811270ac:	00800044 	movi	r2,1
811270b0:	f800283a 	ret
811270b4:	3212b03a 	or	r9,r6,r8
811270b8:	483fec26 	beq	r9,zero,8112706c <__reset+0xfb10706c>
811270bc:	00bfff84 	movi	r2,-2
811270c0:	f800283a 	ret
811270c4:	39c03fcc 	andi	r7,r7,255
811270c8:	29c00626 	beq	r5,r7,811270e4 <__gedf2+0xb0>
811270cc:	283ff726 	beq	r5,zero,811270ac <__reset+0xfb1070ac>
811270d0:	00bfffc4 	movi	r2,-1
811270d4:	f800283a 	ret
811270d8:	2292b03a 	or	r9,r4,r10
811270dc:	483fe126 	beq	r9,zero,81127064 <__reset+0xfb107064>
811270e0:	003ff606 	br	811270bc <__reset+0xfb1070bc>
811270e4:	18bff916 	blt	r3,r2,811270cc <__reset+0xfb1070cc>
811270e8:	10c00316 	blt	r2,r3,811270f8 <__gedf2+0xc4>
811270ec:	42bff736 	bltu	r8,r10,811270cc <__reset+0xfb1070cc>
811270f0:	52000326 	beq	r10,r8,81127100 <__gedf2+0xcc>
811270f4:	5200042e 	bgeu	r10,r8,81127108 <__gedf2+0xd4>
811270f8:	283fec1e 	bne	r5,zero,811270ac <__reset+0xfb1070ac>
811270fc:	003ff406 	br	811270d0 <__reset+0xfb1070d0>
81127100:	313ff236 	bltu	r6,r4,811270cc <__reset+0xfb1070cc>
81127104:	21bffc36 	bltu	r4,r6,811270f8 <__reset+0xfb1070f8>
81127108:	0005883a 	mov	r2,zero
8112710c:	f800283a 	ret

81127110 <__ledf2>:
81127110:	2804d53a 	srli	r2,r5,20
81127114:	3810d53a 	srli	r8,r7,20
81127118:	00c00434 	movhi	r3,16
8112711c:	18ffffc4 	addi	r3,r3,-1
81127120:	1081ffcc 	andi	r2,r2,2047
81127124:	0241ffc4 	movi	r9,2047
81127128:	28d4703a 	and	r10,r5,r3
8112712c:	4201ffcc 	andi	r8,r8,2047
81127130:	38c6703a 	and	r3,r7,r3
81127134:	280ad7fa 	srli	r5,r5,31
81127138:	380ed7fa 	srli	r7,r7,31
8112713c:	12401f26 	beq	r2,r9,811271bc <__ledf2+0xac>
81127140:	0241ffc4 	movi	r9,2047
81127144:	42401426 	beq	r8,r9,81127198 <__ledf2+0x88>
81127148:	1000091e 	bne	r2,zero,81127170 <__ledf2+0x60>
8112714c:	2296b03a 	or	r11,r4,r10
81127150:	5813003a 	cmpeq	r9,r11,zero
81127154:	29403fcc 	andi	r5,r5,255
81127158:	40000a1e 	bne	r8,zero,81127184 <__ledf2+0x74>
8112715c:	30d8b03a 	or	r12,r6,r3
81127160:	6000081e 	bne	r12,zero,81127184 <__ledf2+0x74>
81127164:	0005883a 	mov	r2,zero
81127168:	5800111e 	bne	r11,zero,811271b0 <__ledf2+0xa0>
8112716c:	f800283a 	ret
81127170:	29403fcc 	andi	r5,r5,255
81127174:	40000c1e 	bne	r8,zero,811271a8 <__ledf2+0x98>
81127178:	30d2b03a 	or	r9,r6,r3
8112717c:	48000c26 	beq	r9,zero,811271b0 <__ledf2+0xa0>
81127180:	0013883a 	mov	r9,zero
81127184:	39c03fcc 	andi	r7,r7,255
81127188:	48000826 	beq	r9,zero,811271ac <__ledf2+0x9c>
8112718c:	38001126 	beq	r7,zero,811271d4 <__ledf2+0xc4>
81127190:	00800044 	movi	r2,1
81127194:	f800283a 	ret
81127198:	30d2b03a 	or	r9,r6,r3
8112719c:	483fea26 	beq	r9,zero,81127148 <__reset+0xfb107148>
811271a0:	00800084 	movi	r2,2
811271a4:	f800283a 	ret
811271a8:	39c03fcc 	andi	r7,r7,255
811271ac:	39400726 	beq	r7,r5,811271cc <__ledf2+0xbc>
811271b0:	2800081e 	bne	r5,zero,811271d4 <__ledf2+0xc4>
811271b4:	00800044 	movi	r2,1
811271b8:	f800283a 	ret
811271bc:	2292b03a 	or	r9,r4,r10
811271c0:	483fdf26 	beq	r9,zero,81127140 <__reset+0xfb107140>
811271c4:	00800084 	movi	r2,2
811271c8:	f800283a 	ret
811271cc:	4080030e 	bge	r8,r2,811271dc <__ledf2+0xcc>
811271d0:	383fef26 	beq	r7,zero,81127190 <__reset+0xfb107190>
811271d4:	00bfffc4 	movi	r2,-1
811271d8:	f800283a 	ret
811271dc:	123feb16 	blt	r2,r8,8112718c <__reset+0xfb10718c>
811271e0:	1abff336 	bltu	r3,r10,811271b0 <__reset+0xfb1071b0>
811271e4:	50c00326 	beq	r10,r3,811271f4 <__ledf2+0xe4>
811271e8:	50c0042e 	bgeu	r10,r3,811271fc <__ledf2+0xec>
811271ec:	283fe81e 	bne	r5,zero,81127190 <__reset+0xfb107190>
811271f0:	003ff806 	br	811271d4 <__reset+0xfb1071d4>
811271f4:	313fee36 	bltu	r6,r4,811271b0 <__reset+0xfb1071b0>
811271f8:	21bffc36 	bltu	r4,r6,811271ec <__reset+0xfb1071ec>
811271fc:	0005883a 	mov	r2,zero
81127200:	f800283a 	ret

81127204 <__subdf3>:
81127204:	02000434 	movhi	r8,16
81127208:	423fffc4 	addi	r8,r8,-1
8112720c:	defffb04 	addi	sp,sp,-20
81127210:	2a14703a 	and	r10,r5,r8
81127214:	3812d53a 	srli	r9,r7,20
81127218:	3a10703a 	and	r8,r7,r8
8112721c:	de00012e 	bgeu	sp,et,81127224 <__subdf3+0x20>
81127220:	003b68fa 	trap	3
81127224:	2006d77a 	srli	r3,r4,29
81127228:	3004d77a 	srli	r2,r6,29
8112722c:	dc000015 	stw	r16,0(sp)
81127230:	501490fa 	slli	r10,r10,3
81127234:	2820d53a 	srli	r16,r5,20
81127238:	401090fa 	slli	r8,r8,3
8112723c:	dc800215 	stw	r18,8(sp)
81127240:	dc400115 	stw	r17,4(sp)
81127244:	dfc00415 	stw	ra,16(sp)
81127248:	202290fa 	slli	r17,r4,3
8112724c:	dcc00315 	stw	r19,12(sp)
81127250:	4a41ffcc 	andi	r9,r9,2047
81127254:	0101ffc4 	movi	r4,2047
81127258:	2824d7fa 	srli	r18,r5,31
8112725c:	8401ffcc 	andi	r16,r16,2047
81127260:	50c6b03a 	or	r3,r10,r3
81127264:	380ed7fa 	srli	r7,r7,31
81127268:	408ab03a 	or	r5,r8,r2
8112726c:	300c90fa 	slli	r6,r6,3
81127270:	49009626 	beq	r9,r4,811274cc <__subdf3+0x2c8>
81127274:	39c0005c 	xori	r7,r7,1
81127278:	8245c83a 	sub	r2,r16,r9
8112727c:	3c807426 	beq	r7,r18,81127450 <__subdf3+0x24c>
81127280:	0080af0e 	bge	zero,r2,81127540 <__subdf3+0x33c>
81127284:	48002a1e 	bne	r9,zero,81127330 <__subdf3+0x12c>
81127288:	2988b03a 	or	r4,r5,r6
8112728c:	20009a1e 	bne	r4,zero,811274f8 <__subdf3+0x2f4>
81127290:	888001cc 	andi	r2,r17,7
81127294:	10000726 	beq	r2,zero,811272b4 <__subdf3+0xb0>
81127298:	888003cc 	andi	r2,r17,15
8112729c:	01000104 	movi	r4,4
811272a0:	11000426 	beq	r2,r4,811272b4 <__subdf3+0xb0>
811272a4:	890b883a 	add	r5,r17,r4
811272a8:	2c63803a 	cmpltu	r17,r5,r17
811272ac:	1c47883a 	add	r3,r3,r17
811272b0:	2823883a 	mov	r17,r5
811272b4:	1880202c 	andhi	r2,r3,128
811272b8:	10005926 	beq	r2,zero,81127420 <__subdf3+0x21c>
811272bc:	84000044 	addi	r16,r16,1
811272c0:	0081ffc4 	movi	r2,2047
811272c4:	8080be26 	beq	r16,r2,811275c0 <__subdf3+0x3bc>
811272c8:	017fe034 	movhi	r5,65408
811272cc:	297fffc4 	addi	r5,r5,-1
811272d0:	1946703a 	and	r3,r3,r5
811272d4:	1804977a 	slli	r2,r3,29
811272d8:	1806927a 	slli	r3,r3,9
811272dc:	8822d0fa 	srli	r17,r17,3
811272e0:	8401ffcc 	andi	r16,r16,2047
811272e4:	180ad33a 	srli	r5,r3,12
811272e8:	9100004c 	andi	r4,r18,1
811272ec:	1444b03a 	or	r2,r2,r17
811272f0:	80c1ffcc 	andi	r3,r16,2047
811272f4:	1820953a 	slli	r16,r3,20
811272f8:	20c03fcc 	andi	r3,r4,255
811272fc:	180897fa 	slli	r4,r3,31
81127300:	00c00434 	movhi	r3,16
81127304:	18ffffc4 	addi	r3,r3,-1
81127308:	28c6703a 	and	r3,r5,r3
8112730c:	1c06b03a 	or	r3,r3,r16
81127310:	1906b03a 	or	r3,r3,r4
81127314:	dfc00417 	ldw	ra,16(sp)
81127318:	dcc00317 	ldw	r19,12(sp)
8112731c:	dc800217 	ldw	r18,8(sp)
81127320:	dc400117 	ldw	r17,4(sp)
81127324:	dc000017 	ldw	r16,0(sp)
81127328:	dec00504 	addi	sp,sp,20
8112732c:	f800283a 	ret
81127330:	0101ffc4 	movi	r4,2047
81127334:	813fd626 	beq	r16,r4,81127290 <__reset+0xfb107290>
81127338:	29402034 	orhi	r5,r5,128
8112733c:	01000e04 	movi	r4,56
81127340:	2080a316 	blt	r4,r2,811275d0 <__subdf3+0x3cc>
81127344:	010007c4 	movi	r4,31
81127348:	2080c616 	blt	r4,r2,81127664 <__subdf3+0x460>
8112734c:	01000804 	movi	r4,32
81127350:	2089c83a 	sub	r4,r4,r2
81127354:	2910983a 	sll	r8,r5,r4
81127358:	308ed83a 	srl	r7,r6,r2
8112735c:	3108983a 	sll	r4,r6,r4
81127360:	2884d83a 	srl	r2,r5,r2
81127364:	41ccb03a 	or	r6,r8,r7
81127368:	2008c03a 	cmpne	r4,r4,zero
8112736c:	310cb03a 	or	r6,r6,r4
81127370:	898dc83a 	sub	r6,r17,r6
81127374:	89a3803a 	cmpltu	r17,r17,r6
81127378:	1887c83a 	sub	r3,r3,r2
8112737c:	1c47c83a 	sub	r3,r3,r17
81127380:	3023883a 	mov	r17,r6
81127384:	1880202c 	andhi	r2,r3,128
81127388:	10002326 	beq	r2,zero,81127418 <__subdf3+0x214>
8112738c:	04c02034 	movhi	r19,128
81127390:	9cffffc4 	addi	r19,r19,-1
81127394:	1ce6703a 	and	r19,r3,r19
81127398:	98007a26 	beq	r19,zero,81127584 <__subdf3+0x380>
8112739c:	9809883a 	mov	r4,r19
811273a0:	11125200 	call	81112520 <__clzsi2>
811273a4:	113ffe04 	addi	r4,r2,-8
811273a8:	00c007c4 	movi	r3,31
811273ac:	19007b16 	blt	r3,r4,8112759c <__subdf3+0x398>
811273b0:	00800804 	movi	r2,32
811273b4:	1105c83a 	sub	r2,r2,r4
811273b8:	8884d83a 	srl	r2,r17,r2
811273bc:	9906983a 	sll	r3,r19,r4
811273c0:	8922983a 	sll	r17,r17,r4
811273c4:	10c4b03a 	or	r2,r2,r3
811273c8:	24007816 	blt	r4,r16,811275ac <__subdf3+0x3a8>
811273cc:	2421c83a 	sub	r16,r4,r16
811273d0:	80c00044 	addi	r3,r16,1
811273d4:	010007c4 	movi	r4,31
811273d8:	20c09516 	blt	r4,r3,81127630 <__subdf3+0x42c>
811273dc:	01400804 	movi	r5,32
811273e0:	28cbc83a 	sub	r5,r5,r3
811273e4:	88c8d83a 	srl	r4,r17,r3
811273e8:	8962983a 	sll	r17,r17,r5
811273ec:	114a983a 	sll	r5,r2,r5
811273f0:	10c6d83a 	srl	r3,r2,r3
811273f4:	8804c03a 	cmpne	r2,r17,zero
811273f8:	290ab03a 	or	r5,r5,r4
811273fc:	28a2b03a 	or	r17,r5,r2
81127400:	0021883a 	mov	r16,zero
81127404:	003fa206 	br	81127290 <__reset+0xfb107290>
81127408:	2090b03a 	or	r8,r4,r2
8112740c:	40018e26 	beq	r8,zero,81127a48 <__subdf3+0x844>
81127410:	1007883a 	mov	r3,r2
81127414:	2023883a 	mov	r17,r4
81127418:	888001cc 	andi	r2,r17,7
8112741c:	103f9e1e 	bne	r2,zero,81127298 <__reset+0xfb107298>
81127420:	1804977a 	slli	r2,r3,29
81127424:	8822d0fa 	srli	r17,r17,3
81127428:	1810d0fa 	srli	r8,r3,3
8112742c:	9100004c 	andi	r4,r18,1
81127430:	1444b03a 	or	r2,r2,r17
81127434:	00c1ffc4 	movi	r3,2047
81127438:	80c02826 	beq	r16,r3,811274dc <__subdf3+0x2d8>
8112743c:	01400434 	movhi	r5,16
81127440:	297fffc4 	addi	r5,r5,-1
81127444:	80e0703a 	and	r16,r16,r3
81127448:	414a703a 	and	r5,r8,r5
8112744c:	003fa806 	br	811272f0 <__reset+0xfb1072f0>
81127450:	0080630e 	bge	zero,r2,811275e0 <__subdf3+0x3dc>
81127454:	48003026 	beq	r9,zero,81127518 <__subdf3+0x314>
81127458:	0101ffc4 	movi	r4,2047
8112745c:	813f8c26 	beq	r16,r4,81127290 <__reset+0xfb107290>
81127460:	29402034 	orhi	r5,r5,128
81127464:	01000e04 	movi	r4,56
81127468:	2080a90e 	bge	r4,r2,81127710 <__subdf3+0x50c>
8112746c:	298cb03a 	or	r6,r5,r6
81127470:	3012c03a 	cmpne	r9,r6,zero
81127474:	0005883a 	mov	r2,zero
81127478:	4c53883a 	add	r9,r9,r17
8112747c:	4c63803a 	cmpltu	r17,r9,r17
81127480:	10c7883a 	add	r3,r2,r3
81127484:	88c7883a 	add	r3,r17,r3
81127488:	4823883a 	mov	r17,r9
8112748c:	1880202c 	andhi	r2,r3,128
81127490:	1000d026 	beq	r2,zero,811277d4 <__subdf3+0x5d0>
81127494:	84000044 	addi	r16,r16,1
81127498:	0081ffc4 	movi	r2,2047
8112749c:	8080fe26 	beq	r16,r2,81127898 <__subdf3+0x694>
811274a0:	00bfe034 	movhi	r2,65408
811274a4:	10bfffc4 	addi	r2,r2,-1
811274a8:	1886703a 	and	r3,r3,r2
811274ac:	880ad07a 	srli	r5,r17,1
811274b0:	180497fa 	slli	r2,r3,31
811274b4:	8900004c 	andi	r4,r17,1
811274b8:	2922b03a 	or	r17,r5,r4
811274bc:	1806d07a 	srli	r3,r3,1
811274c0:	1462b03a 	or	r17,r2,r17
811274c4:	3825883a 	mov	r18,r7
811274c8:	003f7106 	br	81127290 <__reset+0xfb107290>
811274cc:	2984b03a 	or	r2,r5,r6
811274d0:	103f6826 	beq	r2,zero,81127274 <__reset+0xfb107274>
811274d4:	39c03fcc 	andi	r7,r7,255
811274d8:	003f6706 	br	81127278 <__reset+0xfb107278>
811274dc:	4086b03a 	or	r3,r8,r2
811274e0:	18015226 	beq	r3,zero,81127a2c <__subdf3+0x828>
811274e4:	00c00434 	movhi	r3,16
811274e8:	41400234 	orhi	r5,r8,8
811274ec:	18ffffc4 	addi	r3,r3,-1
811274f0:	28ca703a 	and	r5,r5,r3
811274f4:	003f7e06 	br	811272f0 <__reset+0xfb1072f0>
811274f8:	10bfffc4 	addi	r2,r2,-1
811274fc:	1000491e 	bne	r2,zero,81127624 <__subdf3+0x420>
81127500:	898fc83a 	sub	r7,r17,r6
81127504:	89e3803a 	cmpltu	r17,r17,r7
81127508:	1947c83a 	sub	r3,r3,r5
8112750c:	1c47c83a 	sub	r3,r3,r17
81127510:	3823883a 	mov	r17,r7
81127514:	003f9b06 	br	81127384 <__reset+0xfb107384>
81127518:	2988b03a 	or	r4,r5,r6
8112751c:	203f5c26 	beq	r4,zero,81127290 <__reset+0xfb107290>
81127520:	10bfffc4 	addi	r2,r2,-1
81127524:	1000931e 	bne	r2,zero,81127774 <__subdf3+0x570>
81127528:	898d883a 	add	r6,r17,r6
8112752c:	3463803a 	cmpltu	r17,r6,r17
81127530:	1947883a 	add	r3,r3,r5
81127534:	88c7883a 	add	r3,r17,r3
81127538:	3023883a 	mov	r17,r6
8112753c:	003fd306 	br	8112748c <__reset+0xfb10748c>
81127540:	1000541e 	bne	r2,zero,81127694 <__subdf3+0x490>
81127544:	80800044 	addi	r2,r16,1
81127548:	1081ffcc 	andi	r2,r2,2047
8112754c:	01000044 	movi	r4,1
81127550:	2080a20e 	bge	r4,r2,811277dc <__subdf3+0x5d8>
81127554:	8989c83a 	sub	r4,r17,r6
81127558:	8905803a 	cmpltu	r2,r17,r4
8112755c:	1967c83a 	sub	r19,r3,r5
81127560:	98a7c83a 	sub	r19,r19,r2
81127564:	9880202c 	andhi	r2,r19,128
81127568:	10006326 	beq	r2,zero,811276f8 <__subdf3+0x4f4>
8112756c:	3463c83a 	sub	r17,r6,r17
81127570:	28c7c83a 	sub	r3,r5,r3
81127574:	344d803a 	cmpltu	r6,r6,r17
81127578:	19a7c83a 	sub	r19,r3,r6
8112757c:	3825883a 	mov	r18,r7
81127580:	983f861e 	bne	r19,zero,8112739c <__reset+0xfb10739c>
81127584:	8809883a 	mov	r4,r17
81127588:	11125200 	call	81112520 <__clzsi2>
8112758c:	10800804 	addi	r2,r2,32
81127590:	113ffe04 	addi	r4,r2,-8
81127594:	00c007c4 	movi	r3,31
81127598:	193f850e 	bge	r3,r4,811273b0 <__reset+0xfb1073b0>
8112759c:	10bff604 	addi	r2,r2,-40
811275a0:	8884983a 	sll	r2,r17,r2
811275a4:	0023883a 	mov	r17,zero
811275a8:	243f880e 	bge	r4,r16,811273cc <__reset+0xfb1073cc>
811275ac:	00ffe034 	movhi	r3,65408
811275b0:	18ffffc4 	addi	r3,r3,-1
811275b4:	8121c83a 	sub	r16,r16,r4
811275b8:	10c6703a 	and	r3,r2,r3
811275bc:	003f3406 	br	81127290 <__reset+0xfb107290>
811275c0:	9100004c 	andi	r4,r18,1
811275c4:	000b883a 	mov	r5,zero
811275c8:	0005883a 	mov	r2,zero
811275cc:	003f4806 	br	811272f0 <__reset+0xfb1072f0>
811275d0:	298cb03a 	or	r6,r5,r6
811275d4:	300cc03a 	cmpne	r6,r6,zero
811275d8:	0005883a 	mov	r2,zero
811275dc:	003f6406 	br	81127370 <__reset+0xfb107370>
811275e0:	10009a1e 	bne	r2,zero,8112784c <__subdf3+0x648>
811275e4:	82400044 	addi	r9,r16,1
811275e8:	4881ffcc 	andi	r2,r9,2047
811275ec:	02800044 	movi	r10,1
811275f0:	5080670e 	bge	r10,r2,81127790 <__subdf3+0x58c>
811275f4:	0081ffc4 	movi	r2,2047
811275f8:	4880af26 	beq	r9,r2,811278b8 <__subdf3+0x6b4>
811275fc:	898d883a 	add	r6,r17,r6
81127600:	1945883a 	add	r2,r3,r5
81127604:	3447803a 	cmpltu	r3,r6,r17
81127608:	1887883a 	add	r3,r3,r2
8112760c:	182297fa 	slli	r17,r3,31
81127610:	300cd07a 	srli	r6,r6,1
81127614:	1806d07a 	srli	r3,r3,1
81127618:	4821883a 	mov	r16,r9
8112761c:	89a2b03a 	or	r17,r17,r6
81127620:	003f1b06 	br	81127290 <__reset+0xfb107290>
81127624:	0101ffc4 	movi	r4,2047
81127628:	813f441e 	bne	r16,r4,8112733c <__reset+0xfb10733c>
8112762c:	003f1806 	br	81127290 <__reset+0xfb107290>
81127630:	843ff844 	addi	r16,r16,-31
81127634:	01400804 	movi	r5,32
81127638:	1408d83a 	srl	r4,r2,r16
8112763c:	19405026 	beq	r3,r5,81127780 <__subdf3+0x57c>
81127640:	01401004 	movi	r5,64
81127644:	28c7c83a 	sub	r3,r5,r3
81127648:	10c4983a 	sll	r2,r2,r3
8112764c:	88a2b03a 	or	r17,r17,r2
81127650:	8822c03a 	cmpne	r17,r17,zero
81127654:	2462b03a 	or	r17,r4,r17
81127658:	0007883a 	mov	r3,zero
8112765c:	0021883a 	mov	r16,zero
81127660:	003f6d06 	br	81127418 <__reset+0xfb107418>
81127664:	11fff804 	addi	r7,r2,-32
81127668:	01000804 	movi	r4,32
8112766c:	29ced83a 	srl	r7,r5,r7
81127670:	11004526 	beq	r2,r4,81127788 <__subdf3+0x584>
81127674:	01001004 	movi	r4,64
81127678:	2089c83a 	sub	r4,r4,r2
8112767c:	2904983a 	sll	r2,r5,r4
81127680:	118cb03a 	or	r6,r2,r6
81127684:	300cc03a 	cmpne	r6,r6,zero
81127688:	398cb03a 	or	r6,r7,r6
8112768c:	0005883a 	mov	r2,zero
81127690:	003f3706 	br	81127370 <__reset+0xfb107370>
81127694:	80002a26 	beq	r16,zero,81127740 <__subdf3+0x53c>
81127698:	0101ffc4 	movi	r4,2047
8112769c:	49006626 	beq	r9,r4,81127838 <__subdf3+0x634>
811276a0:	0085c83a 	sub	r2,zero,r2
811276a4:	18c02034 	orhi	r3,r3,128
811276a8:	01000e04 	movi	r4,56
811276ac:	20807e16 	blt	r4,r2,811278a8 <__subdf3+0x6a4>
811276b0:	010007c4 	movi	r4,31
811276b4:	2080e716 	blt	r4,r2,81127a54 <__subdf3+0x850>
811276b8:	01000804 	movi	r4,32
811276bc:	2089c83a 	sub	r4,r4,r2
811276c0:	1914983a 	sll	r10,r3,r4
811276c4:	8890d83a 	srl	r8,r17,r2
811276c8:	8908983a 	sll	r4,r17,r4
811276cc:	1884d83a 	srl	r2,r3,r2
811276d0:	5222b03a 	or	r17,r10,r8
811276d4:	2006c03a 	cmpne	r3,r4,zero
811276d8:	88e2b03a 	or	r17,r17,r3
811276dc:	3463c83a 	sub	r17,r6,r17
811276e0:	2885c83a 	sub	r2,r5,r2
811276e4:	344d803a 	cmpltu	r6,r6,r17
811276e8:	1187c83a 	sub	r3,r2,r6
811276ec:	4821883a 	mov	r16,r9
811276f0:	3825883a 	mov	r18,r7
811276f4:	003f2306 	br	81127384 <__reset+0xfb107384>
811276f8:	24d0b03a 	or	r8,r4,r19
811276fc:	40001b1e 	bne	r8,zero,8112776c <__subdf3+0x568>
81127700:	0005883a 	mov	r2,zero
81127704:	0009883a 	mov	r4,zero
81127708:	0021883a 	mov	r16,zero
8112770c:	003f4906 	br	81127434 <__reset+0xfb107434>
81127710:	010007c4 	movi	r4,31
81127714:	20803a16 	blt	r4,r2,81127800 <__subdf3+0x5fc>
81127718:	01000804 	movi	r4,32
8112771c:	2089c83a 	sub	r4,r4,r2
81127720:	2912983a 	sll	r9,r5,r4
81127724:	3090d83a 	srl	r8,r6,r2
81127728:	3108983a 	sll	r4,r6,r4
8112772c:	2884d83a 	srl	r2,r5,r2
81127730:	4a12b03a 	or	r9,r9,r8
81127734:	2008c03a 	cmpne	r4,r4,zero
81127738:	4912b03a 	or	r9,r9,r4
8112773c:	003f4e06 	br	81127478 <__reset+0xfb107478>
81127740:	1c48b03a 	or	r4,r3,r17
81127744:	20003c26 	beq	r4,zero,81127838 <__subdf3+0x634>
81127748:	0084303a 	nor	r2,zero,r2
8112774c:	1000381e 	bne	r2,zero,81127830 <__subdf3+0x62c>
81127750:	3463c83a 	sub	r17,r6,r17
81127754:	28c5c83a 	sub	r2,r5,r3
81127758:	344d803a 	cmpltu	r6,r6,r17
8112775c:	1187c83a 	sub	r3,r2,r6
81127760:	4821883a 	mov	r16,r9
81127764:	3825883a 	mov	r18,r7
81127768:	003f0606 	br	81127384 <__reset+0xfb107384>
8112776c:	2023883a 	mov	r17,r4
81127770:	003f0906 	br	81127398 <__reset+0xfb107398>
81127774:	0101ffc4 	movi	r4,2047
81127778:	813f3a1e 	bne	r16,r4,81127464 <__reset+0xfb107464>
8112777c:	003ec406 	br	81127290 <__reset+0xfb107290>
81127780:	0005883a 	mov	r2,zero
81127784:	003fb106 	br	8112764c <__reset+0xfb10764c>
81127788:	0005883a 	mov	r2,zero
8112778c:	003fbc06 	br	81127680 <__reset+0xfb107680>
81127790:	1c44b03a 	or	r2,r3,r17
81127794:	80008e1e 	bne	r16,zero,811279d0 <__subdf3+0x7cc>
81127798:	1000c826 	beq	r2,zero,81127abc <__subdf3+0x8b8>
8112779c:	2984b03a 	or	r2,r5,r6
811277a0:	103ebb26 	beq	r2,zero,81127290 <__reset+0xfb107290>
811277a4:	8989883a 	add	r4,r17,r6
811277a8:	1945883a 	add	r2,r3,r5
811277ac:	2447803a 	cmpltu	r3,r4,r17
811277b0:	1887883a 	add	r3,r3,r2
811277b4:	1880202c 	andhi	r2,r3,128
811277b8:	2023883a 	mov	r17,r4
811277bc:	103f1626 	beq	r2,zero,81127418 <__reset+0xfb107418>
811277c0:	00bfe034 	movhi	r2,65408
811277c4:	10bfffc4 	addi	r2,r2,-1
811277c8:	5021883a 	mov	r16,r10
811277cc:	1886703a 	and	r3,r3,r2
811277d0:	003eaf06 	br	81127290 <__reset+0xfb107290>
811277d4:	3825883a 	mov	r18,r7
811277d8:	003f0f06 	br	81127418 <__reset+0xfb107418>
811277dc:	1c44b03a 	or	r2,r3,r17
811277e0:	8000251e 	bne	r16,zero,81127878 <__subdf3+0x674>
811277e4:	1000661e 	bne	r2,zero,81127980 <__subdf3+0x77c>
811277e8:	2990b03a 	or	r8,r5,r6
811277ec:	40009626 	beq	r8,zero,81127a48 <__subdf3+0x844>
811277f0:	2807883a 	mov	r3,r5
811277f4:	3023883a 	mov	r17,r6
811277f8:	3825883a 	mov	r18,r7
811277fc:	003ea406 	br	81127290 <__reset+0xfb107290>
81127800:	127ff804 	addi	r9,r2,-32
81127804:	01000804 	movi	r4,32
81127808:	2a52d83a 	srl	r9,r5,r9
8112780c:	11008c26 	beq	r2,r4,81127a40 <__subdf3+0x83c>
81127810:	01001004 	movi	r4,64
81127814:	2085c83a 	sub	r2,r4,r2
81127818:	2884983a 	sll	r2,r5,r2
8112781c:	118cb03a 	or	r6,r2,r6
81127820:	300cc03a 	cmpne	r6,r6,zero
81127824:	4992b03a 	or	r9,r9,r6
81127828:	0005883a 	mov	r2,zero
8112782c:	003f1206 	br	81127478 <__reset+0xfb107478>
81127830:	0101ffc4 	movi	r4,2047
81127834:	493f9c1e 	bne	r9,r4,811276a8 <__reset+0xfb1076a8>
81127838:	2807883a 	mov	r3,r5
8112783c:	3023883a 	mov	r17,r6
81127840:	4821883a 	mov	r16,r9
81127844:	3825883a 	mov	r18,r7
81127848:	003e9106 	br	81127290 <__reset+0xfb107290>
8112784c:	80001f1e 	bne	r16,zero,811278cc <__subdf3+0x6c8>
81127850:	1c48b03a 	or	r4,r3,r17
81127854:	20005a26 	beq	r4,zero,811279c0 <__subdf3+0x7bc>
81127858:	0084303a 	nor	r2,zero,r2
8112785c:	1000561e 	bne	r2,zero,811279b8 <__subdf3+0x7b4>
81127860:	89a3883a 	add	r17,r17,r6
81127864:	1945883a 	add	r2,r3,r5
81127868:	898d803a 	cmpltu	r6,r17,r6
8112786c:	3087883a 	add	r3,r6,r2
81127870:	4821883a 	mov	r16,r9
81127874:	003f0506 	br	8112748c <__reset+0xfb10748c>
81127878:	10002b1e 	bne	r2,zero,81127928 <__subdf3+0x724>
8112787c:	2984b03a 	or	r2,r5,r6
81127880:	10008026 	beq	r2,zero,81127a84 <__subdf3+0x880>
81127884:	2807883a 	mov	r3,r5
81127888:	3023883a 	mov	r17,r6
8112788c:	3825883a 	mov	r18,r7
81127890:	0401ffc4 	movi	r16,2047
81127894:	003e7e06 	br	81127290 <__reset+0xfb107290>
81127898:	3809883a 	mov	r4,r7
8112789c:	0011883a 	mov	r8,zero
811278a0:	0005883a 	mov	r2,zero
811278a4:	003ee306 	br	81127434 <__reset+0xfb107434>
811278a8:	1c62b03a 	or	r17,r3,r17
811278ac:	8822c03a 	cmpne	r17,r17,zero
811278b0:	0005883a 	mov	r2,zero
811278b4:	003f8906 	br	811276dc <__reset+0xfb1076dc>
811278b8:	3809883a 	mov	r4,r7
811278bc:	4821883a 	mov	r16,r9
811278c0:	0011883a 	mov	r8,zero
811278c4:	0005883a 	mov	r2,zero
811278c8:	003eda06 	br	81127434 <__reset+0xfb107434>
811278cc:	0101ffc4 	movi	r4,2047
811278d0:	49003b26 	beq	r9,r4,811279c0 <__subdf3+0x7bc>
811278d4:	0085c83a 	sub	r2,zero,r2
811278d8:	18c02034 	orhi	r3,r3,128
811278dc:	01000e04 	movi	r4,56
811278e0:	20806e16 	blt	r4,r2,81127a9c <__subdf3+0x898>
811278e4:	010007c4 	movi	r4,31
811278e8:	20807716 	blt	r4,r2,81127ac8 <__subdf3+0x8c4>
811278ec:	01000804 	movi	r4,32
811278f0:	2089c83a 	sub	r4,r4,r2
811278f4:	1914983a 	sll	r10,r3,r4
811278f8:	8890d83a 	srl	r8,r17,r2
811278fc:	8908983a 	sll	r4,r17,r4
81127900:	1884d83a 	srl	r2,r3,r2
81127904:	5222b03a 	or	r17,r10,r8
81127908:	2006c03a 	cmpne	r3,r4,zero
8112790c:	88e2b03a 	or	r17,r17,r3
81127910:	89a3883a 	add	r17,r17,r6
81127914:	1145883a 	add	r2,r2,r5
81127918:	898d803a 	cmpltu	r6,r17,r6
8112791c:	3087883a 	add	r3,r6,r2
81127920:	4821883a 	mov	r16,r9
81127924:	003ed906 	br	8112748c <__reset+0xfb10748c>
81127928:	2984b03a 	or	r2,r5,r6
8112792c:	10004226 	beq	r2,zero,81127a38 <__subdf3+0x834>
81127930:	1808d0fa 	srli	r4,r3,3
81127934:	8822d0fa 	srli	r17,r17,3
81127938:	1806977a 	slli	r3,r3,29
8112793c:	2080022c 	andhi	r2,r4,8
81127940:	1c62b03a 	or	r17,r3,r17
81127944:	10000826 	beq	r2,zero,81127968 <__subdf3+0x764>
81127948:	2812d0fa 	srli	r9,r5,3
8112794c:	4880022c 	andhi	r2,r9,8
81127950:	1000051e 	bne	r2,zero,81127968 <__subdf3+0x764>
81127954:	300cd0fa 	srli	r6,r6,3
81127958:	2804977a 	slli	r2,r5,29
8112795c:	4809883a 	mov	r4,r9
81127960:	3825883a 	mov	r18,r7
81127964:	11a2b03a 	or	r17,r2,r6
81127968:	8806d77a 	srli	r3,r17,29
8112796c:	200890fa 	slli	r4,r4,3
81127970:	882290fa 	slli	r17,r17,3
81127974:	0401ffc4 	movi	r16,2047
81127978:	1906b03a 	or	r3,r3,r4
8112797c:	003e4406 	br	81127290 <__reset+0xfb107290>
81127980:	2984b03a 	or	r2,r5,r6
81127984:	103e4226 	beq	r2,zero,81127290 <__reset+0xfb107290>
81127988:	8989c83a 	sub	r4,r17,r6
8112798c:	8911803a 	cmpltu	r8,r17,r4
81127990:	1945c83a 	sub	r2,r3,r5
81127994:	1205c83a 	sub	r2,r2,r8
81127998:	1200202c 	andhi	r8,r2,128
8112799c:	403e9a26 	beq	r8,zero,81127408 <__reset+0xfb107408>
811279a0:	3463c83a 	sub	r17,r6,r17
811279a4:	28c5c83a 	sub	r2,r5,r3
811279a8:	344d803a 	cmpltu	r6,r6,r17
811279ac:	1187c83a 	sub	r3,r2,r6
811279b0:	3825883a 	mov	r18,r7
811279b4:	003e3606 	br	81127290 <__reset+0xfb107290>
811279b8:	0101ffc4 	movi	r4,2047
811279bc:	493fc71e 	bne	r9,r4,811278dc <__reset+0xfb1078dc>
811279c0:	2807883a 	mov	r3,r5
811279c4:	3023883a 	mov	r17,r6
811279c8:	4821883a 	mov	r16,r9
811279cc:	003e3006 	br	81127290 <__reset+0xfb107290>
811279d0:	10003626 	beq	r2,zero,81127aac <__subdf3+0x8a8>
811279d4:	2984b03a 	or	r2,r5,r6
811279d8:	10001726 	beq	r2,zero,81127a38 <__subdf3+0x834>
811279dc:	1808d0fa 	srli	r4,r3,3
811279e0:	8822d0fa 	srli	r17,r17,3
811279e4:	1806977a 	slli	r3,r3,29
811279e8:	2080022c 	andhi	r2,r4,8
811279ec:	1c62b03a 	or	r17,r3,r17
811279f0:	10000726 	beq	r2,zero,81127a10 <__subdf3+0x80c>
811279f4:	2812d0fa 	srli	r9,r5,3
811279f8:	4880022c 	andhi	r2,r9,8
811279fc:	1000041e 	bne	r2,zero,81127a10 <__subdf3+0x80c>
81127a00:	300cd0fa 	srli	r6,r6,3
81127a04:	2804977a 	slli	r2,r5,29
81127a08:	4809883a 	mov	r4,r9
81127a0c:	11a2b03a 	or	r17,r2,r6
81127a10:	8806d77a 	srli	r3,r17,29
81127a14:	200890fa 	slli	r4,r4,3
81127a18:	882290fa 	slli	r17,r17,3
81127a1c:	3825883a 	mov	r18,r7
81127a20:	1906b03a 	or	r3,r3,r4
81127a24:	0401ffc4 	movi	r16,2047
81127a28:	003e1906 	br	81127290 <__reset+0xfb107290>
81127a2c:	000b883a 	mov	r5,zero
81127a30:	0005883a 	mov	r2,zero
81127a34:	003e2e06 	br	811272f0 <__reset+0xfb1072f0>
81127a38:	0401ffc4 	movi	r16,2047
81127a3c:	003e1406 	br	81127290 <__reset+0xfb107290>
81127a40:	0005883a 	mov	r2,zero
81127a44:	003f7506 	br	8112781c <__reset+0xfb10781c>
81127a48:	0005883a 	mov	r2,zero
81127a4c:	0009883a 	mov	r4,zero
81127a50:	003e7806 	br	81127434 <__reset+0xfb107434>
81127a54:	123ff804 	addi	r8,r2,-32
81127a58:	01000804 	movi	r4,32
81127a5c:	1a10d83a 	srl	r8,r3,r8
81127a60:	11002526 	beq	r2,r4,81127af8 <__subdf3+0x8f4>
81127a64:	01001004 	movi	r4,64
81127a68:	2085c83a 	sub	r2,r4,r2
81127a6c:	1884983a 	sll	r2,r3,r2
81127a70:	1444b03a 	or	r2,r2,r17
81127a74:	1004c03a 	cmpne	r2,r2,zero
81127a78:	40a2b03a 	or	r17,r8,r2
81127a7c:	0005883a 	mov	r2,zero
81127a80:	003f1606 	br	811276dc <__reset+0xfb1076dc>
81127a84:	02000434 	movhi	r8,16
81127a88:	0009883a 	mov	r4,zero
81127a8c:	423fffc4 	addi	r8,r8,-1
81127a90:	00bfffc4 	movi	r2,-1
81127a94:	0401ffc4 	movi	r16,2047
81127a98:	003e6606 	br	81127434 <__reset+0xfb107434>
81127a9c:	1c62b03a 	or	r17,r3,r17
81127aa0:	8822c03a 	cmpne	r17,r17,zero
81127aa4:	0005883a 	mov	r2,zero
81127aa8:	003f9906 	br	81127910 <__reset+0xfb107910>
81127aac:	2807883a 	mov	r3,r5
81127ab0:	3023883a 	mov	r17,r6
81127ab4:	0401ffc4 	movi	r16,2047
81127ab8:	003df506 	br	81127290 <__reset+0xfb107290>
81127abc:	2807883a 	mov	r3,r5
81127ac0:	3023883a 	mov	r17,r6
81127ac4:	003df206 	br	81127290 <__reset+0xfb107290>
81127ac8:	123ff804 	addi	r8,r2,-32
81127acc:	01000804 	movi	r4,32
81127ad0:	1a10d83a 	srl	r8,r3,r8
81127ad4:	11000a26 	beq	r2,r4,81127b00 <__subdf3+0x8fc>
81127ad8:	01001004 	movi	r4,64
81127adc:	2085c83a 	sub	r2,r4,r2
81127ae0:	1884983a 	sll	r2,r3,r2
81127ae4:	1444b03a 	or	r2,r2,r17
81127ae8:	1004c03a 	cmpne	r2,r2,zero
81127aec:	40a2b03a 	or	r17,r8,r2
81127af0:	0005883a 	mov	r2,zero
81127af4:	003f8606 	br	81127910 <__reset+0xfb107910>
81127af8:	0005883a 	mov	r2,zero
81127afc:	003fdc06 	br	81127a70 <__reset+0xfb107a70>
81127b00:	0005883a 	mov	r2,zero
81127b04:	003ff706 	br	81127ae4 <__reset+0xfb107ae4>

81127b08 <__fixdfsi>:
81127b08:	280cd53a 	srli	r6,r5,20
81127b0c:	00c00434 	movhi	r3,16
81127b10:	18ffffc4 	addi	r3,r3,-1
81127b14:	3181ffcc 	andi	r6,r6,2047
81127b18:	01c0ff84 	movi	r7,1022
81127b1c:	28c6703a 	and	r3,r5,r3
81127b20:	280ad7fa 	srli	r5,r5,31
81127b24:	3980120e 	bge	r7,r6,81127b70 <__fixdfsi+0x68>
81127b28:	00810744 	movi	r2,1053
81127b2c:	11800c16 	blt	r2,r6,81127b60 <__fixdfsi+0x58>
81127b30:	00810cc4 	movi	r2,1075
81127b34:	1185c83a 	sub	r2,r2,r6
81127b38:	01c007c4 	movi	r7,31
81127b3c:	18c00434 	orhi	r3,r3,16
81127b40:	38800d16 	blt	r7,r2,81127b78 <__fixdfsi+0x70>
81127b44:	31befb44 	addi	r6,r6,-1043
81127b48:	2084d83a 	srl	r2,r4,r2
81127b4c:	1986983a 	sll	r3,r3,r6
81127b50:	1884b03a 	or	r2,r3,r2
81127b54:	28000726 	beq	r5,zero,81127b74 <__fixdfsi+0x6c>
81127b58:	0085c83a 	sub	r2,zero,r2
81127b5c:	f800283a 	ret
81127b60:	00a00034 	movhi	r2,32768
81127b64:	10bfffc4 	addi	r2,r2,-1
81127b68:	2885883a 	add	r2,r5,r2
81127b6c:	f800283a 	ret
81127b70:	0005883a 	mov	r2,zero
81127b74:	f800283a 	ret
81127b78:	008104c4 	movi	r2,1043
81127b7c:	1185c83a 	sub	r2,r2,r6
81127b80:	1884d83a 	srl	r2,r3,r2
81127b84:	003ff306 	br	81127b54 <__reset+0xfb107b54>

81127b88 <__floatsidf>:
81127b88:	defffd04 	addi	sp,sp,-12
81127b8c:	de00012e 	bgeu	sp,et,81127b94 <__floatsidf+0xc>
81127b90:	003b68fa 	trap	3
81127b94:	dfc00215 	stw	ra,8(sp)
81127b98:	dc400115 	stw	r17,4(sp)
81127b9c:	dc000015 	stw	r16,0(sp)
81127ba0:	20002b26 	beq	r4,zero,81127c50 <__floatsidf+0xc8>
81127ba4:	2023883a 	mov	r17,r4
81127ba8:	2020d7fa 	srli	r16,r4,31
81127bac:	20002d16 	blt	r4,zero,81127c64 <__floatsidf+0xdc>
81127bb0:	8809883a 	mov	r4,r17
81127bb4:	11125200 	call	81112520 <__clzsi2>
81127bb8:	01410784 	movi	r5,1054
81127bbc:	288bc83a 	sub	r5,r5,r2
81127bc0:	01010cc4 	movi	r4,1075
81127bc4:	2149c83a 	sub	r4,r4,r5
81127bc8:	00c007c4 	movi	r3,31
81127bcc:	1900160e 	bge	r3,r4,81127c28 <__floatsidf+0xa0>
81127bd0:	00c104c4 	movi	r3,1043
81127bd4:	1947c83a 	sub	r3,r3,r5
81127bd8:	88c6983a 	sll	r3,r17,r3
81127bdc:	00800434 	movhi	r2,16
81127be0:	10bfffc4 	addi	r2,r2,-1
81127be4:	1886703a 	and	r3,r3,r2
81127be8:	2941ffcc 	andi	r5,r5,2047
81127bec:	800d883a 	mov	r6,r16
81127bf0:	0005883a 	mov	r2,zero
81127bf4:	280a953a 	slli	r5,r5,20
81127bf8:	31803fcc 	andi	r6,r6,255
81127bfc:	01000434 	movhi	r4,16
81127c00:	300c97fa 	slli	r6,r6,31
81127c04:	213fffc4 	addi	r4,r4,-1
81127c08:	1906703a 	and	r3,r3,r4
81127c0c:	1946b03a 	or	r3,r3,r5
81127c10:	1986b03a 	or	r3,r3,r6
81127c14:	dfc00217 	ldw	ra,8(sp)
81127c18:	dc400117 	ldw	r17,4(sp)
81127c1c:	dc000017 	ldw	r16,0(sp)
81127c20:	dec00304 	addi	sp,sp,12
81127c24:	f800283a 	ret
81127c28:	00c002c4 	movi	r3,11
81127c2c:	1887c83a 	sub	r3,r3,r2
81127c30:	88c6d83a 	srl	r3,r17,r3
81127c34:	8904983a 	sll	r2,r17,r4
81127c38:	01000434 	movhi	r4,16
81127c3c:	213fffc4 	addi	r4,r4,-1
81127c40:	2941ffcc 	andi	r5,r5,2047
81127c44:	1906703a 	and	r3,r3,r4
81127c48:	800d883a 	mov	r6,r16
81127c4c:	003fe906 	br	81127bf4 <__reset+0xfb107bf4>
81127c50:	000d883a 	mov	r6,zero
81127c54:	000b883a 	mov	r5,zero
81127c58:	0007883a 	mov	r3,zero
81127c5c:	0005883a 	mov	r2,zero
81127c60:	003fe406 	br	81127bf4 <__reset+0xfb107bf4>
81127c64:	0123c83a 	sub	r17,zero,r4
81127c68:	003fd106 	br	81127bb0 <__reset+0xfb107bb0>

81127c6c <__floatunsidf>:
81127c6c:	defffe04 	addi	sp,sp,-8
81127c70:	de00012e 	bgeu	sp,et,81127c78 <__floatunsidf+0xc>
81127c74:	003b68fa 	trap	3
81127c78:	dc000015 	stw	r16,0(sp)
81127c7c:	dfc00115 	stw	ra,4(sp)
81127c80:	2021883a 	mov	r16,r4
81127c84:	20002226 	beq	r4,zero,81127d10 <__floatunsidf+0xa4>
81127c88:	11125200 	call	81112520 <__clzsi2>
81127c8c:	01010784 	movi	r4,1054
81127c90:	2089c83a 	sub	r4,r4,r2
81127c94:	01810cc4 	movi	r6,1075
81127c98:	310dc83a 	sub	r6,r6,r4
81127c9c:	00c007c4 	movi	r3,31
81127ca0:	1980120e 	bge	r3,r6,81127cec <__floatunsidf+0x80>
81127ca4:	00c104c4 	movi	r3,1043
81127ca8:	1907c83a 	sub	r3,r3,r4
81127cac:	80ca983a 	sll	r5,r16,r3
81127cb0:	00800434 	movhi	r2,16
81127cb4:	10bfffc4 	addi	r2,r2,-1
81127cb8:	2101ffcc 	andi	r4,r4,2047
81127cbc:	0021883a 	mov	r16,zero
81127cc0:	288a703a 	and	r5,r5,r2
81127cc4:	2008953a 	slli	r4,r4,20
81127cc8:	00c00434 	movhi	r3,16
81127ccc:	18ffffc4 	addi	r3,r3,-1
81127cd0:	28c6703a 	and	r3,r5,r3
81127cd4:	8005883a 	mov	r2,r16
81127cd8:	1906b03a 	or	r3,r3,r4
81127cdc:	dfc00117 	ldw	ra,4(sp)
81127ce0:	dc000017 	ldw	r16,0(sp)
81127ce4:	dec00204 	addi	sp,sp,8
81127ce8:	f800283a 	ret
81127cec:	00c002c4 	movi	r3,11
81127cf0:	188bc83a 	sub	r5,r3,r2
81127cf4:	814ad83a 	srl	r5,r16,r5
81127cf8:	00c00434 	movhi	r3,16
81127cfc:	18ffffc4 	addi	r3,r3,-1
81127d00:	81a0983a 	sll	r16,r16,r6
81127d04:	2101ffcc 	andi	r4,r4,2047
81127d08:	28ca703a 	and	r5,r5,r3
81127d0c:	003fed06 	br	81127cc4 <__reset+0xfb107cc4>
81127d10:	0009883a 	mov	r4,zero
81127d14:	000b883a 	mov	r5,zero
81127d18:	003fea06 	br	81127cc4 <__reset+0xfb107cc4>

81127d1c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
81127d1c:	defffb04 	addi	sp,sp,-20
81127d20:	de00012e 	bgeu	sp,et,81127d28 <alt_busy_sleep+0xc>
81127d24:	003b68fa 	trap	3
81127d28:	df000415 	stw	fp,16(sp)
81127d2c:	df000404 	addi	fp,sp,16
81127d30:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
81127d34:	008000c4 	movi	r2,3
81127d38:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
81127d3c:	e0fffd17 	ldw	r3,-12(fp)
81127d40:	008003f4 	movhi	r2,15
81127d44:	10909004 	addi	r2,r2,16960
81127d48:	1887383a 	mul	r3,r3,r2
81127d4c:	00817db4 	movhi	r2,1526
81127d50:	10b84004 	addi	r2,r2,-7936
81127d54:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
81127d58:	00a00034 	movhi	r2,32768
81127d5c:	10bfffc4 	addi	r2,r2,-1
81127d60:	10c5203a 	divu	r2,r2,r3
81127d64:	e0ffff17 	ldw	r3,-4(fp)
81127d68:	1885203a 	divu	r2,r3,r2
81127d6c:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
81127d70:	e0bffe17 	ldw	r2,-8(fp)
81127d74:	10002526 	beq	r2,zero,81127e0c <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
81127d78:	e03ffc15 	stw	zero,-16(fp)
81127d7c:	00001406 	br	81127dd0 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81127d80:	00a00034 	movhi	r2,32768
81127d84:	10bfffc4 	addi	r2,r2,-1
81127d88:	10bfffc4 	addi	r2,r2,-1
81127d8c:	103ffe1e 	bne	r2,zero,81127d88 <__reset+0xfb107d88>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81127d90:	e0fffd17 	ldw	r3,-12(fp)
81127d94:	008003f4 	movhi	r2,15
81127d98:	10909004 	addi	r2,r2,16960
81127d9c:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81127da0:	00817db4 	movhi	r2,1526
81127da4:	10b84004 	addi	r2,r2,-7936
81127da8:	10c7203a 	divu	r3,r2,r3
81127dac:	00a00034 	movhi	r2,32768
81127db0:	10bfffc4 	addi	r2,r2,-1
81127db4:	10c5203a 	divu	r2,r2,r3
81127db8:	e0ffff17 	ldw	r3,-4(fp)
81127dbc:	1885c83a 	sub	r2,r3,r2
81127dc0:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81127dc4:	e0bffc17 	ldw	r2,-16(fp)
81127dc8:	10800044 	addi	r2,r2,1
81127dcc:	e0bffc15 	stw	r2,-16(fp)
81127dd0:	e0fffc17 	ldw	r3,-16(fp)
81127dd4:	e0bffe17 	ldw	r2,-8(fp)
81127dd8:	18bfe916 	blt	r3,r2,81127d80 <__reset+0xfb107d80>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81127ddc:	e0fffd17 	ldw	r3,-12(fp)
81127de0:	008003f4 	movhi	r2,15
81127de4:	10909004 	addi	r2,r2,16960
81127de8:	1887383a 	mul	r3,r3,r2
81127dec:	00817db4 	movhi	r2,1526
81127df0:	10b84004 	addi	r2,r2,-7936
81127df4:	10c7203a 	divu	r3,r2,r3
81127df8:	e0bfff17 	ldw	r2,-4(fp)
81127dfc:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81127e00:	10bfffc4 	addi	r2,r2,-1
81127e04:	103ffe1e 	bne	r2,zero,81127e00 <__reset+0xfb107e00>
81127e08:	00000b06 	br	81127e38 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81127e0c:	e0fffd17 	ldw	r3,-12(fp)
81127e10:	008003f4 	movhi	r2,15
81127e14:	10909004 	addi	r2,r2,16960
81127e18:	1887383a 	mul	r3,r3,r2
81127e1c:	00817db4 	movhi	r2,1526
81127e20:	10b84004 	addi	r2,r2,-7936
81127e24:	10c7203a 	divu	r3,r2,r3
81127e28:	e0bfff17 	ldw	r2,-4(fp)
81127e2c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81127e30:	10bfffc4 	addi	r2,r2,-1
81127e34:	00bffe16 	blt	zero,r2,81127e30 <__reset+0xfb107e30>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
81127e38:	0005883a 	mov	r2,zero
}
81127e3c:	e037883a 	mov	sp,fp
81127e40:	df000017 	ldw	fp,0(sp)
81127e44:	dec00104 	addi	sp,sp,4
81127e48:	f800283a 	ret

81127e4c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81127e4c:	defffe04 	addi	sp,sp,-8
81127e50:	de00012e 	bgeu	sp,et,81127e58 <alt_get_errno+0xc>
81127e54:	003b68fa 	trap	3
81127e58:	dfc00115 	stw	ra,4(sp)
81127e5c:	df000015 	stw	fp,0(sp)
81127e60:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81127e64:	d0a01017 	ldw	r2,-32704(gp)
81127e68:	10000326 	beq	r2,zero,81127e78 <alt_get_errno+0x2c>
81127e6c:	d0a01017 	ldw	r2,-32704(gp)
81127e70:	103ee83a 	callr	r2
81127e74:	00000106 	br	81127e7c <alt_get_errno+0x30>
81127e78:	d0a06004 	addi	r2,gp,-32384
}
81127e7c:	e037883a 	mov	sp,fp
81127e80:	dfc00117 	ldw	ra,4(sp)
81127e84:	df000017 	ldw	fp,0(sp)
81127e88:	dec00204 	addi	sp,sp,8
81127e8c:	f800283a 	ret

81127e90 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81127e90:	defffb04 	addi	sp,sp,-20
81127e94:	de00012e 	bgeu	sp,et,81127e9c <close+0xc>
81127e98:	003b68fa 	trap	3
81127e9c:	dfc00415 	stw	ra,16(sp)
81127ea0:	df000315 	stw	fp,12(sp)
81127ea4:	df000304 	addi	fp,sp,12
81127ea8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81127eac:	e0bfff17 	ldw	r2,-4(fp)
81127eb0:	10000616 	blt	r2,zero,81127ecc <close+0x3c>
81127eb4:	e0bfff17 	ldw	r2,-4(fp)
81127eb8:	10c00324 	muli	r3,r2,12
81127ebc:	00a04534 	movhi	r2,33044
81127ec0:	1081b904 	addi	r2,r2,1764
81127ec4:	1885883a 	add	r2,r3,r2
81127ec8:	00000106 	br	81127ed0 <close+0x40>
81127ecc:	0005883a 	mov	r2,zero
81127ed0:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
81127ed4:	e0bffd17 	ldw	r2,-12(fp)
81127ed8:	10001926 	beq	r2,zero,81127f40 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
81127edc:	e0bffd17 	ldw	r2,-12(fp)
81127ee0:	10800017 	ldw	r2,0(r2)
81127ee4:	10800417 	ldw	r2,16(r2)
81127ee8:	10000626 	beq	r2,zero,81127f04 <close+0x74>
81127eec:	e0bffd17 	ldw	r2,-12(fp)
81127ef0:	10800017 	ldw	r2,0(r2)
81127ef4:	10800417 	ldw	r2,16(r2)
81127ef8:	e13ffd17 	ldw	r4,-12(fp)
81127efc:	103ee83a 	callr	r2
81127f00:	00000106 	br	81127f08 <close+0x78>
81127f04:	0005883a 	mov	r2,zero
81127f08:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
81127f0c:	e13fff17 	ldw	r4,-4(fp)
81127f10:	11288d00 	call	811288d0 <alt_release_fd>
    if (rval < 0)
81127f14:	e0bffe17 	ldw	r2,-8(fp)
81127f18:	1000070e 	bge	r2,zero,81127f38 <close+0xa8>
    {
      ALT_ERRNO = -rval;
81127f1c:	1127e4c0 	call	81127e4c <alt_get_errno>
81127f20:	1007883a 	mov	r3,r2
81127f24:	e0bffe17 	ldw	r2,-8(fp)
81127f28:	0085c83a 	sub	r2,zero,r2
81127f2c:	18800015 	stw	r2,0(r3)
      return -1;
81127f30:	00bfffc4 	movi	r2,-1
81127f34:	00000706 	br	81127f54 <close+0xc4>
    }
    return 0;
81127f38:	0005883a 	mov	r2,zero
81127f3c:	00000506 	br	81127f54 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
81127f40:	1127e4c0 	call	81127e4c <alt_get_errno>
81127f44:	1007883a 	mov	r3,r2
81127f48:	00801444 	movi	r2,81
81127f4c:	18800015 	stw	r2,0(r3)
    return -1;
81127f50:	00bfffc4 	movi	r2,-1
  }
}
81127f54:	e037883a 	mov	sp,fp
81127f58:	dfc00117 	ldw	ra,4(sp)
81127f5c:	df000017 	ldw	fp,0(sp)
81127f60:	dec00204 	addi	sp,sp,8
81127f64:	f800283a 	ret

81127f68 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
81127f68:	deffff04 	addi	sp,sp,-4
81127f6c:	de00012e 	bgeu	sp,et,81127f74 <alt_dcache_flush_all+0xc>
81127f70:	003b68fa 	trap	3
81127f74:	df000015 	stw	fp,0(sp)
81127f78:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
81127f7c:	0001883a 	nop
81127f80:	e037883a 	mov	sp,fp
81127f84:	df000017 	ldw	fp,0(sp)
81127f88:	dec00104 	addi	sp,sp,4
81127f8c:	f800283a 	ret

81127f90 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81127f90:	defffc04 	addi	sp,sp,-16
81127f94:	de00012e 	bgeu	sp,et,81127f9c <alt_dev_null_write+0xc>
81127f98:	003b68fa 	trap	3
81127f9c:	df000315 	stw	fp,12(sp)
81127fa0:	df000304 	addi	fp,sp,12
81127fa4:	e13ffd15 	stw	r4,-12(fp)
81127fa8:	e17ffe15 	stw	r5,-8(fp)
81127fac:	e1bfff15 	stw	r6,-4(fp)
  return len;
81127fb0:	e0bfff17 	ldw	r2,-4(fp)
}
81127fb4:	e037883a 	mov	sp,fp
81127fb8:	df000017 	ldw	fp,0(sp)
81127fbc:	dec00104 	addi	sp,sp,4
81127fc0:	f800283a 	ret

81127fc4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81127fc4:	defffe04 	addi	sp,sp,-8
81127fc8:	de00012e 	bgeu	sp,et,81127fd0 <alt_get_errno+0xc>
81127fcc:	003b68fa 	trap	3
81127fd0:	dfc00115 	stw	ra,4(sp)
81127fd4:	df000015 	stw	fp,0(sp)
81127fd8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81127fdc:	d0a01017 	ldw	r2,-32704(gp)
81127fe0:	10000326 	beq	r2,zero,81127ff0 <alt_get_errno+0x2c>
81127fe4:	d0a01017 	ldw	r2,-32704(gp)
81127fe8:	103ee83a 	callr	r2
81127fec:	00000106 	br	81127ff4 <alt_get_errno+0x30>
81127ff0:	d0a06004 	addi	r2,gp,-32384
}
81127ff4:	e037883a 	mov	sp,fp
81127ff8:	dfc00117 	ldw	ra,4(sp)
81127ffc:	df000017 	ldw	fp,0(sp)
81128000:	dec00204 	addi	sp,sp,8
81128004:	f800283a 	ret

81128008 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
81128008:	defffb04 	addi	sp,sp,-20
8112800c:	de00012e 	bgeu	sp,et,81128014 <fstat+0xc>
81128010:	003b68fa 	trap	3
81128014:	dfc00415 	stw	ra,16(sp)
81128018:	df000315 	stw	fp,12(sp)
8112801c:	df000304 	addi	fp,sp,12
81128020:	e13ffe15 	stw	r4,-8(fp)
81128024:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81128028:	e0bffe17 	ldw	r2,-8(fp)
8112802c:	10000616 	blt	r2,zero,81128048 <fstat+0x40>
81128030:	e0bffe17 	ldw	r2,-8(fp)
81128034:	10c00324 	muli	r3,r2,12
81128038:	00a04534 	movhi	r2,33044
8112803c:	1081b904 	addi	r2,r2,1764
81128040:	1885883a 	add	r2,r3,r2
81128044:	00000106 	br	8112804c <fstat+0x44>
81128048:	0005883a 	mov	r2,zero
8112804c:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
81128050:	e0bffd17 	ldw	r2,-12(fp)
81128054:	10001026 	beq	r2,zero,81128098 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
81128058:	e0bffd17 	ldw	r2,-12(fp)
8112805c:	10800017 	ldw	r2,0(r2)
81128060:	10800817 	ldw	r2,32(r2)
81128064:	10000726 	beq	r2,zero,81128084 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
81128068:	e0bffd17 	ldw	r2,-12(fp)
8112806c:	10800017 	ldw	r2,0(r2)
81128070:	10800817 	ldw	r2,32(r2)
81128074:	e17fff17 	ldw	r5,-4(fp)
81128078:	e13ffd17 	ldw	r4,-12(fp)
8112807c:	103ee83a 	callr	r2
81128080:	00000a06 	br	811280ac <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
81128084:	e0bfff17 	ldw	r2,-4(fp)
81128088:	00c80004 	movi	r3,8192
8112808c:	10c00115 	stw	r3,4(r2)
      return 0;
81128090:	0005883a 	mov	r2,zero
81128094:	00000506 	br	811280ac <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81128098:	1127fc40 	call	81127fc4 <alt_get_errno>
8112809c:	1007883a 	mov	r3,r2
811280a0:	00801444 	movi	r2,81
811280a4:	18800015 	stw	r2,0(r3)
    return -1;
811280a8:	00bfffc4 	movi	r2,-1
  }
}
811280ac:	e037883a 	mov	sp,fp
811280b0:	dfc00117 	ldw	ra,4(sp)
811280b4:	df000017 	ldw	fp,0(sp)
811280b8:	dec00204 	addi	sp,sp,8
811280bc:	f800283a 	ret

811280c0 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
811280c0:	defff004 	addi	sp,sp,-64
811280c4:	de00012e 	bgeu	sp,et,811280cc <alt_irq_register+0xc>
811280c8:	003b68fa 	trap	3
811280cc:	df000f15 	stw	fp,60(sp)
811280d0:	df000f04 	addi	fp,sp,60
811280d4:	e13ffd15 	stw	r4,-12(fp)
811280d8:	e17ffe15 	stw	r5,-8(fp)
811280dc:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
811280e0:	00bffa84 	movi	r2,-22
811280e4:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
811280e8:	e0bffd17 	ldw	r2,-12(fp)
811280ec:	10800828 	cmpgeui	r2,r2,32
811280f0:	1000501e 	bne	r2,zero,81128234 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811280f4:	0005303a 	rdctl	r2,status
811280f8:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811280fc:	e0fff617 	ldw	r3,-40(fp)
81128100:	00bfff84 	movi	r2,-2
81128104:	1884703a 	and	r2,r3,r2
81128108:	1001703a 	wrctl	status,r2
  
  return context;
8112810c:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
81128110:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
81128114:	00a04574 	movhi	r2,33045
81128118:	10960c04 	addi	r2,r2,22576
8112811c:	e0fffd17 	ldw	r3,-12(fp)
81128120:	180690fa 	slli	r3,r3,3
81128124:	10c5883a 	add	r2,r2,r3
81128128:	e0ffff17 	ldw	r3,-4(fp)
8112812c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
81128130:	00a04574 	movhi	r2,33045
81128134:	10960c04 	addi	r2,r2,22576
81128138:	e0fffd17 	ldw	r3,-12(fp)
8112813c:	180690fa 	slli	r3,r3,3
81128140:	10c5883a 	add	r2,r2,r3
81128144:	10800104 	addi	r2,r2,4
81128148:	e0fffe17 	ldw	r3,-8(fp)
8112814c:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
81128150:	e0bfff17 	ldw	r2,-4(fp)
81128154:	10001926 	beq	r2,zero,811281bc <alt_irq_register+0xfc>
81128158:	e0bffd17 	ldw	r2,-12(fp)
8112815c:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81128160:	0005303a 	rdctl	r2,status
81128164:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81128168:	e0fff717 	ldw	r3,-36(fp)
8112816c:	00bfff84 	movi	r2,-2
81128170:	1884703a 	and	r2,r3,r2
81128174:	1001703a 	wrctl	status,r2
  
  return context;
81128178:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8112817c:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
81128180:	00c00044 	movi	r3,1
81128184:	e0bff217 	ldw	r2,-56(fp)
81128188:	1884983a 	sll	r2,r3,r2
8112818c:	1007883a 	mov	r3,r2
81128190:	d0a06817 	ldw	r2,-32352(gp)
81128194:	1884b03a 	or	r2,r3,r2
81128198:	d0a06815 	stw	r2,-32352(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8112819c:	d0a06817 	ldw	r2,-32352(gp)
811281a0:	100170fa 	wrctl	ienable,r2
811281a4:	e0bff817 	ldw	r2,-32(fp)
811281a8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811281ac:	e0bff917 	ldw	r2,-28(fp)
811281b0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811281b4:	0005883a 	mov	r2,zero
811281b8:	00001906 	br	81128220 <alt_irq_register+0x160>
811281bc:	e0bffd17 	ldw	r2,-12(fp)
811281c0:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811281c4:	0005303a 	rdctl	r2,status
811281c8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811281cc:	e0fffa17 	ldw	r3,-24(fp)
811281d0:	00bfff84 	movi	r2,-2
811281d4:	1884703a 	and	r2,r3,r2
811281d8:	1001703a 	wrctl	status,r2
  
  return context;
811281dc:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811281e0:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
811281e4:	00c00044 	movi	r3,1
811281e8:	e0bff417 	ldw	r2,-48(fp)
811281ec:	1884983a 	sll	r2,r3,r2
811281f0:	0084303a 	nor	r2,zero,r2
811281f4:	1007883a 	mov	r3,r2
811281f8:	d0a06817 	ldw	r2,-32352(gp)
811281fc:	1884703a 	and	r2,r3,r2
81128200:	d0a06815 	stw	r2,-32352(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81128204:	d0a06817 	ldw	r2,-32352(gp)
81128208:	100170fa 	wrctl	ienable,r2
8112820c:	e0bffb17 	ldw	r2,-20(fp)
81128210:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81128214:	e0bffc17 	ldw	r2,-16(fp)
81128218:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8112821c:	0005883a 	mov	r2,zero
81128220:	e0bff115 	stw	r2,-60(fp)
81128224:	e0bff317 	ldw	r2,-52(fp)
81128228:	e0bff515 	stw	r2,-44(fp)
8112822c:	e0bff517 	ldw	r2,-44(fp)
81128230:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
81128234:	e0bff117 	ldw	r2,-60(fp)
}
81128238:	e037883a 	mov	sp,fp
8112823c:	df000017 	ldw	fp,0(sp)
81128240:	dec00104 	addi	sp,sp,4
81128244:	f800283a 	ret

81128248 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81128248:	defffe04 	addi	sp,sp,-8
8112824c:	de00012e 	bgeu	sp,et,81128254 <alt_get_errno+0xc>
81128250:	003b68fa 	trap	3
81128254:	dfc00115 	stw	ra,4(sp)
81128258:	df000015 	stw	fp,0(sp)
8112825c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81128260:	d0a01017 	ldw	r2,-32704(gp)
81128264:	10000326 	beq	r2,zero,81128274 <alt_get_errno+0x2c>
81128268:	d0a01017 	ldw	r2,-32704(gp)
8112826c:	103ee83a 	callr	r2
81128270:	00000106 	br	81128278 <alt_get_errno+0x30>
81128274:	d0a06004 	addi	r2,gp,-32384
}
81128278:	e037883a 	mov	sp,fp
8112827c:	dfc00117 	ldw	ra,4(sp)
81128280:	df000017 	ldw	fp,0(sp)
81128284:	dec00204 	addi	sp,sp,8
81128288:	f800283a 	ret

8112828c <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
8112828c:	deffed04 	addi	sp,sp,-76
81128290:	de00012e 	bgeu	sp,et,81128298 <isatty+0xc>
81128294:	003b68fa 	trap	3
81128298:	dfc01215 	stw	ra,72(sp)
8112829c:	df001115 	stw	fp,68(sp)
811282a0:	df001104 	addi	fp,sp,68
811282a4:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811282a8:	e0bfff17 	ldw	r2,-4(fp)
811282ac:	10000616 	blt	r2,zero,811282c8 <isatty+0x3c>
811282b0:	e0bfff17 	ldw	r2,-4(fp)
811282b4:	10c00324 	muli	r3,r2,12
811282b8:	00a04534 	movhi	r2,33044
811282bc:	1081b904 	addi	r2,r2,1764
811282c0:	1885883a 	add	r2,r3,r2
811282c4:	00000106 	br	811282cc <isatty+0x40>
811282c8:	0005883a 	mov	r2,zero
811282cc:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
811282d0:	e0bfef17 	ldw	r2,-68(fp)
811282d4:	10000e26 	beq	r2,zero,81128310 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
811282d8:	e0bfef17 	ldw	r2,-68(fp)
811282dc:	10800017 	ldw	r2,0(r2)
811282e0:	10800817 	ldw	r2,32(r2)
811282e4:	1000021e 	bne	r2,zero,811282f0 <isatty+0x64>
    {
      return 1;
811282e8:	00800044 	movi	r2,1
811282ec:	00000d06 	br	81128324 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
811282f0:	e0bff004 	addi	r2,fp,-64
811282f4:	100b883a 	mov	r5,r2
811282f8:	e13fff17 	ldw	r4,-4(fp)
811282fc:	11280080 	call	81128008 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
81128300:	e0bff117 	ldw	r2,-60(fp)
81128304:	10880020 	cmpeqi	r2,r2,8192
81128308:	10803fcc 	andi	r2,r2,255
8112830c:	00000506 	br	81128324 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81128310:	11282480 	call	81128248 <alt_get_errno>
81128314:	1007883a 	mov	r3,r2
81128318:	00801444 	movi	r2,81
8112831c:	18800015 	stw	r2,0(r3)
    return 0;
81128320:	0005883a 	mov	r2,zero
  }
}
81128324:	e037883a 	mov	sp,fp
81128328:	dfc00117 	ldw	ra,4(sp)
8112832c:	df000017 	ldw	fp,0(sp)
81128330:	dec00204 	addi	sp,sp,8
81128334:	f800283a 	ret

81128338 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81128338:	defffe04 	addi	sp,sp,-8
8112833c:	de00012e 	bgeu	sp,et,81128344 <alt_get_errno+0xc>
81128340:	003b68fa 	trap	3
81128344:	dfc00115 	stw	ra,4(sp)
81128348:	df000015 	stw	fp,0(sp)
8112834c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81128350:	d0a01017 	ldw	r2,-32704(gp)
81128354:	10000326 	beq	r2,zero,81128364 <alt_get_errno+0x2c>
81128358:	d0a01017 	ldw	r2,-32704(gp)
8112835c:	103ee83a 	callr	r2
81128360:	00000106 	br	81128368 <alt_get_errno+0x30>
81128364:	d0a06004 	addi	r2,gp,-32384
}
81128368:	e037883a 	mov	sp,fp
8112836c:	dfc00117 	ldw	ra,4(sp)
81128370:	df000017 	ldw	fp,0(sp)
81128374:	dec00204 	addi	sp,sp,8
81128378:	f800283a 	ret

8112837c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
8112837c:	defff904 	addi	sp,sp,-28
81128380:	de00012e 	bgeu	sp,et,81128388 <lseek+0xc>
81128384:	003b68fa 	trap	3
81128388:	dfc00615 	stw	ra,24(sp)
8112838c:	df000515 	stw	fp,20(sp)
81128390:	df000504 	addi	fp,sp,20
81128394:	e13ffd15 	stw	r4,-12(fp)
81128398:	e17ffe15 	stw	r5,-8(fp)
8112839c:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
811283a0:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811283a4:	e0bffd17 	ldw	r2,-12(fp)
811283a8:	10000616 	blt	r2,zero,811283c4 <lseek+0x48>
811283ac:	e0bffd17 	ldw	r2,-12(fp)
811283b0:	10c00324 	muli	r3,r2,12
811283b4:	00a04534 	movhi	r2,33044
811283b8:	1081b904 	addi	r2,r2,1764
811283bc:	1885883a 	add	r2,r3,r2
811283c0:	00000106 	br	811283c8 <lseek+0x4c>
811283c4:	0005883a 	mov	r2,zero
811283c8:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
811283cc:	e0bffc17 	ldw	r2,-16(fp)
811283d0:	10001026 	beq	r2,zero,81128414 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
811283d4:	e0bffc17 	ldw	r2,-16(fp)
811283d8:	10800017 	ldw	r2,0(r2)
811283dc:	10800717 	ldw	r2,28(r2)
811283e0:	10000926 	beq	r2,zero,81128408 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
811283e4:	e0bffc17 	ldw	r2,-16(fp)
811283e8:	10800017 	ldw	r2,0(r2)
811283ec:	10800717 	ldw	r2,28(r2)
811283f0:	e1bfff17 	ldw	r6,-4(fp)
811283f4:	e17ffe17 	ldw	r5,-8(fp)
811283f8:	e13ffc17 	ldw	r4,-16(fp)
811283fc:	103ee83a 	callr	r2
81128400:	e0bffb15 	stw	r2,-20(fp)
81128404:	00000506 	br	8112841c <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
81128408:	00bfde84 	movi	r2,-134
8112840c:	e0bffb15 	stw	r2,-20(fp)
81128410:	00000206 	br	8112841c <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81128414:	00bfebc4 	movi	r2,-81
81128418:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
8112841c:	e0bffb17 	ldw	r2,-20(fp)
81128420:	1000070e 	bge	r2,zero,81128440 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
81128424:	11283380 	call	81128338 <alt_get_errno>
81128428:	1007883a 	mov	r3,r2
8112842c:	e0bffb17 	ldw	r2,-20(fp)
81128430:	0085c83a 	sub	r2,zero,r2
81128434:	18800015 	stw	r2,0(r3)
    rc = -1;
81128438:	00bfffc4 	movi	r2,-1
8112843c:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
81128440:	e0bffb17 	ldw	r2,-20(fp)
}
81128444:	e037883a 	mov	sp,fp
81128448:	dfc00117 	ldw	ra,4(sp)
8112844c:	df000017 	ldw	fp,0(sp)
81128450:	dec00204 	addi	sp,sp,8
81128454:	f800283a 	ret

81128458 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
81128458:	defff904 	addi	sp,sp,-28
8112845c:	de00012e 	bgeu	sp,et,81128464 <alt_main+0xc>
81128460:	003b68fa 	trap	3
81128464:	dfc00615 	stw	ra,24(sp)
81128468:	df000515 	stw	fp,20(sp)
8112846c:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
81128470:	0009883a 	mov	r4,zero
81128474:	1132f900 	call	81132f90 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
81128478:	1129a240 	call	81129a24 <OSInit>
8112847c:	01000044 	movi	r4,1
81128480:	112f7400 	call	8112f740 <OSSemCreate>
81128484:	d0a06f15 	stw	r2,-32324(gp)
81128488:	01000044 	movi	r4,1
8112848c:	112f7400 	call	8112f740 <OSSemCreate>
81128490:	d0a07115 	stw	r2,-32316(gp)
81128494:	d0a06704 	addi	r2,gp,-32356
81128498:	e0bffc15 	stw	r2,-16(fp)
8112849c:	00800044 	movi	r2,1
811284a0:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811284a4:	e0bffd0b 	ldhu	r2,-12(fp)
811284a8:	1009883a 	mov	r4,r2
811284ac:	112f7400 	call	8112f740 <OSSemCreate>
811284b0:	1007883a 	mov	r3,r2
811284b4:	e0bffc17 	ldw	r2,-16(fp)
811284b8:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
811284bc:	1132fd00 	call	81132fd0 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
811284c0:	01a04534 	movhi	r6,33044
811284c4:	31be8604 	addi	r6,r6,-1512
811284c8:	01604534 	movhi	r5,33044
811284cc:	297e8b04 	addi	r5,r5,-1492
811284d0:	01204534 	movhi	r4,33044
811284d4:	213e8b04 	addi	r4,r4,-1492
811284d8:	113b8fc0 	call	8113b8fc <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
811284dc:	113b20c0 	call	8113b20c <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
811284e0:	01204534 	movhi	r4,33044
811284e4:	212c9d04 	addi	r4,r4,-19852
811284e8:	113c0b00 	call	8113c0b0 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
811284ec:	d0a06917 	ldw	r2,-32348(gp)
811284f0:	d0e06a17 	ldw	r3,-32344(gp)
811284f4:	d1206b17 	ldw	r4,-32340(gp)
811284f8:	200d883a 	mov	r6,r4
811284fc:	180b883a 	mov	r5,r3
81128500:	1009883a 	mov	r4,r2
81128504:	110c8780 	call	8110c878 <main>
81128508:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
8112850c:	01000044 	movi	r4,1
81128510:	1127e900 	call	81127e90 <close>
  exit (result);
81128514:	e13ffb17 	ldw	r4,-20(fp)
81128518:	113c0c40 	call	8113c0c4 <exit>

8112851c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112851c:	defffe04 	addi	sp,sp,-8
81128520:	de00012e 	bgeu	sp,et,81128528 <alt_get_errno+0xc>
81128524:	003b68fa 	trap	3
81128528:	dfc00115 	stw	ra,4(sp)
8112852c:	df000015 	stw	fp,0(sp)
81128530:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81128534:	d0a01017 	ldw	r2,-32704(gp)
81128538:	10000326 	beq	r2,zero,81128548 <alt_get_errno+0x2c>
8112853c:	d0a01017 	ldw	r2,-32704(gp)
81128540:	103ee83a 	callr	r2
81128544:	00000106 	br	8112854c <alt_get_errno+0x30>
81128548:	d0a06004 	addi	r2,gp,-32384
}
8112854c:	e037883a 	mov	sp,fp
81128550:	dfc00117 	ldw	ra,4(sp)
81128554:	df000017 	ldw	fp,0(sp)
81128558:	dec00204 	addi	sp,sp,8
8112855c:	f800283a 	ret

81128560 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
81128560:	defffd04 	addi	sp,sp,-12
81128564:	de00012e 	bgeu	sp,et,8112856c <alt_file_locked+0xc>
81128568:	003b68fa 	trap	3
8112856c:	df000215 	stw	fp,8(sp)
81128570:	df000204 	addi	fp,sp,8
81128574:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
81128578:	e0bfff17 	ldw	r2,-4(fp)
8112857c:	10800217 	ldw	r2,8(r2)
81128580:	10d00034 	orhi	r3,r2,16384
81128584:	e0bfff17 	ldw	r2,-4(fp)
81128588:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
8112858c:	e03ffe15 	stw	zero,-8(fp)
81128590:	00001d06 	br	81128608 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81128594:	00a04534 	movhi	r2,33044
81128598:	1081b904 	addi	r2,r2,1764
8112859c:	e0fffe17 	ldw	r3,-8(fp)
811285a0:	18c00324 	muli	r3,r3,12
811285a4:	10c5883a 	add	r2,r2,r3
811285a8:	10c00017 	ldw	r3,0(r2)
811285ac:	e0bfff17 	ldw	r2,-4(fp)
811285b0:	10800017 	ldw	r2,0(r2)
811285b4:	1880111e 	bne	r3,r2,811285fc <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811285b8:	00a04534 	movhi	r2,33044
811285bc:	1081b904 	addi	r2,r2,1764
811285c0:	e0fffe17 	ldw	r3,-8(fp)
811285c4:	18c00324 	muli	r3,r3,12
811285c8:	10c5883a 	add	r2,r2,r3
811285cc:	10800204 	addi	r2,r2,8
811285d0:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811285d4:	1000090e 	bge	r2,zero,811285fc <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
811285d8:	e0bffe17 	ldw	r2,-8(fp)
811285dc:	10c00324 	muli	r3,r2,12
811285e0:	00a04534 	movhi	r2,33044
811285e4:	1081b904 	addi	r2,r2,1764
811285e8:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811285ec:	e0bfff17 	ldw	r2,-4(fp)
811285f0:	18800226 	beq	r3,r2,811285fc <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
811285f4:	00bffcc4 	movi	r2,-13
811285f8:	00000806 	br	8112861c <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811285fc:	e0bffe17 	ldw	r2,-8(fp)
81128600:	10800044 	addi	r2,r2,1
81128604:	e0bffe15 	stw	r2,-8(fp)
81128608:	d0a00f17 	ldw	r2,-32708(gp)
8112860c:	1007883a 	mov	r3,r2
81128610:	e0bffe17 	ldw	r2,-8(fp)
81128614:	18bfdf2e 	bgeu	r3,r2,81128594 <__reset+0xfb108594>
    }
  }
  
  /* The device is not locked */
 
  return 0;
81128618:	0005883a 	mov	r2,zero
}
8112861c:	e037883a 	mov	sp,fp
81128620:	df000017 	ldw	fp,0(sp)
81128624:	dec00104 	addi	sp,sp,4
81128628:	f800283a 	ret

8112862c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
8112862c:	defff604 	addi	sp,sp,-40
81128630:	de00012e 	bgeu	sp,et,81128638 <open+0xc>
81128634:	003b68fa 	trap	3
81128638:	dfc00915 	stw	ra,36(sp)
8112863c:	df000815 	stw	fp,32(sp)
81128640:	df000804 	addi	fp,sp,32
81128644:	e13ffd15 	stw	r4,-12(fp)
81128648:	e17ffe15 	stw	r5,-8(fp)
8112864c:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81128650:	00bfffc4 	movi	r2,-1
81128654:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
81128658:	00bffb44 	movi	r2,-19
8112865c:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
81128660:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
81128664:	d1600d04 	addi	r5,gp,-32716
81128668:	e13ffd17 	ldw	r4,-12(fp)
8112866c:	113b2dc0 	call	8113b2dc <alt_find_dev>
81128670:	e0bff815 	stw	r2,-32(fp)
81128674:	e0bff817 	ldw	r2,-32(fp)
81128678:	1000051e 	bne	r2,zero,81128690 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
8112867c:	e13ffd17 	ldw	r4,-12(fp)
81128680:	113b3740 	call	8113b374 <alt_find_file>
81128684:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
81128688:	00800044 	movi	r2,1
8112868c:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
81128690:	e0bff817 	ldw	r2,-32(fp)
81128694:	10002926 	beq	r2,zero,8112873c <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
81128698:	e13ff817 	ldw	r4,-32(fp)
8112869c:	113b4840 	call	8113b484 <alt_get_fd>
811286a0:	e0bff915 	stw	r2,-28(fp)
811286a4:	e0bff917 	ldw	r2,-28(fp)
811286a8:	1000030e 	bge	r2,zero,811286b8 <open+0x8c>
    {
      status = index;
811286ac:	e0bff917 	ldw	r2,-28(fp)
811286b0:	e0bffa15 	stw	r2,-24(fp)
811286b4:	00002306 	br	81128744 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
811286b8:	e0bff917 	ldw	r2,-28(fp)
811286bc:	10c00324 	muli	r3,r2,12
811286c0:	00a04534 	movhi	r2,33044
811286c4:	1081b904 	addi	r2,r2,1764
811286c8:	1885883a 	add	r2,r3,r2
811286cc:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
811286d0:	e0fffe17 	ldw	r3,-8(fp)
811286d4:	00900034 	movhi	r2,16384
811286d8:	10bfffc4 	addi	r2,r2,-1
811286dc:	1886703a 	and	r3,r3,r2
811286e0:	e0bffc17 	ldw	r2,-16(fp)
811286e4:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
811286e8:	e0bffb17 	ldw	r2,-20(fp)
811286ec:	1000051e 	bne	r2,zero,81128704 <open+0xd8>
811286f0:	e13ffc17 	ldw	r4,-16(fp)
811286f4:	11285600 	call	81128560 <alt_file_locked>
811286f8:	e0bffa15 	stw	r2,-24(fp)
811286fc:	e0bffa17 	ldw	r2,-24(fp)
81128700:	10001016 	blt	r2,zero,81128744 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81128704:	e0bff817 	ldw	r2,-32(fp)
81128708:	10800317 	ldw	r2,12(r2)
8112870c:	10000826 	beq	r2,zero,81128730 <open+0x104>
81128710:	e0bff817 	ldw	r2,-32(fp)
81128714:	10800317 	ldw	r2,12(r2)
81128718:	e1ffff17 	ldw	r7,-4(fp)
8112871c:	e1bffe17 	ldw	r6,-8(fp)
81128720:	e17ffd17 	ldw	r5,-12(fp)
81128724:	e13ffc17 	ldw	r4,-16(fp)
81128728:	103ee83a 	callr	r2
8112872c:	00000106 	br	81128734 <open+0x108>
81128730:	0005883a 	mov	r2,zero
81128734:	e0bffa15 	stw	r2,-24(fp)
81128738:	00000206 	br	81128744 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
8112873c:	00bffb44 	movi	r2,-19
81128740:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81128744:	e0bffa17 	ldw	r2,-24(fp)
81128748:	1000090e 	bge	r2,zero,81128770 <open+0x144>
  {
    alt_release_fd (index);  
8112874c:	e13ff917 	ldw	r4,-28(fp)
81128750:	11288d00 	call	811288d0 <alt_release_fd>
    ALT_ERRNO = -status;
81128754:	112851c0 	call	8112851c <alt_get_errno>
81128758:	1007883a 	mov	r3,r2
8112875c:	e0bffa17 	ldw	r2,-24(fp)
81128760:	0085c83a 	sub	r2,zero,r2
81128764:	18800015 	stw	r2,0(r3)
    return -1;
81128768:	00bfffc4 	movi	r2,-1
8112876c:	00000106 	br	81128774 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
81128770:	e0bff917 	ldw	r2,-28(fp)
}
81128774:	e037883a 	mov	sp,fp
81128778:	dfc00117 	ldw	ra,4(sp)
8112877c:	df000017 	ldw	fp,0(sp)
81128780:	dec00204 	addi	sp,sp,8
81128784:	f800283a 	ret

81128788 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81128788:	defffe04 	addi	sp,sp,-8
8112878c:	de00012e 	bgeu	sp,et,81128794 <alt_get_errno+0xc>
81128790:	003b68fa 	trap	3
81128794:	dfc00115 	stw	ra,4(sp)
81128798:	df000015 	stw	fp,0(sp)
8112879c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811287a0:	d0a01017 	ldw	r2,-32704(gp)
811287a4:	10000326 	beq	r2,zero,811287b4 <alt_get_errno+0x2c>
811287a8:	d0a01017 	ldw	r2,-32704(gp)
811287ac:	103ee83a 	callr	r2
811287b0:	00000106 	br	811287b8 <alt_get_errno+0x30>
811287b4:	d0a06004 	addi	r2,gp,-32384
}
811287b8:	e037883a 	mov	sp,fp
811287bc:	dfc00117 	ldw	ra,4(sp)
811287c0:	df000017 	ldw	fp,0(sp)
811287c4:	dec00204 	addi	sp,sp,8
811287c8:	f800283a 	ret

811287cc <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
811287cc:	defff904 	addi	sp,sp,-28
811287d0:	de00012e 	bgeu	sp,et,811287d8 <read+0xc>
811287d4:	003b68fa 	trap	3
811287d8:	dfc00615 	stw	ra,24(sp)
811287dc:	df000515 	stw	fp,20(sp)
811287e0:	df000504 	addi	fp,sp,20
811287e4:	e13ffd15 	stw	r4,-12(fp)
811287e8:	e17ffe15 	stw	r5,-8(fp)
811287ec:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811287f0:	e0bffd17 	ldw	r2,-12(fp)
811287f4:	10000616 	blt	r2,zero,81128810 <read+0x44>
811287f8:	e0bffd17 	ldw	r2,-12(fp)
811287fc:	10c00324 	muli	r3,r2,12
81128800:	00a04534 	movhi	r2,33044
81128804:	1081b904 	addi	r2,r2,1764
81128808:	1885883a 	add	r2,r3,r2
8112880c:	00000106 	br	81128814 <read+0x48>
81128810:	0005883a 	mov	r2,zero
81128814:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81128818:	e0bffb17 	ldw	r2,-20(fp)
8112881c:	10002226 	beq	r2,zero,811288a8 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81128820:	e0bffb17 	ldw	r2,-20(fp)
81128824:	10800217 	ldw	r2,8(r2)
81128828:	108000cc 	andi	r2,r2,3
8112882c:	10800060 	cmpeqi	r2,r2,1
81128830:	1000181e 	bne	r2,zero,81128894 <read+0xc8>
        (fd->dev->read))
81128834:	e0bffb17 	ldw	r2,-20(fp)
81128838:	10800017 	ldw	r2,0(r2)
8112883c:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81128840:	10001426 	beq	r2,zero,81128894 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
81128844:	e0bffb17 	ldw	r2,-20(fp)
81128848:	10800017 	ldw	r2,0(r2)
8112884c:	10800517 	ldw	r2,20(r2)
81128850:	e0ffff17 	ldw	r3,-4(fp)
81128854:	180d883a 	mov	r6,r3
81128858:	e17ffe17 	ldw	r5,-8(fp)
8112885c:	e13ffb17 	ldw	r4,-20(fp)
81128860:	103ee83a 	callr	r2
81128864:	e0bffc15 	stw	r2,-16(fp)
81128868:	e0bffc17 	ldw	r2,-16(fp)
8112886c:	1000070e 	bge	r2,zero,8112888c <read+0xc0>
        {
          ALT_ERRNO = -rval;
81128870:	11287880 	call	81128788 <alt_get_errno>
81128874:	1007883a 	mov	r3,r2
81128878:	e0bffc17 	ldw	r2,-16(fp)
8112887c:	0085c83a 	sub	r2,zero,r2
81128880:	18800015 	stw	r2,0(r3)
          return -1;
81128884:	00bfffc4 	movi	r2,-1
81128888:	00000c06 	br	811288bc <read+0xf0>
        }
        return rval;
8112888c:	e0bffc17 	ldw	r2,-16(fp)
81128890:	00000a06 	br	811288bc <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81128894:	11287880 	call	81128788 <alt_get_errno>
81128898:	1007883a 	mov	r3,r2
8112889c:	00800344 	movi	r2,13
811288a0:	18800015 	stw	r2,0(r3)
811288a4:	00000406 	br	811288b8 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
811288a8:	11287880 	call	81128788 <alt_get_errno>
811288ac:	1007883a 	mov	r3,r2
811288b0:	00801444 	movi	r2,81
811288b4:	18800015 	stw	r2,0(r3)
  }
  return -1;
811288b8:	00bfffc4 	movi	r2,-1
}
811288bc:	e037883a 	mov	sp,fp
811288c0:	dfc00117 	ldw	ra,4(sp)
811288c4:	df000017 	ldw	fp,0(sp)
811288c8:	dec00204 	addi	sp,sp,8
811288cc:	f800283a 	ret

811288d0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
811288d0:	defffe04 	addi	sp,sp,-8
811288d4:	de00012e 	bgeu	sp,et,811288dc <alt_release_fd+0xc>
811288d8:	003b68fa 	trap	3
811288dc:	df000115 	stw	fp,4(sp)
811288e0:	df000104 	addi	fp,sp,4
811288e4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
811288e8:	e0bfff17 	ldw	r2,-4(fp)
811288ec:	108000d0 	cmplti	r2,r2,3
811288f0:	10000d1e 	bne	r2,zero,81128928 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
811288f4:	00a04534 	movhi	r2,33044
811288f8:	1081b904 	addi	r2,r2,1764
811288fc:	e0ffff17 	ldw	r3,-4(fp)
81128900:	18c00324 	muli	r3,r3,12
81128904:	10c5883a 	add	r2,r2,r3
81128908:	10800204 	addi	r2,r2,8
8112890c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81128910:	00a04534 	movhi	r2,33044
81128914:	1081b904 	addi	r2,r2,1764
81128918:	e0ffff17 	ldw	r3,-4(fp)
8112891c:	18c00324 	muli	r3,r3,12
81128920:	10c5883a 	add	r2,r2,r3
81128924:	10000015 	stw	zero,0(r2)
  }
}
81128928:	0001883a 	nop
8112892c:	e037883a 	mov	sp,fp
81128930:	df000017 	ldw	fp,0(sp)
81128934:	dec00104 	addi	sp,sp,4
81128938:	f800283a 	ret

8112893c <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
8112893c:	defff604 	addi	sp,sp,-40
81128940:	de00012e 	bgeu	sp,et,81128948 <sbrk+0xc>
81128944:	003b68fa 	trap	3
81128948:	df000915 	stw	fp,36(sp)
8112894c:	df000904 	addi	fp,sp,36
81128950:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81128954:	0005303a 	rdctl	r2,status
81128958:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112895c:	e0fffe17 	ldw	r3,-8(fp)
81128960:	00bfff84 	movi	r2,-2
81128964:	1884703a 	and	r2,r3,r2
81128968:	1001703a 	wrctl	status,r2
  
  return context;
8112896c:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81128970:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81128974:	d0a01217 	ldw	r2,-32696(gp)
81128978:	10c000c4 	addi	r3,r2,3
8112897c:	00bfff04 	movi	r2,-4
81128980:	1884703a 	and	r2,r3,r2
81128984:	d0a01215 	stw	r2,-32696(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81128988:	d0e01217 	ldw	r3,-32696(gp)
8112898c:	e0bfff17 	ldw	r2,-4(fp)
81128990:	1887883a 	add	r3,r3,r2
81128994:	00a04834 	movhi	r2,33056
81128998:	10a80004 	addi	r2,r2,-24576
8112899c:	10c0062e 	bgeu	r2,r3,811289b8 <sbrk+0x7c>
811289a0:	e0bff817 	ldw	r2,-32(fp)
811289a4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811289a8:	e0bff717 	ldw	r2,-36(fp)
811289ac:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
811289b0:	00bfffc4 	movi	r2,-1
811289b4:	00001c06 	br	81128a28 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
811289b8:	d0a01217 	ldw	r2,-32696(gp)
811289bc:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
811289c0:	d0e01217 	ldw	r3,-32696(gp)
811289c4:	e0bfff17 	ldw	r2,-4(fp)
811289c8:	1885883a 	add	r2,r3,r2
811289cc:	d0a01215 	stw	r2,-32696(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
811289d0:	c005883a 	mov	r2,et
811289d4:	e0bff915 	stw	r2,-28(fp)

  return limit; 
811289d8:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
811289dc:	e0bffa17 	ldw	r2,-24(fp)
811289e0:	18800c1e 	bne	r3,r2,81128a14 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
811289e4:	d805883a 	mov	r2,sp
811289e8:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
811289ec:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
811289f0:	d0e01217 	ldw	r3,-32696(gp)
811289f4:	18800136 	bltu	r3,r2,811289fc <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
811289f8:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
811289fc:	d0a01217 	ldw	r2,-32696(gp)
81128a00:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81128a04:	e0bffc17 	ldw	r2,-16(fp)
81128a08:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81128a0c:	e0bffc17 	ldw	r2,-16(fp)
81128a10:	1031883a 	mov	et,r2
81128a14:	e0bff817 	ldw	r2,-32(fp)
81128a18:	e0bffd15 	stw	r2,-12(fp)
81128a1c:	e0bffd17 	ldw	r2,-12(fp)
81128a20:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81128a24:	e0bffa17 	ldw	r2,-24(fp)
} 
81128a28:	e037883a 	mov	sp,fp
81128a2c:	df000017 	ldw	fp,0(sp)
81128a30:	dec00104 	addi	sp,sp,4
81128a34:	f800283a 	ret

81128a38 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81128a38:	defffa04 	addi	sp,sp,-24
81128a3c:	de00012e 	bgeu	sp,et,81128a44 <alt_alarm_stop+0xc>
81128a40:	003b68fa 	trap	3
81128a44:	df000515 	stw	fp,20(sp)
81128a48:	df000504 	addi	fp,sp,20
81128a4c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81128a50:	0005303a 	rdctl	r2,status
81128a54:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81128a58:	e0fffc17 	ldw	r3,-16(fp)
81128a5c:	00bfff84 	movi	r2,-2
81128a60:	1884703a 	and	r2,r3,r2
81128a64:	1001703a 	wrctl	status,r2
  
  return context;
81128a68:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81128a6c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81128a70:	e0bfff17 	ldw	r2,-4(fp)
81128a74:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81128a78:	e0bffd17 	ldw	r2,-12(fp)
81128a7c:	10800017 	ldw	r2,0(r2)
81128a80:	e0fffd17 	ldw	r3,-12(fp)
81128a84:	18c00117 	ldw	r3,4(r3)
81128a88:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81128a8c:	e0bffd17 	ldw	r2,-12(fp)
81128a90:	10800117 	ldw	r2,4(r2)
81128a94:	e0fffd17 	ldw	r3,-12(fp)
81128a98:	18c00017 	ldw	r3,0(r3)
81128a9c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81128aa0:	e0bffd17 	ldw	r2,-12(fp)
81128aa4:	e0fffd17 	ldw	r3,-12(fp)
81128aa8:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81128aac:	e0bffd17 	ldw	r2,-12(fp)
81128ab0:	e0fffd17 	ldw	r3,-12(fp)
81128ab4:	10c00015 	stw	r3,0(r2)
81128ab8:	e0bffb17 	ldw	r2,-20(fp)
81128abc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81128ac0:	e0bffe17 	ldw	r2,-8(fp)
81128ac4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81128ac8:	0001883a 	nop
81128acc:	e037883a 	mov	sp,fp
81128ad0:	df000017 	ldw	fp,0(sp)
81128ad4:	dec00104 	addi	sp,sp,4
81128ad8:	f800283a 	ret

81128adc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81128adc:	defffb04 	addi	sp,sp,-20
81128ae0:	de00012e 	bgeu	sp,et,81128ae8 <alt_tick+0xc>
81128ae4:	003b68fa 	trap	3
81128ae8:	dfc00415 	stw	ra,16(sp)
81128aec:	df000315 	stw	fp,12(sp)
81128af0:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81128af4:	d0a01317 	ldw	r2,-32692(gp)
81128af8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81128afc:	d0a06d17 	ldw	r2,-32332(gp)
81128b00:	10800044 	addi	r2,r2,1
81128b04:	d0a06d15 	stw	r2,-32332(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81128b08:	00002e06 	br	81128bc4 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81128b0c:	e0bffd17 	ldw	r2,-12(fp)
81128b10:	10800017 	ldw	r2,0(r2)
81128b14:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81128b18:	e0bffd17 	ldw	r2,-12(fp)
81128b1c:	10800403 	ldbu	r2,16(r2)
81128b20:	10803fcc 	andi	r2,r2,255
81128b24:	10000426 	beq	r2,zero,81128b38 <alt_tick+0x5c>
81128b28:	d0a06d17 	ldw	r2,-32332(gp)
81128b2c:	1000021e 	bne	r2,zero,81128b38 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81128b30:	e0bffd17 	ldw	r2,-12(fp)
81128b34:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81128b38:	e0bffd17 	ldw	r2,-12(fp)
81128b3c:	10800217 	ldw	r2,8(r2)
81128b40:	d0e06d17 	ldw	r3,-32332(gp)
81128b44:	18801d36 	bltu	r3,r2,81128bbc <alt_tick+0xe0>
81128b48:	e0bffd17 	ldw	r2,-12(fp)
81128b4c:	10800403 	ldbu	r2,16(r2)
81128b50:	10803fcc 	andi	r2,r2,255
81128b54:	1000191e 	bne	r2,zero,81128bbc <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81128b58:	e0bffd17 	ldw	r2,-12(fp)
81128b5c:	10800317 	ldw	r2,12(r2)
81128b60:	e0fffd17 	ldw	r3,-12(fp)
81128b64:	18c00517 	ldw	r3,20(r3)
81128b68:	1809883a 	mov	r4,r3
81128b6c:	103ee83a 	callr	r2
81128b70:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81128b74:	e0bfff17 	ldw	r2,-4(fp)
81128b78:	1000031e 	bne	r2,zero,81128b88 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81128b7c:	e13ffd17 	ldw	r4,-12(fp)
81128b80:	1128a380 	call	81128a38 <alt_alarm_stop>
81128b84:	00000d06 	br	81128bbc <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81128b88:	e0bffd17 	ldw	r2,-12(fp)
81128b8c:	10c00217 	ldw	r3,8(r2)
81128b90:	e0bfff17 	ldw	r2,-4(fp)
81128b94:	1887883a 	add	r3,r3,r2
81128b98:	e0bffd17 	ldw	r2,-12(fp)
81128b9c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81128ba0:	e0bffd17 	ldw	r2,-12(fp)
81128ba4:	10c00217 	ldw	r3,8(r2)
81128ba8:	d0a06d17 	ldw	r2,-32332(gp)
81128bac:	1880032e 	bgeu	r3,r2,81128bbc <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81128bb0:	e0bffd17 	ldw	r2,-12(fp)
81128bb4:	00c00044 	movi	r3,1
81128bb8:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81128bbc:	e0bffe17 	ldw	r2,-8(fp)
81128bc0:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81128bc4:	e0fffd17 	ldw	r3,-12(fp)
81128bc8:	d0a01304 	addi	r2,gp,-32692
81128bcc:	18bfcf1e 	bne	r3,r2,81128b0c <__reset+0xfb108b0c>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81128bd0:	1129e840 	call	81129e84 <OSTimeTick>
}
81128bd4:	0001883a 	nop
81128bd8:	e037883a 	mov	sp,fp
81128bdc:	dfc00117 	ldw	ra,4(sp)
81128be0:	df000017 	ldw	fp,0(sp)
81128be4:	dec00204 	addi	sp,sp,8
81128be8:	f800283a 	ret

81128bec <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81128bec:	defffb04 	addi	sp,sp,-20
81128bf0:	de00012e 	bgeu	sp,et,81128bf8 <usleep+0xc>
81128bf4:	003b68fa 	trap	3
81128bf8:	dfc00415 	stw	ra,16(sp)
81128bfc:	df000315 	stw	fp,12(sp)
81128c00:	df000304 	addi	fp,sp,12
81128c04:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81128c08:	d0a07503 	ldbu	r2,-32300(gp)
81128c0c:	10803fcc 	andi	r2,r2,255
81128c10:	1000031e 	bne	r2,zero,81128c20 <usleep+0x34>
  {
    return alt_busy_sleep (us);
81128c14:	e13fff17 	ldw	r4,-4(fp)
81128c18:	1127d1c0 	call	81127d1c <alt_busy_sleep>
81128c1c:	00003d06 	br	81128d14 <usleep+0x128>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81128c20:	d0a06c17 	ldw	r2,-32336(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81128c24:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81128c28:	e0ffff17 	ldw	r3,-4(fp)
81128c2c:	0090c734 	movhi	r2,17180
81128c30:	10b7a0c4 	addi	r2,r2,-8573
81128c34:	1888383a 	mulxuu	r4,r3,r2
81128c38:	1885383a 	mul	r2,r3,r2
81128c3c:	1013883a 	mov	r9,r2
81128c40:	2015883a 	mov	r10,r4
81128c44:	5006d4ba 	srli	r3,r10,18
81128c48:	e0bffe17 	ldw	r2,-8(fp)
81128c4c:	1893383a 	mul	r9,r3,r2
81128c50:	e0ffff17 	ldw	r3,-4(fp)
81128c54:	0090c734 	movhi	r2,17180
81128c58:	10b7a0c4 	addi	r2,r2,-8573
81128c5c:	1888383a 	mulxuu	r4,r3,r2
81128c60:	1885383a 	mul	r2,r3,r2
81128c64:	100f883a 	mov	r7,r2
81128c68:	2011883a 	mov	r8,r4
81128c6c:	4004d4ba 	srli	r2,r8,18
81128c70:	010003f4 	movhi	r4,15
81128c74:	21109004 	addi	r4,r4,16960
81128c78:	1105383a 	mul	r2,r2,r4
81128c7c:	1885c83a 	sub	r2,r3,r2
81128c80:	e0fffe17 	ldw	r3,-8(fp)
81128c84:	10c7383a 	mul	r3,r2,r3
81128c88:	0090c734 	movhi	r2,17180
81128c8c:	10b7a0c4 	addi	r2,r2,-8573
81128c90:	1888383a 	mulxuu	r4,r3,r2
81128c94:	1885383a 	mul	r2,r3,r2
81128c98:	100b883a 	mov	r5,r2
81128c9c:	200d883a 	mov	r6,r4
81128ca0:	3004d4ba 	srli	r2,r6,18
81128ca4:	4885883a 	add	r2,r9,r2
81128ca8:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81128cac:	00000706 	br	81128ccc <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81128cb0:	013fffd4 	movui	r4,65535
81128cb4:	11318f40 	call	811318f4 <OSTimeDly>
    ticks -= 0xffff;
81128cb8:	e0fffd17 	ldw	r3,-12(fp)
81128cbc:	00bffff4 	movhi	r2,65535
81128cc0:	10800044 	addi	r2,r2,1
81128cc4:	1885883a 	add	r2,r3,r2
81128cc8:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81128ccc:	e0bffd17 	ldw	r2,-12(fp)
81128cd0:	00ffffd4 	movui	r3,65535
81128cd4:	18bff636 	bltu	r3,r2,81128cb0 <__reset+0xfb108cb0>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81128cd8:	e0bffd17 	ldw	r2,-12(fp)
81128cdc:	10bfffcc 	andi	r2,r2,65535
81128ce0:	1009883a 	mov	r4,r2
81128ce4:	11318f40 	call	811318f4 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81128ce8:	008003f4 	movhi	r2,15
81128cec:	10909004 	addi	r2,r2,16960
81128cf0:	e0fffe17 	ldw	r3,-8(fp)
81128cf4:	10c7203a 	divu	r3,r2,r3
81128cf8:	e0bfff17 	ldw	r2,-4(fp)
81128cfc:	10c9203a 	divu	r4,r2,r3
81128d00:	20c7383a 	mul	r3,r4,r3
81128d04:	10c5c83a 	sub	r2,r2,r3
81128d08:	1009883a 	mov	r4,r2
81128d0c:	1127d1c0 	call	81127d1c <alt_busy_sleep>

  return 0;  
81128d10:	0005883a 	mov	r2,zero
}
81128d14:	e037883a 	mov	sp,fp
81128d18:	dfc00117 	ldw	ra,4(sp)
81128d1c:	df000017 	ldw	fp,0(sp)
81128d20:	dec00204 	addi	sp,sp,8
81128d24:	f800283a 	ret

81128d28 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81128d28:	defffe04 	addi	sp,sp,-8
81128d2c:	de00012e 	bgeu	sp,et,81128d34 <alt_get_errno+0xc>
81128d30:	003b68fa 	trap	3
81128d34:	dfc00115 	stw	ra,4(sp)
81128d38:	df000015 	stw	fp,0(sp)
81128d3c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81128d40:	d0a01017 	ldw	r2,-32704(gp)
81128d44:	10000326 	beq	r2,zero,81128d54 <alt_get_errno+0x2c>
81128d48:	d0a01017 	ldw	r2,-32704(gp)
81128d4c:	103ee83a 	callr	r2
81128d50:	00000106 	br	81128d58 <alt_get_errno+0x30>
81128d54:	d0a06004 	addi	r2,gp,-32384
}
81128d58:	e037883a 	mov	sp,fp
81128d5c:	dfc00117 	ldw	ra,4(sp)
81128d60:	df000017 	ldw	fp,0(sp)
81128d64:	dec00204 	addi	sp,sp,8
81128d68:	f800283a 	ret

81128d6c <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81128d6c:	defff904 	addi	sp,sp,-28
81128d70:	de00012e 	bgeu	sp,et,81128d78 <write+0xc>
81128d74:	003b68fa 	trap	3
81128d78:	dfc00615 	stw	ra,24(sp)
81128d7c:	df000515 	stw	fp,20(sp)
81128d80:	df000504 	addi	fp,sp,20
81128d84:	e13ffd15 	stw	r4,-12(fp)
81128d88:	e17ffe15 	stw	r5,-8(fp)
81128d8c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81128d90:	e0bffd17 	ldw	r2,-12(fp)
81128d94:	10000616 	blt	r2,zero,81128db0 <write+0x44>
81128d98:	e0bffd17 	ldw	r2,-12(fp)
81128d9c:	10c00324 	muli	r3,r2,12
81128da0:	00a04534 	movhi	r2,33044
81128da4:	1081b904 	addi	r2,r2,1764
81128da8:	1885883a 	add	r2,r3,r2
81128dac:	00000106 	br	81128db4 <write+0x48>
81128db0:	0005883a 	mov	r2,zero
81128db4:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81128db8:	e0bffb17 	ldw	r2,-20(fp)
81128dbc:	10002126 	beq	r2,zero,81128e44 <write+0xd8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81128dc0:	e0bffb17 	ldw	r2,-20(fp)
81128dc4:	10800217 	ldw	r2,8(r2)
81128dc8:	108000cc 	andi	r2,r2,3
81128dcc:	10001826 	beq	r2,zero,81128e30 <write+0xc4>
81128dd0:	e0bffb17 	ldw	r2,-20(fp)
81128dd4:	10800017 	ldw	r2,0(r2)
81128dd8:	10800617 	ldw	r2,24(r2)
81128ddc:	10001426 	beq	r2,zero,81128e30 <write+0xc4>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81128de0:	e0bffb17 	ldw	r2,-20(fp)
81128de4:	10800017 	ldw	r2,0(r2)
81128de8:	10800617 	ldw	r2,24(r2)
81128dec:	e0ffff17 	ldw	r3,-4(fp)
81128df0:	180d883a 	mov	r6,r3
81128df4:	e17ffe17 	ldw	r5,-8(fp)
81128df8:	e13ffb17 	ldw	r4,-20(fp)
81128dfc:	103ee83a 	callr	r2
81128e00:	e0bffc15 	stw	r2,-16(fp)
81128e04:	e0bffc17 	ldw	r2,-16(fp)
81128e08:	1000070e 	bge	r2,zero,81128e28 <write+0xbc>
      {
        ALT_ERRNO = -rval;
81128e0c:	1128d280 	call	81128d28 <alt_get_errno>
81128e10:	1007883a 	mov	r3,r2
81128e14:	e0bffc17 	ldw	r2,-16(fp)
81128e18:	0085c83a 	sub	r2,zero,r2
81128e1c:	18800015 	stw	r2,0(r3)
        return -1;
81128e20:	00bfffc4 	movi	r2,-1
81128e24:	00000c06 	br	81128e58 <write+0xec>
      }
      return rval;
81128e28:	e0bffc17 	ldw	r2,-16(fp)
81128e2c:	00000a06 	br	81128e58 <write+0xec>
    }
    else
    {
      ALT_ERRNO = EACCES;
81128e30:	1128d280 	call	81128d28 <alt_get_errno>
81128e34:	1007883a 	mov	r3,r2
81128e38:	00800344 	movi	r2,13
81128e3c:	18800015 	stw	r2,0(r3)
81128e40:	00000406 	br	81128e54 <write+0xe8>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81128e44:	1128d280 	call	81128d28 <alt_get_errno>
81128e48:	1007883a 	mov	r3,r2
81128e4c:	00801444 	movi	r2,81
81128e50:	18800015 	stw	r2,0(r3)
  }
  return -1;
81128e54:	00bfffc4 	movi	r2,-1
}
81128e58:	e037883a 	mov	sp,fp
81128e5c:	dfc00117 	ldw	ra,4(sp)
81128e60:	df000017 	ldw	fp,0(sp)
81128e64:	dec00204 	addi	sp,sp,8
81128e68:	f800283a 	ret

81128e6c <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81128e6c:	deffde04 	addi	sp,sp,-136
81128e70:	de00012e 	bgeu	sp,et,81128e78 <__env_lock+0xc>
81128e74:	003b68fa 	trap	3
81128e78:	dfc02115 	stw	ra,132(sp)
81128e7c:	df002015 	stw	fp,128(sp)
81128e80:	df002004 	addi	fp,sp,128
81128e84:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81128e88:	e0bfe104 	addi	r2,fp,-124
81128e8c:	100b883a 	mov	r5,r2
81128e90:	01003fc4 	movi	r4,255
81128e94:	11317500 	call	81131750 <OSTaskQuery>
81128e98:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81128e9c:	e0bffe83 	ldbu	r2,-6(fp)
81128ea0:	10803fcc 	andi	r2,r2,255
81128ea4:	10001e1e 	bne	r2,zero,81128f20 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81128ea8:	e0bfed83 	ldbu	r2,-74(fp)
81128eac:	10803fcc 	andi	r2,r2,255
81128eb0:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81128eb4:	d0a06f17 	ldw	r2,-32324(gp)
81128eb8:	e0fffc04 	addi	r3,fp,-16
81128ebc:	180b883a 	mov	r5,r3
81128ec0:	1009883a 	mov	r4,r2
81128ec4:	112ff080 	call	8112ff08 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81128ec8:	e0bffe03 	ldbu	r2,-8(fp)
81128ecc:	10803fcc 	andi	r2,r2,255
81128ed0:	10000726 	beq	r2,zero,81128ef0 <__env_lock+0x84>
81128ed4:	d0a01517 	ldw	r2,-32684(gp)
81128ed8:	e0ffe017 	ldw	r3,-128(fp)
81128edc:	1880041e 	bne	r3,r2,81128ef0 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81128ee0:	d0a06e17 	ldw	r2,-32328(gp)
81128ee4:	10800044 	addi	r2,r2,1
81128ee8:	d0a06e15 	stw	r2,-32328(gp)
81128eec:	00000a06 	br	81128f18 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81128ef0:	d0a06f17 	ldw	r2,-32324(gp)
81128ef4:	e0fffe84 	addi	r3,fp,-6
81128ef8:	180d883a 	mov	r6,r3
81128efc:	000b883a 	mov	r5,zero
81128f00:	1009883a 	mov	r4,r2
81128f04:	112fa680 	call	8112fa68 <OSSemPend>
    locks  = 1;
81128f08:	00800044 	movi	r2,1
81128f0c:	d0a06e15 	stw	r2,-32328(gp)
    lockid = id;
81128f10:	e0bfe017 	ldw	r2,-128(fp)
81128f14:	d0a01515 	stw	r2,-32684(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81128f18:	0001883a 	nop
81128f1c:	00000106 	br	81128f24 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81128f20:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81128f24:	e037883a 	mov	sp,fp
81128f28:	dfc00117 	ldw	ra,4(sp)
81128f2c:	df000017 	ldw	fp,0(sp)
81128f30:	dec00204 	addi	sp,sp,8
81128f34:	f800283a 	ret

81128f38 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81128f38:	defffd04 	addi	sp,sp,-12
81128f3c:	de00012e 	bgeu	sp,et,81128f44 <__env_unlock+0xc>
81128f40:	003b68fa 	trap	3
81128f44:	dfc00215 	stw	ra,8(sp)
81128f48:	df000115 	stw	fp,4(sp)
81128f4c:	df000104 	addi	fp,sp,4
81128f50:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81128f54:	d0a06e17 	ldw	r2,-32328(gp)
81128f58:	10000b26 	beq	r2,zero,81128f88 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81128f5c:	d0a06e17 	ldw	r2,-32328(gp)
81128f60:	10bfffc4 	addi	r2,r2,-1
81128f64:	d0a06e15 	stw	r2,-32328(gp)
81128f68:	d0a06e17 	ldw	r2,-32328(gp)
81128f6c:	1000071e 	bne	r2,zero,81128f8c <__env_unlock+0x54>
  {
    lockid = -1;
81128f70:	00bfffc4 	movi	r2,-1
81128f74:	d0a01515 	stw	r2,-32684(gp)
    OSSemPost( alt_envsem );
81128f78:	d0a06f17 	ldw	r2,-32324(gp)
81128f7c:	1009883a 	mov	r4,r2
81128f80:	112fdf00 	call	8112fdf0 <OSSemPost>
81128f84:	00000106 	br	81128f8c <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81128f88:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81128f8c:	e037883a 	mov	sp,fp
81128f90:	dfc00117 	ldw	ra,4(sp)
81128f94:	df000017 	ldw	fp,0(sp)
81128f98:	dec00204 	addi	sp,sp,8
81128f9c:	f800283a 	ret

81128fa0 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81128fa0:	deffda04 	addi	sp,sp,-152
81128fa4:	de00012e 	bgeu	sp,et,81128fac <__malloc_lock+0xc>
81128fa8:	003b68fa 	trap	3
81128fac:	dfc02515 	stw	ra,148(sp)
81128fb0:	df002415 	stw	fp,144(sp)
81128fb4:	df002404 	addi	fp,sp,144
81128fb8:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81128fbc:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
81128fc0:	d0a07503 	ldbu	r2,-32300(gp)
81128fc4:	10803fcc 	andi	r2,r2,255
81128fc8:	10800060 	cmpeqi	r2,r2,1
81128fcc:	10003626 	beq	r2,zero,811290a8 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81128fd0:	e0bfe104 	addi	r2,fp,-124
81128fd4:	100b883a 	mov	r5,r2
81128fd8:	01003fc4 	movi	r4,255
81128fdc:	11317500 	call	81131750 <OSTaskQuery>
81128fe0:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81128fe4:	e0bffe83 	ldbu	r2,-6(fp)
81128fe8:	10803fcc 	andi	r2,r2,255
81128fec:	1000301e 	bne	r2,zero,811290b0 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81128ff0:	e0bfed83 	ldbu	r2,-74(fp)
81128ff4:	10803fcc 	andi	r2,r2,255
81128ff8:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81128ffc:	d0a07117 	ldw	r2,-32316(gp)
81129000:	e0fffc04 	addi	r3,fp,-16
81129004:	180b883a 	mov	r5,r3
81129008:	1009883a 	mov	r4,r2
8112900c:	112ff080 	call	8112ff08 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81129010:	0005303a 	rdctl	r2,status
81129014:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129018:	e0ffe017 	ldw	r3,-128(fp)
8112901c:	00bfff84 	movi	r2,-2
81129020:	1884703a 	and	r2,r3,r2
81129024:	1001703a 	wrctl	status,r2
  
  return context;
81129028:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
8112902c:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81129030:	e0bffc0b 	ldhu	r2,-16(fp)
81129034:	10bfffcc 	andi	r2,r2,65535
81129038:	10000b1e 	bne	r2,zero,81129068 <__malloc_lock+0xc8>
8112903c:	d0a01617 	ldw	r2,-32680(gp)
81129040:	e0ffdd17 	ldw	r3,-140(fp)
81129044:	1880081e 	bne	r3,r2,81129068 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81129048:	d0a07017 	ldw	r2,-32320(gp)
8112904c:	10800044 	addi	r2,r2,1
81129050:	d0a07015 	stw	r2,-32320(gp)
81129054:	e0bfdc17 	ldw	r2,-144(fp)
81129058:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112905c:	e0bfde17 	ldw	r2,-136(fp)
81129060:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81129064:	00000e06 	br	811290a0 <__malloc_lock+0x100>
81129068:	e0bfdc17 	ldw	r2,-144(fp)
8112906c:	e0bfdf15 	stw	r2,-132(fp)
81129070:	e0bfdf17 	ldw	r2,-132(fp)
81129074:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
81129078:	d0a07117 	ldw	r2,-32316(gp)
8112907c:	e0fffe84 	addi	r3,fp,-6
81129080:	180d883a 	mov	r6,r3
81129084:	000b883a 	mov	r5,zero
81129088:	1009883a 	mov	r4,r2
8112908c:	112fa680 	call	8112fa68 <OSSemPend>
    locks  = 1;
81129090:	00800044 	movi	r2,1
81129094:	d0a07015 	stw	r2,-32320(gp)
    lockid = id;
81129098:	e0bfdd17 	ldw	r2,-140(fp)
8112909c:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
811290a0:	0001883a 	nop
811290a4:	00000306 	br	811290b4 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
811290a8:	0001883a 	nop
811290ac:	00000106 	br	811290b4 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
811290b0:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
811290b4:	e037883a 	mov	sp,fp
811290b8:	dfc00117 	ldw	ra,4(sp)
811290bc:	df000017 	ldw	fp,0(sp)
811290c0:	dec00204 	addi	sp,sp,8
811290c4:	f800283a 	ret

811290c8 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
811290c8:	defff804 	addi	sp,sp,-32
811290cc:	de00012e 	bgeu	sp,et,811290d4 <__malloc_unlock+0xc>
811290d0:	003b68fa 	trap	3
811290d4:	dfc00715 	stw	ra,28(sp)
811290d8:	df000615 	stw	fp,24(sp)
811290dc:	df000604 	addi	fp,sp,24
811290e0:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811290e4:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
811290e8:	d0a07503 	ldbu	r2,-32300(gp)
811290ec:	10803fcc 	andi	r2,r2,255
811290f0:	10800060 	cmpeqi	r2,r2,1
811290f4:	10002326 	beq	r2,zero,81129184 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811290f8:	0005303a 	rdctl	r2,status
811290fc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129100:	e0fffe17 	ldw	r3,-8(fp)
81129104:	00bfff84 	movi	r2,-2
81129108:	1884703a 	and	r2,r3,r2
8112910c:	1001703a 	wrctl	status,r2
  
  return context;
81129110:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81129114:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81129118:	d0a07017 	ldw	r2,-32320(gp)
8112911c:	1000051e 	bne	r2,zero,81129134 <__malloc_unlock+0x6c>
81129120:	e0bffa17 	ldw	r2,-24(fp)
81129124:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81129128:	e0bffb17 	ldw	r2,-20(fp)
8112912c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81129130:	00001506 	br	81129188 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81129134:	d0a07017 	ldw	r2,-32320(gp)
81129138:	10bfffc4 	addi	r2,r2,-1
8112913c:	d0a07015 	stw	r2,-32320(gp)
81129140:	d0a07017 	ldw	r2,-32320(gp)
81129144:	10000a1e 	bne	r2,zero,81129170 <__malloc_unlock+0xa8>
  {
    lockid = -1;
81129148:	00bfffc4 	movi	r2,-1
8112914c:	d0a01615 	stw	r2,-32680(gp)
81129150:	e0bffa17 	ldw	r2,-24(fp)
81129154:	e0bffc15 	stw	r2,-16(fp)
81129158:	e0bffc17 	ldw	r2,-16(fp)
8112915c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81129160:	d0a07117 	ldw	r2,-32316(gp)
81129164:	1009883a 	mov	r4,r2
81129168:	112fdf00 	call	8112fdf0 <OSSemPost>
8112916c:	00000606 	br	81129188 <__malloc_unlock+0xc0>
81129170:	e0bffa17 	ldw	r2,-24(fp)
81129174:	e0bffd15 	stw	r2,-12(fp)
81129178:	e0bffd17 	ldw	r2,-12(fp)
8112917c:	1001703a 	wrctl	status,r2
81129180:	00000106 	br	81129188 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
81129184:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81129188:	e037883a 	mov	sp,fp
8112918c:	dfc00117 	ldw	ra,4(sp)
81129190:	df000017 	ldw	fp,0(sp)
81129194:	dec00204 	addi	sp,sp,8
81129198:	f800283a 	ret

8112919c <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8112919c:	defff704 	addi	sp,sp,-36
811291a0:	de00012e 	bgeu	sp,et,811291a8 <OSEventNameGet+0xc>
811291a4:	003b68fa 	trap	3
811291a8:	dfc00815 	stw	ra,32(sp)
811291ac:	df000715 	stw	fp,28(sp)
811291b0:	df000704 	addi	fp,sp,28
811291b4:	e13ffd15 	stw	r4,-12(fp)
811291b8:	e17ffe15 	stw	r5,-8(fp)
811291bc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811291c0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811291c4:	e0bfff17 	ldw	r2,-4(fp)
811291c8:	1000021e 	bne	r2,zero,811291d4 <OSEventNameGet+0x38>
        return (0);
811291cc:	0005883a 	mov	r2,zero
811291d0:	00003706 	br	811292b0 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
811291d4:	e0bffd17 	ldw	r2,-12(fp)
811291d8:	1000051e 	bne	r2,zero,811291f0 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
811291dc:	e0bfff17 	ldw	r2,-4(fp)
811291e0:	00c00104 	movi	r3,4
811291e4:	10c00005 	stb	r3,0(r2)
        return (0);
811291e8:	0005883a 	mov	r2,zero
811291ec:	00003006 	br	811292b0 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811291f0:	e0bffe17 	ldw	r2,-8(fp)
811291f4:	1000051e 	bne	r2,zero,8112920c <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
811291f8:	e0bfff17 	ldw	r2,-4(fp)
811291fc:	00c00304 	movi	r3,12
81129200:	10c00005 	stb	r3,0(r2)
        return (0);
81129204:	0005883a 	mov	r2,zero
81129208:	00002906 	br	811292b0 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112920c:	d0a08503 	ldbu	r2,-32236(gp)
81129210:	10803fcc 	andi	r2,r2,255
81129214:	10000526 	beq	r2,zero,8112922c <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81129218:	e0bfff17 	ldw	r2,-4(fp)
8112921c:	00c00444 	movi	r3,17
81129220:	10c00005 	stb	r3,0(r2)
        return (0);
81129224:	0005883a 	mov	r2,zero
81129228:	00002106 	br	811292b0 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
8112922c:	e0bffd17 	ldw	r2,-12(fp)
81129230:	10800003 	ldbu	r2,0(r2)
81129234:	10803fcc 	andi	r2,r2,255
81129238:	10bfffc4 	addi	r2,r2,-1
8112923c:	10800128 	cmpgeui	r2,r2,4
81129240:	10000526 	beq	r2,zero,81129258 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81129244:	e0bfff17 	ldw	r2,-4(fp)
81129248:	00c00044 	movi	r3,1
8112924c:	10c00005 	stb	r3,0(r2)
             return (0);
81129250:	0005883a 	mov	r2,zero
81129254:	00001606 	br	811292b0 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81129258:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112925c:	0005303a 	rdctl	r2,status
81129260:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129264:	e0fffb17 	ldw	r3,-20(fp)
81129268:	00bfff84 	movi	r2,-2
8112926c:	1884703a 	and	r2,r3,r2
81129270:	1001703a 	wrctl	status,r2
  
  return context;
81129274:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81129278:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
8112927c:	e0bffd17 	ldw	r2,-12(fp)
81129280:	10800444 	addi	r2,r2,17
81129284:	100b883a 	mov	r5,r2
81129288:	e13ffe17 	ldw	r4,-8(fp)
8112928c:	112ad0c0 	call	8112ad0c <OS_StrCopy>
81129290:	e0bffa05 	stb	r2,-24(fp)
81129294:	e0bff917 	ldw	r2,-28(fp)
81129298:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112929c:	e0bffc17 	ldw	r2,-16(fp)
811292a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811292a4:	e0bfff17 	ldw	r2,-4(fp)
811292a8:	10000005 	stb	zero,0(r2)
    return (len);
811292ac:	e0bffa03 	ldbu	r2,-24(fp)
}
811292b0:	e037883a 	mov	sp,fp
811292b4:	dfc00117 	ldw	ra,4(sp)
811292b8:	df000017 	ldw	fp,0(sp)
811292bc:	dec00204 	addi	sp,sp,8
811292c0:	f800283a 	ret

811292c4 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811292c4:	defff604 	addi	sp,sp,-40
811292c8:	de00012e 	bgeu	sp,et,811292d0 <OSEventNameSet+0xc>
811292cc:	003b68fa 	trap	3
811292d0:	dfc00915 	stw	ra,36(sp)
811292d4:	df000815 	stw	fp,32(sp)
811292d8:	df000804 	addi	fp,sp,32
811292dc:	e13ffd15 	stw	r4,-12(fp)
811292e0:	e17ffe15 	stw	r5,-8(fp)
811292e4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811292e8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811292ec:	e0bfff17 	ldw	r2,-4(fp)
811292f0:	10004026 	beq	r2,zero,811293f4 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
811292f4:	e0bffd17 	ldw	r2,-12(fp)
811292f8:	1000041e 	bne	r2,zero,8112930c <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
811292fc:	e0bfff17 	ldw	r2,-4(fp)
81129300:	00c00104 	movi	r3,4
81129304:	10c00005 	stb	r3,0(r2)
        return;
81129308:	00003b06 	br	811293f8 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112930c:	e0bffe17 	ldw	r2,-8(fp)
81129310:	1000041e 	bne	r2,zero,81129324 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81129314:	e0bfff17 	ldw	r2,-4(fp)
81129318:	00c00304 	movi	r3,12
8112931c:	10c00005 	stb	r3,0(r2)
        return;
81129320:	00003506 	br	811293f8 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81129324:	d0a08503 	ldbu	r2,-32236(gp)
81129328:	10803fcc 	andi	r2,r2,255
8112932c:	10000426 	beq	r2,zero,81129340 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81129330:	e0bfff17 	ldw	r2,-4(fp)
81129334:	00c00484 	movi	r3,18
81129338:	10c00005 	stb	r3,0(r2)
        return;
8112933c:	00002e06 	br	811293f8 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81129340:	e0bffd17 	ldw	r2,-12(fp)
81129344:	10800003 	ldbu	r2,0(r2)
81129348:	10803fcc 	andi	r2,r2,255
8112934c:	10bfffc4 	addi	r2,r2,-1
81129350:	10800128 	cmpgeui	r2,r2,4
81129354:	10000426 	beq	r2,zero,81129368 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81129358:	e0bfff17 	ldw	r2,-4(fp)
8112935c:	00c00044 	movi	r3,1
81129360:	10c00005 	stb	r3,0(r2)
             return;
81129364:	00002406 	br	811293f8 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81129368:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112936c:	0005303a 	rdctl	r2,status
81129370:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129374:	e0fffc17 	ldw	r3,-16(fp)
81129378:	00bfff84 	movi	r2,-2
8112937c:	1884703a 	and	r2,r3,r2
81129380:	1001703a 	wrctl	status,r2
  
  return context;
81129384:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
81129388:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
8112938c:	e13ffe17 	ldw	r4,-8(fp)
81129390:	112ad880 	call	8112ad88 <OS_StrLen>
81129394:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
81129398:	e0bffa03 	ldbu	r2,-24(fp)
8112939c:	10800830 	cmpltui	r2,r2,32
811293a0:	1000081e 	bne	r2,zero,811293c4 <OSEventNameSet+0x100>
811293a4:	e0bff817 	ldw	r2,-32(fp)
811293a8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811293ac:	e0bff917 	ldw	r2,-28(fp)
811293b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
811293b4:	e0bfff17 	ldw	r2,-4(fp)
811293b8:	00c002c4 	movi	r3,11
811293bc:	10c00005 	stb	r3,0(r2)
        return;
811293c0:	00000d06 	br	811293f8 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
811293c4:	e0bffd17 	ldw	r2,-12(fp)
811293c8:	10800444 	addi	r2,r2,17
811293cc:	e17ffe17 	ldw	r5,-8(fp)
811293d0:	1009883a 	mov	r4,r2
811293d4:	112ad0c0 	call	8112ad0c <OS_StrCopy>
811293d8:	e0bff817 	ldw	r2,-32(fp)
811293dc:	e0bffb15 	stw	r2,-20(fp)
811293e0:	e0bffb17 	ldw	r2,-20(fp)
811293e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811293e8:	e0bfff17 	ldw	r2,-4(fp)
811293ec:	10000005 	stb	zero,0(r2)
811293f0:	00000106 	br	811293f8 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
811293f4:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
811293f8:	e037883a 	mov	sp,fp
811293fc:	dfc00117 	ldw	ra,4(sp)
81129400:	df000017 	ldw	fp,0(sp)
81129404:	dec00204 	addi	sp,sp,8
81129408:	f800283a 	ret

8112940c <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
8112940c:	deffed04 	addi	sp,sp,-76
81129410:	de00012e 	bgeu	sp,et,81129418 <OSEventPendMulti+0xc>
81129414:	003b68fa 	trap	3
81129418:	dfc01215 	stw	ra,72(sp)
8112941c:	df001115 	stw	fp,68(sp)
81129420:	df001104 	addi	fp,sp,68
81129424:	e13ffc15 	stw	r4,-16(fp)
81129428:	e17ffd15 	stw	r5,-12(fp)
8112942c:	e1bffe15 	stw	r6,-8(fp)
81129430:	3805883a 	mov	r2,r7
81129434:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81129438:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
8112943c:	e0800217 	ldw	r2,8(fp)
81129440:	1000021e 	bne	r2,zero,8112944c <OSEventPendMulti+0x40>
        return (0);
81129444:	0005883a 	mov	r2,zero
81129448:	00017106 	br	81129a10 <OSEventPendMulti+0x604>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
8112944c:	e0bffc17 	ldw	r2,-16(fp)
81129450:	1000051e 	bne	r2,zero,81129468 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
81129454:	e0800217 	ldw	r2,8(fp)
81129458:	00c00104 	movi	r3,4
8112945c:	10c00005 	stb	r3,0(r2)
        return (0);
81129460:	0005883a 	mov	r2,zero
81129464:	00016a06 	br	81129a10 <OSEventPendMulti+0x604>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
81129468:	e0bffd17 	ldw	r2,-12(fp)
8112946c:	1000051e 	bne	r2,zero,81129484 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
81129470:	e0800217 	ldw	r2,8(fp)
81129474:	00c00104 	movi	r3,4
81129478:	10c00005 	stb	r3,0(r2)
        return (0);
8112947c:	0005883a 	mov	r2,zero
81129480:	00016306 	br	81129a10 <OSEventPendMulti+0x604>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
81129484:	e0bffe17 	ldw	r2,-8(fp)
81129488:	1000051e 	bne	r2,zero,811294a0 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
8112948c:	e0800217 	ldw	r2,8(fp)
81129490:	00c00104 	movi	r3,4
81129494:	10c00005 	stb	r3,0(r2)
        return (0);
81129498:	0005883a 	mov	r2,zero
8112949c:	00015c06 	br	81129a10 <OSEventPendMulti+0x604>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
811294a0:	e0bffd17 	ldw	r2,-12(fp)
811294a4:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
811294a8:	e0bffc17 	ldw	r2,-16(fp)
811294ac:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
811294b0:	e0bfef17 	ldw	r2,-68(fp)
811294b4:	10800017 	ldw	r2,0(r2)
811294b8:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
811294bc:	00001906 	br	81129524 <OSEventPendMulti+0x118>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
811294c0:	e0bff017 	ldw	r2,-64(fp)
811294c4:	10800003 	ldbu	r2,0(r2)
811294c8:	10803fcc 	andi	r2,r2,255
811294cc:	10c000a0 	cmpeqi	r3,r2,2
811294d0:	1800091e 	bne	r3,zero,811294f8 <OSEventPendMulti+0xec>
811294d4:	10c000e0 	cmpeqi	r3,r2,3
811294d8:	1800091e 	bne	r3,zero,81129500 <OSEventPendMulti+0xf4>
811294dc:	10800060 	cmpeqi	r2,r2,1
811294e0:	1000091e 	bne	r2,zero,81129508 <OSEventPendMulti+0xfc>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
811294e4:	e0800217 	ldw	r2,8(fp)
811294e8:	00c00044 	movi	r3,1
811294ec:	10c00005 	stb	r3,0(r2)
                 return (0);
811294f0:	0005883a 	mov	r2,zero
811294f4:	00014606 	br	81129a10 <OSEventPendMulti+0x604>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
811294f8:	0001883a 	nop
811294fc:	00000306 	br	8112950c <OSEventPendMulti+0x100>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
81129500:	0001883a 	nop
81129504:	00000106 	br	8112950c <OSEventPendMulti+0x100>
#endif
#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 break;
81129508:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
8112950c:	e0bfef17 	ldw	r2,-68(fp)
81129510:	10800104 	addi	r2,r2,4
81129514:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81129518:	e0bfef17 	ldw	r2,-68(fp)
8112951c:	10800017 	ldw	r2,0(r2)
81129520:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
81129524:	e0bff017 	ldw	r2,-64(fp)
81129528:	103fe51e 	bne	r2,zero,811294c0 <__reset+0xfb1094c0>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
8112952c:	d0a08503 	ldbu	r2,-32236(gp)
81129530:	10803fcc 	andi	r2,r2,255
81129534:	10000526 	beq	r2,zero,8112954c <OSEventPendMulti+0x140>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
81129538:	e0800217 	ldw	r2,8(fp)
8112953c:	00c00084 	movi	r3,2
81129540:	10c00005 	stb	r3,0(r2)
        return (0);
81129544:	0005883a 	mov	r2,zero
81129548:	00013106 	br	81129a10 <OSEventPendMulti+0x604>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
8112954c:	d0a07303 	ldbu	r2,-32308(gp)
81129550:	10803fcc 	andi	r2,r2,255
81129554:	10000526 	beq	r2,zero,8112956c <OSEventPendMulti+0x160>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
81129558:	e0800217 	ldw	r2,8(fp)
8112955c:	00c00344 	movi	r3,13
81129560:	10c00005 	stb	r3,0(r2)
        return (0);
81129564:	0005883a 	mov	r2,zero
81129568:	00012906 	br	81129a10 <OSEventPendMulti+0x604>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112956c:	0005303a 	rdctl	r2,status
81129570:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129574:	e0fffb17 	ldw	r3,-20(fp)
81129578:	00bfff84 	movi	r2,-2
8112957c:	1884703a 	and	r2,r3,r2
81129580:	1001703a 	wrctl	status,r2
  
  return context;
81129584:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
81129588:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
8112958c:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
81129590:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
81129594:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
81129598:	e0bffc17 	ldw	r2,-16(fp)
8112959c:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
811295a0:	e0bfef17 	ldw	r2,-68(fp)
811295a4:	10800017 	ldw	r2,0(r2)
811295a8:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811295ac:	00008106 	br	811297b4 <OSEventPendMulti+0x3a8>
        switch (pevent->OSEventType) {
811295b0:	e0bff017 	ldw	r2,-64(fp)
811295b4:	10800003 	ldbu	r2,0(r2)
811295b8:	10803fcc 	andi	r2,r2,255
811295bc:	10c000a0 	cmpeqi	r3,r2,2
811295c0:	18003c1e 	bne	r3,zero,811296b4 <OSEventPendMulti+0x2a8>
811295c4:	10c000e0 	cmpeqi	r3,r2,3
811295c8:	1800031e 	bne	r3,zero,811295d8 <OSEventPendMulti+0x1cc>
811295cc:	10800060 	cmpeqi	r2,r2,1
811295d0:	10001e1e 	bne	r2,zero,8112964c <OSEventPendMulti+0x240>
811295d4:	00006606 	br	81129770 <OSEventPendMulti+0x364>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
811295d8:	e0bff017 	ldw	r2,-64(fp)
811295dc:	1080020b 	ldhu	r2,8(r2)
811295e0:	10bfffcc 	andi	r2,r2,65535
811295e4:	10001526 	beq	r2,zero,8112963c <OSEventPendMulti+0x230>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
811295e8:	e0bff017 	ldw	r2,-64(fp)
811295ec:	1080020b 	ldhu	r2,8(r2)
811295f0:	10bfffc4 	addi	r2,r2,-1
811295f4:	1007883a 	mov	r3,r2
811295f8:	e0bff017 	ldw	r2,-64(fp)
811295fc:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
81129600:	e0bffd17 	ldw	r2,-12(fp)
81129604:	10c00104 	addi	r3,r2,4
81129608:	e0fffd15 	stw	r3,-12(fp)
8112960c:	e0fff017 	ldw	r3,-64(fp)
81129610:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
81129614:	00800044 	movi	r2,1
81129618:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
8112961c:	e0bffe17 	ldw	r2,-8(fp)
81129620:	10c00104 	addi	r3,r2,4
81129624:	e0fffe15 	stw	r3,-8(fp)
81129628:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
8112962c:	e0bff18b 	ldhu	r2,-58(fp)
81129630:	10800044 	addi	r2,r2,1
81129634:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
81129638:	00005806 	br	8112979c <OSEventPendMulti+0x390>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
8112963c:	e0bff203 	ldbu	r2,-56(fp)
81129640:	10800054 	ori	r2,r2,1
81129644:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81129648:	00005406 	br	8112979c <OSEventPendMulti+0x390>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
8112964c:	e0bff017 	ldw	r2,-64(fp)
81129650:	10800117 	ldw	r2,4(r2)
81129654:	10001326 	beq	r2,zero,811296a4 <OSEventPendMulti+0x298>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
81129658:	e0bffe17 	ldw	r2,-8(fp)
8112965c:	10c00104 	addi	r3,r2,4
81129660:	e0fffe15 	stw	r3,-8(fp)
81129664:	e0fff017 	ldw	r3,-64(fp)
81129668:	18c00117 	ldw	r3,4(r3)
8112966c:	10c00015 	stw	r3,0(r2)
                     pevent->OSEventPtr  = (void *)0;
81129670:	e0bff017 	ldw	r2,-64(fp)
81129674:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
81129678:	e0bffd17 	ldw	r2,-12(fp)
8112967c:	10c00104 	addi	r3,r2,4
81129680:	e0fffd15 	stw	r3,-12(fp)
81129684:	e0fff017 	ldw	r3,-64(fp)
81129688:	10c00015 	stw	r3,0(r2)
                      events_rdy         =  OS_TRUE;
8112968c:	00800044 	movi	r2,1
81129690:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81129694:	e0bff18b 	ldhu	r2,-58(fp)
81129698:	10800044 	addi	r2,r2,1
8112969c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
                 }
                 break;
811296a0:	00003e06 	br	8112979c <OSEventPendMulti+0x390>
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
811296a4:	e0bff203 	ldbu	r2,-56(fp)
811296a8:	10800094 	ori	r2,r2,2
811296ac:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
811296b0:	00003a06 	br	8112979c <OSEventPendMulti+0x390>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
811296b4:	e0bff017 	ldw	r2,-64(fp)
811296b8:	10800117 	ldw	r2,4(r2)
811296bc:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
811296c0:	e0bff517 	ldw	r2,-44(fp)
811296c4:	1080058b 	ldhu	r2,22(r2)
811296c8:	10bfffcc 	andi	r2,r2,65535
811296cc:	10002426 	beq	r2,zero,81129760 <OSEventPendMulti+0x354>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
811296d0:	e0bffe17 	ldw	r2,-8(fp)
811296d4:	10c00104 	addi	r3,r2,4
811296d8:	e0fffe15 	stw	r3,-8(fp)
811296dc:	e0fff517 	ldw	r3,-44(fp)
811296e0:	18c00417 	ldw	r3,16(r3)
811296e4:	19400104 	addi	r5,r3,4
811296e8:	e13ff517 	ldw	r4,-44(fp)
811296ec:	21400415 	stw	r5,16(r4)
811296f0:	18c00017 	ldw	r3,0(r3)
811296f4:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
811296f8:	e0bff517 	ldw	r2,-44(fp)
811296fc:	10c00417 	ldw	r3,16(r2)
81129700:	e0bff517 	ldw	r2,-44(fp)
81129704:	10800217 	ldw	r2,8(r2)
81129708:	1880041e 	bne	r3,r2,8112971c <OSEventPendMulti+0x310>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
8112970c:	e0bff517 	ldw	r2,-44(fp)
81129710:	10c00117 	ldw	r3,4(r2)
81129714:	e0bff517 	ldw	r2,-44(fp)
81129718:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
8112971c:	e0bff517 	ldw	r2,-44(fp)
81129720:	1080058b 	ldhu	r2,22(r2)
81129724:	10bfffc4 	addi	r2,r2,-1
81129728:	1007883a 	mov	r3,r2
8112972c:	e0bff517 	ldw	r2,-44(fp)
81129730:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
81129734:	e0bffd17 	ldw	r2,-12(fp)
81129738:	10c00104 	addi	r3,r2,4
8112973c:	e0fffd15 	stw	r3,-12(fp)
81129740:	e0fff017 	ldw	r3,-64(fp)
81129744:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
81129748:	00800044 	movi	r2,1
8112974c:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81129750:	e0bff18b 	ldhu	r2,-58(fp)
81129754:	10800044 	addi	r2,r2,1
81129758:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
8112975c:	00000f06 	br	8112979c <OSEventPendMulti+0x390>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81129760:	e0bff203 	ldbu	r2,-56(fp)
81129764:	10800114 	ori	r2,r2,4
81129768:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8112976c:	00000b06 	br	8112979c <OSEventPendMulti+0x390>
81129770:	e0bff317 	ldw	r2,-52(fp)
81129774:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81129778:	e0bff417 	ldw	r2,-48(fp)
8112977c:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81129780:	e0bffd17 	ldw	r2,-12(fp)
81129784:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
81129788:	e0800217 	ldw	r2,8(fp)
8112978c:	00c00044 	movi	r3,1
81129790:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
81129794:	e0bff18b 	ldhu	r2,-58(fp)
81129798:	00009d06 	br	81129a10 <OSEventPendMulti+0x604>
        }
        pevents++;
8112979c:	e0bfef17 	ldw	r2,-68(fp)
811297a0:	10800104 	addi	r2,r2,4
811297a4:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
811297a8:	e0bfef17 	ldw	r2,-68(fp)
811297ac:	10800017 	ldw	r2,0(r2)
811297b0:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811297b4:	e0bff017 	ldw	r2,-64(fp)
811297b8:	103f7d1e 	bne	r2,zero,811295b0 <__reset+0xfb1095b0>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
811297bc:	e0bff103 	ldbu	r2,-60(fp)
811297c0:	10800058 	cmpnei	r2,r2,1
811297c4:	10000a1e 	bne	r2,zero,811297f0 <OSEventPendMulti+0x3e4>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
811297c8:	e0bffd17 	ldw	r2,-12(fp)
811297cc:	10000015 	stw	zero,0(r2)
811297d0:	e0bff317 	ldw	r2,-52(fp)
811297d4:	e0bff615 	stw	r2,-40(fp)
811297d8:	e0bff617 	ldw	r2,-40(fp)
811297dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
811297e0:	e0800217 	ldw	r2,8(fp)
811297e4:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
811297e8:	e0bff18b 	ldhu	r2,-58(fp)
811297ec:	00008806 	br	81129a10 <OSEventPendMulti+0x604>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
811297f0:	d0a08617 	ldw	r2,-32232(gp)
811297f4:	d0e08617 	ldw	r3,-32232(gp)
811297f8:	19000c03 	ldbu	r4,48(r3)
811297fc:	e0fff203 	ldbu	r3,-56(fp)
81129800:	20c6b03a 	or	r3,r4,r3
81129804:	1809883a 	mov	r4,r3
81129808:	00ffe004 	movi	r3,-128
8112980c:	20c6b03a 	or	r3,r4,r3
81129810:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81129814:	d0a08617 	ldw	r2,-32232(gp)
81129818:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
8112981c:	d0a08617 	ldw	r2,-32232(gp)
81129820:	e0ffff0b 	ldhu	r3,-4(fp)
81129824:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
81129828:	e13ffc17 	ldw	r4,-16(fp)
8112982c:	112a3b40 	call	8112a3b4 <OS_EventTaskWaitMulti>
81129830:	e0bff317 	ldw	r2,-52(fp)
81129834:	e0bff915 	stw	r2,-28(fp)
81129838:	e0bff917 	ldw	r2,-28(fp)
8112983c:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81129840:	112abb80 	call	8112abb8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81129844:	0005303a 	rdctl	r2,status
81129848:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112984c:	e0fff717 	ldw	r3,-36(fp)
81129850:	00bfff84 	movi	r2,-2
81129854:	1884703a 	and	r2,r3,r2
81129858:	1001703a 	wrctl	status,r2
  
  return context;
8112985c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81129860:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81129864:	d0a08617 	ldw	r2,-32232(gp)
81129868:	10800c43 	ldbu	r2,49(r2)
8112986c:	10803fcc 	andi	r2,r2,255
81129870:	10000226 	beq	r2,zero,8112987c <OSEventPendMulti+0x470>
81129874:	108000a0 	cmpeqi	r2,r2,2
81129878:	10001826 	beq	r2,zero,811298dc <OSEventPendMulti+0x4d0>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
8112987c:	d0a08617 	ldw	r2,-32232(gp)
81129880:	10800717 	ldw	r2,28(r2)
81129884:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81129888:	e0bff017 	ldw	r2,-64(fp)
8112988c:	10000b26 	beq	r2,zero,811298bc <OSEventPendMulti+0x4b0>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
81129890:	e0bffd17 	ldw	r2,-12(fp)
81129894:	10c00104 	addi	r3,r2,4
81129898:	e0fffd15 	stw	r3,-12(fp)
8112989c:	e0fff017 	ldw	r3,-64(fp)
811298a0:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
811298a4:	e0bffd17 	ldw	r2,-12(fp)
811298a8:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
811298ac:	e0bff18b 	ldhu	r2,-58(fp)
811298b0:	10800044 	addi	r2,r2,1
811298b4:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
811298b8:	00000d06 	br	811298f0 <OSEventPendMulti+0x4e4>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
811298bc:	d0a08617 	ldw	r2,-32232(gp)
811298c0:	00c00044 	movi	r3,1
811298c4:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811298c8:	d0a08617 	ldw	r2,-32232(gp)
811298cc:	e17ffc17 	ldw	r5,-16(fp)
811298d0:	1009883a 	mov	r4,r2
811298d4:	112a5cc0 	call	8112a5cc <OS_EventTaskRemoveMulti>
             }
			 break;
811298d8:	00000506 	br	811298f0 <OSEventPendMulti+0x4e4>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811298dc:	d0a08617 	ldw	r2,-32232(gp)
811298e0:	e17ffc17 	ldw	r5,-16(fp)
811298e4:	1009883a 	mov	r4,r2
811298e8:	112a5cc0 	call	8112a5cc <OS_EventTaskRemoveMulti>
             break;
811298ec:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
811298f0:	d0a08617 	ldw	r2,-32232(gp)
811298f4:	10800c43 	ldbu	r2,49(r2)
811298f8:	10803fcc 	andi	r2,r2,255
811298fc:	10000326 	beq	r2,zero,8112990c <OSEventPendMulti+0x500>
81129900:	108000a0 	cmpeqi	r2,r2,2
81129904:	1000231e 	bne	r2,zero,81129994 <OSEventPendMulti+0x588>
81129908:	00002a06 	br	811299b4 <OSEventPendMulti+0x5a8>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
8112990c:	e0bff017 	ldw	r2,-64(fp)
81129910:	10800003 	ldbu	r2,0(r2)
81129914:	10803fcc 	andi	r2,r2,255
81129918:	0080100e 	bge	zero,r2,8112995c <OSEventPendMulti+0x550>
8112991c:	10c000d0 	cmplti	r3,r2,3
81129920:	1800071e 	bne	r3,zero,81129940 <OSEventPendMulti+0x534>
81129924:	108000e0 	cmpeqi	r2,r2,3
81129928:	10000c26 	beq	r2,zero,8112995c <OSEventPendMulti+0x550>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
8112992c:	e0bffe17 	ldw	r2,-8(fp)
81129930:	10c00104 	addi	r3,r2,4
81129934:	e0fffe15 	stw	r3,-8(fp)
81129938:	10000015 	stw	zero,0(r2)
                      break;
8112993c:	00001206 	br	81129988 <OSEventPendMulti+0x57c>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
81129940:	e0bffe17 	ldw	r2,-8(fp)
81129944:	10c00104 	addi	r3,r2,4
81129948:	e0fffe15 	stw	r3,-8(fp)
8112994c:	d0e08617 	ldw	r3,-32232(gp)
81129950:	18c00917 	ldw	r3,36(r3)
81129954:	10c00015 	stw	r3,0(r2)
                      break;
81129958:	00000b06 	br	81129988 <OSEventPendMulti+0x57c>
8112995c:	e0bff317 	ldw	r2,-52(fp)
81129960:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81129964:	e0bff817 	ldw	r2,-32(fp)
81129968:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
8112996c:	e0bffd17 	ldw	r2,-12(fp)
81129970:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81129974:	e0800217 	ldw	r2,8(fp)
81129978:	00c00044 	movi	r3,1
8112997c:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81129980:	e0bff18b 	ldhu	r2,-58(fp)
81129984:	00002206 	br	81129a10 <OSEventPendMulti+0x604>
             }
            *perr = OS_ERR_NONE;
81129988:	e0800217 	ldw	r2,8(fp)
8112998c:	10000005 	stb	zero,0(r2)
             break;
81129990:	00001006 	br	811299d4 <OSEventPendMulti+0x5c8>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81129994:	e0bffe17 	ldw	r2,-8(fp)
81129998:	10c00104 	addi	r3,r2,4
8112999c:	e0fffe15 	stw	r3,-8(fp)
811299a0:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
811299a4:	e0800217 	ldw	r2,8(fp)
811299a8:	00c00384 	movi	r3,14
811299ac:	10c00005 	stb	r3,0(r2)
             break;
811299b0:	00000806 	br	811299d4 <OSEventPendMulti+0x5c8>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
811299b4:	e0bffe17 	ldw	r2,-8(fp)
811299b8:	10c00104 	addi	r3,r2,4
811299bc:	e0fffe15 	stw	r3,-8(fp)
811299c0:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
811299c4:	e0800217 	ldw	r2,8(fp)
811299c8:	00c00284 	movi	r3,10
811299cc:	10c00005 	stb	r3,0(r2)
             break;
811299d0:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
811299d4:	d0a08617 	ldw	r2,-32232(gp)
811299d8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
811299dc:	d0a08617 	ldw	r2,-32232(gp)
811299e0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
811299e4:	d0a08617 	ldw	r2,-32232(gp)
811299e8:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
811299ec:	d0a08617 	ldw	r2,-32232(gp)
811299f0:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
811299f4:	d0a08617 	ldw	r2,-32232(gp)
811299f8:	10000915 	stw	zero,36(r2)
811299fc:	e0bff317 	ldw	r2,-52(fp)
81129a00:	e0bffa15 	stw	r2,-24(fp)
81129a04:	e0bffa17 	ldw	r2,-24(fp)
81129a08:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81129a0c:	e0bff18b 	ldhu	r2,-58(fp)
}
81129a10:	e037883a 	mov	sp,fp
81129a14:	dfc00117 	ldw	ra,4(sp)
81129a18:	df000017 	ldw	fp,0(sp)
81129a1c:	dec00204 	addi	sp,sp,8
81129a20:	f800283a 	ret

81129a24 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81129a24:	defffe04 	addi	sp,sp,-8
81129a28:	de00012e 	bgeu	sp,et,81129a30 <OSInit+0xc>
81129a2c:	003b68fa 	trap	3
81129a30:	dfc00115 	stw	ra,4(sp)
81129a34:	df000015 	stw	fp,0(sp)
81129a38:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81129a3c:	113bf640 	call	8113bf64 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81129a40:	112a82c0 	call	8112a82c <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81129a44:	112a87c0 	call	8112a87c <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
81129a48:	112aa000 	call	8112aa00 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81129a4c:	112a7440 	call	8112a744 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81129a50:	112c9c00 	call	8112c9c0 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81129a54:	112d3080 	call	8112d308 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
81129a58:	112f5d80 	call	8112f5d8 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81129a5c:	112a8f00 	call	8112a8f0 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81129a60:	112a9780 	call	8112a978 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81129a64:	113297c0 	call	8113297c <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
81129a68:	113bf900 	call	8113bf90 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81129a6c:	112b2dc0 	call	8112b2dc <OSDebugInit>
#endif
}
81129a70:	0001883a 	nop
81129a74:	e037883a 	mov	sp,fp
81129a78:	dfc00117 	ldw	ra,4(sp)
81129a7c:	df000017 	ldw	fp,0(sp)
81129a80:	dec00204 	addi	sp,sp,8
81129a84:	f800283a 	ret

81129a88 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81129a88:	deffff04 	addi	sp,sp,-4
81129a8c:	de00012e 	bgeu	sp,et,81129a94 <OSIntEnter+0xc>
81129a90:	003b68fa 	trap	3
81129a94:	df000015 	stw	fp,0(sp)
81129a98:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
81129a9c:	d0a07503 	ldbu	r2,-32300(gp)
81129aa0:	10803fcc 	andi	r2,r2,255
81129aa4:	10800058 	cmpnei	r2,r2,1
81129aa8:	1000071e 	bne	r2,zero,81129ac8 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81129aac:	d0a08503 	ldbu	r2,-32236(gp)
81129ab0:	10803fcc 	andi	r2,r2,255
81129ab4:	10803fe0 	cmpeqi	r2,r2,255
81129ab8:	1000031e 	bne	r2,zero,81129ac8 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81129abc:	d0a08503 	ldbu	r2,-32236(gp)
81129ac0:	10800044 	addi	r2,r2,1
81129ac4:	d0a08505 	stb	r2,-32236(gp)
        }
    }
}
81129ac8:	0001883a 	nop
81129acc:	e037883a 	mov	sp,fp
81129ad0:	df000017 	ldw	fp,0(sp)
81129ad4:	dec00104 	addi	sp,sp,4
81129ad8:	f800283a 	ret

81129adc <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81129adc:	defffb04 	addi	sp,sp,-20
81129ae0:	de00012e 	bgeu	sp,et,81129ae8 <OSIntExit+0xc>
81129ae4:	003b68fa 	trap	3
81129ae8:	dfc00415 	stw	ra,16(sp)
81129aec:	df000315 	stw	fp,12(sp)
81129af0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81129af4:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81129af8:	d0a07503 	ldbu	r2,-32300(gp)
81129afc:	10803fcc 	andi	r2,r2,255
81129b00:	10800058 	cmpnei	r2,r2,1
81129b04:	10002f1e 	bne	r2,zero,81129bc4 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81129b08:	0005303a 	rdctl	r2,status
81129b0c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129b10:	e0ffff17 	ldw	r3,-4(fp)
81129b14:	00bfff84 	movi	r2,-2
81129b18:	1884703a 	and	r2,r3,r2
81129b1c:	1001703a 	wrctl	status,r2
  
  return context;
81129b20:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81129b24:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81129b28:	d0a08503 	ldbu	r2,-32236(gp)
81129b2c:	10803fcc 	andi	r2,r2,255
81129b30:	10000326 	beq	r2,zero,81129b40 <OSIntExit+0x64>
            OSIntNesting--;
81129b34:	d0a08503 	ldbu	r2,-32236(gp)
81129b38:	10bfffc4 	addi	r2,r2,-1
81129b3c:	d0a08505 	stb	r2,-32236(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81129b40:	d0a08503 	ldbu	r2,-32236(gp)
81129b44:	10803fcc 	andi	r2,r2,255
81129b48:	10001a1e 	bne	r2,zero,81129bb4 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81129b4c:	d0a07303 	ldbu	r2,-32308(gp)
81129b50:	10803fcc 	andi	r2,r2,255
81129b54:	1000171e 	bne	r2,zero,81129bb4 <OSIntExit+0xd8>
                OS_SchedNew();
81129b58:	112ac900 	call	8112ac90 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81129b5c:	d0e07783 	ldbu	r3,-32290(gp)
81129b60:	d0a077c3 	ldbu	r2,-32289(gp)
81129b64:	18c03fcc 	andi	r3,r3,255
81129b68:	10803fcc 	andi	r2,r2,255
81129b6c:	18801126 	beq	r3,r2,81129bb4 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81129b70:	d0a07783 	ldbu	r2,-32290(gp)
81129b74:	10c03fcc 	andi	r3,r2,255
81129b78:	00a04574 	movhi	r2,33045
81129b7c:	10948904 	addi	r2,r2,21028
81129b80:	18c7883a 	add	r3,r3,r3
81129b84:	18c7883a 	add	r3,r3,r3
81129b88:	10c5883a 	add	r2,r2,r3
81129b8c:	10800017 	ldw	r2,0(r2)
81129b90:	d0a08015 	stw	r2,-32256(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81129b94:	d0a08017 	ldw	r2,-32256(gp)
81129b98:	10c00e17 	ldw	r3,56(r2)
81129b9c:	18c00044 	addi	r3,r3,1
81129ba0:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
81129ba4:	d0a07a17 	ldw	r2,-32280(gp)
81129ba8:	10800044 	addi	r2,r2,1
81129bac:	d0a07a15 	stw	r2,-32280(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81129bb0:	113bc240 	call	8113bc24 <OSCtxSw>
81129bb4:	e0bffd17 	ldw	r2,-12(fp)
81129bb8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81129bbc:	e0bffe17 	ldw	r2,-8(fp)
81129bc0:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81129bc4:	0001883a 	nop
81129bc8:	e037883a 	mov	sp,fp
81129bcc:	dfc00117 	ldw	ra,4(sp)
81129bd0:	df000017 	ldw	fp,0(sp)
81129bd4:	dec00204 	addi	sp,sp,8
81129bd8:	f800283a 	ret

81129bdc <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81129bdc:	defffc04 	addi	sp,sp,-16
81129be0:	de00012e 	bgeu	sp,et,81129be8 <OSSchedLock+0xc>
81129be4:	003b68fa 	trap	3
81129be8:	df000315 	stw	fp,12(sp)
81129bec:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81129bf0:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81129bf4:	d0a07503 	ldbu	r2,-32300(gp)
81129bf8:	10803fcc 	andi	r2,r2,255
81129bfc:	10800058 	cmpnei	r2,r2,1
81129c00:	1000161e 	bne	r2,zero,81129c5c <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81129c04:	0005303a 	rdctl	r2,status
81129c08:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129c0c:	e0ffff17 	ldw	r3,-4(fp)
81129c10:	00bfff84 	movi	r2,-2
81129c14:	1884703a 	and	r2,r3,r2
81129c18:	1001703a 	wrctl	status,r2
  
  return context;
81129c1c:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81129c20:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81129c24:	d0a08503 	ldbu	r2,-32236(gp)
81129c28:	10803fcc 	andi	r2,r2,255
81129c2c:	1000071e 	bne	r2,zero,81129c4c <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81129c30:	d0a07303 	ldbu	r2,-32308(gp)
81129c34:	10803fcc 	andi	r2,r2,255
81129c38:	10803fe0 	cmpeqi	r2,r2,255
81129c3c:	1000031e 	bne	r2,zero,81129c4c <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81129c40:	d0a07303 	ldbu	r2,-32308(gp)
81129c44:	10800044 	addi	r2,r2,1
81129c48:	d0a07305 	stb	r2,-32308(gp)
81129c4c:	e0bffd17 	ldw	r2,-12(fp)
81129c50:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81129c54:	e0bffe17 	ldw	r2,-8(fp)
81129c58:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81129c5c:	0001883a 	nop
81129c60:	e037883a 	mov	sp,fp
81129c64:	df000017 	ldw	fp,0(sp)
81129c68:	dec00104 	addi	sp,sp,4
81129c6c:	f800283a 	ret

81129c70 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81129c70:	defff804 	addi	sp,sp,-32
81129c74:	de00012e 	bgeu	sp,et,81129c7c <OSSchedUnlock+0xc>
81129c78:	003b68fa 	trap	3
81129c7c:	dfc00715 	stw	ra,28(sp)
81129c80:	df000615 	stw	fp,24(sp)
81129c84:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81129c88:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81129c8c:	d0a07503 	ldbu	r2,-32300(gp)
81129c90:	10803fcc 	andi	r2,r2,255
81129c94:	10800058 	cmpnei	r2,r2,1
81129c98:	1000281e 	bne	r2,zero,81129d3c <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81129c9c:	0005303a 	rdctl	r2,status
81129ca0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129ca4:	e0ffff17 	ldw	r3,-4(fp)
81129ca8:	00bfff84 	movi	r2,-2
81129cac:	1884703a 	and	r2,r3,r2
81129cb0:	1001703a 	wrctl	status,r2
  
  return context;
81129cb4:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81129cb8:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
81129cbc:	d0a07303 	ldbu	r2,-32308(gp)
81129cc0:	10803fcc 	andi	r2,r2,255
81129cc4:	10001926 	beq	r2,zero,81129d2c <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81129cc8:	d0a07303 	ldbu	r2,-32308(gp)
81129ccc:	10bfffc4 	addi	r2,r2,-1
81129cd0:	d0a07305 	stb	r2,-32308(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
81129cd4:	d0a07303 	ldbu	r2,-32308(gp)
81129cd8:	10803fcc 	andi	r2,r2,255
81129cdc:	10000e1e 	bne	r2,zero,81129d18 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81129ce0:	d0a08503 	ldbu	r2,-32236(gp)
81129ce4:	10803fcc 	andi	r2,r2,255
81129ce8:	1000061e 	bne	r2,zero,81129d04 <OSSchedUnlock+0x94>
81129cec:	e0bffa17 	ldw	r2,-24(fp)
81129cf0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81129cf4:	e0bffb17 	ldw	r2,-20(fp)
81129cf8:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81129cfc:	112abb80 	call	8112abb8 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81129d00:	00000e06 	br	81129d3c <OSSchedUnlock+0xcc>
81129d04:	e0bffa17 	ldw	r2,-24(fp)
81129d08:	e0bffc15 	stw	r2,-16(fp)
81129d0c:	e0bffc17 	ldw	r2,-16(fp)
81129d10:	1001703a 	wrctl	status,r2
81129d14:	00000906 	br	81129d3c <OSSchedUnlock+0xcc>
81129d18:	e0bffa17 	ldw	r2,-24(fp)
81129d1c:	e0bffd15 	stw	r2,-12(fp)
81129d20:	e0bffd17 	ldw	r2,-12(fp)
81129d24:	1001703a 	wrctl	status,r2
81129d28:	00000406 	br	81129d3c <OSSchedUnlock+0xcc>
81129d2c:	e0bffa17 	ldw	r2,-24(fp)
81129d30:	e0bffe15 	stw	r2,-8(fp)
81129d34:	e0bffe17 	ldw	r2,-8(fp)
81129d38:	1001703a 	wrctl	status,r2
81129d3c:	0001883a 	nop
81129d40:	e037883a 	mov	sp,fp
81129d44:	dfc00117 	ldw	ra,4(sp)
81129d48:	df000017 	ldw	fp,0(sp)
81129d4c:	dec00204 	addi	sp,sp,8
81129d50:	f800283a 	ret

81129d54 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
81129d54:	defffe04 	addi	sp,sp,-8
81129d58:	de00012e 	bgeu	sp,et,81129d60 <OSStart+0xc>
81129d5c:	003b68fa 	trap	3
81129d60:	dfc00115 	stw	ra,4(sp)
81129d64:	df000015 	stw	fp,0(sp)
81129d68:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
81129d6c:	d0a07503 	ldbu	r2,-32300(gp)
81129d70:	10803fcc 	andi	r2,r2,255
81129d74:	10000f1e 	bne	r2,zero,81129db4 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81129d78:	112ac900 	call	8112ac90 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
81129d7c:	d0a07783 	ldbu	r2,-32290(gp)
81129d80:	d0a077c5 	stb	r2,-32289(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81129d84:	d0a07783 	ldbu	r2,-32290(gp)
81129d88:	10c03fcc 	andi	r3,r2,255
81129d8c:	00a04574 	movhi	r2,33045
81129d90:	10948904 	addi	r2,r2,21028
81129d94:	18c7883a 	add	r3,r3,r3
81129d98:	18c7883a 	add	r3,r3,r3
81129d9c:	10c5883a 	add	r2,r2,r3
81129da0:	10800017 	ldw	r2,0(r2)
81129da4:	d0a08015 	stw	r2,-32256(gp)
        OSTCBCur      = OSTCBHighRdy;
81129da8:	d0a08017 	ldw	r2,-32256(gp)
81129dac:	d0a08615 	stw	r2,-32232(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
81129db0:	113bcc00 	call	8113bcc0 <OSStartHighRdy>
    }
}
81129db4:	0001883a 	nop
81129db8:	e037883a 	mov	sp,fp
81129dbc:	dfc00117 	ldw	ra,4(sp)
81129dc0:	df000017 	ldw	fp,0(sp)
81129dc4:	dec00204 	addi	sp,sp,8
81129dc8:	f800283a 	ret

81129dcc <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
81129dcc:	defff904 	addi	sp,sp,-28
81129dd0:	de00012e 	bgeu	sp,et,81129dd8 <OSStatInit+0xc>
81129dd4:	003b68fa 	trap	3
81129dd8:	dfc00615 	stw	ra,24(sp)
81129ddc:	df000515 	stw	fp,20(sp)
81129de0:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81129de4:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81129de8:	01000084 	movi	r4,2
81129dec:	11318f40 	call	811318f4 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81129df0:	0005303a 	rdctl	r2,status
81129df4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129df8:	e0fffc17 	ldw	r3,-16(fp)
81129dfc:	00bfff84 	movi	r2,-2
81129e00:	1884703a 	and	r2,r3,r2
81129e04:	1001703a 	wrctl	status,r2
  
  return context;
81129e08:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81129e0c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81129e10:	d0207615 	stw	zero,-32296(gp)
81129e14:	e0bffb17 	ldw	r2,-20(fp)
81129e18:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81129e1c:	e0bffd17 	ldw	r2,-12(fp)
81129e20:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81129e24:	01001904 	movi	r4,100
81129e28:	11318f40 	call	811318f4 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81129e2c:	0005303a 	rdctl	r2,status
81129e30:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129e34:	e0fffe17 	ldw	r3,-8(fp)
81129e38:	00bfff84 	movi	r2,-2
81129e3c:	1884703a 	and	r2,r3,r2
81129e40:	1001703a 	wrctl	status,r2
  
  return context;
81129e44:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
81129e48:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
81129e4c:	d0a07617 	ldw	r2,-32296(gp)
81129e50:	d0a07c15 	stw	r2,-32272(gp)
    OSStatRdy    = OS_TRUE;
81129e54:	00800044 	movi	r2,1
81129e58:	d0a08b05 	stb	r2,-32212(gp)
81129e5c:	e0bffb17 	ldw	r2,-20(fp)
81129e60:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81129e64:	e0bfff17 	ldw	r2,-4(fp)
81129e68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81129e6c:	0001883a 	nop
81129e70:	e037883a 	mov	sp,fp
81129e74:	dfc00117 	ldw	ra,4(sp)
81129e78:	df000017 	ldw	fp,0(sp)
81129e7c:	dec00204 	addi	sp,sp,8
81129e80:	f800283a 	ret

81129e84 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81129e84:	defff704 	addi	sp,sp,-36
81129e88:	de00012e 	bgeu	sp,et,81129e90 <OSTimeTick+0xc>
81129e8c:	003b68fa 	trap	3
81129e90:	dfc00815 	stw	ra,32(sp)
81129e94:	df000715 	stw	fp,28(sp)
81129e98:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81129e9c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
81129ea0:	113bf100 	call	8113bf10 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81129ea4:	0005303a 	rdctl	r2,status
81129ea8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129eac:	e0fffd17 	ldw	r3,-12(fp)
81129eb0:	00bfff84 	movi	r2,-2
81129eb4:	1884703a 	and	r2,r3,r2
81129eb8:	1001703a 	wrctl	status,r2
  
  return context;
81129ebc:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
81129ec0:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
81129ec4:	d0a08817 	ldw	r2,-32224(gp)
81129ec8:	10800044 	addi	r2,r2,1
81129ecc:	d0a08815 	stw	r2,-32224(gp)
81129ed0:	e0bffb17 	ldw	r2,-20(fp)
81129ed4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81129ed8:	e0bfff17 	ldw	r2,-4(fp)
81129edc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
81129ee0:	d0a07503 	ldbu	r2,-32300(gp)
81129ee4:	10803fcc 	andi	r2,r2,255
81129ee8:	10800058 	cmpnei	r2,r2,1
81129eec:	10006a1e 	bne	r2,zero,8112a098 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81129ef0:	d0a07903 	ldbu	r2,-32284(gp)
81129ef4:	10803fcc 	andi	r2,r2,255
81129ef8:	10c00060 	cmpeqi	r3,r2,1
81129efc:	1800061e 	bne	r3,zero,81129f18 <OSTimeTick+0x94>
81129f00:	10c000a0 	cmpeqi	r3,r2,2
81129f04:	1800061e 	bne	r3,zero,81129f20 <OSTimeTick+0x9c>
81129f08:	10000a1e 	bne	r2,zero,81129f34 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81129f0c:	00800044 	movi	r2,1
81129f10:	e0bffa05 	stb	r2,-24(fp)
                 break;
81129f14:	00000b06 	br	81129f44 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81129f18:	e03ffa05 	stb	zero,-24(fp)
                 break;
81129f1c:	00000906 	br	81129f44 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81129f20:	00800044 	movi	r2,1
81129f24:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81129f28:	00800044 	movi	r2,1
81129f2c:	d0a07905 	stb	r2,-32284(gp)
                 break;
81129f30:	00000406 	br	81129f44 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
81129f34:	00800044 	movi	r2,1
81129f38:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
81129f3c:	d0207905 	stb	zero,-32284(gp)
                 break;
81129f40:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
81129f44:	e0bffa03 	ldbu	r2,-24(fp)
81129f48:	10005226 	beq	r2,zero,8112a094 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
81129f4c:	d0a07817 	ldw	r2,-32288(gp)
81129f50:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81129f54:	00004906 	br	8112a07c <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81129f58:	0005303a 	rdctl	r2,status
81129f5c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81129f60:	e0fffc17 	ldw	r3,-16(fp)
81129f64:	00bfff84 	movi	r2,-2
81129f68:	1884703a 	and	r2,r3,r2
81129f6c:	1001703a 	wrctl	status,r2
  
  return context;
81129f70:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81129f74:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
81129f78:	e0bff917 	ldw	r2,-28(fp)
81129f7c:	10800b8b 	ldhu	r2,46(r2)
81129f80:	10bfffcc 	andi	r2,r2,65535
81129f84:	10003626 	beq	r2,zero,8112a060 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
81129f88:	e0bff917 	ldw	r2,-28(fp)
81129f8c:	10800b8b 	ldhu	r2,46(r2)
81129f90:	10bfffc4 	addi	r2,r2,-1
81129f94:	1007883a 	mov	r3,r2
81129f98:	e0bff917 	ldw	r2,-28(fp)
81129f9c:	10c00b8d 	sth	r3,46(r2)
81129fa0:	e0bff917 	ldw	r2,-28(fp)
81129fa4:	10800b8b 	ldhu	r2,46(r2)
81129fa8:	10bfffcc 	andi	r2,r2,65535
81129fac:	10002c1e 	bne	r2,zero,8112a060 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81129fb0:	e0bff917 	ldw	r2,-28(fp)
81129fb4:	10800c03 	ldbu	r2,48(r2)
81129fb8:	10803fcc 	andi	r2,r2,255
81129fbc:	10800dcc 	andi	r2,r2,55
81129fc0:	10000b26 	beq	r2,zero,81129ff0 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81129fc4:	e0bff917 	ldw	r2,-28(fp)
81129fc8:	10c00c03 	ldbu	r3,48(r2)
81129fcc:	00bff204 	movi	r2,-56
81129fd0:	1884703a 	and	r2,r3,r2
81129fd4:	1007883a 	mov	r3,r2
81129fd8:	e0bff917 	ldw	r2,-28(fp)
81129fdc:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
81129fe0:	e0bff917 	ldw	r2,-28(fp)
81129fe4:	00c00044 	movi	r3,1
81129fe8:	10c00c45 	stb	r3,49(r2)
81129fec:	00000206 	br	81129ff8 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81129ff0:	e0bff917 	ldw	r2,-28(fp)
81129ff4:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
81129ff8:	e0bff917 	ldw	r2,-28(fp)
81129ffc:	10800c03 	ldbu	r2,48(r2)
8112a000:	10803fcc 	andi	r2,r2,255
8112a004:	1080020c 	andi	r2,r2,8
8112a008:	1000151e 	bne	r2,zero,8112a060 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
8112a00c:	e0bff917 	ldw	r2,-28(fp)
8112a010:	10c00d83 	ldbu	r3,54(r2)
8112a014:	d0a08203 	ldbu	r2,-32248(gp)
8112a018:	1884b03a 	or	r2,r3,r2
8112a01c:	d0a08205 	stb	r2,-32248(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8112a020:	e0bff917 	ldw	r2,-28(fp)
8112a024:	10800d03 	ldbu	r2,52(r2)
8112a028:	10c03fcc 	andi	r3,r2,255
8112a02c:	e0bff917 	ldw	r2,-28(fp)
8112a030:	10800d03 	ldbu	r2,52(r2)
8112a034:	11003fcc 	andi	r4,r2,255
8112a038:	d0a08244 	addi	r2,gp,-32247
8112a03c:	2085883a 	add	r2,r4,r2
8112a040:	11000003 	ldbu	r4,0(r2)
8112a044:	e0bff917 	ldw	r2,-28(fp)
8112a048:	10800d43 	ldbu	r2,53(r2)
8112a04c:	2084b03a 	or	r2,r4,r2
8112a050:	1009883a 	mov	r4,r2
8112a054:	d0a08244 	addi	r2,gp,-32247
8112a058:	1885883a 	add	r2,r3,r2
8112a05c:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
8112a060:	e0bff917 	ldw	r2,-28(fp)
8112a064:	10800517 	ldw	r2,20(r2)
8112a068:	e0bff915 	stw	r2,-28(fp)
8112a06c:	e0bffb17 	ldw	r2,-20(fp)
8112a070:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112a074:	e0bffe17 	ldw	r2,-8(fp)
8112a078:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8112a07c:	e0bff917 	ldw	r2,-28(fp)
8112a080:	10800c83 	ldbu	r2,50(r2)
8112a084:	10803fcc 	andi	r2,r2,255
8112a088:	10800a18 	cmpnei	r2,r2,40
8112a08c:	103fb21e 	bne	r2,zero,81129f58 <__reset+0xfb109f58>
8112a090:	00000106 	br	8112a098 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
8112a094:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
8112a098:	e037883a 	mov	sp,fp
8112a09c:	dfc00117 	ldw	ra,4(sp)
8112a0a0:	df000017 	ldw	fp,0(sp)
8112a0a4:	dec00204 	addi	sp,sp,8
8112a0a8:	f800283a 	ret

8112a0ac <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
8112a0ac:	deffff04 	addi	sp,sp,-4
8112a0b0:	de00012e 	bgeu	sp,et,8112a0b8 <OSVersion+0xc>
8112a0b4:	003b68fa 	trap	3
8112a0b8:	df000015 	stw	fp,0(sp)
8112a0bc:	d839883a 	mov	fp,sp
    return (OS_VERSION);
8112a0c0:	00804784 	movi	r2,286
}
8112a0c4:	e037883a 	mov	sp,fp
8112a0c8:	df000017 	ldw	fp,0(sp)
8112a0cc:	dec00104 	addi	sp,sp,4
8112a0d0:	f800283a 	ret

8112a0d4 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
8112a0d4:	deffff04 	addi	sp,sp,-4
8112a0d8:	de00012e 	bgeu	sp,et,8112a0e0 <OS_Dummy+0xc>
8112a0dc:	003b68fa 	trap	3
8112a0e0:	df000015 	stw	fp,0(sp)
8112a0e4:	d839883a 	mov	fp,sp
}
8112a0e8:	0001883a 	nop
8112a0ec:	e037883a 	mov	sp,fp
8112a0f0:	df000017 	ldw	fp,0(sp)
8112a0f4:	dec00104 	addi	sp,sp,4
8112a0f8:	f800283a 	ret

8112a0fc <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
8112a0fc:	defff804 	addi	sp,sp,-32
8112a100:	de00012e 	bgeu	sp,et,8112a108 <OS_EventTaskRdy+0xc>
8112a104:	003b68fa 	trap	3
8112a108:	dfc00715 	stw	ra,28(sp)
8112a10c:	df000615 	stw	fp,24(sp)
8112a110:	df000604 	addi	fp,sp,24
8112a114:	e13ffc15 	stw	r4,-16(fp)
8112a118:	e17ffd15 	stw	r5,-12(fp)
8112a11c:	3007883a 	mov	r3,r6
8112a120:	3805883a 	mov	r2,r7
8112a124:	e0fffe05 	stb	r3,-8(fp)
8112a128:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
8112a12c:	e0bffc17 	ldw	r2,-16(fp)
8112a130:	10800283 	ldbu	r2,10(r2)
8112a134:	10c03fcc 	andi	r3,r2,255
8112a138:	00a04534 	movhi	r2,33044
8112a13c:	10be8f04 	addi	r2,r2,-1476
8112a140:	10c5883a 	add	r2,r2,r3
8112a144:	10800003 	ldbu	r2,0(r2)
8112a148:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
8112a14c:	e0bffa03 	ldbu	r2,-24(fp)
8112a150:	e0fffc17 	ldw	r3,-16(fp)
8112a154:	1885883a 	add	r2,r3,r2
8112a158:	108002c4 	addi	r2,r2,11
8112a15c:	10800003 	ldbu	r2,0(r2)
8112a160:	10c03fcc 	andi	r3,r2,255
8112a164:	00a04534 	movhi	r2,33044
8112a168:	10be8f04 	addi	r2,r2,-1476
8112a16c:	10c5883a 	add	r2,r2,r3
8112a170:	10800003 	ldbu	r2,0(r2)
8112a174:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
8112a178:	e0bffa03 	ldbu	r2,-24(fp)
8112a17c:	100490fa 	slli	r2,r2,3
8112a180:	1007883a 	mov	r3,r2
8112a184:	e0bffa43 	ldbu	r2,-23(fp)
8112a188:	1885883a 	add	r2,r3,r2
8112a18c:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
8112a190:	e0fffa83 	ldbu	r3,-22(fp)
8112a194:	00a04574 	movhi	r2,33045
8112a198:	10948904 	addi	r2,r2,21028
8112a19c:	18c7883a 	add	r3,r3,r3
8112a1a0:	18c7883a 	add	r3,r3,r3
8112a1a4:	10c5883a 	add	r2,r2,r3
8112a1a8:	10800017 	ldw	r2,0(r2)
8112a1ac:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
8112a1b0:	e0bffb17 	ldw	r2,-20(fp)
8112a1b4:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
8112a1b8:	e0bffb17 	ldw	r2,-20(fp)
8112a1bc:	e0fffd17 	ldw	r3,-12(fp)
8112a1c0:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
8112a1c4:	e0bffb17 	ldw	r2,-20(fp)
8112a1c8:	10800c03 	ldbu	r2,48(r2)
8112a1cc:	1007883a 	mov	r3,r2
8112a1d0:	e0bffe03 	ldbu	r2,-8(fp)
8112a1d4:	0084303a 	nor	r2,zero,r2
8112a1d8:	1884703a 	and	r2,r3,r2
8112a1dc:	1007883a 	mov	r3,r2
8112a1e0:	e0bffb17 	ldw	r2,-20(fp)
8112a1e4:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
8112a1e8:	e0bffb17 	ldw	r2,-20(fp)
8112a1ec:	e0ffff03 	ldbu	r3,-4(fp)
8112a1f0:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
8112a1f4:	e0bffb17 	ldw	r2,-20(fp)
8112a1f8:	10800c03 	ldbu	r2,48(r2)
8112a1fc:	10803fcc 	andi	r2,r2,255
8112a200:	1080020c 	andi	r2,r2,8
8112a204:	1000111e 	bne	r2,zero,8112a24c <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
8112a208:	e0bffb17 	ldw	r2,-20(fp)
8112a20c:	10c00d83 	ldbu	r3,54(r2)
8112a210:	d0a08203 	ldbu	r2,-32248(gp)
8112a214:	1884b03a 	or	r2,r3,r2
8112a218:	d0a08205 	stb	r2,-32248(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
8112a21c:	e0fffa03 	ldbu	r3,-24(fp)
8112a220:	e13ffa03 	ldbu	r4,-24(fp)
8112a224:	d0a08244 	addi	r2,gp,-32247
8112a228:	2085883a 	add	r2,r4,r2
8112a22c:	11000003 	ldbu	r4,0(r2)
8112a230:	e0bffb17 	ldw	r2,-20(fp)
8112a234:	10800d43 	ldbu	r2,53(r2)
8112a238:	2084b03a 	or	r2,r4,r2
8112a23c:	1009883a 	mov	r4,r2
8112a240:	d0a08244 	addi	r2,gp,-32247
8112a244:	1885883a 	add	r2,r3,r2
8112a248:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
8112a24c:	e17ffc17 	ldw	r5,-16(fp)
8112a250:	e13ffb17 	ldw	r4,-20(fp)
8112a254:	112a50c0 	call	8112a50c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
8112a258:	e0bffb17 	ldw	r2,-20(fp)
8112a25c:	10800817 	ldw	r2,32(r2)
8112a260:	10000826 	beq	r2,zero,8112a284 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8112a264:	e0bffb17 	ldw	r2,-20(fp)
8112a268:	10800817 	ldw	r2,32(r2)
8112a26c:	100b883a 	mov	r5,r2
8112a270:	e13ffb17 	ldw	r4,-20(fp)
8112a274:	112a5cc0 	call	8112a5cc <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
8112a278:	e0bffb17 	ldw	r2,-20(fp)
8112a27c:	e0fffc17 	ldw	r3,-16(fp)
8112a280:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
8112a284:	e0bffa83 	ldbu	r2,-22(fp)
}
8112a288:	e037883a 	mov	sp,fp
8112a28c:	dfc00117 	ldw	ra,4(sp)
8112a290:	df000017 	ldw	fp,0(sp)
8112a294:	dec00204 	addi	sp,sp,8
8112a298:	f800283a 	ret

8112a29c <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
8112a29c:	defffd04 	addi	sp,sp,-12
8112a2a0:	de00012e 	bgeu	sp,et,8112a2a8 <OS_EventTaskWait+0xc>
8112a2a4:	003b68fa 	trap	3
8112a2a8:	df000215 	stw	fp,8(sp)
8112a2ac:	df000204 	addi	fp,sp,8
8112a2b0:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
8112a2b4:	d0a08617 	ldw	r2,-32232(gp)
8112a2b8:	e0ffff17 	ldw	r3,-4(fp)
8112a2bc:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
8112a2c0:	d0a08617 	ldw	r2,-32232(gp)
8112a2c4:	10800d03 	ldbu	r2,52(r2)
8112a2c8:	10803fcc 	andi	r2,r2,255
8112a2cc:	d0e08617 	ldw	r3,-32232(gp)
8112a2d0:	18c00d03 	ldbu	r3,52(r3)
8112a2d4:	18c03fcc 	andi	r3,r3,255
8112a2d8:	e13fff17 	ldw	r4,-4(fp)
8112a2dc:	20c7883a 	add	r3,r4,r3
8112a2e0:	18c002c4 	addi	r3,r3,11
8112a2e4:	19000003 	ldbu	r4,0(r3)
8112a2e8:	d0e08617 	ldw	r3,-32232(gp)
8112a2ec:	18c00d43 	ldbu	r3,53(r3)
8112a2f0:	20c6b03a 	or	r3,r4,r3
8112a2f4:	1809883a 	mov	r4,r3
8112a2f8:	e0ffff17 	ldw	r3,-4(fp)
8112a2fc:	1885883a 	add	r2,r3,r2
8112a300:	108002c4 	addi	r2,r2,11
8112a304:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8112a308:	e0bfff17 	ldw	r2,-4(fp)
8112a30c:	10c00283 	ldbu	r3,10(r2)
8112a310:	d0a08617 	ldw	r2,-32232(gp)
8112a314:	10800d83 	ldbu	r2,54(r2)
8112a318:	1884b03a 	or	r2,r3,r2
8112a31c:	1007883a 	mov	r3,r2
8112a320:	e0bfff17 	ldw	r2,-4(fp)
8112a324:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8112a328:	d0a08617 	ldw	r2,-32232(gp)
8112a32c:	10800d03 	ldbu	r2,52(r2)
8112a330:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8112a334:	e0fffe03 	ldbu	r3,-8(fp)
8112a338:	e13ffe03 	ldbu	r4,-8(fp)
8112a33c:	d0a08244 	addi	r2,gp,-32247
8112a340:	2085883a 	add	r2,r4,r2
8112a344:	10800003 	ldbu	r2,0(r2)
8112a348:	1009883a 	mov	r4,r2
8112a34c:	d0a08617 	ldw	r2,-32232(gp)
8112a350:	10800d43 	ldbu	r2,53(r2)
8112a354:	0084303a 	nor	r2,zero,r2
8112a358:	2084703a 	and	r2,r4,r2
8112a35c:	1009883a 	mov	r4,r2
8112a360:	d0a08244 	addi	r2,gp,-32247
8112a364:	1885883a 	add	r2,r3,r2
8112a368:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8112a36c:	e0fffe03 	ldbu	r3,-8(fp)
8112a370:	d0a08244 	addi	r2,gp,-32247
8112a374:	1885883a 	add	r2,r3,r2
8112a378:	10800003 	ldbu	r2,0(r2)
8112a37c:	10803fcc 	andi	r2,r2,255
8112a380:	1000071e 	bne	r2,zero,8112a3a0 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8112a384:	d0a08617 	ldw	r2,-32232(gp)
8112a388:	10800d83 	ldbu	r2,54(r2)
8112a38c:	0084303a 	nor	r2,zero,r2
8112a390:	1007883a 	mov	r3,r2
8112a394:	d0a08203 	ldbu	r2,-32248(gp)
8112a398:	1884703a 	and	r2,r3,r2
8112a39c:	d0a08205 	stb	r2,-32248(gp)
    }
}
8112a3a0:	0001883a 	nop
8112a3a4:	e037883a 	mov	sp,fp
8112a3a8:	df000017 	ldw	fp,0(sp)
8112a3ac:	dec00104 	addi	sp,sp,4
8112a3b0:	f800283a 	ret

8112a3b4 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
8112a3b4:	defffb04 	addi	sp,sp,-20
8112a3b8:	de00012e 	bgeu	sp,et,8112a3c0 <OS_EventTaskWaitMulti+0xc>
8112a3bc:	003b68fa 	trap	3
8112a3c0:	df000415 	stw	fp,16(sp)
8112a3c4:	df000404 	addi	fp,sp,16
8112a3c8:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
8112a3cc:	d0a08617 	ldw	r2,-32232(gp)
8112a3d0:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
8112a3d4:	d0a08617 	ldw	r2,-32232(gp)
8112a3d8:	e0ffff17 	ldw	r3,-4(fp)
8112a3dc:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
8112a3e0:	e0bfff17 	ldw	r2,-4(fp)
8112a3e4:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
8112a3e8:	e0bffc17 	ldw	r2,-16(fp)
8112a3ec:	10800017 	ldw	r2,0(r2)
8112a3f0:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8112a3f4:	00002006 	br	8112a478 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
8112a3f8:	d0a08617 	ldw	r2,-32232(gp)
8112a3fc:	10800d03 	ldbu	r2,52(r2)
8112a400:	10803fcc 	andi	r2,r2,255
8112a404:	d0e08617 	ldw	r3,-32232(gp)
8112a408:	18c00d03 	ldbu	r3,52(r3)
8112a40c:	18c03fcc 	andi	r3,r3,255
8112a410:	e13ffd17 	ldw	r4,-12(fp)
8112a414:	20c7883a 	add	r3,r4,r3
8112a418:	18c002c4 	addi	r3,r3,11
8112a41c:	19000003 	ldbu	r4,0(r3)
8112a420:	d0e08617 	ldw	r3,-32232(gp)
8112a424:	18c00d43 	ldbu	r3,53(r3)
8112a428:	20c6b03a 	or	r3,r4,r3
8112a42c:	1809883a 	mov	r4,r3
8112a430:	e0fffd17 	ldw	r3,-12(fp)
8112a434:	1885883a 	add	r2,r3,r2
8112a438:	108002c4 	addi	r2,r2,11
8112a43c:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8112a440:	e0bffd17 	ldw	r2,-12(fp)
8112a444:	10c00283 	ldbu	r3,10(r2)
8112a448:	d0a08617 	ldw	r2,-32232(gp)
8112a44c:	10800d83 	ldbu	r2,54(r2)
8112a450:	1884b03a 	or	r2,r3,r2
8112a454:	1007883a 	mov	r3,r2
8112a458:	e0bffd17 	ldw	r2,-12(fp)
8112a45c:	10c00285 	stb	r3,10(r2)
        pevents++;
8112a460:	e0bffc17 	ldw	r2,-16(fp)
8112a464:	10800104 	addi	r2,r2,4
8112a468:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
8112a46c:	e0bffc17 	ldw	r2,-16(fp)
8112a470:	10800017 	ldw	r2,0(r2)
8112a474:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8112a478:	e0bffd17 	ldw	r2,-12(fp)
8112a47c:	103fde1e 	bne	r2,zero,8112a3f8 <__reset+0xfb10a3f8>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8112a480:	d0a08617 	ldw	r2,-32232(gp)
8112a484:	10800d03 	ldbu	r2,52(r2)
8112a488:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8112a48c:	e0fffe03 	ldbu	r3,-8(fp)
8112a490:	e13ffe03 	ldbu	r4,-8(fp)
8112a494:	d0a08244 	addi	r2,gp,-32247
8112a498:	2085883a 	add	r2,r4,r2
8112a49c:	10800003 	ldbu	r2,0(r2)
8112a4a0:	1009883a 	mov	r4,r2
8112a4a4:	d0a08617 	ldw	r2,-32232(gp)
8112a4a8:	10800d43 	ldbu	r2,53(r2)
8112a4ac:	0084303a 	nor	r2,zero,r2
8112a4b0:	2084703a 	and	r2,r4,r2
8112a4b4:	1009883a 	mov	r4,r2
8112a4b8:	d0a08244 	addi	r2,gp,-32247
8112a4bc:	1885883a 	add	r2,r3,r2
8112a4c0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8112a4c4:	e0fffe03 	ldbu	r3,-8(fp)
8112a4c8:	d0a08244 	addi	r2,gp,-32247
8112a4cc:	1885883a 	add	r2,r3,r2
8112a4d0:	10800003 	ldbu	r2,0(r2)
8112a4d4:	10803fcc 	andi	r2,r2,255
8112a4d8:	1000071e 	bne	r2,zero,8112a4f8 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8112a4dc:	d0a08617 	ldw	r2,-32232(gp)
8112a4e0:	10800d83 	ldbu	r2,54(r2)
8112a4e4:	0084303a 	nor	r2,zero,r2
8112a4e8:	1007883a 	mov	r3,r2
8112a4ec:	d0a08203 	ldbu	r2,-32248(gp)
8112a4f0:	1884703a 	and	r2,r3,r2
8112a4f4:	d0a08205 	stb	r2,-32248(gp)
    }
}
8112a4f8:	0001883a 	nop
8112a4fc:	e037883a 	mov	sp,fp
8112a500:	df000017 	ldw	fp,0(sp)
8112a504:	dec00104 	addi	sp,sp,4
8112a508:	f800283a 	ret

8112a50c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
8112a50c:	defffc04 	addi	sp,sp,-16
8112a510:	de00012e 	bgeu	sp,et,8112a518 <OS_EventTaskRemove+0xc>
8112a514:	003b68fa 	trap	3
8112a518:	df000315 	stw	fp,12(sp)
8112a51c:	df000304 	addi	fp,sp,12
8112a520:	e13ffe15 	stw	r4,-8(fp)
8112a524:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
8112a528:	e0bffe17 	ldw	r2,-8(fp)
8112a52c:	10800d03 	ldbu	r2,52(r2)
8112a530:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
8112a534:	e0bffd03 	ldbu	r2,-12(fp)
8112a538:	e0fffd03 	ldbu	r3,-12(fp)
8112a53c:	e13fff17 	ldw	r4,-4(fp)
8112a540:	20c7883a 	add	r3,r4,r3
8112a544:	18c002c4 	addi	r3,r3,11
8112a548:	18c00003 	ldbu	r3,0(r3)
8112a54c:	1809883a 	mov	r4,r3
8112a550:	e0fffe17 	ldw	r3,-8(fp)
8112a554:	18c00d43 	ldbu	r3,53(r3)
8112a558:	00c6303a 	nor	r3,zero,r3
8112a55c:	20c6703a 	and	r3,r4,r3
8112a560:	1809883a 	mov	r4,r3
8112a564:	e0ffff17 	ldw	r3,-4(fp)
8112a568:	1885883a 	add	r2,r3,r2
8112a56c:	108002c4 	addi	r2,r2,11
8112a570:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
8112a574:	e0bffd03 	ldbu	r2,-12(fp)
8112a578:	e0ffff17 	ldw	r3,-4(fp)
8112a57c:	1885883a 	add	r2,r3,r2
8112a580:	108002c4 	addi	r2,r2,11
8112a584:	10800003 	ldbu	r2,0(r2)
8112a588:	10803fcc 	andi	r2,r2,255
8112a58c:	10000a1e 	bne	r2,zero,8112a5b8 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
8112a590:	e0bfff17 	ldw	r2,-4(fp)
8112a594:	10800283 	ldbu	r2,10(r2)
8112a598:	1007883a 	mov	r3,r2
8112a59c:	e0bffe17 	ldw	r2,-8(fp)
8112a5a0:	10800d83 	ldbu	r2,54(r2)
8112a5a4:	0084303a 	nor	r2,zero,r2
8112a5a8:	1884703a 	and	r2,r3,r2
8112a5ac:	1007883a 	mov	r3,r2
8112a5b0:	e0bfff17 	ldw	r2,-4(fp)
8112a5b4:	10c00285 	stb	r3,10(r2)
    }
}
8112a5b8:	0001883a 	nop
8112a5bc:	e037883a 	mov	sp,fp
8112a5c0:	df000017 	ldw	fp,0(sp)
8112a5c4:	dec00104 	addi	sp,sp,4
8112a5c8:	f800283a 	ret

8112a5cc <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
8112a5cc:	defffa04 	addi	sp,sp,-24
8112a5d0:	de00012e 	bgeu	sp,et,8112a5d8 <OS_EventTaskRemoveMulti+0xc>
8112a5d4:	003b68fa 	trap	3
8112a5d8:	df000515 	stw	fp,20(sp)
8112a5dc:	df000504 	addi	fp,sp,20
8112a5e0:	e13ffe15 	stw	r4,-8(fp)
8112a5e4:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
8112a5e8:	e0bffe17 	ldw	r2,-8(fp)
8112a5ec:	10800d03 	ldbu	r2,52(r2)
8112a5f0:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
8112a5f4:	e0bffe17 	ldw	r2,-8(fp)
8112a5f8:	10800d83 	ldbu	r2,54(r2)
8112a5fc:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
8112a600:	e0bffe17 	ldw	r2,-8(fp)
8112a604:	10800d43 	ldbu	r2,53(r2)
8112a608:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
8112a60c:	e0bfff17 	ldw	r2,-4(fp)
8112a610:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
8112a614:	e0bffb17 	ldw	r2,-20(fp)
8112a618:	10800017 	ldw	r2,0(r2)
8112a61c:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8112a620:	00002506 	br	8112a6b8 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
8112a624:	e0bffd03 	ldbu	r2,-12(fp)
8112a628:	e0fffd03 	ldbu	r3,-12(fp)
8112a62c:	e13ffc17 	ldw	r4,-16(fp)
8112a630:	20c7883a 	add	r3,r4,r3
8112a634:	18c002c4 	addi	r3,r3,11
8112a638:	18c00003 	ldbu	r3,0(r3)
8112a63c:	1809883a 	mov	r4,r3
8112a640:	e0fffd83 	ldbu	r3,-10(fp)
8112a644:	00c6303a 	nor	r3,zero,r3
8112a648:	20c6703a 	and	r3,r4,r3
8112a64c:	1809883a 	mov	r4,r3
8112a650:	e0fffc17 	ldw	r3,-16(fp)
8112a654:	1885883a 	add	r2,r3,r2
8112a658:	108002c4 	addi	r2,r2,11
8112a65c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
8112a660:	e0bffd03 	ldbu	r2,-12(fp)
8112a664:	e0fffc17 	ldw	r3,-16(fp)
8112a668:	1885883a 	add	r2,r3,r2
8112a66c:	108002c4 	addi	r2,r2,11
8112a670:	10800003 	ldbu	r2,0(r2)
8112a674:	10803fcc 	andi	r2,r2,255
8112a678:	1000091e 	bne	r2,zero,8112a6a0 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8112a67c:	e0bffc17 	ldw	r2,-16(fp)
8112a680:	10800283 	ldbu	r2,10(r2)
8112a684:	1007883a 	mov	r3,r2
8112a688:	e0bffd43 	ldbu	r2,-11(fp)
8112a68c:	0084303a 	nor	r2,zero,r2
8112a690:	1884703a 	and	r2,r3,r2
8112a694:	1007883a 	mov	r3,r2
8112a698:	e0bffc17 	ldw	r2,-16(fp)
8112a69c:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
8112a6a0:	e0bffb17 	ldw	r2,-20(fp)
8112a6a4:	10800104 	addi	r2,r2,4
8112a6a8:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
8112a6ac:	e0bffb17 	ldw	r2,-20(fp)
8112a6b0:	10800017 	ldw	r2,0(r2)
8112a6b4:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8112a6b8:	e0bffc17 	ldw	r2,-16(fp)
8112a6bc:	103fd91e 	bne	r2,zero,8112a624 <__reset+0xfb10a624>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
8112a6c0:	0001883a 	nop
8112a6c4:	e037883a 	mov	sp,fp
8112a6c8:	df000017 	ldw	fp,0(sp)
8112a6cc:	dec00104 	addi	sp,sp,4
8112a6d0:	f800283a 	ret

8112a6d4 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
8112a6d4:	defffc04 	addi	sp,sp,-16
8112a6d8:	de00012e 	bgeu	sp,et,8112a6e0 <OS_EventWaitListInit+0xc>
8112a6dc:	003b68fa 	trap	3
8112a6e0:	df000315 	stw	fp,12(sp)
8112a6e4:	df000304 	addi	fp,sp,12
8112a6e8:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
8112a6ec:	e0bfff17 	ldw	r2,-4(fp)
8112a6f0:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
8112a6f4:	e0bfff17 	ldw	r2,-4(fp)
8112a6f8:	108002c4 	addi	r2,r2,11
8112a6fc:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112a700:	e03ffe05 	stb	zero,-8(fp)
8112a704:	00000706 	br	8112a724 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
8112a708:	e0bffd17 	ldw	r2,-12(fp)
8112a70c:	10c00044 	addi	r3,r2,1
8112a710:	e0fffd15 	stw	r3,-12(fp)
8112a714:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112a718:	e0bffe03 	ldbu	r2,-8(fp)
8112a71c:	10800044 	addi	r2,r2,1
8112a720:	e0bffe05 	stb	r2,-8(fp)
8112a724:	e0bffe03 	ldbu	r2,-8(fp)
8112a728:	108001b0 	cmpltui	r2,r2,6
8112a72c:	103ff61e 	bne	r2,zero,8112a708 <__reset+0xfb10a708>
        *ptbl++ = 0;
    }
}
8112a730:	0001883a 	nop
8112a734:	e037883a 	mov	sp,fp
8112a738:	df000017 	ldw	fp,0(sp)
8112a73c:	dec00104 	addi	sp,sp,4
8112a740:	f800283a 	ret

8112a744 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
8112a744:	defffb04 	addi	sp,sp,-20
8112a748:	de00012e 	bgeu	sp,et,8112a750 <OS_InitEventList+0xc>
8112a74c:	003b68fa 	trap	3
8112a750:	dfc00415 	stw	ra,16(sp)
8112a754:	df000315 	stw	fp,12(sp)
8112a758:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8112a75c:	01430c04 	movi	r5,3120
8112a760:	01204574 	movhi	r4,33045
8112a764:	210de704 	addi	r4,r4,14236
8112a768:	112aaec0 	call	8112aaec <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8112a76c:	00a04574 	movhi	r2,33045
8112a770:	108de704 	addi	r2,r2,14236
8112a774:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
8112a778:	00a04574 	movhi	r2,33045
8112a77c:	108df404 	addi	r2,r2,14288
8112a780:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8112a784:	e03ffd0d 	sth	zero,-12(fp)
8112a788:	00001306 	br	8112a7d8 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8112a78c:	e0bffe17 	ldw	r2,-8(fp)
8112a790:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
8112a794:	e0bffe17 	ldw	r2,-8(fp)
8112a798:	e0ffff17 	ldw	r3,-4(fp)
8112a79c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
8112a7a0:	e0bffe17 	ldw	r2,-8(fp)
8112a7a4:	00c00fc4 	movi	r3,63
8112a7a8:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
8112a7ac:	e0bffe17 	ldw	r2,-8(fp)
8112a7b0:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
8112a7b4:	e0bffe17 	ldw	r2,-8(fp)
8112a7b8:	10800d04 	addi	r2,r2,52
8112a7bc:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
8112a7c0:	e0bfff17 	ldw	r2,-4(fp)
8112a7c4:	10800d04 	addi	r2,r2,52
8112a7c8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8112a7cc:	e0bffd0b 	ldhu	r2,-12(fp)
8112a7d0:	10800044 	addi	r2,r2,1
8112a7d4:	e0bffd0d 	sth	r2,-12(fp)
8112a7d8:	e0bffd0b 	ldhu	r2,-12(fp)
8112a7dc:	10800ef0 	cmpltui	r2,r2,59
8112a7e0:	103fea1e 	bne	r2,zero,8112a78c <__reset+0xfb10a78c>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
8112a7e4:	e0bffe17 	ldw	r2,-8(fp)
8112a7e8:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
8112a7ec:	e0bffe17 	ldw	r2,-8(fp)
8112a7f0:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
8112a7f4:	e0bffe17 	ldw	r2,-8(fp)
8112a7f8:	00c00fc4 	movi	r3,63
8112a7fc:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
8112a800:	e0bffe17 	ldw	r2,-8(fp)
8112a804:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
8112a808:	00a04574 	movhi	r2,33045
8112a80c:	108de704 	addi	r2,r2,14236
8112a810:	d0a08415 	stw	r2,-32240(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
8112a814:	0001883a 	nop
8112a818:	e037883a 	mov	sp,fp
8112a81c:	dfc00117 	ldw	ra,4(sp)
8112a820:	df000017 	ldw	fp,0(sp)
8112a824:	dec00204 	addi	sp,sp,8
8112a828:	f800283a 	ret

8112a82c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
8112a82c:	deffff04 	addi	sp,sp,-4
8112a830:	de00012e 	bgeu	sp,et,8112a838 <OS_InitMisc+0xc>
8112a834:	003b68fa 	trap	3
8112a838:	df000015 	stw	fp,0(sp)
8112a83c:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
8112a840:	d0208815 	stw	zero,-32224(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
8112a844:	d0208505 	stb	zero,-32236(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
8112a848:	d0207305 	stb	zero,-32308(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
8112a84c:	d0207e45 	stb	zero,-32263(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
8112a850:	d0207505 	stb	zero,-32300(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
8112a854:	d0207a15 	stw	zero,-32280(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
8112a858:	d0207615 	stw	zero,-32296(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8112a85c:	d0208c15 	stw	zero,-32208(gp)
    OSIdleCtrMax  = 0L;
8112a860:	d0207c15 	stw	zero,-32272(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
8112a864:	d0208b05 	stb	zero,-32212(gp)
#endif
}
8112a868:	0001883a 	nop
8112a86c:	e037883a 	mov	sp,fp
8112a870:	df000017 	ldw	fp,0(sp)
8112a874:	dec00104 	addi	sp,sp,4
8112a878:	f800283a 	ret

8112a87c <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8112a87c:	defffd04 	addi	sp,sp,-12
8112a880:	de00012e 	bgeu	sp,et,8112a888 <OS_InitRdyList+0xc>
8112a884:	003b68fa 	trap	3
8112a888:	df000215 	stw	fp,8(sp)
8112a88c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
8112a890:	d0208205 	stb	zero,-32248(gp)
    prdytbl       = &OSRdyTbl[0];
8112a894:	d0a08244 	addi	r2,gp,-32247
8112a898:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8112a89c:	e03ffe05 	stb	zero,-8(fp)
8112a8a0:	00000706 	br	8112a8c0 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
8112a8a4:	e0bfff17 	ldw	r2,-4(fp)
8112a8a8:	10c00044 	addi	r3,r2,1
8112a8ac:	e0ffff15 	stw	r3,-4(fp)
8112a8b0:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8112a8b4:	e0bffe03 	ldbu	r2,-8(fp)
8112a8b8:	10800044 	addi	r2,r2,1
8112a8bc:	e0bffe05 	stb	r2,-8(fp)
8112a8c0:	e0bffe03 	ldbu	r2,-8(fp)
8112a8c4:	108001b0 	cmpltui	r2,r2,6
8112a8c8:	103ff61e 	bne	r2,zero,8112a8a4 <__reset+0xfb10a8a4>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
8112a8cc:	d02077c5 	stb	zero,-32289(gp)
    OSPrioHighRdy = 0;
8112a8d0:	d0207785 	stb	zero,-32290(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
8112a8d4:	d0208015 	stw	zero,-32256(gp)
    OSTCBCur      = (OS_TCB *)0;
8112a8d8:	d0208615 	stw	zero,-32232(gp)
}
8112a8dc:	0001883a 	nop
8112a8e0:	e037883a 	mov	sp,fp
8112a8e4:	df000017 	ldw	fp,0(sp)
8112a8e8:	dec00104 	addi	sp,sp,4
8112a8ec:	f800283a 	ret

8112a8f0 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
8112a8f0:	defff804 	addi	sp,sp,-32
8112a8f4:	de00012e 	bgeu	sp,et,8112a8fc <OS_InitTaskIdle+0xc>
8112a8f8:	003b68fa 	trap	3
8112a8fc:	dfc00715 	stw	ra,28(sp)
8112a900:	df000615 	stw	fp,24(sp)
8112a904:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
8112a908:	008000c4 	movi	r2,3
8112a90c:	d8800415 	stw	r2,16(sp)
8112a910:	d8000315 	stw	zero,12(sp)
8112a914:	00808004 	movi	r2,512
8112a918:	d8800215 	stw	r2,8(sp)
8112a91c:	00a04574 	movhi	r2,33045
8112a920:	108be704 	addi	r2,r2,12188
8112a924:	d8800115 	stw	r2,4(sp)
8112a928:	00bfffd4 	movui	r2,65535
8112a92c:	d8800015 	stw	r2,0(sp)
8112a930:	01c00a04 	movi	r7,40
8112a934:	01a04574 	movhi	r6,33045
8112a938:	318de604 	addi	r6,r6,14232
8112a93c:	000b883a 	mov	r5,zero
8112a940:	012044f4 	movhi	r4,33043
8112a944:	212b7904 	addi	r4,r4,-21020
8112a948:	11307d40 	call	811307d4 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
8112a94c:	e1bfff04 	addi	r6,fp,-4
8112a950:	01604534 	movhi	r5,33044
8112a954:	297ecf04 	addi	r5,r5,-1220
8112a958:	01000a04 	movi	r4,40
8112a95c:	11310040 	call	81131004 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
8112a960:	0001883a 	nop
8112a964:	e037883a 	mov	sp,fp
8112a968:	dfc00117 	ldw	ra,4(sp)
8112a96c:	df000017 	ldw	fp,0(sp)
8112a970:	dec00204 	addi	sp,sp,8
8112a974:	f800283a 	ret

8112a978 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
8112a978:	defff804 	addi	sp,sp,-32
8112a97c:	de00012e 	bgeu	sp,et,8112a984 <OS_InitTaskStat+0xc>
8112a980:	003b68fa 	trap	3
8112a984:	dfc00715 	stw	ra,28(sp)
8112a988:	df000615 	stw	fp,24(sp)
8112a98c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
8112a990:	008000c4 	movi	r2,3
8112a994:	d8800415 	stw	r2,16(sp)
8112a998:	d8000315 	stw	zero,12(sp)
8112a99c:	00808004 	movi	r2,512
8112a9a0:	d8800215 	stw	r2,8(sp)
8112a9a4:	00a04574 	movhi	r2,33045
8112a9a8:	10876f04 	addi	r2,r2,7612
8112a9ac:	d8800115 	stw	r2,4(sp)
8112a9b0:	00bfff94 	movui	r2,65534
8112a9b4:	d8800015 	stw	r2,0(sp)
8112a9b8:	01c009c4 	movi	r7,39
8112a9bc:	01a04574 	movhi	r6,33045
8112a9c0:	31896e04 	addi	r6,r6,9656
8112a9c4:	000b883a 	mov	r5,zero
8112a9c8:	012044f4 	movhi	r4,33043
8112a9cc:	212b9204 	addi	r4,r4,-20920
8112a9d0:	11307d40 	call	811307d4 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
8112a9d4:	e1bfff04 	addi	r6,fp,-4
8112a9d8:	01604534 	movhi	r5,33044
8112a9dc:	297ed304 	addi	r5,r5,-1204
8112a9e0:	010009c4 	movi	r4,39
8112a9e4:	11310040 	call	81131004 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
8112a9e8:	0001883a 	nop
8112a9ec:	e037883a 	mov	sp,fp
8112a9f0:	dfc00117 	ldw	ra,4(sp)
8112a9f4:	df000017 	ldw	fp,0(sp)
8112a9f8:	dec00204 	addi	sp,sp,8
8112a9fc:	f800283a 	ret

8112aa00 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
8112aa00:	defffb04 	addi	sp,sp,-20
8112aa04:	de00012e 	bgeu	sp,et,8112aa0c <OS_InitTCBList+0xc>
8112aa08:	003b68fa 	trap	3
8112aa0c:	dfc00415 	stw	ra,16(sp)
8112aa10:	df000315 	stw	fp,12(sp)
8112aa14:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
8112aa18:	01439604 	movi	r5,3672
8112aa1c:	01204574 	movhi	r4,33045
8112aa20:	2110f304 	addi	r4,r4,17356
8112aa24:	112aaec0 	call	8112aaec <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
8112aa28:	01402904 	movi	r5,164
8112aa2c:	01204574 	movhi	r4,33045
8112aa30:	21148904 	addi	r4,r4,21028
8112aa34:	112aaec0 	call	8112aaec <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
8112aa38:	00a04574 	movhi	r2,33045
8112aa3c:	1090f304 	addi	r2,r2,17356
8112aa40:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
8112aa44:	00a04574 	movhi	r2,33045
8112aa48:	10910e04 	addi	r2,r2,17464
8112aa4c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8112aa50:	e03ffd05 	stb	zero,-12(fp)
8112aa54:	00001106 	br	8112aa9c <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
8112aa58:	e0bffe17 	ldw	r2,-8(fp)
8112aa5c:	e0ffff17 	ldw	r3,-4(fp)
8112aa60:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
8112aa64:	e0bffe17 	ldw	r2,-8(fp)
8112aa68:	00c00fc4 	movi	r3,63
8112aa6c:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8112aa70:	e0bffe17 	ldw	r2,-8(fp)
8112aa74:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
8112aa78:	e0bffe17 	ldw	r2,-8(fp)
8112aa7c:	10801b04 	addi	r2,r2,108
8112aa80:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
8112aa84:	e0bfff17 	ldw	r2,-4(fp)
8112aa88:	10801b04 	addi	r2,r2,108
8112aa8c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8112aa90:	e0bffd03 	ldbu	r2,-12(fp)
8112aa94:	10800044 	addi	r2,r2,1
8112aa98:	e0bffd05 	stb	r2,-12(fp)
8112aa9c:	e0bffd03 	ldbu	r2,-12(fp)
8112aaa0:	10800870 	cmpltui	r2,r2,33
8112aaa4:	103fec1e 	bne	r2,zero,8112aa58 <__reset+0xfb10aa58>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
8112aaa8:	e0bffe17 	ldw	r2,-8(fp)
8112aaac:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
8112aab0:	e0bffe17 	ldw	r2,-8(fp)
8112aab4:	00c00fc4 	movi	r3,63
8112aab8:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8112aabc:	e0bffe17 	ldw	r2,-8(fp)
8112aac0:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
8112aac4:	d0207815 	stw	zero,-32288(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
8112aac8:	00a04574 	movhi	r2,33045
8112aacc:	1090f304 	addi	r2,r2,17356
8112aad0:	d0a07d15 	stw	r2,-32268(gp)
}
8112aad4:	0001883a 	nop
8112aad8:	e037883a 	mov	sp,fp
8112aadc:	dfc00117 	ldw	ra,4(sp)
8112aae0:	df000017 	ldw	fp,0(sp)
8112aae4:	dec00204 	addi	sp,sp,8
8112aae8:	f800283a 	ret

8112aaec <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
8112aaec:	defffd04 	addi	sp,sp,-12
8112aaf0:	de00012e 	bgeu	sp,et,8112aaf8 <OS_MemClr+0xc>
8112aaf4:	003b68fa 	trap	3
8112aaf8:	df000215 	stw	fp,8(sp)
8112aafc:	df000204 	addi	fp,sp,8
8112ab00:	e13ffe15 	stw	r4,-8(fp)
8112ab04:	2805883a 	mov	r2,r5
8112ab08:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8112ab0c:	00000706 	br	8112ab2c <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
8112ab10:	e0bffe17 	ldw	r2,-8(fp)
8112ab14:	10c00044 	addi	r3,r2,1
8112ab18:	e0fffe15 	stw	r3,-8(fp)
8112ab1c:	10000005 	stb	zero,0(r2)
        size--;
8112ab20:	e0bfff0b 	ldhu	r2,-4(fp)
8112ab24:	10bfffc4 	addi	r2,r2,-1
8112ab28:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
8112ab2c:	e0bfff0b 	ldhu	r2,-4(fp)
8112ab30:	103ff71e 	bne	r2,zero,8112ab10 <__reset+0xfb10ab10>
        *pdest++ = (INT8U)0;
        size--;
    }
}
8112ab34:	0001883a 	nop
8112ab38:	e037883a 	mov	sp,fp
8112ab3c:	df000017 	ldw	fp,0(sp)
8112ab40:	dec00104 	addi	sp,sp,4
8112ab44:	f800283a 	ret

8112ab48 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
8112ab48:	defffc04 	addi	sp,sp,-16
8112ab4c:	de00012e 	bgeu	sp,et,8112ab54 <OS_MemCopy+0xc>
8112ab50:	003b68fa 	trap	3
8112ab54:	df000315 	stw	fp,12(sp)
8112ab58:	df000304 	addi	fp,sp,12
8112ab5c:	e13ffd15 	stw	r4,-12(fp)
8112ab60:	e17ffe15 	stw	r5,-8(fp)
8112ab64:	3005883a 	mov	r2,r6
8112ab68:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8112ab6c:	00000b06 	br	8112ab9c <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
8112ab70:	e0bffd17 	ldw	r2,-12(fp)
8112ab74:	10c00044 	addi	r3,r2,1
8112ab78:	e0fffd15 	stw	r3,-12(fp)
8112ab7c:	e0fffe17 	ldw	r3,-8(fp)
8112ab80:	19000044 	addi	r4,r3,1
8112ab84:	e13ffe15 	stw	r4,-8(fp)
8112ab88:	18c00003 	ldbu	r3,0(r3)
8112ab8c:	10c00005 	stb	r3,0(r2)
        size--;
8112ab90:	e0bfff0b 	ldhu	r2,-4(fp)
8112ab94:	10bfffc4 	addi	r2,r2,-1
8112ab98:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
8112ab9c:	e0bfff0b 	ldhu	r2,-4(fp)
8112aba0:	103ff31e 	bne	r2,zero,8112ab70 <__reset+0xfb10ab70>
        *pdest++ = *psrc++;
        size--;
    }
}
8112aba4:	0001883a 	nop
8112aba8:	e037883a 	mov	sp,fp
8112abac:	df000017 	ldw	fp,0(sp)
8112abb0:	dec00104 	addi	sp,sp,4
8112abb4:	f800283a 	ret

8112abb8 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
8112abb8:	defffb04 	addi	sp,sp,-20
8112abbc:	de00012e 	bgeu	sp,et,8112abc4 <OS_Sched+0xc>
8112abc0:	003b68fa 	trap	3
8112abc4:	dfc00415 	stw	ra,16(sp)
8112abc8:	df000315 	stw	fp,12(sp)
8112abcc:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8112abd0:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112abd4:	0005303a 	rdctl	r2,status
8112abd8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112abdc:	e0ffff17 	ldw	r3,-4(fp)
8112abe0:	00bfff84 	movi	r2,-2
8112abe4:	1884703a 	and	r2,r3,r2
8112abe8:	1001703a 	wrctl	status,r2
  
  return context;
8112abec:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
8112abf0:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
8112abf4:	d0a08503 	ldbu	r2,-32236(gp)
8112abf8:	10803fcc 	andi	r2,r2,255
8112abfc:	10001a1e 	bne	r2,zero,8112ac68 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
8112ac00:	d0a07303 	ldbu	r2,-32308(gp)
8112ac04:	10803fcc 	andi	r2,r2,255
8112ac08:	1000171e 	bne	r2,zero,8112ac68 <OS_Sched+0xb0>
            OS_SchedNew();
8112ac0c:	112ac900 	call	8112ac90 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
8112ac10:	d0e07783 	ldbu	r3,-32290(gp)
8112ac14:	d0a077c3 	ldbu	r2,-32289(gp)
8112ac18:	18c03fcc 	andi	r3,r3,255
8112ac1c:	10803fcc 	andi	r2,r2,255
8112ac20:	18801126 	beq	r3,r2,8112ac68 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
8112ac24:	d0a07783 	ldbu	r2,-32290(gp)
8112ac28:	10c03fcc 	andi	r3,r2,255
8112ac2c:	00a04574 	movhi	r2,33045
8112ac30:	10948904 	addi	r2,r2,21028
8112ac34:	18c7883a 	add	r3,r3,r3
8112ac38:	18c7883a 	add	r3,r3,r3
8112ac3c:	10c5883a 	add	r2,r2,r3
8112ac40:	10800017 	ldw	r2,0(r2)
8112ac44:	d0a08015 	stw	r2,-32256(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
8112ac48:	d0a08017 	ldw	r2,-32256(gp)
8112ac4c:	10c00e17 	ldw	r3,56(r2)
8112ac50:	18c00044 	addi	r3,r3,1
8112ac54:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
8112ac58:	d0a07a17 	ldw	r2,-32280(gp)
8112ac5c:	10800044 	addi	r2,r2,1
8112ac60:	d0a07a15 	stw	r2,-32280(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
8112ac64:	113bc240 	call	8113bc24 <OSCtxSw>
8112ac68:	e0bffd17 	ldw	r2,-12(fp)
8112ac6c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ac70:	e0bffe17 	ldw	r2,-8(fp)
8112ac74:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
8112ac78:	0001883a 	nop
8112ac7c:	e037883a 	mov	sp,fp
8112ac80:	dfc00117 	ldw	ra,4(sp)
8112ac84:	df000017 	ldw	fp,0(sp)
8112ac88:	dec00204 	addi	sp,sp,8
8112ac8c:	f800283a 	ret

8112ac90 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
8112ac90:	defffe04 	addi	sp,sp,-8
8112ac94:	de00012e 	bgeu	sp,et,8112ac9c <OS_SchedNew+0xc>
8112ac98:	003b68fa 	trap	3
8112ac9c:	df000115 	stw	fp,4(sp)
8112aca0:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
8112aca4:	d0a08203 	ldbu	r2,-32248(gp)
8112aca8:	10c03fcc 	andi	r3,r2,255
8112acac:	00a04534 	movhi	r2,33044
8112acb0:	10be8f04 	addi	r2,r2,-1476
8112acb4:	10c5883a 	add	r2,r2,r3
8112acb8:	10800003 	ldbu	r2,0(r2)
8112acbc:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
8112acc0:	e0bfff03 	ldbu	r2,-4(fp)
8112acc4:	100490fa 	slli	r2,r2,3
8112acc8:	1009883a 	mov	r4,r2
8112accc:	e0ffff03 	ldbu	r3,-4(fp)
8112acd0:	d0a08244 	addi	r2,gp,-32247
8112acd4:	1885883a 	add	r2,r3,r2
8112acd8:	10800003 	ldbu	r2,0(r2)
8112acdc:	10c03fcc 	andi	r3,r2,255
8112ace0:	00a04534 	movhi	r2,33044
8112ace4:	10be8f04 	addi	r2,r2,-1476
8112ace8:	10c5883a 	add	r2,r2,r3
8112acec:	10800003 	ldbu	r2,0(r2)
8112acf0:	2085883a 	add	r2,r4,r2
8112acf4:	d0a07785 	stb	r2,-32290(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
8112acf8:	0001883a 	nop
8112acfc:	e037883a 	mov	sp,fp
8112ad00:	df000017 	ldw	fp,0(sp)
8112ad04:	dec00104 	addi	sp,sp,4
8112ad08:	f800283a 	ret

8112ad0c <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
8112ad0c:	defffc04 	addi	sp,sp,-16
8112ad10:	de00012e 	bgeu	sp,et,8112ad18 <OS_StrCopy+0xc>
8112ad14:	003b68fa 	trap	3
8112ad18:	df000315 	stw	fp,12(sp)
8112ad1c:	df000304 	addi	fp,sp,12
8112ad20:	e13ffe15 	stw	r4,-8(fp)
8112ad24:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
8112ad28:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
8112ad2c:	00000b06 	br	8112ad5c <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
8112ad30:	e0bffe17 	ldw	r2,-8(fp)
8112ad34:	10c00044 	addi	r3,r2,1
8112ad38:	e0fffe15 	stw	r3,-8(fp)
8112ad3c:	e0ffff17 	ldw	r3,-4(fp)
8112ad40:	19000044 	addi	r4,r3,1
8112ad44:	e13fff15 	stw	r4,-4(fp)
8112ad48:	18c00003 	ldbu	r3,0(r3)
8112ad4c:	10c00005 	stb	r3,0(r2)
        len++;
8112ad50:	e0bffd03 	ldbu	r2,-12(fp)
8112ad54:	10800044 	addi	r2,r2,1
8112ad58:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8112ad5c:	e0bfff17 	ldw	r2,-4(fp)
8112ad60:	10800003 	ldbu	r2,0(r2)
8112ad64:	10803fcc 	andi	r2,r2,255
8112ad68:	103ff11e 	bne	r2,zero,8112ad30 <__reset+0xfb10ad30>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
8112ad6c:	e0bffe17 	ldw	r2,-8(fp)
8112ad70:	10000005 	stb	zero,0(r2)
    return (len);
8112ad74:	e0bffd03 	ldbu	r2,-12(fp)
}
8112ad78:	e037883a 	mov	sp,fp
8112ad7c:	df000017 	ldw	fp,0(sp)
8112ad80:	dec00104 	addi	sp,sp,4
8112ad84:	f800283a 	ret

8112ad88 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
8112ad88:	defffd04 	addi	sp,sp,-12
8112ad8c:	de00012e 	bgeu	sp,et,8112ad94 <OS_StrLen+0xc>
8112ad90:	003b68fa 	trap	3
8112ad94:	df000215 	stw	fp,8(sp)
8112ad98:	df000204 	addi	fp,sp,8
8112ad9c:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
8112ada0:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
8112ada4:	00000606 	br	8112adc0 <OS_StrLen+0x38>
        psrc++;
8112ada8:	e0bfff17 	ldw	r2,-4(fp)
8112adac:	10800044 	addi	r2,r2,1
8112adb0:	e0bfff15 	stw	r2,-4(fp)
        len++;
8112adb4:	e0bffe03 	ldbu	r2,-8(fp)
8112adb8:	10800044 	addi	r2,r2,1
8112adbc:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8112adc0:	e0bfff17 	ldw	r2,-4(fp)
8112adc4:	10800003 	ldbu	r2,0(r2)
8112adc8:	10803fcc 	andi	r2,r2,255
8112adcc:	103ff61e 	bne	r2,zero,8112ada8 <__reset+0xfb10ada8>
        psrc++;
        len++;
    }
    return (len);
8112add0:	e0bffe03 	ldbu	r2,-8(fp)
}
8112add4:	e037883a 	mov	sp,fp
8112add8:	df000017 	ldw	fp,0(sp)
8112addc:	dec00104 	addi	sp,sp,4
8112ade0:	f800283a 	ret

8112ade4 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
8112ade4:	defffa04 	addi	sp,sp,-24
8112ade8:	de00012e 	bgeu	sp,et,8112adf0 <OS_TaskIdle+0xc>
8112adec:	003b68fa 	trap	3
8112adf0:	dfc00515 	stw	ra,20(sp)
8112adf4:	df000415 	stw	fp,16(sp)
8112adf8:	df000404 	addi	fp,sp,16
8112adfc:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112ae00:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ae04:	0005303a 	rdctl	r2,status
8112ae08:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ae0c:	e0fffd17 	ldw	r3,-12(fp)
8112ae10:	00bfff84 	movi	r2,-2
8112ae14:	1884703a 	and	r2,r3,r2
8112ae18:	1001703a 	wrctl	status,r2
  
  return context;
8112ae1c:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
8112ae20:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
8112ae24:	d0a07617 	ldw	r2,-32296(gp)
8112ae28:	10800044 	addi	r2,r2,1
8112ae2c:	d0a07615 	stw	r2,-32296(gp)
8112ae30:	e0bffc17 	ldw	r2,-16(fp)
8112ae34:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ae38:	e0bffe17 	ldw	r2,-8(fp)
8112ae3c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
8112ae40:	113bfb80 	call	8113bfb8 <OSTaskIdleHook>
    }
8112ae44:	003fef06 	br	8112ae04 <__reset+0xfb10ae04>

8112ae48 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
8112ae48:	defff804 	addi	sp,sp,-32
8112ae4c:	de00012e 	bgeu	sp,et,8112ae54 <OS_TaskStat+0xc>
8112ae50:	003b68fa 	trap	3
8112ae54:	dfc00715 	stw	ra,28(sp)
8112ae58:	df000615 	stw	fp,24(sp)
8112ae5c:	dc400515 	stw	r17,20(sp)
8112ae60:	dc000415 	stw	r16,16(sp)
8112ae64:	df000604 	addi	fp,sp,24
8112ae68:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112ae6c:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8112ae70:	00000206 	br	8112ae7c <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
8112ae74:	01003204 	movi	r4,200
8112ae78:	11318f40 	call	811318f4 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8112ae7c:	d0a08b03 	ldbu	r2,-32212(gp)
8112ae80:	10803fcc 	andi	r2,r2,255
8112ae84:	103ffb26 	beq	r2,zero,8112ae74 <__reset+0xfb10ae74>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
8112ae88:	d0e07c17 	ldw	r3,-32272(gp)
8112ae8c:	00947b34 	movhi	r2,20972
8112ae90:	10a147c4 	addi	r2,r2,-31457
8112ae94:	1888383a 	mulxuu	r4,r3,r2
8112ae98:	1885383a 	mul	r2,r3,r2
8112ae9c:	1021883a 	mov	r16,r2
8112aea0:	2023883a 	mov	r17,r4
8112aea4:	8804d17a 	srli	r2,r17,5
8112aea8:	d0a07c15 	stw	r2,-32272(gp)
    if (OSIdleCtrMax == 0L) {
8112aeac:	d0a07c17 	ldw	r2,-32272(gp)
8112aeb0:	1000031e 	bne	r2,zero,8112aec0 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
8112aeb4:	d0207e05 	stb	zero,-32264(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
8112aeb8:	01003fc4 	movi	r4,255
8112aebc:	11315640 	call	81131564 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112aec0:	0005303a 	rdctl	r2,status
8112aec4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112aec8:	e0fffb17 	ldw	r3,-20(fp)
8112aecc:	00bfff84 	movi	r2,-2
8112aed0:	1884703a 	and	r2,r3,r2
8112aed4:	1001703a 	wrctl	status,r2
  
  return context;
8112aed8:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
8112aedc:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
8112aee0:	d0a07617 	ldw	r2,-32296(gp)
8112aee4:	d0a08c15 	stw	r2,-32208(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
8112aee8:	d0207615 	stw	zero,-32296(gp)
8112aeec:	e0bffa17 	ldw	r2,-24(fp)
8112aef0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112aef4:	e0bffc17 	ldw	r2,-16(fp)
8112aef8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
8112aefc:	d0e08c17 	ldw	r3,-32208(gp)
8112af00:	d0a07c17 	ldw	r2,-32272(gp)
8112af04:	1885203a 	divu	r2,r3,r2
8112af08:	1007883a 	mov	r3,r2
8112af0c:	00801904 	movi	r2,100
8112af10:	10c5c83a 	sub	r2,r2,r3
8112af14:	d0a07e05 	stb	r2,-32264(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
8112af18:	113bee80 	call	8113bee8 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
8112af1c:	112af2c0 	call	8112af2c <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
8112af20:	01001904 	movi	r4,100
8112af24:	11318f40 	call	811318f4 <OSTimeDly>
    }
8112af28:	003fe506 	br	8112aec0 <__reset+0xfb10aec0>

8112af2c <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
8112af2c:	defffa04 	addi	sp,sp,-24
8112af30:	de00012e 	bgeu	sp,et,8112af38 <OS_TaskStatStkChk+0xc>
8112af34:	003b68fa 	trap	3
8112af38:	dfc00515 	stw	ra,20(sp)
8112af3c:	df000415 	stw	fp,16(sp)
8112af40:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8112af44:	e03ffc05 	stb	zero,-16(fp)
8112af48:	00002406 	br	8112afdc <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
8112af4c:	e0bffc03 	ldbu	r2,-16(fp)
8112af50:	e0fffe04 	addi	r3,fp,-8
8112af54:	180b883a 	mov	r5,r3
8112af58:	1009883a 	mov	r4,r2
8112af5c:	113139c0 	call	8113139c <OSTaskStkChk>
8112af60:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
8112af64:	e0bffc43 	ldbu	r2,-15(fp)
8112af68:	1000191e 	bne	r2,zero,8112afd0 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
8112af6c:	e0fffc03 	ldbu	r3,-16(fp)
8112af70:	00a04574 	movhi	r2,33045
8112af74:	10948904 	addi	r2,r2,21028
8112af78:	18c7883a 	add	r3,r3,r3
8112af7c:	18c7883a 	add	r3,r3,r3
8112af80:	10c5883a 	add	r2,r2,r3
8112af84:	10800017 	ldw	r2,0(r2)
8112af88:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8112af8c:	e0bffd17 	ldw	r2,-12(fp)
8112af90:	10000f26 	beq	r2,zero,8112afd0 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
8112af94:	e0bffd17 	ldw	r2,-12(fp)
8112af98:	10800060 	cmpeqi	r2,r2,1
8112af9c:	10000c1e 	bne	r2,zero,8112afd0 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
8112afa0:	e0bffd17 	ldw	r2,-12(fp)
8112afa4:	10c00217 	ldw	r3,8(r2)
8112afa8:	e0bffd17 	ldw	r2,-12(fp)
8112afac:	10800317 	ldw	r2,12(r2)
8112afb0:	1085883a 	add	r2,r2,r2
8112afb4:	1085883a 	add	r2,r2,r2
8112afb8:	1887883a 	add	r3,r3,r2
8112afbc:	e0bffd17 	ldw	r2,-12(fp)
8112afc0:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
8112afc4:	e0ffff17 	ldw	r3,-4(fp)
8112afc8:	e0bffd17 	ldw	r2,-12(fp)
8112afcc:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8112afd0:	e0bffc03 	ldbu	r2,-16(fp)
8112afd4:	10800044 	addi	r2,r2,1
8112afd8:	e0bffc05 	stb	r2,-16(fp)
8112afdc:	e0bffc03 	ldbu	r2,-16(fp)
8112afe0:	10800a70 	cmpltui	r2,r2,41
8112afe4:	103fd91e 	bne	r2,zero,8112af4c <__reset+0xfb10af4c>
#endif
                }
            }
        }
    }
}
8112afe8:	0001883a 	nop
8112afec:	e037883a 	mov	sp,fp
8112aff0:	dfc00117 	ldw	ra,4(sp)
8112aff4:	df000017 	ldw	fp,0(sp)
8112aff8:	dec00204 	addi	sp,sp,8
8112affc:	f800283a 	ret

8112b000 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
8112b000:	defff204 	addi	sp,sp,-56
8112b004:	de00012e 	bgeu	sp,et,8112b00c <OS_TCBInit+0xc>
8112b008:	003b68fa 	trap	3
8112b00c:	dfc00d15 	stw	ra,52(sp)
8112b010:	df000c15 	stw	fp,48(sp)
8112b014:	df000c04 	addi	fp,sp,48
8112b018:	e17ffc15 	stw	r5,-16(fp)
8112b01c:	e1bffd15 	stw	r6,-12(fp)
8112b020:	3807883a 	mov	r3,r7
8112b024:	e0800417 	ldw	r2,16(fp)
8112b028:	e13ffb05 	stb	r4,-20(fp)
8112b02c:	e0fffe0d 	sth	r3,-8(fp)
8112b030:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112b034:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112b038:	0005303a 	rdctl	r2,status
8112b03c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112b040:	e0fffa17 	ldw	r3,-24(fp)
8112b044:	00bfff84 	movi	r2,-2
8112b048:	1884703a 	and	r2,r3,r2
8112b04c:	1001703a 	wrctl	status,r2
  
  return context;
8112b050:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
8112b054:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
8112b058:	d0a07d17 	ldw	r2,-32268(gp)
8112b05c:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
8112b060:	e0bff617 	ldw	r2,-40(fp)
8112b064:	10009326 	beq	r2,zero,8112b2b4 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
8112b068:	e0bff617 	ldw	r2,-40(fp)
8112b06c:	10800517 	ldw	r2,20(r2)
8112b070:	d0a07d15 	stw	r2,-32268(gp)
8112b074:	e0bff417 	ldw	r2,-48(fp)
8112b078:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112b07c:	e0bff817 	ldw	r2,-32(fp)
8112b080:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
8112b084:	e0bff617 	ldw	r2,-40(fp)
8112b088:	e0fffc17 	ldw	r3,-16(fp)
8112b08c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
8112b090:	e0bff617 	ldw	r2,-40(fp)
8112b094:	e0fffb03 	ldbu	r3,-20(fp)
8112b098:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
8112b09c:	e0bff617 	ldw	r2,-40(fp)
8112b0a0:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
8112b0a4:	e0bff617 	ldw	r2,-40(fp)
8112b0a8:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
8112b0ac:	e0bff617 	ldw	r2,-40(fp)
8112b0b0:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
8112b0b4:	e0bff617 	ldw	r2,-40(fp)
8112b0b8:	e0c00317 	ldw	r3,12(fp)
8112b0bc:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
8112b0c0:	e0bff617 	ldw	r2,-40(fp)
8112b0c4:	e0c00217 	ldw	r3,8(fp)
8112b0c8:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
8112b0cc:	e0bff617 	ldw	r2,-40(fp)
8112b0d0:	e0fffd17 	ldw	r3,-12(fp)
8112b0d4:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
8112b0d8:	e0bff617 	ldw	r2,-40(fp)
8112b0dc:	e0ffff0b 	ldhu	r3,-4(fp)
8112b0e0:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
8112b0e4:	e0bff617 	ldw	r2,-40(fp)
8112b0e8:	e0fffe0b 	ldhu	r3,-8(fp)
8112b0ec:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
8112b0f0:	e0bff617 	ldw	r2,-40(fp)
8112b0f4:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
8112b0f8:	e0bffb03 	ldbu	r2,-20(fp)
8112b0fc:	1004d0fa 	srli	r2,r2,3
8112b100:	1007883a 	mov	r3,r2
8112b104:	e0bff617 	ldw	r2,-40(fp)
8112b108:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
8112b10c:	e0bffb03 	ldbu	r2,-20(fp)
8112b110:	108001cc 	andi	r2,r2,7
8112b114:	1007883a 	mov	r3,r2
8112b118:	e0bff617 	ldw	r2,-40(fp)
8112b11c:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
8112b120:	e0bff617 	ldw	r2,-40(fp)
8112b124:	10800d03 	ldbu	r2,52(r2)
8112b128:	10803fcc 	andi	r2,r2,255
8112b12c:	00c00044 	movi	r3,1
8112b130:	1884983a 	sll	r2,r3,r2
8112b134:	1007883a 	mov	r3,r2
8112b138:	e0bff617 	ldw	r2,-40(fp)
8112b13c:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
8112b140:	e0bff617 	ldw	r2,-40(fp)
8112b144:	10800cc3 	ldbu	r2,51(r2)
8112b148:	10803fcc 	andi	r2,r2,255
8112b14c:	00c00044 	movi	r3,1
8112b150:	1884983a 	sll	r2,r3,r2
8112b154:	1007883a 	mov	r3,r2
8112b158:	e0bff617 	ldw	r2,-40(fp)
8112b15c:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
8112b160:	e0bff617 	ldw	r2,-40(fp)
8112b164:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
8112b168:	e0bff617 	ldw	r2,-40(fp)
8112b16c:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
8112b170:	e0bff617 	ldw	r2,-40(fp)
8112b174:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
8112b178:	e0bff617 	ldw	r2,-40(fp)
8112b17c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
8112b180:	e0bff617 	ldw	r2,-40(fp)
8112b184:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
8112b188:	e0bff617 	ldw	r2,-40(fp)
8112b18c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
8112b190:	e0bff617 	ldw	r2,-40(fp)
8112b194:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
8112b198:	e0bff617 	ldw	r2,-40(fp)
8112b19c:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
8112b1a0:	e0bff617 	ldw	r2,-40(fp)
8112b1a4:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
8112b1a8:	e0bff617 	ldw	r2,-40(fp)
8112b1ac:	00c00fc4 	movi	r3,63
8112b1b0:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8112b1b4:	e0bff617 	ldw	r2,-40(fp)
8112b1b8:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
8112b1bc:	e13ff617 	ldw	r4,-40(fp)
8112b1c0:	113bfe00 	call	8113bfe0 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
8112b1c4:	e13ff617 	ldw	r4,-40(fp)
8112b1c8:	113be680 	call	8113be68 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112b1cc:	0005303a 	rdctl	r2,status
8112b1d0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112b1d4:	e0fff517 	ldw	r3,-44(fp)
8112b1d8:	00bfff84 	movi	r2,-2
8112b1dc:	1884703a 	and	r2,r3,r2
8112b1e0:	1001703a 	wrctl	status,r2
  
  return context;
8112b1e4:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
8112b1e8:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8112b1ec:	e0fffb03 	ldbu	r3,-20(fp)
8112b1f0:	00a04574 	movhi	r2,33045
8112b1f4:	10948904 	addi	r2,r2,21028
8112b1f8:	18c7883a 	add	r3,r3,r3
8112b1fc:	18c7883a 	add	r3,r3,r3
8112b200:	10c5883a 	add	r2,r2,r3
8112b204:	e0fff617 	ldw	r3,-40(fp)
8112b208:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8112b20c:	d0e07817 	ldw	r3,-32288(gp)
8112b210:	e0bff617 	ldw	r2,-40(fp)
8112b214:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
8112b218:	e0bff617 	ldw	r2,-40(fp)
8112b21c:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
8112b220:	d0a07817 	ldw	r2,-32288(gp)
8112b224:	10000326 	beq	r2,zero,8112b234 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
8112b228:	d0a07817 	ldw	r2,-32288(gp)
8112b22c:	e0fff617 	ldw	r3,-40(fp)
8112b230:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
8112b234:	e0bff617 	ldw	r2,-40(fp)
8112b238:	d0a07815 	stw	r2,-32288(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
8112b23c:	e0bff617 	ldw	r2,-40(fp)
8112b240:	10c00d83 	ldbu	r3,54(r2)
8112b244:	d0a08203 	ldbu	r2,-32248(gp)
8112b248:	1884b03a 	or	r2,r3,r2
8112b24c:	d0a08205 	stb	r2,-32248(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8112b250:	e0bff617 	ldw	r2,-40(fp)
8112b254:	10800d03 	ldbu	r2,52(r2)
8112b258:	10c03fcc 	andi	r3,r2,255
8112b25c:	e0bff617 	ldw	r2,-40(fp)
8112b260:	10800d03 	ldbu	r2,52(r2)
8112b264:	11003fcc 	andi	r4,r2,255
8112b268:	d0a08244 	addi	r2,gp,-32247
8112b26c:	2085883a 	add	r2,r4,r2
8112b270:	11000003 	ldbu	r4,0(r2)
8112b274:	e0bff617 	ldw	r2,-40(fp)
8112b278:	10800d43 	ldbu	r2,53(r2)
8112b27c:	2084b03a 	or	r2,r4,r2
8112b280:	1009883a 	mov	r4,r2
8112b284:	d0a08244 	addi	r2,gp,-32247
8112b288:	1885883a 	add	r2,r3,r2
8112b28c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
8112b290:	d0a07e43 	ldbu	r2,-32263(gp)
8112b294:	10800044 	addi	r2,r2,1
8112b298:	d0a07e45 	stb	r2,-32263(gp)
8112b29c:	e0bff417 	ldw	r2,-48(fp)
8112b2a0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112b2a4:	e0bff717 	ldw	r2,-36(fp)
8112b2a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8112b2ac:	0005883a 	mov	r2,zero
8112b2b0:	00000506 	br	8112b2c8 <OS_TCBInit+0x2c8>
8112b2b4:	e0bff417 	ldw	r2,-48(fp)
8112b2b8:	e0bff915 	stw	r2,-28(fp)
8112b2bc:	e0bff917 	ldw	r2,-28(fp)
8112b2c0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
8112b2c4:	00801084 	movi	r2,66
}
8112b2c8:	e037883a 	mov	sp,fp
8112b2cc:	dfc00117 	ldw	ra,4(sp)
8112b2d0:	df000017 	ldw	fp,0(sp)
8112b2d4:	dec00204 	addi	sp,sp,8
8112b2d8:	f800283a 	ret

8112b2dc <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
8112b2dc:	defffe04 	addi	sp,sp,-8
8112b2e0:	de00012e 	bgeu	sp,et,8112b2e8 <OSDebugInit+0xc>
8112b2e4:	003b68fa 	trap	3
8112b2e8:	df000115 	stw	fp,4(sp)
8112b2ec:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
8112b2f0:	d0a01704 	addi	r2,gp,-32676
8112b2f4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
8112b2f8:	d0a01804 	addi	r2,gp,-32672
8112b2fc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
8112b300:	d0a01984 	addi	r2,gp,-32666
8112b304:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
8112b308:	d0a01a04 	addi	r2,gp,-32664
8112b30c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
8112b310:	d0a01904 	addi	r2,gp,-32668
8112b314:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
8112b318:	d0a01a84 	addi	r2,gp,-32662
8112b31c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
8112b320:	d0a01b04 	addi	r2,gp,-32660
8112b324:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
8112b328:	d0a01b84 	addi	r2,gp,-32658
8112b32c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
8112b330:	d0a01c04 	addi	r2,gp,-32656
8112b334:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
8112b338:	d0a01c84 	addi	r2,gp,-32654
8112b33c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
8112b340:	d0a01d04 	addi	r2,gp,-32652
8112b344:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
8112b348:	d0a01d84 	addi	r2,gp,-32650
8112b34c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
8112b350:	d0a01e04 	addi	r2,gp,-32648
8112b354:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
8112b358:	d0a01e84 	addi	r2,gp,-32646
8112b35c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
8112b360:	d0a01f04 	addi	r2,gp,-32644
8112b364:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
8112b368:	d0a01f84 	addi	r2,gp,-32642
8112b36c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
8112b370:	d0a02004 	addi	r2,gp,-32640
8112b374:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
8112b378:	d0a02084 	addi	r2,gp,-32638
8112b37c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
8112b380:	d0a02104 	addi	r2,gp,-32636
8112b384:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
8112b388:	d0a02184 	addi	r2,gp,-32634
8112b38c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
8112b390:	d0a02204 	addi	r2,gp,-32632
8112b394:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
8112b398:	d0a02284 	addi	r2,gp,-32630
8112b39c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
8112b3a0:	d0a02304 	addi	r2,gp,-32628
8112b3a4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
8112b3a8:	d0a02384 	addi	r2,gp,-32626
8112b3ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
8112b3b0:	d0a02404 	addi	r2,gp,-32624
8112b3b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
8112b3b8:	d0a02484 	addi	r2,gp,-32622
8112b3bc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
8112b3c0:	d0a02504 	addi	r2,gp,-32620
8112b3c4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
8112b3c8:	d0a02584 	addi	r2,gp,-32618
8112b3cc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
8112b3d0:	d0a02604 	addi	r2,gp,-32616
8112b3d4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
8112b3d8:	d0a02684 	addi	r2,gp,-32614
8112b3dc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
8112b3e0:	d0a02704 	addi	r2,gp,-32612
8112b3e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
8112b3e8:	d0a02784 	addi	r2,gp,-32610
8112b3ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
8112b3f0:	d0a02804 	addi	r2,gp,-32608
8112b3f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
8112b3f8:	d0a02884 	addi	r2,gp,-32606
8112b3fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
8112b400:	d0a02904 	addi	r2,gp,-32604
8112b404:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
8112b408:	d0a02984 	addi	r2,gp,-32602
8112b40c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
8112b410:	d0a02a04 	addi	r2,gp,-32600
8112b414:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
8112b418:	d0a02a84 	addi	r2,gp,-32598
8112b41c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
8112b420:	d0a02b04 	addi	r2,gp,-32596
8112b424:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
8112b428:	d0a02b84 	addi	r2,gp,-32594
8112b42c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
8112b430:	d0a02c04 	addi	r2,gp,-32592
8112b434:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
8112b438:	d0a02c84 	addi	r2,gp,-32590
8112b43c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
8112b440:	d0a02d04 	addi	r2,gp,-32588
8112b444:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
8112b448:	d0a02d84 	addi	r2,gp,-32586
8112b44c:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
8112b450:	00a04574 	movhi	r2,33045
8112b454:	1083fb04 	addi	r2,r2,4076
8112b458:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
8112b45c:	00a04574 	movhi	r2,33045
8112b460:	10831b04 	addi	r2,r2,3180
8112b464:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
8112b468:	d0a02e84 	addi	r2,gp,-32582
8112b46c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
8112b470:	d0a02f04 	addi	r2,gp,-32580
8112b474:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
8112b478:	d0a02f84 	addi	r2,gp,-32578
8112b47c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
8112b480:	d0a03004 	addi	r2,gp,-32576
8112b484:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
8112b488:	d0a03084 	addi	r2,gp,-32574
8112b48c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
8112b490:	d0a03104 	addi	r2,gp,-32572
8112b494:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
8112b498:	d0a03184 	addi	r2,gp,-32570
8112b49c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
8112b4a0:	d0a03204 	addi	r2,gp,-32568
8112b4a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
8112b4a8:	d0a03284 	addi	r2,gp,-32566
8112b4ac:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
8112b4b0:	d0a02e04 	addi	r2,gp,-32584
8112b4b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
8112b4b8:	d0a03304 	addi	r2,gp,-32564
8112b4bc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
8112b4c0:	0001883a 	nop
8112b4c4:	e037883a 	mov	sp,fp
8112b4c8:	df000017 	ldw	fp,0(sp)
8112b4cc:	dec00104 	addi	sp,sp,4
8112b4d0:	f800283a 	ret

8112b4d4 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
8112b4d4:	defff204 	addi	sp,sp,-56
8112b4d8:	de00012e 	bgeu	sp,et,8112b4e0 <OSFlagAccept+0xc>
8112b4dc:	003b68fa 	trap	3
8112b4e0:	df000d15 	stw	fp,52(sp)
8112b4e4:	df000d04 	addi	fp,sp,52
8112b4e8:	e13ffc15 	stw	r4,-16(fp)
8112b4ec:	2807883a 	mov	r3,r5
8112b4f0:	3005883a 	mov	r2,r6
8112b4f4:	e1ffff15 	stw	r7,-4(fp)
8112b4f8:	e0fffd0d 	sth	r3,-12(fp)
8112b4fc:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8112b500:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112b504:	e0bfff17 	ldw	r2,-4(fp)
8112b508:	1000021e 	bne	r2,zero,8112b514 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8112b50c:	0005883a 	mov	r2,zero
8112b510:	0000b006 	br	8112b7d4 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8112b514:	e0bffc17 	ldw	r2,-16(fp)
8112b518:	1000051e 	bne	r2,zero,8112b530 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112b51c:	e0bfff17 	ldw	r2,-4(fp)
8112b520:	00c01b84 	movi	r3,110
8112b524:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112b528:	0005883a 	mov	r2,zero
8112b52c:	0000a906 	br	8112b7d4 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8112b530:	e0bffc17 	ldw	r2,-16(fp)
8112b534:	10800003 	ldbu	r2,0(r2)
8112b538:	10803fcc 	andi	r2,r2,255
8112b53c:	10800160 	cmpeqi	r2,r2,5
8112b540:	1000051e 	bne	r2,zero,8112b558 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
8112b544:	e0bfff17 	ldw	r2,-4(fp)
8112b548:	00c00044 	movi	r3,1
8112b54c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112b550:	0005883a 	mov	r2,zero
8112b554:	00009f06 	br	8112b7d4 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8112b558:	e0fffe03 	ldbu	r3,-8(fp)
8112b55c:	00bfe004 	movi	r2,-128
8112b560:	1884703a 	and	r2,r3,r2
8112b564:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
8112b568:	e0bff503 	ldbu	r2,-44(fp)
8112b56c:	10000626 	beq	r2,zero,8112b588 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
8112b570:	e0bffe03 	ldbu	r2,-8(fp)
8112b574:	10801fcc 	andi	r2,r2,127
8112b578:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8112b57c:	00800044 	movi	r2,1
8112b580:	e0bff385 	stb	r2,-50(fp)
8112b584:	00000106 	br	8112b58c <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
8112b588:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8112b58c:	e0bfff17 	ldw	r2,-4(fp)
8112b590:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112b594:	0005303a 	rdctl	r2,status
8112b598:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112b59c:	e0fffb17 	ldw	r3,-20(fp)
8112b5a0:	00bfff84 	movi	r2,-2
8112b5a4:	1884703a 	and	r2,r3,r2
8112b5a8:	1001703a 	wrctl	status,r2
  
  return context;
8112b5ac:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8112b5b0:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
8112b5b4:	e0bffe03 	ldbu	r2,-8(fp)
8112b5b8:	10c00060 	cmpeqi	r3,r2,1
8112b5bc:	18005f1e 	bne	r3,zero,8112b73c <OSFlagAccept+0x268>
8112b5c0:	10c00088 	cmpgei	r3,r2,2
8112b5c4:	1800021e 	bne	r3,zero,8112b5d0 <OSFlagAccept+0xfc>
8112b5c8:	10003f26 	beq	r2,zero,8112b6c8 <OSFlagAccept+0x1f4>
8112b5cc:	00007706 	br	8112b7ac <OSFlagAccept+0x2d8>
8112b5d0:	10c000a0 	cmpeqi	r3,r2,2
8112b5d4:	1800031e 	bne	r3,zero,8112b5e4 <OSFlagAccept+0x110>
8112b5d8:	108000e0 	cmpeqi	r2,r2,3
8112b5dc:	10001e1e 	bne	r2,zero,8112b658 <OSFlagAccept+0x184>
8112b5e0:	00007206 	br	8112b7ac <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8112b5e4:	e0bffc17 	ldw	r2,-16(fp)
8112b5e8:	10c0020b 	ldhu	r3,8(r2)
8112b5ec:	e0bffd0b 	ldhu	r2,-12(fp)
8112b5f0:	1884703a 	and	r2,r3,r2
8112b5f4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8112b5f8:	e0fff30b 	ldhu	r3,-52(fp)
8112b5fc:	e0bffd0b 	ldhu	r2,-12(fp)
8112b600:	18800d1e 	bne	r3,r2,8112b638 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112b604:	e0bff383 	ldbu	r2,-50(fp)
8112b608:	10800058 	cmpnei	r2,r2,1
8112b60c:	10000d1e 	bne	r2,zero,8112b644 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8112b610:	e0bffc17 	ldw	r2,-16(fp)
8112b614:	1080020b 	ldhu	r2,8(r2)
8112b618:	1007883a 	mov	r3,r2
8112b61c:	e0bff30b 	ldhu	r2,-52(fp)
8112b620:	0084303a 	nor	r2,zero,r2
8112b624:	1884703a 	and	r2,r3,r2
8112b628:	1007883a 	mov	r3,r2
8112b62c:	e0bffc17 	ldw	r2,-16(fp)
8112b630:	10c0020d 	sth	r3,8(r2)
8112b634:	00000306 	br	8112b644 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8112b638:	e0bfff17 	ldw	r2,-4(fp)
8112b63c:	00c01c04 	movi	r3,112
8112b640:	10c00005 	stb	r3,0(r2)
8112b644:	e0bff417 	ldw	r2,-48(fp)
8112b648:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112b64c:	e0bff617 	ldw	r2,-40(fp)
8112b650:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8112b654:	00005e06 	br	8112b7d0 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8112b658:	e0bffc17 	ldw	r2,-16(fp)
8112b65c:	10c0020b 	ldhu	r3,8(r2)
8112b660:	e0bffd0b 	ldhu	r2,-12(fp)
8112b664:	1884703a 	and	r2,r3,r2
8112b668:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8112b66c:	e0bff30b 	ldhu	r2,-52(fp)
8112b670:	10000d26 	beq	r2,zero,8112b6a8 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112b674:	e0bff383 	ldbu	r2,-50(fp)
8112b678:	10800058 	cmpnei	r2,r2,1
8112b67c:	10000d1e 	bne	r2,zero,8112b6b4 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8112b680:	e0bffc17 	ldw	r2,-16(fp)
8112b684:	1080020b 	ldhu	r2,8(r2)
8112b688:	1007883a 	mov	r3,r2
8112b68c:	e0bff30b 	ldhu	r2,-52(fp)
8112b690:	0084303a 	nor	r2,zero,r2
8112b694:	1884703a 	and	r2,r3,r2
8112b698:	1007883a 	mov	r3,r2
8112b69c:	e0bffc17 	ldw	r2,-16(fp)
8112b6a0:	10c0020d 	sth	r3,8(r2)
8112b6a4:	00000306 	br	8112b6b4 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8112b6a8:	e0bfff17 	ldw	r2,-4(fp)
8112b6ac:	00c01c04 	movi	r3,112
8112b6b0:	10c00005 	stb	r3,0(r2)
8112b6b4:	e0bff417 	ldw	r2,-48(fp)
8112b6b8:	e0bff715 	stw	r2,-36(fp)
8112b6bc:	e0bff717 	ldw	r2,-36(fp)
8112b6c0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8112b6c4:	00004206 	br	8112b7d0 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8112b6c8:	e0bffc17 	ldw	r2,-16(fp)
8112b6cc:	1080020b 	ldhu	r2,8(r2)
8112b6d0:	0084303a 	nor	r2,zero,r2
8112b6d4:	1007883a 	mov	r3,r2
8112b6d8:	e0bffd0b 	ldhu	r2,-12(fp)
8112b6dc:	1884703a 	and	r2,r3,r2
8112b6e0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8112b6e4:	e0fff30b 	ldhu	r3,-52(fp)
8112b6e8:	e0bffd0b 	ldhu	r2,-12(fp)
8112b6ec:	18800b1e 	bne	r3,r2,8112b71c <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112b6f0:	e0bff383 	ldbu	r2,-50(fp)
8112b6f4:	10800058 	cmpnei	r2,r2,1
8112b6f8:	10000b1e 	bne	r2,zero,8112b728 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8112b6fc:	e0bffc17 	ldw	r2,-16(fp)
8112b700:	10c0020b 	ldhu	r3,8(r2)
8112b704:	e0bff30b 	ldhu	r2,-52(fp)
8112b708:	1884b03a 	or	r2,r3,r2
8112b70c:	1007883a 	mov	r3,r2
8112b710:	e0bffc17 	ldw	r2,-16(fp)
8112b714:	10c0020d 	sth	r3,8(r2)
8112b718:	00000306 	br	8112b728 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8112b71c:	e0bfff17 	ldw	r2,-4(fp)
8112b720:	00c01c04 	movi	r3,112
8112b724:	10c00005 	stb	r3,0(r2)
8112b728:	e0bff417 	ldw	r2,-48(fp)
8112b72c:	e0bff815 	stw	r2,-32(fp)
8112b730:	e0bff817 	ldw	r2,-32(fp)
8112b734:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8112b738:	00002506 	br	8112b7d0 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8112b73c:	e0bffc17 	ldw	r2,-16(fp)
8112b740:	1080020b 	ldhu	r2,8(r2)
8112b744:	0084303a 	nor	r2,zero,r2
8112b748:	1007883a 	mov	r3,r2
8112b74c:	e0bffd0b 	ldhu	r2,-12(fp)
8112b750:	1884703a 	and	r2,r3,r2
8112b754:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8112b758:	e0bff30b 	ldhu	r2,-52(fp)
8112b75c:	10000b26 	beq	r2,zero,8112b78c <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112b760:	e0bff383 	ldbu	r2,-50(fp)
8112b764:	10800058 	cmpnei	r2,r2,1
8112b768:	10000b1e 	bne	r2,zero,8112b798 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8112b76c:	e0bffc17 	ldw	r2,-16(fp)
8112b770:	10c0020b 	ldhu	r3,8(r2)
8112b774:	e0bff30b 	ldhu	r2,-52(fp)
8112b778:	1884b03a 	or	r2,r3,r2
8112b77c:	1007883a 	mov	r3,r2
8112b780:	e0bffc17 	ldw	r2,-16(fp)
8112b784:	10c0020d 	sth	r3,8(r2)
8112b788:	00000306 	br	8112b798 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8112b78c:	e0bfff17 	ldw	r2,-4(fp)
8112b790:	00c01c04 	movi	r3,112
8112b794:	10c00005 	stb	r3,0(r2)
8112b798:	e0bff417 	ldw	r2,-48(fp)
8112b79c:	e0bff915 	stw	r2,-28(fp)
8112b7a0:	e0bff917 	ldw	r2,-28(fp)
8112b7a4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8112b7a8:	00000906 	br	8112b7d0 <OSFlagAccept+0x2fc>
8112b7ac:	e0bff417 	ldw	r2,-48(fp)
8112b7b0:	e0bffa15 	stw	r2,-24(fp)
8112b7b4:	e0bffa17 	ldw	r2,-24(fp)
8112b7b8:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8112b7bc:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
8112b7c0:	e0bfff17 	ldw	r2,-4(fp)
8112b7c4:	00c01bc4 	movi	r3,111
8112b7c8:	10c00005 	stb	r3,0(r2)
             break;
8112b7cc:	0001883a 	nop
    }
    return (flags_rdy);
8112b7d0:	e0bff30b 	ldhu	r2,-52(fp)
}
8112b7d4:	e037883a 	mov	sp,fp
8112b7d8:	df000017 	ldw	fp,0(sp)
8112b7dc:	dec00104 	addi	sp,sp,4
8112b7e0:	f800283a 	ret

8112b7e4 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
8112b7e4:	defff804 	addi	sp,sp,-32
8112b7e8:	de00012e 	bgeu	sp,et,8112b7f0 <OSFlagCreate+0xc>
8112b7ec:	003b68fa 	trap	3
8112b7f0:	df000715 	stw	fp,28(sp)
8112b7f4:	df000704 	addi	fp,sp,28
8112b7f8:	2005883a 	mov	r2,r4
8112b7fc:	e17fff15 	stw	r5,-4(fp)
8112b800:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
8112b804:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
8112b808:	e0bfff17 	ldw	r2,-4(fp)
8112b80c:	1000021e 	bne	r2,zero,8112b818 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
8112b810:	0005883a 	mov	r2,zero
8112b814:	00003306 	br	8112b8e4 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
8112b818:	d0a08503 	ldbu	r2,-32236(gp)
8112b81c:	10803fcc 	andi	r2,r2,255
8112b820:	10000526 	beq	r2,zero,8112b838 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
8112b824:	e0bfff17 	ldw	r2,-4(fp)
8112b828:	00c00404 	movi	r3,16
8112b82c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
8112b830:	0005883a 	mov	r2,zero
8112b834:	00002b06 	br	8112b8e4 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112b838:	0005303a 	rdctl	r2,status
8112b83c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112b840:	e0fffd17 	ldw	r3,-12(fp)
8112b844:	00bfff84 	movi	r2,-2
8112b848:	1884703a 	and	r2,r3,r2
8112b84c:	1001703a 	wrctl	status,r2
  
  return context;
8112b850:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8112b854:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8112b858:	d0a08a17 	ldw	r2,-32216(gp)
8112b85c:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
8112b860:	e0bffb17 	ldw	r2,-20(fp)
8112b864:	10001726 	beq	r2,zero,8112b8c4 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8112b868:	d0a08a17 	ldw	r2,-32216(gp)
8112b86c:	10800117 	ldw	r2,4(r2)
8112b870:	d0a08a15 	stw	r2,-32216(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
8112b874:	e0bffb17 	ldw	r2,-20(fp)
8112b878:	00c00144 	movi	r3,5
8112b87c:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
8112b880:	e0bffb17 	ldw	r2,-20(fp)
8112b884:	e0fffe0b 	ldhu	r3,-8(fp)
8112b888:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8112b88c:	e0bffb17 	ldw	r2,-20(fp)
8112b890:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
8112b894:	e0bffb17 	ldw	r2,-20(fp)
8112b898:	00c00fc4 	movi	r3,63
8112b89c:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8112b8a0:	e0bffb17 	ldw	r2,-20(fp)
8112b8a4:	100002c5 	stb	zero,11(r2)
8112b8a8:	e0bff917 	ldw	r2,-28(fp)
8112b8ac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112b8b0:	e0bffa17 	ldw	r2,-24(fp)
8112b8b4:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
8112b8b8:	e0bfff17 	ldw	r2,-4(fp)
8112b8bc:	10000005 	stb	zero,0(r2)
8112b8c0:	00000706 	br	8112b8e0 <OSFlagCreate+0xfc>
8112b8c4:	e0bff917 	ldw	r2,-28(fp)
8112b8c8:	e0bffc15 	stw	r2,-16(fp)
8112b8cc:	e0bffc17 	ldw	r2,-16(fp)
8112b8d0:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
8112b8d4:	e0bfff17 	ldw	r2,-4(fp)
8112b8d8:	00c01c84 	movi	r3,114
8112b8dc:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
8112b8e0:	e0bffb17 	ldw	r2,-20(fp)
}
8112b8e4:	e037883a 	mov	sp,fp
8112b8e8:	df000017 	ldw	fp,0(sp)
8112b8ec:	dec00104 	addi	sp,sp,4
8112b8f0:	f800283a 	ret

8112b8f4 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
8112b8f4:	defff204 	addi	sp,sp,-56
8112b8f8:	de00012e 	bgeu	sp,et,8112b900 <OSFlagDel+0xc>
8112b8fc:	003b68fa 	trap	3
8112b900:	dfc00d15 	stw	ra,52(sp)
8112b904:	df000c15 	stw	fp,48(sp)
8112b908:	df000c04 	addi	fp,sp,48
8112b90c:	e13ffd15 	stw	r4,-12(fp)
8112b910:	2805883a 	mov	r2,r5
8112b914:	e1bfff15 	stw	r6,-4(fp)
8112b918:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8112b91c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112b920:	e0bfff17 	ldw	r2,-4(fp)
8112b924:	1000021e 	bne	r2,zero,8112b930 <OSFlagDel+0x3c>
        return (pgrp);
8112b928:	e0bffd17 	ldw	r2,-12(fp)
8112b92c:	00008006 	br	8112bb30 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8112b930:	e0bffd17 	ldw	r2,-12(fp)
8112b934:	1000051e 	bne	r2,zero,8112b94c <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112b938:	e0bfff17 	ldw	r2,-4(fp)
8112b93c:	00c01b84 	movi	r3,110
8112b940:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8112b944:	e0bffd17 	ldw	r2,-12(fp)
8112b948:	00007906 	br	8112bb30 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112b94c:	d0a08503 	ldbu	r2,-32236(gp)
8112b950:	10803fcc 	andi	r2,r2,255
8112b954:	10000526 	beq	r2,zero,8112b96c <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8112b958:	e0bfff17 	ldw	r2,-4(fp)
8112b95c:	00c003c4 	movi	r3,15
8112b960:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8112b964:	e0bffd17 	ldw	r2,-12(fp)
8112b968:	00007106 	br	8112bb30 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
8112b96c:	e0bffd17 	ldw	r2,-12(fp)
8112b970:	10800003 	ldbu	r2,0(r2)
8112b974:	10803fcc 	andi	r2,r2,255
8112b978:	10800160 	cmpeqi	r2,r2,5
8112b97c:	1000051e 	bne	r2,zero,8112b994 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
8112b980:	e0bfff17 	ldw	r2,-4(fp)
8112b984:	00c00044 	movi	r3,1
8112b988:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8112b98c:	e0bffd17 	ldw	r2,-12(fp)
8112b990:	00006706 	br	8112bb30 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112b994:	0005303a 	rdctl	r2,status
8112b998:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112b99c:	e0fffc17 	ldw	r3,-16(fp)
8112b9a0:	00bfff84 	movi	r2,-2
8112b9a4:	1884703a 	and	r2,r3,r2
8112b9a8:	1001703a 	wrctl	status,r2
  
  return context;
8112b9ac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112b9b0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
8112b9b4:	e0bffd17 	ldw	r2,-12(fp)
8112b9b8:	10800117 	ldw	r2,4(r2)
8112b9bc:	10000326 	beq	r2,zero,8112b9cc <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8112b9c0:	00800044 	movi	r2,1
8112b9c4:	e0bff405 	stb	r2,-48(fp)
8112b9c8:	00000106 	br	8112b9d0 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8112b9cc:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8112b9d0:	e0bffe03 	ldbu	r2,-8(fp)
8112b9d4:	10000326 	beq	r2,zero,8112b9e4 <OSFlagDel+0xf0>
8112b9d8:	10800060 	cmpeqi	r2,r2,1
8112b9dc:	1000231e 	bne	r2,zero,8112ba6c <OSFlagDel+0x178>
8112b9e0:	00004806 	br	8112bb04 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
8112b9e4:	e0bff403 	ldbu	r2,-48(fp)
8112b9e8:	1000161e 	bne	r2,zero,8112ba44 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
8112b9ec:	e0bffd17 	ldw	r2,-12(fp)
8112b9f0:	00c00fc4 	movi	r3,63
8112b9f4:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8112b9f8:	e0bffd17 	ldw	r2,-12(fp)
8112b9fc:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8112ba00:	e0bffd17 	ldw	r2,-12(fp)
8112ba04:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
8112ba08:	d0e08a17 	ldw	r3,-32216(gp)
8112ba0c:	e0bffd17 	ldw	r2,-12(fp)
8112ba10:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
8112ba14:	e0bffd17 	ldw	r2,-12(fp)
8112ba18:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
8112ba1c:	e0bffd17 	ldw	r2,-12(fp)
8112ba20:	d0a08a15 	stw	r2,-32216(gp)
8112ba24:	e0bff717 	ldw	r2,-36(fp)
8112ba28:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ba2c:	e0bff817 	ldw	r2,-32(fp)
8112ba30:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
8112ba34:	e0bfff17 	ldw	r2,-4(fp)
8112ba38:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
8112ba3c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
8112ba40:	00003a06 	br	8112bb2c <OSFlagDel+0x238>
8112ba44:	e0bff717 	ldw	r2,-36(fp)
8112ba48:	e0bff915 	stw	r2,-28(fp)
8112ba4c:	e0bff917 	ldw	r2,-28(fp)
8112ba50:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
8112ba54:	e0bfff17 	ldw	r2,-4(fp)
8112ba58:	00c01244 	movi	r3,73
8112ba5c:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
8112ba60:	e0bffd17 	ldw	r2,-12(fp)
8112ba64:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8112ba68:	00003006 	br	8112bb2c <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8112ba6c:	e0bffd17 	ldw	r2,-12(fp)
8112ba70:	10800117 	ldw	r2,4(r2)
8112ba74:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8112ba78:	00000606 	br	8112ba94 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8112ba7c:	000b883a 	mov	r5,zero
8112ba80:	e13ff517 	ldw	r4,-44(fp)
8112ba84:	112caa80 	call	8112caa8 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8112ba88:	e0bff517 	ldw	r2,-44(fp)
8112ba8c:	10800017 	ldw	r2,0(r2)
8112ba90:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8112ba94:	e0bff517 	ldw	r2,-44(fp)
8112ba98:	103ff81e 	bne	r2,zero,8112ba7c <__reset+0xfb10ba7c>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
8112ba9c:	e0bffd17 	ldw	r2,-12(fp)
8112baa0:	00c00fc4 	movi	r3,63
8112baa4:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8112baa8:	e0bffd17 	ldw	r2,-12(fp)
8112baac:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8112bab0:	e0bffd17 	ldw	r2,-12(fp)
8112bab4:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
8112bab8:	d0e08a17 	ldw	r3,-32216(gp)
8112babc:	e0bffd17 	ldw	r2,-12(fp)
8112bac0:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
8112bac4:	e0bffd17 	ldw	r2,-12(fp)
8112bac8:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
8112bacc:	e0bffd17 	ldw	r2,-12(fp)
8112bad0:	d0a08a15 	stw	r2,-32216(gp)
8112bad4:	e0bff717 	ldw	r2,-36(fp)
8112bad8:	e0bffa15 	stw	r2,-24(fp)
8112badc:	e0bffa17 	ldw	r2,-24(fp)
8112bae0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8112bae4:	e0bff403 	ldbu	r2,-48(fp)
8112bae8:	10800058 	cmpnei	r2,r2,1
8112baec:	1000011e 	bne	r2,zero,8112baf4 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8112baf0:	112abb80 	call	8112abb8 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
8112baf4:	e0bfff17 	ldw	r2,-4(fp)
8112baf8:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8112bafc:	e03ff615 	stw	zero,-40(fp)
             break;
8112bb00:	00000a06 	br	8112bb2c <OSFlagDel+0x238>
8112bb04:	e0bff717 	ldw	r2,-36(fp)
8112bb08:	e0bffb15 	stw	r2,-20(fp)
8112bb0c:	e0bffb17 	ldw	r2,-20(fp)
8112bb10:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
8112bb14:	e0bfff17 	ldw	r2,-4(fp)
8112bb18:	00c001c4 	movi	r3,7
8112bb1c:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
8112bb20:	e0bffd17 	ldw	r2,-12(fp)
8112bb24:	e0bff615 	stw	r2,-40(fp)
             break;
8112bb28:	0001883a 	nop
    }
    return (pgrp_return);
8112bb2c:	e0bff617 	ldw	r2,-40(fp)
}
8112bb30:	e037883a 	mov	sp,fp
8112bb34:	dfc00117 	ldw	ra,4(sp)
8112bb38:	df000017 	ldw	fp,0(sp)
8112bb3c:	dec00204 	addi	sp,sp,8
8112bb40:	f800283a 	ret

8112bb44 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8112bb44:	defff604 	addi	sp,sp,-40
8112bb48:	de00012e 	bgeu	sp,et,8112bb50 <OSFlagNameGet+0xc>
8112bb4c:	003b68fa 	trap	3
8112bb50:	dfc00915 	stw	ra,36(sp)
8112bb54:	df000815 	stw	fp,32(sp)
8112bb58:	df000804 	addi	fp,sp,32
8112bb5c:	e13ffd15 	stw	r4,-12(fp)
8112bb60:	e17ffe15 	stw	r5,-8(fp)
8112bb64:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112bb68:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112bb6c:	e0bfff17 	ldw	r2,-4(fp)
8112bb70:	1000021e 	bne	r2,zero,8112bb7c <OSFlagNameGet+0x38>
        return (0);
8112bb74:	0005883a 	mov	r2,zero
8112bb78:	00003906 	br	8112bc60 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8112bb7c:	e0bffd17 	ldw	r2,-12(fp)
8112bb80:	1000051e 	bne	r2,zero,8112bb98 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112bb84:	e0bfff17 	ldw	r2,-4(fp)
8112bb88:	00c01b84 	movi	r3,110
8112bb8c:	10c00005 	stb	r3,0(r2)
        return (0);
8112bb90:	0005883a 	mov	r2,zero
8112bb94:	00003206 	br	8112bc60 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112bb98:	e0bffe17 	ldw	r2,-8(fp)
8112bb9c:	1000051e 	bne	r2,zero,8112bbb4 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8112bba0:	e0bfff17 	ldw	r2,-4(fp)
8112bba4:	00c00304 	movi	r3,12
8112bba8:	10c00005 	stb	r3,0(r2)
        return (0);
8112bbac:	0005883a 	mov	r2,zero
8112bbb0:	00002b06 	br	8112bc60 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112bbb4:	d0a08503 	ldbu	r2,-32236(gp)
8112bbb8:	10803fcc 	andi	r2,r2,255
8112bbbc:	10000526 	beq	r2,zero,8112bbd4 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8112bbc0:	e0bfff17 	ldw	r2,-4(fp)
8112bbc4:	00c00444 	movi	r3,17
8112bbc8:	10c00005 	stb	r3,0(r2)
        return (0);
8112bbcc:	0005883a 	mov	r2,zero
8112bbd0:	00002306 	br	8112bc60 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112bbd4:	0005303a 	rdctl	r2,status
8112bbd8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112bbdc:	e0fffc17 	ldw	r3,-16(fp)
8112bbe0:	00bfff84 	movi	r2,-2
8112bbe4:	1884703a 	and	r2,r3,r2
8112bbe8:	1001703a 	wrctl	status,r2
  
  return context;
8112bbec:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112bbf0:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8112bbf4:	e0bffd17 	ldw	r2,-12(fp)
8112bbf8:	10800003 	ldbu	r2,0(r2)
8112bbfc:	10803fcc 	andi	r2,r2,255
8112bc00:	10800160 	cmpeqi	r2,r2,5
8112bc04:	1000091e 	bne	r2,zero,8112bc2c <OSFlagNameGet+0xe8>
8112bc08:	e0bff817 	ldw	r2,-32(fp)
8112bc0c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112bc10:	e0bff917 	ldw	r2,-28(fp)
8112bc14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8112bc18:	e0bfff17 	ldw	r2,-4(fp)
8112bc1c:	00c00044 	movi	r3,1
8112bc20:	10c00005 	stb	r3,0(r2)
        return (0);
8112bc24:	0005883a 	mov	r2,zero
8112bc28:	00000d06 	br	8112bc60 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
8112bc2c:	e0bffd17 	ldw	r2,-12(fp)
8112bc30:	10800284 	addi	r2,r2,10
8112bc34:	100b883a 	mov	r5,r2
8112bc38:	e13ffe17 	ldw	r4,-8(fp)
8112bc3c:	112ad0c0 	call	8112ad0c <OS_StrCopy>
8112bc40:	e0bffb05 	stb	r2,-20(fp)
8112bc44:	e0bff817 	ldw	r2,-32(fp)
8112bc48:	e0bffa15 	stw	r2,-24(fp)
8112bc4c:	e0bffa17 	ldw	r2,-24(fp)
8112bc50:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112bc54:	e0bfff17 	ldw	r2,-4(fp)
8112bc58:	10000005 	stb	zero,0(r2)
    return (len);
8112bc5c:	e0bffb03 	ldbu	r2,-20(fp)
}
8112bc60:	e037883a 	mov	sp,fp
8112bc64:	dfc00117 	ldw	ra,4(sp)
8112bc68:	df000017 	ldw	fp,0(sp)
8112bc6c:	dec00204 	addi	sp,sp,8
8112bc70:	f800283a 	ret

8112bc74 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8112bc74:	defff504 	addi	sp,sp,-44
8112bc78:	de00012e 	bgeu	sp,et,8112bc80 <OSFlagNameSet+0xc>
8112bc7c:	003b68fa 	trap	3
8112bc80:	dfc00a15 	stw	ra,40(sp)
8112bc84:	df000915 	stw	fp,36(sp)
8112bc88:	df000904 	addi	fp,sp,36
8112bc8c:	e13ffd15 	stw	r4,-12(fp)
8112bc90:	e17ffe15 	stw	r5,-8(fp)
8112bc94:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112bc98:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112bc9c:	e0bfff17 	ldw	r2,-4(fp)
8112bca0:	10004326 	beq	r2,zero,8112bdb0 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8112bca4:	e0bffd17 	ldw	r2,-12(fp)
8112bca8:	1000041e 	bne	r2,zero,8112bcbc <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112bcac:	e0bfff17 	ldw	r2,-4(fp)
8112bcb0:	00c01b84 	movi	r3,110
8112bcb4:	10c00005 	stb	r3,0(r2)
        return;
8112bcb8:	00003e06 	br	8112bdb4 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112bcbc:	e0bffe17 	ldw	r2,-8(fp)
8112bcc0:	1000041e 	bne	r2,zero,8112bcd4 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8112bcc4:	e0bfff17 	ldw	r2,-4(fp)
8112bcc8:	00c00304 	movi	r3,12
8112bccc:	10c00005 	stb	r3,0(r2)
        return;
8112bcd0:	00003806 	br	8112bdb4 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112bcd4:	d0a08503 	ldbu	r2,-32236(gp)
8112bcd8:	10803fcc 	andi	r2,r2,255
8112bcdc:	10000426 	beq	r2,zero,8112bcf0 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8112bce0:	e0bfff17 	ldw	r2,-4(fp)
8112bce4:	00c00484 	movi	r3,18
8112bce8:	10c00005 	stb	r3,0(r2)
        return;
8112bcec:	00003106 	br	8112bdb4 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112bcf0:	0005303a 	rdctl	r2,status
8112bcf4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112bcf8:	e0fffc17 	ldw	r3,-16(fp)
8112bcfc:	00bfff84 	movi	r2,-2
8112bd00:	1884703a 	and	r2,r3,r2
8112bd04:	1001703a 	wrctl	status,r2
  
  return context;
8112bd08:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112bd0c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8112bd10:	e0bffd17 	ldw	r2,-12(fp)
8112bd14:	10800003 	ldbu	r2,0(r2)
8112bd18:	10803fcc 	andi	r2,r2,255
8112bd1c:	10800160 	cmpeqi	r2,r2,5
8112bd20:	1000081e 	bne	r2,zero,8112bd44 <OSFlagNameSet+0xd0>
8112bd24:	e0bff717 	ldw	r2,-36(fp)
8112bd28:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112bd2c:	e0bff817 	ldw	r2,-32(fp)
8112bd30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8112bd34:	e0bfff17 	ldw	r2,-4(fp)
8112bd38:	00c00044 	movi	r3,1
8112bd3c:	10c00005 	stb	r3,0(r2)
        return;
8112bd40:	00001c06 	br	8112bdb4 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8112bd44:	e13ffe17 	ldw	r4,-8(fp)
8112bd48:	112ad880 	call	8112ad88 <OS_StrLen>
8112bd4c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
8112bd50:	e0bffa03 	ldbu	r2,-24(fp)
8112bd54:	10800830 	cmpltui	r2,r2,32
8112bd58:	1000081e 	bne	r2,zero,8112bd7c <OSFlagNameSet+0x108>
8112bd5c:	e0bff717 	ldw	r2,-36(fp)
8112bd60:	e0bff915 	stw	r2,-28(fp)
8112bd64:	e0bff917 	ldw	r2,-28(fp)
8112bd68:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
8112bd6c:	e0bfff17 	ldw	r2,-4(fp)
8112bd70:	00c01cc4 	movi	r3,115
8112bd74:	10c00005 	stb	r3,0(r2)
        return;
8112bd78:	00000e06 	br	8112bdb4 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8112bd7c:	e0bffd17 	ldw	r2,-12(fp)
8112bd80:	10800284 	addi	r2,r2,10
8112bd84:	e17ffe17 	ldw	r5,-8(fp)
8112bd88:	1009883a 	mov	r4,r2
8112bd8c:	112ad0c0 	call	8112ad0c <OS_StrCopy>
8112bd90:	e0bff717 	ldw	r2,-36(fp)
8112bd94:	e0bffb15 	stw	r2,-20(fp)
8112bd98:	e0bffb17 	ldw	r2,-20(fp)
8112bd9c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112bda0:	e0bfff17 	ldw	r2,-4(fp)
8112bda4:	10000005 	stb	zero,0(r2)
    return;
8112bda8:	0001883a 	nop
8112bdac:	00000106 	br	8112bdb4 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8112bdb0:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
8112bdb4:	e037883a 	mov	sp,fp
8112bdb8:	dfc00117 	ldw	ra,4(sp)
8112bdbc:	df000017 	ldw	fp,0(sp)
8112bdc0:	dec00204 	addi	sp,sp,8
8112bdc4:	f800283a 	ret

8112bdc8 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8112bdc8:	deffe104 	addi	sp,sp,-124
8112bdcc:	de00012e 	bgeu	sp,et,8112bdd4 <OSFlagPend+0xc>
8112bdd0:	003b68fa 	trap	3
8112bdd4:	dfc01e15 	stw	ra,120(sp)
8112bdd8:	df001d15 	stw	fp,116(sp)
8112bddc:	df001d04 	addi	fp,sp,116
8112bde0:	e13ffc15 	stw	r4,-16(fp)
8112bde4:	2809883a 	mov	r4,r5
8112bde8:	3007883a 	mov	r3,r6
8112bdec:	3805883a 	mov	r2,r7
8112bdf0:	e13ffd0d 	sth	r4,-12(fp)
8112bdf4:	e0fffe05 	stb	r3,-8(fp)
8112bdf8:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8112bdfc:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112be00:	e0800217 	ldw	r2,8(fp)
8112be04:	1000021e 	bne	r2,zero,8112be10 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8112be08:	0005883a 	mov	r2,zero
8112be0c:	00015906 	br	8112c374 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8112be10:	e0bffc17 	ldw	r2,-16(fp)
8112be14:	1000051e 	bne	r2,zero,8112be2c <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112be18:	e0800217 	ldw	r2,8(fp)
8112be1c:	00c01b84 	movi	r3,110
8112be20:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112be24:	0005883a 	mov	r2,zero
8112be28:	00015206 	br	8112c374 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112be2c:	d0a08503 	ldbu	r2,-32236(gp)
8112be30:	10803fcc 	andi	r2,r2,255
8112be34:	10000526 	beq	r2,zero,8112be4c <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8112be38:	e0800217 	ldw	r2,8(fp)
8112be3c:	00c00084 	movi	r3,2
8112be40:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112be44:	0005883a 	mov	r2,zero
8112be48:	00014a06 	br	8112c374 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8112be4c:	d0a07303 	ldbu	r2,-32308(gp)
8112be50:	10803fcc 	andi	r2,r2,255
8112be54:	10000526 	beq	r2,zero,8112be6c <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8112be58:	e0800217 	ldw	r2,8(fp)
8112be5c:	00c00344 	movi	r3,13
8112be60:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112be64:	0005883a 	mov	r2,zero
8112be68:	00014206 	br	8112c374 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8112be6c:	e0bffc17 	ldw	r2,-16(fp)
8112be70:	10800003 	ldbu	r2,0(r2)
8112be74:	10803fcc 	andi	r2,r2,255
8112be78:	10800160 	cmpeqi	r2,r2,5
8112be7c:	1000051e 	bne	r2,zero,8112be94 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
8112be80:	e0800217 	ldw	r2,8(fp)
8112be84:	00c00044 	movi	r3,1
8112be88:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112be8c:	0005883a 	mov	r2,zero
8112be90:	00013806 	br	8112c374 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8112be94:	e0fffe03 	ldbu	r3,-8(fp)
8112be98:	00bfe004 	movi	r2,-128
8112be9c:	1884703a 	and	r2,r3,r2
8112bea0:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
8112bea4:	e0bfe603 	ldbu	r2,-104(fp)
8112bea8:	10000626 	beq	r2,zero,8112bec4 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8112beac:	e0bffe03 	ldbu	r2,-8(fp)
8112beb0:	10801fcc 	andi	r2,r2,127
8112beb4:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8112beb8:	00800044 	movi	r2,1
8112bebc:	e0bfe405 	stb	r2,-112(fp)
8112bec0:	00000106 	br	8112bec8 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
8112bec4:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112bec8:	0005303a 	rdctl	r2,status
8112becc:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112bed0:	e0fff617 	ldw	r3,-40(fp)
8112bed4:	00bfff84 	movi	r2,-2
8112bed8:	1884703a 	and	r2,r3,r2
8112bedc:	1001703a 	wrctl	status,r2
  
  return context;
8112bee0:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8112bee4:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8112bee8:	e0bffe03 	ldbu	r2,-8(fp)
8112beec:	10c00060 	cmpeqi	r3,r2,1
8112bef0:	1800921e 	bne	r3,zero,8112c13c <OSFlagPend+0x374>
8112bef4:	10c00088 	cmpgei	r3,r2,2
8112bef8:	1800021e 	bne	r3,zero,8112bf04 <OSFlagPend+0x13c>
8112befc:	10006126 	beq	r2,zero,8112c084 <OSFlagPend+0x2bc>
8112bf00:	0000bb06 	br	8112c1f0 <OSFlagPend+0x428>
8112bf04:	10c000a0 	cmpeqi	r3,r2,2
8112bf08:	1800031e 	bne	r3,zero,8112bf18 <OSFlagPend+0x150>
8112bf0c:	108000e0 	cmpeqi	r2,r2,3
8112bf10:	10002f1e 	bne	r2,zero,8112bfd0 <OSFlagPend+0x208>
8112bf14:	0000b606 	br	8112c1f0 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8112bf18:	e0bffc17 	ldw	r2,-16(fp)
8112bf1c:	10c0020b 	ldhu	r3,8(r2)
8112bf20:	e0bffd0b 	ldhu	r2,-12(fp)
8112bf24:	1884703a 	and	r2,r3,r2
8112bf28:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8112bf2c:	e0ffe80b 	ldhu	r3,-96(fp)
8112bf30:	e0bffd0b 	ldhu	r2,-12(fp)
8112bf34:	1880171e 	bne	r3,r2,8112bf94 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112bf38:	e0bfe403 	ldbu	r2,-112(fp)
8112bf3c:	10800058 	cmpnei	r2,r2,1
8112bf40:	1000091e 	bne	r2,zero,8112bf68 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8112bf44:	e0bffc17 	ldw	r2,-16(fp)
8112bf48:	1080020b 	ldhu	r2,8(r2)
8112bf4c:	1007883a 	mov	r3,r2
8112bf50:	e0bfe80b 	ldhu	r2,-96(fp)
8112bf54:	0084303a 	nor	r2,zero,r2
8112bf58:	1884703a 	and	r2,r3,r2
8112bf5c:	1007883a 	mov	r3,r2
8112bf60:	e0bffc17 	ldw	r2,-16(fp)
8112bf64:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8112bf68:	d0a08617 	ldw	r2,-32232(gp)
8112bf6c:	e0ffe80b 	ldhu	r3,-96(fp)
8112bf70:	10c00b0d 	sth	r3,44(r2)
8112bf74:	e0bfe517 	ldw	r2,-108(fp)
8112bf78:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112bf7c:	e0bfe717 	ldw	r2,-100(fp)
8112bf80:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8112bf84:	e0800217 	ldw	r2,8(fp)
8112bf88:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8112bf8c:	e0bfe80b 	ldhu	r2,-96(fp)
8112bf90:	0000f806 	br	8112c374 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8112bf94:	e13ffd0b 	ldhu	r4,-12(fp)
8112bf98:	e17ffe03 	ldbu	r5,-8(fp)
8112bf9c:	e0bfff0b 	ldhu	r2,-4(fp)
8112bfa0:	e0fff704 	addi	r3,fp,-36
8112bfa4:	d8800015 	stw	r2,0(sp)
8112bfa8:	280f883a 	mov	r7,r5
8112bfac:	200d883a 	mov	r6,r4
8112bfb0:	180b883a 	mov	r5,r3
8112bfb4:	e13ffc17 	ldw	r4,-16(fp)
8112bfb8:	112c8580 	call	8112c858 <OS_FlagBlock>
8112bfbc:	e0bfe517 	ldw	r2,-108(fp)
8112bfc0:	e0bfe915 	stw	r2,-92(fp)
8112bfc4:	e0bfe917 	ldw	r2,-92(fp)
8112bfc8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8112bfcc:	00009206 	br	8112c218 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8112bfd0:	e0bffc17 	ldw	r2,-16(fp)
8112bfd4:	10c0020b 	ldhu	r3,8(r2)
8112bfd8:	e0bffd0b 	ldhu	r2,-12(fp)
8112bfdc:	1884703a 	and	r2,r3,r2
8112bfe0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8112bfe4:	e0bfe80b 	ldhu	r2,-96(fp)
8112bfe8:	10001726 	beq	r2,zero,8112c048 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112bfec:	e0bfe403 	ldbu	r2,-112(fp)
8112bff0:	10800058 	cmpnei	r2,r2,1
8112bff4:	1000091e 	bne	r2,zero,8112c01c <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8112bff8:	e0bffc17 	ldw	r2,-16(fp)
8112bffc:	1080020b 	ldhu	r2,8(r2)
8112c000:	1007883a 	mov	r3,r2
8112c004:	e0bfe80b 	ldhu	r2,-96(fp)
8112c008:	0084303a 	nor	r2,zero,r2
8112c00c:	1884703a 	and	r2,r3,r2
8112c010:	1007883a 	mov	r3,r2
8112c014:	e0bffc17 	ldw	r2,-16(fp)
8112c018:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8112c01c:	d0a08617 	ldw	r2,-32232(gp)
8112c020:	e0ffe80b 	ldhu	r3,-96(fp)
8112c024:	10c00b0d 	sth	r3,44(r2)
8112c028:	e0bfe517 	ldw	r2,-108(fp)
8112c02c:	e0bfea15 	stw	r2,-88(fp)
8112c030:	e0bfea17 	ldw	r2,-88(fp)
8112c034:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8112c038:	e0800217 	ldw	r2,8(fp)
8112c03c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8112c040:	e0bfe80b 	ldhu	r2,-96(fp)
8112c044:	0000cb06 	br	8112c374 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8112c048:	e13ffd0b 	ldhu	r4,-12(fp)
8112c04c:	e17ffe03 	ldbu	r5,-8(fp)
8112c050:	e0bfff0b 	ldhu	r2,-4(fp)
8112c054:	e0fff704 	addi	r3,fp,-36
8112c058:	d8800015 	stw	r2,0(sp)
8112c05c:	280f883a 	mov	r7,r5
8112c060:	200d883a 	mov	r6,r4
8112c064:	180b883a 	mov	r5,r3
8112c068:	e13ffc17 	ldw	r4,-16(fp)
8112c06c:	112c8580 	call	8112c858 <OS_FlagBlock>
8112c070:	e0bfe517 	ldw	r2,-108(fp)
8112c074:	e0bfeb15 	stw	r2,-84(fp)
8112c078:	e0bfeb17 	ldw	r2,-84(fp)
8112c07c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8112c080:	00006506 	br	8112c218 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8112c084:	e0bffc17 	ldw	r2,-16(fp)
8112c088:	1080020b 	ldhu	r2,8(r2)
8112c08c:	0084303a 	nor	r2,zero,r2
8112c090:	1007883a 	mov	r3,r2
8112c094:	e0bffd0b 	ldhu	r2,-12(fp)
8112c098:	1884703a 	and	r2,r3,r2
8112c09c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8112c0a0:	e0ffe80b 	ldhu	r3,-96(fp)
8112c0a4:	e0bffd0b 	ldhu	r2,-12(fp)
8112c0a8:	1880151e 	bne	r3,r2,8112c100 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112c0ac:	e0bfe403 	ldbu	r2,-112(fp)
8112c0b0:	10800058 	cmpnei	r2,r2,1
8112c0b4:	1000071e 	bne	r2,zero,8112c0d4 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8112c0b8:	e0bffc17 	ldw	r2,-16(fp)
8112c0bc:	10c0020b 	ldhu	r3,8(r2)
8112c0c0:	e0bfe80b 	ldhu	r2,-96(fp)
8112c0c4:	1884b03a 	or	r2,r3,r2
8112c0c8:	1007883a 	mov	r3,r2
8112c0cc:	e0bffc17 	ldw	r2,-16(fp)
8112c0d0:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8112c0d4:	d0a08617 	ldw	r2,-32232(gp)
8112c0d8:	e0ffe80b 	ldhu	r3,-96(fp)
8112c0dc:	10c00b0d 	sth	r3,44(r2)
8112c0e0:	e0bfe517 	ldw	r2,-108(fp)
8112c0e4:	e0bfec15 	stw	r2,-80(fp)
8112c0e8:	e0bfec17 	ldw	r2,-80(fp)
8112c0ec:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8112c0f0:	e0800217 	ldw	r2,8(fp)
8112c0f4:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8112c0f8:	e0bfe80b 	ldhu	r2,-96(fp)
8112c0fc:	00009d06 	br	8112c374 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8112c100:	e13ffd0b 	ldhu	r4,-12(fp)
8112c104:	e17ffe03 	ldbu	r5,-8(fp)
8112c108:	e0bfff0b 	ldhu	r2,-4(fp)
8112c10c:	e0fff704 	addi	r3,fp,-36
8112c110:	d8800015 	stw	r2,0(sp)
8112c114:	280f883a 	mov	r7,r5
8112c118:	200d883a 	mov	r6,r4
8112c11c:	180b883a 	mov	r5,r3
8112c120:	e13ffc17 	ldw	r4,-16(fp)
8112c124:	112c8580 	call	8112c858 <OS_FlagBlock>
8112c128:	e0bfe517 	ldw	r2,-108(fp)
8112c12c:	e0bfed15 	stw	r2,-76(fp)
8112c130:	e0bfed17 	ldw	r2,-76(fp)
8112c134:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8112c138:	00003706 	br	8112c218 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8112c13c:	e0bffc17 	ldw	r2,-16(fp)
8112c140:	1080020b 	ldhu	r2,8(r2)
8112c144:	0084303a 	nor	r2,zero,r2
8112c148:	1007883a 	mov	r3,r2
8112c14c:	e0bffd0b 	ldhu	r2,-12(fp)
8112c150:	1884703a 	and	r2,r3,r2
8112c154:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8112c158:	e0bfe80b 	ldhu	r2,-96(fp)
8112c15c:	10001526 	beq	r2,zero,8112c1b4 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8112c160:	e0bfe403 	ldbu	r2,-112(fp)
8112c164:	10800058 	cmpnei	r2,r2,1
8112c168:	1000071e 	bne	r2,zero,8112c188 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8112c16c:	e0bffc17 	ldw	r2,-16(fp)
8112c170:	10c0020b 	ldhu	r3,8(r2)
8112c174:	e0bfe80b 	ldhu	r2,-96(fp)
8112c178:	1884b03a 	or	r2,r3,r2
8112c17c:	1007883a 	mov	r3,r2
8112c180:	e0bffc17 	ldw	r2,-16(fp)
8112c184:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8112c188:	d0a08617 	ldw	r2,-32232(gp)
8112c18c:	e0ffe80b 	ldhu	r3,-96(fp)
8112c190:	10c00b0d 	sth	r3,44(r2)
8112c194:	e0bfe517 	ldw	r2,-108(fp)
8112c198:	e0bfee15 	stw	r2,-72(fp)
8112c19c:	e0bfee17 	ldw	r2,-72(fp)
8112c1a0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8112c1a4:	e0800217 	ldw	r2,8(fp)
8112c1a8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8112c1ac:	e0bfe80b 	ldhu	r2,-96(fp)
8112c1b0:	00007006 	br	8112c374 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8112c1b4:	e13ffd0b 	ldhu	r4,-12(fp)
8112c1b8:	e17ffe03 	ldbu	r5,-8(fp)
8112c1bc:	e0bfff0b 	ldhu	r2,-4(fp)
8112c1c0:	e0fff704 	addi	r3,fp,-36
8112c1c4:	d8800015 	stw	r2,0(sp)
8112c1c8:	280f883a 	mov	r7,r5
8112c1cc:	200d883a 	mov	r6,r4
8112c1d0:	180b883a 	mov	r5,r3
8112c1d4:	e13ffc17 	ldw	r4,-16(fp)
8112c1d8:	112c8580 	call	8112c858 <OS_FlagBlock>
8112c1dc:	e0bfe517 	ldw	r2,-108(fp)
8112c1e0:	e0bfef15 	stw	r2,-68(fp)
8112c1e4:	e0bfef17 	ldw	r2,-68(fp)
8112c1e8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8112c1ec:	00000a06 	br	8112c218 <OSFlagPend+0x450>
8112c1f0:	e0bfe517 	ldw	r2,-108(fp)
8112c1f4:	e0bff015 	stw	r2,-64(fp)
8112c1f8:	e0bff017 	ldw	r2,-64(fp)
8112c1fc:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8112c200:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
8112c204:	e0800217 	ldw	r2,8(fp)
8112c208:	00c01bc4 	movi	r3,111
8112c20c:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8112c210:	e0bfe80b 	ldhu	r2,-96(fp)
8112c214:	00005706 	br	8112c374 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
8112c218:	112abb80 	call	8112abb8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112c21c:	0005303a 	rdctl	r2,status
8112c220:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112c224:	e0fff117 	ldw	r3,-60(fp)
8112c228:	00bfff84 	movi	r2,-2
8112c22c:	1884703a 	and	r2,r3,r2
8112c230:	1001703a 	wrctl	status,r2
  
  return context;
8112c234:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8112c238:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8112c23c:	d0a08617 	ldw	r2,-32232(gp)
8112c240:	10800c43 	ldbu	r2,49(r2)
8112c244:	10803fcc 	andi	r2,r2,255
8112c248:	10001c26 	beq	r2,zero,8112c2bc <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8112c24c:	d0a08617 	ldw	r2,-32232(gp)
8112c250:	10800c43 	ldbu	r2,49(r2)
8112c254:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8112c258:	d0a08617 	ldw	r2,-32232(gp)
8112c25c:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
8112c260:	e0bff704 	addi	r2,fp,-36
8112c264:	1009883a 	mov	r4,r2
8112c268:	112cba40 	call	8112cba4 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8112c26c:	d0a08617 	ldw	r2,-32232(gp)
8112c270:	10000c05 	stb	zero,48(r2)
8112c274:	e0bfe517 	ldw	r2,-108(fp)
8112c278:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112c27c:	e0bff217 	ldw	r2,-56(fp)
8112c280:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
8112c284:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8112c288:	e0bff303 	ldbu	r2,-52(fp)
8112c28c:	108000a0 	cmpeqi	r2,r2,2
8112c290:	10000426 	beq	r2,zero,8112c2a4 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
8112c294:	e0800217 	ldw	r2,8(fp)
8112c298:	00c00384 	movi	r3,14
8112c29c:	10c00005 	stb	r3,0(r2)
                 break;
8112c2a0:	00000406 	br	8112c2b4 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
8112c2a4:	e0800217 	ldw	r2,8(fp)
8112c2a8:	00c00284 	movi	r3,10
8112c2ac:	10c00005 	stb	r3,0(r2)
                 break;
8112c2b0:	0001883a 	nop
        }
        return (flags_rdy);
8112c2b4:	e0bfe80b 	ldhu	r2,-96(fp)
8112c2b8:	00002e06 	br	8112c374 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8112c2bc:	d0a08617 	ldw	r2,-32232(gp)
8112c2c0:	10800b0b 	ldhu	r2,44(r2)
8112c2c4:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8112c2c8:	e0bfe403 	ldbu	r2,-112(fp)
8112c2cc:	10800058 	cmpnei	r2,r2,1
8112c2d0:	1000211e 	bne	r2,zero,8112c358 <OSFlagPend+0x590>
        switch (wait_type) {
8112c2d4:	e0bffe03 	ldbu	r2,-8(fp)
8112c2d8:	10001616 	blt	r2,zero,8112c334 <OSFlagPend+0x56c>
8112c2dc:	10c00090 	cmplti	r3,r2,2
8112c2e0:	18000c1e 	bne	r3,zero,8112c314 <OSFlagPend+0x54c>
8112c2e4:	10800108 	cmpgei	r2,r2,4
8112c2e8:	1000121e 	bne	r2,zero,8112c334 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8112c2ec:	e0bffc17 	ldw	r2,-16(fp)
8112c2f0:	1080020b 	ldhu	r2,8(r2)
8112c2f4:	1007883a 	mov	r3,r2
8112c2f8:	e0bfe80b 	ldhu	r2,-96(fp)
8112c2fc:	0084303a 	nor	r2,zero,r2
8112c300:	1884703a 	and	r2,r3,r2
8112c304:	1007883a 	mov	r3,r2
8112c308:	e0bffc17 	ldw	r2,-16(fp)
8112c30c:	10c0020d 	sth	r3,8(r2)
                 break;
8112c310:	00001106 	br	8112c358 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
8112c314:	e0bffc17 	ldw	r2,-16(fp)
8112c318:	10c0020b 	ldhu	r3,8(r2)
8112c31c:	e0bfe80b 	ldhu	r2,-96(fp)
8112c320:	1884b03a 	or	r2,r3,r2
8112c324:	1007883a 	mov	r3,r2
8112c328:	e0bffc17 	ldw	r2,-16(fp)
8112c32c:	10c0020d 	sth	r3,8(r2)
                 break;
8112c330:	00000906 	br	8112c358 <OSFlagPend+0x590>
8112c334:	e0bfe517 	ldw	r2,-108(fp)
8112c338:	e0bff415 	stw	r2,-48(fp)
8112c33c:	e0bff417 	ldw	r2,-48(fp)
8112c340:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8112c344:	e0800217 	ldw	r2,8(fp)
8112c348:	00c01bc4 	movi	r3,111
8112c34c:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8112c350:	0005883a 	mov	r2,zero
8112c354:	00000706 	br	8112c374 <OSFlagPend+0x5ac>
8112c358:	e0bfe517 	ldw	r2,-108(fp)
8112c35c:	e0bff515 	stw	r2,-44(fp)
8112c360:	e0bff517 	ldw	r2,-44(fp)
8112c364:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
8112c368:	e0800217 	ldw	r2,8(fp)
8112c36c:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
8112c370:	e0bfe80b 	ldhu	r2,-96(fp)
}
8112c374:	e037883a 	mov	sp,fp
8112c378:	dfc00117 	ldw	ra,4(sp)
8112c37c:	df000017 	ldw	fp,0(sp)
8112c380:	dec00204 	addi	sp,sp,8
8112c384:	f800283a 	ret

8112c388 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8112c388:	defffb04 	addi	sp,sp,-20
8112c38c:	de00012e 	bgeu	sp,et,8112c394 <OSFlagPendGetFlagsRdy+0xc>
8112c390:	003b68fa 	trap	3
8112c394:	df000415 	stw	fp,16(sp)
8112c398:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8112c39c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112c3a0:	0005303a 	rdctl	r2,status
8112c3a4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112c3a8:	e0fffe17 	ldw	r3,-8(fp)
8112c3ac:	00bfff84 	movi	r2,-2
8112c3b0:	1884703a 	and	r2,r3,r2
8112c3b4:	1001703a 	wrctl	status,r2
  
  return context;
8112c3b8:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8112c3bc:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
8112c3c0:	d0a08617 	ldw	r2,-32232(gp)
8112c3c4:	10800b0b 	ldhu	r2,44(r2)
8112c3c8:	e0bffd0d 	sth	r2,-12(fp)
8112c3cc:	e0bffc17 	ldw	r2,-16(fp)
8112c3d0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112c3d4:	e0bfff17 	ldw	r2,-4(fp)
8112c3d8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8112c3dc:	e0bffd0b 	ldhu	r2,-12(fp)
}
8112c3e0:	e037883a 	mov	sp,fp
8112c3e4:	df000017 	ldw	fp,0(sp)
8112c3e8:	dec00104 	addi	sp,sp,4
8112c3ec:	f800283a 	ret

8112c3f0 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
8112c3f0:	deffef04 	addi	sp,sp,-68
8112c3f4:	de00012e 	bgeu	sp,et,8112c3fc <OSFlagPost+0xc>
8112c3f8:	003b68fa 	trap	3
8112c3fc:	dfc01015 	stw	ra,64(sp)
8112c400:	df000f15 	stw	fp,60(sp)
8112c404:	df000f04 	addi	fp,sp,60
8112c408:	e13ffc15 	stw	r4,-16(fp)
8112c40c:	2807883a 	mov	r3,r5
8112c410:	3005883a 	mov	r2,r6
8112c414:	e1ffff15 	stw	r7,-4(fp)
8112c418:	e0fffd0d 	sth	r3,-12(fp)
8112c41c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
8112c420:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8112c424:	e0bfff17 	ldw	r2,-4(fp)
8112c428:	1000021e 	bne	r2,zero,8112c434 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
8112c42c:	0005883a 	mov	r2,zero
8112c430:	0000d106 	br	8112c778 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
8112c434:	e0bffc17 	ldw	r2,-16(fp)
8112c438:	1000051e 	bne	r2,zero,8112c450 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112c43c:	e0bfff17 	ldw	r2,-4(fp)
8112c440:	00c01b84 	movi	r3,110
8112c444:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112c448:	0005883a 	mov	r2,zero
8112c44c:	0000ca06 	br	8112c778 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
8112c450:	e0bffc17 	ldw	r2,-16(fp)
8112c454:	10800003 	ldbu	r2,0(r2)
8112c458:	10803fcc 	andi	r2,r2,255
8112c45c:	10800160 	cmpeqi	r2,r2,5
8112c460:	1000051e 	bne	r2,zero,8112c478 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
8112c464:	e0bfff17 	ldw	r2,-4(fp)
8112c468:	00c00044 	movi	r3,1
8112c46c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112c470:	0005883a 	mov	r2,zero
8112c474:	0000c006 	br	8112c778 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112c478:	0005303a 	rdctl	r2,status
8112c47c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112c480:	e0fffb17 	ldw	r3,-20(fp)
8112c484:	00bfff84 	movi	r2,-2
8112c488:	1884703a 	and	r2,r3,r2
8112c48c:	1001703a 	wrctl	status,r2
  
  return context;
8112c490:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8112c494:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8112c498:	e0bffe03 	ldbu	r2,-8(fp)
8112c49c:	10000326 	beq	r2,zero,8112c4ac <OSFlagPost+0xbc>
8112c4a0:	10800060 	cmpeqi	r2,r2,1
8112c4a4:	10000b1e 	bne	r2,zero,8112c4d4 <OSFlagPost+0xe4>
8112c4a8:	00001206 	br	8112c4f4 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8112c4ac:	e0bffc17 	ldw	r2,-16(fp)
8112c4b0:	1080020b 	ldhu	r2,8(r2)
8112c4b4:	1007883a 	mov	r3,r2
8112c4b8:	e0bffd0b 	ldhu	r2,-12(fp)
8112c4bc:	0084303a 	nor	r2,zero,r2
8112c4c0:	1884703a 	and	r2,r3,r2
8112c4c4:	1007883a 	mov	r3,r2
8112c4c8:	e0bffc17 	ldw	r2,-16(fp)
8112c4cc:	10c0020d 	sth	r3,8(r2)
             break;
8112c4d0:	00001106 	br	8112c518 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
8112c4d4:	e0bffc17 	ldw	r2,-16(fp)
8112c4d8:	10c0020b 	ldhu	r3,8(r2)
8112c4dc:	e0bffd0b 	ldhu	r2,-12(fp)
8112c4e0:	1884b03a 	or	r2,r3,r2
8112c4e4:	1007883a 	mov	r3,r2
8112c4e8:	e0bffc17 	ldw	r2,-16(fp)
8112c4ec:	10c0020d 	sth	r3,8(r2)
             break;
8112c4f0:	00000906 	br	8112c518 <OSFlagPost+0x128>
8112c4f4:	e0bff317 	ldw	r2,-52(fp)
8112c4f8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112c4fc:	e0bff417 	ldw	r2,-48(fp)
8112c500:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
8112c504:	e0bfff17 	ldw	r2,-4(fp)
8112c508:	00c01c44 	movi	r3,113
8112c50c:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
8112c510:	0005883a 	mov	r2,zero
8112c514:	00009806 	br	8112c778 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
8112c518:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8112c51c:	e0bffc17 	ldw	r2,-16(fp)
8112c520:	10800117 	ldw	r2,4(r2)
8112c524:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8112c528:	00007706 	br	8112c708 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8112c52c:	e0bff117 	ldw	r2,-60(fp)
8112c530:	10800483 	ldbu	r2,18(r2)
8112c534:	10803fcc 	andi	r2,r2,255
8112c538:	10c00060 	cmpeqi	r3,r2,1
8112c53c:	18004a1e 	bne	r3,zero,8112c668 <OSFlagPost+0x278>
8112c540:	10c00088 	cmpgei	r3,r2,2
8112c544:	1800021e 	bne	r3,zero,8112c550 <OSFlagPost+0x160>
8112c548:	10002f26 	beq	r2,zero,8112c608 <OSFlagPost+0x218>
8112c54c:	00005b06 	br	8112c6bc <OSFlagPost+0x2cc>
8112c550:	10c000a0 	cmpeqi	r3,r2,2
8112c554:	1800031e 	bne	r3,zero,8112c564 <OSFlagPost+0x174>
8112c558:	108000e0 	cmpeqi	r2,r2,3
8112c55c:	1000171e 	bne	r2,zero,8112c5bc <OSFlagPost+0x1cc>
8112c560:	00005606 	br	8112c6bc <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8112c564:	e0bffc17 	ldw	r2,-16(fp)
8112c568:	10c0020b 	ldhu	r3,8(r2)
8112c56c:	e0bff117 	ldw	r2,-60(fp)
8112c570:	1080040b 	ldhu	r2,16(r2)
8112c574:	1884703a 	and	r2,r3,r2
8112c578:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8112c57c:	e0bff117 	ldw	r2,-60(fp)
8112c580:	1080040b 	ldhu	r2,16(r2)
8112c584:	10ffffcc 	andi	r3,r2,65535
8112c588:	e0bff60b 	ldhu	r2,-40(fp)
8112c58c:	1880541e 	bne	r3,r2,8112c6e0 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8112c590:	e0bff60b 	ldhu	r2,-40(fp)
8112c594:	100b883a 	mov	r5,r2
8112c598:	e13ff117 	ldw	r4,-60(fp)
8112c59c:	112caa80 	call	8112caa8 <OS_FlagTaskRdy>
8112c5a0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8112c5a4:	e0bff683 	ldbu	r2,-38(fp)
8112c5a8:	10800058 	cmpnei	r2,r2,1
8112c5ac:	10004c1e 	bne	r2,zero,8112c6e0 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8112c5b0:	00800044 	movi	r2,1
8112c5b4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8112c5b8:	00004906 	br	8112c6e0 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8112c5bc:	e0bffc17 	ldw	r2,-16(fp)
8112c5c0:	10c0020b 	ldhu	r3,8(r2)
8112c5c4:	e0bff117 	ldw	r2,-60(fp)
8112c5c8:	1080040b 	ldhu	r2,16(r2)
8112c5cc:	1884703a 	and	r2,r3,r2
8112c5d0:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8112c5d4:	e0bff60b 	ldhu	r2,-40(fp)
8112c5d8:	10004326 	beq	r2,zero,8112c6e8 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8112c5dc:	e0bff60b 	ldhu	r2,-40(fp)
8112c5e0:	100b883a 	mov	r5,r2
8112c5e4:	e13ff117 	ldw	r4,-60(fp)
8112c5e8:	112caa80 	call	8112caa8 <OS_FlagTaskRdy>
8112c5ec:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8112c5f0:	e0bff683 	ldbu	r2,-38(fp)
8112c5f4:	10800058 	cmpnei	r2,r2,1
8112c5f8:	10003b1e 	bne	r2,zero,8112c6e8 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8112c5fc:	00800044 	movi	r2,1
8112c600:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8112c604:	00003806 	br	8112c6e8 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8112c608:	e0bffc17 	ldw	r2,-16(fp)
8112c60c:	1080020b 	ldhu	r2,8(r2)
8112c610:	0084303a 	nor	r2,zero,r2
8112c614:	1007883a 	mov	r3,r2
8112c618:	e0bff117 	ldw	r2,-60(fp)
8112c61c:	1080040b 	ldhu	r2,16(r2)
8112c620:	1884703a 	and	r2,r3,r2
8112c624:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8112c628:	e0bff117 	ldw	r2,-60(fp)
8112c62c:	1080040b 	ldhu	r2,16(r2)
8112c630:	10ffffcc 	andi	r3,r2,65535
8112c634:	e0bff60b 	ldhu	r2,-40(fp)
8112c638:	18802d1e 	bne	r3,r2,8112c6f0 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8112c63c:	e0bff60b 	ldhu	r2,-40(fp)
8112c640:	100b883a 	mov	r5,r2
8112c644:	e13ff117 	ldw	r4,-60(fp)
8112c648:	112caa80 	call	8112caa8 <OS_FlagTaskRdy>
8112c64c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8112c650:	e0bff683 	ldbu	r2,-38(fp)
8112c654:	10800058 	cmpnei	r2,r2,1
8112c658:	1000251e 	bne	r2,zero,8112c6f0 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8112c65c:	00800044 	movi	r2,1
8112c660:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8112c664:	00002206 	br	8112c6f0 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8112c668:	e0bffc17 	ldw	r2,-16(fp)
8112c66c:	1080020b 	ldhu	r2,8(r2)
8112c670:	0084303a 	nor	r2,zero,r2
8112c674:	1007883a 	mov	r3,r2
8112c678:	e0bff117 	ldw	r2,-60(fp)
8112c67c:	1080040b 	ldhu	r2,16(r2)
8112c680:	1884703a 	and	r2,r3,r2
8112c684:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8112c688:	e0bff60b 	ldhu	r2,-40(fp)
8112c68c:	10001a26 	beq	r2,zero,8112c6f8 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8112c690:	e0bff60b 	ldhu	r2,-40(fp)
8112c694:	100b883a 	mov	r5,r2
8112c698:	e13ff117 	ldw	r4,-60(fp)
8112c69c:	112caa80 	call	8112caa8 <OS_FlagTaskRdy>
8112c6a0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8112c6a4:	e0bff683 	ldbu	r2,-38(fp)
8112c6a8:	10800058 	cmpnei	r2,r2,1
8112c6ac:	1000121e 	bne	r2,zero,8112c6f8 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8112c6b0:	00800044 	movi	r2,1
8112c6b4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8112c6b8:	00000f06 	br	8112c6f8 <OSFlagPost+0x308>
8112c6bc:	e0bff317 	ldw	r2,-52(fp)
8112c6c0:	e0bff515 	stw	r2,-44(fp)
8112c6c4:	e0bff517 	ldw	r2,-44(fp)
8112c6c8:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8112c6cc:	e0bfff17 	ldw	r2,-4(fp)
8112c6d0:	00c01bc4 	movi	r3,111
8112c6d4:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8112c6d8:	0005883a 	mov	r2,zero
8112c6dc:	00002606 	br	8112c778 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8112c6e0:	0001883a 	nop
8112c6e4:	00000506 	br	8112c6fc <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8112c6e8:	0001883a 	nop
8112c6ec:	00000306 	br	8112c6fc <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8112c6f0:	0001883a 	nop
8112c6f4:	00000106 	br	8112c6fc <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8112c6f8:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8112c6fc:	e0bff117 	ldw	r2,-60(fp)
8112c700:	10800017 	ldw	r2,0(r2)
8112c704:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8112c708:	e0bff117 	ldw	r2,-60(fp)
8112c70c:	103f871e 	bne	r2,zero,8112c52c <__reset+0xfb10c52c>
8112c710:	e0bff317 	ldw	r2,-52(fp)
8112c714:	e0bff715 	stw	r2,-36(fp)
8112c718:	e0bff717 	ldw	r2,-36(fp)
8112c71c:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
8112c720:	e0bff203 	ldbu	r2,-56(fp)
8112c724:	10800058 	cmpnei	r2,r2,1
8112c728:	1000011e 	bne	r2,zero,8112c730 <OSFlagPost+0x340>
        OS_Sched();
8112c72c:	112abb80 	call	8112abb8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112c730:	0005303a 	rdctl	r2,status
8112c734:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112c738:	e0fffa17 	ldw	r3,-24(fp)
8112c73c:	00bfff84 	movi	r2,-2
8112c740:	1884703a 	and	r2,r3,r2
8112c744:	1001703a 	wrctl	status,r2
  
  return context;
8112c748:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8112c74c:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
8112c750:	e0bffc17 	ldw	r2,-16(fp)
8112c754:	1080020b 	ldhu	r2,8(r2)
8112c758:	e0bff90d 	sth	r2,-28(fp)
8112c75c:	e0bff317 	ldw	r2,-52(fp)
8112c760:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112c764:	e0bff817 	ldw	r2,-32(fp)
8112c768:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8112c76c:	e0bfff17 	ldw	r2,-4(fp)
8112c770:	10000005 	stb	zero,0(r2)
    return (flags_cur);
8112c774:	e0bff90b 	ldhu	r2,-28(fp)
}
8112c778:	e037883a 	mov	sp,fp
8112c77c:	dfc00117 	ldw	ra,4(sp)
8112c780:	df000017 	ldw	fp,0(sp)
8112c784:	dec00204 	addi	sp,sp,8
8112c788:	f800283a 	ret

8112c78c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8112c78c:	defff904 	addi	sp,sp,-28
8112c790:	de00012e 	bgeu	sp,et,8112c798 <OSFlagQuery+0xc>
8112c794:	003b68fa 	trap	3
8112c798:	df000615 	stw	fp,24(sp)
8112c79c:	df000604 	addi	fp,sp,24
8112c7a0:	e13ffe15 	stw	r4,-8(fp)
8112c7a4:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
8112c7a8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
8112c7ac:	e0bfff17 	ldw	r2,-4(fp)
8112c7b0:	1000021e 	bne	r2,zero,8112c7bc <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
8112c7b4:	0005883a 	mov	r2,zero
8112c7b8:	00002306 	br	8112c848 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
8112c7bc:	e0bffe17 	ldw	r2,-8(fp)
8112c7c0:	1000051e 	bne	r2,zero,8112c7d8 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8112c7c4:	e0bfff17 	ldw	r2,-4(fp)
8112c7c8:	00c01b84 	movi	r3,110
8112c7cc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112c7d0:	0005883a 	mov	r2,zero
8112c7d4:	00001c06 	br	8112c848 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
8112c7d8:	e0bffe17 	ldw	r2,-8(fp)
8112c7dc:	10800003 	ldbu	r2,0(r2)
8112c7e0:	10803fcc 	andi	r2,r2,255
8112c7e4:	10800160 	cmpeqi	r2,r2,5
8112c7e8:	1000051e 	bne	r2,zero,8112c800 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8112c7ec:	e0bfff17 	ldw	r2,-4(fp)
8112c7f0:	00c00044 	movi	r3,1
8112c7f4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8112c7f8:	0005883a 	mov	r2,zero
8112c7fc:	00001206 	br	8112c848 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112c800:	0005303a 	rdctl	r2,status
8112c804:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112c808:	e0fffc17 	ldw	r3,-16(fp)
8112c80c:	00bfff84 	movi	r2,-2
8112c810:	1884703a 	and	r2,r3,r2
8112c814:	1001703a 	wrctl	status,r2
  
  return context;
8112c818:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112c81c:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
8112c820:	e0bffe17 	ldw	r2,-8(fp)
8112c824:	1080020b 	ldhu	r2,8(r2)
8112c828:	e0bffb0d 	sth	r2,-20(fp)
8112c82c:	e0bffa17 	ldw	r2,-24(fp)
8112c830:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112c834:	e0bffd17 	ldw	r2,-12(fp)
8112c838:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112c83c:	e0bfff17 	ldw	r2,-4(fp)
8112c840:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
8112c844:	e0bffb0b 	ldhu	r2,-20(fp)
}
8112c848:	e037883a 	mov	sp,fp
8112c84c:	df000017 	ldw	fp,0(sp)
8112c850:	dec00104 	addi	sp,sp,4
8112c854:	f800283a 	ret

8112c858 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8112c858:	defff804 	addi	sp,sp,-32
8112c85c:	de00012e 	bgeu	sp,et,8112c864 <OS_FlagBlock+0xc>
8112c860:	003b68fa 	trap	3
8112c864:	df000715 	stw	fp,28(sp)
8112c868:	df000704 	addi	fp,sp,28
8112c86c:	e13ffb15 	stw	r4,-20(fp)
8112c870:	e17ffc15 	stw	r5,-16(fp)
8112c874:	3009883a 	mov	r4,r6
8112c878:	3807883a 	mov	r3,r7
8112c87c:	e0800117 	ldw	r2,4(fp)
8112c880:	e13ffd0d 	sth	r4,-12(fp)
8112c884:	e0fffe05 	stb	r3,-8(fp)
8112c888:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8112c88c:	d0a08617 	ldw	r2,-32232(gp)
8112c890:	d0e08617 	ldw	r3,-32232(gp)
8112c894:	18c00c03 	ldbu	r3,48(r3)
8112c898:	18c00814 	ori	r3,r3,32
8112c89c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
8112c8a0:	d0a08617 	ldw	r2,-32232(gp)
8112c8a4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
8112c8a8:	d0a08617 	ldw	r2,-32232(gp)
8112c8ac:	e0ffff0b 	ldhu	r3,-4(fp)
8112c8b0:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
8112c8b4:	d0a08617 	ldw	r2,-32232(gp)
8112c8b8:	e0fffc17 	ldw	r3,-16(fp)
8112c8bc:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
8112c8c0:	e0bffc17 	ldw	r2,-16(fp)
8112c8c4:	e0fffd0b 	ldhu	r3,-12(fp)
8112c8c8:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8112c8cc:	e0bffc17 	ldw	r2,-16(fp)
8112c8d0:	e0fffe03 	ldbu	r3,-8(fp)
8112c8d4:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
8112c8d8:	d0e08617 	ldw	r3,-32232(gp)
8112c8dc:	e0bffc17 	ldw	r2,-16(fp)
8112c8e0:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
8112c8e4:	e0bffb17 	ldw	r2,-20(fp)
8112c8e8:	10c00117 	ldw	r3,4(r2)
8112c8ec:	e0bffc17 	ldw	r2,-16(fp)
8112c8f0:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
8112c8f4:	e0bffc17 	ldw	r2,-16(fp)
8112c8f8:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8112c8fc:	e0bffc17 	ldw	r2,-16(fp)
8112c900:	e0fffb17 	ldw	r3,-20(fp)
8112c904:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8112c908:	e0bffb17 	ldw	r2,-20(fp)
8112c90c:	10800117 	ldw	r2,4(r2)
8112c910:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8112c914:	e0bff917 	ldw	r2,-28(fp)
8112c918:	10000326 	beq	r2,zero,8112c928 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
8112c91c:	e0bff917 	ldw	r2,-28(fp)
8112c920:	e0fffc17 	ldw	r3,-16(fp)
8112c924:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
8112c928:	e0bffb17 	ldw	r2,-20(fp)
8112c92c:	e0fffc17 	ldw	r3,-16(fp)
8112c930:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
8112c934:	d0a08617 	ldw	r2,-32232(gp)
8112c938:	10800d03 	ldbu	r2,52(r2)
8112c93c:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8112c940:	e0fffa03 	ldbu	r3,-24(fp)
8112c944:	e13ffa03 	ldbu	r4,-24(fp)
8112c948:	d0a08244 	addi	r2,gp,-32247
8112c94c:	2085883a 	add	r2,r4,r2
8112c950:	10800003 	ldbu	r2,0(r2)
8112c954:	1009883a 	mov	r4,r2
8112c958:	d0a08617 	ldw	r2,-32232(gp)
8112c95c:	10800d43 	ldbu	r2,53(r2)
8112c960:	0084303a 	nor	r2,zero,r2
8112c964:	2084703a 	and	r2,r4,r2
8112c968:	1009883a 	mov	r4,r2
8112c96c:	d0a08244 	addi	r2,gp,-32247
8112c970:	1885883a 	add	r2,r3,r2
8112c974:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8112c978:	e0fffa03 	ldbu	r3,-24(fp)
8112c97c:	d0a08244 	addi	r2,gp,-32247
8112c980:	1885883a 	add	r2,r3,r2
8112c984:	10800003 	ldbu	r2,0(r2)
8112c988:	10803fcc 	andi	r2,r2,255
8112c98c:	1000071e 	bne	r2,zero,8112c9ac <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8112c990:	d0a08617 	ldw	r2,-32232(gp)
8112c994:	10800d83 	ldbu	r2,54(r2)
8112c998:	0084303a 	nor	r2,zero,r2
8112c99c:	1007883a 	mov	r3,r2
8112c9a0:	d0a08203 	ldbu	r2,-32248(gp)
8112c9a4:	1884703a 	and	r2,r3,r2
8112c9a8:	d0a08205 	stb	r2,-32248(gp)
    }
}
8112c9ac:	0001883a 	nop
8112c9b0:	e037883a 	mov	sp,fp
8112c9b4:	df000017 	ldw	fp,0(sp)
8112c9b8:	dec00104 	addi	sp,sp,4
8112c9bc:	f800283a 	ret

8112c9c0 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
8112c9c0:	defffb04 	addi	sp,sp,-20
8112c9c4:	de00012e 	bgeu	sp,et,8112c9cc <OS_FlagInit+0xc>
8112c9c8:	003b68fa 	trap	3
8112c9cc:	dfc00415 	stw	ra,16(sp)
8112c9d0:	df000315 	stw	fp,12(sp)
8112c9d4:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
8112c9d8:	0140dc04 	movi	r5,880
8112c9dc:	01204574 	movhi	r4,33045
8112c9e0:	21031f04 	addi	r4,r4,3196
8112c9e4:	112aaec0 	call	8112aaec <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
8112c9e8:	00a04574 	movhi	r2,33045
8112c9ec:	10831f04 	addi	r2,r2,3196
8112c9f0:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
8112c9f4:	00a04574 	movhi	r2,33045
8112c9f8:	10832a04 	addi	r2,r2,3240
8112c9fc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8112ca00:	e03ffd0d 	sth	zero,-12(fp)
8112ca04:	00001306 	br	8112ca54 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8112ca08:	e0bffe17 	ldw	r2,-8(fp)
8112ca0c:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
8112ca10:	e0bffe17 	ldw	r2,-8(fp)
8112ca14:	e0ffff17 	ldw	r3,-4(fp)
8112ca18:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
8112ca1c:	e0bffe17 	ldw	r2,-8(fp)
8112ca20:	00c00fc4 	movi	r3,63
8112ca24:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8112ca28:	e0bffe17 	ldw	r2,-8(fp)
8112ca2c:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
8112ca30:	e0bffe17 	ldw	r2,-8(fp)
8112ca34:	10800b04 	addi	r2,r2,44
8112ca38:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
8112ca3c:	e0bfff17 	ldw	r2,-4(fp)
8112ca40:	10800b04 	addi	r2,r2,44
8112ca44:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8112ca48:	e0bffd0b 	ldhu	r2,-12(fp)
8112ca4c:	10800044 	addi	r2,r2,1
8112ca50:	e0bffd0d 	sth	r2,-12(fp)
8112ca54:	e0bffd0b 	ldhu	r2,-12(fp)
8112ca58:	108004f0 	cmpltui	r2,r2,19
8112ca5c:	103fea1e 	bne	r2,zero,8112ca08 <__reset+0xfb10ca08>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8112ca60:	e0bffe17 	ldw	r2,-8(fp)
8112ca64:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
8112ca68:	e0bffe17 	ldw	r2,-8(fp)
8112ca6c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
8112ca70:	e0bffe17 	ldw	r2,-8(fp)
8112ca74:	00c00fc4 	movi	r3,63
8112ca78:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8112ca7c:	e0bffe17 	ldw	r2,-8(fp)
8112ca80:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8112ca84:	00a04574 	movhi	r2,33045
8112ca88:	10831f04 	addi	r2,r2,3196
8112ca8c:	d0a08a15 	stw	r2,-32216(gp)
#endif
}
8112ca90:	0001883a 	nop
8112ca94:	e037883a 	mov	sp,fp
8112ca98:	dfc00117 	ldw	ra,4(sp)
8112ca9c:	df000017 	ldw	fp,0(sp)
8112caa0:	dec00204 	addi	sp,sp,8
8112caa4:	f800283a 	ret

8112caa8 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
8112caa8:	defffa04 	addi	sp,sp,-24
8112caac:	de00012e 	bgeu	sp,et,8112cab4 <OS_FlagTaskRdy+0xc>
8112cab0:	003b68fa 	trap	3
8112cab4:	dfc00515 	stw	ra,20(sp)
8112cab8:	df000415 	stw	fp,16(sp)
8112cabc:	df000404 	addi	fp,sp,16
8112cac0:	e13ffe15 	stw	r4,-8(fp)
8112cac4:	2805883a 	mov	r2,r5
8112cac8:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
8112cacc:	e0bffe17 	ldw	r2,-8(fp)
8112cad0:	10800217 	ldw	r2,8(r2)
8112cad4:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
8112cad8:	e0bffd17 	ldw	r2,-12(fp)
8112cadc:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
8112cae0:	e0bffd17 	ldw	r2,-12(fp)
8112cae4:	e0ffff0b 	ldhu	r3,-4(fp)
8112cae8:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
8112caec:	e0bffd17 	ldw	r2,-12(fp)
8112caf0:	10c00c03 	ldbu	r3,48(r2)
8112caf4:	00bff7c4 	movi	r2,-33
8112caf8:	1884703a 	and	r2,r3,r2
8112cafc:	1007883a 	mov	r3,r2
8112cb00:	e0bffd17 	ldw	r2,-12(fp)
8112cb04:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
8112cb08:	e0bffd17 	ldw	r2,-12(fp)
8112cb0c:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
8112cb10:	e0bffd17 	ldw	r2,-12(fp)
8112cb14:	10800c03 	ldbu	r2,48(r2)
8112cb18:	10803fcc 	andi	r2,r2,255
8112cb1c:	1000181e 	bne	r2,zero,8112cb80 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
8112cb20:	e0bffd17 	ldw	r2,-12(fp)
8112cb24:	10c00d83 	ldbu	r3,54(r2)
8112cb28:	d0a08203 	ldbu	r2,-32248(gp)
8112cb2c:	1884b03a 	or	r2,r3,r2
8112cb30:	d0a08205 	stb	r2,-32248(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8112cb34:	e0bffd17 	ldw	r2,-12(fp)
8112cb38:	10800d03 	ldbu	r2,52(r2)
8112cb3c:	10c03fcc 	andi	r3,r2,255
8112cb40:	e0bffd17 	ldw	r2,-12(fp)
8112cb44:	10800d03 	ldbu	r2,52(r2)
8112cb48:	11003fcc 	andi	r4,r2,255
8112cb4c:	d0a08244 	addi	r2,gp,-32247
8112cb50:	2085883a 	add	r2,r4,r2
8112cb54:	11000003 	ldbu	r4,0(r2)
8112cb58:	e0bffd17 	ldw	r2,-12(fp)
8112cb5c:	10800d43 	ldbu	r2,53(r2)
8112cb60:	2084b03a 	or	r2,r4,r2
8112cb64:	1009883a 	mov	r4,r2
8112cb68:	d0a08244 	addi	r2,gp,-32247
8112cb6c:	1885883a 	add	r2,r3,r2
8112cb70:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
8112cb74:	00800044 	movi	r2,1
8112cb78:	e0bffc05 	stb	r2,-16(fp)
8112cb7c:	00000106 	br	8112cb84 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
8112cb80:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8112cb84:	e13ffe17 	ldw	r4,-8(fp)
8112cb88:	112cba40 	call	8112cba4 <OS_FlagUnlink>
    return (sched);
8112cb8c:	e0bffc03 	ldbu	r2,-16(fp)
}
8112cb90:	e037883a 	mov	sp,fp
8112cb94:	dfc00117 	ldw	ra,4(sp)
8112cb98:	df000017 	ldw	fp,0(sp)
8112cb9c:	dec00204 	addi	sp,sp,8
8112cba0:	f800283a 	ret

8112cba4 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8112cba4:	defffa04 	addi	sp,sp,-24
8112cba8:	de00012e 	bgeu	sp,et,8112cbb0 <OS_FlagUnlink+0xc>
8112cbac:	003b68fa 	trap	3
8112cbb0:	df000515 	stw	fp,20(sp)
8112cbb4:	df000504 	addi	fp,sp,20
8112cbb8:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
8112cbbc:	e0bfff17 	ldw	r2,-4(fp)
8112cbc0:	10800117 	ldw	r2,4(r2)
8112cbc4:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8112cbc8:	e0bfff17 	ldw	r2,-4(fp)
8112cbcc:	10800017 	ldw	r2,0(r2)
8112cbd0:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
8112cbd4:	e0bffb17 	ldw	r2,-20(fp)
8112cbd8:	10000b1e 	bne	r2,zero,8112cc08 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
8112cbdc:	e0bfff17 	ldw	r2,-4(fp)
8112cbe0:	10800317 	ldw	r2,12(r2)
8112cbe4:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
8112cbe8:	e0bffd17 	ldw	r2,-12(fp)
8112cbec:	e0fffc17 	ldw	r3,-16(fp)
8112cbf0:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
8112cbf4:	e0bffc17 	ldw	r2,-16(fp)
8112cbf8:	10000b26 	beq	r2,zero,8112cc28 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8112cbfc:	e0bffc17 	ldw	r2,-16(fp)
8112cc00:	10000115 	stw	zero,4(r2)
8112cc04:	00000806 	br	8112cc28 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8112cc08:	e0bffb17 	ldw	r2,-20(fp)
8112cc0c:	e0fffc17 	ldw	r3,-16(fp)
8112cc10:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8112cc14:	e0bffc17 	ldw	r2,-16(fp)
8112cc18:	10000326 	beq	r2,zero,8112cc28 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
8112cc1c:	e0bffc17 	ldw	r2,-16(fp)
8112cc20:	e0fffb17 	ldw	r3,-20(fp)
8112cc24:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
8112cc28:	e0bfff17 	ldw	r2,-4(fp)
8112cc2c:	10800217 	ldw	r2,8(r2)
8112cc30:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
8112cc34:	e0bffe17 	ldw	r2,-8(fp)
8112cc38:	10000a15 	stw	zero,40(r2)
#endif
}
8112cc3c:	0001883a 	nop
8112cc40:	e037883a 	mov	sp,fp
8112cc44:	df000017 	ldw	fp,0(sp)
8112cc48:	dec00104 	addi	sp,sp,4
8112cc4c:	f800283a 	ret

8112cc50 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
8112cc50:	defff404 	addi	sp,sp,-48
8112cc54:	de00012e 	bgeu	sp,et,8112cc5c <OSMemCreate+0xc>
8112cc58:	003b68fa 	trap	3
8112cc5c:	df000b15 	stw	fp,44(sp)
8112cc60:	df000b04 	addi	fp,sp,44
8112cc64:	e13ffc15 	stw	r4,-16(fp)
8112cc68:	e17ffd15 	stw	r5,-12(fp)
8112cc6c:	e1bffe15 	stw	r6,-8(fp)
8112cc70:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8112cc74:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8112cc78:	e0bfff17 	ldw	r2,-4(fp)
8112cc7c:	1000021e 	bne	r2,zero,8112cc88 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
8112cc80:	0005883a 	mov	r2,zero
8112cc84:	00006506 	br	8112ce1c <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8112cc88:	e0bffc17 	ldw	r2,-16(fp)
8112cc8c:	1000051e 	bne	r2,zero,8112cca4 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8112cc90:	e0bfff17 	ldw	r2,-4(fp)
8112cc94:	00c01884 	movi	r3,98
8112cc98:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8112cc9c:	0005883a 	mov	r2,zero
8112cca0:	00005e06 	br	8112ce1c <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8112cca4:	e0bffc17 	ldw	r2,-16(fp)
8112cca8:	108000cc 	andi	r2,r2,3
8112ccac:	10000526 	beq	r2,zero,8112ccc4 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8112ccb0:	e0bfff17 	ldw	r2,-4(fp)
8112ccb4:	00c01884 	movi	r3,98
8112ccb8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8112ccbc:	0005883a 	mov	r2,zero
8112ccc0:	00005606 	br	8112ce1c <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
8112ccc4:	e0bffd17 	ldw	r2,-12(fp)
8112ccc8:	108000a8 	cmpgeui	r2,r2,2
8112cccc:	1000051e 	bne	r2,zero,8112cce4 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
8112ccd0:	e0bfff17 	ldw	r2,-4(fp)
8112ccd4:	00c016c4 	movi	r3,91
8112ccd8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8112ccdc:	0005883a 	mov	r2,zero
8112cce0:	00004e06 	br	8112ce1c <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
8112cce4:	e0bffe17 	ldw	r2,-8(fp)
8112cce8:	10800128 	cmpgeui	r2,r2,4
8112ccec:	1000051e 	bne	r2,zero,8112cd04 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
8112ccf0:	e0bfff17 	ldw	r2,-4(fp)
8112ccf4:	00c01704 	movi	r3,92
8112ccf8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8112ccfc:	0005883a 	mov	r2,zero
8112cd00:	00004606 	br	8112ce1c <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112cd04:	0005303a 	rdctl	r2,status
8112cd08:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112cd0c:	e0fffb17 	ldw	r3,-20(fp)
8112cd10:	00bfff84 	movi	r2,-2
8112cd14:	1884703a 	and	r2,r3,r2
8112cd18:	1001703a 	wrctl	status,r2
  
  return context;
8112cd1c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8112cd20:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
8112cd24:	d0a07f17 	ldw	r2,-32260(gp)
8112cd28:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
8112cd2c:	d0a07f17 	ldw	r2,-32260(gp)
8112cd30:	10000326 	beq	r2,zero,8112cd40 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
8112cd34:	d0a07f17 	ldw	r2,-32260(gp)
8112cd38:	10800117 	ldw	r2,4(r2)
8112cd3c:	d0a07f15 	stw	r2,-32260(gp)
8112cd40:	e0bff817 	ldw	r2,-32(fp)
8112cd44:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112cd48:	e0bff917 	ldw	r2,-28(fp)
8112cd4c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
8112cd50:	e0bffa17 	ldw	r2,-24(fp)
8112cd54:	1000051e 	bne	r2,zero,8112cd6c <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
8112cd58:	e0bfff17 	ldw	r2,-4(fp)
8112cd5c:	00c01684 	movi	r3,90
8112cd60:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8112cd64:	0005883a 	mov	r2,zero
8112cd68:	00002c06 	br	8112ce1c <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
8112cd6c:	e0bffc17 	ldw	r2,-16(fp)
8112cd70:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
8112cd74:	e0fffc17 	ldw	r3,-16(fp)
8112cd78:	e0bffe17 	ldw	r2,-8(fp)
8112cd7c:	1885883a 	add	r2,r3,r2
8112cd80:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
8112cd84:	e03ff715 	stw	zero,-36(fp)
8112cd88:	00000c06 	br	8112cdbc <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8112cd8c:	e0bff617 	ldw	r2,-40(fp)
8112cd90:	e0fff517 	ldw	r3,-44(fp)
8112cd94:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8112cd98:	e0bff517 	ldw	r2,-44(fp)
8112cd9c:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
8112cda0:	e0fff517 	ldw	r3,-44(fp)
8112cda4:	e0bffe17 	ldw	r2,-8(fp)
8112cda8:	1885883a 	add	r2,r3,r2
8112cdac:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
8112cdb0:	e0bff717 	ldw	r2,-36(fp)
8112cdb4:	10800044 	addi	r2,r2,1
8112cdb8:	e0bff715 	stw	r2,-36(fp)
8112cdbc:	e0bffd17 	ldw	r2,-12(fp)
8112cdc0:	10bfffc4 	addi	r2,r2,-1
8112cdc4:	e0fff717 	ldw	r3,-36(fp)
8112cdc8:	18bff036 	bltu	r3,r2,8112cd8c <__reset+0xfb10cd8c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8112cdcc:	e0bff617 	ldw	r2,-40(fp)
8112cdd0:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
8112cdd4:	e0bffa17 	ldw	r2,-24(fp)
8112cdd8:	e0fffc17 	ldw	r3,-16(fp)
8112cddc:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
8112cde0:	e0bffa17 	ldw	r2,-24(fp)
8112cde4:	e0fffc17 	ldw	r3,-16(fp)
8112cde8:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8112cdec:	e0bffa17 	ldw	r2,-24(fp)
8112cdf0:	e0fffd17 	ldw	r3,-12(fp)
8112cdf4:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
8112cdf8:	e0bffa17 	ldw	r2,-24(fp)
8112cdfc:	e0fffd17 	ldw	r3,-12(fp)
8112ce00:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
8112ce04:	e0bffa17 	ldw	r2,-24(fp)
8112ce08:	e0fffe17 	ldw	r3,-8(fp)
8112ce0c:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
8112ce10:	e0bfff17 	ldw	r2,-4(fp)
8112ce14:	10000005 	stb	zero,0(r2)
    return (pmem);
8112ce18:	e0bffa17 	ldw	r2,-24(fp)
}
8112ce1c:	e037883a 	mov	sp,fp
8112ce20:	df000017 	ldw	fp,0(sp)
8112ce24:	dec00104 	addi	sp,sp,4
8112ce28:	f800283a 	ret

8112ce2c <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
8112ce2c:	defff804 	addi	sp,sp,-32
8112ce30:	de00012e 	bgeu	sp,et,8112ce38 <OSMemGet+0xc>
8112ce34:	003b68fa 	trap	3
8112ce38:	df000715 	stw	fp,28(sp)
8112ce3c:	df000704 	addi	fp,sp,28
8112ce40:	e13ffe15 	stw	r4,-8(fp)
8112ce44:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8112ce48:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8112ce4c:	e0bfff17 	ldw	r2,-4(fp)
8112ce50:	1000021e 	bne	r2,zero,8112ce5c <OSMemGet+0x30>
        return ((void *)0);
8112ce54:	0005883a 	mov	r2,zero
8112ce58:	00002e06 	br	8112cf14 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
8112ce5c:	e0bffe17 	ldw	r2,-8(fp)
8112ce60:	1000051e 	bne	r2,zero,8112ce78 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8112ce64:	e0bfff17 	ldw	r2,-4(fp)
8112ce68:	00c01804 	movi	r3,96
8112ce6c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8112ce70:	0005883a 	mov	r2,zero
8112ce74:	00002706 	br	8112cf14 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ce78:	0005303a 	rdctl	r2,status
8112ce7c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ce80:	e0fffd17 	ldw	r3,-12(fp)
8112ce84:	00bfff84 	movi	r2,-2
8112ce88:	1884703a 	and	r2,r3,r2
8112ce8c:	1001703a 	wrctl	status,r2
  
  return context;
8112ce90:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8112ce94:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8112ce98:	e0bffe17 	ldw	r2,-8(fp)
8112ce9c:	10800417 	ldw	r2,16(r2)
8112cea0:	10001426 	beq	r2,zero,8112cef4 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
8112cea4:	e0bffe17 	ldw	r2,-8(fp)
8112cea8:	10800117 	ldw	r2,4(r2)
8112ceac:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
8112ceb0:	e0bffb17 	ldw	r2,-20(fp)
8112ceb4:	10c00017 	ldw	r3,0(r2)
8112ceb8:	e0bffe17 	ldw	r2,-8(fp)
8112cebc:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
8112cec0:	e0bffe17 	ldw	r2,-8(fp)
8112cec4:	10800417 	ldw	r2,16(r2)
8112cec8:	10ffffc4 	addi	r3,r2,-1
8112cecc:	e0bffe17 	ldw	r2,-8(fp)
8112ced0:	10c00415 	stw	r3,16(r2)
8112ced4:	e0bff917 	ldw	r2,-28(fp)
8112ced8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112cedc:	e0bffa17 	ldw	r2,-24(fp)
8112cee0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
8112cee4:	e0bfff17 	ldw	r2,-4(fp)
8112cee8:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8112ceec:	e0bffb17 	ldw	r2,-20(fp)
8112cef0:	00000806 	br	8112cf14 <OSMemGet+0xe8>
8112cef4:	e0bff917 	ldw	r2,-28(fp)
8112cef8:	e0bffc15 	stw	r2,-16(fp)
8112cefc:	e0bffc17 	ldw	r2,-16(fp)
8112cf00:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
8112cf04:	e0bfff17 	ldw	r2,-4(fp)
8112cf08:	00c01744 	movi	r3,93
8112cf0c:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
8112cf10:	0005883a 	mov	r2,zero
}
8112cf14:	e037883a 	mov	sp,fp
8112cf18:	df000017 	ldw	fp,0(sp)
8112cf1c:	dec00104 	addi	sp,sp,4
8112cf20:	f800283a 	ret

8112cf24 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8112cf24:	defff704 	addi	sp,sp,-36
8112cf28:	de00012e 	bgeu	sp,et,8112cf30 <OSMemNameGet+0xc>
8112cf2c:	003b68fa 	trap	3
8112cf30:	dfc00815 	stw	ra,32(sp)
8112cf34:	df000715 	stw	fp,28(sp)
8112cf38:	df000704 	addi	fp,sp,28
8112cf3c:	e13ffd15 	stw	r4,-12(fp)
8112cf40:	e17ffe15 	stw	r5,-8(fp)
8112cf44:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112cf48:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112cf4c:	e0bfff17 	ldw	r2,-4(fp)
8112cf50:	1000021e 	bne	r2,zero,8112cf5c <OSMemNameGet+0x38>
        return (0);
8112cf54:	0005883a 	mov	r2,zero
8112cf58:	00002b06 	br	8112d008 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8112cf5c:	e0bffd17 	ldw	r2,-12(fp)
8112cf60:	1000051e 	bne	r2,zero,8112cf78 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8112cf64:	e0bfff17 	ldw	r2,-4(fp)
8112cf68:	00c01804 	movi	r3,96
8112cf6c:	10c00005 	stb	r3,0(r2)
        return (0);
8112cf70:	0005883a 	mov	r2,zero
8112cf74:	00002406 	br	8112d008 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112cf78:	e0bffe17 	ldw	r2,-8(fp)
8112cf7c:	1000051e 	bne	r2,zero,8112cf94 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8112cf80:	e0bfff17 	ldw	r2,-4(fp)
8112cf84:	00c00304 	movi	r3,12
8112cf88:	10c00005 	stb	r3,0(r2)
        return (0);
8112cf8c:	0005883a 	mov	r2,zero
8112cf90:	00001d06 	br	8112d008 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112cf94:	d0a08503 	ldbu	r2,-32236(gp)
8112cf98:	10803fcc 	andi	r2,r2,255
8112cf9c:	10000526 	beq	r2,zero,8112cfb4 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8112cfa0:	e0bfff17 	ldw	r2,-4(fp)
8112cfa4:	00c00444 	movi	r3,17
8112cfa8:	10c00005 	stb	r3,0(r2)
        return (0);
8112cfac:	0005883a 	mov	r2,zero
8112cfb0:	00001506 	br	8112d008 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112cfb4:	0005303a 	rdctl	r2,status
8112cfb8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112cfbc:	e0fffb17 	ldw	r3,-20(fp)
8112cfc0:	00bfff84 	movi	r2,-2
8112cfc4:	1884703a 	and	r2,r3,r2
8112cfc8:	1001703a 	wrctl	status,r2
  
  return context;
8112cfcc:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8112cfd0:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
8112cfd4:	e0bffd17 	ldw	r2,-12(fp)
8112cfd8:	10800504 	addi	r2,r2,20
8112cfdc:	100b883a 	mov	r5,r2
8112cfe0:	e13ffe17 	ldw	r4,-8(fp)
8112cfe4:	112ad0c0 	call	8112ad0c <OS_StrCopy>
8112cfe8:	e0bffa05 	stb	r2,-24(fp)
8112cfec:	e0bff917 	ldw	r2,-28(fp)
8112cff0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112cff4:	e0bffc17 	ldw	r2,-16(fp)
8112cff8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112cffc:	e0bfff17 	ldw	r2,-4(fp)
8112d000:	10000005 	stb	zero,0(r2)
    return (len);
8112d004:	e0bffa03 	ldbu	r2,-24(fp)
}
8112d008:	e037883a 	mov	sp,fp
8112d00c:	dfc00117 	ldw	ra,4(sp)
8112d010:	df000017 	ldw	fp,0(sp)
8112d014:	dec00204 	addi	sp,sp,8
8112d018:	f800283a 	ret

8112d01c <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8112d01c:	defff604 	addi	sp,sp,-40
8112d020:	de00012e 	bgeu	sp,et,8112d028 <OSMemNameSet+0xc>
8112d024:	003b68fa 	trap	3
8112d028:	dfc00915 	stw	ra,36(sp)
8112d02c:	df000815 	stw	fp,32(sp)
8112d030:	df000804 	addi	fp,sp,32
8112d034:	e13ffd15 	stw	r4,-12(fp)
8112d038:	e17ffe15 	stw	r5,-8(fp)
8112d03c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112d040:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112d044:	e0bfff17 	ldw	r2,-4(fp)
8112d048:	10003526 	beq	r2,zero,8112d120 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8112d04c:	e0bffd17 	ldw	r2,-12(fp)
8112d050:	1000041e 	bne	r2,zero,8112d064 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8112d054:	e0bfff17 	ldw	r2,-4(fp)
8112d058:	00c01804 	movi	r3,96
8112d05c:	10c00005 	stb	r3,0(r2)
        return;
8112d060:	00003006 	br	8112d124 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112d064:	e0bffe17 	ldw	r2,-8(fp)
8112d068:	1000041e 	bne	r2,zero,8112d07c <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8112d06c:	e0bfff17 	ldw	r2,-4(fp)
8112d070:	00c00304 	movi	r3,12
8112d074:	10c00005 	stb	r3,0(r2)
        return;
8112d078:	00002a06 	br	8112d124 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112d07c:	d0a08503 	ldbu	r2,-32236(gp)
8112d080:	10803fcc 	andi	r2,r2,255
8112d084:	10000426 	beq	r2,zero,8112d098 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8112d088:	e0bfff17 	ldw	r2,-4(fp)
8112d08c:	00c00484 	movi	r3,18
8112d090:	10c00005 	stb	r3,0(r2)
        return;
8112d094:	00002306 	br	8112d124 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d098:	0005303a 	rdctl	r2,status
8112d09c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d0a0:	e0fffc17 	ldw	r3,-16(fp)
8112d0a4:	00bfff84 	movi	r2,-2
8112d0a8:	1884703a 	and	r2,r3,r2
8112d0ac:	1001703a 	wrctl	status,r2
  
  return context;
8112d0b0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112d0b4:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8112d0b8:	e13ffe17 	ldw	r4,-8(fp)
8112d0bc:	112ad880 	call	8112ad88 <OS_StrLen>
8112d0c0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
8112d0c4:	e0bffa03 	ldbu	r2,-24(fp)
8112d0c8:	10800830 	cmpltui	r2,r2,32
8112d0cc:	1000081e 	bne	r2,zero,8112d0f0 <OSMemNameSet+0xd4>
8112d0d0:	e0bff817 	ldw	r2,-32(fp)
8112d0d4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d0d8:	e0bff917 	ldw	r2,-28(fp)
8112d0dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8112d0e0:	e0bfff17 	ldw	r2,-4(fp)
8112d0e4:	00c018c4 	movi	r3,99
8112d0e8:	10c00005 	stb	r3,0(r2)
        return;
8112d0ec:	00000d06 	br	8112d124 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8112d0f0:	e0bffd17 	ldw	r2,-12(fp)
8112d0f4:	10800504 	addi	r2,r2,20
8112d0f8:	e17ffe17 	ldw	r5,-8(fp)
8112d0fc:	1009883a 	mov	r4,r2
8112d100:	112ad0c0 	call	8112ad0c <OS_StrCopy>
8112d104:	e0bff817 	ldw	r2,-32(fp)
8112d108:	e0bffb15 	stw	r2,-20(fp)
8112d10c:	e0bffb17 	ldw	r2,-20(fp)
8112d110:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112d114:	e0bfff17 	ldw	r2,-4(fp)
8112d118:	10000005 	stb	zero,0(r2)
8112d11c:	00000106 	br	8112d124 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8112d120:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8112d124:	e037883a 	mov	sp,fp
8112d128:	dfc00117 	ldw	ra,4(sp)
8112d12c:	df000017 	ldw	fp,0(sp)
8112d130:	dec00204 	addi	sp,sp,8
8112d134:	f800283a 	ret

8112d138 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8112d138:	defff904 	addi	sp,sp,-28
8112d13c:	de00012e 	bgeu	sp,et,8112d144 <OSMemPut+0xc>
8112d140:	003b68fa 	trap	3
8112d144:	df000615 	stw	fp,24(sp)
8112d148:	df000604 	addi	fp,sp,24
8112d14c:	e13ffe15 	stw	r4,-8(fp)
8112d150:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112d154:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8112d158:	e0bffe17 	ldw	r2,-8(fp)
8112d15c:	1000021e 	bne	r2,zero,8112d168 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8112d160:	00801804 	movi	r2,96
8112d164:	00002806 	br	8112d208 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8112d168:	e0bfff17 	ldw	r2,-4(fp)
8112d16c:	1000021e 	bne	r2,zero,8112d178 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
8112d170:	008017c4 	movi	r2,95
8112d174:	00002406 	br	8112d208 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d178:	0005303a 	rdctl	r2,status
8112d17c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d180:	e0fffd17 	ldw	r3,-12(fp)
8112d184:	00bfff84 	movi	r2,-2
8112d188:	1884703a 	and	r2,r3,r2
8112d18c:	1001703a 	wrctl	status,r2
  
  return context;
8112d190:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8112d194:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8112d198:	e0bffe17 	ldw	r2,-8(fp)
8112d19c:	10c00417 	ldw	r3,16(r2)
8112d1a0:	e0bffe17 	ldw	r2,-8(fp)
8112d1a4:	10800317 	ldw	r2,12(r2)
8112d1a8:	18800636 	bltu	r3,r2,8112d1c4 <OSMemPut+0x8c>
8112d1ac:	e0bffa17 	ldw	r2,-24(fp)
8112d1b0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d1b4:	e0bffb17 	ldw	r2,-20(fp)
8112d1b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8112d1bc:	00801784 	movi	r2,94
8112d1c0:	00001106 	br	8112d208 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
8112d1c4:	e0bffe17 	ldw	r2,-8(fp)
8112d1c8:	10c00117 	ldw	r3,4(r2)
8112d1cc:	e0bfff17 	ldw	r2,-4(fp)
8112d1d0:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
8112d1d4:	e0bffe17 	ldw	r2,-8(fp)
8112d1d8:	e0ffff17 	ldw	r3,-4(fp)
8112d1dc:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8112d1e0:	e0bffe17 	ldw	r2,-8(fp)
8112d1e4:	10800417 	ldw	r2,16(r2)
8112d1e8:	10c00044 	addi	r3,r2,1
8112d1ec:	e0bffe17 	ldw	r2,-8(fp)
8112d1f0:	10c00415 	stw	r3,16(r2)
8112d1f4:	e0bffa17 	ldw	r2,-24(fp)
8112d1f8:	e0bffc15 	stw	r2,-16(fp)
8112d1fc:	e0bffc17 	ldw	r2,-16(fp)
8112d200:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
8112d204:	0005883a 	mov	r2,zero
}
8112d208:	e037883a 	mov	sp,fp
8112d20c:	df000017 	ldw	fp,0(sp)
8112d210:	dec00104 	addi	sp,sp,4
8112d214:	f800283a 	ret

8112d218 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
8112d218:	defffa04 	addi	sp,sp,-24
8112d21c:	de00012e 	bgeu	sp,et,8112d224 <OSMemQuery+0xc>
8112d220:	003b68fa 	trap	3
8112d224:	df000515 	stw	fp,20(sp)
8112d228:	df000504 	addi	fp,sp,20
8112d22c:	e13ffe15 	stw	r4,-8(fp)
8112d230:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112d234:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8112d238:	e0bffe17 	ldw	r2,-8(fp)
8112d23c:	1000021e 	bne	r2,zero,8112d248 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8112d240:	00801804 	movi	r2,96
8112d244:	00002c06 	br	8112d2f8 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8112d248:	e0bfff17 	ldw	r2,-4(fp)
8112d24c:	1000021e 	bne	r2,zero,8112d258 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
8112d250:	00801844 	movi	r2,97
8112d254:	00002806 	br	8112d2f8 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d258:	0005303a 	rdctl	r2,status
8112d25c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d260:	e0fffc17 	ldw	r3,-16(fp)
8112d264:	00bfff84 	movi	r2,-2
8112d268:	1884703a 	and	r2,r3,r2
8112d26c:	1001703a 	wrctl	status,r2
  
  return context;
8112d270:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8112d274:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8112d278:	e0bffe17 	ldw	r2,-8(fp)
8112d27c:	10c00017 	ldw	r3,0(r2)
8112d280:	e0bfff17 	ldw	r2,-4(fp)
8112d284:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8112d288:	e0bffe17 	ldw	r2,-8(fp)
8112d28c:	10c00117 	ldw	r3,4(r2)
8112d290:	e0bfff17 	ldw	r2,-4(fp)
8112d294:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8112d298:	e0bffe17 	ldw	r2,-8(fp)
8112d29c:	10c00217 	ldw	r3,8(r2)
8112d2a0:	e0bfff17 	ldw	r2,-4(fp)
8112d2a4:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8112d2a8:	e0bffe17 	ldw	r2,-8(fp)
8112d2ac:	10c00317 	ldw	r3,12(r2)
8112d2b0:	e0bfff17 	ldw	r2,-4(fp)
8112d2b4:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8112d2b8:	e0bffe17 	ldw	r2,-8(fp)
8112d2bc:	10c00417 	ldw	r3,16(r2)
8112d2c0:	e0bfff17 	ldw	r2,-4(fp)
8112d2c4:	10c00415 	stw	r3,16(r2)
8112d2c8:	e0bffb17 	ldw	r2,-20(fp)
8112d2cc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d2d0:	e0bffd17 	ldw	r2,-12(fp)
8112d2d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8112d2d8:	e0bfff17 	ldw	r2,-4(fp)
8112d2dc:	10c00317 	ldw	r3,12(r2)
8112d2e0:	e0bfff17 	ldw	r2,-4(fp)
8112d2e4:	10800417 	ldw	r2,16(r2)
8112d2e8:	1887c83a 	sub	r3,r3,r2
8112d2ec:	e0bfff17 	ldw	r2,-4(fp)
8112d2f0:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
8112d2f4:	0005883a 	mov	r2,zero
}
8112d2f8:	e037883a 	mov	sp,fp
8112d2fc:	df000017 	ldw	fp,0(sp)
8112d300:	dec00104 	addi	sp,sp,4
8112d304:	f800283a 	ret

8112d308 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8112d308:	defffc04 	addi	sp,sp,-16
8112d30c:	de00012e 	bgeu	sp,et,8112d314 <OS_MemInit+0xc>
8112d310:	003b68fa 	trap	3
8112d314:	dfc00315 	stw	ra,12(sp)
8112d318:	df000215 	stw	fp,8(sp)
8112d31c:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
8112d320:	01430c04 	movi	r5,3120
8112d324:	01204574 	movhi	r4,33045
8112d328:	21046304 	addi	r4,r4,4492
8112d32c:	112aaec0 	call	8112aaec <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
8112d330:	00a04574 	movhi	r2,33045
8112d334:	10846304 	addi	r2,r2,4492
8112d338:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8112d33c:	e03fff0d 	sth	zero,-4(fp)
8112d340:	00001306 	br	8112d390 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8112d344:	e0bfff0b 	ldhu	r2,-4(fp)
8112d348:	10800044 	addi	r2,r2,1
8112d34c:	10c00d24 	muli	r3,r2,52
8112d350:	00a04574 	movhi	r2,33045
8112d354:	10846304 	addi	r2,r2,4492
8112d358:	1887883a 	add	r3,r3,r2
8112d35c:	e0bffe17 	ldw	r2,-8(fp)
8112d360:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8112d364:	e0bffe17 	ldw	r2,-8(fp)
8112d368:	00c00fc4 	movi	r3,63
8112d36c:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
8112d370:	e0bffe17 	ldw	r2,-8(fp)
8112d374:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8112d378:	e0bffe17 	ldw	r2,-8(fp)
8112d37c:	10800d04 	addi	r2,r2,52
8112d380:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8112d384:	e0bfff0b 	ldhu	r2,-4(fp)
8112d388:	10800044 	addi	r2,r2,1
8112d38c:	e0bfff0d 	sth	r2,-4(fp)
8112d390:	e0bfff0b 	ldhu	r2,-4(fp)
8112d394:	10800ef0 	cmpltui	r2,r2,59
8112d398:	103fea1e 	bne	r2,zero,8112d344 <__reset+0xfb10d344>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8112d39c:	e0bffe17 	ldw	r2,-8(fp)
8112d3a0:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8112d3a4:	e0bffe17 	ldw	r2,-8(fp)
8112d3a8:	00c00fc4 	movi	r3,63
8112d3ac:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8112d3b0:	e0bffe17 	ldw	r2,-8(fp)
8112d3b4:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8112d3b8:	00a04574 	movhi	r2,33045
8112d3bc:	10846304 	addi	r2,r2,4492
8112d3c0:	d0a07f15 	stw	r2,-32260(gp)
#endif
}
8112d3c4:	0001883a 	nop
8112d3c8:	e037883a 	mov	sp,fp
8112d3cc:	dfc00117 	ldw	ra,4(sp)
8112d3d0:	df000017 	ldw	fp,0(sp)
8112d3d4:	dec00204 	addi	sp,sp,8
8112d3d8:	f800283a 	ret

8112d3dc <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8112d3dc:	defff704 	addi	sp,sp,-36
8112d3e0:	de00012e 	bgeu	sp,et,8112d3e8 <OSMutexAccept+0xc>
8112d3e4:	003b68fa 	trap	3
8112d3e8:	df000815 	stw	fp,32(sp)
8112d3ec:	df000804 	addi	fp,sp,32
8112d3f0:	e13ffe15 	stw	r4,-8(fp)
8112d3f4:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8112d3f8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8112d3fc:	e0bfff17 	ldw	r2,-4(fp)
8112d400:	1000021e 	bne	r2,zero,8112d40c <OSMutexAccept+0x30>
        return (OS_FALSE);
8112d404:	0005883a 	mov	r2,zero
8112d408:	00005b06 	br	8112d578 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8112d40c:	e0bffe17 	ldw	r2,-8(fp)
8112d410:	1000051e 	bne	r2,zero,8112d428 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8112d414:	e0bfff17 	ldw	r2,-4(fp)
8112d418:	00c00104 	movi	r3,4
8112d41c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8112d420:	0005883a 	mov	r2,zero
8112d424:	00005406 	br	8112d578 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
8112d428:	e0bffe17 	ldw	r2,-8(fp)
8112d42c:	10800003 	ldbu	r2,0(r2)
8112d430:	10803fcc 	andi	r2,r2,255
8112d434:	10800120 	cmpeqi	r2,r2,4
8112d438:	1000051e 	bne	r2,zero,8112d450 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8112d43c:	e0bfff17 	ldw	r2,-4(fp)
8112d440:	00c00044 	movi	r3,1
8112d444:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8112d448:	0005883a 	mov	r2,zero
8112d44c:	00004a06 	br	8112d578 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
8112d450:	d0a08503 	ldbu	r2,-32236(gp)
8112d454:	10803fcc 	andi	r2,r2,255
8112d458:	10000526 	beq	r2,zero,8112d470 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8112d45c:	e0bfff17 	ldw	r2,-4(fp)
8112d460:	00c00084 	movi	r3,2
8112d464:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8112d468:	0005883a 	mov	r2,zero
8112d46c:	00004206 	br	8112d578 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d470:	0005303a 	rdctl	r2,status
8112d474:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d478:	e0fffd17 	ldw	r3,-12(fp)
8112d47c:	00bfff84 	movi	r2,-2
8112d480:	1884703a 	and	r2,r3,r2
8112d484:	1001703a 	wrctl	status,r2
  
  return context;
8112d488:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8112d48c:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8112d490:	e0bffe17 	ldw	r2,-8(fp)
8112d494:	1080020b 	ldhu	r2,8(r2)
8112d498:	10bfffcc 	andi	r2,r2,65535
8112d49c:	1004d23a 	srli	r2,r2,8
8112d4a0:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8112d4a4:	e0bffe17 	ldw	r2,-8(fp)
8112d4a8:	1080020b 	ldhu	r2,8(r2)
8112d4ac:	10bfffcc 	andi	r2,r2,65535
8112d4b0:	10803fcc 	andi	r2,r2,255
8112d4b4:	10803fd8 	cmpnei	r2,r2,255
8112d4b8:	1000281e 	bne	r2,zero,8112d55c <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8112d4bc:	e0bffe17 	ldw	r2,-8(fp)
8112d4c0:	10c0020b 	ldhu	r3,8(r2)
8112d4c4:	00bfc004 	movi	r2,-256
8112d4c8:	1884703a 	and	r2,r3,r2
8112d4cc:	1007883a 	mov	r3,r2
8112d4d0:	e0bffe17 	ldw	r2,-8(fp)
8112d4d4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8112d4d8:	e0bffe17 	ldw	r2,-8(fp)
8112d4dc:	10c0020b 	ldhu	r3,8(r2)
8112d4e0:	d0a08617 	ldw	r2,-32232(gp)
8112d4e4:	10800c83 	ldbu	r2,50(r2)
8112d4e8:	10803fcc 	andi	r2,r2,255
8112d4ec:	1884b03a 	or	r2,r3,r2
8112d4f0:	1007883a 	mov	r3,r2
8112d4f4:	e0bffe17 	ldw	r2,-8(fp)
8112d4f8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8112d4fc:	d0e08617 	ldw	r3,-32232(gp)
8112d500:	e0bffe17 	ldw	r2,-8(fp)
8112d504:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8112d508:	d0a08617 	ldw	r2,-32232(gp)
8112d50c:	10800c83 	ldbu	r2,50(r2)
8112d510:	10803fcc 	andi	r2,r2,255
8112d514:	e0fffa03 	ldbu	r3,-24(fp)
8112d518:	18800836 	bltu	r3,r2,8112d53c <OSMutexAccept+0x160>
8112d51c:	e0bff817 	ldw	r2,-32(fp)
8112d520:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d524:	e0bff917 	ldw	r2,-28(fp)
8112d528:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8112d52c:	e0bfff17 	ldw	r2,-4(fp)
8112d530:	00c01e04 	movi	r3,120
8112d534:	10c00005 	stb	r3,0(r2)
8112d538:	00000606 	br	8112d554 <OSMutexAccept+0x178>
8112d53c:	e0bff817 	ldw	r2,-32(fp)
8112d540:	e0bffb15 	stw	r2,-20(fp)
8112d544:	e0bffb17 	ldw	r2,-20(fp)
8112d548:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8112d54c:	e0bfff17 	ldw	r2,-4(fp)
8112d550:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8112d554:	00800044 	movi	r2,1
8112d558:	00000706 	br	8112d578 <OSMutexAccept+0x19c>
8112d55c:	e0bff817 	ldw	r2,-32(fp)
8112d560:	e0bffc15 	stw	r2,-16(fp)
8112d564:	e0bffc17 	ldw	r2,-16(fp)
8112d568:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112d56c:	e0bfff17 	ldw	r2,-4(fp)
8112d570:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8112d574:	0005883a 	mov	r2,zero
}
8112d578:	e037883a 	mov	sp,fp
8112d57c:	df000017 	ldw	fp,0(sp)
8112d580:	dec00104 	addi	sp,sp,4
8112d584:	f800283a 	ret

8112d588 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8112d588:	defff604 	addi	sp,sp,-40
8112d58c:	de00012e 	bgeu	sp,et,8112d594 <OSMutexCreate+0xc>
8112d590:	003b68fa 	trap	3
8112d594:	dfc00915 	stw	ra,36(sp)
8112d598:	df000815 	stw	fp,32(sp)
8112d59c:	df000804 	addi	fp,sp,32
8112d5a0:	2005883a 	mov	r2,r4
8112d5a4:	e17fff15 	stw	r5,-4(fp)
8112d5a8:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112d5ac:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112d5b0:	e0bfff17 	ldw	r2,-4(fp)
8112d5b4:	1000021e 	bne	r2,zero,8112d5c0 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8112d5b8:	0005883a 	mov	r2,zero
8112d5bc:	00006106 	br	8112d744 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8112d5c0:	e0bffe03 	ldbu	r2,-8(fp)
8112d5c4:	10800a30 	cmpltui	r2,r2,40
8112d5c8:	1000051e 	bne	r2,zero,8112d5e0 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8112d5cc:	e0bfff17 	ldw	r2,-4(fp)
8112d5d0:	00c00a84 	movi	r3,42
8112d5d4:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8112d5d8:	0005883a 	mov	r2,zero
8112d5dc:	00005906 	br	8112d744 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112d5e0:	d0a08503 	ldbu	r2,-32236(gp)
8112d5e4:	10803fcc 	andi	r2,r2,255
8112d5e8:	10000526 	beq	r2,zero,8112d600 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8112d5ec:	e0bfff17 	ldw	r2,-4(fp)
8112d5f0:	00c00404 	movi	r3,16
8112d5f4:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8112d5f8:	0005883a 	mov	r2,zero
8112d5fc:	00005106 	br	8112d744 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d600:	0005303a 	rdctl	r2,status
8112d604:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d608:	e0fffd17 	ldw	r3,-12(fp)
8112d60c:	00bfff84 	movi	r2,-2
8112d610:	1884703a 	and	r2,r3,r2
8112d614:	1001703a 	wrctl	status,r2
  
  return context;
8112d618:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8112d61c:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
8112d620:	e0fffe03 	ldbu	r3,-8(fp)
8112d624:	00a04574 	movhi	r2,33045
8112d628:	10948904 	addi	r2,r2,21028
8112d62c:	18c7883a 	add	r3,r3,r3
8112d630:	18c7883a 	add	r3,r3,r3
8112d634:	10c5883a 	add	r2,r2,r3
8112d638:	10800017 	ldw	r2,0(r2)
8112d63c:	10000926 	beq	r2,zero,8112d664 <OSMutexCreate+0xdc>
8112d640:	e0bff817 	ldw	r2,-32(fp)
8112d644:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d648:	e0bff917 	ldw	r2,-28(fp)
8112d64c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
8112d650:	e0bfff17 	ldw	r2,-4(fp)
8112d654:	00c00a04 	movi	r3,40
8112d658:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8112d65c:	0005883a 	mov	r2,zero
8112d660:	00003806 	br	8112d744 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8112d664:	e0fffe03 	ldbu	r3,-8(fp)
8112d668:	00a04574 	movhi	r2,33045
8112d66c:	10948904 	addi	r2,r2,21028
8112d670:	18c7883a 	add	r3,r3,r3
8112d674:	18c7883a 	add	r3,r3,r3
8112d678:	10c5883a 	add	r2,r2,r3
8112d67c:	00c00044 	movi	r3,1
8112d680:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8112d684:	d0a08417 	ldw	r2,-32240(gp)
8112d688:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8112d68c:	e0bffb17 	ldw	r2,-20(fp)
8112d690:	1000101e 	bne	r2,zero,8112d6d4 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8112d694:	e0fffe03 	ldbu	r3,-8(fp)
8112d698:	00a04574 	movhi	r2,33045
8112d69c:	10948904 	addi	r2,r2,21028
8112d6a0:	18c7883a 	add	r3,r3,r3
8112d6a4:	18c7883a 	add	r3,r3,r3
8112d6a8:	10c5883a 	add	r2,r2,r3
8112d6ac:	10000015 	stw	zero,0(r2)
8112d6b0:	e0bff817 	ldw	r2,-32(fp)
8112d6b4:	e0bffa15 	stw	r2,-24(fp)
8112d6b8:	e0bffa17 	ldw	r2,-24(fp)
8112d6bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8112d6c0:	e0bfff17 	ldw	r2,-4(fp)
8112d6c4:	00c00104 	movi	r3,4
8112d6c8:	10c00005 	stb	r3,0(r2)
        return (pevent);
8112d6cc:	e0bffb17 	ldw	r2,-20(fp)
8112d6d0:	00001c06 	br	8112d744 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8112d6d4:	d0a08417 	ldw	r2,-32240(gp)
8112d6d8:	10800117 	ldw	r2,4(r2)
8112d6dc:	d0a08415 	stw	r2,-32240(gp)
8112d6e0:	e0bff817 	ldw	r2,-32(fp)
8112d6e4:	e0bffc15 	stw	r2,-16(fp)
8112d6e8:	e0bffc17 	ldw	r2,-16(fp)
8112d6ec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8112d6f0:	e0bffb17 	ldw	r2,-20(fp)
8112d6f4:	00c00104 	movi	r3,4
8112d6f8:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8112d6fc:	e0bffe03 	ldbu	r2,-8(fp)
8112d700:	1004923a 	slli	r2,r2,8
8112d704:	10803fd4 	ori	r2,r2,255
8112d708:	1007883a 	mov	r3,r2
8112d70c:	e0bffb17 	ldw	r2,-20(fp)
8112d710:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8112d714:	e0bffb17 	ldw	r2,-20(fp)
8112d718:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8112d71c:	e0bffb17 	ldw	r2,-20(fp)
8112d720:	00c00fc4 	movi	r3,63
8112d724:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8112d728:	e0bffb17 	ldw	r2,-20(fp)
8112d72c:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
8112d730:	e13ffb17 	ldw	r4,-20(fp)
8112d734:	112a6d40 	call	8112a6d4 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8112d738:	e0bfff17 	ldw	r2,-4(fp)
8112d73c:	10000005 	stb	zero,0(r2)
    return (pevent);
8112d740:	e0bffb17 	ldw	r2,-20(fp)
}
8112d744:	e037883a 	mov	sp,fp
8112d748:	dfc00117 	ldw	ra,4(sp)
8112d74c:	df000017 	ldw	fp,0(sp)
8112d750:	dec00204 	addi	sp,sp,8
8112d754:	f800283a 	ret

8112d758 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8112d758:	defff004 	addi	sp,sp,-64
8112d75c:	de00012e 	bgeu	sp,et,8112d764 <OSMutexDel+0xc>
8112d760:	003b68fa 	trap	3
8112d764:	dfc00f15 	stw	ra,60(sp)
8112d768:	df000e15 	stw	fp,56(sp)
8112d76c:	df000e04 	addi	fp,sp,56
8112d770:	e13ffd15 	stw	r4,-12(fp)
8112d774:	2805883a 	mov	r2,r5
8112d778:	e1bfff15 	stw	r6,-4(fp)
8112d77c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112d780:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112d784:	e0bfff17 	ldw	r2,-4(fp)
8112d788:	1000021e 	bne	r2,zero,8112d794 <OSMutexDel+0x3c>
        return (pevent);
8112d78c:	e0bffd17 	ldw	r2,-12(fp)
8112d790:	0000ad06 	br	8112da48 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8112d794:	e0bffd17 	ldw	r2,-12(fp)
8112d798:	1000051e 	bne	r2,zero,8112d7b0 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8112d79c:	e0bfff17 	ldw	r2,-4(fp)
8112d7a0:	00c00104 	movi	r3,4
8112d7a4:	10c00005 	stb	r3,0(r2)
        return (pevent);
8112d7a8:	e0bffd17 	ldw	r2,-12(fp)
8112d7ac:	0000a606 	br	8112da48 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8112d7b0:	e0bffd17 	ldw	r2,-12(fp)
8112d7b4:	10800003 	ldbu	r2,0(r2)
8112d7b8:	10803fcc 	andi	r2,r2,255
8112d7bc:	10800120 	cmpeqi	r2,r2,4
8112d7c0:	1000051e 	bne	r2,zero,8112d7d8 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8112d7c4:	e0bfff17 	ldw	r2,-4(fp)
8112d7c8:	00c00044 	movi	r3,1
8112d7cc:	10c00005 	stb	r3,0(r2)
        return (pevent);
8112d7d0:	e0bffd17 	ldw	r2,-12(fp)
8112d7d4:	00009c06 	br	8112da48 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112d7d8:	d0a08503 	ldbu	r2,-32236(gp)
8112d7dc:	10803fcc 	andi	r2,r2,255
8112d7e0:	10000526 	beq	r2,zero,8112d7f8 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8112d7e4:	e0bfff17 	ldw	r2,-4(fp)
8112d7e8:	00c003c4 	movi	r3,15
8112d7ec:	10c00005 	stb	r3,0(r2)
        return (pevent);
8112d7f0:	e0bffd17 	ldw	r2,-12(fp)
8112d7f4:	00009406 	br	8112da48 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112d7f8:	0005303a 	rdctl	r2,status
8112d7fc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112d800:	e0fffc17 	ldw	r3,-16(fp)
8112d804:	00bfff84 	movi	r2,-2
8112d808:	1884703a 	and	r2,r3,r2
8112d80c:	1001703a 	wrctl	status,r2
  
  return context;
8112d810:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112d814:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8112d818:	e0bffd17 	ldw	r2,-12(fp)
8112d81c:	10800283 	ldbu	r2,10(r2)
8112d820:	10803fcc 	andi	r2,r2,255
8112d824:	10000326 	beq	r2,zero,8112d834 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8112d828:	00800044 	movi	r2,1
8112d82c:	e0bff205 	stb	r2,-56(fp)
8112d830:	00000106 	br	8112d838 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8112d834:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8112d838:	e0bffe03 	ldbu	r2,-8(fp)
8112d83c:	10000326 	beq	r2,zero,8112d84c <OSMutexDel+0xf4>
8112d840:	10800060 	cmpeqi	r2,r2,1
8112d844:	10002f1e 	bne	r2,zero,8112d904 <OSMutexDel+0x1ac>
8112d848:	00007406 	br	8112da1c <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8112d84c:	e0bff203 	ldbu	r2,-56(fp)
8112d850:	1000221e 	bne	r2,zero,8112d8dc <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8112d854:	e0bffd17 	ldw	r2,-12(fp)
8112d858:	00c00fc4 	movi	r3,63
8112d85c:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8112d860:	e0bffd17 	ldw	r2,-12(fp)
8112d864:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8112d868:	e0bffd17 	ldw	r2,-12(fp)
8112d86c:	1080020b 	ldhu	r2,8(r2)
8112d870:	10bfffcc 	andi	r2,r2,65535
8112d874:	1004d23a 	srli	r2,r2,8
8112d878:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8112d87c:	e0fff603 	ldbu	r3,-40(fp)
8112d880:	00a04574 	movhi	r2,33045
8112d884:	10948904 	addi	r2,r2,21028
8112d888:	18c7883a 	add	r3,r3,r3
8112d88c:	18c7883a 	add	r3,r3,r3
8112d890:	10c5883a 	add	r2,r2,r3
8112d894:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8112d898:	e0bffd17 	ldw	r2,-12(fp)
8112d89c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8112d8a0:	d0e08417 	ldw	r3,-32240(gp)
8112d8a4:	e0bffd17 	ldw	r2,-12(fp)
8112d8a8:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8112d8ac:	e0bffd17 	ldw	r2,-12(fp)
8112d8b0:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8112d8b4:	e0bffd17 	ldw	r2,-12(fp)
8112d8b8:	d0a08415 	stw	r2,-32240(gp)
8112d8bc:	e0bff417 	ldw	r2,-48(fp)
8112d8c0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112d8c4:	e0bff517 	ldw	r2,-44(fp)
8112d8c8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8112d8cc:	e0bfff17 	ldw	r2,-4(fp)
8112d8d0:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8112d8d4:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
8112d8d8:	00005a06 	br	8112da44 <OSMutexDel+0x2ec>
8112d8dc:	e0bff417 	ldw	r2,-48(fp)
8112d8e0:	e0bff715 	stw	r2,-36(fp)
8112d8e4:	e0bff717 	ldw	r2,-36(fp)
8112d8e8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8112d8ec:	e0bfff17 	ldw	r2,-4(fp)
8112d8f0:	00c01244 	movi	r3,73
8112d8f4:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
8112d8f8:	e0bffd17 	ldw	r2,-12(fp)
8112d8fc:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8112d900:	00005006 	br	8112da44 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8112d904:	e0bffd17 	ldw	r2,-12(fp)
8112d908:	1080020b 	ldhu	r2,8(r2)
8112d90c:	10bfffcc 	andi	r2,r2,65535
8112d910:	1004d23a 	srli	r2,r2,8
8112d914:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8112d918:	e0bffd17 	ldw	r2,-12(fp)
8112d91c:	1080020b 	ldhu	r2,8(r2)
8112d920:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8112d924:	e0bffd17 	ldw	r2,-12(fp)
8112d928:	10800117 	ldw	r2,4(r2)
8112d92c:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
8112d930:	e0bffa17 	ldw	r2,-24(fp)
8112d934:	10000f26 	beq	r2,zero,8112d974 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8112d938:	e0bffa17 	ldw	r2,-24(fp)
8112d93c:	10800c83 	ldbu	r2,50(r2)
8112d940:	10c03fcc 	andi	r3,r2,255
8112d944:	e0bff603 	ldbu	r2,-40(fp)
8112d948:	18800a1e 	bne	r3,r2,8112d974 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8112d94c:	e0bff903 	ldbu	r2,-28(fp)
8112d950:	100b883a 	mov	r5,r2
8112d954:	e13ffa17 	ldw	r4,-24(fp)
8112d958:	112e3940 	call	8112e394 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8112d95c:	00000506 	br	8112d974 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8112d960:	000f883a 	mov	r7,zero
8112d964:	01800404 	movi	r6,16
8112d968:	000b883a 	mov	r5,zero
8112d96c:	e13ffd17 	ldw	r4,-12(fp)
8112d970:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8112d974:	e0bffd17 	ldw	r2,-12(fp)
8112d978:	10800283 	ldbu	r2,10(r2)
8112d97c:	10803fcc 	andi	r2,r2,255
8112d980:	103ff71e 	bne	r2,zero,8112d960 <__reset+0xfb10d960>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8112d984:	e0bffd17 	ldw	r2,-12(fp)
8112d988:	00c00fc4 	movi	r3,63
8112d98c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8112d990:	e0bffd17 	ldw	r2,-12(fp)
8112d994:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8112d998:	e0bffd17 	ldw	r2,-12(fp)
8112d99c:	1080020b 	ldhu	r2,8(r2)
8112d9a0:	10bfffcc 	andi	r2,r2,65535
8112d9a4:	1004d23a 	srli	r2,r2,8
8112d9a8:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8112d9ac:	e0fff603 	ldbu	r3,-40(fp)
8112d9b0:	00a04574 	movhi	r2,33045
8112d9b4:	10948904 	addi	r2,r2,21028
8112d9b8:	18c7883a 	add	r3,r3,r3
8112d9bc:	18c7883a 	add	r3,r3,r3
8112d9c0:	10c5883a 	add	r2,r2,r3
8112d9c4:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8112d9c8:	e0bffd17 	ldw	r2,-12(fp)
8112d9cc:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
8112d9d0:	d0e08417 	ldw	r3,-32240(gp)
8112d9d4:	e0bffd17 	ldw	r2,-12(fp)
8112d9d8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8112d9dc:	e0bffd17 	ldw	r2,-12(fp)
8112d9e0:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8112d9e4:	e0bffd17 	ldw	r2,-12(fp)
8112d9e8:	d0a08415 	stw	r2,-32240(gp)
8112d9ec:	e0bff417 	ldw	r2,-48(fp)
8112d9f0:	e0bff815 	stw	r2,-32(fp)
8112d9f4:	e0bff817 	ldw	r2,-32(fp)
8112d9f8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8112d9fc:	e0bff203 	ldbu	r2,-56(fp)
8112da00:	10800058 	cmpnei	r2,r2,1
8112da04:	1000011e 	bne	r2,zero,8112da0c <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8112da08:	112abb80 	call	8112abb8 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8112da0c:	e0bfff17 	ldw	r2,-4(fp)
8112da10:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8112da14:	e03ff315 	stw	zero,-52(fp)
             break;
8112da18:	00000a06 	br	8112da44 <OSMutexDel+0x2ec>
8112da1c:	e0bff417 	ldw	r2,-48(fp)
8112da20:	e0bffb15 	stw	r2,-20(fp)
8112da24:	e0bffb17 	ldw	r2,-20(fp)
8112da28:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8112da2c:	e0bfff17 	ldw	r2,-4(fp)
8112da30:	00c001c4 	movi	r3,7
8112da34:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8112da38:	e0bffd17 	ldw	r2,-12(fp)
8112da3c:	e0bff315 	stw	r2,-52(fp)
             break;
8112da40:	0001883a 	nop
    }
    return (pevent_return);
8112da44:	e0bff317 	ldw	r2,-52(fp)
}
8112da48:	e037883a 	mov	sp,fp
8112da4c:	dfc00117 	ldw	ra,4(sp)
8112da50:	df000017 	ldw	fp,0(sp)
8112da54:	dec00204 	addi	sp,sp,8
8112da58:	f800283a 	ret

8112da5c <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8112da5c:	deffee04 	addi	sp,sp,-72
8112da60:	de00012e 	bgeu	sp,et,8112da68 <OSMutexPend+0xc>
8112da64:	003b68fa 	trap	3
8112da68:	dfc01115 	stw	ra,68(sp)
8112da6c:	df001015 	stw	fp,64(sp)
8112da70:	df001004 	addi	fp,sp,64
8112da74:	e13ffd15 	stw	r4,-12(fp)
8112da78:	2805883a 	mov	r2,r5
8112da7c:	e1bfff15 	stw	r6,-4(fp)
8112da80:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112da84:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112da88:	e0bfff17 	ldw	r2,-4(fp)
8112da8c:	10015626 	beq	r2,zero,8112dfe8 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8112da90:	e0bffd17 	ldw	r2,-12(fp)
8112da94:	1000041e 	bne	r2,zero,8112daa8 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8112da98:	e0bfff17 	ldw	r2,-4(fp)
8112da9c:	00c00104 	movi	r3,4
8112daa0:	10c00005 	stb	r3,0(r2)
        return;
8112daa4:	00015106 	br	8112dfec <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8112daa8:	e0bffd17 	ldw	r2,-12(fp)
8112daac:	10800003 	ldbu	r2,0(r2)
8112dab0:	10803fcc 	andi	r2,r2,255
8112dab4:	10800120 	cmpeqi	r2,r2,4
8112dab8:	1000041e 	bne	r2,zero,8112dacc <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8112dabc:	e0bfff17 	ldw	r2,-4(fp)
8112dac0:	00c00044 	movi	r3,1
8112dac4:	10c00005 	stb	r3,0(r2)
        return;
8112dac8:	00014806 	br	8112dfec <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112dacc:	d0a08503 	ldbu	r2,-32236(gp)
8112dad0:	10803fcc 	andi	r2,r2,255
8112dad4:	10000426 	beq	r2,zero,8112dae8 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8112dad8:	e0bfff17 	ldw	r2,-4(fp)
8112dadc:	00c00084 	movi	r3,2
8112dae0:	10c00005 	stb	r3,0(r2)
        return;
8112dae4:	00014106 	br	8112dfec <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8112dae8:	d0a07303 	ldbu	r2,-32308(gp)
8112daec:	10803fcc 	andi	r2,r2,255
8112daf0:	10000426 	beq	r2,zero,8112db04 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8112daf4:	e0bfff17 	ldw	r2,-4(fp)
8112daf8:	00c00344 	movi	r3,13
8112dafc:	10c00005 	stb	r3,0(r2)
        return;
8112db00:	00013a06 	br	8112dfec <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112db04:	0005303a 	rdctl	r2,status
8112db08:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112db0c:	e0fffc17 	ldw	r3,-16(fp)
8112db10:	00bfff84 	movi	r2,-2
8112db14:	1884703a 	and	r2,r3,r2
8112db18:	1001703a 	wrctl	status,r2
  
  return context;
8112db1c:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8112db20:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8112db24:	e0bffd17 	ldw	r2,-12(fp)
8112db28:	1080020b 	ldhu	r2,8(r2)
8112db2c:	10bfffcc 	andi	r2,r2,65535
8112db30:	1004d23a 	srli	r2,r2,8
8112db34:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8112db38:	e0bffd17 	ldw	r2,-12(fp)
8112db3c:	1080020b 	ldhu	r2,8(r2)
8112db40:	10803fcc 	andi	r2,r2,255
8112db44:	10803fd8 	cmpnei	r2,r2,255
8112db48:	1000271e 	bne	r2,zero,8112dbe8 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8112db4c:	e0bffd17 	ldw	r2,-12(fp)
8112db50:	10c0020b 	ldhu	r3,8(r2)
8112db54:	00bfc004 	movi	r2,-256
8112db58:	1884703a 	and	r2,r3,r2
8112db5c:	1007883a 	mov	r3,r2
8112db60:	e0bffd17 	ldw	r2,-12(fp)
8112db64:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8112db68:	e0bffd17 	ldw	r2,-12(fp)
8112db6c:	10c0020b 	ldhu	r3,8(r2)
8112db70:	d0a08617 	ldw	r2,-32232(gp)
8112db74:	10800c83 	ldbu	r2,50(r2)
8112db78:	10803fcc 	andi	r2,r2,255
8112db7c:	1884b03a 	or	r2,r3,r2
8112db80:	1007883a 	mov	r3,r2
8112db84:	e0bffd17 	ldw	r2,-12(fp)
8112db88:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8112db8c:	d0e08617 	ldw	r3,-32232(gp)
8112db90:	e0bffd17 	ldw	r2,-12(fp)
8112db94:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8112db98:	d0a08617 	ldw	r2,-32232(gp)
8112db9c:	10800c83 	ldbu	r2,50(r2)
8112dba0:	10803fcc 	andi	r2,r2,255
8112dba4:	e0fff303 	ldbu	r3,-52(fp)
8112dba8:	18800836 	bltu	r3,r2,8112dbcc <OSMutexPend+0x170>
8112dbac:	e0bff117 	ldw	r2,-60(fp)
8112dbb0:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112dbb4:	e0bff217 	ldw	r2,-56(fp)
8112dbb8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8112dbbc:	e0bfff17 	ldw	r2,-4(fp)
8112dbc0:	00c01e04 	movi	r3,120
8112dbc4:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8112dbc8:	00010806 	br	8112dfec <OSMutexPend+0x590>
8112dbcc:	e0bff117 	ldw	r2,-60(fp)
8112dbd0:	e0bff415 	stw	r2,-48(fp)
8112dbd4:	e0bff417 	ldw	r2,-48(fp)
8112dbd8:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8112dbdc:	e0bfff17 	ldw	r2,-4(fp)
8112dbe0:	10000005 	stb	zero,0(r2)
        }
        return;
8112dbe4:	00010106 	br	8112dfec <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8112dbe8:	e0bffd17 	ldw	r2,-12(fp)
8112dbec:	1080020b 	ldhu	r2,8(r2)
8112dbf0:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8112dbf4:	e0bffd17 	ldw	r2,-12(fp)
8112dbf8:	10800117 	ldw	r2,4(r2)
8112dbfc:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
8112dc00:	e0bff717 	ldw	r2,-36(fp)
8112dc04:	10800c83 	ldbu	r2,50(r2)
8112dc08:	10803fcc 	andi	r2,r2,255
8112dc0c:	e0fff303 	ldbu	r3,-52(fp)
8112dc10:	1880b92e 	bgeu	r3,r2,8112def8 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8112dc14:	d0a08617 	ldw	r2,-32232(gp)
8112dc18:	10800c83 	ldbu	r2,50(r2)
8112dc1c:	10c03fcc 	andi	r3,r2,255
8112dc20:	e0bff603 	ldbu	r2,-40(fp)
8112dc24:	1880b42e 	bgeu	r3,r2,8112def8 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8112dc28:	e0bff717 	ldw	r2,-36(fp)
8112dc2c:	10800d03 	ldbu	r2,52(r2)
8112dc30:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8112dc34:	e0fff803 	ldbu	r3,-32(fp)
8112dc38:	d0a08244 	addi	r2,gp,-32247
8112dc3c:	1885883a 	add	r2,r3,r2
8112dc40:	10c00003 	ldbu	r3,0(r2)
8112dc44:	e0bff717 	ldw	r2,-36(fp)
8112dc48:	10800d43 	ldbu	r2,53(r2)
8112dc4c:	1884703a 	and	r2,r3,r2
8112dc50:	10803fcc 	andi	r2,r2,255
8112dc54:	10001e26 	beq	r2,zero,8112dcd0 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8112dc58:	e0fff803 	ldbu	r3,-32(fp)
8112dc5c:	e13ff803 	ldbu	r4,-32(fp)
8112dc60:	d0a08244 	addi	r2,gp,-32247
8112dc64:	2085883a 	add	r2,r4,r2
8112dc68:	10800003 	ldbu	r2,0(r2)
8112dc6c:	1009883a 	mov	r4,r2
8112dc70:	e0bff717 	ldw	r2,-36(fp)
8112dc74:	10800d43 	ldbu	r2,53(r2)
8112dc78:	0084303a 	nor	r2,zero,r2
8112dc7c:	2084703a 	and	r2,r4,r2
8112dc80:	1009883a 	mov	r4,r2
8112dc84:	d0a08244 	addi	r2,gp,-32247
8112dc88:	1885883a 	add	r2,r3,r2
8112dc8c:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
8112dc90:	e0fff803 	ldbu	r3,-32(fp)
8112dc94:	d0a08244 	addi	r2,gp,-32247
8112dc98:	1885883a 	add	r2,r3,r2
8112dc9c:	10800003 	ldbu	r2,0(r2)
8112dca0:	10803fcc 	andi	r2,r2,255
8112dca4:	1000071e 	bne	r2,zero,8112dcc4 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8112dca8:	e0bff717 	ldw	r2,-36(fp)
8112dcac:	10800d83 	ldbu	r2,54(r2)
8112dcb0:	0084303a 	nor	r2,zero,r2
8112dcb4:	1007883a 	mov	r3,r2
8112dcb8:	d0a08203 	ldbu	r2,-32248(gp)
8112dcbc:	1884703a 	and	r2,r3,r2
8112dcc0:	d0a08205 	stb	r2,-32248(gp)
                }
                rdy = OS_TRUE;
8112dcc4:	00800044 	movi	r2,1
8112dcc8:	e0bff005 	stb	r2,-64(fp)
8112dccc:	00002a06 	br	8112dd78 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8112dcd0:	e0bff717 	ldw	r2,-36(fp)
8112dcd4:	10800717 	ldw	r2,28(r2)
8112dcd8:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8112dcdc:	e0bff917 	ldw	r2,-28(fp)
8112dce0:	10002426 	beq	r2,zero,8112dd74 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8112dce4:	e0bff717 	ldw	r2,-36(fp)
8112dce8:	10800d03 	ldbu	r2,52(r2)
8112dcec:	10803fcc 	andi	r2,r2,255
8112dcf0:	e0fff717 	ldw	r3,-36(fp)
8112dcf4:	18c00d03 	ldbu	r3,52(r3)
8112dcf8:	18c03fcc 	andi	r3,r3,255
8112dcfc:	e13ff917 	ldw	r4,-28(fp)
8112dd00:	20c7883a 	add	r3,r4,r3
8112dd04:	18c002c4 	addi	r3,r3,11
8112dd08:	18c00003 	ldbu	r3,0(r3)
8112dd0c:	1809883a 	mov	r4,r3
8112dd10:	e0fff717 	ldw	r3,-36(fp)
8112dd14:	18c00d43 	ldbu	r3,53(r3)
8112dd18:	00c6303a 	nor	r3,zero,r3
8112dd1c:	20c6703a 	and	r3,r4,r3
8112dd20:	1809883a 	mov	r4,r3
8112dd24:	e0fff917 	ldw	r3,-28(fp)
8112dd28:	1887883a 	add	r3,r3,r2
8112dd2c:	18c002c4 	addi	r3,r3,11
8112dd30:	19000005 	stb	r4,0(r3)
8112dd34:	e0fff917 	ldw	r3,-28(fp)
8112dd38:	1885883a 	add	r2,r3,r2
8112dd3c:	108002c4 	addi	r2,r2,11
8112dd40:	10800003 	ldbu	r2,0(r2)
8112dd44:	10803fcc 	andi	r2,r2,255
8112dd48:	10000a1e 	bne	r2,zero,8112dd74 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8112dd4c:	e0bff917 	ldw	r2,-28(fp)
8112dd50:	10800283 	ldbu	r2,10(r2)
8112dd54:	1007883a 	mov	r3,r2
8112dd58:	e0bff717 	ldw	r2,-36(fp)
8112dd5c:	10800d83 	ldbu	r2,54(r2)
8112dd60:	0084303a 	nor	r2,zero,r2
8112dd64:	1884703a 	and	r2,r3,r2
8112dd68:	1007883a 	mov	r3,r2
8112dd6c:	e0bff917 	ldw	r2,-28(fp)
8112dd70:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
8112dd74:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8112dd78:	e0bff717 	ldw	r2,-36(fp)
8112dd7c:	e0fff303 	ldbu	r3,-52(fp)
8112dd80:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
8112dd84:	e0bff717 	ldw	r2,-36(fp)
8112dd88:	10800c83 	ldbu	r2,50(r2)
8112dd8c:	10803fcc 	andi	r2,r2,255
8112dd90:	1004d0fa 	srli	r2,r2,3
8112dd94:	1007883a 	mov	r3,r2
8112dd98:	e0bff717 	ldw	r2,-36(fp)
8112dd9c:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
8112dda0:	e0bff717 	ldw	r2,-36(fp)
8112dda4:	10800c83 	ldbu	r2,50(r2)
8112dda8:	108001cc 	andi	r2,r2,7
8112ddac:	1007883a 	mov	r3,r2
8112ddb0:	e0bff717 	ldw	r2,-36(fp)
8112ddb4:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8112ddb8:	e0bff717 	ldw	r2,-36(fp)
8112ddbc:	10800d03 	ldbu	r2,52(r2)
8112ddc0:	10803fcc 	andi	r2,r2,255
8112ddc4:	00c00044 	movi	r3,1
8112ddc8:	1884983a 	sll	r2,r3,r2
8112ddcc:	1007883a 	mov	r3,r2
8112ddd0:	e0bff717 	ldw	r2,-36(fp)
8112ddd4:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8112ddd8:	e0bff717 	ldw	r2,-36(fp)
8112dddc:	10800cc3 	ldbu	r2,51(r2)
8112dde0:	10803fcc 	andi	r2,r2,255
8112dde4:	00c00044 	movi	r3,1
8112dde8:	1884983a 	sll	r2,r3,r2
8112ddec:	1007883a 	mov	r3,r2
8112ddf0:	e0bff717 	ldw	r2,-36(fp)
8112ddf4:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8112ddf8:	e0bff003 	ldbu	r2,-64(fp)
8112ddfc:	10800058 	cmpnei	r2,r2,1
8112de00:	1000161e 	bne	r2,zero,8112de5c <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
8112de04:	e0bff717 	ldw	r2,-36(fp)
8112de08:	10c00d83 	ldbu	r3,54(r2)
8112de0c:	d0a08203 	ldbu	r2,-32248(gp)
8112de10:	1884b03a 	or	r2,r3,r2
8112de14:	d0a08205 	stb	r2,-32248(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8112de18:	e0bff717 	ldw	r2,-36(fp)
8112de1c:	10800d03 	ldbu	r2,52(r2)
8112de20:	10c03fcc 	andi	r3,r2,255
8112de24:	e0bff717 	ldw	r2,-36(fp)
8112de28:	10800d03 	ldbu	r2,52(r2)
8112de2c:	11003fcc 	andi	r4,r2,255
8112de30:	d0a08244 	addi	r2,gp,-32247
8112de34:	2085883a 	add	r2,r4,r2
8112de38:	11000003 	ldbu	r4,0(r2)
8112de3c:	e0bff717 	ldw	r2,-36(fp)
8112de40:	10800d43 	ldbu	r2,53(r2)
8112de44:	2084b03a 	or	r2,r4,r2
8112de48:	1009883a 	mov	r4,r2
8112de4c:	d0a08244 	addi	r2,gp,-32247
8112de50:	1885883a 	add	r2,r3,r2
8112de54:	11000005 	stb	r4,0(r2)
8112de58:	00001f06 	br	8112ded8 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8112de5c:	e0bff717 	ldw	r2,-36(fp)
8112de60:	10800717 	ldw	r2,28(r2)
8112de64:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8112de68:	e0bff917 	ldw	r2,-28(fp)
8112de6c:	10001a26 	beq	r2,zero,8112ded8 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
8112de70:	e0bff917 	ldw	r2,-28(fp)
8112de74:	10c00283 	ldbu	r3,10(r2)
8112de78:	e0bff717 	ldw	r2,-36(fp)
8112de7c:	10800d83 	ldbu	r2,54(r2)
8112de80:	1884b03a 	or	r2,r3,r2
8112de84:	1007883a 	mov	r3,r2
8112de88:	e0bff917 	ldw	r2,-28(fp)
8112de8c:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8112de90:	e0bff717 	ldw	r2,-36(fp)
8112de94:	10800d03 	ldbu	r2,52(r2)
8112de98:	10803fcc 	andi	r2,r2,255
8112de9c:	e0fff717 	ldw	r3,-36(fp)
8112dea0:	18c00d03 	ldbu	r3,52(r3)
8112dea4:	18c03fcc 	andi	r3,r3,255
8112dea8:	e13ff917 	ldw	r4,-28(fp)
8112deac:	20c7883a 	add	r3,r4,r3
8112deb0:	18c002c4 	addi	r3,r3,11
8112deb4:	19000003 	ldbu	r4,0(r3)
8112deb8:	e0fff717 	ldw	r3,-36(fp)
8112debc:	18c00d43 	ldbu	r3,53(r3)
8112dec0:	20c6b03a 	or	r3,r4,r3
8112dec4:	1809883a 	mov	r4,r3
8112dec8:	e0fff917 	ldw	r3,-28(fp)
8112decc:	1885883a 	add	r2,r3,r2
8112ded0:	108002c4 	addi	r2,r2,11
8112ded4:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8112ded8:	e0fff303 	ldbu	r3,-52(fp)
8112dedc:	00a04574 	movhi	r2,33045
8112dee0:	10948904 	addi	r2,r2,21028
8112dee4:	18c7883a 	add	r3,r3,r3
8112dee8:	18c7883a 	add	r3,r3,r3
8112deec:	10c5883a 	add	r2,r2,r3
8112def0:	e0fff717 	ldw	r3,-36(fp)
8112def4:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8112def8:	d0a08617 	ldw	r2,-32232(gp)
8112defc:	d0e08617 	ldw	r3,-32232(gp)
8112df00:	18c00c03 	ldbu	r3,48(r3)
8112df04:	18c00414 	ori	r3,r3,16
8112df08:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8112df0c:	d0a08617 	ldw	r2,-32232(gp)
8112df10:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
8112df14:	d0a08617 	ldw	r2,-32232(gp)
8112df18:	e0fffe0b 	ldhu	r3,-8(fp)
8112df1c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8112df20:	e13ffd17 	ldw	r4,-12(fp)
8112df24:	112a29c0 	call	8112a29c <OS_EventTaskWait>
8112df28:	e0bff117 	ldw	r2,-60(fp)
8112df2c:	e0bffb15 	stw	r2,-20(fp)
8112df30:	e0bffb17 	ldw	r2,-20(fp)
8112df34:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8112df38:	112abb80 	call	8112abb8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112df3c:	0005303a 	rdctl	r2,status
8112df40:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112df44:	e0fff517 	ldw	r3,-44(fp)
8112df48:	00bfff84 	movi	r2,-2
8112df4c:	1884703a 	and	r2,r3,r2
8112df50:	1001703a 	wrctl	status,r2
  
  return context;
8112df54:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8112df58:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8112df5c:	d0a08617 	ldw	r2,-32232(gp)
8112df60:	10800c43 	ldbu	r2,49(r2)
8112df64:	10803fcc 	andi	r2,r2,255
8112df68:	10000326 	beq	r2,zero,8112df78 <OSMutexPend+0x51c>
8112df6c:	108000a0 	cmpeqi	r2,r2,2
8112df70:	1000041e 	bne	r2,zero,8112df84 <OSMutexPend+0x528>
8112df74:	00000706 	br	8112df94 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8112df78:	e0bfff17 	ldw	r2,-4(fp)
8112df7c:	10000005 	stb	zero,0(r2)
             break;
8112df80:	00000c06 	br	8112dfb4 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
8112df84:	e0bfff17 	ldw	r2,-4(fp)
8112df88:	00c00384 	movi	r3,14
8112df8c:	10c00005 	stb	r3,0(r2)
             break;
8112df90:	00000806 	br	8112dfb4 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8112df94:	d0a08617 	ldw	r2,-32232(gp)
8112df98:	e17ffd17 	ldw	r5,-12(fp)
8112df9c:	1009883a 	mov	r4,r2
8112dfa0:	112a50c0 	call	8112a50c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
8112dfa4:	e0bfff17 	ldw	r2,-4(fp)
8112dfa8:	00c00284 	movi	r3,10
8112dfac:	10c00005 	stb	r3,0(r2)
             break;
8112dfb0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8112dfb4:	d0a08617 	ldw	r2,-32232(gp)
8112dfb8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8112dfbc:	d0a08617 	ldw	r2,-32232(gp)
8112dfc0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8112dfc4:	d0a08617 	ldw	r2,-32232(gp)
8112dfc8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8112dfcc:	d0a08617 	ldw	r2,-32232(gp)
8112dfd0:	10000815 	stw	zero,32(r2)
8112dfd4:	e0bff117 	ldw	r2,-60(fp)
8112dfd8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112dfdc:	e0bffa17 	ldw	r2,-24(fp)
8112dfe0:	1001703a 	wrctl	status,r2
8112dfe4:	00000106 	br	8112dfec <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8112dfe8:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8112dfec:	e037883a 	mov	sp,fp
8112dff0:	dfc00117 	ldw	ra,4(sp)
8112dff4:	df000017 	ldw	fp,0(sp)
8112dff8:	dec00204 	addi	sp,sp,8
8112dffc:	f800283a 	ret

8112e000 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8112e000:	defff604 	addi	sp,sp,-40
8112e004:	de00012e 	bgeu	sp,et,8112e00c <OSMutexPost+0xc>
8112e008:	003b68fa 	trap	3
8112e00c:	dfc00915 	stw	ra,36(sp)
8112e010:	df000815 	stw	fp,32(sp)
8112e014:	df000804 	addi	fp,sp,32
8112e018:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8112e01c:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8112e020:	d0a08503 	ldbu	r2,-32236(gp)
8112e024:	10803fcc 	andi	r2,r2,255
8112e028:	10000226 	beq	r2,zero,8112e034 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8112e02c:	00800144 	movi	r2,5
8112e030:	00007606 	br	8112e20c <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8112e034:	e0bfff17 	ldw	r2,-4(fp)
8112e038:	1000021e 	bne	r2,zero,8112e044 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8112e03c:	00800104 	movi	r2,4
8112e040:	00007206 	br	8112e20c <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
8112e044:	e0bfff17 	ldw	r2,-4(fp)
8112e048:	10800003 	ldbu	r2,0(r2)
8112e04c:	10803fcc 	andi	r2,r2,255
8112e050:	10800120 	cmpeqi	r2,r2,4
8112e054:	1000021e 	bne	r2,zero,8112e060 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8112e058:	00800044 	movi	r2,1
8112e05c:	00006b06 	br	8112e20c <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e060:	0005303a 	rdctl	r2,status
8112e064:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e068:	e0fffe17 	ldw	r3,-8(fp)
8112e06c:	00bfff84 	movi	r2,-2
8112e070:	1884703a 	and	r2,r3,r2
8112e074:	1001703a 	wrctl	status,r2
  
  return context;
8112e078:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8112e07c:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8112e080:	e0bfff17 	ldw	r2,-4(fp)
8112e084:	1080020b 	ldhu	r2,8(r2)
8112e088:	10bfffcc 	andi	r2,r2,65535
8112e08c:	1004d23a 	srli	r2,r2,8
8112e090:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
8112e094:	e0bfff17 	ldw	r2,-4(fp)
8112e098:	1080020b 	ldhu	r2,8(r2)
8112e09c:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8112e0a0:	e0bfff17 	ldw	r2,-4(fp)
8112e0a4:	10c00117 	ldw	r3,4(r2)
8112e0a8:	d0a08617 	ldw	r2,-32232(gp)
8112e0ac:	18800626 	beq	r3,r2,8112e0c8 <OSMutexPost+0xc8>
8112e0b0:	e0bff817 	ldw	r2,-32(fp)
8112e0b4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e0b8:	e0bff917 	ldw	r2,-28(fp)
8112e0bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8112e0c0:	00801904 	movi	r2,100
8112e0c4:	00005106 	br	8112e20c <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8112e0c8:	d0a08617 	ldw	r2,-32232(gp)
8112e0cc:	10800c83 	ldbu	r2,50(r2)
8112e0d0:	10c03fcc 	andi	r3,r2,255
8112e0d4:	e0bffa03 	ldbu	r2,-24(fp)
8112e0d8:	1880051e 	bne	r3,r2,8112e0f0 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8112e0dc:	d0a08617 	ldw	r2,-32232(gp)
8112e0e0:	e0fffa43 	ldbu	r3,-23(fp)
8112e0e4:	180b883a 	mov	r5,r3
8112e0e8:	1009883a 	mov	r4,r2
8112e0ec:	112e3940 	call	8112e394 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8112e0f0:	e0fffa03 	ldbu	r3,-24(fp)
8112e0f4:	00a04574 	movhi	r2,33045
8112e0f8:	10948904 	addi	r2,r2,21028
8112e0fc:	18c7883a 	add	r3,r3,r3
8112e100:	18c7883a 	add	r3,r3,r3
8112e104:	10c5883a 	add	r2,r2,r3
8112e108:	00c00044 	movi	r3,1
8112e10c:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8112e110:	e0bfff17 	ldw	r2,-4(fp)
8112e114:	10800283 	ldbu	r2,10(r2)
8112e118:	10803fcc 	andi	r2,r2,255
8112e11c:	10002e26 	beq	r2,zero,8112e1d8 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8112e120:	000f883a 	mov	r7,zero
8112e124:	01800404 	movi	r6,16
8112e128:	000b883a 	mov	r5,zero
8112e12c:	e13fff17 	ldw	r4,-4(fp)
8112e130:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
8112e134:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8112e138:	e0bfff17 	ldw	r2,-4(fp)
8112e13c:	10c0020b 	ldhu	r3,8(r2)
8112e140:	00bfc004 	movi	r2,-256
8112e144:	1884703a 	and	r2,r3,r2
8112e148:	1007883a 	mov	r3,r2
8112e14c:	e0bfff17 	ldw	r2,-4(fp)
8112e150:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
8112e154:	e0bfff17 	ldw	r2,-4(fp)
8112e158:	10c0020b 	ldhu	r3,8(r2)
8112e15c:	e0bffa43 	ldbu	r2,-23(fp)
8112e160:	1884b03a 	or	r2,r3,r2
8112e164:	1007883a 	mov	r3,r2
8112e168:	e0bfff17 	ldw	r2,-4(fp)
8112e16c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
8112e170:	e0fffa43 	ldbu	r3,-23(fp)
8112e174:	00a04574 	movhi	r2,33045
8112e178:	10948904 	addi	r2,r2,21028
8112e17c:	18c7883a 	add	r3,r3,r3
8112e180:	18c7883a 	add	r3,r3,r3
8112e184:	10c5883a 	add	r2,r2,r3
8112e188:	10c00017 	ldw	r3,0(r2)
8112e18c:	e0bfff17 	ldw	r2,-4(fp)
8112e190:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
8112e194:	e0bffa43 	ldbu	r2,-23(fp)
8112e198:	e0fffa03 	ldbu	r3,-24(fp)
8112e19c:	18800736 	bltu	r3,r2,8112e1bc <OSMutexPost+0x1bc>
8112e1a0:	e0bff817 	ldw	r2,-32(fp)
8112e1a4:	e0bffb15 	stw	r2,-20(fp)
8112e1a8:	e0bffb17 	ldw	r2,-20(fp)
8112e1ac:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8112e1b0:	112abb80 	call	8112abb8 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
8112e1b4:	00801e04 	movi	r2,120
8112e1b8:	00001406 	br	8112e20c <OSMutexPost+0x20c>
8112e1bc:	e0bff817 	ldw	r2,-32(fp)
8112e1c0:	e0bffc15 	stw	r2,-16(fp)
8112e1c4:	e0bffc17 	ldw	r2,-16(fp)
8112e1c8:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8112e1cc:	112abb80 	call	8112abb8 <OS_Sched>
            return (OS_ERR_NONE);
8112e1d0:	0005883a 	mov	r2,zero
8112e1d4:	00000d06 	br	8112e20c <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8112e1d8:	e0bfff17 	ldw	r2,-4(fp)
8112e1dc:	1080020b 	ldhu	r2,8(r2)
8112e1e0:	10803fd4 	ori	r2,r2,255
8112e1e4:	1007883a 	mov	r3,r2
8112e1e8:	e0bfff17 	ldw	r2,-4(fp)
8112e1ec:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8112e1f0:	e0bfff17 	ldw	r2,-4(fp)
8112e1f4:	10000115 	stw	zero,4(r2)
8112e1f8:	e0bff817 	ldw	r2,-32(fp)
8112e1fc:	e0bffd15 	stw	r2,-12(fp)
8112e200:	e0bffd17 	ldw	r2,-12(fp)
8112e204:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8112e208:	0005883a 	mov	r2,zero
}
8112e20c:	e037883a 	mov	sp,fp
8112e210:	dfc00117 	ldw	ra,4(sp)
8112e214:	df000017 	ldw	fp,0(sp)
8112e218:	dec00204 	addi	sp,sp,8
8112e21c:	f800283a 	ret

8112e220 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
8112e220:	defff704 	addi	sp,sp,-36
8112e224:	de00012e 	bgeu	sp,et,8112e22c <OSMutexQuery+0xc>
8112e228:	003b68fa 	trap	3
8112e22c:	df000815 	stw	fp,32(sp)
8112e230:	df000804 	addi	fp,sp,32
8112e234:	e13ffe15 	stw	r4,-8(fp)
8112e238:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112e23c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112e240:	d0a08503 	ldbu	r2,-32236(gp)
8112e244:	10803fcc 	andi	r2,r2,255
8112e248:	10000226 	beq	r2,zero,8112e254 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8112e24c:	00800184 	movi	r2,6
8112e250:	00004c06 	br	8112e384 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8112e254:	e0bffe17 	ldw	r2,-8(fp)
8112e258:	1000021e 	bne	r2,zero,8112e264 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8112e25c:	00800104 	movi	r2,4
8112e260:	00004806 	br	8112e384 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
8112e264:	e0bfff17 	ldw	r2,-4(fp)
8112e268:	1000021e 	bne	r2,zero,8112e274 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8112e26c:	00800244 	movi	r2,9
8112e270:	00004406 	br	8112e384 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8112e274:	e0bffe17 	ldw	r2,-8(fp)
8112e278:	10800003 	ldbu	r2,0(r2)
8112e27c:	10803fcc 	andi	r2,r2,255
8112e280:	10800120 	cmpeqi	r2,r2,4
8112e284:	1000021e 	bne	r2,zero,8112e290 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8112e288:	00800044 	movi	r2,1
8112e28c:	00003d06 	br	8112e384 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e290:	0005303a 	rdctl	r2,status
8112e294:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e298:	e0fffd17 	ldw	r3,-12(fp)
8112e29c:	00bfff84 	movi	r2,-2
8112e2a0:	1884703a 	and	r2,r3,r2
8112e2a4:	1001703a 	wrctl	status,r2
  
  return context;
8112e2a8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8112e2ac:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8112e2b0:	e0bffe17 	ldw	r2,-8(fp)
8112e2b4:	1080020b 	ldhu	r2,8(r2)
8112e2b8:	10bfffcc 	andi	r2,r2,65535
8112e2bc:	1004d23a 	srli	r2,r2,8
8112e2c0:	1007883a 	mov	r3,r2
8112e2c4:	e0bfff17 	ldw	r2,-4(fp)
8112e2c8:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8112e2cc:	e0bffe17 	ldw	r2,-8(fp)
8112e2d0:	1080020b 	ldhu	r2,8(r2)
8112e2d4:	1007883a 	mov	r3,r2
8112e2d8:	e0bfff17 	ldw	r2,-4(fp)
8112e2dc:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8112e2e0:	e0bfff17 	ldw	r2,-4(fp)
8112e2e4:	10800203 	ldbu	r2,8(r2)
8112e2e8:	10803fcc 	andi	r2,r2,255
8112e2ec:	10803fd8 	cmpnei	r2,r2,255
8112e2f0:	1000041e 	bne	r2,zero,8112e304 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
8112e2f4:	e0bfff17 	ldw	r2,-4(fp)
8112e2f8:	00c00044 	movi	r3,1
8112e2fc:	10c001c5 	stb	r3,7(r2)
8112e300:	00000206 	br	8112e30c <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
8112e304:	e0bfff17 	ldw	r2,-4(fp)
8112e308:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8112e30c:	e0bffe17 	ldw	r2,-8(fp)
8112e310:	10c00283 	ldbu	r3,10(r2)
8112e314:	e0bfff17 	ldw	r2,-4(fp)
8112e318:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8112e31c:	e0bffe17 	ldw	r2,-8(fp)
8112e320:	108002c4 	addi	r2,r2,11
8112e324:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
8112e328:	e0bfff17 	ldw	r2,-4(fp)
8112e32c:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112e330:	e03ff805 	stb	zero,-32(fp)
8112e334:	00000b06 	br	8112e364 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8112e338:	e0bffa17 	ldw	r2,-24(fp)
8112e33c:	10c00044 	addi	r3,r2,1
8112e340:	e0fffa15 	stw	r3,-24(fp)
8112e344:	e0fff917 	ldw	r3,-28(fp)
8112e348:	19000044 	addi	r4,r3,1
8112e34c:	e13ff915 	stw	r4,-28(fp)
8112e350:	18c00003 	ldbu	r3,0(r3)
8112e354:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112e358:	e0bff803 	ldbu	r2,-32(fp)
8112e35c:	10800044 	addi	r2,r2,1
8112e360:	e0bff805 	stb	r2,-32(fp)
8112e364:	e0bff803 	ldbu	r2,-32(fp)
8112e368:	108001b0 	cmpltui	r2,r2,6
8112e36c:	103ff21e 	bne	r2,zero,8112e338 <__reset+0xfb10e338>
8112e370:	e0bffb17 	ldw	r2,-20(fp)
8112e374:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e378:	e0bffc17 	ldw	r2,-16(fp)
8112e37c:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8112e380:	0005883a 	mov	r2,zero
}
8112e384:	e037883a 	mov	sp,fp
8112e388:	df000017 	ldw	fp,0(sp)
8112e38c:	dec00104 	addi	sp,sp,4
8112e390:	f800283a 	ret

8112e394 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8112e394:	defffc04 	addi	sp,sp,-16
8112e398:	de00012e 	bgeu	sp,et,8112e3a0 <OSMutex_RdyAtPrio+0xc>
8112e39c:	003b68fa 	trap	3
8112e3a0:	df000315 	stw	fp,12(sp)
8112e3a4:	df000304 	addi	fp,sp,12
8112e3a8:	e13ffe15 	stw	r4,-8(fp)
8112e3ac:	2805883a 	mov	r2,r5
8112e3b0:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8112e3b4:	e0bffe17 	ldw	r2,-8(fp)
8112e3b8:	10800d03 	ldbu	r2,52(r2)
8112e3bc:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8112e3c0:	e0fffd03 	ldbu	r3,-12(fp)
8112e3c4:	e13ffd03 	ldbu	r4,-12(fp)
8112e3c8:	d0a08244 	addi	r2,gp,-32247
8112e3cc:	2085883a 	add	r2,r4,r2
8112e3d0:	10800003 	ldbu	r2,0(r2)
8112e3d4:	1009883a 	mov	r4,r2
8112e3d8:	e0bffe17 	ldw	r2,-8(fp)
8112e3dc:	10800d43 	ldbu	r2,53(r2)
8112e3e0:	0084303a 	nor	r2,zero,r2
8112e3e4:	2084703a 	and	r2,r4,r2
8112e3e8:	1009883a 	mov	r4,r2
8112e3ec:	d0a08244 	addi	r2,gp,-32247
8112e3f0:	1885883a 	add	r2,r3,r2
8112e3f4:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8112e3f8:	e0fffd03 	ldbu	r3,-12(fp)
8112e3fc:	d0a08244 	addi	r2,gp,-32247
8112e400:	1885883a 	add	r2,r3,r2
8112e404:	10800003 	ldbu	r2,0(r2)
8112e408:	10803fcc 	andi	r2,r2,255
8112e40c:	1000071e 	bne	r2,zero,8112e42c <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8112e410:	e0bffe17 	ldw	r2,-8(fp)
8112e414:	10800d83 	ldbu	r2,54(r2)
8112e418:	0084303a 	nor	r2,zero,r2
8112e41c:	1007883a 	mov	r3,r2
8112e420:	d0a08203 	ldbu	r2,-32248(gp)
8112e424:	1884703a 	and	r2,r3,r2
8112e428:	d0a08205 	stb	r2,-32248(gp)
    }
    ptcb->OSTCBPrio         = prio;
8112e42c:	e0bffe17 	ldw	r2,-8(fp)
8112e430:	e0ffff03 	ldbu	r3,-4(fp)
8112e434:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8112e438:	e0bfff03 	ldbu	r2,-4(fp)
8112e43c:	1004d0fa 	srli	r2,r2,3
8112e440:	108001cc 	andi	r2,r2,7
8112e444:	1007883a 	mov	r3,r2
8112e448:	e0bffe17 	ldw	r2,-8(fp)
8112e44c:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8112e450:	e0bfff03 	ldbu	r2,-4(fp)
8112e454:	108001cc 	andi	r2,r2,7
8112e458:	1007883a 	mov	r3,r2
8112e45c:	e0bffe17 	ldw	r2,-8(fp)
8112e460:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8112e464:	e0bffe17 	ldw	r2,-8(fp)
8112e468:	10800d03 	ldbu	r2,52(r2)
8112e46c:	10803fcc 	andi	r2,r2,255
8112e470:	00c00044 	movi	r3,1
8112e474:	1884983a 	sll	r2,r3,r2
8112e478:	1007883a 	mov	r3,r2
8112e47c:	e0bffe17 	ldw	r2,-8(fp)
8112e480:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8112e484:	e0bffe17 	ldw	r2,-8(fp)
8112e488:	10800cc3 	ldbu	r2,51(r2)
8112e48c:	10803fcc 	andi	r2,r2,255
8112e490:	00c00044 	movi	r3,1
8112e494:	1884983a 	sll	r2,r3,r2
8112e498:	1007883a 	mov	r3,r2
8112e49c:	e0bffe17 	ldw	r2,-8(fp)
8112e4a0:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8112e4a4:	e0bffe17 	ldw	r2,-8(fp)
8112e4a8:	10c00d83 	ldbu	r3,54(r2)
8112e4ac:	d0a08203 	ldbu	r2,-32248(gp)
8112e4b0:	1884b03a 	or	r2,r3,r2
8112e4b4:	d0a08205 	stb	r2,-32248(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8112e4b8:	e0bffe17 	ldw	r2,-8(fp)
8112e4bc:	10800d03 	ldbu	r2,52(r2)
8112e4c0:	10c03fcc 	andi	r3,r2,255
8112e4c4:	e0bffe17 	ldw	r2,-8(fp)
8112e4c8:	10800d03 	ldbu	r2,52(r2)
8112e4cc:	11003fcc 	andi	r4,r2,255
8112e4d0:	d0a08244 	addi	r2,gp,-32247
8112e4d4:	2085883a 	add	r2,r4,r2
8112e4d8:	11000003 	ldbu	r4,0(r2)
8112e4dc:	e0bffe17 	ldw	r2,-8(fp)
8112e4e0:	10800d43 	ldbu	r2,53(r2)
8112e4e4:	2084b03a 	or	r2,r4,r2
8112e4e8:	1009883a 	mov	r4,r2
8112e4ec:	d0a08244 	addi	r2,gp,-32247
8112e4f0:	1885883a 	add	r2,r3,r2
8112e4f4:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8112e4f8:	e0ffff03 	ldbu	r3,-4(fp)
8112e4fc:	00a04574 	movhi	r2,33045
8112e500:	10948904 	addi	r2,r2,21028
8112e504:	18c7883a 	add	r3,r3,r3
8112e508:	18c7883a 	add	r3,r3,r3
8112e50c:	10c5883a 	add	r2,r2,r3
8112e510:	e0fffe17 	ldw	r3,-8(fp)
8112e514:	10c00015 	stw	r3,0(r2)
}
8112e518:	0001883a 	nop
8112e51c:	e037883a 	mov	sp,fp
8112e520:	df000017 	ldw	fp,0(sp)
8112e524:	dec00104 	addi	sp,sp,4
8112e528:	f800283a 	ret

8112e52c <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8112e52c:	defff804 	addi	sp,sp,-32
8112e530:	de00012e 	bgeu	sp,et,8112e538 <OSQAccept+0xc>
8112e534:	003b68fa 	trap	3
8112e538:	df000715 	stw	fp,28(sp)
8112e53c:	df000704 	addi	fp,sp,28
8112e540:	e13ffe15 	stw	r4,-8(fp)
8112e544:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112e548:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112e54c:	e0bfff17 	ldw	r2,-4(fp)
8112e550:	1000021e 	bne	r2,zero,8112e55c <OSQAccept+0x30>
        return ((void *)0);
8112e554:	0005883a 	mov	r2,zero
8112e558:	00004206 	br	8112e664 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8112e55c:	e0bffe17 	ldw	r2,-8(fp)
8112e560:	1000051e 	bne	r2,zero,8112e578 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8112e564:	e0bfff17 	ldw	r2,-4(fp)
8112e568:	00c00104 	movi	r3,4
8112e56c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8112e570:	0005883a 	mov	r2,zero
8112e574:	00003b06 	br	8112e664 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8112e578:	e0bffe17 	ldw	r2,-8(fp)
8112e57c:	10800003 	ldbu	r2,0(r2)
8112e580:	10803fcc 	andi	r2,r2,255
8112e584:	108000a0 	cmpeqi	r2,r2,2
8112e588:	1000051e 	bne	r2,zero,8112e5a0 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8112e58c:	e0bfff17 	ldw	r2,-4(fp)
8112e590:	00c00044 	movi	r3,1
8112e594:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8112e598:	0005883a 	mov	r2,zero
8112e59c:	00003106 	br	8112e664 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e5a0:	0005303a 	rdctl	r2,status
8112e5a4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e5a8:	e0fffd17 	ldw	r3,-12(fp)
8112e5ac:	00bfff84 	movi	r2,-2
8112e5b0:	1884703a 	and	r2,r3,r2
8112e5b4:	1001703a 	wrctl	status,r2
  
  return context;
8112e5b8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8112e5bc:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8112e5c0:	e0bffe17 	ldw	r2,-8(fp)
8112e5c4:	10800117 	ldw	r2,4(r2)
8112e5c8:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8112e5cc:	e0bffc17 	ldw	r2,-16(fp)
8112e5d0:	1080058b 	ldhu	r2,22(r2)
8112e5d4:	10bfffcc 	andi	r2,r2,65535
8112e5d8:	10001926 	beq	r2,zero,8112e640 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8112e5dc:	e0bffc17 	ldw	r2,-16(fp)
8112e5e0:	10800417 	ldw	r2,16(r2)
8112e5e4:	11000104 	addi	r4,r2,4
8112e5e8:	e0fffc17 	ldw	r3,-16(fp)
8112e5ec:	19000415 	stw	r4,16(r3)
8112e5f0:	10800017 	ldw	r2,0(r2)
8112e5f4:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8112e5f8:	e0bffc17 	ldw	r2,-16(fp)
8112e5fc:	1080058b 	ldhu	r2,22(r2)
8112e600:	10bfffc4 	addi	r2,r2,-1
8112e604:	1007883a 	mov	r3,r2
8112e608:	e0bffc17 	ldw	r2,-16(fp)
8112e60c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8112e610:	e0bffc17 	ldw	r2,-16(fp)
8112e614:	10c00417 	ldw	r3,16(r2)
8112e618:	e0bffc17 	ldw	r2,-16(fp)
8112e61c:	10800217 	ldw	r2,8(r2)
8112e620:	1880041e 	bne	r3,r2,8112e634 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8112e624:	e0bffc17 	ldw	r2,-16(fp)
8112e628:	10c00117 	ldw	r3,4(r2)
8112e62c:	e0bffc17 	ldw	r2,-16(fp)
8112e630:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8112e634:	e0bfff17 	ldw	r2,-4(fp)
8112e638:	10000005 	stb	zero,0(r2)
8112e63c:	00000406 	br	8112e650 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8112e640:	e0bfff17 	ldw	r2,-4(fp)
8112e644:	00c007c4 	movi	r3,31
8112e648:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8112e64c:	e03ff915 	stw	zero,-28(fp)
8112e650:	e0bffa17 	ldw	r2,-24(fp)
8112e654:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e658:	e0bffb17 	ldw	r2,-20(fp)
8112e65c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8112e660:	e0bff917 	ldw	r2,-28(fp)
}
8112e664:	e037883a 	mov	sp,fp
8112e668:	df000017 	ldw	fp,0(sp)
8112e66c:	dec00104 	addi	sp,sp,4
8112e670:	f800283a 	ret

8112e674 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8112e674:	defff404 	addi	sp,sp,-48
8112e678:	de00012e 	bgeu	sp,et,8112e680 <OSQCreate+0xc>
8112e67c:	003b68fa 	trap	3
8112e680:	dfc00b15 	stw	ra,44(sp)
8112e684:	df000a15 	stw	fp,40(sp)
8112e688:	df000a04 	addi	fp,sp,40
8112e68c:	e13ffe15 	stw	r4,-8(fp)
8112e690:	2805883a 	mov	r2,r5
8112e694:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112e698:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8112e69c:	d0a08503 	ldbu	r2,-32236(gp)
8112e6a0:	10803fcc 	andi	r2,r2,255
8112e6a4:	10000226 	beq	r2,zero,8112e6b0 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8112e6a8:	0005883a 	mov	r2,zero
8112e6ac:	00005906 	br	8112e814 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e6b0:	0005303a 	rdctl	r2,status
8112e6b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e6b8:	e0fffd17 	ldw	r3,-12(fp)
8112e6bc:	00bfff84 	movi	r2,-2
8112e6c0:	1884703a 	and	r2,r3,r2
8112e6c4:	1001703a 	wrctl	status,r2
  
  return context;
8112e6c8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8112e6cc:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8112e6d0:	d0a08417 	ldw	r2,-32240(gp)
8112e6d4:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8112e6d8:	d0a08417 	ldw	r2,-32240(gp)
8112e6dc:	10000326 	beq	r2,zero,8112e6ec <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8112e6e0:	d0a08417 	ldw	r2,-32240(gp)
8112e6e4:	10800117 	ldw	r2,4(r2)
8112e6e8:	d0a08415 	stw	r2,-32240(gp)
8112e6ec:	e0bff717 	ldw	r2,-36(fp)
8112e6f0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e6f4:	e0bff817 	ldw	r2,-32(fp)
8112e6f8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8112e6fc:	e0bff617 	ldw	r2,-40(fp)
8112e700:	10004326 	beq	r2,zero,8112e810 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e704:	0005303a 	rdctl	r2,status
8112e708:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e70c:	e0fff917 	ldw	r3,-28(fp)
8112e710:	00bfff84 	movi	r2,-2
8112e714:	1884703a 	and	r2,r3,r2
8112e718:	1001703a 	wrctl	status,r2
  
  return context;
8112e71c:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8112e720:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8112e724:	d0a08117 	ldw	r2,-32252(gp)
8112e728:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8112e72c:	e0bffb17 	ldw	r2,-20(fp)
8112e730:	10002d26 	beq	r2,zero,8112e7e8 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8112e734:	d0a08117 	ldw	r2,-32252(gp)
8112e738:	10800017 	ldw	r2,0(r2)
8112e73c:	d0a08115 	stw	r2,-32252(gp)
8112e740:	e0bff717 	ldw	r2,-36(fp)
8112e744:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e748:	e0bffa17 	ldw	r2,-24(fp)
8112e74c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8112e750:	e0bffb17 	ldw	r2,-20(fp)
8112e754:	e0fffe17 	ldw	r3,-8(fp)
8112e758:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8112e75c:	e0bfff0b 	ldhu	r2,-4(fp)
8112e760:	1085883a 	add	r2,r2,r2
8112e764:	1085883a 	add	r2,r2,r2
8112e768:	1007883a 	mov	r3,r2
8112e76c:	e0bffe17 	ldw	r2,-8(fp)
8112e770:	10c7883a 	add	r3,r2,r3
8112e774:	e0bffb17 	ldw	r2,-20(fp)
8112e778:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8112e77c:	e0bffb17 	ldw	r2,-20(fp)
8112e780:	e0fffe17 	ldw	r3,-8(fp)
8112e784:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8112e788:	e0bffb17 	ldw	r2,-20(fp)
8112e78c:	e0fffe17 	ldw	r3,-8(fp)
8112e790:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8112e794:	e0bffb17 	ldw	r2,-20(fp)
8112e798:	e0ffff0b 	ldhu	r3,-4(fp)
8112e79c:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8112e7a0:	e0bffb17 	ldw	r2,-20(fp)
8112e7a4:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8112e7a8:	e0bff617 	ldw	r2,-40(fp)
8112e7ac:	00c00084 	movi	r3,2
8112e7b0:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8112e7b4:	e0bff617 	ldw	r2,-40(fp)
8112e7b8:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8112e7bc:	e0bff617 	ldw	r2,-40(fp)
8112e7c0:	e0fffb17 	ldw	r3,-20(fp)
8112e7c4:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8112e7c8:	e0bff617 	ldw	r2,-40(fp)
8112e7cc:	00c00fc4 	movi	r3,63
8112e7d0:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8112e7d4:	e0bff617 	ldw	r2,-40(fp)
8112e7d8:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8112e7dc:	e13ff617 	ldw	r4,-40(fp)
8112e7e0:	112a6d40 	call	8112a6d4 <OS_EventWaitListInit>
8112e7e4:	00000a06 	br	8112e810 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8112e7e8:	d0e08417 	ldw	r3,-32240(gp)
8112e7ec:	e0bff617 	ldw	r2,-40(fp)
8112e7f0:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8112e7f4:	e0bff617 	ldw	r2,-40(fp)
8112e7f8:	d0a08415 	stw	r2,-32240(gp)
8112e7fc:	e0bff717 	ldw	r2,-36(fp)
8112e800:	e0bffc15 	stw	r2,-16(fp)
8112e804:	e0bffc17 	ldw	r2,-16(fp)
8112e808:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8112e80c:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8112e810:	e0bff617 	ldw	r2,-40(fp)
}
8112e814:	e037883a 	mov	sp,fp
8112e818:	dfc00117 	ldw	ra,4(sp)
8112e81c:	df000017 	ldw	fp,0(sp)
8112e820:	dec00204 	addi	sp,sp,8
8112e824:	f800283a 	ret

8112e828 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8112e828:	defff204 	addi	sp,sp,-56
8112e82c:	de00012e 	bgeu	sp,et,8112e834 <OSQDel+0xc>
8112e830:	003b68fa 	trap	3
8112e834:	dfc00d15 	stw	ra,52(sp)
8112e838:	df000c15 	stw	fp,48(sp)
8112e83c:	df000c04 	addi	fp,sp,48
8112e840:	e13ffd15 	stw	r4,-12(fp)
8112e844:	2805883a 	mov	r2,r5
8112e848:	e1bfff15 	stw	r6,-4(fp)
8112e84c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112e850:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112e854:	e0bfff17 	ldw	r2,-4(fp)
8112e858:	1000021e 	bne	r2,zero,8112e864 <OSQDel+0x3c>
        return (pevent);
8112e85c:	e0bffd17 	ldw	r2,-12(fp)
8112e860:	00008e06 	br	8112ea9c <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8112e864:	e0bffd17 	ldw	r2,-12(fp)
8112e868:	1000051e 	bne	r2,zero,8112e880 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8112e86c:	e0bfff17 	ldw	r2,-4(fp)
8112e870:	00c00104 	movi	r3,4
8112e874:	10c00005 	stb	r3,0(r2)
        return (pevent);
8112e878:	e0bffd17 	ldw	r2,-12(fp)
8112e87c:	00008706 	br	8112ea9c <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8112e880:	e0bffd17 	ldw	r2,-12(fp)
8112e884:	10800003 	ldbu	r2,0(r2)
8112e888:	10803fcc 	andi	r2,r2,255
8112e88c:	108000a0 	cmpeqi	r2,r2,2
8112e890:	1000051e 	bne	r2,zero,8112e8a8 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8112e894:	e0bfff17 	ldw	r2,-4(fp)
8112e898:	00c00044 	movi	r3,1
8112e89c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8112e8a0:	e0bffd17 	ldw	r2,-12(fp)
8112e8a4:	00007d06 	br	8112ea9c <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112e8a8:	d0a08503 	ldbu	r2,-32236(gp)
8112e8ac:	10803fcc 	andi	r2,r2,255
8112e8b0:	10000526 	beq	r2,zero,8112e8c8 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8112e8b4:	e0bfff17 	ldw	r2,-4(fp)
8112e8b8:	00c003c4 	movi	r3,15
8112e8bc:	10c00005 	stb	r3,0(r2)
        return (pevent);
8112e8c0:	e0bffd17 	ldw	r2,-12(fp)
8112e8c4:	00007506 	br	8112ea9c <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e8c8:	0005303a 	rdctl	r2,status
8112e8cc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e8d0:	e0fffc17 	ldw	r3,-16(fp)
8112e8d4:	00bfff84 	movi	r2,-2
8112e8d8:	1884703a 	and	r2,r3,r2
8112e8dc:	1001703a 	wrctl	status,r2
  
  return context;
8112e8e0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112e8e4:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8112e8e8:	e0bffd17 	ldw	r2,-12(fp)
8112e8ec:	10800283 	ldbu	r2,10(r2)
8112e8f0:	10803fcc 	andi	r2,r2,255
8112e8f4:	10000326 	beq	r2,zero,8112e904 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8112e8f8:	00800044 	movi	r2,1
8112e8fc:	e0bff405 	stb	r2,-48(fp)
8112e900:	00000106 	br	8112e908 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8112e904:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8112e908:	e0bffe03 	ldbu	r2,-8(fp)
8112e90c:	10000326 	beq	r2,zero,8112e91c <OSQDel+0xf4>
8112e910:	10800060 	cmpeqi	r2,r2,1
8112e914:	1000301e 	bne	r2,zero,8112e9d8 <OSQDel+0x1b0>
8112e918:	00005506 	br	8112ea70 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8112e91c:	e0bff403 	ldbu	r2,-48(fp)
8112e920:	10001e1e 	bne	r2,zero,8112e99c <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8112e924:	e0bffd17 	ldw	r2,-12(fp)
8112e928:	00c00fc4 	movi	r3,63
8112e92c:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8112e930:	e0bffd17 	ldw	r2,-12(fp)
8112e934:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8112e938:	e0bffd17 	ldw	r2,-12(fp)
8112e93c:	10800117 	ldw	r2,4(r2)
8112e940:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8112e944:	d0e08117 	ldw	r3,-32252(gp)
8112e948:	e0bff817 	ldw	r2,-32(fp)
8112e94c:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8112e950:	e0bff817 	ldw	r2,-32(fp)
8112e954:	d0a08115 	stw	r2,-32252(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8112e958:	e0bffd17 	ldw	r2,-12(fp)
8112e95c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8112e960:	d0e08417 	ldw	r3,-32240(gp)
8112e964:	e0bffd17 	ldw	r2,-12(fp)
8112e968:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8112e96c:	e0bffd17 	ldw	r2,-12(fp)
8112e970:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8112e974:	e0bffd17 	ldw	r2,-12(fp)
8112e978:	d0a08415 	stw	r2,-32240(gp)
8112e97c:	e0bff617 	ldw	r2,-40(fp)
8112e980:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e984:	e0bff717 	ldw	r2,-36(fp)
8112e988:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8112e98c:	e0bfff17 	ldw	r2,-4(fp)
8112e990:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8112e994:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8112e998:	00003f06 	br	8112ea98 <OSQDel+0x270>
8112e99c:	e0bff617 	ldw	r2,-40(fp)
8112e9a0:	e0bff915 	stw	r2,-28(fp)
8112e9a4:	e0bff917 	ldw	r2,-28(fp)
8112e9a8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8112e9ac:	e0bfff17 	ldw	r2,-4(fp)
8112e9b0:	00c01244 	movi	r3,73
8112e9b4:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8112e9b8:	e0bffd17 	ldw	r2,-12(fp)
8112e9bc:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8112e9c0:	00003506 	br	8112ea98 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8112e9c4:	000f883a 	mov	r7,zero
8112e9c8:	01800104 	movi	r6,4
8112e9cc:	000b883a 	mov	r5,zero
8112e9d0:	e13ffd17 	ldw	r4,-12(fp)
8112e9d4:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8112e9d8:	e0bffd17 	ldw	r2,-12(fp)
8112e9dc:	10800283 	ldbu	r2,10(r2)
8112e9e0:	10803fcc 	andi	r2,r2,255
8112e9e4:	103ff71e 	bne	r2,zero,8112e9c4 <__reset+0xfb10e9c4>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8112e9e8:	e0bffd17 	ldw	r2,-12(fp)
8112e9ec:	00c00fc4 	movi	r3,63
8112e9f0:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8112e9f4:	e0bffd17 	ldw	r2,-12(fp)
8112e9f8:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8112e9fc:	e0bffd17 	ldw	r2,-12(fp)
8112ea00:	10800117 	ldw	r2,4(r2)
8112ea04:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8112ea08:	d0e08117 	ldw	r3,-32252(gp)
8112ea0c:	e0bff817 	ldw	r2,-32(fp)
8112ea10:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8112ea14:	e0bff817 	ldw	r2,-32(fp)
8112ea18:	d0a08115 	stw	r2,-32252(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8112ea1c:	e0bffd17 	ldw	r2,-12(fp)
8112ea20:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8112ea24:	d0e08417 	ldw	r3,-32240(gp)
8112ea28:	e0bffd17 	ldw	r2,-12(fp)
8112ea2c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8112ea30:	e0bffd17 	ldw	r2,-12(fp)
8112ea34:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8112ea38:	e0bffd17 	ldw	r2,-12(fp)
8112ea3c:	d0a08415 	stw	r2,-32240(gp)
8112ea40:	e0bff617 	ldw	r2,-40(fp)
8112ea44:	e0bffa15 	stw	r2,-24(fp)
8112ea48:	e0bffa17 	ldw	r2,-24(fp)
8112ea4c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8112ea50:	e0bff403 	ldbu	r2,-48(fp)
8112ea54:	10800058 	cmpnei	r2,r2,1
8112ea58:	1000011e 	bne	r2,zero,8112ea60 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8112ea5c:	112abb80 	call	8112abb8 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8112ea60:	e0bfff17 	ldw	r2,-4(fp)
8112ea64:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8112ea68:	e03ff515 	stw	zero,-44(fp)
             break;
8112ea6c:	00000a06 	br	8112ea98 <OSQDel+0x270>
8112ea70:	e0bff617 	ldw	r2,-40(fp)
8112ea74:	e0bffb15 	stw	r2,-20(fp)
8112ea78:	e0bffb17 	ldw	r2,-20(fp)
8112ea7c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8112ea80:	e0bfff17 	ldw	r2,-4(fp)
8112ea84:	00c001c4 	movi	r3,7
8112ea88:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8112ea8c:	e0bffd17 	ldw	r2,-12(fp)
8112ea90:	e0bff515 	stw	r2,-44(fp)
             break;
8112ea94:	0001883a 	nop
    }
    return (pevent_return);
8112ea98:	e0bff517 	ldw	r2,-44(fp)
}
8112ea9c:	e037883a 	mov	sp,fp
8112eaa0:	dfc00117 	ldw	ra,4(sp)
8112eaa4:	df000017 	ldw	fp,0(sp)
8112eaa8:	dec00204 	addi	sp,sp,8
8112eaac:	f800283a 	ret

8112eab0 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8112eab0:	defffa04 	addi	sp,sp,-24
8112eab4:	de00012e 	bgeu	sp,et,8112eabc <OSQFlush+0xc>
8112eab8:	003b68fa 	trap	3
8112eabc:	df000515 	stw	fp,20(sp)
8112eac0:	df000504 	addi	fp,sp,20
8112eac4:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8112eac8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8112eacc:	e0bfff17 	ldw	r2,-4(fp)
8112ead0:	1000021e 	bne	r2,zero,8112eadc <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8112ead4:	00800104 	movi	r2,4
8112ead8:	00002106 	br	8112eb60 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8112eadc:	e0bfff17 	ldw	r2,-4(fp)
8112eae0:	10800003 	ldbu	r2,0(r2)
8112eae4:	10803fcc 	andi	r2,r2,255
8112eae8:	108000a0 	cmpeqi	r2,r2,2
8112eaec:	1000021e 	bne	r2,zero,8112eaf8 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8112eaf0:	00800044 	movi	r2,1
8112eaf4:	00001a06 	br	8112eb60 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112eaf8:	0005303a 	rdctl	r2,status
8112eafc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112eb00:	e0fffd17 	ldw	r3,-12(fp)
8112eb04:	00bfff84 	movi	r2,-2
8112eb08:	1884703a 	and	r2,r3,r2
8112eb0c:	1001703a 	wrctl	status,r2
  
  return context;
8112eb10:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8112eb14:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8112eb18:	e0bfff17 	ldw	r2,-4(fp)
8112eb1c:	10800117 	ldw	r2,4(r2)
8112eb20:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8112eb24:	e0bffc17 	ldw	r2,-16(fp)
8112eb28:	10c00117 	ldw	r3,4(r2)
8112eb2c:	e0bffc17 	ldw	r2,-16(fp)
8112eb30:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8112eb34:	e0bffc17 	ldw	r2,-16(fp)
8112eb38:	10c00117 	ldw	r3,4(r2)
8112eb3c:	e0bffc17 	ldw	r2,-16(fp)
8112eb40:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8112eb44:	e0bffc17 	ldw	r2,-16(fp)
8112eb48:	1000058d 	sth	zero,22(r2)
8112eb4c:	e0bffb17 	ldw	r2,-20(fp)
8112eb50:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112eb54:	e0bffe17 	ldw	r2,-8(fp)
8112eb58:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8112eb5c:	0005883a 	mov	r2,zero
}
8112eb60:	e037883a 	mov	sp,fp
8112eb64:	df000017 	ldw	fp,0(sp)
8112eb68:	dec00104 	addi	sp,sp,4
8112eb6c:	f800283a 	ret

8112eb70 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8112eb70:	defff304 	addi	sp,sp,-52
8112eb74:	de00012e 	bgeu	sp,et,8112eb7c <OSQPend+0xc>
8112eb78:	003b68fa 	trap	3
8112eb7c:	dfc00c15 	stw	ra,48(sp)
8112eb80:	df000b15 	stw	fp,44(sp)
8112eb84:	df000b04 	addi	fp,sp,44
8112eb88:	e13ffd15 	stw	r4,-12(fp)
8112eb8c:	2805883a 	mov	r2,r5
8112eb90:	e1bfff15 	stw	r6,-4(fp)
8112eb94:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112eb98:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112eb9c:	e0bfff17 	ldw	r2,-4(fp)
8112eba0:	1000021e 	bne	r2,zero,8112ebac <OSQPend+0x3c>
        return ((void *)0);
8112eba4:	0005883a 	mov	r2,zero
8112eba8:	00009106 	br	8112edf0 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8112ebac:	e0bffd17 	ldw	r2,-12(fp)
8112ebb0:	1000051e 	bne	r2,zero,8112ebc8 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8112ebb4:	e0bfff17 	ldw	r2,-4(fp)
8112ebb8:	00c00104 	movi	r3,4
8112ebbc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8112ebc0:	0005883a 	mov	r2,zero
8112ebc4:	00008a06 	br	8112edf0 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8112ebc8:	e0bffd17 	ldw	r2,-12(fp)
8112ebcc:	10800003 	ldbu	r2,0(r2)
8112ebd0:	10803fcc 	andi	r2,r2,255
8112ebd4:	108000a0 	cmpeqi	r2,r2,2
8112ebd8:	1000051e 	bne	r2,zero,8112ebf0 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8112ebdc:	e0bfff17 	ldw	r2,-4(fp)
8112ebe0:	00c00044 	movi	r3,1
8112ebe4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8112ebe8:	0005883a 	mov	r2,zero
8112ebec:	00008006 	br	8112edf0 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8112ebf0:	d0a08503 	ldbu	r2,-32236(gp)
8112ebf4:	10803fcc 	andi	r2,r2,255
8112ebf8:	10000526 	beq	r2,zero,8112ec10 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8112ebfc:	e0bfff17 	ldw	r2,-4(fp)
8112ec00:	00c00084 	movi	r3,2
8112ec04:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8112ec08:	0005883a 	mov	r2,zero
8112ec0c:	00007806 	br	8112edf0 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8112ec10:	d0a07303 	ldbu	r2,-32308(gp)
8112ec14:	10803fcc 	andi	r2,r2,255
8112ec18:	10000526 	beq	r2,zero,8112ec30 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8112ec1c:	e0bfff17 	ldw	r2,-4(fp)
8112ec20:	00c00344 	movi	r3,13
8112ec24:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8112ec28:	0005883a 	mov	r2,zero
8112ec2c:	00007006 	br	8112edf0 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ec30:	0005303a 	rdctl	r2,status
8112ec34:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ec38:	e0fffc17 	ldw	r3,-16(fp)
8112ec3c:	00bfff84 	movi	r2,-2
8112ec40:	1884703a 	and	r2,r3,r2
8112ec44:	1001703a 	wrctl	status,r2
  
  return context;
8112ec48:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112ec4c:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8112ec50:	e0bffd17 	ldw	r2,-12(fp)
8112ec54:	10800117 	ldw	r2,4(r2)
8112ec58:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8112ec5c:	e0bff817 	ldw	r2,-32(fp)
8112ec60:	1080058b 	ldhu	r2,22(r2)
8112ec64:	10bfffcc 	andi	r2,r2,65535
8112ec68:	10001e26 	beq	r2,zero,8112ece4 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8112ec6c:	e0bff817 	ldw	r2,-32(fp)
8112ec70:	10800417 	ldw	r2,16(r2)
8112ec74:	11000104 	addi	r4,r2,4
8112ec78:	e0fff817 	ldw	r3,-32(fp)
8112ec7c:	19000415 	stw	r4,16(r3)
8112ec80:	10800017 	ldw	r2,0(r2)
8112ec84:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8112ec88:	e0bff817 	ldw	r2,-32(fp)
8112ec8c:	1080058b 	ldhu	r2,22(r2)
8112ec90:	10bfffc4 	addi	r2,r2,-1
8112ec94:	1007883a 	mov	r3,r2
8112ec98:	e0bff817 	ldw	r2,-32(fp)
8112ec9c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8112eca0:	e0bff817 	ldw	r2,-32(fp)
8112eca4:	10c00417 	ldw	r3,16(r2)
8112eca8:	e0bff817 	ldw	r2,-32(fp)
8112ecac:	10800217 	ldw	r2,8(r2)
8112ecb0:	1880041e 	bne	r3,r2,8112ecc4 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8112ecb4:	e0bff817 	ldw	r2,-32(fp)
8112ecb8:	10c00117 	ldw	r3,4(r2)
8112ecbc:	e0bff817 	ldw	r2,-32(fp)
8112ecc0:	10c00415 	stw	r3,16(r2)
8112ecc4:	e0bff617 	ldw	r2,-40(fp)
8112ecc8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112eccc:	e0bff717 	ldw	r2,-36(fp)
8112ecd0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8112ecd4:	e0bfff17 	ldw	r2,-4(fp)
8112ecd8:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8112ecdc:	e0bff517 	ldw	r2,-44(fp)
8112ece0:	00004306 	br	8112edf0 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8112ece4:	d0a08617 	ldw	r2,-32232(gp)
8112ece8:	d0e08617 	ldw	r3,-32232(gp)
8112ecec:	18c00c03 	ldbu	r3,48(r3)
8112ecf0:	18c00114 	ori	r3,r3,4
8112ecf4:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8112ecf8:	d0a08617 	ldw	r2,-32232(gp)
8112ecfc:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8112ed00:	d0a08617 	ldw	r2,-32232(gp)
8112ed04:	e0fffe0b 	ldhu	r3,-8(fp)
8112ed08:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8112ed0c:	e13ffd17 	ldw	r4,-12(fp)
8112ed10:	112a29c0 	call	8112a29c <OS_EventTaskWait>
8112ed14:	e0bff617 	ldw	r2,-40(fp)
8112ed18:	e0bffb15 	stw	r2,-20(fp)
8112ed1c:	e0bffb17 	ldw	r2,-20(fp)
8112ed20:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8112ed24:	112abb80 	call	8112abb8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ed28:	0005303a 	rdctl	r2,status
8112ed2c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ed30:	e0fff917 	ldw	r3,-28(fp)
8112ed34:	00bfff84 	movi	r2,-2
8112ed38:	1884703a 	and	r2,r3,r2
8112ed3c:	1001703a 	wrctl	status,r2
  
  return context;
8112ed40:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8112ed44:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8112ed48:	d0a08617 	ldw	r2,-32232(gp)
8112ed4c:	10800c43 	ldbu	r2,49(r2)
8112ed50:	10803fcc 	andi	r2,r2,255
8112ed54:	10000326 	beq	r2,zero,8112ed64 <OSQPend+0x1f4>
8112ed58:	108000a0 	cmpeqi	r2,r2,2
8112ed5c:	1000071e 	bne	r2,zero,8112ed7c <OSQPend+0x20c>
8112ed60:	00000b06 	br	8112ed90 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8112ed64:	d0a08617 	ldw	r2,-32232(gp)
8112ed68:	10800917 	ldw	r2,36(r2)
8112ed6c:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8112ed70:	e0bfff17 	ldw	r2,-4(fp)
8112ed74:	10000005 	stb	zero,0(r2)
             break;
8112ed78:	00000e06 	br	8112edb4 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8112ed7c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8112ed80:	e0bfff17 	ldw	r2,-4(fp)
8112ed84:	00c00384 	movi	r3,14
8112ed88:	10c00005 	stb	r3,0(r2)
             break;
8112ed8c:	00000906 	br	8112edb4 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8112ed90:	d0a08617 	ldw	r2,-32232(gp)
8112ed94:	e17ffd17 	ldw	r5,-12(fp)
8112ed98:	1009883a 	mov	r4,r2
8112ed9c:	112a50c0 	call	8112a50c <OS_EventTaskRemove>
             pmsg = (void *)0;
8112eda0:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8112eda4:	e0bfff17 	ldw	r2,-4(fp)
8112eda8:	00c00284 	movi	r3,10
8112edac:	10c00005 	stb	r3,0(r2)
             break;
8112edb0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8112edb4:	d0a08617 	ldw	r2,-32232(gp)
8112edb8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8112edbc:	d0a08617 	ldw	r2,-32232(gp)
8112edc0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8112edc4:	d0a08617 	ldw	r2,-32232(gp)
8112edc8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8112edcc:	d0a08617 	ldw	r2,-32232(gp)
8112edd0:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8112edd4:	d0a08617 	ldw	r2,-32232(gp)
8112edd8:	10000915 	stw	zero,36(r2)
8112eddc:	e0bff617 	ldw	r2,-40(fp)
8112ede0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ede4:	e0bffa17 	ldw	r2,-24(fp)
8112ede8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8112edec:	e0bff517 	ldw	r2,-44(fp)
}
8112edf0:	e037883a 	mov	sp,fp
8112edf4:	dfc00117 	ldw	ra,4(sp)
8112edf8:	df000017 	ldw	fp,0(sp)
8112edfc:	dec00204 	addi	sp,sp,8
8112ee00:	f800283a 	ret

8112ee04 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8112ee04:	defff604 	addi	sp,sp,-40
8112ee08:	de00012e 	bgeu	sp,et,8112ee10 <OSQPendAbort+0xc>
8112ee0c:	003b68fa 	trap	3
8112ee10:	dfc00915 	stw	ra,36(sp)
8112ee14:	df000815 	stw	fp,32(sp)
8112ee18:	df000804 	addi	fp,sp,32
8112ee1c:	e13ffd15 	stw	r4,-12(fp)
8112ee20:	2805883a 	mov	r2,r5
8112ee24:	e1bfff15 	stw	r6,-4(fp)
8112ee28:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112ee2c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112ee30:	e0bfff17 	ldw	r2,-4(fp)
8112ee34:	1000021e 	bne	r2,zero,8112ee40 <OSQPendAbort+0x3c>
        return (0);
8112ee38:	0005883a 	mov	r2,zero
8112ee3c:	00004906 	br	8112ef64 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8112ee40:	e0bffd17 	ldw	r2,-12(fp)
8112ee44:	1000051e 	bne	r2,zero,8112ee5c <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8112ee48:	e0bfff17 	ldw	r2,-4(fp)
8112ee4c:	00c00104 	movi	r3,4
8112ee50:	10c00005 	stb	r3,0(r2)
        return (0);
8112ee54:	0005883a 	mov	r2,zero
8112ee58:	00004206 	br	8112ef64 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8112ee5c:	e0bffd17 	ldw	r2,-12(fp)
8112ee60:	10800003 	ldbu	r2,0(r2)
8112ee64:	10803fcc 	andi	r2,r2,255
8112ee68:	108000a0 	cmpeqi	r2,r2,2
8112ee6c:	1000051e 	bne	r2,zero,8112ee84 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8112ee70:	e0bfff17 	ldw	r2,-4(fp)
8112ee74:	00c00044 	movi	r3,1
8112ee78:	10c00005 	stb	r3,0(r2)
        return (0);
8112ee7c:	0005883a 	mov	r2,zero
8112ee80:	00003806 	br	8112ef64 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ee84:	0005303a 	rdctl	r2,status
8112ee88:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ee8c:	e0fffc17 	ldw	r3,-16(fp)
8112ee90:	00bfff84 	movi	r2,-2
8112ee94:	1884703a 	and	r2,r3,r2
8112ee98:	1001703a 	wrctl	status,r2
  
  return context;
8112ee9c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112eea0:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8112eea4:	e0bffd17 	ldw	r2,-12(fp)
8112eea8:	10800283 	ldbu	r2,10(r2)
8112eeac:	10803fcc 	andi	r2,r2,255
8112eeb0:	10002526 	beq	r2,zero,8112ef48 <OSQPendAbort+0x144>
        nbr_tasks = 0;
8112eeb4:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8112eeb8:	e0bffe03 	ldbu	r2,-8(fp)
8112eebc:	10800060 	cmpeqi	r2,r2,1
8112eec0:	10000e26 	beq	r2,zero,8112eefc <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8112eec4:	00000806 	br	8112eee8 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8112eec8:	01c00084 	movi	r7,2
8112eecc:	01800104 	movi	r6,4
8112eed0:	000b883a 	mov	r5,zero
8112eed4:	e13ffd17 	ldw	r4,-12(fp)
8112eed8:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
                     nbr_tasks++;
8112eedc:	e0bff803 	ldbu	r2,-32(fp)
8112eee0:	10800044 	addi	r2,r2,1
8112eee4:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8112eee8:	e0bffd17 	ldw	r2,-12(fp)
8112eeec:	10800283 	ldbu	r2,10(r2)
8112eef0:	10803fcc 	andi	r2,r2,255
8112eef4:	103ff41e 	bne	r2,zero,8112eec8 <__reset+0xfb10eec8>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8112eef8:	00000906 	br	8112ef20 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8112eefc:	01c00084 	movi	r7,2
8112ef00:	01800104 	movi	r6,4
8112ef04:	000b883a 	mov	r5,zero
8112ef08:	e13ffd17 	ldw	r4,-12(fp)
8112ef0c:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
                 nbr_tasks++;
8112ef10:	e0bff803 	ldbu	r2,-32(fp)
8112ef14:	10800044 	addi	r2,r2,1
8112ef18:	e0bff805 	stb	r2,-32(fp)
                 break;
8112ef1c:	0001883a 	nop
8112ef20:	e0bff917 	ldw	r2,-28(fp)
8112ef24:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ef28:	e0bffa17 	ldw	r2,-24(fp)
8112ef2c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8112ef30:	112abb80 	call	8112abb8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8112ef34:	e0bfff17 	ldw	r2,-4(fp)
8112ef38:	00c00384 	movi	r3,14
8112ef3c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8112ef40:	e0bff803 	ldbu	r2,-32(fp)
8112ef44:	00000706 	br	8112ef64 <OSQPendAbort+0x160>
8112ef48:	e0bff917 	ldw	r2,-28(fp)
8112ef4c:	e0bffb15 	stw	r2,-20(fp)
8112ef50:	e0bffb17 	ldw	r2,-20(fp)
8112ef54:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112ef58:	e0bfff17 	ldw	r2,-4(fp)
8112ef5c:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
8112ef60:	0005883a 	mov	r2,zero
}
8112ef64:	e037883a 	mov	sp,fp
8112ef68:	dfc00117 	ldw	ra,4(sp)
8112ef6c:	df000017 	ldw	fp,0(sp)
8112ef70:	dec00204 	addi	sp,sp,8
8112ef74:	f800283a 	ret

8112ef78 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8112ef78:	defff604 	addi	sp,sp,-40
8112ef7c:	de00012e 	bgeu	sp,et,8112ef84 <OSQPost+0xc>
8112ef80:	003b68fa 	trap	3
8112ef84:	dfc00915 	stw	ra,36(sp)
8112ef88:	df000815 	stw	fp,32(sp)
8112ef8c:	df000804 	addi	fp,sp,32
8112ef90:	e13ffe15 	stw	r4,-8(fp)
8112ef94:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8112ef98:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8112ef9c:	e0bffe17 	ldw	r2,-8(fp)
8112efa0:	1000021e 	bne	r2,zero,8112efac <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8112efa4:	00800104 	movi	r2,4
8112efa8:	00004a06 	br	8112f0d4 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8112efac:	e0bffe17 	ldw	r2,-8(fp)
8112efb0:	10800003 	ldbu	r2,0(r2)
8112efb4:	10803fcc 	andi	r2,r2,255
8112efb8:	108000a0 	cmpeqi	r2,r2,2
8112efbc:	1000021e 	bne	r2,zero,8112efc8 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8112efc0:	00800044 	movi	r2,1
8112efc4:	00004306 	br	8112f0d4 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112efc8:	0005303a 	rdctl	r2,status
8112efcc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112efd0:	e0fffd17 	ldw	r3,-12(fp)
8112efd4:	00bfff84 	movi	r2,-2
8112efd8:	1884703a 	and	r2,r3,r2
8112efdc:	1001703a 	wrctl	status,r2
  
  return context;
8112efe0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8112efe4:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8112efe8:	e0bffe17 	ldw	r2,-8(fp)
8112efec:	10800283 	ldbu	r2,10(r2)
8112eff0:	10803fcc 	andi	r2,r2,255
8112eff4:	10000c26 	beq	r2,zero,8112f028 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8112eff8:	000f883a 	mov	r7,zero
8112effc:	01800104 	movi	r6,4
8112f000:	e17fff17 	ldw	r5,-4(fp)
8112f004:	e13ffe17 	ldw	r4,-8(fp)
8112f008:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
8112f00c:	e0bff817 	ldw	r2,-32(fp)
8112f010:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f014:	e0bff917 	ldw	r2,-28(fp)
8112f018:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8112f01c:	112abb80 	call	8112abb8 <OS_Sched>
        return (OS_ERR_NONE);
8112f020:	0005883a 	mov	r2,zero
8112f024:	00002b06 	br	8112f0d4 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8112f028:	e0bffe17 	ldw	r2,-8(fp)
8112f02c:	10800117 	ldw	r2,4(r2)
8112f030:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8112f034:	e0bffb17 	ldw	r2,-20(fp)
8112f038:	10c0058b 	ldhu	r3,22(r2)
8112f03c:	e0bffb17 	ldw	r2,-20(fp)
8112f040:	1080050b 	ldhu	r2,20(r2)
8112f044:	18ffffcc 	andi	r3,r3,65535
8112f048:	10bfffcc 	andi	r2,r2,65535
8112f04c:	18800636 	bltu	r3,r2,8112f068 <OSQPost+0xf0>
8112f050:	e0bff817 	ldw	r2,-32(fp)
8112f054:	e0bffa15 	stw	r2,-24(fp)
8112f058:	e0bffa17 	ldw	r2,-24(fp)
8112f05c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8112f060:	00800784 	movi	r2,30
8112f064:	00001b06 	br	8112f0d4 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8112f068:	e0bffb17 	ldw	r2,-20(fp)
8112f06c:	10800317 	ldw	r2,12(r2)
8112f070:	11000104 	addi	r4,r2,4
8112f074:	e0fffb17 	ldw	r3,-20(fp)
8112f078:	19000315 	stw	r4,12(r3)
8112f07c:	e0ffff17 	ldw	r3,-4(fp)
8112f080:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8112f084:	e0bffb17 	ldw	r2,-20(fp)
8112f088:	1080058b 	ldhu	r2,22(r2)
8112f08c:	10800044 	addi	r2,r2,1
8112f090:	1007883a 	mov	r3,r2
8112f094:	e0bffb17 	ldw	r2,-20(fp)
8112f098:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8112f09c:	e0bffb17 	ldw	r2,-20(fp)
8112f0a0:	10c00317 	ldw	r3,12(r2)
8112f0a4:	e0bffb17 	ldw	r2,-20(fp)
8112f0a8:	10800217 	ldw	r2,8(r2)
8112f0ac:	1880041e 	bne	r3,r2,8112f0c0 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8112f0b0:	e0bffb17 	ldw	r2,-20(fp)
8112f0b4:	10c00117 	ldw	r3,4(r2)
8112f0b8:	e0bffb17 	ldw	r2,-20(fp)
8112f0bc:	10c00315 	stw	r3,12(r2)
8112f0c0:	e0bff817 	ldw	r2,-32(fp)
8112f0c4:	e0bffc15 	stw	r2,-16(fp)
8112f0c8:	e0bffc17 	ldw	r2,-16(fp)
8112f0cc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8112f0d0:	0005883a 	mov	r2,zero
}
8112f0d4:	e037883a 	mov	sp,fp
8112f0d8:	dfc00117 	ldw	ra,4(sp)
8112f0dc:	df000017 	ldw	fp,0(sp)
8112f0e0:	dec00204 	addi	sp,sp,8
8112f0e4:	f800283a 	ret

8112f0e8 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8112f0e8:	defff604 	addi	sp,sp,-40
8112f0ec:	de00012e 	bgeu	sp,et,8112f0f4 <OSQPostFront+0xc>
8112f0f0:	003b68fa 	trap	3
8112f0f4:	dfc00915 	stw	ra,36(sp)
8112f0f8:	df000815 	stw	fp,32(sp)
8112f0fc:	df000804 	addi	fp,sp,32
8112f100:	e13ffe15 	stw	r4,-8(fp)
8112f104:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8112f108:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8112f10c:	e0bffe17 	ldw	r2,-8(fp)
8112f110:	1000021e 	bne	r2,zero,8112f11c <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8112f114:	00800104 	movi	r2,4
8112f118:	00004c06 	br	8112f24c <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8112f11c:	e0bffe17 	ldw	r2,-8(fp)
8112f120:	10800003 	ldbu	r2,0(r2)
8112f124:	10803fcc 	andi	r2,r2,255
8112f128:	108000a0 	cmpeqi	r2,r2,2
8112f12c:	1000021e 	bne	r2,zero,8112f138 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8112f130:	00800044 	movi	r2,1
8112f134:	00004506 	br	8112f24c <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f138:	0005303a 	rdctl	r2,status
8112f13c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f140:	e0fffd17 	ldw	r3,-12(fp)
8112f144:	00bfff84 	movi	r2,-2
8112f148:	1884703a 	and	r2,r3,r2
8112f14c:	1001703a 	wrctl	status,r2
  
  return context;
8112f150:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8112f154:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8112f158:	e0bffe17 	ldw	r2,-8(fp)
8112f15c:	10800283 	ldbu	r2,10(r2)
8112f160:	10803fcc 	andi	r2,r2,255
8112f164:	10000c26 	beq	r2,zero,8112f198 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8112f168:	000f883a 	mov	r7,zero
8112f16c:	01800104 	movi	r6,4
8112f170:	e17fff17 	ldw	r5,-4(fp)
8112f174:	e13ffe17 	ldw	r4,-8(fp)
8112f178:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
8112f17c:	e0bff817 	ldw	r2,-32(fp)
8112f180:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f184:	e0bff917 	ldw	r2,-28(fp)
8112f188:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8112f18c:	112abb80 	call	8112abb8 <OS_Sched>
        return (OS_ERR_NONE);
8112f190:	0005883a 	mov	r2,zero
8112f194:	00002d06 	br	8112f24c <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8112f198:	e0bffe17 	ldw	r2,-8(fp)
8112f19c:	10800117 	ldw	r2,4(r2)
8112f1a0:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8112f1a4:	e0bffb17 	ldw	r2,-20(fp)
8112f1a8:	10c0058b 	ldhu	r3,22(r2)
8112f1ac:	e0bffb17 	ldw	r2,-20(fp)
8112f1b0:	1080050b 	ldhu	r2,20(r2)
8112f1b4:	18ffffcc 	andi	r3,r3,65535
8112f1b8:	10bfffcc 	andi	r2,r2,65535
8112f1bc:	18800636 	bltu	r3,r2,8112f1d8 <OSQPostFront+0xf0>
8112f1c0:	e0bff817 	ldw	r2,-32(fp)
8112f1c4:	e0bffa15 	stw	r2,-24(fp)
8112f1c8:	e0bffa17 	ldw	r2,-24(fp)
8112f1cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8112f1d0:	00800784 	movi	r2,30
8112f1d4:	00001d06 	br	8112f24c <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8112f1d8:	e0bffb17 	ldw	r2,-20(fp)
8112f1dc:	10c00417 	ldw	r3,16(r2)
8112f1e0:	e0bffb17 	ldw	r2,-20(fp)
8112f1e4:	10800117 	ldw	r2,4(r2)
8112f1e8:	1880041e 	bne	r3,r2,8112f1fc <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8112f1ec:	e0bffb17 	ldw	r2,-20(fp)
8112f1f0:	10c00217 	ldw	r3,8(r2)
8112f1f4:	e0bffb17 	ldw	r2,-20(fp)
8112f1f8:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8112f1fc:	e0bffb17 	ldw	r2,-20(fp)
8112f200:	10800417 	ldw	r2,16(r2)
8112f204:	10ffff04 	addi	r3,r2,-4
8112f208:	e0bffb17 	ldw	r2,-20(fp)
8112f20c:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8112f210:	e0bffb17 	ldw	r2,-20(fp)
8112f214:	10800417 	ldw	r2,16(r2)
8112f218:	e0ffff17 	ldw	r3,-4(fp)
8112f21c:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8112f220:	e0bffb17 	ldw	r2,-20(fp)
8112f224:	1080058b 	ldhu	r2,22(r2)
8112f228:	10800044 	addi	r2,r2,1
8112f22c:	1007883a 	mov	r3,r2
8112f230:	e0bffb17 	ldw	r2,-20(fp)
8112f234:	10c0058d 	sth	r3,22(r2)
8112f238:	e0bff817 	ldw	r2,-32(fp)
8112f23c:	e0bffc15 	stw	r2,-16(fp)
8112f240:	e0bffc17 	ldw	r2,-16(fp)
8112f244:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8112f248:	0005883a 	mov	r2,zero
}
8112f24c:	e037883a 	mov	sp,fp
8112f250:	dfc00117 	ldw	ra,4(sp)
8112f254:	df000017 	ldw	fp,0(sp)
8112f258:	dec00204 	addi	sp,sp,8
8112f25c:	f800283a 	ret

8112f260 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8112f260:	defff504 	addi	sp,sp,-44
8112f264:	de00012e 	bgeu	sp,et,8112f26c <OSQPostOpt+0xc>
8112f268:	003b68fa 	trap	3
8112f26c:	dfc00a15 	stw	ra,40(sp)
8112f270:	df000915 	stw	fp,36(sp)
8112f274:	df000904 	addi	fp,sp,36
8112f278:	e13ffd15 	stw	r4,-12(fp)
8112f27c:	e17ffe15 	stw	r5,-8(fp)
8112f280:	3005883a 	mov	r2,r6
8112f284:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8112f288:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8112f28c:	e0bffd17 	ldw	r2,-12(fp)
8112f290:	1000021e 	bne	r2,zero,8112f29c <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8112f294:	00800104 	movi	r2,4
8112f298:	00007106 	br	8112f460 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8112f29c:	e0bffd17 	ldw	r2,-12(fp)
8112f2a0:	10800003 	ldbu	r2,0(r2)
8112f2a4:	10803fcc 	andi	r2,r2,255
8112f2a8:	108000a0 	cmpeqi	r2,r2,2
8112f2ac:	1000021e 	bne	r2,zero,8112f2b8 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8112f2b0:	00800044 	movi	r2,1
8112f2b4:	00006a06 	br	8112f460 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f2b8:	0005303a 	rdctl	r2,status
8112f2bc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f2c0:	e0fffc17 	ldw	r3,-16(fp)
8112f2c4:	00bfff84 	movi	r2,-2
8112f2c8:	1884703a 	and	r2,r3,r2
8112f2cc:	1001703a 	wrctl	status,r2
  
  return context;
8112f2d0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112f2d4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8112f2d8:	e0bffd17 	ldw	r2,-12(fp)
8112f2dc:	10800283 	ldbu	r2,10(r2)
8112f2e0:	10803fcc 	andi	r2,r2,255
8112f2e4:	10001d26 	beq	r2,zero,8112f35c <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8112f2e8:	e0bfff03 	ldbu	r2,-4(fp)
8112f2ec:	1080004c 	andi	r2,r2,1
8112f2f0:	10000b26 	beq	r2,zero,8112f320 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8112f2f4:	00000506 	br	8112f30c <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8112f2f8:	000f883a 	mov	r7,zero
8112f2fc:	01800104 	movi	r6,4
8112f300:	e17ffe17 	ldw	r5,-8(fp)
8112f304:	e13ffd17 	ldw	r4,-12(fp)
8112f308:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8112f30c:	e0bffd17 	ldw	r2,-12(fp)
8112f310:	10800283 	ldbu	r2,10(r2)
8112f314:	10803fcc 	andi	r2,r2,255
8112f318:	103ff71e 	bne	r2,zero,8112f2f8 <__reset+0xfb10f2f8>
8112f31c:	00000506 	br	8112f334 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8112f320:	000f883a 	mov	r7,zero
8112f324:	01800104 	movi	r6,4
8112f328:	e17ffe17 	ldw	r5,-8(fp)
8112f32c:	e13ffd17 	ldw	r4,-12(fp)
8112f330:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
8112f334:	e0bff717 	ldw	r2,-36(fp)
8112f338:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f33c:	e0bff817 	ldw	r2,-32(fp)
8112f340:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8112f344:	e0bfff03 	ldbu	r2,-4(fp)
8112f348:	1080010c 	andi	r2,r2,4
8112f34c:	1000011e 	bne	r2,zero,8112f354 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
8112f350:	112abb80 	call	8112abb8 <OS_Sched>
        }
        return (OS_ERR_NONE);
8112f354:	0005883a 	mov	r2,zero
8112f358:	00004106 	br	8112f460 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8112f35c:	e0bffd17 	ldw	r2,-12(fp)
8112f360:	10800117 	ldw	r2,4(r2)
8112f364:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8112f368:	e0bffa17 	ldw	r2,-24(fp)
8112f36c:	10c0058b 	ldhu	r3,22(r2)
8112f370:	e0bffa17 	ldw	r2,-24(fp)
8112f374:	1080050b 	ldhu	r2,20(r2)
8112f378:	18ffffcc 	andi	r3,r3,65535
8112f37c:	10bfffcc 	andi	r2,r2,65535
8112f380:	18800636 	bltu	r3,r2,8112f39c <OSQPostOpt+0x13c>
8112f384:	e0bff717 	ldw	r2,-36(fp)
8112f388:	e0bff915 	stw	r2,-28(fp)
8112f38c:	e0bff917 	ldw	r2,-28(fp)
8112f390:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8112f394:	00800784 	movi	r2,30
8112f398:	00003106 	br	8112f460 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8112f39c:	e0bfff03 	ldbu	r2,-4(fp)
8112f3a0:	1080008c 	andi	r2,r2,2
8112f3a4:	10001326 	beq	r2,zero,8112f3f4 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8112f3a8:	e0bffa17 	ldw	r2,-24(fp)
8112f3ac:	10c00417 	ldw	r3,16(r2)
8112f3b0:	e0bffa17 	ldw	r2,-24(fp)
8112f3b4:	10800117 	ldw	r2,4(r2)
8112f3b8:	1880041e 	bne	r3,r2,8112f3cc <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8112f3bc:	e0bffa17 	ldw	r2,-24(fp)
8112f3c0:	10c00217 	ldw	r3,8(r2)
8112f3c4:	e0bffa17 	ldw	r2,-24(fp)
8112f3c8:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8112f3cc:	e0bffa17 	ldw	r2,-24(fp)
8112f3d0:	10800417 	ldw	r2,16(r2)
8112f3d4:	10ffff04 	addi	r3,r2,-4
8112f3d8:	e0bffa17 	ldw	r2,-24(fp)
8112f3dc:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
8112f3e0:	e0bffa17 	ldw	r2,-24(fp)
8112f3e4:	10800417 	ldw	r2,16(r2)
8112f3e8:	e0fffe17 	ldw	r3,-8(fp)
8112f3ec:	10c00015 	stw	r3,0(r2)
8112f3f0:	00001006 	br	8112f434 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
8112f3f4:	e0bffa17 	ldw	r2,-24(fp)
8112f3f8:	10800317 	ldw	r2,12(r2)
8112f3fc:	11000104 	addi	r4,r2,4
8112f400:	e0fffa17 	ldw	r3,-24(fp)
8112f404:	19000315 	stw	r4,12(r3)
8112f408:	e0fffe17 	ldw	r3,-8(fp)
8112f40c:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
8112f410:	e0bffa17 	ldw	r2,-24(fp)
8112f414:	10c00317 	ldw	r3,12(r2)
8112f418:	e0bffa17 	ldw	r2,-24(fp)
8112f41c:	10800217 	ldw	r2,8(r2)
8112f420:	1880041e 	bne	r3,r2,8112f434 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8112f424:	e0bffa17 	ldw	r2,-24(fp)
8112f428:	10c00117 	ldw	r3,4(r2)
8112f42c:	e0bffa17 	ldw	r2,-24(fp)
8112f430:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8112f434:	e0bffa17 	ldw	r2,-24(fp)
8112f438:	1080058b 	ldhu	r2,22(r2)
8112f43c:	10800044 	addi	r2,r2,1
8112f440:	1007883a 	mov	r3,r2
8112f444:	e0bffa17 	ldw	r2,-24(fp)
8112f448:	10c0058d 	sth	r3,22(r2)
8112f44c:	e0bff717 	ldw	r2,-36(fp)
8112f450:	e0bffb15 	stw	r2,-20(fp)
8112f454:	e0bffb17 	ldw	r2,-20(fp)
8112f458:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8112f45c:	0005883a 	mov	r2,zero
}
8112f460:	e037883a 	mov	sp,fp
8112f464:	dfc00117 	ldw	ra,4(sp)
8112f468:	df000017 	ldw	fp,0(sp)
8112f46c:	dec00204 	addi	sp,sp,8
8112f470:	f800283a 	ret

8112f474 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8112f474:	defff604 	addi	sp,sp,-40
8112f478:	de00012e 	bgeu	sp,et,8112f480 <OSQQuery+0xc>
8112f47c:	003b68fa 	trap	3
8112f480:	df000915 	stw	fp,36(sp)
8112f484:	df000904 	addi	fp,sp,36
8112f488:	e13ffe15 	stw	r4,-8(fp)
8112f48c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8112f490:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8112f494:	e0bffe17 	ldw	r2,-8(fp)
8112f498:	1000021e 	bne	r2,zero,8112f4a4 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8112f49c:	00800104 	movi	r2,4
8112f4a0:	00004906 	br	8112f5c8 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8112f4a4:	e0bfff17 	ldw	r2,-4(fp)
8112f4a8:	1000021e 	bne	r2,zero,8112f4b4 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8112f4ac:	00800244 	movi	r2,9
8112f4b0:	00004506 	br	8112f5c8 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8112f4b4:	e0bffe17 	ldw	r2,-8(fp)
8112f4b8:	10800003 	ldbu	r2,0(r2)
8112f4bc:	10803fcc 	andi	r2,r2,255
8112f4c0:	108000a0 	cmpeqi	r2,r2,2
8112f4c4:	1000021e 	bne	r2,zero,8112f4d0 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8112f4c8:	00800044 	movi	r2,1
8112f4cc:	00003e06 	br	8112f5c8 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f4d0:	0005303a 	rdctl	r2,status
8112f4d4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f4d8:	e0fffd17 	ldw	r3,-12(fp)
8112f4dc:	00bfff84 	movi	r2,-2
8112f4e0:	1884703a 	and	r2,r3,r2
8112f4e4:	1001703a 	wrctl	status,r2
  
  return context;
8112f4e8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8112f4ec:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
8112f4f0:	e0bffe17 	ldw	r2,-8(fp)
8112f4f4:	10c00283 	ldbu	r3,10(r2)
8112f4f8:	e0bfff17 	ldw	r2,-4(fp)
8112f4fc:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
8112f500:	e0bffe17 	ldw	r2,-8(fp)
8112f504:	108002c4 	addi	r2,r2,11
8112f508:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8112f50c:	e0bfff17 	ldw	r2,-4(fp)
8112f510:	10800204 	addi	r2,r2,8
8112f514:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112f518:	e03ff705 	stb	zero,-36(fp)
8112f51c:	00000b06 	br	8112f54c <OSQQuery+0xd8>
        *pdest++ = *psrc++;
8112f520:	e0bff917 	ldw	r2,-28(fp)
8112f524:	10c00044 	addi	r3,r2,1
8112f528:	e0fff915 	stw	r3,-28(fp)
8112f52c:	e0fff817 	ldw	r3,-32(fp)
8112f530:	19000044 	addi	r4,r3,1
8112f534:	e13ff815 	stw	r4,-32(fp)
8112f538:	18c00003 	ldbu	r3,0(r3)
8112f53c:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112f540:	e0bff703 	ldbu	r2,-36(fp)
8112f544:	10800044 	addi	r2,r2,1
8112f548:	e0bff705 	stb	r2,-36(fp)
8112f54c:	e0bff703 	ldbu	r2,-36(fp)
8112f550:	108001b0 	cmpltui	r2,r2,6
8112f554:	103ff21e 	bne	r2,zero,8112f520 <__reset+0xfb10f520>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8112f558:	e0bffe17 	ldw	r2,-8(fp)
8112f55c:	10800117 	ldw	r2,4(r2)
8112f560:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8112f564:	e0bffc17 	ldw	r2,-16(fp)
8112f568:	1080058b 	ldhu	r2,22(r2)
8112f56c:	10bfffcc 	andi	r2,r2,65535
8112f570:	10000626 	beq	r2,zero,8112f58c <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8112f574:	e0bffc17 	ldw	r2,-16(fp)
8112f578:	10800417 	ldw	r2,16(r2)
8112f57c:	10c00017 	ldw	r3,0(r2)
8112f580:	e0bfff17 	ldw	r2,-4(fp)
8112f584:	10c00015 	stw	r3,0(r2)
8112f588:	00000206 	br	8112f594 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8112f58c:	e0bfff17 	ldw	r2,-4(fp)
8112f590:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8112f594:	e0bffc17 	ldw	r2,-16(fp)
8112f598:	10c0058b 	ldhu	r3,22(r2)
8112f59c:	e0bfff17 	ldw	r2,-4(fp)
8112f5a0:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8112f5a4:	e0bffc17 	ldw	r2,-16(fp)
8112f5a8:	10c0050b 	ldhu	r3,20(r2)
8112f5ac:	e0bfff17 	ldw	r2,-4(fp)
8112f5b0:	10c0018d 	sth	r3,6(r2)
8112f5b4:	e0bffa17 	ldw	r2,-24(fp)
8112f5b8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f5bc:	e0bffb17 	ldw	r2,-20(fp)
8112f5c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8112f5c4:	0005883a 	mov	r2,zero
}
8112f5c8:	e037883a 	mov	sp,fp
8112f5cc:	df000017 	ldw	fp,0(sp)
8112f5d0:	dec00104 	addi	sp,sp,4
8112f5d4:	f800283a 	ret

8112f5d8 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8112f5d8:	defffb04 	addi	sp,sp,-20
8112f5dc:	de00012e 	bgeu	sp,et,8112f5e4 <OS_QInit+0xc>
8112f5e0:	003b68fa 	trap	3
8112f5e4:	dfc00415 	stw	ra,16(sp)
8112f5e8:	df000315 	stw	fp,12(sp)
8112f5ec:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
8112f5f0:	01407804 	movi	r5,480
8112f5f4:	01204574 	movhi	r4,33045
8112f5f8:	21096f04 	addi	r4,r4,9660
8112f5fc:	112aaec0 	call	8112aaec <OS_MemClr>
    pq1 = &OSQTbl[0];
8112f600:	00a04574 	movhi	r2,33045
8112f604:	10896f04 	addi	r2,r2,9660
8112f608:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8112f60c:	00a04574 	movhi	r2,33045
8112f610:	10897504 	addi	r2,r2,9684
8112f614:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8112f618:	e03ffd0d 	sth	zero,-12(fp)
8112f61c:	00000c06 	br	8112f650 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
8112f620:	e0bffe17 	ldw	r2,-8(fp)
8112f624:	e0ffff17 	ldw	r3,-4(fp)
8112f628:	10c00015 	stw	r3,0(r2)
        pq1++;
8112f62c:	e0bffe17 	ldw	r2,-8(fp)
8112f630:	10800604 	addi	r2,r2,24
8112f634:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8112f638:	e0bfff17 	ldw	r2,-4(fp)
8112f63c:	10800604 	addi	r2,r2,24
8112f640:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8112f644:	e0bffd0b 	ldhu	r2,-12(fp)
8112f648:	10800044 	addi	r2,r2,1
8112f64c:	e0bffd0d 	sth	r2,-12(fp)
8112f650:	e0bffd0b 	ldhu	r2,-12(fp)
8112f654:	108004f0 	cmpltui	r2,r2,19
8112f658:	103ff11e 	bne	r2,zero,8112f620 <__reset+0xfb10f620>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8112f65c:	e0bffe17 	ldw	r2,-8(fp)
8112f660:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8112f664:	00a04574 	movhi	r2,33045
8112f668:	10896f04 	addi	r2,r2,9660
8112f66c:	d0a08115 	stw	r2,-32252(gp)
#endif
}
8112f670:	0001883a 	nop
8112f674:	e037883a 	mov	sp,fp
8112f678:	dfc00117 	ldw	ra,4(sp)
8112f67c:	df000017 	ldw	fp,0(sp)
8112f680:	dec00204 	addi	sp,sp,8
8112f684:	f800283a 	ret

8112f688 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8112f688:	defffa04 	addi	sp,sp,-24
8112f68c:	de00012e 	bgeu	sp,et,8112f694 <OSSemAccept+0xc>
8112f690:	003b68fa 	trap	3
8112f694:	df000515 	stw	fp,20(sp)
8112f698:	df000504 	addi	fp,sp,20
8112f69c:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8112f6a0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8112f6a4:	e0bfff17 	ldw	r2,-4(fp)
8112f6a8:	1000021e 	bne	r2,zero,8112f6b4 <OSSemAccept+0x2c>
        return (0);
8112f6ac:	0005883a 	mov	r2,zero
8112f6b0:	00001f06 	br	8112f730 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8112f6b4:	e0bfff17 	ldw	r2,-4(fp)
8112f6b8:	10800003 	ldbu	r2,0(r2)
8112f6bc:	10803fcc 	andi	r2,r2,255
8112f6c0:	108000e0 	cmpeqi	r2,r2,3
8112f6c4:	1000021e 	bne	r2,zero,8112f6d0 <OSSemAccept+0x48>
        return (0);
8112f6c8:	0005883a 	mov	r2,zero
8112f6cc:	00001806 	br	8112f730 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f6d0:	0005303a 	rdctl	r2,status
8112f6d4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f6d8:	e0fffe17 	ldw	r3,-8(fp)
8112f6dc:	00bfff84 	movi	r2,-2
8112f6e0:	1884703a 	and	r2,r3,r2
8112f6e4:	1001703a 	wrctl	status,r2
  
  return context;
8112f6e8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8112f6ec:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
8112f6f0:	e0bfff17 	ldw	r2,-4(fp)
8112f6f4:	1080020b 	ldhu	r2,8(r2)
8112f6f8:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8112f6fc:	e0bffd0b 	ldhu	r2,-12(fp)
8112f700:	10000626 	beq	r2,zero,8112f71c <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
8112f704:	e0bfff17 	ldw	r2,-4(fp)
8112f708:	1080020b 	ldhu	r2,8(r2)
8112f70c:	10bfffc4 	addi	r2,r2,-1
8112f710:	1007883a 	mov	r3,r2
8112f714:	e0bfff17 	ldw	r2,-4(fp)
8112f718:	10c0020d 	sth	r3,8(r2)
8112f71c:	e0bffb17 	ldw	r2,-20(fp)
8112f720:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f724:	e0bffc17 	ldw	r2,-16(fp)
8112f728:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8112f72c:	e0bffd0b 	ldhu	r2,-12(fp)
}
8112f730:	e037883a 	mov	sp,fp
8112f734:	df000017 	ldw	fp,0(sp)
8112f738:	dec00104 	addi	sp,sp,4
8112f73c:	f800283a 	ret

8112f740 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
8112f740:	defff904 	addi	sp,sp,-28
8112f744:	de00012e 	bgeu	sp,et,8112f74c <OSSemCreate+0xc>
8112f748:	003b68fa 	trap	3
8112f74c:	dfc00615 	stw	ra,24(sp)
8112f750:	df000515 	stw	fp,20(sp)
8112f754:	df000504 	addi	fp,sp,20
8112f758:	2005883a 	mov	r2,r4
8112f75c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112f760:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112f764:	d0a08503 	ldbu	r2,-32236(gp)
8112f768:	10803fcc 	andi	r2,r2,255
8112f76c:	10000226 	beq	r2,zero,8112f778 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
8112f770:	0005883a 	mov	r2,zero
8112f774:	00002506 	br	8112f80c <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f778:	0005303a 	rdctl	r2,status
8112f77c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f780:	e0fffe17 	ldw	r3,-8(fp)
8112f784:	00bfff84 	movi	r2,-2
8112f788:	1884703a 	and	r2,r3,r2
8112f78c:	1001703a 	wrctl	status,r2
  
  return context;
8112f790:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8112f794:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8112f798:	d0a08417 	ldw	r2,-32240(gp)
8112f79c:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
8112f7a0:	d0a08417 	ldw	r2,-32240(gp)
8112f7a4:	10000326 	beq	r2,zero,8112f7b4 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8112f7a8:	d0a08417 	ldw	r2,-32240(gp)
8112f7ac:	10800117 	ldw	r2,4(r2)
8112f7b0:	d0a08415 	stw	r2,-32240(gp)
8112f7b4:	e0bffb17 	ldw	r2,-20(fp)
8112f7b8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f7bc:	e0bffc17 	ldw	r2,-16(fp)
8112f7c0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
8112f7c4:	e0bffd17 	ldw	r2,-12(fp)
8112f7c8:	10000f26 	beq	r2,zero,8112f808 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
8112f7cc:	e0bffd17 	ldw	r2,-12(fp)
8112f7d0:	00c000c4 	movi	r3,3
8112f7d4:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8112f7d8:	e0bffd17 	ldw	r2,-12(fp)
8112f7dc:	e0ffff0b 	ldhu	r3,-4(fp)
8112f7e0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
8112f7e4:	e0bffd17 	ldw	r2,-12(fp)
8112f7e8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
8112f7ec:	e0bffd17 	ldw	r2,-12(fp)
8112f7f0:	00c00fc4 	movi	r3,63
8112f7f4:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8112f7f8:	e0bffd17 	ldw	r2,-12(fp)
8112f7fc:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
8112f800:	e13ffd17 	ldw	r4,-12(fp)
8112f804:	112a6d40 	call	8112a6d4 <OS_EventWaitListInit>
    }
    return (pevent);
8112f808:	e0bffd17 	ldw	r2,-12(fp)
}
8112f80c:	e037883a 	mov	sp,fp
8112f810:	dfc00117 	ldw	ra,4(sp)
8112f814:	df000017 	ldw	fp,0(sp)
8112f818:	dec00204 	addi	sp,sp,8
8112f81c:	f800283a 	ret

8112f820 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8112f820:	defff304 	addi	sp,sp,-52
8112f824:	de00012e 	bgeu	sp,et,8112f82c <OSSemDel+0xc>
8112f828:	003b68fa 	trap	3
8112f82c:	dfc00c15 	stw	ra,48(sp)
8112f830:	df000b15 	stw	fp,44(sp)
8112f834:	df000b04 	addi	fp,sp,44
8112f838:	e13ffd15 	stw	r4,-12(fp)
8112f83c:	2805883a 	mov	r2,r5
8112f840:	e1bfff15 	stw	r6,-4(fp)
8112f844:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112f848:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8112f84c:	e0bfff17 	ldw	r2,-4(fp)
8112f850:	1000021e 	bne	r2,zero,8112f85c <OSSemDel+0x3c>
        return (pevent);
8112f854:	e0bffd17 	ldw	r2,-12(fp)
8112f858:	00007e06 	br	8112fa54 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8112f85c:	e0bffd17 	ldw	r2,-12(fp)
8112f860:	1000051e 	bne	r2,zero,8112f878 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8112f864:	e0bfff17 	ldw	r2,-4(fp)
8112f868:	00c00104 	movi	r3,4
8112f86c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8112f870:	e0bffd17 	ldw	r2,-12(fp)
8112f874:	00007706 	br	8112fa54 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8112f878:	e0bffd17 	ldw	r2,-12(fp)
8112f87c:	10800003 	ldbu	r2,0(r2)
8112f880:	10803fcc 	andi	r2,r2,255
8112f884:	108000e0 	cmpeqi	r2,r2,3
8112f888:	1000051e 	bne	r2,zero,8112f8a0 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8112f88c:	e0bfff17 	ldw	r2,-4(fp)
8112f890:	00c00044 	movi	r3,1
8112f894:	10c00005 	stb	r3,0(r2)
        return (pevent);
8112f898:	e0bffd17 	ldw	r2,-12(fp)
8112f89c:	00006d06 	br	8112fa54 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8112f8a0:	d0a08503 	ldbu	r2,-32236(gp)
8112f8a4:	10803fcc 	andi	r2,r2,255
8112f8a8:	10000526 	beq	r2,zero,8112f8c0 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8112f8ac:	e0bfff17 	ldw	r2,-4(fp)
8112f8b0:	00c003c4 	movi	r3,15
8112f8b4:	10c00005 	stb	r3,0(r2)
        return (pevent);
8112f8b8:	e0bffd17 	ldw	r2,-12(fp)
8112f8bc:	00006506 	br	8112fa54 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f8c0:	0005303a 	rdctl	r2,status
8112f8c4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f8c8:	e0fffc17 	ldw	r3,-16(fp)
8112f8cc:	00bfff84 	movi	r2,-2
8112f8d0:	1884703a 	and	r2,r3,r2
8112f8d4:	1001703a 	wrctl	status,r2
  
  return context;
8112f8d8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112f8dc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8112f8e0:	e0bffd17 	ldw	r2,-12(fp)
8112f8e4:	10800283 	ldbu	r2,10(r2)
8112f8e8:	10803fcc 	andi	r2,r2,255
8112f8ec:	10000326 	beq	r2,zero,8112f8fc <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8112f8f0:	00800044 	movi	r2,1
8112f8f4:	e0bff505 	stb	r2,-44(fp)
8112f8f8:	00000106 	br	8112f900 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8112f8fc:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8112f900:	e0bffe03 	ldbu	r2,-8(fp)
8112f904:	10000326 	beq	r2,zero,8112f914 <OSSemDel+0xf4>
8112f908:	10800060 	cmpeqi	r2,r2,1
8112f90c:	1000281e 	bne	r2,zero,8112f9b0 <OSSemDel+0x190>
8112f910:	00004506 	br	8112fa28 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8112f914:	e0bff503 	ldbu	r2,-44(fp)
8112f918:	1000161e 	bne	r2,zero,8112f974 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8112f91c:	e0bffd17 	ldw	r2,-12(fp)
8112f920:	00c00fc4 	movi	r3,63
8112f924:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8112f928:	e0bffd17 	ldw	r2,-12(fp)
8112f92c:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8112f930:	e0bffd17 	ldw	r2,-12(fp)
8112f934:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8112f938:	d0e08417 	ldw	r3,-32240(gp)
8112f93c:	e0bffd17 	ldw	r2,-12(fp)
8112f940:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8112f944:	e0bffd17 	ldw	r2,-12(fp)
8112f948:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8112f94c:	e0bffd17 	ldw	r2,-12(fp)
8112f950:	d0a08415 	stw	r2,-32240(gp)
8112f954:	e0bff717 	ldw	r2,-36(fp)
8112f958:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f95c:	e0bff817 	ldw	r2,-32(fp)
8112f960:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8112f964:	e0bfff17 	ldw	r2,-4(fp)
8112f968:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8112f96c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8112f970:	00003706 	br	8112fa50 <OSSemDel+0x230>
8112f974:	e0bff717 	ldw	r2,-36(fp)
8112f978:	e0bff915 	stw	r2,-28(fp)
8112f97c:	e0bff917 	ldw	r2,-28(fp)
8112f980:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8112f984:	e0bfff17 	ldw	r2,-4(fp)
8112f988:	00c01244 	movi	r3,73
8112f98c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8112f990:	e0bffd17 	ldw	r2,-12(fp)
8112f994:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8112f998:	00002d06 	br	8112fa50 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8112f99c:	000f883a 	mov	r7,zero
8112f9a0:	01800044 	movi	r6,1
8112f9a4:	000b883a 	mov	r5,zero
8112f9a8:	e13ffd17 	ldw	r4,-12(fp)
8112f9ac:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8112f9b0:	e0bffd17 	ldw	r2,-12(fp)
8112f9b4:	10800283 	ldbu	r2,10(r2)
8112f9b8:	10803fcc 	andi	r2,r2,255
8112f9bc:	103ff71e 	bne	r2,zero,8112f99c <__reset+0xfb10f99c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8112f9c0:	e0bffd17 	ldw	r2,-12(fp)
8112f9c4:	00c00fc4 	movi	r3,63
8112f9c8:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8112f9cc:	e0bffd17 	ldw	r2,-12(fp)
8112f9d0:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8112f9d4:	e0bffd17 	ldw	r2,-12(fp)
8112f9d8:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8112f9dc:	d0e08417 	ldw	r3,-32240(gp)
8112f9e0:	e0bffd17 	ldw	r2,-12(fp)
8112f9e4:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8112f9e8:	e0bffd17 	ldw	r2,-12(fp)
8112f9ec:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8112f9f0:	e0bffd17 	ldw	r2,-12(fp)
8112f9f4:	d0a08415 	stw	r2,-32240(gp)
8112f9f8:	e0bff717 	ldw	r2,-36(fp)
8112f9fc:	e0bffa15 	stw	r2,-24(fp)
8112fa00:	e0bffa17 	ldw	r2,-24(fp)
8112fa04:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8112fa08:	e0bff503 	ldbu	r2,-44(fp)
8112fa0c:	10800058 	cmpnei	r2,r2,1
8112fa10:	1000011e 	bne	r2,zero,8112fa18 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8112fa14:	112abb80 	call	8112abb8 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8112fa18:	e0bfff17 	ldw	r2,-4(fp)
8112fa1c:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8112fa20:	e03ff615 	stw	zero,-40(fp)
             break;
8112fa24:	00000a06 	br	8112fa50 <OSSemDel+0x230>
8112fa28:	e0bff717 	ldw	r2,-36(fp)
8112fa2c:	e0bffb15 	stw	r2,-20(fp)
8112fa30:	e0bffb17 	ldw	r2,-20(fp)
8112fa34:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8112fa38:	e0bfff17 	ldw	r2,-4(fp)
8112fa3c:	00c001c4 	movi	r3,7
8112fa40:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8112fa44:	e0bffd17 	ldw	r2,-12(fp)
8112fa48:	e0bff615 	stw	r2,-40(fp)
             break;
8112fa4c:	0001883a 	nop
    }
    return (pevent_return);
8112fa50:	e0bff617 	ldw	r2,-40(fp)
}
8112fa54:	e037883a 	mov	sp,fp
8112fa58:	dfc00117 	ldw	ra,4(sp)
8112fa5c:	df000017 	ldw	fp,0(sp)
8112fa60:	dec00204 	addi	sp,sp,8
8112fa64:	f800283a 	ret

8112fa68 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8112fa68:	defff504 	addi	sp,sp,-44
8112fa6c:	de00012e 	bgeu	sp,et,8112fa74 <OSSemPend+0xc>
8112fa70:	003b68fa 	trap	3
8112fa74:	dfc00a15 	stw	ra,40(sp)
8112fa78:	df000915 	stw	fp,36(sp)
8112fa7c:	df000904 	addi	fp,sp,36
8112fa80:	e13ffd15 	stw	r4,-12(fp)
8112fa84:	2805883a 	mov	r2,r5
8112fa88:	e1bfff15 	stw	r6,-4(fp)
8112fa8c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8112fa90:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8112fa94:	e0bfff17 	ldw	r2,-4(fp)
8112fa98:	10007226 	beq	r2,zero,8112fc64 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8112fa9c:	e0bffd17 	ldw	r2,-12(fp)
8112faa0:	1000041e 	bne	r2,zero,8112fab4 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8112faa4:	e0bfff17 	ldw	r2,-4(fp)
8112faa8:	00c00104 	movi	r3,4
8112faac:	10c00005 	stb	r3,0(r2)
        return;
8112fab0:	00006d06 	br	8112fc68 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8112fab4:	e0bffd17 	ldw	r2,-12(fp)
8112fab8:	10800003 	ldbu	r2,0(r2)
8112fabc:	10803fcc 	andi	r2,r2,255
8112fac0:	108000e0 	cmpeqi	r2,r2,3
8112fac4:	1000041e 	bne	r2,zero,8112fad8 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8112fac8:	e0bfff17 	ldw	r2,-4(fp)
8112facc:	00c00044 	movi	r3,1
8112fad0:	10c00005 	stb	r3,0(r2)
        return;
8112fad4:	00006406 	br	8112fc68 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8112fad8:	d0a08503 	ldbu	r2,-32236(gp)
8112fadc:	10803fcc 	andi	r2,r2,255
8112fae0:	10000426 	beq	r2,zero,8112faf4 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8112fae4:	e0bfff17 	ldw	r2,-4(fp)
8112fae8:	00c00084 	movi	r3,2
8112faec:	10c00005 	stb	r3,0(r2)
        return;
8112faf0:	00005d06 	br	8112fc68 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8112faf4:	d0a07303 	ldbu	r2,-32308(gp)
8112faf8:	10803fcc 	andi	r2,r2,255
8112fafc:	10000426 	beq	r2,zero,8112fb10 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8112fb00:	e0bfff17 	ldw	r2,-4(fp)
8112fb04:	00c00344 	movi	r3,13
8112fb08:	10c00005 	stb	r3,0(r2)
        return;
8112fb0c:	00005606 	br	8112fc68 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112fb10:	0005303a 	rdctl	r2,status
8112fb14:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112fb18:	e0fffc17 	ldw	r3,-16(fp)
8112fb1c:	00bfff84 	movi	r2,-2
8112fb20:	1884703a 	and	r2,r3,r2
8112fb24:	1001703a 	wrctl	status,r2
  
  return context;
8112fb28:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112fb2c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8112fb30:	e0bffd17 	ldw	r2,-12(fp)
8112fb34:	1080020b 	ldhu	r2,8(r2)
8112fb38:	10bfffcc 	andi	r2,r2,65535
8112fb3c:	10000d26 	beq	r2,zero,8112fb74 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8112fb40:	e0bffd17 	ldw	r2,-12(fp)
8112fb44:	1080020b 	ldhu	r2,8(r2)
8112fb48:	10bfffc4 	addi	r2,r2,-1
8112fb4c:	1007883a 	mov	r3,r2
8112fb50:	e0bffd17 	ldw	r2,-12(fp)
8112fb54:	10c0020d 	sth	r3,8(r2)
8112fb58:	e0bff717 	ldw	r2,-36(fp)
8112fb5c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112fb60:	e0bff817 	ldw	r2,-32(fp)
8112fb64:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8112fb68:	e0bfff17 	ldw	r2,-4(fp)
8112fb6c:	10000005 	stb	zero,0(r2)
        return;
8112fb70:	00003d06 	br	8112fc68 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8112fb74:	d0a08617 	ldw	r2,-32232(gp)
8112fb78:	d0e08617 	ldw	r3,-32232(gp)
8112fb7c:	18c00c03 	ldbu	r3,48(r3)
8112fb80:	18c00054 	ori	r3,r3,1
8112fb84:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8112fb88:	d0a08617 	ldw	r2,-32232(gp)
8112fb8c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8112fb90:	d0a08617 	ldw	r2,-32232(gp)
8112fb94:	e0fffe0b 	ldhu	r3,-8(fp)
8112fb98:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8112fb9c:	e13ffd17 	ldw	r4,-12(fp)
8112fba0:	112a29c0 	call	8112a29c <OS_EventTaskWait>
8112fba4:	e0bff717 	ldw	r2,-36(fp)
8112fba8:	e0bffb15 	stw	r2,-20(fp)
8112fbac:	e0bffb17 	ldw	r2,-20(fp)
8112fbb0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8112fbb4:	112abb80 	call	8112abb8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112fbb8:	0005303a 	rdctl	r2,status
8112fbbc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112fbc0:	e0fff917 	ldw	r3,-28(fp)
8112fbc4:	00bfff84 	movi	r2,-2
8112fbc8:	1884703a 	and	r2,r3,r2
8112fbcc:	1001703a 	wrctl	status,r2
  
  return context;
8112fbd0:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8112fbd4:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8112fbd8:	d0a08617 	ldw	r2,-32232(gp)
8112fbdc:	10800c43 	ldbu	r2,49(r2)
8112fbe0:	10803fcc 	andi	r2,r2,255
8112fbe4:	10000326 	beq	r2,zero,8112fbf4 <OSSemPend+0x18c>
8112fbe8:	108000a0 	cmpeqi	r2,r2,2
8112fbec:	1000041e 	bne	r2,zero,8112fc00 <OSSemPend+0x198>
8112fbf0:	00000706 	br	8112fc10 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8112fbf4:	e0bfff17 	ldw	r2,-4(fp)
8112fbf8:	10000005 	stb	zero,0(r2)
             break;
8112fbfc:	00000c06 	br	8112fc30 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8112fc00:	e0bfff17 	ldw	r2,-4(fp)
8112fc04:	00c00384 	movi	r3,14
8112fc08:	10c00005 	stb	r3,0(r2)
             break;
8112fc0c:	00000806 	br	8112fc30 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8112fc10:	d0a08617 	ldw	r2,-32232(gp)
8112fc14:	e17ffd17 	ldw	r5,-12(fp)
8112fc18:	1009883a 	mov	r4,r2
8112fc1c:	112a50c0 	call	8112a50c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8112fc20:	e0bfff17 	ldw	r2,-4(fp)
8112fc24:	00c00284 	movi	r3,10
8112fc28:	10c00005 	stb	r3,0(r2)
             break;
8112fc2c:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8112fc30:	d0a08617 	ldw	r2,-32232(gp)
8112fc34:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8112fc38:	d0a08617 	ldw	r2,-32232(gp)
8112fc3c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8112fc40:	d0a08617 	ldw	r2,-32232(gp)
8112fc44:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8112fc48:	d0a08617 	ldw	r2,-32232(gp)
8112fc4c:	10000815 	stw	zero,32(r2)
8112fc50:	e0bff717 	ldw	r2,-36(fp)
8112fc54:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112fc58:	e0bffa17 	ldw	r2,-24(fp)
8112fc5c:	1001703a 	wrctl	status,r2
8112fc60:	00000106 	br	8112fc68 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8112fc64:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8112fc68:	e037883a 	mov	sp,fp
8112fc6c:	dfc00117 	ldw	ra,4(sp)
8112fc70:	df000017 	ldw	fp,0(sp)
8112fc74:	dec00204 	addi	sp,sp,8
8112fc78:	f800283a 	ret

8112fc7c <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8112fc7c:	defff604 	addi	sp,sp,-40
8112fc80:	de00012e 	bgeu	sp,et,8112fc88 <OSSemPendAbort+0xc>
8112fc84:	003b68fa 	trap	3
8112fc88:	dfc00915 	stw	ra,36(sp)
8112fc8c:	df000815 	stw	fp,32(sp)
8112fc90:	df000804 	addi	fp,sp,32
8112fc94:	e13ffd15 	stw	r4,-12(fp)
8112fc98:	2805883a 	mov	r2,r5
8112fc9c:	e1bfff15 	stw	r6,-4(fp)
8112fca0:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8112fca4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8112fca8:	e0bfff17 	ldw	r2,-4(fp)
8112fcac:	1000021e 	bne	r2,zero,8112fcb8 <OSSemPendAbort+0x3c>
        return (0);
8112fcb0:	0005883a 	mov	r2,zero
8112fcb4:	00004906 	br	8112fddc <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8112fcb8:	e0bffd17 	ldw	r2,-12(fp)
8112fcbc:	1000051e 	bne	r2,zero,8112fcd4 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8112fcc0:	e0bfff17 	ldw	r2,-4(fp)
8112fcc4:	00c00104 	movi	r3,4
8112fcc8:	10c00005 	stb	r3,0(r2)
        return (0);
8112fccc:	0005883a 	mov	r2,zero
8112fcd0:	00004206 	br	8112fddc <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8112fcd4:	e0bffd17 	ldw	r2,-12(fp)
8112fcd8:	10800003 	ldbu	r2,0(r2)
8112fcdc:	10803fcc 	andi	r2,r2,255
8112fce0:	108000e0 	cmpeqi	r2,r2,3
8112fce4:	1000051e 	bne	r2,zero,8112fcfc <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8112fce8:	e0bfff17 	ldw	r2,-4(fp)
8112fcec:	00c00044 	movi	r3,1
8112fcf0:	10c00005 	stb	r3,0(r2)
        return (0);
8112fcf4:	0005883a 	mov	r2,zero
8112fcf8:	00003806 	br	8112fddc <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112fcfc:	0005303a 	rdctl	r2,status
8112fd00:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112fd04:	e0fffc17 	ldw	r3,-16(fp)
8112fd08:	00bfff84 	movi	r2,-2
8112fd0c:	1884703a 	and	r2,r3,r2
8112fd10:	1001703a 	wrctl	status,r2
  
  return context;
8112fd14:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8112fd18:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8112fd1c:	e0bffd17 	ldw	r2,-12(fp)
8112fd20:	10800283 	ldbu	r2,10(r2)
8112fd24:	10803fcc 	andi	r2,r2,255
8112fd28:	10002526 	beq	r2,zero,8112fdc0 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8112fd2c:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8112fd30:	e0bffe03 	ldbu	r2,-8(fp)
8112fd34:	10800060 	cmpeqi	r2,r2,1
8112fd38:	10000e26 	beq	r2,zero,8112fd74 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8112fd3c:	00000806 	br	8112fd60 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8112fd40:	01c00084 	movi	r7,2
8112fd44:	01800044 	movi	r6,1
8112fd48:	000b883a 	mov	r5,zero
8112fd4c:	e13ffd17 	ldw	r4,-12(fp)
8112fd50:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
                     nbr_tasks++;
8112fd54:	e0bff803 	ldbu	r2,-32(fp)
8112fd58:	10800044 	addi	r2,r2,1
8112fd5c:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8112fd60:	e0bffd17 	ldw	r2,-12(fp)
8112fd64:	10800283 	ldbu	r2,10(r2)
8112fd68:	10803fcc 	andi	r2,r2,255
8112fd6c:	103ff41e 	bne	r2,zero,8112fd40 <__reset+0xfb10fd40>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8112fd70:	00000906 	br	8112fd98 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8112fd74:	01c00084 	movi	r7,2
8112fd78:	01800044 	movi	r6,1
8112fd7c:	000b883a 	mov	r5,zero
8112fd80:	e13ffd17 	ldw	r4,-12(fp)
8112fd84:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
                 nbr_tasks++;
8112fd88:	e0bff803 	ldbu	r2,-32(fp)
8112fd8c:	10800044 	addi	r2,r2,1
8112fd90:	e0bff805 	stb	r2,-32(fp)
                 break;
8112fd94:	0001883a 	nop
8112fd98:	e0bff917 	ldw	r2,-28(fp)
8112fd9c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112fda0:	e0bffa17 	ldw	r2,-24(fp)
8112fda4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8112fda8:	112abb80 	call	8112abb8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8112fdac:	e0bfff17 	ldw	r2,-4(fp)
8112fdb0:	00c00384 	movi	r3,14
8112fdb4:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8112fdb8:	e0bff803 	ldbu	r2,-32(fp)
8112fdbc:	00000706 	br	8112fddc <OSSemPendAbort+0x160>
8112fdc0:	e0bff917 	ldw	r2,-28(fp)
8112fdc4:	e0bffb15 	stw	r2,-20(fp)
8112fdc8:	e0bffb17 	ldw	r2,-20(fp)
8112fdcc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112fdd0:	e0bfff17 	ldw	r2,-4(fp)
8112fdd4:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8112fdd8:	0005883a 	mov	r2,zero
}
8112fddc:	e037883a 	mov	sp,fp
8112fde0:	dfc00117 	ldw	ra,4(sp)
8112fde4:	df000017 	ldw	fp,0(sp)
8112fde8:	dec00204 	addi	sp,sp,8
8112fdec:	f800283a 	ret

8112fdf0 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
8112fdf0:	defff804 	addi	sp,sp,-32
8112fdf4:	de00012e 	bgeu	sp,et,8112fdfc <OSSemPost+0xc>
8112fdf8:	003b68fa 	trap	3
8112fdfc:	dfc00715 	stw	ra,28(sp)
8112fe00:	df000615 	stw	fp,24(sp)
8112fe04:	df000604 	addi	fp,sp,24
8112fe08:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8112fe0c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8112fe10:	e0bfff17 	ldw	r2,-4(fp)
8112fe14:	1000021e 	bne	r2,zero,8112fe20 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8112fe18:	00800104 	movi	r2,4
8112fe1c:	00003506 	br	8112fef4 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8112fe20:	e0bfff17 	ldw	r2,-4(fp)
8112fe24:	10800003 	ldbu	r2,0(r2)
8112fe28:	10803fcc 	andi	r2,r2,255
8112fe2c:	108000e0 	cmpeqi	r2,r2,3
8112fe30:	1000021e 	bne	r2,zero,8112fe3c <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
8112fe34:	00800044 	movi	r2,1
8112fe38:	00002e06 	br	8112fef4 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112fe3c:	0005303a 	rdctl	r2,status
8112fe40:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112fe44:	e0fffe17 	ldw	r3,-8(fp)
8112fe48:	00bfff84 	movi	r2,-2
8112fe4c:	1884703a 	and	r2,r3,r2
8112fe50:	1001703a 	wrctl	status,r2
  
  return context;
8112fe54:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8112fe58:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8112fe5c:	e0bfff17 	ldw	r2,-4(fp)
8112fe60:	10800283 	ldbu	r2,10(r2)
8112fe64:	10803fcc 	andi	r2,r2,255
8112fe68:	10000c26 	beq	r2,zero,8112fe9c <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8112fe6c:	000f883a 	mov	r7,zero
8112fe70:	01800044 	movi	r6,1
8112fe74:	000b883a 	mov	r5,zero
8112fe78:	e13fff17 	ldw	r4,-4(fp)
8112fe7c:	112a0fc0 	call	8112a0fc <OS_EventTaskRdy>
8112fe80:	e0bffa17 	ldw	r2,-24(fp)
8112fe84:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112fe88:	e0bffb17 	ldw	r2,-20(fp)
8112fe8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8112fe90:	112abb80 	call	8112abb8 <OS_Sched>
        return (OS_ERR_NONE);
8112fe94:	0005883a 	mov	r2,zero
8112fe98:	00001606 	br	8112fef4 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8112fe9c:	e0bfff17 	ldw	r2,-4(fp)
8112fea0:	1080020b 	ldhu	r2,8(r2)
8112fea4:	10ffffcc 	andi	r3,r2,65535
8112fea8:	00bfffd4 	movui	r2,65535
8112feac:	18800c26 	beq	r3,r2,8112fee0 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8112feb0:	e0bfff17 	ldw	r2,-4(fp)
8112feb4:	1080020b 	ldhu	r2,8(r2)
8112feb8:	10800044 	addi	r2,r2,1
8112febc:	1007883a 	mov	r3,r2
8112fec0:	e0bfff17 	ldw	r2,-4(fp)
8112fec4:	10c0020d 	sth	r3,8(r2)
8112fec8:	e0bffa17 	ldw	r2,-24(fp)
8112fecc:	e0bffc15 	stw	r2,-16(fp)
8112fed0:	e0bffc17 	ldw	r2,-16(fp)
8112fed4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8112fed8:	0005883a 	mov	r2,zero
8112fedc:	00000506 	br	8112fef4 <OSSemPost+0x104>
8112fee0:	e0bffa17 	ldw	r2,-24(fp)
8112fee4:	e0bffd15 	stw	r2,-12(fp)
8112fee8:	e0bffd17 	ldw	r2,-12(fp)
8112feec:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8112fef0:	00800c84 	movi	r2,50
}
8112fef4:	e037883a 	mov	sp,fp
8112fef8:	dfc00117 	ldw	ra,4(sp)
8112fefc:	df000017 	ldw	fp,0(sp)
8112ff00:	dec00204 	addi	sp,sp,8
8112ff04:	f800283a 	ret

8112ff08 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8112ff08:	defff704 	addi	sp,sp,-36
8112ff0c:	de00012e 	bgeu	sp,et,8112ff14 <OSSemQuery+0xc>
8112ff10:	003b68fa 	trap	3
8112ff14:	df000815 	stw	fp,32(sp)
8112ff18:	df000804 	addi	fp,sp,32
8112ff1c:	e13ffe15 	stw	r4,-8(fp)
8112ff20:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112ff24:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8112ff28:	e0bffe17 	ldw	r2,-8(fp)
8112ff2c:	1000021e 	bne	r2,zero,8112ff38 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8112ff30:	00800104 	movi	r2,4
8112ff34:	00003606 	br	81130010 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8112ff38:	e0bfff17 	ldw	r2,-4(fp)
8112ff3c:	1000021e 	bne	r2,zero,8112ff48 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8112ff40:	00800244 	movi	r2,9
8112ff44:	00003206 	br	81130010 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8112ff48:	e0bffe17 	ldw	r2,-8(fp)
8112ff4c:	10800003 	ldbu	r2,0(r2)
8112ff50:	10803fcc 	andi	r2,r2,255
8112ff54:	108000e0 	cmpeqi	r2,r2,3
8112ff58:	1000021e 	bne	r2,zero,8112ff64 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8112ff5c:	00800044 	movi	r2,1
8112ff60:	00002b06 	br	81130010 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ff64:	0005303a 	rdctl	r2,status
8112ff68:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ff6c:	e0fffd17 	ldw	r3,-12(fp)
8112ff70:	00bfff84 	movi	r2,-2
8112ff74:	1884703a 	and	r2,r3,r2
8112ff78:	1001703a 	wrctl	status,r2
  
  return context;
8112ff7c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8112ff80:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8112ff84:	e0bffe17 	ldw	r2,-8(fp)
8112ff88:	10c00283 	ldbu	r3,10(r2)
8112ff8c:	e0bfff17 	ldw	r2,-4(fp)
8112ff90:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8112ff94:	e0bffe17 	ldw	r2,-8(fp)
8112ff98:	108002c4 	addi	r2,r2,11
8112ff9c:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8112ffa0:	e0bfff17 	ldw	r2,-4(fp)
8112ffa4:	10800084 	addi	r2,r2,2
8112ffa8:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112ffac:	e03ffa05 	stb	zero,-24(fp)
8112ffb0:	00000b06 	br	8112ffe0 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8112ffb4:	e0bff917 	ldw	r2,-28(fp)
8112ffb8:	10c00044 	addi	r3,r2,1
8112ffbc:	e0fff915 	stw	r3,-28(fp)
8112ffc0:	e0fff817 	ldw	r3,-32(fp)
8112ffc4:	19000044 	addi	r4,r3,1
8112ffc8:	e13ff815 	stw	r4,-32(fp)
8112ffcc:	18c00003 	ldbu	r3,0(r3)
8112ffd0:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112ffd4:	e0bffa03 	ldbu	r2,-24(fp)
8112ffd8:	10800044 	addi	r2,r2,1
8112ffdc:	e0bffa05 	stb	r2,-24(fp)
8112ffe0:	e0bffa03 	ldbu	r2,-24(fp)
8112ffe4:	108001b0 	cmpltui	r2,r2,6
8112ffe8:	103ff21e 	bne	r2,zero,8112ffb4 <__reset+0xfb10ffb4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8112ffec:	e0bffe17 	ldw	r2,-8(fp)
8112fff0:	10c0020b 	ldhu	r3,8(r2)
8112fff4:	e0bfff17 	ldw	r2,-4(fp)
8112fff8:	10c0000d 	sth	r3,0(r2)
8112fffc:	e0bffb17 	ldw	r2,-20(fp)
81130000:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130004:	e0bffc17 	ldw	r2,-16(fp)
81130008:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113000c:	0005883a 	mov	r2,zero
}
81130010:	e037883a 	mov	sp,fp
81130014:	df000017 	ldw	fp,0(sp)
81130018:	dec00104 	addi	sp,sp,4
8113001c:	f800283a 	ret

81130020 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
81130020:	defff904 	addi	sp,sp,-28
81130024:	de00012e 	bgeu	sp,et,8113002c <OSSemSet+0xc>
81130028:	003b68fa 	trap	3
8113002c:	df000615 	stw	fp,24(sp)
81130030:	df000604 	addi	fp,sp,24
81130034:	e13ffd15 	stw	r4,-12(fp)
81130038:	2805883a 	mov	r2,r5
8113003c:	e1bfff15 	stw	r6,-4(fp)
81130040:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81130044:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81130048:	e0bfff17 	ldw	r2,-4(fp)
8113004c:	10003126 	beq	r2,zero,81130114 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81130050:	e0bffd17 	ldw	r2,-12(fp)
81130054:	1000041e 	bne	r2,zero,81130068 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81130058:	e0bfff17 	ldw	r2,-4(fp)
8113005c:	00c00104 	movi	r3,4
81130060:	10c00005 	stb	r3,0(r2)
        return;
81130064:	00002c06 	br	81130118 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81130068:	e0bffd17 	ldw	r2,-12(fp)
8113006c:	10800003 	ldbu	r2,0(r2)
81130070:	10803fcc 	andi	r2,r2,255
81130074:	108000e0 	cmpeqi	r2,r2,3
81130078:	1000041e 	bne	r2,zero,8113008c <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113007c:	e0bfff17 	ldw	r2,-4(fp)
81130080:	00c00044 	movi	r3,1
81130084:	10c00005 	stb	r3,0(r2)
        return;
81130088:	00002306 	br	81130118 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113008c:	0005303a 	rdctl	r2,status
81130090:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130094:	e0fffc17 	ldw	r3,-16(fp)
81130098:	00bfff84 	movi	r2,-2
8113009c:	1884703a 	and	r2,r3,r2
811300a0:	1001703a 	wrctl	status,r2
  
  return context;
811300a4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811300a8:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
811300ac:	e0bfff17 	ldw	r2,-4(fp)
811300b0:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
811300b4:	e0bffd17 	ldw	r2,-12(fp)
811300b8:	1080020b 	ldhu	r2,8(r2)
811300bc:	10bfffcc 	andi	r2,r2,65535
811300c0:	10000426 	beq	r2,zero,811300d4 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
811300c4:	e0bffd17 	ldw	r2,-12(fp)
811300c8:	e0fffe0b 	ldhu	r3,-8(fp)
811300cc:	10c0020d 	sth	r3,8(r2)
811300d0:	00000b06 	br	81130100 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
811300d4:	e0bffd17 	ldw	r2,-12(fp)
811300d8:	10800283 	ldbu	r2,10(r2)
811300dc:	10803fcc 	andi	r2,r2,255
811300e0:	1000041e 	bne	r2,zero,811300f4 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
811300e4:	e0bffd17 	ldw	r2,-12(fp)
811300e8:	e0fffe0b 	ldhu	r3,-8(fp)
811300ec:	10c0020d 	sth	r3,8(r2)
811300f0:	00000306 	br	81130100 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
811300f4:	e0bfff17 	ldw	r2,-4(fp)
811300f8:	00c01244 	movi	r3,73
811300fc:	10c00005 	stb	r3,0(r2)
81130100:	e0bffa17 	ldw	r2,-24(fp)
81130104:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130108:	e0bffb17 	ldw	r2,-20(fp)
8113010c:	1001703a 	wrctl	status,r2
81130110:	00000106 	br	81130118 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81130114:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
81130118:	e037883a 	mov	sp,fp
8113011c:	df000017 	ldw	fp,0(sp)
81130120:	dec00104 	addi	sp,sp,4
81130124:	f800283a 	ret

81130128 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
81130128:	defff104 	addi	sp,sp,-60
8113012c:	de00012e 	bgeu	sp,et,81130134 <OSTaskChangePrio+0xc>
81130130:	003b68fa 	trap	3
81130134:	dfc00e15 	stw	ra,56(sp)
81130138:	df000d15 	stw	fp,52(sp)
8113013c:	df000d04 	addi	fp,sp,52
81130140:	2007883a 	mov	r3,r4
81130144:	2805883a 	mov	r2,r5
81130148:	e0fffe05 	stb	r3,-8(fp)
8113014c:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
81130150:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
81130154:	e0bffe03 	ldbu	r2,-8(fp)
81130158:	10800a30 	cmpltui	r2,r2,40
8113015c:	1000051e 	bne	r2,zero,81130174 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
81130160:	e0bffe03 	ldbu	r2,-8(fp)
81130164:	10803fe0 	cmpeqi	r2,r2,255
81130168:	1000021e 	bne	r2,zero,81130174 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8113016c:	00800a84 	movi	r2,42
81130170:	00012606 	br	8113060c <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
81130174:	e0bfff03 	ldbu	r2,-4(fp)
81130178:	10800a30 	cmpltui	r2,r2,40
8113017c:	1000021e 	bne	r2,zero,81130188 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
81130180:	00800a84 	movi	r2,42
81130184:	00012106 	br	8113060c <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130188:	0005303a 	rdctl	r2,status
8113018c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130190:	e0fffd17 	ldw	r3,-12(fp)
81130194:	00bfff84 	movi	r2,-2
81130198:	1884703a 	and	r2,r3,r2
8113019c:	1001703a 	wrctl	status,r2
  
  return context;
811301a0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811301a4:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
811301a8:	e0ffff03 	ldbu	r3,-4(fp)
811301ac:	00a04574 	movhi	r2,33045
811301b0:	10948904 	addi	r2,r2,21028
811301b4:	18c7883a 	add	r3,r3,r3
811301b8:	18c7883a 	add	r3,r3,r3
811301bc:	10c5883a 	add	r2,r2,r3
811301c0:	10800017 	ldw	r2,0(r2)
811301c4:	10000626 	beq	r2,zero,811301e0 <OSTaskChangePrio+0xb8>
811301c8:	e0bff517 	ldw	r2,-44(fp)
811301cc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811301d0:	e0bff617 	ldw	r2,-40(fp)
811301d4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
811301d8:	00800a04 	movi	r2,40
811301dc:	00010b06 	br	8113060c <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
811301e0:	e0bffe03 	ldbu	r2,-8(fp)
811301e4:	10803fd8 	cmpnei	r2,r2,255
811301e8:	1000031e 	bne	r2,zero,811301f8 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
811301ec:	d0a08617 	ldw	r2,-32232(gp)
811301f0:	10800c83 	ldbu	r2,50(r2)
811301f4:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
811301f8:	e0fffe03 	ldbu	r3,-8(fp)
811301fc:	00a04574 	movhi	r2,33045
81130200:	10948904 	addi	r2,r2,21028
81130204:	18c7883a 	add	r3,r3,r3
81130208:	18c7883a 	add	r3,r3,r3
8113020c:	10c5883a 	add	r2,r2,r3
81130210:	10800017 	ldw	r2,0(r2)
81130214:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
81130218:	e0bff817 	ldw	r2,-32(fp)
8113021c:	1000061e 	bne	r2,zero,81130238 <OSTaskChangePrio+0x110>
81130220:	e0bff517 	ldw	r2,-44(fp)
81130224:	e0bff715 	stw	r2,-36(fp)
81130228:	e0bff717 	ldw	r2,-36(fp)
8113022c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
81130230:	00800a44 	movi	r2,41
81130234:	0000f506 	br	8113060c <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
81130238:	e0bff817 	ldw	r2,-32(fp)
8113023c:	10800058 	cmpnei	r2,r2,1
81130240:	1000061e 	bne	r2,zero,8113025c <OSTaskChangePrio+0x134>
81130244:	e0bff517 	ldw	r2,-44(fp)
81130248:	e0bff915 	stw	r2,-28(fp)
8113024c:	e0bff917 	ldw	r2,-28(fp)
81130250:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
81130254:	008010c4 	movi	r2,67
81130258:	0000ec06 	br	8113060c <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8113025c:	e0bfff03 	ldbu	r2,-4(fp)
81130260:	1004d0fa 	srli	r2,r2,3
81130264:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
81130268:	e0bfff03 	ldbu	r2,-4(fp)
8113026c:	108001cc 	andi	r2,r2,7
81130270:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
81130274:	e0bffb03 	ldbu	r2,-20(fp)
81130278:	00c00044 	movi	r3,1
8113027c:	1884983a 	sll	r2,r3,r2
81130280:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
81130284:	e0bffb43 	ldbu	r2,-19(fp)
81130288:	00c00044 	movi	r3,1
8113028c:	1884983a 	sll	r2,r3,r2
81130290:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
81130294:	e0fffe03 	ldbu	r3,-8(fp)
81130298:	00a04574 	movhi	r2,33045
8113029c:	10948904 	addi	r2,r2,21028
811302a0:	18c7883a 	add	r3,r3,r3
811302a4:	18c7883a 	add	r3,r3,r3
811302a8:	10c5883a 	add	r2,r2,r3
811302ac:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
811302b0:	e0ffff03 	ldbu	r3,-4(fp)
811302b4:	00a04574 	movhi	r2,33045
811302b8:	10948904 	addi	r2,r2,21028
811302bc:	18c7883a 	add	r3,r3,r3
811302c0:	18c7883a 	add	r3,r3,r3
811302c4:	10c5883a 	add	r2,r2,r3
811302c8:	e0fff817 	ldw	r3,-32(fp)
811302cc:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
811302d0:	e0bff817 	ldw	r2,-32(fp)
811302d4:	10800d03 	ldbu	r2,52(r2)
811302d8:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
811302dc:	e0bff817 	ldw	r2,-32(fp)
811302e0:	10800d83 	ldbu	r2,54(r2)
811302e4:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
811302e8:	e0bff817 	ldw	r2,-32(fp)
811302ec:	10800d43 	ldbu	r2,53(r2)
811302f0:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
811302f4:	e0fffc03 	ldbu	r3,-16(fp)
811302f8:	d0a08244 	addi	r2,gp,-32247
811302fc:	1885883a 	add	r2,r3,r2
81130300:	10c00003 	ldbu	r3,0(r2)
81130304:	e0bffc83 	ldbu	r2,-14(fp)
81130308:	1884703a 	and	r2,r3,r2
8113030c:	10803fcc 	andi	r2,r2,255
81130310:	10002826 	beq	r2,zero,811303b4 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
81130314:	e0fffc03 	ldbu	r3,-16(fp)
81130318:	e13ffc03 	ldbu	r4,-16(fp)
8113031c:	d0a08244 	addi	r2,gp,-32247
81130320:	2085883a 	add	r2,r4,r2
81130324:	10800003 	ldbu	r2,0(r2)
81130328:	1009883a 	mov	r4,r2
8113032c:	e0bffc83 	ldbu	r2,-14(fp)
81130330:	0084303a 	nor	r2,zero,r2
81130334:	2084703a 	and	r2,r4,r2
81130338:	1009883a 	mov	r4,r2
8113033c:	d0a08244 	addi	r2,gp,-32247
81130340:	1885883a 	add	r2,r3,r2
81130344:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
81130348:	e0fffc03 	ldbu	r3,-16(fp)
8113034c:	d0a08244 	addi	r2,gp,-32247
81130350:	1885883a 	add	r2,r3,r2
81130354:	10800003 	ldbu	r2,0(r2)
81130358:	10803fcc 	andi	r2,r2,255
8113035c:	1000061e 	bne	r2,zero,81130378 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
81130360:	e0bffc43 	ldbu	r2,-15(fp)
81130364:	0084303a 	nor	r2,zero,r2
81130368:	1007883a 	mov	r3,r2
8113036c:	d0a08203 	ldbu	r2,-32248(gp)
81130370:	1884703a 	and	r2,r3,r2
81130374:	d0a08205 	stb	r2,-32248(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
81130378:	d0e08203 	ldbu	r3,-32248(gp)
8113037c:	e0bffb83 	ldbu	r2,-18(fp)
81130380:	1884b03a 	or	r2,r3,r2
81130384:	d0a08205 	stb	r2,-32248(gp)
         OSRdyTbl[y_new] |= bitx_new;
81130388:	e0fffb03 	ldbu	r3,-20(fp)
8113038c:	e13ffb03 	ldbu	r4,-20(fp)
81130390:	d0a08244 	addi	r2,gp,-32247
81130394:	2085883a 	add	r2,r4,r2
81130398:	11000003 	ldbu	r4,0(r2)
8113039c:	e0bffbc3 	ldbu	r2,-17(fp)
811303a0:	2084b03a 	or	r2,r4,r2
811303a4:	1009883a 	mov	r4,r2
811303a8:	d0a08244 	addi	r2,gp,-32247
811303ac:	1885883a 	add	r2,r3,r2
811303b0:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
811303b4:	e0bff817 	ldw	r2,-32(fp)
811303b8:	10800717 	ldw	r2,28(r2)
811303bc:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
811303c0:	e0bff317 	ldw	r2,-52(fp)
811303c4:	10003326 	beq	r2,zero,81130494 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
811303c8:	e0bffc03 	ldbu	r2,-16(fp)
811303cc:	e0fffc03 	ldbu	r3,-16(fp)
811303d0:	e13ff317 	ldw	r4,-52(fp)
811303d4:	20c7883a 	add	r3,r4,r3
811303d8:	18c002c4 	addi	r3,r3,11
811303dc:	18c00003 	ldbu	r3,0(r3)
811303e0:	1809883a 	mov	r4,r3
811303e4:	e0fffc83 	ldbu	r3,-14(fp)
811303e8:	00c6303a 	nor	r3,zero,r3
811303ec:	20c6703a 	and	r3,r4,r3
811303f0:	1809883a 	mov	r4,r3
811303f4:	e0fff317 	ldw	r3,-52(fp)
811303f8:	1885883a 	add	r2,r3,r2
811303fc:	108002c4 	addi	r2,r2,11
81130400:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
81130404:	e0bffc03 	ldbu	r2,-16(fp)
81130408:	e0fff317 	ldw	r3,-52(fp)
8113040c:	1885883a 	add	r2,r3,r2
81130410:	108002c4 	addi	r2,r2,11
81130414:	10800003 	ldbu	r2,0(r2)
81130418:	10803fcc 	andi	r2,r2,255
8113041c:	1000091e 	bne	r2,zero,81130444 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
81130420:	e0bff317 	ldw	r2,-52(fp)
81130424:	10800283 	ldbu	r2,10(r2)
81130428:	1007883a 	mov	r3,r2
8113042c:	e0bffc43 	ldbu	r2,-15(fp)
81130430:	0084303a 	nor	r2,zero,r2
81130434:	1884703a 	and	r2,r3,r2
81130438:	1007883a 	mov	r3,r2
8113043c:	e0bff317 	ldw	r2,-52(fp)
81130440:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
81130444:	e0bff317 	ldw	r2,-52(fp)
81130448:	10c00283 	ldbu	r3,10(r2)
8113044c:	e0bffb83 	ldbu	r2,-18(fp)
81130450:	1884b03a 	or	r2,r3,r2
81130454:	1007883a 	mov	r3,r2
81130458:	e0bff317 	ldw	r2,-52(fp)
8113045c:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
81130460:	e0bffb03 	ldbu	r2,-20(fp)
81130464:	e0fffb03 	ldbu	r3,-20(fp)
81130468:	e13ff317 	ldw	r4,-52(fp)
8113046c:	20c7883a 	add	r3,r4,r3
81130470:	18c002c4 	addi	r3,r3,11
81130474:	19000003 	ldbu	r4,0(r3)
81130478:	e0fffbc3 	ldbu	r3,-17(fp)
8113047c:	20c6b03a 	or	r3,r4,r3
81130480:	1809883a 	mov	r4,r3
81130484:	e0fff317 	ldw	r3,-52(fp)
81130488:	1885883a 	add	r2,r3,r2
8113048c:	108002c4 	addi	r2,r2,11
81130490:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
81130494:	e0bff817 	ldw	r2,-32(fp)
81130498:	10800817 	ldw	r2,32(r2)
8113049c:	10004226 	beq	r2,zero,811305a8 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
811304a0:	e0bff817 	ldw	r2,-32(fp)
811304a4:	10800817 	ldw	r2,32(r2)
811304a8:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
811304ac:	e0bff417 	ldw	r2,-48(fp)
811304b0:	10800017 	ldw	r2,0(r2)
811304b4:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
811304b8:	00003906 	br	811305a0 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
811304bc:	e0bffc03 	ldbu	r2,-16(fp)
811304c0:	e0fffc03 	ldbu	r3,-16(fp)
811304c4:	e13ff317 	ldw	r4,-52(fp)
811304c8:	20c7883a 	add	r3,r4,r3
811304cc:	18c002c4 	addi	r3,r3,11
811304d0:	18c00003 	ldbu	r3,0(r3)
811304d4:	1809883a 	mov	r4,r3
811304d8:	e0fffc83 	ldbu	r3,-14(fp)
811304dc:	00c6303a 	nor	r3,zero,r3
811304e0:	20c6703a 	and	r3,r4,r3
811304e4:	1809883a 	mov	r4,r3
811304e8:	e0fff317 	ldw	r3,-52(fp)
811304ec:	1885883a 	add	r2,r3,r2
811304f0:	108002c4 	addi	r2,r2,11
811304f4:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
811304f8:	e0bffc03 	ldbu	r2,-16(fp)
811304fc:	e0fff317 	ldw	r3,-52(fp)
81130500:	1885883a 	add	r2,r3,r2
81130504:	108002c4 	addi	r2,r2,11
81130508:	10800003 	ldbu	r2,0(r2)
8113050c:	10803fcc 	andi	r2,r2,255
81130510:	1000091e 	bne	r2,zero,81130538 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
81130514:	e0bff317 	ldw	r2,-52(fp)
81130518:	10800283 	ldbu	r2,10(r2)
8113051c:	1007883a 	mov	r3,r2
81130520:	e0bffc43 	ldbu	r2,-15(fp)
81130524:	0084303a 	nor	r2,zero,r2
81130528:	1884703a 	and	r2,r3,r2
8113052c:	1007883a 	mov	r3,r2
81130530:	e0bff317 	ldw	r2,-52(fp)
81130534:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
81130538:	e0bff317 	ldw	r2,-52(fp)
8113053c:	10c00283 	ldbu	r3,10(r2)
81130540:	e0bffb83 	ldbu	r2,-18(fp)
81130544:	1884b03a 	or	r2,r3,r2
81130548:	1007883a 	mov	r3,r2
8113054c:	e0bff317 	ldw	r2,-52(fp)
81130550:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
81130554:	e0bffb03 	ldbu	r2,-20(fp)
81130558:	e0fffb03 	ldbu	r3,-20(fp)
8113055c:	e13ff317 	ldw	r4,-52(fp)
81130560:	20c7883a 	add	r3,r4,r3
81130564:	18c002c4 	addi	r3,r3,11
81130568:	19000003 	ldbu	r4,0(r3)
8113056c:	e0fffbc3 	ldbu	r3,-17(fp)
81130570:	20c6b03a 	or	r3,r4,r3
81130574:	1809883a 	mov	r4,r3
81130578:	e0fff317 	ldw	r3,-52(fp)
8113057c:	1885883a 	add	r2,r3,r2
81130580:	108002c4 	addi	r2,r2,11
81130584:	11000005 	stb	r4,0(r2)
            pevents++;
81130588:	e0bff417 	ldw	r2,-48(fp)
8113058c:	10800104 	addi	r2,r2,4
81130590:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
81130594:	e0bff417 	ldw	r2,-48(fp)
81130598:	10800017 	ldw	r2,0(r2)
8113059c:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
811305a0:	e0bff317 	ldw	r2,-52(fp)
811305a4:	103fc51e 	bne	r2,zero,811304bc <__reset+0xfb1104bc>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
811305a8:	e0bff817 	ldw	r2,-32(fp)
811305ac:	e0ffff03 	ldbu	r3,-4(fp)
811305b0:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
811305b4:	e0bff817 	ldw	r2,-32(fp)
811305b8:	e0fffb03 	ldbu	r3,-20(fp)
811305bc:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
811305c0:	e0bff817 	ldw	r2,-32(fp)
811305c4:	e0fffb43 	ldbu	r3,-19(fp)
811305c8:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
811305cc:	e0bff817 	ldw	r2,-32(fp)
811305d0:	e0fffb83 	ldbu	r3,-18(fp)
811305d4:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
811305d8:	e0bff817 	ldw	r2,-32(fp)
811305dc:	e0fffbc3 	ldbu	r3,-17(fp)
811305e0:	10c00d45 	stb	r3,53(r2)
811305e4:	e0bff517 	ldw	r2,-44(fp)
811305e8:	e0bffa15 	stw	r2,-24(fp)
811305ec:	e0bffa17 	ldw	r2,-24(fp)
811305f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
811305f4:	d0a07503 	ldbu	r2,-32300(gp)
811305f8:	10803fcc 	andi	r2,r2,255
811305fc:	10800058 	cmpnei	r2,r2,1
81130600:	1000011e 	bne	r2,zero,81130608 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
81130604:	112abb80 	call	8112abb8 <OS_Sched>
    }
    return (OS_ERR_NONE);
81130608:	0005883a 	mov	r2,zero
}
8113060c:	e037883a 	mov	sp,fp
81130610:	dfc00117 	ldw	ra,4(sp)
81130614:	df000017 	ldw	fp,0(sp)
81130618:	dec00204 	addi	sp,sp,8
8113061c:	f800283a 	ret

81130620 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
81130620:	deffee04 	addi	sp,sp,-72
81130624:	de00012e 	bgeu	sp,et,8113062c <OSTaskCreate+0xc>
81130628:	003b68fa 	trap	3
8113062c:	dfc01115 	stw	ra,68(sp)
81130630:	df001015 	stw	fp,64(sp)
81130634:	df001004 	addi	fp,sp,64
81130638:	e13ffc15 	stw	r4,-16(fp)
8113063c:	e17ffd15 	stw	r5,-12(fp)
81130640:	e1bffe15 	stw	r6,-8(fp)
81130644:	3805883a 	mov	r2,r7
81130648:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113064c:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81130650:	e0bfff03 	ldbu	r2,-4(fp)
81130654:	10800a70 	cmpltui	r2,r2,41
81130658:	1000021e 	bne	r2,zero,81130664 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8113065c:	00800a84 	movi	r2,42
81130660:	00005706 	br	811307c0 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130664:	0005303a 	rdctl	r2,status
81130668:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113066c:	e0fffb17 	ldw	r3,-20(fp)
81130670:	00bfff84 	movi	r2,-2
81130674:	1884703a 	and	r2,r3,r2
81130678:	1001703a 	wrctl	status,r2
  
  return context;
8113067c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81130680:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81130684:	d0a08503 	ldbu	r2,-32236(gp)
81130688:	10803fcc 	andi	r2,r2,255
8113068c:	10000626 	beq	r2,zero,811306a8 <OSTaskCreate+0x88>
81130690:	e0bff317 	ldw	r2,-52(fp)
81130694:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130698:	e0bff417 	ldw	r2,-48(fp)
8113069c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
811306a0:	00800f04 	movi	r2,60
811306a4:	00004606 	br	811307c0 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
811306a8:	e0ffff03 	ldbu	r3,-4(fp)
811306ac:	00a04574 	movhi	r2,33045
811306b0:	10948904 	addi	r2,r2,21028
811306b4:	18c7883a 	add	r3,r3,r3
811306b8:	18c7883a 	add	r3,r3,r3
811306bc:	10c5883a 	add	r2,r2,r3
811306c0:	10800017 	ldw	r2,0(r2)
811306c4:	1000391e 	bne	r2,zero,811307ac <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
811306c8:	e0ffff03 	ldbu	r3,-4(fp)
811306cc:	00a04574 	movhi	r2,33045
811306d0:	10948904 	addi	r2,r2,21028
811306d4:	18c7883a 	add	r3,r3,r3
811306d8:	18c7883a 	add	r3,r3,r3
811306dc:	10c5883a 	add	r2,r2,r3
811306e0:	00c00044 	movi	r3,1
811306e4:	10c00015 	stw	r3,0(r2)
811306e8:	e0bff317 	ldw	r2,-52(fp)
811306ec:	e0bff515 	stw	r2,-44(fp)
811306f0:	e0bff517 	ldw	r2,-44(fp)
811306f4:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
811306f8:	000f883a 	mov	r7,zero
811306fc:	e1bffe17 	ldw	r6,-8(fp)
81130700:	e17ffd17 	ldw	r5,-12(fp)
81130704:	e13ffc17 	ldw	r4,-16(fp)
81130708:	113bd040 	call	8113bd04 <OSTaskStkInit>
8113070c:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
81130710:	e0bfff03 	ldbu	r2,-4(fp)
81130714:	d8000215 	stw	zero,8(sp)
81130718:	d8000115 	stw	zero,4(sp)
8113071c:	d8000015 	stw	zero,0(sp)
81130720:	000f883a 	mov	r7,zero
81130724:	000d883a 	mov	r6,zero
81130728:	e17ff717 	ldw	r5,-36(fp)
8113072c:	1009883a 	mov	r4,r2
81130730:	112b0000 	call	8112b000 <OS_TCBInit>
81130734:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
81130738:	e0bff803 	ldbu	r2,-32(fp)
8113073c:	1000061e 	bne	r2,zero,81130758 <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
81130740:	d0a07503 	ldbu	r2,-32300(gp)
81130744:	10803fcc 	andi	r2,r2,255
81130748:	10800058 	cmpnei	r2,r2,1
8113074c:	1000151e 	bne	r2,zero,811307a4 <OSTaskCreate+0x184>
                OS_Sched();
81130750:	112abb80 	call	8112abb8 <OS_Sched>
81130754:	00001306 	br	811307a4 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130758:	0005303a 	rdctl	r2,status
8113075c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130760:	e0fffa17 	ldw	r3,-24(fp)
81130764:	00bfff84 	movi	r2,-2
81130768:	1884703a 	and	r2,r3,r2
8113076c:	1001703a 	wrctl	status,r2
  
  return context;
81130770:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81130774:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
81130778:	e0ffff03 	ldbu	r3,-4(fp)
8113077c:	00a04574 	movhi	r2,33045
81130780:	10948904 	addi	r2,r2,21028
81130784:	18c7883a 	add	r3,r3,r3
81130788:	18c7883a 	add	r3,r3,r3
8113078c:	10c5883a 	add	r2,r2,r3
81130790:	10000015 	stw	zero,0(r2)
81130794:	e0bff317 	ldw	r2,-52(fp)
81130798:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113079c:	e0bff617 	ldw	r2,-40(fp)
811307a0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
811307a4:	e0bff803 	ldbu	r2,-32(fp)
811307a8:	00000506 	br	811307c0 <OSTaskCreate+0x1a0>
811307ac:	e0bff317 	ldw	r2,-52(fp)
811307b0:	e0bff915 	stw	r2,-28(fp)
811307b4:	e0bff917 	ldw	r2,-28(fp)
811307b8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
811307bc:	00800a04 	movi	r2,40
}
811307c0:	e037883a 	mov	sp,fp
811307c4:	dfc00117 	ldw	ra,4(sp)
811307c8:	df000017 	ldw	fp,0(sp)
811307cc:	dec00204 	addi	sp,sp,8
811307d0:	f800283a 	ret

811307d4 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
811307d4:	deffec04 	addi	sp,sp,-80
811307d8:	de00012e 	bgeu	sp,et,811307e0 <OSTaskCreateExt+0xc>
811307dc:	003b68fa 	trap	3
811307e0:	dfc01315 	stw	ra,76(sp)
811307e4:	df001215 	stw	fp,72(sp)
811307e8:	df001204 	addi	fp,sp,72
811307ec:	e13ffa15 	stw	r4,-24(fp)
811307f0:	e17ffb15 	stw	r5,-20(fp)
811307f4:	e1bffc15 	stw	r6,-16(fp)
811307f8:	3809883a 	mov	r4,r7
811307fc:	e0c00217 	ldw	r3,8(fp)
81130800:	e0800617 	ldw	r2,24(fp)
81130804:	e13ffd05 	stb	r4,-12(fp)
81130808:	e0fffe0d 	sth	r3,-8(fp)
8113080c:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
81130810:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81130814:	e0bffd03 	ldbu	r2,-12(fp)
81130818:	10800a70 	cmpltui	r2,r2,41
8113081c:	1000021e 	bne	r2,zero,81130828 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
81130820:	00800a84 	movi	r2,42
81130824:	00006106 	br	811309ac <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130828:	0005303a 	rdctl	r2,status
8113082c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130830:	e0fff917 	ldw	r3,-28(fp)
81130834:	00bfff84 	movi	r2,-2
81130838:	1884703a 	and	r2,r3,r2
8113083c:	1001703a 	wrctl	status,r2
  
  return context;
81130840:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81130844:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81130848:	d0a08503 	ldbu	r2,-32236(gp)
8113084c:	10803fcc 	andi	r2,r2,255
81130850:	10000626 	beq	r2,zero,8113086c <OSTaskCreateExt+0x98>
81130854:	e0bff117 	ldw	r2,-60(fp)
81130858:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113085c:	e0bff217 	ldw	r2,-56(fp)
81130860:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81130864:	00800f04 	movi	r2,60
81130868:	00005006 	br	811309ac <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113086c:	e0fffd03 	ldbu	r3,-12(fp)
81130870:	00a04574 	movhi	r2,33045
81130874:	10948904 	addi	r2,r2,21028
81130878:	18c7883a 	add	r3,r3,r3
8113087c:	18c7883a 	add	r3,r3,r3
81130880:	10c5883a 	add	r2,r2,r3
81130884:	10800017 	ldw	r2,0(r2)
81130888:	1000431e 	bne	r2,zero,81130998 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113088c:	e0fffd03 	ldbu	r3,-12(fp)
81130890:	00a04574 	movhi	r2,33045
81130894:	10948904 	addi	r2,r2,21028
81130898:	18c7883a 	add	r3,r3,r3
8113089c:	18c7883a 	add	r3,r3,r3
811308a0:	10c5883a 	add	r2,r2,r3
811308a4:	00c00044 	movi	r3,1
811308a8:	10c00015 	stw	r3,0(r2)
811308ac:	e0bff117 	ldw	r2,-60(fp)
811308b0:	e0bff315 	stw	r2,-52(fp)
811308b4:	e0bff317 	ldw	r2,-52(fp)
811308b8:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
811308bc:	e0bfff0b 	ldhu	r2,-4(fp)
811308c0:	100d883a 	mov	r6,r2
811308c4:	e1400417 	ldw	r5,16(fp)
811308c8:	e1000317 	ldw	r4,12(fp)
811308cc:	113187c0 	call	8113187c <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
811308d0:	e0bfff0b 	ldhu	r2,-4(fp)
811308d4:	100f883a 	mov	r7,r2
811308d8:	e1bffc17 	ldw	r6,-16(fp)
811308dc:	e17ffb17 	ldw	r5,-20(fp)
811308e0:	e13ffa17 	ldw	r4,-24(fp)
811308e4:	113bd040 	call	8113bd04 <OSTaskStkInit>
811308e8:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
811308ec:	e0fffd03 	ldbu	r3,-12(fp)
811308f0:	e13ffe0b 	ldhu	r4,-8(fp)
811308f4:	e0bfff0b 	ldhu	r2,-4(fp)
811308f8:	d8800215 	stw	r2,8(sp)
811308fc:	e0800517 	ldw	r2,20(fp)
81130900:	d8800115 	stw	r2,4(sp)
81130904:	e0800417 	ldw	r2,16(fp)
81130908:	d8800015 	stw	r2,0(sp)
8113090c:	200f883a 	mov	r7,r4
81130910:	e1800317 	ldw	r6,12(fp)
81130914:	e17ff517 	ldw	r5,-44(fp)
81130918:	1809883a 	mov	r4,r3
8113091c:	112b0000 	call	8112b000 <OS_TCBInit>
81130920:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
81130924:	e0bff603 	ldbu	r2,-40(fp)
81130928:	1000061e 	bne	r2,zero,81130944 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113092c:	d0a07503 	ldbu	r2,-32300(gp)
81130930:	10803fcc 	andi	r2,r2,255
81130934:	10800058 	cmpnei	r2,r2,1
81130938:	1000151e 	bne	r2,zero,81130990 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113093c:	112abb80 	call	8112abb8 <OS_Sched>
81130940:	00001306 	br	81130990 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130944:	0005303a 	rdctl	r2,status
81130948:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113094c:	e0fff817 	ldw	r3,-32(fp)
81130950:	00bfff84 	movi	r2,-2
81130954:	1884703a 	and	r2,r3,r2
81130958:	1001703a 	wrctl	status,r2
  
  return context;
8113095c:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81130960:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
81130964:	e0fffd03 	ldbu	r3,-12(fp)
81130968:	00a04574 	movhi	r2,33045
8113096c:	10948904 	addi	r2,r2,21028
81130970:	18c7883a 	add	r3,r3,r3
81130974:	18c7883a 	add	r3,r3,r3
81130978:	10c5883a 	add	r2,r2,r3
8113097c:	10000015 	stw	zero,0(r2)
81130980:	e0bff117 	ldw	r2,-60(fp)
81130984:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130988:	e0bff417 	ldw	r2,-48(fp)
8113098c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
81130990:	e0bff603 	ldbu	r2,-40(fp)
81130994:	00000506 	br	811309ac <OSTaskCreateExt+0x1d8>
81130998:	e0bff117 	ldw	r2,-60(fp)
8113099c:	e0bff715 	stw	r2,-36(fp)
811309a0:	e0bff717 	ldw	r2,-36(fp)
811309a4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
811309a8:	00800a04 	movi	r2,40
}
811309ac:	e037883a 	mov	sp,fp
811309b0:	dfc00117 	ldw	ra,4(sp)
811309b4:	df000017 	ldw	fp,0(sp)
811309b8:	dec00204 	addi	sp,sp,8
811309bc:	f800283a 	ret

811309c0 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
811309c0:	defff404 	addi	sp,sp,-48
811309c4:	de00012e 	bgeu	sp,et,811309cc <OSTaskDel+0xc>
811309c8:	003b68fa 	trap	3
811309cc:	dfc00b15 	stw	ra,44(sp)
811309d0:	df000a15 	stw	fp,40(sp)
811309d4:	df000a04 	addi	fp,sp,40
811309d8:	2005883a 	mov	r2,r4
811309dc:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
811309e0:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
811309e4:	d0a08503 	ldbu	r2,-32236(gp)
811309e8:	10803fcc 	andi	r2,r2,255
811309ec:	10000226 	beq	r2,zero,811309f8 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
811309f0:	00801004 	movi	r2,64
811309f4:	0000c006 	br	81130cf8 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
811309f8:	e0bfff03 	ldbu	r2,-4(fp)
811309fc:	10800a18 	cmpnei	r2,r2,40
81130a00:	1000021e 	bne	r2,zero,81130a0c <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
81130a04:	00800f84 	movi	r2,62
81130a08:	0000bb06 	br	81130cf8 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
81130a0c:	e0bfff03 	ldbu	r2,-4(fp)
81130a10:	10800a30 	cmpltui	r2,r2,40
81130a14:	1000051e 	bne	r2,zero,81130a2c <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
81130a18:	e0bfff03 	ldbu	r2,-4(fp)
81130a1c:	10803fe0 	cmpeqi	r2,r2,255
81130a20:	1000021e 	bne	r2,zero,81130a2c <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
81130a24:	00800a84 	movi	r2,42
81130a28:	0000b306 	br	81130cf8 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130a2c:	0005303a 	rdctl	r2,status
81130a30:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130a34:	e0fffe17 	ldw	r3,-8(fp)
81130a38:	00bfff84 	movi	r2,-2
81130a3c:	1884703a 	and	r2,r3,r2
81130a40:	1001703a 	wrctl	status,r2
  
  return context;
81130a44:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
81130a48:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
81130a4c:	e0bfff03 	ldbu	r2,-4(fp)
81130a50:	10803fd8 	cmpnei	r2,r2,255
81130a54:	1000031e 	bne	r2,zero,81130a64 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
81130a58:	d0a08617 	ldw	r2,-32232(gp)
81130a5c:	10800c83 	ldbu	r2,50(r2)
81130a60:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81130a64:	e0ffff03 	ldbu	r3,-4(fp)
81130a68:	00a04574 	movhi	r2,33045
81130a6c:	10948904 	addi	r2,r2,21028
81130a70:	18c7883a 	add	r3,r3,r3
81130a74:	18c7883a 	add	r3,r3,r3
81130a78:	10c5883a 	add	r2,r2,r3
81130a7c:	10800017 	ldw	r2,0(r2)
81130a80:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
81130a84:	e0bff817 	ldw	r2,-32(fp)
81130a88:	1000061e 	bne	r2,zero,81130aa4 <OSTaskDel+0xe4>
81130a8c:	e0bff617 	ldw	r2,-40(fp)
81130a90:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130a94:	e0bff717 	ldw	r2,-36(fp)
81130a98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81130a9c:	008010c4 	movi	r2,67
81130aa0:	00009506 	br	81130cf8 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
81130aa4:	e0bff817 	ldw	r2,-32(fp)
81130aa8:	10800058 	cmpnei	r2,r2,1
81130aac:	1000061e 	bne	r2,zero,81130ac8 <OSTaskDel+0x108>
81130ab0:	e0bff617 	ldw	r2,-40(fp)
81130ab4:	e0bff915 	stw	r2,-28(fp)
81130ab8:	e0bff917 	ldw	r2,-28(fp)
81130abc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81130ac0:	00800f44 	movi	r2,61
81130ac4:	00008c06 	br	81130cf8 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
81130ac8:	e0bff817 	ldw	r2,-32(fp)
81130acc:	10800d03 	ldbu	r2,52(r2)
81130ad0:	10c03fcc 	andi	r3,r2,255
81130ad4:	e0bff817 	ldw	r2,-32(fp)
81130ad8:	10800d03 	ldbu	r2,52(r2)
81130adc:	11003fcc 	andi	r4,r2,255
81130ae0:	d0a08244 	addi	r2,gp,-32247
81130ae4:	2085883a 	add	r2,r4,r2
81130ae8:	10800003 	ldbu	r2,0(r2)
81130aec:	1009883a 	mov	r4,r2
81130af0:	e0bff817 	ldw	r2,-32(fp)
81130af4:	10800d43 	ldbu	r2,53(r2)
81130af8:	0084303a 	nor	r2,zero,r2
81130afc:	2084703a 	and	r2,r4,r2
81130b00:	1009883a 	mov	r4,r2
81130b04:	d0a08244 	addi	r2,gp,-32247
81130b08:	1885883a 	add	r2,r3,r2
81130b0c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
81130b10:	e0bff817 	ldw	r2,-32(fp)
81130b14:	10800d03 	ldbu	r2,52(r2)
81130b18:	10c03fcc 	andi	r3,r2,255
81130b1c:	d0a08244 	addi	r2,gp,-32247
81130b20:	1885883a 	add	r2,r3,r2
81130b24:	10800003 	ldbu	r2,0(r2)
81130b28:	10803fcc 	andi	r2,r2,255
81130b2c:	1000071e 	bne	r2,zero,81130b4c <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
81130b30:	e0bff817 	ldw	r2,-32(fp)
81130b34:	10800d83 	ldbu	r2,54(r2)
81130b38:	0084303a 	nor	r2,zero,r2
81130b3c:	1007883a 	mov	r3,r2
81130b40:	d0a08203 	ldbu	r2,-32248(gp)
81130b44:	1884703a 	and	r2,r3,r2
81130b48:	d0a08205 	stb	r2,-32248(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
81130b4c:	e0bff817 	ldw	r2,-32(fp)
81130b50:	10800717 	ldw	r2,28(r2)
81130b54:	10000526 	beq	r2,zero,81130b6c <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
81130b58:	e0bff817 	ldw	r2,-32(fp)
81130b5c:	10800717 	ldw	r2,28(r2)
81130b60:	100b883a 	mov	r5,r2
81130b64:	e13ff817 	ldw	r4,-32(fp)
81130b68:	112a50c0 	call	8112a50c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
81130b6c:	e0bff817 	ldw	r2,-32(fp)
81130b70:	10800817 	ldw	r2,32(r2)
81130b74:	10000526 	beq	r2,zero,81130b8c <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81130b78:	e0bff817 	ldw	r2,-32(fp)
81130b7c:	10800817 	ldw	r2,32(r2)
81130b80:	100b883a 	mov	r5,r2
81130b84:	e13ff817 	ldw	r4,-32(fp)
81130b88:	112a5cc0 	call	8112a5cc <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
81130b8c:	e0bff817 	ldw	r2,-32(fp)
81130b90:	10800a17 	ldw	r2,40(r2)
81130b94:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
81130b98:	e0bffb17 	ldw	r2,-20(fp)
81130b9c:	10000226 	beq	r2,zero,81130ba8 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
81130ba0:	e13ffb17 	ldw	r4,-20(fp)
81130ba4:	112cba40 	call	8112cba4 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
81130ba8:	e0bff817 	ldw	r2,-32(fp)
81130bac:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
81130bb0:	e0bff817 	ldw	r2,-32(fp)
81130bb4:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81130bb8:	e0bff817 	ldw	r2,-32(fp)
81130bbc:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
81130bc0:	d0a07303 	ldbu	r2,-32308(gp)
81130bc4:	10803fcc 	andi	r2,r2,255
81130bc8:	10803fe0 	cmpeqi	r2,r2,255
81130bcc:	1000031e 	bne	r2,zero,81130bdc <OSTaskDel+0x21c>
        OSLockNesting++;
81130bd0:	d0a07303 	ldbu	r2,-32308(gp)
81130bd4:	10800044 	addi	r2,r2,1
81130bd8:	d0a07305 	stb	r2,-32308(gp)
81130bdc:	e0bff617 	ldw	r2,-40(fp)
81130be0:	e0bffd15 	stw	r2,-12(fp)
81130be4:	e0bffd17 	ldw	r2,-12(fp)
81130be8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
81130bec:	112a0d40 	call	8112a0d4 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130bf0:	0005303a 	rdctl	r2,status
81130bf4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130bf8:	e0fffa17 	ldw	r3,-24(fp)
81130bfc:	00bfff84 	movi	r2,-2
81130c00:	1884703a 	and	r2,r3,r2
81130c04:	1001703a 	wrctl	status,r2
  
  return context;
81130c08:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
81130c0c:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
81130c10:	d0a07303 	ldbu	r2,-32308(gp)
81130c14:	10803fcc 	andi	r2,r2,255
81130c18:	10000326 	beq	r2,zero,81130c28 <OSTaskDel+0x268>
        OSLockNesting--;
81130c1c:	d0a07303 	ldbu	r2,-32308(gp)
81130c20:	10bfffc4 	addi	r2,r2,-1
81130c24:	d0a07305 	stb	r2,-32308(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
81130c28:	e13ff817 	ldw	r4,-32(fp)
81130c2c:	113be940 	call	8113be94 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
81130c30:	d0a07e43 	ldbu	r2,-32263(gp)
81130c34:	10bfffc4 	addi	r2,r2,-1
81130c38:	d0a07e45 	stb	r2,-32263(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
81130c3c:	e0ffff03 	ldbu	r3,-4(fp)
81130c40:	00a04574 	movhi	r2,33045
81130c44:	10948904 	addi	r2,r2,21028
81130c48:	18c7883a 	add	r3,r3,r3
81130c4c:	18c7883a 	add	r3,r3,r3
81130c50:	10c5883a 	add	r2,r2,r3
81130c54:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
81130c58:	e0bff817 	ldw	r2,-32(fp)
81130c5c:	10800617 	ldw	r2,24(r2)
81130c60:	1000071e 	bne	r2,zero,81130c80 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
81130c64:	e0bff817 	ldw	r2,-32(fp)
81130c68:	10800517 	ldw	r2,20(r2)
81130c6c:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
81130c70:	e0bff817 	ldw	r2,-32(fp)
81130c74:	10800517 	ldw	r2,20(r2)
81130c78:	d0a07815 	stw	r2,-32288(gp)
81130c7c:	00000a06 	br	81130ca8 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
81130c80:	e0bff817 	ldw	r2,-32(fp)
81130c84:	10800617 	ldw	r2,24(r2)
81130c88:	e0fff817 	ldw	r3,-32(fp)
81130c8c:	18c00517 	ldw	r3,20(r3)
81130c90:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
81130c94:	e0bff817 	ldw	r2,-32(fp)
81130c98:	10800517 	ldw	r2,20(r2)
81130c9c:	e0fff817 	ldw	r3,-32(fp)
81130ca0:	18c00617 	ldw	r3,24(r3)
81130ca4:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
81130ca8:	d0e07d17 	ldw	r3,-32268(gp)
81130cac:	e0bff817 	ldw	r2,-32(fp)
81130cb0:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
81130cb4:	e0bff817 	ldw	r2,-32(fp)
81130cb8:	d0a07d15 	stw	r2,-32268(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
81130cbc:	e0bff817 	ldw	r2,-32(fp)
81130cc0:	00c00fc4 	movi	r3,63
81130cc4:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81130cc8:	e0bff817 	ldw	r2,-32(fp)
81130ccc:	10001345 	stb	zero,77(r2)
81130cd0:	e0bff617 	ldw	r2,-40(fp)
81130cd4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130cd8:	e0bffc17 	ldw	r2,-16(fp)
81130cdc:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81130ce0:	d0a07503 	ldbu	r2,-32300(gp)
81130ce4:	10803fcc 	andi	r2,r2,255
81130ce8:	10800058 	cmpnei	r2,r2,1
81130cec:	1000011e 	bne	r2,zero,81130cf4 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
81130cf0:	112abb80 	call	8112abb8 <OS_Sched>
    }
    return (OS_ERR_NONE);
81130cf4:	0005883a 	mov	r2,zero
}
81130cf8:	e037883a 	mov	sp,fp
81130cfc:	dfc00117 	ldw	ra,4(sp)
81130d00:	df000017 	ldw	fp,0(sp)
81130d04:	dec00204 	addi	sp,sp,8
81130d08:	f800283a 	ret

81130d0c <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
81130d0c:	defff504 	addi	sp,sp,-44
81130d10:	de00012e 	bgeu	sp,et,81130d18 <OSTaskDelReq+0xc>
81130d14:	003b68fa 	trap	3
81130d18:	df000a15 	stw	fp,40(sp)
81130d1c:	df000a04 	addi	fp,sp,40
81130d20:	2005883a 	mov	r2,r4
81130d24:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130d28:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
81130d2c:	e0bfff03 	ldbu	r2,-4(fp)
81130d30:	10800a18 	cmpnei	r2,r2,40
81130d34:	1000021e 	bne	r2,zero,81130d40 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
81130d38:	00800f84 	movi	r2,62
81130d3c:	00004506 	br	81130e54 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81130d40:	e0bfff03 	ldbu	r2,-4(fp)
81130d44:	10800a30 	cmpltui	r2,r2,40
81130d48:	1000051e 	bne	r2,zero,81130d60 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
81130d4c:	e0bfff03 	ldbu	r2,-4(fp)
81130d50:	10803fe0 	cmpeqi	r2,r2,255
81130d54:	1000021e 	bne	r2,zero,81130d60 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
81130d58:	00800a84 	movi	r2,42
81130d5c:	00003d06 	br	81130e54 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
81130d60:	e0bfff03 	ldbu	r2,-4(fp)
81130d64:	10803fd8 	cmpnei	r2,r2,255
81130d68:	1000111e 	bne	r2,zero,81130db0 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130d6c:	0005303a 	rdctl	r2,status
81130d70:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130d74:	e0fff917 	ldw	r3,-28(fp)
81130d78:	00bfff84 	movi	r2,-2
81130d7c:	1884703a 	and	r2,r3,r2
81130d80:	1001703a 	wrctl	status,r2
  
  return context;
81130d84:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
81130d88:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
81130d8c:	d0a08617 	ldw	r2,-32232(gp)
81130d90:	10800dc3 	ldbu	r2,55(r2)
81130d94:	e0bff805 	stb	r2,-32(fp)
81130d98:	e0bff617 	ldw	r2,-40(fp)
81130d9c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130da0:	e0bffe17 	ldw	r2,-8(fp)
81130da4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
81130da8:	e0bff803 	ldbu	r2,-32(fp)
81130dac:	00002906 	br	81130e54 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130db0:	0005303a 	rdctl	r2,status
81130db4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130db8:	e0fff717 	ldw	r3,-36(fp)
81130dbc:	00bfff84 	movi	r2,-2
81130dc0:	1884703a 	and	r2,r3,r2
81130dc4:	1001703a 	wrctl	status,r2
  
  return context;
81130dc8:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
81130dcc:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81130dd0:	e0ffff03 	ldbu	r3,-4(fp)
81130dd4:	00a04574 	movhi	r2,33045
81130dd8:	10948904 	addi	r2,r2,21028
81130ddc:	18c7883a 	add	r3,r3,r3
81130de0:	18c7883a 	add	r3,r3,r3
81130de4:	10c5883a 	add	r2,r2,r3
81130de8:	10800017 	ldw	r2,0(r2)
81130dec:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
81130df0:	e0bffb17 	ldw	r2,-20(fp)
81130df4:	1000061e 	bne	r2,zero,81130e10 <OSTaskDelReq+0x104>
81130df8:	e0bff617 	ldw	r2,-40(fp)
81130dfc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130e00:	e0bffa17 	ldw	r2,-24(fp)
81130e04:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
81130e08:	008010c4 	movi	r2,67
81130e0c:	00001106 	br	81130e54 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
81130e10:	e0bffb17 	ldw	r2,-20(fp)
81130e14:	10800058 	cmpnei	r2,r2,1
81130e18:	1000061e 	bne	r2,zero,81130e34 <OSTaskDelReq+0x128>
81130e1c:	e0bff617 	ldw	r2,-40(fp)
81130e20:	e0bffc15 	stw	r2,-16(fp)
81130e24:	e0bffc17 	ldw	r2,-16(fp)
81130e28:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81130e2c:	00800f44 	movi	r2,61
81130e30:	00000806 	br	81130e54 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
81130e34:	e0bffb17 	ldw	r2,-20(fp)
81130e38:	00c00fc4 	movi	r3,63
81130e3c:	10c00dc5 	stb	r3,55(r2)
81130e40:	e0bff617 	ldw	r2,-40(fp)
81130e44:	e0bffd15 	stw	r2,-12(fp)
81130e48:	e0bffd17 	ldw	r2,-12(fp)
81130e4c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81130e50:	0005883a 	mov	r2,zero
}
81130e54:	e037883a 	mov	sp,fp
81130e58:	df000017 	ldw	fp,0(sp)
81130e5c:	dec00104 	addi	sp,sp,4
81130e60:	f800283a 	ret

81130e64 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
81130e64:	defff404 	addi	sp,sp,-48
81130e68:	de00012e 	bgeu	sp,et,81130e70 <OSTaskNameGet+0xc>
81130e6c:	003b68fa 	trap	3
81130e70:	dfc00b15 	stw	ra,44(sp)
81130e74:	df000a15 	stw	fp,40(sp)
81130e78:	df000a04 	addi	fp,sp,40
81130e7c:	2005883a 	mov	r2,r4
81130e80:	e17ffe15 	stw	r5,-8(fp)
81130e84:	e1bfff15 	stw	r6,-4(fp)
81130e88:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
81130e8c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
81130e90:	e0bfff17 	ldw	r2,-4(fp)
81130e94:	1000021e 	bne	r2,zero,81130ea0 <OSTaskNameGet+0x3c>
        return (0);
81130e98:	0005883a 	mov	r2,zero
81130e9c:	00005406 	br	81130ff0 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
81130ea0:	e0bffd03 	ldbu	r2,-12(fp)
81130ea4:	10800a70 	cmpltui	r2,r2,41
81130ea8:	1000081e 	bne	r2,zero,81130ecc <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
81130eac:	e0bffd03 	ldbu	r2,-12(fp)
81130eb0:	10803fe0 	cmpeqi	r2,r2,255
81130eb4:	1000051e 	bne	r2,zero,81130ecc <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
81130eb8:	e0bfff17 	ldw	r2,-4(fp)
81130ebc:	00c00a84 	movi	r3,42
81130ec0:	10c00005 	stb	r3,0(r2)
            return (0);
81130ec4:	0005883a 	mov	r2,zero
81130ec8:	00004906 	br	81130ff0 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
81130ecc:	e0bffe17 	ldw	r2,-8(fp)
81130ed0:	1000051e 	bne	r2,zero,81130ee8 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
81130ed4:	e0bfff17 	ldw	r2,-4(fp)
81130ed8:	00c00304 	movi	r3,12
81130edc:	10c00005 	stb	r3,0(r2)
        return (0);
81130ee0:	0005883a 	mov	r2,zero
81130ee4:	00004206 	br	81130ff0 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
81130ee8:	d0a08503 	ldbu	r2,-32236(gp)
81130eec:	10803fcc 	andi	r2,r2,255
81130ef0:	10000526 	beq	r2,zero,81130f08 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
81130ef4:	e0bfff17 	ldw	r2,-4(fp)
81130ef8:	00c00444 	movi	r3,17
81130efc:	10c00005 	stb	r3,0(r2)
        return (0);
81130f00:	0005883a 	mov	r2,zero
81130f04:	00003a06 	br	81130ff0 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130f08:	0005303a 	rdctl	r2,status
81130f0c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130f10:	e0fffc17 	ldw	r3,-16(fp)
81130f14:	00bfff84 	movi	r2,-2
81130f18:	1884703a 	and	r2,r3,r2
81130f1c:	1001703a 	wrctl	status,r2
  
  return context;
81130f20:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81130f24:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
81130f28:	e0bffd03 	ldbu	r2,-12(fp)
81130f2c:	10803fd8 	cmpnei	r2,r2,255
81130f30:	1000031e 	bne	r2,zero,81130f40 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
81130f34:	d0a08617 	ldw	r2,-32232(gp)
81130f38:	10800c83 	ldbu	r2,50(r2)
81130f3c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81130f40:	e0fffd03 	ldbu	r3,-12(fp)
81130f44:	00a04574 	movhi	r2,33045
81130f48:	10948904 	addi	r2,r2,21028
81130f4c:	18c7883a 	add	r3,r3,r3
81130f50:	18c7883a 	add	r3,r3,r3
81130f54:	10c5883a 	add	r2,r2,r3
81130f58:	10800017 	ldw	r2,0(r2)
81130f5c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
81130f60:	e0bff817 	ldw	r2,-32(fp)
81130f64:	1000091e 	bne	r2,zero,81130f8c <OSTaskNameGet+0x128>
81130f68:	e0bff617 	ldw	r2,-40(fp)
81130f6c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130f70:	e0bff717 	ldw	r2,-36(fp)
81130f74:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
81130f78:	e0bfff17 	ldw	r2,-4(fp)
81130f7c:	00c010c4 	movi	r3,67
81130f80:	10c00005 	stb	r3,0(r2)
        return (0);
81130f84:	0005883a 	mov	r2,zero
81130f88:	00001906 	br	81130ff0 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
81130f8c:	e0bff817 	ldw	r2,-32(fp)
81130f90:	10800058 	cmpnei	r2,r2,1
81130f94:	1000091e 	bne	r2,zero,81130fbc <OSTaskNameGet+0x158>
81130f98:	e0bff617 	ldw	r2,-40(fp)
81130f9c:	e0bff915 	stw	r2,-28(fp)
81130fa0:	e0bff917 	ldw	r2,-28(fp)
81130fa4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
81130fa8:	e0bfff17 	ldw	r2,-4(fp)
81130fac:	00c010c4 	movi	r3,67
81130fb0:	10c00005 	stb	r3,0(r2)
        return (0);
81130fb4:	0005883a 	mov	r2,zero
81130fb8:	00000d06 	br	81130ff0 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
81130fbc:	e0bff817 	ldw	r2,-32(fp)
81130fc0:	10801304 	addi	r2,r2,76
81130fc4:	100b883a 	mov	r5,r2
81130fc8:	e13ffe17 	ldw	r4,-8(fp)
81130fcc:	112ad0c0 	call	8112ad0c <OS_StrCopy>
81130fd0:	e0bffb05 	stb	r2,-20(fp)
81130fd4:	e0bff617 	ldw	r2,-40(fp)
81130fd8:	e0bffa15 	stw	r2,-24(fp)
81130fdc:	e0bffa17 	ldw	r2,-24(fp)
81130fe0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81130fe4:	e0bfff17 	ldw	r2,-4(fp)
81130fe8:	10000005 	stb	zero,0(r2)
    return (len);
81130fec:	e0bffb03 	ldbu	r2,-20(fp)
}
81130ff0:	e037883a 	mov	sp,fp
81130ff4:	dfc00117 	ldw	ra,4(sp)
81130ff8:	df000017 	ldw	fp,0(sp)
81130ffc:	dec00204 	addi	sp,sp,8
81131000:	f800283a 	ret

81131004 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
81131004:	defff304 	addi	sp,sp,-52
81131008:	de00012e 	bgeu	sp,et,81131010 <OSTaskNameSet+0xc>
8113100c:	003b68fa 	trap	3
81131010:	dfc00c15 	stw	ra,48(sp)
81131014:	df000b15 	stw	fp,44(sp)
81131018:	df000b04 	addi	fp,sp,44
8113101c:	2005883a 	mov	r2,r4
81131020:	e17ffe15 	stw	r5,-8(fp)
81131024:	e1bfff15 	stw	r6,-4(fp)
81131028:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113102c:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
81131030:	e0bfff17 	ldw	r2,-4(fp)
81131034:	10005c26 	beq	r2,zero,811311a8 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
81131038:	e0bffd03 	ldbu	r2,-12(fp)
8113103c:	10800a70 	cmpltui	r2,r2,41
81131040:	1000071e 	bne	r2,zero,81131060 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
81131044:	e0bffd03 	ldbu	r2,-12(fp)
81131048:	10803fe0 	cmpeqi	r2,r2,255
8113104c:	1000041e 	bne	r2,zero,81131060 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
81131050:	e0bfff17 	ldw	r2,-4(fp)
81131054:	00c00a84 	movi	r3,42
81131058:	10c00005 	stb	r3,0(r2)
            return;
8113105c:	00005306 	br	811311ac <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
81131060:	e0bffe17 	ldw	r2,-8(fp)
81131064:	1000041e 	bne	r2,zero,81131078 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
81131068:	e0bfff17 	ldw	r2,-4(fp)
8113106c:	00c00304 	movi	r3,12
81131070:	10c00005 	stb	r3,0(r2)
        return;
81131074:	00004d06 	br	811311ac <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
81131078:	d0a08503 	ldbu	r2,-32236(gp)
8113107c:	10803fcc 	andi	r2,r2,255
81131080:	10000426 	beq	r2,zero,81131094 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
81131084:	e0bfff17 	ldw	r2,-4(fp)
81131088:	00c00484 	movi	r3,18
8113108c:	10c00005 	stb	r3,0(r2)
        return;
81131090:	00004606 	br	811311ac <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131094:	0005303a 	rdctl	r2,status
81131098:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113109c:	e0fffc17 	ldw	r3,-16(fp)
811310a0:	00bfff84 	movi	r2,-2
811310a4:	1884703a 	and	r2,r3,r2
811310a8:	1001703a 	wrctl	status,r2
  
  return context;
811310ac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811310b0:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
811310b4:	e0bffd03 	ldbu	r2,-12(fp)
811310b8:	10803fd8 	cmpnei	r2,r2,255
811310bc:	1000031e 	bne	r2,zero,811310cc <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
811310c0:	d0a08617 	ldw	r2,-32232(gp)
811310c4:	10800c83 	ldbu	r2,50(r2)
811310c8:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811310cc:	e0fffd03 	ldbu	r3,-12(fp)
811310d0:	00a04574 	movhi	r2,33045
811310d4:	10948904 	addi	r2,r2,21028
811310d8:	18c7883a 	add	r3,r3,r3
811310dc:	18c7883a 	add	r3,r3,r3
811310e0:	10c5883a 	add	r2,r2,r3
811310e4:	10800017 	ldw	r2,0(r2)
811310e8:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
811310ec:	e0bff717 	ldw	r2,-36(fp)
811310f0:	1000081e 	bne	r2,zero,81131114 <OSTaskNameSet+0x110>
811310f4:	e0bff517 	ldw	r2,-44(fp)
811310f8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811310fc:	e0bff617 	ldw	r2,-40(fp)
81131100:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
81131104:	e0bfff17 	ldw	r2,-4(fp)
81131108:	00c010c4 	movi	r3,67
8113110c:	10c00005 	stb	r3,0(r2)
        return;
81131110:	00002606 	br	811311ac <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
81131114:	e0bff717 	ldw	r2,-36(fp)
81131118:	10800058 	cmpnei	r2,r2,1
8113111c:	1000081e 	bne	r2,zero,81131140 <OSTaskNameSet+0x13c>
81131120:	e0bff517 	ldw	r2,-44(fp)
81131124:	e0bff815 	stw	r2,-32(fp)
81131128:	e0bff817 	ldw	r2,-32(fp)
8113112c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
81131130:	e0bfff17 	ldw	r2,-4(fp)
81131134:	00c010c4 	movi	r3,67
81131138:	10c00005 	stb	r3,0(r2)
        return;
8113113c:	00001b06 	br	811311ac <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
81131140:	e13ffe17 	ldw	r4,-8(fp)
81131144:	112ad880 	call	8112ad88 <OS_StrLen>
81131148:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8113114c:	e0bffa03 	ldbu	r2,-24(fp)
81131150:	10800830 	cmpltui	r2,r2,32
81131154:	1000081e 	bne	r2,zero,81131178 <OSTaskNameSet+0x174>
81131158:	e0bff517 	ldw	r2,-44(fp)
8113115c:	e0bff915 	stw	r2,-28(fp)
81131160:	e0bff917 	ldw	r2,-28(fp)
81131164:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
81131168:	e0bfff17 	ldw	r2,-4(fp)
8113116c:	00c01044 	movi	r3,65
81131170:	10c00005 	stb	r3,0(r2)
        return;
81131174:	00000d06 	br	811311ac <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
81131178:	e0bff717 	ldw	r2,-36(fp)
8113117c:	10801304 	addi	r2,r2,76
81131180:	e17ffe17 	ldw	r5,-8(fp)
81131184:	1009883a 	mov	r4,r2
81131188:	112ad0c0 	call	8112ad0c <OS_StrCopy>
8113118c:	e0bff517 	ldw	r2,-44(fp)
81131190:	e0bffb15 	stw	r2,-20(fp)
81131194:	e0bffb17 	ldw	r2,-20(fp)
81131198:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113119c:	e0bfff17 	ldw	r2,-4(fp)
811311a0:	10000005 	stb	zero,0(r2)
811311a4:	00000106 	br	811311ac <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
811311a8:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
811311ac:	e037883a 	mov	sp,fp
811311b0:	dfc00117 	ldw	ra,4(sp)
811311b4:	df000017 	ldw	fp,0(sp)
811311b8:	dec00204 	addi	sp,sp,8
811311bc:	f800283a 	ret

811311c0 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
811311c0:	defff404 	addi	sp,sp,-48
811311c4:	de00012e 	bgeu	sp,et,811311cc <OSTaskResume+0xc>
811311c8:	003b68fa 	trap	3
811311cc:	dfc00b15 	stw	ra,44(sp)
811311d0:	df000a15 	stw	fp,40(sp)
811311d4:	df000a04 	addi	fp,sp,40
811311d8:	2005883a 	mov	r2,r4
811311dc:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
811311e0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
811311e4:	e0bfff03 	ldbu	r2,-4(fp)
811311e8:	10800a30 	cmpltui	r2,r2,40
811311ec:	1000021e 	bne	r2,zero,811311f8 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
811311f0:	00800a84 	movi	r2,42
811311f4:	00006406 	br	81131388 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811311f8:	0005303a 	rdctl	r2,status
811311fc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131200:	e0fffe17 	ldw	r3,-8(fp)
81131204:	00bfff84 	movi	r2,-2
81131208:	1884703a 	and	r2,r3,r2
8113120c:	1001703a 	wrctl	status,r2
  
  return context;
81131210:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81131214:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81131218:	e0ffff03 	ldbu	r3,-4(fp)
8113121c:	00a04574 	movhi	r2,33045
81131220:	10948904 	addi	r2,r2,21028
81131224:	18c7883a 	add	r3,r3,r3
81131228:	18c7883a 	add	r3,r3,r3
8113122c:	10c5883a 	add	r2,r2,r3
81131230:	10800017 	ldw	r2,0(r2)
81131234:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
81131238:	e0bff817 	ldw	r2,-32(fp)
8113123c:	1000061e 	bne	r2,zero,81131258 <OSTaskResume+0x98>
81131240:	e0bff617 	ldw	r2,-40(fp)
81131244:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131248:	e0bff717 	ldw	r2,-36(fp)
8113124c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
81131250:	00801184 	movi	r2,70
81131254:	00004c06 	br	81131388 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
81131258:	e0bff817 	ldw	r2,-32(fp)
8113125c:	10800058 	cmpnei	r2,r2,1
81131260:	1000061e 	bne	r2,zero,8113127c <OSTaskResume+0xbc>
81131264:	e0bff617 	ldw	r2,-40(fp)
81131268:	e0bff915 	stw	r2,-28(fp)
8113126c:	e0bff917 	ldw	r2,-28(fp)
81131270:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81131274:	008010c4 	movi	r2,67
81131278:	00004306 	br	81131388 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8113127c:	e0bff817 	ldw	r2,-32(fp)
81131280:	10800c03 	ldbu	r2,48(r2)
81131284:	10803fcc 	andi	r2,r2,255
81131288:	1080020c 	andi	r2,r2,8
8113128c:	10003926 	beq	r2,zero,81131374 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
81131290:	e0bff817 	ldw	r2,-32(fp)
81131294:	10c00c03 	ldbu	r3,48(r2)
81131298:	00bffdc4 	movi	r2,-9
8113129c:	1884703a 	and	r2,r3,r2
811312a0:	1007883a 	mov	r3,r2
811312a4:	e0bff817 	ldw	r2,-32(fp)
811312a8:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
811312ac:	e0bff817 	ldw	r2,-32(fp)
811312b0:	10800c03 	ldbu	r2,48(r2)
811312b4:	10803fcc 	andi	r2,r2,255
811312b8:	1000281e 	bne	r2,zero,8113135c <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
811312bc:	e0bff817 	ldw	r2,-32(fp)
811312c0:	10800b8b 	ldhu	r2,46(r2)
811312c4:	10bfffcc 	andi	r2,r2,65535
811312c8:	10001f1e 	bne	r2,zero,81131348 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
811312cc:	e0bff817 	ldw	r2,-32(fp)
811312d0:	10c00d83 	ldbu	r3,54(r2)
811312d4:	d0a08203 	ldbu	r2,-32248(gp)
811312d8:	1884b03a 	or	r2,r3,r2
811312dc:	d0a08205 	stb	r2,-32248(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811312e0:	e0bff817 	ldw	r2,-32(fp)
811312e4:	10800d03 	ldbu	r2,52(r2)
811312e8:	10c03fcc 	andi	r3,r2,255
811312ec:	e0bff817 	ldw	r2,-32(fp)
811312f0:	10800d03 	ldbu	r2,52(r2)
811312f4:	11003fcc 	andi	r4,r2,255
811312f8:	d0a08244 	addi	r2,gp,-32247
811312fc:	2085883a 	add	r2,r4,r2
81131300:	11000003 	ldbu	r4,0(r2)
81131304:	e0bff817 	ldw	r2,-32(fp)
81131308:	10800d43 	ldbu	r2,53(r2)
8113130c:	2084b03a 	or	r2,r4,r2
81131310:	1009883a 	mov	r4,r2
81131314:	d0a08244 	addi	r2,gp,-32247
81131318:	1885883a 	add	r2,r3,r2
8113131c:	11000005 	stb	r4,0(r2)
81131320:	e0bff617 	ldw	r2,-40(fp)
81131324:	e0bffa15 	stw	r2,-24(fp)
81131328:	e0bffa17 	ldw	r2,-24(fp)
8113132c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
81131330:	d0a07503 	ldbu	r2,-32300(gp)
81131334:	10803fcc 	andi	r2,r2,255
81131338:	10800058 	cmpnei	r2,r2,1
8113133c:	10000b1e 	bne	r2,zero,8113136c <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
81131340:	112abb80 	call	8112abb8 <OS_Sched>
81131344:	00000906 	br	8113136c <OSTaskResume+0x1ac>
81131348:	e0bff617 	ldw	r2,-40(fp)
8113134c:	e0bffb15 	stw	r2,-20(fp)
81131350:	e0bffb17 	ldw	r2,-20(fp)
81131354:	1001703a 	wrctl	status,r2
81131358:	00000406 	br	8113136c <OSTaskResume+0x1ac>
8113135c:	e0bff617 	ldw	r2,-40(fp)
81131360:	e0bffc15 	stw	r2,-16(fp)
81131364:	e0bffc17 	ldw	r2,-16(fp)
81131368:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8113136c:	0005883a 	mov	r2,zero
81131370:	00000506 	br	81131388 <OSTaskResume+0x1c8>
81131374:	e0bff617 	ldw	r2,-40(fp)
81131378:	e0bffd15 	stw	r2,-12(fp)
8113137c:	e0bffd17 	ldw	r2,-12(fp)
81131380:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
81131384:	00801104 	movi	r2,68
}
81131388:	e037883a 	mov	sp,fp
8113138c:	dfc00117 	ldw	ra,4(sp)
81131390:	df000017 	ldw	fp,0(sp)
81131394:	dec00204 	addi	sp,sp,8
81131398:	f800283a 	ret

8113139c <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8113139c:	defff304 	addi	sp,sp,-52
811313a0:	de00012e 	bgeu	sp,et,811313a8 <OSTaskStkChk+0xc>
811313a4:	003b68fa 	trap	3
811313a8:	df000c15 	stw	fp,48(sp)
811313ac:	df000c04 	addi	fp,sp,48
811313b0:	2005883a 	mov	r2,r4
811313b4:	e17fff15 	stw	r5,-4(fp)
811313b8:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811313bc:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
811313c0:	e0bffe03 	ldbu	r2,-8(fp)
811313c4:	10800a70 	cmpltui	r2,r2,41
811313c8:	1000051e 	bne	r2,zero,811313e0 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
811313cc:	e0bffe03 	ldbu	r2,-8(fp)
811313d0:	10803fe0 	cmpeqi	r2,r2,255
811313d4:	1000021e 	bne	r2,zero,811313e0 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
811313d8:	00800a84 	movi	r2,42
811313dc:	00005d06 	br	81131554 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
811313e0:	e0bfff17 	ldw	r2,-4(fp)
811313e4:	1000021e 	bne	r2,zero,811313f0 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
811313e8:	00800244 	movi	r2,9
811313ec:	00005906 	br	81131554 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
811313f0:	e0bfff17 	ldw	r2,-4(fp)
811313f4:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
811313f8:	e0bfff17 	ldw	r2,-4(fp)
811313fc:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131400:	0005303a 	rdctl	r2,status
81131404:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131408:	e0fffd17 	ldw	r3,-12(fp)
8113140c:	00bfff84 	movi	r2,-2
81131410:	1884703a 	and	r2,r3,r2
81131414:	1001703a 	wrctl	status,r2
  
  return context;
81131418:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8113141c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
81131420:	e0bffe03 	ldbu	r2,-8(fp)
81131424:	10803fd8 	cmpnei	r2,r2,255
81131428:	1000031e 	bne	r2,zero,81131438 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113142c:	d0a08617 	ldw	r2,-32232(gp)
81131430:	10800c83 	ldbu	r2,50(r2)
81131434:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81131438:	e0fffe03 	ldbu	r3,-8(fp)
8113143c:	00a04574 	movhi	r2,33045
81131440:	10948904 	addi	r2,r2,21028
81131444:	18c7883a 	add	r3,r3,r3
81131448:	18c7883a 	add	r3,r3,r3
8113144c:	10c5883a 	add	r2,r2,r3
81131450:	10800017 	ldw	r2,0(r2)
81131454:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
81131458:	e0bff817 	ldw	r2,-32(fp)
8113145c:	1000061e 	bne	r2,zero,81131478 <OSTaskStkChk+0xdc>
81131460:	e0bff617 	ldw	r2,-40(fp)
81131464:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131468:	e0bff717 	ldw	r2,-36(fp)
8113146c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81131470:	008010c4 	movi	r2,67
81131474:	00003706 	br	81131554 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81131478:	e0bff817 	ldw	r2,-32(fp)
8113147c:	10800058 	cmpnei	r2,r2,1
81131480:	1000061e 	bne	r2,zero,8113149c <OSTaskStkChk+0x100>
81131484:	e0bff617 	ldw	r2,-40(fp)
81131488:	e0bff915 	stw	r2,-28(fp)
8113148c:	e0bff917 	ldw	r2,-28(fp)
81131490:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81131494:	008010c4 	movi	r2,67
81131498:	00002e06 	br	81131554 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8113149c:	e0bff817 	ldw	r2,-32(fp)
811314a0:	1080040b 	ldhu	r2,16(r2)
811314a4:	10bfffcc 	andi	r2,r2,65535
811314a8:	1080004c 	andi	r2,r2,1
811314ac:	1000061e 	bne	r2,zero,811314c8 <OSTaskStkChk+0x12c>
811314b0:	e0bff617 	ldw	r2,-40(fp)
811314b4:	e0bffa15 	stw	r2,-24(fp)
811314b8:	e0bffa17 	ldw	r2,-24(fp)
811314bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
811314c0:	00801144 	movi	r2,69
811314c4:	00002306 	br	81131554 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
811314c8:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
811314cc:	e0bff817 	ldw	r2,-32(fp)
811314d0:	10800317 	ldw	r2,12(r2)
811314d4:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
811314d8:	e0bff817 	ldw	r2,-32(fp)
811314dc:	10800217 	ldw	r2,8(r2)
811314e0:	e0bff415 	stw	r2,-48(fp)
811314e4:	e0bff617 	ldw	r2,-40(fp)
811314e8:	e0bffb15 	stw	r2,-20(fp)
811314ec:	e0bffb17 	ldw	r2,-20(fp)
811314f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
811314f4:	00000306 	br	81131504 <OSTaskStkChk+0x168>
        nfree++;
811314f8:	e0bff517 	ldw	r2,-44(fp)
811314fc:	10800044 	addi	r2,r2,1
81131500:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
81131504:	e0bff417 	ldw	r2,-48(fp)
81131508:	10c00104 	addi	r3,r2,4
8113150c:	e0fff415 	stw	r3,-48(fp)
81131510:	10800017 	ldw	r2,0(r2)
81131514:	103ff826 	beq	r2,zero,811314f8 <__reset+0xfb1114f8>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
81131518:	e0bff517 	ldw	r2,-44(fp)
8113151c:	1085883a 	add	r2,r2,r2
81131520:	1085883a 	add	r2,r2,r2
81131524:	1007883a 	mov	r3,r2
81131528:	e0bfff17 	ldw	r2,-4(fp)
8113152c:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
81131530:	e0fffc17 	ldw	r3,-16(fp)
81131534:	e0bff517 	ldw	r2,-44(fp)
81131538:	1885c83a 	sub	r2,r3,r2
8113153c:	1085883a 	add	r2,r2,r2
81131540:	1085883a 	add	r2,r2,r2
81131544:	1007883a 	mov	r3,r2
81131548:	e0bfff17 	ldw	r2,-4(fp)
8113154c:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
81131550:	0005883a 	mov	r2,zero
}
81131554:	e037883a 	mov	sp,fp
81131558:	df000017 	ldw	fp,0(sp)
8113155c:	dec00104 	addi	sp,sp,4
81131560:	f800283a 	ret

81131564 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
81131564:	defff504 	addi	sp,sp,-44
81131568:	de00012e 	bgeu	sp,et,81131570 <OSTaskSuspend+0xc>
8113156c:	003b68fa 	trap	3
81131570:	dfc00a15 	stw	ra,40(sp)
81131574:	df000915 	stw	fp,36(sp)
81131578:	df000904 	addi	fp,sp,36
8113157c:	2005883a 	mov	r2,r4
81131580:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81131584:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
81131588:	e0bfff03 	ldbu	r2,-4(fp)
8113158c:	10800a18 	cmpnei	r2,r2,40
81131590:	1000021e 	bne	r2,zero,8113159c <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
81131594:	008011c4 	movi	r2,71
81131598:	00006806 	br	8113173c <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113159c:	e0bfff03 	ldbu	r2,-4(fp)
811315a0:	10800a30 	cmpltui	r2,r2,40
811315a4:	1000051e 	bne	r2,zero,811315bc <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
811315a8:	e0bfff03 	ldbu	r2,-4(fp)
811315ac:	10803fe0 	cmpeqi	r2,r2,255
811315b0:	1000021e 	bne	r2,zero,811315bc <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
811315b4:	00800a84 	movi	r2,42
811315b8:	00006006 	br	8113173c <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811315bc:	0005303a 	rdctl	r2,status
811315c0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811315c4:	e0fffe17 	ldw	r3,-8(fp)
811315c8:	00bfff84 	movi	r2,-2
811315cc:	1884703a 	and	r2,r3,r2
811315d0:	1001703a 	wrctl	status,r2
  
  return context;
811315d4:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
811315d8:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
811315dc:	e0bfff03 	ldbu	r2,-4(fp)
811315e0:	10803fd8 	cmpnei	r2,r2,255
811315e4:	1000061e 	bne	r2,zero,81131600 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
811315e8:	d0a08617 	ldw	r2,-32232(gp)
811315ec:	10800c83 	ldbu	r2,50(r2)
811315f0:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
811315f4:	00800044 	movi	r2,1
811315f8:	e0bff705 	stb	r2,-36(fp)
811315fc:	00000906 	br	81131624 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
81131600:	d0a08617 	ldw	r2,-32232(gp)
81131604:	10800c83 	ldbu	r2,50(r2)
81131608:	10c03fcc 	andi	r3,r2,255
8113160c:	e0bfff03 	ldbu	r2,-4(fp)
81131610:	1880031e 	bne	r3,r2,81131620 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
81131614:	00800044 	movi	r2,1
81131618:	e0bff705 	stb	r2,-36(fp)
8113161c:	00000106 	br	81131624 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
81131620:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81131624:	e0ffff03 	ldbu	r3,-4(fp)
81131628:	00a04574 	movhi	r2,33045
8113162c:	10948904 	addi	r2,r2,21028
81131630:	18c7883a 	add	r3,r3,r3
81131634:	18c7883a 	add	r3,r3,r3
81131638:	10c5883a 	add	r2,r2,r3
8113163c:	10800017 	ldw	r2,0(r2)
81131640:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
81131644:	e0bffa17 	ldw	r2,-24(fp)
81131648:	1000061e 	bne	r2,zero,81131664 <OSTaskSuspend+0x100>
8113164c:	e0bff817 	ldw	r2,-32(fp)
81131650:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131654:	e0bff917 	ldw	r2,-28(fp)
81131658:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8113165c:	00801204 	movi	r2,72
81131660:	00003606 	br	8113173c <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
81131664:	e0bffa17 	ldw	r2,-24(fp)
81131668:	10800058 	cmpnei	r2,r2,1
8113166c:	1000061e 	bne	r2,zero,81131688 <OSTaskSuspend+0x124>
81131670:	e0bff817 	ldw	r2,-32(fp)
81131674:	e0bffb15 	stw	r2,-20(fp)
81131678:	e0bffb17 	ldw	r2,-20(fp)
8113167c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81131680:	008010c4 	movi	r2,67
81131684:	00002d06 	br	8113173c <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
81131688:	e0bffa17 	ldw	r2,-24(fp)
8113168c:	10800d03 	ldbu	r2,52(r2)
81131690:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
81131694:	e0fffd03 	ldbu	r3,-12(fp)
81131698:	e13ffd03 	ldbu	r4,-12(fp)
8113169c:	d0a08244 	addi	r2,gp,-32247
811316a0:	2085883a 	add	r2,r4,r2
811316a4:	10800003 	ldbu	r2,0(r2)
811316a8:	1009883a 	mov	r4,r2
811316ac:	e0bffa17 	ldw	r2,-24(fp)
811316b0:	10800d43 	ldbu	r2,53(r2)
811316b4:	0084303a 	nor	r2,zero,r2
811316b8:	2084703a 	and	r2,r4,r2
811316bc:	1009883a 	mov	r4,r2
811316c0:	d0a08244 	addi	r2,gp,-32247
811316c4:	1885883a 	add	r2,r3,r2
811316c8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811316cc:	e0fffd03 	ldbu	r3,-12(fp)
811316d0:	d0a08244 	addi	r2,gp,-32247
811316d4:	1885883a 	add	r2,r3,r2
811316d8:	10800003 	ldbu	r2,0(r2)
811316dc:	10803fcc 	andi	r2,r2,255
811316e0:	1000071e 	bne	r2,zero,81131700 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
811316e4:	e0bffa17 	ldw	r2,-24(fp)
811316e8:	10800d83 	ldbu	r2,54(r2)
811316ec:	0084303a 	nor	r2,zero,r2
811316f0:	1007883a 	mov	r3,r2
811316f4:	d0a08203 	ldbu	r2,-32248(gp)
811316f8:	1884703a 	and	r2,r3,r2
811316fc:	d0a08205 	stb	r2,-32248(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
81131700:	e0bffa17 	ldw	r2,-24(fp)
81131704:	10800c03 	ldbu	r2,48(r2)
81131708:	10800214 	ori	r2,r2,8
8113170c:	1007883a 	mov	r3,r2
81131710:	e0bffa17 	ldw	r2,-24(fp)
81131714:	10c00c05 	stb	r3,48(r2)
81131718:	e0bff817 	ldw	r2,-32(fp)
8113171c:	e0bffc15 	stw	r2,-16(fp)
81131720:	e0bffc17 	ldw	r2,-16(fp)
81131724:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
81131728:	e0bff703 	ldbu	r2,-36(fp)
8113172c:	10800058 	cmpnei	r2,r2,1
81131730:	1000011e 	bne	r2,zero,81131738 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
81131734:	112abb80 	call	8112abb8 <OS_Sched>
    }
    return (OS_ERR_NONE);
81131738:	0005883a 	mov	r2,zero
}
8113173c:	e037883a 	mov	sp,fp
81131740:	dfc00117 	ldw	ra,4(sp)
81131744:	df000017 	ldw	fp,0(sp)
81131748:	dec00204 	addi	sp,sp,8
8113174c:	f800283a 	ret

81131750 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
81131750:	defff604 	addi	sp,sp,-40
81131754:	de00012e 	bgeu	sp,et,8113175c <OSTaskQuery+0xc>
81131758:	003b68fa 	trap	3
8113175c:	dfc00915 	stw	ra,36(sp)
81131760:	df000815 	stw	fp,32(sp)
81131764:	df000804 	addi	fp,sp,32
81131768:	2005883a 	mov	r2,r4
8113176c:	e17fff15 	stw	r5,-4(fp)
81131770:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81131774:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
81131778:	e0bffe03 	ldbu	r2,-8(fp)
8113177c:	10800a70 	cmpltui	r2,r2,41
81131780:	1000051e 	bne	r2,zero,81131798 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
81131784:	e0bffe03 	ldbu	r2,-8(fp)
81131788:	10803fe0 	cmpeqi	r2,r2,255
8113178c:	1000021e 	bne	r2,zero,81131798 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
81131790:	00800a84 	movi	r2,42
81131794:	00003406 	br	81131868 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
81131798:	e0bfff17 	ldw	r2,-4(fp)
8113179c:	1000021e 	bne	r2,zero,811317a8 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
811317a0:	00800244 	movi	r2,9
811317a4:	00003006 	br	81131868 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811317a8:	0005303a 	rdctl	r2,status
811317ac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811317b0:	e0fffd17 	ldw	r3,-12(fp)
811317b4:	00bfff84 	movi	r2,-2
811317b8:	1884703a 	and	r2,r3,r2
811317bc:	1001703a 	wrctl	status,r2
  
  return context;
811317c0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811317c4:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
811317c8:	e0bffe03 	ldbu	r2,-8(fp)
811317cc:	10803fd8 	cmpnei	r2,r2,255
811317d0:	1000031e 	bne	r2,zero,811317e0 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
811317d4:	d0a08617 	ldw	r2,-32232(gp)
811317d8:	10800c83 	ldbu	r2,50(r2)
811317dc:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811317e0:	e0fffe03 	ldbu	r3,-8(fp)
811317e4:	00a04574 	movhi	r2,33045
811317e8:	10948904 	addi	r2,r2,21028
811317ec:	18c7883a 	add	r3,r3,r3
811317f0:	18c7883a 	add	r3,r3,r3
811317f4:	10c5883a 	add	r2,r2,r3
811317f8:	10800017 	ldw	r2,0(r2)
811317fc:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
81131800:	e0bffa17 	ldw	r2,-24(fp)
81131804:	1000061e 	bne	r2,zero,81131820 <OSTaskQuery+0xd0>
81131808:	e0bff817 	ldw	r2,-32(fp)
8113180c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131810:	e0bff917 	ldw	r2,-28(fp)
81131814:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
81131818:	00800a44 	movi	r2,41
8113181c:	00001206 	br	81131868 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
81131820:	e0bffa17 	ldw	r2,-24(fp)
81131824:	10800058 	cmpnei	r2,r2,1
81131828:	1000061e 	bne	r2,zero,81131844 <OSTaskQuery+0xf4>
8113182c:	e0bff817 	ldw	r2,-32(fp)
81131830:	e0bffb15 	stw	r2,-20(fp)
81131834:	e0bffb17 	ldw	r2,-20(fp)
81131838:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113183c:	008010c4 	movi	r2,67
81131840:	00000906 	br	81131868 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
81131844:	01801b04 	movi	r6,108
81131848:	e17ffa17 	ldw	r5,-24(fp)
8113184c:	e13fff17 	ldw	r4,-4(fp)
81131850:	112ab480 	call	8112ab48 <OS_MemCopy>
81131854:	e0bff817 	ldw	r2,-32(fp)
81131858:	e0bffc15 	stw	r2,-16(fp)
8113185c:	e0bffc17 	ldw	r2,-16(fp)
81131860:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81131864:	0005883a 	mov	r2,zero
}
81131868:	e037883a 	mov	sp,fp
8113186c:	dfc00117 	ldw	ra,4(sp)
81131870:	df000017 	ldw	fp,0(sp)
81131874:	dec00204 	addi	sp,sp,8
81131878:	f800283a 	ret

8113187c <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8113187c:	defffc04 	addi	sp,sp,-16
81131880:	de00012e 	bgeu	sp,et,81131888 <OS_TaskStkClr+0xc>
81131884:	003b68fa 	trap	3
81131888:	df000315 	stw	fp,12(sp)
8113188c:	df000304 	addi	fp,sp,12
81131890:	e13ffd15 	stw	r4,-12(fp)
81131894:	e17ffe15 	stw	r5,-8(fp)
81131898:	3005883a 	mov	r2,r6
8113189c:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
811318a0:	e0bfff0b 	ldhu	r2,-4(fp)
811318a4:	1080004c 	andi	r2,r2,1
811318a8:	10000d26 	beq	r2,zero,811318e0 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
811318ac:	e0bfff0b 	ldhu	r2,-4(fp)
811318b0:	1080008c 	andi	r2,r2,2
811318b4:	10000a26 	beq	r2,zero,811318e0 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
811318b8:	00000706 	br	811318d8 <OS_TaskStkClr+0x5c>
                size--;
811318bc:	e0bffe17 	ldw	r2,-8(fp)
811318c0:	10bfffc4 	addi	r2,r2,-1
811318c4:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
811318c8:	e0bffd17 	ldw	r2,-12(fp)
811318cc:	10c00104 	addi	r3,r2,4
811318d0:	e0fffd15 	stw	r3,-12(fp)
811318d4:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
811318d8:	e0bffe17 	ldw	r2,-8(fp)
811318dc:	103ff71e 	bne	r2,zero,811318bc <__reset+0xfb1118bc>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
811318e0:	0001883a 	nop
811318e4:	e037883a 	mov	sp,fp
811318e8:	df000017 	ldw	fp,0(sp)
811318ec:	dec00104 	addi	sp,sp,4
811318f0:	f800283a 	ret

811318f4 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
811318f4:	defff904 	addi	sp,sp,-28
811318f8:	de00012e 	bgeu	sp,et,81131900 <OSTimeDly+0xc>
811318fc:	003b68fa 	trap	3
81131900:	dfc00615 	stw	ra,24(sp)
81131904:	df000515 	stw	fp,20(sp)
81131908:	df000504 	addi	fp,sp,20
8113190c:	2005883a 	mov	r2,r4
81131910:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81131914:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81131918:	d0a08503 	ldbu	r2,-32236(gp)
8113191c:	10803fcc 	andi	r2,r2,255
81131920:	1000311e 	bne	r2,zero,811319e8 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
81131924:	e0bfff0b 	ldhu	r2,-4(fp)
81131928:	10003026 	beq	r2,zero,811319ec <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113192c:	0005303a 	rdctl	r2,status
81131930:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131934:	e0fffe17 	ldw	r3,-8(fp)
81131938:	00bfff84 	movi	r2,-2
8113193c:	1884703a 	and	r2,r3,r2
81131940:	1001703a 	wrctl	status,r2
  
  return context;
81131944:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
81131948:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8113194c:	d0a08617 	ldw	r2,-32232(gp)
81131950:	10800d03 	ldbu	r2,52(r2)
81131954:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81131958:	e0fffd03 	ldbu	r3,-12(fp)
8113195c:	e13ffd03 	ldbu	r4,-12(fp)
81131960:	d0a08244 	addi	r2,gp,-32247
81131964:	2085883a 	add	r2,r4,r2
81131968:	10800003 	ldbu	r2,0(r2)
8113196c:	1009883a 	mov	r4,r2
81131970:	d0a08617 	ldw	r2,-32232(gp)
81131974:	10800d43 	ldbu	r2,53(r2)
81131978:	0084303a 	nor	r2,zero,r2
8113197c:	2084703a 	and	r2,r4,r2
81131980:	1009883a 	mov	r4,r2
81131984:	d0a08244 	addi	r2,gp,-32247
81131988:	1885883a 	add	r2,r3,r2
8113198c:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
81131990:	e0fffd03 	ldbu	r3,-12(fp)
81131994:	d0a08244 	addi	r2,gp,-32247
81131998:	1885883a 	add	r2,r3,r2
8113199c:	10800003 	ldbu	r2,0(r2)
811319a0:	10803fcc 	andi	r2,r2,255
811319a4:	1000071e 	bne	r2,zero,811319c4 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
811319a8:	d0a08617 	ldw	r2,-32232(gp)
811319ac:	10800d83 	ldbu	r2,54(r2)
811319b0:	0084303a 	nor	r2,zero,r2
811319b4:	1007883a 	mov	r3,r2
811319b8:	d0a08203 	ldbu	r2,-32248(gp)
811319bc:	1884703a 	and	r2,r3,r2
811319c0:	d0a08205 	stb	r2,-32248(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
811319c4:	d0a08617 	ldw	r2,-32232(gp)
811319c8:	e0ffff0b 	ldhu	r3,-4(fp)
811319cc:	10c00b8d 	sth	r3,46(r2)
811319d0:	e0bffb17 	ldw	r2,-20(fp)
811319d4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811319d8:	e0bffc17 	ldw	r2,-16(fp)
811319dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
811319e0:	112abb80 	call	8112abb8 <OS_Sched>
811319e4:	00000106 	br	811319ec <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
811319e8:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
811319ec:	e037883a 	mov	sp,fp
811319f0:	dfc00117 	ldw	ra,4(sp)
811319f4:	df000017 	ldw	fp,0(sp)
811319f8:	dec00204 	addi	sp,sp,8
811319fc:	f800283a 	ret

81131a00 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
81131a00:	defff804 	addi	sp,sp,-32
81131a04:	de00012e 	bgeu	sp,et,81131a0c <OSTimeDlyHMSM+0xc>
81131a08:	003b68fa 	trap	3
81131a0c:	dfc00715 	stw	ra,28(sp)
81131a10:	df000615 	stw	fp,24(sp)
81131a14:	df000604 	addi	fp,sp,24
81131a18:	2015883a 	mov	r10,r4
81131a1c:	2809883a 	mov	r4,r5
81131a20:	3007883a 	mov	r3,r6
81131a24:	3805883a 	mov	r2,r7
81131a28:	e2bffc05 	stb	r10,-16(fp)
81131a2c:	e13ffd05 	stb	r4,-12(fp)
81131a30:	e0fffe05 	stb	r3,-8(fp)
81131a34:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81131a38:	d0a08503 	ldbu	r2,-32236(gp)
81131a3c:	10803fcc 	andi	r2,r2,255
81131a40:	10000226 	beq	r2,zero,81131a4c <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
81131a44:	00801544 	movi	r2,85
81131a48:	00004106 	br	81131b50 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
81131a4c:	e0bffc03 	ldbu	r2,-16(fp)
81131a50:	1000081e 	bne	r2,zero,81131a74 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
81131a54:	e0bffd03 	ldbu	r2,-12(fp)
81131a58:	1000061e 	bne	r2,zero,81131a74 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
81131a5c:	e0bffe03 	ldbu	r2,-8(fp)
81131a60:	1000041e 	bne	r2,zero,81131a74 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
81131a64:	e0bfff0b 	ldhu	r2,-4(fp)
81131a68:	1000021e 	bne	r2,zero,81131a74 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
81131a6c:	00801504 	movi	r2,84
81131a70:	00003706 	br	81131b50 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
81131a74:	e0bffd03 	ldbu	r2,-12(fp)
81131a78:	10800f30 	cmpltui	r2,r2,60
81131a7c:	1000021e 	bne	r2,zero,81131a88 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
81131a80:	00801444 	movi	r2,81
81131a84:	00003206 	br	81131b50 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
81131a88:	e0bffe03 	ldbu	r2,-8(fp)
81131a8c:	10800f30 	cmpltui	r2,r2,60
81131a90:	1000021e 	bne	r2,zero,81131a9c <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
81131a94:	00801484 	movi	r2,82
81131a98:	00002d06 	br	81131b50 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
81131a9c:	e0bfff0b 	ldhu	r2,-4(fp)
81131aa0:	1080fa30 	cmpltui	r2,r2,1000
81131aa4:	1000021e 	bne	r2,zero,81131ab0 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
81131aa8:	008014c4 	movi	r2,83
81131aac:	00002806 	br	81131b50 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81131ab0:	e0bffc03 	ldbu	r2,-16(fp)
81131ab4:	10c38424 	muli	r3,r2,3600
81131ab8:	e0bffd03 	ldbu	r2,-12(fp)
81131abc:	10800f24 	muli	r2,r2,60
81131ac0:	1887883a 	add	r3,r3,r2
81131ac4:	e0bffe03 	ldbu	r2,-8(fp)
81131ac8:	1885883a 	add	r2,r3,r2
81131acc:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
81131ad0:	e0bfff0b 	ldhu	r2,-4(fp)
81131ad4:	10c0fa24 	muli	r3,r2,1000
81131ad8:	008418b4 	movhi	r2,4194
81131adc:	109374c4 	addi	r2,r2,19923
81131ae0:	188a383a 	mulxuu	r5,r3,r2
81131ae4:	1885383a 	mul	r2,r3,r2
81131ae8:	1011883a 	mov	r8,r2
81131aec:	2813883a 	mov	r9,r5
81131af0:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81131af4:	2085883a 	add	r2,r4,r2
81131af8:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
81131afc:	e0bffb17 	ldw	r2,-20(fp)
81131b00:	1004d43a 	srli	r2,r2,16
81131b04:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
81131b08:	e0bffb17 	ldw	r2,-20(fp)
81131b0c:	10bfffcc 	andi	r2,r2,65535
81131b10:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
81131b14:	e0bffb17 	ldw	r2,-20(fp)
81131b18:	10bfffcc 	andi	r2,r2,65535
81131b1c:	1009883a 	mov	r4,r2
81131b20:	11318f40 	call	811318f4 <OSTimeDly>
    while (loops > 0) {
81131b24:	00000706 	br	81131b44 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
81131b28:	01200014 	movui	r4,32768
81131b2c:	11318f40 	call	811318f4 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81131b30:	01200014 	movui	r4,32768
81131b34:	11318f40 	call	811318f4 <OSTimeDly>
        loops--;
81131b38:	e0bffa0b 	ldhu	r2,-24(fp)
81131b3c:	10bfffc4 	addi	r2,r2,-1
81131b40:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
81131b44:	e0bffa0b 	ldhu	r2,-24(fp)
81131b48:	103ff71e 	bne	r2,zero,81131b28 <__reset+0xfb111b28>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
81131b4c:	0005883a 	mov	r2,zero
}
81131b50:	e037883a 	mov	sp,fp
81131b54:	dfc00117 	ldw	ra,4(sp)
81131b58:	df000017 	ldw	fp,0(sp)
81131b5c:	dec00204 	addi	sp,sp,8
81131b60:	f800283a 	ret

81131b64 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
81131b64:	defff504 	addi	sp,sp,-44
81131b68:	de00012e 	bgeu	sp,et,81131b70 <OSTimeDlyResume+0xc>
81131b6c:	003b68fa 	trap	3
81131b70:	dfc00a15 	stw	ra,40(sp)
81131b74:	df000915 	stw	fp,36(sp)
81131b78:	df000904 	addi	fp,sp,36
81131b7c:	2005883a 	mov	r2,r4
81131b80:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81131b84:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
81131b88:	e0bfff03 	ldbu	r2,-4(fp)
81131b8c:	10800a30 	cmpltui	r2,r2,40
81131b90:	1000021e 	bne	r2,zero,81131b9c <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81131b94:	00800a84 	movi	r2,42
81131b98:	00006406 	br	81131d2c <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131b9c:	0005303a 	rdctl	r2,status
81131ba0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131ba4:	e0fffe17 	ldw	r3,-8(fp)
81131ba8:	00bfff84 	movi	r2,-2
81131bac:	1884703a 	and	r2,r3,r2
81131bb0:	1001703a 	wrctl	status,r2
  
  return context;
81131bb4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81131bb8:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
81131bbc:	e0ffff03 	ldbu	r3,-4(fp)
81131bc0:	00a04574 	movhi	r2,33045
81131bc4:	10948904 	addi	r2,r2,21028
81131bc8:	18c7883a 	add	r3,r3,r3
81131bcc:	18c7883a 	add	r3,r3,r3
81131bd0:	10c5883a 	add	r2,r2,r3
81131bd4:	10800017 	ldw	r2,0(r2)
81131bd8:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
81131bdc:	e0bff917 	ldw	r2,-28(fp)
81131be0:	1000061e 	bne	r2,zero,81131bfc <OSTimeDlyResume+0x98>
81131be4:	e0bff717 	ldw	r2,-36(fp)
81131be8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131bec:	e0bff817 	ldw	r2,-32(fp)
81131bf0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81131bf4:	008010c4 	movi	r2,67
81131bf8:	00004c06 	br	81131d2c <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81131bfc:	e0bff917 	ldw	r2,-28(fp)
81131c00:	10800058 	cmpnei	r2,r2,1
81131c04:	1000061e 	bne	r2,zero,81131c20 <OSTimeDlyResume+0xbc>
81131c08:	e0bff717 	ldw	r2,-36(fp)
81131c0c:	e0bffa15 	stw	r2,-24(fp)
81131c10:	e0bffa17 	ldw	r2,-24(fp)
81131c14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81131c18:	008010c4 	movi	r2,67
81131c1c:	00004306 	br	81131d2c <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81131c20:	e0bff917 	ldw	r2,-28(fp)
81131c24:	10800b8b 	ldhu	r2,46(r2)
81131c28:	10bfffcc 	andi	r2,r2,65535
81131c2c:	1000061e 	bne	r2,zero,81131c48 <OSTimeDlyResume+0xe4>
81131c30:	e0bff717 	ldw	r2,-36(fp)
81131c34:	e0bffb15 	stw	r2,-20(fp)
81131c38:	e0bffb17 	ldw	r2,-20(fp)
81131c3c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
81131c40:	00801404 	movi	r2,80
81131c44:	00003906 	br	81131d2c <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
81131c48:	e0bff917 	ldw	r2,-28(fp)
81131c4c:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81131c50:	e0bff917 	ldw	r2,-28(fp)
81131c54:	10800c03 	ldbu	r2,48(r2)
81131c58:	10803fcc 	andi	r2,r2,255
81131c5c:	10800dcc 	andi	r2,r2,55
81131c60:	10000b26 	beq	r2,zero,81131c90 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
81131c64:	e0bff917 	ldw	r2,-28(fp)
81131c68:	10c00c03 	ldbu	r3,48(r2)
81131c6c:	00bff204 	movi	r2,-56
81131c70:	1884703a 	and	r2,r3,r2
81131c74:	1007883a 	mov	r3,r2
81131c78:	e0bff917 	ldw	r2,-28(fp)
81131c7c:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
81131c80:	e0bff917 	ldw	r2,-28(fp)
81131c84:	00c00044 	movi	r3,1
81131c88:	10c00c45 	stb	r3,49(r2)
81131c8c:	00000206 	br	81131c98 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
81131c90:	e0bff917 	ldw	r2,-28(fp)
81131c94:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
81131c98:	e0bff917 	ldw	r2,-28(fp)
81131c9c:	10800c03 	ldbu	r2,48(r2)
81131ca0:	10803fcc 	andi	r2,r2,255
81131ca4:	1080020c 	andi	r2,r2,8
81131ca8:	10001b1e 	bne	r2,zero,81131d18 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
81131cac:	e0bff917 	ldw	r2,-28(fp)
81131cb0:	10c00d83 	ldbu	r3,54(r2)
81131cb4:	d0a08203 	ldbu	r2,-32248(gp)
81131cb8:	1884b03a 	or	r2,r3,r2
81131cbc:	d0a08205 	stb	r2,-32248(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81131cc0:	e0bff917 	ldw	r2,-28(fp)
81131cc4:	10800d03 	ldbu	r2,52(r2)
81131cc8:	10c03fcc 	andi	r3,r2,255
81131ccc:	e0bff917 	ldw	r2,-28(fp)
81131cd0:	10800d03 	ldbu	r2,52(r2)
81131cd4:	11003fcc 	andi	r4,r2,255
81131cd8:	d0a08244 	addi	r2,gp,-32247
81131cdc:	2085883a 	add	r2,r4,r2
81131ce0:	11000003 	ldbu	r4,0(r2)
81131ce4:	e0bff917 	ldw	r2,-28(fp)
81131ce8:	10800d43 	ldbu	r2,53(r2)
81131cec:	2084b03a 	or	r2,r4,r2
81131cf0:	1009883a 	mov	r4,r2
81131cf4:	d0a08244 	addi	r2,gp,-32247
81131cf8:	1885883a 	add	r2,r3,r2
81131cfc:	11000005 	stb	r4,0(r2)
81131d00:	e0bff717 	ldw	r2,-36(fp)
81131d04:	e0bffc15 	stw	r2,-16(fp)
81131d08:	e0bffc17 	ldw	r2,-16(fp)
81131d0c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
81131d10:	112abb80 	call	8112abb8 <OS_Sched>
81131d14:	00000406 	br	81131d28 <OSTimeDlyResume+0x1c4>
81131d18:	e0bff717 	ldw	r2,-36(fp)
81131d1c:	e0bffd15 	stw	r2,-12(fp)
81131d20:	e0bffd17 	ldw	r2,-12(fp)
81131d24:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
81131d28:	0005883a 	mov	r2,zero
}
81131d2c:	e037883a 	mov	sp,fp
81131d30:	dfc00117 	ldw	ra,4(sp)
81131d34:	df000017 	ldw	fp,0(sp)
81131d38:	dec00204 	addi	sp,sp,8
81131d3c:	f800283a 	ret

81131d40 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
81131d40:	defffb04 	addi	sp,sp,-20
81131d44:	de00012e 	bgeu	sp,et,81131d4c <OSTimeGet+0xc>
81131d48:	003b68fa 	trap	3
81131d4c:	df000415 	stw	fp,16(sp)
81131d50:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81131d54:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131d58:	0005303a 	rdctl	r2,status
81131d5c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131d60:	e0fffe17 	ldw	r3,-8(fp)
81131d64:	00bfff84 	movi	r2,-2
81131d68:	1884703a 	and	r2,r3,r2
81131d6c:	1001703a 	wrctl	status,r2
  
  return context;
81131d70:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81131d74:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
81131d78:	d0a08817 	ldw	r2,-32224(gp)
81131d7c:	e0bffd15 	stw	r2,-12(fp)
81131d80:	e0bffc17 	ldw	r2,-16(fp)
81131d84:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131d88:	e0bfff17 	ldw	r2,-4(fp)
81131d8c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
81131d90:	e0bffd17 	ldw	r2,-12(fp)
}
81131d94:	e037883a 	mov	sp,fp
81131d98:	df000017 	ldw	fp,0(sp)
81131d9c:	dec00104 	addi	sp,sp,4
81131da0:	f800283a 	ret

81131da4 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
81131da4:	defffb04 	addi	sp,sp,-20
81131da8:	de00012e 	bgeu	sp,et,81131db0 <OSTimeSet+0xc>
81131dac:	003b68fa 	trap	3
81131db0:	df000415 	stw	fp,16(sp)
81131db4:	df000404 	addi	fp,sp,16
81131db8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81131dbc:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131dc0:	0005303a 	rdctl	r2,status
81131dc4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131dc8:	e0fffd17 	ldw	r3,-12(fp)
81131dcc:	00bfff84 	movi	r2,-2
81131dd0:	1884703a 	and	r2,r3,r2
81131dd4:	1001703a 	wrctl	status,r2
  
  return context;
81131dd8:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
81131ddc:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
81131de0:	e0bfff17 	ldw	r2,-4(fp)
81131de4:	d0a08815 	stw	r2,-32224(gp)
81131de8:	e0bffc17 	ldw	r2,-16(fp)
81131dec:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131df0:	e0bffe17 	ldw	r2,-8(fp)
81131df4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81131df8:	0001883a 	nop
81131dfc:	e037883a 	mov	sp,fp
81131e00:	df000017 	ldw	fp,0(sp)
81131e04:	dec00104 	addi	sp,sp,4
81131e08:	f800283a 	ret

81131e0c <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
81131e0c:	defff804 	addi	sp,sp,-32
81131e10:	de00012e 	bgeu	sp,et,81131e18 <OSTmrCreate+0xc>
81131e14:	003b68fa 	trap	3
81131e18:	dfc00715 	stw	ra,28(sp)
81131e1c:	df000615 	stw	fp,24(sp)
81131e20:	df000604 	addi	fp,sp,24
81131e24:	e13ffc15 	stw	r4,-16(fp)
81131e28:	e17ffd15 	stw	r5,-12(fp)
81131e2c:	3005883a 	mov	r2,r6
81131e30:	e1ffff15 	stw	r7,-4(fp)
81131e34:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81131e38:	e0800417 	ldw	r2,16(fp)
81131e3c:	1000021e 	bne	r2,zero,81131e48 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
81131e40:	0005883a 	mov	r2,zero
81131e44:	00005d06 	br	81131fbc <OSTmrCreate+0x1b0>
    }
    switch (opt) {
81131e48:	e0bffe03 	ldbu	r2,-8(fp)
81131e4c:	10c00060 	cmpeqi	r3,r2,1
81131e50:	1800091e 	bne	r3,zero,81131e78 <OSTmrCreate+0x6c>
81131e54:	108000a0 	cmpeqi	r2,r2,2
81131e58:	10000e26 	beq	r2,zero,81131e94 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
81131e5c:	e0bffd17 	ldw	r2,-12(fp)
81131e60:	1000111e 	bne	r2,zero,81131ea8 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
81131e64:	e0800417 	ldw	r2,16(fp)
81131e68:	00ffe0c4 	movi	r3,-125
81131e6c:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81131e70:	0005883a 	mov	r2,zero
81131e74:	00005106 	br	81131fbc <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
81131e78:	e0bffc17 	ldw	r2,-16(fp)
81131e7c:	10000c1e 	bne	r2,zero,81131eb0 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
81131e80:	e0800417 	ldw	r2,16(fp)
81131e84:	00ffe084 	movi	r3,-126
81131e88:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81131e8c:	0005883a 	mov	r2,zero
81131e90:	00004a06 	br	81131fbc <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
81131e94:	e0800417 	ldw	r2,16(fp)
81131e98:	00ffe104 	movi	r3,-124
81131e9c:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
81131ea0:	0005883a 	mov	r2,zero
81131ea4:	00004506 	br	81131fbc <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
81131ea8:	0001883a 	nop
81131eac:	00000106 	br	81131eb4 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
81131eb0:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81131eb4:	d0a08503 	ldbu	r2,-32236(gp)
81131eb8:	10803fcc 	andi	r2,r2,255
81131ebc:	10000526 	beq	r2,zero,81131ed4 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
81131ec0:	e0800417 	ldw	r2,16(fp)
81131ec4:	00ffe2c4 	movi	r3,-117
81131ec8:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81131ecc:	0005883a 	mov	r2,zero
81131ed0:	00003a06 	br	81131fbc <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
81131ed4:	1132dc40 	call	81132dc4 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
81131ed8:	11328640 	call	81132864 <OSTmr_Alloc>
81131edc:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
81131ee0:	e0bffa17 	ldw	r2,-24(fp)
81131ee4:	1000061e 	bne	r2,zero,81131f00 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
81131ee8:	1132e080 	call	81132e08 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
81131eec:	e0800417 	ldw	r2,16(fp)
81131ef0:	00ffe184 	movi	r3,-122
81131ef4:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81131ef8:	0005883a 	mov	r2,zero
81131efc:	00002f06 	br	81131fbc <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
81131f00:	e0bffa17 	ldw	r2,-24(fp)
81131f04:	00c00044 	movi	r3,1
81131f08:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81131f0c:	e0bffa17 	ldw	r2,-24(fp)
81131f10:	e0fffc17 	ldw	r3,-16(fp)
81131f14:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
81131f18:	e0bffa17 	ldw	r2,-24(fp)
81131f1c:	e0fffd17 	ldw	r3,-12(fp)
81131f20:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
81131f24:	e0bffa17 	ldw	r2,-24(fp)
81131f28:	e0fffe03 	ldbu	r3,-8(fp)
81131f2c:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
81131f30:	e0bffa17 	ldw	r2,-24(fp)
81131f34:	e0ffff17 	ldw	r3,-4(fp)
81131f38:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
81131f3c:	e0bffa17 	ldw	r2,-24(fp)
81131f40:	e0c00217 	ldw	r3,8(fp)
81131f44:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
81131f48:	e0800317 	ldw	r2,12(fp)
81131f4c:	10001726 	beq	r2,zero,81131fac <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
81131f50:	e1000317 	ldw	r4,12(fp)
81131f54:	112ad880 	call	8112ad88 <OS_StrLen>
81131f58:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
81131f5c:	e0bffb03 	ldbu	r2,-20(fp)
81131f60:	10800428 	cmpgeui	r2,r2,16
81131f64:	1000061e 	bne	r2,zero,81131f80 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
81131f68:	e0bffa17 	ldw	r2,-24(fp)
81131f6c:	10800804 	addi	r2,r2,32
81131f70:	e1400317 	ldw	r5,12(fp)
81131f74:	1009883a 	mov	r4,r2
81131f78:	112ad0c0 	call	8112ad0c <OS_StrCopy>
81131f7c:	00000b06 	br	81131fac <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
81131f80:	e0bffa17 	ldw	r2,-24(fp)
81131f84:	00c008c4 	movi	r3,35
81131f88:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
81131f8c:	e0bffa17 	ldw	r2,-24(fp)
81131f90:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
81131f94:	e0800417 	ldw	r2,16(fp)
81131f98:	00ffe304 	movi	r3,-116
81131f9c:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
81131fa0:	1132e080 	call	81132e08 <OSTmr_Unlock>
            return (ptmr);
81131fa4:	e0bffa17 	ldw	r2,-24(fp)
81131fa8:	00000406 	br	81131fbc <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81131fac:	1132e080 	call	81132e08 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
81131fb0:	e0800417 	ldw	r2,16(fp)
81131fb4:	10000005 	stb	zero,0(r2)
    return (ptmr);
81131fb8:	e0bffa17 	ldw	r2,-24(fp)
}
81131fbc:	e037883a 	mov	sp,fp
81131fc0:	dfc00117 	ldw	ra,4(sp)
81131fc4:	df000017 	ldw	fp,0(sp)
81131fc8:	dec00204 	addi	sp,sp,8
81131fcc:	f800283a 	ret

81131fd0 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
81131fd0:	defffc04 	addi	sp,sp,-16
81131fd4:	de00012e 	bgeu	sp,et,81131fdc <OSTmrDel+0xc>
81131fd8:	003b68fa 	trap	3
81131fdc:	dfc00315 	stw	ra,12(sp)
81131fe0:	df000215 	stw	fp,8(sp)
81131fe4:	df000204 	addi	fp,sp,8
81131fe8:	e13ffe15 	stw	r4,-8(fp)
81131fec:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81131ff0:	e0bfff17 	ldw	r2,-4(fp)
81131ff4:	1000021e 	bne	r2,zero,81132000 <OSTmrDel+0x30>
        return (OS_FALSE);
81131ff8:	0005883a 	mov	r2,zero
81131ffc:	00003f06 	br	811320fc <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81132000:	e0bffe17 	ldw	r2,-8(fp)
81132004:	1000051e 	bne	r2,zero,8113201c <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81132008:	e0bfff17 	ldw	r2,-4(fp)
8113200c:	00ffe284 	movi	r3,-118
81132010:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81132014:	0005883a 	mov	r2,zero
81132018:	00003806 	br	811320fc <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113201c:	e0bffe17 	ldw	r2,-8(fp)
81132020:	10800003 	ldbu	r2,0(r2)
81132024:	10803fcc 	andi	r2,r2,255
81132028:	10801920 	cmpeqi	r2,r2,100
8113202c:	1000051e 	bne	r2,zero,81132044 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81132030:	e0bfff17 	ldw	r2,-4(fp)
81132034:	00ffe244 	movi	r3,-119
81132038:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113203c:	0005883a 	mov	r2,zero
81132040:	00002e06 	br	811320fc <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81132044:	d0a08503 	ldbu	r2,-32236(gp)
81132048:	10803fcc 	andi	r2,r2,255
8113204c:	10000526 	beq	r2,zero,81132064 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
81132050:	e0bfff17 	ldw	r2,-4(fp)
81132054:	00ffe2c4 	movi	r3,-117
81132058:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113205c:	0005883a 	mov	r2,zero
81132060:	00002606 	br	811320fc <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
81132064:	1132dc40 	call	81132dc4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81132068:	e0bffe17 	ldw	r2,-8(fp)
8113206c:	10800c43 	ldbu	r2,49(r2)
81132070:	10803fcc 	andi	r2,r2,255
81132074:	10c000c8 	cmpgei	r3,r2,3
81132078:	1800031e 	bne	r3,zero,81132088 <OSTmrDel+0xb8>
8113207c:	00800d16 	blt	zero,r2,811320b4 <OSTmrDel+0xe4>
81132080:	10001326 	beq	r2,zero,811320d0 <OSTmrDel+0x100>
81132084:	00001806 	br	811320e8 <OSTmrDel+0x118>
81132088:	108000e0 	cmpeqi	r2,r2,3
8113208c:	10001626 	beq	r2,zero,811320e8 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
81132090:	e13ffe17 	ldw	r4,-8(fp)
81132094:	1132cc80 	call	81132cc8 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81132098:	e13ffe17 	ldw	r4,-8(fp)
8113209c:	11328d80 	call	811328d8 <OSTmr_Free>
             OSTmr_Unlock();
811320a0:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811320a4:	e0bfff17 	ldw	r2,-4(fp)
811320a8:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811320ac:	00800044 	movi	r2,1
811320b0:	00001206 	br	811320fc <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
811320b4:	e13ffe17 	ldw	r4,-8(fp)
811320b8:	11328d80 	call	811328d8 <OSTmr_Free>
             OSTmr_Unlock();
811320bc:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811320c0:	e0bfff17 	ldw	r2,-4(fp)
811320c4:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811320c8:	00800044 	movi	r2,1
811320cc:	00000b06 	br	811320fc <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
811320d0:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811320d4:	e0bfff17 	ldw	r2,-4(fp)
811320d8:	00ffe1c4 	movi	r3,-121
811320dc:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811320e0:	0005883a 	mov	r2,zero
811320e4:	00000506 	br	811320fc <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
811320e8:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811320ec:	e0bfff17 	ldw	r2,-4(fp)
811320f0:	00ffe344 	movi	r3,-115
811320f4:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811320f8:	0005883a 	mov	r2,zero
    }
}
811320fc:	e037883a 	mov	sp,fp
81132100:	dfc00117 	ldw	ra,4(sp)
81132104:	df000017 	ldw	fp,0(sp)
81132108:	dec00204 	addi	sp,sp,8
8113210c:	f800283a 	ret

81132110 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
81132110:	defffa04 	addi	sp,sp,-24
81132114:	de00012e 	bgeu	sp,et,8113211c <OSTmrNameGet+0xc>
81132118:	003b68fa 	trap	3
8113211c:	dfc00515 	stw	ra,20(sp)
81132120:	df000415 	stw	fp,16(sp)
81132124:	df000404 	addi	fp,sp,16
81132128:	e13ffd15 	stw	r4,-12(fp)
8113212c:	e17ffe15 	stw	r5,-8(fp)
81132130:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81132134:	e0bfff17 	ldw	r2,-4(fp)
81132138:	1000021e 	bne	r2,zero,81132144 <OSTmrNameGet+0x34>
        return (0);
8113213c:	0005883a 	mov	r2,zero
81132140:	00003e06 	br	8113223c <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
81132144:	e0bffe17 	ldw	r2,-8(fp)
81132148:	1000051e 	bne	r2,zero,81132160 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
8113214c:	e0bfff17 	ldw	r2,-4(fp)
81132150:	00ffe204 	movi	r3,-120
81132154:	10c00005 	stb	r3,0(r2)
        return (0);
81132158:	0005883a 	mov	r2,zero
8113215c:	00003706 	br	8113223c <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81132160:	e0bffd17 	ldw	r2,-12(fp)
81132164:	1000051e 	bne	r2,zero,8113217c <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
81132168:	e0bfff17 	ldw	r2,-4(fp)
8113216c:	00ffe284 	movi	r3,-118
81132170:	10c00005 	stb	r3,0(r2)
        return (0);
81132174:	0005883a 	mov	r2,zero
81132178:	00003006 	br	8113223c <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113217c:	e0bffd17 	ldw	r2,-12(fp)
81132180:	10800003 	ldbu	r2,0(r2)
81132184:	10803fcc 	andi	r2,r2,255
81132188:	10801920 	cmpeqi	r2,r2,100
8113218c:	1000051e 	bne	r2,zero,811321a4 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81132190:	e0bfff17 	ldw	r2,-4(fp)
81132194:	00ffe244 	movi	r3,-119
81132198:	10c00005 	stb	r3,0(r2)
        return (0);
8113219c:	0005883a 	mov	r2,zero
811321a0:	00002606 	br	8113223c <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
811321a4:	d0a08503 	ldbu	r2,-32236(gp)
811321a8:	10803fcc 	andi	r2,r2,255
811321ac:	10000526 	beq	r2,zero,811321c4 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
811321b0:	e0bfff17 	ldw	r2,-4(fp)
811321b4:	00c00444 	movi	r3,17
811321b8:	10c00005 	stb	r3,0(r2)
        return (0);
811321bc:	0005883a 	mov	r2,zero
811321c0:	00001e06 	br	8113223c <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
811321c4:	1132dc40 	call	81132dc4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811321c8:	e0bffd17 	ldw	r2,-12(fp)
811321cc:	10800c43 	ldbu	r2,49(r2)
811321d0:	10803fcc 	andi	r2,r2,255
811321d4:	10000e26 	beq	r2,zero,81132210 <OSTmrNameGet+0x100>
811321d8:	10001316 	blt	r2,zero,81132228 <OSTmrNameGet+0x118>
811321dc:	10800108 	cmpgei	r2,r2,4
811321e0:	1000111e 	bne	r2,zero,81132228 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
811321e4:	e0bffd17 	ldw	r2,-12(fp)
811321e8:	10800804 	addi	r2,r2,32
811321ec:	100b883a 	mov	r5,r2
811321f0:	e13ffe17 	ldw	r4,-8(fp)
811321f4:	112ad0c0 	call	8112ad0c <OS_StrCopy>
811321f8:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
811321fc:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81132200:	e0bfff17 	ldw	r2,-4(fp)
81132204:	10000005 	stb	zero,0(r2)
             return (len);
81132208:	e0bffc03 	ldbu	r2,-16(fp)
8113220c:	00000b06 	br	8113223c <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
81132210:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81132214:	e0bfff17 	ldw	r2,-4(fp)
81132218:	00ffe1c4 	movi	r3,-121
8113221c:	10c00005 	stb	r3,0(r2)
             return (0);
81132220:	0005883a 	mov	r2,zero
81132224:	00000506 	br	8113223c <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
81132228:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113222c:	e0bfff17 	ldw	r2,-4(fp)
81132230:	00ffe344 	movi	r3,-115
81132234:	10c00005 	stb	r3,0(r2)
             return (0);
81132238:	0005883a 	mov	r2,zero
    }
}
8113223c:	e037883a 	mov	sp,fp
81132240:	dfc00117 	ldw	ra,4(sp)
81132244:	df000017 	ldw	fp,0(sp)
81132248:	dec00204 	addi	sp,sp,8
8113224c:	f800283a 	ret

81132250 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
81132250:	defffb04 	addi	sp,sp,-20
81132254:	de00012e 	bgeu	sp,et,8113225c <OSTmrRemainGet+0xc>
81132258:	003b68fa 	trap	3
8113225c:	dfc00415 	stw	ra,16(sp)
81132260:	df000315 	stw	fp,12(sp)
81132264:	df000304 	addi	fp,sp,12
81132268:	e13ffe15 	stw	r4,-8(fp)
8113226c:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81132270:	e0bfff17 	ldw	r2,-4(fp)
81132274:	1000021e 	bne	r2,zero,81132280 <OSTmrRemainGet+0x30>
        return (0);
81132278:	0005883a 	mov	r2,zero
8113227c:	00005d06 	br	811323f4 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
81132280:	e0bffe17 	ldw	r2,-8(fp)
81132284:	1000051e 	bne	r2,zero,8113229c <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81132288:	e0bfff17 	ldw	r2,-4(fp)
8113228c:	00ffe284 	movi	r3,-118
81132290:	10c00005 	stb	r3,0(r2)
        return (0);
81132294:	0005883a 	mov	r2,zero
81132298:	00005606 	br	811323f4 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113229c:	e0bffe17 	ldw	r2,-8(fp)
811322a0:	10800003 	ldbu	r2,0(r2)
811322a4:	10803fcc 	andi	r2,r2,255
811322a8:	10801920 	cmpeqi	r2,r2,100
811322ac:	1000051e 	bne	r2,zero,811322c4 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811322b0:	e0bfff17 	ldw	r2,-4(fp)
811322b4:	00ffe244 	movi	r3,-119
811322b8:	10c00005 	stb	r3,0(r2)
        return (0);
811322bc:	0005883a 	mov	r2,zero
811322c0:	00004c06 	br	811323f4 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
811322c4:	d0a08503 	ldbu	r2,-32236(gp)
811322c8:	10803fcc 	andi	r2,r2,255
811322cc:	10000526 	beq	r2,zero,811322e4 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
811322d0:	e0bfff17 	ldw	r2,-4(fp)
811322d4:	00ffe2c4 	movi	r3,-117
811322d8:	10c00005 	stb	r3,0(r2)
        return (0);
811322dc:	0005883a 	mov	r2,zero
811322e0:	00004406 	br	811323f4 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
811322e4:	1132dc40 	call	81132dc4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811322e8:	e0bffe17 	ldw	r2,-8(fp)
811322ec:	10800c43 	ldbu	r2,49(r2)
811322f0:	10803fcc 	andi	r2,r2,255
811322f4:	10c00060 	cmpeqi	r3,r2,1
811322f8:	1800121e 	bne	r3,zero,81132344 <OSTmrRemainGet+0xf4>
811322fc:	10c00088 	cmpgei	r3,r2,2
81132300:	1800021e 	bne	r3,zero,8113230c <OSTmrRemainGet+0xbc>
81132304:	10003026 	beq	r2,zero,811323c8 <OSTmrRemainGet+0x178>
81132308:	00003506 	br	811323e0 <OSTmrRemainGet+0x190>
8113230c:	10c000a0 	cmpeqi	r3,r2,2
81132310:	1800281e 	bne	r3,zero,811323b4 <OSTmrRemainGet+0x164>
81132314:	108000e0 	cmpeqi	r2,r2,3
81132318:	10003126 	beq	r2,zero,811323e0 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
8113231c:	e0bffe17 	ldw	r2,-8(fp)
81132320:	10c00517 	ldw	r3,20(r2)
81132324:	d0a08717 	ldw	r2,-32228(gp)
81132328:	1885c83a 	sub	r2,r3,r2
8113232c:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
81132330:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
81132334:	e0bfff17 	ldw	r2,-4(fp)
81132338:	10000005 	stb	zero,0(r2)
             return (remain);
8113233c:	e0bffd17 	ldw	r2,-12(fp)
81132340:	00002c06 	br	811323f4 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
81132344:	e0bffe17 	ldw	r2,-8(fp)
81132348:	10800c03 	ldbu	r2,48(r2)
8113234c:	10803fcc 	andi	r2,r2,255
81132350:	108000a0 	cmpeqi	r2,r2,2
81132354:	10000e26 	beq	r2,zero,81132390 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
81132358:	e0bffe17 	ldw	r2,-8(fp)
8113235c:	10800617 	ldw	r2,24(r2)
81132360:	1000041e 	bne	r2,zero,81132374 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
81132364:	e0bffe17 	ldw	r2,-8(fp)
81132368:	10800717 	ldw	r2,28(r2)
8113236c:	e0bffd15 	stw	r2,-12(fp)
81132370:	00000306 	br	81132380 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
81132374:	e0bffe17 	ldw	r2,-8(fp)
81132378:	10800617 	ldw	r2,24(r2)
8113237c:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
81132380:	1132e080 	call	81132e08 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81132384:	e0bfff17 	ldw	r2,-4(fp)
81132388:	10000005 	stb	zero,0(r2)
                      break;
8113238c:	00000706 	br	811323ac <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
81132390:	e0bffe17 	ldw	r2,-8(fp)
81132394:	10800617 	ldw	r2,24(r2)
81132398:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
8113239c:	1132e080 	call	81132e08 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
811323a0:	e0bfff17 	ldw	r2,-4(fp)
811323a4:	10000005 	stb	zero,0(r2)
                      break;
811323a8:	0001883a 	nop
             }
             return (remain);
811323ac:	e0bffd17 	ldw	r2,-12(fp)
811323b0:	00001006 	br	811323f4 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
811323b4:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811323b8:	e0bfff17 	ldw	r2,-4(fp)
811323bc:	10000005 	stb	zero,0(r2)
             return (0);
811323c0:	0005883a 	mov	r2,zero
811323c4:	00000b06 	br	811323f4 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
811323c8:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811323cc:	e0bfff17 	ldw	r2,-4(fp)
811323d0:	00ffe1c4 	movi	r3,-121
811323d4:	10c00005 	stb	r3,0(r2)
             return (0);
811323d8:	0005883a 	mov	r2,zero
811323dc:	00000506 	br	811323f4 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
811323e0:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811323e4:	e0bfff17 	ldw	r2,-4(fp)
811323e8:	00ffe344 	movi	r3,-115
811323ec:	10c00005 	stb	r3,0(r2)
             return (0);
811323f0:	0005883a 	mov	r2,zero
    }
}
811323f4:	e037883a 	mov	sp,fp
811323f8:	dfc00117 	ldw	ra,4(sp)
811323fc:	df000017 	ldw	fp,0(sp)
81132400:	dec00204 	addi	sp,sp,8
81132404:	f800283a 	ret

81132408 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
81132408:	defffb04 	addi	sp,sp,-20
8113240c:	de00012e 	bgeu	sp,et,81132414 <OSTmrStateGet+0xc>
81132410:	003b68fa 	trap	3
81132414:	dfc00415 	stw	ra,16(sp)
81132418:	df000315 	stw	fp,12(sp)
8113241c:	df000304 	addi	fp,sp,12
81132420:	e13ffe15 	stw	r4,-8(fp)
81132424:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81132428:	e0bfff17 	ldw	r2,-4(fp)
8113242c:	1000021e 	bne	r2,zero,81132438 <OSTmrStateGet+0x30>
        return (0);
81132430:	0005883a 	mov	r2,zero
81132434:	00002a06 	br	811324e0 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
81132438:	e0bffe17 	ldw	r2,-8(fp)
8113243c:	1000051e 	bne	r2,zero,81132454 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81132440:	e0bfff17 	ldw	r2,-4(fp)
81132444:	00ffe284 	movi	r3,-118
81132448:	10c00005 	stb	r3,0(r2)
        return (0);
8113244c:	0005883a 	mov	r2,zero
81132450:	00002306 	br	811324e0 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81132454:	e0bffe17 	ldw	r2,-8(fp)
81132458:	10800003 	ldbu	r2,0(r2)
8113245c:	10803fcc 	andi	r2,r2,255
81132460:	10801920 	cmpeqi	r2,r2,100
81132464:	1000051e 	bne	r2,zero,8113247c <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81132468:	e0bfff17 	ldw	r2,-4(fp)
8113246c:	00ffe244 	movi	r3,-119
81132470:	10c00005 	stb	r3,0(r2)
        return (0);
81132474:	0005883a 	mov	r2,zero
81132478:	00001906 	br	811324e0 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113247c:	d0a08503 	ldbu	r2,-32236(gp)
81132480:	10803fcc 	andi	r2,r2,255
81132484:	10000526 	beq	r2,zero,8113249c <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81132488:	e0bfff17 	ldw	r2,-4(fp)
8113248c:	00ffe2c4 	movi	r3,-117
81132490:	10c00005 	stb	r3,0(r2)
        return (0);
81132494:	0005883a 	mov	r2,zero
81132498:	00001106 	br	811324e0 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
8113249c:	1132dc40 	call	81132dc4 <OSTmr_Lock>
    state = ptmr->OSTmrState;
811324a0:	e0bffe17 	ldw	r2,-8(fp)
811324a4:	10800c43 	ldbu	r2,49(r2)
811324a8:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
811324ac:	e0bffd03 	ldbu	r2,-12(fp)
811324b0:	1005883a 	mov	r2,r2
811324b4:	10800128 	cmpgeui	r2,r2,4
811324b8:	1000031e 	bne	r2,zero,811324c8 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
811324bc:	e0bfff17 	ldw	r2,-4(fp)
811324c0:	10000005 	stb	zero,0(r2)
             break;
811324c4:	00000406 	br	811324d8 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
811324c8:	e0bfff17 	ldw	r2,-4(fp)
811324cc:	00ffe344 	movi	r3,-115
811324d0:	10c00005 	stb	r3,0(r2)
             break;
811324d4:	0001883a 	nop
    }
    OSTmr_Unlock();
811324d8:	1132e080 	call	81132e08 <OSTmr_Unlock>
    return (state);
811324dc:	e0bffd03 	ldbu	r2,-12(fp)
}
811324e0:	e037883a 	mov	sp,fp
811324e4:	dfc00117 	ldw	ra,4(sp)
811324e8:	df000017 	ldw	fp,0(sp)
811324ec:	dec00204 	addi	sp,sp,8
811324f0:	f800283a 	ret

811324f4 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
811324f4:	defffc04 	addi	sp,sp,-16
811324f8:	de00012e 	bgeu	sp,et,81132500 <OSTmrStart+0xc>
811324fc:	003b68fa 	trap	3
81132500:	dfc00315 	stw	ra,12(sp)
81132504:	df000215 	stw	fp,8(sp)
81132508:	df000204 	addi	fp,sp,8
8113250c:	e13ffe15 	stw	r4,-8(fp)
81132510:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81132514:	e0bfff17 	ldw	r2,-4(fp)
81132518:	1000021e 	bne	r2,zero,81132524 <OSTmrStart+0x30>
        return (OS_FALSE);
8113251c:	0005883a 	mov	r2,zero
81132520:	00004106 	br	81132628 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
81132524:	e0bffe17 	ldw	r2,-8(fp)
81132528:	1000051e 	bne	r2,zero,81132540 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113252c:	e0bfff17 	ldw	r2,-4(fp)
81132530:	00ffe284 	movi	r3,-118
81132534:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81132538:	0005883a 	mov	r2,zero
8113253c:	00003a06 	br	81132628 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81132540:	e0bffe17 	ldw	r2,-8(fp)
81132544:	10800003 	ldbu	r2,0(r2)
81132548:	10803fcc 	andi	r2,r2,255
8113254c:	10801920 	cmpeqi	r2,r2,100
81132550:	1000051e 	bne	r2,zero,81132568 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81132554:	e0bfff17 	ldw	r2,-4(fp)
81132558:	00ffe244 	movi	r3,-119
8113255c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81132560:	0005883a 	mov	r2,zero
81132564:	00003006 	br	81132628 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81132568:	d0a08503 	ldbu	r2,-32236(gp)
8113256c:	10803fcc 	andi	r2,r2,255
81132570:	10000526 	beq	r2,zero,81132588 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
81132574:	e0bfff17 	ldw	r2,-4(fp)
81132578:	00ffe2c4 	movi	r3,-117
8113257c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81132580:	0005883a 	mov	r2,zero
81132584:	00002806 	br	81132628 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
81132588:	1132dc40 	call	81132dc4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113258c:	e0bffe17 	ldw	r2,-8(fp)
81132590:	10800c43 	ldbu	r2,49(r2)
81132594:	10803fcc 	andi	r2,r2,255
81132598:	10c000c8 	cmpgei	r3,r2,3
8113259c:	1800031e 	bne	r3,zero,811325ac <OSTmrStart+0xb8>
811325a0:	00800e16 	blt	zero,r2,811325dc <OSTmrStart+0xe8>
811325a4:	10001526 	beq	r2,zero,811325fc <OSTmrStart+0x108>
811325a8:	00001a06 	br	81132614 <OSTmrStart+0x120>
811325ac:	108000e0 	cmpeqi	r2,r2,3
811325b0:	10001826 	beq	r2,zero,81132614 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
811325b4:	e13ffe17 	ldw	r4,-8(fp)
811325b8:	1132cc80 	call	81132cc8 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
811325bc:	000b883a 	mov	r5,zero
811325c0:	e13ffe17 	ldw	r4,-8(fp)
811325c4:	1132b780 	call	81132b78 <OSTmr_Link>
             OSTmr_Unlock();
811325c8:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811325cc:	e0bfff17 	ldw	r2,-4(fp)
811325d0:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811325d4:	00800044 	movi	r2,1
811325d8:	00001306 	br	81132628 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
811325dc:	000b883a 	mov	r5,zero
811325e0:	e13ffe17 	ldw	r4,-8(fp)
811325e4:	1132b780 	call	81132b78 <OSTmr_Link>
             OSTmr_Unlock();
811325e8:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811325ec:	e0bfff17 	ldw	r2,-4(fp)
811325f0:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811325f4:	00800044 	movi	r2,1
811325f8:	00000b06 	br	81132628 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
811325fc:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81132600:	e0bfff17 	ldw	r2,-4(fp)
81132604:	00ffe1c4 	movi	r3,-121
81132608:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113260c:	0005883a 	mov	r2,zero
81132610:	00000506 	br	81132628 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
81132614:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81132618:	e0bfff17 	ldw	r2,-4(fp)
8113261c:	00ffe344 	movi	r3,-115
81132620:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81132624:	0005883a 	mov	r2,zero
    }
}
81132628:	e037883a 	mov	sp,fp
8113262c:	dfc00117 	ldw	ra,4(sp)
81132630:	df000017 	ldw	fp,0(sp)
81132634:	dec00204 	addi	sp,sp,8
81132638:	f800283a 	ret

8113263c <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
8113263c:	defff904 	addi	sp,sp,-28
81132640:	de00012e 	bgeu	sp,et,81132648 <OSTmrStop+0xc>
81132644:	003b68fa 	trap	3
81132648:	dfc00615 	stw	ra,24(sp)
8113264c:	df000515 	stw	fp,20(sp)
81132650:	df000504 	addi	fp,sp,20
81132654:	e13ffc15 	stw	r4,-16(fp)
81132658:	2805883a 	mov	r2,r5
8113265c:	e1bffe15 	stw	r6,-8(fp)
81132660:	e1ffff15 	stw	r7,-4(fp)
81132664:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
81132668:	e0bfff17 	ldw	r2,-4(fp)
8113266c:	1000021e 	bne	r2,zero,81132678 <OSTmrStop+0x3c>
        return (OS_FALSE);
81132670:	0005883a 	mov	r2,zero
81132674:	00006606 	br	81132810 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
81132678:	e0bffc17 	ldw	r2,-16(fp)
8113267c:	1000051e 	bne	r2,zero,81132694 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
81132680:	e0bfff17 	ldw	r2,-4(fp)
81132684:	00ffe284 	movi	r3,-118
81132688:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113268c:	0005883a 	mov	r2,zero
81132690:	00005f06 	br	81132810 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
81132694:	e0bffc17 	ldw	r2,-16(fp)
81132698:	10800003 	ldbu	r2,0(r2)
8113269c:	10803fcc 	andi	r2,r2,255
811326a0:	10801920 	cmpeqi	r2,r2,100
811326a4:	1000051e 	bne	r2,zero,811326bc <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811326a8:	e0bfff17 	ldw	r2,-4(fp)
811326ac:	00ffe244 	movi	r3,-119
811326b0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811326b4:	0005883a 	mov	r2,zero
811326b8:	00005506 	br	81132810 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
811326bc:	d0a08503 	ldbu	r2,-32236(gp)
811326c0:	10803fcc 	andi	r2,r2,255
811326c4:	10000526 	beq	r2,zero,811326dc <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
811326c8:	e0bfff17 	ldw	r2,-4(fp)
811326cc:	00ffe2c4 	movi	r3,-117
811326d0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811326d4:	0005883a 	mov	r2,zero
811326d8:	00004d06 	br	81132810 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
811326dc:	1132dc40 	call	81132dc4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811326e0:	e0bffc17 	ldw	r2,-16(fp)
811326e4:	10800c43 	ldbu	r2,49(r2)
811326e8:	10803fcc 	andi	r2,r2,255
811326ec:	10c000c8 	cmpgei	r3,r2,3
811326f0:	1800031e 	bne	r3,zero,81132700 <OSTmrStop+0xc4>
811326f4:	00803516 	blt	zero,r2,811327cc <OSTmrStop+0x190>
811326f8:	10003a26 	beq	r2,zero,811327e4 <OSTmrStop+0x1a8>
811326fc:	00003f06 	br	811327fc <OSTmrStop+0x1c0>
81132700:	108000e0 	cmpeqi	r2,r2,3
81132704:	10003d26 	beq	r2,zero,811327fc <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
81132708:	e13ffc17 	ldw	r4,-16(fp)
8113270c:	1132cc80 	call	81132cc8 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
81132710:	e0bfff17 	ldw	r2,-4(fp)
81132714:	10000005 	stb	zero,0(r2)
             switch (opt) {
81132718:	e0bffd03 	ldbu	r2,-12(fp)
8113271c:	10c000e0 	cmpeqi	r3,r2,3
81132720:	1800041e 	bne	r3,zero,81132734 <OSTmrStop+0xf8>
81132724:	10c00120 	cmpeqi	r3,r2,4
81132728:	1800121e 	bne	r3,zero,81132774 <OSTmrStop+0x138>
8113272c:	10002326 	beq	r2,zero,811327bc <OSTmrStop+0x180>
81132730:	00001e06 	br	811327ac <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81132734:	e0bffc17 	ldw	r2,-16(fp)
81132738:	10800117 	ldw	r2,4(r2)
8113273c:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81132740:	e0bffb17 	ldw	r2,-20(fp)
81132744:	10000726 	beq	r2,zero,81132764 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
81132748:	e0bffc17 	ldw	r2,-16(fp)
8113274c:	10c00217 	ldw	r3,8(r2)
81132750:	e0bffb17 	ldw	r2,-20(fp)
81132754:	180b883a 	mov	r5,r3
81132758:	e13ffc17 	ldw	r4,-16(fp)
8113275c:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81132760:	00001706 	br	811327c0 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81132764:	e0bfff17 	ldw	r2,-4(fp)
81132768:	00ffe3c4 	movi	r3,-113
8113276c:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81132770:	00001306 	br	811327c0 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81132774:	e0bffc17 	ldw	r2,-16(fp)
81132778:	10800117 	ldw	r2,4(r2)
8113277c:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81132780:	e0bffb17 	ldw	r2,-20(fp)
81132784:	10000526 	beq	r2,zero,8113279c <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
81132788:	e0bffb17 	ldw	r2,-20(fp)
8113278c:	e17ffe17 	ldw	r5,-8(fp)
81132790:	e13ffc17 	ldw	r4,-16(fp)
81132794:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81132798:	00000906 	br	811327c0 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113279c:	e0bfff17 	ldw	r2,-4(fp)
811327a0:	00ffe3c4 	movi	r3,-113
811327a4:	10c00005 	stb	r3,0(r2)
                      }
                      break;
811327a8:	00000506 	br	811327c0 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
811327ac:	e0bfff17 	ldw	r2,-4(fp)
811327b0:	00ffe104 	movi	r3,-124
811327b4:	10c00005 	stb	r3,0(r2)
                     break;
811327b8:	00000106 	br	811327c0 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
811327bc:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
811327c0:	1132e080 	call	81132e08 <OSTmr_Unlock>
             return (OS_TRUE);
811327c4:	00800044 	movi	r2,1
811327c8:	00001106 	br	81132810 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
811327cc:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
811327d0:	e0bfff17 	ldw	r2,-4(fp)
811327d4:	00ffe384 	movi	r3,-114
811327d8:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
811327dc:	00800044 	movi	r2,1
811327e0:	00000b06 	br	81132810 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
811327e4:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811327e8:	e0bfff17 	ldw	r2,-4(fp)
811327ec:	00ffe1c4 	movi	r3,-121
811327f0:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811327f4:	0005883a 	mov	r2,zero
811327f8:	00000506 	br	81132810 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
811327fc:	1132e080 	call	81132e08 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81132800:	e0bfff17 	ldw	r2,-4(fp)
81132804:	00ffe344 	movi	r3,-115
81132808:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113280c:	0005883a 	mov	r2,zero
    }
}
81132810:	e037883a 	mov	sp,fp
81132814:	dfc00117 	ldw	ra,4(sp)
81132818:	df000017 	ldw	fp,0(sp)
8113281c:	dec00204 	addi	sp,sp,8
81132820:	f800283a 	ret

81132824 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
81132824:	defffd04 	addi	sp,sp,-12
81132828:	de00012e 	bgeu	sp,et,81132830 <OSTmrSignal+0xc>
8113282c:	003b68fa 	trap	3
81132830:	dfc00215 	stw	ra,8(sp)
81132834:	df000115 	stw	fp,4(sp)
81132838:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
8113283c:	d0a07417 	ldw	r2,-32304(gp)
81132840:	1009883a 	mov	r4,r2
81132844:	112fdf00 	call	8112fdf0 <OSSemPost>
81132848:	e0bfff05 	stb	r2,-4(fp)
    return (err);
8113284c:	e0bfff03 	ldbu	r2,-4(fp)
}
81132850:	e037883a 	mov	sp,fp
81132854:	dfc00117 	ldw	ra,4(sp)
81132858:	df000017 	ldw	fp,0(sp)
8113285c:	dec00204 	addi	sp,sp,8
81132860:	f800283a 	ret

81132864 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
81132864:	defffe04 	addi	sp,sp,-8
81132868:	de00012e 	bgeu	sp,et,81132870 <OSTmr_Alloc+0xc>
8113286c:	003b68fa 	trap	3
81132870:	df000115 	stw	fp,4(sp)
81132874:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
81132878:	d0a07217 	ldw	r2,-32312(gp)
8113287c:	1000021e 	bne	r2,zero,81132888 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
81132880:	0005883a 	mov	r2,zero
81132884:	00001006 	br	811328c8 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
81132888:	d0a07217 	ldw	r2,-32312(gp)
8113288c:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
81132890:	e0bfff17 	ldw	r2,-4(fp)
81132894:	10800317 	ldw	r2,12(r2)
81132898:	d0a07215 	stw	r2,-32312(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8113289c:	e0bfff17 	ldw	r2,-4(fp)
811328a0:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
811328a4:	e0bfff17 	ldw	r2,-4(fp)
811328a8:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
811328ac:	d0a0770b 	ldhu	r2,-32292(gp)
811328b0:	10800044 	addi	r2,r2,1
811328b4:	d0a0770d 	sth	r2,-32292(gp)
    OSTmrFree--;
811328b8:	d0a07b0b 	ldhu	r2,-32276(gp)
811328bc:	10bfffc4 	addi	r2,r2,-1
811328c0:	d0a07b0d 	sth	r2,-32276(gp)
    return (ptmr);
811328c4:	e0bfff17 	ldw	r2,-4(fp)
}
811328c8:	e037883a 	mov	sp,fp
811328cc:	df000017 	ldw	fp,0(sp)
811328d0:	dec00104 	addi	sp,sp,4
811328d4:	f800283a 	ret

811328d8 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
811328d8:	defffe04 	addi	sp,sp,-8
811328dc:	de00012e 	bgeu	sp,et,811328e4 <OSTmr_Free+0xc>
811328e0:	003b68fa 	trap	3
811328e4:	df000115 	stw	fp,4(sp)
811328e8:	df000104 	addi	fp,sp,4
811328ec:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
811328f0:	e0bfff17 	ldw	r2,-4(fp)
811328f4:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
811328f8:	e0bfff17 	ldw	r2,-4(fp)
811328fc:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
81132900:	e0bfff17 	ldw	r2,-4(fp)
81132904:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
81132908:	e0bfff17 	ldw	r2,-4(fp)
8113290c:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
81132910:	e0bfff17 	ldw	r2,-4(fp)
81132914:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
81132918:	e0bfff17 	ldw	r2,-4(fp)
8113291c:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
81132920:	e0bfff17 	ldw	r2,-4(fp)
81132924:	00c00fc4 	movi	r3,63
81132928:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
8113292c:	e0bfff17 	ldw	r2,-4(fp)
81132930:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
81132934:	e0bfff17 	ldw	r2,-4(fp)
81132938:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
8113293c:	d0e07217 	ldw	r3,-32312(gp)
81132940:	e0bfff17 	ldw	r2,-4(fp)
81132944:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
81132948:	e0bfff17 	ldw	r2,-4(fp)
8113294c:	d0a07215 	stw	r2,-32312(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
81132950:	d0a0770b 	ldhu	r2,-32292(gp)
81132954:	10bfffc4 	addi	r2,r2,-1
81132958:	d0a0770d 	sth	r2,-32292(gp)
    OSTmrFree++;
8113295c:	d0a07b0b 	ldhu	r2,-32276(gp)
81132960:	10800044 	addi	r2,r2,1
81132964:	d0a07b0d 	sth	r2,-32276(gp)
}
81132968:	0001883a 	nop
8113296c:	e037883a 	mov	sp,fp
81132970:	df000017 	ldw	fp,0(sp)
81132974:	dec00104 	addi	sp,sp,4
81132978:	f800283a 	ret

8113297c <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
8113297c:	defffa04 	addi	sp,sp,-24
81132980:	de00012e 	bgeu	sp,et,81132988 <OSTmr_Init+0xc>
81132984:	003b68fa 	trap	3
81132988:	dfc00515 	stw	ra,20(sp)
8113298c:	df000415 	stw	fp,16(sp)
81132990:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
81132994:	01406804 	movi	r5,416
81132998:	01204574 	movhi	r4,33045
8113299c:	2103fb04 	addi	r4,r4,4076
811329a0:	112aaec0 	call	8112aaec <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
811329a4:	01400404 	movi	r5,16
811329a8:	01204574 	movhi	r4,33045
811329ac:	21031b04 	addi	r4,r4,3180
811329b0:	112aaec0 	call	8112aaec <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
811329b4:	00a04574 	movhi	r2,33045
811329b8:	1083fb04 	addi	r2,r2,4076
811329bc:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
811329c0:	00a04574 	movhi	r2,33045
811329c4:	10840804 	addi	r2,r2,4128
811329c8:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
811329cc:	e03ffc0d 	sth	zero,-16(fp)
811329d0:	00001606 	br	81132a2c <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
811329d4:	e0bffd17 	ldw	r2,-12(fp)
811329d8:	00c01904 	movi	r3,100
811329dc:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
811329e0:	e0bffd17 	ldw	r2,-12(fp)
811329e4:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
811329e8:	e0bffd17 	ldw	r2,-12(fp)
811329ec:	e0fffe17 	ldw	r3,-8(fp)
811329f0:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
811329f4:	e0bffd17 	ldw	r2,-12(fp)
811329f8:	00c00fc4 	movi	r3,63
811329fc:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81132a00:	e0bffd17 	ldw	r2,-12(fp)
81132a04:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
81132a08:	e0bffd17 	ldw	r2,-12(fp)
81132a0c:	10800d04 	addi	r2,r2,52
81132a10:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
81132a14:	e0bffe17 	ldw	r2,-8(fp)
81132a18:	10800d04 	addi	r2,r2,52
81132a1c:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81132a20:	e0bffc0b 	ldhu	r2,-16(fp)
81132a24:	10800044 	addi	r2,r2,1
81132a28:	e0bffc0d 	sth	r2,-16(fp)
81132a2c:	e0bffc0b 	ldhu	r2,-16(fp)
81132a30:	108001f0 	cmpltui	r2,r2,7
81132a34:	103fe71e 	bne	r2,zero,811329d4 <__reset+0xfb1129d4>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
81132a38:	e0bffd17 	ldw	r2,-12(fp)
81132a3c:	00c01904 	movi	r3,100
81132a40:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
81132a44:	e0bffd17 	ldw	r2,-12(fp)
81132a48:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
81132a4c:	e0bffd17 	ldw	r2,-12(fp)
81132a50:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
81132a54:	e0bffd17 	ldw	r2,-12(fp)
81132a58:	00c00fc4 	movi	r3,63
81132a5c:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81132a60:	e0bffd17 	ldw	r2,-12(fp)
81132a64:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
81132a68:	d0208715 	stw	zero,-32228(gp)
    OSTmrUsed           = 0;
81132a6c:	d020770d 	sth	zero,-32292(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
81132a70:	00800204 	movi	r2,8
81132a74:	d0a07b0d 	sth	r2,-32276(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
81132a78:	00a04574 	movhi	r2,33045
81132a7c:	1083fb04 	addi	r2,r2,4076
81132a80:	d0a07215 	stw	r2,-32312(gp)
    OSTmrSem            = OSSemCreate(1);
81132a84:	01000044 	movi	r4,1
81132a88:	112f7400 	call	8112f740 <OSSemCreate>
81132a8c:	d0a08915 	stw	r2,-32220(gp)
    OSTmrSemSignal      = OSSemCreate(0);
81132a90:	0009883a 	mov	r4,zero
81132a94:	112f7400 	call	8112f740 <OSSemCreate>
81132a98:	d0a07415 	stw	r2,-32304(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
81132a9c:	d0a08917 	ldw	r2,-32220(gp)
81132aa0:	e0ffff04 	addi	r3,fp,-4
81132aa4:	180d883a 	mov	r6,r3
81132aa8:	01604534 	movhi	r5,33044
81132aac:	297ed704 	addi	r5,r5,-1188
81132ab0:	1009883a 	mov	r4,r2
81132ab4:	11292c40 	call	811292c4 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
81132ab8:	d0a07417 	ldw	r2,-32304(gp)
81132abc:	e0ffff04 	addi	r3,fp,-4
81132ac0:	180d883a 	mov	r6,r3
81132ac4:	01604534 	movhi	r5,33044
81132ac8:	297edc04 	addi	r5,r5,-1168
81132acc:	1009883a 	mov	r4,r2
81132ad0:	11292c40 	call	811292c4 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
81132ad4:	1132af00 	call	81132af0 <OSTmr_InitTask>
}
81132ad8:	0001883a 	nop
81132adc:	e037883a 	mov	sp,fp
81132ae0:	dfc00117 	ldw	ra,4(sp)
81132ae4:	df000017 	ldw	fp,0(sp)
81132ae8:	dec00204 	addi	sp,sp,8
81132aec:	f800283a 	ret

81132af0 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
81132af0:	defff804 	addi	sp,sp,-32
81132af4:	de00012e 	bgeu	sp,et,81132afc <OSTmr_InitTask+0xc>
81132af8:	003b68fa 	trap	3
81132afc:	dfc00715 	stw	ra,28(sp)
81132b00:	df000615 	stw	fp,24(sp)
81132b04:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
81132b08:	008000c4 	movi	r2,3
81132b0c:	d8800415 	stw	r2,16(sp)
81132b10:	d8000315 	stw	zero,12(sp)
81132b14:	00808004 	movi	r2,512
81132b18:	d8800215 	stw	r2,8(sp)
81132b1c:	00a04574 	movhi	r2,33045
81132b20:	1089e704 	addi	r2,r2,10140
81132b24:	d8800115 	stw	r2,4(sp)
81132b28:	00bfff54 	movui	r2,65533
81132b2c:	d8800015 	stw	r2,0(sp)
81132b30:	01c00484 	movi	r7,18
81132b34:	01a04574 	movhi	r6,33045
81132b38:	318be604 	addi	r6,r6,12184
81132b3c:	000b883a 	mov	r5,zero
81132b40:	012044f4 	movhi	r4,33043
81132b44:	210b9104 	addi	r4,r4,11844
81132b48:	11307d40 	call	811307d4 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
81132b4c:	e1bfff04 	addi	r6,fp,-4
81132b50:	01604534 	movhi	r5,33044
81132b54:	297ee104 	addi	r5,r5,-1148
81132b58:	01000484 	movi	r4,18
81132b5c:	11310040 	call	81131004 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
81132b60:	0001883a 	nop
81132b64:	e037883a 	mov	sp,fp
81132b68:	dfc00117 	ldw	ra,4(sp)
81132b6c:	df000017 	ldw	fp,0(sp)
81132b70:	dec00204 	addi	sp,sp,8
81132b74:	f800283a 	ret

81132b78 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
81132b78:	defffa04 	addi	sp,sp,-24
81132b7c:	de00012e 	bgeu	sp,et,81132b84 <OSTmr_Link+0xc>
81132b80:	003b68fa 	trap	3
81132b84:	df000515 	stw	fp,20(sp)
81132b88:	df000504 	addi	fp,sp,20
81132b8c:	e13ffe15 	stw	r4,-8(fp)
81132b90:	2805883a 	mov	r2,r5
81132b94:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
81132b98:	e0bffe17 	ldw	r2,-8(fp)
81132b9c:	00c000c4 	movi	r3,3
81132ba0:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
81132ba4:	e0bfff03 	ldbu	r2,-4(fp)
81132ba8:	10800058 	cmpnei	r2,r2,1
81132bac:	1000071e 	bne	r2,zero,81132bcc <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81132bb0:	e0bffe17 	ldw	r2,-8(fp)
81132bb4:	10c00717 	ldw	r3,28(r2)
81132bb8:	d0a08717 	ldw	r2,-32228(gp)
81132bbc:	1887883a 	add	r3,r3,r2
81132bc0:	e0bffe17 	ldw	r2,-8(fp)
81132bc4:	10c00515 	stw	r3,20(r2)
81132bc8:	00001006 	br	81132c0c <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
81132bcc:	e0bffe17 	ldw	r2,-8(fp)
81132bd0:	10800617 	ldw	r2,24(r2)
81132bd4:	1000071e 	bne	r2,zero,81132bf4 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81132bd8:	e0bffe17 	ldw	r2,-8(fp)
81132bdc:	10c00717 	ldw	r3,28(r2)
81132be0:	d0a08717 	ldw	r2,-32228(gp)
81132be4:	1887883a 	add	r3,r3,r2
81132be8:	e0bffe17 	ldw	r2,-8(fp)
81132bec:	10c00515 	stw	r3,20(r2)
81132bf0:	00000606 	br	81132c0c <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
81132bf4:	e0bffe17 	ldw	r2,-8(fp)
81132bf8:	10c00617 	ldw	r3,24(r2)
81132bfc:	d0a08717 	ldw	r2,-32228(gp)
81132c00:	1887883a 	add	r3,r3,r2
81132c04:	e0bffe17 	ldw	r2,-8(fp)
81132c08:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81132c0c:	e0bffe17 	ldw	r2,-8(fp)
81132c10:	10800517 	ldw	r2,20(r2)
81132c14:	1080004c 	andi	r2,r2,1
81132c18:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81132c1c:	e0bffb0b 	ldhu	r2,-20(fp)
81132c20:	100690fa 	slli	r3,r2,3
81132c24:	00a04574 	movhi	r2,33045
81132c28:	10831b04 	addi	r2,r2,3180
81132c2c:	1885883a 	add	r2,r3,r2
81132c30:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
81132c34:	e0bffc17 	ldw	r2,-16(fp)
81132c38:	10800017 	ldw	r2,0(r2)
81132c3c:	1000091e 	bne	r2,zero,81132c64 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
81132c40:	e0bffc17 	ldw	r2,-16(fp)
81132c44:	e0fffe17 	ldw	r3,-8(fp)
81132c48:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
81132c4c:	e0bffe17 	ldw	r2,-8(fp)
81132c50:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
81132c54:	e0bffc17 	ldw	r2,-16(fp)
81132c58:	00c00044 	movi	r3,1
81132c5c:	10c0010d 	sth	r3,4(r2)
81132c60:	00001206 	br	81132cac <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
81132c64:	e0bffc17 	ldw	r2,-16(fp)
81132c68:	10800017 	ldw	r2,0(r2)
81132c6c:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
81132c70:	e0bffc17 	ldw	r2,-16(fp)
81132c74:	e0fffe17 	ldw	r3,-8(fp)
81132c78:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
81132c7c:	e0bffe17 	ldw	r2,-8(fp)
81132c80:	e0fffd17 	ldw	r3,-12(fp)
81132c84:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
81132c88:	e0bffd17 	ldw	r2,-12(fp)
81132c8c:	e0fffe17 	ldw	r3,-8(fp)
81132c90:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
81132c94:	e0bffc17 	ldw	r2,-16(fp)
81132c98:	1080010b 	ldhu	r2,4(r2)
81132c9c:	10800044 	addi	r2,r2,1
81132ca0:	1007883a 	mov	r3,r2
81132ca4:	e0bffc17 	ldw	r2,-16(fp)
81132ca8:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
81132cac:	e0bffe17 	ldw	r2,-8(fp)
81132cb0:	10000415 	stw	zero,16(r2)
}
81132cb4:	0001883a 	nop
81132cb8:	e037883a 	mov	sp,fp
81132cbc:	df000017 	ldw	fp,0(sp)
81132cc0:	dec00104 	addi	sp,sp,4
81132cc4:	f800283a 	ret

81132cc8 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
81132cc8:	defffa04 	addi	sp,sp,-24
81132ccc:	de00012e 	bgeu	sp,et,81132cd4 <OSTmr_Unlink+0xc>
81132cd0:	003b68fa 	trap	3
81132cd4:	df000515 	stw	fp,20(sp)
81132cd8:	df000504 	addi	fp,sp,20
81132cdc:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81132ce0:	e0bfff17 	ldw	r2,-4(fp)
81132ce4:	10800517 	ldw	r2,20(r2)
81132ce8:	1080004c 	andi	r2,r2,1
81132cec:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81132cf0:	e0bffb0b 	ldhu	r2,-20(fp)
81132cf4:	100690fa 	slli	r3,r2,3
81132cf8:	00a04574 	movhi	r2,33045
81132cfc:	10831b04 	addi	r2,r2,3180
81132d00:	1885883a 	add	r2,r3,r2
81132d04:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
81132d08:	e0bffc17 	ldw	r2,-16(fp)
81132d0c:	10c00017 	ldw	r3,0(r2)
81132d10:	e0bfff17 	ldw	r2,-4(fp)
81132d14:	18800b1e 	bne	r3,r2,81132d44 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
81132d18:	e0bfff17 	ldw	r2,-4(fp)
81132d1c:	10800317 	ldw	r2,12(r2)
81132d20:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
81132d24:	e0bffc17 	ldw	r2,-16(fp)
81132d28:	e0fffd17 	ldw	r3,-12(fp)
81132d2c:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
81132d30:	e0bffd17 	ldw	r2,-12(fp)
81132d34:	10001126 	beq	r2,zero,81132d7c <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
81132d38:	e0bffd17 	ldw	r2,-12(fp)
81132d3c:	10000415 	stw	zero,16(r2)
81132d40:	00000e06 	br	81132d7c <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
81132d44:	e0bfff17 	ldw	r2,-4(fp)
81132d48:	10800417 	ldw	r2,16(r2)
81132d4c:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
81132d50:	e0bfff17 	ldw	r2,-4(fp)
81132d54:	10800317 	ldw	r2,12(r2)
81132d58:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
81132d5c:	e0bffd17 	ldw	r2,-12(fp)
81132d60:	e0fffe17 	ldw	r3,-8(fp)
81132d64:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
81132d68:	e0bffe17 	ldw	r2,-8(fp)
81132d6c:	10000326 	beq	r2,zero,81132d7c <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
81132d70:	e0bffe17 	ldw	r2,-8(fp)
81132d74:	e0fffd17 	ldw	r3,-12(fp)
81132d78:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
81132d7c:	e0bfff17 	ldw	r2,-4(fp)
81132d80:	00c00044 	movi	r3,1
81132d84:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
81132d88:	e0bfff17 	ldw	r2,-4(fp)
81132d8c:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
81132d90:	e0bfff17 	ldw	r2,-4(fp)
81132d94:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
81132d98:	e0bffc17 	ldw	r2,-16(fp)
81132d9c:	1080010b 	ldhu	r2,4(r2)
81132da0:	10bfffc4 	addi	r2,r2,-1
81132da4:	1007883a 	mov	r3,r2
81132da8:	e0bffc17 	ldw	r2,-16(fp)
81132dac:	10c0010d 	sth	r3,4(r2)
}
81132db0:	0001883a 	nop
81132db4:	e037883a 	mov	sp,fp
81132db8:	df000017 	ldw	fp,0(sp)
81132dbc:	dec00104 	addi	sp,sp,4
81132dc0:	f800283a 	ret

81132dc4 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
81132dc4:	defffd04 	addi	sp,sp,-12
81132dc8:	de00012e 	bgeu	sp,et,81132dd0 <OSTmr_Lock+0xc>
81132dcc:	003b68fa 	trap	3
81132dd0:	dfc00215 	stw	ra,8(sp)
81132dd4:	df000115 	stw	fp,4(sp)
81132dd8:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
81132ddc:	d0a08917 	ldw	r2,-32220(gp)
81132de0:	e1bfff04 	addi	r6,fp,-4
81132de4:	000b883a 	mov	r5,zero
81132de8:	1009883a 	mov	r4,r2
81132dec:	112fa680 	call	8112fa68 <OSSemPend>
    (void)err;
}
81132df0:	0001883a 	nop
81132df4:	e037883a 	mov	sp,fp
81132df8:	dfc00117 	ldw	ra,4(sp)
81132dfc:	df000017 	ldw	fp,0(sp)
81132e00:	dec00204 	addi	sp,sp,8
81132e04:	f800283a 	ret

81132e08 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
81132e08:	defffe04 	addi	sp,sp,-8
81132e0c:	de00012e 	bgeu	sp,et,81132e14 <OSTmr_Unlock+0xc>
81132e10:	003b68fa 	trap	3
81132e14:	dfc00115 	stw	ra,4(sp)
81132e18:	df000015 	stw	fp,0(sp)
81132e1c:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
81132e20:	d0a08917 	ldw	r2,-32220(gp)
81132e24:	1009883a 	mov	r4,r2
81132e28:	112fdf00 	call	8112fdf0 <OSSemPost>
}
81132e2c:	0001883a 	nop
81132e30:	e037883a 	mov	sp,fp
81132e34:	dfc00117 	ldw	ra,4(sp)
81132e38:	df000017 	ldw	fp,0(sp)
81132e3c:	dec00204 	addi	sp,sp,8
81132e40:	f800283a 	ret

81132e44 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
81132e44:	defff704 	addi	sp,sp,-36
81132e48:	de00012e 	bgeu	sp,et,81132e50 <OSTmr_Task+0xc>
81132e4c:	003b68fa 	trap	3
81132e50:	dfc00815 	stw	ra,32(sp)
81132e54:	df000715 	stw	fp,28(sp)
81132e58:	df000704 	addi	fp,sp,28
81132e5c:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
81132e60:	d0a07417 	ldw	r2,-32304(gp)
81132e64:	e0fffe04 	addi	r3,fp,-8
81132e68:	180d883a 	mov	r6,r3
81132e6c:	000b883a 	mov	r5,zero
81132e70:	1009883a 	mov	r4,r2
81132e74:	112fa680 	call	8112fa68 <OSSemPend>
        OSTmr_Lock();
81132e78:	1132dc40 	call	81132dc4 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
81132e7c:	d0a08717 	ldw	r2,-32228(gp)
81132e80:	10800044 	addi	r2,r2,1
81132e84:	d0a08715 	stw	r2,-32228(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
81132e88:	d0a08717 	ldw	r2,-32228(gp)
81132e8c:	1080004c 	andi	r2,r2,1
81132e90:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
81132e94:	e0bffa0b 	ldhu	r2,-24(fp)
81132e98:	100690fa 	slli	r3,r2,3
81132e9c:	00a04574 	movhi	r2,33045
81132ea0:	10831b04 	addi	r2,r2,3180
81132ea4:	1885883a 	add	r2,r3,r2
81132ea8:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
81132eac:	e0bffb17 	ldw	r2,-20(fp)
81132eb0:	10800017 	ldw	r2,0(r2)
81132eb4:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
81132eb8:	00002206 	br	81132f44 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81132ebc:	e0bff917 	ldw	r2,-28(fp)
81132ec0:	10800317 	ldw	r2,12(r2)
81132ec4:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
81132ec8:	e0bff917 	ldw	r2,-28(fp)
81132ecc:	10c00517 	ldw	r3,20(r2)
81132ed0:	d0a08717 	ldw	r2,-32228(gp)
81132ed4:	1880191e 	bne	r3,r2,81132f3c <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
81132ed8:	e0bff917 	ldw	r2,-28(fp)
81132edc:	10800117 	ldw	r2,4(r2)
81132ee0:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
81132ee4:	e0bffd17 	ldw	r2,-12(fp)
81132ee8:	10000626 	beq	r2,zero,81132f04 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
81132eec:	e0bff917 	ldw	r2,-28(fp)
81132ef0:	10c00217 	ldw	r3,8(r2)
81132ef4:	e0bffd17 	ldw	r2,-12(fp)
81132ef8:	180b883a 	mov	r5,r3
81132efc:	e13ff917 	ldw	r4,-28(fp)
81132f00:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
81132f04:	e13ff917 	ldw	r4,-28(fp)
81132f08:	1132cc80 	call	81132cc8 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
81132f0c:	e0bff917 	ldw	r2,-28(fp)
81132f10:	10800c03 	ldbu	r2,48(r2)
81132f14:	10803fcc 	andi	r2,r2,255
81132f18:	10800098 	cmpnei	r2,r2,2
81132f1c:	1000041e 	bne	r2,zero,81132f30 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
81132f20:	01400044 	movi	r5,1
81132f24:	e13ff917 	ldw	r4,-28(fp)
81132f28:	1132b780 	call	81132b78 <OSTmr_Link>
81132f2c:	00000306 	br	81132f3c <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
81132f30:	e0bff917 	ldw	r2,-28(fp)
81132f34:	00c00084 	movi	r3,2
81132f38:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
81132f3c:	e0bffc17 	ldw	r2,-16(fp)
81132f40:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
81132f44:	e0bff917 	ldw	r2,-28(fp)
81132f48:	103fdc1e 	bne	r2,zero,81132ebc <__reset+0xfb112ebc>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
81132f4c:	1132e080 	call	81132e08 <OSTmr_Unlock>
    }
81132f50:	003fc306 	br	81132e60 <__reset+0xfb112e60>

81132f54 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
81132f54:	defffd04 	addi	sp,sp,-12
81132f58:	de00012e 	bgeu	sp,et,81132f60 <alt_dev_reg+0xc>
81132f5c:	003b68fa 	trap	3
81132f60:	dfc00215 	stw	ra,8(sp)
81132f64:	df000115 	stw	fp,4(sp)
81132f68:	df000104 	addi	fp,sp,4
81132f6c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
81132f70:	d1600d04 	addi	r5,gp,-32716
81132f74:	e13fff17 	ldw	r4,-4(fp)
81132f78:	113b1600 	call	8113b160 <alt_dev_llist_insert>
}
81132f7c:	e037883a 	mov	sp,fp
81132f80:	dfc00117 	ldw	ra,4(sp)
81132f84:	df000017 	ldw	fp,0(sp)
81132f88:	dec00204 	addi	sp,sp,8
81132f8c:	f800283a 	ret

81132f90 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
81132f90:	defffd04 	addi	sp,sp,-12
81132f94:	de00012e 	bgeu	sp,et,81132f9c <alt_irq_init+0xc>
81132f98:	003b68fa 	trap	3
81132f9c:	dfc00215 	stw	ra,8(sp)
81132fa0:	df000115 	stw	fp,4(sp)
81132fa4:	df000104 	addi	fp,sp,4
81132fa8:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
81132fac:	113bbf80 	call	8113bbf8 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
81132fb0:	00800044 	movi	r2,1
81132fb4:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
81132fb8:	0001883a 	nop
81132fbc:	e037883a 	mov	sp,fp
81132fc0:	dfc00117 	ldw	ra,4(sp)
81132fc4:	df000017 	ldw	fp,0(sp)
81132fc8:	dec00204 	addi	sp,sp,8
81132fcc:	f800283a 	ret

81132fd0 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
81132fd0:	defffe04 	addi	sp,sp,-8
81132fd4:	de00012e 	bgeu	sp,et,81132fdc <alt_sys_init+0xc>
81132fd8:	003b68fa 	trap	3
81132fdc:	dfc00115 	stw	ra,4(sp)
81132fe0:	df000015 	stw	fp,0(sp)
81132fe4:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
81132fe8:	01c0fa04 	movi	r7,1000
81132fec:	01800304 	movi	r6,12
81132ff0:	000b883a 	mov	r5,zero
81132ff4:	01200034 	movhi	r4,32768
81132ff8:	21022004 	addi	r4,r4,2176
81132ffc:	11382940 	call	81138294 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
81133000:	018002c4 	movi	r6,11
81133004:	000b883a 	mov	r5,zero
81133008:	01204534 	movhi	r4,33044
8113300c:	21022304 	addi	r4,r4,2188
81133010:	11376140 	call	81137614 <altera_avalon_jtag_uart_init>
81133014:	01204534 	movhi	r4,33044
81133018:	21021904 	addi	r4,r4,2148
8113301c:	1132f540 	call	81132f54 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
81133020:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
81133024:	018003c4 	movi	r6,15
81133028:	000b883a 	mov	r5,zero
8113302c:	01204534 	movhi	r4,33044
81133030:	21063e04 	addi	r4,r4,6392
81133034:	11384400 	call	81138440 <altera_avalon_uart_init>
81133038:	01204534 	movhi	r4,33044
8113303c:	21063404 	addi	r4,r4,6352
81133040:	1132f540 	call	81132f54 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
81133044:	00a04534 	movhi	r2,33044
81133048:	10866804 	addi	r2,r2,6560
8113304c:	10c00717 	ldw	r3,28(r2)
81133050:	00a04534 	movhi	r2,33044
81133054:	10866804 	addi	r2,r2,6560
81133058:	10800817 	ldw	r2,32(r2)
8113305c:	100d883a 	mov	r6,r2
81133060:	180b883a 	mov	r5,r3
81133064:	01204534 	movhi	r4,33044
81133068:	21066804 	addi	r4,r4,6560
8113306c:	113acc80 	call	8113acc8 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
81133070:	00a04534 	movhi	r2,33044
81133074:	10868104 	addi	r2,r2,6660
81133078:	10c00717 	ldw	r3,28(r2)
8113307c:	00a04534 	movhi	r2,33044
81133080:	10868104 	addi	r2,r2,6660
81133084:	10800817 	ldw	r2,32(r2)
81133088:	100d883a 	mov	r6,r2
8113308c:	180b883a 	mov	r5,r3
81133090:	01204534 	movhi	r4,33044
81133094:	21068104 	addi	r4,r4,6660
81133098:	113acc80 	call	8113acc8 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8113309c:	01204534 	movhi	r4,33044
811330a0:	21069a04 	addi	r4,r4,6760
811330a4:	1132f540 	call	81132f54 <alt_dev_reg>
}
811330a8:	0001883a 	nop
811330ac:	e037883a 	mov	sp,fp
811330b0:	dfc00117 	ldw	ra,4(sp)
811330b4:	df000017 	ldw	fp,0(sp)
811330b8:	dec00204 	addi	sp,sp,8
811330bc:	f800283a 	ret

811330c0 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
811330c0:	defffa04 	addi	sp,sp,-24
811330c4:	de00012e 	bgeu	sp,et,811330cc <Write_Sector_Data+0xc>
811330c8:	003b68fa 	trap	3
811330cc:	dfc00515 	stw	ra,20(sp)
811330d0:	df000415 	stw	fp,16(sp)
811330d4:	df000404 	addi	fp,sp,16
811330d8:	e13ffe15 	stw	r4,-8(fp)
811330dc:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
811330e0:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
811330e4:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
811330e8:	10001e26 	beq	r2,zero,81133164 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
811330ec:	00803fc4 	movi	r2,255
811330f0:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
811330f4:	d0a09317 	ldw	r2,-32180(gp)
811330f8:	e13ffe17 	ldw	r4,-8(fp)
811330fc:	e0ffff17 	ldw	r3,-4(fp)
81133100:	20c7883a 	add	r3,r4,r3
81133104:	1806927a 	slli	r3,r3,9
81133108:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
8113310c:	d0a09217 	ldw	r2,-32184(gp)
81133110:	00c00604 	movi	r3,24
81133114:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81133118:	d0a08f17 	ldw	r2,-32196(gp)
8113311c:	1080002b 	ldhuio	r2,0(r2)
81133120:	10bfffcc 	andi	r2,r2,65535
81133124:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
81133128:	e0bffd0b 	ldhu	r2,-12(fp)
8113312c:	10bfffcc 	andi	r2,r2,65535
81133130:	1080010c 	andi	r2,r2,4
81133134:	103ff81e 	bne	r2,zero,81133118 <__reset+0xfb113118>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
81133138:	e0bffd0b 	ldhu	r2,-12(fp)
8113313c:	10bfffcc 	andi	r2,r2,65535
81133140:	1080040c 	andi	r2,r2,16
81133144:	1000071e 	bne	r2,zero,81133164 <Write_Sector_Data+0xa4>
        {
            result = true;
81133148:	00800044 	movi	r2,1
8113314c:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81133150:	d0209815 	stw	zero,-32160(gp)
            current_sector_index = sector_index+partition_offset;
81133154:	e0fffe17 	ldw	r3,-8(fp)
81133158:	e0bfff17 	ldw	r2,-4(fp)
8113315c:	1885883a 	add	r2,r3,r2
81133160:	d0a09915 	stw	r2,-32156(gp)
        }
    }
    return result;
81133164:	e0bffc17 	ldw	r2,-16(fp)
}
81133168:	e037883a 	mov	sp,fp
8113316c:	dfc00117 	ldw	ra,4(sp)
81133170:	df000017 	ldw	fp,0(sp)
81133174:	dec00204 	addi	sp,sp,8
81133178:	f800283a 	ret

8113317c <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8113317c:	defffd04 	addi	sp,sp,-12
81133180:	de00012e 	bgeu	sp,et,81133188 <Save_Modified_Sector+0xc>
81133184:	003b68fa 	trap	3
81133188:	dfc00215 	stw	ra,8(sp)
8113318c:	df000115 	stw	fp,4(sp)
81133190:	df000104 	addi	fp,sp,4
    bool result = true;
81133194:	00800044 	movi	r2,1
81133198:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8113319c:	d0a09817 	ldw	r2,-32160(gp)
811331a0:	10000526 	beq	r2,zero,811331b8 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
811331a4:	d0a09917 	ldw	r2,-32156(gp)
811331a8:	000b883a 	mov	r5,zero
811331ac:	1009883a 	mov	r4,r2
811331b0:	11330c00 	call	811330c0 <Write_Sector_Data>
811331b4:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
811331b8:	e0bfff17 	ldw	r2,-4(fp)
}
811331bc:	e037883a 	mov	sp,fp
811331c0:	dfc00117 	ldw	ra,4(sp)
811331c4:	df000017 	ldw	fp,0(sp)
811331c8:	dec00204 	addi	sp,sp,8
811331cc:	f800283a 	ret

811331d0 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
811331d0:	defffa04 	addi	sp,sp,-24
811331d4:	de00012e 	bgeu	sp,et,811331dc <Read_Sector_Data+0xc>
811331d8:	003b68fa 	trap	3
811331dc:	dfc00515 	stw	ra,20(sp)
811331e0:	df000415 	stw	fp,16(sp)
811331e4:	df000404 	addi	fp,sp,16
811331e8:	e13ffe15 	stw	r4,-8(fp)
811331ec:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
811331f0:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
811331f4:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
811331f8:	10002726 	beq	r2,zero,81133298 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
811331fc:	00803fc4 	movi	r2,255
81133200:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
81133204:	d0a09817 	ldw	r2,-32160(gp)
81133208:	10000726 	beq	r2,zero,81133228 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
8113320c:	d0a09917 	ldw	r2,-32156(gp)
81133210:	000b883a 	mov	r5,zero
81133214:	1009883a 	mov	r4,r2
81133218:	11330c00 	call	811330c0 <Write_Sector_Data>
8113321c:	1000021e 	bne	r2,zero,81133228 <Read_Sector_Data+0x58>
            {
                return false;
81133220:	0005883a 	mov	r2,zero
81133224:	00001d06 	br	8113329c <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81133228:	d0a09317 	ldw	r2,-32180(gp)
8113322c:	e13ffe17 	ldw	r4,-8(fp)
81133230:	e0ffff17 	ldw	r3,-4(fp)
81133234:	20c7883a 	add	r3,r4,r3
81133238:	1806927a 	slli	r3,r3,9
8113323c:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
81133240:	d0a09217 	ldw	r2,-32184(gp)
81133244:	00c00444 	movi	r3,17
81133248:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113324c:	d0a08f17 	ldw	r2,-32196(gp)
81133250:	1080002b 	ldhuio	r2,0(r2)
81133254:	10bfffcc 	andi	r2,r2,65535
81133258:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8113325c:	e0bffd0b 	ldhu	r2,-12(fp)
81133260:	10bfffcc 	andi	r2,r2,65535
81133264:	1080010c 	andi	r2,r2,4
81133268:	103ff81e 	bne	r2,zero,8113324c <__reset+0xfb11324c>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8113326c:	e0bffd0b 	ldhu	r2,-12(fp)
81133270:	10bfffcc 	andi	r2,r2,65535
81133274:	1080040c 	andi	r2,r2,16
81133278:	1000071e 	bne	r2,zero,81133298 <Read_Sector_Data+0xc8>
		{
			result = true;
8113327c:	00800044 	movi	r2,1
81133280:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81133284:	d0209815 	stw	zero,-32160(gp)
            current_sector_index = sector_index+partition_offset;
81133288:	e0fffe17 	ldw	r3,-8(fp)
8113328c:	e0bfff17 	ldw	r2,-4(fp)
81133290:	1885883a 	add	r2,r3,r2
81133294:	d0a09915 	stw	r2,-32156(gp)
		}
	}
	return result;
81133298:	e0bffc17 	ldw	r2,-16(fp)
}
8113329c:	e037883a 	mov	sp,fp
811332a0:	dfc00117 	ldw	ra,4(sp)
811332a4:	df000017 	ldw	fp,0(sp)
811332a8:	dec00204 	addi	sp,sp,8
811332ac:	f800283a 	ret

811332b0 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
811332b0:	defffb04 	addi	sp,sp,-20
811332b4:	de00012e 	bgeu	sp,et,811332bc <get_cluster_flag+0xc>
811332b8:	003b68fa 	trap	3
811332bc:	dfc00415 	stw	ra,16(sp)
811332c0:	df000315 	stw	fp,12(sp)
811332c4:	df000304 	addi	fp,sp,12
811332c8:	e13ffe15 	stw	r4,-8(fp)
811332cc:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
811332d0:	e0bffe17 	ldw	r2,-8(fp)
811332d4:	1004d23a 	srli	r2,r2,8
811332d8:	d0e09517 	ldw	r3,-32172(gp)
811332dc:	10c5883a 	add	r2,r2,r3
811332e0:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
811332e4:	00a04574 	movhi	r2,33045
811332e8:	1094b704 	addi	r2,r2,21212
811332ec:	10801117 	ldw	r2,68(r2)
811332f0:	e0fffd17 	ldw	r3,-12(fp)
811332f4:	1885883a 	add	r2,r3,r2
811332f8:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
811332fc:	d0a09917 	ldw	r2,-32156(gp)
81133300:	e0fffd17 	ldw	r3,-12(fp)
81133304:	18800726 	beq	r3,r2,81133324 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
81133308:	e0bffd17 	ldw	r2,-12(fp)
8113330c:	000b883a 	mov	r5,zero
81133310:	1009883a 	mov	r4,r2
81133314:	11331d00 	call	811331d0 <Read_Sector_Data>
81133318:	1000021e 	bne	r2,zero,81133324 <get_cluster_flag+0x74>
        {
            return false;
8113331c:	0005883a 	mov	r2,zero
81133320:	00000d06 	br	81133358 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
81133324:	e0bffe17 	ldw	r2,-8(fp)
81133328:	10803fcc 	andi	r2,r2,255
8113332c:	1085883a 	add	r2,r2,r2
81133330:	1007883a 	mov	r3,r2
81133334:	d0a09717 	ldw	r2,-32164(gp)
81133338:	10800a17 	ldw	r2,40(r2)
8113333c:	1885883a 	add	r2,r3,r2
81133340:	1080002b 	ldhuio	r2,0(r2)
81133344:	10bfffcc 	andi	r2,r2,65535
81133348:	1007883a 	mov	r3,r2
8113334c:	e0bfff17 	ldw	r2,-4(fp)
81133350:	10c0000d 	sth	r3,0(r2)
    return true;
81133354:	00800044 	movi	r2,1
}
81133358:	e037883a 	mov	sp,fp
8113335c:	dfc00117 	ldw	ra,4(sp)
81133360:	df000017 	ldw	fp,0(sp)
81133364:	dec00204 	addi	sp,sp,8
81133368:	f800283a 	ret

8113336c <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8113336c:	defffa04 	addi	sp,sp,-24
81133370:	de00012e 	bgeu	sp,et,81133378 <mark_cluster+0xc>
81133374:	003b68fa 	trap	3
81133378:	dfc00515 	stw	ra,20(sp)
8113337c:	df000415 	stw	fp,16(sp)
81133380:	df000404 	addi	fp,sp,16
81133384:	e13ffd15 	stw	r4,-12(fp)
81133388:	2805883a 	mov	r2,r5
8113338c:	e1bfff15 	stw	r6,-4(fp)
81133390:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
81133394:	e0bffd17 	ldw	r2,-12(fp)
81133398:	1004d23a 	srli	r2,r2,8
8113339c:	d0e09517 	ldw	r3,-32172(gp)
811333a0:	10c5883a 	add	r2,r2,r3
811333a4:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
811333a8:	e0bfff17 	ldw	r2,-4(fp)
811333ac:	10000726 	beq	r2,zero,811333cc <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
811333b0:	00a04574 	movhi	r2,33045
811333b4:	1094b704 	addi	r2,r2,21212
811333b8:	10801117 	ldw	r2,68(r2)
811333bc:	e0fffc17 	ldw	r3,-16(fp)
811333c0:	1885883a 	add	r2,r3,r2
811333c4:	e0bffc15 	stw	r2,-16(fp)
811333c8:	00000606 	br	811333e4 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
811333cc:	00a04574 	movhi	r2,33045
811333d0:	1094b704 	addi	r2,r2,21212
811333d4:	10801217 	ldw	r2,72(r2)
811333d8:	e0fffc17 	ldw	r3,-16(fp)
811333dc:	1885883a 	add	r2,r3,r2
811333e0:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
811333e4:	d0a09917 	ldw	r2,-32156(gp)
811333e8:	e0fffc17 	ldw	r3,-16(fp)
811333ec:	18800726 	beq	r3,r2,8113340c <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811333f0:	e0bffc17 	ldw	r2,-16(fp)
811333f4:	000b883a 	mov	r5,zero
811333f8:	1009883a 	mov	r4,r2
811333fc:	11331d00 	call	811331d0 <Read_Sector_Data>
81133400:	1000021e 	bne	r2,zero,8113340c <mark_cluster+0xa0>
        {
            return false;
81133404:	0005883a 	mov	r2,zero
81133408:	00000d06 	br	81133440 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
8113340c:	e0bffd17 	ldw	r2,-12(fp)
81133410:	10803fcc 	andi	r2,r2,255
81133414:	1085883a 	add	r2,r2,r2
81133418:	1007883a 	mov	r3,r2
8113341c:	d0a09717 	ldw	r2,-32164(gp)
81133420:	10800a17 	ldw	r2,40(r2)
81133424:	1885883a 	add	r2,r3,r2
81133428:	1007883a 	mov	r3,r2
8113342c:	e0bffe0f 	ldh	r2,-8(fp)
81133430:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
81133434:	00800044 	movi	r2,1
81133438:	d0a09815 	stw	r2,-32160(gp)
    return true;
8113343c:	00800044 	movi	r2,1
}
81133440:	e037883a 	mov	sp,fp
81133444:	dfc00117 	ldw	ra,4(sp)
81133448:	df000017 	ldw	fp,0(sp)
8113344c:	dec00204 	addi	sp,sp,8
81133450:	f800283a 	ret

81133454 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
81133454:	defff704 	addi	sp,sp,-36
81133458:	de00012e 	bgeu	sp,et,81133460 <Check_for_Master_Boot_Record+0xc>
8113345c:	003b68fa 	trap	3
81133460:	dfc00815 	stw	ra,32(sp)
81133464:	df000715 	stw	fp,28(sp)
81133468:	df000704 	addi	fp,sp,28
	bool result = false;
8113346c:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
81133470:	000b883a 	mov	r5,zero
81133474:	0009883a 	mov	r4,zero
81133478:	11331d00 	call	811331d0 <Read_Sector_Data>
8113347c:	10005a26 	beq	r2,zero,811335e8 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
81133480:	d0a09717 	ldw	r2,-32164(gp)
81133484:	10800a17 	ldw	r2,40(r2)
81133488:	10807f84 	addi	r2,r2,510
8113348c:	1080002b 	ldhuio	r2,0(r2)
81133490:	10bfffcc 	andi	r2,r2,65535
81133494:	10bfffcc 	andi	r2,r2,65535
81133498:	10a0001c 	xori	r2,r2,32768
8113349c:	10a00004 	addi	r2,r2,-32768
811334a0:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
811334a4:	e0bffb17 	ldw	r2,-20(fp)
811334a8:	10ffffcc 	andi	r3,r2,65535
811334ac:	00aa9554 	movui	r2,43605
811334b0:	18804d1e 	bne	r3,r2,811335e8 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
811334b4:	e03ffa15 	stw	zero,-24(fp)
811334b8:	00004806 	br	811335dc <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
811334bc:	e0bffa17 	ldw	r2,-24(fp)
811334c0:	1004913a 	slli	r2,r2,4
811334c4:	10806f84 	addi	r2,r2,446
811334c8:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
811334cc:	d0a09717 	ldw	r2,-32164(gp)
811334d0:	10c00a17 	ldw	r3,40(r2)
811334d4:	e0bffc17 	ldw	r2,-16(fp)
811334d8:	1885883a 	add	r2,r3,r2
811334dc:	10800104 	addi	r2,r2,4
811334e0:	10800023 	ldbuio	r2,0(r2)
811334e4:	10803fcc 	andi	r2,r2,255
811334e8:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
811334ec:	e0bffd07 	ldb	r2,-12(fp)
811334f0:	10800060 	cmpeqi	r2,r2,1
811334f4:	1000091e 	bne	r2,zero,8113351c <Check_for_Master_Boot_Record+0xc8>
811334f8:	e0bffd07 	ldb	r2,-12(fp)
811334fc:	10800120 	cmpeqi	r2,r2,4
81133500:	1000061e 	bne	r2,zero,8113351c <Check_for_Master_Boot_Record+0xc8>
81133504:	e0bffd07 	ldb	r2,-12(fp)
81133508:	108001a0 	cmpeqi	r2,r2,6
8113350c:	1000031e 	bne	r2,zero,8113351c <Check_for_Master_Boot_Record+0xc8>
81133510:	e0bffd07 	ldb	r2,-12(fp)
81133514:	10800398 	cmpnei	r2,r2,14
81133518:	10002d1e 	bne	r2,zero,811335d0 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
8113351c:	d0a09717 	ldw	r2,-32164(gp)
81133520:	10c00a17 	ldw	r3,40(r2)
81133524:	e0bffc17 	ldw	r2,-16(fp)
81133528:	1885883a 	add	r2,r3,r2
8113352c:	10800284 	addi	r2,r2,10
81133530:	1080002b 	ldhuio	r2,0(r2)
81133534:	10bfffcc 	andi	r2,r2,65535
81133538:	1006943a 	slli	r3,r2,16
8113353c:	d0a09717 	ldw	r2,-32164(gp)
81133540:	11000a17 	ldw	r4,40(r2)
81133544:	e0bffc17 	ldw	r2,-16(fp)
81133548:	2085883a 	add	r2,r4,r2
8113354c:	10800204 	addi	r2,r2,8
81133550:	1080002b 	ldhuio	r2,0(r2)
81133554:	10bfffcc 	andi	r2,r2,65535
81133558:	10bfffcc 	andi	r2,r2,65535
8113355c:	1884b03a 	or	r2,r3,r2
81133560:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
81133564:	d0a09717 	ldw	r2,-32164(gp)
81133568:	10c00a17 	ldw	r3,40(r2)
8113356c:	e0bffc17 	ldw	r2,-16(fp)
81133570:	1885883a 	add	r2,r3,r2
81133574:	10800384 	addi	r2,r2,14
81133578:	1080002b 	ldhuio	r2,0(r2)
8113357c:	10bfffcc 	andi	r2,r2,65535
81133580:	1006943a 	slli	r3,r2,16
81133584:	d0a09717 	ldw	r2,-32164(gp)
81133588:	11000a17 	ldw	r4,40(r2)
8113358c:	e0bffc17 	ldw	r2,-16(fp)
81133590:	2085883a 	add	r2,r4,r2
81133594:	10800304 	addi	r2,r2,12
81133598:	1080002b 	ldhuio	r2,0(r2)
8113359c:	10bfffcc 	andi	r2,r2,65535
811335a0:	10bfffcc 	andi	r2,r2,65535
811335a4:	1884b03a 	or	r2,r3,r2
811335a8:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
811335ac:	e0bfff17 	ldw	r2,-4(fp)
811335b0:	0080070e 	bge	zero,r2,811335d0 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
811335b4:	00800044 	movi	r2,1
811335b8:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
811335bc:	e0bfff17 	ldw	r2,-4(fp)
811335c0:	d0a09615 	stw	r2,-32168(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
811335c4:	e0bffe17 	ldw	r2,-8(fp)
811335c8:	d0a09515 	stw	r2,-32172(gp)
						break;
811335cc:	00000606 	br	811335e8 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
811335d0:	e0bffa17 	ldw	r2,-24(fp)
811335d4:	10800044 	addi	r2,r2,1
811335d8:	e0bffa15 	stw	r2,-24(fp)
811335dc:	e0bffa17 	ldw	r2,-24(fp)
811335e0:	10800110 	cmplti	r2,r2,4
811335e4:	103fb51e 	bne	r2,zero,811334bc <__reset+0xfb1134bc>
				}
			}
		}
	}

	return result;
811335e8:	e0bff917 	ldw	r2,-28(fp)
}
811335ec:	e037883a 	mov	sp,fp
811335f0:	dfc00117 	ldw	ra,4(sp)
811335f4:	df000017 	ldw	fp,0(sp)
811335f8:	dec00204 	addi	sp,sp,8
811335fc:	f800283a 	ret

81133600 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
81133600:	defff804 	addi	sp,sp,-32
81133604:	de00012e 	bgeu	sp,et,8113360c <Read_File_Record_At_Offset+0xc>
81133608:	003b68fa 	trap	3
8113360c:	dfc00715 	stw	ra,28(sp)
81133610:	df000615 	stw	fp,24(sp)
81133614:	df000604 	addi	fp,sp,24
81133618:	e13ffc15 	stw	r4,-16(fp)
8113361c:	e17ffd15 	stw	r5,-12(fp)
81133620:	e1bffe15 	stw	r6,-8(fp)
81133624:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
81133628:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113362c:	e0bffc17 	ldw	r2,-16(fp)
81133630:	108007cc 	andi	r2,r2,31
81133634:	10008d1e 	bne	r2,zero,8113386c <Read_File_Record_At_Offset+0x26c>
81133638:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
8113363c:	10008b26 	beq	r2,zero,8113386c <Read_File_Record_At_Offset+0x26c>
81133640:	d0a08e17 	ldw	r2,-32200(gp)
81133644:	10008926 	beq	r2,zero,8113386c <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
81133648:	e03ffb15 	stw	zero,-20(fp)
8113364c:	00001106 	br	81133694 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
81133650:	e0fffc17 	ldw	r3,-16(fp)
81133654:	e0bffb17 	ldw	r2,-20(fp)
81133658:	1885883a 	add	r2,r3,r2
8113365c:	1007883a 	mov	r3,r2
81133660:	d0a09717 	ldw	r2,-32164(gp)
81133664:	10800a17 	ldw	r2,40(r2)
81133668:	1885883a 	add	r2,r3,r2
8113366c:	10800023 	ldbuio	r2,0(r2)
81133670:	10803fcc 	andi	r2,r2,255
81133674:	1009883a 	mov	r4,r2
81133678:	e0fffd17 	ldw	r3,-12(fp)
8113367c:	e0bffb17 	ldw	r2,-20(fp)
81133680:	1885883a 	add	r2,r3,r2
81133684:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
81133688:	e0bffb17 	ldw	r2,-20(fp)
8113368c:	10800044 	addi	r2,r2,1
81133690:	e0bffb15 	stw	r2,-20(fp)
81133694:	e0bffb17 	ldw	r2,-20(fp)
81133698:	10800210 	cmplti	r2,r2,8
8113369c:	103fec1e 	bne	r2,zero,81133650 <__reset+0xfb113650>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
811336a0:	e03ffb15 	stw	zero,-20(fp)
811336a4:	00001306 	br	811336f4 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
811336a8:	e0fffc17 	ldw	r3,-16(fp)
811336ac:	e0bffb17 	ldw	r2,-20(fp)
811336b0:	1885883a 	add	r2,r3,r2
811336b4:	1007883a 	mov	r3,r2
811336b8:	d0a09717 	ldw	r2,-32164(gp)
811336bc:	10800a17 	ldw	r2,40(r2)
811336c0:	1885883a 	add	r2,r3,r2
811336c4:	10800204 	addi	r2,r2,8
811336c8:	10800023 	ldbuio	r2,0(r2)
811336cc:	10803fcc 	andi	r2,r2,255
811336d0:	1009883a 	mov	r4,r2
811336d4:	e0fffd17 	ldw	r3,-12(fp)
811336d8:	e0bffb17 	ldw	r2,-20(fp)
811336dc:	1885883a 	add	r2,r3,r2
811336e0:	10800204 	addi	r2,r2,8
811336e4:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
811336e8:	e0bffb17 	ldw	r2,-20(fp)
811336ec:	10800044 	addi	r2,r2,1
811336f0:	e0bffb15 	stw	r2,-20(fp)
811336f4:	e0bffb17 	ldw	r2,-20(fp)
811336f8:	108000d0 	cmplti	r2,r2,3
811336fc:	103fea1e 	bne	r2,zero,811336a8 <__reset+0xfb1136a8>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
81133700:	d0a09717 	ldw	r2,-32164(gp)
81133704:	10c00a17 	ldw	r3,40(r2)
81133708:	e0bffc17 	ldw	r2,-16(fp)
8113370c:	1885883a 	add	r2,r3,r2
81133710:	108002c4 	addi	r2,r2,11
81133714:	10800023 	ldbuio	r2,0(r2)
81133718:	10803fcc 	andi	r2,r2,255
8113371c:	1007883a 	mov	r3,r2
81133720:	e0bffd17 	ldw	r2,-12(fp)
81133724:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
81133728:	d0a09717 	ldw	r2,-32164(gp)
8113372c:	10c00a17 	ldw	r3,40(r2)
81133730:	e0bffc17 	ldw	r2,-16(fp)
81133734:	1885883a 	add	r2,r3,r2
81133738:	10800384 	addi	r2,r2,14
8113373c:	1080002b 	ldhuio	r2,0(r2)
81133740:	10bfffcc 	andi	r2,r2,65535
81133744:	1007883a 	mov	r3,r2
81133748:	e0bffd17 	ldw	r2,-12(fp)
8113374c:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
81133750:	d0a09717 	ldw	r2,-32164(gp)
81133754:	10c00a17 	ldw	r3,40(r2)
81133758:	e0bffc17 	ldw	r2,-16(fp)
8113375c:	1885883a 	add	r2,r3,r2
81133760:	10800404 	addi	r2,r2,16
81133764:	1080002b 	ldhuio	r2,0(r2)
81133768:	10bfffcc 	andi	r2,r2,65535
8113376c:	1007883a 	mov	r3,r2
81133770:	e0bffd17 	ldw	r2,-12(fp)
81133774:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
81133778:	d0a09717 	ldw	r2,-32164(gp)
8113377c:	10c00a17 	ldw	r3,40(r2)
81133780:	e0bffc17 	ldw	r2,-16(fp)
81133784:	1885883a 	add	r2,r3,r2
81133788:	10800484 	addi	r2,r2,18
8113378c:	1080002b 	ldhuio	r2,0(r2)
81133790:	10bfffcc 	andi	r2,r2,65535
81133794:	1007883a 	mov	r3,r2
81133798:	e0bffd17 	ldw	r2,-12(fp)
8113379c:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
811337a0:	d0a09717 	ldw	r2,-32164(gp)
811337a4:	10c00a17 	ldw	r3,40(r2)
811337a8:	e0bffc17 	ldw	r2,-16(fp)
811337ac:	1885883a 	add	r2,r3,r2
811337b0:	10800584 	addi	r2,r2,22
811337b4:	1080002b 	ldhuio	r2,0(r2)
811337b8:	10bfffcc 	andi	r2,r2,65535
811337bc:	1007883a 	mov	r3,r2
811337c0:	e0bffd17 	ldw	r2,-12(fp)
811337c4:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
811337c8:	d0a09717 	ldw	r2,-32164(gp)
811337cc:	10c00a17 	ldw	r3,40(r2)
811337d0:	e0bffc17 	ldw	r2,-16(fp)
811337d4:	1885883a 	add	r2,r3,r2
811337d8:	10800604 	addi	r2,r2,24
811337dc:	1080002b 	ldhuio	r2,0(r2)
811337e0:	10bfffcc 	andi	r2,r2,65535
811337e4:	1007883a 	mov	r3,r2
811337e8:	e0bffd17 	ldw	r2,-12(fp)
811337ec:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
811337f0:	d0a09717 	ldw	r2,-32164(gp)
811337f4:	10c00a17 	ldw	r3,40(r2)
811337f8:	e0bffc17 	ldw	r2,-16(fp)
811337fc:	1885883a 	add	r2,r3,r2
81133800:	10800684 	addi	r2,r2,26
81133804:	1080002b 	ldhuio	r2,0(r2)
81133808:	10bfffcc 	andi	r2,r2,65535
8113380c:	1007883a 	mov	r3,r2
81133810:	e0bffd17 	ldw	r2,-12(fp)
81133814:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
81133818:	d0a09717 	ldw	r2,-32164(gp)
8113381c:	10c00a17 	ldw	r3,40(r2)
81133820:	e0bffc17 	ldw	r2,-16(fp)
81133824:	1885883a 	add	r2,r3,r2
81133828:	10800704 	addi	r2,r2,28
8113382c:	10800037 	ldwio	r2,0(r2)
81133830:	1007883a 	mov	r3,r2
81133834:	e0bffd17 	ldw	r2,-12(fp)
81133838:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
8113383c:	e0bffd17 	ldw	r2,-12(fp)
81133840:	e0fffe17 	ldw	r3,-8(fp)
81133844:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
81133848:	e0bffd17 	ldw	r2,-12(fp)
8113384c:	e0ffff17 	ldw	r3,-4(fp)
81133850:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
81133854:	e0bffc17 	ldw	r2,-16(fp)
81133858:	1007883a 	mov	r3,r2
8113385c:	e0bffd17 	ldw	r2,-12(fp)
81133860:	10c00c0d 	sth	r3,48(r2)
		result = true;
81133864:	00800044 	movi	r2,1
81133868:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8113386c:	e0bffa17 	ldw	r2,-24(fp)
}
81133870:	e037883a 	mov	sp,fp
81133874:	dfc00117 	ldw	ra,4(sp)
81133878:	df000017 	ldw	fp,0(sp)
8113387c:	dec00204 	addi	sp,sp,8
81133880:	f800283a 	ret

81133884 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
81133884:	defff904 	addi	sp,sp,-28
81133888:	de00012e 	bgeu	sp,et,81133890 <Write_File_Record_At_Offset+0xc>
8113388c:	003b68fa 	trap	3
81133890:	dfc00615 	stw	ra,24(sp)
81133894:	df000515 	stw	fp,20(sp)
81133898:	df000504 	addi	fp,sp,20
8113389c:	e13ffe15 	stw	r4,-8(fp)
811338a0:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
811338a4:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811338a8:	e0bffe17 	ldw	r2,-8(fp)
811338ac:	108007cc 	andi	r2,r2,31
811338b0:	1000931e 	bne	r2,zero,81133b00 <Write_File_Record_At_Offset+0x27c>
811338b4:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
811338b8:	10009126 	beq	r2,zero,81133b00 <Write_File_Record_At_Offset+0x27c>
811338bc:	d0a08e17 	ldw	r2,-32200(gp)
811338c0:	10008f26 	beq	r2,zero,81133b00 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
811338c4:	e03ffc15 	stw	zero,-16(fp)
811338c8:	00001f06 	br	81133948 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
811338cc:	e0bffc17 	ldw	r2,-16(fp)
811338d0:	10800044 	addi	r2,r2,1
811338d4:	e0ffff17 	ldw	r3,-4(fp)
811338d8:	1885883a 	add	r2,r3,r2
811338dc:	10800003 	ldbu	r2,0(r2)
811338e0:	10803fcc 	andi	r2,r2,255
811338e4:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
811338e8:	e0bffd0f 	ldh	r2,-12(fp)
811338ec:	1004923a 	slli	r2,r2,8
811338f0:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
811338f4:	e0ffff17 	ldw	r3,-4(fp)
811338f8:	e0bffc17 	ldw	r2,-16(fp)
811338fc:	1885883a 	add	r2,r3,r2
81133900:	10800003 	ldbu	r2,0(r2)
81133904:	10c03fcc 	andi	r3,r2,255
81133908:	e0bffd0b 	ldhu	r2,-12(fp)
8113390c:	1884b03a 	or	r2,r3,r2
81133910:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
81133914:	e0fffe17 	ldw	r3,-8(fp)
81133918:	e0bffc17 	ldw	r2,-16(fp)
8113391c:	1885883a 	add	r2,r3,r2
81133920:	1007883a 	mov	r3,r2
81133924:	d0a09717 	ldw	r2,-32164(gp)
81133928:	10800a17 	ldw	r2,40(r2)
8113392c:	1885883a 	add	r2,r3,r2
81133930:	1007883a 	mov	r3,r2
81133934:	e0bffd0f 	ldh	r2,-12(fp)
81133938:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113393c:	e0bffc17 	ldw	r2,-16(fp)
81133940:	10800084 	addi	r2,r2,2
81133944:	e0bffc15 	stw	r2,-16(fp)
81133948:	e0bffc17 	ldw	r2,-16(fp)
8113394c:	10800210 	cmplti	r2,r2,8
81133950:	103fde1e 	bne	r2,zero,811338cc <__reset+0xfb1138cc>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81133954:	e03ffc15 	stw	zero,-16(fp)
81133958:	00001306 	br	811339a8 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
8113395c:	e0fffe17 	ldw	r3,-8(fp)
81133960:	e0bffc17 	ldw	r2,-16(fp)
81133964:	1885883a 	add	r2,r3,r2
81133968:	1007883a 	mov	r3,r2
8113396c:	d0a09717 	ldw	r2,-32164(gp)
81133970:	10800a17 	ldw	r2,40(r2)
81133974:	1885883a 	add	r2,r3,r2
81133978:	10800204 	addi	r2,r2,8
8113397c:	1009883a 	mov	r4,r2
81133980:	e0ffff17 	ldw	r3,-4(fp)
81133984:	e0bffc17 	ldw	r2,-16(fp)
81133988:	1885883a 	add	r2,r3,r2
8113398c:	10800204 	addi	r2,r2,8
81133990:	10800003 	ldbu	r2,0(r2)
81133994:	10803fcc 	andi	r2,r2,255
81133998:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113399c:	e0bffc17 	ldw	r2,-16(fp)
811339a0:	10800044 	addi	r2,r2,1
811339a4:	e0bffc15 	stw	r2,-16(fp)
811339a8:	e0bffc17 	ldw	r2,-16(fp)
811339ac:	108000d0 	cmplti	r2,r2,3
811339b0:	103fea1e 	bne	r2,zero,8113395c <__reset+0xfb11395c>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
811339b4:	d0a09717 	ldw	r2,-32164(gp)
811339b8:	10c00a17 	ldw	r3,40(r2)
811339bc:	e0bffe17 	ldw	r2,-8(fp)
811339c0:	1885883a 	add	r2,r3,r2
811339c4:	108002c4 	addi	r2,r2,11
811339c8:	1007883a 	mov	r3,r2
811339cc:	e0bfff17 	ldw	r2,-4(fp)
811339d0:	108002c3 	ldbu	r2,11(r2)
811339d4:	10803fcc 	andi	r2,r2,255
811339d8:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
811339dc:	d0a09717 	ldw	r2,-32164(gp)
811339e0:	10c00a17 	ldw	r3,40(r2)
811339e4:	e0bffe17 	ldw	r2,-8(fp)
811339e8:	1885883a 	add	r2,r3,r2
811339ec:	10800384 	addi	r2,r2,14
811339f0:	1007883a 	mov	r3,r2
811339f4:	e0bfff17 	ldw	r2,-4(fp)
811339f8:	1080030b 	ldhu	r2,12(r2)
811339fc:	10bfffcc 	andi	r2,r2,65535
81133a00:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
81133a04:	d0a09717 	ldw	r2,-32164(gp)
81133a08:	10c00a17 	ldw	r3,40(r2)
81133a0c:	e0bffe17 	ldw	r2,-8(fp)
81133a10:	1885883a 	add	r2,r3,r2
81133a14:	10800404 	addi	r2,r2,16
81133a18:	1007883a 	mov	r3,r2
81133a1c:	e0bfff17 	ldw	r2,-4(fp)
81133a20:	1080038b 	ldhu	r2,14(r2)
81133a24:	10bfffcc 	andi	r2,r2,65535
81133a28:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81133a2c:	d0a09717 	ldw	r2,-32164(gp)
81133a30:	10c00a17 	ldw	r3,40(r2)
81133a34:	e0bffe17 	ldw	r2,-8(fp)
81133a38:	1885883a 	add	r2,r3,r2
81133a3c:	10800484 	addi	r2,r2,18
81133a40:	1007883a 	mov	r3,r2
81133a44:	e0bfff17 	ldw	r2,-4(fp)
81133a48:	1080040b 	ldhu	r2,16(r2)
81133a4c:	10bfffcc 	andi	r2,r2,65535
81133a50:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81133a54:	d0a09717 	ldw	r2,-32164(gp)
81133a58:	10c00a17 	ldw	r3,40(r2)
81133a5c:	e0bffe17 	ldw	r2,-8(fp)
81133a60:	1885883a 	add	r2,r3,r2
81133a64:	10800584 	addi	r2,r2,22
81133a68:	1007883a 	mov	r3,r2
81133a6c:	e0bfff17 	ldw	r2,-4(fp)
81133a70:	1080048b 	ldhu	r2,18(r2)
81133a74:	10bfffcc 	andi	r2,r2,65535
81133a78:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
81133a7c:	d0a09717 	ldw	r2,-32164(gp)
81133a80:	10c00a17 	ldw	r3,40(r2)
81133a84:	e0bffe17 	ldw	r2,-8(fp)
81133a88:	1885883a 	add	r2,r3,r2
81133a8c:	10800604 	addi	r2,r2,24
81133a90:	1007883a 	mov	r3,r2
81133a94:	e0bfff17 	ldw	r2,-4(fp)
81133a98:	1080050b 	ldhu	r2,20(r2)
81133a9c:	10bfffcc 	andi	r2,r2,65535
81133aa0:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
81133aa4:	d0a09717 	ldw	r2,-32164(gp)
81133aa8:	10c00a17 	ldw	r3,40(r2)
81133aac:	e0bffe17 	ldw	r2,-8(fp)
81133ab0:	1885883a 	add	r2,r3,r2
81133ab4:	10800684 	addi	r2,r2,26
81133ab8:	1007883a 	mov	r3,r2
81133abc:	e0bfff17 	ldw	r2,-4(fp)
81133ac0:	1080058b 	ldhu	r2,22(r2)
81133ac4:	10bfffcc 	andi	r2,r2,65535
81133ac8:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
81133acc:	d0a09717 	ldw	r2,-32164(gp)
81133ad0:	10c00a17 	ldw	r3,40(r2)
81133ad4:	e0bffe17 	ldw	r2,-8(fp)
81133ad8:	1885883a 	add	r2,r3,r2
81133adc:	10800704 	addi	r2,r2,28
81133ae0:	1007883a 	mov	r3,r2
81133ae4:	e0bfff17 	ldw	r2,-4(fp)
81133ae8:	10800617 	ldw	r2,24(r2)
81133aec:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81133af0:	00800044 	movi	r2,1
81133af4:	d0a09815 	stw	r2,-32160(gp)
        result = true;
81133af8:	00800044 	movi	r2,1
81133afc:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81133b00:	e0bffb17 	ldw	r2,-20(fp)
}
81133b04:	e037883a 	mov	sp,fp
81133b08:	dfc00117 	ldw	ra,4(sp)
81133b0c:	df000017 	ldw	fp,0(sp)
81133b10:	dec00204 	addi	sp,sp,8
81133b14:	f800283a 	ret

81133b18 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
81133b18:	defff904 	addi	sp,sp,-28
81133b1c:	de00012e 	bgeu	sp,et,81133b24 <Check_for_DOS_FAT+0xc>
81133b20:	003b68fa 	trap	3
81133b24:	dfc00615 	stw	ra,24(sp)
81133b28:	df000515 	stw	fp,20(sp)
81133b2c:	df000504 	addi	fp,sp,20
81133b30:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81133b34:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
81133b38:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81133b3c:	e17fff17 	ldw	r5,-4(fp)
81133b40:	0009883a 	mov	r4,zero
81133b44:	11331d00 	call	811331d0 <Read_Sector_Data>
81133b48:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81133b4c:	d0a09717 	ldw	r2,-32164(gp)
81133b50:	10800a17 	ldw	r2,40(r2)
81133b54:	10807f84 	addi	r2,r2,510
81133b58:	1080002b 	ldhuio	r2,0(r2)
81133b5c:	10bfffcc 	andi	r2,r2,65535
81133b60:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
81133b64:	e0bffe0f 	ldh	r2,-8(fp)
81133b68:	10ffffcc 	andi	r3,r2,65535
81133b6c:	00aa9554 	movui	r2,43605
81133b70:	1881841e 	bne	r3,r2,81134184 <Check_for_DOS_FAT+0x66c>
81133b74:	e0bffb17 	ldw	r2,-20(fp)
81133b78:	10018226 	beq	r2,zero,81134184 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
81133b7c:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
81133b80:	d0a09717 	ldw	r2,-32164(gp)
81133b84:	10800a17 	ldw	r2,40(r2)
81133b88:	10800023 	ldbuio	r2,0(r2)
81133b8c:	10803fcc 	andi	r2,r2,255
81133b90:	1007883a 	mov	r3,r2
81133b94:	00a04574 	movhi	r2,33045
81133b98:	1094b704 	addi	r2,r2,21212
81133b9c:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
81133ba0:	d0a09717 	ldw	r2,-32164(gp)
81133ba4:	10800a17 	ldw	r2,40(r2)
81133ba8:	10800044 	addi	r2,r2,1
81133bac:	10800023 	ldbuio	r2,0(r2)
81133bb0:	10803fcc 	andi	r2,r2,255
81133bb4:	1007883a 	mov	r3,r2
81133bb8:	00a04574 	movhi	r2,33045
81133bbc:	1094b704 	addi	r2,r2,21212
81133bc0:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
81133bc4:	d0a09717 	ldw	r2,-32164(gp)
81133bc8:	10800a17 	ldw	r2,40(r2)
81133bcc:	10800084 	addi	r2,r2,2
81133bd0:	10800023 	ldbuio	r2,0(r2)
81133bd4:	10803fcc 	andi	r2,r2,255
81133bd8:	1007883a 	mov	r3,r2
81133bdc:	00a04574 	movhi	r2,33045
81133be0:	1094b704 	addi	r2,r2,21212
81133be4:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
81133be8:	e03ffc15 	stw	zero,-16(fp)
81133bec:	00001106 	br	81133c34 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81133bf0:	d0a09717 	ldw	r2,-32164(gp)
81133bf4:	10c00a17 	ldw	r3,40(r2)
81133bf8:	e0bffc17 	ldw	r2,-16(fp)
81133bfc:	1885883a 	add	r2,r3,r2
81133c00:	108000c4 	addi	r2,r2,3
81133c04:	10800023 	ldbuio	r2,0(r2)
81133c08:	10803fcc 	andi	r2,r2,255
81133c0c:	1009883a 	mov	r4,r2
81133c10:	00a04574 	movhi	r2,33045
81133c14:	1094b704 	addi	r2,r2,21212
81133c18:	e0fffc17 	ldw	r3,-16(fp)
81133c1c:	10c5883a 	add	r2,r2,r3
81133c20:	108000c4 	addi	r2,r2,3
81133c24:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
81133c28:	e0bffc17 	ldw	r2,-16(fp)
81133c2c:	10800044 	addi	r2,r2,1
81133c30:	e0bffc15 	stw	r2,-16(fp)
81133c34:	e0bffc17 	ldw	r2,-16(fp)
81133c38:	10800210 	cmplti	r2,r2,8
81133c3c:	103fec1e 	bne	r2,zero,81133bf0 <__reset+0xfb113bf0>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81133c40:	d0a09717 	ldw	r2,-32164(gp)
81133c44:	10800a17 	ldw	r2,40(r2)
81133c48:	10800304 	addi	r2,r2,12
81133c4c:	10800023 	ldbuio	r2,0(r2)
81133c50:	10803fcc 	andi	r2,r2,255
81133c54:	1004923a 	slli	r2,r2,8
81133c58:	1007883a 	mov	r3,r2
81133c5c:	d0a09717 	ldw	r2,-32164(gp)
81133c60:	10800a17 	ldw	r2,40(r2)
81133c64:	108002c4 	addi	r2,r2,11
81133c68:	10800023 	ldbuio	r2,0(r2)
81133c6c:	10803fcc 	andi	r2,r2,255
81133c70:	10803fcc 	andi	r2,r2,255
81133c74:	1080201c 	xori	r2,r2,128
81133c78:	10bfe004 	addi	r2,r2,-128
81133c7c:	1884b03a 	or	r2,r3,r2
81133c80:	1007883a 	mov	r3,r2
81133c84:	00a04574 	movhi	r2,33045
81133c88:	1094b704 	addi	r2,r2,21212
81133c8c:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
81133c90:	d0a09717 	ldw	r2,-32164(gp)
81133c94:	10800a17 	ldw	r2,40(r2)
81133c98:	10800344 	addi	r2,r2,13
81133c9c:	10800023 	ldbuio	r2,0(r2)
81133ca0:	10803fcc 	andi	r2,r2,255
81133ca4:	1007883a 	mov	r3,r2
81133ca8:	00a04574 	movhi	r2,33045
81133cac:	1094b704 	addi	r2,r2,21212
81133cb0:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
81133cb4:	d0a09717 	ldw	r2,-32164(gp)
81133cb8:	10800a17 	ldw	r2,40(r2)
81133cbc:	10800384 	addi	r2,r2,14
81133cc0:	1080002b 	ldhuio	r2,0(r2)
81133cc4:	10bfffcc 	andi	r2,r2,65535
81133cc8:	1007883a 	mov	r3,r2
81133ccc:	00a04574 	movhi	r2,33045
81133cd0:	1094b704 	addi	r2,r2,21212
81133cd4:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
81133cd8:	d0a09717 	ldw	r2,-32164(gp)
81133cdc:	10800a17 	ldw	r2,40(r2)
81133ce0:	10800404 	addi	r2,r2,16
81133ce4:	10800023 	ldbuio	r2,0(r2)
81133ce8:	10803fcc 	andi	r2,r2,255
81133cec:	1007883a 	mov	r3,r2
81133cf0:	00a04574 	movhi	r2,33045
81133cf4:	1094b704 	addi	r2,r2,21212
81133cf8:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
81133cfc:	d0a09717 	ldw	r2,-32164(gp)
81133d00:	10800a17 	ldw	r2,40(r2)
81133d04:	10800484 	addi	r2,r2,18
81133d08:	10800023 	ldbuio	r2,0(r2)
81133d0c:	10803fcc 	andi	r2,r2,255
81133d10:	1004923a 	slli	r2,r2,8
81133d14:	1007883a 	mov	r3,r2
81133d18:	d0a09717 	ldw	r2,-32164(gp)
81133d1c:	10800a17 	ldw	r2,40(r2)
81133d20:	10800444 	addi	r2,r2,17
81133d24:	10800023 	ldbuio	r2,0(r2)
81133d28:	10803fcc 	andi	r2,r2,255
81133d2c:	10803fcc 	andi	r2,r2,255
81133d30:	1884b03a 	or	r2,r3,r2
81133d34:	1007883a 	mov	r3,r2
81133d38:	00a04574 	movhi	r2,33045
81133d3c:	1094b704 	addi	r2,r2,21212
81133d40:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
81133d44:	d0a09717 	ldw	r2,-32164(gp)
81133d48:	10800a17 	ldw	r2,40(r2)
81133d4c:	10800504 	addi	r2,r2,20
81133d50:	10800023 	ldbuio	r2,0(r2)
81133d54:	10803fcc 	andi	r2,r2,255
81133d58:	1004923a 	slli	r2,r2,8
81133d5c:	1007883a 	mov	r3,r2
81133d60:	d0a09717 	ldw	r2,-32164(gp)
81133d64:	10800a17 	ldw	r2,40(r2)
81133d68:	108004c4 	addi	r2,r2,19
81133d6c:	10800023 	ldbuio	r2,0(r2)
81133d70:	10803fcc 	andi	r2,r2,255
81133d74:	10803fcc 	andi	r2,r2,255
81133d78:	1884b03a 	or	r2,r3,r2
81133d7c:	1007883a 	mov	r3,r2
81133d80:	00a04574 	movhi	r2,33045
81133d84:	1094b704 	addi	r2,r2,21212
81133d88:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
81133d8c:	d0a09717 	ldw	r2,-32164(gp)
81133d90:	10800a17 	ldw	r2,40(r2)
81133d94:	10800544 	addi	r2,r2,21
81133d98:	10800023 	ldbuio	r2,0(r2)
81133d9c:	10803fcc 	andi	r2,r2,255
81133da0:	1007883a 	mov	r3,r2
81133da4:	00a04574 	movhi	r2,33045
81133da8:	1094b704 	addi	r2,r2,21212
81133dac:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
81133db0:	d0a09717 	ldw	r2,-32164(gp)
81133db4:	10800a17 	ldw	r2,40(r2)
81133db8:	10800584 	addi	r2,r2,22
81133dbc:	1080002b 	ldhuio	r2,0(r2)
81133dc0:	10bfffcc 	andi	r2,r2,65535
81133dc4:	1007883a 	mov	r3,r2
81133dc8:	00a04574 	movhi	r2,33045
81133dcc:	1094b704 	addi	r2,r2,21212
81133dd0:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
81133dd4:	d0a09717 	ldw	r2,-32164(gp)
81133dd8:	10800a17 	ldw	r2,40(r2)
81133ddc:	10800604 	addi	r2,r2,24
81133de0:	1080002b 	ldhuio	r2,0(r2)
81133de4:	10bfffcc 	andi	r2,r2,65535
81133de8:	1007883a 	mov	r3,r2
81133dec:	00a04574 	movhi	r2,33045
81133df0:	1094b704 	addi	r2,r2,21212
81133df4:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
81133df8:	d0a09717 	ldw	r2,-32164(gp)
81133dfc:	10800a17 	ldw	r2,40(r2)
81133e00:	10800684 	addi	r2,r2,26
81133e04:	1080002b 	ldhuio	r2,0(r2)
81133e08:	10bfffcc 	andi	r2,r2,65535
81133e0c:	1007883a 	mov	r3,r2
81133e10:	00a04574 	movhi	r2,33045
81133e14:	1094b704 	addi	r2,r2,21212
81133e18:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81133e1c:	d0a09717 	ldw	r2,-32164(gp)
81133e20:	10800a17 	ldw	r2,40(r2)
81133e24:	10800704 	addi	r2,r2,28
81133e28:	10800037 	ldwio	r2,0(r2)
81133e2c:	1007883a 	mov	r3,r2
81133e30:	00a04574 	movhi	r2,33045
81133e34:	1094b704 	addi	r2,r2,21212
81133e38:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
81133e3c:	d0a09717 	ldw	r2,-32164(gp)
81133e40:	10800a17 	ldw	r2,40(r2)
81133e44:	10800804 	addi	r2,r2,32
81133e48:	10800037 	ldwio	r2,0(r2)
81133e4c:	1007883a 	mov	r3,r2
81133e50:	00a04574 	movhi	r2,33045
81133e54:	1094b704 	addi	r2,r2,21212
81133e58:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
81133e5c:	d0a09717 	ldw	r2,-32164(gp)
81133e60:	10800a17 	ldw	r2,40(r2)
81133e64:	10800904 	addi	r2,r2,36
81133e68:	10800023 	ldbuio	r2,0(r2)
81133e6c:	10803fcc 	andi	r2,r2,255
81133e70:	1007883a 	mov	r3,r2
81133e74:	00a04574 	movhi	r2,33045
81133e78:	1094b704 	addi	r2,r2,21212
81133e7c:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
81133e80:	d0a09717 	ldw	r2,-32164(gp)
81133e84:	10800a17 	ldw	r2,40(r2)
81133e88:	10800944 	addi	r2,r2,37
81133e8c:	10800023 	ldbuio	r2,0(r2)
81133e90:	10803fcc 	andi	r2,r2,255
81133e94:	1007883a 	mov	r3,r2
81133e98:	00a04574 	movhi	r2,33045
81133e9c:	1094b704 	addi	r2,r2,21212
81133ea0:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
81133ea4:	d0a09717 	ldw	r2,-32164(gp)
81133ea8:	10800a17 	ldw	r2,40(r2)
81133eac:	10800984 	addi	r2,r2,38
81133eb0:	10800023 	ldbuio	r2,0(r2)
81133eb4:	10803fcc 	andi	r2,r2,255
81133eb8:	1007883a 	mov	r3,r2
81133ebc:	00a04574 	movhi	r2,33045
81133ec0:	1094b704 	addi	r2,r2,21212
81133ec4:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81133ec8:	00a04574 	movhi	r2,33045
81133ecc:	1094b704 	addi	r2,r2,21212
81133ed0:	1080040b 	ldhu	r2,16(r2)
81133ed4:	10ffffcc 	andi	r3,r2,65535
81133ed8:	00a04574 	movhi	r2,33045
81133edc:	1094b704 	addi	r2,r2,21212
81133ee0:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
81133ee4:	00a04574 	movhi	r2,33045
81133ee8:	1094b704 	addi	r2,r2,21212
81133eec:	10c01117 	ldw	r3,68(r2)
81133ef0:	00a04574 	movhi	r2,33045
81133ef4:	1094b704 	addi	r2,r2,21212
81133ef8:	1080068b 	ldhu	r2,26(r2)
81133efc:	10bfffcc 	andi	r2,r2,65535
81133f00:	1887883a 	add	r3,r3,r2
81133f04:	00a04574 	movhi	r2,33045
81133f08:	1094b704 	addi	r2,r2,21212
81133f0c:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
81133f10:	00a04574 	movhi	r2,33045
81133f14:	1094b704 	addi	r2,r2,21212
81133f18:	10c01217 	ldw	r3,72(r2)
81133f1c:	00a04574 	movhi	r2,33045
81133f20:	1094b704 	addi	r2,r2,21212
81133f24:	1080068b 	ldhu	r2,26(r2)
81133f28:	10bfffcc 	andi	r2,r2,65535
81133f2c:	1887883a 	add	r3,r3,r2
81133f30:	00a04574 	movhi	r2,33045
81133f34:	1094b704 	addi	r2,r2,21212
81133f38:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
81133f3c:	00a04574 	movhi	r2,33045
81133f40:	1094b704 	addi	r2,r2,21212
81133f44:	10c01317 	ldw	r3,76(r2)
81133f48:	00a04574 	movhi	r2,33045
81133f4c:	1094b704 	addi	r2,r2,21212
81133f50:	1080050b 	ldhu	r2,20(r2)
81133f54:	10bfffcc 	andi	r2,r2,65535
81133f58:	1008917a 	slli	r4,r2,5
81133f5c:	00a04574 	movhi	r2,33045
81133f60:	1094b704 	addi	r2,r2,21212
81133f64:	1080030b 	ldhu	r2,12(r2)
81133f68:	10bfffcc 	andi	r2,r2,65535
81133f6c:	2085283a 	div	r2,r4,r2
81133f70:	1887883a 	add	r3,r3,r2
81133f74:	00a04574 	movhi	r2,33045
81133f78:	1094b704 	addi	r2,r2,21212
81133f7c:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
81133f80:	00a04574 	movhi	r2,33045
81133f84:	1094b704 	addi	r2,r2,21212
81133f88:	1080058b 	ldhu	r2,22(r2)
81133f8c:	10bfffcc 	andi	r2,r2,65535
81133f90:	10000b26 	beq	r2,zero,81133fc0 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
81133f94:	00a04574 	movhi	r2,33045
81133f98:	1094b704 	addi	r2,r2,21212
81133f9c:	1080058b 	ldhu	r2,22(r2)
81133fa0:	10ffffcc 	andi	r3,r2,65535
81133fa4:	00a04574 	movhi	r2,33045
81133fa8:	1094b704 	addi	r2,r2,21212
81133fac:	10800383 	ldbu	r2,14(r2)
81133fb0:	10803fcc 	andi	r2,r2,255
81133fb4:	1885283a 	div	r2,r3,r2
81133fb8:	e0bffd15 	stw	r2,-12(fp)
81133fbc:	00000906 	br	81133fe4 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
81133fc0:	00a04574 	movhi	r2,33045
81133fc4:	1094b704 	addi	r2,r2,21212
81133fc8:	10c00917 	ldw	r3,36(r2)
81133fcc:	00a04574 	movhi	r2,33045
81133fd0:	1094b704 	addi	r2,r2,21212
81133fd4:	10800383 	ldbu	r2,14(r2)
81133fd8:	10803fcc 	andi	r2,r2,255
81133fdc:	1885203a 	divu	r2,r3,r2
81133fe0:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
81133fe4:	e0bffd17 	ldw	r2,-12(fp)
81133fe8:	1083fdc8 	cmpgei	r2,r2,4087
81133fec:	1000051e 	bne	r2,zero,81134004 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
81133ff0:	00a04574 	movhi	r2,33045
81133ff4:	1094b704 	addi	r2,r2,21212
81133ff8:	00c00304 	movi	r3,12
81133ffc:	10c01085 	stb	r3,66(r2)
81134000:	00000c06 	br	81134034 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
81134004:	e0bffd17 	ldw	r2,-12(fp)
81134008:	00fffb54 	movui	r3,65517
8113400c:	18800516 	blt	r3,r2,81134024 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
81134010:	00a04574 	movhi	r2,33045
81134014:	1094b704 	addi	r2,r2,21212
81134018:	00c00404 	movi	r3,16
8113401c:	10c01085 	stb	r3,66(r2)
81134020:	00000406 	br	81134034 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
81134024:	00a04574 	movhi	r2,33045
81134028:	1094b704 	addi	r2,r2,21212
8113402c:	00c00804 	movi	r3,32
81134030:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
81134034:	e03ffc15 	stw	zero,-16(fp)
81134038:	00001106 	br	81134080 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
8113403c:	d0a09717 	ldw	r2,-32164(gp)
81134040:	10c00a17 	ldw	r3,40(r2)
81134044:	e0bffc17 	ldw	r2,-16(fp)
81134048:	1885883a 	add	r2,r3,r2
8113404c:	108009c4 	addi	r2,r2,39
81134050:	10800023 	ldbuio	r2,0(r2)
81134054:	10803fcc 	andi	r2,r2,255
81134058:	1009883a 	mov	r4,r2
8113405c:	00a04574 	movhi	r2,33045
81134060:	1094b704 	addi	r2,r2,21212
81134064:	e0fffc17 	ldw	r3,-16(fp)
81134068:	10c5883a 	add	r2,r2,r3
8113406c:	10800ac4 	addi	r2,r2,43
81134070:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
81134074:	e0bffc17 	ldw	r2,-16(fp)
81134078:	10800044 	addi	r2,r2,1
8113407c:	e0bffc15 	stw	r2,-16(fp)
81134080:	e0bffc17 	ldw	r2,-16(fp)
81134084:	10800110 	cmplti	r2,r2,4
81134088:	103fec1e 	bne	r2,zero,8113403c <__reset+0xfb11403c>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113408c:	e03ffc15 	stw	zero,-16(fp)
81134090:	00001106 	br	811340d8 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81134094:	d0a09717 	ldw	r2,-32164(gp)
81134098:	10c00a17 	ldw	r3,40(r2)
8113409c:	e0bffc17 	ldw	r2,-16(fp)
811340a0:	1885883a 	add	r2,r3,r2
811340a4:	10800ac4 	addi	r2,r2,43
811340a8:	10800023 	ldbuio	r2,0(r2)
811340ac:	10803fcc 	andi	r2,r2,255
811340b0:	1009883a 	mov	r4,r2
811340b4:	00a04574 	movhi	r2,33045
811340b8:	1094b704 	addi	r2,r2,21212
811340bc:	e0fffc17 	ldw	r3,-16(fp)
811340c0:	10c5883a 	add	r2,r2,r3
811340c4:	10800bc4 	addi	r2,r2,47
811340c8:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
811340cc:	e0bffc17 	ldw	r2,-16(fp)
811340d0:	10800044 	addi	r2,r2,1
811340d4:	e0bffc15 	stw	r2,-16(fp)
811340d8:	e0bffc17 	ldw	r2,-16(fp)
811340dc:	108002d0 	cmplti	r2,r2,11
811340e0:	103fec1e 	bne	r2,zero,81134094 <__reset+0xfb114094>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
811340e4:	e03ffc15 	stw	zero,-16(fp)
811340e8:	00001106 	br	81134130 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
811340ec:	d0a09717 	ldw	r2,-32164(gp)
811340f0:	10c00a17 	ldw	r3,40(r2)
811340f4:	e0bffc17 	ldw	r2,-16(fp)
811340f8:	1885883a 	add	r2,r3,r2
811340fc:	10800d84 	addi	r2,r2,54
81134100:	10800023 	ldbuio	r2,0(r2)
81134104:	10803fcc 	andi	r2,r2,255
81134108:	1009883a 	mov	r4,r2
8113410c:	00a04574 	movhi	r2,33045
81134110:	1094b704 	addi	r2,r2,21212
81134114:	e0fffc17 	ldw	r3,-16(fp)
81134118:	10c5883a 	add	r2,r2,r3
8113411c:	10800e84 	addi	r2,r2,58
81134120:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81134124:	e0bffc17 	ldw	r2,-16(fp)
81134128:	10800044 	addi	r2,r2,1
8113412c:	e0bffc15 	stw	r2,-16(fp)
81134130:	e0bffc17 	ldw	r2,-16(fp)
81134134:	10800210 	cmplti	r2,r2,8
81134138:	103fec1e 	bne	r2,zero,811340ec <__reset+0xfb1140ec>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113413c:	e03ffc15 	stw	zero,-16(fp)
81134140:	00000a06 	br	8113416c <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
81134144:	00a04574 	movhi	r2,33045
81134148:	1094cc04 	addi	r2,r2,21296
8113414c:	e0fffc17 	ldw	r3,-16(fp)
81134150:	180691ba 	slli	r3,r3,6
81134154:	10c5883a 	add	r2,r2,r3
81134158:	10800f04 	addi	r2,r2,60
8113415c:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81134160:	e0bffc17 	ldw	r2,-16(fp)
81134164:	10800044 	addi	r2,r2,1
81134168:	e0bffc15 	stw	r2,-16(fp)
8113416c:	e0bffc17 	ldw	r2,-16(fp)
81134170:	10800510 	cmplti	r2,r2,20
81134174:	103ff31e 	bne	r2,zero,81134144 <__reset+0xfb114144>
		{
			active_files[counter].in_use = false;
		}
		result = true;
81134178:	00800044 	movi	r2,1
8113417c:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
81134180:	00000106 	br	81134188 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
81134184:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
81134188:	e0bffb17 	ldw	r2,-20(fp)
}
8113418c:	e037883a 	mov	sp,fp
81134190:	dfc00117 	ldw	ra,4(sp)
81134194:	df000017 	ldw	fp,0(sp)
81134198:	dec00204 	addi	sp,sp,8
8113419c:	f800283a 	ret

811341a0 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
811341a0:	defffc04 	addi	sp,sp,-16
811341a4:	de00012e 	bgeu	sp,et,811341ac <Look_for_FAT16+0xc>
811341a8:	003b68fa 	trap	3
811341ac:	dfc00315 	stw	ra,12(sp)
811341b0:	df000215 	stw	fp,8(sp)
811341b4:	df000204 	addi	fp,sp,8
	bool result = false;
811341b8:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
811341bc:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
811341c0:	10002e26 	beq	r2,zero,8113427c <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
811341c4:	d0a09117 	ldw	r2,-32188(gp)
811341c8:	1080000b 	ldhu	r2,0(r2)
811341cc:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
811341d0:	d0209515 	stw	zero,-32172(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
811341d4:	d0209615 	stw	zero,-32168(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
811341d8:	e0bfff0f 	ldh	r2,-4(fp)
811341dc:	10002716 	blt	r2,zero,8113427c <Look_for_FAT16+0xdc>
811341e0:	e0bfff0b 	ldhu	r2,-4(fp)
811341e4:	10bfffcc 	andi	r2,r2,65535
811341e8:	1083000c 	andi	r2,r2,3072
811341ec:	10830020 	cmpeqi	r2,r2,3072
811341f0:	1000221e 	bne	r2,zero,8113427c <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
811341f4:	e0bfff0b 	ldhu	r2,-4(fp)
811341f8:	10bfffcc 	andi	r2,r2,65535
811341fc:	1083000c 	andi	r2,r2,3072
81134200:	10810018 	cmpnei	r2,r2,1024
81134204:	1000031e 	bne	r2,zero,81134214 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
81134208:	0009883a 	mov	r4,zero
8113420c:	1133b180 	call	81133b18 <Check_for_DOS_FAT>
81134210:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
81134214:	e0bfff0b 	ldhu	r2,-4(fp)
81134218:	10bfffcc 	andi	r2,r2,65535
8113421c:	1083000c 	andi	r2,r2,3072
81134220:	1000061e 	bne	r2,zero,8113423c <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
81134224:	11334540 	call	81133454 <Check_for_Master_Boot_Record>
81134228:	10000426 	beq	r2,zero,8113423c <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
8113422c:	d0a09517 	ldw	r2,-32172(gp)
81134230:	1009883a 	mov	r4,r2
81134234:	1133b180 	call	81133b18 <Check_for_DOS_FAT>
81134238:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
8113423c:	e0bffe17 	ldw	r2,-8(fp)
81134240:	10800058 	cmpnei	r2,r2,1
81134244:	10000d1e 	bne	r2,zero,8113427c <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
81134248:	00a04574 	movhi	r2,33045
8113424c:	1094b704 	addi	r2,r2,21212
81134250:	10801083 	ldbu	r2,66(r2)
81134254:	10803fcc 	andi	r2,r2,255
81134258:	10800420 	cmpeqi	r2,r2,16
8113425c:	1000021e 	bne	r2,zero,81134268 <Look_for_FAT16+0xc8>
				{
					result = false;
81134260:	e03ffe15 	stw	zero,-8(fp)
81134264:	00000506 	br	8113427c <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
81134268:	00a04574 	movhi	r2,33045
8113426c:	1094b704 	addi	r2,r2,21212
81134270:	1080058b 	ldhu	r2,22(r2)
81134274:	10bfffcc 	andi	r2,r2,65535
81134278:	d0a09615 	stw	r2,-32168(gp)
				}
			}
		}
	}
	return result;
8113427c:	e0bffe17 	ldw	r2,-8(fp)
}
81134280:	e037883a 	mov	sp,fp
81134284:	dfc00117 	ldw	ra,4(sp)
81134288:	df000017 	ldw	fp,0(sp)
8113428c:	dec00204 	addi	sp,sp,8
81134290:	f800283a 	ret

81134294 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
81134294:	defffb04 	addi	sp,sp,-20
81134298:	de00012e 	bgeu	sp,et,811342a0 <filename_to_upper_case+0xc>
8113429c:	003b68fa 	trap	3
811342a0:	dfc00415 	stw	ra,16(sp)
811342a4:	df000315 	stw	fp,12(sp)
811342a8:	df000304 	addi	fp,sp,12
811342ac:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
811342b0:	e13fff17 	ldw	r4,-4(fp)
811342b4:	111405c0 	call	8111405c <strlen>
811342b8:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
811342bc:	e03ffd15 	stw	zero,-12(fp)
811342c0:	00001e06 	br	8113433c <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
811342c4:	e0bffd17 	ldw	r2,-12(fp)
811342c8:	e0ffff17 	ldw	r3,-4(fp)
811342cc:	1885883a 	add	r2,r3,r2
811342d0:	10800003 	ldbu	r2,0(r2)
811342d4:	10803fcc 	andi	r2,r2,255
811342d8:	1080201c 	xori	r2,r2,128
811342dc:	10bfe004 	addi	r2,r2,-128
811342e0:	10801850 	cmplti	r2,r2,97
811342e4:	1000121e 	bne	r2,zero,81134330 <filename_to_upper_case+0x9c>
811342e8:	e0bffd17 	ldw	r2,-12(fp)
811342ec:	e0ffff17 	ldw	r3,-4(fp)
811342f0:	1885883a 	add	r2,r3,r2
811342f4:	10800003 	ldbu	r2,0(r2)
811342f8:	10803fcc 	andi	r2,r2,255
811342fc:	1080201c 	xori	r2,r2,128
81134300:	10bfe004 	addi	r2,r2,-128
81134304:	10801ec8 	cmpgei	r2,r2,123
81134308:	1000091e 	bne	r2,zero,81134330 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
8113430c:	e0bffd17 	ldw	r2,-12(fp)
81134310:	e0ffff17 	ldw	r3,-4(fp)
81134314:	1885883a 	add	r2,r3,r2
81134318:	e0fffd17 	ldw	r3,-12(fp)
8113431c:	e13fff17 	ldw	r4,-4(fp)
81134320:	20c7883a 	add	r3,r4,r3
81134324:	18c00003 	ldbu	r3,0(r3)
81134328:	18fff804 	addi	r3,r3,-32
8113432c:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
81134330:	e0bffd17 	ldw	r2,-12(fp)
81134334:	10800044 	addi	r2,r2,1
81134338:	e0bffd15 	stw	r2,-12(fp)
8113433c:	e0fffd17 	ldw	r3,-12(fp)
81134340:	e0bffe17 	ldw	r2,-8(fp)
81134344:	18bfdf16 	blt	r3,r2,811342c4 <__reset+0xfb1142c4>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
81134348:	0001883a 	nop
8113434c:	e037883a 	mov	sp,fp
81134350:	dfc00117 	ldw	ra,4(sp)
81134354:	df000017 	ldw	fp,0(sp)
81134358:	dec00204 	addi	sp,sp,8
8113435c:	f800283a 	ret

81134360 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
81134360:	defff804 	addi	sp,sp,-32
81134364:	de00012e 	bgeu	sp,et,8113436c <check_file_name_for_FAT16_compliance+0xc>
81134368:	003b68fa 	trap	3
8113436c:	dfc00715 	stw	ra,28(sp)
81134370:	df000615 	stw	fp,24(sp)
81134374:	df000604 	addi	fp,sp,24
81134378:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
8113437c:	e13fff17 	ldw	r4,-4(fp)
81134380:	111405c0 	call	8111405c <strlen>
81134384:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
81134388:	00bfffc4 	movi	r2,-1
8113438c:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
81134390:	00bfffc4 	movi	r2,-1
81134394:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
81134398:	00800044 	movi	r2,1
8113439c:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
811343a0:	e03ffa15 	stw	zero,-24(fp)
811343a4:	00006d06 	br	8113455c <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
811343a8:	e0bffa17 	ldw	r2,-24(fp)
811343ac:	e0ffff17 	ldw	r3,-4(fp)
811343b0:	1885883a 	add	r2,r3,r2
811343b4:	10800003 	ldbu	r2,0(r2)
811343b8:	10803fcc 	andi	r2,r2,255
811343bc:	1080201c 	xori	r2,r2,128
811343c0:	10bfe004 	addi	r2,r2,-128
811343c4:	10800820 	cmpeqi	r2,r2,32
811343c8:	10003e1e 	bne	r2,zero,811344c4 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811343cc:	e0bffa17 	ldw	r2,-24(fp)
811343d0:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
811343d4:	e0bffb17 	ldw	r2,-20(fp)
811343d8:	1880121e 	bne	r3,r2,81134424 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811343dc:	e0bffa17 	ldw	r2,-24(fp)
811343e0:	e0ffff17 	ldw	r3,-4(fp)
811343e4:	1885883a 	add	r2,r3,r2
811343e8:	10800003 	ldbu	r2,0(r2)
811343ec:	10803fcc 	andi	r2,r2,255
811343f0:	1080201c 	xori	r2,r2,128
811343f4:	10bfe004 	addi	r2,r2,-128
811343f8:	10801720 	cmpeqi	r2,r2,92
811343fc:	1000311e 	bne	r2,zero,811344c4 <check_file_name_for_FAT16_compliance+0x164>
81134400:	e0bffa17 	ldw	r2,-24(fp)
81134404:	e0ffff17 	ldw	r3,-4(fp)
81134408:	1885883a 	add	r2,r3,r2
8113440c:	10800003 	ldbu	r2,0(r2)
81134410:	10803fcc 	andi	r2,r2,255
81134414:	1080201c 	xori	r2,r2,128
81134418:	10bfe004 	addi	r2,r2,-128
8113441c:	10800be0 	cmpeqi	r2,r2,47
81134420:	1000281e 	bne	r2,zero,811344c4 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81134424:	e0fffa17 	ldw	r3,-24(fp)
81134428:	e0bffc17 	ldw	r2,-16(fp)
8113442c:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81134430:	10800258 	cmpnei	r2,r2,9
81134434:	1000091e 	bne	r2,zero,8113445c <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81134438:	e0bffa17 	ldw	r2,-24(fp)
8113443c:	e0ffff17 	ldw	r3,-4(fp)
81134440:	1885883a 	add	r2,r3,r2
81134444:	10800003 	ldbu	r2,0(r2)
81134448:	10803fcc 	andi	r2,r2,255
8113444c:	1080201c 	xori	r2,r2,128
81134450:	10bfe004 	addi	r2,r2,-128
81134454:	10800b98 	cmpnei	r2,r2,46
81134458:	10001a1e 	bne	r2,zero,811344c4 <check_file_name_for_FAT16_compliance+0x164>
8113445c:	e0fffb17 	ldw	r3,-20(fp)
81134460:	e0bffc17 	ldw	r2,-16(fp)
81134464:	18801926 	beq	r3,r2,811344cc <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81134468:	e0fffa17 	ldw	r3,-24(fp)
8113446c:	e0bffc17 	ldw	r2,-16(fp)
81134470:	1885c83a 	sub	r2,r3,r2
81134474:	10800110 	cmplti	r2,r2,4
81134478:	1000141e 	bne	r2,zero,811344cc <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113447c:	e0bffa17 	ldw	r2,-24(fp)
81134480:	e0ffff17 	ldw	r3,-4(fp)
81134484:	1885883a 	add	r2,r3,r2
81134488:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113448c:	10803fcc 	andi	r2,r2,255
81134490:	1080201c 	xori	r2,r2,128
81134494:	10bfe004 	addi	r2,r2,-128
81134498:	10801720 	cmpeqi	r2,r2,92
8113449c:	10000b1e 	bne	r2,zero,811344cc <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
811344a0:	e0bffa17 	ldw	r2,-24(fp)
811344a4:	e0ffff17 	ldw	r3,-4(fp)
811344a8:	1885883a 	add	r2,r3,r2
811344ac:	10800003 	ldbu	r2,0(r2)
811344b0:	10803fcc 	andi	r2,r2,255
811344b4:	1080201c 	xori	r2,r2,128
811344b8:	10bfe004 	addi	r2,r2,-128
811344bc:	10800be0 	cmpeqi	r2,r2,47
811344c0:	1000021e 	bne	r2,zero,811344cc <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
811344c4:	e03ffd15 	stw	zero,-12(fp)
            break;
811344c8:	00002706 	br	81134568 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
811344cc:	e0bffa17 	ldw	r2,-24(fp)
811344d0:	e0ffff17 	ldw	r3,-4(fp)
811344d4:	1885883a 	add	r2,r3,r2
811344d8:	10800003 	ldbu	r2,0(r2)
811344dc:	10803fcc 	andi	r2,r2,255
811344e0:	1080201c 	xori	r2,r2,128
811344e4:	10bfe004 	addi	r2,r2,-128
811344e8:	10801720 	cmpeqi	r2,r2,92
811344ec:	1000091e 	bne	r2,zero,81134514 <check_file_name_for_FAT16_compliance+0x1b4>
811344f0:	e0bffa17 	ldw	r2,-24(fp)
811344f4:	e0ffff17 	ldw	r3,-4(fp)
811344f8:	1885883a 	add	r2,r3,r2
811344fc:	10800003 	ldbu	r2,0(r2)
81134500:	10803fcc 	andi	r2,r2,255
81134504:	1080201c 	xori	r2,r2,128
81134508:	10bfe004 	addi	r2,r2,-128
8113450c:	10800bd8 	cmpnei	r2,r2,47
81134510:	1000041e 	bne	r2,zero,81134524 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
81134514:	e0bffa17 	ldw	r2,-24(fp)
81134518:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
8113451c:	e0bffa17 	ldw	r2,-24(fp)
81134520:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
81134524:	e0bffa17 	ldw	r2,-24(fp)
81134528:	e0ffff17 	ldw	r3,-4(fp)
8113452c:	1885883a 	add	r2,r3,r2
81134530:	10800003 	ldbu	r2,0(r2)
81134534:	10803fcc 	andi	r2,r2,255
81134538:	1080201c 	xori	r2,r2,128
8113453c:	10bfe004 	addi	r2,r2,-128
81134540:	10800b98 	cmpnei	r2,r2,46
81134544:	1000021e 	bne	r2,zero,81134550 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
81134548:	e0bffa17 	ldw	r2,-24(fp)
8113454c:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
81134550:	e0bffa17 	ldw	r2,-24(fp)
81134554:	10800044 	addi	r2,r2,1
81134558:	e0bffa15 	stw	r2,-24(fp)
8113455c:	e0fffa17 	ldw	r3,-24(fp)
81134560:	e0bffe17 	ldw	r2,-8(fp)
81134564:	18bf9016 	blt	r3,r2,811343a8 <__reset+0xfb1143a8>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
81134568:	e0bffe17 	ldw	r2,-8(fp)
8113456c:	10bfffc4 	addi	r2,r2,-1
81134570:	e0ffff17 	ldw	r3,-4(fp)
81134574:	1885883a 	add	r2,r3,r2
81134578:	10800003 	ldbu	r2,0(r2)
8113457c:	10803fcc 	andi	r2,r2,255
81134580:	1080201c 	xori	r2,r2,128
81134584:	10bfe004 	addi	r2,r2,-128
81134588:	10801720 	cmpeqi	r2,r2,92
8113458c:	10000a1e 	bne	r2,zero,811345b8 <check_file_name_for_FAT16_compliance+0x258>
81134590:	e0bffe17 	ldw	r2,-8(fp)
81134594:	10bfffc4 	addi	r2,r2,-1
81134598:	e0ffff17 	ldw	r3,-4(fp)
8113459c:	1885883a 	add	r2,r3,r2
811345a0:	10800003 	ldbu	r2,0(r2)
811345a4:	10803fcc 	andi	r2,r2,255
811345a8:	1080201c 	xori	r2,r2,128
811345ac:	10bfe004 	addi	r2,r2,-128
811345b0:	10800bd8 	cmpnei	r2,r2,47
811345b4:	1000011e 	bne	r2,zero,811345bc <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
811345b8:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
811345bc:	e0bffd17 	ldw	r2,-12(fp)
}
811345c0:	e037883a 	mov	sp,fp
811345c4:	dfc00117 	ldw	ra,4(sp)
811345c8:	df000017 	ldw	fp,0(sp)
811345cc:	dec00204 	addi	sp,sp,8
811345d0:	f800283a 	ret

811345d4 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
811345d4:	defffb04 	addi	sp,sp,-20
811345d8:	de00012e 	bgeu	sp,et,811345e0 <get_dir_divider_location+0xc>
811345dc:	003b68fa 	trap	3
811345e0:	dfc00415 	stw	ra,16(sp)
811345e4:	df000315 	stw	fp,12(sp)
811345e8:	df000304 	addi	fp,sp,12
811345ec:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
811345f0:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
811345f4:	e13fff17 	ldw	r4,-4(fp)
811345f8:	111405c0 	call	8111405c <strlen>
811345fc:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
81134600:	e03ffd15 	stw	zero,-12(fp)
81134604:	00001506 	br	8113465c <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
81134608:	e0bffd17 	ldw	r2,-12(fp)
8113460c:	e0ffff17 	ldw	r3,-4(fp)
81134610:	1885883a 	add	r2,r3,r2
81134614:	10800003 	ldbu	r2,0(r2)
81134618:	10803fcc 	andi	r2,r2,255
8113461c:	1080201c 	xori	r2,r2,128
81134620:	10bfe004 	addi	r2,r2,-128
81134624:	10801720 	cmpeqi	r2,r2,92
81134628:	10000f1e 	bne	r2,zero,81134668 <get_dir_divider_location+0x94>
8113462c:	e0bffd17 	ldw	r2,-12(fp)
81134630:	e0ffff17 	ldw	r3,-4(fp)
81134634:	1885883a 	add	r2,r3,r2
81134638:	10800003 	ldbu	r2,0(r2)
8113463c:	10803fcc 	andi	r2,r2,255
81134640:	1080201c 	xori	r2,r2,128
81134644:	10bfe004 	addi	r2,r2,-128
81134648:	10800be0 	cmpeqi	r2,r2,47
8113464c:	1000061e 	bne	r2,zero,81134668 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
81134650:	e0bffd17 	ldw	r2,-12(fp)
81134654:	10800044 	addi	r2,r2,1
81134658:	e0bffd15 	stw	r2,-12(fp)
8113465c:	e0fffd17 	ldw	r3,-12(fp)
81134660:	e0bffe17 	ldw	r2,-8(fp)
81134664:	18bfe816 	blt	r3,r2,81134608 <__reset+0xfb114608>
        {
            break;
        }
    }
    
    if (index == length)
81134668:	e0fffd17 	ldw	r3,-12(fp)
8113466c:	e0bffe17 	ldw	r2,-8(fp)
81134670:	1880021e 	bne	r3,r2,8113467c <get_dir_divider_location+0xa8>
    {
        index = -1;
81134674:	00bfffc4 	movi	r2,-1
81134678:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
8113467c:	e0bffd17 	ldw	r2,-12(fp)
}
81134680:	e037883a 	mov	sp,fp
81134684:	dfc00117 	ldw	ra,4(sp)
81134688:	df000017 	ldw	fp,0(sp)
8113468c:	dec00204 	addi	sp,sp,8
81134690:	f800283a 	ret

81134694 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
81134694:	defffa04 	addi	sp,sp,-24
81134698:	de00012e 	bgeu	sp,et,811346a0 <match_file_record_to_name_ext+0xc>
8113469c:	003b68fa 	trap	3
811346a0:	df000515 	stw	fp,20(sp)
811346a4:	df000504 	addi	fp,sp,20
811346a8:	e13ffd15 	stw	r4,-12(fp)
811346ac:	e17ffe15 	stw	r5,-8(fp)
811346b0:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
811346b4:	00800044 	movi	r2,1
811346b8:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
811346bc:	e03ffc15 	stw	zero,-16(fp)
811346c0:	00004606 	br	811347dc <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
811346c4:	e0fffd17 	ldw	r3,-12(fp)
811346c8:	e0bffc17 	ldw	r2,-16(fp)
811346cc:	1885883a 	add	r2,r3,r2
811346d0:	10800003 	ldbu	r2,0(r2)
811346d4:	10803fcc 	andi	r2,r2,255
811346d8:	10801870 	cmpltui	r2,r2,97
811346dc:	1000101e 	bne	r2,zero,81134720 <match_file_record_to_name_ext+0x8c>
811346e0:	e0fffd17 	ldw	r3,-12(fp)
811346e4:	e0bffc17 	ldw	r2,-16(fp)
811346e8:	1885883a 	add	r2,r3,r2
811346ec:	10800003 	ldbu	r2,0(r2)
811346f0:	10803fcc 	andi	r2,r2,255
811346f4:	10801ee8 	cmpgeui	r2,r2,123
811346f8:	1000091e 	bne	r2,zero,81134720 <match_file_record_to_name_ext+0x8c>
811346fc:	e0fffd17 	ldw	r3,-12(fp)
81134700:	e0bffc17 	ldw	r2,-16(fp)
81134704:	1885883a 	add	r2,r3,r2
81134708:	10800003 	ldbu	r2,0(r2)
8113470c:	10bff804 	addi	r2,r2,-32
81134710:	10c03fcc 	andi	r3,r2,255
81134714:	18c0201c 	xori	r3,r3,128
81134718:	18ffe004 	addi	r3,r3,-128
8113471c:	00000706 	br	8113473c <match_file_record_to_name_ext+0xa8>
81134720:	e0fffd17 	ldw	r3,-12(fp)
81134724:	e0bffc17 	ldw	r2,-16(fp)
81134728:	1885883a 	add	r2,r3,r2
8113472c:	10800003 	ldbu	r2,0(r2)
81134730:	10c03fcc 	andi	r3,r2,255
81134734:	18c0201c 	xori	r3,r3,128
81134738:	18ffe004 	addi	r3,r3,-128
8113473c:	e0bffc17 	ldw	r2,-16(fp)
81134740:	e13ffe17 	ldw	r4,-8(fp)
81134744:	2085883a 	add	r2,r4,r2
81134748:	10800003 	ldbu	r2,0(r2)
8113474c:	10803fcc 	andi	r2,r2,255
81134750:	1080201c 	xori	r2,r2,128
81134754:	10bfe004 	addi	r2,r2,-128
81134758:	10801850 	cmplti	r2,r2,97
8113475c:	1000121e 	bne	r2,zero,811347a8 <match_file_record_to_name_ext+0x114>
81134760:	e0bffc17 	ldw	r2,-16(fp)
81134764:	e13ffe17 	ldw	r4,-8(fp)
81134768:	2085883a 	add	r2,r4,r2
8113476c:	10800003 	ldbu	r2,0(r2)
81134770:	10803fcc 	andi	r2,r2,255
81134774:	1080201c 	xori	r2,r2,128
81134778:	10bfe004 	addi	r2,r2,-128
8113477c:	10801ec8 	cmpgei	r2,r2,123
81134780:	1000091e 	bne	r2,zero,811347a8 <match_file_record_to_name_ext+0x114>
81134784:	e0bffc17 	ldw	r2,-16(fp)
81134788:	e13ffe17 	ldw	r4,-8(fp)
8113478c:	2085883a 	add	r2,r4,r2
81134790:	10800003 	ldbu	r2,0(r2)
81134794:	10bff804 	addi	r2,r2,-32
81134798:	10803fcc 	andi	r2,r2,255
8113479c:	1080201c 	xori	r2,r2,128
811347a0:	10bfe004 	addi	r2,r2,-128
811347a4:	00000706 	br	811347c4 <match_file_record_to_name_ext+0x130>
811347a8:	e0bffc17 	ldw	r2,-16(fp)
811347ac:	e13ffe17 	ldw	r4,-8(fp)
811347b0:	2085883a 	add	r2,r4,r2
811347b4:	10800003 	ldbu	r2,0(r2)
811347b8:	10803fcc 	andi	r2,r2,255
811347bc:	1080201c 	xori	r2,r2,128
811347c0:	10bfe004 	addi	r2,r2,-128
811347c4:	18800226 	beq	r3,r2,811347d0 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
811347c8:	e03ffb15 	stw	zero,-20(fp)
			break;
811347cc:	00000606 	br	811347e8 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
811347d0:	e0bffc17 	ldw	r2,-16(fp)
811347d4:	10800044 	addi	r2,r2,1
811347d8:	e0bffc15 	stw	r2,-16(fp)
811347dc:	e0bffc17 	ldw	r2,-16(fp)
811347e0:	10800210 	cmplti	r2,r2,8
811347e4:	103fb71e 	bne	r2,zero,811346c4 <__reset+0xfb1146c4>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
811347e8:	e03ffc15 	stw	zero,-16(fp)
811347ec:	00004a06 	br	81134918 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
811347f0:	e0fffd17 	ldw	r3,-12(fp)
811347f4:	e0bffc17 	ldw	r2,-16(fp)
811347f8:	1885883a 	add	r2,r3,r2
811347fc:	10800204 	addi	r2,r2,8
81134800:	10800003 	ldbu	r2,0(r2)
81134804:	10803fcc 	andi	r2,r2,255
81134808:	10801870 	cmpltui	r2,r2,97
8113480c:	1000121e 	bne	r2,zero,81134858 <match_file_record_to_name_ext+0x1c4>
81134810:	e0fffd17 	ldw	r3,-12(fp)
81134814:	e0bffc17 	ldw	r2,-16(fp)
81134818:	1885883a 	add	r2,r3,r2
8113481c:	10800204 	addi	r2,r2,8
81134820:	10800003 	ldbu	r2,0(r2)
81134824:	10803fcc 	andi	r2,r2,255
81134828:	10801ee8 	cmpgeui	r2,r2,123
8113482c:	10000a1e 	bne	r2,zero,81134858 <match_file_record_to_name_ext+0x1c4>
81134830:	e0fffd17 	ldw	r3,-12(fp)
81134834:	e0bffc17 	ldw	r2,-16(fp)
81134838:	1885883a 	add	r2,r3,r2
8113483c:	10800204 	addi	r2,r2,8
81134840:	10800003 	ldbu	r2,0(r2)
81134844:	10bff804 	addi	r2,r2,-32
81134848:	10c03fcc 	andi	r3,r2,255
8113484c:	18c0201c 	xori	r3,r3,128
81134850:	18ffe004 	addi	r3,r3,-128
81134854:	00000806 	br	81134878 <match_file_record_to_name_ext+0x1e4>
81134858:	e0fffd17 	ldw	r3,-12(fp)
8113485c:	e0bffc17 	ldw	r2,-16(fp)
81134860:	1885883a 	add	r2,r3,r2
81134864:	10800204 	addi	r2,r2,8
81134868:	10800003 	ldbu	r2,0(r2)
8113486c:	10c03fcc 	andi	r3,r2,255
81134870:	18c0201c 	xori	r3,r3,128
81134874:	18ffe004 	addi	r3,r3,-128
81134878:	e0bffc17 	ldw	r2,-16(fp)
8113487c:	e13fff17 	ldw	r4,-4(fp)
81134880:	2085883a 	add	r2,r4,r2
81134884:	10800003 	ldbu	r2,0(r2)
81134888:	10803fcc 	andi	r2,r2,255
8113488c:	1080201c 	xori	r2,r2,128
81134890:	10bfe004 	addi	r2,r2,-128
81134894:	10801850 	cmplti	r2,r2,97
81134898:	1000121e 	bne	r2,zero,811348e4 <match_file_record_to_name_ext+0x250>
8113489c:	e0bffc17 	ldw	r2,-16(fp)
811348a0:	e13fff17 	ldw	r4,-4(fp)
811348a4:	2085883a 	add	r2,r4,r2
811348a8:	10800003 	ldbu	r2,0(r2)
811348ac:	10803fcc 	andi	r2,r2,255
811348b0:	1080201c 	xori	r2,r2,128
811348b4:	10bfe004 	addi	r2,r2,-128
811348b8:	10801ec8 	cmpgei	r2,r2,123
811348bc:	1000091e 	bne	r2,zero,811348e4 <match_file_record_to_name_ext+0x250>
811348c0:	e0bffc17 	ldw	r2,-16(fp)
811348c4:	e13fff17 	ldw	r4,-4(fp)
811348c8:	2085883a 	add	r2,r4,r2
811348cc:	10800003 	ldbu	r2,0(r2)
811348d0:	10bff804 	addi	r2,r2,-32
811348d4:	10803fcc 	andi	r2,r2,255
811348d8:	1080201c 	xori	r2,r2,128
811348dc:	10bfe004 	addi	r2,r2,-128
811348e0:	00000706 	br	81134900 <match_file_record_to_name_ext+0x26c>
811348e4:	e0bffc17 	ldw	r2,-16(fp)
811348e8:	e13fff17 	ldw	r4,-4(fp)
811348ec:	2085883a 	add	r2,r4,r2
811348f0:	10800003 	ldbu	r2,0(r2)
811348f4:	10803fcc 	andi	r2,r2,255
811348f8:	1080201c 	xori	r2,r2,128
811348fc:	10bfe004 	addi	r2,r2,-128
81134900:	18800226 	beq	r3,r2,8113490c <match_file_record_to_name_ext+0x278>
        {
            match = false;
81134904:	e03ffb15 	stw	zero,-20(fp)
			break;
81134908:	00000606 	br	81134924 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113490c:	e0bffc17 	ldw	r2,-16(fp)
81134910:	10800044 	addi	r2,r2,1
81134914:	e0bffc15 	stw	r2,-16(fp)
81134918:	e0bffc17 	ldw	r2,-16(fp)
8113491c:	108000d0 	cmplti	r2,r2,3
81134920:	103fb31e 	bne	r2,zero,811347f0 <__reset+0xfb1147f0>
        {
            match = false;
			break;
        }
    }
	return match;
81134924:	e0bffb17 	ldw	r2,-20(fp)
}
81134928:	e037883a 	mov	sp,fp
8113492c:	df000017 	ldw	fp,0(sp)
81134930:	dec00104 	addi	sp,sp,4
81134934:	f800283a 	ret

81134938 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
81134938:	deffe704 	addi	sp,sp,-100
8113493c:	de00012e 	bgeu	sp,et,81134944 <get_home_directory_cluster_for_file+0xc>
81134940:	003b68fa 	trap	3
81134944:	dfc01815 	stw	ra,96(sp)
81134948:	df001715 	stw	fp,92(sp)
8113494c:	df001704 	addi	fp,sp,92
81134950:	e13ffd15 	stw	r4,-12(fp)
81134954:	e17ffe15 	stw	r5,-8(fp)
81134958:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
8113495c:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
81134960:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
81134964:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
81134968:	e13ffd17 	ldw	r4,-12(fp)
8113496c:	11345d40 	call	811345d4 <get_dir_divider_location>
81134970:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
81134974:	00012f06 	br	81134e34 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81134978:	00800804 	movi	r2,32
8113497c:	e0bff905 	stb	r2,-28(fp)
81134980:	00800804 	movi	r2,32
81134984:	e0bff945 	stb	r2,-27(fp)
81134988:	00800804 	movi	r2,32
8113498c:	e0bff985 	stb	r2,-26(fp)
81134990:	00800804 	movi	r2,32
81134994:	e0bff9c5 	stb	r2,-25(fp)
81134998:	00800804 	movi	r2,32
8113499c:	e0bffa05 	stb	r2,-24(fp)
811349a0:	00800804 	movi	r2,32
811349a4:	e0bffa45 	stb	r2,-23(fp)
811349a8:	00800804 	movi	r2,32
811349ac:	e0bffa85 	stb	r2,-22(fp)
811349b0:	00800804 	movi	r2,32
811349b4:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
811349b8:	00800804 	movi	r2,32
811349bc:	e0bffb05 	stb	r2,-20(fp)
811349c0:	00800804 	movi	r2,32
811349c4:	e0bffb45 	stb	r2,-19(fp)
811349c8:	00800804 	movi	r2,32
811349cc:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
811349d0:	00bfffc4 	movi	r2,-1
811349d4:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
811349d8:	e0bfea17 	ldw	r2,-88(fp)
811349dc:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
811349e0:	e03fec15 	stw	zero,-80(fp)
811349e4:	00002d06 	br	81134a9c <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
811349e8:	e0ffec17 	ldw	r3,-80(fp)
811349ec:	e0bfed17 	ldw	r2,-76(fp)
811349f0:	1885883a 	add	r2,r3,r2
811349f4:	1007883a 	mov	r3,r2
811349f8:	e0bffd17 	ldw	r2,-12(fp)
811349fc:	10c5883a 	add	r2,r2,r3
81134a00:	10800003 	ldbu	r2,0(r2)
81134a04:	10803fcc 	andi	r2,r2,255
81134a08:	1080201c 	xori	r2,r2,128
81134a0c:	10bfe004 	addi	r2,r2,-128
81134a10:	10800b98 	cmpnei	r2,r2,46
81134a14:	1000031e 	bne	r2,zero,81134a24 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
81134a18:	e0bfec17 	ldw	r2,-80(fp)
81134a1c:	e0bfee15 	stw	r2,-72(fp)
81134a20:	00001b06 	br	81134a90 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81134a24:	e0bfee17 	ldw	r2,-72(fp)
81134a28:	10000c0e 	bge	r2,zero,81134a5c <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81134a2c:	e0ffec17 	ldw	r3,-80(fp)
81134a30:	e0bfed17 	ldw	r2,-76(fp)
81134a34:	1885883a 	add	r2,r3,r2
81134a38:	1007883a 	mov	r3,r2
81134a3c:	e0bffd17 	ldw	r2,-12(fp)
81134a40:	10c5883a 	add	r2,r2,r3
81134a44:	10c00003 	ldbu	r3,0(r2)
81134a48:	e13ff904 	addi	r4,fp,-28
81134a4c:	e0bfec17 	ldw	r2,-80(fp)
81134a50:	2085883a 	add	r2,r4,r2
81134a54:	10c00005 	stb	r3,0(r2)
81134a58:	00000d06 	br	81134a90 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
81134a5c:	e0ffec17 	ldw	r3,-80(fp)
81134a60:	e0bfee17 	ldw	r2,-72(fp)
81134a64:	1885c83a 	sub	r2,r3,r2
81134a68:	e13fec17 	ldw	r4,-80(fp)
81134a6c:	e0ffed17 	ldw	r3,-76(fp)
81134a70:	20c7883a 	add	r3,r4,r3
81134a74:	1809883a 	mov	r4,r3
81134a78:	e0fffd17 	ldw	r3,-12(fp)
81134a7c:	1907883a 	add	r3,r3,r4
81134a80:	18c00003 	ldbu	r3,0(r3)
81134a84:	e13ffb04 	addi	r4,fp,-20
81134a88:	2085883a 	add	r2,r4,r2
81134a8c:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81134a90:	e0bfec17 	ldw	r2,-80(fp)
81134a94:	10800044 	addi	r2,r2,1
81134a98:	e0bfec15 	stw	r2,-80(fp)
81134a9c:	e0ffec17 	ldw	r3,-80(fp)
81134aa0:	e0bfeb17 	ldw	r2,-84(fp)
81134aa4:	18bfd016 	blt	r3,r2,811349e8 <__reset+0xfb1149e8>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
81134aa8:	e0bfea17 	ldw	r2,-88(fp)
81134aac:	10005c1e 	bne	r2,zero,81134c20 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81134ab0:	00a04574 	movhi	r2,33045
81134ab4:	1094b704 	addi	r2,r2,21212
81134ab8:	1080050b 	ldhu	r2,20(r2)
81134abc:	10bfffcc 	andi	r2,r2,65535
81134ac0:	1006917a 	slli	r3,r2,5
81134ac4:	00a04574 	movhi	r2,33045
81134ac8:	1094b704 	addi	r2,r2,21212
81134acc:	1080030b 	ldhu	r2,12(r2)
81134ad0:	10bfffcc 	andi	r2,r2,65535
81134ad4:	1885283a 	div	r2,r3,r2
81134ad8:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81134adc:	e03ff015 	stw	zero,-64(fp)
81134ae0:	00003b06 	br	81134bd0 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
81134ae4:	00a04574 	movhi	r2,33045
81134ae8:	1094b704 	addi	r2,r2,21212
81134aec:	10c01317 	ldw	r3,76(r2)
81134af0:	e0bff017 	ldw	r2,-64(fp)
81134af4:	1885883a 	add	r2,r3,r2
81134af8:	1007883a 	mov	r3,r2
81134afc:	d0a09517 	ldw	r2,-32172(gp)
81134b00:	100b883a 	mov	r5,r2
81134b04:	1809883a 	mov	r4,r3
81134b08:	11331d00 	call	811331d0 <Read_Sector_Data>
81134b0c:	10003426 	beq	r2,zero,81134be0 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81134b10:	e03ff115 	stw	zero,-60(fp)
81134b14:	00002506 	br	81134bac <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81134b18:	e0bff117 	ldw	r2,-60(fp)
81134b1c:	1004917a 	slli	r2,r2,5
81134b20:	e0fff017 	ldw	r3,-64(fp)
81134b24:	180f883a 	mov	r7,r3
81134b28:	000d883a 	mov	r6,zero
81134b2c:	e17fff17 	ldw	r5,-4(fp)
81134b30:	1009883a 	mov	r4,r2
81134b34:	11336000 	call	81133600 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81134b38:	e0bfff17 	ldw	r2,-4(fp)
81134b3c:	10800003 	ldbu	r2,0(r2)
81134b40:	10803fcc 	andi	r2,r2,255
81134b44:	10803960 	cmpeqi	r2,r2,229
81134b48:	1000151e 	bne	r2,zero,81134ba0 <get_home_directory_cluster_for_file+0x268>
81134b4c:	e0bfff17 	ldw	r2,-4(fp)
81134b50:	10800003 	ldbu	r2,0(r2)
81134b54:	10803fcc 	andi	r2,r2,255
81134b58:	10001126 	beq	r2,zero,81134ba0 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81134b5c:	e0fffb04 	addi	r3,fp,-20
81134b60:	e0bff904 	addi	r2,fp,-28
81134b64:	180d883a 	mov	r6,r3
81134b68:	100b883a 	mov	r5,r2
81134b6c:	e13fff17 	ldw	r4,-4(fp)
81134b70:	11346940 	call	81134694 <match_file_record_to_name_ext>
81134b74:	e0bff815 	stw	r2,-32(fp)
                            if (match)
81134b78:	e0bff817 	ldw	r2,-32(fp)
81134b7c:	10000826 	beq	r2,zero,81134ba0 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81134b80:	e0bfff17 	ldw	r2,-4(fp)
81134b84:	1080058b 	ldhu	r2,22(r2)
81134b88:	10bfffcc 	andi	r2,r2,65535
81134b8c:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
81134b90:	e0bfff17 	ldw	r2,-4(fp)
81134b94:	00c00044 	movi	r3,1
81134b98:	10c00a15 	stw	r3,40(r2)
                                break;
81134b9c:	00000606 	br	81134bb8 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81134ba0:	e0bff117 	ldw	r2,-60(fp)
81134ba4:	10800044 	addi	r2,r2,1
81134ba8:	e0bff115 	stw	r2,-60(fp)
81134bac:	e0bff117 	ldw	r2,-60(fp)
81134bb0:	10800410 	cmplti	r2,r2,16
81134bb4:	103fd81e 	bne	r2,zero,81134b18 <__reset+0xfb114b18>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
81134bb8:	e0ffef17 	ldw	r3,-68(fp)
81134bbc:	e0bfea17 	ldw	r2,-88(fp)
81134bc0:	1880091e 	bne	r3,r2,81134be8 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81134bc4:	e0bff017 	ldw	r2,-64(fp)
81134bc8:	10800044 	addi	r2,r2,1
81134bcc:	e0bff015 	stw	r2,-64(fp)
81134bd0:	e0fff017 	ldw	r3,-64(fp)
81134bd4:	e0bff717 	ldw	r2,-36(fp)
81134bd8:	18bfc216 	blt	r3,r2,81134ae4 <__reset+0xfb114ae4>
81134bdc:	00000306 	br	81134bec <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81134be0:	0001883a 	nop
81134be4:	00000106 	br	81134bec <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
81134be8:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81134bec:	e0ffef17 	ldw	r3,-68(fp)
81134bf0:	e0bfea17 	ldw	r2,-88(fp)
81134bf4:	18800826 	beq	r3,r2,81134c18 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81134bf8:	e0bfef17 	ldw	r2,-68(fp)
81134bfc:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81134c00:	e0ffed17 	ldw	r3,-76(fp)
81134c04:	e0bfeb17 	ldw	r2,-84(fp)
81134c08:	1885883a 	add	r2,r3,r2
81134c0c:	10800044 	addi	r2,r2,1
81134c10:	e0bfed15 	stw	r2,-76(fp)
81134c14:	00007d06 	br	81134e0c <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81134c18:	0005883a 	mov	r2,zero
81134c1c:	00009106 	br	81134e64 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81134c20:	e0bfea17 	ldw	r2,-88(fp)
81134c24:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81134c28:	e0bff417 	ldw	r2,-48(fp)
81134c2c:	10ffff84 	addi	r3,r2,-2
81134c30:	00a04574 	movhi	r2,33045
81134c34:	1094b704 	addi	r2,r2,21212
81134c38:	10800383 	ldbu	r2,14(r2)
81134c3c:	10803fcc 	andi	r2,r2,255
81134c40:	1885383a 	mul	r2,r3,r2
81134c44:	1007883a 	mov	r3,r2
81134c48:	00a04574 	movhi	r2,33045
81134c4c:	1094b704 	addi	r2,r2,21212
81134c50:	10801417 	ldw	r2,80(r2)
81134c54:	1885883a 	add	r2,r3,r2
81134c58:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81134c5c:	e03ff215 	stw	zero,-56(fp)
81134c60:	00003606 	br	81134d3c <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81134c64:	e0fff217 	ldw	r3,-56(fp)
81134c68:	e0bff517 	ldw	r2,-44(fp)
81134c6c:	1885883a 	add	r2,r3,r2
81134c70:	d0e09517 	ldw	r3,-32172(gp)
81134c74:	180b883a 	mov	r5,r3
81134c78:	1009883a 	mov	r4,r2
81134c7c:	11331d00 	call	811331d0 <Read_Sector_Data>
81134c80:	10003526 	beq	r2,zero,81134d58 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81134c84:	e03ff315 	stw	zero,-52(fp)
81134c88:	00002306 	br	81134d18 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81134c8c:	e0bff317 	ldw	r2,-52(fp)
81134c90:	1004917a 	slli	r2,r2,5
81134c94:	e0fff417 	ldw	r3,-48(fp)
81134c98:	e13ff217 	ldw	r4,-56(fp)
81134c9c:	200f883a 	mov	r7,r4
81134ca0:	180d883a 	mov	r6,r3
81134ca4:	e17fff17 	ldw	r5,-4(fp)
81134ca8:	1009883a 	mov	r4,r2
81134cac:	11336000 	call	81133600 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81134cb0:	e0bfff17 	ldw	r2,-4(fp)
81134cb4:	10800003 	ldbu	r2,0(r2)
81134cb8:	10803fcc 	andi	r2,r2,255
81134cbc:	10803960 	cmpeqi	r2,r2,229
81134cc0:	1000121e 	bne	r2,zero,81134d0c <get_home_directory_cluster_for_file+0x3d4>
81134cc4:	e0bfff17 	ldw	r2,-4(fp)
81134cc8:	10800003 	ldbu	r2,0(r2)
81134ccc:	10803fcc 	andi	r2,r2,255
81134cd0:	10000e26 	beq	r2,zero,81134d0c <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
81134cd4:	e0fffb04 	addi	r3,fp,-20
81134cd8:	e0bff904 	addi	r2,fp,-28
81134cdc:	180d883a 	mov	r6,r3
81134ce0:	100b883a 	mov	r5,r2
81134ce4:	e13fff17 	ldw	r4,-4(fp)
81134ce8:	11346940 	call	81134694 <match_file_record_to_name_ext>
81134cec:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81134cf0:	e0bff617 	ldw	r2,-40(fp)
81134cf4:	10000526 	beq	r2,zero,81134d0c <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
81134cf8:	e0bfff17 	ldw	r2,-4(fp)
81134cfc:	1080058b 	ldhu	r2,22(r2)
81134d00:	10bfffcc 	andi	r2,r2,65535
81134d04:	e0bfef15 	stw	r2,-68(fp)
                                    break;
81134d08:	00000606 	br	81134d24 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81134d0c:	e0bff317 	ldw	r2,-52(fp)
81134d10:	10800044 	addi	r2,r2,1
81134d14:	e0bff315 	stw	r2,-52(fp)
81134d18:	e0bff317 	ldw	r2,-52(fp)
81134d1c:	10800410 	cmplti	r2,r2,16
81134d20:	103fda1e 	bne	r2,zero,81134c8c <__reset+0xfb114c8c>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
81134d24:	e0ffef17 	ldw	r3,-68(fp)
81134d28:	e0bfea17 	ldw	r2,-88(fp)
81134d2c:	18800c1e 	bne	r3,r2,81134d60 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81134d30:	e0bff217 	ldw	r2,-56(fp)
81134d34:	10800044 	addi	r2,r2,1
81134d38:	e0bff215 	stw	r2,-56(fp)
81134d3c:	00a04574 	movhi	r2,33045
81134d40:	1094b704 	addi	r2,r2,21212
81134d44:	10800383 	ldbu	r2,14(r2)
81134d48:	10803fcc 	andi	r2,r2,255
81134d4c:	e0fff217 	ldw	r3,-56(fp)
81134d50:	18bfc416 	blt	r3,r2,81134c64 <__reset+0xfb114c64>
81134d54:	00000306 	br	81134d64 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
81134d58:	0001883a 	nop
81134d5c:	00000106 	br	81134d64 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
81134d60:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
81134d64:	e0ffef17 	ldw	r3,-68(fp)
81134d68:	e0bfea17 	ldw	r2,-88(fp)
81134d6c:	1880141e 	bne	r3,r2,81134dc0 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
81134d70:	e0bfef17 	ldw	r2,-68(fp)
81134d74:	e0fffc04 	addi	r3,fp,-16
81134d78:	180b883a 	mov	r5,r3
81134d7c:	1009883a 	mov	r4,r2
81134d80:	11332b00 	call	811332b0 <get_cluster_flag>
81134d84:	10000c26 	beq	r2,zero,81134db8 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81134d88:	e0bffc0b 	ldhu	r2,-16(fp)
81134d8c:	10bfffcc 	andi	r2,r2,65535
81134d90:	10fffe0c 	andi	r3,r2,65528
81134d94:	00bffe14 	movui	r2,65528
81134d98:	1880021e 	bne	r3,r2,81134da4 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81134d9c:	0005883a 	mov	r2,zero
81134da0:	00003006 	br	81134e64 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81134da4:	e0bffc0b 	ldhu	r2,-16(fp)
81134da8:	10bfffcc 	andi	r2,r2,65535
81134dac:	10bffe0c 	andi	r2,r2,65528
81134db0:	e0bfef15 	stw	r2,-68(fp)
81134db4:	00000206 	br	81134dc0 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81134db8:	0005883a 	mov	r2,zero
81134dbc:	00002906 	br	81134e64 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81134dc0:	e0bff417 	ldw	r2,-48(fp)
81134dc4:	00fffdd4 	movui	r3,65527
81134dc8:	18800316 	blt	r3,r2,81134dd8 <get_home_directory_cluster_for_file+0x4a0>
81134dcc:	e0ffef17 	ldw	r3,-68(fp)
81134dd0:	e0bfea17 	ldw	r2,-88(fp)
81134dd4:	18bf9426 	beq	r3,r2,81134c28 <__reset+0xfb114c28>
            if (new_cluster != home_dir_cluster)
81134dd8:	e0ffef17 	ldw	r3,-68(fp)
81134ddc:	e0bfea17 	ldw	r2,-88(fp)
81134de0:	18800826 	beq	r3,r2,81134e04 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81134de4:	e0bfef17 	ldw	r2,-68(fp)
81134de8:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81134dec:	e0ffed17 	ldw	r3,-76(fp)
81134df0:	e0bfeb17 	ldw	r2,-84(fp)
81134df4:	1885883a 	add	r2,r3,r2
81134df8:	10800044 	addi	r2,r2,1
81134dfc:	e0bfed15 	stw	r2,-76(fp)
81134e00:	00000206 	br	81134e0c <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81134e04:	0005883a 	mov	r2,zero
81134e08:	00001606 	br	81134e64 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81134e0c:	e0bfed17 	ldw	r2,-76(fp)
81134e10:	e0fffd17 	ldw	r3,-12(fp)
81134e14:	1885883a 	add	r2,r3,r2
81134e18:	1009883a 	mov	r4,r2
81134e1c:	11345d40 	call	811345d4 <get_dir_divider_location>
81134e20:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81134e24:	e0bfeb17 	ldw	r2,-84(fp)
81134e28:	1000020e 	bge	r2,zero,81134e34 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81134e2c:	00800044 	movi	r2,1
81134e30:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81134e34:	e0bfeb17 	ldw	r2,-84(fp)
81134e38:	00becf16 	blt	zero,r2,81134978 <__reset+0xfb114978>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81134e3c:	e0bffe17 	ldw	r2,-8(fp)
81134e40:	e0ffea17 	ldw	r3,-88(fp)
81134e44:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
81134e48:	e0bfea17 	ldw	r2,-88(fp)
81134e4c:	1000041e 	bne	r2,zero,81134e60 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
81134e50:	e0bfff17 	ldw	r2,-4(fp)
81134e54:	10000a15 	stw	zero,40(r2)
		result = true;
81134e58:	00800044 	movi	r2,1
81134e5c:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
81134e60:	e0bfe917 	ldw	r2,-92(fp)
}
81134e64:	e037883a 	mov	sp,fp
81134e68:	dfc00117 	ldw	ra,4(sp)
81134e6c:	df000017 	ldw	fp,0(sp)
81134e70:	dec00204 	addi	sp,sp,8
81134e74:	f800283a 	ret

81134e78 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
81134e78:	deffe804 	addi	sp,sp,-96
81134e7c:	de00012e 	bgeu	sp,et,81134e84 <find_file_in_directory+0xc>
81134e80:	003b68fa 	trap	3
81134e84:	dfc01715 	stw	ra,92(sp)
81134e88:	df001615 	stw	fp,88(sp)
81134e8c:	df001604 	addi	fp,sp,88
81134e90:	e13ffd15 	stw	r4,-12(fp)
81134e94:	e17ffe15 	stw	r5,-8(fp)
81134e98:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81134e9c:	e13ffe17 	ldw	r4,-8(fp)
81134ea0:	11345d40 	call	811345d4 <get_dir_divider_location>
81134ea4:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81134ea8:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81134eac:	00800804 	movi	r2,32
81134eb0:	e0bff905 	stb	r2,-28(fp)
81134eb4:	00800804 	movi	r2,32
81134eb8:	e0bff945 	stb	r2,-27(fp)
81134ebc:	00800804 	movi	r2,32
81134ec0:	e0bff985 	stb	r2,-26(fp)
81134ec4:	00800804 	movi	r2,32
81134ec8:	e0bff9c5 	stb	r2,-25(fp)
81134ecc:	00800804 	movi	r2,32
81134ed0:	e0bffa05 	stb	r2,-24(fp)
81134ed4:	00800804 	movi	r2,32
81134ed8:	e0bffa45 	stb	r2,-23(fp)
81134edc:	00800804 	movi	r2,32
81134ee0:	e0bffa85 	stb	r2,-22(fp)
81134ee4:	00800804 	movi	r2,32
81134ee8:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81134eec:	00800804 	movi	r2,32
81134ef0:	e0bffb05 	stb	r2,-20(fp)
81134ef4:	00800804 	movi	r2,32
81134ef8:	e0bffb45 	stb	r2,-19(fp)
81134efc:	00800804 	movi	r2,32
81134f00:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81134f04:	00bfffc4 	movi	r2,-1
81134f08:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81134f0c:	e0bffd17 	ldw	r2,-12(fp)
81134f10:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81134f14:	e13ffe17 	ldw	r4,-8(fp)
81134f18:	111405c0 	call	8111405c <strlen>
81134f1c:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81134f20:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
81134f24:	00000b06 	br	81134f54 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
81134f28:	e0ffeb17 	ldw	r3,-84(fp)
81134f2c:	e0bfea17 	ldw	r2,-88(fp)
81134f30:	1885883a 	add	r2,r3,r2
81134f34:	10800044 	addi	r2,r2,1
81134f38:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
81134f3c:	e0bfeb17 	ldw	r2,-84(fp)
81134f40:	e0fffe17 	ldw	r3,-8(fp)
81134f44:	1885883a 	add	r2,r3,r2
81134f48:	1009883a 	mov	r4,r2
81134f4c:	11345d40 	call	811345d4 <get_dir_divider_location>
81134f50:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
81134f54:	e0bfea17 	ldw	r2,-88(fp)
81134f58:	00bff316 	blt	zero,r2,81134f28 <__reset+0xfb114f28>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81134f5c:	e0bfeb17 	ldw	r2,-84(fp)
81134f60:	e0bfee15 	stw	r2,-72(fp)
81134f64:	00002706 	br	81135004 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
81134f68:	e0bfee17 	ldw	r2,-72(fp)
81134f6c:	e0fffe17 	ldw	r3,-8(fp)
81134f70:	1885883a 	add	r2,r3,r2
81134f74:	10800003 	ldbu	r2,0(r2)
81134f78:	10803fcc 	andi	r2,r2,255
81134f7c:	1080201c 	xori	r2,r2,128
81134f80:	10bfe004 	addi	r2,r2,-128
81134f84:	10800b98 	cmpnei	r2,r2,46
81134f88:	1000031e 	bne	r2,zero,81134f98 <find_file_in_directory+0x120>
        {
            ext_index = index;
81134f8c:	e0bfee17 	ldw	r2,-72(fp)
81134f90:	e0bfec15 	stw	r2,-80(fp)
81134f94:	00001806 	br	81134ff8 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
81134f98:	e0bfec17 	ldw	r2,-80(fp)
81134f9c:	10000b0e 	bge	r2,zero,81134fcc <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
81134fa0:	e0ffee17 	ldw	r3,-72(fp)
81134fa4:	e0bfeb17 	ldw	r2,-84(fp)
81134fa8:	1885c83a 	sub	r2,r3,r2
81134fac:	e0ffee17 	ldw	r3,-72(fp)
81134fb0:	e13ffe17 	ldw	r4,-8(fp)
81134fb4:	20c7883a 	add	r3,r4,r3
81134fb8:	18c00003 	ldbu	r3,0(r3)
81134fbc:	e13ff904 	addi	r4,fp,-28
81134fc0:	2085883a 	add	r2,r4,r2
81134fc4:	10c00005 	stb	r3,0(r2)
81134fc8:	00000b06 	br	81134ff8 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81134fcc:	e0ffee17 	ldw	r3,-72(fp)
81134fd0:	e0bfec17 	ldw	r2,-80(fp)
81134fd4:	1885c83a 	sub	r2,r3,r2
81134fd8:	10bfffc4 	addi	r2,r2,-1
81134fdc:	e0ffee17 	ldw	r3,-72(fp)
81134fe0:	e13ffe17 	ldw	r4,-8(fp)
81134fe4:	20c7883a 	add	r3,r4,r3
81134fe8:	18c00003 	ldbu	r3,0(r3)
81134fec:	e13ffb04 	addi	r4,fp,-20
81134ff0:	2085883a 	add	r2,r4,r2
81134ff4:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81134ff8:	e0bfee17 	ldw	r2,-72(fp)
81134ffc:	10800044 	addi	r2,r2,1
81135000:	e0bfee15 	stw	r2,-72(fp)
81135004:	e0ffee17 	ldw	r3,-72(fp)
81135008:	e0bff417 	ldw	r2,-48(fp)
8113500c:	18bfd616 	blt	r3,r2,81134f68 <__reset+0xfb114f68>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
81135010:	e0bffd17 	ldw	r2,-12(fp)
81135014:	1000461e 	bne	r2,zero,81135130 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81135018:	00a04574 	movhi	r2,33045
8113501c:	1094b704 	addi	r2,r2,21212
81135020:	1080050b 	ldhu	r2,20(r2)
81135024:	10bfffcc 	andi	r2,r2,65535
81135028:	1006917a 	slli	r3,r2,5
8113502c:	00a04574 	movhi	r2,33045
81135030:	1094b704 	addi	r2,r2,21212
81135034:	1080030b 	ldhu	r2,12(r2)
81135038:	10bfffcc 	andi	r2,r2,65535
8113503c:	1885283a 	div	r2,r3,r2
81135040:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81135044:	e03ff015 	stw	zero,-64(fp)
81135048:	00003506 	br	81135120 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113504c:	00a04574 	movhi	r2,33045
81135050:	1094b704 	addi	r2,r2,21212
81135054:	10c01317 	ldw	r3,76(r2)
81135058:	e0bff017 	ldw	r2,-64(fp)
8113505c:	1885883a 	add	r2,r3,r2
81135060:	1007883a 	mov	r3,r2
81135064:	d0a09517 	ldw	r2,-32172(gp)
81135068:	100b883a 	mov	r5,r2
8113506c:	1809883a 	mov	r4,r3
81135070:	11331d00 	call	811331d0 <Read_Sector_Data>
81135074:	10009626 	beq	r2,zero,811352d0 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81135078:	e03ff115 	stw	zero,-60(fp)
8113507c:	00002006 	br	81135100 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81135080:	e0bff117 	ldw	r2,-60(fp)
81135084:	1004917a 	slli	r2,r2,5
81135088:	e0fff017 	ldw	r3,-64(fp)
8113508c:	180f883a 	mov	r7,r3
81135090:	000d883a 	mov	r6,zero
81135094:	e17fff17 	ldw	r5,-4(fp)
81135098:	1009883a 	mov	r4,r2
8113509c:	11336000 	call	81133600 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
811350a0:	e0bfff17 	ldw	r2,-4(fp)
811350a4:	10800003 	ldbu	r2,0(r2)
811350a8:	10803fcc 	andi	r2,r2,255
811350ac:	10803960 	cmpeqi	r2,r2,229
811350b0:	1000101e 	bne	r2,zero,811350f4 <find_file_in_directory+0x27c>
811350b4:	e0bfff17 	ldw	r2,-4(fp)
811350b8:	10800003 	ldbu	r2,0(r2)
811350bc:	10803fcc 	andi	r2,r2,255
811350c0:	10000c26 	beq	r2,zero,811350f4 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
811350c4:	e0fffb04 	addi	r3,fp,-20
811350c8:	e0bff904 	addi	r2,fp,-28
811350cc:	180d883a 	mov	r6,r3
811350d0:	100b883a 	mov	r5,r2
811350d4:	e13fff17 	ldw	r4,-4(fp)
811350d8:	11346940 	call	81134694 <match_file_record_to_name_ext>
811350dc:	e0bff815 	stw	r2,-32(fp)

                        if (match)
811350e0:	e0bff817 	ldw	r2,-32(fp)
811350e4:	10000326 	beq	r2,zero,811350f4 <find_file_in_directory+0x27c>
                        {
                            result = true;
811350e8:	00800044 	movi	r2,1
811350ec:	e0bfef15 	stw	r2,-68(fp)
                            break;
811350f0:	00000606 	br	8113510c <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811350f4:	e0bff117 	ldw	r2,-60(fp)
811350f8:	10800044 	addi	r2,r2,1
811350fc:	e0bff115 	stw	r2,-60(fp)
81135100:	e0bff117 	ldw	r2,-60(fp)
81135104:	10800410 	cmplti	r2,r2,16
81135108:	103fdd1e 	bne	r2,zero,81135080 <__reset+0xfb115080>
            }
            else
            {
                break;
            }
            if (result)
8113510c:	e0bfef17 	ldw	r2,-68(fp)
81135110:	1000711e 	bne	r2,zero,811352d8 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81135114:	e0bff017 	ldw	r2,-64(fp)
81135118:	10800044 	addi	r2,r2,1
8113511c:	e0bff015 	stw	r2,-64(fp)
81135120:	e0fff017 	ldw	r3,-64(fp)
81135124:	e0bff717 	ldw	r2,-36(fp)
81135128:	18bfc816 	blt	r3,r2,8113504c <__reset+0xfb11504c>
8113512c:	00006b06 	br	811352dc <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81135130:	e0bfed17 	ldw	r2,-76(fp)
81135134:	10ffff84 	addi	r3,r2,-2
81135138:	00a04574 	movhi	r2,33045
8113513c:	1094b704 	addi	r2,r2,21212
81135140:	10800383 	ldbu	r2,14(r2)
81135144:	10803fcc 	andi	r2,r2,255
81135148:	1885383a 	mul	r2,r3,r2
8113514c:	1007883a 	mov	r3,r2
81135150:	00a04574 	movhi	r2,33045
81135154:	1094b704 	addi	r2,r2,21212
81135158:	10801417 	ldw	r2,80(r2)
8113515c:	1885883a 	add	r2,r3,r2
81135160:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81135164:	e03ff215 	stw	zero,-56(fp)
81135168:	00003306 	br	81135238 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113516c:	e0fff217 	ldw	r3,-56(fp)
81135170:	e0bff517 	ldw	r2,-44(fp)
81135174:	1885883a 	add	r2,r3,r2
81135178:	d0e09517 	ldw	r3,-32172(gp)
8113517c:	180b883a 	mov	r5,r3
81135180:	1009883a 	mov	r4,r2
81135184:	11331d00 	call	811331d0 <Read_Sector_Data>
81135188:	10003226 	beq	r2,zero,81135254 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113518c:	e03ff315 	stw	zero,-52(fp)
81135190:	00002106 	br	81135218 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81135194:	e0bff317 	ldw	r2,-52(fp)
81135198:	1004917a 	slli	r2,r2,5
8113519c:	e0ffed17 	ldw	r3,-76(fp)
811351a0:	e13ff217 	ldw	r4,-56(fp)
811351a4:	200f883a 	mov	r7,r4
811351a8:	180d883a 	mov	r6,r3
811351ac:	e17fff17 	ldw	r5,-4(fp)
811351b0:	1009883a 	mov	r4,r2
811351b4:	11336000 	call	81133600 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
811351b8:	e0bfff17 	ldw	r2,-4(fp)
811351bc:	10800003 	ldbu	r2,0(r2)
811351c0:	10803fcc 	andi	r2,r2,255
811351c4:	10803960 	cmpeqi	r2,r2,229
811351c8:	1000101e 	bne	r2,zero,8113520c <find_file_in_directory+0x394>
811351cc:	e0bfff17 	ldw	r2,-4(fp)
811351d0:	10800003 	ldbu	r2,0(r2)
811351d4:	10803fcc 	andi	r2,r2,255
811351d8:	10000c26 	beq	r2,zero,8113520c <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
811351dc:	e0fffb04 	addi	r3,fp,-20
811351e0:	e0bff904 	addi	r2,fp,-28
811351e4:	180d883a 	mov	r6,r3
811351e8:	100b883a 	mov	r5,r2
811351ec:	e13fff17 	ldw	r4,-4(fp)
811351f0:	11346940 	call	81134694 <match_file_record_to_name_ext>
811351f4:	e0bff615 	stw	r2,-40(fp)

                            if (match)
811351f8:	e0bff617 	ldw	r2,-40(fp)
811351fc:	10000326 	beq	r2,zero,8113520c <find_file_in_directory+0x394>
                            {                               
                                result = true;
81135200:	00800044 	movi	r2,1
81135204:	e0bfef15 	stw	r2,-68(fp)
                                break;
81135208:	00000606 	br	81135224 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113520c:	e0bff317 	ldw	r2,-52(fp)
81135210:	10800044 	addi	r2,r2,1
81135214:	e0bff315 	stw	r2,-52(fp)
81135218:	e0bff317 	ldw	r2,-52(fp)
8113521c:	10800410 	cmplti	r2,r2,16
81135220:	103fdc1e 	bne	r2,zero,81135194 <__reset+0xfb115194>
                }
                else
                {
                    break;
                }
                if (result)
81135224:	e0bfef17 	ldw	r2,-68(fp)
81135228:	10000c1e 	bne	r2,zero,8113525c <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113522c:	e0bff217 	ldw	r2,-56(fp)
81135230:	10800044 	addi	r2,r2,1
81135234:	e0bff215 	stw	r2,-56(fp)
81135238:	00a04574 	movhi	r2,33045
8113523c:	1094b704 	addi	r2,r2,21212
81135240:	10800383 	ldbu	r2,14(r2)
81135244:	10803fcc 	andi	r2,r2,255
81135248:	e0fff217 	ldw	r3,-56(fp)
8113524c:	18bfc716 	blt	r3,r2,8113516c <__reset+0xfb11516c>
81135250:	00000306 	br	81135260 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
81135254:	0001883a 	nop
81135258:	00000106 	br	81135260 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
8113525c:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
81135260:	e0bfef17 	ldw	r2,-68(fp)
81135264:	1000141e 	bne	r2,zero,811352b8 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
81135268:	e0bfed17 	ldw	r2,-76(fp)
8113526c:	e0fffc04 	addi	r3,fp,-16
81135270:	180b883a 	mov	r5,r3
81135274:	1009883a 	mov	r4,r2
81135278:	11332b00 	call	811332b0 <get_cluster_flag>
8113527c:	10000c26 	beq	r2,zero,811352b0 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81135280:	e0bffc0b 	ldhu	r2,-16(fp)
81135284:	10bfffcc 	andi	r2,r2,65535
81135288:	10fffe0c 	andi	r3,r2,65528
8113528c:	00bffe14 	movui	r2,65528
81135290:	1880021e 	bne	r3,r2,8113529c <find_file_in_directory+0x424>
					{
						return false;
81135294:	0005883a 	mov	r2,zero
81135298:	00001106 	br	811352e0 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
8113529c:	e0bffc0b 	ldhu	r2,-16(fp)
811352a0:	10bfffcc 	andi	r2,r2,65535
811352a4:	10bffe0c 	andi	r2,r2,65528
811352a8:	e0bfed15 	stw	r2,-76(fp)
811352ac:	00000206 	br	811352b8 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
811352b0:	0005883a 	mov	r2,zero
811352b4:	00000a06 	br	811352e0 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
811352b8:	e0bfed17 	ldw	r2,-76(fp)
811352bc:	00fffdd4 	movui	r3,65527
811352c0:	18800616 	blt	r3,r2,811352dc <find_file_in_directory+0x464>
811352c4:	e0bfef17 	ldw	r2,-68(fp)
811352c8:	103f9926 	beq	r2,zero,81135130 <__reset+0xfb115130>
811352cc:	00000306 	br	811352dc <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
811352d0:	0001883a 	nop
811352d4:	00000106 	br	811352dc <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
811352d8:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
811352dc:	e0bfef17 	ldw	r2,-68(fp)
}
811352e0:	e037883a 	mov	sp,fp
811352e4:	dfc00117 	ldw	ra,4(sp)
811352e8:	df000017 	ldw	fp,0(sp)
811352ec:	dec00204 	addi	sp,sp,8
811352f0:	f800283a 	ret

811352f4 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
811352f4:	defff504 	addi	sp,sp,-44
811352f8:	de00012e 	bgeu	sp,et,81135300 <find_first_empty_cluster+0xc>
811352fc:	003b68fa 	trap	3
81135300:	dfc00a15 	stw	ra,40(sp)
81135304:	df000915 	stw	fp,36(sp)
81135308:	df000904 	addi	fp,sp,36
8113530c:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
81135310:	00a04574 	movhi	r2,33045
81135314:	1094b704 	addi	r2,r2,21212
81135318:	10801117 	ldw	r2,68(r2)
8113531c:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
81135320:	00800084 	movi	r2,2
81135324:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
81135328:	00bfffc4 	movi	r2,-1
8113532c:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
81135330:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
81135334:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
81135338:	00a04574 	movhi	r2,33045
8113533c:	1094b704 	addi	r2,r2,21212
81135340:	10801417 	ldw	r2,80(r2)
81135344:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
81135348:	00a04574 	movhi	r2,33045
8113534c:	1094b704 	addi	r2,r2,21212
81135350:	1080058b 	ldhu	r2,22(r2)
81135354:	10bfffcc 	andi	r2,r2,65535
81135358:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
8113535c:	00a04574 	movhi	r2,33045
81135360:	1094b704 	addi	r2,r2,21212
81135364:	10800917 	ldw	r2,36(r2)
81135368:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
8113536c:	e0bffd17 	ldw	r2,-12(fp)
81135370:	e0fffe17 	ldw	r3,-8(fp)
81135374:	18800b2e 	bgeu	r3,r2,811353a4 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81135378:	e0fffd17 	ldw	r3,-12(fp)
8113537c:	e0bffc17 	ldw	r2,-16(fp)
81135380:	1887c83a 	sub	r3,r3,r2
81135384:	00a04574 	movhi	r2,33045
81135388:	1094b704 	addi	r2,r2,21212
8113538c:	10800383 	ldbu	r2,14(r2)
81135390:	10803fcc 	andi	r2,r2,255
81135394:	1885203a 	divu	r2,r3,r2
81135398:	10800044 	addi	r2,r2,1
8113539c:	e0bffb15 	stw	r2,-20(fp)
811353a0:	00002a06 	br	8113544c <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
811353a4:	e0fffe17 	ldw	r3,-8(fp)
811353a8:	e0bffc17 	ldw	r2,-16(fp)
811353ac:	1887c83a 	sub	r3,r3,r2
811353b0:	00a04574 	movhi	r2,33045
811353b4:	1094b704 	addi	r2,r2,21212
811353b8:	10800383 	ldbu	r2,14(r2)
811353bc:	10803fcc 	andi	r2,r2,255
811353c0:	1885203a 	divu	r2,r3,r2
811353c4:	10800044 	addi	r2,r2,1
811353c8:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
811353cc:	00001f06 	br	8113544c <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
811353d0:	e0bff717 	ldw	r2,-36(fp)
811353d4:	d0e09517 	ldw	r3,-32172(gp)
811353d8:	180b883a 	mov	r5,r3
811353dc:	1009883a 	mov	r4,r2
811353e0:	11331d00 	call	811331d0 <Read_Sector_Data>
811353e4:	10001426 	beq	r2,zero,81135438 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
811353e8:	e0bff817 	ldw	r2,-32(fp)
811353ec:	10803fcc 	andi	r2,r2,255
811353f0:	1085883a 	add	r2,r2,r2
811353f4:	1007883a 	mov	r3,r2
811353f8:	d0a09717 	ldw	r2,-32164(gp)
811353fc:	10800a17 	ldw	r2,40(r2)
81135400:	1885883a 	add	r2,r3,r2
81135404:	1080002b 	ldhuio	r2,0(r2)
81135408:	10bfffcc 	andi	r2,r2,65535
8113540c:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
81135410:	e0bff90f 	ldh	r2,-28(fp)
81135414:	10000726 	beq	r2,zero,81135434 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
81135418:	e0bff817 	ldw	r2,-32(fp)
8113541c:	10800044 	addi	r2,r2,1
81135420:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
81135424:	e0bff817 	ldw	r2,-32(fp)
81135428:	10803fcc 	andi	r2,r2,255
8113542c:	103fee1e 	bne	r2,zero,811353e8 <__reset+0xfb1153e8>
81135430:	00000106 	br	81135438 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
81135434:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
81135438:	e0bff90f 	ldh	r2,-28(fp)
8113543c:	10000926 	beq	r2,zero,81135464 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
81135440:	e0bff717 	ldw	r2,-36(fp)
81135444:	10800044 	addi	r2,r2,1
81135448:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113544c:	00a04574 	movhi	r2,33045
81135450:	1094b704 	addi	r2,r2,21212
81135454:	10c01217 	ldw	r3,72(r2)
81135458:	e0bff717 	ldw	r2,-36(fp)
8113545c:	18bfdc1e 	bne	r3,r2,811353d0 <__reset+0xfb1153d0>
81135460:	00000106 	br	81135468 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
81135464:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
81135468:	e0bff90f 	ldh	r2,-28(fp)
8113546c:	1000081e 	bne	r2,zero,81135490 <find_first_empty_cluster+0x19c>
81135470:	e0bff90f 	ldh	r2,-28(fp)
81135474:	e0fffb17 	ldw	r3,-20(fp)
81135478:	18800536 	bltu	r3,r2,81135490 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
8113547c:	e0bfff17 	ldw	r2,-4(fp)
81135480:	e0fff817 	ldw	r3,-32(fp)
81135484:	10c00015 	stw	r3,0(r2)
		result = true;
81135488:	00800044 	movi	r2,1
8113548c:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
81135490:	e0bffa17 	ldw	r2,-24(fp)
}
81135494:	e037883a 	mov	sp,fp
81135498:	dfc00117 	ldw	ra,4(sp)
8113549c:	df000017 	ldw	fp,0(sp)
811354a0:	dec00204 	addi	sp,sp,8
811354a4:	f800283a 	ret

811354a8 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
811354a8:	defff604 	addi	sp,sp,-40
811354ac:	de00012e 	bgeu	sp,et,811354b4 <find_first_empty_record_in_a_subdirectory+0xc>
811354b0:	003b68fa 	trap	3
811354b4:	dfc00915 	stw	ra,36(sp)
811354b8:	df000815 	stw	fp,32(sp)
811354bc:	df000804 	addi	fp,sp,32
811354c0:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
811354c4:	00bfffc4 	movi	r2,-1
811354c8:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
811354cc:	e0bfff17 	ldw	r2,-4(fp)
811354d0:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811354d4:	e0bff917 	ldw	r2,-28(fp)
811354d8:	10ffff84 	addi	r3,r2,-2
811354dc:	00a04574 	movhi	r2,33045
811354e0:	1094b704 	addi	r2,r2,21212
811354e4:	10800383 	ldbu	r2,14(r2)
811354e8:	10803fcc 	andi	r2,r2,255
811354ec:	1885383a 	mul	r2,r3,r2
811354f0:	1007883a 	mov	r3,r2
811354f4:	00a04574 	movhi	r2,33045
811354f8:	1094b704 	addi	r2,r2,21212
811354fc:	10801417 	ldw	r2,80(r2)
81135500:	1885883a 	add	r2,r3,r2
81135504:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81135508:	e03ffa15 	stw	zero,-24(fp)
8113550c:	00002c06 	br	811355c0 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81135510:	e0fffa17 	ldw	r3,-24(fp)
81135514:	e0bffc17 	ldw	r2,-16(fp)
81135518:	1885883a 	add	r2,r3,r2
8113551c:	d0e09517 	ldw	r3,-32172(gp)
81135520:	180b883a 	mov	r5,r3
81135524:	1009883a 	mov	r4,r2
81135528:	11331d00 	call	811331d0 <Read_Sector_Data>
8113552c:	10002b26 	beq	r2,zero,811355dc <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81135530:	e03ffb15 	stw	zero,-20(fp)
81135534:	00001c06 	br	811355a8 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81135538:	e0bffb17 	ldw	r2,-20(fp)
8113553c:	1004917a 	slli	r2,r2,5
81135540:	1007883a 	mov	r3,r2
81135544:	d0a09717 	ldw	r2,-32164(gp)
81135548:	10800a17 	ldw	r2,40(r2)
8113554c:	1885883a 	add	r2,r3,r2
81135550:	10800023 	ldbuio	r2,0(r2)
81135554:	10803fcc 	andi	r2,r2,255
81135558:	10803fcc 	andi	r2,r2,255
8113555c:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
81135560:	e0bffd0b 	ldhu	r2,-12(fp)
81135564:	10803960 	cmpeqi	r2,r2,229
81135568:	1000021e 	bne	r2,zero,81135574 <find_first_empty_record_in_a_subdirectory+0xcc>
8113556c:	e0bffd0b 	ldhu	r2,-12(fp)
81135570:	10000a1e 	bne	r2,zero,8113559c <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
81135574:	e0bffa17 	ldw	r2,-24(fp)
81135578:	1006913a 	slli	r3,r2,4
8113557c:	e0bffb17 	ldw	r2,-20(fp)
81135580:	1885883a 	add	r2,r3,r2
81135584:	1006943a 	slli	r3,r2,16
81135588:	e0bff917 	ldw	r2,-28(fp)
8113558c:	1884b03a 	or	r2,r3,r2
81135590:	e0bff815 	stw	r2,-32(fp)
                        return result;
81135594:	e0bff817 	ldw	r2,-32(fp)
81135598:	00005306 	br	811356e8 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113559c:	e0bffb17 	ldw	r2,-20(fp)
811355a0:	10800044 	addi	r2,r2,1
811355a4:	e0bffb15 	stw	r2,-20(fp)
811355a8:	e0bffb17 	ldw	r2,-20(fp)
811355ac:	10800410 	cmplti	r2,r2,16
811355b0:	103fe11e 	bne	r2,zero,81135538 <__reset+0xfb115538>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811355b4:	e0bffa17 	ldw	r2,-24(fp)
811355b8:	10800044 	addi	r2,r2,1
811355bc:	e0bffa15 	stw	r2,-24(fp)
811355c0:	00a04574 	movhi	r2,33045
811355c4:	1094b704 	addi	r2,r2,21212
811355c8:	10800383 	ldbu	r2,14(r2)
811355cc:	10803fcc 	andi	r2,r2,255
811355d0:	e0fffa17 	ldw	r3,-24(fp)
811355d4:	18bfce16 	blt	r3,r2,81135510 <__reset+0xfb115510>
811355d8:	00000106 	br	811355e0 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
811355dc:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
811355e0:	e0bff817 	ldw	r2,-32(fp)
811355e4:	1000390e 	bge	r2,zero,811356cc <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
811355e8:	e0bff917 	ldw	r2,-28(fp)
811355ec:	e0fffd84 	addi	r3,fp,-10
811355f0:	180b883a 	mov	r5,r3
811355f4:	1009883a 	mov	r4,r2
811355f8:	11332b00 	call	811332b0 <get_cluster_flag>
811355fc:	10003126 	beq	r2,zero,811356c4 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81135600:	e0bffd8b 	ldhu	r2,-10(fp)
81135604:	10bfffcc 	andi	r2,r2,65535
81135608:	10fffe0c 	andi	r3,r2,65528
8113560c:	00bffe14 	movui	r2,65528
81135610:	18802e1e 	bne	r3,r2,811356cc <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
81135614:	e0bffe04 	addi	r2,fp,-8
81135618:	1009883a 	mov	r4,r2
8113561c:	11352f40 	call	811352f4 <find_first_empty_cluster>
81135620:	10002326 	beq	r2,zero,811356b0 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81135624:	e0bff917 	ldw	r2,-28(fp)
81135628:	e0fffe17 	ldw	r3,-8(fp)
8113562c:	18ffffcc 	andi	r3,r3,65535
81135630:	18e0001c 	xori	r3,r3,32768
81135634:	18e00004 	addi	r3,r3,-32768
81135638:	01800044 	movi	r6,1
8113563c:	180b883a 	mov	r5,r3
81135640:	1009883a 	mov	r4,r2
81135644:	113336c0 	call	8113336c <mark_cluster>
81135648:	10001926 	beq	r2,zero,811356b0 <find_first_empty_record_in_a_subdirectory+0x208>
8113564c:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81135650:	01800044 	movi	r6,1
81135654:	017fffc4 	movi	r5,-1
81135658:	1009883a 	mov	r4,r2
8113565c:	113336c0 	call	8113336c <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81135660:	10001326 	beq	r2,zero,811356b0 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81135664:	e0bff917 	ldw	r2,-28(fp)
81135668:	e0fffe17 	ldw	r3,-8(fp)
8113566c:	18ffffcc 	andi	r3,r3,65535
81135670:	18e0001c 	xori	r3,r3,32768
81135674:	18e00004 	addi	r3,r3,-32768
81135678:	000d883a 	mov	r6,zero
8113567c:	180b883a 	mov	r5,r3
81135680:	1009883a 	mov	r4,r2
81135684:	113336c0 	call	8113336c <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81135688:	10000926 	beq	r2,zero,811356b0 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113568c:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
81135690:	000d883a 	mov	r6,zero
81135694:	017fffc4 	movi	r5,-1
81135698:	1009883a 	mov	r4,r2
8113569c:	113336c0 	call	8113336c <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811356a0:	10000326 	beq	r2,zero,811356b0 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
811356a4:	113317c0 	call	8113317c <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
811356a8:	e0bffe17 	ldw	r2,-8(fp)
811356ac:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
811356b0:	e0bffd8b 	ldhu	r2,-10(fp)
811356b4:	10bfffcc 	andi	r2,r2,65535
811356b8:	10bffe0c 	andi	r2,r2,65528
811356bc:	e0bff915 	stw	r2,-28(fp)
811356c0:	00000206 	br	811356cc <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
811356c4:	00bfffc4 	movi	r2,-1
811356c8:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
811356cc:	e0bff917 	ldw	r2,-28(fp)
811356d0:	00fffdd4 	movui	r3,65527
811356d4:	18800316 	blt	r3,r2,811356e4 <find_first_empty_record_in_a_subdirectory+0x23c>
811356d8:	e0bff817 	ldw	r2,-32(fp)
811356dc:	10bfffe0 	cmpeqi	r2,r2,-1
811356e0:	103f7c1e 	bne	r2,zero,811354d4 <__reset+0xfb1154d4>
    return result; 
811356e4:	e0bff817 	ldw	r2,-32(fp)
}
811356e8:	e037883a 	mov	sp,fp
811356ec:	dfc00117 	ldw	ra,4(sp)
811356f0:	df000017 	ldw	fp,0(sp)
811356f4:	dec00204 	addi	sp,sp,8
811356f8:	f800283a 	ret

811356fc <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
811356fc:	defff904 	addi	sp,sp,-28
81135700:	de00012e 	bgeu	sp,et,81135708 <find_first_empty_record_in_root_directory+0xc>
81135704:	003b68fa 	trap	3
81135708:	dfc00615 	stw	ra,24(sp)
8113570c:	df000515 	stw	fp,20(sp)
81135710:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81135714:	00a04574 	movhi	r2,33045
81135718:	1094b704 	addi	r2,r2,21212
8113571c:	1080050b 	ldhu	r2,20(r2)
81135720:	10bfffcc 	andi	r2,r2,65535
81135724:	1006917a 	slli	r3,r2,5
81135728:	00a04574 	movhi	r2,33045
8113572c:	1094b704 	addi	r2,r2,21212
81135730:	1080030b 	ldhu	r2,12(r2)
81135734:	10bfffcc 	andi	r2,r2,65535
81135738:	1885283a 	div	r2,r3,r2
8113573c:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
81135740:	00bfffc4 	movi	r2,-1
81135744:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81135748:	e03ffb15 	stw	zero,-20(fp)
8113574c:	00002d06 	br	81135804 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81135750:	00a04574 	movhi	r2,33045
81135754:	1094b704 	addi	r2,r2,21212
81135758:	10c01317 	ldw	r3,76(r2)
8113575c:	e0bffb17 	ldw	r2,-20(fp)
81135760:	1885883a 	add	r2,r3,r2
81135764:	1007883a 	mov	r3,r2
81135768:	d0a09517 	ldw	r2,-32172(gp)
8113576c:	100b883a 	mov	r5,r2
81135770:	1809883a 	mov	r4,r3
81135774:	11331d00 	call	811331d0 <Read_Sector_Data>
81135778:	10002626 	beq	r2,zero,81135814 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113577c:	e03ffc15 	stw	zero,-16(fp)
81135780:	00001a06 	br	811357ec <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81135784:	e0bffc17 	ldw	r2,-16(fp)
81135788:	1004917a 	slli	r2,r2,5
8113578c:	1007883a 	mov	r3,r2
81135790:	d0a09717 	ldw	r2,-32164(gp)
81135794:	10800a17 	ldw	r2,40(r2)
81135798:	1885883a 	add	r2,r3,r2
8113579c:	10800023 	ldbuio	r2,0(r2)
811357a0:	10803fcc 	andi	r2,r2,255
811357a4:	10803fcc 	andi	r2,r2,255
811357a8:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
811357ac:	e0bfff0b 	ldhu	r2,-4(fp)
811357b0:	10803960 	cmpeqi	r2,r2,229
811357b4:	1000021e 	bne	r2,zero,811357c0 <find_first_empty_record_in_root_directory+0xc4>
811357b8:	e0bfff0b 	ldhu	r2,-4(fp)
811357bc:	1000081e 	bne	r2,zero,811357e0 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
811357c0:	e0bffb17 	ldw	r2,-20(fp)
811357c4:	1006913a 	slli	r3,r2,4
811357c8:	e0bffc17 	ldw	r2,-16(fp)
811357cc:	1885883a 	add	r2,r3,r2
811357d0:	1004943a 	slli	r2,r2,16
811357d4:	e0bffe15 	stw	r2,-8(fp)
                    return result;
811357d8:	e0bffe17 	ldw	r2,-8(fp)
811357dc:	00000f06 	br	8113581c <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
811357e0:	e0bffc17 	ldw	r2,-16(fp)
811357e4:	10800044 	addi	r2,r2,1
811357e8:	e0bffc15 	stw	r2,-16(fp)
811357ec:	e0bffc17 	ldw	r2,-16(fp)
811357f0:	10800410 	cmplti	r2,r2,16
811357f4:	103fe31e 	bne	r2,zero,81135784 <__reset+0xfb115784>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811357f8:	e0bffb17 	ldw	r2,-20(fp)
811357fc:	10800044 	addi	r2,r2,1
81135800:	e0bffb15 	stw	r2,-20(fp)
81135804:	e0fffb17 	ldw	r3,-20(fp)
81135808:	e0bffd17 	ldw	r2,-12(fp)
8113580c:	18bfd016 	blt	r3,r2,81135750 <__reset+0xfb115750>
81135810:	00000106 	br	81135818 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
81135814:	0001883a 	nop
        }
    }
    return result;
81135818:	e0bffe17 	ldw	r2,-8(fp)
}
8113581c:	e037883a 	mov	sp,fp
81135820:	dfc00117 	ldw	ra,4(sp)
81135824:	df000017 	ldw	fp,0(sp)
81135828:	dec00204 	addi	sp,sp,8
8113582c:	f800283a 	ret

81135830 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
81135830:	defffa04 	addi	sp,sp,-24
81135834:	de00012e 	bgeu	sp,et,8113583c <convert_filename_to_name_extension+0xc>
81135838:	003b68fa 	trap	3
8113583c:	df000515 	stw	fp,20(sp)
81135840:	df000504 	addi	fp,sp,20
81135844:	e13ffd15 	stw	r4,-12(fp)
81135848:	e17ffe15 	stw	r5,-8(fp)
8113584c:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
81135850:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
81135854:	e03ffb15 	stw	zero,-20(fp)
81135858:	00002506 	br	811358f0 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
8113585c:	e0bffc17 	ldw	r2,-16(fp)
81135860:	e0fffd17 	ldw	r3,-12(fp)
81135864:	1885883a 	add	r2,r3,r2
81135868:	10800003 	ldbu	r2,0(r2)
8113586c:	10803fcc 	andi	r2,r2,255
81135870:	1080201c 	xori	r2,r2,128
81135874:	10bfe004 	addi	r2,r2,-128
81135878:	10800ba0 	cmpeqi	r2,r2,46
8113587c:	1000141e 	bne	r2,zero,811358d0 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81135880:	e0bffb17 	ldw	r2,-20(fp)
81135884:	e0fffe17 	ldw	r3,-8(fp)
81135888:	1885883a 	add	r2,r3,r2
8113588c:	e0fffc17 	ldw	r3,-16(fp)
81135890:	e13ffd17 	ldw	r4,-12(fp)
81135894:	20c7883a 	add	r3,r4,r3
81135898:	18c00003 	ldbu	r3,0(r3)
8113589c:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
811358a0:	e0bffc17 	ldw	r2,-16(fp)
811358a4:	e0fffd17 	ldw	r3,-12(fp)
811358a8:	1885883a 	add	r2,r3,r2
811358ac:	10800003 	ldbu	r2,0(r2)
811358b0:	10803fcc 	andi	r2,r2,255
811358b4:	1080201c 	xori	r2,r2,128
811358b8:	10bfe004 	addi	r2,r2,-128
811358bc:	10000926 	beq	r2,zero,811358e4 <convert_filename_to_name_extension+0xb4>
811358c0:	e0bffc17 	ldw	r2,-16(fp)
811358c4:	10800044 	addi	r2,r2,1
811358c8:	e0bffc15 	stw	r2,-16(fp)
811358cc:	00000506 	br	811358e4 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
811358d0:	e0bffb17 	ldw	r2,-20(fp)
811358d4:	e0fffe17 	ldw	r3,-8(fp)
811358d8:	1885883a 	add	r2,r3,r2
811358dc:	00c00804 	movi	r3,32
811358e0:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
811358e4:	e0bffb17 	ldw	r2,-20(fp)
811358e8:	10800044 	addi	r2,r2,1
811358ec:	e0bffb15 	stw	r2,-20(fp)
811358f0:	e0bffb17 	ldw	r2,-20(fp)
811358f4:	10800210 	cmplti	r2,r2,8
811358f8:	103fd81e 	bne	r2,zero,8113585c <__reset+0xfb11585c>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
811358fc:	e0bffc17 	ldw	r2,-16(fp)
81135900:	e0fffd17 	ldw	r3,-12(fp)
81135904:	1885883a 	add	r2,r3,r2
81135908:	10800003 	ldbu	r2,0(r2)
8113590c:	10803fcc 	andi	r2,r2,255
81135910:	1080201c 	xori	r2,r2,128
81135914:	10bfe004 	addi	r2,r2,-128
81135918:	10800b98 	cmpnei	r2,r2,46
8113591c:	1000031e 	bne	r2,zero,8113592c <convert_filename_to_name_extension+0xfc>
81135920:	e0bffc17 	ldw	r2,-16(fp)
81135924:	10800044 	addi	r2,r2,1
81135928:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
8113592c:	e03ffb15 	stw	zero,-20(fp)
81135930:	00001c06 	br	811359a4 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
81135934:	e0bffc17 	ldw	r2,-16(fp)
81135938:	e0fffd17 	ldw	r3,-12(fp)
8113593c:	1885883a 	add	r2,r3,r2
81135940:	10800003 	ldbu	r2,0(r2)
81135944:	10803fcc 	andi	r2,r2,255
81135948:	1080201c 	xori	r2,r2,128
8113594c:	10bfe004 	addi	r2,r2,-128
81135950:	10000c26 	beq	r2,zero,81135984 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
81135954:	e0bffb17 	ldw	r2,-20(fp)
81135958:	e0ffff17 	ldw	r3,-4(fp)
8113595c:	1885883a 	add	r2,r3,r2
81135960:	e0fffc17 	ldw	r3,-16(fp)
81135964:	e13ffd17 	ldw	r4,-12(fp)
81135968:	20c7883a 	add	r3,r4,r3
8113596c:	18c00003 	ldbu	r3,0(r3)
81135970:	10c00005 	stb	r3,0(r2)
            local++;
81135974:	e0bffc17 	ldw	r2,-16(fp)
81135978:	10800044 	addi	r2,r2,1
8113597c:	e0bffc15 	stw	r2,-16(fp)
81135980:	00000506 	br	81135998 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81135984:	e0bffb17 	ldw	r2,-20(fp)
81135988:	e0ffff17 	ldw	r3,-4(fp)
8113598c:	1885883a 	add	r2,r3,r2
81135990:	00c00804 	movi	r3,32
81135994:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
81135998:	e0bffb17 	ldw	r2,-20(fp)
8113599c:	10800044 	addi	r2,r2,1
811359a0:	e0bffb15 	stw	r2,-20(fp)
811359a4:	e0bffb17 	ldw	r2,-20(fp)
811359a8:	108000d0 	cmplti	r2,r2,3
811359ac:	103fe11e 	bne	r2,zero,81135934 <__reset+0xfb115934>
        {
            extension[counter] = ' ';
        }
    }

}
811359b0:	0001883a 	nop
811359b4:	e037883a 	mov	sp,fp
811359b8:	df000017 	ldw	fp,0(sp)
811359bc:	dec00104 	addi	sp,sp,4
811359c0:	f800283a 	ret

811359c4 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
811359c4:	defff504 	addi	sp,sp,-44
811359c8:	de00012e 	bgeu	sp,et,811359d0 <create_file+0xc>
811359cc:	003b68fa 	trap	3
811359d0:	dfc00a15 	stw	ra,40(sp)
811359d4:	df000915 	stw	fp,36(sp)
811359d8:	df000904 	addi	fp,sp,36
811359dc:	e13ffd15 	stw	r4,-12(fp)
811359e0:	e17ffe15 	stw	r5,-8(fp)
811359e4:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
811359e8:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
811359ec:	e0bffc04 	addi	r2,fp,-16
811359f0:	1009883a 	mov	r4,r2
811359f4:	11352f40 	call	811352f4 <find_first_empty_cluster>
811359f8:	1000a026 	beq	r2,zero,81135c7c <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
811359fc:	e0bfff17 	ldw	r2,-4(fp)
81135a00:	10800a17 	ldw	r2,40(r2)
81135a04:	1000031e 	bne	r2,zero,81135a14 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81135a08:	11356fc0 	call	811356fc <find_first_empty_record_in_root_directory>
81135a0c:	e0bff815 	stw	r2,-32(fp)
81135a10:	00000606 	br	81135a2c <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81135a14:	e0bfff17 	ldw	r2,-4(fp)
81135a18:	1080058b 	ldhu	r2,22(r2)
81135a1c:	10bfffcc 	andi	r2,r2,65535
81135a20:	1009883a 	mov	r4,r2
81135a24:	11354a80 	call	811354a8 <find_first_empty_record_in_a_subdirectory>
81135a28:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81135a2c:	e0bff817 	ldw	r2,-32(fp)
81135a30:	10009216 	blt	r2,zero,81135c7c <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81135a34:	e13ffd17 	ldw	r4,-12(fp)
81135a38:	11345d40 	call	811345d4 <get_dir_divider_location>
81135a3c:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81135a40:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81135a44:	00000b06 	br	81135a74 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
81135a48:	e0fffa17 	ldw	r3,-24(fp)
81135a4c:	e0bff917 	ldw	r2,-28(fp)
81135a50:	1885883a 	add	r2,r3,r2
81135a54:	10800044 	addi	r2,r2,1
81135a58:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
81135a5c:	e0bffa17 	ldw	r2,-24(fp)
81135a60:	e0fffd17 	ldw	r3,-12(fp)
81135a64:	1885883a 	add	r2,r3,r2
81135a68:	1009883a 	mov	r4,r2
81135a6c:	11345d40 	call	811345d4 <get_dir_divider_location>
81135a70:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81135a74:	e0bff917 	ldw	r2,-28(fp)
81135a78:	00bff316 	blt	zero,r2,81135a48 <__reset+0xfb115a48>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81135a7c:	e0bffa17 	ldw	r2,-24(fp)
81135a80:	e0fffd17 	ldw	r3,-12(fp)
81135a84:	1887883a 	add	r3,r3,r2
81135a88:	e13ffe17 	ldw	r4,-8(fp)
81135a8c:	e0bffe17 	ldw	r2,-8(fp)
81135a90:	10800204 	addi	r2,r2,8
81135a94:	100d883a 	mov	r6,r2
81135a98:	200b883a 	mov	r5,r4
81135a9c:	1809883a 	mov	r4,r3
81135aa0:	11358300 	call	81135830 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
81135aa4:	e0bffe17 	ldw	r2,-8(fp)
81135aa8:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
81135aac:	e0bffe17 	ldw	r2,-8(fp)
81135ab0:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
81135ab4:	e0bffe17 	ldw	r2,-8(fp)
81135ab8:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81135abc:	e0bffe17 	ldw	r2,-8(fp)
81135ac0:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
81135ac4:	e0bffe17 	ldw	r2,-8(fp)
81135ac8:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81135acc:	e0bffe17 	ldw	r2,-8(fp)
81135ad0:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
81135ad4:	e0bffc17 	ldw	r2,-16(fp)
81135ad8:	1007883a 	mov	r3,r2
81135adc:	e0bffe17 	ldw	r2,-8(fp)
81135ae0:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
81135ae4:	e0bffe17 	ldw	r2,-8(fp)
81135ae8:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81135aec:	e0fffc17 	ldw	r3,-16(fp)
81135af0:	e0bffe17 	ldw	r2,-8(fp)
81135af4:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81135af8:	e0bffe17 	ldw	r2,-8(fp)
81135afc:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81135b00:	e0bffe17 	ldw	r2,-8(fp)
81135b04:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81135b08:	e0bff817 	ldw	r2,-32(fp)
81135b0c:	10ffffcc 	andi	r3,r2,65535
81135b10:	e0bffe17 	ldw	r2,-8(fp)
81135b14:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
81135b18:	e0bff817 	ldw	r2,-32(fp)
81135b1c:	1004d43a 	srli	r2,r2,16
81135b20:	1000010e 	bge	r2,zero,81135b28 <create_file+0x164>
81135b24:	108003c4 	addi	r2,r2,15
81135b28:	1005d13a 	srai	r2,r2,4
81135b2c:	1007883a 	mov	r3,r2
81135b30:	e0bffe17 	ldw	r2,-8(fp)
81135b34:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
81135b38:	e0bff817 	ldw	r2,-32(fp)
81135b3c:	1004d43a 	srli	r2,r2,16
81135b40:	1007883a 	mov	r3,r2
81135b44:	00a00034 	movhi	r2,32768
81135b48:	108003c4 	addi	r2,r2,15
81135b4c:	1884703a 	and	r2,r3,r2
81135b50:	1000040e 	bge	r2,zero,81135b64 <create_file+0x1a0>
81135b54:	10bfffc4 	addi	r2,r2,-1
81135b58:	00fffc04 	movi	r3,-16
81135b5c:	10c4b03a 	or	r2,r2,r3
81135b60:	10800044 	addi	r2,r2,1
81135b64:	1004917a 	slli	r2,r2,5
81135b68:	1007883a 	mov	r3,r2
81135b6c:	e0bffe17 	ldw	r2,-8(fp)
81135b70:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81135b74:	e0bfff17 	ldw	r2,-4(fp)
81135b78:	1080058b 	ldhu	r2,22(r2)
81135b7c:	10ffffcc 	andi	r3,r2,65535
81135b80:	e0bffe17 	ldw	r2,-8(fp)
81135b84:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
81135b88:	e0bffe17 	ldw	r2,-8(fp)
81135b8c:	00c00044 	movi	r3,1
81135b90:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
81135b94:	e0bffe17 	ldw	r2,-8(fp)
81135b98:	00c00044 	movi	r3,1
81135b9c:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81135ba0:	e0bffe17 	ldw	r2,-8(fp)
81135ba4:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81135ba8:	1000071e 	bne	r2,zero,81135bc8 <create_file+0x204>
81135bac:	00a04574 	movhi	r2,33045
81135bb0:	1094b704 	addi	r2,r2,21212
81135bb4:	10c01317 	ldw	r3,76(r2)
81135bb8:	e0bffe17 	ldw	r2,-8(fp)
81135bbc:	10800b17 	ldw	r2,44(r2)
81135bc0:	1885883a 	add	r2,r3,r2
81135bc4:	00000f06 	br	81135c04 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81135bc8:	00a04574 	movhi	r2,33045
81135bcc:	1094b704 	addi	r2,r2,21212
81135bd0:	10c01417 	ldw	r3,80(r2)
81135bd4:	e0bffe17 	ldw	r2,-8(fp)
81135bd8:	10800a17 	ldw	r2,40(r2)
81135bdc:	113fff84 	addi	r4,r2,-2
81135be0:	00a04574 	movhi	r2,33045
81135be4:	1094b704 	addi	r2,r2,21212
81135be8:	10800383 	ldbu	r2,14(r2)
81135bec:	10803fcc 	andi	r2,r2,255
81135bf0:	2085383a 	mul	r2,r4,r2
81135bf4:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81135bf8:	e0bffe17 	ldw	r2,-8(fp)
81135bfc:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81135c00:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81135c04:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81135c08:	e0bffb17 	ldw	r2,-20(fp)
81135c0c:	d0e09517 	ldw	r3,-32172(gp)
81135c10:	180b883a 	mov	r5,r3
81135c14:	1009883a 	mov	r4,r2
81135c18:	11331d00 	call	811331d0 <Read_Sector_Data>
81135c1c:	10001726 	beq	r2,zero,81135c7c <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81135c20:	e0bffe17 	ldw	r2,-8(fp)
81135c24:	10800c0b 	ldhu	r2,48(r2)
81135c28:	10bfffcc 	andi	r2,r2,65535
81135c2c:	10a0001c 	xori	r2,r2,32768
81135c30:	10a00004 	addi	r2,r2,-32768
81135c34:	e17ffe17 	ldw	r5,-8(fp)
81135c38:	1009883a 	mov	r4,r2
81135c3c:	11338840 	call	81133884 <Write_File_Record_At_Offset>
81135c40:	10000e26 	beq	r2,zero,81135c7c <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81135c44:	113317c0 	call	8113317c <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
81135c48:	e0bffc17 	ldw	r2,-16(fp)
81135c4c:	01800044 	movi	r6,1
81135c50:	017fffc4 	movi	r5,-1
81135c54:	1009883a 	mov	r4,r2
81135c58:	113336c0 	call	8113336c <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
81135c5c:	e0bffc17 	ldw	r2,-16(fp)
81135c60:	000d883a 	mov	r6,zero
81135c64:	017fffc4 	movi	r5,-1
81135c68:	1009883a 	mov	r4,r2
81135c6c:	113336c0 	call	8113336c <mark_cluster>
81135c70:	10000226 	beq	r2,zero,81135c7c <create_file+0x2b8>
                    {
                        result = true;
81135c74:	00800044 	movi	r2,1
81135c78:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81135c7c:	e0bff717 	ldw	r2,-36(fp)
}
81135c80:	e037883a 	mov	sp,fp
81135c84:	dfc00117 	ldw	ra,4(sp)
81135c88:	df000017 	ldw	fp,0(sp)
81135c8c:	dec00204 	addi	sp,sp,8
81135c90:	f800283a 	ret

81135c94 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81135c94:	defffb04 	addi	sp,sp,-20
81135c98:	de00012e 	bgeu	sp,et,81135ca0 <copy_file_record_name_to_string+0xc>
81135c9c:	003b68fa 	trap	3
81135ca0:	df000415 	stw	fp,16(sp)
81135ca4:	df000404 	addi	fp,sp,16
81135ca8:	e13ffe15 	stw	r4,-8(fp)
81135cac:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81135cb0:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81135cb4:	e03ffc15 	stw	zero,-16(fp)
81135cb8:	00001506 	br	81135d10 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81135cbc:	e0fffe17 	ldw	r3,-8(fp)
81135cc0:	e0bffc17 	ldw	r2,-16(fp)
81135cc4:	1885883a 	add	r2,r3,r2
81135cc8:	10800003 	ldbu	r2,0(r2)
81135ccc:	10803fcc 	andi	r2,r2,255
81135cd0:	10800820 	cmpeqi	r2,r2,32
81135cd4:	10000b1e 	bne	r2,zero,81135d04 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
81135cd8:	e0bffd17 	ldw	r2,-12(fp)
81135cdc:	e0ffff17 	ldw	r3,-4(fp)
81135ce0:	1885883a 	add	r2,r3,r2
81135ce4:	e13ffe17 	ldw	r4,-8(fp)
81135ce8:	e0fffc17 	ldw	r3,-16(fp)
81135cec:	20c7883a 	add	r3,r4,r3
81135cf0:	18c00003 	ldbu	r3,0(r3)
81135cf4:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
81135cf8:	e0bffd17 	ldw	r2,-12(fp)
81135cfc:	10800044 	addi	r2,r2,1
81135d00:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81135d04:	e0bffc17 	ldw	r2,-16(fp)
81135d08:	10800044 	addi	r2,r2,1
81135d0c:	e0bffc15 	stw	r2,-16(fp)
81135d10:	e0bffc17 	ldw	r2,-16(fp)
81135d14:	10800210 	cmplti	r2,r2,8
81135d18:	103fe81e 	bne	r2,zero,81135cbc <__reset+0xfb115cbc>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81135d1c:	e0bffe17 	ldw	r2,-8(fp)
81135d20:	10800203 	ldbu	r2,8(r2)
81135d24:	10803fcc 	andi	r2,r2,255
81135d28:	10800820 	cmpeqi	r2,r2,32
81135d2c:	1000241e 	bne	r2,zero,81135dc0 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81135d30:	e0bffd17 	ldw	r2,-12(fp)
81135d34:	e0ffff17 	ldw	r3,-4(fp)
81135d38:	1885883a 	add	r2,r3,r2
81135d3c:	00c00b84 	movi	r3,46
81135d40:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
81135d44:	e0bffd17 	ldw	r2,-12(fp)
81135d48:	10800044 	addi	r2,r2,1
81135d4c:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
81135d50:	e03ffc15 	stw	zero,-16(fp)
81135d54:	00001706 	br	81135db4 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
81135d58:	e0fffe17 	ldw	r3,-8(fp)
81135d5c:	e0bffc17 	ldw	r2,-16(fp)
81135d60:	1885883a 	add	r2,r3,r2
81135d64:	10800204 	addi	r2,r2,8
81135d68:	10800003 	ldbu	r2,0(r2)
81135d6c:	10803fcc 	andi	r2,r2,255
81135d70:	10800820 	cmpeqi	r2,r2,32
81135d74:	10000c1e 	bne	r2,zero,81135da8 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81135d78:	e0bffd17 	ldw	r2,-12(fp)
81135d7c:	e0ffff17 	ldw	r3,-4(fp)
81135d80:	1885883a 	add	r2,r3,r2
81135d84:	e13ffe17 	ldw	r4,-8(fp)
81135d88:	e0fffc17 	ldw	r3,-16(fp)
81135d8c:	20c7883a 	add	r3,r4,r3
81135d90:	18c00204 	addi	r3,r3,8
81135d94:	18c00003 	ldbu	r3,0(r3)
81135d98:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81135d9c:	e0bffd17 	ldw	r2,-12(fp)
81135da0:	10800044 	addi	r2,r2,1
81135da4:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81135da8:	e0bffc17 	ldw	r2,-16(fp)
81135dac:	10800044 	addi	r2,r2,1
81135db0:	e0bffc15 	stw	r2,-16(fp)
81135db4:	e0bffc17 	ldw	r2,-16(fp)
81135db8:	108000d0 	cmplti	r2,r2,3
81135dbc:	103fe61e 	bne	r2,zero,81135d58 <__reset+0xfb115d58>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81135dc0:	e0bffd17 	ldw	r2,-12(fp)
81135dc4:	e0ffff17 	ldw	r3,-4(fp)
81135dc8:	1885883a 	add	r2,r3,r2
81135dcc:	10000005 	stb	zero,0(r2)
}
81135dd0:	0001883a 	nop
81135dd4:	e037883a 	mov	sp,fp
81135dd8:	df000017 	ldw	fp,0(sp)
81135ddc:	dec00104 	addi	sp,sp,4
81135de0:	f800283a 	ret

81135de4 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81135de4:	defffc04 	addi	sp,sp,-16
81135de8:	de00012e 	bgeu	sp,et,81135df0 <alt_up_sd_card_open_dev+0xc>
81135dec:	003b68fa 	trap	3
81135df0:	dfc00315 	stw	ra,12(sp)
81135df4:	df000215 	stw	fp,8(sp)
81135df8:	df000204 	addi	fp,sp,8
81135dfc:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81135e00:	d1600d04 	addi	r5,gp,-32716
81135e04:	e13fff17 	ldw	r4,-4(fp)
81135e08:	113b2dc0 	call	8113b2dc <alt_find_dev>
81135e0c:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81135e10:	e0bffe17 	ldw	r2,-8(fp)
81135e14:	10001e26 	beq	r2,zero,81135e90 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
81135e18:	e0bffe17 	ldw	r2,-8(fp)
81135e1c:	10800a17 	ldw	r2,40(r2)
81135e20:	10808d04 	addi	r2,r2,564
81135e24:	d0a08f15 	stw	r2,-32196(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
81135e28:	e0bffe17 	ldw	r2,-8(fp)
81135e2c:	10800a17 	ldw	r2,40(r2)
81135e30:	10808904 	addi	r2,r2,548
81135e34:	d0a09015 	stw	r2,-32192(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
81135e38:	e0bffe17 	ldw	r2,-8(fp)
81135e3c:	10800a17 	ldw	r2,40(r2)
81135e40:	10808404 	addi	r2,r2,528
81135e44:	d0a09115 	stw	r2,-32188(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
81135e48:	e0bffe17 	ldw	r2,-8(fp)
81135e4c:	10800a17 	ldw	r2,40(r2)
81135e50:	10808c04 	addi	r2,r2,560
81135e54:	d0a09215 	stw	r2,-32184(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
81135e58:	e0bffe17 	ldw	r2,-8(fp)
81135e5c:	10800a17 	ldw	r2,40(r2)
81135e60:	10808b04 	addi	r2,r2,556
81135e64:	d0a09315 	stw	r2,-32180(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
81135e68:	e0bffe17 	ldw	r2,-8(fp)
81135e6c:	10800a17 	ldw	r2,40(r2)
81135e70:	d0a09415 	stw	r2,-32176(gp)
		device_pointer = dev;
81135e74:	e0bffe17 	ldw	r2,-8(fp)
81135e78:	d0a09715 	stw	r2,-32164(gp)
		initialized = false;
81135e7c:	d0208d15 	stw	zero,-32204(gp)
		is_sd_card_formated_as_FAT16 = false;
81135e80:	d0208e15 	stw	zero,-32200(gp)
		search_data.valid = false;
81135e84:	00a04574 	movhi	r2,33045
81135e88:	1094b204 	addi	r2,r2,21192
81135e8c:	10000415 	stw	zero,16(r2)
	}
	return dev;
81135e90:	e0bffe17 	ldw	r2,-8(fp)
}
81135e94:	e037883a 	mov	sp,fp
81135e98:	dfc00117 	ldw	ra,4(sp)
81135e9c:	df000017 	ldw	fp,0(sp)
81135ea0:	dec00204 	addi	sp,sp,8
81135ea4:	f800283a 	ret

81135ea8 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81135ea8:	defffd04 	addi	sp,sp,-12
81135eac:	de00012e 	bgeu	sp,et,81135eb4 <alt_up_sd_card_is_Present+0xc>
81135eb0:	003b68fa 	trap	3
81135eb4:	df000215 	stw	fp,8(sp)
81135eb8:	df000204 	addi	fp,sp,8
    bool result = false;
81135ebc:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81135ec0:	d0a09717 	ldw	r2,-32164(gp)
81135ec4:	10000826 	beq	r2,zero,81135ee8 <alt_up_sd_card_is_Present+0x40>
81135ec8:	d0a08f17 	ldw	r2,-32196(gp)
81135ecc:	1080002b 	ldhuio	r2,0(r2)
81135ed0:	10bfffcc 	andi	r2,r2,65535
81135ed4:	1080008c 	andi	r2,r2,2
81135ed8:	10000326 	beq	r2,zero,81135ee8 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81135edc:	00800044 	movi	r2,1
81135ee0:	e0bffe15 	stw	r2,-8(fp)
81135ee4:	00001e06 	br	81135f60 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81135ee8:	d0a08d17 	ldw	r2,-32204(gp)
81135eec:	10800058 	cmpnei	r2,r2,1
81135ef0:	10001b1e 	bne	r2,zero,81135f60 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81135ef4:	d0208d15 	stw	zero,-32204(gp)
		search_data.valid = false;
81135ef8:	00a04574 	movhi	r2,33045
81135efc:	1094b204 	addi	r2,r2,21192
81135f00:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81135f04:	d0208e15 	stw	zero,-32200(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81135f08:	e03fff15 	stw	zero,-4(fp)
81135f0c:	00001106 	br	81135f54 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81135f10:	00a04574 	movhi	r2,33045
81135f14:	1094cc04 	addi	r2,r2,21296
81135f18:	e0ffff17 	ldw	r3,-4(fp)
81135f1c:	180691ba 	slli	r3,r3,6
81135f20:	10c5883a 	add	r2,r2,r3
81135f24:	10800f04 	addi	r2,r2,60
81135f28:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81135f2c:	00a04574 	movhi	r2,33045
81135f30:	1094cc04 	addi	r2,r2,21296
81135f34:	e0ffff17 	ldw	r3,-4(fp)
81135f38:	180691ba 	slli	r3,r3,6
81135f3c:	10c5883a 	add	r2,r2,r3
81135f40:	10800e04 	addi	r2,r2,56
81135f44:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
81135f48:	e0bfff17 	ldw	r2,-4(fp)
81135f4c:	10800044 	addi	r2,r2,1
81135f50:	e0bfff15 	stw	r2,-4(fp)
81135f54:	e0bfff17 	ldw	r2,-4(fp)
81135f58:	10800510 	cmplti	r2,r2,20
81135f5c:	103fec1e 	bne	r2,zero,81135f10 <__reset+0xfb115f10>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
81135f60:	e0bffe17 	ldw	r2,-8(fp)
}
81135f64:	e037883a 	mov	sp,fp
81135f68:	df000017 	ldw	fp,0(sp)
81135f6c:	dec00104 	addi	sp,sp,4
81135f70:	f800283a 	ret

81135f74 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81135f74:	defffd04 	addi	sp,sp,-12
81135f78:	de00012e 	bgeu	sp,et,81135f80 <alt_up_sd_card_is_FAT16+0xc>
81135f7c:	003b68fa 	trap	3
81135f80:	dfc00215 	stw	ra,8(sp)
81135f84:	df000115 	stw	fp,4(sp)
81135f88:	df000104 	addi	fp,sp,4
	bool result = false;
81135f8c:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
81135f90:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
81135f94:	10000c26 	beq	r2,zero,81135fc8 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81135f98:	d0a08d17 	ldw	r2,-32204(gp)
81135f9c:	1000071e 	bne	r2,zero,81135fbc <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
81135fa0:	11341a00 	call	811341a0 <Look_for_FAT16>
81135fa4:	d0a08e15 	stw	r2,-32200(gp)
			initialized = is_sd_card_formated_as_FAT16;
81135fa8:	d0a08e17 	ldw	r2,-32200(gp)
81135fac:	d0a08d15 	stw	r2,-32204(gp)
			search_data.valid = false;
81135fb0:	00a04574 	movhi	r2,33045
81135fb4:	1094b204 	addi	r2,r2,21192
81135fb8:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81135fbc:	d0a08e17 	ldw	r2,-32200(gp)
81135fc0:	e0bfff15 	stw	r2,-4(fp)
81135fc4:	00000206 	br	81135fd0 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81135fc8:	d0208d15 	stw	zero,-32204(gp)
		is_sd_card_formated_as_FAT16 = false;
81135fcc:	d0208e15 	stw	zero,-32200(gp)
	}

	return result;
81135fd0:	e0bfff17 	ldw	r2,-4(fp)
}
81135fd4:	e037883a 	mov	sp,fp
81135fd8:	dfc00117 	ldw	ra,4(sp)
81135fdc:	df000017 	ldw	fp,0(sp)
81135fe0:	dec00204 	addi	sp,sp,8
81135fe4:	f800283a 	ret

81135fe8 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81135fe8:	deffea04 	addi	sp,sp,-88
81135fec:	de00012e 	bgeu	sp,et,81135ff4 <alt_up_sd_card_find_first+0xc>
81135ff0:	003b68fa 	trap	3
81135ff4:	dfc01515 	stw	ra,84(sp)
81135ff8:	df001415 	stw	fp,80(sp)
81135ffc:	df001404 	addi	fp,sp,80
81136000:	e13ffe15 	stw	r4,-8(fp)
81136004:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
81136008:	00800084 	movi	r2,2
8113600c:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81136010:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
81136014:	10002426 	beq	r2,zero,811360a8 <alt_up_sd_card_find_first+0xc0>
81136018:	d0a08e17 	ldw	r2,-32200(gp)
8113601c:	10002226 	beq	r2,zero,811360a8 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
81136020:	e0ffee04 	addi	r3,fp,-72
81136024:	e0bfed04 	addi	r2,fp,-76
81136028:	180d883a 	mov	r6,r3
8113602c:	100b883a 	mov	r5,r2
81136030:	e13ffe17 	ldw	r4,-8(fp)
81136034:	11349380 	call	81134938 <get_home_directory_cluster_for_file>
81136038:	10001926 	beq	r2,zero,811360a0 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
8113603c:	e0bfed17 	ldw	r2,-76(fp)
81136040:	1007883a 	mov	r3,r2
81136044:	00a04574 	movhi	r2,33045
81136048:	1094b204 	addi	r2,r2,21192
8113604c:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
81136050:	e0bfed17 	ldw	r2,-76(fp)
81136054:	1007883a 	mov	r3,r2
81136058:	00a04574 	movhi	r2,33045
8113605c:	1094b204 	addi	r2,r2,21192
81136060:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
81136064:	00a04574 	movhi	r2,33045
81136068:	1094b204 	addi	r2,r2,21192
8113606c:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
81136070:	00a04574 	movhi	r2,33045
81136074:	1094b204 	addi	r2,r2,21192
81136078:	00ffffc4 	movi	r3,-1
8113607c:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
81136080:	00a04574 	movhi	r2,33045
81136084:	1094b204 	addi	r2,r2,21192
81136088:	00c00044 	movi	r3,1
8113608c:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
81136090:	e13fff17 	ldw	r4,-4(fp)
81136094:	11360c00 	call	811360c0 <alt_up_sd_card_find_next>
81136098:	e0bfec0d 	sth	r2,-80(fp)
8113609c:	00000206 	br	811360a8 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
811360a0:	00800044 	movi	r2,1
811360a4:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
811360a8:	e0bfec0b 	ldhu	r2,-80(fp)
}
811360ac:	e037883a 	mov	sp,fp
811360b0:	dfc00117 	ldw	ra,4(sp)
811360b4:	df000017 	ldw	fp,0(sp)
811360b8:	dec00204 	addi	sp,sp,8
811360bc:	f800283a 	ret

811360c0 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
811360c0:	deffe404 	addi	sp,sp,-112
811360c4:	de00012e 	bgeu	sp,et,811360cc <alt_up_sd_card_find_next+0xc>
811360c8:	003b68fa 	trap	3
811360cc:	dfc01b15 	stw	ra,108(sp)
811360d0:	df001a15 	stw	fp,104(sp)
811360d4:	df001a04 	addi	fp,sp,104
811360d8:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
811360dc:	00800084 	movi	r2,2
811360e0:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811360e4:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
811360e8:	1000df26 	beq	r2,zero,81136468 <alt_up_sd_card_find_next+0x3a8>
811360ec:	d0a08e17 	ldw	r2,-32200(gp)
811360f0:	1000dd26 	beq	r2,zero,81136468 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
811360f4:	00a04574 	movhi	r2,33045
811360f8:	1094b204 	addi	r2,r2,21192
811360fc:	10800417 	ldw	r2,16(r2)
81136100:	1000d726 	beq	r2,zero,81136460 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81136104:	00a04574 	movhi	r2,33045
81136108:	1094b204 	addi	r2,r2,21192
8113610c:	10800117 	ldw	r2,4(r2)
81136110:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
81136114:	e0bfe717 	ldw	r2,-100(fp)
81136118:	1000561e 	bne	r2,zero,81136274 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113611c:	00a04574 	movhi	r2,33045
81136120:	1094b704 	addi	r2,r2,21212
81136124:	1080050b 	ldhu	r2,20(r2)
81136128:	10bfffcc 	andi	r2,r2,65535
8113612c:	1006917a 	slli	r3,r2,5
81136130:	00a04574 	movhi	r2,33045
81136134:	1094b704 	addi	r2,r2,21212
81136138:	1080030b 	ldhu	r2,12(r2)
8113613c:	10bfffcc 	andi	r2,r2,65535
81136140:	1885283a 	div	r2,r3,r2
81136144:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
81136148:	00a04574 	movhi	r2,33045
8113614c:	1094b204 	addi	r2,r2,21192
81136150:	10800217 	ldw	r2,8(r2)
81136154:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
81136158:	00a04574 	movhi	r2,33045
8113615c:	1094b204 	addi	r2,r2,21192
81136160:	1080030b 	ldhu	r2,12(r2)
81136164:	10bfffcc 	andi	r2,r2,65535
81136168:	10a0001c 	xori	r2,r2,32768
8113616c:	10a00004 	addi	r2,r2,-32768
81136170:	10800044 	addi	r2,r2,1
81136174:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81136178:	00003606 	br	81136254 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113617c:	00a04574 	movhi	r2,33045
81136180:	1094b704 	addi	r2,r2,21212
81136184:	10c01317 	ldw	r3,76(r2)
81136188:	e0bfe817 	ldw	r2,-96(fp)
8113618c:	1885883a 	add	r2,r3,r2
81136190:	1007883a 	mov	r3,r2
81136194:	d0a09517 	ldw	r2,-32172(gp)
81136198:	100b883a 	mov	r5,r2
8113619c:	1809883a 	mov	r4,r3
811361a0:	11331d00 	call	811331d0 <Read_Sector_Data>
811361a4:	10002f26 	beq	r2,zero,81136264 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
811361a8:	00002306 	br	81136238 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
811361ac:	e0bfe917 	ldw	r2,-92(fp)
811361b0:	1004917a 	slli	r2,r2,5
811361b4:	e13fe817 	ldw	r4,-96(fp)
811361b8:	e0ffef04 	addi	r3,fp,-68
811361bc:	200f883a 	mov	r7,r4
811361c0:	000d883a 	mov	r6,zero
811361c4:	180b883a 	mov	r5,r3
811361c8:	1009883a 	mov	r4,r2
811361cc:	11336000 	call	81133600 <Read_File_Record_At_Offset>
811361d0:	10001626 	beq	r2,zero,8113622c <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
811361d4:	e0bfef03 	ldbu	r2,-68(fp)
811361d8:	10803fcc 	andi	r2,r2,255
811361dc:	10001326 	beq	r2,zero,8113622c <alt_up_sd_card_find_next+0x16c>
811361e0:	e0bfef03 	ldbu	r2,-68(fp)
811361e4:	10803fcc 	andi	r2,r2,255
811361e8:	10803960 	cmpeqi	r2,r2,229
811361ec:	10000f1e 	bne	r2,zero,8113622c <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
811361f0:	e0bfe917 	ldw	r2,-92(fp)
811361f4:	1007883a 	mov	r3,r2
811361f8:	00a04574 	movhi	r2,33045
811361fc:	1094b204 	addi	r2,r2,21192
81136200:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81136204:	e0ffe817 	ldw	r3,-96(fp)
81136208:	00a04574 	movhi	r2,33045
8113620c:	1094b204 	addi	r2,r2,21192
81136210:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
81136214:	e0bfef04 	addi	r2,fp,-68
81136218:	e17fff17 	ldw	r5,-4(fp)
8113621c:	1009883a 	mov	r4,r2
81136220:	1135c940 	call	81135c94 <copy_file_record_name_to_string>
									return 0;
81136224:	0005883a 	mov	r2,zero
81136228:	00009006 	br	8113646c <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8113622c:	e0bfe917 	ldw	r2,-92(fp)
81136230:	10800044 	addi	r2,r2,1
81136234:	e0bfe915 	stw	r2,-92(fp)
81136238:	e0bfe917 	ldw	r2,-92(fp)
8113623c:	10800410 	cmplti	r2,r2,16
81136240:	103fda1e 	bne	r2,zero,811361ac <__reset+0xfb1161ac>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
81136244:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81136248:	e0bfe817 	ldw	r2,-96(fp)
8113624c:	10800044 	addi	r2,r2,1
81136250:	e0bfe815 	stw	r2,-96(fp)
81136254:	e0ffe817 	ldw	r3,-96(fp)
81136258:	e0bfec17 	ldw	r2,-80(fp)
8113625c:	18bfc716 	blt	r3,r2,8113617c <__reset+0xfb11617c>
81136260:	00000106 	br	81136268 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
81136264:	0001883a 	nop
					}
				}
				result = -1;
81136268:	00bfffc4 	movi	r2,-1
8113626c:	e0bfe60d 	sth	r2,-104(fp)
81136270:	00007d06 	br	81136468 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81136274:	00a04574 	movhi	r2,33045
81136278:	1094b204 	addi	r2,r2,21192
8113627c:	1080030b 	ldhu	r2,12(r2)
81136280:	10bfffcc 	andi	r2,r2,65535
81136284:	10a0001c 	xori	r2,r2,32768
81136288:	10a00004 	addi	r2,r2,-32768
8113628c:	10800044 	addi	r2,r2,1
81136290:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81136294:	e0bfe717 	ldw	r2,-100(fp)
81136298:	10ffff84 	addi	r3,r2,-2
8113629c:	00a04574 	movhi	r2,33045
811362a0:	1094b704 	addi	r2,r2,21212
811362a4:	10800383 	ldbu	r2,14(r2)
811362a8:	10803fcc 	andi	r2,r2,255
811362ac:	1885383a 	mul	r2,r3,r2
811362b0:	1007883a 	mov	r3,r2
811362b4:	00a04574 	movhi	r2,33045
811362b8:	1094b704 	addi	r2,r2,21212
811362bc:	10801417 	ldw	r2,80(r2)
811362c0:	1885883a 	add	r2,r3,r2
811362c4:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
811362c8:	00a04574 	movhi	r2,33045
811362cc:	1094b204 	addi	r2,r2,21192
811362d0:	10800217 	ldw	r2,8(r2)
811362d4:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811362d8:	00003806 	br	811363bc <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811362dc:	e0ffeb17 	ldw	r3,-84(fp)
811362e0:	e0bfed17 	ldw	r2,-76(fp)
811362e4:	1885883a 	add	r2,r3,r2
811362e8:	d0e09517 	ldw	r3,-32172(gp)
811362ec:	180b883a 	mov	r5,r3
811362f0:	1009883a 	mov	r4,r2
811362f4:	11331d00 	call	811331d0 <Read_Sector_Data>
811362f8:	10003726 	beq	r2,zero,811363d8 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
811362fc:	00002806 	br	811363a0 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
81136300:	e0bfea17 	ldw	r2,-88(fp)
81136304:	1004917a 	slli	r2,r2,5
81136308:	e13fe717 	ldw	r4,-100(fp)
8113630c:	e17feb17 	ldw	r5,-84(fp)
81136310:	e0ffef04 	addi	r3,fp,-68
81136314:	280f883a 	mov	r7,r5
81136318:	200d883a 	mov	r6,r4
8113631c:	180b883a 	mov	r5,r3
81136320:	1009883a 	mov	r4,r2
81136324:	11336000 	call	81133600 <Read_File_Record_At_Offset>
81136328:	10001a26 	beq	r2,zero,81136394 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
8113632c:	e0bfef03 	ldbu	r2,-68(fp)
81136330:	10803fcc 	andi	r2,r2,255
81136334:	10001726 	beq	r2,zero,81136394 <alt_up_sd_card_find_next+0x2d4>
81136338:	e0bfef03 	ldbu	r2,-68(fp)
8113633c:	10803fcc 	andi	r2,r2,255
81136340:	10803960 	cmpeqi	r2,r2,229
81136344:	1000131e 	bne	r2,zero,81136394 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
81136348:	e0ffe717 	ldw	r3,-100(fp)
8113634c:	00a04574 	movhi	r2,33045
81136350:	1094b204 	addi	r2,r2,21192
81136354:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
81136358:	e0bfea17 	ldw	r2,-88(fp)
8113635c:	1007883a 	mov	r3,r2
81136360:	00a04574 	movhi	r2,33045
81136364:	1094b204 	addi	r2,r2,21192
81136368:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
8113636c:	e0ffeb17 	ldw	r3,-84(fp)
81136370:	00a04574 	movhi	r2,33045
81136374:	1094b204 	addi	r2,r2,21192
81136378:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
8113637c:	e0bfef04 	addi	r2,fp,-68
81136380:	e17fff17 	ldw	r5,-4(fp)
81136384:	1009883a 	mov	r4,r2
81136388:	1135c940 	call	81135c94 <copy_file_record_name_to_string>
										return 0;
8113638c:	0005883a 	mov	r2,zero
81136390:	00003606 	br	8113646c <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81136394:	e0bfea17 	ldw	r2,-88(fp)
81136398:	10800044 	addi	r2,r2,1
8113639c:	e0bfea15 	stw	r2,-88(fp)
811363a0:	e0bfea17 	ldw	r2,-88(fp)
811363a4:	10800410 	cmplti	r2,r2,16
811363a8:	103fd51e 	bne	r2,zero,81136300 <__reset+0xfb116300>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
811363ac:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811363b0:	e0bfeb17 	ldw	r2,-84(fp)
811363b4:	10800044 	addi	r2,r2,1
811363b8:	e0bfeb15 	stw	r2,-84(fp)
811363bc:	00a04574 	movhi	r2,33045
811363c0:	1094b704 	addi	r2,r2,21212
811363c4:	10800383 	ldbu	r2,14(r2)
811363c8:	10803fcc 	andi	r2,r2,255
811363cc:	e0ffeb17 	ldw	r3,-84(fp)
811363d0:	18bfc216 	blt	r3,r2,811362dc <__reset+0xfb1162dc>
811363d4:	00000106 	br	811363dc <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
811363d8:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
811363dc:	00a04574 	movhi	r2,33045
811363e0:	1094b704 	addi	r2,r2,21212
811363e4:	10800383 	ldbu	r2,14(r2)
811363e8:	10803fcc 	andi	r2,r2,255
811363ec:	e0ffeb17 	ldw	r3,-84(fp)
811363f0:	18801716 	blt	r3,r2,81136450 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
811363f4:	e0bfe717 	ldw	r2,-100(fp)
811363f8:	e0ffee04 	addi	r3,fp,-72
811363fc:	180b883a 	mov	r5,r3
81136400:	1009883a 	mov	r4,r2
81136404:	11332b00 	call	811332b0 <get_cluster_flag>
81136408:	10000f26 	beq	r2,zero,81136448 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113640c:	e0bfee0b 	ldhu	r2,-72(fp)
81136410:	10bfffcc 	andi	r2,r2,65535
81136414:	10fffe0c 	andi	r3,r2,65528
81136418:	00bffe14 	movui	r2,65528
8113641c:	1880051e 	bne	r3,r2,81136434 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
81136420:	00bfffc4 	movi	r2,-1
81136424:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
81136428:	00a04574 	movhi	r2,33045
8113642c:	1094b204 	addi	r2,r2,21192
81136430:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
81136434:	e0bfee0b 	ldhu	r2,-72(fp)
81136438:	10bfffcc 	andi	r2,r2,65535
8113643c:	10bffe0c 	andi	r2,r2,65528
81136440:	e0bfe715 	stw	r2,-100(fp)
81136444:	00000206 	br	81136450 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
81136448:	00bfffc4 	movi	r2,-1
8113644c:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
81136450:	e0bfe717 	ldw	r2,-100(fp)
81136454:	00fffdd4 	movui	r3,65527
81136458:	18bf8e0e 	bge	r3,r2,81136294 <__reset+0xfb116294>
8113645c:	00000206 	br	81136468 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
81136460:	008000c4 	movi	r2,3
81136464:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
81136468:	e0bfe60b 	ldhu	r2,-104(fp)
}
8113646c:	e037883a 	mov	sp,fp
81136470:	dfc00117 	ldw	ra,4(sp)
81136474:	df000017 	ldw	fp,0(sp)
81136478:	dec00204 	addi	sp,sp,8
8113647c:	f800283a 	ret

81136480 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
81136480:	deffe904 	addi	sp,sp,-92
81136484:	de00012e 	bgeu	sp,et,8113648c <alt_up_sd_card_fopen+0xc>
81136488:	003b68fa 	trap	3
8113648c:	dfc01615 	stw	ra,88(sp)
81136490:	df001515 	stw	fp,84(sp)
81136494:	df001504 	addi	fp,sp,84
81136498:	e13ffe15 	stw	r4,-8(fp)
8113649c:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
811364a0:	00bfffc4 	movi	r2,-1
811364a4:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811364a8:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
811364ac:	1000cf26 	beq	r2,zero,811367ec <alt_up_sd_card_fopen+0x36c>
811364b0:	d0a08e17 	ldw	r2,-32200(gp)
811364b4:	1000cd26 	beq	r2,zero,811367ec <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
811364b8:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
811364bc:	e13ffe17 	ldw	r4,-8(fp)
811364c0:	11342940 	call	81134294 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
811364c4:	e13ffe17 	ldw	r4,-8(fp)
811364c8:	11343600 	call	81134360 <check_file_name_for_FAT16_compliance>
811364cc:	1000c726 	beq	r2,zero,811367ec <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
811364d0:	e0ffee04 	addi	r3,fp,-72
811364d4:	e0bfed04 	addi	r2,fp,-76
811364d8:	180d883a 	mov	r6,r3
811364dc:	100b883a 	mov	r5,r2
811364e0:	e13ffe17 	ldw	r4,-8(fp)
811364e4:	11349380 	call	81134938 <get_home_directory_cluster_for_file>
811364e8:	1000021e 	bne	r2,zero,811364f4 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
811364ec:	e0bfeb0b 	ldhu	r2,-84(fp)
811364f0:	0000bf06 	br	811367f0 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811364f4:	e03fec15 	stw	zero,-80(fp)
811364f8:	00000e06 	br	81136534 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
811364fc:	00a04574 	movhi	r2,33045
81136500:	1094cc04 	addi	r2,r2,21296
81136504:	e0ffec17 	ldw	r3,-80(fp)
81136508:	180691ba 	slli	r3,r3,6
8113650c:	10c5883a 	add	r2,r2,r3
81136510:	10800f04 	addi	r2,r2,60
81136514:	10800017 	ldw	r2,0(r2)
81136518:	1000031e 	bne	r2,zero,81136528 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
8113651c:	e0bfec17 	ldw	r2,-80(fp)
81136520:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
81136524:	00000606 	br	81136540 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81136528:	e0bfec17 	ldw	r2,-80(fp)
8113652c:	10800044 	addi	r2,r2,1
81136530:	e0bfec15 	stw	r2,-80(fp)
81136534:	e0bfec17 	ldw	r2,-80(fp)
81136538:	10800510 	cmplti	r2,r2,20
8113653c:	103fef1e 	bne	r2,zero,811364fc <__reset+0xfb1164fc>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
81136540:	e0bfeb0f 	ldh	r2,-84(fp)
81136544:	1000a916 	blt	r2,zero,811367ec <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
81136548:	e0bfed17 	ldw	r2,-76(fp)
8113654c:	1009883a 	mov	r4,r2
81136550:	e0bfeb0f 	ldh	r2,-84(fp)
81136554:	100691ba 	slli	r3,r2,6
81136558:	00a04574 	movhi	r2,33045
8113655c:	1094cc04 	addi	r2,r2,21296
81136560:	1885883a 	add	r2,r3,r2
81136564:	100d883a 	mov	r6,r2
81136568:	e17ffe17 	ldw	r5,-8(fp)
8113656c:	1134e780 	call	81134e78 <find_file_in_directory>
81136570:	10007b26 	beq	r2,zero,81136760 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
81136574:	e0bfff17 	ldw	r2,-4(fp)
81136578:	10000226 	beq	r2,zero,81136584 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
8113657c:	00bfffc4 	movi	r2,-1
81136580:	00009b06 	br	811367f0 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
81136584:	e13feb0f 	ldh	r4,-84(fp)
81136588:	e0ffeb0f 	ldh	r3,-84(fp)
8113658c:	00a04574 	movhi	r2,33045
81136590:	1094cc04 	addi	r2,r2,21296
81136594:	180691ba 	slli	r3,r3,6
81136598:	10c5883a 	add	r2,r2,r3
8113659c:	10800584 	addi	r2,r2,22
811365a0:	1080000b 	ldhu	r2,0(r2)
811365a4:	10ffffcc 	andi	r3,r2,65535
811365a8:	00a04574 	movhi	r2,33045
811365ac:	1094cc04 	addi	r2,r2,21296
811365b0:	200891ba 	slli	r4,r4,6
811365b4:	1105883a 	add	r2,r2,r4
811365b8:	10800704 	addi	r2,r2,28
811365bc:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
811365c0:	e0ffeb0f 	ldh	r3,-84(fp)
811365c4:	00a04574 	movhi	r2,33045
811365c8:	1094cc04 	addi	r2,r2,21296
811365cc:	180691ba 	slli	r3,r3,6
811365d0:	10c5883a 	add	r2,r2,r3
811365d4:	10800804 	addi	r2,r2,32
811365d8:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
811365dc:	e0ffeb0f 	ldh	r3,-84(fp)
811365e0:	00a04574 	movhi	r2,33045
811365e4:	1094cc04 	addi	r2,r2,21296
811365e8:	180691ba 	slli	r3,r3,6
811365ec:	10c5883a 	add	r2,r2,r3
811365f0:	10800904 	addi	r2,r2,36
811365f4:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
811365f8:	e0ffeb0f 	ldh	r3,-84(fp)
811365fc:	00a04574 	movhi	r2,33045
81136600:	1094cc04 	addi	r2,r2,21296
81136604:	180691ba 	slli	r3,r3,6
81136608:	10c5883a 	add	r2,r2,r3
8113660c:	10800f04 	addi	r2,r2,60
81136610:	00c00044 	movi	r3,1
81136614:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
81136618:	e0ffeb0f 	ldh	r3,-84(fp)
8113661c:	00a04574 	movhi	r2,33045
81136620:	1094cc04 	addi	r2,r2,21296
81136624:	180691ba 	slli	r3,r3,6
81136628:	10c5883a 	add	r2,r2,r3
8113662c:	10800e04 	addi	r2,r2,56
81136630:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81136634:	e03fec15 	stw	zero,-80(fp)
81136638:	00004506 	br	81136750 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
8113663c:	e0ffeb0f 	ldh	r3,-84(fp)
81136640:	e0bfec17 	ldw	r2,-80(fp)
81136644:	18803f26 	beq	r3,r2,81136744 <alt_up_sd_card_fopen+0x2c4>
81136648:	00a04574 	movhi	r2,33045
8113664c:	1094cc04 	addi	r2,r2,21296
81136650:	e0ffec17 	ldw	r3,-80(fp)
81136654:	180691ba 	slli	r3,r3,6
81136658:	10c5883a 	add	r2,r2,r3
8113665c:	10800f04 	addi	r2,r2,60
81136660:	10800017 	ldw	r2,0(r2)
81136664:	10800058 	cmpnei	r2,r2,1
81136668:	1000361e 	bne	r2,zero,81136744 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113666c:	e0ffeb0f 	ldh	r3,-84(fp)
81136670:	00a04574 	movhi	r2,33045
81136674:	1094cc04 	addi	r2,r2,21296
81136678:	180691ba 	slli	r3,r3,6
8113667c:	10c5883a 	add	r2,r2,r3
81136680:	10800a04 	addi	r2,r2,40
81136684:	10c00017 	ldw	r3,0(r2)
81136688:	00a04574 	movhi	r2,33045
8113668c:	1094cc04 	addi	r2,r2,21296
81136690:	e13fec17 	ldw	r4,-80(fp)
81136694:	200891ba 	slli	r4,r4,6
81136698:	1105883a 	add	r2,r2,r4
8113669c:	10800a04 	addi	r2,r2,40
811366a0:	10800017 	ldw	r2,0(r2)
811366a4:	1880271e 	bne	r3,r2,81136744 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
811366a8:	e0ffeb0f 	ldh	r3,-84(fp)
811366ac:	00a04574 	movhi	r2,33045
811366b0:	1094cc04 	addi	r2,r2,21296
811366b4:	180691ba 	slli	r3,r3,6
811366b8:	10c5883a 	add	r2,r2,r3
811366bc:	10800b04 	addi	r2,r2,44
811366c0:	10c00017 	ldw	r3,0(r2)
811366c4:	00a04574 	movhi	r2,33045
811366c8:	1094cc04 	addi	r2,r2,21296
811366cc:	e13fec17 	ldw	r4,-80(fp)
811366d0:	200891ba 	slli	r4,r4,6
811366d4:	1105883a 	add	r2,r2,r4
811366d8:	10800b04 	addi	r2,r2,44
811366dc:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
811366e0:	1880181e 	bne	r3,r2,81136744 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
811366e4:	e0ffeb0f 	ldh	r3,-84(fp)
811366e8:	00a04574 	movhi	r2,33045
811366ec:	1094cc04 	addi	r2,r2,21296
811366f0:	180691ba 	slli	r3,r3,6
811366f4:	10c5883a 	add	r2,r2,r3
811366f8:	10800c04 	addi	r2,r2,48
811366fc:	1100000b 	ldhu	r4,0(r2)
81136700:	00a04574 	movhi	r2,33045
81136704:	1094cc04 	addi	r2,r2,21296
81136708:	e0ffec17 	ldw	r3,-80(fp)
8113670c:	180691ba 	slli	r3,r3,6
81136710:	10c5883a 	add	r2,r2,r3
81136714:	10800c04 	addi	r2,r2,48
81136718:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113671c:	20ffffcc 	andi	r3,r4,65535
81136720:	18e0001c 	xori	r3,r3,32768
81136724:	18e00004 	addi	r3,r3,-32768
81136728:	10bfffcc 	andi	r2,r2,65535
8113672c:	10a0001c 	xori	r2,r2,32768
81136730:	10a00004 	addi	r2,r2,-32768
81136734:	1880031e 	bne	r3,r2,81136744 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
81136738:	00bfff84 	movi	r2,-2
8113673c:	e0bfeb0d 	sth	r2,-84(fp)
								break;
81136740:	00002a06 	br	811367ec <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81136744:	e0bfec17 	ldw	r2,-80(fp)
81136748:	10800044 	addi	r2,r2,1
8113674c:	e0bfec15 	stw	r2,-80(fp)
81136750:	e0bfec17 	ldw	r2,-80(fp)
81136754:	10800510 	cmplti	r2,r2,20
81136758:	103fb81e 	bne	r2,zero,8113663c <__reset+0xfb11663c>
8113675c:	00002306 	br	811367ec <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
81136760:	e0bfff17 	ldw	r2,-4(fp)
81136764:	10001f26 	beq	r2,zero,811367e4 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
81136768:	e0bfeb0f 	ldh	r2,-84(fp)
8113676c:	100691ba 	slli	r3,r2,6
81136770:	00a04574 	movhi	r2,33045
81136774:	1094cc04 	addi	r2,r2,21296
81136778:	1885883a 	add	r2,r3,r2
8113677c:	e0ffee04 	addi	r3,fp,-72
81136780:	180d883a 	mov	r6,r3
81136784:	100b883a 	mov	r5,r2
81136788:	e13ffe17 	ldw	r4,-8(fp)
8113678c:	11359c40 	call	811359c4 <create_file>
81136790:	10001126 	beq	r2,zero,811367d8 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
81136794:	e0ffeb0f 	ldh	r3,-84(fp)
81136798:	00a04574 	movhi	r2,33045
8113679c:	1094cc04 	addi	r2,r2,21296
811367a0:	180691ba 	slli	r3,r3,6
811367a4:	10c5883a 	add	r2,r2,r3
811367a8:	10800f04 	addi	r2,r2,60
811367ac:	00c00044 	movi	r3,1
811367b0:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
811367b4:	e0ffeb0f 	ldh	r3,-84(fp)
811367b8:	00a04574 	movhi	r2,33045
811367bc:	1094cc04 	addi	r2,r2,21296
811367c0:	180691ba 	slli	r3,r3,6
811367c4:	10c5883a 	add	r2,r2,r3
811367c8:	10800e04 	addi	r2,r2,56
811367cc:	00c00044 	movi	r3,1
811367d0:	10c00015 	stw	r3,0(r2)
811367d4:	00000506 	br	811367ec <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
811367d8:	00bfffc4 	movi	r2,-1
811367dc:	e0bfeb0d 	sth	r2,-84(fp)
811367e0:	00000206 	br	811367ec <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
811367e4:	00bfffc4 	movi	r2,-1
811367e8:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
811367ec:	e0bfeb0b 	ldhu	r2,-84(fp)
}
811367f0:	e037883a 	mov	sp,fp
811367f4:	dfc00117 	ldw	ra,4(sp)
811367f8:	df000017 	ldw	fp,0(sp)
811367fc:	dec00204 	addi	sp,sp,8
81136800:	f800283a 	ret

81136804 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81136804:	defffd04 	addi	sp,sp,-12
81136808:	de00012e 	bgeu	sp,et,81136810 <alt_up_sd_card_set_attributes+0xc>
8113680c:	003b68fa 	trap	3
81136810:	df000215 	stw	fp,8(sp)
81136814:	df000204 	addi	fp,sp,8
81136818:	2007883a 	mov	r3,r4
8113681c:	2805883a 	mov	r2,r5
81136820:	e0fffe0d 	sth	r3,-8(fp)
81136824:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81136828:	e0bffe0f 	ldh	r2,-8(fp)
8113682c:	10001416 	blt	r2,zero,81136880 <alt_up_sd_card_set_attributes+0x7c>
81136830:	e0bffe0f 	ldh	r2,-8(fp)
81136834:	10800508 	cmpgei	r2,r2,20
81136838:	1000111e 	bne	r2,zero,81136880 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8113683c:	e0fffe0f 	ldh	r3,-8(fp)
81136840:	00a04574 	movhi	r2,33045
81136844:	1094cc04 	addi	r2,r2,21296
81136848:	180691ba 	slli	r3,r3,6
8113684c:	10c5883a 	add	r2,r2,r3
81136850:	10800f04 	addi	r2,r2,60
81136854:	10800017 	ldw	r2,0(r2)
81136858:	10000926 	beq	r2,zero,81136880 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
8113685c:	e0fffe0f 	ldh	r3,-8(fp)
81136860:	e0bfff0b 	ldhu	r2,-4(fp)
81136864:	1009883a 	mov	r4,r2
81136868:	00a04574 	movhi	r2,33045
8113686c:	1094cc04 	addi	r2,r2,21296
81136870:	180691ba 	slli	r3,r3,6
81136874:	10c5883a 	add	r2,r2,r3
81136878:	108002c4 	addi	r2,r2,11
8113687c:	11000005 	stb	r4,0(r2)
        }
    }
}
81136880:	0001883a 	nop
81136884:	e037883a 	mov	sp,fp
81136888:	df000017 	ldw	fp,0(sp)
8113688c:	dec00104 	addi	sp,sp,4
81136890:	f800283a 	ret

81136894 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81136894:	defffd04 	addi	sp,sp,-12
81136898:	de00012e 	bgeu	sp,et,811368a0 <alt_up_sd_card_get_attributes+0xc>
8113689c:	003b68fa 	trap	3
811368a0:	df000215 	stw	fp,8(sp)
811368a4:	df000204 	addi	fp,sp,8
811368a8:	2005883a 	mov	r2,r4
811368ac:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
811368b0:	00bfffc4 	movi	r2,-1
811368b4:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811368b8:	e0bfff0f 	ldh	r2,-4(fp)
811368bc:	10001416 	blt	r2,zero,81136910 <alt_up_sd_card_get_attributes+0x7c>
811368c0:	e0bfff0f 	ldh	r2,-4(fp)
811368c4:	10800508 	cmpgei	r2,r2,20
811368c8:	1000111e 	bne	r2,zero,81136910 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
811368cc:	e0ffff0f 	ldh	r3,-4(fp)
811368d0:	00a04574 	movhi	r2,33045
811368d4:	1094cc04 	addi	r2,r2,21296
811368d8:	180691ba 	slli	r3,r3,6
811368dc:	10c5883a 	add	r2,r2,r3
811368e0:	10800f04 	addi	r2,r2,60
811368e4:	10800017 	ldw	r2,0(r2)
811368e8:	10000926 	beq	r2,zero,81136910 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
811368ec:	e0ffff0f 	ldh	r3,-4(fp)
811368f0:	00a04574 	movhi	r2,33045
811368f4:	1094cc04 	addi	r2,r2,21296
811368f8:	180691ba 	slli	r3,r3,6
811368fc:	10c5883a 	add	r2,r2,r3
81136900:	108002c4 	addi	r2,r2,11
81136904:	10800003 	ldbu	r2,0(r2)
81136908:	10803fcc 	andi	r2,r2,255
8113690c:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
81136910:	e0bffe0b 	ldhu	r2,-8(fp)
}
81136914:	e037883a 	mov	sp,fp
81136918:	df000017 	ldw	fp,0(sp)
8113691c:	dec00104 	addi	sp,sp,4
81136920:	f800283a 	ret

81136924 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
81136924:	defffa04 	addi	sp,sp,-24
81136928:	de00012e 	bgeu	sp,et,81136930 <alt_up_sd_card_read+0xc>
8113692c:	003b68fa 	trap	3
81136930:	dfc00515 	stw	ra,20(sp)
81136934:	df000415 	stw	fp,16(sp)
81136938:	df000404 	addi	fp,sp,16
8113693c:	2005883a 	mov	r2,r4
81136940:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
81136944:	00bfffc4 	movi	r2,-1
81136948:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113694c:	e0bfff0f 	ldh	r2,-4(fp)
81136950:	1000ce16 	blt	r2,zero,81136c8c <alt_up_sd_card_read+0x368>
81136954:	e0bfff0f 	ldh	r2,-4(fp)
81136958:	10800508 	cmpgei	r2,r2,20
8113695c:	1000cb1e 	bne	r2,zero,81136c8c <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
81136960:	e0ffff0f 	ldh	r3,-4(fp)
81136964:	00a04574 	movhi	r2,33045
81136968:	1094cc04 	addi	r2,r2,21296
8113696c:	180691ba 	slli	r3,r3,6
81136970:	10c5883a 	add	r2,r2,r3
81136974:	10800f04 	addi	r2,r2,60
81136978:	10800017 	ldw	r2,0(r2)
8113697c:	1000c326 	beq	r2,zero,81136c8c <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81136980:	e0ffff0f 	ldh	r3,-4(fp)
81136984:	00a04574 	movhi	r2,33045
81136988:	1094cc04 	addi	r2,r2,21296
8113698c:	180691ba 	slli	r3,r3,6
81136990:	10c5883a 	add	r2,r2,r3
81136994:	10800904 	addi	r2,r2,36
81136998:	10c00017 	ldw	r3,0(r2)
8113699c:	e13fff0f 	ldh	r4,-4(fp)
811369a0:	00a04574 	movhi	r2,33045
811369a4:	1094cc04 	addi	r2,r2,21296
811369a8:	200891ba 	slli	r4,r4,6
811369ac:	1105883a 	add	r2,r2,r4
811369b0:	10800604 	addi	r2,r2,24
811369b4:	10800017 	ldw	r2,0(r2)
811369b8:	1880b42e 	bgeu	r3,r2,81136c8c <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811369bc:	00a04574 	movhi	r2,33045
811369c0:	1094b704 	addi	r2,r2,21212
811369c4:	10c01417 	ldw	r3,80(r2)
811369c8:	e13fff0f 	ldh	r4,-4(fp)
811369cc:	00a04574 	movhi	r2,33045
811369d0:	1094cc04 	addi	r2,r2,21296
811369d4:	200891ba 	slli	r4,r4,6
811369d8:	1105883a 	add	r2,r2,r4
811369dc:	10800704 	addi	r2,r2,28
811369e0:	10800017 	ldw	r2,0(r2)
811369e4:	113fff84 	addi	r4,r2,-2
811369e8:	00a04574 	movhi	r2,33045
811369ec:	1094b704 	addi	r2,r2,21212
811369f0:	10800383 	ldbu	r2,14(r2)
811369f4:	10803fcc 	andi	r2,r2,255
811369f8:	2085383a 	mul	r2,r4,r2
811369fc:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81136a00:	e13fff0f 	ldh	r4,-4(fp)
81136a04:	00a04574 	movhi	r2,33045
81136a08:	1094cc04 	addi	r2,r2,21296
81136a0c:	200891ba 	slli	r4,r4,6
81136a10:	1105883a 	add	r2,r2,r4
81136a14:	10800804 	addi	r2,r2,32
81136a18:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81136a1c:	1885883a 	add	r2,r3,r2
81136a20:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81136a24:	e0ffff0f 	ldh	r3,-4(fp)
81136a28:	00a04574 	movhi	r2,33045
81136a2c:	1094cc04 	addi	r2,r2,21296
81136a30:	180691ba 	slli	r3,r3,6
81136a34:	10c5883a 	add	r2,r2,r3
81136a38:	10800904 	addi	r2,r2,36
81136a3c:	10800017 	ldw	r2,0(r2)
81136a40:	10006826 	beq	r2,zero,81136be4 <alt_up_sd_card_read+0x2c0>
81136a44:	e0ffff0f 	ldh	r3,-4(fp)
81136a48:	00a04574 	movhi	r2,33045
81136a4c:	1094cc04 	addi	r2,r2,21296
81136a50:	180691ba 	slli	r3,r3,6
81136a54:	10c5883a 	add	r2,r2,r3
81136a58:	10800904 	addi	r2,r2,36
81136a5c:	10800017 	ldw	r2,0(r2)
81136a60:	10807fcc 	andi	r2,r2,511
81136a64:	10005f1e 	bne	r2,zero,81136be4 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81136a68:	e0ffff0f 	ldh	r3,-4(fp)
81136a6c:	00a04574 	movhi	r2,33045
81136a70:	1094cc04 	addi	r2,r2,21296
81136a74:	180691ba 	slli	r3,r3,6
81136a78:	10c5883a 	add	r2,r2,r3
81136a7c:	10800804 	addi	r2,r2,32
81136a80:	10c00017 	ldw	r3,0(r2)
81136a84:	00a04574 	movhi	r2,33045
81136a88:	1094b704 	addi	r2,r2,21212
81136a8c:	10800383 	ldbu	r2,14(r2)
81136a90:	10803fcc 	andi	r2,r2,255
81136a94:	10bfffc4 	addi	r2,r2,-1
81136a98:	1880401e 	bne	r3,r2,81136b9c <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81136a9c:	e0ffff0f 	ldh	r3,-4(fp)
81136aa0:	00a04574 	movhi	r2,33045
81136aa4:	1094cc04 	addi	r2,r2,21296
81136aa8:	180691ba 	slli	r3,r3,6
81136aac:	10c5883a 	add	r2,r2,r3
81136ab0:	10800704 	addi	r2,r2,28
81136ab4:	10800017 	ldw	r2,0(r2)
81136ab8:	e0fffe04 	addi	r3,fp,-8
81136abc:	180b883a 	mov	r5,r3
81136ac0:	1009883a 	mov	r4,r2
81136ac4:	11332b00 	call	811332b0 <get_cluster_flag>
81136ac8:	10003226 	beq	r2,zero,81136b94 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81136acc:	e0bffe0b 	ldhu	r2,-8(fp)
81136ad0:	10bfffcc 	andi	r2,r2,65535
81136ad4:	10fffe0c 	andi	r3,r2,65528
81136ad8:	00bffe14 	movui	r2,65528
81136adc:	1880021e 	bne	r3,r2,81136ae8 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81136ae0:	00bfffc4 	movi	r2,-1
81136ae4:	00006a06 	br	81136c90 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81136ae8:	e13fff0f 	ldh	r4,-4(fp)
81136aec:	e0bffe0b 	ldhu	r2,-8(fp)
81136af0:	10ffffcc 	andi	r3,r2,65535
81136af4:	00a04574 	movhi	r2,33045
81136af8:	1094cc04 	addi	r2,r2,21296
81136afc:	200891ba 	slli	r4,r4,6
81136b00:	1105883a 	add	r2,r2,r4
81136b04:	10800704 	addi	r2,r2,28
81136b08:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81136b0c:	e0ffff0f 	ldh	r3,-4(fp)
81136b10:	00a04574 	movhi	r2,33045
81136b14:	1094cc04 	addi	r2,r2,21296
81136b18:	180691ba 	slli	r3,r3,6
81136b1c:	10c5883a 	add	r2,r2,r3
81136b20:	10800804 	addi	r2,r2,32
81136b24:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81136b28:	00a04574 	movhi	r2,33045
81136b2c:	1094b704 	addi	r2,r2,21212
81136b30:	10c01417 	ldw	r3,80(r2)
81136b34:	e13fff0f 	ldh	r4,-4(fp)
81136b38:	00a04574 	movhi	r2,33045
81136b3c:	1094cc04 	addi	r2,r2,21296
81136b40:	200891ba 	slli	r4,r4,6
81136b44:	1105883a 	add	r2,r2,r4
81136b48:	10800704 	addi	r2,r2,28
81136b4c:	10800017 	ldw	r2,0(r2)
81136b50:	113fff84 	addi	r4,r2,-2
81136b54:	00a04574 	movhi	r2,33045
81136b58:	1094b704 	addi	r2,r2,21212
81136b5c:	10800383 	ldbu	r2,14(r2)
81136b60:	10803fcc 	andi	r2,r2,255
81136b64:	2085383a 	mul	r2,r4,r2
81136b68:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81136b6c:	e13fff0f 	ldh	r4,-4(fp)
81136b70:	00a04574 	movhi	r2,33045
81136b74:	1094cc04 	addi	r2,r2,21296
81136b78:	200891ba 	slli	r4,r4,6
81136b7c:	1105883a 	add	r2,r2,r4
81136b80:	10800804 	addi	r2,r2,32
81136b84:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81136b88:	1885883a 	add	r2,r3,r2
81136b8c:	e0bffd15 	stw	r2,-12(fp)
81136b90:	00001406 	br	81136be4 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81136b94:	00bfff84 	movi	r2,-2
81136b98:	00003d06 	br	81136c90 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81136b9c:	e13fff0f 	ldh	r4,-4(fp)
81136ba0:	e0ffff0f 	ldh	r3,-4(fp)
81136ba4:	00a04574 	movhi	r2,33045
81136ba8:	1094cc04 	addi	r2,r2,21296
81136bac:	180691ba 	slli	r3,r3,6
81136bb0:	10c5883a 	add	r2,r2,r3
81136bb4:	10800804 	addi	r2,r2,32
81136bb8:	10800017 	ldw	r2,0(r2)
81136bbc:	10c00044 	addi	r3,r2,1
81136bc0:	00a04574 	movhi	r2,33045
81136bc4:	1094cc04 	addi	r2,r2,21296
81136bc8:	200891ba 	slli	r4,r4,6
81136bcc:	1105883a 	add	r2,r2,r4
81136bd0:	10800804 	addi	r2,r2,32
81136bd4:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81136bd8:	e0bffd17 	ldw	r2,-12(fp)
81136bdc:	10800044 	addi	r2,r2,1
81136be0:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81136be4:	d0e09517 	ldw	r3,-32172(gp)
81136be8:	e0bffd17 	ldw	r2,-12(fp)
81136bec:	1885883a 	add	r2,r3,r2
81136bf0:	1007883a 	mov	r3,r2
81136bf4:	d0a09917 	ldw	r2,-32156(gp)
81136bf8:	18800726 	beq	r3,r2,81136c18 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81136bfc:	d0a09517 	ldw	r2,-32172(gp)
81136c00:	100b883a 	mov	r5,r2
81136c04:	e13ffd17 	ldw	r4,-12(fp)
81136c08:	11331d00 	call	811331d0 <Read_Sector_Data>
81136c0c:	1000021e 	bne	r2,zero,81136c18 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81136c10:	00bfff84 	movi	r2,-2
81136c14:	00001e06 	br	81136c90 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81136c18:	d0e09417 	ldw	r3,-32176(gp)
81136c1c:	e13fff0f 	ldh	r4,-4(fp)
81136c20:	00a04574 	movhi	r2,33045
81136c24:	1094cc04 	addi	r2,r2,21296
81136c28:	200891ba 	slli	r4,r4,6
81136c2c:	1105883a 	add	r2,r2,r4
81136c30:	10800904 	addi	r2,r2,36
81136c34:	10800017 	ldw	r2,0(r2)
81136c38:	10807fcc 	andi	r2,r2,511
81136c3c:	1885883a 	add	r2,r3,r2
81136c40:	10800023 	ldbuio	r2,0(r2)
81136c44:	10803fcc 	andi	r2,r2,255
81136c48:	10803fcc 	andi	r2,r2,255
81136c4c:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81136c50:	e13fff0f 	ldh	r4,-4(fp)
81136c54:	e0ffff0f 	ldh	r3,-4(fp)
81136c58:	00a04574 	movhi	r2,33045
81136c5c:	1094cc04 	addi	r2,r2,21296
81136c60:	180691ba 	slli	r3,r3,6
81136c64:	10c5883a 	add	r2,r2,r3
81136c68:	10800904 	addi	r2,r2,36
81136c6c:	10800017 	ldw	r2,0(r2)
81136c70:	10c00044 	addi	r3,r2,1
81136c74:	00a04574 	movhi	r2,33045
81136c78:	1094cc04 	addi	r2,r2,21296
81136c7c:	200891ba 	slli	r4,r4,6
81136c80:	1105883a 	add	r2,r2,r4
81136c84:	10800904 	addi	r2,r2,36
81136c88:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81136c8c:	e0bffc0b 	ldhu	r2,-16(fp)
}
81136c90:	e037883a 	mov	sp,fp
81136c94:	dfc00117 	ldw	ra,4(sp)
81136c98:	df000017 	ldw	fp,0(sp)
81136c9c:	dec00204 	addi	sp,sp,8
81136ca0:	f800283a 	ret

81136ca4 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81136ca4:	defff804 	addi	sp,sp,-32
81136ca8:	de00012e 	bgeu	sp,et,81136cb0 <alt_up_sd_card_write+0xc>
81136cac:	003b68fa 	trap	3
81136cb0:	dfc00715 	stw	ra,28(sp)
81136cb4:	df000615 	stw	fp,24(sp)
81136cb8:	df000604 	addi	fp,sp,24
81136cbc:	2007883a 	mov	r3,r4
81136cc0:	2805883a 	mov	r2,r5
81136cc4:	e0fffe0d 	sth	r3,-8(fp)
81136cc8:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81136ccc:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81136cd0:	e0bffe0f 	ldh	r2,-8(fp)
81136cd4:	10017716 	blt	r2,zero,811372b4 <alt_up_sd_card_write+0x610>
81136cd8:	e0bffe0f 	ldh	r2,-8(fp)
81136cdc:	10800508 	cmpgei	r2,r2,20
81136ce0:	1001741e 	bne	r2,zero,811372b4 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81136ce4:	e0fffe0f 	ldh	r3,-8(fp)
81136ce8:	00a04574 	movhi	r2,33045
81136cec:	1094cc04 	addi	r2,r2,21296
81136cf0:	180691ba 	slli	r3,r3,6
81136cf4:	10c5883a 	add	r2,r2,r3
81136cf8:	10800f04 	addi	r2,r2,60
81136cfc:	10800017 	ldw	r2,0(r2)
81136d00:	10016c26 	beq	r2,zero,811372b4 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81136d04:	00a04574 	movhi	r2,33045
81136d08:	1094b704 	addi	r2,r2,21212
81136d0c:	10c01417 	ldw	r3,80(r2)
81136d10:	e13ffe0f 	ldh	r4,-8(fp)
81136d14:	00a04574 	movhi	r2,33045
81136d18:	1094cc04 	addi	r2,r2,21296
81136d1c:	200891ba 	slli	r4,r4,6
81136d20:	1105883a 	add	r2,r2,r4
81136d24:	10800704 	addi	r2,r2,28
81136d28:	10800017 	ldw	r2,0(r2)
81136d2c:	113fff84 	addi	r4,r2,-2
81136d30:	00a04574 	movhi	r2,33045
81136d34:	1094b704 	addi	r2,r2,21212
81136d38:	10800383 	ldbu	r2,14(r2)
81136d3c:	10803fcc 	andi	r2,r2,255
81136d40:	2085383a 	mul	r2,r4,r2
81136d44:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81136d48:	e13ffe0f 	ldh	r4,-8(fp)
81136d4c:	00a04574 	movhi	r2,33045
81136d50:	1094cc04 	addi	r2,r2,21296
81136d54:	200891ba 	slli	r4,r4,6
81136d58:	1105883a 	add	r2,r2,r4
81136d5c:	10800804 	addi	r2,r2,32
81136d60:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81136d64:	1885883a 	add	r2,r3,r2
81136d68:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
81136d6c:	e0fffe0f 	ldh	r3,-8(fp)
81136d70:	00a04574 	movhi	r2,33045
81136d74:	1094cc04 	addi	r2,r2,21296
81136d78:	180691ba 	slli	r3,r3,6
81136d7c:	10c5883a 	add	r2,r2,r3
81136d80:	10800904 	addi	r2,r2,36
81136d84:	10c00017 	ldw	r3,0(r2)
81136d88:	00a04574 	movhi	r2,33045
81136d8c:	1094b704 	addi	r2,r2,21212
81136d90:	1080030b 	ldhu	r2,12(r2)
81136d94:	10bfffcc 	andi	r2,r2,65535
81136d98:	1889203a 	divu	r4,r3,r2
81136d9c:	2085383a 	mul	r2,r4,r2
81136da0:	1885c83a 	sub	r2,r3,r2
81136da4:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81136da8:	e0fffe0f 	ldh	r3,-8(fp)
81136dac:	00a04574 	movhi	r2,33045
81136db0:	1094cc04 	addi	r2,r2,21296
81136db4:	180691ba 	slli	r3,r3,6
81136db8:	10c5883a 	add	r2,r2,r3
81136dbc:	10800904 	addi	r2,r2,36
81136dc0:	10c00017 	ldw	r3,0(r2)
81136dc4:	e13ffe0f 	ldh	r4,-8(fp)
81136dc8:	00a04574 	movhi	r2,33045
81136dcc:	1094cc04 	addi	r2,r2,21296
81136dd0:	200891ba 	slli	r4,r4,6
81136dd4:	1105883a 	add	r2,r2,r4
81136dd8:	10800604 	addi	r2,r2,24
81136ddc:	10800017 	ldw	r2,0(r2)
81136de0:	1880672e 	bgeu	r3,r2,81136f80 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81136de4:	e0fffe0f 	ldh	r3,-8(fp)
81136de8:	00a04574 	movhi	r2,33045
81136dec:	1094cc04 	addi	r2,r2,21296
81136df0:	180691ba 	slli	r3,r3,6
81136df4:	10c5883a 	add	r2,r2,r3
81136df8:	10800904 	addi	r2,r2,36
81136dfc:	10800017 	ldw	r2,0(r2)
81136e00:	1000e126 	beq	r2,zero,81137188 <alt_up_sd_card_write+0x4e4>
81136e04:	e0bffc0f 	ldh	r2,-16(fp)
81136e08:	1000df1e 	bne	r2,zero,81137188 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81136e0c:	e0fffe0f 	ldh	r3,-8(fp)
81136e10:	00a04574 	movhi	r2,33045
81136e14:	1094cc04 	addi	r2,r2,21296
81136e18:	180691ba 	slli	r3,r3,6
81136e1c:	10c5883a 	add	r2,r2,r3
81136e20:	10800804 	addi	r2,r2,32
81136e24:	10c00017 	ldw	r3,0(r2)
81136e28:	00a04574 	movhi	r2,33045
81136e2c:	1094b704 	addi	r2,r2,21212
81136e30:	10800383 	ldbu	r2,14(r2)
81136e34:	10803fcc 	andi	r2,r2,255
81136e38:	10bfffc4 	addi	r2,r2,-1
81136e3c:	18803d1e 	bne	r3,r2,81136f34 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81136e40:	e0fffe0f 	ldh	r3,-8(fp)
81136e44:	00a04574 	movhi	r2,33045
81136e48:	1094cc04 	addi	r2,r2,21296
81136e4c:	180691ba 	slli	r3,r3,6
81136e50:	10c5883a 	add	r2,r2,r3
81136e54:	10800704 	addi	r2,r2,28
81136e58:	10800017 	ldw	r2,0(r2)
81136e5c:	e0fffc84 	addi	r3,fp,-14
81136e60:	180b883a 	mov	r5,r3
81136e64:	1009883a 	mov	r4,r2
81136e68:	11332b00 	call	811332b0 <get_cluster_flag>
81136e6c:	10002f26 	beq	r2,zero,81136f2c <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
81136e70:	e0bffc8b 	ldhu	r2,-14(fp)
81136e74:	10bfffcc 	andi	r2,r2,65535
81136e78:	10bffe28 	cmpgeui	r2,r2,65528
81136e7c:	1000c21e 	bne	r2,zero,81137188 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81136e80:	e13ffe0f 	ldh	r4,-8(fp)
81136e84:	e0bffc8b 	ldhu	r2,-14(fp)
81136e88:	10ffffcc 	andi	r3,r2,65535
81136e8c:	00a04574 	movhi	r2,33045
81136e90:	1094cc04 	addi	r2,r2,21296
81136e94:	200891ba 	slli	r4,r4,6
81136e98:	1105883a 	add	r2,r2,r4
81136e9c:	10800704 	addi	r2,r2,28
81136ea0:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81136ea4:	e0fffe0f 	ldh	r3,-8(fp)
81136ea8:	00a04574 	movhi	r2,33045
81136eac:	1094cc04 	addi	r2,r2,21296
81136eb0:	180691ba 	slli	r3,r3,6
81136eb4:	10c5883a 	add	r2,r2,r3
81136eb8:	10800804 	addi	r2,r2,32
81136ebc:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81136ec0:	00a04574 	movhi	r2,33045
81136ec4:	1094b704 	addi	r2,r2,21212
81136ec8:	10c01417 	ldw	r3,80(r2)
81136ecc:	e13ffe0f 	ldh	r4,-8(fp)
81136ed0:	00a04574 	movhi	r2,33045
81136ed4:	1094cc04 	addi	r2,r2,21296
81136ed8:	200891ba 	slli	r4,r4,6
81136edc:	1105883a 	add	r2,r2,r4
81136ee0:	10800704 	addi	r2,r2,28
81136ee4:	10800017 	ldw	r2,0(r2)
81136ee8:	113fff84 	addi	r4,r2,-2
81136eec:	00a04574 	movhi	r2,33045
81136ef0:	1094b704 	addi	r2,r2,21212
81136ef4:	10800383 	ldbu	r2,14(r2)
81136ef8:	10803fcc 	andi	r2,r2,255
81136efc:	2085383a 	mul	r2,r4,r2
81136f00:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81136f04:	e13ffe0f 	ldh	r4,-8(fp)
81136f08:	00a04574 	movhi	r2,33045
81136f0c:	1094cc04 	addi	r2,r2,21296
81136f10:	200891ba 	slli	r4,r4,6
81136f14:	1105883a 	add	r2,r2,r4
81136f18:	10800804 	addi	r2,r2,32
81136f1c:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81136f20:	1885883a 	add	r2,r3,r2
81136f24:	e0bffb15 	stw	r2,-20(fp)
81136f28:	00009706 	br	81137188 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81136f2c:	0005883a 	mov	r2,zero
81136f30:	0000e106 	br	811372b8 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81136f34:	e13ffe0f 	ldh	r4,-8(fp)
81136f38:	e0fffe0f 	ldh	r3,-8(fp)
81136f3c:	00a04574 	movhi	r2,33045
81136f40:	1094cc04 	addi	r2,r2,21296
81136f44:	180691ba 	slli	r3,r3,6
81136f48:	10c5883a 	add	r2,r2,r3
81136f4c:	10800804 	addi	r2,r2,32
81136f50:	10800017 	ldw	r2,0(r2)
81136f54:	10c00044 	addi	r3,r2,1
81136f58:	00a04574 	movhi	r2,33045
81136f5c:	1094cc04 	addi	r2,r2,21296
81136f60:	200891ba 	slli	r4,r4,6
81136f64:	1105883a 	add	r2,r2,r4
81136f68:	10800804 	addi	r2,r2,32
81136f6c:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81136f70:	e0bffb17 	ldw	r2,-20(fp)
81136f74:	10800044 	addi	r2,r2,1
81136f78:	e0bffb15 	stw	r2,-20(fp)
81136f7c:	00008206 	br	81137188 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81136f80:	e0fffe0f 	ldh	r3,-8(fp)
81136f84:	00a04574 	movhi	r2,33045
81136f88:	1094cc04 	addi	r2,r2,21296
81136f8c:	180691ba 	slli	r3,r3,6
81136f90:	10c5883a 	add	r2,r2,r3
81136f94:	10800904 	addi	r2,r2,36
81136f98:	10800017 	ldw	r2,0(r2)
81136f9c:	10007a26 	beq	r2,zero,81137188 <alt_up_sd_card_write+0x4e4>
81136fa0:	e0bffc0f 	ldh	r2,-16(fp)
81136fa4:	1000781e 	bne	r2,zero,81137188 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81136fa8:	e0fffe0f 	ldh	r3,-8(fp)
81136fac:	00a04574 	movhi	r2,33045
81136fb0:	1094cc04 	addi	r2,r2,21296
81136fb4:	180691ba 	slli	r3,r3,6
81136fb8:	10c5883a 	add	r2,r2,r3
81136fbc:	10800804 	addi	r2,r2,32
81136fc0:	10c00017 	ldw	r3,0(r2)
81136fc4:	00a04574 	movhi	r2,33045
81136fc8:	1094b704 	addi	r2,r2,21212
81136fcc:	10800383 	ldbu	r2,14(r2)
81136fd0:	10803fcc 	andi	r2,r2,255
81136fd4:	10bfffc4 	addi	r2,r2,-1
81136fd8:	18803e1e 	bne	r3,r2,811370d4 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
81136fdc:	e0bffd04 	addi	r2,fp,-12
81136fe0:	1009883a 	mov	r4,r2
81136fe4:	11352f40 	call	811352f4 <find_first_empty_cluster>
81136fe8:	10003826 	beq	r2,zero,811370cc <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
81136fec:	e0fffe0f 	ldh	r3,-8(fp)
81136ff0:	00a04574 	movhi	r2,33045
81136ff4:	1094cc04 	addi	r2,r2,21296
81136ff8:	180691ba 	slli	r3,r3,6
81136ffc:	10c5883a 	add	r2,r2,r3
81137000:	10800704 	addi	r2,r2,28
81137004:	10800017 	ldw	r2,0(r2)
81137008:	e0fffd17 	ldw	r3,-12(fp)
8113700c:	18ffffcc 	andi	r3,r3,65535
81137010:	18e0001c 	xori	r3,r3,32768
81137014:	18e00004 	addi	r3,r3,-32768
81137018:	01800044 	movi	r6,1
8113701c:	180b883a 	mov	r5,r3
81137020:	1009883a 	mov	r4,r2
81137024:	113336c0 	call	8113336c <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
81137028:	e0bffd17 	ldw	r2,-12(fp)
8113702c:	01800044 	movi	r6,1
81137030:	017fffc4 	movi	r5,-1
81137034:	1009883a 	mov	r4,r2
81137038:	113336c0 	call	8113336c <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
8113703c:	e0fffe0f 	ldh	r3,-8(fp)
81137040:	00a04574 	movhi	r2,33045
81137044:	1094cc04 	addi	r2,r2,21296
81137048:	180691ba 	slli	r3,r3,6
8113704c:	10c5883a 	add	r2,r2,r3
81137050:	10800704 	addi	r2,r2,28
81137054:	10800017 	ldw	r2,0(r2)
81137058:	e0fffd17 	ldw	r3,-12(fp)
8113705c:	18ffffcc 	andi	r3,r3,65535
81137060:	18e0001c 	xori	r3,r3,32768
81137064:	18e00004 	addi	r3,r3,-32768
81137068:	000d883a 	mov	r6,zero
8113706c:	180b883a 	mov	r5,r3
81137070:	1009883a 	mov	r4,r2
81137074:	113336c0 	call	8113336c <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81137078:	e0bffd17 	ldw	r2,-12(fp)
8113707c:	000d883a 	mov	r6,zero
81137080:	017fffc4 	movi	r5,-1
81137084:	1009883a 	mov	r4,r2
81137088:	113336c0 	call	8113336c <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
8113708c:	e13ffe0f 	ldh	r4,-8(fp)
81137090:	e0fffd17 	ldw	r3,-12(fp)
81137094:	00a04574 	movhi	r2,33045
81137098:	1094cc04 	addi	r2,r2,21296
8113709c:	200891ba 	slli	r4,r4,6
811370a0:	1105883a 	add	r2,r2,r4
811370a4:	10800704 	addi	r2,r2,28
811370a8:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
811370ac:	e0fffe0f 	ldh	r3,-8(fp)
811370b0:	00a04574 	movhi	r2,33045
811370b4:	1094cc04 	addi	r2,r2,21296
811370b8:	180691ba 	slli	r3,r3,6
811370bc:	10c5883a 	add	r2,r2,r3
811370c0:	10800804 	addi	r2,r2,32
811370c4:	10000015 	stw	zero,0(r2)
811370c8:	00001506 	br	81137120 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
811370cc:	0005883a 	mov	r2,zero
811370d0:	00007906 	br	811372b8 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
811370d4:	e13ffe0f 	ldh	r4,-8(fp)
811370d8:	e0fffe0f 	ldh	r3,-8(fp)
811370dc:	00a04574 	movhi	r2,33045
811370e0:	1094cc04 	addi	r2,r2,21296
811370e4:	180691ba 	slli	r3,r3,6
811370e8:	10c5883a 	add	r2,r2,r3
811370ec:	10800904 	addi	r2,r2,36
811370f0:	10c00017 	ldw	r3,0(r2)
811370f4:	00a04574 	movhi	r2,33045
811370f8:	1094b704 	addi	r2,r2,21212
811370fc:	1080030b 	ldhu	r2,12(r2)
81137100:	10bfffcc 	andi	r2,r2,65535
81137104:	1887203a 	divu	r3,r3,r2
81137108:	00a04574 	movhi	r2,33045
8113710c:	1094cc04 	addi	r2,r2,21296
81137110:	200891ba 	slli	r4,r4,6
81137114:	1105883a 	add	r2,r2,r4
81137118:	10800804 	addi	r2,r2,32
8113711c:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81137120:	00a04574 	movhi	r2,33045
81137124:	1094b704 	addi	r2,r2,21212
81137128:	10c01417 	ldw	r3,80(r2)
8113712c:	e13ffe0f 	ldh	r4,-8(fp)
81137130:	00a04574 	movhi	r2,33045
81137134:	1094cc04 	addi	r2,r2,21296
81137138:	200891ba 	slli	r4,r4,6
8113713c:	1105883a 	add	r2,r2,r4
81137140:	10800704 	addi	r2,r2,28
81137144:	10800017 	ldw	r2,0(r2)
81137148:	113fff84 	addi	r4,r2,-2
8113714c:	00a04574 	movhi	r2,33045
81137150:	1094b704 	addi	r2,r2,21212
81137154:	10800383 	ldbu	r2,14(r2)
81137158:	10803fcc 	andi	r2,r2,255
8113715c:	2085383a 	mul	r2,r4,r2
81137160:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
81137164:	e13ffe0f 	ldh	r4,-8(fp)
81137168:	00a04574 	movhi	r2,33045
8113716c:	1094cc04 	addi	r2,r2,21296
81137170:	200891ba 	slli	r4,r4,6
81137174:	1105883a 	add	r2,r2,r4
81137178:	10800804 	addi	r2,r2,32
8113717c:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81137180:	1885883a 	add	r2,r3,r2
81137184:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
81137188:	d0e09517 	ldw	r3,-32172(gp)
8113718c:	e0bffb17 	ldw	r2,-20(fp)
81137190:	1885883a 	add	r2,r3,r2
81137194:	1007883a 	mov	r3,r2
81137198:	d0a09917 	ldw	r2,-32156(gp)
8113719c:	18800726 	beq	r3,r2,811371bc <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
811371a0:	d0a09517 	ldw	r2,-32172(gp)
811371a4:	100b883a 	mov	r5,r2
811371a8:	e13ffb17 	ldw	r4,-20(fp)
811371ac:	11331d00 	call	811331d0 <Read_Sector_Data>
811371b0:	1000021e 	bne	r2,zero,811371bc <alt_up_sd_card_write+0x518>
                {
					return false;
811371b4:	0005883a 	mov	r2,zero
811371b8:	00003f06 	br	811372b8 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
811371bc:	d0e09417 	ldw	r3,-32176(gp)
811371c0:	e0bffc0f 	ldh	r2,-16(fp)
811371c4:	1885883a 	add	r2,r3,r2
811371c8:	e0ffff07 	ldb	r3,-4(fp)
811371cc:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
811371d0:	e13ffe0f 	ldh	r4,-8(fp)
811371d4:	e0fffe0f 	ldh	r3,-8(fp)
811371d8:	00a04574 	movhi	r2,33045
811371dc:	1094cc04 	addi	r2,r2,21296
811371e0:	180691ba 	slli	r3,r3,6
811371e4:	10c5883a 	add	r2,r2,r3
811371e8:	10800904 	addi	r2,r2,36
811371ec:	10800017 	ldw	r2,0(r2)
811371f0:	10c00044 	addi	r3,r2,1
811371f4:	00a04574 	movhi	r2,33045
811371f8:	1094cc04 	addi	r2,r2,21296
811371fc:	200891ba 	slli	r4,r4,6
81137200:	1105883a 	add	r2,r2,r4
81137204:	10800904 	addi	r2,r2,36
81137208:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
8113720c:	e0fffe0f 	ldh	r3,-8(fp)
81137210:	00a04574 	movhi	r2,33045
81137214:	1094cc04 	addi	r2,r2,21296
81137218:	180691ba 	slli	r3,r3,6
8113721c:	10c5883a 	add	r2,r2,r3
81137220:	10800904 	addi	r2,r2,36
81137224:	10c00017 	ldw	r3,0(r2)
81137228:	e13ffe0f 	ldh	r4,-8(fp)
8113722c:	00a04574 	movhi	r2,33045
81137230:	1094cc04 	addi	r2,r2,21296
81137234:	200891ba 	slli	r4,r4,6
81137238:	1105883a 	add	r2,r2,r4
8113723c:	10800604 	addi	r2,r2,24
81137240:	10800017 	ldw	r2,0(r2)
81137244:	18801736 	bltu	r3,r2,811372a4 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
81137248:	e13ffe0f 	ldh	r4,-8(fp)
8113724c:	e0fffe0f 	ldh	r3,-8(fp)
81137250:	00a04574 	movhi	r2,33045
81137254:	1094cc04 	addi	r2,r2,21296
81137258:	180691ba 	slli	r3,r3,6
8113725c:	10c5883a 	add	r2,r2,r3
81137260:	10800604 	addi	r2,r2,24
81137264:	10800017 	ldw	r2,0(r2)
81137268:	10c00044 	addi	r3,r2,1
8113726c:	00a04574 	movhi	r2,33045
81137270:	1094cc04 	addi	r2,r2,21296
81137274:	200891ba 	slli	r4,r4,6
81137278:	1105883a 	add	r2,r2,r4
8113727c:	10800604 	addi	r2,r2,24
81137280:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81137284:	e0fffe0f 	ldh	r3,-8(fp)
81137288:	00a04574 	movhi	r2,33045
8113728c:	1094cc04 	addi	r2,r2,21296
81137290:	180691ba 	slli	r3,r3,6
81137294:	10c5883a 	add	r2,r2,r3
81137298:	10800e04 	addi	r2,r2,56
8113729c:	00c00044 	movi	r3,1
811372a0:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
811372a4:	00800044 	movi	r2,1
811372a8:	d0a09815 	stw	r2,-32160(gp)
			result = true;
811372ac:	00800044 	movi	r2,1
811372b0:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
811372b4:	e0bffa17 	ldw	r2,-24(fp)
}
811372b8:	e037883a 	mov	sp,fp
811372bc:	dfc00117 	ldw	ra,4(sp)
811372c0:	df000017 	ldw	fp,0(sp)
811372c4:	dec00204 	addi	sp,sp,8
811372c8:	f800283a 	ret

811372cc <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
811372cc:	defffb04 	addi	sp,sp,-20
811372d0:	de00012e 	bgeu	sp,et,811372d8 <alt_up_sd_card_fclose+0xc>
811372d4:	003b68fa 	trap	3
811372d8:	dfc00415 	stw	ra,16(sp)
811372dc:	df000315 	stw	fp,12(sp)
811372e0:	df000304 	addi	fp,sp,12
811372e4:	2005883a 	mov	r2,r4
811372e8:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
811372ec:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811372f0:	1135ea80 	call	81135ea8 <alt_up_sd_card_is_Present>
811372f4:	10006026 	beq	r2,zero,81137478 <alt_up_sd_card_fclose+0x1ac>
811372f8:	d0a08e17 	ldw	r2,-32200(gp)
811372fc:	10005e26 	beq	r2,zero,81137478 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
81137300:	e0ffff0f 	ldh	r3,-4(fp)
81137304:	00a04574 	movhi	r2,33045
81137308:	1094cc04 	addi	r2,r2,21296
8113730c:	180691ba 	slli	r3,r3,6
81137310:	10c5883a 	add	r2,r2,r3
81137314:	10800f04 	addi	r2,r2,60
81137318:	10800017 	ldw	r2,0(r2)
8113731c:	10005626 	beq	r2,zero,81137478 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
81137320:	e0ffff0f 	ldh	r3,-4(fp)
81137324:	00a04574 	movhi	r2,33045
81137328:	1094cc04 	addi	r2,r2,21296
8113732c:	180691ba 	slli	r3,r3,6
81137330:	10c5883a 	add	r2,r2,r3
81137334:	10800e04 	addi	r2,r2,56
81137338:	10800017 	ldw	r2,0(r2)
8113733c:	10004526 	beq	r2,zero,81137454 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
81137340:	e0ffff0f 	ldh	r3,-4(fp)
81137344:	00a04574 	movhi	r2,33045
81137348:	1094cc04 	addi	r2,r2,21296
8113734c:	180691ba 	slli	r3,r3,6
81137350:	10c5883a 	add	r2,r2,r3
81137354:	10800b04 	addi	r2,r2,44
81137358:	10800017 	ldw	r2,0(r2)
8113735c:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81137360:	e0ffff0f 	ldh	r3,-4(fp)
81137364:	00a04574 	movhi	r2,33045
81137368:	1094cc04 	addi	r2,r2,21296
8113736c:	180691ba 	slli	r3,r3,6
81137370:	10c5883a 	add	r2,r2,r3
81137374:	10800a04 	addi	r2,r2,40
81137378:	10800017 	ldw	r2,0(r2)
8113737c:	1000071e 	bne	r2,zero,8113739c <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
81137380:	00a04574 	movhi	r2,33045
81137384:	1094b704 	addi	r2,r2,21212
81137388:	10801317 	ldw	r2,76(r2)
8113738c:	e0fffe17 	ldw	r3,-8(fp)
81137390:	1885883a 	add	r2,r3,r2
81137394:	e0bffe15 	stw	r2,-8(fp)
81137398:	00001406 	br	811373ec <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
8113739c:	00a04574 	movhi	r2,33045
811373a0:	1094b704 	addi	r2,r2,21212
811373a4:	10c01417 	ldw	r3,80(r2)
811373a8:	e0bffe17 	ldw	r2,-8(fp)
811373ac:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
811373b0:	e13fff0f 	ldh	r4,-4(fp)
811373b4:	00a04574 	movhi	r2,33045
811373b8:	1094cc04 	addi	r2,r2,21296
811373bc:	200891ba 	slli	r4,r4,6
811373c0:	1105883a 	add	r2,r2,r4
811373c4:	10800a04 	addi	r2,r2,40
811373c8:	10800017 	ldw	r2,0(r2)
811373cc:	113fff84 	addi	r4,r2,-2
811373d0:	00a04574 	movhi	r2,33045
811373d4:	1094b704 	addi	r2,r2,21212
811373d8:	10800383 	ldbu	r2,14(r2)
811373dc:	10803fcc 	andi	r2,r2,255
811373e0:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
811373e4:	1885883a 	add	r2,r3,r2
811373e8:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
811373ec:	e0bffe17 	ldw	r2,-8(fp)
811373f0:	d0e09517 	ldw	r3,-32172(gp)
811373f4:	180b883a 	mov	r5,r3
811373f8:	1009883a 	mov	r4,r2
811373fc:	11331d00 	call	811331d0 <Read_Sector_Data>
81137400:	10001426 	beq	r2,zero,81137454 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
81137404:	e0ffff0f 	ldh	r3,-4(fp)
81137408:	00a04574 	movhi	r2,33045
8113740c:	1094cc04 	addi	r2,r2,21296
81137410:	180691ba 	slli	r3,r3,6
81137414:	10c5883a 	add	r2,r2,r3
81137418:	10800c04 	addi	r2,r2,48
8113741c:	1080000b 	ldhu	r2,0(r2)
81137420:	113fffcc 	andi	r4,r2,65535
81137424:	2120001c 	xori	r4,r4,32768
81137428:	21200004 	addi	r4,r4,-32768
8113742c:	e0bfff0f 	ldh	r2,-4(fp)
81137430:	100691ba 	slli	r3,r2,6
81137434:	00a04574 	movhi	r2,33045
81137438:	1094cc04 	addi	r2,r2,21296
8113743c:	1885883a 	add	r2,r3,r2
81137440:	100b883a 	mov	r5,r2
81137444:	11338840 	call	81133884 <Write_File_Record_At_Offset>
81137448:	10000226 	beq	r2,zero,81137454 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
8113744c:	113317c0 	call	8113317c <Save_Modified_Sector>
81137450:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
81137454:	e0ffff0f 	ldh	r3,-4(fp)
81137458:	00a04574 	movhi	r2,33045
8113745c:	1094cc04 	addi	r2,r2,21296
81137460:	180691ba 	slli	r3,r3,6
81137464:	10c5883a 	add	r2,r2,r3
81137468:	10800f04 	addi	r2,r2,60
8113746c:	10000015 	stw	zero,0(r2)
			result = true;
81137470:	00800044 	movi	r2,1
81137474:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
81137478:	e0bffd17 	ldw	r2,-12(fp)
}
8113747c:	e037883a 	mov	sp,fp
81137480:	dfc00117 	ldw	ra,4(sp)
81137484:	df000017 	ldw	fp,0(sp)
81137488:	dec00204 	addi	sp,sp,8
8113748c:	f800283a 	ret

81137490 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81137490:	defffa04 	addi	sp,sp,-24
81137494:	de00012e 	bgeu	sp,et,8113749c <altera_avalon_jtag_uart_read_fd+0xc>
81137498:	003b68fa 	trap	3
8113749c:	dfc00515 	stw	ra,20(sp)
811374a0:	df000415 	stw	fp,16(sp)
811374a4:	df000404 	addi	fp,sp,16
811374a8:	e13ffd15 	stw	r4,-12(fp)
811374ac:	e17ffe15 	stw	r5,-8(fp)
811374b0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811374b4:	e0bffd17 	ldw	r2,-12(fp)
811374b8:	10800017 	ldw	r2,0(r2)
811374bc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
811374c0:	e0bffc17 	ldw	r2,-16(fp)
811374c4:	10c00a04 	addi	r3,r2,40
811374c8:	e0bffd17 	ldw	r2,-12(fp)
811374cc:	10800217 	ldw	r2,8(r2)
811374d0:	100f883a 	mov	r7,r2
811374d4:	e1bfff17 	ldw	r6,-4(fp)
811374d8:	e17ffe17 	ldw	r5,-8(fp)
811374dc:	1809883a 	mov	r4,r3
811374e0:	1137c840 	call	81137c84 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
811374e4:	e037883a 	mov	sp,fp
811374e8:	dfc00117 	ldw	ra,4(sp)
811374ec:	df000017 	ldw	fp,0(sp)
811374f0:	dec00204 	addi	sp,sp,8
811374f4:	f800283a 	ret

811374f8 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
811374f8:	defffa04 	addi	sp,sp,-24
811374fc:	de00012e 	bgeu	sp,et,81137504 <altera_avalon_jtag_uart_write_fd+0xc>
81137500:	003b68fa 	trap	3
81137504:	dfc00515 	stw	ra,20(sp)
81137508:	df000415 	stw	fp,16(sp)
8113750c:	df000404 	addi	fp,sp,16
81137510:	e13ffd15 	stw	r4,-12(fp)
81137514:	e17ffe15 	stw	r5,-8(fp)
81137518:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113751c:	e0bffd17 	ldw	r2,-12(fp)
81137520:	10800017 	ldw	r2,0(r2)
81137524:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
81137528:	e0bffc17 	ldw	r2,-16(fp)
8113752c:	10c00a04 	addi	r3,r2,40
81137530:	e0bffd17 	ldw	r2,-12(fp)
81137534:	10800217 	ldw	r2,8(r2)
81137538:	100f883a 	mov	r7,r2
8113753c:	e1bfff17 	ldw	r6,-4(fp)
81137540:	e17ffe17 	ldw	r5,-8(fp)
81137544:	1809883a 	mov	r4,r3
81137548:	1137f480 	call	81137f48 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
8113754c:	e037883a 	mov	sp,fp
81137550:	dfc00117 	ldw	ra,4(sp)
81137554:	df000017 	ldw	fp,0(sp)
81137558:	dec00204 	addi	sp,sp,8
8113755c:	f800283a 	ret

81137560 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
81137560:	defffc04 	addi	sp,sp,-16
81137564:	de00012e 	bgeu	sp,et,8113756c <altera_avalon_jtag_uart_close_fd+0xc>
81137568:	003b68fa 	trap	3
8113756c:	dfc00315 	stw	ra,12(sp)
81137570:	df000215 	stw	fp,8(sp)
81137574:	df000204 	addi	fp,sp,8
81137578:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113757c:	e0bfff17 	ldw	r2,-4(fp)
81137580:	10800017 	ldw	r2,0(r2)
81137584:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
81137588:	e0bffe17 	ldw	r2,-8(fp)
8113758c:	10c00a04 	addi	r3,r2,40
81137590:	e0bfff17 	ldw	r2,-4(fp)
81137594:	10800217 	ldw	r2,8(r2)
81137598:	100b883a 	mov	r5,r2
8113759c:	1809883a 	mov	r4,r3
811375a0:	1137b1c0 	call	81137b1c <altera_avalon_jtag_uart_close>
}
811375a4:	e037883a 	mov	sp,fp
811375a8:	dfc00117 	ldw	ra,4(sp)
811375ac:	df000017 	ldw	fp,0(sp)
811375b0:	dec00204 	addi	sp,sp,8
811375b4:	f800283a 	ret

811375b8 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
811375b8:	defffa04 	addi	sp,sp,-24
811375bc:	de00012e 	bgeu	sp,et,811375c4 <altera_avalon_jtag_uart_ioctl_fd+0xc>
811375c0:	003b68fa 	trap	3
811375c4:	dfc00515 	stw	ra,20(sp)
811375c8:	df000415 	stw	fp,16(sp)
811375cc:	df000404 	addi	fp,sp,16
811375d0:	e13ffd15 	stw	r4,-12(fp)
811375d4:	e17ffe15 	stw	r5,-8(fp)
811375d8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
811375dc:	e0bffd17 	ldw	r2,-12(fp)
811375e0:	10800017 	ldw	r2,0(r2)
811375e4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
811375e8:	e0bffc17 	ldw	r2,-16(fp)
811375ec:	10800a04 	addi	r2,r2,40
811375f0:	e1bfff17 	ldw	r6,-4(fp)
811375f4:	e17ffe17 	ldw	r5,-8(fp)
811375f8:	1009883a 	mov	r4,r2
811375fc:	1137b8c0 	call	81137b8c <altera_avalon_jtag_uart_ioctl>
}
81137600:	e037883a 	mov	sp,fp
81137604:	dfc00117 	ldw	ra,4(sp)
81137608:	df000017 	ldw	fp,0(sp)
8113760c:	dec00204 	addi	sp,sp,8
81137610:	f800283a 	ret

81137614 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
81137614:	defff104 	addi	sp,sp,-60
81137618:	de00012e 	bgeu	sp,et,81137620 <altera_avalon_jtag_uart_init+0xc>
8113761c:	003b68fa 	trap	3
81137620:	dfc00e15 	stw	ra,56(sp)
81137624:	df000d15 	stw	fp,52(sp)
81137628:	df000d04 	addi	fp,sp,52
8113762c:	e13ff915 	stw	r4,-28(fp)
81137630:	e17ffa15 	stw	r5,-24(fp)
81137634:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
81137638:	e0bff917 	ldw	r2,-28(fp)
8113763c:	10800c04 	addi	r2,r2,48
81137640:	e0bff415 	stw	r2,-48(fp)
81137644:	e03ff80d 	sth	zero,-32(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81137648:	e0bff80b 	ldhu	r2,-32(fp)
8113764c:	e0fff884 	addi	r3,fp,-30
81137650:	180b883a 	mov	r5,r3
81137654:	1009883a 	mov	r4,r2
81137658:	112b7e40 	call	8112b7e4 <OSFlagCreate>
8113765c:	1007883a 	mov	r3,r2
81137660:	e0bff417 	ldw	r2,-48(fp)
81137664:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
81137668:	e0bff917 	ldw	r2,-28(fp)
8113766c:	10800a04 	addi	r2,r2,40
81137670:	e0bff515 	stw	r2,-44(fp)
81137674:	00800044 	movi	r2,1
81137678:	e0bff78d 	sth	r2,-34(fp)
8113767c:	e0bff78b 	ldhu	r2,-34(fp)
81137680:	1009883a 	mov	r4,r2
81137684:	112f7400 	call	8112f740 <OSSemCreate>
81137688:	1007883a 	mov	r3,r2
8113768c:	e0bff517 	ldw	r2,-44(fp)
81137690:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
81137694:	e0bff917 	ldw	r2,-28(fp)
81137698:	10800b04 	addi	r2,r2,44
8113769c:	e0bff615 	stw	r2,-40(fp)
811376a0:	00800044 	movi	r2,1
811376a4:	e0bff70d 	sth	r2,-36(fp)
811376a8:	e0bff70b 	ldhu	r2,-36(fp)
811376ac:	1009883a 	mov	r4,r2
811376b0:	112f7400 	call	8112f740 <OSSemCreate>
811376b4:	1007883a 	mov	r3,r2
811376b8:	e0bff617 	ldw	r2,-40(fp)
811376bc:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811376c0:	e0bff917 	ldw	r2,-28(fp)
811376c4:	00c00044 	movi	r3,1
811376c8:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
811376cc:	e0bff917 	ldw	r2,-28(fp)
811376d0:	10800017 	ldw	r2,0(r2)
811376d4:	10800104 	addi	r2,r2,4
811376d8:	1007883a 	mov	r3,r2
811376dc:	e0bff917 	ldw	r2,-28(fp)
811376e0:	10800817 	ldw	r2,32(r2)
811376e4:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
811376e8:	e0bffa17 	ldw	r2,-24(fp)
811376ec:	e0fffb17 	ldw	r3,-20(fp)
811376f0:	d8000015 	stw	zero,0(sp)
811376f4:	e1fff917 	ldw	r7,-28(fp)
811376f8:	01a044f4 	movhi	r6,33043
811376fc:	319dd904 	addi	r6,r6,30564
81137700:	180b883a 	mov	r5,r3
81137704:	1009883a 	mov	r4,r2
81137708:	113b5680 	call	8113b568 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
8113770c:	e0bff917 	ldw	r2,-28(fp)
81137710:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
81137714:	e0bff917 	ldw	r2,-28(fp)
81137718:	10800204 	addi	r2,r2,8
8113771c:	d0e06c17 	ldw	r3,-32336(gp)
81137720:	e1fff917 	ldw	r7,-28(fp)
81137724:	01a044f4 	movhi	r6,33043
81137728:	319e8404 	addi	r6,r6,31248
8113772c:	180b883a 	mov	r5,r3
81137730:	1009883a 	mov	r4,r2
81137734:	113afe80 	call	8113afe8 <alt_alarm_start>
81137738:	1000040e 	bge	r2,zero,8113774c <altera_avalon_jtag_uart_init+0x138>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
8113773c:	e0fff917 	ldw	r3,-28(fp)
81137740:	00a00034 	movhi	r2,32768
81137744:	10bfffc4 	addi	r2,r2,-1
81137748:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
8113774c:	0001883a 	nop
81137750:	e037883a 	mov	sp,fp
81137754:	dfc00117 	ldw	ra,4(sp)
81137758:	df000017 	ldw	fp,0(sp)
8113775c:	dec00204 	addi	sp,sp,8
81137760:	f800283a 	ret

81137764 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81137764:	defff204 	addi	sp,sp,-56
81137768:	de00012e 	bgeu	sp,et,81137770 <altera_avalon_jtag_uart_irq+0xc>
8113776c:	003b68fa 	trap	3
81137770:	dfc00d15 	stw	ra,52(sp)
81137774:	df000c15 	stw	fp,48(sp)
81137778:	df000c04 	addi	fp,sp,48
8113777c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
81137780:	e0bfff17 	ldw	r2,-4(fp)
81137784:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81137788:	e0bff617 	ldw	r2,-40(fp)
8113778c:	10800017 	ldw	r2,0(r2)
81137790:	e0bff715 	stw	r2,-36(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81137794:	e0bff717 	ldw	r2,-36(fp)
81137798:	10800104 	addi	r2,r2,4
8113779c:	10800037 	ldwio	r2,0(r2)
811377a0:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
811377a4:	e0bff817 	ldw	r2,-32(fp)
811377a8:	1080c00c 	andi	r2,r2,768
811377ac:	10009126 	beq	r2,zero,811379f4 <altera_avalon_jtag_uart_irq+0x290>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
811377b0:	e0bff817 	ldw	r2,-32(fp)
811377b4:	1080400c 	andi	r2,r2,256
811377b8:	10004726 	beq	r2,zero,811378d8 <altera_avalon_jtag_uart_irq+0x174>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
811377bc:	00800074 	movhi	r2,1
811377c0:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811377c4:	e0bff617 	ldw	r2,-40(fp)
811377c8:	10800d17 	ldw	r2,52(r2)
811377cc:	10800044 	addi	r2,r2,1
811377d0:	1081ffcc 	andi	r2,r2,2047
811377d4:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
811377d8:	e0bff617 	ldw	r2,-40(fp)
811377dc:	10c00e17 	ldw	r3,56(r2)
811377e0:	e0bff917 	ldw	r2,-28(fp)
811377e4:	18802726 	beq	r3,r2,81137884 <altera_avalon_jtag_uart_irq+0x120>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
811377e8:	e0bff717 	ldw	r2,-36(fp)
811377ec:	10800037 	ldwio	r2,0(r2)
811377f0:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
811377f4:	e0bff417 	ldw	r2,-48(fp)
811377f8:	10a0000c 	andi	r2,r2,32768
811377fc:	10002326 	beq	r2,zero,8113788c <altera_avalon_jtag_uart_irq+0x128>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
81137800:	e0bff617 	ldw	r2,-40(fp)
81137804:	10800d17 	ldw	r2,52(r2)
81137808:	e0fff417 	ldw	r3,-48(fp)
8113780c:	1809883a 	mov	r4,r3
81137810:	e0fff617 	ldw	r3,-40(fp)
81137814:	1885883a 	add	r2,r3,r2
81137818:	10801104 	addi	r2,r2,68
8113781c:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81137820:	e0bff617 	ldw	r2,-40(fp)
81137824:	10800d17 	ldw	r2,52(r2)
81137828:	10800044 	addi	r2,r2,1
8113782c:	10c1ffcc 	andi	r3,r2,2047
81137830:	e0bff617 	ldw	r2,-40(fp)
81137834:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81137838:	e0bff617 	ldw	r2,-40(fp)
8113783c:	10800c17 	ldw	r2,48(r2)
81137840:	e0bffb15 	stw	r2,-20(fp)
81137844:	00800044 	movi	r2,1
81137848:	e0bffc0d 	sth	r2,-16(fp)
8113784c:	00800044 	movi	r2,1
81137850:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81137854:	d0a07503 	ldbu	r2,-32300(gp)
81137858:	10803fcc 	andi	r2,r2,255
8113785c:	103fd926 	beq	r2,zero,811377c4 <__reset+0xfb1177c4>
  {
    OSFlagPost (group, flags, opt, &err);
81137860:	e0bffc0b 	ldhu	r2,-16(fp)
81137864:	e0fffc83 	ldbu	r3,-14(fp)
81137868:	e13ffdc4 	addi	r4,fp,-9
8113786c:	200f883a 	mov	r7,r4
81137870:	180d883a 	mov	r6,r3
81137874:	100b883a 	mov	r5,r2
81137878:	e13ffb17 	ldw	r4,-20(fp)
8113787c:	112c3f00 	call	8112c3f0 <OSFlagPost>
      }
81137880:	003fd006 	br	811377c4 <__reset+0xfb1177c4>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
81137884:	0001883a 	nop
81137888:	00000106 	br	81137890 <altera_avalon_jtag_uart_irq+0x12c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
8113788c:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
81137890:	e0bff417 	ldw	r2,-48(fp)
81137894:	10bfffec 	andhi	r2,r2,65535
81137898:	10000f26 	beq	r2,zero,811378d8 <altera_avalon_jtag_uart_irq+0x174>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8113789c:	e0bff617 	ldw	r2,-40(fp)
811378a0:	10c00817 	ldw	r3,32(r2)
811378a4:	00bfff84 	movi	r2,-2
811378a8:	1886703a 	and	r3,r3,r2
811378ac:	e0bff617 	ldw	r2,-40(fp)
811378b0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
811378b4:	e0bff717 	ldw	r2,-36(fp)
811378b8:	10800104 	addi	r2,r2,4
811378bc:	1007883a 	mov	r3,r2
811378c0:	e0bff617 	ldw	r2,-40(fp)
811378c4:	10800817 	ldw	r2,32(r2)
811378c8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811378cc:	e0bff717 	ldw	r2,-36(fp)
811378d0:	10800104 	addi	r2,r2,4
811378d4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
811378d8:	e0bff817 	ldw	r2,-32(fp)
811378dc:	1080800c 	andi	r2,r2,512
811378e0:	103fac26 	beq	r2,zero,81137794 <__reset+0xfb117794>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
811378e4:	e0bff817 	ldw	r2,-32(fp)
811378e8:	1004d43a 	srli	r2,r2,16
811378ec:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
811378f0:	00002606 	br	8113798c <altera_avalon_jtag_uart_irq+0x228>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
811378f4:	e0bff717 	ldw	r2,-36(fp)
811378f8:	e0fff617 	ldw	r3,-40(fp)
811378fc:	18c01017 	ldw	r3,64(r3)
81137900:	e13ff617 	ldw	r4,-40(fp)
81137904:	20c7883a 	add	r3,r4,r3
81137908:	18c21104 	addi	r3,r3,2116
8113790c:	18c00003 	ldbu	r3,0(r3)
81137910:	18c03fcc 	andi	r3,r3,255
81137914:	18c0201c 	xori	r3,r3,128
81137918:	18ffe004 	addi	r3,r3,-128
8113791c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81137920:	e0bff617 	ldw	r2,-40(fp)
81137924:	10801017 	ldw	r2,64(r2)
81137928:	10800044 	addi	r2,r2,1
8113792c:	10c1ffcc 	andi	r3,r2,2047
81137930:	e0bff617 	ldw	r2,-40(fp)
81137934:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81137938:	e0bff617 	ldw	r2,-40(fp)
8113793c:	10800c17 	ldw	r2,48(r2)
81137940:	e0bffa15 	stw	r2,-24(fp)
81137944:	00800084 	movi	r2,2
81137948:	e0bffd0d 	sth	r2,-12(fp)
8113794c:	00800044 	movi	r2,1
81137950:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81137954:	d0a07503 	ldbu	r2,-32300(gp)
81137958:	10803fcc 	andi	r2,r2,255
8113795c:	10000826 	beq	r2,zero,81137980 <altera_avalon_jtag_uart_irq+0x21c>
  {
    OSFlagPost (group, flags, opt, &err);
81137960:	e0bffd0b 	ldhu	r2,-12(fp)
81137964:	e0fffd83 	ldbu	r3,-10(fp)
81137968:	e13ffe04 	addi	r4,fp,-8
8113796c:	200f883a 	mov	r7,r4
81137970:	180d883a 	mov	r6,r3
81137974:	100b883a 	mov	r5,r2
81137978:	e13ffa17 	ldw	r4,-24(fp)
8113797c:	112c3f00 	call	8112c3f0 <OSFlagPost>

        space--;
81137980:	e0bff517 	ldw	r2,-44(fp)
81137984:	10bfffc4 	addi	r2,r2,-1
81137988:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
8113798c:	e0bff517 	ldw	r2,-44(fp)
81137990:	10000526 	beq	r2,zero,811379a8 <altera_avalon_jtag_uart_irq+0x244>
81137994:	e0bff617 	ldw	r2,-40(fp)
81137998:	10c01017 	ldw	r3,64(r2)
8113799c:	e0bff617 	ldw	r2,-40(fp)
811379a0:	10800f17 	ldw	r2,60(r2)
811379a4:	18bfd31e 	bne	r3,r2,811378f4 <__reset+0xfb1178f4>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
811379a8:	e0bff517 	ldw	r2,-44(fp)
811379ac:	103f7926 	beq	r2,zero,81137794 <__reset+0xfb117794>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811379b0:	e0bff617 	ldw	r2,-40(fp)
811379b4:	10c00817 	ldw	r3,32(r2)
811379b8:	00bfff44 	movi	r2,-3
811379bc:	1886703a 	and	r3,r3,r2
811379c0:	e0bff617 	ldw	r2,-40(fp)
811379c4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811379c8:	e0bff617 	ldw	r2,-40(fp)
811379cc:	10800017 	ldw	r2,0(r2)
811379d0:	10800104 	addi	r2,r2,4
811379d4:	1007883a 	mov	r3,r2
811379d8:	e0bff617 	ldw	r2,-40(fp)
811379dc:	10800817 	ldw	r2,32(r2)
811379e0:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811379e4:	e0bff717 	ldw	r2,-36(fp)
811379e8:	10800104 	addi	r2,r2,4
811379ec:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
811379f0:	003f6806 	br	81137794 <__reset+0xfb117794>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
811379f4:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
811379f8:	0001883a 	nop
811379fc:	e037883a 	mov	sp,fp
81137a00:	dfc00117 	ldw	ra,4(sp)
81137a04:	df000017 	ldw	fp,0(sp)
81137a08:	dec00204 	addi	sp,sp,8
81137a0c:	f800283a 	ret

81137a10 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81137a10:	defff904 	addi	sp,sp,-28
81137a14:	de00012e 	bgeu	sp,et,81137a1c <altera_avalon_jtag_uart_timeout+0xc>
81137a18:	003b68fa 	trap	3
81137a1c:	dfc00615 	stw	ra,24(sp)
81137a20:	df000515 	stw	fp,20(sp)
81137a24:	df000504 	addi	fp,sp,20
81137a28:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81137a2c:	e0bfff17 	ldw	r2,-4(fp)
81137a30:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81137a34:	e0bffb17 	ldw	r2,-20(fp)
81137a38:	10800017 	ldw	r2,0(r2)
81137a3c:	10800104 	addi	r2,r2,4
81137a40:	10800037 	ldwio	r2,0(r2)
81137a44:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81137a48:	e0bffc17 	ldw	r2,-16(fp)
81137a4c:	1081000c 	andi	r2,r2,1024
81137a50:	10000b26 	beq	r2,zero,81137a80 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81137a54:	e0bffb17 	ldw	r2,-20(fp)
81137a58:	10800017 	ldw	r2,0(r2)
81137a5c:	10800104 	addi	r2,r2,4
81137a60:	1007883a 	mov	r3,r2
81137a64:	e0bffb17 	ldw	r2,-20(fp)
81137a68:	10800817 	ldw	r2,32(r2)
81137a6c:	10810014 	ori	r2,r2,1024
81137a70:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81137a74:	e0bffb17 	ldw	r2,-20(fp)
81137a78:	10000915 	stw	zero,36(r2)
81137a7c:	00002106 	br	81137b04 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81137a80:	e0bffb17 	ldw	r2,-20(fp)
81137a84:	10c00917 	ldw	r3,36(r2)
81137a88:	00a00034 	movhi	r2,32768
81137a8c:	10bfff04 	addi	r2,r2,-4
81137a90:	10c01c36 	bltu	r2,r3,81137b04 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81137a94:	e0bffb17 	ldw	r2,-20(fp)
81137a98:	10800917 	ldw	r2,36(r2)
81137a9c:	10c00044 	addi	r3,r2,1
81137aa0:	e0bffb17 	ldw	r2,-20(fp)
81137aa4:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81137aa8:	e0bffb17 	ldw	r2,-20(fp)
81137aac:	10c00917 	ldw	r3,36(r2)
81137ab0:	e0bffb17 	ldw	r2,-20(fp)
81137ab4:	10800117 	ldw	r2,4(r2)
81137ab8:	18801236 	bltu	r3,r2,81137b04 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81137abc:	e0bffb17 	ldw	r2,-20(fp)
81137ac0:	10800c17 	ldw	r2,48(r2)
81137ac4:	e0bffd15 	stw	r2,-12(fp)
81137ac8:	00800104 	movi	r2,4
81137acc:	e0bffe0d 	sth	r2,-8(fp)
81137ad0:	00800044 	movi	r2,1
81137ad4:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81137ad8:	d0a07503 	ldbu	r2,-32300(gp)
81137adc:	10803fcc 	andi	r2,r2,255
81137ae0:	10000826 	beq	r2,zero,81137b04 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81137ae4:	e0bffe0b 	ldhu	r2,-8(fp)
81137ae8:	e0fffe83 	ldbu	r3,-6(fp)
81137aec:	e13ffec4 	addi	r4,fp,-5
81137af0:	200f883a 	mov	r7,r4
81137af4:	180d883a 	mov	r6,r3
81137af8:	100b883a 	mov	r5,r2
81137afc:	e13ffd17 	ldw	r4,-12(fp)
81137b00:	112c3f00 	call	8112c3f0 <OSFlagPost>
81137b04:	d0a06c17 	ldw	r2,-32336(gp)
    }
  }

  return alt_ticks_per_second();
}
81137b08:	e037883a 	mov	sp,fp
81137b0c:	dfc00117 	ldw	ra,4(sp)
81137b10:	df000017 	ldw	fp,0(sp)
81137b14:	dec00204 	addi	sp,sp,8
81137b18:	f800283a 	ret

81137b1c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81137b1c:	defffd04 	addi	sp,sp,-12
81137b20:	de00012e 	bgeu	sp,et,81137b28 <altera_avalon_jtag_uart_close+0xc>
81137b24:	003b68fa 	trap	3
81137b28:	df000215 	stw	fp,8(sp)
81137b2c:	df000204 	addi	fp,sp,8
81137b30:	e13ffe15 	stw	r4,-8(fp)
81137b34:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81137b38:	00000506 	br	81137b50 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81137b3c:	e0bfff17 	ldw	r2,-4(fp)
81137b40:	1090000c 	andi	r2,r2,16384
81137b44:	10000226 	beq	r2,zero,81137b50 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81137b48:	00bffd44 	movi	r2,-11
81137b4c:	00000b06 	br	81137b7c <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81137b50:	e0bffe17 	ldw	r2,-8(fp)
81137b54:	10c01017 	ldw	r3,64(r2)
81137b58:	e0bffe17 	ldw	r2,-8(fp)
81137b5c:	10800f17 	ldw	r2,60(r2)
81137b60:	18800526 	beq	r3,r2,81137b78 <altera_avalon_jtag_uart_close+0x5c>
81137b64:	e0bffe17 	ldw	r2,-8(fp)
81137b68:	10c00917 	ldw	r3,36(r2)
81137b6c:	e0bffe17 	ldw	r2,-8(fp)
81137b70:	10800117 	ldw	r2,4(r2)
81137b74:	18bff136 	bltu	r3,r2,81137b3c <__reset+0xfb117b3c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81137b78:	0005883a 	mov	r2,zero
}
81137b7c:	e037883a 	mov	sp,fp
81137b80:	df000017 	ldw	fp,0(sp)
81137b84:	dec00104 	addi	sp,sp,4
81137b88:	f800283a 	ret

81137b8c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81137b8c:	defffa04 	addi	sp,sp,-24
81137b90:	de00012e 	bgeu	sp,et,81137b98 <altera_avalon_jtag_uart_ioctl+0xc>
81137b94:	003b68fa 	trap	3
81137b98:	df000515 	stw	fp,20(sp)
81137b9c:	df000504 	addi	fp,sp,20
81137ba0:	e13ffd15 	stw	r4,-12(fp)
81137ba4:	e17ffe15 	stw	r5,-8(fp)
81137ba8:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81137bac:	00bff9c4 	movi	r2,-25
81137bb0:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81137bb4:	e0bffe17 	ldw	r2,-8(fp)
81137bb8:	10da8060 	cmpeqi	r3,r2,27137
81137bbc:	1800031e 	bne	r3,zero,81137bcc <altera_avalon_jtag_uart_ioctl+0x40>
81137bc0:	109a80a0 	cmpeqi	r2,r2,27138
81137bc4:	1000181e 	bne	r2,zero,81137c28 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81137bc8:	00002906 	br	81137c70 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81137bcc:	e0bffd17 	ldw	r2,-12(fp)
81137bd0:	10c00117 	ldw	r3,4(r2)
81137bd4:	00a00034 	movhi	r2,32768
81137bd8:	10bfffc4 	addi	r2,r2,-1
81137bdc:	18802126 	beq	r3,r2,81137c64 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81137be0:	e0bfff17 	ldw	r2,-4(fp)
81137be4:	10800017 	ldw	r2,0(r2)
81137be8:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81137bec:	e0bffc17 	ldw	r2,-16(fp)
81137bf0:	10800090 	cmplti	r2,r2,2
81137bf4:	1000061e 	bne	r2,zero,81137c10 <altera_avalon_jtag_uart_ioctl+0x84>
81137bf8:	e0fffc17 	ldw	r3,-16(fp)
81137bfc:	00a00034 	movhi	r2,32768
81137c00:	10bfffc4 	addi	r2,r2,-1
81137c04:	18800226 	beq	r3,r2,81137c10 <altera_avalon_jtag_uart_ioctl+0x84>
81137c08:	e0bffc17 	ldw	r2,-16(fp)
81137c0c:	00000206 	br	81137c18 <altera_avalon_jtag_uart_ioctl+0x8c>
81137c10:	00a00034 	movhi	r2,32768
81137c14:	10bfff84 	addi	r2,r2,-2
81137c18:	e0fffd17 	ldw	r3,-12(fp)
81137c1c:	18800115 	stw	r2,4(r3)
      rc = 0;
81137c20:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81137c24:	00000f06 	br	81137c64 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81137c28:	e0bffd17 	ldw	r2,-12(fp)
81137c2c:	10c00117 	ldw	r3,4(r2)
81137c30:	00a00034 	movhi	r2,32768
81137c34:	10bfffc4 	addi	r2,r2,-1
81137c38:	18800c26 	beq	r3,r2,81137c6c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81137c3c:	e0bffd17 	ldw	r2,-12(fp)
81137c40:	10c00917 	ldw	r3,36(r2)
81137c44:	e0bffd17 	ldw	r2,-12(fp)
81137c48:	10800117 	ldw	r2,4(r2)
81137c4c:	1885803a 	cmpltu	r2,r3,r2
81137c50:	10c03fcc 	andi	r3,r2,255
81137c54:	e0bfff17 	ldw	r2,-4(fp)
81137c58:	10c00015 	stw	r3,0(r2)
      rc = 0;
81137c5c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81137c60:	00000206 	br	81137c6c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81137c64:	0001883a 	nop
81137c68:	00000106 	br	81137c70 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81137c6c:	0001883a 	nop

  default:
    break;
  }

  return rc;
81137c70:	e0bffb17 	ldw	r2,-20(fp)
}
81137c74:	e037883a 	mov	sp,fp
81137c78:	df000017 	ldw	fp,0(sp)
81137c7c:	dec00104 	addi	sp,sp,4
81137c80:	f800283a 	ret

81137c84 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81137c84:	deffed04 	addi	sp,sp,-76
81137c88:	de00012e 	bgeu	sp,et,81137c90 <altera_avalon_jtag_uart_read+0xc>
81137c8c:	003b68fa 	trap	3
81137c90:	dfc01215 	stw	ra,72(sp)
81137c94:	df001115 	stw	fp,68(sp)
81137c98:	df001104 	addi	fp,sp,68
81137c9c:	e13ffc15 	stw	r4,-16(fp)
81137ca0:	e17ffd15 	stw	r5,-12(fp)
81137ca4:	e1bffe15 	stw	r6,-8(fp)
81137ca8:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81137cac:	e0bffd17 	ldw	r2,-12(fp)
81137cb0:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81137cb4:	e0bffc17 	ldw	r2,-16(fp)
81137cb8:	10800a17 	ldw	r2,40(r2)
81137cbc:	e0bff815 	stw	r2,-32(fp)
81137cc0:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81137cc4:	e0bff90b 	ldhu	r2,-28(fp)
81137cc8:	e0fffb04 	addi	r3,fp,-20
81137ccc:	180d883a 	mov	r6,r3
81137cd0:	100b883a 	mov	r5,r2
81137cd4:	e13ff817 	ldw	r4,-32(fp)
81137cd8:	112fa680 	call	8112fa68 <OSSemPend>

  while (space > 0)
81137cdc:	00006106 	br	81137e64 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81137ce0:	e0bffc17 	ldw	r2,-16(fp)
81137ce4:	10800d17 	ldw	r2,52(r2)
81137ce8:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81137cec:	e0bffc17 	ldw	r2,-16(fp)
81137cf0:	10800e17 	ldw	r2,56(r2)
81137cf4:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81137cf8:	e0fff317 	ldw	r3,-52(fp)
81137cfc:	e0bff417 	ldw	r2,-48(fp)
81137d00:	18800536 	bltu	r3,r2,81137d18 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81137d04:	e0fff317 	ldw	r3,-52(fp)
81137d08:	e0bff417 	ldw	r2,-48(fp)
81137d0c:	1885c83a 	sub	r2,r3,r2
81137d10:	e0bff115 	stw	r2,-60(fp)
81137d14:	00000406 	br	81137d28 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81137d18:	00c20004 	movi	r3,2048
81137d1c:	e0bff417 	ldw	r2,-48(fp)
81137d20:	1885c83a 	sub	r2,r3,r2
81137d24:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81137d28:	e0bff117 	ldw	r2,-60(fp)
81137d2c:	10001e26 	beq	r2,zero,81137da8 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81137d30:	e0fffe17 	ldw	r3,-8(fp)
81137d34:	e0bff117 	ldw	r2,-60(fp)
81137d38:	1880022e 	bgeu	r3,r2,81137d44 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81137d3c:	e0bffe17 	ldw	r2,-8(fp)
81137d40:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81137d44:	e0bffc17 	ldw	r2,-16(fp)
81137d48:	10c01104 	addi	r3,r2,68
81137d4c:	e0bff417 	ldw	r2,-48(fp)
81137d50:	1885883a 	add	r2,r3,r2
81137d54:	e1bff117 	ldw	r6,-60(fp)
81137d58:	100b883a 	mov	r5,r2
81137d5c:	e13ff017 	ldw	r4,-64(fp)
81137d60:	11136e00 	call	811136e0 <memcpy>
      ptr   += n;
81137d64:	e0fff017 	ldw	r3,-64(fp)
81137d68:	e0bff117 	ldw	r2,-60(fp)
81137d6c:	1885883a 	add	r2,r3,r2
81137d70:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81137d74:	e0fffe17 	ldw	r3,-8(fp)
81137d78:	e0bff117 	ldw	r2,-60(fp)
81137d7c:	1885c83a 	sub	r2,r3,r2
81137d80:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81137d84:	e0fff417 	ldw	r3,-48(fp)
81137d88:	e0bff117 	ldw	r2,-60(fp)
81137d8c:	1885883a 	add	r2,r3,r2
81137d90:	10c1ffcc 	andi	r3,r2,2047
81137d94:	e0bffc17 	ldw	r2,-16(fp)
81137d98:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81137d9c:	e0bffe17 	ldw	r2,-8(fp)
81137da0:	00bfcf16 	blt	zero,r2,81137ce0 <__reset+0xfb117ce0>
81137da4:	00000106 	br	81137dac <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81137da8:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81137dac:	e0fff017 	ldw	r3,-64(fp)
81137db0:	e0bffd17 	ldw	r2,-12(fp)
81137db4:	18802e1e 	bne	r3,r2,81137e70 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81137db8:	e0bfff17 	ldw	r2,-4(fp)
81137dbc:	1090000c 	andi	r2,r2,16384
81137dc0:	10002d1e 	bne	r2,zero,81137e78 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81137dc4:	d0a07503 	ldbu	r2,-32300(gp)
81137dc8:	10803fcc 	andi	r2,r2,255
81137dcc:	10800058 	cmpnei	r2,r2,1
81137dd0:	1000161e 	bne	r2,zero,81137e2c <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81137dd4:	e0bffc17 	ldw	r2,-16(fp)
81137dd8:	10800c17 	ldw	r2,48(r2)
81137ddc:	e0bff215 	stw	r2,-56(fp)
81137de0:	00800144 	movi	r2,5
81137de4:	e0bff98d 	sth	r2,-26(fp)
81137de8:	00bfe0c4 	movi	r2,-125
81137dec:	e0bffa05 	stb	r2,-24(fp)
81137df0:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81137df4:	d0a07503 	ldbu	r2,-32300(gp)
81137df8:	10803fcc 	andi	r2,r2,255
81137dfc:	10001526 	beq	r2,zero,81137e54 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81137e00:	e0fff98b 	ldhu	r3,-26(fp)
81137e04:	e13ffa03 	ldbu	r4,-24(fp)
81137e08:	e17ffa8b 	ldhu	r5,-22(fp)
81137e0c:	e0bffb44 	addi	r2,fp,-19
81137e10:	d8800015 	stw	r2,0(sp)
81137e14:	280f883a 	mov	r7,r5
81137e18:	200d883a 	mov	r6,r4
81137e1c:	180b883a 	mov	r5,r3
81137e20:	e13ff217 	ldw	r4,-56(fp)
81137e24:	112bdc80 	call	8112bdc8 <OSFlagPend>
81137e28:	00000a06 	br	81137e54 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81137e2c:	0001883a 	nop
81137e30:	e0bffc17 	ldw	r2,-16(fp)
81137e34:	10c00d17 	ldw	r3,52(r2)
81137e38:	e0bff317 	ldw	r2,-52(fp)
81137e3c:	1880051e 	bne	r3,r2,81137e54 <altera_avalon_jtag_uart_read+0x1d0>
81137e40:	e0bffc17 	ldw	r2,-16(fp)
81137e44:	10c00917 	ldw	r3,36(r2)
81137e48:	e0bffc17 	ldw	r2,-16(fp)
81137e4c:	10800117 	ldw	r2,4(r2)
81137e50:	18bff736 	bltu	r3,r2,81137e30 <__reset+0xfb117e30>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81137e54:	e0bffc17 	ldw	r2,-16(fp)
81137e58:	10c00d17 	ldw	r3,52(r2)
81137e5c:	e0bff317 	ldw	r2,-52(fp)
81137e60:	18800726 	beq	r3,r2,81137e80 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81137e64:	e0bffe17 	ldw	r2,-8(fp)
81137e68:	00bf9d16 	blt	zero,r2,81137ce0 <__reset+0xfb117ce0>
81137e6c:	00000506 	br	81137e84 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81137e70:	0001883a 	nop
81137e74:	00000306 	br	81137e84 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81137e78:	0001883a 	nop
81137e7c:	00000106 	br	81137e84 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81137e80:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81137e84:	e0bffc17 	ldw	r2,-16(fp)
81137e88:	10800a17 	ldw	r2,40(r2)
81137e8c:	1009883a 	mov	r4,r2
81137e90:	112fdf00 	call	8112fdf0 <OSSemPost>

  if (ptr != buffer)
81137e94:	e0fff017 	ldw	r3,-64(fp)
81137e98:	e0bffd17 	ldw	r2,-12(fp)
81137e9c:	18801826 	beq	r3,r2,81137f00 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137ea0:	0005303a 	rdctl	r2,status
81137ea4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137ea8:	e0fff717 	ldw	r3,-36(fp)
81137eac:	00bfff84 	movi	r2,-2
81137eb0:	1884703a 	and	r2,r3,r2
81137eb4:	1001703a 	wrctl	status,r2
  
  return context;
81137eb8:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81137ebc:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81137ec0:	e0bffc17 	ldw	r2,-16(fp)
81137ec4:	10800817 	ldw	r2,32(r2)
81137ec8:	10c00054 	ori	r3,r2,1
81137ecc:	e0bffc17 	ldw	r2,-16(fp)
81137ed0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81137ed4:	e0bffc17 	ldw	r2,-16(fp)
81137ed8:	10800017 	ldw	r2,0(r2)
81137edc:	10800104 	addi	r2,r2,4
81137ee0:	1007883a 	mov	r3,r2
81137ee4:	e0bffc17 	ldw	r2,-16(fp)
81137ee8:	10800817 	ldw	r2,32(r2)
81137eec:	18800035 	stwio	r2,0(r3)
81137ef0:	e0bff617 	ldw	r2,-40(fp)
81137ef4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137ef8:	e0bff517 	ldw	r2,-44(fp)
81137efc:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
81137f00:	e0fff017 	ldw	r3,-64(fp)
81137f04:	e0bffd17 	ldw	r2,-12(fp)
81137f08:	18800426 	beq	r3,r2,81137f1c <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81137f0c:	e0fff017 	ldw	r3,-64(fp)
81137f10:	e0bffd17 	ldw	r2,-12(fp)
81137f14:	1885c83a 	sub	r2,r3,r2
81137f18:	00000606 	br	81137f34 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81137f1c:	e0bfff17 	ldw	r2,-4(fp)
81137f20:	1090000c 	andi	r2,r2,16384
81137f24:	10000226 	beq	r2,zero,81137f30 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81137f28:	00bffd44 	movi	r2,-11
81137f2c:	00000106 	br	81137f34 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81137f30:	00bffec4 	movi	r2,-5
}
81137f34:	e037883a 	mov	sp,fp
81137f38:	dfc00117 	ldw	ra,4(sp)
81137f3c:	df000017 	ldw	fp,0(sp)
81137f40:	dec00204 	addi	sp,sp,8
81137f44:	f800283a 	ret

81137f48 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81137f48:	deffed04 	addi	sp,sp,-76
81137f4c:	de00012e 	bgeu	sp,et,81137f54 <altera_avalon_jtag_uart_write+0xc>
81137f50:	003b68fa 	trap	3
81137f54:	dfc01215 	stw	ra,72(sp)
81137f58:	df001115 	stw	fp,68(sp)
81137f5c:	df001104 	addi	fp,sp,68
81137f60:	e13ffc15 	stw	r4,-16(fp)
81137f64:	e17ffd15 	stw	r5,-12(fp)
81137f68:	e1bffe15 	stw	r6,-8(fp)
81137f6c:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
81137f70:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81137f74:	e0bffd17 	ldw	r2,-12(fp)
81137f78:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
81137f7c:	e0bffc17 	ldw	r2,-16(fp)
81137f80:	10800b17 	ldw	r2,44(r2)
81137f84:	e0bff815 	stw	r2,-32(fp)
81137f88:	e03ff90d 	sth	zero,-28(fp)
81137f8c:	e0bff90b 	ldhu	r2,-28(fp)
81137f90:	e0fffb44 	addi	r3,fp,-19
81137f94:	180d883a 	mov	r6,r3
81137f98:	100b883a 	mov	r5,r2
81137f9c:	e13ff817 	ldw	r4,-32(fp)
81137fa0:	112fa680 	call	8112fa68 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81137fa4:	00003706 	br	81138084 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
81137fa8:	e0bffc17 	ldw	r2,-16(fp)
81137fac:	10800f17 	ldw	r2,60(r2)
81137fb0:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
81137fb4:	e0bffc17 	ldw	r2,-16(fp)
81137fb8:	10801017 	ldw	r2,64(r2)
81137fbc:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
81137fc0:	e0fff417 	ldw	r3,-48(fp)
81137fc4:	e0bff017 	ldw	r2,-64(fp)
81137fc8:	1880062e 	bgeu	r3,r2,81137fe4 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
81137fcc:	e0fff017 	ldw	r3,-64(fp)
81137fd0:	e0bff417 	ldw	r2,-48(fp)
81137fd4:	1885c83a 	sub	r2,r3,r2
81137fd8:	10bfffc4 	addi	r2,r2,-1
81137fdc:	e0bff115 	stw	r2,-60(fp)
81137fe0:	00000b06 	br	81138010 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81137fe4:	e0bff017 	ldw	r2,-64(fp)
81137fe8:	10000526 	beq	r2,zero,81138000 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
81137fec:	00c20004 	movi	r3,2048
81137ff0:	e0bff417 	ldw	r2,-48(fp)
81137ff4:	1885c83a 	sub	r2,r3,r2
81137ff8:	e0bff115 	stw	r2,-60(fp)
81137ffc:	00000406 	br	81138010 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81138000:	00c1ffc4 	movi	r3,2047
81138004:	e0bff417 	ldw	r2,-48(fp)
81138008:	1885c83a 	sub	r2,r3,r2
8113800c:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81138010:	e0bff117 	ldw	r2,-60(fp)
81138014:	10001e26 	beq	r2,zero,81138090 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81138018:	e0fffe17 	ldw	r3,-8(fp)
8113801c:	e0bff117 	ldw	r2,-60(fp)
81138020:	1880022e 	bgeu	r3,r2,8113802c <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81138024:	e0bffe17 	ldw	r2,-8(fp)
81138028:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
8113802c:	e0bffc17 	ldw	r2,-16(fp)
81138030:	10c21104 	addi	r3,r2,2116
81138034:	e0bff417 	ldw	r2,-48(fp)
81138038:	1885883a 	add	r2,r3,r2
8113803c:	e1bff117 	ldw	r6,-60(fp)
81138040:	e17ffd17 	ldw	r5,-12(fp)
81138044:	1009883a 	mov	r4,r2
81138048:	11136e00 	call	811136e0 <memcpy>
      ptr   += n;
8113804c:	e0fffd17 	ldw	r3,-12(fp)
81138050:	e0bff117 	ldw	r2,-60(fp)
81138054:	1885883a 	add	r2,r3,r2
81138058:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
8113805c:	e0fffe17 	ldw	r3,-8(fp)
81138060:	e0bff117 	ldw	r2,-60(fp)
81138064:	1885c83a 	sub	r2,r3,r2
81138068:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113806c:	e0fff417 	ldw	r3,-48(fp)
81138070:	e0bff117 	ldw	r2,-60(fp)
81138074:	1885883a 	add	r2,r3,r2
81138078:	10c1ffcc 	andi	r3,r2,2047
8113807c:	e0bffc17 	ldw	r2,-16(fp)
81138080:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81138084:	e0bffe17 	ldw	r2,-8(fp)
81138088:	00bfc716 	blt	zero,r2,81137fa8 <__reset+0xfb117fa8>
8113808c:	00000106 	br	81138094 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
81138090:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138094:	0005303a 	rdctl	r2,status
81138098:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113809c:	e0fff717 	ldw	r3,-36(fp)
811380a0:	00bfff84 	movi	r2,-2
811380a4:	1884703a 	and	r2,r3,r2
811380a8:	1001703a 	wrctl	status,r2
  
  return context;
811380ac:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
811380b0:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811380b4:	e0bffc17 	ldw	r2,-16(fp)
811380b8:	10800817 	ldw	r2,32(r2)
811380bc:	10c00094 	ori	r3,r2,2
811380c0:	e0bffc17 	ldw	r2,-16(fp)
811380c4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811380c8:	e0bffc17 	ldw	r2,-16(fp)
811380cc:	10800017 	ldw	r2,0(r2)
811380d0:	10800104 	addi	r2,r2,4
811380d4:	1007883a 	mov	r3,r2
811380d8:	e0bffc17 	ldw	r2,-16(fp)
811380dc:	10800817 	ldw	r2,32(r2)
811380e0:	18800035 	stwio	r2,0(r3)
811380e4:	e0bff617 	ldw	r2,-40(fp)
811380e8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811380ec:	e0bff317 	ldw	r2,-52(fp)
811380f0:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
811380f4:	e0bffe17 	ldw	r2,-8(fp)
811380f8:	00802a0e 	bge	zero,r2,811381a4 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
811380fc:	e0bfff17 	ldw	r2,-4(fp)
81138100:	1090000c 	andi	r2,r2,16384
81138104:	10002a1e 	bne	r2,zero,811381b0 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81138108:	d0a07503 	ldbu	r2,-32300(gp)
8113810c:	10803fcc 	andi	r2,r2,255
81138110:	10800058 	cmpnei	r2,r2,1
81138114:	1000161e 	bne	r2,zero,81138170 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81138118:	e0bffc17 	ldw	r2,-16(fp)
8113811c:	10800c17 	ldw	r2,48(r2)
81138120:	e0bff515 	stw	r2,-44(fp)
81138124:	00800184 	movi	r2,6
81138128:	e0bff98d 	sth	r2,-26(fp)
8113812c:	00bfe0c4 	movi	r2,-125
81138130:	e0bffa05 	stb	r2,-24(fp)
81138134:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81138138:	d0a07503 	ldbu	r2,-32300(gp)
8113813c:	10803fcc 	andi	r2,r2,255
81138140:	10001526 	beq	r2,zero,81138198 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81138144:	e0fff98b 	ldhu	r3,-26(fp)
81138148:	e13ffa03 	ldbu	r4,-24(fp)
8113814c:	e17ffa8b 	ldhu	r5,-22(fp)
81138150:	e0bffb04 	addi	r2,fp,-20
81138154:	d8800015 	stw	r2,0(sp)
81138158:	280f883a 	mov	r7,r5
8113815c:	200d883a 	mov	r6,r4
81138160:	180b883a 	mov	r5,r3
81138164:	e13ff517 	ldw	r4,-44(fp)
81138168:	112bdc80 	call	8112bdc8 <OSFlagPend>
8113816c:	00000a06 	br	81138198 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
81138170:	0001883a 	nop
81138174:	e0bffc17 	ldw	r2,-16(fp)
81138178:	10c01017 	ldw	r3,64(r2)
8113817c:	e0bff017 	ldw	r2,-64(fp)
81138180:	1880051e 	bne	r3,r2,81138198 <altera_avalon_jtag_uart_write+0x250>
81138184:	e0bffc17 	ldw	r2,-16(fp)
81138188:	10c00917 	ldw	r3,36(r2)
8113818c:	e0bffc17 	ldw	r2,-16(fp)
81138190:	10800117 	ldw	r2,4(r2)
81138194:	18bff736 	bltu	r3,r2,81138174 <__reset+0xfb118174>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
81138198:	e0bffc17 	ldw	r2,-16(fp)
8113819c:	10800917 	ldw	r2,36(r2)
811381a0:	1000051e 	bne	r2,zero,811381b8 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
811381a4:	e0bffe17 	ldw	r2,-8(fp)
811381a8:	00bfb616 	blt	zero,r2,81138084 <__reset+0xfb118084>
811381ac:	00000306 	br	811381bc <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
811381b0:	0001883a 	nop
811381b4:	00000106 	br	811381bc <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
811381b8:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
811381bc:	e0bffc17 	ldw	r2,-16(fp)
811381c0:	10800b17 	ldw	r2,44(r2)
811381c4:	1009883a 	mov	r4,r2
811381c8:	112fdf00 	call	8112fdf0 <OSSemPost>

  if (ptr != start)
811381cc:	e0fffd17 	ldw	r3,-12(fp)
811381d0:	e0bff217 	ldw	r2,-56(fp)
811381d4:	18800426 	beq	r3,r2,811381e8 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
811381d8:	e0fffd17 	ldw	r3,-12(fp)
811381dc:	e0bff217 	ldw	r2,-56(fp)
811381e0:	1885c83a 	sub	r2,r3,r2
811381e4:	00000606 	br	81138200 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
811381e8:	e0bfff17 	ldw	r2,-4(fp)
811381ec:	1090000c 	andi	r2,r2,16384
811381f0:	10000226 	beq	r2,zero,811381fc <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
811381f4:	00bffd44 	movi	r2,-11
811381f8:	00000106 	br	81138200 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
811381fc:	00bffec4 	movi	r2,-5
}
81138200:	e037883a 	mov	sp,fp
81138204:	dfc00117 	ldw	ra,4(sp)
81138208:	df000017 	ldw	fp,0(sp)
8113820c:	dec00204 	addi	sp,sp,8
81138210:	f800283a 	ret

81138214 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81138214:	defffa04 	addi	sp,sp,-24
81138218:	de00012e 	bgeu	sp,et,81138220 <alt_avalon_timer_sc_irq+0xc>
8113821c:	003b68fa 	trap	3
81138220:	dfc00515 	stw	ra,20(sp)
81138224:	df000415 	stw	fp,16(sp)
81138228:	df000404 	addi	fp,sp,16
8113822c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
81138230:	0007883a 	mov	r3,zero
81138234:	e0bfff17 	ldw	r2,-4(fp)
81138238:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
8113823c:	e0bfff17 	ldw	r2,-4(fp)
81138240:	10800104 	addi	r2,r2,4
81138244:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138248:	0005303a 	rdctl	r2,status
8113824c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138250:	e0fffd17 	ldw	r3,-12(fp)
81138254:	00bfff84 	movi	r2,-2
81138258:	1884703a 	and	r2,r3,r2
8113825c:	1001703a 	wrctl	status,r2
  
  return context;
81138260:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
81138264:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81138268:	1128adc0 	call	81128adc <alt_tick>
8113826c:	e0bffc17 	ldw	r2,-16(fp)
81138270:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138274:	e0bffe17 	ldw	r2,-8(fp)
81138278:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
8113827c:	0001883a 	nop
81138280:	e037883a 	mov	sp,fp
81138284:	dfc00117 	ldw	ra,4(sp)
81138288:	df000017 	ldw	fp,0(sp)
8113828c:	dec00204 	addi	sp,sp,8
81138290:	f800283a 	ret

81138294 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
81138294:	defff804 	addi	sp,sp,-32
81138298:	de00012e 	bgeu	sp,et,811382a0 <alt_avalon_timer_sc_init+0xc>
8113829c:	003b68fa 	trap	3
811382a0:	dfc00715 	stw	ra,28(sp)
811382a4:	df000615 	stw	fp,24(sp)
811382a8:	df000604 	addi	fp,sp,24
811382ac:	e13ffc15 	stw	r4,-16(fp)
811382b0:	e17ffd15 	stw	r5,-12(fp)
811382b4:	e1bffe15 	stw	r6,-8(fp)
811382b8:	e1ffff15 	stw	r7,-4(fp)
811382bc:	e0bfff17 	ldw	r2,-4(fp)
811382c0:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
811382c4:	d0a06c17 	ldw	r2,-32336(gp)
811382c8:	1000021e 	bne	r2,zero,811382d4 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
811382cc:	e0bffb17 	ldw	r2,-20(fp)
811382d0:	d0a06c15 	stw	r2,-32336(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
811382d4:	e0bffc17 	ldw	r2,-16(fp)
811382d8:	10800104 	addi	r2,r2,4
811382dc:	00c001c4 	movi	r3,7
811382e0:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
811382e4:	d8000015 	stw	zero,0(sp)
811382e8:	e1fffc17 	ldw	r7,-16(fp)
811382ec:	01a04534 	movhi	r6,33044
811382f0:	31a08504 	addi	r6,r6,-32236
811382f4:	e17ffe17 	ldw	r5,-8(fp)
811382f8:	e13ffd17 	ldw	r4,-12(fp)
811382fc:	113b5680 	call	8113b568 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81138300:	0001883a 	nop
81138304:	e037883a 	mov	sp,fp
81138308:	dfc00117 	ldw	ra,4(sp)
8113830c:	df000017 	ldw	fp,0(sp)
81138310:	dec00204 	addi	sp,sp,8
81138314:	f800283a 	ret

81138318 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81138318:	defffa04 	addi	sp,sp,-24
8113831c:	de00012e 	bgeu	sp,et,81138324 <altera_avalon_uart_read_fd+0xc>
81138320:	003b68fa 	trap	3
81138324:	dfc00515 	stw	ra,20(sp)
81138328:	df000415 	stw	fp,16(sp)
8113832c:	df000404 	addi	fp,sp,16
81138330:	e13ffd15 	stw	r4,-12(fp)
81138334:	e17ffe15 	stw	r5,-8(fp)
81138338:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8113833c:	e0bffd17 	ldw	r2,-12(fp)
81138340:	10800017 	ldw	r2,0(r2)
81138344:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
81138348:	e0bffc17 	ldw	r2,-16(fp)
8113834c:	10c00a04 	addi	r3,r2,40
81138350:	e0bffd17 	ldw	r2,-12(fp)
81138354:	10800217 	ldw	r2,8(r2)
81138358:	100f883a 	mov	r7,r2
8113835c:	e1bfff17 	ldw	r6,-4(fp)
81138360:	e17ffe17 	ldw	r5,-8(fp)
81138364:	1809883a 	mov	r4,r3
81138368:	11389d80 	call	811389d8 <altera_avalon_uart_read>
      fd->fd_flags);
}
8113836c:	e037883a 	mov	sp,fp
81138370:	dfc00117 	ldw	ra,4(sp)
81138374:	df000017 	ldw	fp,0(sp)
81138378:	dec00204 	addi	sp,sp,8
8113837c:	f800283a 	ret

81138380 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81138380:	defffa04 	addi	sp,sp,-24
81138384:	de00012e 	bgeu	sp,et,8113838c <altera_avalon_uart_write_fd+0xc>
81138388:	003b68fa 	trap	3
8113838c:	dfc00515 	stw	ra,20(sp)
81138390:	df000415 	stw	fp,16(sp)
81138394:	df000404 	addi	fp,sp,16
81138398:	e13ffd15 	stw	r4,-12(fp)
8113839c:	e17ffe15 	stw	r5,-8(fp)
811383a0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811383a4:	e0bffd17 	ldw	r2,-12(fp)
811383a8:	10800017 	ldw	r2,0(r2)
811383ac:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
811383b0:	e0bffc17 	ldw	r2,-16(fp)
811383b4:	10c00a04 	addi	r3,r2,40
811383b8:	e0bffd17 	ldw	r2,-12(fp)
811383bc:	10800217 	ldw	r2,8(r2)
811383c0:	100f883a 	mov	r7,r2
811383c4:	e1bfff17 	ldw	r6,-4(fp)
811383c8:	e17ffe17 	ldw	r5,-8(fp)
811383cc:	1809883a 	mov	r4,r3
811383d0:	1138c8c0 	call	81138c8c <altera_avalon_uart_write>
      fd->fd_flags);
}
811383d4:	e037883a 	mov	sp,fp
811383d8:	dfc00117 	ldw	ra,4(sp)
811383dc:	df000017 	ldw	fp,0(sp)
811383e0:	dec00204 	addi	sp,sp,8
811383e4:	f800283a 	ret

811383e8 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
811383e8:	defffc04 	addi	sp,sp,-16
811383ec:	de00012e 	bgeu	sp,et,811383f4 <altera_avalon_uart_close_fd+0xc>
811383f0:	003b68fa 	trap	3
811383f4:	dfc00315 	stw	ra,12(sp)
811383f8:	df000215 	stw	fp,8(sp)
811383fc:	df000204 	addi	fp,sp,8
81138400:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81138404:	e0bfff17 	ldw	r2,-4(fp)
81138408:	10800017 	ldw	r2,0(r2)
8113840c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81138410:	e0bffe17 	ldw	r2,-8(fp)
81138414:	10c00a04 	addi	r3,r2,40
81138418:	e0bfff17 	ldw	r2,-4(fp)
8113841c:	10800217 	ldw	r2,8(r2)
81138420:	100b883a 	mov	r5,r2
81138424:	1809883a 	mov	r4,r3
81138428:	11389380 	call	81138938 <altera_avalon_uart_close>
}
8113842c:	e037883a 	mov	sp,fp
81138430:	dfc00117 	ldw	ra,4(sp)
81138434:	df000017 	ldw	fp,0(sp)
81138438:	dec00204 	addi	sp,sp,8
8113843c:	f800283a 	ret

81138440 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81138440:	defff304 	addi	sp,sp,-52
81138444:	de00012e 	bgeu	sp,et,8113844c <altera_avalon_uart_init+0xc>
81138448:	003b68fa 	trap	3
8113844c:	dfc00c15 	stw	ra,48(sp)
81138450:	df000b15 	stw	fp,44(sp)
81138454:	df000b04 	addi	fp,sp,44
81138458:	e13ffd15 	stw	r4,-12(fp)
8113845c:	e17ffe15 	stw	r5,-8(fp)
81138460:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
81138464:	e0bffd17 	ldw	r2,-12(fp)
81138468:	10800017 	ldw	r2,0(r2)
8113846c:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81138470:	e0bffd17 	ldw	r2,-12(fp)
81138474:	10800704 	addi	r2,r2,28
81138478:	e0bffa15 	stw	r2,-24(fp)
8113847c:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81138480:	e0bffb0b 	ldhu	r2,-20(fp)
81138484:	e0fffc84 	addi	r3,fp,-14
81138488:	180b883a 	mov	r5,r3
8113848c:	1009883a 	mov	r4,r2
81138490:	112b7e40 	call	8112b7e4 <OSFlagCreate>
81138494:	1007883a 	mov	r3,r2
81138498:	e0bffa17 	ldw	r2,-24(fp)
8113849c:	10c00015 	stw	r3,0(r2)
  return err;
811384a0:	e0bffc83 	ldbu	r2,-14(fp)
811384a4:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811384a8:	1000241e 	bne	r2,zero,8113853c <altera_avalon_uart_init+0xfc>
811384ac:	e0bffd17 	ldw	r2,-12(fp)
811384b0:	10800804 	addi	r2,r2,32
811384b4:	e0bff715 	stw	r2,-36(fp)
811384b8:	00800044 	movi	r2,1
811384bc:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811384c0:	e0bffb8b 	ldhu	r2,-18(fp)
811384c4:	1009883a 	mov	r4,r2
811384c8:	112f7400 	call	8112f740 <OSSemCreate>
811384cc:	1007883a 	mov	r3,r2
811384d0:	e0bff717 	ldw	r2,-36(fp)
811384d4:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811384d8:	e0bff717 	ldw	r2,-36(fp)
811384dc:	10800017 	ldw	r2,0(r2)
811384e0:	10000226 	beq	r2,zero,811384ec <altera_avalon_uart_init+0xac>
811384e4:	0005883a 	mov	r2,zero
811384e8:	00000106 	br	811384f0 <altera_avalon_uart_init+0xb0>
811384ec:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811384f0:	1000121e 	bne	r2,zero,8113853c <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
811384f4:	e0bffd17 	ldw	r2,-12(fp)
811384f8:	10800904 	addi	r2,r2,36
811384fc:	e0bff815 	stw	r2,-32(fp)
81138500:	00800044 	movi	r2,1
81138504:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81138508:	e0bffc0b 	ldhu	r2,-16(fp)
8113850c:	1009883a 	mov	r4,r2
81138510:	112f7400 	call	8112f740 <OSSemCreate>
81138514:	1007883a 	mov	r3,r2
81138518:	e0bff817 	ldw	r2,-32(fp)
8113851c:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81138520:	e0bff817 	ldw	r2,-32(fp)
81138524:	10800017 	ldw	r2,0(r2)
81138528:	10000226 	beq	r2,zero,81138534 <altera_avalon_uart_init+0xf4>
8113852c:	0005883a 	mov	r2,zero
81138530:	00000106 	br	81138538 <altera_avalon_uart_init+0xf8>
81138534:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81138538:	10000226 	beq	r2,zero,81138544 <altera_avalon_uart_init+0x104>
8113853c:	00800044 	movi	r2,1
81138540:	00000106 	br	81138548 <altera_avalon_uart_init+0x108>
81138544:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81138548:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
8113854c:	e0bff917 	ldw	r2,-28(fp)
81138550:	10000f1e 	bne	r2,zero,81138590 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81138554:	e0bffd17 	ldw	r2,-12(fp)
81138558:	00c32004 	movi	r3,3200
8113855c:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81138560:	e0bff617 	ldw	r2,-40(fp)
81138564:	10800304 	addi	r2,r2,12
81138568:	e0fffd17 	ldw	r3,-12(fp)
8113856c:	18c00117 	ldw	r3,4(r3)
81138570:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
81138574:	d8000015 	stw	zero,0(sp)
81138578:	e1fffd17 	ldw	r7,-12(fp)
8113857c:	01a04534 	movhi	r6,33044
81138580:	31a16a04 	addi	r6,r6,-31320
81138584:	e17fff17 	ldw	r5,-4(fp)
81138588:	e13ffe17 	ldw	r4,-8(fp)
8113858c:	113b5680 	call	8113b568 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
81138590:	0001883a 	nop
81138594:	e037883a 	mov	sp,fp
81138598:	dfc00117 	ldw	ra,4(sp)
8113859c:	df000017 	ldw	fp,0(sp)
811385a0:	dec00204 	addi	sp,sp,8
811385a4:	f800283a 	ret

811385a8 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
811385a8:	defffa04 	addi	sp,sp,-24
811385ac:	de00012e 	bgeu	sp,et,811385b4 <altera_avalon_uart_irq+0xc>
811385b0:	003b68fa 	trap	3
811385b4:	dfc00515 	stw	ra,20(sp)
811385b8:	df000415 	stw	fp,16(sp)
811385bc:	df000404 	addi	fp,sp,16
811385c0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
811385c4:	e0bfff17 	ldw	r2,-4(fp)
811385c8:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
811385cc:	e0bffc17 	ldw	r2,-16(fp)
811385d0:	10800017 	ldw	r2,0(r2)
811385d4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
811385d8:	e0bffd17 	ldw	r2,-12(fp)
811385dc:	10800204 	addi	r2,r2,8
811385e0:	10800037 	ldwio	r2,0(r2)
811385e4:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
811385e8:	e0bffd17 	ldw	r2,-12(fp)
811385ec:	10800204 	addi	r2,r2,8
811385f0:	0007883a 	mov	r3,zero
811385f4:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
811385f8:	e0bffd17 	ldw	r2,-12(fp)
811385fc:	10800204 	addi	r2,r2,8
81138600:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
81138604:	e0bffe17 	ldw	r2,-8(fp)
81138608:	1080200c 	andi	r2,r2,128
8113860c:	10000326 	beq	r2,zero,8113861c <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81138610:	e17ffe17 	ldw	r5,-8(fp)
81138614:	e13ffc17 	ldw	r4,-16(fp)
81138618:	113864c0 	call	8113864c <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
8113861c:	e0bffe17 	ldw	r2,-8(fp)
81138620:	1081100c 	andi	r2,r2,1088
81138624:	10000326 	beq	r2,zero,81138634 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81138628:	e17ffe17 	ldw	r5,-8(fp)
8113862c:	e13ffc17 	ldw	r4,-16(fp)
81138630:	113878c0 	call	8113878c <altera_avalon_uart_txirq>
  }
  

}
81138634:	0001883a 	nop
81138638:	e037883a 	mov	sp,fp
8113863c:	dfc00117 	ldw	ra,4(sp)
81138640:	df000017 	ldw	fp,0(sp)
81138644:	dec00204 	addi	sp,sp,8
81138648:	f800283a 	ret

8113864c <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
8113864c:	defff904 	addi	sp,sp,-28
81138650:	de00012e 	bgeu	sp,et,81138658 <altera_avalon_uart_rxirq+0xc>
81138654:	003b68fa 	trap	3
81138658:	dfc00615 	stw	ra,24(sp)
8113865c:	df000515 	stw	fp,20(sp)
81138660:	df000504 	addi	fp,sp,20
81138664:	e13ffe15 	stw	r4,-8(fp)
81138668:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
8113866c:	e0bfff17 	ldw	r2,-4(fp)
81138670:	108000cc 	andi	r2,r2,3
81138674:	10003f1e 	bne	r2,zero,81138774 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81138678:	e0bffe17 	ldw	r2,-8(fp)
8113867c:	10c00317 	ldw	r3,12(r2)
81138680:	e0bffe17 	ldw	r2,-8(fp)
81138684:	10800217 	ldw	r2,8(r2)
81138688:	1880121e 	bne	r3,r2,811386d4 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
8113868c:	e0bffe17 	ldw	r2,-8(fp)
81138690:	10800717 	ldw	r2,28(r2)
81138694:	e0bffc15 	stw	r2,-16(fp)
81138698:	00800044 	movi	r2,1
8113869c:	e0bffd0d 	sth	r2,-12(fp)
811386a0:	00800044 	movi	r2,1
811386a4:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811386a8:	d0a07503 	ldbu	r2,-32300(gp)
811386ac:	10803fcc 	andi	r2,r2,255
811386b0:	10000826 	beq	r2,zero,811386d4 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
811386b4:	e0bffd0b 	ldhu	r2,-12(fp)
811386b8:	e0fffd83 	ldbu	r3,-10(fp)
811386bc:	e13ffdc4 	addi	r4,fp,-9
811386c0:	200f883a 	mov	r7,r4
811386c4:	180d883a 	mov	r6,r3
811386c8:	100b883a 	mov	r5,r2
811386cc:	e13ffc17 	ldw	r4,-16(fp)
811386d0:	112c3f00 	call	8112c3f0 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811386d4:	e0bffe17 	ldw	r2,-8(fp)
811386d8:	10800317 	ldw	r2,12(r2)
811386dc:	10800044 	addi	r2,r2,1
811386e0:	10800fcc 	andi	r2,r2,63
811386e4:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
811386e8:	e0bffe17 	ldw	r2,-8(fp)
811386ec:	10800317 	ldw	r2,12(r2)
811386f0:	e0fffe17 	ldw	r3,-8(fp)
811386f4:	18c00017 	ldw	r3,0(r3)
811386f8:	18c00037 	ldwio	r3,0(r3)
811386fc:	1809883a 	mov	r4,r3
81138700:	e0fffe17 	ldw	r3,-8(fp)
81138704:	1885883a 	add	r2,r3,r2
81138708:	10800a04 	addi	r2,r2,40
8113870c:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81138710:	e0bffe17 	ldw	r2,-8(fp)
81138714:	e0fffb17 	ldw	r3,-20(fp)
81138718:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8113871c:	e0bffe17 	ldw	r2,-8(fp)
81138720:	10800317 	ldw	r2,12(r2)
81138724:	10800044 	addi	r2,r2,1
81138728:	10800fcc 	andi	r2,r2,63
8113872c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81138730:	e0bffe17 	ldw	r2,-8(fp)
81138734:	10c00217 	ldw	r3,8(r2)
81138738:	e0bffb17 	ldw	r2,-20(fp)
8113873c:	18800e1e 	bne	r3,r2,81138778 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81138740:	e0bffe17 	ldw	r2,-8(fp)
81138744:	10c00117 	ldw	r3,4(r2)
81138748:	00bfdfc4 	movi	r2,-129
8113874c:	1886703a 	and	r3,r3,r2
81138750:	e0bffe17 	ldw	r2,-8(fp)
81138754:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81138758:	e0bffe17 	ldw	r2,-8(fp)
8113875c:	10800017 	ldw	r2,0(r2)
81138760:	10800304 	addi	r2,r2,12
81138764:	e0fffe17 	ldw	r3,-8(fp)
81138768:	18c00117 	ldw	r3,4(r3)
8113876c:	10c00035 	stwio	r3,0(r2)
81138770:	00000106 	br	81138778 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81138774:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81138778:	e037883a 	mov	sp,fp
8113877c:	dfc00117 	ldw	ra,4(sp)
81138780:	df000017 	ldw	fp,0(sp)
81138784:	dec00204 	addi	sp,sp,8
81138788:	f800283a 	ret

8113878c <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
8113878c:	defffa04 	addi	sp,sp,-24
81138790:	de00012e 	bgeu	sp,et,81138798 <altera_avalon_uart_txirq+0xc>
81138794:	003b68fa 	trap	3
81138798:	dfc00515 	stw	ra,20(sp)
8113879c:	df000415 	stw	fp,16(sp)
811387a0:	df000404 	addi	fp,sp,16
811387a4:	e13ffe15 	stw	r4,-8(fp)
811387a8:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
811387ac:	e0bffe17 	ldw	r2,-8(fp)
811387b0:	10c00417 	ldw	r3,16(r2)
811387b4:	e0bffe17 	ldw	r2,-8(fp)
811387b8:	10800517 	ldw	r2,20(r2)
811387bc:	18804726 	beq	r3,r2,811388dc <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811387c0:	e0bffe17 	ldw	r2,-8(fp)
811387c4:	10800617 	ldw	r2,24(r2)
811387c8:	1080008c 	andi	r2,r2,2
811387cc:	10000326 	beq	r2,zero,811387dc <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811387d0:	e0bfff17 	ldw	r2,-4(fp)
811387d4:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811387d8:	10003226 	beq	r2,zero,811388a4 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
811387dc:	e0bffe17 	ldw	r2,-8(fp)
811387e0:	10c00417 	ldw	r3,16(r2)
811387e4:	e0bffe17 	ldw	r2,-8(fp)
811387e8:	10800517 	ldw	r2,20(r2)
811387ec:	10800044 	addi	r2,r2,1
811387f0:	10800fcc 	andi	r2,r2,63
811387f4:	1880121e 	bne	r3,r2,81138840 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
811387f8:	e0bffe17 	ldw	r2,-8(fp)
811387fc:	10800717 	ldw	r2,28(r2)
81138800:	e0bffc15 	stw	r2,-16(fp)
81138804:	00800084 	movi	r2,2
81138808:	e0bffd0d 	sth	r2,-12(fp)
8113880c:	00800044 	movi	r2,1
81138810:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81138814:	d0a07503 	ldbu	r2,-32300(gp)
81138818:	10803fcc 	andi	r2,r2,255
8113881c:	10000826 	beq	r2,zero,81138840 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81138820:	e0bffd0b 	ldhu	r2,-12(fp)
81138824:	e0fffd83 	ldbu	r3,-10(fp)
81138828:	e13ffdc4 	addi	r4,fp,-9
8113882c:	200f883a 	mov	r7,r4
81138830:	180d883a 	mov	r6,r3
81138834:	100b883a 	mov	r5,r2
81138838:	e13ffc17 	ldw	r4,-16(fp)
8113883c:	112c3f00 	call	8112c3f0 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81138840:	e0bffe17 	ldw	r2,-8(fp)
81138844:	10800017 	ldw	r2,0(r2)
81138848:	10800104 	addi	r2,r2,4
8113884c:	e0fffe17 	ldw	r3,-8(fp)
81138850:	18c00417 	ldw	r3,16(r3)
81138854:	e13ffe17 	ldw	r4,-8(fp)
81138858:	20c7883a 	add	r3,r4,r3
8113885c:	18c01a04 	addi	r3,r3,104
81138860:	18c00003 	ldbu	r3,0(r3)
81138864:	18c03fcc 	andi	r3,r3,255
81138868:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
8113886c:	e0bffe17 	ldw	r2,-8(fp)
81138870:	10800417 	ldw	r2,16(r2)
81138874:	10800044 	addi	r2,r2,1
81138878:	e0fffe17 	ldw	r3,-8(fp)
8113887c:	18800415 	stw	r2,16(r3)
81138880:	10c00fcc 	andi	r3,r2,63
81138884:	e0bffe17 	ldw	r2,-8(fp)
81138888:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
8113888c:	e0bffe17 	ldw	r2,-8(fp)
81138890:	10800117 	ldw	r2,4(r2)
81138894:	10c01014 	ori	r3,r2,64
81138898:	e0bffe17 	ldw	r2,-8(fp)
8113889c:	10c00115 	stw	r3,4(r2)
811388a0:	00000e06 	br	811388dc <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
811388a4:	e0bffe17 	ldw	r2,-8(fp)
811388a8:	10800017 	ldw	r2,0(r2)
811388ac:	10800204 	addi	r2,r2,8
811388b0:	10800037 	ldwio	r2,0(r2)
811388b4:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811388b8:	e0bfff17 	ldw	r2,-4(fp)
811388bc:	1082000c 	andi	r2,r2,2048
811388c0:	1000061e 	bne	r2,zero,811388dc <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811388c4:	e0bffe17 	ldw	r2,-8(fp)
811388c8:	10c00117 	ldw	r3,4(r2)
811388cc:	00bfefc4 	movi	r2,-65
811388d0:	1886703a 	and	r3,r3,r2
811388d4:	e0bffe17 	ldw	r2,-8(fp)
811388d8:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
811388dc:	e0bffe17 	ldw	r2,-8(fp)
811388e0:	10c00417 	ldw	r3,16(r2)
811388e4:	e0bffe17 	ldw	r2,-8(fp)
811388e8:	10800517 	ldw	r2,20(r2)
811388ec:	1880061e 	bne	r3,r2,81138908 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
811388f0:	e0bffe17 	ldw	r2,-8(fp)
811388f4:	10c00117 	ldw	r3,4(r2)
811388f8:	00beefc4 	movi	r2,-1089
811388fc:	1886703a 	and	r3,r3,r2
81138900:	e0bffe17 	ldw	r2,-8(fp)
81138904:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81138908:	e0bffe17 	ldw	r2,-8(fp)
8113890c:	10800017 	ldw	r2,0(r2)
81138910:	10800304 	addi	r2,r2,12
81138914:	e0fffe17 	ldw	r3,-8(fp)
81138918:	18c00117 	ldw	r3,4(r3)
8113891c:	10c00035 	stwio	r3,0(r2)
}
81138920:	0001883a 	nop
81138924:	e037883a 	mov	sp,fp
81138928:	dfc00117 	ldw	ra,4(sp)
8113892c:	df000017 	ldw	fp,0(sp)
81138930:	dec00204 	addi	sp,sp,8
81138934:	f800283a 	ret

81138938 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81138938:	defffd04 	addi	sp,sp,-12
8113893c:	de00012e 	bgeu	sp,et,81138944 <altera_avalon_uart_close+0xc>
81138940:	003b68fa 	trap	3
81138944:	df000215 	stw	fp,8(sp)
81138948:	df000204 	addi	fp,sp,8
8113894c:	e13ffe15 	stw	r4,-8(fp)
81138950:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81138954:	00000506 	br	8113896c <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81138958:	e0bfff17 	ldw	r2,-4(fp)
8113895c:	1090000c 	andi	r2,r2,16384
81138960:	10000226 	beq	r2,zero,8113896c <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81138964:	00bffd44 	movi	r2,-11
81138968:	00000606 	br	81138984 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
8113896c:	e0bffe17 	ldw	r2,-8(fp)
81138970:	10c00417 	ldw	r3,16(r2)
81138974:	e0bffe17 	ldw	r2,-8(fp)
81138978:	10800517 	ldw	r2,20(r2)
8113897c:	18bff61e 	bne	r3,r2,81138958 <__reset+0xfb118958>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81138980:	0005883a 	mov	r2,zero
}
81138984:	e037883a 	mov	sp,fp
81138988:	df000017 	ldw	fp,0(sp)
8113898c:	dec00104 	addi	sp,sp,4
81138990:	f800283a 	ret

81138994 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81138994:	defffe04 	addi	sp,sp,-8
81138998:	de00012e 	bgeu	sp,et,811389a0 <alt_get_errno+0xc>
8113899c:	003b68fa 	trap	3
811389a0:	dfc00115 	stw	ra,4(sp)
811389a4:	df000015 	stw	fp,0(sp)
811389a8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811389ac:	d0a01017 	ldw	r2,-32704(gp)
811389b0:	10000326 	beq	r2,zero,811389c0 <alt_get_errno+0x2c>
811389b4:	d0a01017 	ldw	r2,-32704(gp)
811389b8:	103ee83a 	callr	r2
811389bc:	00000106 	br	811389c4 <alt_get_errno+0x30>
811389c0:	d0a06004 	addi	r2,gp,-32384
}
811389c4:	e037883a 	mov	sp,fp
811389c8:	dfc00117 	ldw	ra,4(sp)
811389cc:	df000017 	ldw	fp,0(sp)
811389d0:	dec00204 	addi	sp,sp,8
811389d4:	f800283a 	ret

811389d8 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
811389d8:	deffec04 	addi	sp,sp,-80
811389dc:	de00012e 	bgeu	sp,et,811389e4 <altera_avalon_uart_read+0xc>
811389e0:	003b68fa 	trap	3
811389e4:	dfc01315 	stw	ra,76(sp)
811389e8:	df001215 	stw	fp,72(sp)
811389ec:	df001204 	addi	fp,sp,72
811389f0:	e13ffc15 	stw	r4,-16(fp)
811389f4:	e17ffd15 	stw	r5,-12(fp)
811389f8:	e1bffe15 	stw	r6,-8(fp)
811389fc:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
81138a00:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
81138a04:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
81138a08:	e0bfff17 	ldw	r2,-4(fp)
81138a0c:	1090000c 	andi	r2,r2,16384
81138a10:	1005003a 	cmpeq	r2,r2,zero
81138a14:	10803fcc 	andi	r2,r2,255
81138a18:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81138a1c:	e0bffc17 	ldw	r2,-16(fp)
81138a20:	10800817 	ldw	r2,32(r2)
81138a24:	e0bff815 	stw	r2,-32(fp)
81138a28:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81138a2c:	e0bff90b 	ldhu	r2,-28(fp)
81138a30:	e0fffb44 	addi	r3,fp,-19
81138a34:	180d883a 	mov	r6,r3
81138a38:	100b883a 	mov	r5,r2
81138a3c:	e13ff817 	ldw	r4,-32(fp)
81138a40:	112fa680 	call	8112fa68 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81138a44:	00001306 	br	81138a94 <altera_avalon_uart_read+0xbc>
    {
      count++;
81138a48:	e0bff017 	ldw	r2,-64(fp)
81138a4c:	10800044 	addi	r2,r2,1
81138a50:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81138a54:	e0bffd17 	ldw	r2,-12(fp)
81138a58:	10c00044 	addi	r3,r2,1
81138a5c:	e0fffd15 	stw	r3,-12(fp)
81138a60:	e0fffc17 	ldw	r3,-16(fp)
81138a64:	18c00217 	ldw	r3,8(r3)
81138a68:	e13ffc17 	ldw	r4,-16(fp)
81138a6c:	20c7883a 	add	r3,r4,r3
81138a70:	18c00a04 	addi	r3,r3,40
81138a74:	18c00003 	ldbu	r3,0(r3)
81138a78:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81138a7c:	e0bffc17 	ldw	r2,-16(fp)
81138a80:	10800217 	ldw	r2,8(r2)
81138a84:	10800044 	addi	r2,r2,1
81138a88:	10c00fcc 	andi	r3,r2,63
81138a8c:	e0bffc17 	ldw	r2,-16(fp)
81138a90:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81138a94:	e0fff017 	ldw	r3,-64(fp)
81138a98:	e0bffe17 	ldw	r2,-8(fp)
81138a9c:	1880050e 	bge	r3,r2,81138ab4 <altera_avalon_uart_read+0xdc>
81138aa0:	e0bffc17 	ldw	r2,-16(fp)
81138aa4:	10c00217 	ldw	r3,8(r2)
81138aa8:	e0bffc17 	ldw	r2,-16(fp)
81138aac:	10800317 	ldw	r2,12(r2)
81138ab0:	18bfe51e 	bne	r3,r2,81138a48 <__reset+0xfb118a48>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81138ab4:	e0bff017 	ldw	r2,-64(fp)
81138ab8:	10003a1e 	bne	r2,zero,81138ba4 <altera_avalon_uart_read+0x1cc>
81138abc:	e0bffc17 	ldw	r2,-16(fp)
81138ac0:	10c00217 	ldw	r3,8(r2)
81138ac4:	e0bffc17 	ldw	r2,-16(fp)
81138ac8:	10800317 	ldw	r2,12(r2)
81138acc:	1880351e 	bne	r3,r2,81138ba4 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81138ad0:	e0bff117 	ldw	r2,-60(fp)
81138ad4:	1000071e 	bne	r2,zero,81138af4 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81138ad8:	11389940 	call	81138994 <alt_get_errno>
81138adc:	1007883a 	mov	r3,r2
81138ae0:	008002c4 	movi	r2,11
81138ae4:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81138ae8:	00800044 	movi	r2,1
81138aec:	e0bfef05 	stb	r2,-68(fp)
        break;
81138af0:	00003006 	br	81138bb4 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138af4:	0005303a 	rdctl	r2,status
81138af8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138afc:	e0fff517 	ldw	r3,-44(fp)
81138b00:	00bfff84 	movi	r2,-2
81138b04:	1884703a 	and	r2,r3,r2
81138b08:	1001703a 	wrctl	status,r2
  
  return context;
81138b0c:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81138b10:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81138b14:	e0bffc17 	ldw	r2,-16(fp)
81138b18:	10800117 	ldw	r2,4(r2)
81138b1c:	10c02014 	ori	r3,r2,128
81138b20:	e0bffc17 	ldw	r2,-16(fp)
81138b24:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81138b28:	e0bffc17 	ldw	r2,-16(fp)
81138b2c:	10800017 	ldw	r2,0(r2)
81138b30:	10800304 	addi	r2,r2,12
81138b34:	e0fffc17 	ldw	r3,-16(fp)
81138b38:	18c00117 	ldw	r3,4(r3)
81138b3c:	10c00035 	stwio	r3,0(r2)
81138b40:	e0bff417 	ldw	r2,-48(fp)
81138b44:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138b48:	e0bff617 	ldw	r2,-40(fp)
81138b4c:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81138b50:	e0bffc17 	ldw	r2,-16(fp)
81138b54:	10800717 	ldw	r2,28(r2)
81138b58:	e0bff215 	stw	r2,-56(fp)
81138b5c:	00800044 	movi	r2,1
81138b60:	e0bff98d 	sth	r2,-26(fp)
81138b64:	00bfe0c4 	movi	r2,-125
81138b68:	e0bffa05 	stb	r2,-24(fp)
81138b6c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81138b70:	d0a07503 	ldbu	r2,-32300(gp)
81138b74:	10803fcc 	andi	r2,r2,255
81138b78:	10000a26 	beq	r2,zero,81138ba4 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81138b7c:	e0fff98b 	ldhu	r3,-26(fp)
81138b80:	e13ffa03 	ldbu	r4,-24(fp)
81138b84:	e17ffa8b 	ldhu	r5,-22(fp)
81138b88:	e0bffb04 	addi	r2,fp,-20
81138b8c:	d8800015 	stw	r2,0(sp)
81138b90:	280f883a 	mov	r7,r5
81138b94:	200d883a 	mov	r6,r4
81138b98:	180b883a 	mov	r5,r3
81138b9c:	e13ff217 	ldw	r4,-56(fp)
81138ba0:	112bdc80 	call	8112bdc8 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81138ba4:	e0bff017 	ldw	r2,-64(fp)
81138ba8:	1000021e 	bne	r2,zero,81138bb4 <altera_avalon_uart_read+0x1dc>
81138bac:	e0bffe17 	ldw	r2,-8(fp)
81138bb0:	103fb81e 	bne	r2,zero,81138a94 <__reset+0xfb118a94>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81138bb4:	e0bffc17 	ldw	r2,-16(fp)
81138bb8:	10800817 	ldw	r2,32(r2)
81138bbc:	1009883a 	mov	r4,r2
81138bc0:	112fdf00 	call	8112fdf0 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138bc4:	0005303a 	rdctl	r2,status
81138bc8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138bcc:	e0fff717 	ldw	r3,-36(fp)
81138bd0:	00bfff84 	movi	r2,-2
81138bd4:	1884703a 	and	r2,r3,r2
81138bd8:	1001703a 	wrctl	status,r2
  
  return context;
81138bdc:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81138be0:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81138be4:	e0bffc17 	ldw	r2,-16(fp)
81138be8:	10800117 	ldw	r2,4(r2)
81138bec:	10c02014 	ori	r3,r2,128
81138bf0:	e0bffc17 	ldw	r2,-16(fp)
81138bf4:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81138bf8:	e0bffc17 	ldw	r2,-16(fp)
81138bfc:	10800017 	ldw	r2,0(r2)
81138c00:	10800304 	addi	r2,r2,12
81138c04:	e0fffc17 	ldw	r3,-16(fp)
81138c08:	18c00117 	ldw	r3,4(r3)
81138c0c:	10c00035 	stwio	r3,0(r2)
81138c10:	e0bff417 	ldw	r2,-48(fp)
81138c14:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138c18:	e0bff317 	ldw	r2,-52(fp)
81138c1c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81138c20:	e0bfef03 	ldbu	r2,-68(fp)
81138c24:	10000226 	beq	r2,zero,81138c30 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81138c28:	00bffd44 	movi	r2,-11
81138c2c:	00000106 	br	81138c34 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81138c30:	e0bff017 	ldw	r2,-64(fp)
  }
}
81138c34:	e037883a 	mov	sp,fp
81138c38:	dfc00117 	ldw	ra,4(sp)
81138c3c:	df000017 	ldw	fp,0(sp)
81138c40:	dec00204 	addi	sp,sp,8
81138c44:	f800283a 	ret

81138c48 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81138c48:	defffe04 	addi	sp,sp,-8
81138c4c:	de00012e 	bgeu	sp,et,81138c54 <alt_get_errno+0xc>
81138c50:	003b68fa 	trap	3
81138c54:	dfc00115 	stw	ra,4(sp)
81138c58:	df000015 	stw	fp,0(sp)
81138c5c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81138c60:	d0a01017 	ldw	r2,-32704(gp)
81138c64:	10000326 	beq	r2,zero,81138c74 <alt_get_errno+0x2c>
81138c68:	d0a01017 	ldw	r2,-32704(gp)
81138c6c:	103ee83a 	callr	r2
81138c70:	00000106 	br	81138c78 <alt_get_errno+0x30>
81138c74:	d0a06004 	addi	r2,gp,-32384
}
81138c78:	e037883a 	mov	sp,fp
81138c7c:	dfc00117 	ldw	ra,4(sp)
81138c80:	df000017 	ldw	fp,0(sp)
81138c84:	dec00204 	addi	sp,sp,8
81138c88:	f800283a 	ret

81138c8c <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81138c8c:	deffec04 	addi	sp,sp,-80
81138c90:	de00012e 	bgeu	sp,et,81138c98 <altera_avalon_uart_write+0xc>
81138c94:	003b68fa 	trap	3
81138c98:	dfc01315 	stw	ra,76(sp)
81138c9c:	df001215 	stw	fp,72(sp)
81138ca0:	df001204 	addi	fp,sp,72
81138ca4:	e13ffc15 	stw	r4,-16(fp)
81138ca8:	e17ffd15 	stw	r5,-12(fp)
81138cac:	e1bffe15 	stw	r6,-8(fp)
81138cb0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81138cb4:	e0bffe17 	ldw	r2,-8(fp)
81138cb8:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81138cbc:	e0bfff17 	ldw	r2,-4(fp)
81138cc0:	1090000c 	andi	r2,r2,16384
81138cc4:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81138cc8:	e0bffc17 	ldw	r2,-16(fp)
81138ccc:	10800917 	ldw	r2,36(r2)
81138cd0:	e0bff815 	stw	r2,-32(fp)
81138cd4:	e03ff90d 	sth	zero,-28(fp)
81138cd8:	e0bff90b 	ldhu	r2,-28(fp)
81138cdc:	e0fffb44 	addi	r3,fp,-19
81138ce0:	180d883a 	mov	r6,r3
81138ce4:	100b883a 	mov	r5,r2
81138ce8:	e13ff817 	ldw	r4,-32(fp)
81138cec:	112fa680 	call	8112fa68 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81138cf0:	00005106 	br	81138e38 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81138cf4:	e0bffc17 	ldw	r2,-16(fp)
81138cf8:	10800517 	ldw	r2,20(r2)
81138cfc:	10800044 	addi	r2,r2,1
81138d00:	10800fcc 	andi	r2,r2,63
81138d04:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81138d08:	e0bffc17 	ldw	r2,-16(fp)
81138d0c:	10c00417 	ldw	r3,16(r2)
81138d10:	e0bff217 	ldw	r2,-56(fp)
81138d14:	1880371e 	bne	r3,r2,81138df4 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81138d18:	e0bff017 	ldw	r2,-64(fp)
81138d1c:	10000526 	beq	r2,zero,81138d34 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81138d20:	1138c480 	call	81138c48 <alt_get_errno>
81138d24:	1007883a 	mov	r3,r2
81138d28:	008002c4 	movi	r2,11
81138d2c:	18800015 	stw	r2,0(r3)
        break;
81138d30:	00004306 	br	81138e40 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138d34:	0005303a 	rdctl	r2,status
81138d38:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138d3c:	e0fff517 	ldw	r3,-44(fp)
81138d40:	00bfff84 	movi	r2,-2
81138d44:	1884703a 	and	r2,r3,r2
81138d48:	1001703a 	wrctl	status,r2
  
  return context;
81138d4c:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81138d50:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81138d54:	e0bffc17 	ldw	r2,-16(fp)
81138d58:	10800117 	ldw	r2,4(r2)
81138d5c:	10c11014 	ori	r3,r2,1088
81138d60:	e0bffc17 	ldw	r2,-16(fp)
81138d64:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81138d68:	e0bffc17 	ldw	r2,-16(fp)
81138d6c:	10800017 	ldw	r2,0(r2)
81138d70:	10800304 	addi	r2,r2,12
81138d74:	e0fffc17 	ldw	r3,-16(fp)
81138d78:	18c00117 	ldw	r3,4(r3)
81138d7c:	10c00035 	stwio	r3,0(r2)
81138d80:	e0bff417 	ldw	r2,-48(fp)
81138d84:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138d88:	e0bff117 	ldw	r2,-60(fp)
81138d8c:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81138d90:	e0bffc17 	ldw	r2,-16(fp)
81138d94:	10800717 	ldw	r2,28(r2)
81138d98:	e0bff315 	stw	r2,-52(fp)
81138d9c:	00800084 	movi	r2,2
81138da0:	e0bff98d 	sth	r2,-26(fp)
81138da4:	00bfe0c4 	movi	r2,-125
81138da8:	e0bffa05 	stb	r2,-24(fp)
81138dac:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81138db0:	d0a07503 	ldbu	r2,-32300(gp)
81138db4:	10803fcc 	andi	r2,r2,255
81138db8:	10000a26 	beq	r2,zero,81138de4 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81138dbc:	e0fff98b 	ldhu	r3,-26(fp)
81138dc0:	e13ffa03 	ldbu	r4,-24(fp)
81138dc4:	e17ffa8b 	ldhu	r5,-22(fp)
81138dc8:	e0bffb04 	addi	r2,fp,-20
81138dcc:	d8800015 	stw	r2,0(sp)
81138dd0:	280f883a 	mov	r7,r5
81138dd4:	200d883a 	mov	r6,r4
81138dd8:	180b883a 	mov	r5,r3
81138ddc:	e13ff317 	ldw	r4,-52(fp)
81138de0:	112bdc80 	call	8112bdc8 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81138de4:	e0bffc17 	ldw	r2,-16(fp)
81138de8:	10c00417 	ldw	r3,16(r2)
81138dec:	e0bff217 	ldw	r2,-56(fp)
81138df0:	18bfe726 	beq	r3,r2,81138d90 <__reset+0xfb118d90>
      }
    }

    count--;
81138df4:	e0bfef17 	ldw	r2,-68(fp)
81138df8:	10bfffc4 	addi	r2,r2,-1
81138dfc:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81138e00:	e0bffc17 	ldw	r2,-16(fp)
81138e04:	10c00517 	ldw	r3,20(r2)
81138e08:	e0bffd17 	ldw	r2,-12(fp)
81138e0c:	11000044 	addi	r4,r2,1
81138e10:	e13ffd15 	stw	r4,-12(fp)
81138e14:	10800003 	ldbu	r2,0(r2)
81138e18:	1009883a 	mov	r4,r2
81138e1c:	e0bffc17 	ldw	r2,-16(fp)
81138e20:	10c5883a 	add	r2,r2,r3
81138e24:	10801a04 	addi	r2,r2,104
81138e28:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81138e2c:	e0bffc17 	ldw	r2,-16(fp)
81138e30:	e0fff217 	ldw	r3,-56(fp)
81138e34:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81138e38:	e0bfef17 	ldw	r2,-68(fp)
81138e3c:	103fad1e 	bne	r2,zero,81138cf4 <__reset+0xfb118cf4>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81138e40:	e0bffc17 	ldw	r2,-16(fp)
81138e44:	10800917 	ldw	r2,36(r2)
81138e48:	1009883a 	mov	r4,r2
81138e4c:	112fdf00 	call	8112fdf0 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138e50:	0005303a 	rdctl	r2,status
81138e54:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138e58:	e0fff717 	ldw	r3,-36(fp)
81138e5c:	00bfff84 	movi	r2,-2
81138e60:	1884703a 	and	r2,r3,r2
81138e64:	1001703a 	wrctl	status,r2
  
  return context;
81138e68:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81138e6c:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81138e70:	e0bffc17 	ldw	r2,-16(fp)
81138e74:	10800117 	ldw	r2,4(r2)
81138e78:	10c11014 	ori	r3,r2,1088
81138e7c:	e0bffc17 	ldw	r2,-16(fp)
81138e80:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81138e84:	e0bffc17 	ldw	r2,-16(fp)
81138e88:	10800017 	ldw	r2,0(r2)
81138e8c:	10800304 	addi	r2,r2,12
81138e90:	e0fffc17 	ldw	r3,-16(fp)
81138e94:	18c00117 	ldw	r3,4(r3)
81138e98:	10c00035 	stwio	r3,0(r2)
81138e9c:	e0bff417 	ldw	r2,-48(fp)
81138ea0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138ea4:	e0bff617 	ldw	r2,-40(fp)
81138ea8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81138eac:	e0fffe17 	ldw	r3,-8(fp)
81138eb0:	e0bfef17 	ldw	r2,-68(fp)
81138eb4:	1885c83a 	sub	r2,r3,r2
}
81138eb8:	e037883a 	mov	sp,fp
81138ebc:	dfc00117 	ldw	ra,4(sp)
81138ec0:	df000017 	ldw	fp,0(sp)
81138ec4:	dec00204 	addi	sp,sp,8
81138ec8:	f800283a 	ret

81138ecc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81138ecc:	defffe04 	addi	sp,sp,-8
81138ed0:	de00012e 	bgeu	sp,et,81138ed8 <alt_get_errno+0xc>
81138ed4:	003b68fa 	trap	3
81138ed8:	dfc00115 	stw	ra,4(sp)
81138edc:	df000015 	stw	fp,0(sp)
81138ee0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81138ee4:	d0a01017 	ldw	r2,-32704(gp)
81138ee8:	10000326 	beq	r2,zero,81138ef8 <alt_get_errno+0x2c>
81138eec:	d0a01017 	ldw	r2,-32704(gp)
81138ef0:	103ee83a 	callr	r2
81138ef4:	00000106 	br	81138efc <alt_get_errno+0x30>
81138ef8:	d0a06004 	addi	r2,gp,-32384
}
81138efc:	e037883a 	mov	sp,fp
81138f00:	dfc00117 	ldw	ra,4(sp)
81138f04:	df000017 	ldw	fp,0(sp)
81138f08:	dec00204 	addi	sp,sp,8
81138f0c:	f800283a 	ret

81138f10 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81138f10:	defffc04 	addi	sp,sp,-16
81138f14:	de00012e 	bgeu	sp,et,81138f1c <alt_msgdma_write_standard_descriptor+0xc>
81138f18:	003b68fa 	trap	3
81138f1c:	df000315 	stw	fp,12(sp)
81138f20:	df000304 	addi	fp,sp,12
81138f24:	e13ffd15 	stw	r4,-12(fp)
81138f28:	e17ffe15 	stw	r5,-8(fp)
81138f2c:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81138f30:	e0bffd17 	ldw	r2,-12(fp)
81138f34:	10800037 	ldwio	r2,0(r2)
81138f38:	1080010c 	andi	r2,r2,4
81138f3c:	10000226 	beq	r2,zero,81138f48 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81138f40:	00bff904 	movi	r2,-28
81138f44:	00001506 	br	81138f9c <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81138f48:	e0bfff17 	ldw	r2,-4(fp)
81138f4c:	10800017 	ldw	r2,0(r2)
81138f50:	1007883a 	mov	r3,r2
81138f54:	e0bffe17 	ldw	r2,-8(fp)
81138f58:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81138f5c:	e0bffe17 	ldw	r2,-8(fp)
81138f60:	10800104 	addi	r2,r2,4
81138f64:	e0ffff17 	ldw	r3,-4(fp)
81138f68:	18c00117 	ldw	r3,4(r3)
81138f6c:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81138f70:	e0bffe17 	ldw	r2,-8(fp)
81138f74:	10800204 	addi	r2,r2,8
81138f78:	e0ffff17 	ldw	r3,-4(fp)
81138f7c:	18c00217 	ldw	r3,8(r3)
81138f80:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
81138f84:	e0bffe17 	ldw	r2,-8(fp)
81138f88:	10800304 	addi	r2,r2,12
81138f8c:	e0ffff17 	ldw	r3,-4(fp)
81138f90:	18c00317 	ldw	r3,12(r3)
81138f94:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
81138f98:	0005883a 	mov	r2,zero
}
81138f9c:	e037883a 	mov	sp,fp
81138fa0:	df000017 	ldw	fp,0(sp)
81138fa4:	dec00104 	addi	sp,sp,4
81138fa8:	f800283a 	ret

81138fac <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
81138fac:	defffc04 	addi	sp,sp,-16
81138fb0:	de00012e 	bgeu	sp,et,81138fb8 <alt_msgdma_write_extended_descriptor+0xc>
81138fb4:	003b68fa 	trap	3
81138fb8:	df000315 	stw	fp,12(sp)
81138fbc:	df000304 	addi	fp,sp,12
81138fc0:	e13ffd15 	stw	r4,-12(fp)
81138fc4:	e17ffe15 	stw	r5,-8(fp)
81138fc8:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81138fcc:	e0bffd17 	ldw	r2,-12(fp)
81138fd0:	10800037 	ldwio	r2,0(r2)
81138fd4:	1080010c 	andi	r2,r2,4
81138fd8:	10000226 	beq	r2,zero,81138fe4 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81138fdc:	00bff904 	movi	r2,-28
81138fe0:	00003b06 	br	811390d0 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81138fe4:	e0bfff17 	ldw	r2,-4(fp)
81138fe8:	10800017 	ldw	r2,0(r2)
81138fec:	1007883a 	mov	r3,r2
81138ff0:	e0bffe17 	ldw	r2,-8(fp)
81138ff4:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
81138ff8:	e0bffe17 	ldw	r2,-8(fp)
81138ffc:	10800104 	addi	r2,r2,4
81139000:	e0ffff17 	ldw	r3,-4(fp)
81139004:	18c00117 	ldw	r3,4(r3)
81139008:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
8113900c:	e0bffe17 	ldw	r2,-8(fp)
81139010:	10800204 	addi	r2,r2,8
81139014:	e0ffff17 	ldw	r3,-4(fp)
81139018:	18c00217 	ldw	r3,8(r3)
8113901c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81139020:	e0bffe17 	ldw	r2,-8(fp)
81139024:	10800304 	addi	r2,r2,12
81139028:	e0ffff17 	ldw	r3,-4(fp)
8113902c:	18c0030b 	ldhu	r3,12(r3)
81139030:	18ffffcc 	andi	r3,r3,65535
81139034:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81139038:	e0bffe17 	ldw	r2,-8(fp)
8113903c:	10800384 	addi	r2,r2,14
81139040:	e0ffff17 	ldw	r3,-4(fp)
81139044:	18c00383 	ldbu	r3,14(r3)
81139048:	18c03fcc 	andi	r3,r3,255
8113904c:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81139050:	e0bffe17 	ldw	r2,-8(fp)
81139054:	108003c4 	addi	r2,r2,15
81139058:	e0ffff17 	ldw	r3,-4(fp)
8113905c:	18c003c3 	ldbu	r3,15(r3)
81139060:	18c03fcc 	andi	r3,r3,255
81139064:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81139068:	e0bffe17 	ldw	r2,-8(fp)
8113906c:	10800404 	addi	r2,r2,16
81139070:	e0ffff17 	ldw	r3,-4(fp)
81139074:	18c0040b 	ldhu	r3,16(r3)
81139078:	18ffffcc 	andi	r3,r3,65535
8113907c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81139080:	e0bffe17 	ldw	r2,-8(fp)
81139084:	10800484 	addi	r2,r2,18
81139088:	e0ffff17 	ldw	r3,-4(fp)
8113908c:	18c0048b 	ldhu	r3,18(r3)
81139090:	18ffffcc 	andi	r3,r3,65535
81139094:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
81139098:	e0bffe17 	ldw	r2,-8(fp)
8113909c:	10800504 	addi	r2,r2,20
811390a0:	0007883a 	mov	r3,zero
811390a4:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
811390a8:	e0bffe17 	ldw	r2,-8(fp)
811390ac:	10800604 	addi	r2,r2,24
811390b0:	0007883a 	mov	r3,zero
811390b4:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
811390b8:	e0bffe17 	ldw	r2,-8(fp)
811390bc:	10800704 	addi	r2,r2,28
811390c0:	e0ffff17 	ldw	r3,-4(fp)
811390c4:	18c00717 	ldw	r3,28(r3)
811390c8:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
811390cc:	0005883a 	mov	r2,zero
}
811390d0:	e037883a 	mov	sp,fp
811390d4:	df000017 	ldw	fp,0(sp)
811390d8:	dec00104 	addi	sp,sp,4
811390dc:	f800283a 	ret

811390e0 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
811390e0:	defff804 	addi	sp,sp,-32
811390e4:	de00012e 	bgeu	sp,et,811390ec <alt_msgdma_irq+0xc>
811390e8:	003b68fa 	trap	3
811390ec:	dfc00715 	stw	ra,28(sp)
811390f0:	df000615 	stw	fp,24(sp)
811390f4:	df000604 	addi	fp,sp,24
811390f8:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
811390fc:	e0bfff17 	ldw	r2,-4(fp)
81139100:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81139104:	e0bffa17 	ldw	r2,-24(fp)
81139108:	10801783 	ldbu	r2,94(r2)
8113910c:	10803fcc 	andi	r2,r2,255
81139110:	10001126 	beq	r2,zero,81139158 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81139114:	e0bffa17 	ldw	r2,-24(fp)
81139118:	10800617 	ldw	r2,24(r2)
8113911c:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81139120:	1007883a 	mov	r3,r2
81139124:	00bffdc4 	movi	r2,-9
81139128:	1884703a 	and	r2,r3,r2
8113912c:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81139130:	e0bffa17 	ldw	r2,-24(fp)
81139134:	10800617 	ldw	r2,24(r2)
81139138:	e0fffb17 	ldw	r3,-20(fp)
8113913c:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81139140:	e0bffa17 	ldw	r2,-24(fp)
81139144:	10800617 	ldw	r2,24(r2)
81139148:	10800404 	addi	r2,r2,16
8113914c:	00c00044 	movi	r3,1
81139150:	10c00035 	stwio	r3,0(r2)
81139154:	00001106 	br	8113919c <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81139158:	e0bffa17 	ldw	r2,-24(fp)
8113915c:	10800317 	ldw	r2,12(r2)
81139160:	10800104 	addi	r2,r2,4
81139164:	10800037 	ldwio	r2,0(r2)
81139168:	1007883a 	mov	r3,r2
8113916c:	00bffbc4 	movi	r2,-17
81139170:	1884703a 	and	r2,r3,r2
81139174:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81139178:	e0bffa17 	ldw	r2,-24(fp)
8113917c:	10800317 	ldw	r2,12(r2)
81139180:	10800104 	addi	r2,r2,4
81139184:	e0fffb17 	ldw	r3,-20(fp)
81139188:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8113918c:	e0bffa17 	ldw	r2,-24(fp)
81139190:	10800317 	ldw	r2,12(r2)
81139194:	00c08004 	movi	r3,512
81139198:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
8113919c:	e0bffa17 	ldw	r2,-24(fp)
811391a0:	10800b17 	ldw	r2,44(r2)
811391a4:	10001226 	beq	r2,zero,811391f0 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811391a8:	0005303a 	rdctl	r2,status
811391ac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811391b0:	e0fffd17 	ldw	r3,-12(fp)
811391b4:	00bfff84 	movi	r2,-2
811391b8:	1884703a 	and	r2,r3,r2
811391bc:	1001703a 	wrctl	status,r2
  
  return context;
811391c0:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
811391c4:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
811391c8:	e0bffa17 	ldw	r2,-24(fp)
811391cc:	10800b17 	ldw	r2,44(r2)
811391d0:	e0fffa17 	ldw	r3,-24(fp)
811391d4:	18c00c17 	ldw	r3,48(r3)
811391d8:	1809883a 	mov	r4,r3
811391dc:	103ee83a 	callr	r2
811391e0:	e0bffc17 	ldw	r2,-16(fp)
811391e4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811391e8:	e0bffe17 	ldw	r2,-8(fp)
811391ec:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
811391f0:	e0bffa17 	ldw	r2,-24(fp)
811391f4:	10801783 	ldbu	r2,94(r2)
811391f8:	10803fcc 	andi	r2,r2,255
811391fc:	10000a26 	beq	r2,zero,81139228 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81139200:	e0bffa17 	ldw	r2,-24(fp)
81139204:	10800617 	ldw	r2,24(r2)
81139208:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8113920c:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81139210:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81139214:	e0bffa17 	ldw	r2,-24(fp)
81139218:	10800617 	ldw	r2,24(r2)
8113921c:	e0fffb17 	ldw	r3,-20(fp)
81139220:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81139224:	00000c06 	br	81139258 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81139228:	e0bffa17 	ldw	r2,-24(fp)
8113922c:	10800317 	ldw	r2,12(r2)
81139230:	10800104 	addi	r2,r2,4
81139234:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81139238:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8113923c:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81139240:	e0bffa17 	ldw	r2,-24(fp)
81139244:	10800317 	ldw	r2,12(r2)
81139248:	10800104 	addi	r2,r2,4
8113924c:	e0fffb17 	ldw	r3,-20(fp)
81139250:	10c00035 	stwio	r3,0(r2)
    }

    return;
81139254:	0001883a 	nop
}
81139258:	e037883a 	mov	sp,fp
8113925c:	dfc00117 	ldw	ra,4(sp)
81139260:	df000017 	ldw	fp,0(sp)
81139264:	dec00204 	addi	sp,sp,8
81139268:	f800283a 	ret

8113926c <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113926c:	defffb04 	addi	sp,sp,-20
81139270:	de00012e 	bgeu	sp,et,81139278 <alt_msgdma_construct_standard_descriptor+0xc>
81139274:	003b68fa 	trap	3
81139278:	df000415 	stw	fp,16(sp)
8113927c:	df000404 	addi	fp,sp,16
81139280:	e13ffc15 	stw	r4,-16(fp)
81139284:	e17ffd15 	stw	r5,-12(fp)
81139288:	e1bffe15 	stw	r6,-8(fp)
8113928c:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81139290:	e0bffc17 	ldw	r2,-16(fp)
81139294:	10c01217 	ldw	r3,72(r2)
81139298:	e0800117 	ldw	r2,4(fp)
8113929c:	18800436 	bltu	r3,r2,811392b0 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
811392a0:	e0bffc17 	ldw	r2,-16(fp)
811392a4:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
811392a8:	10803fcc 	andi	r2,r2,255
811392ac:	10000226 	beq	r2,zero,811392b8 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
811392b0:	00bffa84 	movi	r2,-22
811392b4:	00000e06 	br	811392f0 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
811392b8:	e0bffd17 	ldw	r2,-12(fp)
811392bc:	e0fffe17 	ldw	r3,-8(fp)
811392c0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
811392c4:	e0bffd17 	ldw	r2,-12(fp)
811392c8:	e0ffff17 	ldw	r3,-4(fp)
811392cc:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811392d0:	e0bffd17 	ldw	r2,-12(fp)
811392d4:	e0c00117 	ldw	r3,4(fp)
811392d8:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811392dc:	e0800217 	ldw	r2,8(fp)
811392e0:	10e00034 	orhi	r3,r2,32768
811392e4:	e0bffd17 	ldw	r2,-12(fp)
811392e8:	10c00315 	stw	r3,12(r2)
    
    return 0;
811392ec:	0005883a 	mov	r2,zero
}
811392f0:	e037883a 	mov	sp,fp
811392f4:	df000017 	ldw	fp,0(sp)
811392f8:	dec00104 	addi	sp,sp,4
811392fc:	f800283a 	ret

81139300 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81139300:	defff604 	addi	sp,sp,-40
81139304:	de00012e 	bgeu	sp,et,8113930c <alt_msgdma_construct_extended_descriptor+0xc>
81139308:	003b68fa 	trap	3
8113930c:	df000915 	stw	fp,36(sp)
81139310:	df000904 	addi	fp,sp,36
81139314:	e13ff715 	stw	r4,-36(fp)
81139318:	e17ff815 	stw	r5,-32(fp)
8113931c:	e1bff915 	stw	r6,-28(fp)
81139320:	e1fffa15 	stw	r7,-24(fp)
81139324:	e1800317 	ldw	r6,12(fp)
81139328:	e1400417 	ldw	r5,16(fp)
8113932c:	e1000517 	ldw	r4,20(fp)
81139330:	e0c00617 	ldw	r3,24(fp)
81139334:	e0800717 	ldw	r2,28(fp)
81139338:	e1bffb0d 	sth	r6,-20(fp)
8113933c:	e17ffc05 	stb	r5,-16(fp)
81139340:	e13ffd05 	stb	r4,-12(fp)
81139344:	e0fffe0d 	sth	r3,-8(fp)
81139348:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
8113934c:	e0bff717 	ldw	r2,-36(fp)
81139350:	10c01217 	ldw	r3,72(r2)
81139354:	e0800117 	ldw	r2,4(fp)
81139358:	18801936 	bltu	r3,r2,811393c0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8113935c:	e13ff717 	ldw	r4,-36(fp)
81139360:	20801317 	ldw	r2,76(r4)
81139364:	20c01417 	ldw	r3,80(r4)
81139368:	e13ffe0b 	ldhu	r4,-8(fp)
8113936c:	213fffcc 	andi	r4,r4,65535
81139370:	2015883a 	mov	r10,r4
81139374:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81139378:	1ac01136 	bltu	r3,r11,811393c0 <alt_msgdma_construct_extended_descriptor+0xc0>
8113937c:	58c0011e 	bne	r11,r3,81139384 <alt_msgdma_construct_extended_descriptor+0x84>
81139380:	12800f36 	bltu	r2,r10,811393c0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81139384:	e13ff717 	ldw	r4,-36(fp)
81139388:	20801317 	ldw	r2,76(r4)
8113938c:	20c01417 	ldw	r3,80(r4)
81139390:	e13fff0b 	ldhu	r4,-4(fp)
81139394:	213fffcc 	andi	r4,r4,65535
81139398:	2011883a 	mov	r8,r4
8113939c:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
811393a0:	1a400736 	bltu	r3,r9,811393c0 <alt_msgdma_construct_extended_descriptor+0xc0>
811393a4:	48c0011e 	bne	r9,r3,811393ac <alt_msgdma_construct_extended_descriptor+0xac>
811393a8:	12000536 	bltu	r2,r8,811393c0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
811393ac:	e0bff717 	ldw	r2,-36(fp)
811393b0:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811393b4:	10803fcc 	andi	r2,r2,255
811393b8:	10800060 	cmpeqi	r2,r2,1
811393bc:	1000021e 	bne	r2,zero,811393c8 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
811393c0:	00bffa84 	movi	r2,-22
811393c4:	00002106 	br	8113944c <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
811393c8:	e0bff817 	ldw	r2,-32(fp)
811393cc:	e0fff917 	ldw	r3,-28(fp)
811393d0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
811393d4:	e0bff817 	ldw	r2,-32(fp)
811393d8:	e0fffa17 	ldw	r3,-24(fp)
811393dc:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811393e0:	e0bff817 	ldw	r2,-32(fp)
811393e4:	e0c00117 	ldw	r3,4(fp)
811393e8:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
811393ec:	e0bff817 	ldw	r2,-32(fp)
811393f0:	e0fffb0b 	ldhu	r3,-20(fp)
811393f4:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
811393f8:	e0bff817 	ldw	r2,-32(fp)
811393fc:	e0fffc03 	ldbu	r3,-16(fp)
81139400:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81139404:	e0bff817 	ldw	r2,-32(fp)
81139408:	e0fffd03 	ldbu	r3,-12(fp)
8113940c:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81139410:	e0bff817 	ldw	r2,-32(fp)
81139414:	e0fffe0b 	ldhu	r3,-8(fp)
81139418:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
8113941c:	e0bff817 	ldw	r2,-32(fp)
81139420:	e0ffff0b 	ldhu	r3,-4(fp)
81139424:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81139428:	e0bff817 	ldw	r2,-32(fp)
8113942c:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81139430:	e0bff817 	ldw	r2,-32(fp)
81139434:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81139438:	e0800217 	ldw	r2,8(fp)
8113943c:	10e00034 	orhi	r3,r2,32768
81139440:	e0bff817 	ldw	r2,-32(fp)
81139444:	10c00715 	stw	r3,28(r2)

  return 0 ;
81139448:	0005883a 	mov	r2,zero

}
8113944c:	e037883a 	mov	sp,fp
81139450:	df000017 	ldw	fp,0(sp)
81139454:	dec00104 	addi	sp,sp,4
81139458:	f800283a 	ret

8113945c <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8113945c:	deffee04 	addi	sp,sp,-72
81139460:	de00012e 	bgeu	sp,et,81139468 <alt_msgdma_descriptor_async_transfer+0xc>
81139464:	003b68fa 	trap	3
81139468:	dfc01115 	stw	ra,68(sp)
8113946c:	df001015 	stw	fp,64(sp)
81139470:	df001004 	addi	fp,sp,64
81139474:	e13ffd15 	stw	r4,-12(fp)
81139478:	e17ffe15 	stw	r5,-8(fp)
8113947c:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
81139480:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
81139484:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
81139488:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113948c:	e0bffd17 	ldw	r2,-12(fp)
81139490:	10800317 	ldw	r2,12(r2)
81139494:	10800204 	addi	r2,r2,8
81139498:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8113949c:	10bfffcc 	andi	r2,r2,65535
811394a0:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811394a4:	e0bffd17 	ldw	r2,-12(fp)
811394a8:	10800317 	ldw	r2,12(r2)
811394ac:	10800204 	addi	r2,r2,8
811394b0:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811394b4:	1004d43a 	srli	r2,r2,16
811394b8:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811394bc:	e0bffd17 	ldw	r2,-12(fp)
811394c0:	10800917 	ldw	r2,36(r2)
811394c4:	e0fff417 	ldw	r3,-48(fp)
811394c8:	1880042e 	bgeu	r3,r2,811394dc <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
811394cc:	e0bffd17 	ldw	r2,-12(fp)
811394d0:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811394d4:	e0fff317 	ldw	r3,-52(fp)
811394d8:	18800236 	bltu	r3,r2,811394e4 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
811394dc:	00bff904 	movi	r2,-28
811394e0:	0000a906 	br	81139788 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
811394e4:	e0bffd17 	ldw	r2,-12(fp)
811394e8:	10801817 	ldw	r2,96(r2)
811394ec:	e0bff615 	stw	r2,-40(fp)
811394f0:	e03ffc0d 	sth	zero,-16(fp)
811394f4:	e0bffc0b 	ldhu	r2,-16(fp)
811394f8:	e0fffc84 	addi	r3,fp,-14
811394fc:	180d883a 	mov	r6,r3
81139500:	100b883a 	mov	r5,r2
81139504:	e13ff617 	ldw	r4,-40(fp)
81139508:	112fa680 	call	8112fa68 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8113950c:	00800804 	movi	r2,32
81139510:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139514:	0005303a 	rdctl	r2,status
81139518:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113951c:	e0fff717 	ldw	r3,-36(fp)
81139520:	00bfff84 	movi	r2,-2
81139524:	1884703a 	and	r2,r3,r2
81139528:	1001703a 	wrctl	status,r2
  
  return context;
8113952c:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81139530:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81139534:	e0bffd17 	ldw	r2,-12(fp)
81139538:	10800317 	ldw	r2,12(r2)
8113953c:	10800104 	addi	r2,r2,4
81139540:	e0fff117 	ldw	r3,-60(fp)
81139544:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
81139548:	e0bffd17 	ldw	r2,-12(fp)
8113954c:	10800317 	ldw	r2,12(r2)
81139550:	e0fffd17 	ldw	r3,-12(fp)
81139554:	18c00317 	ldw	r3,12(r3)
81139558:	18c00037 	ldwio	r3,0(r3)
8113955c:	10c00035 	stwio	r3,0(r2)
81139560:	e0bff217 	ldw	r2,-56(fp)
81139564:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139568:	e0bffb17 	ldw	r2,-20(fp)
8113956c:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81139570:	e0bffe17 	ldw	r2,-8(fp)
81139574:	10001e26 	beq	r2,zero,811395f0 <alt_msgdma_descriptor_async_transfer+0x194>
81139578:	e0bfff17 	ldw	r2,-4(fp)
8113957c:	10001c1e 	bne	r2,zero,811395f0 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81139580:	00001106 	br	811395c8 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81139584:	01000044 	movi	r4,1
81139588:	1127d1c0 	call	81127d1c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113958c:	e0bff00b 	ldhu	r2,-64(fp)
81139590:	1084e230 	cmpltui	r2,r2,5000
81139594:	1000091e 	bne	r2,zero,811395bc <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
81139598:	01204534 	movhi	r4,33044
8113959c:	213f0904 	addi	r4,r4,-988
811395a0:	113b9800 	call	8113b980 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811395a4:	e0bffd17 	ldw	r2,-12(fp)
811395a8:	10801817 	ldw	r2,96(r2)
811395ac:	1009883a 	mov	r4,r2
811395b0:	112fdf00 	call	8112fdf0 <OSSemPost>
				
                return -ETIME;
811395b4:	00bff084 	movi	r2,-62
811395b8:	00007306 	br	81139788 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
811395bc:	e0bff00b 	ldhu	r2,-64(fp)
811395c0:	10800044 	addi	r2,r2,1
811395c4:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811395c8:	e0bffd17 	ldw	r2,-12(fp)
811395cc:	10c00317 	ldw	r3,12(r2)
811395d0:	e0bffd17 	ldw	r2,-12(fp)
811395d4:	10800417 	ldw	r2,16(r2)
811395d8:	e1bffe17 	ldw	r6,-8(fp)
811395dc:	100b883a 	mov	r5,r2
811395e0:	1809883a 	mov	r4,r3
811395e4:	1138f100 	call	81138f10 <alt_msgdma_write_standard_descriptor>
811395e8:	103fe61e 	bne	r2,zero,81139584 <__reset+0xfb119584>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
811395ec:	00002706 	br	8113968c <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811395f0:	e0bffe17 	ldw	r2,-8(fp)
811395f4:	10001f1e 	bne	r2,zero,81139674 <alt_msgdma_descriptor_async_transfer+0x218>
811395f8:	e0bfff17 	ldw	r2,-4(fp)
811395fc:	10001d26 	beq	r2,zero,81139674 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
81139600:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81139604:	00001106 	br	8113964c <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81139608:	01000044 	movi	r4,1
8113960c:	1127d1c0 	call	81127d1c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81139610:	e0bff00b 	ldhu	r2,-64(fp)
81139614:	1084e230 	cmpltui	r2,r2,5000
81139618:	1000091e 	bne	r2,zero,81139640 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
8113961c:	01204534 	movhi	r4,33044
81139620:	213f1f04 	addi	r4,r4,-900
81139624:	113b9800 	call	8113b980 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81139628:	e0bffd17 	ldw	r2,-12(fp)
8113962c:	10801817 	ldw	r2,96(r2)
81139630:	1009883a 	mov	r4,r2
81139634:	112fdf00 	call	8112fdf0 <OSSemPost>
				
                return -ETIME;
81139638:	00bff084 	movi	r2,-62
8113963c:	00005206 	br	81139788 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81139640:	e0bff00b 	ldhu	r2,-64(fp)
81139644:	10800044 	addi	r2,r2,1
81139648:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8113964c:	e0bffd17 	ldw	r2,-12(fp)
81139650:	10c00317 	ldw	r3,12(r2)
81139654:	e0bffd17 	ldw	r2,-12(fp)
81139658:	10800417 	ldw	r2,16(r2)
8113965c:	e1bfff17 	ldw	r6,-4(fp)
81139660:	100b883a 	mov	r5,r2
81139664:	1809883a 	mov	r4,r3
81139668:	1138fac0 	call	81138fac <alt_msgdma_write_extended_descriptor>
8113966c:	103fe61e 	bne	r2,zero,81139608 <__reset+0xfb119608>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81139670:	00000606 	br	8113968c <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81139674:	e0bffd17 	ldw	r2,-12(fp)
81139678:	10801817 	ldw	r2,96(r2)
8113967c:	1009883a 	mov	r4,r2
81139680:	112fdf00 	call	8112fdf0 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81139684:	00bfffc4 	movi	r2,-1
81139688:	00003f06 	br	81139788 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
8113968c:	e0bffd17 	ldw	r2,-12(fp)
81139690:	10800b17 	ldw	r2,44(r2)
81139694:	10001c26 	beq	r2,zero,81139708 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
81139698:	e0bffd17 	ldw	r2,-12(fp)
8113969c:	10c00d17 	ldw	r3,52(r2)
811396a0:	e0bff117 	ldw	r2,-60(fp)
811396a4:	1884b03a 	or	r2,r3,r2
811396a8:	10800514 	ori	r2,r2,20
811396ac:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
811396b0:	e0fff117 	ldw	r3,-60(fp)
811396b4:	00bff7c4 	movi	r2,-33
811396b8:	1884703a 	and	r2,r3,r2
811396bc:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811396c0:	0005303a 	rdctl	r2,status
811396c4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811396c8:	e0fff917 	ldw	r3,-28(fp)
811396cc:	00bfff84 	movi	r2,-2
811396d0:	1884703a 	and	r2,r3,r2
811396d4:	1001703a 	wrctl	status,r2
  
  return context;
811396d8:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
811396dc:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811396e0:	e0bffd17 	ldw	r2,-12(fp)
811396e4:	10800317 	ldw	r2,12(r2)
811396e8:	10800104 	addi	r2,r2,4
811396ec:	e0fff117 	ldw	r3,-60(fp)
811396f0:	10c00035 	stwio	r3,0(r2)
811396f4:	e0bff217 	ldw	r2,-56(fp)
811396f8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811396fc:	e0bff517 	ldw	r2,-44(fp)
81139700:	1001703a 	wrctl	status,r2
81139704:	00001b06 	br	81139774 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
81139708:	e0bffd17 	ldw	r2,-12(fp)
8113970c:	10c00d17 	ldw	r3,52(r2)
81139710:	e0bff117 	ldw	r2,-60(fp)
81139714:	1884b03a 	or	r2,r3,r2
81139718:	10800114 	ori	r2,r2,4
8113971c:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
81139720:	e0fff117 	ldw	r3,-60(fp)
81139724:	00bff3c4 	movi	r2,-49
81139728:	1884703a 	and	r2,r3,r2
8113972c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139730:	0005303a 	rdctl	r2,status
81139734:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139738:	e0fffa17 	ldw	r3,-24(fp)
8113973c:	00bfff84 	movi	r2,-2
81139740:	1884703a 	and	r2,r3,r2
81139744:	1001703a 	wrctl	status,r2
  
  return context;
81139748:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
8113974c:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81139750:	e0bffd17 	ldw	r2,-12(fp)
81139754:	10800317 	ldw	r2,12(r2)
81139758:	10800104 	addi	r2,r2,4
8113975c:	e0fff117 	ldw	r3,-60(fp)
81139760:	10c00035 	stwio	r3,0(r2)
81139764:	e0bff217 	ldw	r2,-56(fp)
81139768:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113976c:	e0bff817 	ldw	r2,-32(fp)
81139770:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81139774:	e0bffd17 	ldw	r2,-12(fp)
81139778:	10801817 	ldw	r2,96(r2)
8113977c:	1009883a 	mov	r4,r2
81139780:	112fdf00 	call	8112fdf0 <OSSemPost>
    
    return 0;
81139784:	0005883a 	mov	r2,zero
}
81139788:	e037883a 	mov	sp,fp
8113978c:	dfc00117 	ldw	ra,4(sp)
81139790:	df000017 	ldw	fp,0(sp)
81139794:	dec00204 	addi	sp,sp,8
81139798:	f800283a 	ret

8113979c <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8113979c:	deffee04 	addi	sp,sp,-72
811397a0:	de00012e 	bgeu	sp,et,811397a8 <alt_msgdma_descriptor_sync_transfer+0xc>
811397a4:	003b68fa 	trap	3
811397a8:	dfc01115 	stw	ra,68(sp)
811397ac:	df001015 	stw	fp,64(sp)
811397b0:	df001004 	addi	fp,sp,64
811397b4:	e13ffd15 	stw	r4,-12(fp)
811397b8:	e17ffe15 	stw	r5,-8(fp)
811397bc:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
811397c0:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
811397c4:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
811397c8:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
811397cc:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811397d0:	e0bffd17 	ldw	r2,-12(fp)
811397d4:	10800317 	ldw	r2,12(r2)
811397d8:	10800204 	addi	r2,r2,8
811397dc:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
811397e0:	10bfffcc 	andi	r2,r2,65535
811397e4:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811397e8:	e0bffd17 	ldw	r2,-12(fp)
811397ec:	10800317 	ldw	r2,12(r2)
811397f0:	10800204 	addi	r2,r2,8
811397f4:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811397f8:	1004d43a 	srli	r2,r2,16
811397fc:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
81139800:	00807804 	movi	r2,480
81139804:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81139808:	00001906 	br	81139870 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
8113980c:	01000044 	movi	r4,1
81139810:	1127d1c0 	call	81127d1c <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81139814:	e0bff10b 	ldhu	r2,-60(fp)
81139818:	1084e230 	cmpltui	r2,r2,5000
8113981c:	1000051e 	bne	r2,zero,81139834 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
81139820:	01204534 	movhi	r4,33044
81139824:	213f3504 	addi	r4,r4,-812
81139828:	113b9800 	call	8113b980 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
8113982c:	00bff084 	movi	r2,-62
81139830:	0000d706 	br	81139b90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81139834:	e0bff10b 	ldhu	r2,-60(fp)
81139838:	10800044 	addi	r2,r2,1
8113983c:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81139840:	e0bffd17 	ldw	r2,-12(fp)
81139844:	10800317 	ldw	r2,12(r2)
81139848:	10800204 	addi	r2,r2,8
8113984c:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81139850:	10bfffcc 	andi	r2,r2,65535
81139854:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81139858:	e0bffd17 	ldw	r2,-12(fp)
8113985c:	10800317 	ldw	r2,12(r2)
81139860:	10800204 	addi	r2,r2,8
81139864:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
81139868:	1004d43a 	srli	r2,r2,16
8113986c:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81139870:	e0bffd17 	ldw	r2,-12(fp)
81139874:	10800917 	ldw	r2,36(r2)
81139878:	e0fff317 	ldw	r3,-52(fp)
8113987c:	18bfe32e 	bgeu	r3,r2,8113980c <__reset+0xfb11980c>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81139880:	e0bffd17 	ldw	r2,-12(fp)
81139884:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81139888:	e0fff217 	ldw	r3,-56(fp)
8113988c:	18bfdf2e 	bgeu	r3,r2,8113980c <__reset+0xfb11980c>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
81139890:	e0bffd17 	ldw	r2,-12(fp)
81139894:	10801817 	ldw	r2,96(r2)
81139898:	e0bff815 	stw	r2,-32(fp)
8113989c:	e03ffc0d 	sth	zero,-16(fp)
811398a0:	e0bffc0b 	ldhu	r2,-16(fp)
811398a4:	e0fffc84 	addi	r3,fp,-14
811398a8:	180d883a 	mov	r6,r3
811398ac:	100b883a 	mov	r5,r2
811398b0:	e13ff817 	ldw	r4,-32(fp)
811398b4:	112fa680 	call	8112fa68 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811398b8:	0005303a 	rdctl	r2,status
811398bc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811398c0:	e0fffb17 	ldw	r3,-20(fp)
811398c4:	00bfff84 	movi	r2,-2
811398c8:	1884703a 	and	r2,r3,r2
811398cc:	1001703a 	wrctl	status,r2
  
  return context;
811398d0:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
811398d4:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811398d8:	e0bffd17 	ldw	r2,-12(fp)
811398dc:	10800317 	ldw	r2,12(r2)
811398e0:	10800104 	addi	r2,r2,4
811398e4:	00c00804 	movi	r3,32
811398e8:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
811398ec:	e0bffd17 	ldw	r2,-12(fp)
811398f0:	10800317 	ldw	r2,12(r2)
811398f4:	e0fffd17 	ldw	r3,-12(fp)
811398f8:	18c00317 	ldw	r3,12(r3)
811398fc:	18c00037 	ldwio	r3,0(r3)
81139900:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81139904:	e0bffe17 	ldw	r2,-8(fp)
81139908:	10001f26 	beq	r2,zero,81139988 <alt_msgdma_descriptor_sync_transfer+0x1ec>
8113990c:	e0bfff17 	ldw	r2,-4(fp)
81139910:	10001d1e 	bne	r2,zero,81139988 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81139914:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81139918:	00001106 	br	81139960 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
8113991c:	01000044 	movi	r4,1
81139920:	1127d1c0 	call	81127d1c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81139924:	e0bff10b 	ldhu	r2,-60(fp)
81139928:	1084e230 	cmpltui	r2,r2,5000
8113992c:	1000091e 	bne	r2,zero,81139954 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
81139930:	01204534 	movhi	r4,33044
81139934:	213f4904 	addi	r4,r4,-732
81139938:	113b9800 	call	8113b980 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8113993c:	e0bffd17 	ldw	r2,-12(fp)
81139940:	10801817 	ldw	r2,96(r2)
81139944:	1009883a 	mov	r4,r2
81139948:	112fdf00 	call	8112fdf0 <OSSemPost>
				
                return -ETIME;
8113994c:	00bff084 	movi	r2,-62
81139950:	00008f06 	br	81139b90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81139954:	e0bff10b 	ldhu	r2,-60(fp)
81139958:	10800044 	addi	r2,r2,1
8113995c:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81139960:	e0bffd17 	ldw	r2,-12(fp)
81139964:	10c00317 	ldw	r3,12(r2)
81139968:	e0bffd17 	ldw	r2,-12(fp)
8113996c:	10800417 	ldw	r2,16(r2)
81139970:	e1bffe17 	ldw	r6,-8(fp)
81139974:	100b883a 	mov	r5,r2
81139978:	1809883a 	mov	r4,r3
8113997c:	1138f100 	call	81138f10 <alt_msgdma_write_standard_descriptor>
81139980:	103fe61e 	bne	r2,zero,8113991c <__reset+0xfb11991c>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81139984:	00002706 	br	81139a24 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81139988:	e0bffe17 	ldw	r2,-8(fp)
8113998c:	10001f1e 	bne	r2,zero,81139a0c <alt_msgdma_descriptor_sync_transfer+0x270>
81139990:	e0bfff17 	ldw	r2,-4(fp)
81139994:	10001d26 	beq	r2,zero,81139a0c <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
81139998:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8113999c:	00001106 	br	811399e4 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811399a0:	01000044 	movi	r4,1
811399a4:	1127d1c0 	call	81127d1c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811399a8:	e0bff10b 	ldhu	r2,-60(fp)
811399ac:	1084e230 	cmpltui	r2,r2,5000
811399b0:	1000091e 	bne	r2,zero,811399d8 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
811399b4:	01204534 	movhi	r4,33044
811399b8:	213f5a04 	addi	r4,r4,-664
811399bc:	113b9800 	call	8113b980 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811399c0:	e0bffd17 	ldw	r2,-12(fp)
811399c4:	10801817 	ldw	r2,96(r2)
811399c8:	1009883a 	mov	r4,r2
811399cc:	112fdf00 	call	8112fdf0 <OSSemPost>
				
                return -ETIME;
811399d0:	00bff084 	movi	r2,-62
811399d4:	00006e06 	br	81139b90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
811399d8:	e0bff10b 	ldhu	r2,-60(fp)
811399dc:	10800044 	addi	r2,r2,1
811399e0:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811399e4:	e0bffd17 	ldw	r2,-12(fp)
811399e8:	10c00317 	ldw	r3,12(r2)
811399ec:	e0bffd17 	ldw	r2,-12(fp)
811399f0:	10800417 	ldw	r2,16(r2)
811399f4:	e1bfff17 	ldw	r6,-4(fp)
811399f8:	100b883a 	mov	r5,r2
811399fc:	1809883a 	mov	r4,r3
81139a00:	1138fac0 	call	81138fac <alt_msgdma_write_extended_descriptor>
81139a04:	103fe61e 	bne	r2,zero,811399a0 <__reset+0xfb1199a0>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81139a08:	00000606 	br	81139a24 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81139a0c:	e0bffd17 	ldw	r2,-12(fp)
81139a10:	10801817 	ldw	r2,96(r2)
81139a14:	1009883a 	mov	r4,r2
81139a18:	112fdf00 	call	8112fdf0 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81139a1c:	00bfffc4 	movi	r2,-1
81139a20:	00005b06 	br	81139b90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81139a24:	e0bffd17 	ldw	r2,-12(fp)
81139a28:	10800317 	ldw	r2,12(r2)
81139a2c:	10800104 	addi	r2,r2,4
81139a30:	e0fffd17 	ldw	r3,-12(fp)
81139a34:	19000d17 	ldw	r4,52(r3)
81139a38:	00fff2c4 	movi	r3,-53
81139a3c:	20c6703a 	and	r3,r4,r3
81139a40:	18c00114 	ori	r3,r3,4
81139a44:	10c00035 	stwio	r3,0(r2)
81139a48:	e0bff517 	ldw	r2,-44(fp)
81139a4c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139a50:	e0bff717 	ldw	r2,-36(fp)
81139a54:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81139a58:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81139a5c:	e0bffd17 	ldw	r2,-12(fp)
81139a60:	10800317 	ldw	r2,12(r2)
81139a64:	10800037 	ldwio	r2,0(r2)
81139a68:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81139a6c:	00001506 	br	81139ac4 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81139a70:	01000044 	movi	r4,1
81139a74:	1127d1c0 	call	81127d1c <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81139a78:	e0bff10b 	ldhu	r2,-60(fp)
81139a7c:	1084e230 	cmpltui	r2,r2,5000
81139a80:	1000091e 	bne	r2,zero,81139aa8 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81139a84:	01204534 	movhi	r4,33044
81139a88:	213f6b04 	addi	r4,r4,-596
81139a8c:	113b9800 	call	8113b980 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81139a90:	e0bffd17 	ldw	r2,-12(fp)
81139a94:	10801817 	ldw	r2,96(r2)
81139a98:	1009883a 	mov	r4,r2
81139a9c:	112fdf00 	call	8112fdf0 <OSSemPost>
			
            return -ETIME;
81139aa0:	00bff084 	movi	r2,-62
81139aa4:	00003a06 	br	81139b90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
81139aa8:	e0bff10b 	ldhu	r2,-60(fp)
81139aac:	10800044 	addi	r2,r2,1
81139ab0:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81139ab4:	e0bffd17 	ldw	r2,-12(fp)
81139ab8:	10800317 	ldw	r2,12(r2)
81139abc:	10800037 	ldwio	r2,0(r2)
81139ac0:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81139ac4:	e0fff017 	ldw	r3,-64(fp)
81139ac8:	e0bff617 	ldw	r2,-40(fp)
81139acc:	1884703a 	and	r2,r3,r2
81139ad0:	1000031e 	bne	r2,zero,81139ae0 <alt_msgdma_descriptor_sync_transfer+0x344>
81139ad4:	e0bff017 	ldw	r2,-64(fp)
81139ad8:	1080004c 	andi	r2,r2,1
81139adc:	103fe41e 	bne	r2,zero,81139a70 <__reset+0xfb119a70>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81139ae0:	e0fff017 	ldw	r3,-64(fp)
81139ae4:	e0bff617 	ldw	r2,-40(fp)
81139ae8:	1884703a 	and	r2,r3,r2
81139aec:	10000626 	beq	r2,zero,81139b08 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81139af0:	e0bffd17 	ldw	r2,-12(fp)
81139af4:	10801817 	ldw	r2,96(r2)
81139af8:	1009883a 	mov	r4,r2
81139afc:	112fdf00 	call	8112fdf0 <OSSemPost>
		
        return error;
81139b00:	e0bff617 	ldw	r2,-40(fp)
81139b04:	00002206 	br	81139b90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
81139b08:	e0bffd17 	ldw	r2,-12(fp)
81139b0c:	10800317 	ldw	r2,12(r2)
81139b10:	10800104 	addi	r2,r2,4
81139b14:	10800037 	ldwio	r2,0(r2)
81139b18:	10800814 	ori	r2,r2,32
81139b1c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139b20:	0005303a 	rdctl	r2,status
81139b24:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139b28:	e0fffa17 	ldw	r3,-24(fp)
81139b2c:	00bfff84 	movi	r2,-2
81139b30:	1884703a 	and	r2,r3,r2
81139b34:	1001703a 	wrctl	status,r2
  
  return context;
81139b38:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81139b3c:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81139b40:	e0bffd17 	ldw	r2,-12(fp)
81139b44:	10800317 	ldw	r2,12(r2)
81139b48:	10800104 	addi	r2,r2,4
81139b4c:	e0fff417 	ldw	r3,-48(fp)
81139b50:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81139b54:	e0bffd17 	ldw	r2,-12(fp)
81139b58:	10800317 	ldw	r2,12(r2)
81139b5c:	e0fffd17 	ldw	r3,-12(fp)
81139b60:	18c00317 	ldw	r3,12(r3)
81139b64:	18c00037 	ldwio	r3,0(r3)
81139b68:	10c00035 	stwio	r3,0(r2)
81139b6c:	e0bff517 	ldw	r2,-44(fp)
81139b70:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139b74:	e0bff917 	ldw	r2,-28(fp)
81139b78:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81139b7c:	e0bffd17 	ldw	r2,-12(fp)
81139b80:	10801817 	ldw	r2,96(r2)
81139b84:	1009883a 	mov	r4,r2
81139b88:	112fdf00 	call	8112fdf0 <OSSemPost>
    
    return 0;
81139b8c:	0005883a 	mov	r2,zero

}
81139b90:	e037883a 	mov	sp,fp
81139b94:	dfc00117 	ldw	ra,4(sp)
81139b98:	df000017 	ldw	fp,0(sp)
81139b9c:	dec00204 	addi	sp,sp,8
81139ba0:	f800283a 	ret

81139ba4 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81139ba4:	defff804 	addi	sp,sp,-32
81139ba8:	de00012e 	bgeu	sp,et,81139bb0 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81139bac:	003b68fa 	trap	3
81139bb0:	dfc00715 	stw	ra,28(sp)
81139bb4:	df000615 	stw	fp,24(sp)
81139bb8:	df000604 	addi	fp,sp,24
81139bbc:	e13ffc15 	stw	r4,-16(fp)
81139bc0:	e17ffd15 	stw	r5,-12(fp)
81139bc4:	e1bffe15 	stw	r6,-8(fp)
81139bc8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
81139bcc:	e0800217 	ldw	r2,8(fp)
81139bd0:	d8800115 	stw	r2,4(sp)
81139bd4:	e0bfff17 	ldw	r2,-4(fp)
81139bd8:	d8800015 	stw	r2,0(sp)
81139bdc:	e1fffe17 	ldw	r7,-8(fp)
81139be0:	000d883a 	mov	r6,zero
81139be4:	e17ffd17 	ldw	r5,-12(fp)
81139be8:	e13ffc17 	ldw	r4,-16(fp)
81139bec:	113926c0 	call	8113926c <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81139bf0:	e037883a 	mov	sp,fp
81139bf4:	dfc00117 	ldw	ra,4(sp)
81139bf8:	df000017 	ldw	fp,0(sp)
81139bfc:	dec00204 	addi	sp,sp,8
81139c00:	f800283a 	ret

81139c04 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81139c04:	defff804 	addi	sp,sp,-32
81139c08:	de00012e 	bgeu	sp,et,81139c10 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
81139c0c:	003b68fa 	trap	3
81139c10:	dfc00715 	stw	ra,28(sp)
81139c14:	df000615 	stw	fp,24(sp)
81139c18:	df000604 	addi	fp,sp,24
81139c1c:	e13ffc15 	stw	r4,-16(fp)
81139c20:	e17ffd15 	stw	r5,-12(fp)
81139c24:	e1bffe15 	stw	r6,-8(fp)
81139c28:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81139c2c:	e0800217 	ldw	r2,8(fp)
81139c30:	d8800115 	stw	r2,4(sp)
81139c34:	e0bfff17 	ldw	r2,-4(fp)
81139c38:	d8800015 	stw	r2,0(sp)
81139c3c:	000f883a 	mov	r7,zero
81139c40:	e1bffe17 	ldw	r6,-8(fp)
81139c44:	e17ffd17 	ldw	r5,-12(fp)
81139c48:	e13ffc17 	ldw	r4,-16(fp)
81139c4c:	113926c0 	call	8113926c <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
81139c50:	e037883a 	mov	sp,fp
81139c54:	dfc00117 	ldw	ra,4(sp)
81139c58:	df000017 	ldw	fp,0(sp)
81139c5c:	dec00204 	addi	sp,sp,8
81139c60:	f800283a 	ret

81139c64 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81139c64:	defff804 	addi	sp,sp,-32
81139c68:	de00012e 	bgeu	sp,et,81139c70 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81139c6c:	003b68fa 	trap	3
81139c70:	dfc00715 	stw	ra,28(sp)
81139c74:	df000615 	stw	fp,24(sp)
81139c78:	df000604 	addi	fp,sp,24
81139c7c:	e13ffc15 	stw	r4,-16(fp)
81139c80:	e17ffd15 	stw	r5,-12(fp)
81139c84:	e1bffe15 	stw	r6,-8(fp)
81139c88:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81139c8c:	e0800317 	ldw	r2,12(fp)
81139c90:	d8800115 	stw	r2,4(sp)
81139c94:	e0800217 	ldw	r2,8(fp)
81139c98:	d8800015 	stw	r2,0(sp)
81139c9c:	e1ffff17 	ldw	r7,-4(fp)
81139ca0:	e1bffe17 	ldw	r6,-8(fp)
81139ca4:	e17ffd17 	ldw	r5,-12(fp)
81139ca8:	e13ffc17 	ldw	r4,-16(fp)
81139cac:	113926c0 	call	8113926c <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81139cb0:	e037883a 	mov	sp,fp
81139cb4:	dfc00117 	ldw	ra,4(sp)
81139cb8:	df000017 	ldw	fp,0(sp)
81139cbc:	dec00204 	addi	sp,sp,8
81139cc0:	f800283a 	ret

81139cc4 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
81139cc4:	defff004 	addi	sp,sp,-64
81139cc8:	de00012e 	bgeu	sp,et,81139cd0 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
81139ccc:	003b68fa 	trap	3
81139cd0:	dfc00f15 	stw	ra,60(sp)
81139cd4:	df000e15 	stw	fp,56(sp)
81139cd8:	df000e04 	addi	fp,sp,56
81139cdc:	e13ff915 	stw	r4,-28(fp)
81139ce0:	e17ffa15 	stw	r5,-24(fp)
81139ce4:	e1bffb15 	stw	r6,-20(fp)
81139ce8:	e1fffc15 	stw	r7,-16(fp)
81139cec:	e1000317 	ldw	r4,12(fp)
81139cf0:	e0c00417 	ldw	r3,16(fp)
81139cf4:	e0800517 	ldw	r2,20(fp)
81139cf8:	e13ffd0d 	sth	r4,-12(fp)
81139cfc:	e0fffe05 	stb	r3,-8(fp)
81139d00:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81139d04:	e0bffd0b 	ldhu	r2,-12(fp)
81139d08:	e0fffe03 	ldbu	r3,-8(fp)
81139d0c:	e13fff0b 	ldhu	r4,-4(fp)
81139d10:	d9000615 	stw	r4,24(sp)
81139d14:	d8000515 	stw	zero,20(sp)
81139d18:	d8c00415 	stw	r3,16(sp)
81139d1c:	d8000315 	stw	zero,12(sp)
81139d20:	d8800215 	stw	r2,8(sp)
81139d24:	e0800217 	ldw	r2,8(fp)
81139d28:	d8800115 	stw	r2,4(sp)
81139d2c:	e0bffc17 	ldw	r2,-16(fp)
81139d30:	d8800015 	stw	r2,0(sp)
81139d34:	e1fffb17 	ldw	r7,-20(fp)
81139d38:	000d883a 	mov	r6,zero
81139d3c:	e17ffa17 	ldw	r5,-24(fp)
81139d40:	e13ff917 	ldw	r4,-28(fp)
81139d44:	11393000 	call	81139300 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
81139d48:	e037883a 	mov	sp,fp
81139d4c:	dfc00117 	ldw	ra,4(sp)
81139d50:	df000017 	ldw	fp,0(sp)
81139d54:	dec00204 	addi	sp,sp,8
81139d58:	f800283a 	ret

81139d5c <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81139d5c:	defff004 	addi	sp,sp,-64
81139d60:	de00012e 	bgeu	sp,et,81139d68 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81139d64:	003b68fa 	trap	3
81139d68:	dfc00f15 	stw	ra,60(sp)
81139d6c:	df000e15 	stw	fp,56(sp)
81139d70:	df000e04 	addi	fp,sp,56
81139d74:	e13ff915 	stw	r4,-28(fp)
81139d78:	e17ffa15 	stw	r5,-24(fp)
81139d7c:	e1bffb15 	stw	r6,-20(fp)
81139d80:	e1fffc15 	stw	r7,-16(fp)
81139d84:	e1000317 	ldw	r4,12(fp)
81139d88:	e0c00417 	ldw	r3,16(fp)
81139d8c:	e0800517 	ldw	r2,20(fp)
81139d90:	e13ffd0d 	sth	r4,-12(fp)
81139d94:	e0fffe05 	stb	r3,-8(fp)
81139d98:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81139d9c:	e0bffd0b 	ldhu	r2,-12(fp)
81139da0:	e0fffe03 	ldbu	r3,-8(fp)
81139da4:	e13fff0b 	ldhu	r4,-4(fp)
81139da8:	d8000615 	stw	zero,24(sp)
81139dac:	d9000515 	stw	r4,20(sp)
81139db0:	d8000415 	stw	zero,16(sp)
81139db4:	d8c00315 	stw	r3,12(sp)
81139db8:	d8800215 	stw	r2,8(sp)
81139dbc:	e0800217 	ldw	r2,8(fp)
81139dc0:	d8800115 	stw	r2,4(sp)
81139dc4:	e0bffc17 	ldw	r2,-16(fp)
81139dc8:	d8800015 	stw	r2,0(sp)
81139dcc:	000f883a 	mov	r7,zero
81139dd0:	e1bffb17 	ldw	r6,-20(fp)
81139dd4:	e17ffa17 	ldw	r5,-24(fp)
81139dd8:	e13ff917 	ldw	r4,-28(fp)
81139ddc:	11393000 	call	81139300 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
81139de0:	e037883a 	mov	sp,fp
81139de4:	dfc00117 	ldw	ra,4(sp)
81139de8:	df000017 	ldw	fp,0(sp)
81139dec:	dec00204 	addi	sp,sp,8
81139df0:	f800283a 	ret

81139df4 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
81139df4:	deffee04 	addi	sp,sp,-72
81139df8:	de00012e 	bgeu	sp,et,81139e00 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
81139dfc:	003b68fa 	trap	3
81139e00:	dfc01115 	stw	ra,68(sp)
81139e04:	df001015 	stw	fp,64(sp)
81139e08:	df001004 	addi	fp,sp,64
81139e0c:	e13ff715 	stw	r4,-36(fp)
81139e10:	e17ff815 	stw	r5,-32(fp)
81139e14:	e1bff915 	stw	r6,-28(fp)
81139e18:	e1fffa15 	stw	r7,-24(fp)
81139e1c:	e1800417 	ldw	r6,16(fp)
81139e20:	e1400517 	ldw	r5,20(fp)
81139e24:	e1000617 	ldw	r4,24(fp)
81139e28:	e0c00717 	ldw	r3,28(fp)
81139e2c:	e0800817 	ldw	r2,32(fp)
81139e30:	e1bffb0d 	sth	r6,-20(fp)
81139e34:	e17ffc05 	stb	r5,-16(fp)
81139e38:	e13ffd05 	stb	r4,-12(fp)
81139e3c:	e0fffe0d 	sth	r3,-8(fp)
81139e40:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81139e44:	e0bffb0b 	ldhu	r2,-20(fp)
81139e48:	e0fffc03 	ldbu	r3,-16(fp)
81139e4c:	e13ffd03 	ldbu	r4,-12(fp)
81139e50:	e17ffe0b 	ldhu	r5,-8(fp)
81139e54:	e1bfff0b 	ldhu	r6,-4(fp)
81139e58:	d9800615 	stw	r6,24(sp)
81139e5c:	d9400515 	stw	r5,20(sp)
81139e60:	d9000415 	stw	r4,16(sp)
81139e64:	d8c00315 	stw	r3,12(sp)
81139e68:	d8800215 	stw	r2,8(sp)
81139e6c:	e0800317 	ldw	r2,12(fp)
81139e70:	d8800115 	stw	r2,4(sp)
81139e74:	e0800217 	ldw	r2,8(fp)
81139e78:	d8800015 	stw	r2,0(sp)
81139e7c:	e1fffa17 	ldw	r7,-24(fp)
81139e80:	e1bff917 	ldw	r6,-28(fp)
81139e84:	e17ff817 	ldw	r5,-32(fp)
81139e88:	e13ff717 	ldw	r4,-36(fp)
81139e8c:	11393000 	call	81139300 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81139e90:	e037883a 	mov	sp,fp
81139e94:	dfc00117 	ldw	ra,4(sp)
81139e98:	df000017 	ldw	fp,0(sp)
81139e9c:	dec00204 	addi	sp,sp,8
81139ea0:	f800283a 	ret

81139ea4 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81139ea4:	defffb04 	addi	sp,sp,-20
81139ea8:	de00012e 	bgeu	sp,et,81139eb0 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81139eac:	003b68fa 	trap	3
81139eb0:	df000415 	stw	fp,16(sp)
81139eb4:	df000404 	addi	fp,sp,16
81139eb8:	e13ffc15 	stw	r4,-16(fp)
81139ebc:	e17ffd15 	stw	r5,-12(fp)
81139ec0:	e1bffe15 	stw	r6,-8(fp)
81139ec4:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81139ec8:	e0bffc17 	ldw	r2,-16(fp)
81139ecc:	10c01217 	ldw	r3,72(r2)
81139ed0:	e0800117 	ldw	r2,4(fp)
81139ed4:	18800436 	bltu	r3,r2,81139ee8 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
81139ed8:	e0bffc17 	ldw	r2,-16(fp)
81139edc:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81139ee0:	10803fcc 	andi	r2,r2,255
81139ee4:	10000226 	beq	r2,zero,81139ef0 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81139ee8:	00bffa84 	movi	r2,-22
81139eec:	00001406 	br	81139f40 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
81139ef0:	e0bffd17 	ldw	r2,-12(fp)
81139ef4:	e0fffe17 	ldw	r3,-8(fp)
81139ef8:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81139efc:	e0bffd17 	ldw	r2,-12(fp)
81139f00:	e0ffff17 	ldw	r3,-4(fp)
81139f04:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81139f08:	e0bffd17 	ldw	r2,-12(fp)
81139f0c:	e0c00117 	ldw	r3,4(fp)
81139f10:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81139f14:	e0fffd17 	ldw	r3,-12(fp)
81139f18:	e0bffd17 	ldw	r2,-12(fp)
81139f1c:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81139f20:	e0c00217 	ldw	r3,8(fp)
81139f24:	00900034 	movhi	r2,16384
81139f28:	10bfffc4 	addi	r2,r2,-1
81139f2c:	1884703a 	and	r2,r3,r2
81139f30:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81139f34:	e0bffd17 	ldw	r2,-12(fp)
81139f38:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81139f3c:	0005883a 	mov	r2,zero
}
81139f40:	e037883a 	mov	sp,fp
81139f44:	df000017 	ldw	fp,0(sp)
81139f48:	dec00104 	addi	sp,sp,4
81139f4c:	f800283a 	ret

81139f50 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81139f50:	defff404 	addi	sp,sp,-48
81139f54:	de00012e 	bgeu	sp,et,81139f5c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
81139f58:	003b68fa 	trap	3
81139f5c:	df000b15 	stw	fp,44(sp)
81139f60:	df000b04 	addi	fp,sp,44
81139f64:	e13ff715 	stw	r4,-36(fp)
81139f68:	e17ff815 	stw	r5,-32(fp)
81139f6c:	e1bff915 	stw	r6,-28(fp)
81139f70:	e1fffa15 	stw	r7,-24(fp)
81139f74:	e1800517 	ldw	r6,20(fp)
81139f78:	e1400617 	ldw	r5,24(fp)
81139f7c:	e1000717 	ldw	r4,28(fp)
81139f80:	e0c00817 	ldw	r3,32(fp)
81139f84:	e0800917 	ldw	r2,36(fp)
81139f88:	e1bffb0d 	sth	r6,-20(fp)
81139f8c:	e17ffc05 	stb	r5,-16(fp)
81139f90:	e13ffd05 	stb	r4,-12(fp)
81139f94:	e0fffe0d 	sth	r3,-8(fp)
81139f98:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81139f9c:	e0bff717 	ldw	r2,-36(fp)
81139fa0:	10c01217 	ldw	r3,72(r2)
81139fa4:	e0800317 	ldw	r2,12(fp)
81139fa8:	18801936 	bltu	r3,r2,8113a010 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81139fac:	e13ff717 	ldw	r4,-36(fp)
81139fb0:	20801317 	ldw	r2,76(r4)
81139fb4:	20c01417 	ldw	r3,80(r4)
81139fb8:	e13ffe0b 	ldhu	r4,-8(fp)
81139fbc:	213fffcc 	andi	r4,r4,65535
81139fc0:	2015883a 	mov	r10,r4
81139fc4:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81139fc8:	1ac01136 	bltu	r3,r11,8113a010 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81139fcc:	58c0011e 	bne	r11,r3,81139fd4 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
81139fd0:	12800f36 	bltu	r2,r10,8113a010 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81139fd4:	e13ff717 	ldw	r4,-36(fp)
81139fd8:	20801317 	ldw	r2,76(r4)
81139fdc:	20c01417 	ldw	r3,80(r4)
81139fe0:	e13fff0b 	ldhu	r4,-4(fp)
81139fe4:	213fffcc 	andi	r4,r4,65535
81139fe8:	2011883a 	mov	r8,r4
81139fec:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81139ff0:	1a400736 	bltu	r3,r9,8113a010 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81139ff4:	48c0011e 	bne	r9,r3,81139ffc <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
81139ff8:	12000536 	bltu	r2,r8,8113a010 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81139ffc:	e0bff717 	ldw	r2,-36(fp)
8113a000:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8113a004:	10803fcc 	andi	r2,r2,255
8113a008:	10800060 	cmpeqi	r2,r2,1
8113a00c:	1000021e 	bne	r2,zero,8113a018 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8113a010:	00bffa84 	movi	r2,-22
8113a014:	00003106 	br	8113a0dc <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
8113a018:	e0bff817 	ldw	r2,-32(fp)
8113a01c:	e0fff917 	ldw	r3,-28(fp)
8113a020:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
8113a024:	e0bff817 	ldw	r2,-32(fp)
8113a028:	e0fffa17 	ldw	r3,-24(fp)
8113a02c:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
8113a030:	e0bff817 	ldw	r2,-32(fp)
8113a034:	e0c00117 	ldw	r3,4(fp)
8113a038:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
8113a03c:	e0bff817 	ldw	r2,-32(fp)
8113a040:	e0c00217 	ldw	r3,8(fp)
8113a044:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8113a048:	e0bff817 	ldw	r2,-32(fp)
8113a04c:	e0c00317 	ldw	r3,12(fp)
8113a050:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8113a054:	e0bff817 	ldw	r2,-32(fp)
8113a058:	e0fffb0b 	ldhu	r3,-20(fp)
8113a05c:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
8113a060:	e0bff817 	ldw	r2,-32(fp)
8113a064:	e0fffc03 	ldbu	r3,-16(fp)
8113a068:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
8113a06c:	e0bff817 	ldw	r2,-32(fp)
8113a070:	e0fffd03 	ldbu	r3,-12(fp)
8113a074:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
8113a078:	e0bff817 	ldw	r2,-32(fp)
8113a07c:	e0fffe0b 	ldhu	r3,-8(fp)
8113a080:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
8113a084:	e0bff817 	ldw	r2,-32(fp)
8113a088:	e0ffff0b 	ldhu	r3,-4(fp)
8113a08c:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
8113a090:	e0bff817 	ldw	r2,-32(fp)
8113a094:	1019883a 	mov	r12,r2
8113a098:	001b883a 	mov	r13,zero
8113a09c:	e33ff515 	stw	r12,-44(fp)
8113a0a0:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
8113a0a4:	e0fff517 	ldw	r3,-44(fp)
8113a0a8:	e0bff817 	ldw	r2,-32(fp)
8113a0ac:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
8113a0b0:	e0fff617 	ldw	r3,-40(fp)
8113a0b4:	e0bff817 	ldw	r2,-32(fp)
8113a0b8:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8113a0bc:	e0c00417 	ldw	r3,16(fp)
8113a0c0:	00900034 	movhi	r2,16384
8113a0c4:	10bfffc4 	addi	r2,r2,-1
8113a0c8:	1884703a 	and	r2,r3,r2
8113a0cc:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
8113a0d0:	e0bff817 	ldw	r2,-32(fp)
8113a0d4:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
8113a0d8:	0005883a 	mov	r2,zero
}
8113a0dc:	e037883a 	mov	sp,fp
8113a0e0:	df000017 	ldw	fp,0(sp)
8113a0e4:	dec00104 	addi	sp,sp,4
8113a0e8:	f800283a 	ret

8113a0ec <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
8113a0ec:	defff804 	addi	sp,sp,-32
8113a0f0:	de00012e 	bgeu	sp,et,8113a0f8 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
8113a0f4:	003b68fa 	trap	3
8113a0f8:	dfc00715 	stw	ra,28(sp)
8113a0fc:	df000615 	stw	fp,24(sp)
8113a100:	df000604 	addi	fp,sp,24
8113a104:	e13ffc15 	stw	r4,-16(fp)
8113a108:	e17ffd15 	stw	r5,-12(fp)
8113a10c:	e1bffe15 	stw	r6,-8(fp)
8113a110:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8113a114:	e0800317 	ldw	r2,12(fp)
8113a118:	d8800115 	stw	r2,4(sp)
8113a11c:	e0800217 	ldw	r2,8(fp)
8113a120:	d8800015 	stw	r2,0(sp)
8113a124:	e1ffff17 	ldw	r7,-4(fp)
8113a128:	e1bffe17 	ldw	r6,-8(fp)
8113a12c:	e17ffd17 	ldw	r5,-12(fp)
8113a130:	e13ffc17 	ldw	r4,-16(fp)
8113a134:	1139ea40 	call	81139ea4 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
8113a138:	e037883a 	mov	sp,fp
8113a13c:	dfc00117 	ldw	ra,4(sp)
8113a140:	df000017 	ldw	fp,0(sp)
8113a144:	dec00204 	addi	sp,sp,8
8113a148:	f800283a 	ret

8113a14c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113a14c:	defff804 	addi	sp,sp,-32
8113a150:	de00012e 	bgeu	sp,et,8113a158 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
8113a154:	003b68fa 	trap	3
8113a158:	dfc00715 	stw	ra,28(sp)
8113a15c:	df000615 	stw	fp,24(sp)
8113a160:	df000604 	addi	fp,sp,24
8113a164:	e13ffc15 	stw	r4,-16(fp)
8113a168:	e17ffd15 	stw	r5,-12(fp)
8113a16c:	e1bffe15 	stw	r6,-8(fp)
8113a170:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8113a174:	e0800217 	ldw	r2,8(fp)
8113a178:	d8800115 	stw	r2,4(sp)
8113a17c:	e0bfff17 	ldw	r2,-4(fp)
8113a180:	d8800015 	stw	r2,0(sp)
8113a184:	e1fffe17 	ldw	r7,-8(fp)
8113a188:	000d883a 	mov	r6,zero
8113a18c:	e17ffd17 	ldw	r5,-12(fp)
8113a190:	e13ffc17 	ldw	r4,-16(fp)
8113a194:	1139ea40 	call	81139ea4 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
8113a198:	e037883a 	mov	sp,fp
8113a19c:	dfc00117 	ldw	ra,4(sp)
8113a1a0:	df000017 	ldw	fp,0(sp)
8113a1a4:	dec00204 	addi	sp,sp,8
8113a1a8:	f800283a 	ret

8113a1ac <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113a1ac:	defff804 	addi	sp,sp,-32
8113a1b0:	de00012e 	bgeu	sp,et,8113a1b8 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
8113a1b4:	003b68fa 	trap	3
8113a1b8:	dfc00715 	stw	ra,28(sp)
8113a1bc:	df000615 	stw	fp,24(sp)
8113a1c0:	df000604 	addi	fp,sp,24
8113a1c4:	e13ffc15 	stw	r4,-16(fp)
8113a1c8:	e17ffd15 	stw	r5,-12(fp)
8113a1cc:	e1bffe15 	stw	r6,-8(fp)
8113a1d0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8113a1d4:	e0800217 	ldw	r2,8(fp)
8113a1d8:	d8800115 	stw	r2,4(sp)
8113a1dc:	e0bfff17 	ldw	r2,-4(fp)
8113a1e0:	d8800015 	stw	r2,0(sp)
8113a1e4:	000f883a 	mov	r7,zero
8113a1e8:	e1bffe17 	ldw	r6,-8(fp)
8113a1ec:	e17ffd17 	ldw	r5,-12(fp)
8113a1f0:	e13ffc17 	ldw	r4,-16(fp)
8113a1f4:	1139ea40 	call	81139ea4 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
8113a1f8:	e037883a 	mov	sp,fp
8113a1fc:	dfc00117 	ldw	ra,4(sp)
8113a200:	df000017 	ldw	fp,0(sp)
8113a204:	dec00204 	addi	sp,sp,8
8113a208:	f800283a 	ret

8113a20c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
8113a20c:	deffee04 	addi	sp,sp,-72
8113a210:	de00012e 	bgeu	sp,et,8113a218 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
8113a214:	003b68fa 	trap	3
8113a218:	dfc01115 	stw	ra,68(sp)
8113a21c:	df001015 	stw	fp,64(sp)
8113a220:	df001004 	addi	fp,sp,64
8113a224:	e13ff915 	stw	r4,-28(fp)
8113a228:	e17ffa15 	stw	r5,-24(fp)
8113a22c:	e1bffb15 	stw	r6,-20(fp)
8113a230:	e1fffc15 	stw	r7,-16(fp)
8113a234:	e1000417 	ldw	r4,16(fp)
8113a238:	e0c00517 	ldw	r3,20(fp)
8113a23c:	e0800617 	ldw	r2,24(fp)
8113a240:	e13ffd0d 	sth	r4,-12(fp)
8113a244:	e0fffe05 	stb	r3,-8(fp)
8113a248:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
8113a24c:	e0bffd0b 	ldhu	r2,-12(fp)
8113a250:	e0fffe03 	ldbu	r3,-8(fp)
8113a254:	e13fff0b 	ldhu	r4,-4(fp)
8113a258:	d9000815 	stw	r4,32(sp)
8113a25c:	d8000715 	stw	zero,28(sp)
8113a260:	d8c00615 	stw	r3,24(sp)
8113a264:	d8000515 	stw	zero,20(sp)
8113a268:	d8800415 	stw	r2,16(sp)
8113a26c:	e0800317 	ldw	r2,12(fp)
8113a270:	d8800315 	stw	r2,12(sp)
8113a274:	e0800217 	ldw	r2,8(fp)
8113a278:	d8800215 	stw	r2,8(sp)
8113a27c:	e0bffc17 	ldw	r2,-16(fp)
8113a280:	d8800115 	stw	r2,4(sp)
8113a284:	e0bffb17 	ldw	r2,-20(fp)
8113a288:	d8800015 	stw	r2,0(sp)
8113a28c:	000f883a 	mov	r7,zero
8113a290:	000d883a 	mov	r6,zero
8113a294:	e17ffa17 	ldw	r5,-24(fp)
8113a298:	e13ff917 	ldw	r4,-28(fp)
8113a29c:	1139f500 	call	81139f50 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
8113a2a0:	e037883a 	mov	sp,fp
8113a2a4:	dfc00117 	ldw	ra,4(sp)
8113a2a8:	df000017 	ldw	fp,0(sp)
8113a2ac:	dec00204 	addi	sp,sp,8
8113a2b0:	f800283a 	ret

8113a2b4 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8113a2b4:	deffee04 	addi	sp,sp,-72
8113a2b8:	de00012e 	bgeu	sp,et,8113a2c0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
8113a2bc:	003b68fa 	trap	3
8113a2c0:	dfc01115 	stw	ra,68(sp)
8113a2c4:	df001015 	stw	fp,64(sp)
8113a2c8:	df001004 	addi	fp,sp,64
8113a2cc:	e13ff915 	stw	r4,-28(fp)
8113a2d0:	e17ffa15 	stw	r5,-24(fp)
8113a2d4:	e1bffb15 	stw	r6,-20(fp)
8113a2d8:	e1fffc15 	stw	r7,-16(fp)
8113a2dc:	e1000417 	ldw	r4,16(fp)
8113a2e0:	e0c00517 	ldw	r3,20(fp)
8113a2e4:	e0800617 	ldw	r2,24(fp)
8113a2e8:	e13ffd0d 	sth	r4,-12(fp)
8113a2ec:	e0fffe05 	stb	r3,-8(fp)
8113a2f0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8113a2f4:	e0bffd0b 	ldhu	r2,-12(fp)
8113a2f8:	e0fffe03 	ldbu	r3,-8(fp)
8113a2fc:	e13fff0b 	ldhu	r4,-4(fp)
8113a300:	d8000815 	stw	zero,32(sp)
8113a304:	d9000715 	stw	r4,28(sp)
8113a308:	d8000615 	stw	zero,24(sp)
8113a30c:	d8c00515 	stw	r3,20(sp)
8113a310:	d8800415 	stw	r2,16(sp)
8113a314:	e0800317 	ldw	r2,12(fp)
8113a318:	d8800315 	stw	r2,12(sp)
8113a31c:	e0800217 	ldw	r2,8(fp)
8113a320:	d8800215 	stw	r2,8(sp)
8113a324:	d8000115 	stw	zero,4(sp)
8113a328:	d8000015 	stw	zero,0(sp)
8113a32c:	e1fffc17 	ldw	r7,-16(fp)
8113a330:	e1bffb17 	ldw	r6,-20(fp)
8113a334:	e17ffa17 	ldw	r5,-24(fp)
8113a338:	e13ff917 	ldw	r4,-28(fp)
8113a33c:	1139f500 	call	81139f50 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
8113a340:	e037883a 	mov	sp,fp
8113a344:	dfc00117 	ldw	ra,4(sp)
8113a348:	df000017 	ldw	fp,0(sp)
8113a34c:	dec00204 	addi	sp,sp,8
8113a350:	f800283a 	ret

8113a354 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8113a354:	deffec04 	addi	sp,sp,-80
8113a358:	de00012e 	bgeu	sp,et,8113a360 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
8113a35c:	003b68fa 	trap	3
8113a360:	dfc01315 	stw	ra,76(sp)
8113a364:	df001215 	stw	fp,72(sp)
8113a368:	df001204 	addi	fp,sp,72
8113a36c:	e13ff715 	stw	r4,-36(fp)
8113a370:	e17ff815 	stw	r5,-32(fp)
8113a374:	e1bff915 	stw	r6,-28(fp)
8113a378:	e1fffa15 	stw	r7,-24(fp)
8113a37c:	e1800617 	ldw	r6,24(fp)
8113a380:	e1400717 	ldw	r5,28(fp)
8113a384:	e1000817 	ldw	r4,32(fp)
8113a388:	e0c00917 	ldw	r3,36(fp)
8113a38c:	e0800a17 	ldw	r2,40(fp)
8113a390:	e1bffb0d 	sth	r6,-20(fp)
8113a394:	e17ffc05 	stb	r5,-16(fp)
8113a398:	e13ffd05 	stb	r4,-12(fp)
8113a39c:	e0fffe0d 	sth	r3,-8(fp)
8113a3a0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8113a3a4:	e0bffb0b 	ldhu	r2,-20(fp)
8113a3a8:	e0fffc03 	ldbu	r3,-16(fp)
8113a3ac:	e13ffd03 	ldbu	r4,-12(fp)
8113a3b0:	e17ffe0b 	ldhu	r5,-8(fp)
8113a3b4:	e1bfff0b 	ldhu	r6,-4(fp)
8113a3b8:	d9800815 	stw	r6,32(sp)
8113a3bc:	d9400715 	stw	r5,28(sp)
8113a3c0:	d9000615 	stw	r4,24(sp)
8113a3c4:	d8c00515 	stw	r3,20(sp)
8113a3c8:	d8800415 	stw	r2,16(sp)
8113a3cc:	e0800517 	ldw	r2,20(fp)
8113a3d0:	d8800315 	stw	r2,12(sp)
8113a3d4:	e0800417 	ldw	r2,16(fp)
8113a3d8:	d8800215 	stw	r2,8(sp)
8113a3dc:	e0800317 	ldw	r2,12(fp)
8113a3e0:	d8800115 	stw	r2,4(sp)
8113a3e4:	e0800217 	ldw	r2,8(fp)
8113a3e8:	d8800015 	stw	r2,0(sp)
8113a3ec:	e1fffa17 	ldw	r7,-24(fp)
8113a3f0:	e1bff917 	ldw	r6,-28(fp)
8113a3f4:	e17ff817 	ldw	r5,-32(fp)
8113a3f8:	e13ff717 	ldw	r4,-36(fp)
8113a3fc:	1139f500 	call	81139f50 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
8113a400:	e037883a 	mov	sp,fp
8113a404:	dfc00117 	ldw	ra,4(sp)
8113a408:	df000017 	ldw	fp,0(sp)
8113a40c:	dec00204 	addi	sp,sp,8
8113a410:	f800283a 	ret

8113a414 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
8113a414:	defffc04 	addi	sp,sp,-16
8113a418:	de00012e 	bgeu	sp,et,8113a420 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
8113a41c:	003b68fa 	trap	3
8113a420:	df000315 	stw	fp,12(sp)
8113a424:	df000304 	addi	fp,sp,12
8113a428:	e13ffe15 	stw	r4,-8(fp)
8113a42c:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
8113a430:	e0bfff17 	ldw	r2,-4(fp)
8113a434:	1000021e 	bne	r2,zero,8113a440 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8113a438:	00bffa84 	movi	r2,-22
8113a43c:	00002f06 	br	8113a4fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
8113a440:	e0bfff17 	ldw	r2,-4(fp)
8113a444:	10c00317 	ldw	r3,12(r2)
8113a448:	e0bfff17 	ldw	r2,-4(fp)
8113a44c:	18800226 	beq	r3,r2,8113a458 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8113a450:	00bffa84 	movi	r2,-22
8113a454:	00002906 	br	8113a4fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
8113a458:	e0bffe17 	ldw	r2,-8(fp)
8113a45c:	10800017 	ldw	r2,0(r2)
8113a460:	1000051e 	bne	r2,zero,8113a478 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
8113a464:	e0bffe17 	ldw	r2,-8(fp)
8113a468:	e0ffff17 	ldw	r3,-4(fp)
8113a46c:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
8113a470:	0005883a 	mov	r2,zero
8113a474:	00002106 	br	8113a4fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
8113a478:	e0bffe17 	ldw	r2,-8(fp)
8113a47c:	10c00017 	ldw	r3,0(r2)
8113a480:	e0bfff17 	ldw	r2,-4(fp)
8113a484:	1880021e 	bne	r3,r2,8113a490 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8113a488:	00bffa84 	movi	r2,-22
8113a48c:	00001b06 	br	8113a4fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8113a490:	e0bffe17 	ldw	r2,-8(fp)
8113a494:	10800017 	ldw	r2,0(r2)
8113a498:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8113a49c:	00000906 	br	8113a4c4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
8113a4a0:	e0bffd17 	ldw	r2,-12(fp)
8113a4a4:	10c00317 	ldw	r3,12(r2)
8113a4a8:	e0bfff17 	ldw	r2,-4(fp)
8113a4ac:	1880021e 	bne	r3,r2,8113a4b8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8113a4b0:	00bffa84 	movi	r2,-22
8113a4b4:	00001106 	br	8113a4fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8113a4b8:	e0bffd17 	ldw	r2,-12(fp)
8113a4bc:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
8113a4c0:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8113a4c4:	e0bffd17 	ldw	r2,-12(fp)
8113a4c8:	10800317 	ldw	r2,12(r2)
8113a4cc:	e0fffe17 	ldw	r3,-8(fp)
8113a4d0:	18c00017 	ldw	r3,0(r3)
8113a4d4:	10fff21e 	bne	r2,r3,8113a4a0 <__reset+0xfb11a4a0>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8113a4d8:	e0ffff17 	ldw	r3,-4(fp)
8113a4dc:	e0bffd17 	ldw	r2,-12(fp)
8113a4e0:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
8113a4e4:	e0bffe17 	ldw	r2,-8(fp)
8113a4e8:	10800017 	ldw	r2,0(r2)
8113a4ec:	1007883a 	mov	r3,r2
8113a4f0:	e0bfff17 	ldw	r2,-4(fp)
8113a4f4:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
8113a4f8:	0005883a 	mov	r2,zero
}
8113a4fc:	e037883a 	mov	sp,fp
8113a500:	df000017 	ldw	fp,0(sp)
8113a504:	dec00104 	addi	sp,sp,4
8113a508:	f800283a 	ret

8113a50c <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
8113a50c:	defff804 	addi	sp,sp,-32
8113a510:	de00012e 	bgeu	sp,et,8113a518 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
8113a514:	003b68fa 	trap	3
8113a518:	df000715 	stw	fp,28(sp)
8113a51c:	df000704 	addi	fp,sp,28
8113a520:	e13ffe15 	stw	r4,-8(fp)
8113a524:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
8113a528:	e13fff17 	ldw	r4,-4(fp)
8113a52c:	2000021e 	bne	r4,zero,8113a538 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8113a530:	00bffa84 	movi	r2,-22
8113a534:	00005906 	br	8113a69c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
8113a538:	e13fff17 	ldw	r4,-4(fp)
8113a53c:	2015883a 	mov	r10,r4
8113a540:	0017883a 	mov	r11,zero
8113a544:	e2bffc15 	stw	r10,-16(fp)
8113a548:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8113a54c:	e13fff17 	ldw	r4,-4(fp)
8113a550:	21400317 	ldw	r5,12(r4)
8113a554:	e13ffc17 	ldw	r4,-16(fp)
8113a558:	29000626 	beq	r5,r4,8113a574 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
8113a55c:	e13fff17 	ldw	r4,-4(fp)
8113a560:	21400b17 	ldw	r5,44(r4)
8113a564:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8113a568:	29000226 	beq	r5,r4,8113a574 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8113a56c:	00bffa84 	movi	r2,-22
8113a570:	00004a06 	br	8113a69c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
8113a574:	e13ffe17 	ldw	r4,-8(fp)
8113a578:	21000017 	ldw	r4,0(r4)
8113a57c:	2000051e 	bne	r4,zero,8113a594 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
8113a580:	e0bffe17 	ldw	r2,-8(fp)
8113a584:	e0ffff17 	ldw	r3,-4(fp)
8113a588:	10c00015 	stw	r3,0(r2)
		return 0;
8113a58c:	0005883a 	mov	r2,zero
8113a590:	00004206 	br	8113a69c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
8113a594:	e13ffe17 	ldw	r4,-8(fp)
8113a598:	21400017 	ldw	r5,0(r4)
8113a59c:	e13fff17 	ldw	r4,-4(fp)
8113a5a0:	2900021e 	bne	r5,r4,8113a5ac <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8113a5a4:	00bffa84 	movi	r2,-22
8113a5a8:	00003c06 	br	8113a69c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8113a5ac:	e13ffe17 	ldw	r4,-8(fp)
8113a5b0:	21000017 	ldw	r4,0(r4)
8113a5b4:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
8113a5b8:	e13ffe17 	ldw	r4,-8(fp)
8113a5bc:	21000017 	ldw	r4,0(r4)
8113a5c0:	2011883a 	mov	r8,r4
8113a5c4:	0013883a 	mov	r9,zero
8113a5c8:	e23ffa15 	stw	r8,-24(fp)
8113a5cc:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113a5d0:	00001806 	br	8113a634 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
8113a5d4:	e13fff17 	ldw	r4,-4(fp)
8113a5d8:	200d883a 	mov	r6,r4
8113a5dc:	000f883a 	mov	r7,zero
8113a5e0:	e1bffc15 	stw	r6,-16(fp)
8113a5e4:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8113a5e8:	e13ff917 	ldw	r4,-28(fp)
8113a5ec:	21400317 	ldw	r5,12(r4)
8113a5f0:	e13ffc17 	ldw	r4,-16(fp)
8113a5f4:	2900061e 	bne	r5,r4,8113a610 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
8113a5f8:	e13ff917 	ldw	r4,-28(fp)
8113a5fc:	21400b17 	ldw	r5,44(r4)
8113a600:	e13ffd17 	ldw	r4,-12(fp)
8113a604:	2900021e 	bne	r5,r4,8113a610 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8113a608:	00bffa84 	movi	r2,-22
8113a60c:	00002306 	br	8113a69c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8113a610:	e13ff917 	ldw	r4,-28(fp)
8113a614:	21000317 	ldw	r4,12(r4)
8113a618:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8113a61c:	e13ff917 	ldw	r4,-28(fp)
8113a620:	21000b17 	ldw	r4,44(r4)
8113a624:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8113a628:	e13ffc17 	ldw	r4,-16(fp)
8113a62c:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8113a630:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113a634:	e13ff917 	ldw	r4,-28(fp)
8113a638:	21400317 	ldw	r5,12(r4)
8113a63c:	e13ffa17 	ldw	r4,-24(fp)
8113a640:	29000426 	beq	r5,r4,8113a654 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8113a644:	e13ff917 	ldw	r4,-28(fp)
8113a648:	21400b17 	ldw	r5,44(r4)
8113a64c:	e13ffb17 	ldw	r4,-20(fp)
8113a650:	293fe01e 	bne	r5,r4,8113a5d4 <__reset+0xfb11a5d4>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
8113a654:	e13fff17 	ldw	r4,-4(fp)
8113a658:	2005883a 	mov	r2,r4
8113a65c:	0007883a 	mov	r3,zero
8113a660:	e0bffc15 	stw	r2,-16(fp)
8113a664:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
8113a668:	e0fffc17 	ldw	r3,-16(fp)
8113a66c:	e0bff917 	ldw	r2,-28(fp)
8113a670:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
8113a674:	e0fffd17 	ldw	r3,-12(fp)
8113a678:	e0bff917 	ldw	r2,-28(fp)
8113a67c:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
8113a680:	e0fffa17 	ldw	r3,-24(fp)
8113a684:	e0bfff17 	ldw	r2,-4(fp)
8113a688:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
8113a68c:	e0fffb17 	ldw	r3,-20(fp)
8113a690:	e0bfff17 	ldw	r2,-4(fp)
8113a694:	10c00b15 	stw	r3,44(r2)
	return 0;
8113a698:	0005883a 	mov	r2,zero
}
8113a69c:	e037883a 	mov	sp,fp
8113a6a0:	df000017 	ldw	fp,0(sp)
8113a6a4:	dec00104 	addi	sp,sp,4
8113a6a8:	f800283a 	ret

8113a6ac <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
8113a6ac:	defffc04 	addi	sp,sp,-16
8113a6b0:	de00012e 	bgeu	sp,et,8113a6b8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
8113a6b4:	003b68fa 	trap	3
8113a6b8:	df000315 	stw	fp,12(sp)
8113a6bc:	df000304 	addi	fp,sp,12
8113a6c0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8113a6c4:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8113a6c8:	e0bfff17 	ldw	r2,-4(fp)
8113a6cc:	1000021e 	bne	r2,zero,8113a6d8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8113a6d0:	00bffa84 	movi	r2,-22
8113a6d4:	00001906 	br	8113a73c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8113a6d8:	e0bfff17 	ldw	r2,-4(fp)
8113a6dc:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8113a6e0:	00000a06 	br	8113a70c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
8113a6e4:	e0bffd17 	ldw	r2,-12(fp)
8113a6e8:	10800717 	ldw	r2,28(r2)
8113a6ec:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113a6f0:	e0bffe17 	ldw	r2,-8(fp)
8113a6f4:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8113a6f8:	e0bffd17 	ldw	r2,-12(fp)
8113a6fc:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8113a700:	e0bffd17 	ldw	r2,-12(fp)
8113a704:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
8113a708:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8113a70c:	e0bffd17 	ldw	r2,-12(fp)
8113a710:	10c00317 	ldw	r3,12(r2)
8113a714:	e0bfff17 	ldw	r2,-4(fp)
8113a718:	18bff21e 	bne	r3,r2,8113a6e4 <__reset+0xfb11a6e4>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
8113a71c:	e0bffd17 	ldw	r2,-12(fp)
8113a720:	10800717 	ldw	r2,28(r2)
8113a724:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113a728:	e0bffe17 	ldw	r2,-8(fp)
8113a72c:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8113a730:	e0bffd17 	ldw	r2,-12(fp)
8113a734:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
8113a738:	0005883a 	mov	r2,zero
}
8113a73c:	e037883a 	mov	sp,fp
8113a740:	df000017 	ldw	fp,0(sp)
8113a744:	dec00104 	addi	sp,sp,4
8113a748:	f800283a 	ret

8113a74c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
8113a74c:	defff804 	addi	sp,sp,-32
8113a750:	de00012e 	bgeu	sp,et,8113a758 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
8113a754:	003b68fa 	trap	3
8113a758:	df000715 	stw	fp,28(sp)
8113a75c:	df000704 	addi	fp,sp,28
8113a760:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8113a764:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
8113a768:	e13fff17 	ldw	r4,-4(fp)
8113a76c:	2000021e 	bne	r4,zero,8113a778 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8113a770:	00bffa84 	movi	r2,-22
8113a774:	00002806 	br	8113a818 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8113a778:	e13fff17 	ldw	r4,-4(fp)
8113a77c:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
8113a780:	e13fff17 	ldw	r4,-4(fp)
8113a784:	2005883a 	mov	r2,r4
8113a788:	0007883a 	mov	r3,zero
8113a78c:	e0bffb15 	stw	r2,-20(fp)
8113a790:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113a794:	00001006 	br	8113a7d8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
8113a798:	e0bff917 	ldw	r2,-28(fp)
8113a79c:	10800f17 	ldw	r2,60(r2)
8113a7a0:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113a7a4:	e0bffa17 	ldw	r2,-24(fp)
8113a7a8:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8113a7ac:	e0bff917 	ldw	r2,-28(fp)
8113a7b0:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8113a7b4:	e0bff917 	ldw	r2,-28(fp)
8113a7b8:	10800317 	ldw	r2,12(r2)
8113a7bc:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8113a7c0:	e0bff917 	ldw	r2,-28(fp)
8113a7c4:	10800b17 	ldw	r2,44(r2)
8113a7c8:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8113a7cc:	e0bffd17 	ldw	r2,-12(fp)
8113a7d0:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8113a7d4:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113a7d8:	e0bff917 	ldw	r2,-28(fp)
8113a7dc:	10c00317 	ldw	r3,12(r2)
8113a7e0:	e0bffb17 	ldw	r2,-20(fp)
8113a7e4:	18800426 	beq	r3,r2,8113a7f8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8113a7e8:	e0bff917 	ldw	r2,-28(fp)
8113a7ec:	10c00b17 	ldw	r3,44(r2)
8113a7f0:	e0bffc17 	ldw	r2,-16(fp)
8113a7f4:	18bfe81e 	bne	r3,r2,8113a798 <__reset+0xfb11a798>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8113a7f8:	e0bff917 	ldw	r2,-28(fp)
8113a7fc:	10800f17 	ldw	r2,60(r2)
8113a800:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113a804:	e0bffa17 	ldw	r2,-24(fp)
8113a808:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8113a80c:	e0bff917 	ldw	r2,-28(fp)
8113a810:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
8113a814:	0005883a 	mov	r2,zero
}
8113a818:	e037883a 	mov	sp,fp
8113a81c:	df000017 	ldw	fp,0(sp)
8113a820:	dec00104 	addi	sp,sp,4
8113a824:	f800283a 	ret

8113a828 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8113a828:	deffeb04 	addi	sp,sp,-84
8113a82c:	de00012e 	bgeu	sp,et,8113a834 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
8113a830:	003b68fa 	trap	3
8113a834:	dfc01415 	stw	ra,80(sp)
8113a838:	df001315 	stw	fp,76(sp)
8113a83c:	df001304 	addi	fp,sp,76
8113a840:	e13ffb15 	stw	r4,-20(fp)
8113a844:	e17ffc15 	stw	r5,-16(fp)
8113a848:	e1bffd15 	stw	r6,-12(fp)
8113a84c:	3807883a 	mov	r3,r7
8113a850:	e0800217 	ldw	r2,8(fp)
8113a854:	e0fffe05 	stb	r3,-8(fp)
8113a858:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
8113a85c:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
8113a860:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
8113a864:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8113a868:	e0bffc17 	ldw	r2,-16(fp)
8113a86c:	e0bff815 	stw	r2,-32(fp)
8113a870:	e0bffd17 	ldw	r2,-12(fp)
8113a874:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8113a878:	e0bffb17 	ldw	r2,-20(fp)
8113a87c:	10801817 	ldw	r2,96(r2)
8113a880:	e0bff615 	stw	r2,-40(fp)
8113a884:	e03ff70d 	sth	zero,-36(fp)
8113a888:	e0bff70b 	ldhu	r2,-36(fp)
8113a88c:	e0fffa04 	addi	r3,fp,-24
8113a890:	180d883a 	mov	r6,r3
8113a894:	100b883a 	mov	r5,r2
8113a898:	e13ff617 	ldw	r4,-40(fp)
8113a89c:	112fa680 	call	8112fa68 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
8113a8a0:	e0bffb17 	ldw	r2,-20(fp)
8113a8a4:	10800617 	ldw	r2,24(r2)
8113a8a8:	10800037 	ldwio	r2,0(r2)
8113a8ac:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
8113a8b0:	e0bfed17 	ldw	r2,-76(fp)
8113a8b4:	1080004c 	andi	r2,r2,1
8113a8b8:	10000626 	beq	r2,zero,8113a8d4 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
8113a8bc:	e0bffb17 	ldw	r2,-20(fp)
8113a8c0:	10801817 	ldw	r2,96(r2)
8113a8c4:	1009883a 	mov	r4,r2
8113a8c8:	112fdf00 	call	8112fdf0 <OSSemPost>
		return -EBUSY;
8113a8cc:	00bffc04 	movi	r2,-16
8113a8d0:	00009606 	br	8113ab2c <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8113a8d4:	00800804 	movi	r2,32
8113a8d8:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a8dc:	0005303a 	rdctl	r2,status
8113a8e0:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a8e4:	e0fff217 	ldw	r3,-56(fp)
8113a8e8:	00bfff84 	movi	r2,-2
8113a8ec:	1884703a 	and	r2,r3,r2
8113a8f0:	1001703a 	wrctl	status,r2
  
  return context;
8113a8f4:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8113a8f8:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8113a8fc:	e0bffb17 	ldw	r2,-20(fp)
8113a900:	10800317 	ldw	r2,12(r2)
8113a904:	10800104 	addi	r2,r2,4
8113a908:	e0ffee17 	ldw	r3,-72(fp)
8113a90c:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
8113a910:	e0bffb17 	ldw	r2,-20(fp)
8113a914:	10800317 	ldw	r2,12(r2)
8113a918:	e0fffb17 	ldw	r3,-20(fp)
8113a91c:	18c00317 	ldw	r3,12(r3)
8113a920:	18c00037 	ldwio	r3,0(r3)
8113a924:	10c00035 	stwio	r3,0(r2)
8113a928:	e0bfef17 	ldw	r2,-68(fp)
8113a92c:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a930:	e0bff017 	ldw	r2,-64(fp)
8113a934:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
8113a938:	e0bffb17 	ldw	r2,-20(fp)
8113a93c:	10800b17 	ldw	r2,44(r2)
8113a940:	10002326 	beq	r2,zero,8113a9d0 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
8113a944:	e0bffb17 	ldw	r2,-20(fp)
8113a948:	10c00d17 	ldw	r3,52(r2)
8113a94c:	e0bfee17 	ldw	r2,-72(fp)
8113a950:	1884b03a 	or	r2,r3,r2
8113a954:	10800514 	ori	r2,r2,20
8113a958:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8113a95c:	e0ffee17 	ldw	r3,-72(fp)
8113a960:	00bff7c4 	movi	r2,-33
8113a964:	1884703a 	and	r2,r3,r2
8113a968:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8113a96c:	e0bfed17 	ldw	r2,-76(fp)
8113a970:	10800214 	ori	r2,r2,8
8113a974:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a978:	0005303a 	rdctl	r2,status
8113a97c:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a980:	e0fff417 	ldw	r3,-48(fp)
8113a984:	00bfff84 	movi	r2,-2
8113a988:	1884703a 	and	r2,r3,r2
8113a98c:	1001703a 	wrctl	status,r2
  
  return context;
8113a990:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
8113a994:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8113a998:	e0bffb17 	ldw	r2,-20(fp)
8113a99c:	10800317 	ldw	r2,12(r2)
8113a9a0:	10800104 	addi	r2,r2,4
8113a9a4:	e0ffee17 	ldw	r3,-72(fp)
8113a9a8:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8113a9ac:	e0bffb17 	ldw	r2,-20(fp)
8113a9b0:	10800617 	ldw	r2,24(r2)
8113a9b4:	e0ffed17 	ldw	r3,-76(fp)
8113a9b8:	10c00035 	stwio	r3,0(r2)
8113a9bc:	e0bfef17 	ldw	r2,-68(fp)
8113a9c0:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a9c4:	e0bff117 	ldw	r2,-60(fp)
8113a9c8:	1001703a 	wrctl	status,r2
8113a9cc:	00002306 	br	8113aa5c <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
8113a9d0:	e0bffb17 	ldw	r2,-20(fp)
8113a9d4:	10c00d17 	ldw	r3,52(r2)
8113a9d8:	e0bfee17 	ldw	r2,-72(fp)
8113a9dc:	1884b03a 	or	r2,r3,r2
8113a9e0:	10800114 	ori	r2,r2,4
8113a9e4:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
8113a9e8:	e0ffee17 	ldw	r3,-72(fp)
8113a9ec:	00bff3c4 	movi	r2,-49
8113a9f0:	1884703a 	and	r2,r3,r2
8113a9f4:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
8113a9f8:	e0ffed17 	ldw	r3,-76(fp)
8113a9fc:	00bffdc4 	movi	r2,-9
8113aa00:	1884703a 	and	r2,r3,r2
8113aa04:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aa08:	0005303a 	rdctl	r2,status
8113aa0c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aa10:	e0fff517 	ldw	r3,-44(fp)
8113aa14:	00bfff84 	movi	r2,-2
8113aa18:	1884703a 	and	r2,r3,r2
8113aa1c:	1001703a 	wrctl	status,r2
  
  return context;
8113aa20:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
8113aa24:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8113aa28:	e0bffb17 	ldw	r2,-20(fp)
8113aa2c:	10800317 	ldw	r2,12(r2)
8113aa30:	10800104 	addi	r2,r2,4
8113aa34:	e0ffee17 	ldw	r3,-72(fp)
8113aa38:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8113aa3c:	e0bffb17 	ldw	r2,-20(fp)
8113aa40:	10800617 	ldw	r2,24(r2)
8113aa44:	e0ffed17 	ldw	r3,-76(fp)
8113aa48:	10c00035 	stwio	r3,0(r2)
8113aa4c:	e0bfef17 	ldw	r2,-68(fp)
8113aa50:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aa54:	e0bff317 	ldw	r2,-52(fp)
8113aa58:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
8113aa5c:	e0bffb17 	ldw	r2,-20(fp)
8113aa60:	10800617 	ldw	r2,24(r2)
8113aa64:	10800104 	addi	r2,r2,4
8113aa68:	e0fff817 	ldw	r3,-32(fp)
8113aa6c:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
8113aa70:	e0bffb17 	ldw	r2,-20(fp)
8113aa74:	10800617 	ldw	r2,24(r2)
8113aa78:	10800204 	addi	r2,r2,8
8113aa7c:	e0fff917 	ldw	r3,-28(fp)
8113aa80:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
8113aa84:	e0bffe03 	ldbu	r2,-8(fp)
8113aa88:	10000426 	beq	r2,zero,8113aa9c <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
8113aa8c:	e0bfed17 	ldw	r2,-76(fp)
8113aa90:	10800414 	ori	r2,r2,16
8113aa94:	e0bfed15 	stw	r2,-76(fp)
8113aa98:	00000406 	br	8113aaac <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
8113aa9c:	e0ffed17 	ldw	r3,-76(fp)
8113aaa0:	00bffbc4 	movi	r2,-17
8113aaa4:	1884703a 	and	r2,r3,r2
8113aaa8:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
8113aaac:	e0bfff03 	ldbu	r2,-4(fp)
8113aab0:	10000e26 	beq	r2,zero,8113aaec <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
8113aab4:	e0bfed17 	ldw	r2,-76(fp)
8113aab8:	10800094 	ori	r2,r2,2
8113aabc:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8113aac0:	e0bffb17 	ldw	r2,-20(fp)
8113aac4:	10800617 	ldw	r2,24(r2)
8113aac8:	10800304 	addi	r2,r2,12
8113aacc:	10800037 	ldwio	r2,0(r2)
8113aad0:	10000a1e 	bne	r2,zero,8113aafc <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8113aad4:	e0bffb17 	ldw	r2,-20(fp)
8113aad8:	10800617 	ldw	r2,24(r2)
8113aadc:	10800304 	addi	r2,r2,12
8113aae0:	00c03fc4 	movi	r3,255
8113aae4:	10c00035 	stwio	r3,0(r2)
8113aae8:	00000406 	br	8113aafc <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
8113aaec:	e0ffed17 	ldw	r3,-76(fp)
8113aaf0:	00bfff44 	movi	r2,-3
8113aaf4:	1884703a 	and	r2,r3,r2
8113aaf8:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
8113aafc:	e0bfed17 	ldw	r2,-76(fp)
8113ab00:	10800054 	ori	r2,r2,1
8113ab04:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8113ab08:	e0bffb17 	ldw	r2,-20(fp)
8113ab0c:	10800617 	ldw	r2,24(r2)
8113ab10:	e0ffed17 	ldw	r3,-76(fp)
8113ab14:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
8113ab18:	e0bffb17 	ldw	r2,-20(fp)
8113ab1c:	10801817 	ldw	r2,96(r2)
8113ab20:	1009883a 	mov	r4,r2
8113ab24:	112fdf00 	call	8112fdf0 <OSSemPost>
	 
	 return 0;
8113ab28:	0005883a 	mov	r2,zero
}
8113ab2c:	e037883a 	mov	sp,fp
8113ab30:	dfc00117 	ldw	ra,4(sp)
8113ab34:	df000017 	ldw	fp,0(sp)
8113ab38:	dec00204 	addi	sp,sp,8
8113ab3c:	f800283a 	ret

8113ab40 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
8113ab40:	defff704 	addi	sp,sp,-36
8113ab44:	de00012e 	bgeu	sp,et,8113ab4c <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
8113ab48:	003b68fa 	trap	3
8113ab4c:	dfc00815 	stw	ra,32(sp)
8113ab50:	df000715 	stw	fp,28(sp)
8113ab54:	dc400615 	stw	r17,24(sp)
8113ab58:	dc000515 	stw	r16,20(sp)
8113ab5c:	df000704 	addi	fp,sp,28
8113ab60:	e13ffa15 	stw	r4,-24(fp)
8113ab64:	e17ffb15 	stw	r5,-20(fp)
8113ab68:	3007883a 	mov	r3,r6
8113ab6c:	3805883a 	mov	r2,r7
8113ab70:	e0fffc05 	stb	r3,-16(fp)
8113ab74:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
8113ab78:	e13ffb17 	ldw	r4,-20(fp)
8113ab7c:	113a6ac0 	call	8113a6ac <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
8113ab80:	10000226 	beq	r2,zero,8113ab8c <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
8113ab84:	00bffa84 	movi	r2,-22
8113ab88:	00000b06 	br	8113abb8 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
8113ab8c:	e0bffb17 	ldw	r2,-20(fp)
8113ab90:	1021883a 	mov	r16,r2
8113ab94:	0023883a 	mov	r17,zero
8113ab98:	e0fffc03 	ldbu	r3,-16(fp)
8113ab9c:	e0bffd03 	ldbu	r2,-12(fp)
8113aba0:	d8800015 	stw	r2,0(sp)
8113aba4:	180f883a 	mov	r7,r3
8113aba8:	800b883a 	mov	r5,r16
8113abac:	880d883a 	mov	r6,r17
8113abb0:	e13ffa17 	ldw	r4,-24(fp)
8113abb4:	113a8280 	call	8113a828 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8113abb8:	e6fffe04 	addi	sp,fp,-8
8113abbc:	dfc00317 	ldw	ra,12(sp)
8113abc0:	df000217 	ldw	fp,8(sp)
8113abc4:	dc400117 	ldw	r17,4(sp)
8113abc8:	dc000017 	ldw	r16,0(sp)
8113abcc:	dec00404 	addi	sp,sp,16
8113abd0:	f800283a 	ret

8113abd4 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8113abd4:	defff704 	addi	sp,sp,-36
8113abd8:	de00012e 	bgeu	sp,et,8113abe0 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
8113abdc:	003b68fa 	trap	3
8113abe0:	dfc00815 	stw	ra,32(sp)
8113abe4:	df000715 	stw	fp,28(sp)
8113abe8:	dc400615 	stw	r17,24(sp)
8113abec:	dc000515 	stw	r16,20(sp)
8113abf0:	df000704 	addi	fp,sp,28
8113abf4:	e13ffa15 	stw	r4,-24(fp)
8113abf8:	e17ffb15 	stw	r5,-20(fp)
8113abfc:	3007883a 	mov	r3,r6
8113ac00:	3805883a 	mov	r2,r7
8113ac04:	e0fffc05 	stb	r3,-16(fp)
8113ac08:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
8113ac0c:	e13ffb17 	ldw	r4,-20(fp)
8113ac10:	113a74c0 	call	8113a74c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
8113ac14:	10000226 	beq	r2,zero,8113ac20 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
8113ac18:	00bffa84 	movi	r2,-22
8113ac1c:	00000b06 	br	8113ac4c <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
8113ac20:	e0bffb17 	ldw	r2,-20(fp)
8113ac24:	1021883a 	mov	r16,r2
8113ac28:	0023883a 	mov	r17,zero
8113ac2c:	e0fffc03 	ldbu	r3,-16(fp)
8113ac30:	e0bffd03 	ldbu	r2,-12(fp)
8113ac34:	d8800015 	stw	r2,0(sp)
8113ac38:	180f883a 	mov	r7,r3
8113ac3c:	800b883a 	mov	r5,r16
8113ac40:	880d883a 	mov	r6,r17
8113ac44:	e13ffa17 	ldw	r4,-24(fp)
8113ac48:	113a8280 	call	8113a828 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8113ac4c:	e6fffe04 	addi	sp,fp,-8
8113ac50:	dfc00317 	ldw	ra,12(sp)
8113ac54:	df000217 	ldw	fp,8(sp)
8113ac58:	dc400117 	ldw	r17,4(sp)
8113ac5c:	dc000017 	ldw	r16,0(sp)
8113ac60:	dec00404 	addi	sp,sp,16
8113ac64:	f800283a 	ret

8113ac68 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
8113ac68:	defffc04 	addi	sp,sp,-16
8113ac6c:	de00012e 	bgeu	sp,et,8113ac74 <alt_msgdma_open+0xc>
8113ac70:	003b68fa 	trap	3
8113ac74:	dfc00315 	stw	ra,12(sp)
8113ac78:	df000215 	stw	fp,8(sp)
8113ac7c:	df000204 	addi	fp,sp,8
8113ac80:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
8113ac84:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
8113ac88:	d1603404 	addi	r5,gp,-32560
8113ac8c:	e13fff17 	ldw	r4,-4(fp)
8113ac90:	113b2dc0 	call	8113b2dc <alt_find_dev>
8113ac94:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
8113ac98:	e0bffe17 	ldw	r2,-8(fp)
8113ac9c:	1000041e 	bne	r2,zero,8113acb0 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
8113aca0:	1138ecc0 	call	81138ecc <alt_get_errno>
8113aca4:	1007883a 	mov	r3,r2
8113aca8:	008004c4 	movi	r2,19
8113acac:	18800015 	stw	r2,0(r3)
    }

    return dev;
8113acb0:	e0bffe17 	ldw	r2,-8(fp)
}
8113acb4:	e037883a 	mov	sp,fp
8113acb8:	dfc00117 	ldw	ra,4(sp)
8113acbc:	df000017 	ldw	fp,0(sp)
8113acc0:	dec00204 	addi	sp,sp,8
8113acc4:	f800283a 	ret

8113acc8 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
8113acc8:	defff604 	addi	sp,sp,-40
8113accc:	de00012e 	bgeu	sp,et,8113acd4 <alt_msgdma_init+0xc>
8113acd0:	003b68fa 	trap	3
8113acd4:	dfc00915 	stw	ra,36(sp)
8113acd8:	df000815 	stw	fp,32(sp)
8113acdc:	df000804 	addi	fp,sp,32
8113ace0:	e13ffd15 	stw	r4,-12(fp)
8113ace4:	e17ffe15 	stw	r5,-8(fp)
8113ace8:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
8113acec:	e0bffd17 	ldw	r2,-12(fp)
8113acf0:	10801783 	ldbu	r2,94(r2)
8113acf4:	10803fcc 	andi	r2,r2,255
8113acf8:	10000b26 	beq	r2,zero,8113ad28 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
8113acfc:	e0bffd17 	ldw	r2,-12(fp)
8113ad00:	10800617 	ldw	r2,24(r2)
8113ad04:	00c00104 	movi	r3,4
8113ad08:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
8113ad0c:	0001883a 	nop
8113ad10:	e0bffd17 	ldw	r2,-12(fp)
8113ad14:	10800617 	ldw	r2,24(r2)
8113ad18:	10800037 	ldwio	r2,0(r2)
8113ad1c:	1080010c 	andi	r2,r2,4
8113ad20:	1005d0ba 	srai	r2,r2,2
8113ad24:	103ffa1e 	bne	r2,zero,8113ad10 <__reset+0xfb11ad10>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
8113ad28:	e0bffd17 	ldw	r2,-12(fp)
8113ad2c:	10800317 	ldw	r2,12(r2)
8113ad30:	10800104 	addi	r2,r2,4
8113ad34:	00c00084 	movi	r3,2
8113ad38:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8113ad3c:	0001883a 	nop
8113ad40:	e0bffd17 	ldw	r2,-12(fp)
8113ad44:	10800317 	ldw	r2,12(r2)
8113ad48:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
8113ad4c:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8113ad50:	103ffb1e 	bne	r2,zero,8113ad40 <__reset+0xfb11ad40>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8113ad54:	e0bffd17 	ldw	r2,-12(fp)
8113ad58:	10800317 	ldw	r2,12(r2)
8113ad5c:	10800104 	addi	r2,r2,4
8113ad60:	10800037 	ldwio	r2,0(r2)
8113ad64:	1007883a 	mov	r3,r2
8113ad68:	00bffbc4 	movi	r2,-17
8113ad6c:	1884703a 	and	r2,r3,r2
8113ad70:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8113ad74:	e0bff917 	ldw	r2,-28(fp)
8113ad78:	10800814 	ori	r2,r2,32
8113ad7c:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8113ad80:	e0bffd17 	ldw	r2,-12(fp)
8113ad84:	10800317 	ldw	r2,12(r2)
8113ad88:	10800104 	addi	r2,r2,4
8113ad8c:	e0fff917 	ldw	r3,-28(fp)
8113ad90:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
8113ad94:	e0bffd17 	ldw	r2,-12(fp)
8113ad98:	10800317 	ldw	r2,12(r2)
8113ad9c:	e0fffd17 	ldw	r3,-12(fp)
8113ada0:	18c00317 	ldw	r3,12(r3)
8113ada4:	18c00037 	ldwio	r3,0(r3)
8113ada8:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
8113adac:	e0bffd17 	ldw	r2,-12(fp)
8113adb0:	10801783 	ldbu	r2,94(r2)
8113adb4:	10803fcc 	andi	r2,r2,255
8113adb8:	10000826 	beq	r2,zero,8113addc <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
8113adbc:	e0bffd17 	ldw	r2,-12(fp)
8113adc0:	10800617 	ldw	r2,24(r2)
8113adc4:	10800404 	addi	r2,r2,16
8113adc8:	e0fffd17 	ldw	r3,-12(fp)
8113adcc:	18c00617 	ldw	r3,24(r3)
8113add0:	18c00404 	addi	r3,r3,16
8113add4:	18c00037 	ldwio	r3,0(r3)
8113add8:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
8113addc:	d1603404 	addi	r5,gp,-32560
8113ade0:	e13ffd17 	ldw	r4,-12(fp)
8113ade4:	113b1600 	call	8113b160 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
8113ade8:	e0bffd17 	ldw	r2,-12(fp)
8113adec:	10801804 	addi	r2,r2,96
8113adf0:	e0bffb15 	stw	r2,-20(fp)
8113adf4:	00800044 	movi	r2,1
8113adf8:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8113adfc:	e0bffc0b 	ldhu	r2,-16(fp)
8113ae00:	1009883a 	mov	r4,r2
8113ae04:	112f7400 	call	8112f740 <OSSemCreate>
8113ae08:	1007883a 	mov	r3,r2
8113ae0c:	e0bffb17 	ldw	r2,-20(fp)
8113ae10:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8113ae14:	e0bffb17 	ldw	r2,-20(fp)
8113ae18:	10800017 	ldw	r2,0(r2)
8113ae1c:	10000226 	beq	r2,zero,8113ae28 <alt_msgdma_init+0x160>
8113ae20:	0005883a 	mov	r2,zero
8113ae24:	00000106 	br	8113ae2c <alt_msgdma_init+0x164>
8113ae28:	00bfffc4 	movi	r2,-1
8113ae2c:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
8113ae30:	e0bffa17 	ldw	r2,-24(fp)
8113ae34:	1000081e 	bne	r2,zero,8113ae58 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
8113ae38:	d8000015 	stw	zero,0(sp)
8113ae3c:	e1fffd17 	ldw	r7,-12(fp)
8113ae40:	01a04534 	movhi	r6,33044
8113ae44:	31a43804 	addi	r6,r6,-28448
8113ae48:	e17fff17 	ldw	r5,-4(fp)
8113ae4c:	e13ffe17 	ldw	r4,-8(fp)
8113ae50:	113b5680 	call	8113b568 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
8113ae54:	00000406 	br	8113ae68 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
8113ae58:	01204534 	movhi	r4,33044
8113ae5c:	213f7d04 	addi	r4,r4,-524
8113ae60:	113b9800 	call	8113b980 <alt_printf>
    }
    
    return;
8113ae64:	0001883a 	nop

}
8113ae68:	e037883a 	mov	sp,fp
8113ae6c:	dfc00117 	ldw	ra,4(sp)
8113ae70:	df000017 	ldw	fp,0(sp)
8113ae74:	dec00204 	addi	sp,sp,8
8113ae78:	f800283a 	ret

8113ae7c <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
8113ae7c:	defffb04 	addi	sp,sp,-20
8113ae80:	de00012e 	bgeu	sp,et,8113ae88 <alt_msgdma_register_callback+0xc>
8113ae84:	003b68fa 	trap	3
8113ae88:	df000415 	stw	fp,16(sp)
8113ae8c:	df000404 	addi	fp,sp,16
8113ae90:	e13ffc15 	stw	r4,-16(fp)
8113ae94:	e17ffd15 	stw	r5,-12(fp)
8113ae98:	e1bffe15 	stw	r6,-8(fp)
8113ae9c:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
8113aea0:	e0bffc17 	ldw	r2,-16(fp)
8113aea4:	e0fffd17 	ldw	r3,-12(fp)
8113aea8:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
8113aeac:	e0bffc17 	ldw	r2,-16(fp)
8113aeb0:	e0ffff17 	ldw	r3,-4(fp)
8113aeb4:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
8113aeb8:	e0bffc17 	ldw	r2,-16(fp)
8113aebc:	e0fffe17 	ldw	r3,-8(fp)
8113aec0:	10c00d15 	stw	r3,52(r2)

    return ;
8113aec4:	0001883a 	nop
}
8113aec8:	e037883a 	mov	sp,fp
8113aecc:	df000017 	ldw	fp,0(sp)
8113aed0:	dec00104 	addi	sp,sp,4
8113aed4:	f800283a 	ret

8113aed8 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8113aed8:	defffc04 	addi	sp,sp,-16
8113aedc:	de00012e 	bgeu	sp,et,8113aee4 <alt_msgdma_standard_descriptor_async_transfer+0xc>
8113aee0:	003b68fa 	trap	3
8113aee4:	dfc00315 	stw	ra,12(sp)
8113aee8:	df000215 	stw	fp,8(sp)
8113aeec:	df000204 	addi	fp,sp,8
8113aef0:	e13ffe15 	stw	r4,-8(fp)
8113aef4:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
8113aef8:	000d883a 	mov	r6,zero
8113aefc:	e17fff17 	ldw	r5,-4(fp)
8113af00:	e13ffe17 	ldw	r4,-8(fp)
8113af04:	113945c0 	call	8113945c <alt_msgdma_descriptor_async_transfer>

}
8113af08:	e037883a 	mov	sp,fp
8113af0c:	dfc00117 	ldw	ra,4(sp)
8113af10:	df000017 	ldw	fp,0(sp)
8113af14:	dec00204 	addi	sp,sp,8
8113af18:	f800283a 	ret

8113af1c <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8113af1c:	defffc04 	addi	sp,sp,-16
8113af20:	de00012e 	bgeu	sp,et,8113af28 <alt_msgdma_extended_descriptor_async_transfer+0xc>
8113af24:	003b68fa 	trap	3
8113af28:	dfc00315 	stw	ra,12(sp)
8113af2c:	df000215 	stw	fp,8(sp)
8113af30:	df000204 	addi	fp,sp,8
8113af34:	e13ffe15 	stw	r4,-8(fp)
8113af38:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
8113af3c:	e1bfff17 	ldw	r6,-4(fp)
8113af40:	000b883a 	mov	r5,zero
8113af44:	e13ffe17 	ldw	r4,-8(fp)
8113af48:	113945c0 	call	8113945c <alt_msgdma_descriptor_async_transfer>
}
8113af4c:	e037883a 	mov	sp,fp
8113af50:	dfc00117 	ldw	ra,4(sp)
8113af54:	df000017 	ldw	fp,0(sp)
8113af58:	dec00204 	addi	sp,sp,8
8113af5c:	f800283a 	ret

8113af60 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8113af60:	defffc04 	addi	sp,sp,-16
8113af64:	de00012e 	bgeu	sp,et,8113af6c <alt_msgdma_standard_descriptor_sync_transfer+0xc>
8113af68:	003b68fa 	trap	3
8113af6c:	dfc00315 	stw	ra,12(sp)
8113af70:	df000215 	stw	fp,8(sp)
8113af74:	df000204 	addi	fp,sp,8
8113af78:	e13ffe15 	stw	r4,-8(fp)
8113af7c:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
8113af80:	000d883a 	mov	r6,zero
8113af84:	e17fff17 	ldw	r5,-4(fp)
8113af88:	e13ffe17 	ldw	r4,-8(fp)
8113af8c:	113979c0 	call	8113979c <alt_msgdma_descriptor_sync_transfer>
}
8113af90:	e037883a 	mov	sp,fp
8113af94:	dfc00117 	ldw	ra,4(sp)
8113af98:	df000017 	ldw	fp,0(sp)
8113af9c:	dec00204 	addi	sp,sp,8
8113afa0:	f800283a 	ret

8113afa4 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8113afa4:	defffc04 	addi	sp,sp,-16
8113afa8:	de00012e 	bgeu	sp,et,8113afb0 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
8113afac:	003b68fa 	trap	3
8113afb0:	dfc00315 	stw	ra,12(sp)
8113afb4:	df000215 	stw	fp,8(sp)
8113afb8:	df000204 	addi	fp,sp,8
8113afbc:	e13ffe15 	stw	r4,-8(fp)
8113afc0:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
8113afc4:	e1bfff17 	ldw	r6,-4(fp)
8113afc8:	000b883a 	mov	r5,zero
8113afcc:	e13ffe17 	ldw	r4,-8(fp)
8113afd0:	113979c0 	call	8113979c <alt_msgdma_descriptor_sync_transfer>
}
8113afd4:	e037883a 	mov	sp,fp
8113afd8:	dfc00117 	ldw	ra,4(sp)
8113afdc:	df000017 	ldw	fp,0(sp)
8113afe0:	dec00204 	addi	sp,sp,8
8113afe4:	f800283a 	ret

8113afe8 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
8113afe8:	defff504 	addi	sp,sp,-44
8113afec:	de00012e 	bgeu	sp,et,8113aff4 <alt_alarm_start+0xc>
8113aff0:	003b68fa 	trap	3
8113aff4:	df000a15 	stw	fp,40(sp)
8113aff8:	df000a04 	addi	fp,sp,40
8113affc:	e13ffc15 	stw	r4,-16(fp)
8113b000:	e17ffd15 	stw	r5,-12(fp)
8113b004:	e1bffe15 	stw	r6,-8(fp)
8113b008:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
8113b00c:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8113b010:	d0a06c17 	ldw	r2,-32336(gp)
  
  if (alt_ticks_per_second ())
8113b014:	10003c26 	beq	r2,zero,8113b108 <alt_alarm_start+0x120>
  {
    if (alarm)
8113b018:	e0bffc17 	ldw	r2,-16(fp)
8113b01c:	10003826 	beq	r2,zero,8113b100 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
8113b020:	e0bffc17 	ldw	r2,-16(fp)
8113b024:	e0fffe17 	ldw	r3,-8(fp)
8113b028:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8113b02c:	e0bffc17 	ldw	r2,-16(fp)
8113b030:	e0ffff17 	ldw	r3,-4(fp)
8113b034:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b038:	0005303a 	rdctl	r2,status
8113b03c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b040:	e0fff917 	ldw	r3,-28(fp)
8113b044:	00bfff84 	movi	r2,-2
8113b048:	1884703a 	and	r2,r3,r2
8113b04c:	1001703a 	wrctl	status,r2
  
  return context;
8113b050:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
8113b054:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8113b058:	d0a06d17 	ldw	r2,-32332(gp)
      
      current_nticks = alt_nticks();
8113b05c:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
8113b060:	e0fffd17 	ldw	r3,-12(fp)
8113b064:	e0bff617 	ldw	r2,-40(fp)
8113b068:	1885883a 	add	r2,r3,r2
8113b06c:	10c00044 	addi	r3,r2,1
8113b070:	e0bffc17 	ldw	r2,-16(fp)
8113b074:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
8113b078:	e0bffc17 	ldw	r2,-16(fp)
8113b07c:	10c00217 	ldw	r3,8(r2)
8113b080:	e0bff617 	ldw	r2,-40(fp)
8113b084:	1880042e 	bgeu	r3,r2,8113b098 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
8113b088:	e0bffc17 	ldw	r2,-16(fp)
8113b08c:	00c00044 	movi	r3,1
8113b090:	10c00405 	stb	r3,16(r2)
8113b094:	00000206 	br	8113b0a0 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
8113b098:	e0bffc17 	ldw	r2,-16(fp)
8113b09c:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
8113b0a0:	e0bffc17 	ldw	r2,-16(fp)
8113b0a4:	d0e01304 	addi	r3,gp,-32692
8113b0a8:	e0fffa15 	stw	r3,-24(fp)
8113b0ac:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8113b0b0:	e0bffb17 	ldw	r2,-20(fp)
8113b0b4:	e0fffa17 	ldw	r3,-24(fp)
8113b0b8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8113b0bc:	e0bffa17 	ldw	r2,-24(fp)
8113b0c0:	10c00017 	ldw	r3,0(r2)
8113b0c4:	e0bffb17 	ldw	r2,-20(fp)
8113b0c8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8113b0cc:	e0bffa17 	ldw	r2,-24(fp)
8113b0d0:	10800017 	ldw	r2,0(r2)
8113b0d4:	e0fffb17 	ldw	r3,-20(fp)
8113b0d8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8113b0dc:	e0bffa17 	ldw	r2,-24(fp)
8113b0e0:	e0fffb17 	ldw	r3,-20(fp)
8113b0e4:	10c00015 	stw	r3,0(r2)
8113b0e8:	e0bff817 	ldw	r2,-32(fp)
8113b0ec:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b0f0:	e0bff717 	ldw	r2,-36(fp)
8113b0f4:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
8113b0f8:	0005883a 	mov	r2,zero
8113b0fc:	00000306 	br	8113b10c <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
8113b100:	00bffa84 	movi	r2,-22
8113b104:	00000106 	br	8113b10c <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
8113b108:	00bfde84 	movi	r2,-134
  }
}
8113b10c:	e037883a 	mov	sp,fp
8113b110:	df000017 	ldw	fp,0(sp)
8113b114:	dec00104 	addi	sp,sp,4
8113b118:	f800283a 	ret

8113b11c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113b11c:	defffe04 	addi	sp,sp,-8
8113b120:	de00012e 	bgeu	sp,et,8113b128 <alt_get_errno+0xc>
8113b124:	003b68fa 	trap	3
8113b128:	dfc00115 	stw	ra,4(sp)
8113b12c:	df000015 	stw	fp,0(sp)
8113b130:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113b134:	d0a01017 	ldw	r2,-32704(gp)
8113b138:	10000326 	beq	r2,zero,8113b148 <alt_get_errno+0x2c>
8113b13c:	d0a01017 	ldw	r2,-32704(gp)
8113b140:	103ee83a 	callr	r2
8113b144:	00000106 	br	8113b14c <alt_get_errno+0x30>
8113b148:	d0a06004 	addi	r2,gp,-32384
}
8113b14c:	e037883a 	mov	sp,fp
8113b150:	dfc00117 	ldw	ra,4(sp)
8113b154:	df000017 	ldw	fp,0(sp)
8113b158:	dec00204 	addi	sp,sp,8
8113b15c:	f800283a 	ret

8113b160 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
8113b160:	defffa04 	addi	sp,sp,-24
8113b164:	de00012e 	bgeu	sp,et,8113b16c <alt_dev_llist_insert+0xc>
8113b168:	003b68fa 	trap	3
8113b16c:	dfc00515 	stw	ra,20(sp)
8113b170:	df000415 	stw	fp,16(sp)
8113b174:	df000404 	addi	fp,sp,16
8113b178:	e13ffe15 	stw	r4,-8(fp)
8113b17c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
8113b180:	e0bffe17 	ldw	r2,-8(fp)
8113b184:	10000326 	beq	r2,zero,8113b194 <alt_dev_llist_insert+0x34>
8113b188:	e0bffe17 	ldw	r2,-8(fp)
8113b18c:	10800217 	ldw	r2,8(r2)
8113b190:	1000061e 	bne	r2,zero,8113b1ac <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
8113b194:	113b11c0 	call	8113b11c <alt_get_errno>
8113b198:	1007883a 	mov	r3,r2
8113b19c:	00800584 	movi	r2,22
8113b1a0:	18800015 	stw	r2,0(r3)
    return -EINVAL;
8113b1a4:	00bffa84 	movi	r2,-22
8113b1a8:	00001306 	br	8113b1f8 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
8113b1ac:	e0bffe17 	ldw	r2,-8(fp)
8113b1b0:	e0ffff17 	ldw	r3,-4(fp)
8113b1b4:	e0fffc15 	stw	r3,-16(fp)
8113b1b8:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8113b1bc:	e0bffd17 	ldw	r2,-12(fp)
8113b1c0:	e0fffc17 	ldw	r3,-16(fp)
8113b1c4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8113b1c8:	e0bffc17 	ldw	r2,-16(fp)
8113b1cc:	10c00017 	ldw	r3,0(r2)
8113b1d0:	e0bffd17 	ldw	r2,-12(fp)
8113b1d4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8113b1d8:	e0bffc17 	ldw	r2,-16(fp)
8113b1dc:	10800017 	ldw	r2,0(r2)
8113b1e0:	e0fffd17 	ldw	r3,-12(fp)
8113b1e4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8113b1e8:	e0bffc17 	ldw	r2,-16(fp)
8113b1ec:	e0fffd17 	ldw	r3,-12(fp)
8113b1f0:	10c00015 	stw	r3,0(r2)

  return 0;  
8113b1f4:	0005883a 	mov	r2,zero
}
8113b1f8:	e037883a 	mov	sp,fp
8113b1fc:	dfc00117 	ldw	ra,4(sp)
8113b200:	df000017 	ldw	fp,0(sp)
8113b204:	dec00204 	addi	sp,sp,8
8113b208:	f800283a 	ret

8113b20c <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
8113b20c:	defffd04 	addi	sp,sp,-12
8113b210:	de00012e 	bgeu	sp,et,8113b218 <_do_ctors+0xc>
8113b214:	003b68fa 	trap	3
8113b218:	dfc00215 	stw	ra,8(sp)
8113b21c:	df000115 	stw	fp,4(sp)
8113b220:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
8113b224:	00a04534 	movhi	r2,33044
8113b228:	10b17604 	addi	r2,r2,-14888
8113b22c:	e0bfff15 	stw	r2,-4(fp)
8113b230:	00000606 	br	8113b24c <_do_ctors+0x40>
        (*ctor) (); 
8113b234:	e0bfff17 	ldw	r2,-4(fp)
8113b238:	10800017 	ldw	r2,0(r2)
8113b23c:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
8113b240:	e0bfff17 	ldw	r2,-4(fp)
8113b244:	10bfff04 	addi	r2,r2,-4
8113b248:	e0bfff15 	stw	r2,-4(fp)
8113b24c:	e0ffff17 	ldw	r3,-4(fp)
8113b250:	00a04534 	movhi	r2,33044
8113b254:	10b17704 	addi	r2,r2,-14884
8113b258:	18bff62e 	bgeu	r3,r2,8113b234 <__reset+0xfb11b234>
        (*ctor) (); 
}
8113b25c:	0001883a 	nop
8113b260:	e037883a 	mov	sp,fp
8113b264:	dfc00117 	ldw	ra,4(sp)
8113b268:	df000017 	ldw	fp,0(sp)
8113b26c:	dec00204 	addi	sp,sp,8
8113b270:	f800283a 	ret

8113b274 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
8113b274:	defffd04 	addi	sp,sp,-12
8113b278:	de00012e 	bgeu	sp,et,8113b280 <_do_dtors+0xc>
8113b27c:	003b68fa 	trap	3
8113b280:	dfc00215 	stw	ra,8(sp)
8113b284:	df000115 	stw	fp,4(sp)
8113b288:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
8113b28c:	00a04534 	movhi	r2,33044
8113b290:	10b17604 	addi	r2,r2,-14888
8113b294:	e0bfff15 	stw	r2,-4(fp)
8113b298:	00000606 	br	8113b2b4 <_do_dtors+0x40>
        (*dtor) (); 
8113b29c:	e0bfff17 	ldw	r2,-4(fp)
8113b2a0:	10800017 	ldw	r2,0(r2)
8113b2a4:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
8113b2a8:	e0bfff17 	ldw	r2,-4(fp)
8113b2ac:	10bfff04 	addi	r2,r2,-4
8113b2b0:	e0bfff15 	stw	r2,-4(fp)
8113b2b4:	e0ffff17 	ldw	r3,-4(fp)
8113b2b8:	00a04534 	movhi	r2,33044
8113b2bc:	10b17704 	addi	r2,r2,-14884
8113b2c0:	18bff62e 	bgeu	r3,r2,8113b29c <__reset+0xfb11b29c>
        (*dtor) (); 
}
8113b2c4:	0001883a 	nop
8113b2c8:	e037883a 	mov	sp,fp
8113b2cc:	dfc00117 	ldw	ra,4(sp)
8113b2d0:	df000017 	ldw	fp,0(sp)
8113b2d4:	dec00204 	addi	sp,sp,8
8113b2d8:	f800283a 	ret

8113b2dc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8113b2dc:	defffa04 	addi	sp,sp,-24
8113b2e0:	de00012e 	bgeu	sp,et,8113b2e8 <alt_find_dev+0xc>
8113b2e4:	003b68fa 	trap	3
8113b2e8:	dfc00515 	stw	ra,20(sp)
8113b2ec:	df000415 	stw	fp,16(sp)
8113b2f0:	df000404 	addi	fp,sp,16
8113b2f4:	e13ffe15 	stw	r4,-8(fp)
8113b2f8:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8113b2fc:	e0bfff17 	ldw	r2,-4(fp)
8113b300:	10800017 	ldw	r2,0(r2)
8113b304:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
8113b308:	e13ffe17 	ldw	r4,-8(fp)
8113b30c:	111405c0 	call	8111405c <strlen>
8113b310:	10800044 	addi	r2,r2,1
8113b314:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8113b318:	00000d06 	br	8113b350 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8113b31c:	e0bffc17 	ldw	r2,-16(fp)
8113b320:	10800217 	ldw	r2,8(r2)
8113b324:	e0fffd17 	ldw	r3,-12(fp)
8113b328:	180d883a 	mov	r6,r3
8113b32c:	e17ffe17 	ldw	r5,-8(fp)
8113b330:	1009883a 	mov	r4,r2
8113b334:	113c1040 	call	8113c104 <memcmp>
8113b338:	1000021e 	bne	r2,zero,8113b344 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8113b33c:	e0bffc17 	ldw	r2,-16(fp)
8113b340:	00000706 	br	8113b360 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
8113b344:	e0bffc17 	ldw	r2,-16(fp)
8113b348:	10800017 	ldw	r2,0(r2)
8113b34c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8113b350:	e0fffc17 	ldw	r3,-16(fp)
8113b354:	e0bfff17 	ldw	r2,-4(fp)
8113b358:	18bff01e 	bne	r3,r2,8113b31c <__reset+0xfb11b31c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
8113b35c:	0005883a 	mov	r2,zero
}
8113b360:	e037883a 	mov	sp,fp
8113b364:	dfc00117 	ldw	ra,4(sp)
8113b368:	df000017 	ldw	fp,0(sp)
8113b36c:	dec00204 	addi	sp,sp,8
8113b370:	f800283a 	ret

8113b374 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
8113b374:	defffb04 	addi	sp,sp,-20
8113b378:	de00012e 	bgeu	sp,et,8113b380 <alt_find_file+0xc>
8113b37c:	003b68fa 	trap	3
8113b380:	dfc00415 	stw	ra,16(sp)
8113b384:	df000315 	stw	fp,12(sp)
8113b388:	df000304 	addi	fp,sp,12
8113b38c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
8113b390:	d0a00b17 	ldw	r2,-32724(gp)
8113b394:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8113b398:	00003106 	br	8113b460 <alt_find_file+0xec>
  {
    len = strlen(next->name);
8113b39c:	e0bffd17 	ldw	r2,-12(fp)
8113b3a0:	10800217 	ldw	r2,8(r2)
8113b3a4:	1009883a 	mov	r4,r2
8113b3a8:	111405c0 	call	8111405c <strlen>
8113b3ac:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
8113b3b0:	e0bffd17 	ldw	r2,-12(fp)
8113b3b4:	10c00217 	ldw	r3,8(r2)
8113b3b8:	e0bffe17 	ldw	r2,-8(fp)
8113b3bc:	10bfffc4 	addi	r2,r2,-1
8113b3c0:	1885883a 	add	r2,r3,r2
8113b3c4:	10800003 	ldbu	r2,0(r2)
8113b3c8:	10803fcc 	andi	r2,r2,255
8113b3cc:	1080201c 	xori	r2,r2,128
8113b3d0:	10bfe004 	addi	r2,r2,-128
8113b3d4:	10800bd8 	cmpnei	r2,r2,47
8113b3d8:	1000031e 	bne	r2,zero,8113b3e8 <alt_find_file+0x74>
    {
      len -= 1;
8113b3dc:	e0bffe17 	ldw	r2,-8(fp)
8113b3e0:	10bfffc4 	addi	r2,r2,-1
8113b3e4:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8113b3e8:	e0bffe17 	ldw	r2,-8(fp)
8113b3ec:	e0ffff17 	ldw	r3,-4(fp)
8113b3f0:	1885883a 	add	r2,r3,r2
8113b3f4:	10800003 	ldbu	r2,0(r2)
8113b3f8:	10803fcc 	andi	r2,r2,255
8113b3fc:	1080201c 	xori	r2,r2,128
8113b400:	10bfe004 	addi	r2,r2,-128
8113b404:	10800be0 	cmpeqi	r2,r2,47
8113b408:	1000081e 	bne	r2,zero,8113b42c <alt_find_file+0xb8>
8113b40c:	e0bffe17 	ldw	r2,-8(fp)
8113b410:	e0ffff17 	ldw	r3,-4(fp)
8113b414:	1885883a 	add	r2,r3,r2
8113b418:	10800003 	ldbu	r2,0(r2)
8113b41c:	10803fcc 	andi	r2,r2,255
8113b420:	1080201c 	xori	r2,r2,128
8113b424:	10bfe004 	addi	r2,r2,-128
8113b428:	10000a1e 	bne	r2,zero,8113b454 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8113b42c:	e0bffd17 	ldw	r2,-12(fp)
8113b430:	10800217 	ldw	r2,8(r2)
8113b434:	e0fffe17 	ldw	r3,-8(fp)
8113b438:	180d883a 	mov	r6,r3
8113b43c:	e17fff17 	ldw	r5,-4(fp)
8113b440:	1009883a 	mov	r4,r2
8113b444:	113c1040 	call	8113c104 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8113b448:	1000021e 	bne	r2,zero,8113b454 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8113b44c:	e0bffd17 	ldw	r2,-12(fp)
8113b450:	00000706 	br	8113b470 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
8113b454:	e0bffd17 	ldw	r2,-12(fp)
8113b458:	10800017 	ldw	r2,0(r2)
8113b45c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8113b460:	e0fffd17 	ldw	r3,-12(fp)
8113b464:	d0a00b04 	addi	r2,gp,-32724
8113b468:	18bfcc1e 	bne	r3,r2,8113b39c <__reset+0xfb11b39c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8113b46c:	0005883a 	mov	r2,zero
}
8113b470:	e037883a 	mov	sp,fp
8113b474:	dfc00117 	ldw	ra,4(sp)
8113b478:	df000017 	ldw	fp,0(sp)
8113b47c:	dec00204 	addi	sp,sp,8
8113b480:	f800283a 	ret

8113b484 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
8113b484:	defff904 	addi	sp,sp,-28
8113b488:	de00012e 	bgeu	sp,et,8113b490 <alt_get_fd+0xc>
8113b48c:	003b68fa 	trap	3
8113b490:	dfc00615 	stw	ra,24(sp)
8113b494:	df000515 	stw	fp,20(sp)
8113b498:	df000504 	addi	fp,sp,20
8113b49c:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
8113b4a0:	00bffa04 	movi	r2,-24
8113b4a4:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
8113b4a8:	d0a06717 	ldw	r2,-32356(gp)
8113b4ac:	e0bffd15 	stw	r2,-12(fp)
8113b4b0:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8113b4b4:	e0bffe0b 	ldhu	r2,-8(fp)
8113b4b8:	e0fffe84 	addi	r3,fp,-6
8113b4bc:	180d883a 	mov	r6,r3
8113b4c0:	100b883a 	mov	r5,r2
8113b4c4:	e13ffd17 	ldw	r4,-12(fp)
8113b4c8:	112fa680 	call	8112fa68 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8113b4cc:	e03ffb15 	stw	zero,-20(fp)
8113b4d0:	00001906 	br	8113b538 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
8113b4d4:	00a04534 	movhi	r2,33044
8113b4d8:	1081b904 	addi	r2,r2,1764
8113b4dc:	e0fffb17 	ldw	r3,-20(fp)
8113b4e0:	18c00324 	muli	r3,r3,12
8113b4e4:	10c5883a 	add	r2,r2,r3
8113b4e8:	10800017 	ldw	r2,0(r2)
8113b4ec:	10000f1e 	bne	r2,zero,8113b52c <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
8113b4f0:	00a04534 	movhi	r2,33044
8113b4f4:	1081b904 	addi	r2,r2,1764
8113b4f8:	e0fffb17 	ldw	r3,-20(fp)
8113b4fc:	18c00324 	muli	r3,r3,12
8113b500:	10c5883a 	add	r2,r2,r3
8113b504:	e0ffff17 	ldw	r3,-4(fp)
8113b508:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8113b50c:	d0e00f17 	ldw	r3,-32708(gp)
8113b510:	e0bffb17 	ldw	r2,-20(fp)
8113b514:	1880020e 	bge	r3,r2,8113b520 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
8113b518:	e0bffb17 	ldw	r2,-20(fp)
8113b51c:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
8113b520:	e0bffb17 	ldw	r2,-20(fp)
8113b524:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
8113b528:	00000606 	br	8113b544 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8113b52c:	e0bffb17 	ldw	r2,-20(fp)
8113b530:	10800044 	addi	r2,r2,1
8113b534:	e0bffb15 	stw	r2,-20(fp)
8113b538:	e0bffb17 	ldw	r2,-20(fp)
8113b53c:	10800810 	cmplti	r2,r2,32
8113b540:	103fe41e 	bne	r2,zero,8113b4d4 <__reset+0xfb11b4d4>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
8113b544:	d0a06717 	ldw	r2,-32356(gp)
8113b548:	1009883a 	mov	r4,r2
8113b54c:	112fdf00 	call	8112fdf0 <OSSemPost>

  return rc;
8113b550:	e0bffc17 	ldw	r2,-16(fp)
}
8113b554:	e037883a 	mov	sp,fp
8113b558:	dfc00117 	ldw	ra,4(sp)
8113b55c:	df000017 	ldw	fp,0(sp)
8113b560:	dec00204 	addi	sp,sp,8
8113b564:	f800283a 	ret

8113b568 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8113b568:	defff904 	addi	sp,sp,-28
8113b56c:	de00012e 	bgeu	sp,et,8113b574 <alt_ic_isr_register+0xc>
8113b570:	003b68fa 	trap	3
8113b574:	dfc00615 	stw	ra,24(sp)
8113b578:	df000515 	stw	fp,20(sp)
8113b57c:	df000504 	addi	fp,sp,20
8113b580:	e13ffc15 	stw	r4,-16(fp)
8113b584:	e17ffd15 	stw	r5,-12(fp)
8113b588:	e1bffe15 	stw	r6,-8(fp)
8113b58c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
8113b590:	e0800217 	ldw	r2,8(fp)
8113b594:	d8800015 	stw	r2,0(sp)
8113b598:	e1ffff17 	ldw	r7,-4(fp)
8113b59c:	e1bffe17 	ldw	r6,-8(fp)
8113b5a0:	e17ffd17 	ldw	r5,-12(fp)
8113b5a4:	e13ffc17 	ldw	r4,-16(fp)
8113b5a8:	113b7380 	call	8113b738 <alt_iic_isr_register>
}  
8113b5ac:	e037883a 	mov	sp,fp
8113b5b0:	dfc00117 	ldw	ra,4(sp)
8113b5b4:	df000017 	ldw	fp,0(sp)
8113b5b8:	dec00204 	addi	sp,sp,8
8113b5bc:	f800283a 	ret

8113b5c0 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
8113b5c0:	defff904 	addi	sp,sp,-28
8113b5c4:	de00012e 	bgeu	sp,et,8113b5cc <alt_ic_irq_enable+0xc>
8113b5c8:	003b68fa 	trap	3
8113b5cc:	df000615 	stw	fp,24(sp)
8113b5d0:	df000604 	addi	fp,sp,24
8113b5d4:	e13ffe15 	stw	r4,-8(fp)
8113b5d8:	e17fff15 	stw	r5,-4(fp)
8113b5dc:	e0bfff17 	ldw	r2,-4(fp)
8113b5e0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b5e4:	0005303a 	rdctl	r2,status
8113b5e8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b5ec:	e0fffb17 	ldw	r3,-20(fp)
8113b5f0:	00bfff84 	movi	r2,-2
8113b5f4:	1884703a 	and	r2,r3,r2
8113b5f8:	1001703a 	wrctl	status,r2
  
  return context;
8113b5fc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8113b600:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
8113b604:	00c00044 	movi	r3,1
8113b608:	e0bffa17 	ldw	r2,-24(fp)
8113b60c:	1884983a 	sll	r2,r3,r2
8113b610:	1007883a 	mov	r3,r2
8113b614:	d0a06817 	ldw	r2,-32352(gp)
8113b618:	1884b03a 	or	r2,r3,r2
8113b61c:	d0a06815 	stw	r2,-32352(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8113b620:	d0a06817 	ldw	r2,-32352(gp)
8113b624:	100170fa 	wrctl	ienable,r2
8113b628:	e0bffc17 	ldw	r2,-16(fp)
8113b62c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b630:	e0bffd17 	ldw	r2,-12(fp)
8113b634:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113b638:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8113b63c:	0001883a 	nop
}
8113b640:	e037883a 	mov	sp,fp
8113b644:	df000017 	ldw	fp,0(sp)
8113b648:	dec00104 	addi	sp,sp,4
8113b64c:	f800283a 	ret

8113b650 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
8113b650:	defff904 	addi	sp,sp,-28
8113b654:	de00012e 	bgeu	sp,et,8113b65c <alt_ic_irq_disable+0xc>
8113b658:	003b68fa 	trap	3
8113b65c:	df000615 	stw	fp,24(sp)
8113b660:	df000604 	addi	fp,sp,24
8113b664:	e13ffe15 	stw	r4,-8(fp)
8113b668:	e17fff15 	stw	r5,-4(fp)
8113b66c:	e0bfff17 	ldw	r2,-4(fp)
8113b670:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b674:	0005303a 	rdctl	r2,status
8113b678:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b67c:	e0fffb17 	ldw	r3,-20(fp)
8113b680:	00bfff84 	movi	r2,-2
8113b684:	1884703a 	and	r2,r3,r2
8113b688:	1001703a 	wrctl	status,r2
  
  return context;
8113b68c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8113b690:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
8113b694:	00c00044 	movi	r3,1
8113b698:	e0bffa17 	ldw	r2,-24(fp)
8113b69c:	1884983a 	sll	r2,r3,r2
8113b6a0:	0084303a 	nor	r2,zero,r2
8113b6a4:	1007883a 	mov	r3,r2
8113b6a8:	d0a06817 	ldw	r2,-32352(gp)
8113b6ac:	1884703a 	and	r2,r3,r2
8113b6b0:	d0a06815 	stw	r2,-32352(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8113b6b4:	d0a06817 	ldw	r2,-32352(gp)
8113b6b8:	100170fa 	wrctl	ienable,r2
8113b6bc:	e0bffc17 	ldw	r2,-16(fp)
8113b6c0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b6c4:	e0bffd17 	ldw	r2,-12(fp)
8113b6c8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113b6cc:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
8113b6d0:	0001883a 	nop
}
8113b6d4:	e037883a 	mov	sp,fp
8113b6d8:	df000017 	ldw	fp,0(sp)
8113b6dc:	dec00104 	addi	sp,sp,4
8113b6e0:	f800283a 	ret

8113b6e4 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
8113b6e4:	defffc04 	addi	sp,sp,-16
8113b6e8:	de00012e 	bgeu	sp,et,8113b6f0 <alt_ic_irq_enabled+0xc>
8113b6ec:	003b68fa 	trap	3
8113b6f0:	df000315 	stw	fp,12(sp)
8113b6f4:	df000304 	addi	fp,sp,12
8113b6f8:	e13ffe15 	stw	r4,-8(fp)
8113b6fc:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
8113b700:	000530fa 	rdctl	r2,ienable
8113b704:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8113b708:	00c00044 	movi	r3,1
8113b70c:	e0bfff17 	ldw	r2,-4(fp)
8113b710:	1884983a 	sll	r2,r3,r2
8113b714:	1007883a 	mov	r3,r2
8113b718:	e0bffd17 	ldw	r2,-12(fp)
8113b71c:	1884703a 	and	r2,r3,r2
8113b720:	1004c03a 	cmpne	r2,r2,zero
8113b724:	10803fcc 	andi	r2,r2,255
}
8113b728:	e037883a 	mov	sp,fp
8113b72c:	df000017 	ldw	fp,0(sp)
8113b730:	dec00104 	addi	sp,sp,4
8113b734:	f800283a 	ret

8113b738 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8113b738:	defff504 	addi	sp,sp,-44
8113b73c:	de00012e 	bgeu	sp,et,8113b744 <alt_iic_isr_register+0xc>
8113b740:	003b68fa 	trap	3
8113b744:	dfc00a15 	stw	ra,40(sp)
8113b748:	df000915 	stw	fp,36(sp)
8113b74c:	df000904 	addi	fp,sp,36
8113b750:	e13ffc15 	stw	r4,-16(fp)
8113b754:	e17ffd15 	stw	r5,-12(fp)
8113b758:	e1bffe15 	stw	r6,-8(fp)
8113b75c:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
8113b760:	00bffa84 	movi	r2,-22
8113b764:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
8113b768:	e0bffd17 	ldw	r2,-12(fp)
8113b76c:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8113b770:	e0bff817 	ldw	r2,-32(fp)
8113b774:	10800808 	cmpgei	r2,r2,32
8113b778:	1000271e 	bne	r2,zero,8113b818 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b77c:	0005303a 	rdctl	r2,status
8113b780:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b784:	e0fffb17 	ldw	r3,-20(fp)
8113b788:	00bfff84 	movi	r2,-2
8113b78c:	1884703a 	and	r2,r3,r2
8113b790:	1001703a 	wrctl	status,r2
  
  return context;
8113b794:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8113b798:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8113b79c:	00a04574 	movhi	r2,33045
8113b7a0:	10960c04 	addi	r2,r2,22576
8113b7a4:	e0fff817 	ldw	r3,-32(fp)
8113b7a8:	180690fa 	slli	r3,r3,3
8113b7ac:	10c5883a 	add	r2,r2,r3
8113b7b0:	e0fffe17 	ldw	r3,-8(fp)
8113b7b4:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8113b7b8:	00a04574 	movhi	r2,33045
8113b7bc:	10960c04 	addi	r2,r2,22576
8113b7c0:	e0fff817 	ldw	r3,-32(fp)
8113b7c4:	180690fa 	slli	r3,r3,3
8113b7c8:	10c5883a 	add	r2,r2,r3
8113b7cc:	10800104 	addi	r2,r2,4
8113b7d0:	e0ffff17 	ldw	r3,-4(fp)
8113b7d4:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
8113b7d8:	e0bffe17 	ldw	r2,-8(fp)
8113b7dc:	10000526 	beq	r2,zero,8113b7f4 <alt_iic_isr_register+0xbc>
8113b7e0:	e0bff817 	ldw	r2,-32(fp)
8113b7e4:	100b883a 	mov	r5,r2
8113b7e8:	e13ffc17 	ldw	r4,-16(fp)
8113b7ec:	113b5c00 	call	8113b5c0 <alt_ic_irq_enable>
8113b7f0:	00000406 	br	8113b804 <alt_iic_isr_register+0xcc>
8113b7f4:	e0bff817 	ldw	r2,-32(fp)
8113b7f8:	100b883a 	mov	r5,r2
8113b7fc:	e13ffc17 	ldw	r4,-16(fp)
8113b800:	113b6500 	call	8113b650 <alt_ic_irq_disable>
8113b804:	e0bff715 	stw	r2,-36(fp)
8113b808:	e0bffa17 	ldw	r2,-24(fp)
8113b80c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b810:	e0bff917 	ldw	r2,-28(fp)
8113b814:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8113b818:	e0bff717 	ldw	r2,-36(fp)
}
8113b81c:	e037883a 	mov	sp,fp
8113b820:	dfc00117 	ldw	ra,4(sp)
8113b824:	df000017 	ldw	fp,0(sp)
8113b828:	dec00204 	addi	sp,sp,8
8113b82c:	f800283a 	ret

8113b830 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
8113b830:	defff904 	addi	sp,sp,-28
8113b834:	de00012e 	bgeu	sp,et,8113b83c <alt_open_fd+0xc>
8113b838:	003b68fa 	trap	3
8113b83c:	dfc00615 	stw	ra,24(sp)
8113b840:	df000515 	stw	fp,20(sp)
8113b844:	df000504 	addi	fp,sp,20
8113b848:	e13ffc15 	stw	r4,-16(fp)
8113b84c:	e17ffd15 	stw	r5,-12(fp)
8113b850:	e1bffe15 	stw	r6,-8(fp)
8113b854:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8113b858:	e1bfff17 	ldw	r6,-4(fp)
8113b85c:	e17ffe17 	ldw	r5,-8(fp)
8113b860:	e13ffd17 	ldw	r4,-12(fp)
8113b864:	112862c0 	call	8112862c <open>
8113b868:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8113b86c:	e0bffb17 	ldw	r2,-20(fp)
8113b870:	10001c16 	blt	r2,zero,8113b8e4 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
8113b874:	00a04534 	movhi	r2,33044
8113b878:	1081b904 	addi	r2,r2,1764
8113b87c:	e0fffb17 	ldw	r3,-20(fp)
8113b880:	18c00324 	muli	r3,r3,12
8113b884:	10c5883a 	add	r2,r2,r3
8113b888:	10c00017 	ldw	r3,0(r2)
8113b88c:	e0bffc17 	ldw	r2,-16(fp)
8113b890:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
8113b894:	00a04534 	movhi	r2,33044
8113b898:	1081b904 	addi	r2,r2,1764
8113b89c:	e0fffb17 	ldw	r3,-20(fp)
8113b8a0:	18c00324 	muli	r3,r3,12
8113b8a4:	10c5883a 	add	r2,r2,r3
8113b8a8:	10800104 	addi	r2,r2,4
8113b8ac:	10c00017 	ldw	r3,0(r2)
8113b8b0:	e0bffc17 	ldw	r2,-16(fp)
8113b8b4:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8113b8b8:	00a04534 	movhi	r2,33044
8113b8bc:	1081b904 	addi	r2,r2,1764
8113b8c0:	e0fffb17 	ldw	r3,-20(fp)
8113b8c4:	18c00324 	muli	r3,r3,12
8113b8c8:	10c5883a 	add	r2,r2,r3
8113b8cc:	10800204 	addi	r2,r2,8
8113b8d0:	10c00017 	ldw	r3,0(r2)
8113b8d4:	e0bffc17 	ldw	r2,-16(fp)
8113b8d8:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8113b8dc:	e13ffb17 	ldw	r4,-20(fp)
8113b8e0:	11288d00 	call	811288d0 <alt_release_fd>
  }
} 
8113b8e4:	0001883a 	nop
8113b8e8:	e037883a 	mov	sp,fp
8113b8ec:	dfc00117 	ldw	ra,4(sp)
8113b8f0:	df000017 	ldw	fp,0(sp)
8113b8f4:	dec00204 	addi	sp,sp,8
8113b8f8:	f800283a 	ret

8113b8fc <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8113b8fc:	defffb04 	addi	sp,sp,-20
8113b900:	de00012e 	bgeu	sp,et,8113b908 <alt_io_redirect+0xc>
8113b904:	003b68fa 	trap	3
8113b908:	dfc00415 	stw	ra,16(sp)
8113b90c:	df000315 	stw	fp,12(sp)
8113b910:	df000304 	addi	fp,sp,12
8113b914:	e13ffd15 	stw	r4,-12(fp)
8113b918:	e17ffe15 	stw	r5,-8(fp)
8113b91c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
8113b920:	01c07fc4 	movi	r7,511
8113b924:	01800044 	movi	r6,1
8113b928:	e17ffd17 	ldw	r5,-12(fp)
8113b92c:	01204534 	movhi	r4,33044
8113b930:	2101bc04 	addi	r4,r4,1776
8113b934:	113b8300 	call	8113b830 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8113b938:	01c07fc4 	movi	r7,511
8113b93c:	000d883a 	mov	r6,zero
8113b940:	e17ffe17 	ldw	r5,-8(fp)
8113b944:	01204534 	movhi	r4,33044
8113b948:	2101b904 	addi	r4,r4,1764
8113b94c:	113b8300 	call	8113b830 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
8113b950:	01c07fc4 	movi	r7,511
8113b954:	01800044 	movi	r6,1
8113b958:	e17fff17 	ldw	r5,-4(fp)
8113b95c:	01204534 	movhi	r4,33044
8113b960:	2101bf04 	addi	r4,r4,1788
8113b964:	113b8300 	call	8113b830 <alt_open_fd>
}  
8113b968:	0001883a 	nop
8113b96c:	e037883a 	mov	sp,fp
8113b970:	dfc00117 	ldw	ra,4(sp)
8113b974:	df000017 	ldw	fp,0(sp)
8113b978:	dec00204 	addi	sp,sp,8
8113b97c:	f800283a 	ret

8113b980 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
8113b980:	defff204 	addi	sp,sp,-56
8113b984:	de00012e 	bgeu	sp,et,8113b98c <alt_printf+0xc>
8113b988:	003b68fa 	trap	3
8113b98c:	dfc00a15 	stw	ra,40(sp)
8113b990:	df000915 	stw	fp,36(sp)
8113b994:	df000904 	addi	fp,sp,36
8113b998:	e13fff15 	stw	r4,-4(fp)
8113b99c:	e1400215 	stw	r5,8(fp)
8113b9a0:	e1800315 	stw	r6,12(fp)
8113b9a4:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
8113b9a8:	e0800204 	addi	r2,fp,8
8113b9ac:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
8113b9b0:	e0bfff17 	ldw	r2,-4(fp)
8113b9b4:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8113b9b8:	00006f06 	br	8113bb78 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
8113b9bc:	e0bff807 	ldb	r2,-32(fp)
8113b9c0:	10800960 	cmpeqi	r2,r2,37
8113b9c4:	1000041e 	bne	r2,zero,8113b9d8 <alt_printf+0x58>
        {
            alt_putchar(c);
8113b9c8:	e0bff807 	ldb	r2,-32(fp)
8113b9cc:	1009883a 	mov	r4,r2
8113b9d0:	113bbb40 	call	8113bbb4 <alt_putchar>
8113b9d4:	00006806 	br	8113bb78 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
8113b9d8:	e0bff717 	ldw	r2,-36(fp)
8113b9dc:	10c00044 	addi	r3,r2,1
8113b9e0:	e0fff715 	stw	r3,-36(fp)
8113b9e4:	10800003 	ldbu	r2,0(r2)
8113b9e8:	e0bff805 	stb	r2,-32(fp)
8113b9ec:	e0bff807 	ldb	r2,-32(fp)
8113b9f0:	10006926 	beq	r2,zero,8113bb98 <alt_printf+0x218>
            {
                if (c == '%')
8113b9f4:	e0bff807 	ldb	r2,-32(fp)
8113b9f8:	10800958 	cmpnei	r2,r2,37
8113b9fc:	1000041e 	bne	r2,zero,8113ba10 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8113ba00:	e0bff807 	ldb	r2,-32(fp)
8113ba04:	1009883a 	mov	r4,r2
8113ba08:	113bbb40 	call	8113bbb4 <alt_putchar>
8113ba0c:	00005a06 	br	8113bb78 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8113ba10:	e0bff807 	ldb	r2,-32(fp)
8113ba14:	108018d8 	cmpnei	r2,r2,99
8113ba18:	1000081e 	bne	r2,zero,8113ba3c <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
8113ba1c:	e0bffe17 	ldw	r2,-8(fp)
8113ba20:	10c00104 	addi	r3,r2,4
8113ba24:	e0fffe15 	stw	r3,-8(fp)
8113ba28:	10800017 	ldw	r2,0(r2)
8113ba2c:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8113ba30:	e13ffd17 	ldw	r4,-12(fp)
8113ba34:	113bbb40 	call	8113bbb4 <alt_putchar>
8113ba38:	00004f06 	br	8113bb78 <alt_printf+0x1f8>
                }
                else if (c == 'x')
8113ba3c:	e0bff807 	ldb	r2,-32(fp)
8113ba40:	10801e18 	cmpnei	r2,r2,120
8113ba44:	1000341e 	bne	r2,zero,8113bb18 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8113ba48:	e0bffe17 	ldw	r2,-8(fp)
8113ba4c:	10c00104 	addi	r3,r2,4
8113ba50:	e0fffe15 	stw	r3,-8(fp)
8113ba54:	10800017 	ldw	r2,0(r2)
8113ba58:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
8113ba5c:	e0bffb17 	ldw	r2,-20(fp)
8113ba60:	1000031e 	bne	r2,zero,8113ba70 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
8113ba64:	01000c04 	movi	r4,48
8113ba68:	113bbb40 	call	8113bbb4 <alt_putchar>
                        continue;
8113ba6c:	00004206 	br	8113bb78 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
8113ba70:	00800704 	movi	r2,28
8113ba74:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8113ba78:	00000306 	br	8113ba88 <alt_printf+0x108>
                        digit_shift -= 4;
8113ba7c:	e0bff917 	ldw	r2,-28(fp)
8113ba80:	10bfff04 	addi	r2,r2,-4
8113ba84:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8113ba88:	00c003c4 	movi	r3,15
8113ba8c:	e0bff917 	ldw	r2,-28(fp)
8113ba90:	1884983a 	sll	r2,r3,r2
8113ba94:	1007883a 	mov	r3,r2
8113ba98:	e0bffb17 	ldw	r2,-20(fp)
8113ba9c:	1884703a 	and	r2,r3,r2
8113baa0:	103ff626 	beq	r2,zero,8113ba7c <__reset+0xfb11ba7c>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8113baa4:	00001906 	br	8113bb0c <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
8113baa8:	00c003c4 	movi	r3,15
8113baac:	e0bff917 	ldw	r2,-28(fp)
8113bab0:	1884983a 	sll	r2,r3,r2
8113bab4:	1007883a 	mov	r3,r2
8113bab8:	e0bffb17 	ldw	r2,-20(fp)
8113babc:	1886703a 	and	r3,r3,r2
8113bac0:	e0bff917 	ldw	r2,-28(fp)
8113bac4:	1884d83a 	srl	r2,r3,r2
8113bac8:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
8113bacc:	e0bffc17 	ldw	r2,-16(fp)
8113bad0:	108002a8 	cmpgeui	r2,r2,10
8113bad4:	1000041e 	bne	r2,zero,8113bae8 <alt_printf+0x168>
                            c = '0' + digit;
8113bad8:	e0bffc17 	ldw	r2,-16(fp)
8113badc:	10800c04 	addi	r2,r2,48
8113bae0:	e0bff805 	stb	r2,-32(fp)
8113bae4:	00000306 	br	8113baf4 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
8113bae8:	e0bffc17 	ldw	r2,-16(fp)
8113baec:	108015c4 	addi	r2,r2,87
8113baf0:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
8113baf4:	e0bff807 	ldb	r2,-32(fp)
8113baf8:	1009883a 	mov	r4,r2
8113bafc:	113bbb40 	call	8113bbb4 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8113bb00:	e0bff917 	ldw	r2,-28(fp)
8113bb04:	10bfff04 	addi	r2,r2,-4
8113bb08:	e0bff915 	stw	r2,-28(fp)
8113bb0c:	e0bff917 	ldw	r2,-28(fp)
8113bb10:	103fe50e 	bge	r2,zero,8113baa8 <__reset+0xfb11baa8>
8113bb14:	00001806 	br	8113bb78 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8113bb18:	e0bff807 	ldb	r2,-32(fp)
8113bb1c:	10801cd8 	cmpnei	r2,r2,115
8113bb20:	1000151e 	bne	r2,zero,8113bb78 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
8113bb24:	e0bffe17 	ldw	r2,-8(fp)
8113bb28:	10c00104 	addi	r3,r2,4
8113bb2c:	e0fffe15 	stw	r3,-8(fp)
8113bb30:	10800017 	ldw	r2,0(r2)
8113bb34:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8113bb38:	00000906 	br	8113bb60 <alt_printf+0x1e0>
                      alt_putchar(*s++);
8113bb3c:	e0bffa17 	ldw	r2,-24(fp)
8113bb40:	10c00044 	addi	r3,r2,1
8113bb44:	e0fffa15 	stw	r3,-24(fp)
8113bb48:	10800003 	ldbu	r2,0(r2)
8113bb4c:	10803fcc 	andi	r2,r2,255
8113bb50:	1080201c 	xori	r2,r2,128
8113bb54:	10bfe004 	addi	r2,r2,-128
8113bb58:	1009883a 	mov	r4,r2
8113bb5c:	113bbb40 	call	8113bbb4 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
8113bb60:	e0bffa17 	ldw	r2,-24(fp)
8113bb64:	10800003 	ldbu	r2,0(r2)
8113bb68:	10803fcc 	andi	r2,r2,255
8113bb6c:	1080201c 	xori	r2,r2,128
8113bb70:	10bfe004 	addi	r2,r2,-128
8113bb74:	103ff11e 	bne	r2,zero,8113bb3c <__reset+0xfb11bb3c>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8113bb78:	e0bff717 	ldw	r2,-36(fp)
8113bb7c:	10c00044 	addi	r3,r2,1
8113bb80:	e0fff715 	stw	r3,-36(fp)
8113bb84:	10800003 	ldbu	r2,0(r2)
8113bb88:	e0bff805 	stb	r2,-32(fp)
8113bb8c:	e0bff807 	ldb	r2,-32(fp)
8113bb90:	103f8a1e 	bne	r2,zero,8113b9bc <__reset+0xfb11b9bc>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8113bb94:	00000106 	br	8113bb9c <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
8113bb98:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8113bb9c:	0001883a 	nop
8113bba0:	e037883a 	mov	sp,fp
8113bba4:	dfc00117 	ldw	ra,4(sp)
8113bba8:	df000017 	ldw	fp,0(sp)
8113bbac:	dec00504 	addi	sp,sp,20
8113bbb0:	f800283a 	ret

8113bbb4 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
8113bbb4:	defffd04 	addi	sp,sp,-12
8113bbb8:	de00012e 	bgeu	sp,et,8113bbc0 <alt_putchar+0xc>
8113bbbc:	003b68fa 	trap	3
8113bbc0:	dfc00215 	stw	ra,8(sp)
8113bbc4:	df000115 	stw	fp,4(sp)
8113bbc8:	df000104 	addi	fp,sp,4
8113bbcc:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8113bbd0:	d0a00517 	ldw	r2,-32748(gp)
8113bbd4:	10800217 	ldw	r2,8(r2)
8113bbd8:	100b883a 	mov	r5,r2
8113bbdc:	e13fff17 	ldw	r4,-4(fp)
8113bbe0:	113c2280 	call	8113c228 <putc>
#endif
#endif
}
8113bbe4:	e037883a 	mov	sp,fp
8113bbe8:	dfc00117 	ldw	ra,4(sp)
8113bbec:	df000017 	ldw	fp,0(sp)
8113bbf0:	dec00204 	addi	sp,sp,8
8113bbf4:	f800283a 	ret

8113bbf8 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8113bbf8:	deffff04 	addi	sp,sp,-4
8113bbfc:	de00012e 	bgeu	sp,et,8113bc04 <altera_nios2_gen2_irq_init+0xc>
8113bc00:	003b68fa 	trap	3
8113bc04:	df000015 	stw	fp,0(sp)
8113bc08:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
8113bc0c:	000170fa 	wrctl	ienable,zero
}
8113bc10:	0001883a 	nop
8113bc14:	e037883a 	mov	sp,fp
8113bc18:	df000017 	ldw	fp,0(sp)
8113bc1c:	dec00104 	addi	sp,sp,4
8113bc20:	f800283a 	ret

8113bc24 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
8113bc24:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8113bc28:	de002436 	bltu	sp,et,8113bcbc <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
8113bc2c:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8113bc30:	d1208617 	ldw	r4,-32232(gp)

      stw ra,  0(sp)
8113bc34:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8113bc38:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
8113bc3c:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8113bc40:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
8113bc44:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8113bc48:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
8113bc4c:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8113bc50:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
8113bc54:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
8113bc58:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
8113bc5c:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
8113bc60:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8113bc64:	113bec00 	call	8113bec0 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
8113bc68:	d1208017 	ldw	r4,-32256(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
8113bc6c:	d1607787 	ldb	r5,-32290(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
8113bc70:	d1208615 	stw	r4,-32232(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
8113bc74:	d16077c5 	stb	r5,-32289(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
8113bc78:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
8113bc7c:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
8113bc80:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
8113bc84:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
8113bc88:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
8113bc8c:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
8113bc90:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
8113bc94:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
8113bc98:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
8113bc9c:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
8113bca0:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
8113bca4:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
8113bca8:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
8113bcac:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
8113bcb0:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
8113bcb4:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
8113bcb8:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
8113bcbc:	003da0fa 	break	3

8113bcc0 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8113bcc0:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
8113bcc4:	047fff84 	movi	r17,-2
      and   r18, r18, r17
8113bcc8:	9464703a 	and	r18,r18,r17
      wrctl status, r18
8113bccc:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8113bcd0:	113bec00 	call	8113bec0 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
8113bcd4:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
8113bcd8:	d4a07505 	stb	r18,-32300(gp)

      /*
       * start execution of the new task.
       */

      br 9b
8113bcdc:	003fe206 	br	8113bc68 <__reset+0xfb11bc68>

8113bce0 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8113bce0:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
8113bce4:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
8113bce8:	10800054 	ori	r2,r2,1
      wrctl status, r2
8113bcec:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8113bcf0:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
8113bcf4:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8113bcf8:	dec00204 	addi	sp,sp,8

      callr r2
8113bcfc:	103ee83a 	callr	r2

      nop
8113bd00:	0001883a 	nop

8113bd04 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
8113bd04:	defff704 	addi	sp,sp,-36
8113bd08:	de00012e 	bgeu	sp,et,8113bd10 <OSTaskStkInit+0xc>
8113bd0c:	003b68fa 	trap	3
8113bd10:	dfc00815 	stw	ra,32(sp)
8113bd14:	df000715 	stw	fp,28(sp)
8113bd18:	df000704 	addi	fp,sp,28
8113bd1c:	e13ffc15 	stw	r4,-16(fp)
8113bd20:	e17ffd15 	stw	r5,-12(fp)
8113bd24:	e1bffe15 	stw	r6,-8(fp)
8113bd28:	3805883a 	mov	r2,r7
8113bd2c:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8113bd30:	e0fffe17 	ldw	r3,-8(fp)
8113bd34:	00bfff04 	movi	r2,-4
8113bd38:	1884703a 	and	r2,r3,r2
8113bd3c:	10bef704 	addi	r2,r2,-1060
8113bd40:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
8113bd44:	01810904 	movi	r6,1060
8113bd48:	000b883a 	mov	r5,zero
8113bd4c:	e13ff917 	ldw	r4,-28(fp)
8113bd50:	11138300 	call	81113830 <memset>
8113bd54:	e0bff917 	ldw	r2,-28(fp)
8113bd58:	10c0bb04 	addi	r3,r2,748
8113bd5c:	e0bff917 	ldw	r2,-28(fp)
8113bd60:	10c00115 	stw	r3,4(r2)
8113bd64:	e0bff917 	ldw	r2,-28(fp)
8113bd68:	10c0d504 	addi	r3,r2,852
8113bd6c:	e0bff917 	ldw	r2,-28(fp)
8113bd70:	10c00215 	stw	r3,8(r2)
8113bd74:	e0bff917 	ldw	r2,-28(fp)
8113bd78:	10c0ef04 	addi	r3,r2,956
8113bd7c:	e0bff917 	ldw	r2,-28(fp)
8113bd80:	10c00315 	stw	r3,12(r2)
8113bd84:	e0fff917 	ldw	r3,-28(fp)
8113bd88:	00a04534 	movhi	r2,33044
8113bd8c:	10bf8504 	addi	r2,r2,-492
8113bd90:	18800d15 	stw	r2,52(r3)
8113bd94:	e0bff917 	ldw	r2,-28(fp)
8113bd98:	00c00044 	movi	r3,1
8113bd9c:	10c02915 	stw	r3,164(r2)
8113bda0:	10002a15 	stw	zero,168(r2)
8113bda4:	e0bff917 	ldw	r2,-28(fp)
8113bda8:	00ccc384 	movi	r3,13070
8113bdac:	10c02b0d 	sth	r3,172(r2)
8113bdb0:	e0bff917 	ldw	r2,-28(fp)
8113bdb4:	00eaf344 	movi	r3,-21555
8113bdb8:	10c02b8d 	sth	r3,174(r2)
8113bdbc:	e0bff917 	ldw	r2,-28(fp)
8113bdc0:	00c48d04 	movi	r3,4660
8113bdc4:	10c02c0d 	sth	r3,176(r2)
8113bdc8:	e0bff917 	ldw	r2,-28(fp)
8113bdcc:	00f99b44 	movi	r3,-6547
8113bdd0:	10c02c8d 	sth	r3,178(r2)
8113bdd4:	e0bff917 	ldw	r2,-28(fp)
8113bdd8:	00f7bb04 	movi	r3,-8468
8113bddc:	10c02d0d 	sth	r3,180(r2)
8113bde0:	e0bff917 	ldw	r2,-28(fp)
8113bde4:	00c00144 	movi	r3,5
8113bde8:	10c02d8d 	sth	r3,182(r2)
8113bdec:	e0bff917 	ldw	r2,-28(fp)
8113bdf0:	00c002c4 	movi	r3,11
8113bdf4:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8113bdf8:	e0bff917 	ldw	r2,-28(fp)
8113bdfc:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8113be00:	e0bffa17 	ldw	r2,-24(fp)
8113be04:	10bff304 	addi	r2,r2,-52
8113be08:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
8113be0c:	e0bffb17 	ldw	r2,-20(fp)
8113be10:	10800c04 	addi	r2,r2,48
8113be14:	e0fffc17 	ldw	r3,-16(fp)
8113be18:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
8113be1c:	e0bffb17 	ldw	r2,-20(fp)
8113be20:	10800b04 	addi	r2,r2,44
8113be24:	e0fffd17 	ldw	r3,-12(fp)
8113be28:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
8113be2c:	e0bffb17 	ldw	r2,-20(fp)
8113be30:	10800a04 	addi	r2,r2,40
8113be34:	e0fff917 	ldw	r3,-28(fp)
8113be38:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8113be3c:	00a04534 	movhi	r2,33044
8113be40:	10af3804 	addi	r2,r2,-17184
8113be44:	10c00104 	addi	r3,r2,4
8113be48:	e0bffb17 	ldw	r2,-20(fp)
8113be4c:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8113be50:	e0bffb17 	ldw	r2,-20(fp)
}
8113be54:	e037883a 	mov	sp,fp
8113be58:	dfc00117 	ldw	ra,4(sp)
8113be5c:	df000017 	ldw	fp,0(sp)
8113be60:	dec00204 	addi	sp,sp,8
8113be64:	f800283a 	ret

8113be68 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8113be68:	defffe04 	addi	sp,sp,-8
8113be6c:	de00012e 	bgeu	sp,et,8113be74 <OSTaskCreateHook+0xc>
8113be70:	003b68fa 	trap	3
8113be74:	df000115 	stw	fp,4(sp)
8113be78:	df000104 	addi	fp,sp,4
8113be7c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
8113be80:	0001883a 	nop
8113be84:	e037883a 	mov	sp,fp
8113be88:	df000017 	ldw	fp,0(sp)
8113be8c:	dec00104 	addi	sp,sp,4
8113be90:	f800283a 	ret

8113be94 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
8113be94:	defffe04 	addi	sp,sp,-8
8113be98:	de00012e 	bgeu	sp,et,8113bea0 <OSTaskDelHook+0xc>
8113be9c:	003b68fa 	trap	3
8113bea0:	df000115 	stw	fp,4(sp)
8113bea4:	df000104 	addi	fp,sp,4
8113bea8:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8113beac:	0001883a 	nop
8113beb0:	e037883a 	mov	sp,fp
8113beb4:	df000017 	ldw	fp,0(sp)
8113beb8:	dec00104 	addi	sp,sp,4
8113bebc:	f800283a 	ret

8113bec0 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
8113bec0:	deffff04 	addi	sp,sp,-4
8113bec4:	de00012e 	bgeu	sp,et,8113becc <OSTaskSwHook+0xc>
8113bec8:	003b68fa 	trap	3
8113becc:	df000015 	stw	fp,0(sp)
8113bed0:	d839883a 	mov	fp,sp
}
8113bed4:	0001883a 	nop
8113bed8:	e037883a 	mov	sp,fp
8113bedc:	df000017 	ldw	fp,0(sp)
8113bee0:	dec00104 	addi	sp,sp,4
8113bee4:	f800283a 	ret

8113bee8 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8113bee8:	deffff04 	addi	sp,sp,-4
8113beec:	de00012e 	bgeu	sp,et,8113bef4 <OSTaskStatHook+0xc>
8113bef0:	003b68fa 	trap	3
8113bef4:	df000015 	stw	fp,0(sp)
8113bef8:	d839883a 	mov	fp,sp
}
8113befc:	0001883a 	nop
8113bf00:	e037883a 	mov	sp,fp
8113bf04:	df000017 	ldw	fp,0(sp)
8113bf08:	dec00104 	addi	sp,sp,4
8113bf0c:	f800283a 	ret

8113bf10 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
8113bf10:	defffe04 	addi	sp,sp,-8
8113bf14:	de00012e 	bgeu	sp,et,8113bf1c <OSTimeTickHook+0xc>
8113bf18:	003b68fa 	trap	3
8113bf1c:	dfc00115 	stw	ra,4(sp)
8113bf20:	df000015 	stw	fp,0(sp)
8113bf24:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8113bf28:	d0a09a0b 	ldhu	r2,-32152(gp)
8113bf2c:	10800044 	addi	r2,r2,1
8113bf30:	d0a09a0d 	sth	r2,-32152(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
8113bf34:	d0a09a0b 	ldhu	r2,-32152(gp)
8113bf38:	10bfffcc 	andi	r2,r2,65535
8113bf3c:	10803230 	cmpltui	r2,r2,200
8113bf40:	1000021e 	bne	r2,zero,8113bf4c <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
8113bf44:	d0209a0d 	sth	zero,-32152(gp)
        OSTmrSignal();
8113bf48:	11328240 	call	81132824 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8113bf4c:	0001883a 	nop
8113bf50:	e037883a 	mov	sp,fp
8113bf54:	dfc00117 	ldw	ra,4(sp)
8113bf58:	df000017 	ldw	fp,0(sp)
8113bf5c:	dec00204 	addi	sp,sp,8
8113bf60:	f800283a 	ret

8113bf64 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
8113bf64:	deffff04 	addi	sp,sp,-4
8113bf68:	de00012e 	bgeu	sp,et,8113bf70 <OSInitHookBegin+0xc>
8113bf6c:	003b68fa 	trap	3
8113bf70:	df000015 	stw	fp,0(sp)
8113bf74:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8113bf78:	d0209a0d 	sth	zero,-32152(gp)
#endif
}
8113bf7c:	0001883a 	nop
8113bf80:	e037883a 	mov	sp,fp
8113bf84:	df000017 	ldw	fp,0(sp)
8113bf88:	dec00104 	addi	sp,sp,4
8113bf8c:	f800283a 	ret

8113bf90 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
8113bf90:	deffff04 	addi	sp,sp,-4
8113bf94:	de00012e 	bgeu	sp,et,8113bf9c <OSInitHookEnd+0xc>
8113bf98:	003b68fa 	trap	3
8113bf9c:	df000015 	stw	fp,0(sp)
8113bfa0:	d839883a 	mov	fp,sp
}
8113bfa4:	0001883a 	nop
8113bfa8:	e037883a 	mov	sp,fp
8113bfac:	df000017 	ldw	fp,0(sp)
8113bfb0:	dec00104 	addi	sp,sp,4
8113bfb4:	f800283a 	ret

8113bfb8 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8113bfb8:	deffff04 	addi	sp,sp,-4
8113bfbc:	de00012e 	bgeu	sp,et,8113bfc4 <OSTaskIdleHook+0xc>
8113bfc0:	003b68fa 	trap	3
8113bfc4:	df000015 	stw	fp,0(sp)
8113bfc8:	d839883a 	mov	fp,sp
}
8113bfcc:	0001883a 	nop
8113bfd0:	e037883a 	mov	sp,fp
8113bfd4:	df000017 	ldw	fp,0(sp)
8113bfd8:	dec00104 	addi	sp,sp,4
8113bfdc:	f800283a 	ret

8113bfe0 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
8113bfe0:	defffe04 	addi	sp,sp,-8
8113bfe4:	de00012e 	bgeu	sp,et,8113bfec <OSTCBInitHook+0xc>
8113bfe8:	003b68fa 	trap	3
8113bfec:	df000115 	stw	fp,4(sp)
8113bff0:	df000104 	addi	fp,sp,4
8113bff4:	e13fff15 	stw	r4,-4(fp)
}
8113bff8:	0001883a 	nop
8113bffc:	e037883a 	mov	sp,fp
8113c000:	df000017 	ldw	fp,0(sp)
8113c004:	dec00104 	addi	sp,sp,4
8113c008:	f800283a 	ret

8113c00c <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8113c00c:	defffe04 	addi	sp,sp,-8
8113c010:	de00012e 	bgeu	sp,et,8113c018 <alt_exception_cause_generated_bad_addr+0xc>
8113c014:	003b68fa 	trap	3
8113c018:	df000115 	stw	fp,4(sp)
8113c01c:	df000104 	addi	fp,sp,4
8113c020:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
8113c024:	e0bfff17 	ldw	r2,-4(fp)
8113c028:	10bffe84 	addi	r2,r2,-6
8113c02c:	10c00428 	cmpgeui	r3,r2,16
8113c030:	18001a1e 	bne	r3,zero,8113c09c <alt_exception_cause_generated_bad_addr+0x90>
8113c034:	100690ba 	slli	r3,r2,2
8113c038:	00a04534 	movhi	r2,33044
8113c03c:	10b01304 	addi	r2,r2,-16308
8113c040:	1885883a 	add	r2,r3,r2
8113c044:	10800017 	ldw	r2,0(r2)
8113c048:	1000683a 	jmp	r2
8113c04c:	8113c08c 	andi	r4,r16,20226
8113c050:	8113c08c 	andi	r4,r16,20226
8113c054:	8113c09c 	xori	r4,r16,20226
8113c058:	8113c09c 	xori	r4,r16,20226
8113c05c:	8113c09c 	xori	r4,r16,20226
8113c060:	8113c08c 	andi	r4,r16,20226
8113c064:	8113c094 	ori	r4,r16,20226
8113c068:	8113c09c 	xori	r4,r16,20226
8113c06c:	8113c08c 	andi	r4,r16,20226
8113c070:	8113c08c 	andi	r4,r16,20226
8113c074:	8113c09c 	xori	r4,r16,20226
8113c078:	8113c08c 	andi	r4,r16,20226
8113c07c:	8113c094 	ori	r4,r16,20226
8113c080:	8113c09c 	xori	r4,r16,20226
8113c084:	8113c09c 	xori	r4,r16,20226
8113c088:	8113c08c 	andi	r4,r16,20226
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8113c08c:	00800044 	movi	r2,1
8113c090:	00000306 	br	8113c0a0 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
8113c094:	0005883a 	mov	r2,zero
8113c098:	00000106 	br	8113c0a0 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8113c09c:	0005883a 	mov	r2,zero
  }
}
8113c0a0:	e037883a 	mov	sp,fp
8113c0a4:	df000017 	ldw	fp,0(sp)
8113c0a8:	dec00104 	addi	sp,sp,4
8113c0ac:	f800283a 	ret

8113c0b0 <atexit>:
8113c0b0:	200b883a 	mov	r5,r4
8113c0b4:	000f883a 	mov	r7,zero
8113c0b8:	000d883a 	mov	r6,zero
8113c0bc:	0009883a 	mov	r4,zero
8113c0c0:	113c2f81 	jmpi	8113c2f8 <__register_exitproc>

8113c0c4 <exit>:
8113c0c4:	defffe04 	addi	sp,sp,-8
8113c0c8:	000b883a 	mov	r5,zero
8113c0cc:	de00012e 	bgeu	sp,et,8113c0d4 <exit+0x10>
8113c0d0:	003b68fa 	trap	3
8113c0d4:	dc000015 	stw	r16,0(sp)
8113c0d8:	dfc00115 	stw	ra,4(sp)
8113c0dc:	2021883a 	mov	r16,r4
8113c0e0:	113c4180 	call	8113c418 <__call_exitprocs>
8113c0e4:	00a04534 	movhi	r2,33044
8113c0e8:	1086a904 	addi	r2,r2,6820
8113c0ec:	11000017 	ldw	r4,0(r2)
8113c0f0:	20800f17 	ldw	r2,60(r4)
8113c0f4:	10000126 	beq	r2,zero,8113c0fc <exit+0x38>
8113c0f8:	103ee83a 	callr	r2
8113c0fc:	8009883a 	mov	r4,r16
8113c100:	113c5a00 	call	8113c5a0 <_exit>

8113c104 <memcmp>:
8113c104:	01c000c4 	movi	r7,3
8113c108:	3980192e 	bgeu	r7,r6,8113c170 <memcmp+0x6c>
8113c10c:	2144b03a 	or	r2,r4,r5
8113c110:	11c4703a 	and	r2,r2,r7
8113c114:	10000f26 	beq	r2,zero,8113c154 <memcmp+0x50>
8113c118:	20800003 	ldbu	r2,0(r4)
8113c11c:	28c00003 	ldbu	r3,0(r5)
8113c120:	10c0151e 	bne	r2,r3,8113c178 <memcmp+0x74>
8113c124:	31bfff84 	addi	r6,r6,-2
8113c128:	01ffffc4 	movi	r7,-1
8113c12c:	00000406 	br	8113c140 <memcmp+0x3c>
8113c130:	20800003 	ldbu	r2,0(r4)
8113c134:	28c00003 	ldbu	r3,0(r5)
8113c138:	31bfffc4 	addi	r6,r6,-1
8113c13c:	10c00e1e 	bne	r2,r3,8113c178 <memcmp+0x74>
8113c140:	21000044 	addi	r4,r4,1
8113c144:	29400044 	addi	r5,r5,1
8113c148:	31fff91e 	bne	r6,r7,8113c130 <__reset+0xfb11c130>
8113c14c:	0005883a 	mov	r2,zero
8113c150:	f800283a 	ret
8113c154:	20c00017 	ldw	r3,0(r4)
8113c158:	28800017 	ldw	r2,0(r5)
8113c15c:	18bfee1e 	bne	r3,r2,8113c118 <__reset+0xfb11c118>
8113c160:	31bfff04 	addi	r6,r6,-4
8113c164:	21000104 	addi	r4,r4,4
8113c168:	29400104 	addi	r5,r5,4
8113c16c:	39bff936 	bltu	r7,r6,8113c154 <__reset+0xfb11c154>
8113c170:	303fe91e 	bne	r6,zero,8113c118 <__reset+0xfb11c118>
8113c174:	003ff506 	br	8113c14c <__reset+0xfb11c14c>
8113c178:	10c5c83a 	sub	r2,r2,r3
8113c17c:	f800283a 	ret

8113c180 <_putc_r>:
8113c180:	defffc04 	addi	sp,sp,-16
8113c184:	de00012e 	bgeu	sp,et,8113c18c <_putc_r+0xc>
8113c188:	003b68fa 	trap	3
8113c18c:	dc000215 	stw	r16,8(sp)
8113c190:	dfc00315 	stw	ra,12(sp)
8113c194:	2021883a 	mov	r16,r4
8113c198:	20000226 	beq	r4,zero,8113c1a4 <_putc_r+0x24>
8113c19c:	20800e17 	ldw	r2,56(r4)
8113c1a0:	10001b26 	beq	r2,zero,8113c210 <_putc_r+0x90>
8113c1a4:	30800217 	ldw	r2,8(r6)
8113c1a8:	10bfffc4 	addi	r2,r2,-1
8113c1ac:	30800215 	stw	r2,8(r6)
8113c1b0:	10000a16 	blt	r2,zero,8113c1dc <_putc_r+0x5c>
8113c1b4:	30800017 	ldw	r2,0(r6)
8113c1b8:	11400005 	stb	r5,0(r2)
8113c1bc:	30800017 	ldw	r2,0(r6)
8113c1c0:	10c00044 	addi	r3,r2,1
8113c1c4:	30c00015 	stw	r3,0(r6)
8113c1c8:	10800003 	ldbu	r2,0(r2)
8113c1cc:	dfc00317 	ldw	ra,12(sp)
8113c1d0:	dc000217 	ldw	r16,8(sp)
8113c1d4:	dec00404 	addi	sp,sp,16
8113c1d8:	f800283a 	ret
8113c1dc:	30c00617 	ldw	r3,24(r6)
8113c1e0:	10c00616 	blt	r2,r3,8113c1fc <_putc_r+0x7c>
8113c1e4:	30800017 	ldw	r2,0(r6)
8113c1e8:	00c00284 	movi	r3,10
8113c1ec:	11400005 	stb	r5,0(r2)
8113c1f0:	30800017 	ldw	r2,0(r6)
8113c1f4:	11400003 	ldbu	r5,0(r2)
8113c1f8:	28fff11e 	bne	r5,r3,8113c1c0 <__reset+0xfb11c1c0>
8113c1fc:	8009883a 	mov	r4,r16
8113c200:	dfc00317 	ldw	ra,12(sp)
8113c204:	dc000217 	ldw	r16,8(sp)
8113c208:	dec00404 	addi	sp,sp,16
8113c20c:	1124bbc1 	jmpi	81124bbc <__swbuf_r>
8113c210:	d9400015 	stw	r5,0(sp)
8113c214:	d9800115 	stw	r6,4(sp)
8113c218:	111c1d00 	call	8111c1d0 <__sinit>
8113c21c:	d9800117 	ldw	r6,4(sp)
8113c220:	d9400017 	ldw	r5,0(sp)
8113c224:	003fdf06 	br	8113c1a4 <__reset+0xfb11c1a4>

8113c228 <putc>:
8113c228:	00a04534 	movhi	r2,33044
8113c22c:	defffc04 	addi	sp,sp,-16
8113c230:	1086aa04 	addi	r2,r2,6824
8113c234:	de00012e 	bgeu	sp,et,8113c23c <putc+0x14>
8113c238:	003b68fa 	trap	3
8113c23c:	dc000115 	stw	r16,4(sp)
8113c240:	14000017 	ldw	r16,0(r2)
8113c244:	dc400215 	stw	r17,8(sp)
8113c248:	dfc00315 	stw	ra,12(sp)
8113c24c:	2023883a 	mov	r17,r4
8113c250:	80000226 	beq	r16,zero,8113c25c <putc+0x34>
8113c254:	80800e17 	ldw	r2,56(r16)
8113c258:	10001a26 	beq	r2,zero,8113c2c4 <putc+0x9c>
8113c25c:	28800217 	ldw	r2,8(r5)
8113c260:	10bfffc4 	addi	r2,r2,-1
8113c264:	28800215 	stw	r2,8(r5)
8113c268:	10000b16 	blt	r2,zero,8113c298 <putc+0x70>
8113c26c:	28800017 	ldw	r2,0(r5)
8113c270:	14400005 	stb	r17,0(r2)
8113c274:	28800017 	ldw	r2,0(r5)
8113c278:	10c00044 	addi	r3,r2,1
8113c27c:	28c00015 	stw	r3,0(r5)
8113c280:	10800003 	ldbu	r2,0(r2)
8113c284:	dfc00317 	ldw	ra,12(sp)
8113c288:	dc400217 	ldw	r17,8(sp)
8113c28c:	dc000117 	ldw	r16,4(sp)
8113c290:	dec00404 	addi	sp,sp,16
8113c294:	f800283a 	ret
8113c298:	28c00617 	ldw	r3,24(r5)
8113c29c:	10c00e16 	blt	r2,r3,8113c2d8 <putc+0xb0>
8113c2a0:	28800017 	ldw	r2,0(r5)
8113c2a4:	01000284 	movi	r4,10
8113c2a8:	14400005 	stb	r17,0(r2)
8113c2ac:	28800017 	ldw	r2,0(r5)
8113c2b0:	10c00003 	ldbu	r3,0(r2)
8113c2b4:	193ff01e 	bne	r3,r4,8113c278 <__reset+0xfb11c278>
8113c2b8:	280d883a 	mov	r6,r5
8113c2bc:	180b883a 	mov	r5,r3
8113c2c0:	00000706 	br	8113c2e0 <putc+0xb8>
8113c2c4:	8009883a 	mov	r4,r16
8113c2c8:	d9400015 	stw	r5,0(sp)
8113c2cc:	111c1d00 	call	8111c1d0 <__sinit>
8113c2d0:	d9400017 	ldw	r5,0(sp)
8113c2d4:	003fe106 	br	8113c25c <__reset+0xfb11c25c>
8113c2d8:	280d883a 	mov	r6,r5
8113c2dc:	880b883a 	mov	r5,r17
8113c2e0:	8009883a 	mov	r4,r16
8113c2e4:	dfc00317 	ldw	ra,12(sp)
8113c2e8:	dc400217 	ldw	r17,8(sp)
8113c2ec:	dc000117 	ldw	r16,4(sp)
8113c2f0:	dec00404 	addi	sp,sp,16
8113c2f4:	1124bbc1 	jmpi	81124bbc <__swbuf_r>

8113c2f8 <__register_exitproc>:
8113c2f8:	defffa04 	addi	sp,sp,-24
8113c2fc:	de00012e 	bgeu	sp,et,8113c304 <__register_exitproc+0xc>
8113c300:	003b68fa 	trap	3
8113c304:	dc000315 	stw	r16,12(sp)
8113c308:	04204534 	movhi	r16,33044
8113c30c:	8406a904 	addi	r16,r16,6820
8113c310:	80c00017 	ldw	r3,0(r16)
8113c314:	dc400415 	stw	r17,16(sp)
8113c318:	dfc00515 	stw	ra,20(sp)
8113c31c:	18805217 	ldw	r2,328(r3)
8113c320:	2023883a 	mov	r17,r4
8113c324:	10003726 	beq	r2,zero,8113c404 <__register_exitproc+0x10c>
8113c328:	10c00117 	ldw	r3,4(r2)
8113c32c:	010007c4 	movi	r4,31
8113c330:	20c00e16 	blt	r4,r3,8113c36c <__register_exitproc+0x74>
8113c334:	1a000044 	addi	r8,r3,1
8113c338:	8800221e 	bne	r17,zero,8113c3c4 <__register_exitproc+0xcc>
8113c33c:	18c00084 	addi	r3,r3,2
8113c340:	18c7883a 	add	r3,r3,r3
8113c344:	18c7883a 	add	r3,r3,r3
8113c348:	12000115 	stw	r8,4(r2)
8113c34c:	10c7883a 	add	r3,r2,r3
8113c350:	19400015 	stw	r5,0(r3)
8113c354:	0005883a 	mov	r2,zero
8113c358:	dfc00517 	ldw	ra,20(sp)
8113c35c:	dc400417 	ldw	r17,16(sp)
8113c360:	dc000317 	ldw	r16,12(sp)
8113c364:	dec00604 	addi	sp,sp,24
8113c368:	f800283a 	ret
8113c36c:	00800034 	movhi	r2,0
8113c370:	10800004 	addi	r2,r2,0
8113c374:	10002626 	beq	r2,zero,8113c410 <__register_exitproc+0x118>
8113c378:	01006404 	movi	r4,400
8113c37c:	d9400015 	stw	r5,0(sp)
8113c380:	d9800115 	stw	r6,4(sp)
8113c384:	d9c00215 	stw	r7,8(sp)
8113c388:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8113c38c:	d9400017 	ldw	r5,0(sp)
8113c390:	d9800117 	ldw	r6,4(sp)
8113c394:	d9c00217 	ldw	r7,8(sp)
8113c398:	10001d26 	beq	r2,zero,8113c410 <__register_exitproc+0x118>
8113c39c:	81000017 	ldw	r4,0(r16)
8113c3a0:	10000115 	stw	zero,4(r2)
8113c3a4:	02000044 	movi	r8,1
8113c3a8:	22405217 	ldw	r9,328(r4)
8113c3ac:	0007883a 	mov	r3,zero
8113c3b0:	12400015 	stw	r9,0(r2)
8113c3b4:	20805215 	stw	r2,328(r4)
8113c3b8:	10006215 	stw	zero,392(r2)
8113c3bc:	10006315 	stw	zero,396(r2)
8113c3c0:	883fde26 	beq	r17,zero,8113c33c <__reset+0xfb11c33c>
8113c3c4:	18c9883a 	add	r4,r3,r3
8113c3c8:	2109883a 	add	r4,r4,r4
8113c3cc:	1109883a 	add	r4,r2,r4
8113c3d0:	21802215 	stw	r6,136(r4)
8113c3d4:	01800044 	movi	r6,1
8113c3d8:	12406217 	ldw	r9,392(r2)
8113c3dc:	30cc983a 	sll	r6,r6,r3
8113c3e0:	4992b03a 	or	r9,r9,r6
8113c3e4:	12406215 	stw	r9,392(r2)
8113c3e8:	21c04215 	stw	r7,264(r4)
8113c3ec:	01000084 	movi	r4,2
8113c3f0:	893fd21e 	bne	r17,r4,8113c33c <__reset+0xfb11c33c>
8113c3f4:	11006317 	ldw	r4,396(r2)
8113c3f8:	218cb03a 	or	r6,r4,r6
8113c3fc:	11806315 	stw	r6,396(r2)
8113c400:	003fce06 	br	8113c33c <__reset+0xfb11c33c>
8113c404:	18805304 	addi	r2,r3,332
8113c408:	18805215 	stw	r2,328(r3)
8113c40c:	003fc606 	br	8113c328 <__reset+0xfb11c328>
8113c410:	00bfffc4 	movi	r2,-1
8113c414:	003fd006 	br	8113c358 <__reset+0xfb11c358>

8113c418 <__call_exitprocs>:
8113c418:	defff504 	addi	sp,sp,-44
8113c41c:	de00012e 	bgeu	sp,et,8113c424 <__call_exitprocs+0xc>
8113c420:	003b68fa 	trap	3
8113c424:	df000915 	stw	fp,36(sp)
8113c428:	dd400615 	stw	r21,24(sp)
8113c42c:	dc800315 	stw	r18,12(sp)
8113c430:	dfc00a15 	stw	ra,40(sp)
8113c434:	ddc00815 	stw	r23,32(sp)
8113c438:	dd800715 	stw	r22,28(sp)
8113c43c:	dd000515 	stw	r20,20(sp)
8113c440:	dcc00415 	stw	r19,16(sp)
8113c444:	dc400215 	stw	r17,8(sp)
8113c448:	dc000115 	stw	r16,4(sp)
8113c44c:	d9000015 	stw	r4,0(sp)
8113c450:	2839883a 	mov	fp,r5
8113c454:	04800044 	movi	r18,1
8113c458:	057fffc4 	movi	r21,-1
8113c45c:	00a04534 	movhi	r2,33044
8113c460:	1086a904 	addi	r2,r2,6820
8113c464:	12000017 	ldw	r8,0(r2)
8113c468:	45005217 	ldw	r20,328(r8)
8113c46c:	44c05204 	addi	r19,r8,328
8113c470:	a0001c26 	beq	r20,zero,8113c4e4 <__call_exitprocs+0xcc>
8113c474:	a0800117 	ldw	r2,4(r20)
8113c478:	15ffffc4 	addi	r23,r2,-1
8113c47c:	b8000d16 	blt	r23,zero,8113c4b4 <__call_exitprocs+0x9c>
8113c480:	14000044 	addi	r16,r2,1
8113c484:	8421883a 	add	r16,r16,r16
8113c488:	8421883a 	add	r16,r16,r16
8113c48c:	84402004 	addi	r17,r16,128
8113c490:	a463883a 	add	r17,r20,r17
8113c494:	a421883a 	add	r16,r20,r16
8113c498:	e0001e26 	beq	fp,zero,8113c514 <__call_exitprocs+0xfc>
8113c49c:	80804017 	ldw	r2,256(r16)
8113c4a0:	e0801c26 	beq	fp,r2,8113c514 <__call_exitprocs+0xfc>
8113c4a4:	bdffffc4 	addi	r23,r23,-1
8113c4a8:	843fff04 	addi	r16,r16,-4
8113c4ac:	8c7fff04 	addi	r17,r17,-4
8113c4b0:	bd7ff91e 	bne	r23,r21,8113c498 <__reset+0xfb11c498>
8113c4b4:	00800034 	movhi	r2,0
8113c4b8:	10800004 	addi	r2,r2,0
8113c4bc:	10000926 	beq	r2,zero,8113c4e4 <__call_exitprocs+0xcc>
8113c4c0:	a0800117 	ldw	r2,4(r20)
8113c4c4:	1000301e 	bne	r2,zero,8113c588 <__call_exitprocs+0x170>
8113c4c8:	a0800017 	ldw	r2,0(r20)
8113c4cc:	10003226 	beq	r2,zero,8113c598 <__call_exitprocs+0x180>
8113c4d0:	a009883a 	mov	r4,r20
8113c4d4:	98800015 	stw	r2,0(r19)
8113c4d8:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8113c4dc:	9d000017 	ldw	r20,0(r19)
8113c4e0:	a03fe41e 	bne	r20,zero,8113c474 <__reset+0xfb11c474>
8113c4e4:	dfc00a17 	ldw	ra,40(sp)
8113c4e8:	df000917 	ldw	fp,36(sp)
8113c4ec:	ddc00817 	ldw	r23,32(sp)
8113c4f0:	dd800717 	ldw	r22,28(sp)
8113c4f4:	dd400617 	ldw	r21,24(sp)
8113c4f8:	dd000517 	ldw	r20,20(sp)
8113c4fc:	dcc00417 	ldw	r19,16(sp)
8113c500:	dc800317 	ldw	r18,12(sp)
8113c504:	dc400217 	ldw	r17,8(sp)
8113c508:	dc000117 	ldw	r16,4(sp)
8113c50c:	dec00b04 	addi	sp,sp,44
8113c510:	f800283a 	ret
8113c514:	a0800117 	ldw	r2,4(r20)
8113c518:	80c00017 	ldw	r3,0(r16)
8113c51c:	10bfffc4 	addi	r2,r2,-1
8113c520:	15c01426 	beq	r2,r23,8113c574 <__call_exitprocs+0x15c>
8113c524:	80000015 	stw	zero,0(r16)
8113c528:	183fde26 	beq	r3,zero,8113c4a4 <__reset+0xfb11c4a4>
8113c52c:	95c8983a 	sll	r4,r18,r23
8113c530:	a0806217 	ldw	r2,392(r20)
8113c534:	a5800117 	ldw	r22,4(r20)
8113c538:	2084703a 	and	r2,r4,r2
8113c53c:	10000b26 	beq	r2,zero,8113c56c <__call_exitprocs+0x154>
8113c540:	a0806317 	ldw	r2,396(r20)
8113c544:	2088703a 	and	r4,r4,r2
8113c548:	20000c1e 	bne	r4,zero,8113c57c <__call_exitprocs+0x164>
8113c54c:	89400017 	ldw	r5,0(r17)
8113c550:	d9000017 	ldw	r4,0(sp)
8113c554:	183ee83a 	callr	r3
8113c558:	a0800117 	ldw	r2,4(r20)
8113c55c:	15bfbf1e 	bne	r2,r22,8113c45c <__reset+0xfb11c45c>
8113c560:	98800017 	ldw	r2,0(r19)
8113c564:	153fcf26 	beq	r2,r20,8113c4a4 <__reset+0xfb11c4a4>
8113c568:	003fbc06 	br	8113c45c <__reset+0xfb11c45c>
8113c56c:	183ee83a 	callr	r3
8113c570:	003ff906 	br	8113c558 <__reset+0xfb11c558>
8113c574:	a5c00115 	stw	r23,4(r20)
8113c578:	003feb06 	br	8113c528 <__reset+0xfb11c528>
8113c57c:	89000017 	ldw	r4,0(r17)
8113c580:	183ee83a 	callr	r3
8113c584:	003ff406 	br	8113c558 <__reset+0xfb11c558>
8113c588:	a0800017 	ldw	r2,0(r20)
8113c58c:	a027883a 	mov	r19,r20
8113c590:	1029883a 	mov	r20,r2
8113c594:	003fb606 	br	8113c470 <__reset+0xfb11c470>
8113c598:	0005883a 	mov	r2,zero
8113c59c:	003ffb06 	br	8113c58c <__reset+0xfb11c58c>

8113c5a0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8113c5a0:	defffd04 	addi	sp,sp,-12
8113c5a4:	de00012e 	bgeu	sp,et,8113c5ac <_exit+0xc>
8113c5a8:	003b68fa 	trap	3
8113c5ac:	df000215 	stw	fp,8(sp)
8113c5b0:	df000204 	addi	fp,sp,8
8113c5b4:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
8113c5b8:	d0207505 	stb	zero,-32300(gp)
8113c5bc:	e0bfff17 	ldw	r2,-4(fp)
8113c5c0:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8113c5c4:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
8113c5c8:	10000226 	beq	r2,zero,8113c5d4 <_exit+0x34>
    ALT_SIM_FAIL();
8113c5cc:	002af070 	cmpltui	zero,zero,43969
8113c5d0:	00000106 	br	8113c5d8 <_exit+0x38>
  } else {
    ALT_SIM_PASS();
8113c5d4:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
8113c5d8:	003fff06 	br	8113c5d8 <__reset+0xfb11c5d8>
